{"sha": "8dad14b5cd63203d7ad9d86686b3c654ff353c83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYWQxNGI1Y2Q2MzIwM2Q3YWQ5ZDg2Njg2YjNjNjU0ZmYzNTNjODM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-12T18:34:17Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-12T18:34:17Z"}, "message": "Convert Thunk to Task", "tree": {"sha": "f823b1423a9735bf4c776d750a25e7a02d136e0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f823b1423a9735bf4c776d750a25e7a02d136e0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dad14b5cd63203d7ad9d86686b3c654ff353c83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dad14b5cd63203d7ad9d86686b3c654ff353c83", "html_url": "https://github.com/rust-lang/rust/commit/8dad14b5cd63203d7ad9d86686b3c654ff353c83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dad14b5cd63203d7ad9d86686b3c654ff353c83/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23c06db9c236db0f9c8ef5117fb1adefd6616c43", "url": "https://api.github.com/repos/rust-lang/rust/commits/23c06db9c236db0f9c8ef5117fb1adefd6616c43", "html_url": "https://github.com/rust-lang/rust/commit/23c06db9c236db0f9c8ef5117fb1adefd6616c43"}], "stats": {"total": 156, "additions": 79, "deletions": 77}, "files": [{"sha": "369c56b64e4e3fce81985ad17d221b53976833e8", "filename": "crates/server/src/dispatch.rs", "status": "modified", "additions": 33, "deletions": 38, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8dad14b5cd63203d7ad9d86686b3c654ff353c83/crates%2Fserver%2Fsrc%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dad14b5cd63203d7ad9d86686b3c654ff353c83/crates%2Fserver%2Fsrc%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fdispatch.rs?ref=8dad14b5cd63203d7ad9d86686b3c654ff353c83", "patch": "@@ -19,38 +19,27 @@ pub struct Responder<R: ClientRequest> {\n     ph: PhantomData<fn(R)>,\n }\n \n-impl<R: ClientRequest> Responder<R>\n-{\n-    pub fn response(self, io: &mut Io, resp: Result<R::Result>) -> Result<()> {\n-        match resp {\n-            Ok(res) => self.result(io, res)?,\n-            Err(e) => {\n-                self.error(io)?;\n-                return Err(e);\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn result(mut self, io: &mut Io, result: R::Result) -> Result<()> {\n+impl<R: ClientRequest> Responder<R> {\n+    pub fn into_response(mut self, result: Result<R::Result>) -> Result<RawResponse> {\n         self.bomb.defuse();\n-        io.send(RawMsg::Response(RawResponse {\n-            id: Some(self.id),\n-            result: serde_json::to_value(result)?,\n-            error: serde_json::Value::Null,\n-        }));\n-        Ok(())\n-    }\n-\n-    pub fn error(mut self, io: &mut Io) -> Result<()> {\n-        self.bomb.defuse();\n-        error(io, self.id, ErrorCode::InternalError, \"internal error\")\n+        let res = match result {\n+            Ok(result) => {\n+                RawResponse {\n+                    id: Some(self.id),\n+                    result: serde_json::to_value(result)?,\n+                    error: serde_json::Value::Null,\n+                }\n+            }\n+            Err(_) => {\n+                error_response(self.id, ErrorCode::InternalError, \"internal error\")?\n+            }\n+        };\n+        Ok(res)\n     }\n }\n \n-\n fn parse_request_as<R: ClientRequest>(raw: RawRequest)\n-    -> Result<::std::result::Result<(R::Params, Responder<R>), RawRequest>>\n+                                      -> Result<::std::result::Result<(R::Params, Responder<R>), RawRequest>>\n {\n     if raw.method != R::METHOD {\n         return Ok(Err(raw));\n@@ -77,13 +66,13 @@ pub fn handle_request<R, F>(req: &mut Option<RawRequest>, f: F) -> Result<()>\n             Err(r) => {\n                 *req = Some(r);\n                 Ok(())\n-            },\n+            }\n         }\n     }\n }\n \n pub fn expect_request<R: ClientRequest>(io: &mut Io, raw: RawRequest)\n-    -> Result<Option<(R::Params, Responder<R>)>>\n+                                        -> Result<Option<(R::Params, Responder<R>)>>\n {\n     let ret = match parse_request_as::<R>(raw)? {\n         Ok(x) => Some(x),\n@@ -120,42 +109,48 @@ pub fn handle_notification<N, F>(not: &mut Option<RawNotification>, f: F) -> Res\n             Err(n) => {\n                 *not = Some(n);\n                 Ok(())\n-            },\n+            }\n         }\n     }\n }\n \n-pub fn send_notification<N>(io: &mut Io, params: N::Params) -> Result<()>\n+pub fn send_notification<N>(params: N::Params) -> RawNotification\n     where\n         N: Notification,\n         N::Params: Serialize\n {\n-    io.send(RawMsg::Notification(RawNotification {\n+    RawNotification {\n         method: N::METHOD.to_string(),\n-        params: serde_json::to_value(params)?,\n-    }));\n-    Ok(())\n+        params: serde_json::to_value(params)\n+            .unwrap(),\n+    }\n }\n \n \n pub fn unknown_method(io: &mut Io, raw: RawRequest) -> Result<()> {\n     error(io, raw.id, ErrorCode::MethodNotFound, \"unknown method\")\n }\n \n-fn error(io: &mut Io, id: u64, code: ErrorCode, message: &'static str) -> Result<()> {\n+fn error_response(id: u64, code: ErrorCode, message: &'static str) -> Result<RawResponse> {\n     #[derive(Serialize)]\n     struct Error {\n         code: i32,\n         message: &'static str,\n     }\n-    io.send(RawMsg::Response(RawResponse {\n+    let resp = RawResponse {\n         id: Some(id),\n         result: serde_json::Value::Null,\n         error: serde_json::to_value(Error {\n             code: code as i32,\n             message,\n         })?,\n-    }));\n+    };\n+    Ok(resp)\n+}\n+\n+fn error(io: &mut Io, id: u64, code: ErrorCode, message: &'static str) -> Result<()> {\n+    let resp = error_response(id, code, message)?;\n+    io.send(RawMsg::Response(resp));\n     Ok(())\n }\n "}, {"sha": "be63fea93b619ab2cd8911e18bc5ab666aa93ae6", "filename": "crates/server/src/main.rs", "status": "modified", "additions": 46, "deletions": 29, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/8dad14b5cd63203d7ad9d86686b3c654ff353c83/crates%2Fserver%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dad14b5cd63203d7ad9d86686b3c654ff353c83/crates%2Fserver%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain.rs?ref=8dad14b5cd63203d7ad9d86686b3c654ff353c83", "patch": "@@ -32,10 +32,10 @@ use languageserver_types::Url;\n use libanalysis::{WorldState, World};\n \n use ::{\n-    io::{Io, RawMsg, RawRequest},\n+    io::{Io, RawMsg, RawRequest, RawResponse, RawNotification},\n     handlers::{handle_syntax_tree, handle_extend_selection, publish_diagnostics, publish_decorations,\n                handle_document_symbol, handle_code_action},\n-    util::{FilePath, FnBox}\n+    util::FilePath,\n };\n \n pub type Result<T> = ::std::result::Result<T, ::failure::Error>;\n@@ -80,9 +80,9 @@ fn initialize(io: &mut Io) -> Result<()> {\n         match io.recv()? {\n             RawMsg::Request(req) => {\n                 if let Some((_params, resp)) = dispatch::expect_request::<req::Initialize>(io, req)? {\n-                    resp.result(io, req::InitializeResult {\n-                        capabilities: caps::SERVER_CAPABILITIES\n-                    })?;\n+                    let res = req::InitializeResult { capabilities: caps::SERVER_CAPABILITIES };\n+                    let resp = resp.into_response(Ok(res))?;\n+                    io.send(RawMsg::Response(resp));\n                     match io.recv()? {\n                         RawMsg::Notification(n) => {\n                             if n.method != \"initialized\" {\n@@ -106,13 +106,18 @@ fn initialize(io: &mut Io) -> Result<()> {\n     }\n }\n \n-type Thunk = Box<for<'a> FnBox<&'a mut Io, Result<()>>>;\n+\n+enum Task {\n+    Respond(RawResponse),\n+    Notify(RawNotification),\n+    Die(::failure::Error),\n+}\n \n fn initialized(io: &mut Io) -> Result<()> {\n     {\n         let mut world = WorldState::new();\n         let mut pool = ThreadPool::new(4);\n-        let (sender, receiver) = bounded::<Thunk>(16);\n+        let (sender, receiver) = bounded::<Task>(16);\n         info!(\"lifecycle: handshake finished, server ready to serve requests\");\n         let res = main_loop(io, &mut world, &mut pool, sender, receiver.clone());\n         info!(\"waiting for background jobs to finish...\");\n@@ -140,14 +145,14 @@ fn main_loop(\n     io: &mut Io,\n     world: &mut WorldState,\n     pool: &mut ThreadPool,\n-    sender: Sender<Thunk>,\n-    receiver: Receiver<Thunk>,\n+    sender: Sender<Task>,\n+    receiver: Receiver<Task>,\n ) -> Result<()> {\n     info!(\"server initialized, serving requests\");\n     loop {\n         enum Event {\n             Msg(RawMsg),\n-            Thunk(Thunk),\n+            Task(Task),\n             ReceiverDead,\n         }\n \n@@ -156,16 +161,23 @@ fn main_loop(\n                 Some(msg) => Event::Msg(msg),\n                 None => Event::ReceiverDead,\n             },\n-            recv(receiver, thunk) => Event::Thunk(thunk.unwrap()),\n+            recv(receiver, task) => Event::Task(task.unwrap()),\n         };\n \n         let msg = match event {\n             Event::ReceiverDead => {\n                 io.cleanup_receiver()?;\n                 unreachable!();\n             }\n-            Event::Thunk(thunk) => {\n-                thunk.call_box(io)?;\n+            Event::Task(task) => {\n+                match task {\n+                    Task::Respond(response) =>\n+                        io.send(RawMsg::Response(response)),\n+                    Task::Notify(n) =>\n+                        io.send(RawMsg::Notification(n)),\n+                    Task::Die(error) =>\n+                        return Err(error),\n+                }\n                 continue;\n             }\n             Event::Msg(msg) => msg,\n@@ -175,21 +187,22 @@ fn main_loop(\n             RawMsg::Request(req) => {\n                 let mut req = Some(req);\n                 handle_request_on_threadpool::<req::SyntaxTree>(\n-                    &mut req, pool, world, &sender, handle_syntax_tree\n+                    &mut req, pool, world, &sender, handle_syntax_tree,\n                 )?;\n                 handle_request_on_threadpool::<req::ExtendSelection>(\n-                    &mut req, pool, world, &sender, handle_extend_selection\n+                    &mut req, pool, world, &sender, handle_extend_selection,\n                 )?;\n                 handle_request_on_threadpool::<req::DocumentSymbolRequest>(\n-                    &mut req, pool, world, &sender, handle_document_symbol\n+                    &mut req, pool, world, &sender, handle_document_symbol,\n                 )?;\n                 handle_request_on_threadpool::<req::CodeActionRequest>(\n-                    &mut req, pool, world, &sender, handle_code_action\n+                    &mut req, pool, world, &sender, handle_code_action,\n                 )?;\n \n                 let mut shutdown = false;\n                 dispatch::handle_request::<req::Shutdown, _>(&mut req, |(), resp| {\n-                    resp.result(io, ())?;\n+                    let resp = resp.into_response(Ok(()))?;\n+                    io.send(RawMsg::Response(resp));\n                     shutdown = true;\n                     Ok(())\n                 })?;\n@@ -227,10 +240,12 @@ fn main_loop(\n                 dispatch::handle_notification::<req::DidCloseTextDocument, _>(&mut not, |params| {\n                     let path = params.text_document.file_path()?;\n                     world.change_overlay(path, None);\n-                    dispatch::send_notification::<req::PublishDiagnostics>(io, req::PublishDiagnosticsParams {\n+                    let not = req::PublishDiagnosticsParams {\n                         uri: params.text_document.uri,\n                         diagnostics: Vec::new(),\n-                    })?;\n+                    };\n+                    let not = dispatch::send_notification::<req::PublishDiagnostics>(not);\n+                    io.send(RawMsg::Notification(not));\n                     Ok(())\n                 })?;\n \n@@ -249,7 +264,7 @@ fn handle_request_on_threadpool<R: req::ClientRequest>(\n     req: &mut Option<RawRequest>,\n     pool: &ThreadPool,\n     world: &WorldState,\n-    sender: &Sender<Thunk>,\n+    sender: &Sender<Task>,\n     f: fn(World, R::Params) -> Result<R::Result>,\n ) -> Result<()>\n {\n@@ -258,7 +273,11 @@ fn handle_request_on_threadpool<R: req::ClientRequest>(\n         let sender = sender.clone();\n         pool.execute(move || {\n             let res = f(world, params);\n-            sender.send(Box::new(|io: &mut Io| resp.response(io, res)))\n+            let task = match resp.into_response(res) {\n+                Ok(resp) => Task::Respond(resp),\n+                Err(e) => Task::Die(e),\n+            };\n+            sender.send(task);\n         });\n         Ok(())\n     })\n@@ -267,7 +286,7 @@ fn handle_request_on_threadpool<R: req::ClientRequest>(\n fn update_file_notifications_on_threadpool(\n     pool: &ThreadPool,\n     world: World,\n-    sender: Sender<Thunk>,\n+    sender: Sender<Task>,\n     uri: Url,\n ) {\n     pool.execute(move || {\n@@ -276,19 +295,17 @@ fn update_file_notifications_on_threadpool(\n                 error!(\"failed to compute diagnostics: {:?}\", e)\n             }\n             Ok(params) => {\n-                sender.send(Box::new(|io: &mut Io| {\n-                    dispatch::send_notification::<req::PublishDiagnostics>(io, params)\n-                }))\n+                let not = dispatch::send_notification::<req::PublishDiagnostics>(params);\n+                sender.send(Task::Notify(not));\n             }\n         }\n         match publish_decorations(world, uri) {\n             Err(e) => {\n                 error!(\"failed to compute decortions: {:?}\", e)\n             }\n             Ok(params) => {\n-                sender.send(Box::new(|io: &mut Io| {\n-                    dispatch::send_notification::<req::PublishDecorations>(io, params)\n-                }))\n+                let not = dispatch::send_notification::<req::PublishDecorations>(params);\n+                sender.send(Task::Notify(not))\n             }\n         }\n     });"}, {"sha": "6747c20a8950369425798c6d5c49c7fa31a32edc", "filename": "crates/server/src/util.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8dad14b5cd63203d7ad9d86686b3c654ff353c83/crates%2Fserver%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dad14b5cd63203d7ad9d86686b3c654ff353c83/crates%2Fserver%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Futil.rs?ref=8dad14b5cd63203d7ad9d86686b3c654ff353c83", "patch": "@@ -3,16 +3,6 @@ use languageserver_types::{TextDocumentItem, VersionedTextDocumentIdentifier,\n                            TextDocumentIdentifier, Url};\n use ::{Result};\n \n-pub trait FnBox<A, R>: Send {\n-    fn call_box(self: Box<Self>, a: A) -> R;\n-}\n-\n-impl<A, R, F: FnOnce(A) -> R + Send> FnBox<A, R> for F {\n-    fn call_box(self: Box<F>, a: A) -> R {\n-        (*self)(a)\n-    }\n-}\n-\n pub trait FilePath {\n     fn file_path(&self) -> Result<PathBuf>;\n }"}]}