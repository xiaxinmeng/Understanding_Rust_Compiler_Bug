{"sha": "7cfddfb4e40584dc206cedef7c70b5fecb03d6a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjZmRkZmI0ZTQwNTg0ZGMyMDZjZWRlZjdjNzBiNWZlY2IwM2Q2YTE=", "commit": {"author": {"name": "Ho\u00e0ng \u0110\u1ee9c Hi\u1ebfu", "email": "hdhoang@hdhoang.space", "date": "2018-12-16T08:50:49Z"}, "committer": {"name": "Ho\u00e0ng \u0110\u1ee9c Hi\u1ebfu", "email": "code@hdhoang.space", "date": "2019-02-23T00:58:16Z"}, "message": "Improve parsing diagnostic for negative supertrait bounds", "tree": {"sha": "0d00c94a1b9b80b6b24ad3380b07e42227623df5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d00c94a1b9b80b6b24ad3380b07e42227623df5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cfddfb4e40584dc206cedef7c70b5fecb03d6a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cfddfb4e40584dc206cedef7c70b5fecb03d6a1", "html_url": "https://github.com/rust-lang/rust/commit/7cfddfb4e40584dc206cedef7c70b5fecb03d6a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cfddfb4e40584dc206cedef7c70b5fecb03d6a1/comments", "author": {"login": "hdhoang", "id": 12537, "node_id": "MDQ6VXNlcjEyNTM3", "avatar_url": "https://avatars.githubusercontent.com/u/12537?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hdhoang", "html_url": "https://github.com/hdhoang", "followers_url": "https://api.github.com/users/hdhoang/followers", "following_url": "https://api.github.com/users/hdhoang/following{/other_user}", "gists_url": "https://api.github.com/users/hdhoang/gists{/gist_id}", "starred_url": "https://api.github.com/users/hdhoang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hdhoang/subscriptions", "organizations_url": "https://api.github.com/users/hdhoang/orgs", "repos_url": "https://api.github.com/users/hdhoang/repos", "events_url": "https://api.github.com/users/hdhoang/events{/privacy}", "received_events_url": "https://api.github.com/users/hdhoang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hdhoang", "id": 12537, "node_id": "MDQ6VXNlcjEyNTM3", "avatar_url": "https://avatars.githubusercontent.com/u/12537?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hdhoang", "html_url": "https://github.com/hdhoang", "followers_url": "https://api.github.com/users/hdhoang/followers", "following_url": "https://api.github.com/users/hdhoang/following{/other_user}", "gists_url": "https://api.github.com/users/hdhoang/gists{/gist_id}", "starred_url": "https://api.github.com/users/hdhoang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hdhoang/subscriptions", "organizations_url": "https://api.github.com/users/hdhoang/orgs", "repos_url": "https://api.github.com/users/hdhoang/repos", "events_url": "https://api.github.com/users/hdhoang/events{/privacy}", "received_events_url": "https://api.github.com/users/hdhoang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "082c86175fcf72c355e6a889956fbea59e65bcdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/082c86175fcf72c355e6a889956fbea59e65bcdb", "html_url": "https://github.com/rust-lang/rust/commit/082c86175fcf72c355e6a889956fbea59e65bcdb"}], "stats": {"total": 152, "additions": 131, "deletions": 21}, "files": [{"sha": "5c2b02067d994403bca92e27fcf53be2925e3119", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 59, "deletions": 21, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7cfddfb4e40584dc206cedef7c70b5fecb03d6a1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cfddfb4e40584dc206cedef7c70b5fecb03d6a1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7cfddfb4e40584dc206cedef7c70b5fecb03d6a1", "patch": "@@ -1731,7 +1731,7 @@ impl<'a> Parser<'a> {\n             }\n         } else if self.eat_keyword(keywords::Impl) {\n             // Always parse bounds greedily for better error recovery.\n-            let bounds = self.parse_generic_bounds()?;\n+            let bounds = self.parse_generic_bounds(None)?;\n             impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n             TyKind::ImplTrait(ast::DUMMY_NODE_ID, bounds)\n         } else if self.check_keyword(keywords::Dyn) &&\n@@ -1740,13 +1740,13 @@ impl<'a> Parser<'a> {\n                                           !can_continue_type_after_non_fn_ident(t))) {\n             self.bump(); // `dyn`\n             // Always parse bounds greedily for better error recovery.\n-            let bounds = self.parse_generic_bounds()?;\n+            let bounds = self.parse_generic_bounds(None)?;\n             impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n             TyKind::TraitObject(bounds, TraitObjectSyntax::Dyn)\n         } else if self.check(&token::Question) ||\n                   self.check_lifetime() && self.look_ahead(1, |t| t.is_like_plus()) {\n             // Bound list (trait object type)\n-            TyKind::TraitObject(self.parse_generic_bounds_common(allow_plus)?,\n+            TyKind::TraitObject(self.parse_generic_bounds_common(allow_plus, None)?,\n                                 TraitObjectSyntax::None)\n         } else if self.eat_lt() {\n             // Qualified path\n@@ -1792,7 +1792,7 @@ impl<'a> Parser<'a> {\n         let mut bounds = vec![GenericBound::Trait(poly_trait_ref, TraitBoundModifier::None)];\n         if parse_plus {\n             self.eat_plus(); // `+`, or `+=` gets split and `+` is discarded\n-            bounds.append(&mut self.parse_generic_bounds()?);\n+            bounds.append(&mut self.parse_generic_bounds(None)?);\n         }\n         Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::None))\n     }\n@@ -1817,7 +1817,7 @@ impl<'a> Parser<'a> {\n         }\n \n         self.bump(); // `+`\n-        let bounds = self.parse_generic_bounds()?;\n+        let bounds = self.parse_generic_bounds(None)?;\n         let sum_span = ty.span.to(self.prev_span);\n \n         let mut err = struct_span_err!(self.sess.span_diagnostic, sum_span, E0178,\n@@ -5492,18 +5492,24 @@ impl<'a> Parser<'a> {\n     /// TY_BOUND = TY_BOUND_NOPAREN | (TY_BOUND_NOPAREN)\n     /// TY_BOUND_NOPAREN = [?] [for<LT_PARAM_DEFS>] SIMPLE_PATH (e.g., `?for<'a: 'b> m::Trait<'a>`)\n     /// ```\n-    fn parse_generic_bounds_common(&mut self, allow_plus: bool) -> PResult<'a, GenericBounds> {\n+    fn parse_generic_bounds_common(&mut self,\n+                                   allow_plus: bool,\n+                                   colon_span: Option<Span>) -> PResult<'a, GenericBounds> {\n         let mut bounds = Vec::new();\n+        let mut negative_bounds = Vec::new();\n+        let mut last_plus_span = None;\n         loop {\n             // This needs to be synchronized with `Token::can_begin_bound`.\n             let is_bound_start = self.check_path() || self.check_lifetime() ||\n+                                 self.check(&token::Not) || // used for error reporting only\n                                  self.check(&token::Question) ||\n                                  self.check_keyword(keywords::For) ||\n                                  self.check(&token::OpenDelim(token::Paren));\n             if is_bound_start {\n                 let lo = self.span;\n                 let has_parens = self.eat(&token::OpenDelim(token::Paren));\n                 let inner_lo = self.span;\n+                let is_negative = self.eat(&token::Not);\n                 let question = if self.eat(&token::Question) { Some(self.prev_span) } else { None };\n                 if self.token.is_lifetime() {\n                     if let Some(question_span) = question {\n@@ -5534,28 +5540,60 @@ impl<'a> Parser<'a> {\n                     if has_parens {\n                         self.expect(&token::CloseDelim(token::Paren))?;\n                     }\n-                    let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n-                    let modifier = if question.is_some() {\n-                        TraitBoundModifier::Maybe\n+                    let poly_span = lo.to(self.prev_span);\n+                    if is_negative {\n+                        negative_bounds.push(\n+                            last_plus_span.or(colon_span).unwrap()\n+                                .to(poly_span));\n                     } else {\n-                        TraitBoundModifier::None\n-                    };\n-                    bounds.push(GenericBound::Trait(poly_trait, modifier));\n+                        let poly_trait = PolyTraitRef::new(lifetime_defs, path, poly_span);\n+                        let modifier = if question.is_some() {\n+                            TraitBoundModifier::Maybe\n+                        } else {\n+                            TraitBoundModifier::None\n+                        };\n+                        bounds.push(GenericBound::Trait(poly_trait, modifier));\n+                    }\n                 }\n             } else {\n                 break\n             }\n \n             if !allow_plus || !self.eat_plus() {\n                 break\n-            }\n+            } else {\n+                last_plus_span = Some(self.prev_span);\n+            }\n+        }\n+\n+        if !negative_bounds.is_empty() {\n+            let plural = negative_bounds.len() > 1;\n+            let mut err = self.struct_span_err(negative_bounds,\n+                                               \"negative trait bounds are not supported\");\n+            let bound_list = colon_span.unwrap().to(self.prev_span);\n+            let mut new_bound_list = String::new();\n+            if !bounds.is_empty() {\n+                let mut snippets = bounds.iter().map(|bound| bound.span())\n+                    .map(|span| self.sess.source_map().span_to_snippet(span));\n+                while let Some(Ok(snippet)) = snippets.next() {\n+                    new_bound_list.push_str(\" + \");\n+                    new_bound_list.push_str(&snippet);\n+                }\n+                new_bound_list = new_bound_list.replacen(\" +\", \":\", 1);\n+            }\n+            err.span_suggestion_short(bound_list,\n+                                      &format!(\"remove the trait bound{}\",\n+                                              if plural { \"s\" } else { \"\" }),\n+                                      new_bound_list,\n+                                      Applicability::MachineApplicable);\n+            err.emit();\n         }\n \n         return Ok(bounds);\n     }\n \n-    fn parse_generic_bounds(&mut self) -> PResult<'a, GenericBounds> {\n-        self.parse_generic_bounds_common(true)\n+    fn parse_generic_bounds(&mut self, colon_span: Option<Span>) -> PResult<'a, GenericBounds> {\n+        self.parse_generic_bounds_common(true, colon_span)\n     }\n \n     /// Parses bounds of a lifetime parameter `BOUND + BOUND + BOUND`, possibly with trailing `+`.\n@@ -5583,7 +5621,7 @@ impl<'a> Parser<'a> {\n \n         // Parse optional colon and param bounds.\n         let bounds = if self.eat(&token::Colon) {\n-            self.parse_generic_bounds()?\n+            self.parse_generic_bounds(None)?\n         } else {\n             Vec::new()\n         };\n@@ -5615,7 +5653,7 @@ impl<'a> Parser<'a> {\n \n         // Parse optional colon and param bounds.\n         let bounds = if self.eat(&token::Colon) {\n-            self.parse_generic_bounds()?\n+            self.parse_generic_bounds(None)?\n         } else {\n             Vec::new()\n         };\n@@ -6028,7 +6066,7 @@ impl<'a> Parser<'a> {\n                 // or with mandatory equality sign and the second type.\n                 let ty = self.parse_ty()?;\n                 if self.eat(&token::Colon) {\n-                    let bounds = self.parse_generic_bounds()?;\n+                    let bounds = self.parse_generic_bounds(None)?;\n                     where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n                         ast::WhereBoundPredicate {\n                             span: lo.to(self.prev_span),\n@@ -6542,14 +6580,14 @@ impl<'a> Parser<'a> {\n \n         // Parse optional colon and supertrait bounds.\n         let bounds = if self.eat(&token::Colon) {\n-            self.parse_generic_bounds()?\n+            self.parse_generic_bounds(Some(self.prev_span))?\n         } else {\n             Vec::new()\n         };\n \n         if self.eat(&token::Eq) {\n             // it's a trait alias\n-            let bounds = self.parse_generic_bounds()?;\n+            let bounds = self.parse_generic_bounds(None)?;\n             tps.where_clause = self.parse_where_clause()?;\n             self.expect(&token::Semi)?;\n             if is_auto == IsAuto::Yes {\n@@ -7584,7 +7622,7 @@ impl<'a> Parser<'a> {\n         tps.where_clause = self.parse_where_clause()?;\n         let alias = if existential {\n             self.expect(&token::Colon)?;\n-            let bounds = self.parse_generic_bounds()?;\n+            let bounds = self.parse_generic_bounds(None)?;\n             AliasKind::Existential(bounds)\n         } else {\n             self.expect(&token::Eq)?;"}, {"sha": "df11f2d855ce0115bf16a7be7cadb88869837de1", "filename": "src/test/ui/parser/issue-33418.fixed", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7cfddfb4e40584dc206cedef7c70b5fecb03d6a1/src%2Ftest%2Fui%2Fparser%2Fissue-33418.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cfddfb4e40584dc206cedef7c70b5fecb03d6a1/src%2Ftest%2Fui%2Fparser%2Fissue-33418.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-33418.fixed?ref=7cfddfb4e40584dc206cedef7c70b5fecb03d6a1", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+\n+trait Tr {} //~ ERROR negative trait bounds are not supported\n+trait Tr2: SuperA {} //~ ERROR negative trait bounds are not supported\n+trait Tr3: SuperB {} //~ ERROR negative trait bounds are not supported\n+trait Tr4: SuperB + SuperD {}\n+trait Tr5 {}\n+\n+trait SuperA {}\n+trait SuperB {}\n+trait SuperC {}\n+trait SuperD {}\n+\n+fn main() {}"}, {"sha": "5bb5f2afca377188105ed00011294633bda41c81", "filename": "src/test/ui/parser/issue-33418.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7cfddfb4e40584dc206cedef7c70b5fecb03d6a1/src%2Ftest%2Fui%2Fparser%2Fissue-33418.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cfddfb4e40584dc206cedef7c70b5fecb03d6a1/src%2Ftest%2Fui%2Fparser%2Fissue-33418.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-33418.rs?ref=7cfddfb4e40584dc206cedef7c70b5fecb03d6a1", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+\n+trait Tr: !SuperA {} //~ ERROR negative trait bounds are not supported\n+trait Tr2: SuperA + !SuperB {} //~ ERROR negative trait bounds are not supported\n+trait Tr3: !SuperA + SuperB {} //~ ERROR negative trait bounds are not supported\n+trait Tr4: !SuperA + SuperB //~ ERROR negative trait bounds are not supported\n+    + !SuperC + SuperD {}\n+trait Tr5: !SuperA //~ ERROR negative trait bounds are not supported\n+    + !SuperB {}\n+\n+trait SuperA {}\n+trait SuperB {}\n+trait SuperC {}\n+trait SuperD {}\n+\n+fn main() {}"}, {"sha": "bfe44588a5b0b08d858c4db271f3961c4f09fafc", "filename": "src/test/ui/parser/issue-33418.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7cfddfb4e40584dc206cedef7c70b5fecb03d6a1/src%2Ftest%2Fui%2Fparser%2Fissue-33418.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cfddfb4e40584dc206cedef7c70b5fecb03d6a1/src%2Ftest%2Fui%2Fparser%2Fissue-33418.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-33418.stderr?ref=7cfddfb4e40584dc206cedef7c70b5fecb03d6a1", "patch": "@@ -0,0 +1,42 @@\n+error: negative trait bounds are not supported\n+  --> $DIR/issue-33418.rs:3:9\n+   |\n+LL | trait Tr: !SuperA {} //~ ERROR negative trait bounds are not supported\n+   |         ^^^^^^^^^ help: remove the trait bound\n+\n+error: negative trait bounds are not supported\n+  --> $DIR/issue-33418.rs:4:19\n+   |\n+LL | trait Tr2: SuperA + !SuperB {} //~ ERROR negative trait bounds are not supported\n+   |          ---------^^^^^^^^^\n+   |          |\n+   |          help: remove the trait bound\n+\n+error: negative trait bounds are not supported\n+  --> $DIR/issue-33418.rs:5:10\n+   |\n+LL | trait Tr3: !SuperA + SuperB {} //~ ERROR negative trait bounds are not supported\n+   |          ^^^^^^^^^---------\n+   |          |\n+   |          help: remove the trait bound\n+\n+error: negative trait bounds are not supported\n+  --> $DIR/issue-33418.rs:6:10\n+   |\n+LL |   trait Tr4: !SuperA + SuperB //~ ERROR negative trait bounds are not supported\n+   |  __________-^^^^^^^^\n+LL | |     + !SuperC + SuperD {}\n+   | |_____^^^^^^^^^________- help: remove the trait bounds\n+\n+error: negative trait bounds are not supported\n+  --> $DIR/issue-33418.rs:8:10\n+   |\n+LL |   trait Tr5: !SuperA //~ ERROR negative trait bounds are not supported\n+   |  __________-^^^^^^^^\n+LL | |     + !SuperB {}\n+   | |     ^^^^^^^^-\n+   | |_____________|\n+   |               help: remove the trait bounds\n+\n+error: aborting due to 5 previous errors\n+"}]}