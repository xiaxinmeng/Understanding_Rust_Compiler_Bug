{"sha": "9042009b7f1ba0f85e892ac5184fa4542d0c10f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwNDIwMDliN2YxYmEwZjg1ZTg5MmFjNTE4NGZhNDU0MmQwYzEwZjU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-30T11:36:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-30T11:36:50Z"}, "message": "Merge #5567\n\n5567: SSR: Wrap placeholder expansions in parenthesis when necessary r=matklad a=davidlattimore\n\ne.g. `foo($a) ==> $a.to_string()` should produce `(1 + 2).to_string()` not `1 + 2.to_string()`\r\n\r\nWe don't yet try to determine if the whole replacement needs to be wrapped in parenthesis. That's harder and I think perhaps less often an issue.\n\nCo-authored-by: David Lattimore <dml@google.com>", "tree": {"sha": "b56e925c4f822f5479350883c87b952300995fc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b56e925c4f822f5479350883c87b952300995fc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9042009b7f1ba0f85e892ac5184fa4542d0c10f5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfIrDSCRBK7hj4Ov3rIwAAdHIIAFxFQLFNxb/xYzfcl+1dpoIW\nI7XwkklWrNvVfSDmbMLZJpgY7HaonIJKQdRvg9aSwAI53EOWQBWkPwkJU95Xcuwy\nSeN+WIEttm44Sc5SrEY9QUctBlc7v7N3rpnRjqDnril683s6RRmSOKLytHE9F1+l\nG8ItHrxtL/NJC4Skh+jQK/LMSGN4P7UO5aslMf8ivCptP3iKu24poXceEgBI5JlK\n+aWAhWG+EDC6XEnCY+z4qY5Sh4Ftiu0igXC4tXN7dksZo+IITbOI2BLM7ROSAYIN\nVSXGtm6iR8JgL9Nzipjf4lmK0OGbG/E7+95jm1zrgTZvUZEpGJm2FDHkhaqxVfo=\n=QQtZ\n-----END PGP SIGNATURE-----\n", "payload": "tree b56e925c4f822f5479350883c87b952300995fc6\nparent be803efb7c7ba257716fcc97c57ecfd07e278b07\nparent fa1e4113224c119258670538f8c3ca6c8ea8ad1e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1596109010 +0000\ncommitter GitHub <noreply@github.com> 1596109010 +0000\n\nMerge #5567\n\n5567: SSR: Wrap placeholder expansions in parenthesis when necessary r=matklad a=davidlattimore\n\ne.g. `foo($a) ==> $a.to_string()` should produce `(1 + 2).to_string()` not `1 + 2.to_string()`\r\n\r\nWe don't yet try to determine if the whole replacement needs to be wrapped in parenthesis. That's harder and I think perhaps less often an issue.\n\nCo-authored-by: David Lattimore <dml@google.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9042009b7f1ba0f85e892ac5184fa4542d0c10f5", "html_url": "https://github.com/rust-lang/rust/commit/9042009b7f1ba0f85e892ac5184fa4542d0c10f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9042009b7f1ba0f85e892ac5184fa4542d0c10f5/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be803efb7c7ba257716fcc97c57ecfd07e278b07", "url": "https://api.github.com/repos/rust-lang/rust/commits/be803efb7c7ba257716fcc97c57ecfd07e278b07", "html_url": "https://github.com/rust-lang/rust/commit/be803efb7c7ba257716fcc97c57ecfd07e278b07"}, {"sha": "fa1e4113224c119258670538f8c3ca6c8ea8ad1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa1e4113224c119258670538f8c3ca6c8ea8ad1e", "html_url": "https://github.com/rust-lang/rust/commit/fa1e4113224c119258670538f8c3ca6c8ea8ad1e"}], "stats": {"total": 131, "additions": 111, "deletions": 20}, "files": [{"sha": "0943244ff9f2a909c2fc37c0cfd396f03fcc80ca", "filename": "crates/ra_ssr/src/replacing.rs", "status": "modified", "additions": 88, "deletions": 18, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/9042009b7f1ba0f85e892ac5184fa4542d0c10f5/crates%2Fra_ssr%2Fsrc%2Freplacing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9042009b7f1ba0f85e892ac5184fa4542d0c10f5/crates%2Fra_ssr%2Fsrc%2Freplacing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Freplacing.rs?ref=9042009b7f1ba0f85e892ac5184fa4542d0c10f5", "patch": "@@ -3,8 +3,9 @@\n use crate::matching::Var;\n use crate::{resolving::ResolvedRule, Match, SsrMatches};\n use ra_syntax::ast::{self, AstToken};\n-use ra_syntax::{SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextSize};\n+use ra_syntax::{SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextSize};\n use ra_text_edit::TextEdit;\n+use rustc_hash::{FxHashMap, FxHashSet};\n \n /// Returns a text edit that will replace each match in `matches` with its corresponding replacement\n /// template. Placeholders in the template will have been substituted with whatever they matched to\n@@ -38,62 +39,79 @@ struct ReplacementRenderer<'a> {\n     file_src: &'a str,\n     rules: &'a [ResolvedRule],\n     rule: &'a ResolvedRule,\n+    out: String,\n+    // Map from a range within `out` to a token in `template` that represents a placeholder. This is\n+    // used to validate that the generated source code doesn't split any placeholder expansions (see\n+    // below).\n+    placeholder_tokens_by_range: FxHashMap<TextRange, SyntaxToken>,\n+    // Which placeholder tokens need to be wrapped in parenthesis in order to ensure that when `out`\n+    // is parsed, placeholders don't get split. e.g. if a template of `$a.to_string()` results in `1\n+    // + 2.to_string()` then the placeholder value `1 + 2` was split and needs parenthesis.\n+    placeholder_tokens_requiring_parenthesis: FxHashSet<SyntaxToken>,\n }\n \n fn render_replace(match_info: &Match, file_src: &str, rules: &[ResolvedRule]) -> String {\n-    let mut out = String::new();\n     let rule = &rules[match_info.rule_index];\n     let template = rule\n         .template\n         .as_ref()\n         .expect(\"You called MatchFinder::edits after calling MatchFinder::add_search_pattern\");\n-    let renderer = ReplacementRenderer { match_info, file_src, rules, rule };\n-    renderer.render_node(&template.node, &mut out);\n+    let mut renderer = ReplacementRenderer {\n+        match_info,\n+        file_src,\n+        rules,\n+        rule,\n+        out: String::new(),\n+        placeholder_tokens_requiring_parenthesis: FxHashSet::default(),\n+        placeholder_tokens_by_range: FxHashMap::default(),\n+    };\n+    renderer.render_node(&template.node);\n+    renderer.maybe_rerender_with_extra_parenthesis(&template.node);\n     for comment in &match_info.ignored_comments {\n-        out.push_str(&comment.syntax().to_string());\n+        renderer.out.push_str(&comment.syntax().to_string());\n     }\n-    out\n+    renderer.out\n }\n \n impl ReplacementRenderer<'_> {\n-    fn render_node_children(&self, node: &SyntaxNode, out: &mut String) {\n+    fn render_node_children(&mut self, node: &SyntaxNode) {\n         for node_or_token in node.children_with_tokens() {\n-            self.render_node_or_token(&node_or_token, out);\n+            self.render_node_or_token(&node_or_token);\n         }\n     }\n \n-    fn render_node_or_token(&self, node_or_token: &SyntaxElement, out: &mut String) {\n+    fn render_node_or_token(&mut self, node_or_token: &SyntaxElement) {\n         match node_or_token {\n             SyntaxElement::Token(token) => {\n-                self.render_token(&token, out);\n+                self.render_token(&token);\n             }\n             SyntaxElement::Node(child_node) => {\n-                self.render_node(&child_node, out);\n+                self.render_node(&child_node);\n             }\n         }\n     }\n \n-    fn render_node(&self, node: &SyntaxNode, out: &mut String) {\n+    fn render_node(&mut self, node: &SyntaxNode) {\n         use ra_syntax::ast::AstNode;\n         if let Some(mod_path) = self.match_info.rendered_template_paths.get(&node) {\n-            out.push_str(&mod_path.to_string());\n+            self.out.push_str(&mod_path.to_string());\n             // Emit everything except for the segment's name-ref, since we already effectively\n             // emitted that as part of `mod_path`.\n             if let Some(path) = ast::Path::cast(node.clone()) {\n                 if let Some(segment) = path.segment() {\n                     for node_or_token in segment.syntax().children_with_tokens() {\n                         if node_or_token.kind() != SyntaxKind::NAME_REF {\n-                            self.render_node_or_token(&node_or_token, out);\n+                            self.render_node_or_token(&node_or_token);\n                         }\n                     }\n                 }\n             }\n         } else {\n-            self.render_node_children(&node, out);\n+            self.render_node_children(&node);\n         }\n     }\n \n-    fn render_token(&self, token: &SyntaxToken, out: &mut String) {\n+    fn render_token(&mut self, token: &SyntaxToken) {\n         if let Some(placeholder) = self.rule.get_placeholder(&token) {\n             if let Some(placeholder_value) =\n                 self.match_info.placeholder_values.get(&Var(placeholder.ident.to_string()))\n@@ -107,8 +125,23 @@ impl ReplacementRenderer<'_> {\n                     range.start(),\n                     self.rules,\n                 );\n+                let needs_parenthesis =\n+                    self.placeholder_tokens_requiring_parenthesis.contains(token);\n                 edit.apply(&mut matched_text);\n-                out.push_str(&matched_text);\n+                if needs_parenthesis {\n+                    self.out.push('(');\n+                }\n+                self.placeholder_tokens_by_range.insert(\n+                    TextRange::new(\n+                        TextSize::of(&self.out),\n+                        TextSize::of(&self.out) + TextSize::of(&matched_text),\n+                    ),\n+                    token.clone(),\n+                );\n+                self.out.push_str(&matched_text);\n+                if needs_parenthesis {\n+                    self.out.push(')');\n+                }\n             } else {\n                 // We validated that all placeholder references were valid before we\n                 // started, so this shouldn't happen.\n@@ -118,7 +151,44 @@ impl ReplacementRenderer<'_> {\n                 );\n             }\n         } else {\n-            out.push_str(token.text().as_str());\n+            self.out.push_str(token.text().as_str());\n+        }\n+    }\n+\n+    // Checks if the resulting code, when parsed doesn't split any placeholders due to different\n+    // order of operations between the search pattern and the replacement template. If any do, then\n+    // we rerender the template and wrap the problematic placeholders with parenthesis.\n+    fn maybe_rerender_with_extra_parenthesis(&mut self, template: &SyntaxNode) {\n+        if let Some(node) = parse_as_kind(&self.out, template.kind()) {\n+            self.remove_node_ranges(node);\n+            if self.placeholder_tokens_by_range.is_empty() {\n+                return;\n+            }\n+            self.placeholder_tokens_requiring_parenthesis =\n+                self.placeholder_tokens_by_range.values().cloned().collect();\n+            self.out.clear();\n+            self.render_node(template);\n+        }\n+    }\n+\n+    fn remove_node_ranges(&mut self, node: SyntaxNode) {\n+        self.placeholder_tokens_by_range.remove(&node.text_range());\n+        for child in node.children() {\n+            self.remove_node_ranges(child);\n+        }\n+    }\n+}\n+\n+fn parse_as_kind(code: &str, kind: SyntaxKind) -> Option<SyntaxNode> {\n+    use ra_syntax::ast::AstNode;\n+    if ast::Expr::can_cast(kind) {\n+        if let Ok(expr) = ast::Expr::parse(code) {\n+            return Some(expr.syntax().clone());\n+        }\n+    } else if ast::Item::can_cast(kind) {\n+        if let Ok(item) = ast::Item::parse(code) {\n+            return Some(item.syntax().clone());\n         }\n     }\n+    None\n }"}, {"sha": "a4fa2cb4470855d50fc8ad55475bd84d3df849ae", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9042009b7f1ba0f85e892ac5184fa4542d0c10f5/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9042009b7f1ba0f85e892ac5184fa4542d0c10f5/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=9042009b7f1ba0f85e892ac5184fa4542d0c10f5", "patch": "@@ -664,7 +664,7 @@ fn replace_binary_op() {\n     assert_ssr_transform(\n         \"$a + $b ==>> $b + $a\",\n         \"fn f() {1 + 2 + 3 + 4}\",\n-        expect![[\"fn f() {4 + 3 + 2 + 1}\"]],\n+        expect![[r#\"fn f() {4 + (3 + (2 + 1))}\"#]],\n     );\n }\n \n@@ -773,11 +773,32 @@ fn preserves_whitespace_within_macro_expansion() {\n             macro_rules! macro1 {\n                 ($a:expr) => {$a}\n             }\n-            fn f() {macro1!(4 - 3 - 1   *   2}\n+            fn f() {macro1!(4 - (3 - 1   *   2)}\n             \"#]],\n     )\n }\n \n+#[test]\n+fn add_parenthesis_when_necessary() {\n+    assert_ssr_transform(\n+        \"foo($a) ==>> $a.to_string()\",\n+        r#\"\n+        fn foo(_: i32) {}\n+        fn bar3(v: i32) {\n+            foo(1 + 2);\n+            foo(-v);\n+        }\n+        \"#,\n+        expect![[r#\"\n+            fn foo(_: i32) {}\n+            fn bar3(v: i32) {\n+                (1 + 2).to_string();\n+                (-v).to_string();\n+            }\n+        \"#]],\n+    )\n+}\n+\n #[test]\n fn match_failure_reasons() {\n     let code = r#\""}]}