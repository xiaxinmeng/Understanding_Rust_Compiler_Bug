{"sha": "2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4MzVjYTY1ODQ1YzVmYWM4ZGEyYTI2MTJhMDZiMTJhZDJmNGM3N2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-20T15:58:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-20T15:58:34Z"}, "message": "Auto merge of #70174 - JohnTitor:rollup-0lum0jh, r=JohnTitor\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #69618 (Clarify the relationship between `forget()` and `ManuallyDrop`.)\n - #69768 (Compute the correct layout for variants of uninhabited enums)\n - #69935 (codegen/mir: support polymorphic `InstanceDef`s)\n - #70103 (Clean up E0437 explanation)\n - #70131 (Add regression test for TAIT lifetime inference (issue #55099))\n - #70133 (remove unused imports)\n - #70145 (doc: Add quote to .init_array)\n - #70146 (Clean up e0438 explanation)\n - #70150 (triagebot.toml: accept cleanup-crew)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "cea22dab1002cfa28d197895ba3958c75d6a1186", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cea22dab1002cfa28d197895ba3958c75d6a1186"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "html_url": "https://github.com/rust-lang/rust/commit/2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4c675c476c18b1a11041193f2f59d695b126bc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4c675c476c18b1a11041193f2f59d695b126bc8", "html_url": "https://github.com/rust-lang/rust/commit/f4c675c476c18b1a11041193f2f59d695b126bc8"}, {"sha": "43c7a503fe7073c83a92b65c59de8cb820cf3b97", "url": "https://api.github.com/repos/rust-lang/rust/commits/43c7a503fe7073c83a92b65c59de8cb820cf3b97", "html_url": "https://github.com/rust-lang/rust/commit/43c7a503fe7073c83a92b65c59de8cb820cf3b97"}], "stats": {"total": 336, "additions": 210, "deletions": 126}, "files": [{"sha": "dac9ee6a5d91e62342468065861a925c72cd8780", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 49, "deletions": 16, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "patch": "@@ -58,7 +58,9 @@ pub use crate::intrinsics::transmute;\n ///\n /// # Examples\n ///\n-/// Leak an I/O object, never closing the file:\n+/// The canonical safe use of `mem::forget` is to circumvent a value's destructor\n+/// implemented by the `Drop` trait. For example, this will leak a `File`, i.e. reclaim\n+/// the space taken by the variable but never close the underlying system resource:\n ///\n /// ```no_run\n /// use std::mem;\n@@ -68,9 +70,40 @@ pub use crate::intrinsics::transmute;\n /// mem::forget(file);\n /// ```\n ///\n-/// The practical use cases for `forget` are rather specialized and mainly come\n-/// up in unsafe or FFI code. However, [`ManuallyDrop`] is usually preferred\n-/// for such cases, e.g.:\n+/// This is useful when the ownership of the underlying resource was previously\n+/// transferred to code outside of Rust, for example by transmitting the raw\n+/// file descriptor to C code.\n+///\n+/// # Relationship with `ManuallyDrop`\n+///\n+/// While `mem::forget` can also be used to transfer *memory* ownership, doing so is error-prone.\n+/// [`ManuallyDrop`] should be used instead. Consider, for example, this code:\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let mut v = vec![65, 122];\n+/// // Build a `String` using the contents of `v`\n+/// let s = unsafe { String::from_raw_parts(v.as_mut_ptr(), v.len(), v.capacity()) };\n+/// // leak `v` because its memory is now managed by `s`\n+/// mem::forget(v);  // ERROR - v is invalid and must not be passed to a function\n+/// assert_eq!(s, \"Az\");\n+/// // `s` is implicitly dropped and its memory deallocated.\n+/// ```\n+///\n+/// There are two issues with the above example:\n+///\n+/// * If more code were added between the construction of `String` and the invocation of\n+///   `mem::forget()`, a panic within it would cause a double free because the same memory\n+///   is handled by both `v` and `s`.\n+/// * After calling `v.as_mut_ptr()` and transmitting the ownership of the data to `s`,\n+///   the `v` value is invalid. Even when a value is just moved to `mem::forget` (which won't\n+///   inspect it), some types have strict requirements on their values that\n+///   make them invalid when dangling or no longer owned. Using invalid values in any\n+///   way, including passing them to or returning them from functions, constitutes\n+///   undefined behavior and may break the assumptions made by the compiler.\n+///\n+/// Switching to `ManuallyDrop` avoids both issues:\n ///\n /// ```\n /// use std::mem::ManuallyDrop;\n@@ -80,24 +113,24 @@ pub use crate::intrinsics::transmute;\n /// // does not get dropped!\n /// let mut v = ManuallyDrop::new(v);\n /// // Now disassemble `v`. These operations cannot panic, so there cannot be a leak.\n-/// let ptr = v.as_mut_ptr();\n-/// let cap = v.capacity();\n+/// let (ptr, len, cap) = (v.as_mut_ptr(), v.len(), v.capacity());\n /// // Finally, build a `String`.\n-/// let s = unsafe { String::from_raw_parts(ptr, 2, cap) };\n+/// let s = unsafe { String::from_raw_parts(ptr, len, cap) };\n /// assert_eq!(s, \"Az\");\n /// // `s` is implicitly dropped and its memory deallocated.\n /// ```\n ///\n-/// Using `ManuallyDrop` here has two advantages:\n+/// `ManuallyDrop` robustly prevents double-free because we disable `v`'s destructor\n+/// before doing anything else. `mem::forget()` doesn't allow this because it consumes its\n+/// argument, forcing us to call it only after extracting anything we need from `v`. Even\n+/// if a panic were introduced between construction of `ManuallyDrop` and building the\n+/// string (which cannot happen in the code as shown), it would result in a leak and not a\n+/// double free. In other words, `ManuallyDrop` errs on the side of leaking instead of\n+/// erring on the side of (double-)dropping.\n ///\n-/// * We do not \"touch\" `v` after disassembling it. For some types, operations\n-///   such as passing ownership (to a function like `mem::forget`) requires them to actually\n-///   be fully owned right now; that is a promise we do not want to make here as we are\n-///   in the process of transferring ownership to the new `String` we are building.\n-/// * In case of an unexpected panic, `ManuallyDrop` is not dropped, but if the panic\n-///   occurs before `mem::forget` was called we might end up dropping invalid data,\n-///   or double-dropping. In other words, `ManuallyDrop` errs on the side of leaking\n-///   instead of erring on the side of dropping.\n+/// Also, `ManuallyDrop` prevents us from having to \"touch\" `v` after transferring the\n+/// ownership to `s` - the final step of interacting with `v` to dispoe of it without\n+/// running its destructor is entirely avoided.\n ///\n /// [drop]: fn.drop.html\n /// [uninit]: fn.uninitialized.html"}, {"sha": "69b9edb77c5649a2be64e3e5f73a8abf53fc094a", "filename": "src/libpanic_unwind/hermit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibpanic_unwind%2Fhermit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibpanic_unwind%2Fhermit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fhermit.rs?ref=2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "patch": "@@ -4,7 +4,6 @@\n \n use alloc::boxed::Box;\n use core::any::Any;\n-use core::ptr;\n \n pub unsafe fn cleanup(_ptr: *mut u8) -> Box<dyn Any + Send> {\n     extern \"C\" {"}, {"sha": "13d58ea73ac6b9074b8d93b09301d67479997e36", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "patch": "@@ -381,6 +381,32 @@ impl<'tcx> Instance<'tcx> {\n         Instance { def, substs }\n     }\n \n+    /// FIXME(#69925) Depending on the kind of `InstanceDef`, the MIR body associated with an\n+    /// instance is expressed in terms of the generic parameters of `self.def_id()`, and in other\n+    /// cases the MIR body is expressed in terms of the types found in the substitution array.\n+    /// In the former case, we want to substitute those generic types and replace them with the\n+    /// values from the substs when monomorphizing the function body. But in the latter case, we\n+    /// don't want to do that substitution, since it has already been done effectively.\n+    ///\n+    /// This function returns `Some(substs)` in the former case and None otherwise -- i.e., if\n+    /// this function returns `None`, then the MIR body does not require substitution during\n+    /// monomorphization.\n+    pub fn substs_for_mir_body(&self) -> Option<SubstsRef<'tcx>> {\n+        match self.def {\n+            InstanceDef::CloneShim(..)\n+            | InstanceDef::DropGlue(_, Some(_)) => None,\n+            InstanceDef::ClosureOnceShim { .. }\n+            | InstanceDef::DropGlue(..)\n+            // FIXME(#69925): `FnPtrShim` should be in the other branch.\n+            | InstanceDef::FnPtrShim(..)\n+            | InstanceDef::Item(_)\n+            | InstanceDef::Intrinsic(..)\n+            | InstanceDef::ReifyShim(..)\n+            | InstanceDef::Virtual(..)\n+            | InstanceDef::VtableShim(..) => Some(self.substs),\n+        }\n+    }\n+\n     pub fn is_vtable_shim(&self) -> bool {\n         if let InstanceDef::VtableShim(..) = self.def { true } else { false }\n     }"}, {"sha": "6d28796b34847231c42291b6de331f6f9f41c268", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "patch": "@@ -780,8 +780,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     present_first @ Some(_) => present_first,\n                     // Uninhabited because it has no variants, or only absent ones.\n                     None if def.is_enum() => return tcx.layout_raw(param_env.and(tcx.types.never)),\n-                    // if it's a struct, still compute a layout so that we can still compute the\n-                    // field offsets\n+                    // If it's a struct, still compute a layout so that we can still compute the\n+                    // field offsets.\n                     None => Some(VariantIdx::new(0)),\n                 };\n \n@@ -1987,7 +1987,15 @@ where\n {\n     fn for_variant(this: TyLayout<'tcx>, cx: &C, variant_index: VariantIdx) -> TyLayout<'tcx> {\n         let details = match this.variants {\n-            Variants::Single { index } if index == variant_index => this.details,\n+            Variants::Single { index }\n+                // If all variants but one are uninhabited, the variant layout is the enum layout.\n+                if index == variant_index &&\n+                // Don't confuse variants of uninhabited enums with the enum itself.\n+                // For more details see https://github.com/rust-lang/rust/issues/69763.\n+                this.fields != FieldPlacement::Union(0) =>\n+            {\n+                this.details\n+            }\n \n             Variants::Single { index } => {\n                 // Deny calling for_variant more than once for non-Single enums."}, {"sha": "000db0155ada38b05667e5a396abf7b1995ebd4d", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "patch": "@@ -86,13 +86,18 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: Copy + TypeFoldable<'tcx>,\n     {\n-        self.cx.tcx().subst_and_normalize_erasing_regions(\n-            self.instance.substs,\n-            ty::ParamEnv::reveal_all(),\n-            value,\n-        )\n+        debug!(\"monomorphize: self.instance={:?}\", self.instance);\n+        if let Some(substs) = self.instance.substs_for_mir_body() {\n+            self.cx.tcx().subst_and_normalize_erasing_regions(\n+                substs,\n+                ty::ParamEnv::reveal_all(),\n+                &value,\n+            )\n+        } else {\n+            self.cx.tcx().normalize_erasing_regions(ty::ParamEnv::reveal_all(), *value)\n+        }\n     }\n }\n "}, {"sha": "0f924ba69206421bc68cd8ad0bdf74b0ce62ef20", "filename": "src/librustc_error_codes/error_codes/E0437.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0437.md", "raw_url": "https://github.com/rust-lang/rust/raw/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0437.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0437.md?ref=2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "patch": "@@ -1,7 +1,5 @@\n-Trait implementations can only implement associated types that are members of\n-the trait in question. This error indicates that you attempted to implement\n-an associated type whose name does not match the name of any associated type\n-in the trait.\n+An associated type whose name does not match any of the associated types\n+in the trait was used when implementing the trait.\n \n Erroneous code example:\n \n@@ -13,6 +11,9 @@ impl Foo for i32 {\n }\n ```\n \n+Trait implementations can only implement associated types that are members of\n+the trait in question.\n+\n The solution to this problem is to remove the extraneous associated type:\n \n ```"}, {"sha": "13723bc30090e6a4f66a24ea626ecbdffe1b2d45", "filename": "src/librustc_error_codes/error_codes/E0438.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0438.md", "raw_url": "https://github.com/rust-lang/rust/raw/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0438.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0438.md?ref=2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "patch": "@@ -1,7 +1,5 @@\n-Trait implementations can only implement associated constants that are\n-members of the trait in question. This error indicates that you\n-attempted to implement an associated constant whose name does not\n-match the name of any associated constant in the trait.\n+An associated constant whose name does not match any of the associated constants\n+in the trait was used when implementing the trait.\n \n Erroneous code example:\n \n@@ -13,6 +11,9 @@ impl Foo for i32 {\n }\n ```\n \n+Trait implementations can only implement associated constants that are\n+members of the trait in question.\n+\n The solution to this problem is to remove the extraneous associated constant:\n \n ```"}, {"sha": "68a893dc4be5d7f8748ff8e7b5e5dc05eee66903", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "patch": "@@ -335,15 +335,25 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     /// Call this on things you got out of the MIR (so it is as generic as the current\n     /// stack frame), to bring it into the proper environment for this interpreter.\n+    pub(super) fn subst_from_current_frame_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n+        &self,\n+        value: T,\n+    ) -> T {\n+        self.subst_from_frame_and_normalize_erasing_regions(self.frame(), value)\n+    }\n+\n+    /// Call this on things you got out of the MIR (so it is as generic as the provided\n+    /// stack frame), to bring it into the proper environment for this interpreter.\n     pub(super) fn subst_from_frame_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n         &self,\n+        frame: &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         value: T,\n     ) -> T {\n-        self.tcx.subst_and_normalize_erasing_regions(\n-            self.frame().instance.substs,\n-            self.param_env,\n-            &value,\n-        )\n+        if let Some(substs) = frame.instance.substs_for_mir_body() {\n+            self.tcx.subst_and_normalize_erasing_regions(substs, self.param_env, &value)\n+        } else {\n+            self.tcx.normalize_erasing_regions(self.param_env, value)\n+        }\n     }\n \n     /// The `substs` are assumed to already be in our interpreter \"universe\" (param_env).\n@@ -371,11 +381,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             None => {\n                 let layout = crate::interpret::operand::from_known_layout(layout, || {\n                     let local_ty = frame.body.local_decls[local].ty;\n-                    let local_ty = self.tcx.subst_and_normalize_erasing_regions(\n-                        frame.instance.substs,\n-                        self.param_env,\n-                        &local_ty,\n-                    );\n+                    let local_ty =\n+                        self.subst_from_frame_and_normalize_erasing_regions(frame, local_ty);\n                     self.layout_of(local_ty)\n                 })?;\n                 if let Some(state) = frame.locals.get(local) {"}, {"sha": "b39058405f5cbf2094b483324afd4e4938291afc", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "patch": "@@ -355,7 +355,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let base = match op.try_as_mplace(self) {\n             Ok(mplace) => {\n-                // The easy case\n+                // We can reuse the mplace field computation logic for indirect operands.\n                 let field = self.mplace_field(mplace, field)?;\n                 return Ok(field.into());\n             }\n@@ -490,7 +490,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Copy(ref place) | Move(ref place) => self.eval_place_to_op(place, layout)?,\n \n             Constant(ref constant) => {\n-                let val = self.subst_from_frame_and_normalize_erasing_regions(constant.literal);\n+                let val =\n+                    self.subst_from_current_frame_and_normalize_erasing_regions(constant.literal);\n                 self.eval_const_to_op(val, layout)?\n             }\n         };"}, {"sha": "5313446c253c848e2864011b352cbfa180c238e4", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "patch": "@@ -410,14 +410,6 @@ where\n                 stride * field\n             }\n             layout::FieldPlacement::Union(count) => {\n-                // This is a narrow bug-fix for rust-lang/rust#69191: if we are\n-                // trying to access absent field of uninhabited variant, then\n-                // signal UB (but don't ICE the compiler).\n-                // FIXME temporary hack to work around incoherence between\n-                // layout computation and MIR building\n-                if field >= count as u64 && base.layout.abi == layout::Abi::Uninhabited {\n-                    throw_ub!(Unreachable);\n-                }\n                 assert!(\n                     field < count as u64,\n                     \"Tried to access field {} of union {:#?} with {} fields\",\n@@ -648,9 +640,11 @@ where\n                         // bail out.\n                         None => Place::null(&*self),\n                     },\n-                    layout: self.layout_of(self.subst_from_frame_and_normalize_erasing_regions(\n-                        self.frame().body.return_ty(),\n-                    ))?,\n+                    layout: self.layout_of(\n+                        self.subst_from_current_frame_and_normalize_erasing_regions(\n+                            self.frame().body.return_ty(),\n+                        ),\n+                    )?,\n                 }\n             }\n             local => PlaceTy {"}, {"sha": "cb11df18378d991fc4bb99157e94d9b21298f542", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "patch": "@@ -248,7 +248,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                let ty = self.subst_from_frame_and_normalize_erasing_regions(ty);\n+                let ty = self.subst_from_current_frame_and_normalize_erasing_regions(ty);\n                 let layout = self.layout_of(ty)?;\n                 assert!(\n                     !layout.is_unsized(),"}, {"sha": "4dd037d93ce9b9c727013d84a35a25690c165668", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 40, "deletions": 62, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "patch": "@@ -185,7 +185,7 @@ use rustc::mir::visit::Visitor as MirVisitor;\n use rustc::mir::{self, Local, Location};\n use rustc::ty::adjustment::{CustomCoerceUnsized, PointerCast};\n use rustc::ty::print::obsolete::DefPathBasedNames;\n-use rustc::ty::subst::{InternalSubsts, SubstsRef};\n+use rustc::ty::subst::InternalSubsts;\n use rustc::ty::{self, GenericParamDefKind, Instance, Ty, TyCtxt, TypeFoldable};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{par_iter, MTLock, MTRef, ParallelIterator};\n@@ -493,7 +493,21 @@ struct MirNeighborCollector<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n     output: &'a mut Vec<MonoItem<'tcx>>,\n-    param_substs: SubstsRef<'tcx>,\n+    instance: Instance<'tcx>,\n+}\n+\n+impl<'a, 'tcx> MirNeighborCollector<'a, 'tcx> {\n+    pub fn monomorphize<T>(&self, value: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        debug!(\"monomorphize: self.instance={:?}\", self.instance);\n+        if let Some(substs) = self.instance.substs_for_mir_body() {\n+            self.tcx.subst_and_normalize_erasing_regions(substs, ty::ParamEnv::reveal_all(), &value)\n+        } else {\n+            self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), value)\n+        }\n+    }\n }\n \n impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n@@ -509,17 +523,9 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 ref operand,\n                 target_ty,\n             ) => {\n-                let target_ty = self.tcx.subst_and_normalize_erasing_regions(\n-                    self.param_substs,\n-                    ty::ParamEnv::reveal_all(),\n-                    &target_ty,\n-                );\n+                let target_ty = self.monomorphize(target_ty);\n                 let source_ty = operand.ty(self.body, self.tcx);\n-                let source_ty = self.tcx.subst_and_normalize_erasing_regions(\n-                    self.param_substs,\n-                    ty::ParamEnv::reveal_all(),\n-                    &source_ty,\n-                );\n+                let source_ty = self.monomorphize(source_ty);\n                 let (source_ty, target_ty) =\n                     find_vtable_types_for_unsizing(self.tcx, source_ty, target_ty);\n                 // This could also be a different Unsize instruction, like\n@@ -540,11 +546,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 _,\n             ) => {\n                 let fn_ty = operand.ty(self.body, self.tcx);\n-                let fn_ty = self.tcx.subst_and_normalize_erasing_regions(\n-                    self.param_substs,\n-                    ty::ParamEnv::reveal_all(),\n-                    &fn_ty,\n-                );\n+                let fn_ty = self.monomorphize(fn_ty);\n                 visit_fn_use(self.tcx, fn_ty, false, &mut self.output);\n             }\n             mir::Rvalue::Cast(\n@@ -553,11 +555,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 _,\n             ) => {\n                 let source_ty = operand.ty(self.body, self.tcx);\n-                let source_ty = self.tcx.subst_and_normalize_erasing_regions(\n-                    self.param_substs,\n-                    ty::ParamEnv::reveal_all(),\n-                    &source_ty,\n-                );\n+                let source_ty = self.monomorphize(source_ty);\n                 match source_ty.kind {\n                     ty::Closure(def_id, substs) => {\n                         let instance = Instance::resolve_closure(\n@@ -593,7 +591,23 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, location: Location) {\n         debug!(\"visiting const {:?} @ {:?}\", *constant, location);\n \n-        collect_const(self.tcx, *constant, self.param_substs, self.output);\n+        let substituted_constant = self.monomorphize(*constant);\n+        let param_env = ty::ParamEnv::reveal_all();\n+\n+        match substituted_constant.val {\n+            ty::ConstKind::Value(val) => collect_const_value(self.tcx, val, self.output),\n+            ty::ConstKind::Unevaluated(def_id, substs, promoted) => {\n+                match self.tcx.const_eval_resolve(param_env, def_id, substs, promoted, None) {\n+                    Ok(val) => collect_const_value(self.tcx, val, self.output),\n+                    Err(ErrorHandled::Reported) => {}\n+                    Err(ErrorHandled::TooGeneric) => span_bug!(\n+                        self.tcx.def_span(def_id),\n+                        \"collection encountered polymorphic constant\",\n+                    ),\n+                }\n+            }\n+            _ => {}\n+        }\n \n         self.super_const(constant);\n     }\n@@ -605,21 +619,13 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         match *kind {\n             mir::TerminatorKind::Call { ref func, .. } => {\n                 let callee_ty = func.ty(self.body, tcx);\n-                let callee_ty = tcx.subst_and_normalize_erasing_regions(\n-                    self.param_substs,\n-                    ty::ParamEnv::reveal_all(),\n-                    &callee_ty,\n-                );\n+                let callee_ty = self.monomorphize(callee_ty);\n                 visit_fn_use(self.tcx, callee_ty, true, &mut self.output);\n             }\n             mir::TerminatorKind::Drop { ref location, .. }\n             | mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n                 let ty = location.ty(self.body, self.tcx).ty;\n-                let ty = tcx.subst_and_normalize_erasing_regions(\n-                    self.param_substs,\n-                    ty::ParamEnv::reveal_all(),\n-                    &ty,\n-                );\n+                let ty = self.monomorphize(ty);\n                 visit_drop_use(self.tcx, ty, true, self.output);\n             }\n             mir::TerminatorKind::Goto { .. }\n@@ -1156,8 +1162,7 @@ fn collect_neighbours<'tcx>(\n     debug!(\"collect_neighbours: {:?}\", instance.def_id());\n     let body = tcx.instance_mir(instance.def);\n \n-    MirNeighborCollector { tcx, body: &body, output, param_substs: instance.substs }\n-        .visit_body(body);\n+    MirNeighborCollector { tcx, body: &body, output, instance }.visit_body(body);\n }\n \n fn def_id_to_string(tcx: TyCtxt<'_>, def_id: DefId) -> String {\n@@ -1167,33 +1172,6 @@ fn def_id_to_string(tcx: TyCtxt<'_>, def_id: DefId) -> String {\n     output\n }\n \n-fn collect_const<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    constant: &'tcx ty::Const<'tcx>,\n-    param_substs: SubstsRef<'tcx>,\n-    output: &mut Vec<MonoItem<'tcx>>,\n-) {\n-    debug!(\"visiting const {:?}\", constant);\n-\n-    let param_env = ty::ParamEnv::reveal_all();\n-    let substituted_constant =\n-        tcx.subst_and_normalize_erasing_regions(param_substs, param_env, &constant);\n-\n-    match substituted_constant.val {\n-        ty::ConstKind::Value(val) => collect_const_value(tcx, val, output),\n-        ty::ConstKind::Unevaluated(def_id, substs, promoted) => {\n-            match tcx.const_eval_resolve(param_env, def_id, substs, promoted, None) {\n-                Ok(val) => collect_const_value(tcx, val, output),\n-                Err(ErrorHandled::Reported) => {}\n-                Err(ErrorHandled::TooGeneric) => {\n-                    span_bug!(tcx.def_span(def_id), \"collection encountered polymorphic constant\",)\n-                }\n-            }\n-        }\n-        _ => {}\n-    }\n-}\n-\n fn collect_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     value: ConstValue<'tcx>,"}, {"sha": "afa30e7e632a729bc0f51f32d291301648852f65", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "patch": "@@ -660,7 +660,10 @@ impl FieldPlacement {\n \n     pub fn offset(&self, i: usize) -> Size {\n         match *self {\n-            FieldPlacement::Union(_) => Size::ZERO,\n+            FieldPlacement::Union(count) => {\n+                assert!(i < count, \"tried to access field {} of union with {} fields\", i, count);\n+                Size::ZERO\n+            }\n             FieldPlacement::Array { stride, count } => {\n                 let i = i as u64;\n                 assert!(i < count);"}, {"sha": "6aad082a97f9a48ac40f0308429915c431a9cfcb", "filename": "src/libstd/env.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "patch": "@@ -723,8 +723,8 @@ pub struct ArgsOs {\n /// (such as `*` and `?`). On Windows this is not done, and such arguments are\n /// passed as-is.\n ///\n-/// On glibc Linux, arguments are retrieved by placing a function in .init_array.\n-/// glibc passes argc, argv, and envp to functions in .init_array, as a non-standard extension.\n+/// On glibc Linux systems, arguments are retrieved by placing a function in \".init_array\".\n+/// Glibc passes argc, argv, and envp to functions in \".init_array\", as a non-standard extension.\n /// This allows `std::env::args` to work even in a `cdylib` or `staticlib`, as it does on macOS\n /// and Windows.\n ///\n@@ -758,8 +758,8 @@ pub fn args() -> Args {\n /// set to arbitrary text, and it may not even exist, so this property should\n /// not be relied upon for security purposes.\n ///\n-/// On glibc Linux, arguments are retrieved by placing a function in .init_array.\n-/// glibc passes argc, argv, and envp to functions in .init_array, as a non-standard extension.\n+/// On glibc Linux systems, arguments are retrieved by placing a function in \".init_array\".\n+/// Glibc passes argc, argv, and envp to functions in \".init_array\", as a non-standard extension.\n /// This allows `std::env::args` to work even in a `cdylib` or `staticlib`, as it does on macOS\n /// and Windows.\n ///"}, {"sha": "8e8508cdd6f308b5036209a2fc36696784632a21", "filename": "src/test/ui/type-alias-impl-trait/issue-55099-lifetime-inference.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-55099-lifetime-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-55099-lifetime-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-55099-lifetime-inference.rs?ref=2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "patch": "@@ -0,0 +1,28 @@\n+// check-pass\n+// Regression test for issue #55099\n+// Tests that we don't incorrectly consider a lifetime to part\n+// of the concrete type\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait Future {\n+}\n+\n+struct AndThen<F>(F);\n+\n+impl<F> Future for AndThen<F> {\n+}\n+\n+struct Foo<'a> {\n+    x: &'a mut (),\n+}\n+\n+type F = impl Future;\n+\n+impl<'a> Foo<'a> {\n+    fn reply(&mut self) -> F {\n+        AndThen(|| ())\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2476f414e0e0328407a65175a9f8a546d27d8855", "filename": "triagebot.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2835ca65845c5fac8da2a2612a06b12ad2f4c77c/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=2835ca65845c5fac8da2a2612a06b12ad2f4c77c", "patch": "@@ -23,7 +23,7 @@ Thanks! <3\n label = \"ICEBreaker-LLVM\"\n \n [ping.icebreakers-cleanup-crew]\n-alias = [\"cleanup\", \"cleanups\", \"shrink\", \"reduce\", \"bisect\"]\n+alias = [\"cleanup\", \"cleanups\", \"cleanup-crew\", \"shrink\", \"reduce\", \"bisect\"]\n message = \"\"\"\\\n Hey Cleanup Crew ICE-breakers! This bug has been identified as a good\n \"Cleanup ICE-breaking candidate\". In case it's useful, here are some"}]}