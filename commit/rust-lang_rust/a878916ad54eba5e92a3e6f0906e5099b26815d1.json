{"sha": "a878916ad54eba5e92a3e6f0906e5099b26815d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4Nzg5MTZhZDU0ZWJhNWU5MmEzZTZmMDkwNmU1MDk5YjI2ODE1ZDE=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-04-14T18:14:03Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-04-14T18:14:03Z"}, "message": "rustfmt all the things", "tree": {"sha": "c65407edd325db0adada86a9a597c5d4daaa9ff0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c65407edd325db0adada86a9a597c5d4daaa9ff0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a878916ad54eba5e92a3e6f0906e5099b26815d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a878916ad54eba5e92a3e6f0906e5099b26815d1", "html_url": "https://github.com/rust-lang/rust/commit/a878916ad54eba5e92a3e6f0906e5099b26815d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a878916ad54eba5e92a3e6f0906e5099b26815d1/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd12a2369a4c3a9b9719a14c7f3f53b6b58b9ebe", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd12a2369a4c3a9b9719a14c7f3f53b6b58b9ebe", "html_url": "https://github.com/rust-lang/rust/commit/cd12a2369a4c3a9b9719a14c7f3f53b6b58b9ebe"}], "stats": {"total": 650, "additions": 375, "deletions": 275}, "files": [{"sha": "2295bd7832a404e0707b95ab3d130a6db7b664e8", "filename": "src/array_indexing.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farray_indexing.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -78,17 +78,16 @@ impl LateLintPass for ArrayIndexing {\n \n                 // Index is a constant range\n                 if let Some(range) = utils::unsugar_range(index) {\n-                    let start = range.start.map(|start|\n-                        eval_const_expr_partial(cx.tcx, start, ExprTypeChecked, None)).map(|v| v.ok());\n-                    let end = range.end.map(|end|\n-                        eval_const_expr_partial(cx.tcx, end, ExprTypeChecked, None)).map(|v| v.ok());\n+                    let start = range.start\n+                                     .map(|start| eval_const_expr_partial(cx.tcx, start, ExprTypeChecked, None))\n+                                     .map(|v| v.ok());\n+                    let end = range.end\n+                                   .map(|end| eval_const_expr_partial(cx.tcx, end, ExprTypeChecked, None))\n+                                   .map(|v| v.ok());\n \n                     if let Some((start, end)) = to_const_range(start, end, range.limits, size) {\n                         if start > size || end > size {\n-                            utils::span_lint(cx,\n-                                             OUT_OF_BOUNDS_INDEXING,\n-                                             e.span,\n-                                             \"range is out of bounds\");\n+                            utils::span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"range is out of bounds\");\n                         }\n                         return;\n                     }\n@@ -111,11 +110,9 @@ impl LateLintPass for ArrayIndexing {\n }\n \n /// Returns an option containing a tuple with the start and end (exclusive) of the range.\n-fn to_const_range(start: Option<Option<ConstVal>>,\n-                  end: Option<Option<ConstVal>>,\n-                  limits: RangeLimits,\n+fn to_const_range(start: Option<Option<ConstVal>>, end: Option<Option<ConstVal>>, limits: RangeLimits,\n                   array_size: ConstInt)\n-                    -> Option<(ConstInt, ConstInt)> {\n+                  -> Option<(ConstInt, ConstInt)> {\n     let start = match start {\n         Some(Some(ConstVal::Integral(x))) => x,\n         Some(_) => return None,\n@@ -131,7 +128,7 @@ fn to_const_range(start: Option<Option<ConstVal>>,\n             }\n         }\n         Some(_) => return None,\n-        None => array_size\n+        None => array_size,\n     };\n \n     Some((start, end))"}, {"sha": "6106486c71e2b4440fc183296624b0db10278467", "filename": "src/attrs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -115,7 +115,8 @@ fn is_relevant_block(block: &Block) -> bool {\n     for stmt in &block.stmts {\n         match stmt.node {\n             StmtDecl(_, _) => return true,\n-            StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => {\n+            StmtExpr(ref expr, _) |\n+            StmtSemi(ref expr, _) => {\n                 return is_relevant_expr(expr);\n             }\n         }"}, {"sha": "aec0990dcc68ac24a2975305121720852b5fd27e", "filename": "src/bit_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -264,7 +264,7 @@ fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u64> {\n                 // borrowing.\n                 let def_map = cx.tcx.def_map.borrow();\n                 match def_map.get(&lit.id) {\n-                    Some(&PathResolution { base_def: Def::Const(def_id), ..}) => Some(def_id),\n+                    Some(&PathResolution { base_def: Def::Const(def_id), .. }) => Some(def_id),\n                     _ => None,\n                 }\n             }"}, {"sha": "908415acc7b954c6a1e66f34f9d9470da4c1daf7", "filename": "src/booleans.rs", "status": "modified", "additions": 59, "deletions": 40, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbooleans.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -49,7 +49,7 @@ struct NonminimalBoolVisitor<'a, 'tcx: 'a>(&'a LateContext<'a, 'tcx>);\n use quine_mc_cluskey::Bool;\n struct Hir2Qmm<'a, 'tcx: 'a, 'v> {\n     terminals: Vec<&'v Expr>,\n-    cx: &'a LateContext<'a, 'tcx>\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n@@ -75,17 +75,17 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                     match binop.node {\n                         BiOr => return Ok(Bool::Or(self.extract(BiOr, &[lhs, rhs], Vec::new())?)),\n                         BiAnd => return Ok(Bool::And(self.extract(BiAnd, &[lhs, rhs], Vec::new())?)),\n-                        _ => {},\n+                        _ => (),\n                     }\n-                },\n+                }\n                 ExprLit(ref lit) => {\n                     match lit.node {\n                         LitKind::Bool(true) => return Ok(Bool::True),\n                         LitKind::Bool(false) => return Ok(Bool::False),\n-                        _ => {},\n+                        _ => (),\n                     }\n-                },\n-                _ => {},\n+                }\n+                _ => (),\n             }\n         }\n         for (n, expr) in self.terminals.iter().enumerate() {\n@@ -95,11 +95,13 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n             }\n             let negated = match e.node {\n                 ExprBinary(binop, ref lhs, ref rhs) => {\n-                    let mk_expr = |op| Expr {\n-                        id: DUMMY_NODE_ID,\n-                        span: DUMMY_SP,\n-                        attrs: None,\n-                        node: ExprBinary(dummy_spanned(op), lhs.clone(), rhs.clone()),\n+                    let mk_expr = |op| {\n+                        Expr {\n+                            id: DUMMY_NODE_ID,\n+                            span: DUMMY_SP,\n+                            attrs: None,\n+                            node: ExprBinary(dummy_spanned(op), lhs.clone(), rhs.clone()),\n+                        }\n                     };\n                     match binop.node {\n                         BiEq => mk_expr(BiNe),\n@@ -110,7 +112,7 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                         BiLe => mk_expr(BiGt),\n                         _ => continue,\n                     }\n-                },\n+                }\n                 _ => continue,\n             };\n             if SpanlessEq::new(self.cx).ignore_fn().eq_expr(&negated, expr) {\n@@ -137,17 +139,17 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n             True => {\n                 s.push_str(\"true\");\n                 s\n-            },\n+            }\n             False => {\n                 s.push_str(\"false\");\n                 s\n-            },\n+            }\n             Not(ref inner) => {\n                 match **inner {\n                     And(_) | Or(_) => {\n                         s.push('!');\n                         recurse(true, cx, inner, terminals, s)\n-                    },\n+                    }\n                     Term(n) => {\n                         if let ExprBinary(binop, ref lhs, ref rhs) = terminals[n as usize].node {\n                             let op = match binop.node {\n@@ -159,8 +161,8 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                                 BiGe => \" < \",\n                                 _ => {\n                                     s.push('!');\n-                                    return recurse(true, cx, inner, terminals, s)\n-                                },\n+                                    return recurse(true, cx, inner, terminals, s);\n+                                }\n                             };\n                             s.push_str(&snip(lhs));\n                             s.push_str(op);\n@@ -170,13 +172,13 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                             s.push('!');\n                             recurse(false, cx, inner, terminals, s)\n                         }\n-                    },\n+                    }\n                     _ => {\n                         s.push('!');\n                         recurse(false, cx, inner, terminals, s)\n-                    },\n+                    }\n                 }\n-            },\n+            }\n             And(ref v) => {\n                 if brackets {\n                     s.push('(');\n@@ -198,7 +200,7 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                     s.push(')');\n                 }\n                 s\n-            },\n+            }\n             Or(ref v) => {\n                 if brackets {\n                     s.push('(');\n@@ -212,7 +214,7 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                     s.push(')');\n                 }\n                 s\n-            },\n+            }\n             Term(n) => {\n                 if brackets {\n                     if let ExprBinary(..) = terminals[n as usize].node {\n@@ -243,13 +245,13 @@ fn simple_negate(b: Bool) -> Bool {\n                 *el = simple_negate(::std::mem::replace(el, True));\n             }\n             Or(v)\n-        },\n+        }\n         Or(mut v) => {\n             for el in &mut v {\n                 *el = simple_negate(::std::mem::replace(el, True));\n             }\n             And(v)\n-        },\n+        }\n         Not(inner) => *inner,\n     }\n }\n@@ -271,13 +273,13 @@ fn terminal_stats(b: &Bool) -> Stats {\n                     _ => stats.negations += 1,\n                 }\n                 recurse(inner, stats);\n-            },\n+            }\n             And(ref v) | Or(ref v) => {\n                 stats.ops += v.len() - 1;\n                 for inner in v {\n                     recurse(inner, stats);\n                 }\n-            },\n+            }\n             Term(n) => stats.terminals[n as usize] += 1,\n         }\n     }\n@@ -306,7 +308,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n             let mut simplified = expr.simplify();\n             for simple in Bool::Not(Box::new(expr.clone())).simplify() {\n                 match simple {\n-                    Bool::Not(_) | Bool::True | Bool::False => {},\n+                    Bool::Not(_) | Bool::True | Bool::False => {}\n                     _ => simplified.push(Bool::Not(Box::new(simple.clone()))),\n                 }\n                 let simple_negated = simple_negate(simple);\n@@ -325,36 +327,53 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                         continue 'simplified;\n                     }\n                     if stats.terminals[i] != 0 && simplified_stats.terminals[i] == 0 {\n-                        span_lint_and_then(self.0, LOGIC_BUG, e.span, \"this boolean expression contains a logic bug\", |db| {\n-                            db.span_help(h2q.terminals[i].span, \"this expression can be optimized out by applying boolean operations to the outer expression\");\n-                            db.span_suggestion(e.span, \"it would look like the following\", suggest(self.0, suggestion, &h2q.terminals));\n-                        });\n+                        span_lint_and_then(self.0,\n+                                           LOGIC_BUG,\n+                                           e.span,\n+                                           \"this boolean expression contains a logic bug\",\n+                                           |db| {\n+                                               db.span_help(h2q.terminals[i].span,\n+                                                            \"this expression can be optimized out by applying \\\n+                                                             boolean operations to the outer expression\");\n+                                               db.span_suggestion(e.span,\n+                                                                  \"it would look like the following\",\n+                                                                  suggest(self.0, suggestion, &h2q.terminals));\n+                                           });\n                         // don't also lint `NONMINIMAL_BOOL`\n                         return;\n                     }\n                     // if the number of occurrences of a terminal decreases or any of the stats decreases while none increases\n                     improvement |= (stats.terminals[i] > simplified_stats.terminals[i]) ||\n-                        (stats.negations > simplified_stats.negations && stats.ops == simplified_stats.ops) ||\n-                        (stats.ops > simplified_stats.ops && stats.negations == simplified_stats.negations);\n+                                   (stats.negations > simplified_stats.negations &&\n+                                    stats.ops == simplified_stats.ops) ||\n+                                   (stats.ops > simplified_stats.ops && stats.negations == simplified_stats.negations);\n                 }\n                 if improvement {\n                     improvements.push(suggestion);\n                 }\n             }\n             if !improvements.is_empty() {\n-                span_lint_and_then(self.0, NONMINIMAL_BOOL, e.span, \"this boolean expression can be simplified\", |db| {\n-                    for suggestion in &improvements {\n-                        db.span_suggestion(e.span, \"try\", suggest(self.0, suggestion, &h2q.terminals));\n-                    }\n-                });\n+                span_lint_and_then(self.0,\n+                                   NONMINIMAL_BOOL,\n+                                   e.span,\n+                                   \"this boolean expression can be simplified\",\n+                                   |db| {\n+                                       for suggestion in &improvements {\n+                                           db.span_suggestion(e.span,\n+                                                              \"try\",\n+                                                              suggest(self.0, suggestion, &h2q.terminals));\n+                                       }\n+                                   });\n             }\n         }\n     }\n }\n \n impl<'a, 'v, 'tcx> Visitor<'v> for NonminimalBoolVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, e: &'v Expr) {\n-        if in_macro(self.0, e.span) { return }\n+        if in_macro(self.0, e.span) {\n+            return;\n+        }\n         match e.node {\n             ExprBinary(binop, _, _) if binop.node == BiOr || binop.node == BiAnd => self.bool_expr(e),\n             ExprUnary(UnNot, ref inner) => {\n@@ -363,7 +382,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for NonminimalBoolVisitor<'a, 'tcx> {\n                 } else {\n                     walk_expr(self, e);\n                 }\n-            },\n+            }\n             _ => walk_expr(self, e),\n         }\n     }"}, {"sha": "38e04723e53024780edb4c8a3994428a18c878cc", "filename": "src/collapsible_if.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcollapsible_if.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -70,7 +70,7 @@ fn check_if(cx: &LateContext, e: &Expr) {\n                     db.span_suggestion(block.span, \"try\", snippet_block(cx, else_.span, \"..\").into_owned());\n                 });\n             }}\n-        } else if let Some(&Expr{ node: ExprIf(ref check_inner, ref content, None), span: sp, ..}) =\n+        } else if let Some(&Expr { node: ExprIf(ref check_inner, ref content, None), span: sp, .. }) =\n                single_stmt_of_block(then) {\n             if e.span.expn_id != sp.expn_id {\n                 return;\n@@ -89,7 +89,7 @@ fn check_if(cx: &LateContext, e: &Expr) {\n \n fn requires_brackets(e: &Expr) -> bool {\n     match e.node {\n-        ExprBinary(Spanned {node: n, ..}, _, _) if n == BiEq => false,\n+        ExprBinary(Spanned { node: n, .. }, _, _) if n == BiEq => false,\n         _ => true,\n     }\n }"}, {"sha": "0eed34a8055fbd82c09a386b4e67e6107b2f2190", "filename": "src/consts.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -85,7 +85,9 @@ impl PartialEq for Constant {\n             (&Constant::Str(ref ls, ref l_sty), &Constant::Str(ref rs, ref r_sty)) => ls == rs && l_sty == r_sty,\n             (&Constant::Binary(ref l), &Constant::Binary(ref r)) => l == r,\n             (&Constant::Char(l), &Constant::Char(r)) => l == r,\n-            (&Constant::Int(l), &Constant::Int(r)) => l.is_negative() == r.is_negative() && l.to_u64_unchecked() == r.to_u64_unchecked(),\n+            (&Constant::Int(l), &Constant::Int(r)) => {\n+                l.is_negative() == r.is_negative() && l.to_u64_unchecked() == r.to_u64_unchecked()\n+            }\n             (&Constant::Float(ref ls, _), &Constant::Float(ref rs, _)) => {\n                 // we want `Fw32 == FwAny` and `FwAny == Fw64`, by transitivity we must have\n                 // `Fw32 == Fw64` so don\u2019t compare them\n@@ -131,7 +133,8 @@ impl Hash for Constant {\n             Constant::Bool(b) => {\n                 b.hash(state);\n             }\n-            Constant::Vec(ref v) | Constant::Tuple(ref v) => {\n+            Constant::Vec(ref v) |\n+            Constant::Tuple(ref v) => {\n                 v.hash(state);\n             }\n             Constant::Repeat(ref c, l) => {\n@@ -186,12 +189,16 @@ fn lit_to_constant(lit: &LitKind) -> Constant {\n         LitKind::Int(value, LitIntType::Unsigned(UintTy::U16)) => Constant::Int(ConstInt::U16(value as u16)),\n         LitKind::Int(value, LitIntType::Unsigned(UintTy::U32)) => Constant::Int(ConstInt::U32(value as u32)),\n         LitKind::Int(value, LitIntType::Unsigned(UintTy::U64)) => Constant::Int(ConstInt::U64(value as u64)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::Us)) => Constant::Int(ConstInt::Usize(ConstUsize::Us32(value as u32))),\n+        LitKind::Int(value, LitIntType::Unsigned(UintTy::Us)) => {\n+            Constant::Int(ConstInt::Usize(ConstUsize::Us32(value as u32)))\n+        }\n         LitKind::Int(value, LitIntType::Signed(IntTy::I8)) => Constant::Int(ConstInt::I8(value as i8)),\n         LitKind::Int(value, LitIntType::Signed(IntTy::I16)) => Constant::Int(ConstInt::I16(value as i16)),\n         LitKind::Int(value, LitIntType::Signed(IntTy::I32)) => Constant::Int(ConstInt::I32(value as i32)),\n         LitKind::Int(value, LitIntType::Signed(IntTy::I64)) => Constant::Int(ConstInt::I64(value as i64)),\n-        LitKind::Int(value, LitIntType::Signed(IntTy::Is)) => Constant::Int(ConstInt::Isize(ConstIsize::Is32(value as i32))),\n+        LitKind::Int(value, LitIntType::Signed(IntTy::Is)) => {\n+            Constant::Int(ConstInt::Isize(ConstIsize::Is32(value as i32)))\n+        }\n         LitKind::Float(ref is, ty) => Constant::Float(is.to_string(), ty.into()),\n         LitKind::FloatUnsuffixed(ref is) => Constant::Float(is.to_string(), FloatWidth::Any),\n         LitKind::Bool(b) => Constant::Bool(b),\n@@ -285,7 +292,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     fn fetch_path(&mut self, e: &Expr) -> Option<Constant> {\n         if let Some(lcx) = self.lcx {\n             let mut maybe_id = None;\n-            if let Some(&PathResolution { base_def: Def::Const(id), ..}) = lcx.tcx.def_map.borrow().get(&e.id) {\n+            if let Some(&PathResolution { base_def: Def::Const(id), .. }) = lcx.tcx.def_map.borrow().get(&e.id) {\n                 maybe_id = Some(id);\n             }\n             // separate if lets to avoid double borrowing the def_map\n@@ -324,7 +331,11 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     }\n \n     fn binop(&mut self, op: BinOp, left: &Expr, right: &Expr) -> Option<Constant> {\n-        let l = if let Some(l) = self.expr(left) { l } else { return None; };\n+        let l = if let Some(l) = self.expr(left) {\n+            l\n+        } else {\n+            return None;\n+        };\n         let r = self.expr(right);\n         match (op.node, l, r) {\n             (BiAdd, Constant::Int(l), Some(Constant::Int(r))) => (l + r).ok().map(Constant::Int),"}, {"sha": "aba4638ab8bb90e9a94d4e799af2afcbcf227def", "filename": "src/copies.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcopies.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -71,7 +71,7 @@ impl LateLintPass for CopyAndPaste {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if !in_macro(cx, expr.span) {\n             // skip ifs directly in else, it will be checked in the parent if\n-            if let Some(&Expr{node: ExprIf(_, _, Some(ref else_expr)), ..}) = get_parent_expr(cx, expr) {\n+            if let Some(&Expr { node: ExprIf(_, _, Some(ref else_expr)), .. }) = get_parent_expr(cx, expr) {\n                 if else_expr.id == expr.id {\n                     return;\n                 }\n@@ -185,7 +185,8 @@ fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<InternedString, ty::Ty<'tcx>> {\n     fn bindings_impl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat, map: &mut HashMap<InternedString, ty::Ty<'tcx>>) {\n         match pat.node {\n-            PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n+            PatKind::Box(ref pat) |\n+            PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n             PatKind::TupleStruct(_, Some(ref pats)) => {\n                 for pat in pats {\n                     bindings_impl(cx, pat, map);"}, {"sha": "e8a3a569a140c475e991d3d5b605c29f704df68c", "filename": "src/cyclomatic_complexity.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcyclomatic_complexity.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -60,12 +60,7 @@ impl CyclomaticComplexity {\n             tcx: &cx.tcx,\n         };\n         helper.visit_block(block);\n-        let CCHelper {\n-            match_arms,\n-            divergence,\n-            short_circuits,\n-            ..\n-        } = helper;\n+        let CCHelper { match_arms, divergence, short_circuits, .. } = helper;\n \n         if cc + divergence < match_arms + short_circuits {\n             report_cc_bug(cx, cc, match_arms, divergence, short_circuits, span);\n@@ -132,7 +127,8 @@ impl<'a, 'b, 'tcx> Visitor<'a> for CCHelper<'b, 'tcx> {\n                 walk_expr(self, e);\n                 let ty = self.tcx.node_id_to_type(callee.id);\n                 match ty.sty {\n-                    ty::TyFnDef(_, _, ty) | ty::TyFnPtr(ty) if ty.sig.skip_binder().output.diverges() => {\n+                    ty::TyFnDef(_, _, ty) |\n+                    ty::TyFnPtr(ty) if ty.sig.skip_binder().output.diverges() => {\n                         self.divergence += 1;\n                     }\n                     _ => (),\n@@ -143,7 +139,7 @@ impl<'a, 'b, 'tcx> Visitor<'a> for CCHelper<'b, 'tcx> {\n                 walk_expr(self, e);\n                 match op.node {\n                     BiAnd | BiOr => self.short_circuits += 1,\n-                    _ => {},\n+                    _ => (),\n                 }\n             }\n             _ => walk_expr(self, e),\n@@ -156,10 +152,10 @@ fn report_cc_bug(_: &LateContext, cc: u64, narms: u64, div: u64, shorts: u64, sp\n     span_bug!(span,\n               \"Clippy encountered a bug calculating cyclomatic complexity: cc = {}, arms = {}, \\\n                div = {}, shorts = {}. Please file a bug report.\",\n-               cc,\n-               narms,\n-               div,\n-               shorts);\n+              cc,\n+              narms,\n+              div,\n+              shorts);\n }\n #[cfg(not(feature=\"debugging\"))]\n fn report_cc_bug(cx: &LateContext, cc: u64, narms: u64, div: u64, shorts: u64, span: Span) {"}, {"sha": "54d5366729e246042ee77a786f6023f13b74c562", "filename": "src/doc.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -142,10 +142,10 @@ pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Sp\n                     }\n                     '`' => {\n                         current_word_begin = jump_to!(chars, '`', len);\n-                    },\n+                    }\n                     '[' => {\n                         let end = jump_to!(chars, ']', len);\n-                        let link_text = &doc[current_word_begin+1..end];\n+                        let link_text = &doc[current_word_begin + 1..end];\n \n                         match chars.peek() {\n                             Some(&(_, c)) => {\n@@ -199,7 +199,7 @@ fn check_word(cx: &EarlyContext, valid_idents: &[String], word: &str, span: Span\n         }\n \n         let s = if s.ends_with('s') {\n-            &s[..s.len()-1]\n+            &s[..s.len() - 1]\n         } else {\n             s\n         };\n@@ -223,6 +223,9 @@ fn check_word(cx: &EarlyContext, valid_idents: &[String], word: &str, span: Span\n     }\n \n     if has_underscore(word) || word.contains(\"::\") || is_camel_case(word) {\n-        span_lint(cx, DOC_MARKDOWN, span, &format!(\"you should put `{}` between ticks in the documentation\", word));\n+        span_lint(cx,\n+                  DOC_MARKDOWN,\n+                  span,\n+                  &format!(\"you should put `{}` between ticks in the documentation\", word));\n     }\n }"}, {"sha": "d63d8c67c5d37955656bfbb90e4aabb1d440a440", "filename": "src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fentry.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -47,7 +47,7 @@ impl LateLintPass for HashMapLint {\n                     // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n                     // we can give a better error message\n                     let sole_expr = else_block.is_none() &&\n-                        ((then_block.expr.is_some() as usize) + then_block.stmts.len() == 1);\n+                                    ((then_block.expr.is_some() as usize) + then_block.stmts.len() == 1);\n \n                     let mut visitor = InsertVisitor {\n                         cx: cx,"}, {"sha": "37a89069d1927d3c9c5d18ebeab5bed5106af5e6", "filename": "src/enum_glob_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fenum_glob_use.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -54,7 +54,7 @@ impl EnumGlobUse {\n                         let child = cx.sess().cstore.item_children(def.def_id());\n                         if let Some(child) = child.first() {\n                             if let DefLike::DlDef(Def::Variant(..)) = child.def {\n-                                span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");   \n+                                span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n                             }\n                         }\n                     }"}, {"sha": "83abe215aa713d3df38269b633cb5d1060042455", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -60,9 +60,10 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                 let fn_ty = cx.tcx.expr_ty(caller);\n                 match fn_ty.sty {\n                     // Is it an unsafe function? They don't implement the closure traits\n-                    ty::TyFnDef(_, _, fn_ty) | ty::TyFnPtr(fn_ty) => {\n+                    ty::TyFnDef(_, _, fn_ty) |\n+                    ty::TyFnPtr(fn_ty) => {\n                         if fn_ty.unsafety == Unsafety::Unsafe ||\n-                            fn_ty.sig.skip_binder().output == ty::FnOutput::FnDiverging {\n+                           fn_ty.sig.skip_binder().output == ty::FnOutput::FnDiverging {\n                             return;\n                         }\n                     }"}, {"sha": "37b65e471fa26e32285bc6808ee2815c69763fc9", "filename": "src/functions.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffunctions.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -31,9 +31,7 @@ pub struct Functions {\n \n impl Functions {\n     pub fn new(threshold: u64) -> Functions {\n-        Functions {\n-            threshold: threshold\n-        }\n+        Functions { threshold: threshold }\n     }\n }\n \n@@ -49,7 +47,8 @@ impl LateLintPass for Functions {\n \n         if let Some(NodeItem(ref item)) = cx.tcx.map.find(cx.tcx.map.get_parent_node(nodeid)) {\n             match item.node {\n-                hir::ItemImpl(_, _, _, Some(_), _, _) | hir::ItemDefaultImpl(..) => return,\n+                hir::ItemImpl(_, _, _, Some(_), _, _) |\n+                hir::ItemDefaultImpl(..) => return,\n                 _ => (),\n             }\n         }\n@@ -68,7 +67,9 @@ impl Functions {\n     fn check_arg_number(&self, cx: &LateContext, decl: &hir::FnDecl, span: Span) {\n         let args = decl.inputs.len() as u64;\n         if args > self.threshold {\n-            span_lint(cx, TOO_MANY_ARGUMENTS, span,\n+            span_lint(cx,\n+                      TOO_MANY_ARGUMENTS,\n+                      span,\n                       &format!(\"this function has to many arguments ({}/{})\", args, self.threshold));\n         }\n     }"}, {"sha": "ebc2ce76fec96f7c6c64e16ba2af0f26db75a550", "filename": "src/if_not_else.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fif_not_else.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -37,15 +37,15 @@ impl EarlyLintPass for IfNotElse {\n                                            item.span,\n                                            \"Unnecessary boolean `not` operation\",\n                                            \"remove the `!` and swap the blocks of the if/else\");\n-                    },\n+                    }\n                     ExprKind::Binary(ref kind, _, _) if kind.node == BinOpKind::Ne => {\n                         span_help_and_lint(cx,\n                                            IF_NOT_ELSE,\n                                            item.span,\n                                            \"Unnecessary `!=` operation\",\n                                            \"change to `==` and swap the blocks of the if/else\");\n-                    },\n-                    _ => {},\n+                    }\n+                    _ => (),\n                 }\n             }\n         }"}, {"sha": "7a7a17bc79d19fb77e334e2bc82144b870f71567", "filename": "src/len_zero.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -64,7 +64,7 @@ impl LateLintPass for LenZero {\n             return;\n         }\n \n-        if let ExprBinary(Spanned{node: cmp, ..}, ref left, ref right) = expr.node {\n+        if let ExprBinary(Spanned { node: cmp, .. }, ref left, ref right) = expr.node {\n             match cmp {\n                 BiEq => check_cmp(cx, expr.span, left, right, \"\"),\n                 BiGt | BiNe => check_cmp(cx, expr.span, left, right, \"!\"),\n@@ -155,7 +155,7 @@ fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str)\n }\n \n fn check_len_zero(cx: &LateContext, span: Span, name: &Name, args: &[P<Expr>], lit: &Lit, op: &str) {\n-    if let Spanned{node: LitKind::Int(0, _), ..} = *lit {\n+    if let Spanned { node: LitKind::Int(0, _), .. } = *lit {\n         if name.as_str() == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n             span_lint_and_then(cx, LEN_ZERO, span, \"length comparison to zero\", |db| {\n                 db.span_suggestion(span,\n@@ -199,7 +199,8 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n               .map_or(false, |ids| ids.iter().any(|i| is_is_empty(cx, i)))\n         }\n         ty::TyProjection(_) => ty.ty_to_def_id().map_or(false, |id| has_is_empty_impl(cx, &id)),\n-        ty::TyEnum(ref id, _) | ty::TyStruct(ref id, _) => has_is_empty_impl(cx, &id.did),\n+        ty::TyEnum(ref id, _) |\n+        ty::TyStruct(ref id, _) => has_is_empty_impl(cx, &id.did),\n         ty::TyArray(..) | ty::TyStr => true,\n         _ => false,\n     }"}, {"sha": "67dfabe2569cacf3053c5eaedc2bdf9161849318", "filename": "src/lifetimes.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -127,7 +127,7 @@ fn could_use_elision<'a, T: Iterator<Item = &'a Lifetime>>(cx: &LateContext, fun\n         match slf.node {\n             SelfRegion(ref opt_lt, _, _) => input_visitor.record(opt_lt),\n             SelfExplicit(ref ty, _) => walk_ty(&mut input_visitor, ty),\n-            _ => {}\n+            _ => (),\n         }\n     }\n     // extract lifetimes in input argument types\n@@ -243,7 +243,8 @@ impl<'v, 't> RefVisitor<'v, 't> {\n             if params.lifetimes.is_empty() {\n                 if let Some(def) = self.cx.tcx.def_map.borrow().get(&ty.id).map(|r| r.full_def()) {\n                     match def {\n-                        Def::TyAlias(def_id) | Def::Struct(def_id) => {\n+                        Def::TyAlias(def_id) |\n+                        Def::Struct(def_id) => {\n                             let type_scheme = self.cx.tcx.lookup_item_type(def_id);\n                             for _ in type_scheme.generics.regions.as_slice() {\n                                 self.record(&None);\n@@ -255,7 +256,7 @@ impl<'v, 't> RefVisitor<'v, 't> {\n                                 self.record(&None);\n                             }\n                         }\n-                        _ => {}\n+                        _ => (),\n                     }\n                 }\n             }\n@@ -277,7 +278,7 @@ impl<'v, 't> Visitor<'v> for RefVisitor<'v, 't> {\n             TyPath(_, ref path) => {\n                 self.collect_anonymous_lifetimes(path, ty);\n             }\n-            _ => {}\n+            _ => (),\n         }\n         walk_ty(self, ty);\n     }\n@@ -353,7 +354,7 @@ fn report_extra_lifetimes(cx: &LateContext, func: &FnDecl, generics: &Generics,\n         match slf.node {\n             SelfRegion(Some(ref lt), _, _) => checker.visit_lifetime(lt),\n             SelfExplicit(ref t, _) => walk_ty(&mut checker, t),\n-            _ => {}\n+            _ => (),\n         }\n     }\n "}, {"sha": "0b341f645df3d2d3f3725ef98ada369a10867455", "filename": "src/loops.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -14,8 +14,8 @@ use std::collections::HashMap;\n use syntax::ast;\n \n use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, in_external_macro,\n-            span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then,\n-            unsugar_range, walk_ptrs_ty, recover_for_loop};\n+            span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then, unsugar_range,\n+            walk_ptrs_ty, recover_for_loop};\n use utils::paths;\n use utils::UnsugaredRange;\n \n@@ -247,7 +247,8 @@ impl LateLintPass for LoopsPass {\n                 if let ExprMatch(ref matchexpr, ref arms, ref source) = inner.node {\n                     // ensure \"if let\" compatible match structure\n                     match *source {\n-                        MatchSource::Normal | MatchSource::IfLetDesugar{..} => {\n+                        MatchSource::Normal |\n+                        MatchSource::IfLetDesugar { .. } => {\n                             if arms.len() == 2 && arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n                                arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n                                is_break_expr(&arms[1].body) {\n@@ -779,7 +780,8 @@ fn extract_first_expr(block: &Block) -> Option<&Expr> {\n         Some(ref expr) => Some(expr),\n         None if !block.stmts.is_empty() => {\n             match block.stmts[0].node {\n-                StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => Some(expr),\n+                StmtExpr(ref expr, _) |\n+                StmtSemi(ref expr, _) => Some(expr),\n                 _ => None,\n             }\n         }"}, {"sha": "bce93b717a36c16ad31c910ef87931fa707dc945", "filename": "src/matches.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -252,19 +252,20 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n \n             if let Some((ref true_expr, ref false_expr)) = exprs {\n                 match (is_unit_expr(true_expr), is_unit_expr(false_expr)) {\n-                    (false, false) =>\n+                    (false, false) => {\n                         Some(format!(\"if {} {} else {}\",\n                                      snippet(cx, ex.span, \"b\"),\n                                      expr_block(cx, true_expr, None, \"..\"),\n-                                     expr_block(cx, false_expr, None, \"..\"))),\n-                    (false, true) =>\n-                        Some(format!(\"if {} {}\",\n-                                     snippet(cx, ex.span, \"b\"),\n-                                     expr_block(cx, true_expr, None, \"..\"))),\n-                    (true, false) =>\n+                                     expr_block(cx, false_expr, None, \"..\")))\n+                    }\n+                    (false, true) => {\n+                        Some(format!(\"if {} {}\", snippet(cx, ex.span, \"b\"), expr_block(cx, true_expr, None, \"..\")))\n+                    }\n+                    (true, false) => {\n                         Some(format!(\"try\\nif !{} {}\",\n                                      snippet(cx, ex.span, \"b\"),\n-                                     expr_block(cx, false_expr, None, \"..\"))),\n+                                     expr_block(cx, false_expr, None, \"..\")))\n+                    }\n                     (true, true) => None,\n                 }\n             } else {\n@@ -312,9 +313,7 @@ fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: Match\n                                expr.span,\n                                \"you don't need to add `&` to both the expression and the patterns\",\n                                |db| {\n-                                   db.span_suggestion(expr.span,\n-                                                      \"try\",\n-                                                      template);\n+                                   db.span_suggestion(expr.span, \"try\", template);\n                                });\n         } else {\n             let template = match_template(cx, expr.span, source, \"*\", ex);\n@@ -324,7 +323,8 @@ fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: Match\n                                \"you don't need to add `&` to all patterns\",\n                                |db| {\n                                    db.span_suggestion(expr.span,\n-                                                      \"instead of prefixing all patterns with `&`, you can dereference the expression\",\n+                                                      \"instead of prefixing all patterns with `&`, you can \\\n+                                                       dereference the expression\",\n                                                       template);\n                                });\n         }\n@@ -373,17 +373,18 @@ type TypedRanges = Vec<SpannedRange<ConstInt>>;\n /// Get all `Int` ranges or all `Uint` ranges. Mixed types are an error anyway and other types than\n /// `Uint` and `Int` probably don't make sense.\n fn type_ranges(ranges: &[SpannedRange<ConstVal>]) -> TypedRanges {\n-    ranges.iter().filter_map(|range| {\n-        if let (ConstVal::Integral(start), ConstVal::Integral(end)) = range.node {\n-            Some(SpannedRange {\n-                span: range.span,\n-                node: (start, end),\n-            })\n-        } else {\n-            None\n-        }\n-    })\n-    .collect()\n+    ranges.iter()\n+          .filter_map(|range| {\n+              if let (ConstVal::Integral(start), ConstVal::Integral(end)) = range.node {\n+                  Some(SpannedRange {\n+                      span: range.span,\n+                      node: (start, end),\n+                  })\n+              } else {\n+                  None\n+              }\n+          })\n+          .collect()\n }\n \n fn is_unit_expr(expr: &Expr) -> bool {\n@@ -416,7 +417,7 @@ fn match_template(cx: &LateContext, span: Span, source: MatchSource, op: &str, e\n         MatchSource::IfLetDesugar { .. } => format!(\"if let .. = {}{} {{ .. }}\", op, expr_snippet),\n         MatchSource::WhileLetDesugar => format!(\"while let .. = {}{} {{ .. }}\", op, expr_snippet),\n         MatchSource::ForLoopDesugar => span_bug!(span, \"for loop desugared to match with &-patterns!\"),\n-        MatchSource::TryDesugar => span_bug!(span, \"`?` operator desugared to match with &-patterns!\")\n+        MatchSource::TryDesugar => span_bug!(span, \"`?` operator desugared to match with &-patterns!\"),\n     }\n }\n \n@@ -432,13 +433,15 @@ pub fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &\n     impl<'a, T: Copy> Kind<'a, T> {\n         fn range(&self) -> &'a SpannedRange<T> {\n             match *self {\n-                Kind::Start(_, r) | Kind::End(_, r) => r,\n+                Kind::Start(_, r) |\n+                Kind::End(_, r) => r,\n             }\n         }\n \n         fn value(self) -> T {\n             match self {\n-                Kind::Start(t, _) | Kind::End(t, _) => t,\n+                Kind::Start(t, _) |\n+                Kind::End(t, _) => t,\n             }\n         }\n     }"}, {"sha": "4a31a564a3e63e0aa728e7e5746dab4b31b9f114", "filename": "src/methods.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -436,7 +436,8 @@ impl LateLintPass for MethodsPass {\n                     }\n \n                     let ret_ty = return_ty(cx, implitem.id);\n-                    if &name.as_str() == &\"new\" && !ret_ty.map_or(false, |ret_ty| ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem.id))) {\n+                    if &name.as_str() == &\"new\" &&\n+                       !ret_ty.map_or(false, |ret_ty| ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem.id))) {\n                         span_lint(cx,\n                                   NEW_RET_NO_SELF,\n                                   sig.explicit_self.span,\n@@ -946,7 +947,8 @@ impl SelfKind {\n             (&SelfKind::Ref, &SelfRegion(_, Mutability::MutImmutable, _)) |\n             (&SelfKind::RefMut, &SelfRegion(_, Mutability::MutMutable, _)) |\n             (&SelfKind::No, &SelfStatic) => true,\n-            (&SelfKind::Ref, &SelfValue(_)) | (&SelfKind::RefMut, &SelfValue(_)) => allow_value_for_ref,\n+            (&SelfKind::Ref, &SelfValue(_)) |\n+            (&SelfKind::RefMut, &SelfValue(_)) => allow_value_for_ref,\n             (_, &SelfExplicit(ref ty, _)) => self.matches_explicit_type(ty, allow_value_for_ref),\n             _ => false,\n         }"}, {"sha": "7cd2d33cab949ab9c487bcc554d4f8e43a9c6fcb", "filename": "src/minmax.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fminmax.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -34,7 +34,9 @@ impl LateLintPass for MinMaxPass {\n                     return;\n                 }\n                 match (outer_max, outer_c.partial_cmp(&inner_c)) {\n-                    (_, None) | (MinMax::Max, Some(Ordering::Less)) | (MinMax::Min, Some(Ordering::Greater)) => (),\n+                    (_, None) |\n+                    (MinMax::Max, Some(Ordering::Less)) |\n+                    (MinMax::Min, Some(Ordering::Greater)) => (),\n                     _ => {\n                         span_lint(cx, MIN_MAX, expr.span, \"this min/max combination leads to constant result\");\n                     }"}, {"sha": "7323f18a46e239a6777dfe88ad3245859a206475", "filename": "src/misc.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -226,7 +226,7 @@ impl LateLintPass for CmpOwned {\n \n fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: Span) {\n     let (arg_ty, snip) = match expr.node {\n-        ExprMethodCall(Spanned{node: ref name, ..}, _, ref args) if args.len() == 1 => {\n+        ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) if args.len() == 1 => {\n             if name.as_str() == \"to_string\" || name.as_str() == \"to_owned\" && is_str_arg(cx, args) {\n                 (cx.tcx.expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {\n@@ -309,7 +309,7 @@ impl LintPass for ModuloOne {\n impl LateLintPass for ModuloOne {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprBinary(ref cmp, _, ref right) = expr.node {\n-            if let Spanned {node: BinOp_::BiRem, ..} = *cmp {\n+            if let Spanned { node: BinOp_::BiRem, .. } = *cmp {\n                 if is_integer_literal(right, 1) {\n                     span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n                 }\n@@ -422,7 +422,8 @@ impl LateLintPass for UsedUnderscoreBinding {\n fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n     if let Some(ref parent) = get_parent_expr(cx, expr) {\n         match parent.node {\n-            ExprAssign(_, ref rhs) | ExprAssignOp(_, _, ref rhs) => **rhs == *expr,\n+            ExprAssign(_, ref rhs) |\n+            ExprAssignOp(_, _, ref rhs) => **rhs == *expr,\n             _ => is_used(cx, &parent),\n         }\n     } else {"}, {"sha": "b43359f29b98d0c983737d72e3392a637bdb1aa8", "filename": "src/misc_early.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc_early.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -134,11 +134,11 @@ impl EarlyLintPass for MiscEarly {\n                                        expr.span,\n                                        \"Try not to call a closure in the expression where it is declared.\",\n                                        |db| {\n-                                            if decl.inputs.is_empty() {\n-                                                let hint = format!(\"{}\", snippet(cx, block.span, \"..\"));\n-                                                db.span_suggestion(expr.span, \"Try doing something like: \", hint);\n-                                            }\n-                                        });\n+                                           if decl.inputs.is_empty() {\n+                                               let hint = format!(\"{}\", snippet(cx, block.span, \"..\"));\n+                                               db.span_suggestion(expr.span, \"Try doing something like: \", hint);\n+                                           }\n+                                       });\n                 }\n             }\n         }"}, {"sha": "7b7b5ecdf4e7918e816e9d8ccdf298d72bdccf7c", "filename": "src/mut_mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_mut.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -52,7 +52,7 @@ fn check_expr_mut(cx: &LateContext, expr: &Expr) {\n \n     unwrap_addr(expr).map_or((), |e| {\n         unwrap_addr(e).map_or_else(|| {\n-                                       if let TyRef(_, TypeAndMut{mutbl: MutMutable, ..}) = cx.tcx.expr_ty(e).sty {\n+                                       if let TyRef(_, TypeAndMut { mutbl: MutMutable, .. }) = cx.tcx.expr_ty(e).sty {\n                                            span_lint(cx,\n                                                      MUT_MUT,\n                                                      expr.span,\n@@ -71,7 +71,7 @@ fn check_expr_mut(cx: &LateContext, expr: &Expr) {\n \n fn unwrap_mut(ty: &Ty) -> Option<&Ty> {\n     match ty.node {\n-        TyRptr(_, MutTy{ ty: ref pty, mutbl: MutMutable }) => Some(pty),\n+        TyRptr(_, MutTy { ty: ref pty, mutbl: MutMutable }) => Some(pty),\n         _ => None,\n     }\n }"}, {"sha": "4ac4d83360ee65588e1fcdc55e49c716d8a29b1e", "filename": "src/mut_reference.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_reference.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -47,27 +47,28 @@ impl LateLintPass for UnnecessaryMutPassed {\n                 let method_type = borrowed_table.method_map.get(&method_call).expect(\"This should never happen.\");\n                 check_arguments(cx, &arguments, method_type.ty, &name.node.as_str())\n             }\n-            _ => {}\n+            _ => (),\n         }\n     }\n }\n \n fn check_arguments(cx: &LateContext, arguments: &[P<Expr>], type_definition: &TyS, name: &str) {\n     match type_definition.sty {\n-        TypeVariants::TyFnDef(_, _, ref fn_type) | TypeVariants::TyFnPtr(ref fn_type) => {\n+        TypeVariants::TyFnDef(_, _, ref fn_type) |\n+        TypeVariants::TyFnPtr(ref fn_type) => {\n             let parameters = &fn_type.sig.skip_binder().inputs;\n             for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n                 match parameter.sty {\n-                    TypeVariants::TyRef(_, TypeAndMut {mutbl: MutImmutable, ..}) |\n-                    TypeVariants::TyRawPtr(TypeAndMut {mutbl: MutImmutable, ..}) => {\n+                    TypeVariants::TyRef(_, TypeAndMut { mutbl: MutImmutable, .. }) |\n+                    TypeVariants::TyRawPtr(TypeAndMut { mutbl: MutImmutable, .. }) => {\n                         if let ExprAddrOf(MutMutable, _) = argument.node {\n                             span_lint(cx,\n                                       UNNECESSARY_MUT_PASSED,\n                                       argument.span,\n                                       &format!(\"The function/method \\\"{}\\\" doesn't need a mutable reference\", name));\n                         }\n                     }\n-                    _ => {}\n+                    _ => (),\n                 }\n             }\n         }"}, {"sha": "f95d6f5c9c1b5547a0ddceb3f9f8f8882841c8de", "filename": "src/needless_bool.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -57,9 +57,10 @@ impl LateLintPass for NeedlessBool {\n                 span_lint_and_then(cx,\n                                    NEEDLESS_BOOL,\n                                    e.span,\n-                                   \"this if-then-else expression returns a bool literal\", |db| {\n-                    db.span_suggestion(e.span, \"you can reduce it to\", hint);\n-                });\n+                                   \"this if-then-else expression returns a bool literal\",\n+                                   |db| {\n+                                       db.span_suggestion(e.span, \"you can reduce it to\", hint);\n+                                   });\n             };\n             match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n                 (RetBool(true), RetBool(true)) |\n@@ -98,7 +99,7 @@ impl LintPass for BoolComparison {\n impl LateLintPass for BoolComparison {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         use self::Expression::*;\n-        if let ExprBinary(Spanned{ node: BiEq, .. }, ref left_side, ref right_side) = e.node {\n+        if let ExprBinary(Spanned { node: BiEq, .. }, ref left_side, ref right_side) = e.node {\n             match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n                 (Bool(true), Other) => {\n                     let hint = snippet(cx, right_side.span, \"..\").into_owned();\n@@ -155,15 +156,17 @@ enum Expression {\n fn fetch_bool_block(block: &Block) -> Expression {\n     match (&*block.stmts, block.expr.as_ref()) {\n         ([], Some(e)) => fetch_bool_expr(&**e),\n-        ([ref e], None) => if let StmtSemi(ref e, _) = e.node {\n-            if let ExprRet(_) = e.node {\n-                fetch_bool_expr(&**e)\n+        ([ref e], None) => {\n+            if let StmtSemi(ref e, _) = e.node {\n+                if let ExprRet(_) = e.node {\n+                    fetch_bool_expr(&**e)\n+                } else {\n+                    Expression::Other\n+                }\n             } else {\n                 Expression::Other\n             }\n-        } else {\n-            Expression::Other\n-        },\n+        }\n         _ => Expression::Other,\n     }\n }\n@@ -177,11 +180,13 @@ fn fetch_bool_expr(expr: &Expr) -> Expression {\n             } else {\n                 Expression::Other\n             }\n-        },\n-        ExprRet(Some(ref expr)) => match fetch_bool_expr(expr) {\n-            Expression::Bool(value) => Expression::RetBool(value),\n-            _ => Expression::Other,\n-        },\n+        }\n+        ExprRet(Some(ref expr)) => {\n+            match fetch_bool_expr(expr) {\n+                Expression::Bool(value) => Expression::RetBool(value),\n+                _ => Expression::Other,\n+            }\n+        }\n         _ => Expression::Other,\n     }\n }"}, {"sha": "d928de415787209e20e89a0ca4285ac4fe8ee632", "filename": "src/no_effect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fno_effect.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -52,7 +52,8 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n             }\n         }\n         Expr_::ExprBlock(ref block) => {\n-            block.stmts.is_empty() && if let Some(ref expr) = block.expr {\n+            block.stmts.is_empty() &&\n+            if let Some(ref expr) = block.expr {\n                 has_no_effect(cx, expr)\n             } else {\n                 false"}, {"sha": "a6f0571c4993afaa9c8458876f975d3e97ebf384", "filename": "src/non_expressive_names.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnon_expressive_names.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -45,7 +45,7 @@ struct ExistingName {\n     interned: InternedString,\n     span: Span,\n     len: usize,\n-    whitelist: &'static[&'static str],\n+    whitelist: &'static [&'static str],\n }\n \n struct SimilarNamesLocalVisitor<'a, 'b: 'a> {\n@@ -57,6 +57,7 @@ struct SimilarNamesLocalVisitor<'a, 'b: 'a> {\n \n // this list contains lists of names that are allowed to be similar\n // the assumption is that no name is ever contained in multiple lists.\n+#[cfg_attr(rustfmt, rustfmt_skip)]\n const WHITELIST: &'static [&'static [&'static str]] = &[\n     &[\"parsed\", \"parser\"],\n     &[\"lhs\", \"rhs\"],\n@@ -75,7 +76,7 @@ impl<'v, 'a, 'b, 'c> visit::Visitor<'v> for SimilarNamesNameVisitor<'a, 'b, 'c>\n     }\n }\n \n-fn get_whitelist(interned_name: &str) -> Option<&'static[&'static str]> {\n+fn get_whitelist(interned_name: &str) -> Option<&'static [&'static str]> {\n     for &allow in WHITELIST {\n         if whitelisted(interned_name, allow) {\n             return Some(allow);\n@@ -112,8 +113,7 @@ impl<'a, 'b, 'c> SimilarNamesNameVisitor<'a, 'b, 'c> {\n             span_lint(self.0.cx,\n                       MANY_SINGLE_CHAR_NAMES,\n                       span,\n-                      &format!(\"{}th binding whose name is just one char\",\n-                               self.0.single_char_names.len()));\n+                      &format!(\"{}th binding whose name is just one char\", self.0.single_char_names.len()));\n         }\n     }\n     fn check_name(&mut self, span: Span, name: Name) {\n@@ -162,7 +162,8 @@ impl<'a, 'b, 'c> SimilarNamesNameVisitor<'a, 'b, 'c> {\n                     } else {\n                         let second_last_i = interned_chars.next_back().expect(\"we know we have at least three chars\");\n                         let second_last_e = existing_chars.next_back().expect(\"we know we have at least three chars\");\n-                        if !eq_or_numeric(second_last_i, second_last_e) || second_last_i == '_' || !interned_chars.zip(existing_chars).all(|(i, e)| eq_or_numeric(i, e)) {\n+                        if !eq_or_numeric(second_last_i, second_last_e) || second_last_i == '_' ||\n+                           !interned_chars.zip(existing_chars).all(|(i, e)| eq_or_numeric(i, e)) {\n                             // allowed similarity foo_x, foo_y\n                             // or too many chars differ (foo_x, boo_y) or (foox, booy)\n                             continue;\n@@ -172,7 +173,8 @@ impl<'a, 'b, 'c> SimilarNamesNameVisitor<'a, 'b, 'c> {\n                 } else {\n                     let second_i = interned_chars.next().expect(\"we know we have at least two chars\");\n                     let second_e = existing_chars.next().expect(\"we know we have at least two chars\");\n-                    if !eq_or_numeric(second_i, second_e) || second_i == '_' || !interned_chars.zip(existing_chars).all(|(i, e)| eq_or_numeric(i, e)) {\n+                    if !eq_or_numeric(second_i, second_e) || second_i == '_' ||\n+                       !interned_chars.zip(existing_chars).all(|(i, e)| eq_or_numeric(i, e)) {\n                         // allowed similarity x_foo, y_foo\n                         // or too many chars differ (x_foo, y_boo) or (xfoo, yboo)\n                         continue;\n@@ -187,10 +189,11 @@ impl<'a, 'b, 'c> SimilarNamesNameVisitor<'a, 'b, 'c> {\n                                |diag| {\n                                    diag.span_note(existing_name.span, \"existing binding defined here\");\n                                    if let Some(split) = split_at {\n-                                       diag.span_help(span, &format!(\"separate the discriminating character \\\n-                                                                      by an underscore like: `{}_{}`\",\n-                                                                     &interned_name[..split],\n-                                                                     &interned_name[split..]));\n+                                       diag.span_help(span,\n+                                                      &format!(\"separate the discriminating character by an \\\n+                                                                underscore like: `{}_{}`\",\n+                                                               &interned_name[..split],\n+                                                               &interned_name[split..]));\n                                    }\n                                });\n             return;"}, {"sha": "1d760599e3fb5d10f9a32fa94c55b9074399120a", "filename": "src/open_options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fopen_options.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -65,7 +65,7 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n \n             let argument_option = match arguments[1].node {\n                 ExprLit(ref span) => {\n-                    if let Spanned {node: LitKind::Bool(lit), ..} = **span {\n+                    if let Spanned { node: LitKind::Bool(lit), .. } = **span {\n                         if lit {\n                             Argument::True\n                         } else {\n@@ -96,7 +96,7 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n                 \"write\" => {\n                     options.push((OpenOption::Write, argument_option));\n                 }\n-                _ => {}\n+                _ => (),\n             }\n \n             get_open_options(cx, &arguments[0], options);"}, {"sha": "6a8ca368fc143ab57f9005802ba262715be2e139", "filename": "src/overflow_check_conditional.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow_check_conditional.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir::*;\n-use utils::{span_lint};\n+use utils::span_lint;\n \n /// **What it does:** This lint finds classic underflow / overflow checks.\n ///"}, {"sha": "825a1b84450d275748eb87d5c8d3b643ea5e3dba", "filename": "src/precedence.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprecedence.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -31,7 +31,7 @@ impl LintPass for Precedence {\n \n impl EarlyLintPass for Precedence {\n     fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n-        if let ExprKind::Binary(Spanned { node: op, ..}, ref left, ref right) = expr.node {\n+        if let ExprKind::Binary(Spanned { node: op, .. }, ref left, ref right) = expr.node {\n             if !is_bit_op(op) {\n                 return;\n             }\n@@ -75,7 +75,9 @@ impl EarlyLintPass for Precedence {\n                 if let Some(slf) = args.first() {\n                     if let ExprKind::Lit(ref lit) = slf.node {\n                         match lit.node {\n-                            LitKind::Int(..) | LitKind::Float(..) | LitKind::FloatUnsuffixed(..) => {\n+                            LitKind::Int(..) |\n+                            LitKind::Float(..) |\n+                            LitKind::FloatUnsuffixed(..) => {\n                                 span_lint(cx,\n                                           PRECEDENCE,\n                                           expr.span,\n@@ -94,7 +96,7 @@ impl EarlyLintPass for Precedence {\n \n fn is_arith_expr(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprKind::Binary(Spanned { node: op, ..}, _, _) => is_arith_op(op),\n+        ExprKind::Binary(Spanned { node: op, .. }, _, _) => is_arith_op(op),\n         _ => false,\n     }\n }"}, {"sha": "3bd17a2d365851457f972bfc860ae25fc68e0430", "filename": "src/regex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fregex.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -167,14 +167,14 @@ fn is_trivial_regex(s: &regex_syntax::Expr) -> Option<&'static str> {\n \n     match *s {\n         Expr::Empty | Expr::StartText | Expr::EndText => Some(\"the regex is unlikely to be useful as it is\"),\n-        Expr::Literal {..} => Some(\"consider using `str::contains`\"),\n+        Expr::Literal { .. } => Some(\"consider using `str::contains`\"),\n         Expr::Concat(ref exprs) => {\n             match exprs.len() {\n                 2 => {\n                     match (&exprs[0], &exprs[1]) {\n                         (&Expr::StartText, &Expr::EndText) => Some(\"consider using `str::is_empty`\"),\n-                        (&Expr::StartText, &Expr::Literal {..}) => Some(\"consider using `str::starts_with`\"),\n-                        (&Expr::Literal {..}, &Expr::EndText) => Some(\"consider using `str::ends_with`\"),\n+                        (&Expr::StartText, &Expr::Literal { .. }) => Some(\"consider using `str::starts_with`\"),\n+                        (&Expr::Literal { .. }, &Expr::EndText) => Some(\"consider using `str::ends_with`\"),\n                         _ => None,\n                     }\n                 }"}, {"sha": "d78938212634ba6e39366f1689a500390880ce0f", "filename": "src/returns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freturns.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -71,7 +71,7 @@ impl ReturnPass {\n                     self.check_final_expr(cx, &arm.body);\n                 }\n             }\n-            _ => {}\n+            _ => (),\n         }\n     }\n "}, {"sha": "bb287f449e3f85a78cd23e6333f12c94361852ca", "filename": "src/shadow.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -77,7 +77,8 @@ fn check_block(cx: &LateContext, block: &Block, bindings: &mut Vec<(Name, Span)>\n     for stmt in &block.stmts {\n         match stmt.node {\n             StmtDecl(ref decl, _) => check_decl(cx, decl, bindings),\n-            StmtExpr(ref e, _) | StmtSemi(ref e, _) => check_expr(cx, e, bindings),\n+            StmtExpr(ref e, _) |\n+            StmtSemi(ref e, _) => check_expr(cx, e, bindings),\n         }\n     }\n     if let Some(ref o) = block.expr {\n@@ -94,7 +95,7 @@ fn check_decl(cx: &LateContext, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n         return;\n     }\n     if let DeclLocal(ref local) = decl.node {\n-        let Local{ ref pat, ref ty, ref init, span, .. } = **local;\n+        let Local { ref pat, ref ty, ref init, span, .. } = **local;\n         if let Some(ref t) = *ty {\n             check_ty(cx, t, bindings)\n         }\n@@ -109,7 +110,8 @@ fn check_decl(cx: &LateContext, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n \n fn is_binding(cx: &LateContext, pat: &Pat) -> bool {\n     match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-        Some(Def::Variant(..)) | Some(Def::Struct(..)) => false,\n+        Some(Def::Variant(..)) |\n+        Some(Def::Struct(..)) => false,\n         _ => true,\n     }\n }\n@@ -251,7 +253,8 @@ fn check_expr(cx: &LateContext, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n         ExprTupField(ref e, _) |\n         ExprAddrOf(_, ref e) |\n         ExprBox(ref e) => check_expr(cx, e, bindings),\n-        ExprBlock(ref block) | ExprLoop(ref block, _) => check_block(cx, block, bindings),\n+        ExprBlock(ref block) |\n+        ExprLoop(ref block, _) => check_block(cx, block, bindings),\n         // ExprCall\n         // ExprMethodCall\n         ExprVec(ref v) | ExprTup(ref v) => {\n@@ -297,8 +300,8 @@ fn check_ty(cx: &LateContext, ty: &Ty, bindings: &mut Vec<(Name, Span)>) {\n             check_ty(cx, fty, bindings);\n             check_expr(cx, expr, bindings);\n         }\n-        TyPtr(MutTy{ ty: ref mty, .. }) |\n-        TyRptr(_, MutTy{ ty: ref mty, .. }) => check_ty(cx, mty, bindings),\n+        TyPtr(MutTy { ty: ref mty, .. }) |\n+        TyRptr(_, MutTy { ty: ref mty, .. }) => check_ty(cx, mty, bindings),\n         TyTup(ref tup) => {\n             for ref t in tup {\n                 check_ty(cx, t, bindings)"}, {"sha": "92bce8d0e4201e1fcd131dbf2c1d8dbae433ae32", "filename": "src/strings.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -74,7 +74,7 @@ impl LintPass for StringAdd {\n \n impl LateLintPass for StringAdd {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n-        if let ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) = e.node {\n+        if let ExprBinary(Spanned { node: BiAdd, .. }, ref left, _) = e.node {\n             if is_string(cx, left) {\n                 if let Allow = cx.current_level(STRING_ADD_ASSIGN) {\n                     // the string_add_assign is allow, so no duplicates\n@@ -112,7 +112,7 @@ fn is_string(cx: &LateContext, e: &Expr) -> bool {\n \n fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {\n     match src.node {\n-        ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n+        ExprBinary(Spanned { node: BiAdd, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n         ExprBlock(ref block) => {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| is_add(cx, expr, target))\n         }\n@@ -145,8 +145,7 @@ impl LateLintPass for StringLitAsBytes {\n                                                e.span,\n                                                \"calling `as_bytes()` on a string literal\",\n                                                |db| {\n-                                                   let sugg = format!(\"b{}\",\n-                                                                      snippet(cx, args[0].span, r#\"\"foo\"\"#));\n+                                                   let sugg = format!(\"b{}\", snippet(cx, args[0].span, r#\"\"foo\"\"#));\n                                                    db.span_suggestion(e.span,\n                                                                       \"consider using a byte string literal instead\",\n                                                                       sugg);"}, {"sha": "1496a45dac2499ae445fd5183c4eed2d9246ea25", "filename": "src/temporary_assignment.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftemporary_assignment.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -18,8 +18,7 @@ declare_lint! {\n \n fn is_temporary(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprStruct(..) |\n-        ExprTup(..) => true,\n+        ExprStruct(..) | ExprTup(..) => true,\n         _ => false,\n     }\n }\n@@ -37,7 +36,8 @@ impl LateLintPass for TemporaryAssignmentPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprAssign(ref target, _) = expr.node {\n             match target.node {\n-                ExprField(ref base, _) | ExprTupField(ref base, _) => {\n+                ExprField(ref base, _) |\n+                ExprTupField(ref base, _) => {\n                     if is_temporary(base) && !is_adjusted(cx, base) {\n                         span_lint(cx, TEMPORARY_ASSIGNMENT, expr.span, \"assignment to temporary\");\n                     }"}, {"sha": "2217fd59bd96594f4901c79bc73d7719f8ac20c3", "filename": "src/transmute.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftransmute.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -52,11 +52,7 @@ pub struct Transmute;\n \n impl LintPass for Transmute {\n     fn get_lints(&self) -> LintArray {\n-        lint_array! [\n-            CROSSPOINTER_TRANSMUTE,\n-            TRANSMUTE_PTR_TO_REF,\n-            USELESS_TRANSMUTE\n-        ]\n+        lint_array![CROSSPOINTER_TRANSMUTE, TRANSMUTE_PTR_TO_REF, USELESS_TRANSMUTE]\n     }\n }\n \n@@ -79,12 +75,16 @@ impl LateLintPass for Transmute {\n                         span_lint(cx,\n                                   CROSSPOINTER_TRANSMUTE,\n                                   e.span,\n-                                  &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\", from_ty, to_ty));\n+                                  &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n+                                           from_ty,\n+                                           to_ty));\n                     } else if is_ptr_to(from_ty, to_ty) {\n                         span_lint(cx,\n                                   CROSSPOINTER_TRANSMUTE,\n                                   e.span,\n-                                  &format!(\"transmute from a type (`{}`) to the type that it points to (`{}`)\", from_ty, to_ty));\n+                                  &format!(\"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n+                                           from_ty,\n+                                           to_ty));\n                     } else {\n                         check_ptr_to_ref(cx, from_ty, to_ty, e, &args[0]);\n                     }\n@@ -102,10 +102,7 @@ fn is_ptr_to(from: ty::Ty, to: ty::Ty) -> bool {\n     }\n }\n \n-fn check_ptr_to_ref<'tcx>(cx: &LateContext,\n-                          from_ty: ty::Ty<'tcx>,\n-                          to_ty: ty::Ty<'tcx>,\n-                          e: &Expr, arg: &Expr) {\n+fn check_ptr_to_ref<'tcx>(cx: &LateContext, from_ty: ty::Ty<'tcx>, to_ty: ty::Ty<'tcx>, e: &Expr, arg: &Expr) {\n     if let TyRawPtr(ref from_pty) = from_ty.sty {\n         if let TyRef(_, ref to_rty) = to_ty.sty {\n             let mess = format!(\"transmute from a pointer type (`{}`) to a reference type (`{}`)\",\n@@ -122,8 +119,7 @@ fn check_ptr_to_ref<'tcx>(cx: &LateContext,\n \n                     let sugg = if from_pty.ty == to_rty.ty {\n                         format!(\"{}{}\", deref, arg)\n-                    }\n-                    else {\n+                    } else {\n                         format!(\"{}({} as {} {})\", deref, arg, cast, to_rty.ty)\n                     };\n "}, {"sha": "43d42cde501866984706b1de4b1e0b2b43f74cf0", "filename": "src/types.rs", "status": "modified", "additions": 64, "deletions": 44, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -248,7 +248,8 @@ fn int_ty_to_nbits(typ: &ty::TyS) -> usize {\n \n fn is_isize_or_usize(typ: &ty::TyS) -> bool {\n     match typ.sty {\n-        ty::TyInt(IntTy::Is) | ty::TyUint(UintTy::Us) => true,\n+        ty::TyInt(IntTy::Is) |\n+        ty::TyUint(UintTy::Us) => true,\n         _ => false,\n     }\n }\n@@ -536,9 +537,7 @@ impl<'v> Visitor<'v> for TypeComplexityVisitor {\n     fn visit_ty(&mut self, ty: &'v Ty) {\n         let (add_score, sub_nest) = match ty.node {\n             // _, &x and *x have only small overhead; don't mess with nesting level\n-            TyInfer |\n-            TyPtr(..) |\n-            TyRptr(..) => (1, 0),\n+            TyInfer | TyPtr(..) | TyRptr(..) => (1, 0),\n \n             // the \"normal\" components of a type: named types, arrays/tuples\n             TyPath(..) |\n@@ -663,17 +662,17 @@ fn detect_absurd_comparison<'a>(cx: &LateContext, op: BinOp_, lhs: &'a Expr, rhs\n     Some(match rel {\n         Rel::Lt => {\n             match (lx, rx) {\n-                (Some(l @ Extr { which: Maximum, ..}), _) => (l, AlwaysFalse), // max < x\n-                (_, Some(r @ Extr { which: Minimum, ..})) => (r, AlwaysFalse), // x < min\n+                (Some(l @ Extr { which: Maximum, .. }), _) => (l, AlwaysFalse), // max < x\n+                (_, Some(r @ Extr { which: Minimum, .. })) => (r, AlwaysFalse), // x < min\n                 _ => return None,\n             }\n         }\n         Rel::Le => {\n             match (lx, rx) {\n-                (Some(l @ Extr { which: Minimum, ..}), _) => (l, AlwaysTrue), // min <= x\n-                (Some(l @ Extr { which: Maximum, ..}), _) => (l, InequalityImpossible), //max <= x\n-                (_, Some(r @ Extr { which: Minimum, ..})) => (r, InequalityImpossible), // x <= min\n-                (_, Some(r @ Extr { which: Maximum, ..})) => (r, AlwaysTrue), // x <= max\n+                (Some(l @ Extr { which: Minimum, .. }), _) => (l, AlwaysTrue), // min <= x\n+                (Some(l @ Extr { which: Maximum, .. }), _) => (l, InequalityImpossible), //max <= x\n+                (_, Some(r @ Extr { which: Minimum, .. })) => (r, InequalityImpossible), // x <= min\n+                (_, Some(r @ Extr { which: Maximum, .. })) => (r, AlwaysTrue), // x <= max\n                 _ => return None,\n             }\n         }\n@@ -702,14 +701,12 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n \n     let which = match (ty, cv) {\n         (&ty::TyBool, Bool(false)) |\n-\n         (&ty::TyInt(IntTy::Is), Integral(Isize(Is32(::std::i32::MIN)))) |\n         (&ty::TyInt(IntTy::Is), Integral(Isize(Is64(::std::i64::MIN)))) |\n         (&ty::TyInt(IntTy::I8), Integral(I8(::std::i8::MIN))) |\n         (&ty::TyInt(IntTy::I16), Integral(I16(::std::i16::MIN))) |\n         (&ty::TyInt(IntTy::I32), Integral(I32(::std::i32::MIN))) |\n         (&ty::TyInt(IntTy::I64), Integral(I64(::std::i64::MIN))) |\n-\n         (&ty::TyUint(UintTy::Us), Integral(Usize(Us32(::std::u32::MIN)))) |\n         (&ty::TyUint(UintTy::Us), Integral(Usize(Us64(::std::u64::MIN)))) |\n         (&ty::TyUint(UintTy::U8), Integral(U8(::std::u8::MIN))) |\n@@ -718,14 +715,12 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n         (&ty::TyUint(UintTy::U64), Integral(U64(::std::u64::MIN))) => Minimum,\n \n         (&ty::TyBool, Bool(true)) |\n-\n         (&ty::TyInt(IntTy::Is), Integral(Isize(Is32(::std::i32::MAX)))) |\n         (&ty::TyInt(IntTy::Is), Integral(Isize(Is64(::std::i64::MAX)))) |\n         (&ty::TyInt(IntTy::I8), Integral(I8(::std::i8::MAX))) |\n         (&ty::TyInt(IntTy::I16), Integral(I16(::std::i16::MAX))) |\n         (&ty::TyInt(IntTy::I32), Integral(I32(::std::i32::MAX))) |\n         (&ty::TyInt(IntTy::I64), Integral(I64(::std::i64::MAX))) |\n-\n         (&ty::TyUint(UintTy::Us), Integral(Usize(Us32(::std::u32::MAX)))) |\n         (&ty::TyUint(UintTy::Us), Integral(Usize(Us64(::std::u64::MAX)))) |\n         (&ty::TyUint(UintTy::U8), Integral(U8(::std::u8::MAX))) |\n@@ -845,22 +840,26 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n     use syntax::ast::{IntTy, UintTy};\n     use std::*;\n \n-    if let ExprCast(ref cast_exp,_) = expr.node {\n+    if let ExprCast(ref cast_exp, _) = expr.node {\n         match cx.tcx.expr_ty(cast_exp).sty {\n-            TyInt(int_ty) => Some(match int_ty {\n-                IntTy::I8 => (FullInt::S(i8::min_value() as i64), FullInt::S(i8::max_value() as i64)),\n-                IntTy::I16 => (FullInt::S(i16::min_value() as i64), FullInt::S(i16::max_value() as i64)),\n-                IntTy::I32 => (FullInt::S(i32::min_value() as i64), FullInt::S(i32::max_value() as i64)),\n-                IntTy::I64 => (FullInt::S(i64::min_value() as i64), FullInt::S(i64::max_value() as i64)),\n-                IntTy::Is => (FullInt::S(isize::min_value() as i64), FullInt::S(isize::max_value() as i64)),\n-            }),\n-            TyUint(uint_ty) => Some(match uint_ty {\n-                UintTy::U8 => (FullInt::U(u8::min_value() as u64), FullInt::U(u8::max_value() as u64)),\n-                UintTy::U16 => (FullInt::U(u16::min_value() as u64), FullInt::U(u16::max_value() as u64)),\n-                UintTy::U32 => (FullInt::U(u32::min_value() as u64), FullInt::U(u32::max_value() as u64)),\n-                UintTy::U64 => (FullInt::U(u64::min_value() as u64), FullInt::U(u64::max_value() as u64)),\n-                UintTy::Us => (FullInt::U(usize::min_value() as u64), FullInt::U(usize::max_value() as u64)),\n-            }),\n+            TyInt(int_ty) => {\n+                Some(match int_ty {\n+                    IntTy::I8 => (FullInt::S(i8::min_value() as i64), FullInt::S(i8::max_value() as i64)),\n+                    IntTy::I16 => (FullInt::S(i16::min_value() as i64), FullInt::S(i16::max_value() as i64)),\n+                    IntTy::I32 => (FullInt::S(i32::min_value() as i64), FullInt::S(i32::max_value() as i64)),\n+                    IntTy::I64 => (FullInt::S(i64::min_value() as i64), FullInt::S(i64::max_value() as i64)),\n+                    IntTy::Is => (FullInt::S(isize::min_value() as i64), FullInt::S(isize::max_value() as i64)),\n+                })\n+            }\n+            TyUint(uint_ty) => {\n+                Some(match uint_ty {\n+                    UintTy::U8 => (FullInt::U(u8::min_value() as u64), FullInt::U(u8::max_value() as u64)),\n+                    UintTy::U16 => (FullInt::U(u16::min_value() as u64), FullInt::U(u16::max_value() as u64)),\n+                    UintTy::U32 => (FullInt::U(u32::min_value() as u64), FullInt::U(u32::max_value() as u64)),\n+                    UintTy::U64 => (FullInt::U(u64::min_value() as u64), FullInt::U(u64::max_value() as u64)),\n+                    UintTy::Us => (FullInt::U(usize::min_value() as u64), FullInt::U(usize::max_value() as u64)),\n+                })\n+            }\n             _ => None,\n         }\n     } else {\n@@ -885,29 +884,26 @@ fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n             } else {\n                 None\n             }\n-        },\n+        }\n         Err(_) => None,\n     }\n }\n \n fn err_upcast_comparison(cx: &LateContext, span: &Span, expr: &Expr, always: bool) {\n     if let ExprCast(ref cast_val, _) = expr.node {\n-        span_lint(\n-            cx,\n-            INVALID_UPCAST_COMPARISONS,\n-            *span,\n-            &format!(\n+        span_lint(cx,\n+                  INVALID_UPCAST_COMPARISONS,\n+                  *span,\n+                  &format!(\n                 \"because of the numeric bounds on `{}` prior to casting, this expression is always {}\",\n                 snippet(cx, cast_val.span, \"the expression\"),\n                 if always { \"true\" } else { \"false\" },\n-            )\n-        );\n+            ));\n     }\n }\n \n-fn upcast_comparison_bounds_err(\n-        cx: &LateContext, span: &Span, rel: comparisons::Rel,\n-        lhs_bounds: Option<(FullInt, FullInt)>, lhs: &Expr, rhs: &Expr, invert: bool) {\n+fn upcast_comparison_bounds_err(cx: &LateContext, span: &Span, rel: comparisons::Rel,\n+                                lhs_bounds: Option<(FullInt, FullInt)>, lhs: &Expr, rhs: &Expr, invert: bool) {\n     use utils::comparisons::*;\n \n     if let Some((lb, ub)) = lhs_bounds {\n@@ -917,14 +913,38 @@ fn upcast_comparison_bounds_err(\n                     err_upcast_comparison(cx, &span, lhs, rel == Rel::Ne);\n                 }\n             } else if match rel {\n-                Rel::Lt => if invert { norm_rhs_val < lb } else { ub < norm_rhs_val },\n-                Rel::Le => if invert { norm_rhs_val <= lb  } else { ub <= norm_rhs_val },\n+                Rel::Lt => {\n+                    if invert {\n+                        norm_rhs_val < lb\n+                    } else {\n+                        ub < norm_rhs_val\n+                    }\n+                }\n+                Rel::Le => {\n+                    if invert {\n+                        norm_rhs_val <= lb\n+                    } else {\n+                        ub <= norm_rhs_val\n+                    }\n+                }\n                 Rel::Eq | Rel::Ne => unreachable!(),\n             } {\n                 err_upcast_comparison(cx, &span, lhs, true)\n             } else if match rel {\n-                Rel::Lt => if invert { norm_rhs_val >= ub } else { lb >= norm_rhs_val },\n-                Rel::Le => if invert { norm_rhs_val > ub } else { lb > norm_rhs_val },\n+                Rel::Lt => {\n+                    if invert {\n+                        norm_rhs_val >= ub\n+                    } else {\n+                        lb >= norm_rhs_val\n+                    }\n+                }\n+                Rel::Le => {\n+                    if invert {\n+                        norm_rhs_val > ub\n+                    } else {\n+                        lb > norm_rhs_val\n+                    }\n+                }\n                 Rel::Eq | Rel::Ne => unreachable!(),\n             } {\n                 err_upcast_comparison(cx, &span, lhs, false)"}, {"sha": "e773cc0e02505f49838614c8df4b2b6ece21176b", "filename": "src/utils/conf.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fconf.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -8,7 +8,8 @@ use toml;\n pub fn conf_file(args: &[ptr::P<ast::MetaItem>]) -> Result<Option<token::InternedString>, (&'static str, codemap::Span)> {\n     for arg in args {\n         match arg.node {\n-            ast::MetaItemKind::Word(ref name) | ast::MetaItemKind::List(ref name, _) => {\n+            ast::MetaItemKind::Word(ref name) |\n+            ast::MetaItemKind::List(ref name, _) => {\n                 if name == &\"conf_file\" {\n                     return Err((\"`conf_file` must be a named value\", arg.span));\n                 }"}, {"sha": "379812a283d5e25aec93e9921949342b9a57eafa", "filename": "src/utils/hir.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fhir.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -76,7 +76,9 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&ExprBlock(ref l), &ExprBlock(ref r)) => self.eq_block(l, r),\n             (&ExprBinary(l_op, ref ll, ref lr), &ExprBinary(r_op, ref rl, ref rr)) => {\n                 l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr) ||\n-                swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr))\n+                swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| {\n+                    l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                })\n             }\n             (&ExprBreak(li), &ExprBreak(ri)) => both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str()),\n             (&ExprBox(ref l), &ExprBox(ref r)) => self.eq_expr(l, r),\n@@ -114,9 +116,8 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 both(l_qself, r_qself, |l, r| self.eq_qself(l, r)) && self.eq_path(l_subpath, r_subpath)\n             }\n             (&ExprStruct(ref l_path, ref lf, ref lo), &ExprStruct(ref r_path, ref rf, ref ro)) => {\n-                self.eq_path(l_path, r_path) &&\n-                    both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n-                    over(lf, rf, |l, r| self.eq_field(l, r))\n+                self.eq_path(l_path, r_path) && both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n+                over(lf, rf, |l, r| self.eq_field(l, r))\n             }\n             (&ExprTup(ref l_tup), &ExprTup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n             (&ExprTupField(ref le, li), &ExprTupField(ref re, ri)) => li.node == ri.node && self.eq_expr(le, re),"}, {"sha": "d8f5a0757b79f734ca49857c773f50fd06cb9735", "filename": "src/utils/mod.rs", "status": "modified", "additions": 40, "deletions": 13, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -144,7 +144,8 @@ pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n /// Check if type is struct or enum type with given def path.\n pub fn match_type(cx: &LateContext, ty: ty::Ty, path: &[&str]) -> bool {\n     match ty.sty {\n-        ty::TyEnum(ref adt, _) | ty::TyStruct(ref adt, _) => match_def_path(cx, adt.did, path),\n+        ty::TyEnum(ref adt, _) |\n+        ty::TyStruct(ref adt, _) => match_def_path(cx, adt.did, path),\n         _ => false,\n     }\n }\n@@ -304,9 +305,9 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.map.get_parent(expr.id);\n     match cx.tcx.map.find(parent_id) {\n-        Some(Node::NodeItem(&Item{ ref name, .. })) |\n-        Some(Node::NodeTraitItem(&TraitItem{ ref name, .. })) |\n-        Some(Node::NodeImplItem(&ImplItem{ ref name, .. })) => Some(*name),\n+        Some(Node::NodeItem(&Item { ref name, .. })) |\n+        Some(Node::NodeTraitItem(&TraitItem { ref name, .. })) |\n+        Some(Node::NodeImplItem(&ImplItem { ref name, .. })) => Some(*name),\n         _ => None,\n     }\n }\n@@ -431,7 +432,7 @@ pub fn get_enclosing_block<'c>(cx: &'c LateContext, node: NodeId) -> Option<&'c\n     if let Some(node) = enclosing_node {\n         match node {\n             Node::NodeBlock(ref block) => Some(block),\n-            Node::NodeItem(&Item{ node: ItemFn(_, _, _, _, _, ref block), .. }) => Some(block),\n+            Node::NodeItem(&Item { node: ItemFn(_, _, _, _, _, ref block), .. }) => Some(block),\n             _ => None,\n         }\n     } else {\n@@ -517,7 +518,8 @@ pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint,\n /// Return the base type for references and raw pointers.\n pub fn walk_ptrs_ty(ty: ty::Ty) -> ty::Ty {\n     match ty.sty {\n-        ty::TyRef(_, ref tm) | ty::TyRawPtr(ref tm) => walk_ptrs_ty(tm.ty),\n+        ty::TyRef(_, ref tm) |\n+        ty::TyRawPtr(ref tm) => walk_ptrs_ty(tm.ty),\n         _ => ty,\n     }\n }\n@@ -526,7 +528,8 @@ pub fn walk_ptrs_ty(ty: ty::Ty) -> ty::Ty {\n pub fn walk_ptrs_ty_depth(ty: ty::Ty) -> (ty::Ty, usize) {\n     fn inner(ty: ty::Ty, depth: usize) -> (ty::Ty, usize) {\n         match ty.sty {\n-            ty::TyRef(_, ref tm) | ty::TyRawPtr(ref tm) => inner(tm.ty, depth + 1),\n+            ty::TyRef(_, ref tm) |\n+            ty::TyRawPtr(ref tm) => inner(tm.ty, depth + 1),\n             _ => (ty, depth),\n         }\n     }\n@@ -730,22 +733,46 @@ pub fn unsugar_range(expr: &Expr) -> Option<UnsugaredRange> {\n     match unwrap_unstable(&expr).node {\n         ExprPath(None, ref path) => {\n             if match_path(path, &paths::RANGE_FULL) {\n-                Some(UnsugaredRange { start: None, end: None, limits: RangeLimits::HalfOpen })\n+                Some(UnsugaredRange {\n+                    start: None,\n+                    end: None,\n+                    limits: RangeLimits::HalfOpen,\n+                })\n             } else {\n                 None\n             }\n         }\n         ExprStruct(ref path, ref fields, None) => {\n             if match_path(path, &paths::RANGE_FROM) {\n-                Some(UnsugaredRange { start: get_field(\"start\", fields), end: None, limits: RangeLimits::HalfOpen })\n+                Some(UnsugaredRange {\n+                    start: get_field(\"start\", fields),\n+                    end: None,\n+                    limits: RangeLimits::HalfOpen,\n+                })\n             } else if match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY) {\n-                Some(UnsugaredRange { start: get_field(\"start\", fields), end: get_field(\"end\", fields), limits: RangeLimits::Closed })\n+                Some(UnsugaredRange {\n+                    start: get_field(\"start\", fields),\n+                    end: get_field(\"end\", fields),\n+                    limits: RangeLimits::Closed,\n+                })\n             } else if match_path(path, &paths::RANGE) {\n-                Some(UnsugaredRange { start: get_field(\"start\", fields), end: get_field(\"end\", fields), limits: RangeLimits::HalfOpen })\n+                Some(UnsugaredRange {\n+                    start: get_field(\"start\", fields),\n+                    end: get_field(\"end\", fields),\n+                    limits: RangeLimits::HalfOpen,\n+                })\n             } else if match_path(path, &paths::RANGE_TO_INCLUSIVE) {\n-                Some(UnsugaredRange { start: None, end: get_field(\"end\", fields), limits: RangeLimits::Closed })\n+                Some(UnsugaredRange {\n+                    start: None,\n+                    end: get_field(\"end\", fields),\n+                    limits: RangeLimits::Closed,\n+                })\n             } else if match_path(path, &paths::RANGE_TO) {\n-                Some(UnsugaredRange { start: None, end: get_field(\"end\", fields), limits: RangeLimits::HalfOpen })\n+                Some(UnsugaredRange {\n+                    start: None,\n+                    end: get_field(\"end\", fields),\n+                    limits: RangeLimits::HalfOpen,\n+                })\n             } else {\n                 None\n             }"}, {"sha": "63b9952c3c824a6995d69bbd110d3948607b25c1", "filename": "src/vec.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a878916ad54eba5e92a3e6f0906e5099b26815d1/src%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvec.rs?ref=a878916ad54eba5e92a3e6f0906e5099b26815d1", "patch": "@@ -63,8 +63,7 @@ fn check_vec_macro(cx: &LateContext, expr: &Expr, vec: &Expr) {\n                     };\n \n                     format!(\"&[{}]\", snippet(cx, span, \"..\")).into()\n-                }\n-                else {\n+                } else {\n                     \"&[]\".into()\n                 }\n             }"}]}