{"sha": "d1b993c0aacb2a29fc87283a8b35fe1b4a542459", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxYjk5M2MwYWFjYjJhMjlmYzg3MjgzYThiMzVmZTFiNGE1NDI0NTk=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-05T10:21:28Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-05T10:21:28Z"}, "message": "Merge #255\n\n255: Binders r=matklad a=matklad\n\nBinding sources to hir is a fuzzy operation, so let's move it to a special enclave in the source code. \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "615c68873a325a02be8e21e1bd4dcb9ce8ab6a1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/615c68873a325a02be8e21e1bd4dcb9ce8ab6a1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1b993c0aacb2a29fc87283a8b35fe1b4a542459", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1b993c0aacb2a29fc87283a8b35fe1b4a542459", "html_url": "https://github.com/rust-lang/rust/commit/d1b993c0aacb2a29fc87283a8b35fe1b4a542459", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1b993c0aacb2a29fc87283a8b35fe1b4a542459/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "7960c8b27681ebeb72d83930c4a2bbf43a982c52", "url": "https://api.github.com/repos/rust-lang/rust/commits/7960c8b27681ebeb72d83930c4a2bbf43a982c52", "html_url": "https://github.com/rust-lang/rust/commit/7960c8b27681ebeb72d83930c4a2bbf43a982c52"}, {"sha": "db456749a85e87cdbe3f87b85bf44446d9d5694b", "url": "https://api.github.com/repos/rust-lang/rust/commits/db456749a85e87cdbe3f87b85bf44446d9d5694b", "html_url": "https://github.com/rust-lang/rust/commit/db456749a85e87cdbe3f87b85bf44446d9d5694b"}], "stats": {"total": 265, "additions": 125, "deletions": 140}, "files": [{"sha": "0f154112a963f6846297473862bf1f35e268ab92", "filename": "crates/ra_analysis/src/completion/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1b993c0aacb2a29fc87283a8b35fe1b4a542459/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1b993c0aacb2a29fc87283a8b35fe1b4a542459/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs?ref=d1b993c0aacb2a29fc87283a8b35fe1b4a542459", "patch": "@@ -9,6 +9,7 @@ use ra_syntax::{\n };\n use ra_db::SyntaxDatabase;\n use rustc_hash::{FxHashMap};\n+use hir::source_binder;\n \n use crate::{\n     db,\n@@ -36,7 +37,7 @@ pub(crate) fn completions(\n         original_file.reparse(&edit)\n     };\n \n-    let module = ctry!(hir::Module::guess_from_position(db, position)?);\n+    let module = ctry!(source_binder::module_from_position(db, position)?);\n \n     let mut res = Vec::new();\n     let mut has_completions = false;"}, {"sha": "975afc1456258eb2fa1f92de4afa550184e1a419", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d1b993c0aacb2a29fc87283a8b35fe1b4a542459/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1b993c0aacb2a29fc87283a8b35fe1b4a542459/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=d1b993c0aacb2a29fc87283a8b35fe1b4a542459", "patch": "@@ -16,6 +16,7 @@ use rustc_hash::FxHashSet;\n use salsa::{Database, ParallelDatabase};\n use hir::{\n     self,\n+    source_binder,\n     FnSignatureInfo,\n     Problem,\n };\n@@ -166,7 +167,7 @@ impl AnalysisImpl {\n     /// This return `Vec`: a module may be included from several places. We\n     /// don't handle this case yet though, so the Vec has length at most one.\n     pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n-        let descr = match hir::Module::guess_from_position(&*self.db, position)? {\n+        let descr = match source_binder::module_from_position(&*self.db, position)? {\n             None => return Ok(Vec::new()),\n             Some(it) => it,\n         };\n@@ -185,7 +186,7 @@ impl AnalysisImpl {\n     }\n     /// Returns `Vec` for the same reason as `parent_module`\n     pub fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n-        let descr = match hir::Module::guess_from_file_id(&*self.db, file_id)? {\n+        let descr = match source_binder::module_from_file_id(&*self.db, file_id)? {\n             None => return Ok(Vec::new()),\n             Some(it) => it,\n         };\n@@ -209,9 +210,11 @@ impl AnalysisImpl {\n         let file = self.db.source_file(position.file_id);\n         let syntax = file.syntax();\n         if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, position.offset) {\n-            if let Some(fn_descr) =\n-                hir::Function::guess_for_name_ref(&*self.db, position.file_id, name_ref)?\n-            {\n+            if let Some(fn_descr) = source_binder::function_from_child_node(\n+                &*self.db,\n+                position.file_id,\n+                name_ref.syntax(),\n+            )? {\n                 let scope = fn_descr.scope(&*self.db);\n                 // First try to resolve the symbol locally\n                 if let Some(entry) = scope.resolve_local_name(name_ref) {\n@@ -234,7 +237,7 @@ impl AnalysisImpl {\n             if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n                 if module.has_semi() {\n                     let parent_module =\n-                        hir::Module::guess_from_file_id(&*self.db, position.file_id)?;\n+                        source_binder::module_from_file_id(&*self.db, position.file_id)?;\n                     let child_name = module.name();\n                     match (parent_module, child_name) {\n                         (Some(parent_module), Some(child_name)) => {\n@@ -282,18 +285,18 @@ impl AnalysisImpl {\n         ) -> Cancelable<Option<(ast::BindPat<'a>, hir::Function)>> {\n             let syntax = source_file.syntax();\n             if let Some(binding) = find_node_at_offset::<ast::BindPat>(syntax, position.offset) {\n-                let descr = ctry!(hir::Function::guess_for_bind_pat(\n+                let descr = ctry!(source_binder::function_from_child_node(\n                     db,\n                     position.file_id,\n-                    binding\n+                    binding.syntax(),\n                 )?);\n                 return Ok(Some((binding, descr)));\n             };\n             let name_ref = ctry!(find_node_at_offset::<ast::NameRef>(syntax, position.offset));\n-            let descr = ctry!(hir::Function::guess_for_name_ref(\n+            let descr = ctry!(source_binder::function_from_child_node(\n                 db,\n                 position.file_id,\n-                name_ref\n+                name_ref.syntax(),\n             )?);\n             let scope = descr.scope(db);\n             let resolved = ctry!(scope.resolve_local_name(name_ref));\n@@ -327,7 +330,7 @@ impl AnalysisImpl {\n                 fix: None,\n             })\n             .collect::<Vec<_>>();\n-        if let Some(m) = hir::Module::guess_from_file_id(&*self.db, file_id)? {\n+        if let Some(m) = source_binder::module_from_file_id(&*self.db, file_id)? {\n             for (name_node, problem) in m.problems(&*self.db) {\n                 let diag = match problem {\n                     Problem::UnresolvedModule { candidate } => {\n@@ -418,7 +421,7 @@ impl AnalysisImpl {\n             if fs.kind == FN_DEF {\n                 let fn_file = self.db.source_file(fn_file_id);\n                 if let Some(fn_def) = find_node_at_offset(fn_file.syntax(), fs.node_range.start()) {\n-                    let descr = ctry!(hir::Function::guess_from_source(\n+                    let descr = ctry!(source_binder::function_from_source(\n                         &*self.db, fn_file_id, fn_def\n                     )?);\n                     if let Some(descriptor) = descr.signature_info(&*self.db) {"}, {"sha": "5187dc051f1ed20f49bf49c8ea8a179edaccdf30", "filename": "crates/ra_hir/src/function/mod.rs", "status": "modified", "additions": 2, "deletions": 50, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d1b993c0aacb2a29fc87283a8b35fe1b4a542459/crates%2Fra_hir%2Fsrc%2Ffunction%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1b993c0aacb2a29fc87283a8b35fe1b4a542459/crates%2Fra_hir%2Fsrc%2Ffunction%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction%2Fmod.rs?ref=d1b993c0aacb2a29fc87283a8b35fe1b4a542459", "patch": "@@ -6,16 +6,11 @@ use std::{\n };\n \n use ra_syntax::{\n-    TextRange, TextUnit, SyntaxNodeRef,\n+    TextRange, TextUnit,\n     ast::{self, AstNode, DocCommentsOwner, NameOwner},\n };\n-use ra_db::FileId;\n \n-use crate::{\n-    Cancelable,\n-    DefLoc, DefKind, DefId, HirDatabase, SourceItemId,\n-    Module,\n-};\n+use crate::{ DefId, HirDatabase };\n \n pub use self::scope::FnScopes;\n \n@@ -32,49 +27,6 @@ impl Function {\n         Function { fn_id }\n     }\n \n-    pub fn guess_from_source(\n-        db: &impl HirDatabase,\n-        file_id: FileId,\n-        fn_def: ast::FnDef,\n-    ) -> Cancelable<Option<Function>> {\n-        let module = ctry!(Module::guess_from_child_node(db, file_id, fn_def.syntax())?);\n-        let file_items = db.file_items(file_id);\n-        let item_id = file_items.id_of(fn_def.syntax());\n-        let source_item_id = SourceItemId { file_id, item_id };\n-        let def_loc = DefLoc {\n-            kind: DefKind::Function,\n-            source_root_id: module.source_root_id,\n-            module_id: module.module_id,\n-            source_item_id,\n-        };\n-        Ok(Some(Function::new(def_loc.id(db))))\n-    }\n-\n-    pub fn guess_for_name_ref(\n-        db: &impl HirDatabase,\n-        file_id: FileId,\n-        name_ref: ast::NameRef,\n-    ) -> Cancelable<Option<Function>> {\n-        Function::guess_for_node(db, file_id, name_ref.syntax())\n-    }\n-\n-    pub fn guess_for_bind_pat(\n-        db: &impl HirDatabase,\n-        file_id: FileId,\n-        bind_pat: ast::BindPat,\n-    ) -> Cancelable<Option<Function>> {\n-        Function::guess_for_node(db, file_id, bind_pat.syntax())\n-    }\n-\n-    fn guess_for_node(\n-        db: &impl HirDatabase,\n-        file_id: FileId,\n-        node: SyntaxNodeRef,\n-    ) -> Cancelable<Option<Function>> {\n-        let fn_def = ctry!(node.ancestors().find_map(ast::FnDef::cast));\n-        Function::guess_from_source(db, file_id, fn_def)\n-    }\n-\n     pub fn scope(&self, db: &impl HirDatabase) -> Arc<FnScopes> {\n         db.fn_scopes(self.fn_id)\n     }"}, {"sha": "983ce99cb2676e2ea8690ff0d82e5e86bc0b034f", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1b993c0aacb2a29fc87283a8b35fe1b4a542459/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1b993c0aacb2a29fc87283a8b35fe1b4a542459/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=d1b993c0aacb2a29fc87283a8b35fe1b4a542459", "patch": "@@ -22,6 +22,7 @@ mod function;\n mod module;\n mod path;\n mod arena;\n+pub mod source_binder;\n \n use std::ops::Index;\n "}, {"sha": "580c737c3006d3519fd53aae883d1dd76046113c", "filename": "crates/ra_hir/src/module/mod.rs", "status": "modified", "additions": 6, "deletions": 76, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d1b993c0aacb2a29fc87283a8b35fe1b4a542459/crates%2Fra_hir%2Fsrc%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1b993c0aacb2a29fc87283a8b35fe1b4a542459/crates%2Fra_hir%2Fsrc%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fmod.rs?ref=d1b993c0aacb2a29fc87283a8b35fe1b4a542459", "patch": "@@ -3,14 +3,12 @@ pub(super) mod nameres;\n \n use std::sync::Arc;\n \n-use ra_editor::find_node_at_offset;\n-\n use ra_syntax::{\n     algo::generate,\n     ast::{self, AstNode, NameOwner},\n-    SmolStr, SyntaxNode, SyntaxNodeRef,\n+    SmolStr, SyntaxNode,\n };\n-use ra_db::{SourceRootId, FileId, FilePosition, Cancelable};\n+use ra_db::{SourceRootId, FileId, Cancelable};\n use relative_path::RelativePathBuf;\n \n use crate::{\n@@ -30,68 +28,6 @@ pub struct Module {\n }\n \n impl Module {\n-    /// Lookup `Module` by `FileId`. Note that this is inherently\n-    /// lossy transformation: in general, a single source might correspond to\n-    /// several modules.\n-    pub fn guess_from_file_id(\n-        db: &impl HirDatabase,\n-        file_id: FileId,\n-    ) -> Cancelable<Option<Module>> {\n-        let module_source = ModuleSource::new_file(db, file_id);\n-        Module::guess_from_source(db, module_source)\n-    }\n-\n-    /// Lookup `Module` by position in the source code. Note that this\n-    /// is inherently lossy transformation: in general, a single source might\n-    /// correspond to several modules.\n-    pub fn guess_from_position(\n-        db: &impl HirDatabase,\n-        position: FilePosition,\n-    ) -> Cancelable<Option<Module>> {\n-        let file = db.source_file(position.file_id);\n-        let module_source = match find_node_at_offset::<ast::Module>(file.syntax(), position.offset)\n-        {\n-            Some(m) if !m.has_semi() => ModuleSource::new_inline(db, position.file_id, m),\n-            _ => ModuleSource::new_file(db, position.file_id),\n-        };\n-        Module::guess_from_source(db, module_source)\n-    }\n-\n-    pub fn guess_from_child_node(\n-        db: &impl HirDatabase,\n-        file_id: FileId,\n-        node: SyntaxNodeRef,\n-    ) -> Cancelable<Option<Module>> {\n-        let module_source = if let Some(m) = node\n-            .ancestors()\n-            .filter_map(ast::Module::cast)\n-            .find(|it| !it.has_semi())\n-        {\n-            ModuleSource::new_inline(db, file_id, m)\n-        } else {\n-            ModuleSource::new_file(db, file_id)\n-        };\n-        Module::guess_from_source(db, module_source)\n-    }\n-\n-    fn guess_from_source(\n-        db: &impl HirDatabase,\n-        module_source: ModuleSource,\n-    ) -> Cancelable<Option<Module>> {\n-        let source_root_id = db.file_source_root(module_source.file_id());\n-        let module_tree = db.module_tree(source_root_id)?;\n-\n-        let res = match module_tree.any_module_for_source(module_source) {\n-            None => None,\n-            Some(module_id) => Some(Module {\n-                tree: module_tree,\n-                source_root_id,\n-                module_id,\n-            }),\n-        };\n-        Ok(res)\n-    }\n-\n     pub(super) fn new(\n         db: &impl HirDatabase,\n         source_root_id: SourceRootId,\n@@ -217,16 +153,10 @@ impl ModuleTree {\n         self.mods.iter().map(|(id, _)| id)\n     }\n \n-    fn modules_for_source(&self, source: ModuleSource) -> Vec<ModuleId> {\n-        self.mods\n-            .iter()\n-            .filter(|(_idx, it)| it.source == source)\n-            .map(|(idx, _)| idx)\n-            .collect()\n-    }\n-\n-    fn any_module_for_source(&self, source: ModuleSource) -> Option<ModuleId> {\n-        self.modules_for_source(source).pop()\n+    pub(crate) fn modules_with_sources<'a>(\n+        &'a self,\n+    ) -> impl Iterator<Item = (ModuleId, ModuleSource)> + 'a {\n+        self.mods.iter().map(|(id, m)| (id, m.source))\n     }\n }\n "}, {"sha": "61a1acfe6f926f34e2c4163b005aff9e05e3f50b", "filename": "crates/ra_hir/src/module/nameres.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1b993c0aacb2a29fc87283a8b35fe1b4a542459/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1b993c0aacb2a29fc87283a8b35fe1b4a542459/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs?ref=d1b993c0aacb2a29fc87283a8b35fe1b4a542459", "patch": "@@ -363,7 +363,9 @@ mod tests {\n     fn item_map(fixture: &str) -> (Arc<hir::ItemMap>, hir::ModuleId) {\n         let (db, pos) = MockDatabase::with_position(fixture);\n         let source_root = db.file_source_root(pos.file_id);\n-        let module = hir::Module::guess_from_position(&db, pos).unwrap().unwrap();\n+        let module = hir::source_binder::module_from_position(&db, pos)\n+            .unwrap()\n+            .unwrap();\n         let module_id = module.module_id;\n         (db.item_map(source_root).unwrap(), module_id)\n     }"}, {"sha": "47915580502752b60ea4573be8dd52940cb132e3", "filename": "crates/ra_hir/src/source_binder.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/d1b993c0aacb2a29fc87283a8b35fe1b4a542459/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1b993c0aacb2a29fc87283a8b35fe1b4a542459/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=d1b993c0aacb2a29fc87283a8b35fe1b4a542459", "patch": "@@ -0,0 +1,96 @@\n+/// Lookup hir elements using position in the source code. This is a lossy\n+/// transformation: in general, a single source might correspond to several\n+/// modules, functions, etc, due to macros, cfgs and `#[path=]` attributes on\n+/// modules.\n+///\n+/// So, this modules should not be used during hir construction, it exists\n+/// purely for \"IDE needs\".\n+use ra_db::{FileId, FilePosition, Cancelable};\n+use ra_editor::find_node_at_offset;\n+use ra_syntax::{\n+    ast::{self, AstNode},\n+    SyntaxNodeRef,\n+};\n+\n+use crate::{\n+    HirDatabase, Module, Function, SourceItemId,\n+    module::ModuleSource,\n+    DefKind, DefLoc\n+};\n+\n+/// Locates the module by `FileId`. Picks topmost module in the file.\n+pub fn module_from_file_id(db: &impl HirDatabase, file_id: FileId) -> Cancelable<Option<Module>> {\n+    let module_source = ModuleSource::new_file(db, file_id);\n+    module_from_source(db, module_source)\n+}\n+\n+/// Locates the module by position in the source code.\n+pub fn module_from_position(\n+    db: &impl HirDatabase,\n+    position: FilePosition,\n+) -> Cancelable<Option<Module>> {\n+    let file = db.source_file(position.file_id);\n+    let module_source = match find_node_at_offset::<ast::Module>(file.syntax(), position.offset) {\n+        Some(m) if !m.has_semi() => ModuleSource::new_inline(db, position.file_id, m),\n+        _ => ModuleSource::new_file(db, position.file_id),\n+    };\n+    module_from_source(db, module_source)\n+}\n+\n+/// Locates the module by child syntax element within the module\n+pub fn module_from_child_node(\n+    db: &impl HirDatabase,\n+    file_id: FileId,\n+    child: SyntaxNodeRef,\n+) -> Cancelable<Option<Module>> {\n+    let module_source = if let Some(m) = child\n+        .ancestors()\n+        .filter_map(ast::Module::cast)\n+        .find(|it| !it.has_semi())\n+    {\n+        ModuleSource::new_inline(db, file_id, m)\n+    } else {\n+        ModuleSource::new_file(db, file_id)\n+    };\n+    module_from_source(db, module_source)\n+}\n+\n+fn module_from_source(\n+    db: &impl HirDatabase,\n+    module_source: ModuleSource,\n+) -> Cancelable<Option<Module>> {\n+    let source_root_id = db.file_source_root(module_source.file_id());\n+    let module_tree = db.module_tree(source_root_id)?;\n+    let m = module_tree\n+        .modules_with_sources()\n+        .find(|(_id, src)| src == &module_source);\n+    let module_id = ctry!(m).0;\n+    Ok(Some(Module::new(db, source_root_id, module_id)?))\n+}\n+\n+pub fn function_from_source(\n+    db: &impl HirDatabase,\n+    file_id: FileId,\n+    fn_def: ast::FnDef,\n+) -> Cancelable<Option<Function>> {\n+    let module = ctry!(module_from_child_node(db, file_id, fn_def.syntax())?);\n+    let file_items = db.file_items(file_id);\n+    let item_id = file_items.id_of(fn_def.syntax());\n+    let source_item_id = SourceItemId { file_id, item_id };\n+    let def_loc = DefLoc {\n+        kind: DefKind::Function,\n+        source_root_id: module.source_root_id,\n+        module_id: module.module_id,\n+        source_item_id,\n+    };\n+    Ok(Some(Function::new(def_loc.id(db))))\n+}\n+\n+pub fn function_from_child_node(\n+    db: &impl HirDatabase,\n+    file_id: FileId,\n+    node: SyntaxNodeRef,\n+) -> Cancelable<Option<Function>> {\n+    let fn_def = ctry!(node.ancestors().find_map(ast::FnDef::cast));\n+    function_from_source(db, file_id, fn_def)\n+}"}]}