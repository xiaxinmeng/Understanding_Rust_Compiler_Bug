{"sha": "12f6c5019a045eead09b46251173ec3ae558891a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyZjZjNTAxOWEwNDVlZWFkMDliNDYyNTExNzNlYzNhZTU1ODg5MWE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-03-27T20:24:15Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-03-27T22:56:23Z"}, "message": "Rollup merge of #40683 - nikomatsakis:incr-comp-coerce-unsized-info, r=eddyb\n\non-demand-ify `custom_coerce_unsized_kind` and `inherent-impls`\n\nThis \"on-demand\" task both checks for errors and computes the custom unsized kind, if any. This task is only defined on impls of `CoerceUnsized`; invoking it on any other kind of impl results in a bug. This is just to avoid having an `Option`, could easily be changed.\n\nr? @eddyb", "tree": {"sha": "161d8ac2fefe949a742f78cd45c29f05e0b4bd3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/161d8ac2fefe949a742f78cd45c29f05e0b4bd3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12f6c5019a045eead09b46251173ec3ae558891a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12f6c5019a045eead09b46251173ec3ae558891a", "html_url": "https://github.com/rust-lang/rust/commit/12f6c5019a045eead09b46251173ec3ae558891a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12f6c5019a045eead09b46251173ec3ae558891a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "666bb1959ec072665d2e8765b01dd96127589177", "url": "https://api.github.com/repos/rust-lang/rust/commits/666bb1959ec072665d2e8765b01dd96127589177", "html_url": "https://github.com/rust-lang/rust/commit/666bb1959ec072665d2e8765b01dd96127589177"}, {"sha": "a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4", "html_url": "https://github.com/rust-lang/rust/commit/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4"}], "stats": {"total": 526, "additions": 306, "deletions": 220}, "files": [{"sha": "5aea2bcaa4f5c5fd5f4979df6ddb5183f4a9dcc5", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=12f6c5019a045eead09b46251173ec3ae558891a", "patch": "@@ -75,7 +75,6 @@ pub enum DepNode<D: Clone + Debug> {\n     CoherenceCheckImpl(D),\n     CoherenceOverlapCheck(D),\n     CoherenceOverlapCheckSpecial(D),\n-    CoherenceOverlapInherentCheck(D),\n     CoherenceOrphanCheck(D),\n     Variance,\n     WfCheck(D),\n@@ -252,7 +251,6 @@ impl<D: Clone + Debug> DepNode<D> {\n             CoherenceCheckImpl(ref d) => op(d).map(CoherenceCheckImpl),\n             CoherenceOverlapCheck(ref d) => op(d).map(CoherenceOverlapCheck),\n             CoherenceOverlapCheckSpecial(ref d) => op(d).map(CoherenceOverlapCheckSpecial),\n-            CoherenceOverlapInherentCheck(ref d) => op(d).map(CoherenceOverlapInherentCheck),\n             CoherenceOrphanCheck(ref d) => op(d).map(CoherenceOrphanCheck),\n             WfCheck(ref d) => op(d).map(WfCheck),\n             TypeckItemType(ref d) => op(d).map(TypeckItemType),"}, {"sha": "b6a2360211cac92610410d081de314d4c45a2148", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=12f6c5019a045eead09b46251173ec3ae558891a", "patch": "@@ -81,21 +81,6 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n     pub fn keys(&self) -> Vec<M::Key> {\n         self.map.keys().cloned().collect()\n     }\n-\n-    /// Append `elem` to the vector stored for `k`, creating a new vector if needed.\n-    /// This is considered a write to `k`.\n-    ///\n-    /// NOTE: Caution is required when using this method. You should\n-    /// be sure that nobody is **reading from the vector** while you\n-    /// are writing to it. Eventually, it'd be nice to remove this.\n-    pub fn push<E: Clone>(&mut self, k: M::Key, elem: E)\n-        where M: DepTrackingMapConfig<Value=Vec<E>>\n-    {\n-        self.write(&k);\n-        self.map.entry(k)\n-                .or_insert(Vec::new())\n-                .push(elem);\n-    }\n }\n \n impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {"}, {"sha": "8bc0cf2577b5db05761ebbbf9a4b966875383605", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=12f6c5019a045eead09b46251173ec3ae558891a", "patch": "@@ -176,7 +176,6 @@ pub trait CrateStore {\n     fn item_generics_cloned(&self, def: DefId) -> ty::Generics;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>;\n-    fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n \n     // trait info\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>;\n@@ -310,7 +309,6 @@ impl CrateStore for DummyCrateStore {\n         { bug!(\"item_generics_cloned\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name> { bug!(\"fn_arg_names\") }\n-    fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n \n     // trait info\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId> { vec![] }"}, {"sha": "d8ca30477205c53ccfcfd0e5bc61dab9c16828ae", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=12f6c5019a045eead09b46251173ec3ae558891a", "patch": "@@ -139,6 +139,21 @@ pub enum AutoBorrow<'tcx> {\n     RawPtr(hir::Mutability),\n }\n \n+/// Information for `CoerceUnsized` impls, storing information we\n+/// have computed about the coercion.\n+///\n+/// This struct can be obtained via the `coerce_impl_info` query.\n+/// Demanding this struct also has the side-effect of reporting errors\n+/// for inappropriate impls.\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+pub struct CoerceUnsizedInfo {\n+    /// If this is a \"custom coerce\" impl, then what kind of custom\n+    /// coercion is it? This applies to impls of `CoerceUnsized` for\n+    /// structs, primarily, where we store a bit of info about which\n+    /// fields need to be coerced.\n+    pub custom_kind: Option<CustomCoerceUnsized>\n+}\n+\n #[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n pub enum CustomCoerceUnsized {\n     /// Records the index of the field being coerced."}, {"sha": "5a57b0072107c666e6c504f2dc39ab37718513a7", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=12f6c5019a045eead09b46251173ec3ae558891a", "patch": "@@ -13,7 +13,7 @@ use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use middle::const_val::ConstVal;\n use middle::privacy::AccessLevels;\n use mir;\n-use ty::{self, Ty, TyCtxt};\n+use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use std::cell::{RefCell, RefMut};\n@@ -177,9 +177,15 @@ impl<'tcx> QueryDescription for queries::coherent_trait<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::coherent_inherent_impls<'tcx> {\n+impl<'tcx> QueryDescription for queries::crate_inherent_impls<'tcx> {\n+    fn describe(_: TyCtxt, k: CrateNum) -> String {\n+        format!(\"all inherent impls defined in crate `{:?}`\", k)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_inherent_impls_overlap_check<'tcx> {\n     fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        format!(\"coherence checking all inherent impls\")\n+        format!(\"check for overlap between inherent impls defined in this crate\")\n     }\n }\n \n@@ -375,7 +381,7 @@ define_maps! { <'tcx>\n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n-    pub inherent_impls: InherentImpls(DefId) -> Vec<DefId>,\n+    pub inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n \n     /// Maps from the def-id of a function/method or const/static\n     /// to its MIR. Mutation is done at an item granularity to\n@@ -400,14 +406,22 @@ define_maps! { <'tcx>\n     pub closure_type: ItemSignature(DefId) -> ty::PolyFnSig<'tcx>,\n \n     /// Caches CoerceUnsized kinds for impls on custom types.\n-    pub custom_coerce_unsized_kind: ItemSignature(DefId)\n-        -> ty::adjustment::CustomCoerceUnsized,\n+    pub coerce_unsized_info: ItemSignature(DefId)\n+        -> ty::adjustment::CoerceUnsizedInfo,\n \n     pub typeck_tables: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n \n     pub coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n \n-    pub coherent_inherent_impls: coherent_inherent_impls_dep_node(CrateNum) -> (),\n+    /// Gets a complete map from all types to their inherent impls.\n+    /// Not meant to be used directly outside of coherence.\n+    /// (Defined only for LOCAL_CRATE)\n+    pub crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum) -> CrateInherentImpls,\n+\n+    /// Checks all types in the krate for overlap in their inherent impls. Reports errors.\n+    /// Not meant to be used directly outside of coherence.\n+    /// (Defined only for LOCAL_CRATE)\n+    pub crate_inherent_impls_overlap_check: crate_inherent_impls_dep_node(CrateNum) -> (),\n \n     /// Results of evaluating monomorphic constants embedded in\n     /// other items, such as enum variant explicit discriminants.\n@@ -423,7 +437,7 @@ fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n     DepNode::CoherenceCheckTrait(def_id)\n }\n \n-fn coherent_inherent_impls_dep_node(_: CrateNum) -> DepNode<DefId> {\n+fn crate_inherent_impls_dep_node(_: CrateNum) -> DepNode<DefId> {\n     DepNode::Coherence\n }\n "}, {"sha": "6a4e7db21dd127d2d20bf57cb32a2517e4b1d0d1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 16, "deletions": 31, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=12f6c5019a045eead09b46251173ec3ae558891a", "patch": "@@ -31,7 +31,7 @@ use ty::subst::{Subst, Substs};\n use ty::util::IntTypeExt;\n use ty::walk::TypeWalker;\n use util::common::MemoizationMap;\n-use util::nodemap::{NodeSet, FxHashMap};\n+use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n \n use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n@@ -2057,8 +2057,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn custom_coerce_unsized_kind(self, did: DefId) -> adjustment::CustomCoerceUnsized {\n-        queries::custom_coerce_unsized_kind::get(self, DUMMY_SP, did)\n+    pub fn coerce_unsized_info(self, did: DefId) -> adjustment::CoerceUnsizedInfo {\n+        queries::coerce_unsized_info::get(self, DUMMY_SP, did)\n     }\n \n     pub fn associated_item(self, def_id: DefId) -> AssociatedItem {\n@@ -2348,34 +2348,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         def.flags.get().intersects(TraitFlags::HAS_DEFAULT_IMPL)\n     }\n \n-    /// Populates the type context with all the inherent implementations for\n-    /// the given type if necessary.\n-    pub fn populate_inherent_implementations_for_type_if_necessary(self,\n-                                                                   span: Span,\n-                                                                   type_id: DefId) {\n-        if type_id.is_local() {\n-            // Make sure coherence of inherent impls ran already.\n-            ty::queries::coherent_inherent_impls::force(self, span, LOCAL_CRATE);\n-            return\n-        }\n-\n-        // The type is not local, hence we are reading this out of\n-        // metadata and don't need to track edges.\n-        let _ignore = self.dep_graph.in_ignore();\n-\n-        if self.populated_external_types.borrow().contains(&type_id) {\n-            return\n-        }\n-\n-        debug!(\"populate_inherent_implementations_for_type_if_necessary: searching for {:?}\",\n-               type_id);\n-\n-        let inherent_impls = self.sess.cstore.inherent_implementations_for_type(type_id);\n-\n-        self.maps.inherent_impls.borrow_mut().insert(type_id, inherent_impls);\n-        self.populated_external_types.borrow_mut().insert(type_id);\n-    }\n-\n     /// Populates the type context with all the implementations for the given\n     /// trait if necessary.\n     pub fn populate_implementations_for_trait_if_necessary(self, trait_id: DefId) {\n@@ -2640,3 +2612,16 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         ..*providers\n     };\n }\n+\n+\n+/// A map for the local crate mapping each type to a vector of its\n+/// inherent impls. This is not meant to be used outside of coherence;\n+/// rather, you should request the vector for a specific type via\n+/// `ty::queries::inherent_impls::get(def_id)` so as to minimize your\n+/// dependencies (constructing this map requires touching the entire\n+/// crate).\n+#[derive(Clone, Debug)]\n+pub struct CrateInherentImpls {\n+    pub inherent_impls: DefIdMap<Rc<Vec<DefId>>>,\n+}\n+"}, {"sha": "3e9b6a6226ab507d7f7087251b31f75fa6bdf9ea", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=12f6c5019a045eead09b46251173ec3ae558891a", "patch": "@@ -88,9 +88,9 @@ provide! { <'tcx> tcx, def_id, cdata\n     }\n     associated_item => { cdata.get_associated_item(def_id.index) }\n     impl_trait_ref => { cdata.get_impl_trait(def_id.index, tcx) }\n-    custom_coerce_unsized_kind => {\n-        cdata.get_custom_coerce_unsized_kind(def_id.index).unwrap_or_else(|| {\n-            bug!(\"custom_coerce_unsized_kind: `{:?}` is missing its kind\", def_id);\n+    coerce_unsized_info => {\n+        cdata.get_coerce_unsized_info(def_id.index).unwrap_or_else(|| {\n+            bug!(\"coerce_unsized_info: `{:?}` is missing its info\", def_id);\n         })\n     }\n     mir => {\n@@ -109,6 +109,7 @@ provide! { <'tcx> tcx, def_id, cdata\n     typeck_tables => { cdata.item_body_tables(def_id.index, tcx) }\n     closure_kind => { cdata.closure_kind(def_id.index) }\n     closure_type => { cdata.closure_ty(def_id.index, tcx) }\n+    inherent_impls => { Rc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n }\n \n impl CrateStore for cstore::CStore {\n@@ -162,12 +163,6 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(did.krate).get_fn_arg_names(did.index)\n     }\n \n-    fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def_id));\n-        self.get_crate_data(def_id.krate).get_inherent_implementations_for_type(def_id.index)\n-    }\n-\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>\n     {\n         if let Some(def_id) = filter {"}, {"sha": "3de1e3442c69ddb6c0ecf63f8a31df8062bbad8d", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=12f6c5019a045eead09b46251173ec3ae558891a", "patch": "@@ -643,10 +643,10 @@ impl<'a, 'tcx> CrateMetadata {\n         self.get_impl_data(id).polarity\n     }\n \n-    pub fn get_custom_coerce_unsized_kind(&self,\n-                                          id: DefIndex)\n-                                          -> Option<ty::adjustment::CustomCoerceUnsized> {\n-        self.get_impl_data(id).coerce_unsized_kind\n+    pub fn get_coerce_unsized_info(&self,\n+                                   id: DefIndex)\n+                                   -> Option<ty::adjustment::CoerceUnsizedInfo> {\n+        self.get_impl_data(id).coerce_unsized_info\n     }\n \n     pub fn get_impl_trait(&self,"}, {"sha": "38d774992a55111b8d901b75a5d192730f76ba38", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=12f6c5019a045eead09b46251173ec3ae558891a", "patch": "@@ -693,7 +693,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let data = ImplData {\n                     polarity: hir::ImplPolarity::Positive,\n                     parent_impl: None,\n-                    coerce_unsized_kind: None,\n+                    coerce_unsized_info: None,\n                     trait_ref: tcx.impl_trait_ref(def_id).map(|trait_ref| self.lazy(&trait_ref)),\n                 };\n \n@@ -713,13 +713,21 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     None\n                 };\n \n+                // if this is an impl of `CoerceUnsized`, create its\n+                // \"unsized info\", else just store None\n+                let coerce_unsized_info =\n+                    trait_ref.and_then(|t| {\n+                        if Some(t.def_id) == tcx.lang_items.coerce_unsized_trait() {\n+                            Some(ty::queries::coerce_unsized_info::get(tcx, item.span, def_id))\n+                        } else {\n+                            None\n+                        }\n+                    });\n+\n                 let data = ImplData {\n                     polarity: polarity,\n                     parent_impl: parent,\n-                    coerce_unsized_kind: tcx.maps.custom_coerce_unsized_kind\n-                        .borrow()\n-                        .get(&def_id)\n-                        .cloned(),\n+                    coerce_unsized_info: coerce_unsized_info,\n                     trait_ref: trait_ref.map(|trait_ref| self.lazy(&trait_ref)),\n                 };\n "}, {"sha": "abb482a50ebc2621487e53fb43c3af4c5e8f7b73", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=12f6c5019a045eead09b46251173ec3ae558891a", "patch": "@@ -285,7 +285,9 @@ pub struct TraitData<'tcx> {\n pub struct ImplData<'tcx> {\n     pub polarity: hir::ImplPolarity,\n     pub parent_impl: Option<DefId>,\n-    pub coerce_unsized_kind: Option<ty::adjustment::CustomCoerceUnsized>,\n+\n+    /// This is `Some` only for impls of `CoerceUnsized`.\n+    pub coerce_unsized_info: Option<ty::adjustment::CoerceUnsizedInfo>,\n     pub trait_ref: Option<Lazy<ty::TraitRef<'tcx>>>,\n }\n "}, {"sha": "382ca8ef01001ecfd31d922b869d143d5e3a04a0", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=12f6c5019a045eead09b46251173ec3ae558891a", "patch": "@@ -287,7 +287,7 @@ pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx\n \n     match fulfill_obligation(scx, DUMMY_SP, trait_ref) {\n         traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n-            scx.tcx().custom_coerce_unsized_kind(impl_def_id)\n+            scx.tcx().coerce_unsized_info(impl_def_id).custom_kind.unwrap()\n         }\n         vtable => {\n             bug!(\"invalid CoerceUnsized vtable: {:?}\", vtable);"}, {"sha": "5b0418921563a2dea56b4fa4bbf47897b57f3fc8", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=12f6c5019a045eead09b46251173ec3ae558891a", "patch": "@@ -479,14 +479,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn assemble_inherent_impl_candidates_for_type(&mut self, def_id: DefId) {\n-        // Read the inherent implementation candidates for this type from the\n-        // metadata if necessary.\n-        self.tcx.populate_inherent_implementations_for_type_if_necessary(self.span, def_id);\n-\n-        if let Some(impl_infos) = self.tcx.maps.inherent_impls.borrow().get(&def_id) {\n-            for &impl_def_id in impl_infos.iter() {\n-                self.assemble_inherent_impl_probe(impl_def_id);\n-            }\n+        let impl_def_ids = ty::queries::inherent_impls::get(self.tcx, self.span, def_id);\n+        for &impl_def_id in impl_def_ids.iter() {\n+            self.assemble_inherent_impl_probe(impl_def_id);\n         }\n     }\n "}, {"sha": "47b41a75cf5316a9f041d1200ce362f260a45aea", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=12f6c5019a045eead09b46251173ec3ae558891a", "patch": "@@ -18,6 +18,7 @@ use rustc::traits::{self, ObligationCause, Reveal};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::ParameterEnvironment;\n use rustc::ty::TypeFoldable;\n+use rustc::ty::adjustment::CoerceUnsizedInfo;\n use rustc::ty::subst::Subst;\n use rustc::ty::util::CopyImplementationError;\n use rustc::infer;\n@@ -159,28 +160,41 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                    coerce_unsized_trait: DefId,\n+                                                    _: DefId,\n                                                     impl_did: DefId) {\n     debug!(\"visit_implementation_of_coerce_unsized: impl_did={:?}\",\n            impl_did);\n \n+    // Just compute this for the side-effects, in particular reporting\n+    // errors; other parts of the code may demand it for the info of\n+    // course.\n+    if impl_did.is_local() {\n+        let span = tcx.def_span(impl_did);\n+        ty::queries::coerce_unsized_info::get(tcx, span, impl_did);\n+    }\n+}\n+\n+pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     impl_did: DefId)\n+                                     -> CoerceUnsizedInfo {\n+    debug!(\"compute_coerce_unsized_info(impl_did={:?})\", impl_did);\n+    let coerce_unsized_trait = tcx.lang_items.coerce_unsized_trait().unwrap();\n+\n     let unsize_trait = match tcx.lang_items.require(UnsizeTraitLangItem) {\n         Ok(id) => id,\n         Err(err) => {\n             tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n         }\n     };\n \n-    let impl_node_id = if let Some(n) = tcx.hir.as_local_node_id(impl_did) {\n-        n\n-    } else {\n-        debug!(\"visit_implementation_of_coerce_unsized(): impl not \\\n-                in this crate\");\n-        return;\n-    };\n+    // this provider should only get invoked for local def-ids\n+    let impl_node_id = tcx.hir.as_local_node_id(impl_did).unwrap_or_else(|| {\n+        bug!(\"coerce_unsized_info: invoked for non-local def-id {:?}\", impl_did)\n+    });\n \n     let source = tcx.item_type(impl_did);\n     let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n+    assert_eq!(trait_ref.def_id, coerce_unsized_trait);\n     let target = trait_ref.substs.type_at(1);\n     debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (bound)\",\n            source,\n@@ -192,6 +206,8 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let target = target.subst(tcx, &param_env.free_substs);\n     assert!(!source.has_escaping_regions());\n \n+    let err_info = CoerceUnsizedInfo { custom_kind: None };\n+\n     debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (free)\",\n            source,\n            target);\n@@ -234,7 +250,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                definition; expected {}, found {}\",\n                               source_path,\n                               target_path);\n-                    return;\n+                    return err_info;\n                 }\n \n                 let fields = &def_a.struct_variant().fields;\n@@ -268,7 +284,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               \"the trait `CoerceUnsized` may only be implemented \\\n                                for a coercion between structures with one field \\\n                                being coerced, none found\");\n-                    return;\n+                    return err_info;\n                 } else if diff_fields.len() > 1 {\n                     let item = tcx.hir.expect_item(impl_node_id);\n                     let span = if let ItemImpl(.., Some(ref t), _, _) = item.node {\n@@ -295,7 +311,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                           .join(\", \")));\n                     err.span_label(span, &format!(\"requires multiple coercions\"));\n                     err.emit();\n-                    return;\n+                    return err_info;\n                 }\n \n                 let (i, a, b) = diff_fields[0];\n@@ -309,7 +325,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           E0376,\n                           \"the trait `CoerceUnsized` may only be implemented \\\n                            for a coercion between structures\");\n-                return;\n+                return err_info;\n             }\n         };\n \n@@ -331,8 +347,8 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             .caller_bounds);\n         infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n \n-        if let Some(kind) = kind {\n-            tcx.maps.custom_coerce_unsized_kind.borrow_mut().insert(impl_did, kind);\n+        CoerceUnsizedInfo {\n+            custom_kind: kind\n         }\n-    });\n+    })\n }"}, {"sha": "3a39df505eb07863ae2314bff3f2174dd419abe3", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "renamed", "additions": 76, "deletions": 107, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=12f6c5019a045eead09b46251173ec3ae558891a", "patch": "@@ -8,19 +8,82 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! The code in this module gathers up all of the inherent impls in\n+//! the current crate and organizes them in a map. It winds up\n+//! touching the whole crate and thus must be recomputed completely\n+//! for any change, but it is very cheap to compute. In practice, most\n+//! code in the compiler never *directly* requests this map. Instead,\n+//! it requests the inherent impls specific to some type (via\n+//! `ty::queries::inherent_impls::get(def_id)`). That value, however,\n+//! is computed by selecting an idea from this table.\n+\n use rustc::dep_graph::DepNode;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::lint;\n-use rustc::traits::{self, Reveal};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, CrateInherentImpls, TyCtxt};\n+use rustc::util::nodemap::DefIdMap;\n \n+use std::rc::Rc;\n use syntax::ast;\n-use syntax_pos::Span;\n+use syntax_pos::{DUMMY_SP, Span};\n+\n+/// On-demand query: yields a map containing all types mapped to their inherent impls.\n+pub fn crate_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      crate_num: CrateNum)\n+                                      -> CrateInherentImpls {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+\n+    let krate = tcx.hir.krate();\n+    let mut collect = InherentCollect {\n+        tcx,\n+        impls_map: CrateInherentImpls {\n+            inherent_impls: DefIdMap()\n+        }\n+    };\n+    krate.visit_all_item_likes(&mut collect);\n+    collect.impls_map\n+}\n+\n+/// On-demand query: yields a vector of the inherent impls for a specific type.\n+pub fn inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                ty_def_id: DefId)\n+                                -> Rc<Vec<DefId>> {\n+    assert!(ty_def_id.is_local());\n+\n+    // NB. Until we adopt the red-green dep-tracking algorithm (see\n+    // [the plan] for details on that), we do some hackery here to get\n+    // the dependencies correct.  Basically, we use a `with_ignore` to\n+    // read the result we want. If we didn't have the `with_ignore`,\n+    // we would wind up with a dependency on the entire crate, which\n+    // we don't want. Then we go and add dependencies on all the impls\n+    // in the result (which is what we wanted).\n+    //\n+    // The result is a graph with an edge from `Hir(I)` for every impl\n+    // `I` defined on some type `T` to `CoherentInherentImpls(T)`,\n+    // thus ensuring that if any of those impls change, the set of\n+    // inherent impls is considered dirty.\n+    //\n+    // [the plan]: https://github.com/rust-lang/rust-roadmap/issues/4\n+\n+    let result = tcx.dep_graph.with_ignore(|| {\n+        let crate_map = ty::queries::crate_inherent_impls::get(tcx, DUMMY_SP, ty_def_id.krate);\n+        match crate_map.inherent_impls.get(&ty_def_id) {\n+            Some(v) => v.clone(),\n+            None => Rc::new(vec![]),\n+        }\n+    });\n+\n+    for &impl_def_id in &result[..] {\n+        tcx.dep_graph.read(DepNode::Hir(impl_def_id));\n+    }\n+\n+    result\n+}\n \n struct InherentCollect<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    impls_map: CrateInherentImpls,\n }\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n@@ -209,25 +272,19 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n-    fn check_def_id(&self, item: &hir::Item, def_id: DefId) {\n+    fn check_def_id(&mut self, item: &hir::Item, def_id: DefId) {\n         if def_id.is_local() {\n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits.\n             let impl_def_id = self.tcx.hir.local_def_id(item.id);\n+            let mut rc_vec = self.impls_map.inherent_impls\n+                                           .entry(def_id)\n+                                           .or_insert_with(|| Rc::new(vec![]));\n \n-            // Subtle: it'd be better to collect these into a local map\n-            // and then write the vector only once all items are known,\n-            // but that leads to degenerate dep-graphs. The problem is\n-            // that the write of that big vector winds up having reads\n-            // from *all* impls in the krate, since we've lost the\n-            // precision basically.  This would be ok in the firewall\n-            // model so once we've made progess towards that we can modify\n-            // the strategy here. In the meantime, using `push` is ok\n-            // because we are doing this as a pre-pass before anyone\n-            // actually reads from `inherent_impls` -- and we know this is\n-            // true beacuse we hold the refcell lock.\n-            self.tcx.maps.inherent_impls.borrow_mut().push(def_id, impl_def_id);\n+            // At this point, there should not be any clones of the\n+            // `Rc`, so we can still safely push into it in place:\n+            Rc::get_mut(&mut rc_vec).unwrap().push(impl_def_id);\n         } else {\n             struct_span_err!(self.tcx.sess,\n                              item.span,\n@@ -266,91 +323,3 @@ impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n     }\n }\n \n-struct InherentOverlapChecker<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n-}\n-\n-impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n-    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId) {\n-        #[derive(Copy, Clone, PartialEq)]\n-        enum Namespace {\n-            Type,\n-            Value,\n-        }\n-\n-        let name_and_namespace = |def_id| {\n-            let item = self.tcx.associated_item(def_id);\n-            (item.name, match item.kind {\n-                ty::AssociatedKind::Type => Namespace::Type,\n-                ty::AssociatedKind::Const |\n-                ty::AssociatedKind::Method => Namespace::Value,\n-            })\n-        };\n-\n-        let impl_items1 = self.tcx.associated_item_def_ids(impl1);\n-        let impl_items2 = self.tcx.associated_item_def_ids(impl2);\n-\n-        for &item1 in &impl_items1[..] {\n-            let (name, namespace) = name_and_namespace(item1);\n-\n-            for &item2 in &impl_items2[..] {\n-                if (name, namespace) == name_and_namespace(item2) {\n-                    let msg = format!(\"duplicate definitions with name `{}`\", name);\n-                    let node_id = self.tcx.hir.as_local_node_id(item1).unwrap();\n-                    self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,\n-                                           node_id,\n-                                           self.tcx.span_of_impl(item1).unwrap(),\n-                                           msg);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_for_overlapping_inherent_impls(&self, ty_def_id: DefId) {\n-        let _task = self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapInherentCheck(ty_def_id));\n-\n-        let inherent_impls = self.tcx.maps.inherent_impls.borrow();\n-        let impls = match inherent_impls.get(&ty_def_id) {\n-            Some(impls) => impls,\n-            None => return,\n-        };\n-\n-        for (i, &impl1_def_id) in impls.iter().enumerate() {\n-            for &impl2_def_id in &impls[(i + 1)..] {\n-                self.tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n-                    if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n-                        self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n-                    }\n-                });\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentOverlapChecker<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &'v hir::Item) {\n-        match item.node {\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemTrait(..) |\n-            hir::ItemUnion(..) => {\n-                let type_def_id = self.tcx.hir.local_def_id(item.id);\n-                self.check_for_overlapping_inherent_impls(type_def_id);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n-    }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n-    }\n-}\n-\n-pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.visit_all_item_likes_in_krate(DepNode::CoherenceCheckImpl,\n-                                      &mut InherentCollect { tcx });\n-    tcx.visit_all_item_likes_in_krate(DepNode::CoherenceOverlapCheckSpecial,\n-                                      &mut InherentOverlapChecker { tcx });\n-}", "previous_filename": "src/librustc_typeck/coherence/inherent.rs"}, {"sha": "4b36072243c810ae1f9b110faa3f8fc69580e784", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=12f6c5019a045eead09b46251173ec3ae558891a", "patch": "@@ -0,0 +1,102 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::hir;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::lint;\n+use rustc::traits::{self, Reveal};\n+use rustc::ty::{self, TyCtxt};\n+\n+use syntax_pos::DUMMY_SP;\n+\n+pub fn crate_inherent_impls_overlap_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                    crate_num: CrateNum) {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+    let krate = tcx.hir.krate();\n+    krate.visit_all_item_likes(&mut InherentOverlapChecker { tcx });\n+}\n+\n+struct InherentOverlapChecker<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+}\n+\n+impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n+    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId) {\n+        #[derive(Copy, Clone, PartialEq)]\n+        enum Namespace {\n+            Type,\n+            Value,\n+        }\n+\n+        let name_and_namespace = |def_id| {\n+            let item = self.tcx.associated_item(def_id);\n+            (item.name, match item.kind {\n+                ty::AssociatedKind::Type => Namespace::Type,\n+                ty::AssociatedKind::Const |\n+                ty::AssociatedKind::Method => Namespace::Value,\n+            })\n+        };\n+\n+        let impl_items1 = self.tcx.associated_item_def_ids(impl1);\n+        let impl_items2 = self.tcx.associated_item_def_ids(impl2);\n+\n+        for &item1 in &impl_items1[..] {\n+            let (name, namespace) = name_and_namespace(item1);\n+\n+            for &item2 in &impl_items2[..] {\n+                if (name, namespace) == name_and_namespace(item2) {\n+                    let msg = format!(\"duplicate definitions with name `{}`\", name);\n+                    let node_id = self.tcx.hir.as_local_node_id(item1).unwrap();\n+                    self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,\n+                                           node_id,\n+                                           self.tcx.span_of_impl(item1).unwrap(),\n+                                           msg);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_for_overlapping_inherent_impls(&self, ty_def_id: DefId) {\n+        let impls = ty::queries::inherent_impls::get(self.tcx, DUMMY_SP, ty_def_id);\n+\n+        for (i, &impl1_def_id) in impls.iter().enumerate() {\n+            for &impl2_def_id in &impls[(i + 1)..] {\n+                self.tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n+                    if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n+                        self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n+                    }\n+                });\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentOverlapChecker<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'v hir::Item) {\n+        match item.node {\n+            hir::ItemEnum(..) |\n+            hir::ItemStruct(..) |\n+            hir::ItemTrait(..) |\n+            hir::ItemUnion(..) => {\n+                let type_def_id = self.tcx.hir.local_def_id(item.id);\n+                self.check_for_overlapping_inherent_impls(type_def_id);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n+}\n+"}, {"sha": "b3a7b612dd5b8532af75ac7aee58742cbfb29953", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=12f6c5019a045eead09b46251173ec3ae558891a", "patch": "@@ -24,7 +24,8 @@ use syntax::ast;\n use syntax_pos::DUMMY_SP;\n \n mod builtin;\n-mod inherent;\n+mod inherent_impls;\n+mod inherent_impls_overlap;\n mod orphan;\n mod overlap;\n mod unsafety;\n@@ -102,9 +103,16 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, impl_def_id: DefId, trait_d\n }\n \n pub fn provide(providers: &mut Providers) {\n+    use self::builtin::coerce_unsized_info;\n+    use self::inherent_impls::{crate_inherent_impls, inherent_impls};\n+    use self::inherent_impls_overlap::crate_inherent_impls_overlap_check;\n+\n     *providers = Providers {\n         coherent_trait,\n-        coherent_inherent_impls,\n+        crate_inherent_impls,\n+        inherent_impls,\n+        crate_inherent_impls_overlap_check,\n+        coerce_unsized_info,\n         ..*providers\n     };\n }\n@@ -123,10 +131,6 @@ fn coherent_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     builtin::check_trait(tcx, def_id);\n }\n \n-fn coherent_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, _: CrateNum) {\n-    inherent::check(tcx);\n-}\n-\n pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::Coherence);\n     for &trait_def_id in tcx.hir.krate().trait_impls.keys() {\n@@ -137,5 +141,7 @@ pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     orphan::check(tcx);\n     overlap::check_default_impls(tcx);\n \n-    ty::queries::coherent_inherent_impls::get(tcx, DUMMY_SP, LOCAL_CRATE);\n+    // these queries are executed for side-effects (error reporting):\n+    ty::queries::crate_inherent_impls::get(tcx, DUMMY_SP, LOCAL_CRATE);\n+    ty::queries::crate_inherent_impls_overlap_check::get(tcx, DUMMY_SP, LOCAL_CRATE);\n }"}, {"sha": "cc30fdf56fc346c08b411d8b027a6400cfbb33f1", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f6c5019a045eead09b46251173ec3ae558891a/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=12f6c5019a045eead09b46251173ec3ae558891a", "patch": "@@ -232,14 +232,12 @@ fn build_type_alias(cx: &DocContext, did: DefId) -> clean::Typedef {\n \n pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n     let tcx = cx.tcx;\n-    tcx.populate_inherent_implementations_for_type_if_necessary(DUMMY_SP, did);\n     let mut impls = Vec::new();\n \n-    if let Some(i) = tcx.maps.inherent_impls.borrow().get(&did) {\n-        for &did in i.iter() {\n-            build_impl(cx, did, &mut impls);\n-        }\n+    for &did in ty::queries::inherent_impls::get(tcx, DUMMY_SP, did).iter() {\n+        build_impl(cx, did, &mut impls);\n     }\n+\n     // If this is the first time we've inlined something from another crate, then\n     // we inline *all* impls from all the crates into this crate. Note that there's\n     // currently no way for us to filter this based on type, and we likely need"}]}