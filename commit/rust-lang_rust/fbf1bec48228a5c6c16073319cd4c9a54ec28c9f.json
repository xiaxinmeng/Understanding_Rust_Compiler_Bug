{"sha": "fbf1bec48228a5c6c16073319cd4c9a54ec28c9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiZjFiZWM0ODIyOGE1YzZjMTYwNzMzMTljZDRjOWE1NGVjMjhjOWY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-03-08T12:05:03Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-04-04T14:51:41Z"}, "message": "resolve/expand: Cache intermediate results of `#[derive]` expansion", "tree": {"sha": "720bbffc79022103bfcca92eac0624e1661ca332", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/720bbffc79022103bfcca92eac0624e1661ca332"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbf1bec48228a5c6c16073319cd4c9a54ec28c9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbf1bec48228a5c6c16073319cd4c9a54ec28c9f", "html_url": "https://github.com/rust-lang/rust/commit/fbf1bec48228a5c6c16073319cd4c9a54ec28c9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbf1bec48228a5c6c16073319cd4c9a54ec28c9f/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1ea2618d3fef50981c566564cf234b4b98f6328", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1ea2618d3fef50981c566564cf234b4b98f6328", "html_url": "https://github.com/rust-lang/rust/commit/b1ea2618d3fef50981c566564cf234b4b98f6328"}], "stats": {"total": 170, "additions": 97, "deletions": 73}, "files": [{"sha": "1bb050a40cee23c813d617f5d024bded7b38a3e6", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fbf1bec48228a5c6c16073319cd4c9a54ec28c9f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbf1bec48228a5c6c16073319cd4c9a54ec28c9f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=fbf1bec48228a5c6c16073319cd4c9a54ec28c9f", "patch": "@@ -1,6 +1,6 @@\n use crate::cfg_eval::cfg_eval;\n \n-use rustc_ast::{self as ast, token, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n+use rustc_ast::{self as ast, attr, token, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n use rustc_feature::AttributeTemplate;\n@@ -26,32 +26,39 @@ impl MultiItemModifier for Expander {\n             return ExpandResult::Ready(vec![item]);\n         }\n \n-        let template =\n-            AttributeTemplate { list: Some(\"Trait1, Trait2, ...\"), ..Default::default() };\n-        let attr = ecx.attribute(meta_item.clone());\n-        validate_attr::check_builtin_attribute(&sess.parse_sess, &attr, sym::derive, template);\n+        let result =\n+            ecx.resolver.resolve_derives(ecx.current_expansion.id, ecx.force_mode, &|| {\n+                let template =\n+                    AttributeTemplate { list: Some(\"Trait1, Trait2, ...\"), ..Default::default() };\n+                let attr = attr::mk_attr_outer(meta_item.clone());\n+                validate_attr::check_builtin_attribute(\n+                    &sess.parse_sess,\n+                    &attr,\n+                    sym::derive,\n+                    template,\n+                );\n \n-        let derives: Vec<_> = attr\n-            .meta_item_list()\n-            .unwrap_or_default()\n-            .into_iter()\n-            .filter_map(|nested_meta| match nested_meta {\n-                NestedMetaItem::MetaItem(meta) => Some(meta),\n-                NestedMetaItem::Literal(lit) => {\n-                    // Reject `#[derive(\"Debug\")]`.\n-                    report_unexpected_literal(sess, &lit);\n-                    None\n-                }\n-            })\n-            .map(|meta| {\n-                // Reject `#[derive(Debug = \"value\", Debug(abc))]`, but recover the paths.\n-                report_path_args(sess, &meta);\n-                meta.path\n-            })\n-            .collect();\n+                attr.meta_item_list()\n+                    .unwrap_or_default()\n+                    .into_iter()\n+                    .filter_map(|nested_meta| match nested_meta {\n+                        NestedMetaItem::MetaItem(meta) => Some(meta),\n+                        NestedMetaItem::Literal(lit) => {\n+                            // Reject `#[derive(\"Debug\")]`.\n+                            report_unexpected_literal(sess, &lit);\n+                            None\n+                        }\n+                    })\n+                    .map(|meta| {\n+                        // Reject `#[derive(Debug = \"value\", Debug(abc))]`, but recover the paths.\n+                        report_path_args(sess, &meta);\n+                        meta.path\n+                    })\n+                    .map(|path| (path, None))\n+                    .collect()\n+            });\n \n-        // FIXME: Try to cache intermediate results to avoid collecting same paths multiple times.\n-        match ecx.resolver.resolve_derives(ecx.current_expansion.id, derives, ecx.force_mode) {\n+        match result {\n             Ok(()) => ExpandResult::Ready(cfg_eval(ecx, item)),\n             Err(Indeterminate) => ExpandResult::Retry(item),\n         }"}, {"sha": "a2035ee3c6ec9b93d9858f6a5087d765033afee6", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fbf1bec48228a5c6c16073319cd4c9a54ec28c9f/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbf1bec48228a5c6c16073319cd4c9a54ec28c9f/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=fbf1bec48228a5c6c16073319cd4c9a54ec28c9f", "patch": "@@ -868,6 +868,8 @@ impl SyntaxExtension {\n /// Error type that denotes indeterminacy.\n pub struct Indeterminate;\n \n+pub type DeriveResolutions = Vec<(ast::Path, Option<Lrc<SyntaxExtension>>)>;\n+\n pub trait ResolverExpand {\n     fn next_node_id(&mut self) -> NodeId;\n \n@@ -904,15 +906,12 @@ pub trait ResolverExpand {\n     fn resolve_derives(\n         &mut self,\n         expn_id: ExpnId,\n-        derives: Vec<ast::Path>,\n         force: bool,\n+        derive_paths: &dyn Fn() -> DeriveResolutions,\n     ) -> Result<(), Indeterminate>;\n     /// Take resolutions for paths inside the `#[derive(...)]` attribute with the given `ExpnId`\n     /// back from resolver.\n-    fn take_derive_resolutions(\n-        &mut self,\n-        expn_id: ExpnId,\n-    ) -> Option<Vec<(Lrc<SyntaxExtension>, ast::Path)>>;\n+    fn take_derive_resolutions(&mut self, expn_id: ExpnId) -> Option<DeriveResolutions>;\n     /// Path resolution logic for `#[cfg_accessible(path)]`.\n     fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate>;\n }"}, {"sha": "53e2b4e6accb4712abe0b2ecf39d79af2bf86ca5", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbf1bec48228a5c6c16073319cd4c9a54ec28c9f/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbf1bec48228a5c6c16073319cd4c9a54ec28c9f/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=fbf1bec48228a5c6c16073319cd4c9a54ec28c9f", "patch": "@@ -515,7 +515,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                             invocations.reserve(derives.len());\n                             derives\n                                 .into_iter()\n-                                .map(|(_exts, path)| {\n+                                .map(|(path, _exts)| {\n                                     // FIXME: Consider using the derive resolutions (`_exts`)\n                                     // instead of enqueuing the derives to be resolved again later.\n                                     let expn_id = ExpnId::fresh(None);"}, {"sha": "9488ce14a54ea6265439af077e3839d14fc6ce9b", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fbf1bec48228a5c6c16073319cd4c9a54ec28c9f/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbf1bec48228a5c6c16073319cd4c9a54ec28c9f/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=fbf1bec48228a5c6c16073319cd4c9a54ec28c9f", "patch": "@@ -37,7 +37,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::ptr_key::PtrKey;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n-use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n+use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n use rustc_hir::def::Namespace::*;\n use rustc_hir::def::{self, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX};\n@@ -851,6 +851,12 @@ enum BuiltinMacroState {\n     AlreadySeen(Span),\n }\n \n+struct DeriveData {\n+    resolutions: DeriveResolutions,\n+    helper_attrs: Vec<Ident>,\n+    has_derive_copy: bool,\n+}\n+\n /// The main resolver class.\n ///\n /// This is the visitor that walks the whole crate.\n@@ -973,8 +979,9 @@ pub struct Resolver<'a> {\n     output_macro_rules_scopes: FxHashMap<ExpnId, MacroRulesScopeRef<'a>>,\n     /// Helper attributes that are in scope for the given expansion.\n     helper_attrs: FxHashMap<ExpnId, Vec<Ident>>,\n-    /// Resolutions for paths inside the `#[derive(...)]` attribute with the given `ExpnId`.\n-    derive_resolutions: FxHashMap<ExpnId, Vec<(Lrc<SyntaxExtension>, ast::Path)>>,\n+    /// Ready or in-progress results of resolving paths inside the `#[derive(...)]` attribute\n+    /// with the given `ExpnId`.\n+    derive_data: FxHashMap<ExpnId, DeriveData>,\n \n     /// Avoid duplicated errors for \"name already defined\".\n     name_already_seen: FxHashMap<Symbol, Span>,\n@@ -1310,7 +1317,7 @@ impl<'a> Resolver<'a> {\n             invocation_parent_scopes: Default::default(),\n             output_macro_rules_scopes: Default::default(),\n             helper_attrs: Default::default(),\n-            derive_resolutions: Default::default(),\n+            derive_data: Default::default(),\n             local_macro_def_scopes: FxHashMap::default(),\n             name_already_seen: FxHashMap::default(),\n             potentially_unused_imports: Vec::new(),"}, {"sha": "567a99e4abf5aa3a914dc1be6f1c6874e8dc8375", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/fbf1bec48228a5c6c16073319cd4c9a54ec28c9f/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbf1bec48228a5c6c16073319cd4c9a54ec28c9f/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=fbf1bec48228a5c6c16073319cd4c9a54ec28c9f", "patch": "@@ -4,7 +4,7 @@\n use crate::imports::ImportResolver;\n use crate::Namespace::*;\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, BuiltinMacroState, Determinacy};\n-use crate::{CrateLint, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Weak};\n+use crate::{CrateLint, DeriveData, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Weak};\n use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment, ToNameBinding};\n use rustc_ast::{self as ast, Inline, ItemKind, ModKind, NodeId};\n use rustc_ast_lowering::ResolverAstLowering;\n@@ -14,8 +14,8 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::ptr_key::PtrKey;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::struct_span_err;\n-use rustc_expand::base::Annotatable;\n-use rustc_expand::base::{Indeterminate, ResolverExpand, SyntaxExtension, SyntaxExtensionKind};\n+use rustc_expand::base::{Annotatable, DeriveResolutions, Indeterminate, ResolverExpand};\n+use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::compile_declarative_macro;\n use rustc_expand::expand::{AstFragment, Invocation, InvocationKind, SupportsMacroExpansion};\n use rustc_feature::is_builtin_attr_name;\n@@ -359,58 +359,69 @@ impl<'a> ResolverExpand for Resolver<'a> {\n     fn resolve_derives(\n         &mut self,\n         expn_id: ExpnId,\n-        derives: Vec<ast::Path>,\n         force: bool,\n+        derive_paths: &dyn Fn() -> DeriveResolutions,\n     ) -> Result<(), Indeterminate> {\n         // Block expansion of the container until we resolve all derives in it.\n         // This is required for two reasons:\n         // - Derive helper attributes are in scope for the item to which the `#[derive]`\n         //   is applied, so they have to be produced by the container's expansion rather\n         //   than by individual derives.\n         // - Derives in the container need to know whether one of them is a built-in `Copy`.\n-        // FIXME: Try to cache intermediate results to avoid resolving same derives multiple times.\n+        // Temporarily take the data to avoid borrow checker conflicts.\n+        let mut derive_data = mem::take(&mut self.derive_data);\n+        let entry = derive_data.entry(expn_id).or_insert_with(|| DeriveData {\n+            resolutions: derive_paths(),\n+            helper_attrs: Vec::new(),\n+            has_derive_copy: false,\n+        });\n         let parent_scope = self.invocation_parent_scopes[&expn_id];\n-        let mut exts = Vec::new();\n-        let mut helper_attrs = Vec::new();\n-        let mut has_derive_copy = false;\n-        for path in derives {\n-            exts.push((\n-                match self.resolve_macro_path(\n-                    &path,\n-                    Some(MacroKind::Derive),\n-                    &parent_scope,\n-                    true,\n-                    force,\n-                ) {\n-                    Ok((Some(ext), _)) => {\n-                        let span =\n-                            path.segments.last().unwrap().ident.span.normalize_to_macros_2_0();\n-                        helper_attrs\n-                            .extend(ext.helper_attrs.iter().map(|name| Ident::new(*name, span)));\n-                        has_derive_copy |= ext.builtin_name == Some(sym::Copy);\n-                        ext\n-                    }\n-                    Ok(_) | Err(Determinacy::Determined) => self.dummy_ext(MacroKind::Derive),\n-                    Err(Determinacy::Undetermined) => return Err(Indeterminate),\n-                },\n-                path,\n-            ))\n+        for (path, opt_ext) in &mut entry.resolutions {\n+            if opt_ext.is_none() {\n+                *opt_ext = Some(\n+                    match self.resolve_macro_path(\n+                        &path,\n+                        Some(MacroKind::Derive),\n+                        &parent_scope,\n+                        true,\n+                        force,\n+                    ) {\n+                        Ok((Some(ext), _)) => {\n+                            if !ext.helper_attrs.is_empty() {\n+                                let last_seg = path.segments.last().unwrap();\n+                                let span = last_seg.ident.span.normalize_to_macros_2_0();\n+                                entry.helper_attrs.extend(\n+                                    ext.helper_attrs.iter().map(|name| Ident::new(*name, span)),\n+                                );\n+                            }\n+                            entry.has_derive_copy |= ext.builtin_name == Some(sym::Copy);\n+                            ext\n+                        }\n+                        Ok(_) | Err(Determinacy::Determined) => self.dummy_ext(MacroKind::Derive),\n+                        Err(Determinacy::Undetermined) => {\n+                            assert!(self.derive_data.is_empty());\n+                            self.derive_data = derive_data;\n+                            return Err(Indeterminate);\n+                        }\n+                    },\n+                );\n+            }\n         }\n-        self.derive_resolutions.insert(expn_id, exts);\n-        self.helper_attrs.insert(expn_id, helper_attrs);\n+        // If we get to here, then `derive_data` for the given `expn_id` will only be accessed by\n+        // `take_derive_resolutions` later, so we can steal `helper_attrs` instead of cloning them.\n+        self.helper_attrs.insert(expn_id, mem::take(&mut entry.helper_attrs));\n         // Mark this derive as having `Copy` either if it has `Copy` itself or if its parent derive\n         // has `Copy`, to support cases like `#[derive(Clone, Copy)] #[derive(Debug)]`.\n-        if has_derive_copy || self.has_derive_copy(parent_scope.expansion) {\n+        if entry.has_derive_copy || self.has_derive_copy(parent_scope.expansion) {\n             self.containers_deriving_copy.insert(expn_id);\n         }\n+        assert!(self.derive_data.is_empty());\n+        self.derive_data = derive_data;\n         Ok(())\n     }\n \n-    fn take_derive_resolutions(\n-        &mut self,\n-        expn_id: ExpnId,\n-    ) -> Option<Vec<(Lrc<SyntaxExtension>, ast::Path)>> {\n-        self.derive_resolutions.remove(&expn_id)\n+    fn take_derive_resolutions(&mut self, expn_id: ExpnId) -> Option<DeriveResolutions> {\n+        self.derive_data.remove(&expn_id).map(|data| data.resolutions)\n     }\n \n     // The function that implements the resolution logic of `#[cfg_accessible(path)]`."}]}