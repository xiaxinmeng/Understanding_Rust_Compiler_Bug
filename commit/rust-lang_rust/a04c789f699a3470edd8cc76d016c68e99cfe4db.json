{"sha": "a04c789f699a3470edd8cc76d016c68e99cfe4db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwNGM3ODlmNjk5YTM0NzBlZGQ4Y2M3NmQwMTZjNjhlOTljZmU0ZGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-27T01:40:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-27T01:40:41Z"}, "message": "Auto merge of #66936 - cjgillot:hirene-expr, r=Zoxc\n\nAllocate HIR on an arena 2/4 -- Expr & Pat\n\nThis is the second PR in the series started by #66931\n\nThis time, commits don't really make sense on their own.\nThey are mostly split by type of compile error.\n\nThe additional diff is here: https://github.com/cjgillot/rust/compare/hirene-preamble...hirene-expr", "tree": {"sha": "0c45a0f6a3102b12e22a8241371d8ded116c5848", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c45a0f6a3102b12e22a8241371d8ded116c5848"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a04c789f699a3470edd8cc76d016c68e99cfe4db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a04c789f699a3470edd8cc76d016c68e99cfe4db", "html_url": "https://github.com/rust-lang/rust/commit/a04c789f699a3470edd8cc76d016c68e99cfe4db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a04c789f699a3470edd8cc76d016c68e99cfe4db/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e0a1c09108b52e41113520c7fa516480a8b67f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e0a1c09108b52e41113520c7fa516480a8b67f9", "html_url": "https://github.com/rust-lang/rust/commit/3e0a1c09108b52e41113520c7fa516480a8b67f9"}, {"sha": "fb100e5ddcb09e5738231a49a1e709a157bdc027", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb100e5ddcb09e5738231a49a1e709a157bdc027", "html_url": "https://github.com/rust-lang/rust/commit/fb100e5ddcb09e5738231a49a1e709a157bdc027"}], "stats": {"total": 2184, "additions": 1189, "deletions": 995}, "files": [{"sha": "f604a66aebc01b77811f7ac2e2b43d4f5a2275c2", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -125,14 +125,25 @@ macro_rules! arena_types {\n \n             // HIR types\n             [few] hir_forest: rustc::hir::map::Forest<$tcx>,\n+            [] arm: rustc::hir::Arm<$tcx>,\n             [] attribute: syntax::ast::Attribute,\n+            [] block: rustc::hir::Block<$tcx>,\n             [few] global_asm: rustc::hir::GlobalAsm,\n+            [] expr: rustc::hir::Expr<$tcx>,\n+            [] field: rustc::hir::Field<$tcx>,\n+            [] field_pat: rustc::hir::FieldPat<$tcx>,\n             [] fn_decl: rustc::hir::FnDecl,\n             [] foreign_item: rustc::hir::ForeignItem<$tcx>,\n             [] impl_item_ref: rustc::hir::ImplItemRef,\n+            [] inline_asm: rustc::hir::InlineAsm<$tcx>,\n+            [] local: rustc::hir::Local<$tcx>,\n             [few] macro_def: rustc::hir::MacroDef<$tcx>,\n-            [] param: rustc::hir::Param,\n+            [] param: rustc::hir::Param<$tcx>,\n+            [] pat: rustc::hir::Pat<$tcx>,\n             [] path: rustc::hir::Path,\n+            [] path_segment: rustc::hir::PathSegment,\n+            [] qpath: rustc::hir::QPath,\n+            [] stmt: rustc::hir::Stmt<$tcx>,\n             [] struct_field: rustc::hir::StructField<$tcx>,\n             [] trait_item_ref: rustc::hir::TraitItemRef,\n             [] ty: rustc::hir::Ty,"}, {"sha": "511244ca516f59447d51c5977eb3d779ea8c5900", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -458,7 +458,7 @@ impl CheckAttrVisitor<'tcx> {\n             .emit();\n     }\n \n-    fn check_stmt_attributes(&self, stmt: &hir::Stmt) {\n+    fn check_stmt_attributes(&self, stmt: &hir::Stmt<'_>) {\n         // When checking statements ignore expressions, they will be checked later\n         if let hir::StmtKind::Local(ref l) = stmt.kind {\n             for attr in l.attrs.iter() {\n@@ -477,7 +477,7 @@ impl CheckAttrVisitor<'tcx> {\n         }\n     }\n \n-    fn check_expr_attributes(&self, expr: &hir::Expr) {\n+    fn check_expr_attributes(&self, expr: &hir::Expr<'_>) {\n         let target = match expr.kind {\n             hir::ExprKind::Closure(..) => Target::Closure,\n             _ => Target::Expression,\n@@ -537,12 +537,12 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n         intravisit::walk_impl_item(self, impl_item)\n     }\n \n-    fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt) {\n+    fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt<'tcx>) {\n         self.check_stmt_attributes(stmt);\n         intravisit::walk_stmt(self, stmt)\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         self.check_expr_attributes(expr);\n         intravisit::walk_expr(self, expr)\n     }"}, {"sha": "659bfc4e63c6b9dcbd23c95cb6ab9fe2a226e961", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -212,7 +212,7 @@ pub trait Visitor<'v>: Sized {\n         }\n     }\n \n-    fn visit_param(&mut self, param: &'v Param) {\n+    fn visit_param(&mut self, param: &'v Param<'v>) {\n         walk_param(self, param)\n     }\n \n@@ -253,25 +253,25 @@ pub trait Visitor<'v>: Sized {\n     fn visit_foreign_item(&mut self, i: &'v ForeignItem<'v>) {\n         walk_foreign_item(self, i)\n     }\n-    fn visit_local(&mut self, l: &'v Local) {\n+    fn visit_local(&mut self, l: &'v Local<'v>) {\n         walk_local(self, l)\n     }\n-    fn visit_block(&mut self, b: &'v Block) {\n+    fn visit_block(&mut self, b: &'v Block<'v>) {\n         walk_block(self, b)\n     }\n-    fn visit_stmt(&mut self, s: &'v Stmt) {\n+    fn visit_stmt(&mut self, s: &'v Stmt<'v>) {\n         walk_stmt(self, s)\n     }\n-    fn visit_arm(&mut self, a: &'v Arm) {\n+    fn visit_arm(&mut self, a: &'v Arm<'v>) {\n         walk_arm(self, a)\n     }\n-    fn visit_pat(&mut self, p: &'v Pat) {\n+    fn visit_pat(&mut self, p: &'v Pat<'v>) {\n         walk_pat(self, p)\n     }\n     fn visit_anon_const(&mut self, c: &'v AnonConst) {\n         walk_anon_const(self, c)\n     }\n-    fn visit_expr(&mut self, ex: &'v Expr) {\n+    fn visit_expr(&mut self, ex: &'v Expr<'v>) {\n         walk_expr(self, ex)\n     }\n     fn visit_ty(&mut self, t: &'v Ty) {\n@@ -409,7 +409,7 @@ pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body<'v>) {\n     visitor.visit_expr(&body.value);\n }\n \n-pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n+pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local<'v>) {\n     // Intentionally visiting the expr first - the initialization expr\n     // dominates the local's definition.\n     walk_list!(visitor, visit_expr, &local.init);\n@@ -462,10 +462,10 @@ where\n     visitor.visit_path(&trait_ref.path, trait_ref.hir_ref_id)\n }\n \n-pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param) {\n+pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param<'v>) {\n     visitor.visit_id(param.hir_id);\n     visitor.visit_pat(&param.pat);\n-    walk_list!(visitor, visit_attribute, &param.attrs);\n+    walk_list!(visitor, visit_attribute, param.attrs);\n }\n \n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n@@ -684,26 +684,26 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V, type_binding\n     }\n }\n \n-pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n+pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat<'v>) {\n     visitor.visit_id(pattern.hir_id);\n     match pattern.kind {\n-        PatKind::TupleStruct(ref qpath, ref children, _) => {\n+        PatKind::TupleStruct(ref qpath, children, _) => {\n             visitor.visit_qpath(qpath, pattern.hir_id, pattern.span);\n             walk_list!(visitor, visit_pat, children);\n         }\n         PatKind::Path(ref qpath) => {\n             visitor.visit_qpath(qpath, pattern.hir_id, pattern.span);\n         }\n-        PatKind::Struct(ref qpath, ref fields, _) => {\n+        PatKind::Struct(ref qpath, fields, _) => {\n             visitor.visit_qpath(qpath, pattern.hir_id, pattern.span);\n             for field in fields {\n                 visitor.visit_id(field.hir_id);\n                 visitor.visit_ident(field.ident);\n                 visitor.visit_pat(&field.pat)\n             }\n         }\n-        PatKind::Or(ref pats) => walk_list!(visitor, visit_pat, pats),\n-        PatKind::Tuple(ref tuple_elements, _) => {\n+        PatKind::Or(pats) => walk_list!(visitor, visit_pat, pats),\n+        PatKind::Tuple(tuple_elements, _) => {\n             walk_list!(visitor, visit_pat, tuple_elements);\n         }\n         PatKind::Box(ref subpattern) | PatKind::Ref(ref subpattern, _) => {\n@@ -719,7 +719,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n             visitor.visit_expr(upper_bound)\n         }\n         PatKind::Wild => (),\n-        PatKind::Slice(ref prepatterns, ref slice_pattern, ref postpatterns) => {\n+        PatKind::Slice(prepatterns, ref slice_pattern, postpatterns) => {\n             walk_list!(visitor, visit_pat, prepatterns);\n             walk_list!(visitor, visit_pat, slice_pattern);\n             walk_list!(visitor, visit_pat, postpatterns);\n@@ -955,13 +955,13 @@ pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V, struct_field: &'v\n     walk_list!(visitor, visit_attribute, struct_field.attrs);\n }\n \n-pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n+pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block<'v>) {\n     visitor.visit_id(block.hir_id);\n-    walk_list!(visitor, visit_stmt, &block.stmts);\n+    walk_list!(visitor, visit_stmt, block.stmts);\n     walk_list!(visitor, visit_expr, &block.expr);\n }\n \n-pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n+pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt<'v>) {\n     visitor.visit_id(statement.hir_id);\n     match statement.kind {\n         StmtKind::Local(ref local) => visitor.visit_local(local),\n@@ -977,19 +977,19 @@ pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonCo\n     visitor.visit_nested_body(constant.body);\n }\n \n-pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n+pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>) {\n     visitor.visit_id(expression.hir_id);\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n     match expression.kind {\n         ExprKind::Box(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::Array(ref subexpressions) => {\n+        ExprKind::Array(subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n         ExprKind::Repeat(ref element, ref count) => {\n             visitor.visit_expr(element);\n             visitor.visit_anon_const(count)\n         }\n-        ExprKind::Struct(ref qpath, ref fields, ref optional_base) => {\n+        ExprKind::Struct(ref qpath, fields, ref optional_base) => {\n             visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n             for field in fields {\n                 visitor.visit_id(field.hir_id);\n@@ -998,14 +998,14 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             }\n             walk_list!(visitor, visit_expr, optional_base);\n         }\n-        ExprKind::Tup(ref subexpressions) => {\n+        ExprKind::Tup(subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprKind::Call(ref callee_expression, ref arguments) => {\n+        ExprKind::Call(ref callee_expression, arguments) => {\n             visitor.visit_expr(callee_expression);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n-        ExprKind::MethodCall(ref segment, _, ref arguments) => {\n+        ExprKind::MethodCall(ref segment, _, arguments) => {\n             visitor.visit_path_segment(expression.span, segment);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n@@ -1027,7 +1027,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }\n-        ExprKind::Match(ref subexpression, ref arms, _) => {\n+        ExprKind::Match(ref subexpression, arms, _) => {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }\n@@ -1077,8 +1077,8 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n         ExprKind::InlineAsm(ref asm) => {\n-            walk_list!(visitor, visit_expr, &asm.outputs_exprs);\n-            walk_list!(visitor, visit_expr, &asm.inputs_exprs);\n+            walk_list!(visitor, visit_expr, asm.outputs_exprs);\n+            walk_list!(visitor, visit_expr, asm.inputs_exprs);\n         }\n         ExprKind::Yield(ref subexpression, _) => {\n             visitor.visit_expr(subexpression);\n@@ -1087,7 +1087,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n     }\n }\n \n-pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n+pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n     visitor.visit_id(arm.hir_id);\n     visitor.visit_pat(&arm.pat);\n     if let Some(ref g) = arm.guard {\n@@ -1096,7 +1096,7 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n         }\n     }\n     visitor.visit_expr(&arm.body);\n-    walk_list!(visitor, visit_attribute, &arm.attrs);\n+    walk_list!(visitor, visit_attribute, arm.attrs);\n }\n \n pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility) {"}, {"sha": "ed84bd118f725fe5d5cb3add8bd9c5ed457fad5a", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 103, "deletions": 85, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -32,9 +32,6 @@\n //! get confused if the spans from leaf AST nodes occur in multiple places\n //! in the HIR, especially for multiple identifiers.\n \n-mod expr;\n-mod item;\n-\n use crate::arena::Arena;\n use crate::dep_graph::DepGraph;\n use crate::hir::def::{DefKind, Namespace, PartialRes, PerNS, Res};\n@@ -76,6 +73,18 @@ use syntax_pos::Span;\n \n use rustc_error_codes::*;\n \n+macro_rules! arena_vec {\n+    () => (\n+        &[]\n+    );\n+    ($this:expr; $($x:expr),*) => (\n+        $this.arena.alloc_from_iter(vec![$($x),*])\n+    );\n+}\n+\n+mod expr;\n+mod item;\n+\n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n pub struct LoweringContext<'a, 'hir: 'a> {\n@@ -921,7 +930,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn with_new_scopes<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut LoweringContext<'_, '_>) -> T,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         let was_in_loop_condition = self.is_in_loop_condition;\n         self.is_in_loop_condition = false;\n@@ -2022,7 +2031,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         })\n     }\n \n-    fn lower_local(&mut self, l: &Local) -> (hir::Local, SmallVec<[NodeId; 1]>) {\n+    fn lower_local(&mut self, l: &Local) -> (hir::Local<'hir>, SmallVec<[NodeId; 1]>) {\n         let mut ids = SmallVec::<[NodeId; 1]>::new();\n         if self.sess.features_untracked().impl_trait_in_bindings {\n             if let Some(ref ty) = l.ty {\n@@ -2031,21 +2040,24 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         }\n         let parent_def_id = DefId::local(self.current_hir_id_owner.last().unwrap().0);\n+        let ty = l.ty.as_ref().map(|t| {\n+            self.lower_ty(\n+                t,\n+                if self.sess.features_untracked().impl_trait_in_bindings {\n+                    ImplTraitContext::OpaqueTy(Some(parent_def_id))\n+                } else {\n+                    ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n+                },\n+            )\n+        });\n+        let ty = ty.map(|ty| &*self.arena.alloc(ty.into_inner()));\n+        let init = l.init.as_ref().map(|e| self.lower_expr(e));\n         (\n             hir::Local {\n                 hir_id: self.lower_node_id(l.id),\n-                ty: l.ty.as_ref().map(|t| {\n-                    self.lower_ty(\n-                        t,\n-                        if self.sess.features_untracked().impl_trait_in_bindings {\n-                            ImplTraitContext::OpaqueTy(Some(parent_def_id))\n-                        } else {\n-                            ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n-                        },\n-                    )\n-                }),\n+                ty,\n                 pat: self.lower_pat(&l.pat),\n-                init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n+                init,\n                 span: l.span,\n                 attrs: l.attrs.clone(),\n                 source: hir::LocalSource::Normal,\n@@ -2586,14 +2598,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         bounds.iter().map(|bound| self.lower_param_bound(bound, itctx.reborrow())).collect()\n     }\n \n-    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n+    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> &'hir hir::Block<'hir> {\n+        self.arena.alloc(self.lower_block_noalloc(b, targeted_by_break))\n+    }\n+\n+    fn lower_block_noalloc(&mut self, b: &Block, targeted_by_break: bool) -> hir::Block<'hir> {\n         let mut stmts = vec![];\n-        let mut expr = None;\n+        let mut expr: Option<&'hir _> = None;\n \n         for (index, stmt) in b.stmts.iter().enumerate() {\n             if index == b.stmts.len() - 1 {\n                 if let StmtKind::Expr(ref e) = stmt.kind {\n-                    expr = Some(P(self.lower_expr(e)));\n+                    expr = Some(self.lower_expr(e));\n                 } else {\n                     stmts.extend(self.lower_stmt(stmt));\n                 }\n@@ -2602,32 +2618,32 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         }\n \n-        P(hir::Block {\n+        hir::Block {\n             hir_id: self.lower_node_id(b.id),\n-            stmts: stmts.into(),\n+            stmts: self.arena.alloc_from_iter(stmts),\n             expr,\n             rules: self.lower_block_check_mode(&b.rules),\n             span: b.span,\n             targeted_by_break,\n-        })\n+        }\n     }\n \n     /// Lowers a block directly to an expression, presuming that it\n     /// has no attributes and is not targeted by a `break`.\n-    fn lower_block_expr(&mut self, b: &Block) -> hir::Expr {\n+    fn lower_block_expr(&mut self, b: &Block) -> hir::Expr<'hir> {\n         let block = self.lower_block(b, false);\n         self.expr_block(block, AttrVec::new())\n     }\n \n-    fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat> {\n+    fn lower_pat(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n         let node = match p.kind {\n             PatKind::Wild => hir::PatKind::Wild,\n             PatKind::Ident(ref binding_mode, ident, ref sub) => {\n                 let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n                 let node = self.lower_pat_ident(p, binding_mode, ident, lower_sub);\n                 node\n             }\n-            PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n+            PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n             PatKind::TupleStruct(ref path, ref pats) => {\n                 let qpath = self.lower_qpath(\n                     p.id,\n@@ -2640,7 +2656,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 hir::PatKind::TupleStruct(qpath, pats, ddpos)\n             }\n             PatKind::Or(ref pats) => {\n-                hir::PatKind::Or(pats.iter().map(|x| self.lower_pat(x)).collect())\n+                hir::PatKind::Or(self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))))\n             }\n             PatKind::Path(ref qself, ref path) => {\n                 let qpath = self.lower_qpath(\n@@ -2661,16 +2677,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     ImplTraitContext::disallowed(),\n                 );\n \n-                let fs = fields\n-                    .iter()\n-                    .map(|f| hir::FieldPat {\n-                        hir_id: self.next_id(),\n-                        ident: f.ident,\n-                        pat: self.lower_pat(&f.pat),\n-                        is_shorthand: f.is_shorthand,\n-                        span: f.span,\n-                    })\n-                    .collect();\n+                let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n+                    hir_id: self.next_id(),\n+                    ident: f.ident,\n+                    pat: self.lower_pat(&f.pat),\n+                    is_shorthand: f.is_shorthand,\n+                    span: f.span,\n+                }));\n                 hir::PatKind::Struct(qpath, fs, etc)\n             }\n             PatKind::Tuple(ref pats) => {\n@@ -2680,8 +2693,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n             PatKind::Ref(ref inner, mutbl) => hir::PatKind::Ref(self.lower_pat(inner), mutbl),\n             PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => hir::PatKind::Range(\n-                P(self.lower_expr(e1)),\n-                P(self.lower_expr(e2)),\n+                self.lower_expr(e1),\n+                self.lower_expr(e2),\n                 self.lower_range_end(end),\n             ),\n             PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n@@ -2700,7 +2713,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         pats: &[AstP<Pat>],\n         ctx: &str,\n-    ) -> (HirVec<P<hir::Pat>>, Option<usize>) {\n+    ) -> (&'hir [&'hir hir::Pat<'hir>], Option<usize>) {\n         let mut elems = Vec::with_capacity(pats.len());\n         let mut rest = None;\n \n@@ -2728,7 +2741,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         }\n \n-        (elems.into(), rest.map(|(ddpos, _)| ddpos))\n+        (self.arena.alloc_from_iter(elems), rest.map(|(ddpos, _)| ddpos))\n     }\n \n     /// Lower a slice pattern of form `[pat_0, ..., pat_n]` into\n@@ -2737,7 +2750,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// When encountering `($binding_mode $ident @)? ..` (`slice`),\n     /// this is interpreted as a sub-slice pattern semantically.\n     /// Patterns that follow, which are not like `slice` -- or an error occurs, are in `after`.\n-    fn lower_pat_slice(&mut self, pats: &[AstP<Pat>]) -> hir::PatKind {\n+    fn lower_pat_slice(&mut self, pats: &[AstP<Pat>]) -> hir::PatKind<'hir> {\n         let mut before = Vec::new();\n         let mut after = Vec::new();\n         let mut slice = None;\n@@ -2788,16 +2801,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         }\n \n-        hir::PatKind::Slice(before.into(), slice, after.into())\n+        hir::PatKind::Slice(\n+            self.arena.alloc_from_iter(before),\n+            slice,\n+            self.arena.alloc_from_iter(after),\n+        )\n     }\n \n     fn lower_pat_ident(\n         &mut self,\n         p: &Pat,\n         binding_mode: &BindingMode,\n         ident: Ident,\n-        lower_sub: impl FnOnce(&mut Self) -> Option<P<hir::Pat>>,\n-    ) -> hir::PatKind {\n+        lower_sub: impl FnOnce(&mut Self) -> Option<&'hir hir::Pat<'hir>>,\n+    ) -> hir::PatKind<'hir> {\n         match self.resolver.get_partial_res(p.id).map(|d| d.base_res()) {\n             // `None` can occur in body-less function signatures\n             res @ None | res @ Some(Res::Local(_)) => {\n@@ -2824,13 +2841,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn pat_wild_with_node_id_of(&mut self, p: &Pat) -> P<hir::Pat> {\n+    fn pat_wild_with_node_id_of(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n         self.pat_with_node_id_of(p, hir::PatKind::Wild)\n     }\n \n     /// Construct a `Pat` with the `HirId` of `p.id` lowered.\n-    fn pat_with_node_id_of(&mut self, p: &Pat, kind: hir::PatKind) -> P<hir::Pat> {\n-        P(hir::Pat { hir_id: self.lower_node_id(p.id), kind, span: p.span })\n+    fn pat_with_node_id_of(&mut self, p: &Pat, kind: hir::PatKind<'hir>) -> &'hir hir::Pat<'hir> {\n+        self.arena.alloc(hir::Pat { hir_id: self.lower_node_id(p.id), kind, span: p.span })\n     }\n \n     /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n@@ -2843,7 +2860,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     /// Used to ban the `..` pattern in places it shouldn't be semantically.\n-    fn ban_illegal_rest_pat(&self, sp: Span) -> hir::PatKind {\n+    fn ban_illegal_rest_pat(&self, sp: Span) -> hir::PatKind<'hir> {\n         self.diagnostic()\n             .struct_span_err(sp, \"`..` patterns are not allowed here\")\n             .note(\"only allowed in tuple, tuple struct, and slice patterns\")\n@@ -2869,11 +2886,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         })\n     }\n \n-    fn lower_stmt(&mut self, s: &Stmt) -> SmallVec<[hir::Stmt; 1]> {\n+    fn lower_stmt(&mut self, s: &Stmt) -> SmallVec<[hir::Stmt<'hir>; 1]> {\n         let kind = match s.kind {\n             StmtKind::Local(ref l) => {\n                 let (l, item_ids) = self.lower_local(l);\n-                let mut ids: SmallVec<[hir::Stmt; 1]> = item_ids\n+                let mut ids: SmallVec<[hir::Stmt<'hir>; 1]> = item_ids\n                     .into_iter()\n                     .map(|item_id| {\n                         let item_id = hir::ItemId { id: self.lower_node_id(item_id) };\n@@ -2883,7 +2900,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 ids.push({\n                     hir::Stmt {\n                         hir_id: self.lower_node_id(s.id),\n-                        kind: hir::StmtKind::Local(P(l)),\n+                        kind: hir::StmtKind::Local(self.arena.alloc(l)),\n                         span: s.span,\n                     }\n                 });\n@@ -2905,8 +2922,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     })\n                     .collect();\n             }\n-            StmtKind::Expr(ref e) => hir::StmtKind::Expr(P(self.lower_expr(e))),\n-            StmtKind::Semi(ref e) => hir::StmtKind::Semi(P(self.lower_expr(e))),\n+            StmtKind::Expr(ref e) => hir::StmtKind::Expr(self.lower_expr(e)),\n+            StmtKind::Semi(ref e) => hir::StmtKind::Semi(self.lower_expr(e)),\n             StmtKind::Mac(..) => panic!(\"shouldn't exist here\"),\n         };\n         smallvec![hir::Stmt { hir_id: self.lower_node_id(s.id), kind, span: s.span }]\n@@ -2944,74 +2961,75 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     // Helper methods for building HIR.\n \n-    fn stmt(&mut self, span: Span, kind: hir::StmtKind) -> hir::Stmt {\n+    fn stmt(&mut self, span: Span, kind: hir::StmtKind<'hir>) -> hir::Stmt<'hir> {\n         hir::Stmt { span, kind, hir_id: self.next_id() }\n     }\n \n-    fn stmt_expr(&mut self, span: Span, expr: hir::Expr) -> hir::Stmt {\n-        self.stmt(span, hir::StmtKind::Expr(P(expr)))\n+    fn stmt_expr(&mut self, span: Span, expr: hir::Expr<'hir>) -> hir::Stmt<'hir> {\n+        self.stmt(span, hir::StmtKind::Expr(self.arena.alloc(expr)))\n     }\n \n     fn stmt_let_pat(\n         &mut self,\n         attrs: AttrVec,\n         span: Span,\n-        init: Option<P<hir::Expr>>,\n-        pat: P<hir::Pat>,\n+        init: Option<&'hir hir::Expr<'hir>>,\n+        pat: &'hir hir::Pat<'hir>,\n         source: hir::LocalSource,\n-    ) -> hir::Stmt {\n+    ) -> hir::Stmt<'hir> {\n         let local = hir::Local { attrs, hir_id: self.next_id(), init, pat, source, span, ty: None };\n-        self.stmt(span, hir::StmtKind::Local(P(local)))\n+        self.stmt(span, hir::StmtKind::Local(self.arena.alloc(local)))\n     }\n \n-    fn block_expr(&mut self, expr: P<hir::Expr>) -> hir::Block {\n-        self.block_all(expr.span, hir::HirVec::new(), Some(expr))\n+    fn block_expr(&mut self, expr: &'hir hir::Expr<'hir>) -> &'hir hir::Block<'hir> {\n+        self.block_all(expr.span, &[], Some(expr))\n     }\n \n     fn block_all(\n         &mut self,\n         span: Span,\n-        stmts: hir::HirVec<hir::Stmt>,\n-        expr: Option<P<hir::Expr>>,\n-    ) -> hir::Block {\n-        hir::Block {\n+        stmts: &'hir [hir::Stmt<'hir>],\n+        expr: Option<&'hir hir::Expr<'hir>>,\n+    ) -> &'hir hir::Block<'hir> {\n+        let blk = hir::Block {\n             stmts,\n             expr,\n             hir_id: self.next_id(),\n             rules: hir::DefaultBlock,\n             span,\n             targeted_by_break: false,\n-        }\n+        };\n+        self.arena.alloc(blk)\n     }\n \n     /// Constructs a `true` or `false` literal pattern.\n-    fn pat_bool(&mut self, span: Span, val: bool) -> P<hir::Pat> {\n+    fn pat_bool(&mut self, span: Span, val: bool) -> &'hir hir::Pat<'hir> {\n         let expr = self.expr_bool(span, val);\n-        self.pat(span, hir::PatKind::Lit(P(expr)))\n+        self.pat(span, hir::PatKind::Lit(expr))\n     }\n \n-    fn pat_ok(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        self.pat_std_enum(span, &[sym::result, sym::Result, sym::Ok], hir_vec![pat])\n+    fn pat_ok(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {\n+        self.pat_std_enum(span, &[sym::result, sym::Result, sym::Ok], arena_vec![self; pat])\n     }\n \n-    fn pat_err(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        self.pat_std_enum(span, &[sym::result, sym::Result, sym::Err], hir_vec![pat])\n+    fn pat_err(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {\n+        self.pat_std_enum(span, &[sym::result, sym::Result, sym::Err], arena_vec![self; pat])\n     }\n \n-    fn pat_some(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        self.pat_std_enum(span, &[sym::option, sym::Option, sym::Some], hir_vec![pat])\n+    fn pat_some(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {\n+        self.pat_std_enum(span, &[sym::option, sym::Option, sym::Some], arena_vec![self; pat])\n     }\n \n-    fn pat_none(&mut self, span: Span) -> P<hir::Pat> {\n-        self.pat_std_enum(span, &[sym::option, sym::Option, sym::None], hir_vec![])\n+    fn pat_none(&mut self, span: Span) -> &'hir hir::Pat<'hir> {\n+        self.pat_std_enum(span, &[sym::option, sym::Option, sym::None], &[])\n     }\n \n     fn pat_std_enum(\n         &mut self,\n         span: Span,\n         components: &[Symbol],\n-        subpats: hir::HirVec<P<hir::Pat>>,\n-    ) -> P<hir::Pat> {\n+        subpats: &'hir [&'hir hir::Pat<'hir>],\n+    ) -> &'hir hir::Pat<'hir> {\n         let path = self.std_path(span, components, None, true);\n         let qpath = hir::QPath::Resolved(None, P(path));\n         let pt = if subpats.is_empty() {\n@@ -3022,7 +3040,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.pat(span, pt)\n     }\n \n-    fn pat_ident(&mut self, span: Span, ident: Ident) -> (P<hir::Pat>, hir::HirId) {\n+    fn pat_ident(&mut self, span: Span, ident: Ident) -> (&'hir hir::Pat<'hir>, hir::HirId) {\n         self.pat_ident_binding_mode(span, ident, hir::BindingAnnotation::Unannotated)\n     }\n \n@@ -3031,11 +3049,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         span: Span,\n         ident: Ident,\n         bm: hir::BindingAnnotation,\n-    ) -> (P<hir::Pat>, hir::HirId) {\n+    ) -> (&'hir hir::Pat<'hir>, hir::HirId) {\n         let hir_id = self.next_id();\n \n         (\n-            P(hir::Pat {\n+            self.arena.alloc(hir::Pat {\n                 hir_id,\n                 kind: hir::PatKind::Binding(bm, hir_id, ident.with_span_pos(span), None),\n                 span,\n@@ -3044,12 +3062,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         )\n     }\n \n-    fn pat_wild(&mut self, span: Span) -> P<hir::Pat> {\n+    fn pat_wild(&mut self, span: Span) -> &'hir hir::Pat<'hir> {\n         self.pat(span, hir::PatKind::Wild)\n     }\n \n-    fn pat(&mut self, span: Span, kind: hir::PatKind) -> P<hir::Pat> {\n-        P(hir::Pat { hir_id: self.next_id(), kind, span })\n+    fn pat(&mut self, span: Span, kind: hir::PatKind<'hir>) -> &'hir hir::Pat<'hir> {\n+        self.arena.alloc(hir::Pat { hir_id: self.next_id(), kind, span })\n     }\n \n     /// Given a suffix `[\"b\", \"c\", \"d\"]`, returns path `::std::b::c::d` when"}, {"sha": "8a9614c6cb2c00e9fdb254fccc4ad51389ab4471", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 264, "deletions": 193, "changes": 457, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -1,7 +1,7 @@\n use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericArgs};\n+use crate::hir;\n use crate::hir::def::Res;\n use crate::hir::ptr::P;\n-use crate::hir::{self, HirVec};\n \n use rustc_data_structures::thin_vec::ThinVec;\n \n@@ -13,27 +13,31 @@ use syntax::symbol::{sym, Symbol};\n \n use rustc_error_codes::*;\n \n-impl LoweringContext<'_, '_> {\n-    fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> HirVec<hir::Expr> {\n-        exprs.iter().map(|x| self.lower_expr(x)).collect()\n+impl<'hir> LoweringContext<'_, 'hir> {\n+    fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> &'hir [hir::Expr<'hir>] {\n+        self.arena.alloc_from_iter(exprs.iter().map(|x| self.lower_expr_mut(x)))\n     }\n \n-    pub(super) fn lower_expr(&mut self, e: &Expr) -> hir::Expr {\n+    pub(super) fn lower_expr(&mut self, e: &Expr) -> &'hir hir::Expr<'hir> {\n+        self.arena.alloc(self.lower_expr_mut(e))\n+    }\n+\n+    pub(super) fn lower_expr_mut(&mut self, e: &Expr) -> hir::Expr<'hir> {\n         let kind = match e.kind {\n-            ExprKind::Box(ref inner) => hir::ExprKind::Box(P(self.lower_expr(inner))),\n+            ExprKind::Box(ref inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n             ExprKind::Array(ref exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n             ExprKind::Repeat(ref expr, ref count) => {\n-                let expr = P(self.lower_expr(expr));\n+                let expr = self.lower_expr(expr);\n                 let count = self.lower_anon_const(count);\n                 hir::ExprKind::Repeat(expr, count)\n             }\n             ExprKind::Tup(ref elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n             ExprKind::Call(ref f, ref args) => {\n-                let f = P(self.lower_expr(f));\n+                let f = self.lower_expr(f);\n                 hir::ExprKind::Call(f, self.lower_exprs(args))\n             }\n             ExprKind::MethodCall(ref seg, ref args) => {\n-                let hir_seg = P(self.lower_path_segment(\n+                let hir_seg = self.arena.alloc(self.lower_path_segment(\n                     e.span,\n                     seg,\n                     ParamMode::Optional,\n@@ -47,26 +51,28 @@ impl LoweringContext<'_, '_> {\n             }\n             ExprKind::Binary(binop, ref lhs, ref rhs) => {\n                 let binop = self.lower_binop(binop);\n-                let lhs = P(self.lower_expr(lhs));\n-                let rhs = P(self.lower_expr(rhs));\n+                let lhs = self.lower_expr(lhs);\n+                let rhs = self.lower_expr(rhs);\n                 hir::ExprKind::Binary(binop, lhs, rhs)\n             }\n             ExprKind::Unary(op, ref ohs) => {\n                 let op = self.lower_unop(op);\n-                let ohs = P(self.lower_expr(ohs));\n+                let ohs = self.lower_expr(ohs);\n                 hir::ExprKind::Unary(op, ohs)\n             }\n             ExprKind::Lit(ref l) => hir::ExprKind::Lit(respan(l.span, l.kind.clone())),\n             ExprKind::Cast(ref expr, ref ty) => {\n-                let expr = P(self.lower_expr(expr));\n-                hir::ExprKind::Cast(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))\n+                let expr = self.lower_expr(expr);\n+                let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n+                hir::ExprKind::Cast(expr, self.arena.alloc(ty.into_inner()))\n             }\n             ExprKind::Type(ref expr, ref ty) => {\n-                let expr = P(self.lower_expr(expr));\n-                hir::ExprKind::Type(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))\n+                let expr = self.lower_expr(expr);\n+                let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n+                hir::ExprKind::Type(expr, self.arena.alloc(ty.into_inner()))\n             }\n             ExprKind::AddrOf(k, m, ref ohs) => {\n-                let ohs = P(self.lower_expr(ohs));\n+                let ohs = self.lower_expr(ohs);\n                 hir::ExprKind::AddrOf(k, m, ohs)\n             }\n             ExprKind::Let(ref pat, ref scrutinee) => self.lower_expr_let(e.span, pat, scrutinee),\n@@ -85,8 +91,8 @@ impl LoweringContext<'_, '_> {\n             }),\n             ExprKind::TryBlock(ref body) => self.lower_expr_try_block(body),\n             ExprKind::Match(ref expr, ref arms) => hir::ExprKind::Match(\n-                P(self.lower_expr(expr)),\n-                arms.iter().map(|x| self.lower_arm(x)).collect(),\n+                self.lower_expr(expr),\n+                self.arena.alloc_from_iter(arms.iter().map(|x| self.lower_arm(x))),\n                 hir::MatchSource::Normal,\n             ),\n             ExprKind::Async(capture_clause, closure_node_id, ref block) => self.make_async_expr(\n@@ -123,16 +129,16 @@ impl LoweringContext<'_, '_> {\n                 self.lower_label(opt_label),\n             ),\n             ExprKind::Assign(ref el, ref er, span) => {\n-                hir::ExprKind::Assign(P(self.lower_expr(el)), P(self.lower_expr(er)), span)\n+                hir::ExprKind::Assign(self.lower_expr(el), self.lower_expr(er), span)\n             }\n             ExprKind::AssignOp(op, ref el, ref er) => hir::ExprKind::AssignOp(\n                 self.lower_binop(op),\n-                P(self.lower_expr(el)),\n-                P(self.lower_expr(er)),\n+                self.lower_expr(el),\n+                self.lower_expr(er),\n             ),\n-            ExprKind::Field(ref el, ident) => hir::ExprKind::Field(P(self.lower_expr(el)), ident),\n+            ExprKind::Field(ref el, ident) => hir::ExprKind::Field(self.lower_expr(el), ident),\n             ExprKind::Index(ref el, ref er) => {\n-                hir::ExprKind::Index(P(self.lower_expr(el)), P(self.lower_expr(er)))\n+                hir::ExprKind::Index(self.lower_expr(el), self.lower_expr(er))\n             }\n             ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n                 self.lower_expr_range_closed(e.span, e1, e2)\n@@ -150,28 +156,34 @@ impl LoweringContext<'_, '_> {\n                 );\n                 hir::ExprKind::Path(qpath)\n             }\n-            ExprKind::Break(opt_label, ref opt_expr) => hir::ExprKind::Break(\n-                self.lower_jump_destination(e.id, opt_label),\n-                opt_expr.as_ref().map(|x| P(self.lower_expr(x))),\n-            ),\n+            ExprKind::Break(opt_label, ref opt_expr) => {\n+                let opt_expr = opt_expr.as_ref().map(|x| self.lower_expr(x));\n+                hir::ExprKind::Break(self.lower_jump_destination(e.id, opt_label), opt_expr)\n+            }\n             ExprKind::Continue(opt_label) => {\n                 hir::ExprKind::Continue(self.lower_jump_destination(e.id, opt_label))\n             }\n-            ExprKind::Ret(ref e) => hir::ExprKind::Ret(e.as_ref().map(|x| P(self.lower_expr(x)))),\n+            ExprKind::Ret(ref e) => {\n+                let e = e.as_ref().map(|x| self.lower_expr(x));\n+                hir::ExprKind::Ret(e)\n+            }\n             ExprKind::InlineAsm(ref asm) => self.lower_expr_asm(asm),\n-            ExprKind::Struct(ref path, ref fields, ref maybe_expr) => hir::ExprKind::Struct(\n-                P(self.lower_qpath(\n-                    e.id,\n-                    &None,\n-                    path,\n-                    ParamMode::Optional,\n-                    ImplTraitContext::disallowed(),\n-                )),\n-                fields.iter().map(|x| self.lower_field(x)).collect(),\n-                maybe_expr.as_ref().map(|x| P(self.lower_expr(x))),\n-            ),\n+            ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n+                let maybe_expr = maybe_expr.as_ref().map(|x| self.lower_expr(x));\n+                hir::ExprKind::Struct(\n+                    self.arena.alloc(self.lower_qpath(\n+                        e.id,\n+                        &None,\n+                        path,\n+                        ParamMode::Optional,\n+                        ImplTraitContext::disallowed(),\n+                    )),\n+                    self.arena.alloc_from_iter(fields.iter().map(|x| self.lower_field(x))),\n+                    maybe_expr,\n+                )\n+            }\n             ExprKind::Paren(ref ex) => {\n-                let mut ex = self.lower_expr(ex);\n+                let mut ex = self.lower_expr_mut(ex);\n                 // Include parens in span, but only if it is a super-span.\n                 if e.span.contains(ex.span) {\n                     ex.span = e.span;\n@@ -237,7 +249,7 @@ impl LoweringContext<'_, '_> {\n     /// ```rust\n     /// match scrutinee { pats => true, _ => false }\n     /// ```\n-    fn lower_expr_let(&mut self, span: Span, pat: &Pat, scrutinee: &Expr) -> hir::ExprKind {\n+    fn lower_expr_let(&mut self, span: Span, pat: &Pat, scrutinee: &Expr) -> hir::ExprKind<'hir> {\n         // If we got here, the `let` expression is not allowed.\n \n         if self.sess.opts.unstable_features.is_nightly_build() {\n@@ -266,16 +278,16 @@ impl LoweringContext<'_, '_> {\n         let then_arm = {\n             let pat = self.lower_pat(pat);\n             let expr = self.expr_bool(span, true);\n-            self.arm(pat, P(expr))\n+            self.arm(pat, expr)\n         };\n         let else_arm = {\n             let pat = self.pat_wild(span);\n             let expr = self.expr_bool(span, false);\n-            self.arm(pat, P(expr))\n+            self.arm(pat, expr)\n         };\n         hir::ExprKind::Match(\n-            P(scrutinee),\n-            vec![then_arm, else_arm].into(),\n+            scrutinee,\n+            arena_vec![self; then_arm, else_arm],\n             hir::MatchSource::Normal,\n         )\n     }\n@@ -286,7 +298,7 @@ impl LoweringContext<'_, '_> {\n         cond: &Expr,\n         then: &Block,\n         else_opt: Option<&Expr>,\n-    ) -> hir::ExprKind {\n+    ) -> hir::ExprKind<'hir> {\n         // FIXME(#53667): handle lowering of && and parens.\n \n         // `_ => else_block` where `else_block` is `{}` if there's `None`:\n@@ -295,7 +307,7 @@ impl LoweringContext<'_, '_> {\n             None => (self.expr_block_empty(span), false),\n             Some(els) => (self.lower_expr(els), true),\n         };\n-        let else_arm = self.arm(else_pat, P(else_expr));\n+        let else_arm = self.arm(else_pat, else_expr);\n \n         // Handle then + scrutinee:\n         let then_expr = self.lower_block_expr(then);\n@@ -315,14 +327,14 @@ impl LoweringContext<'_, '_> {\n                 // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n                 // to preserve drop semantics since `if cond { ... }` does not\n                 // let temporaries live outside of `cond`.\n-                let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n+                let cond = self.expr_drop_temps(span_block, cond, ThinVec::new());\n                 let pat = self.pat_bool(span, true);\n                 (pat, cond, hir::MatchSource::IfDesugar { contains_else_clause })\n             }\n         };\n-        let then_arm = self.arm(then_pat, P(then_expr));\n+        let then_arm = self.arm(then_pat, self.arena.alloc(then_expr));\n \n-        hir::ExprKind::Match(P(scrutinee), vec![then_arm, else_arm].into(), desugar)\n+        hir::ExprKind::Match(scrutinee, arena_vec![self; then_arm, else_arm], desugar)\n     }\n \n     fn lower_expr_while_in_loop_scope(\n@@ -331,7 +343,7 @@ impl LoweringContext<'_, '_> {\n         cond: &Expr,\n         body: &Block,\n         opt_label: Option<Label>,\n-    ) -> hir::ExprKind {\n+    ) -> hir::ExprKind<'hir> {\n         // FIXME(#53667): handle lowering of && and parens.\n \n         // Note that the block AND the condition are evaluated in the loop scope.\n@@ -379,28 +391,36 @@ impl LoweringContext<'_, '_> {\n                 // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n                 // to preserve drop semantics since `while cond { ... }` does not\n                 // let temporaries live outside of `cond`.\n-                let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n+                let cond = self.expr_drop_temps(span_block, cond, ThinVec::new());\n                 // `true => <then>`:\n                 let pat = self.pat_bool(span, true);\n                 (pat, cond, hir::MatchSource::WhileDesugar, hir::LoopSource::While)\n             }\n         };\n-        let then_arm = self.arm(then_pat, P(then_expr));\n+        let then_arm = self.arm(then_pat, self.arena.alloc(then_expr));\n \n         // `match <scrutinee> { ... }`\n-        let match_expr =\n-            self.expr_match(scrutinee.span, P(scrutinee), hir_vec![then_arm, else_arm], desugar);\n+        let match_expr = self.expr_match(\n+            scrutinee.span,\n+            scrutinee,\n+            arena_vec![self; then_arm, else_arm],\n+            desugar,\n+        );\n \n         // `[opt_ident]: loop { ... }`\n-        hir::ExprKind::Loop(P(self.block_expr(P(match_expr))), self.lower_label(opt_label), source)\n+        hir::ExprKind::Loop(\n+            self.block_expr(self.arena.alloc(match_expr)),\n+            self.lower_label(opt_label),\n+            source,\n+        )\n     }\n \n     /// Desugar `try { <stmts>; <expr> }` into `{ <stmts>; ::std::ops::Try::from_ok(<expr>) }`,\n     /// `try { <stmts>; }` into `{ <stmts>; ::std::ops::Try::from_ok(()) }`\n     /// and save the block id to use it as a break target for desugaring of the `?` operator.\n-    fn lower_expr_try_block(&mut self, body: &Block) -> hir::ExprKind {\n+    fn lower_expr_try_block(&mut self, body: &Block) -> hir::ExprKind<'hir> {\n         self.with_catch_scope(body.id, |this| {\n-            let mut block = this.lower_block(body, true).into_inner();\n+            let mut block = this.lower_block_noalloc(body, true);\n \n             let try_span = this.mark_span_with_reason(\n                 DesugaringKind::TryBlock,\n@@ -409,10 +429,10 @@ impl LoweringContext<'_, '_> {\n             );\n \n             // Final expression of the block (if present) or `()` with span at the end of block\n-            let tail_expr = block.expr.take().map_or_else(\n-                || this.expr_unit(this.sess.source_map().end_point(try_span)),\n-                |x: P<hir::Expr>| x.into_inner(),\n-            );\n+            let tail_expr = block\n+                .expr\n+                .take()\n+                .unwrap_or_else(|| this.expr_unit(this.sess.source_map().end_point(try_span)));\n \n             let ok_wrapped_span =\n                 this.mark_span_with_reason(DesugaringKind::TryBlock, tail_expr.span, None);\n@@ -425,32 +445,33 @@ impl LoweringContext<'_, '_> {\n                 ok_wrapped_span,\n             ));\n \n-            hir::ExprKind::Block(P(block), None)\n+            hir::ExprKind::Block(this.arena.alloc(block), None)\n         })\n     }\n \n     fn wrap_in_try_constructor(\n         &mut self,\n         method: Symbol,\n         method_span: Span,\n-        expr: hir::Expr,\n+        expr: &'hir hir::Expr<'hir>,\n         overall_span: Span,\n-    ) -> P<hir::Expr> {\n+    ) -> &'hir hir::Expr<'hir> {\n         let path = &[sym::ops, sym::Try, method];\n-        let constructor = P(self.expr_std_path(method_span, path, None, ThinVec::new()));\n-        P(self.expr_call(overall_span, constructor, hir_vec![expr]))\n+        let constructor =\n+            self.arena.alloc(self.expr_std_path(method_span, path, None, ThinVec::new()));\n+        self.expr_call(overall_span, constructor, std::slice::from_ref(expr))\n     }\n \n-    fn lower_arm(&mut self, arm: &Arm) -> hir::Arm {\n+    fn lower_arm(&mut self, arm: &Arm) -> hir::Arm<'hir> {\n         hir::Arm {\n             hir_id: self.next_id(),\n-            attrs: self.lower_attrs(&arm.attrs),\n+            attrs: self.lower_attrs_arena(&arm.attrs),\n             pat: self.lower_pat(&arm.pat),\n             guard: match arm.guard {\n-                Some(ref x) => Some(hir::Guard::If(P(self.lower_expr(x)))),\n+                Some(ref x) => Some(hir::Guard::If(self.lower_expr(x))),\n                 _ => None,\n             },\n-            body: P(self.lower_expr(&arm.body)),\n+            body: self.lower_expr(&arm.body),\n             span: arm.span,\n         }\n     }\n@@ -462,14 +483,16 @@ impl LoweringContext<'_, '_> {\n         ret_ty: Option<AstP<Ty>>,\n         span: Span,\n         async_gen_kind: hir::AsyncGeneratorKind,\n-        body: impl FnOnce(&mut LoweringContext<'_, '_>) -> hir::Expr,\n-    ) -> hir::ExprKind {\n+        body: impl FnOnce(&mut Self) -> hir::Expr<'hir>,\n+    ) -> hir::ExprKind<'hir> {\n         let output = match ret_ty {\n             Some(ty) => FunctionRetTy::Ty(ty),\n             None => FunctionRetTy::Default(span),\n         };\n         let ast_decl = FnDecl { inputs: vec![], output };\n-        let decl = self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None);\n+        let decl = self.arena.alloc(\n+            self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None).into_inner(),\n+        );\n         let body_id = self.lower_fn_body(&ast_decl, |this| {\n             this.generator_kind = Some(hir::GeneratorKind::Async(async_gen_kind));\n             body(this)\n@@ -501,7 +524,7 @@ impl LoweringContext<'_, '_> {\n         );\n \n         // `future::from_generator(generator)`:\n-        hir::ExprKind::Call(P(gen_future), hir_vec![generator])\n+        hir::ExprKind::Call(self.arena.alloc(gen_future), arena_vec![self; generator])\n     }\n \n     /// Desugar `<expr>.await` into:\n@@ -518,7 +541,7 @@ impl LoweringContext<'_, '_> {\n     ///     }\n     /// }\n     /// ```\n-    fn lower_expr_await(&mut self, await_span: Span, expr: &Expr) -> hir::ExprKind {\n+    fn lower_expr_await(&mut self, await_span: Span, expr: &Expr) -> hir::ExprKind<'hir> {\n         match self.generator_kind {\n             Some(hir::GeneratorKind::Async(_)) => {}\n             Some(hir::GeneratorKind::Gen) | None => {\n@@ -550,23 +573,24 @@ impl LoweringContext<'_, '_> {\n         //     ::std::pin::Pin::new_unchecked(&mut pinned)\n         // })`\n         let poll_expr = {\n-            let pinned = P(self.expr_ident(span, pinned_ident, pinned_pat_hid));\n+            let pinned = self.expr_ident(span, pinned_ident, pinned_pat_hid);\n             let ref_mut_pinned = self.expr_mut_addr_of(span, pinned);\n             let pin_ty_id = self.next_id();\n             let new_unchecked_expr_kind = self.expr_call_std_assoc_fn(\n                 pin_ty_id,\n                 span,\n                 &[sym::pin, sym::Pin],\n                 \"new_unchecked\",\n-                hir_vec![ref_mut_pinned],\n+                arena_vec![self; ref_mut_pinned],\n             );\n-            let new_unchecked = P(self.expr(span, new_unchecked_expr_kind, ThinVec::new()));\n+            let new_unchecked =\n+                self.arena.alloc(self.expr(span, new_unchecked_expr_kind, ThinVec::new()));\n             let unsafe_expr = self.expr_unsafe(new_unchecked);\n-            P(self.expr_call_std_path(\n+            self.expr_call_std_path(\n                 gen_future_span,\n                 &[sym::future, sym::poll_with_tls_context],\n-                hir_vec![unsafe_expr],\n-            ))\n+                arena_vec![self; unsafe_expr],\n+            )\n         };\n \n         // `::std::task::Poll::Ready(result) => break result`\n@@ -575,30 +599,32 @@ impl LoweringContext<'_, '_> {\n         let ready_arm = {\n             let x_ident = Ident::with_dummy_span(sym::result);\n             let (x_pat, x_pat_hid) = self.pat_ident(span, x_ident);\n-            let x_expr = P(self.expr_ident(span, x_ident, x_pat_hid));\n-            let ready_pat =\n-                self.pat_std_enum(span, &[sym::task, sym::Poll, sym::Ready], hir_vec![x_pat]);\n-            let break_x = self.with_loop_scope(loop_node_id, |this| {\n+            let x_expr = self.expr_ident(span, x_ident, x_pat_hid);\n+            let ready_pat = self.pat_std_enum(\n+                span,\n+                &[sym::task, sym::Poll, sym::Ready],\n+                arena_vec![self; x_pat],\n+            );\n+            let break_x = self.with_loop_scope(loop_node_id, move |this| {\n                 let expr_break =\n                     hir::ExprKind::Break(this.lower_loop_destination(None), Some(x_expr));\n-                P(this.expr(await_span, expr_break, ThinVec::new()))\n+                this.arena.alloc(this.expr(await_span, expr_break, ThinVec::new()))\n             });\n             self.arm(ready_pat, break_x)\n         };\n \n         // `::std::task::Poll::Pending => {}`\n         let pending_arm = {\n-            let pending_pat =\n-                self.pat_std_enum(span, &[sym::task, sym::Poll, sym::Pending], hir_vec![]);\n-            let empty_block = P(self.expr_block_empty(span));\n+            let pending_pat = self.pat_std_enum(span, &[sym::task, sym::Poll, sym::Pending], &[]);\n+            let empty_block = self.expr_block_empty(span);\n             self.arm(pending_pat, empty_block)\n         };\n \n         let inner_match_stmt = {\n             let match_expr = self.expr_match(\n                 span,\n                 poll_expr,\n-                hir_vec![ready_arm, pending_arm],\n+                arena_vec![self; ready_arm, pending_arm],\n                 hir::MatchSource::AwaitDesugar,\n             );\n             self.stmt_expr(span, match_expr)\n@@ -608,16 +634,16 @@ impl LoweringContext<'_, '_> {\n             let unit = self.expr_unit(span);\n             let yield_expr = self.expr(\n                 span,\n-                hir::ExprKind::Yield(P(unit), hir::YieldSource::Await),\n+                hir::ExprKind::Yield(unit, hir::YieldSource::Await),\n                 ThinVec::new(),\n             );\n             self.stmt_expr(span, yield_expr)\n         };\n \n-        let loop_block = P(self.block_all(span, hir_vec![inner_match_stmt, yield_stmt], None));\n+        let loop_block = self.block_all(span, arena_vec![self; inner_match_stmt, yield_stmt], None);\n \n         // loop { .. }\n-        let loop_expr = P(hir::Expr {\n+        let loop_expr = self.arena.alloc(hir::Expr {\n             hir_id: loop_hir_id,\n             kind: hir::ExprKind::Loop(loop_block, None, hir::LoopSource::Loop),\n             span,\n@@ -630,8 +656,8 @@ impl LoweringContext<'_, '_> {\n         // match <expr> {\n         //     mut pinned => loop { .. }\n         // }\n-        let expr = P(self.lower_expr(expr));\n-        hir::ExprKind::Match(expr, hir_vec![pinned_arm], hir::MatchSource::AwaitDesugar)\n+        let expr = self.lower_expr(expr);\n+        hir::ExprKind::Match(expr, arena_vec![self; pinned_arm], hir::MatchSource::AwaitDesugar)\n     }\n \n     fn lower_expr_closure(\n@@ -641,16 +667,17 @@ impl LoweringContext<'_, '_> {\n         decl: &FnDecl,\n         body: &Expr,\n         fn_decl_span: Span,\n-    ) -> hir::ExprKind {\n+    ) -> hir::ExprKind<'hir> {\n         // Lower outside new scope to preserve `is_in_loop_condition`.\n         let fn_decl = self.lower_fn_decl(decl, None, false, None);\n+        let fn_decl = self.arena.alloc(fn_decl.into_inner());\n \n-        self.with_new_scopes(|this| {\n+        self.with_new_scopes(move |this| {\n             let prev = this.current_item;\n             this.current_item = Some(fn_decl_span);\n             let mut generator_kind = None;\n             let body_id = this.lower_fn_body(decl, |this| {\n-                let e = this.lower_expr(body);\n+                let e = this.lower_expr_mut(body);\n                 generator_kind = this.generator_kind;\n                 e\n             });\n@@ -699,15 +726,16 @@ impl LoweringContext<'_, '_> {\n         decl: &FnDecl,\n         body: &Expr,\n         fn_decl_span: Span,\n-    ) -> hir::ExprKind {\n+    ) -> hir::ExprKind<'hir> {\n         let outer_decl =\n             FnDecl { inputs: decl.inputs.clone(), output: FunctionRetTy::Default(fn_decl_span) };\n         // We need to lower the declaration outside the new scope, because we\n         // have to conserve the state of being inside a loop condition for the\n         // closure argument types.\n         let fn_decl = self.lower_fn_decl(&outer_decl, None, false, None);\n+        let fn_decl = self.arena.alloc(fn_decl.into_inner());\n \n-        self.with_new_scopes(|this| {\n+        self.with_new_scopes(move |this| {\n             // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n             if capture_clause == CaptureBy::Ref && !decl.inputs.is_empty() {\n                 struct_span_err!(\n@@ -734,7 +762,7 @@ impl LoweringContext<'_, '_> {\n                     async_ret_ty,\n                     body.span,\n                     hir::AsyncGeneratorKind::Closure,\n-                    |this| this.with_new_scopes(|this| this.lower_expr(body)),\n+                    |this| this.with_new_scopes(|this| this.lower_expr_mut(body)),\n                 );\n                 this.expr(fn_decl_span, async_body, ThinVec::new())\n             });\n@@ -743,16 +771,16 @@ impl LoweringContext<'_, '_> {\n     }\n \n     /// Desugar `<start>..=<end>` into `std::ops::RangeInclusive::new(<start>, <end>)`.\n-    fn lower_expr_range_closed(&mut self, span: Span, e1: &Expr, e2: &Expr) -> hir::ExprKind {\n+    fn lower_expr_range_closed(&mut self, span: Span, e1: &Expr, e2: &Expr) -> hir::ExprKind<'hir> {\n         let id = self.next_id();\n-        let e1 = self.lower_expr(e1);\n-        let e2 = self.lower_expr(e2);\n+        let e1 = self.lower_expr_mut(e1);\n+        let e2 = self.lower_expr_mut(e2);\n         self.expr_call_std_assoc_fn(\n             id,\n             span,\n             &[sym::ops, sym::RangeInclusive],\n             \"new\",\n-            hir_vec![e1, e2],\n+            arena_vec![self; e1, e2],\n         )\n     }\n \n@@ -762,7 +790,7 @@ impl LoweringContext<'_, '_> {\n         e1: Option<&Expr>,\n         e2: Option<&Expr>,\n         lims: RangeLimits,\n-    ) -> hir::ExprKind {\n+    ) -> hir::ExprKind<'hir> {\n         use syntax::ast::RangeLimits::*;\n \n         let path = match (e1, e2, lims) {\n@@ -777,16 +805,13 @@ impl LoweringContext<'_, '_> {\n             }\n         };\n \n-        let fields = e1\n-            .iter()\n-            .map(|e| (\"start\", e))\n-            .chain(e2.iter().map(|e| (\"end\", e)))\n-            .map(|(s, e)| {\n-                let expr = P(self.lower_expr(&e));\n+        let fields = self.arena.alloc_from_iter(\n+            e1.iter().map(|e| (\"start\", e)).chain(e2.iter().map(|e| (\"end\", e))).map(|(s, e)| {\n+                let expr = self.lower_expr(&e);\n                 let ident = Ident::new(Symbol::intern(s), e.span);\n                 self.field(ident, expr, e.span)\n-            })\n-            .collect::<P<[hir::Field]>>();\n+            }),\n+        );\n \n         let is_unit = fields.is_empty();\n         let struct_path = [sym::ops, path];\n@@ -796,7 +821,7 @@ impl LoweringContext<'_, '_> {\n         if is_unit {\n             hir::ExprKind::Path(struct_path)\n         } else {\n-            hir::ExprKind::Struct(P(struct_path), fields, None)\n+            hir::ExprKind::Struct(self.arena.alloc(struct_path), fields, None)\n         }\n     }\n \n@@ -837,7 +862,7 @@ impl LoweringContext<'_, '_> {\n \n     fn with_catch_scope<T, F>(&mut self, catch_id: NodeId, f: F) -> T\n     where\n-        F: FnOnce(&mut LoweringContext<'_, '_>) -> T,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         let len = self.catch_scopes.len();\n         self.catch_scopes.push(catch_id);\n@@ -856,7 +881,7 @@ impl LoweringContext<'_, '_> {\n \n     fn with_loop_scope<T, F>(&mut self, loop_id: NodeId, f: F) -> T\n     where\n-        F: FnOnce(&mut LoweringContext<'_, '_>) -> T,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         // We're no longer in the base loop's condition; we're in another loop.\n         let was_in_loop_condition = self.is_in_loop_condition;\n@@ -881,7 +906,7 @@ impl LoweringContext<'_, '_> {\n \n     fn with_loop_condition_scope<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut LoweringContext<'_, '_>) -> T,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         let was_in_loop_condition = self.is_in_loop_condition;\n         self.is_in_loop_condition = true;\n@@ -893,7 +918,7 @@ impl LoweringContext<'_, '_> {\n         result\n     }\n \n-    fn lower_expr_asm(&mut self, asm: &InlineAsm) -> hir::ExprKind {\n+    fn lower_expr_asm(&mut self, asm: &InlineAsm) -> hir::ExprKind<'hir> {\n         let inner = hir::InlineAsmInner {\n             inputs: asm.inputs.iter().map(|&(ref c, _)| c.clone()).collect(),\n             outputs: asm\n@@ -915,23 +940,27 @@ impl LoweringContext<'_, '_> {\n         };\n         let hir_asm = hir::InlineAsm {\n             inner,\n-            inputs_exprs: asm.inputs.iter().map(|&(_, ref input)| self.lower_expr(input)).collect(),\n-            outputs_exprs: asm.outputs.iter().map(|out| self.lower_expr(&out.expr)).collect(),\n+            inputs_exprs: self.arena.alloc_from_iter(\n+                asm.inputs.iter().map(|&(_, ref input)| self.lower_expr_mut(input)),\n+            ),\n+            outputs_exprs: self\n+                .arena\n+                .alloc_from_iter(asm.outputs.iter().map(|out| self.lower_expr_mut(&out.expr))),\n         };\n-        hir::ExprKind::InlineAsm(P(hir_asm))\n+        hir::ExprKind::InlineAsm(self.arena.alloc(hir_asm))\n     }\n \n-    fn lower_field(&mut self, f: &Field) -> hir::Field {\n+    fn lower_field(&mut self, f: &Field) -> hir::Field<'hir> {\n         hir::Field {\n             hir_id: self.next_id(),\n             ident: f.ident,\n-            expr: P(self.lower_expr(&f.expr)),\n+            expr: self.lower_expr(&f.expr),\n             span: f.span,\n             is_shorthand: f.is_shorthand,\n         }\n     }\n \n-    fn lower_expr_yield(&mut self, span: Span, opt_expr: Option<&Expr>) -> hir::ExprKind {\n+    fn lower_expr_yield(&mut self, span: Span, opt_expr: Option<&Expr>) -> hir::ExprKind<'hir> {\n         match self.generator_kind {\n             Some(hir::GeneratorKind::Gen) => {}\n             Some(hir::GeneratorKind::Async(_)) => {\n@@ -944,7 +973,7 @@ impl LoweringContext<'_, '_> {\n         let expr =\n             opt_expr.as_ref().map(|x| self.lower_expr(x)).unwrap_or_else(|| self.expr_unit(span));\n \n-        hir::ExprKind::Yield(P(expr), hir::YieldSource::Yield)\n+        hir::ExprKind::Yield(expr, hir::YieldSource::Yield)\n     }\n \n     /// Desugar `ExprForLoop` from: `[opt_ident]: for <pat> in <head> <body>` into:\n@@ -973,9 +1002,9 @@ impl LoweringContext<'_, '_> {\n         head: &Expr,\n         body: &Block,\n         opt_label: Option<Label>,\n-    ) -> hir::Expr {\n+    ) -> hir::Expr<'hir> {\n         // expand <head>\n-        let mut head = self.lower_expr(head);\n+        let mut head = self.lower_expr_mut(head);\n         let desugared_span = self.mark_span_with_reason(DesugaringKind::ForLoop, head.span, None);\n         head.span = desugared_span;\n \n@@ -992,9 +1021,9 @@ impl LoweringContext<'_, '_> {\n         let pat_arm = {\n             let val_ident = Ident::with_dummy_span(sym::val);\n             let (val_pat, val_pat_hid) = self.pat_ident(pat.span, val_ident);\n-            let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat_hid));\n-            let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat_hid));\n-            let assign = P(self.expr(\n+            let val_expr = self.expr_ident(pat.span, val_ident, val_pat_hid);\n+            let next_expr = self.expr_ident(pat.span, next_ident, next_pat_hid);\n+            let assign = self.arena.alloc(self.expr(\n                 pat.span,\n                 hir::ExprKind::Assign(next_expr, val_expr, pat.span),\n                 ThinVec::new(),\n@@ -1017,18 +1046,18 @@ impl LoweringContext<'_, '_> {\n \n         // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n         let match_expr = {\n-            let iter = P(self.expr_ident(desugared_span, iter, iter_pat_nid));\n+            let iter = self.expr_ident(desugared_span, iter, iter_pat_nid);\n             let ref_mut_iter = self.expr_mut_addr_of(desugared_span, iter);\n             let next_path = &[sym::iter, sym::Iterator, sym::next];\n             let next_expr =\n-                P(self.expr_call_std_path(desugared_span, next_path, hir_vec![ref_mut_iter]));\n-            let arms = hir_vec![pat_arm, break_arm];\n+                self.expr_call_std_path(desugared_span, next_path, arena_vec![self; ref_mut_iter]);\n+            let arms = arena_vec![self; pat_arm, break_arm];\n \n             self.expr_match(desugared_span, next_expr, arms, hir::MatchSource::ForLoopDesugar)\n         };\n         let match_stmt = self.stmt_expr(desugared_span, match_expr);\n \n-        let next_expr = P(self.expr_ident(desugared_span, next_ident, next_pat_hid));\n+        let next_expr = self.expr_ident(desugared_span, next_ident, next_pat_hid);\n \n         // `let mut __next`\n         let next_let = self.stmt_let_pat(\n@@ -1053,13 +1082,16 @@ impl LoweringContext<'_, '_> {\n         let body_expr = self.expr_block(body_block, ThinVec::new());\n         let body_stmt = self.stmt_expr(body.span, body_expr);\n \n-        let loop_block =\n-            P(self.block_all(e.span, hir_vec![next_let, match_stmt, pat_let, body_stmt], None));\n+        let loop_block = self.block_all(\n+            e.span,\n+            arena_vec![self; next_let, match_stmt, pat_let, body_stmt],\n+            None,\n+        );\n \n         // `[opt_ident]: loop { ... }`\n         let kind =\n             hir::ExprKind::Loop(loop_block, self.lower_label(opt_label), hir::LoopSource::ForLoop);\n-        let loop_expr = P(hir::Expr {\n+        let loop_expr = self.arena.alloc(hir::Expr {\n             hir_id: self.lower_node_id(e.id),\n             kind,\n             span: e.span,\n@@ -1072,13 +1104,13 @@ impl LoweringContext<'_, '_> {\n         // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n         let into_iter_expr = {\n             let into_iter_path = &[sym::iter, sym::IntoIterator, sym::into_iter];\n-            P(self.expr_call_std_path(desugared_span, into_iter_path, hir_vec![head]))\n+            self.expr_call_std_path(desugared_span, into_iter_path, arena_vec![self; head])\n         };\n \n-        let match_expr = P(self.expr_match(\n+        let match_expr = self.arena.alloc(self.expr_match(\n             desugared_span,\n             into_iter_expr,\n-            hir_vec![iter_arm],\n+            arena_vec![self; iter_arm],\n             hir::MatchSource::ForLoopDesugar,\n         ));\n \n@@ -1088,7 +1120,7 @@ impl LoweringContext<'_, '_> {\n         // surrounding scope of the `match` since the `match` is not a terminating scope.\n         //\n         // Also, add the attributes to the outer returned expr node.\n-        self.expr_drop_temps(desugared_span, match_expr, e.attrs.clone())\n+        self.expr_drop_temps_mut(desugared_span, match_expr, e.attrs.clone())\n     }\n \n     /// Desugar `ExprKind::Try` from: `<expr>?` into:\n@@ -1102,7 +1134,7 @@ impl LoweringContext<'_, '_> {\n     ///                 return Try::from_error(From::from(err)),\n     /// }\n     /// ```\n-    fn lower_expr_try(&mut self, span: Span, sub_expr: &Expr) -> hir::ExprKind {\n+    fn lower_expr_try(&mut self, span: Span, sub_expr: &Expr) -> hir::ExprKind<'hir> {\n         let unstable_span = self.mark_span_with_reason(\n             DesugaringKind::QuestionMark,\n             span,\n@@ -1118,10 +1150,10 @@ impl LoweringContext<'_, '_> {\n         // `Try::into_result(<expr>)`\n         let scrutinee = {\n             // expand <expr>\n-            let sub_expr = self.lower_expr(sub_expr);\n+            let sub_expr = self.lower_expr_mut(sub_expr);\n \n             let path = &[sym::ops, sym::Try, sym::into_result];\n-            P(self.expr_call_std_path(unstable_span, path, hir_vec![sub_expr]))\n+            self.expr_call_std_path(unstable_span, path, arena_vec![self; sub_expr])\n         };\n \n         // `#[allow(unreachable_code)]`\n@@ -1141,7 +1173,7 @@ impl LoweringContext<'_, '_> {\n         let ok_arm = {\n             let val_ident = Ident::with_dummy_span(sym::val);\n             let (val_pat, val_pat_nid) = self.pat_ident(span, val_ident);\n-            let val_expr = P(self.expr_ident_with_attrs(\n+            let val_expr = self.arena.alloc(self.expr_ident_with_attrs(\n                 span,\n                 val_ident,\n                 val_pat_nid,\n@@ -1158,16 +1190,16 @@ impl LoweringContext<'_, '_> {\n             let (err_local, err_local_nid) = self.pat_ident(try_span, err_ident);\n             let from_expr = {\n                 let from_path = &[sym::convert, sym::From, sym::from];\n-                let err_expr = self.expr_ident(try_span, err_ident, err_local_nid);\n-                self.expr_call_std_path(try_span, from_path, hir_vec![err_expr])\n+                let err_expr = self.expr_ident_mut(try_span, err_ident, err_local_nid);\n+                self.expr_call_std_path(try_span, from_path, arena_vec![self; err_expr])\n             };\n             let from_err_expr =\n                 self.wrap_in_try_constructor(sym::from_error, unstable_span, from_expr, try_span);\n             let thin_attrs = ThinVec::from(attrs);\n             let catch_scope = self.catch_scopes.last().map(|x| *x);\n             let ret_expr = if let Some(catch_node) = catch_scope {\n                 let target_id = Ok(self.lower_node_id(catch_node));\n-                P(self.expr(\n+                self.arena.alloc(self.expr(\n                     try_span,\n                     hir::ExprKind::Break(\n                         hir::Destination { label: None, target_id },\n@@ -1176,24 +1208,32 @@ impl LoweringContext<'_, '_> {\n                     thin_attrs,\n                 ))\n             } else {\n-                P(self.expr(try_span, hir::ExprKind::Ret(Some(from_err_expr)), thin_attrs))\n+                self.arena.alloc(self.expr(\n+                    try_span,\n+                    hir::ExprKind::Ret(Some(from_err_expr)),\n+                    thin_attrs,\n+                ))\n             };\n \n             let err_pat = self.pat_err(try_span, err_local);\n             self.arm(err_pat, ret_expr)\n         };\n \n-        hir::ExprKind::Match(scrutinee, hir_vec![err_arm, ok_arm], hir::MatchSource::TryDesugar)\n+        hir::ExprKind::Match(\n+            scrutinee,\n+            arena_vec![self; err_arm, ok_arm],\n+            hir::MatchSource::TryDesugar,\n+        )\n     }\n \n     // =========================================================================\n     // Helper methods for building HIR.\n     // =========================================================================\n \n     /// Constructs a `true` or `false` literal expression.\n-    pub(super) fn expr_bool(&mut self, span: Span, val: bool) -> hir::Expr {\n+    pub(super) fn expr_bool(&mut self, span: Span, val: bool) -> &'hir hir::Expr<'hir> {\n         let lit = Spanned { span, node: LitKind::Bool(val) };\n-        self.expr(span, hir::ExprKind::Lit(lit), ThinVec::new())\n+        self.arena.alloc(self.expr(span, hir::ExprKind::Lit(lit), ThinVec::new()))\n     }\n \n     /// Wrap the given `expr` in a terminating scope using `hir::ExprKind::DropTemps`.\n@@ -1205,60 +1245,66 @@ impl LoweringContext<'_, '_> {\n     pub(super) fn expr_drop_temps(\n         &mut self,\n         span: Span,\n-        expr: P<hir::Expr>,\n+        expr: &'hir hir::Expr<'hir>,\n+        attrs: AttrVec,\n+    ) -> &'hir hir::Expr<'hir> {\n+        self.arena.alloc(self.expr_drop_temps_mut(span, expr, attrs))\n+    }\n+\n+    pub(super) fn expr_drop_temps_mut(\n+        &mut self,\n+        span: Span,\n+        expr: &'hir hir::Expr<'hir>,\n         attrs: AttrVec,\n-    ) -> hir::Expr {\n+    ) -> hir::Expr<'hir> {\n         self.expr(span, hir::ExprKind::DropTemps(expr), attrs)\n     }\n \n     fn expr_match(\n         &mut self,\n         span: Span,\n-        arg: P<hir::Expr>,\n-        arms: hir::HirVec<hir::Arm>,\n+        arg: &'hir hir::Expr<'hir>,\n+        arms: &'hir [hir::Arm<'hir>],\n         source: hir::MatchSource,\n-    ) -> hir::Expr {\n+    ) -> hir::Expr<'hir> {\n         self.expr(span, hir::ExprKind::Match(arg, arms, source), ThinVec::new())\n     }\n \n-    fn expr_break(&mut self, span: Span, attrs: AttrVec) -> P<hir::Expr> {\n+    fn expr_break(&mut self, span: Span, attrs: AttrVec) -> &'hir hir::Expr<'hir> {\n         let expr_break = hir::ExprKind::Break(self.lower_loop_destination(None), None);\n-        P(self.expr(span, expr_break, attrs))\n+        self.arena.alloc(self.expr(span, expr_break, attrs))\n     }\n \n-    fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> hir::Expr {\n+    fn expr_mut_addr_of(&mut self, span: Span, e: &'hir hir::Expr<'hir>) -> hir::Expr<'hir> {\n         self.expr(\n             span,\n             hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, e),\n             ThinVec::new(),\n         )\n     }\n \n-    fn expr_unit(&mut self, sp: Span) -> hir::Expr {\n-        self.expr_tuple(sp, hir_vec![])\n-    }\n-\n-    fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<hir::Expr>) -> hir::Expr {\n-        self.expr(sp, hir::ExprKind::Tup(exprs), ThinVec::new())\n+    fn expr_unit(&mut self, sp: Span) -> &'hir hir::Expr<'hir> {\n+        self.arena.alloc(self.expr(sp, hir::ExprKind::Tup(&[]), ThinVec::new()))\n     }\n \n     fn expr_call(\n         &mut self,\n         span: Span,\n-        e: P<hir::Expr>,\n-        args: hir::HirVec<hir::Expr>,\n-    ) -> hir::Expr {\n-        self.expr(span, hir::ExprKind::Call(e, args), ThinVec::new())\n+        e: &'hir hir::Expr<'hir>,\n+        args: &'hir [hir::Expr<'hir>],\n+    ) -> &'hir hir::Expr<'hir> {\n+        self.arena.alloc(self.expr(span, hir::ExprKind::Call(e, args), ThinVec::new()))\n     }\n \n     // Note: associated functions must use `expr_call_std_path`.\n     fn expr_call_std_path(\n         &mut self,\n         span: Span,\n         path_components: &[Symbol],\n-        args: hir::HirVec<hir::Expr>,\n-    ) -> hir::Expr {\n-        let path = P(self.expr_std_path(span, path_components, None, ThinVec::new()));\n+        args: &'hir [hir::Expr<'hir>],\n+    ) -> &'hir hir::Expr<'hir> {\n+        let path =\n+            self.arena.alloc(self.expr_std_path(span, path_components, None, ThinVec::new()));\n         self.expr_call(span, path, args)\n     }\n \n@@ -1277,13 +1323,14 @@ impl LoweringContext<'_, '_> {\n         span: Span,\n         ty_path_components: &[Symbol],\n         assoc_fn_name: &str,\n-        args: hir::HirVec<hir::Expr>,\n-    ) -> hir::ExprKind {\n+        args: &'hir [hir::Expr<'hir>],\n+    ) -> hir::ExprKind<'hir> {\n         let ty_path = P(self.std_path(span, ty_path_components, None, false));\n         let ty = P(self.ty_path(ty_path_id, span, hir::QPath::Resolved(None, ty_path)));\n         let fn_seg = P(hir::PathSegment::from_ident(Ident::from_str(assoc_fn_name)));\n         let fn_path = hir::QPath::TypeRelative(ty, fn_seg);\n-        let fn_expr = P(self.expr(span, hir::ExprKind::Path(fn_path), ThinVec::new()));\n+        let fn_expr =\n+            self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path), ThinVec::new()));\n         hir::ExprKind::Call(fn_expr, args)\n     }\n \n@@ -1293,12 +1340,26 @@ impl LoweringContext<'_, '_> {\n         components: &[Symbol],\n         params: Option<P<hir::GenericArgs>>,\n         attrs: AttrVec,\n-    ) -> hir::Expr {\n+    ) -> hir::Expr<'hir> {\n         let path = self.std_path(span, components, params, true);\n         self.expr(span, hir::ExprKind::Path(hir::QPath::Resolved(None, P(path))), attrs)\n     }\n \n-    pub(super) fn expr_ident(&mut self, sp: Span, ident: Ident, binding: hir::HirId) -> hir::Expr {\n+    pub(super) fn expr_ident(\n+        &mut self,\n+        sp: Span,\n+        ident: Ident,\n+        binding: hir::HirId,\n+    ) -> &'hir hir::Expr<'hir> {\n+        self.arena.alloc(self.expr_ident_mut(sp, ident, binding))\n+    }\n+\n+    pub(super) fn expr_ident_mut(\n+        &mut self,\n+        sp: Span,\n+        ident: Ident,\n+        binding: hir::HirId,\n+    ) -> hir::Expr<'hir> {\n         self.expr_ident_with_attrs(sp, ident, binding, ThinVec::new())\n     }\n \n@@ -1308,7 +1369,7 @@ impl LoweringContext<'_, '_> {\n         ident: Ident,\n         binding: hir::HirId,\n         attrs: AttrVec,\n-    ) -> hir::Expr {\n+    ) -> hir::Expr<'hir> {\n         let expr_path = hir::ExprKind::Path(hir::QPath::Resolved(\n             None,\n             P(hir::Path {\n@@ -1321,14 +1382,14 @@ impl LoweringContext<'_, '_> {\n         self.expr(span, expr_path, attrs)\n     }\n \n-    fn expr_unsafe(&mut self, expr: P<hir::Expr>) -> hir::Expr {\n+    fn expr_unsafe(&mut self, expr: &'hir hir::Expr<'hir>) -> hir::Expr<'hir> {\n         let hir_id = self.next_id();\n         let span = expr.span;\n         self.expr(\n             span,\n             hir::ExprKind::Block(\n-                P(hir::Block {\n-                    stmts: hir_vec![],\n+                self.arena.alloc(hir::Block {\n+                    stmts: &[],\n                     expr: Some(expr),\n                     hir_id,\n                     rules: hir::UnsafeBlock(hir::CompilerGenerated),\n@@ -1341,27 +1402,37 @@ impl LoweringContext<'_, '_> {\n         )\n     }\n \n-    fn expr_block_empty(&mut self, span: Span) -> hir::Expr {\n-        let blk = self.block_all(span, hir_vec![], None);\n-        self.expr_block(P(blk), ThinVec::new())\n+    fn expr_block_empty(&mut self, span: Span) -> &'hir hir::Expr<'hir> {\n+        let blk = self.block_all(span, &[], None);\n+        let expr = self.expr_block(blk, ThinVec::new());\n+        self.arena.alloc(expr)\n     }\n \n-    pub(super) fn expr_block(&mut self, b: P<hir::Block>, attrs: AttrVec) -> hir::Expr {\n+    pub(super) fn expr_block(\n+        &mut self,\n+        b: &'hir hir::Block<'hir>,\n+        attrs: AttrVec,\n+    ) -> hir::Expr<'hir> {\n         self.expr(b.span, hir::ExprKind::Block(b, None), attrs)\n     }\n \n-    pub(super) fn expr(&mut self, span: Span, kind: hir::ExprKind, attrs: AttrVec) -> hir::Expr {\n+    pub(super) fn expr(\n+        &mut self,\n+        span: Span,\n+        kind: hir::ExprKind<'hir>,\n+        attrs: AttrVec,\n+    ) -> hir::Expr<'hir> {\n         hir::Expr { hir_id: self.next_id(), kind, span, attrs }\n     }\n \n-    fn field(&mut self, ident: Ident, expr: P<hir::Expr>, span: Span) -> hir::Field {\n+    fn field(&mut self, ident: Ident, expr: &'hir hir::Expr<'hir>, span: Span) -> hir::Field<'hir> {\n         hir::Field { hir_id: self.next_id(), ident, span, expr, is_shorthand: false }\n     }\n \n-    fn arm(&mut self, pat: P<hir::Pat>, expr: P<hir::Expr>) -> hir::Arm {\n+    fn arm(&mut self, pat: &'hir hir::Pat<'hir>, expr: &'hir hir::Expr<'hir>) -> hir::Arm<'hir> {\n         hir::Arm {\n             hir_id: self.next_id(),\n-            attrs: hir_vec![],\n+            attrs: &[],\n             pat,\n             guard: None,\n             span: expr.span,"}, {"sha": "0157e89c96b04a22d747ed2a550a317160ecf9fc", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -797,8 +797,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Provided(body_id)))\n             }\n             AssocItemKind::TyAlias(ref bounds, ref default) => {\n-                let ty = default.as_ref().map(|x| -> &'hir hir::Ty {\n-                    self.arena.alloc(self.lower_ty(x, ImplTraitContext::disallowed()).into_inner())\n+                let ty = default.as_ref().map(|x| {\n+                    &*self\n+                        .arena\n+                        .alloc(self.lower_ty(x, ImplTraitContext::disallowed()).into_inner())\n                 });\n                 let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n                 let kind = hir::TraitItemKind::Type(\n@@ -840,7 +842,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     /// Construct `ExprKind::Err` for the given `span`.\n-    fn expr_err(&mut self, span: Span) -> hir::Expr {\n+    fn expr_err(&mut self, span: Span) -> hir::Expr<'hir> {\n         self.expr(span, hir::ExprKind::Err, AttrVec::new())\n     }\n \n@@ -981,7 +983,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    fn record_body(&mut self, params: &'hir [hir::Param], value: hir::Expr) -> hir::BodyId {\n+    fn record_body(\n+        &mut self,\n+        params: &'hir [hir::Param<'hir>],\n+        value: hir::Expr<'hir>,\n+    ) -> hir::BodyId {\n         let body = hir::Body { generator_kind: self.generator_kind, params, value };\n         let id = body.id();\n         self.bodies.insert(id, body);\n@@ -990,7 +996,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_body(\n         &mut self,\n-        f: impl FnOnce(&mut Self) -> (&'hir [hir::Param], hir::Expr),\n+        f: impl FnOnce(&mut Self) -> (&'hir [hir::Param<'hir>], hir::Expr<'hir>),\n     ) -> hir::BodyId {\n         let prev_gen_kind = self.generator_kind.take();\n         let (parameters, result) = f(self);\n@@ -999,9 +1005,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         body_id\n     }\n \n-    fn lower_param(&mut self, param: &Param) -> hir::Param {\n+    fn lower_param(&mut self, param: &Param) -> hir::Param<'hir> {\n         hir::Param {\n-            attrs: self.lower_attrs(&param.attrs),\n+            attrs: self.lower_attrs_arena(&param.attrs),\n             hir_id: self.lower_node_id(param.id),\n             pat: self.lower_pat(&param.pat),\n             span: param.span,\n@@ -1011,7 +1017,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub(super) fn lower_fn_body(\n         &mut self,\n         decl: &FnDecl,\n-        body: impl FnOnce(&mut LoweringContext<'_, '_>) -> hir::Expr,\n+        body: impl FnOnce(&mut Self) -> hir::Expr<'hir>,\n     ) -> hir::BodyId {\n         self.lower_body(|this| {\n             (\n@@ -1030,7 +1036,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.lower_fn_body(decl, |this| this.lower_block_expr_opt(span, body))\n     }\n \n-    fn lower_block_expr_opt(&mut self, span: Span, block: Option<&Block>) -> hir::Expr {\n+    fn lower_block_expr_opt(&mut self, span: Span, block: Option<&Block>) -> hir::Expr<'hir> {\n         match block {\n             Some(block) => self.lower_block_expr(block),\n             None => self.expr_err(span),\n@@ -1042,7 +1048,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             (\n                 &[],\n                 match expr {\n-                    Some(expr) => this.lower_expr(expr),\n+                    Some(expr) => this.lower_expr_mut(expr),\n                     None => this.expr_err(span),\n                 },\n             )\n@@ -1062,8 +1068,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         };\n \n         self.lower_body(|this| {\n-            let mut parameters: Vec<hir::Param> = Vec::new();\n-            let mut statements: Vec<hir::Stmt> = Vec::new();\n+            let mut parameters: Vec<hir::Param<'_>> = Vec::new();\n+            let mut statements: Vec<hir::Stmt<'_>> = Vec::new();\n \n             // Async function parameters are lowered into the closure body so that they are\n             // captured and so that the drop order matches the equivalent non-async functions.\n@@ -1141,7 +1147,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let stmt = this.stmt_let_pat(\n                         stmt_attrs,\n                         desugared_span,\n-                        Some(P(expr)),\n+                        Some(this.arena.alloc(expr)),\n                         parameter.pat,\n                         hir::LocalSource::AsyncFn,\n                     );\n@@ -1171,7 +1177,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let move_stmt = this.stmt_let_pat(\n                         AttrVec::new(),\n                         desugared_span,\n-                        Some(P(move_expr)),\n+                        Some(this.arena.alloc(move_expr)),\n                         move_pat,\n                         hir::LocalSource::AsyncFn,\n                     );\n@@ -1182,7 +1188,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let pattern_stmt = this.stmt_let_pat(\n                         stmt_attrs,\n                         desugared_span,\n-                        Some(P(pattern_expr)),\n+                        Some(this.arena.alloc(pattern_expr)),\n                         parameter.pat,\n                         hir::LocalSource::AsyncFn,\n                     );\n@@ -1208,8 +1214,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     // Transform into `drop-temps { <user-body> }`, an expression:\n                     let desugared_span =\n                         this.mark_span_with_reason(DesugaringKind::Async, user_body.span, None);\n-                    let user_body =\n-                        this.expr_drop_temps(desugared_span, P(user_body), AttrVec::new());\n+                    let user_body = this.expr_drop_temps(\n+                        desugared_span,\n+                        this.arena.alloc(user_body),\n+                        AttrVec::new(),\n+                    );\n \n                     // As noted above, create the final block like\n                     //\n@@ -1220,9 +1229,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     //   drop-temps { <user-body> }\n                     // }\n                     // ```\n-                    let body =\n-                        this.block_all(desugared_span, statements.into(), Some(P(user_body)));\n-                    this.expr_block(P(body), AttrVec::new())\n+                    let body = this.block_all(\n+                        desugared_span,\n+                        this.arena.alloc_from_iter(statements),\n+                        Some(user_body),\n+                    );\n+\n+                    this.expr_block(body, AttrVec::new())\n                 },\n             );\n "}, {"sha": "7701c33f9162a5352951381faaaace60e542faf2", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -66,7 +66,7 @@ impl MaybeFnLike for ast::TraitItem<'_> {\n     }\n }\n \n-impl MaybeFnLike for ast::Expr {\n+impl MaybeFnLike for ast::Expr<'_> {\n     fn is_fn_like(&self) -> bool {\n         match self.kind {\n             ast::ExprKind::Closure(..) => true,\n@@ -81,7 +81,7 @@ impl MaybeFnLike for ast::Expr {\n #[derive(Copy, Clone)]\n pub enum Code<'a> {\n     FnLike(FnLikeNode<'a>),\n-    Expr(&'a Expr),\n+    Expr(&'a Expr<'a>),\n }\n \n impl<'a> Code<'a> {"}, {"sha": "610be0a0753f05aed1831e49d6135147d61fa4f6", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -365,7 +365,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.currently_in_body = prev_in_body;\n     }\n \n-    fn visit_param(&mut self, param: &'hir Param) {\n+    fn visit_param(&mut self, param: &'hir Param<'hir>) {\n         let node = Node::Param(param);\n         self.insert(param.pat.span, param.hir_id, node);\n         self.with_parent(param.hir_id, |this| {\n@@ -434,7 +434,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_pat(&mut self, pat: &'hir Pat) {\n+    fn visit_pat(&mut self, pat: &'hir Pat<'hir>) {\n         let node =\n             if let PatKind::Binding(..) = pat.kind { Node::Binding(pat) } else { Node::Pat(pat) };\n         self.insert(pat.span, pat.hir_id, node);\n@@ -444,7 +444,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_arm(&mut self, arm: &'hir Arm) {\n+    fn visit_arm(&mut self, arm: &'hir Arm<'hir>) {\n         let node = Node::Arm(arm);\n \n         self.insert(arm.span, arm.hir_id, node);\n@@ -462,15 +462,15 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_expr(&mut self, expr: &'hir Expr) {\n+    fn visit_expr(&mut self, expr: &'hir Expr<'hir>) {\n         self.insert(expr.span, expr.hir_id, Node::Expr(expr));\n \n         self.with_parent(expr.hir_id, |this| {\n             intravisit::walk_expr(this, expr);\n         });\n     }\n \n-    fn visit_stmt(&mut self, stmt: &'hir Stmt) {\n+    fn visit_stmt(&mut self, stmt: &'hir Stmt<'hir>) {\n         self.insert(stmt.span, stmt.hir_id, Node::Stmt(stmt));\n \n         self.with_parent(stmt.hir_id, |this| {\n@@ -513,14 +513,14 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         intravisit::walk_fn(self, fk, fd, b, s, id);\n     }\n \n-    fn visit_block(&mut self, block: &'hir Block) {\n+    fn visit_block(&mut self, block: &'hir Block<'hir>) {\n         self.insert(block.span, block.hir_id, Node::Block(block));\n         self.with_parent(block.hir_id, |this| {\n             intravisit::walk_block(this, block);\n         });\n     }\n \n-    fn visit_local(&mut self, l: &'hir Local) {\n+    fn visit_local(&mut self, l: &'hir Local<'hir>) {\n         self.insert(l.span, l.hir_id, Node::Local(l));\n         self.with_parent(l.hir_id, |this| intravisit::walk_local(this, l))\n     }"}, {"sha": "cc5cb58173fd69c54026a73d2012b1f7426a5c9b", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -180,19 +180,19 @@ pub struct Map<'hir> {\n     hir_to_node_id: FxHashMap<HirId, NodeId>,\n }\n \n-struct ParentHirIterator<'map> {\n+struct ParentHirIterator<'map, 'hir> {\n     current_id: HirId,\n-    map: &'map Map<'map>,\n+    map: &'map Map<'hir>,\n }\n \n-impl<'map> ParentHirIterator<'map> {\n-    fn new(current_id: HirId, map: &'map Map<'map>) -> ParentHirIterator<'map> {\n+impl<'map, 'hir> ParentHirIterator<'map, 'hir> {\n+    fn new(current_id: HirId, map: &'map Map<'hir>) -> ParentHirIterator<'map, 'hir> {\n         ParentHirIterator { current_id, map }\n     }\n }\n \n-impl<'map> Iterator for ParentHirIterator<'map> {\n-    type Item = (HirId, Node<'map>);\n+impl<'map, 'hir> Iterator for ParentHirIterator<'map, 'hir> {\n+    type Item = (HirId, Node<'hir>);\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if self.current_id == CRATE_HIR_ID {\n@@ -782,7 +782,7 @@ impl<'hir> Map<'hir> {\n     ///\n     /// Used by error reporting when there's a type error in a match arm caused by the `match`\n     /// expression needing to be unit.\n-    pub fn get_match_if_cause(&self, hir_id: HirId) -> Option<&Expr> {\n+    pub fn get_match_if_cause(&self, hir_id: HirId) -> Option<&'hir Expr<'hir>> {\n         for (_, node) in ParentHirIterator::new(hir_id, &self) {\n             match node {\n                 Node::Item(_) | Node::ForeignItem(_) | Node::TraitItem(_) | Node::ImplItem(_) => {\n@@ -925,7 +925,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn expect_expr(&self, id: HirId) -> &'hir Expr {\n+    pub fn expect_expr(&self, id: HirId) -> &'hir Expr<'hir> {\n         match self.find(id) {\n             // read recorded by find\n             Some(Node::Expr(expr)) => expr,"}, {"sha": "8a450cf167a369e42ea4d133adc48b2be2945378", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 96, "deletions": 97, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -832,12 +832,12 @@ pub struct MacroDef<'hir> {\n /// `targeted_by_break` field will be `true`) and may be `unsafe` by means of\n /// the `rules` being anything but `DefaultBlock`.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct Block {\n+pub struct Block<'hir> {\n     /// Statements in a block.\n-    pub stmts: HirVec<Stmt>,\n+    pub stmts: &'hir [Stmt<'hir>],\n     /// An expression at the end of the block\n     /// without a semicolon, if any.\n-    pub expr: Option<P<Expr>>,\n+    pub expr: Option<&'hir Expr<'hir>>,\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`.\n@@ -850,14 +850,14 @@ pub struct Block {\n }\n \n #[derive(RustcEncodable, RustcDecodable, HashStable)]\n-pub struct Pat {\n+pub struct Pat<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n-    pub kind: PatKind,\n+    pub kind: PatKind<'hir>,\n     pub span: Span,\n }\n \n-impl fmt::Debug for Pat {\n+impl fmt::Debug for Pat<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n@@ -868,9 +868,9 @@ impl fmt::Debug for Pat {\n     }\n }\n \n-impl Pat {\n+impl Pat<'_> {\n     // FIXME(#19596) this is a workaround, but there should be a better way\n-    fn walk_short_(&self, it: &mut impl FnMut(&Pat) -> bool) -> bool {\n+    fn walk_short_(&self, it: &mut impl FnMut(&Pat<'_>) -> bool) -> bool {\n         if !it(self) {\n             return false;\n         }\n@@ -893,12 +893,12 @@ impl Pat {\n     /// Note that when visiting e.g. `Tuple(ps)`,\n     /// if visiting `ps[0]` returns `false`,\n     /// then `ps[1]` will not be visited.\n-    pub fn walk_short(&self, mut it: impl FnMut(&Pat) -> bool) -> bool {\n+    pub fn walk_short(&self, mut it: impl FnMut(&Pat<'_>) -> bool) -> bool {\n         self.walk_short_(&mut it)\n     }\n \n     // FIXME(#19596) this is a workaround, but there should be a better way\n-    fn walk_(&self, it: &mut impl FnMut(&Pat) -> bool) {\n+    fn walk_(&self, it: &mut impl FnMut(&Pat<'_>) -> bool) {\n         if !it(self) {\n             return;\n         }\n@@ -918,14 +918,14 @@ impl Pat {\n     /// Walk the pattern in left-to-right order.\n     ///\n     /// If `it(pat)` returns `false`, the children are not visited.\n-    pub fn walk(&self, mut it: impl FnMut(&Pat) -> bool) {\n+    pub fn walk(&self, mut it: impl FnMut(&Pat<'_>) -> bool) {\n         self.walk_(&mut it)\n     }\n \n     /// Walk the pattern in left-to-right order.\n     ///\n     /// If you always want to recurse, prefer this method over `walk`.\n-    pub fn walk_always(&self, mut it: impl FnMut(&Pat)) {\n+    pub fn walk_always(&self, mut it: impl FnMut(&Pat<'_>)) {\n         self.walk(|p| {\n             it(p);\n             true\n@@ -939,14 +939,14 @@ impl Pat {\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n /// except `is_shorthand` is true.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct FieldPat {\n+pub struct FieldPat<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     /// The identifier for the field.\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n     /// The pattern the field is destructured to.\n-    pub pat: P<Pat>,\n+    pub pat: &'hir Pat<'hir>,\n     pub is_shorthand: bool,\n     pub span: Span,\n }\n@@ -991,48 +991,48 @@ impl fmt::Display for RangeEnd {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum PatKind {\n+pub enum PatKind<'hir> {\n     /// Represents a wildcard pattern (i.e., `_`).\n     Wild,\n \n     /// A fresh binding `ref mut binding @ OPT_SUBPATTERN`.\n     /// The `HirId` is the canonical ID for the variable being bound,\n     /// (e.g., in `Ok(x) | Err(x)`, both `x` use the same canonical ID),\n     /// which is the pattern ID of the first `x`.\n-    Binding(BindingAnnotation, HirId, Ident, Option<P<Pat>>),\n+    Binding(BindingAnnotation, HirId, Ident, Option<&'hir Pat<'hir>>),\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n-    Struct(QPath, HirVec<FieldPat>, bool),\n+    Struct(QPath, &'hir [FieldPat<'hir>], bool),\n \n     /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n     /// `0 <= position <= subpats.len()`\n-    TupleStruct(QPath, HirVec<P<Pat>>, Option<usize>),\n+    TupleStruct(QPath, &'hir [&'hir Pat<'hir>], Option<usize>),\n \n     /// An or-pattern `A | B | C`.\n     /// Invariant: `pats.len() >= 2`.\n-    Or(HirVec<P<Pat>>),\n+    Or(&'hir [&'hir Pat<'hir>]),\n \n     /// A path pattern for an unit struct/variant or a (maybe-associated) constant.\n     Path(QPath),\n \n     /// A tuple pattern (e.g., `(a, b)`).\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n     /// `0 <= position <= subpats.len()`\n-    Tuple(HirVec<P<Pat>>, Option<usize>),\n+    Tuple(&'hir [&'hir Pat<'hir>], Option<usize>),\n \n     /// A `box` pattern.\n-    Box(P<Pat>),\n+    Box(&'hir Pat<'hir>),\n \n     /// A reference pattern (e.g., `&mut (a, b)`).\n-    Ref(P<Pat>, Mutability),\n+    Ref(&'hir Pat<'hir>, Mutability),\n \n     /// A literal.\n-    Lit(P<Expr>),\n+    Lit(&'hir Expr<'hir>),\n \n     /// A range pattern (e.g., `1..=2` or `1..2`).\n-    Range(P<Expr>, P<Expr>, RangeEnd),\n+    Range(&'hir Expr<'hir>, &'hir Expr<'hir>, RangeEnd),\n \n     /// A slice pattern, `[before_0, ..., before_n, (slice, after_0, ..., after_n)?]`.\n     ///\n@@ -1043,7 +1043,7 @@ pub enum PatKind {\n     /// ```\n     /// PatKind::Slice([Binding(a), Binding(b)], Some(Wild), [Binding(c), Binding(d)])\n     /// ```\n-    Slice(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n+    Slice(&'hir [&'hir Pat<'hir>], Option<&'hir Pat<'hir>>, &'hir [&'hir Pat<'hir>]),\n }\n \n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n@@ -1210,13 +1210,13 @@ impl UnOp {\n \n /// A statement.\n #[derive(RustcEncodable, RustcDecodable, HashStable)]\n-pub struct Stmt {\n+pub struct Stmt<'hir> {\n     pub hir_id: HirId,\n-    pub kind: StmtKind,\n+    pub kind: StmtKind<'hir>,\n     pub span: Span,\n }\n \n-impl fmt::Debug for Stmt {\n+impl fmt::Debug for Stmt<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n@@ -1229,22 +1229,22 @@ impl fmt::Debug for Stmt {\n \n /// The contents of a statement.\n #[derive(RustcEncodable, RustcDecodable, HashStable)]\n-pub enum StmtKind {\n+pub enum StmtKind<'hir> {\n     /// A local (`let`) binding.\n-    Local(P<Local>),\n+    Local(&'hir Local<'hir>),\n \n     /// An item binding.\n     Item(ItemId),\n \n     /// An expression without a trailing semi-colon (must have unit type).\n-    Expr(P<Expr>),\n+    Expr(&'hir Expr<'hir>),\n \n     /// An expression with a trailing semi-colon (may have any type).\n-    Semi(P<Expr>),\n+    Semi(&'hir Expr<'hir>),\n }\n \n-impl StmtKind {\n-    pub fn attrs(&self) -> &[Attribute] {\n+impl StmtKind<'hir> {\n+    pub fn attrs(&self) -> &'hir [Attribute] {\n         match *self {\n             StmtKind::Local(ref l) => &l.attrs,\n             StmtKind::Item(_) => &[],\n@@ -1255,12 +1255,12 @@ impl StmtKind {\n \n /// Represents a `let` statement (i.e., `let <pat>:<ty> = <expr>;`).\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct Local {\n-    pub pat: P<Pat>,\n+pub struct Local<'hir> {\n+    pub pat: &'hir Pat<'hir>,\n     /// Type annotation, if any (otherwise the type will be inferred).\n-    pub ty: Option<P<Ty>>,\n+    pub ty: Option<&'hir Ty>,\n     /// Initializer expression to set the value, if any.\n-    pub init: Option<P<Expr>>,\n+    pub init: Option<&'hir Expr<'hir>>,\n     pub hir_id: HirId,\n     pub span: Span,\n     pub attrs: AttrVec,\n@@ -1272,30 +1272,30 @@ pub struct Local {\n /// Represents a single arm of a `match` expression, e.g.\n /// `<pat> (if <guard>) => <body>`.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct Arm {\n+pub struct Arm<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     pub span: Span,\n-    pub attrs: HirVec<Attribute>,\n+    pub attrs: &'hir [Attribute],\n     /// If this pattern and the optional guard matches, then `body` is evaluated.\n-    pub pat: P<Pat>,\n+    pub pat: &'hir Pat<'hir>,\n     /// Optional guard clause.\n-    pub guard: Option<Guard>,\n+    pub guard: Option<Guard<'hir>>,\n     /// The expression the arm evaluates to if this arm matches.\n-    pub body: P<Expr>,\n+    pub body: &'hir Expr<'hir>,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum Guard {\n-    If(P<Expr>),\n+pub enum Guard<'hir> {\n+    If(&'hir Expr<'hir>),\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct Field {\n+pub struct Field<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     pub ident: Ident,\n-    pub expr: P<Expr>,\n+    pub expr: &'hir Expr<'hir>,\n     pub span: Span,\n     pub is_shorthand: bool,\n }\n@@ -1342,8 +1342,8 @@ pub struct BodyId {\n /// map using `body_owner_def_id()`.\n #[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct Body<'hir> {\n-    pub params: &'hir [Param],\n-    pub value: Expr,\n+    pub params: &'hir [Param<'hir>],\n+    pub value: Expr<'hir>,\n     pub generator_kind: Option<GeneratorKind>,\n }\n \n@@ -1443,18 +1443,18 @@ pub struct AnonConst {\n \n /// An expression.\n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct Expr {\n+pub struct Expr<'hir> {\n     pub hir_id: HirId,\n-    pub kind: ExprKind,\n+    pub kind: ExprKind<'hir>,\n     pub attrs: AttrVec,\n     pub span: Span,\n }\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(Expr, 64);\n+static_assert_size!(Expr<'static>, 64);\n \n-impl Expr {\n+impl Expr<'_> {\n     pub fn precedence(&self) -> ExprPrecedence {\n         match self.kind {\n             ExprKind::Box(_) => ExprPrecedence::Box,\n@@ -1563,7 +1563,7 @@ impl Expr {\n     }\n }\n \n-impl fmt::Debug for Expr {\n+impl fmt::Debug for Expr<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n@@ -1579,7 +1579,7 @@ impl fmt::Debug for Expr {\n ///\n /// FIXME(#60607): This function is a hack. If and when we have `QPath::Lang(...)`,\n /// we can use that instead as simpler, more reliable mechanism, as opposed to using `SourceMap`.\n-pub fn is_range_literal(sm: &SourceMap, expr: &Expr) -> bool {\n+pub fn is_range_literal(sm: &SourceMap, expr: &Expr<'_>) -> bool {\n     // Returns whether the given path represents a (desugared) range,\n     // either in std or core, i.e. has either a `::std::ops::Range` or\n     // `::core::ops::Range` prefix.\n@@ -1637,18 +1637,18 @@ pub fn is_range_literal(sm: &SourceMap, expr: &Expr) -> bool {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum ExprKind {\n+pub enum ExprKind<'hir> {\n     /// A `box x` expression.\n-    Box(P<Expr>),\n+    Box(&'hir Expr<'hir>),\n     /// An array (e.g., `[a, b, c, d]`).\n-    Array(HirVec<Expr>),\n+    Array(&'hir [Expr<'hir>]),\n     /// A function call.\n     ///\n     /// The first field resolves to the function itself (usually an `ExprKind::Path`),\n     /// and the second field is the list of arguments.\n     /// This also represents calling the constructor of\n     /// tuple-like ADTs such as tuple structs and enum variants.\n-    Call(P<Expr>, HirVec<Expr>),\n+    Call(&'hir Expr<'hir>, &'hir [Expr<'hir>]),\n     /// A method call (e.g., `x.foo::<'static, Bar, Baz>(a, b, c, d)`).\n     ///\n     /// The `PathSegment`/`Span` represent the method name and its generic arguments\n@@ -1663,83 +1663,82 @@ pub enum ExprKind {\n     /// the `hir_id` of the `MethodCall` node itself.\n     ///\n     /// [`type_dependent_def_id`]: ../ty/struct.TypeckTables.html#method.type_dependent_def_id\n-    MethodCall(P<PathSegment>, Span, HirVec<Expr>),\n+    MethodCall(&'hir PathSegment, Span, &'hir [Expr<'hir>]),\n     /// A tuple (e.g., `(a, b, c, d)`).\n-    Tup(HirVec<Expr>),\n+    Tup(&'hir [Expr<'hir>]),\n     /// A binary operation (e.g., `a + b`, `a * b`).\n-    Binary(BinOp, P<Expr>, P<Expr>),\n+    Binary(BinOp, &'hir Expr<'hir>, &'hir Expr<'hir>),\n     /// A unary operation (e.g., `!x`, `*x`).\n-    Unary(UnOp, P<Expr>),\n+    Unary(UnOp, &'hir Expr<'hir>),\n     /// A literal (e.g., `1`, `\"foo\"`).\n     Lit(Lit),\n     /// A cast (e.g., `foo as f64`).\n-    Cast(P<Expr>, P<Ty>),\n+    Cast(&'hir Expr<'hir>, &'hir Ty),\n     /// A type reference (e.g., `Foo`).\n-    Type(P<Expr>, P<Ty>),\n+    Type(&'hir Expr<'hir>, &'hir Ty),\n     /// Wraps the expression in a terminating scope.\n     /// This makes it semantically equivalent to `{ let _t = expr; _t }`.\n     ///\n     /// This construct only exists to tweak the drop order in HIR lowering.\n     /// An example of that is the desugaring of `for` loops.\n-    DropTemps(P<Expr>),\n+    DropTemps(&'hir Expr<'hir>),\n     /// A conditionless loop (can be exited with `break`, `continue`, or `return`).\n     ///\n     /// I.e., `'label: loop { <block> }`.\n-    Loop(P<Block>, Option<Label>, LoopSource),\n+    Loop(&'hir Block<'hir>, Option<Label>, LoopSource),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n-    Match(P<Expr>, HirVec<Arm>, MatchSource),\n+    Match(&'hir Expr<'hir>, &'hir [Arm<'hir>], MatchSource),\n     /// A closure (e.g., `move |a, b, c| {a + b + c}`).\n     ///\n     /// The `Span` is the argument block `|...|`.\n     ///\n     /// This may also be a generator literal or an `async block` as indicated by the\n     /// `Option<Movability>`.\n-    Closure(CaptureBy, P<FnDecl>, BodyId, Span, Option<Movability>),\n+    Closure(CaptureBy, &'hir FnDecl, BodyId, Span, Option<Movability>),\n     /// A block (e.g., `'label: { ... }`).\n-    Block(P<Block>, Option<Label>),\n+    Block(&'hir Block<'hir>, Option<Label>),\n \n     /// An assignment (e.g., `a = foo()`).\n-    /// The `Span` argument is the span of the `=` token.\n-    Assign(P<Expr>, P<Expr>, Span),\n+    Assign(&'hir Expr<'hir>, &'hir Expr<'hir>, Span),\n     /// An assignment with an operator.\n     ///\n     /// E.g., `a += 1`.\n-    AssignOp(BinOp, P<Expr>, P<Expr>),\n+    AssignOp(BinOp, &'hir Expr<'hir>, &'hir Expr<'hir>),\n     /// Access of a named (e.g., `obj.foo`) or unnamed (e.g., `obj.0`) struct or tuple field.\n-    Field(P<Expr>, Ident),\n+    Field(&'hir Expr<'hir>, Ident),\n     /// An indexing operation (`foo[2]`).\n-    Index(P<Expr>, P<Expr>),\n+    Index(&'hir Expr<'hir>, &'hir Expr<'hir>),\n \n     /// Path to a definition, possibly containing lifetime or type parameters.\n     Path(QPath),\n \n-    /// A referencing operation (i.e., `&a`, `&mut a`, `&raw const a`, or `&raw mut a`).\n-    AddrOf(BorrowKind, Mutability, P<Expr>),\n+    /// A referencing operation (i.e., `&a` or `&mut a`).\n+    AddrOf(BorrowKind, Mutability, &'hir Expr<'hir>),\n     /// A `break`, with an optional label to break.\n-    Break(Destination, Option<P<Expr>>),\n+    Break(Destination, Option<&'hir Expr<'hir>>),\n     /// A `continue`, with an optional label.\n     Continue(Destination),\n     /// A `return`, with an optional value to be returned.\n-    Ret(Option<P<Expr>>),\n+    Ret(Option<&'hir Expr<'hir>>),\n \n     /// Inline assembly (from `asm!`), with its outputs and inputs.\n-    InlineAsm(P<InlineAsm>),\n+    InlineAsm(&'hir InlineAsm<'hir>),\n \n     /// A struct or struct-like variant literal expression.\n     ///\n     /// E.g., `Foo {x: 1, y: 2}`, or `Foo {x: 1, .. base}`,\n     /// where `base` is the `Option<Expr>`.\n-    Struct(P<QPath>, HirVec<Field>, Option<P<Expr>>),\n+    Struct(&'hir QPath, &'hir [Field<'hir>], Option<&'hir Expr<'hir>>),\n \n     /// An array literal constructed from one repeated element.\n     ///\n     /// E.g., `[1; 5]`. The first expression is the element\n     /// to be repeated; the second is the number of times to repeat it.\n-    Repeat(P<Expr>, AnonConst),\n+    Repeat(&'hir Expr<'hir>, AnonConst),\n \n     /// A suspension point for generators (i.e., `yield <expr>`).\n-    Yield(P<Expr>, YieldSource),\n+    Yield(&'hir Expr<'hir>, YieldSource),\n \n     /// A placeholder for an expression that wasn't syntactically well formed in some way.\n     Err,\n@@ -2159,18 +2158,18 @@ pub struct InlineAsmInner {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct InlineAsm {\n+pub struct InlineAsm<'hir> {\n     pub inner: InlineAsmInner,\n-    pub outputs_exprs: HirVec<Expr>,\n-    pub inputs_exprs: HirVec<Expr>,\n+    pub outputs_exprs: &'hir [Expr<'hir>],\n+    pub inputs_exprs: &'hir [Expr<'hir>],\n }\n \n /// Represents a parameter in a function header.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct Param {\n-    pub attrs: HirVec<Attribute>,\n+pub struct Param<'hir> {\n+    pub attrs: &'hir [Attribute],\n     pub hir_id: HirId,\n-    pub pat: P<Pat>,\n+    pub pat: &'hir Pat<'hir>,\n     pub span: Span,\n }\n \n@@ -2828,24 +2827,24 @@ impl CodegenFnAttrs {\n \n #[derive(Copy, Clone, Debug)]\n pub enum Node<'hir> {\n-    Param(&'hir Param),\n+    Param(&'hir Param<'hir>),\n     Item(&'hir Item<'hir>),\n     ForeignItem(&'hir ForeignItem<'hir>),\n     TraitItem(&'hir TraitItem<'hir>),\n     ImplItem(&'hir ImplItem<'hir>),\n     Variant(&'hir Variant<'hir>),\n     Field(&'hir StructField<'hir>),\n     AnonConst(&'hir AnonConst),\n-    Expr(&'hir Expr),\n-    Stmt(&'hir Stmt),\n+    Expr(&'hir Expr<'hir>),\n+    Stmt(&'hir Stmt<'hir>),\n     PathSegment(&'hir PathSegment),\n     Ty(&'hir Ty),\n     TraitRef(&'hir TraitRef),\n-    Binding(&'hir Pat),\n-    Pat(&'hir Pat),\n-    Arm(&'hir Arm),\n-    Block(&'hir Block),\n-    Local(&'hir Local),\n+    Binding(&'hir Pat<'hir>),\n+    Pat(&'hir Pat<'hir>),\n+    Arm(&'hir Arm<'hir>),\n+    Block(&'hir Block<'hir>),\n+    Local(&'hir Local<'hir>),\n     MacroDef(&'hir MacroDef<'hir>),\n \n     /// `Ctor` refers to the constructor of an enum variant or struct. Only tuple or unit variants"}, {"sha": "0831f5403db5499f4025a71bccdba6f7a731ad07", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -57,7 +57,7 @@ impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n     }\n }\n \n-impl hir::Pat {\n+impl hir::Pat<'_> {\n     pub fn is_refutable(&self) -> bool {\n         match self.kind {\n             PatKind::Lit(_)\n@@ -126,7 +126,7 @@ impl hir::Pat {\n     }\n \n     /// Checks if the pattern satisfies the given predicate on some sub-pattern.\n-    fn satisfies(&self, pred: impl Fn(&Self) -> bool) -> bool {\n+    fn satisfies(&self, pred: impl Fn(&hir::Pat<'_>) -> bool) -> bool {\n         let mut satisfies = false;\n         self.walk_short(|p| {\n             if pred(p) {"}, {"sha": "11a596a8317773f03b71b78e7101a779f3d85226", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -10,7 +10,6 @@ use syntax::util::parser::{self, AssocOp, Fixity};\n use syntax_pos::{self, BytePos, FileName};\n \n use crate::hir;\n-use crate::hir::ptr::P;\n use crate::hir::{GenericArg, GenericParam, GenericParamKind};\n use crate::hir::{GenericBound, PatKind, RangeEnd, TraitBoundModifier};\n \n@@ -20,12 +19,12 @@ use std::vec;\n \n pub enum AnnNode<'a> {\n     Name(&'a ast::Name),\n-    Block(&'a hir::Block),\n+    Block(&'a hir::Block<'a>),\n     Item(&'a hir::Item<'a>),\n     SubItem(hir::HirId),\n-    Expr(&'a hir::Expr),\n-    Pat(&'a hir::Pat),\n-    Arm(&'a hir::Arm),\n+    Expr(&'a hir::Expr<'a>),\n+    Pat(&'a hir::Pat<'a>),\n+    Arm(&'a hir::Arm<'a>),\n }\n \n pub enum Nested {\n@@ -242,7 +241,7 @@ impl<'a> State<'a> {\n         self.end();\n     }\n \n-    pub fn commasep_exprs(&mut self, b: Breaks, exprs: &[hir::Expr]) {\n+    pub fn commasep_exprs(&mut self, b: Breaks, exprs: &[hir::Expr<'_>]) {\n         self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&e), |e| e.span)\n     }\n \n@@ -902,7 +901,7 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::SubItem(ii.hir_id))\n     }\n \n-    pub fn print_local(&mut self, init: Option<&hir::Expr>, decl: impl Fn(&mut Self)) {\n+    pub fn print_local(&mut self, init: Option<&hir::Expr<'_>>, decl: impl Fn(&mut Self)) {\n         self.space_if_not_bol();\n         self.ibox(INDENT_UNIT);\n         self.word_nbsp(\"let\");\n@@ -919,7 +918,7 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn print_stmt(&mut self, st: &hir::Stmt) {\n+    pub fn print_stmt(&mut self, st: &hir::Stmt<'_>) {\n         self.maybe_print_comment(st.span.lo());\n         match st.kind {\n             hir::StmtKind::Local(ref loc) => {\n@@ -942,21 +941,21 @@ impl<'a> State<'a> {\n         self.maybe_print_trailing_comment(st.span, None)\n     }\n \n-    pub fn print_block(&mut self, blk: &hir::Block) {\n+    pub fn print_block(&mut self, blk: &hir::Block<'_>) {\n         self.print_block_with_attrs(blk, &[])\n     }\n \n-    pub fn print_block_unclosed(&mut self, blk: &hir::Block) {\n+    pub fn print_block_unclosed(&mut self, blk: &hir::Block<'_>) {\n         self.print_block_maybe_unclosed(blk, &[], false)\n     }\n \n-    pub fn print_block_with_attrs(&mut self, blk: &hir::Block, attrs: &[ast::Attribute]) {\n+    pub fn print_block_with_attrs(&mut self, blk: &hir::Block<'_>, attrs: &[ast::Attribute]) {\n         self.print_block_maybe_unclosed(blk, attrs, true)\n     }\n \n     pub fn print_block_maybe_unclosed(\n         &mut self,\n-        blk: &hir::Block,\n+        blk: &hir::Block<'_>,\n         attrs: &[ast::Attribute],\n         close_box: bool,\n     ) {\n@@ -972,7 +971,7 @@ impl<'a> State<'a> {\n \n         self.print_inner_attributes(attrs);\n \n-        for st in &blk.stmts {\n+        for st in blk.stmts {\n             self.print_stmt(st);\n         }\n         if let Some(ref expr) = blk.expr {\n@@ -988,13 +987,13 @@ impl<'a> State<'a> {\n         self.ann.nested(self, Nested::Body(constant.body))\n     }\n \n-    fn print_call_post(&mut self, args: &[hir::Expr]) {\n+    fn print_call_post(&mut self, args: &[hir::Expr<'_>]) {\n         self.popen();\n         self.commasep_exprs(Inconsistent, args);\n         self.pclose()\n     }\n \n-    pub fn print_expr_maybe_paren(&mut self, expr: &hir::Expr, prec: i8) {\n+    pub fn print_expr_maybe_paren(&mut self, expr: &hir::Expr<'_>, prec: i8) {\n         let needs_par = expr.precedence().order() < prec;\n         if needs_par {\n             self.popen();\n@@ -1007,7 +1006,7 @@ impl<'a> State<'a> {\n \n     /// Print an expr using syntax that's acceptable in a condition position, such as the `cond` in\n     /// `if cond { ... }`.\n-    pub fn print_expr_as_cond(&mut self, expr: &hir::Expr) {\n+    pub fn print_expr_as_cond(&mut self, expr: &hir::Expr<'_>) {\n         let needs_par = match expr.kind {\n             // These cases need parens due to the parse error observed in #26461: `if return {}`\n             // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n@@ -1025,15 +1024,15 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    fn print_expr_vec(&mut self, exprs: &[hir::Expr]) {\n+    fn print_expr_vec(&mut self, exprs: &[hir::Expr<'_>]) {\n         self.ibox(INDENT_UNIT);\n         self.s.word(\"[\");\n         self.commasep_exprs(Inconsistent, exprs);\n         self.s.word(\"]\");\n         self.end()\n     }\n \n-    fn print_expr_repeat(&mut self, element: &hir::Expr, count: &hir::AnonConst) {\n+    fn print_expr_repeat(&mut self, element: &hir::Expr<'_>, count: &hir::AnonConst) {\n         self.ibox(INDENT_UNIT);\n         self.s.word(\"[\");\n         self.print_expr(element);\n@@ -1046,8 +1045,8 @@ impl<'a> State<'a> {\n     fn print_expr_struct(\n         &mut self,\n         qpath: &hir::QPath,\n-        fields: &[hir::Field],\n-        wth: &Option<P<hir::Expr>>,\n+        fields: &[hir::Field<'_>],\n+        wth: &Option<&'hir hir::Expr<'_>>,\n     ) {\n         self.print_qpath(qpath, true);\n         self.s.word(\"{\");\n@@ -1085,7 +1084,7 @@ impl<'a> State<'a> {\n         self.s.word(\"}\");\n     }\n \n-    fn print_expr_tup(&mut self, exprs: &[hir::Expr]) {\n+    fn print_expr_tup(&mut self, exprs: &[hir::Expr<'_>]) {\n         self.popen();\n         self.commasep_exprs(Inconsistent, exprs);\n         if exprs.len() == 1 {\n@@ -1094,7 +1093,7 @@ impl<'a> State<'a> {\n         self.pclose()\n     }\n \n-    fn print_expr_call(&mut self, func: &hir::Expr, args: &[hir::Expr]) {\n+    fn print_expr_call(&mut self, func: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n         let prec = match func.kind {\n             hir::ExprKind::Field(..) => parser::PREC_FORCE_PAREN,\n             _ => parser::PREC_POSTFIX,\n@@ -1104,7 +1103,7 @@ impl<'a> State<'a> {\n         self.print_call_post(args)\n     }\n \n-    fn print_expr_method_call(&mut self, segment: &hir::PathSegment, args: &[hir::Expr]) {\n+    fn print_expr_method_call(&mut self, segment: &hir::PathSegment, args: &[hir::Expr<'_>]) {\n         let base_args = &args[1..];\n         self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX);\n         self.s.word(\".\");\n@@ -1118,7 +1117,7 @@ impl<'a> State<'a> {\n         self.print_call_post(base_args)\n     }\n \n-    fn print_expr_binary(&mut self, op: hir::BinOp, lhs: &hir::Expr, rhs: &hir::Expr) {\n+    fn print_expr_binary(&mut self, op: hir::BinOp, lhs: &hir::Expr<'_>, rhs: &hir::Expr<'_>) {\n         let assoc_op = bin_op_to_assoc_op(op.node);\n         let prec = assoc_op.precedence() as i8;\n         let fixity = assoc_op.fixity();\n@@ -1144,7 +1143,7 @@ impl<'a> State<'a> {\n         self.print_expr_maybe_paren(rhs, right_prec)\n     }\n \n-    fn print_expr_unary(&mut self, op: hir::UnOp, expr: &hir::Expr) {\n+    fn print_expr_unary(&mut self, op: hir::UnOp, expr: &hir::Expr<'_>) {\n         self.s.word(op.as_str());\n         self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n@@ -1153,7 +1152,7 @@ impl<'a> State<'a> {\n         &mut self,\n         kind: hir::BorrowKind,\n         mutability: hir::Mutability,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n     ) {\n         self.s.word(\"&\");\n         match kind {\n@@ -1171,7 +1170,7 @@ impl<'a> State<'a> {\n         self.word(lit.node.to_lit_token().to_string())\n     }\n \n-    pub fn print_expr(&mut self, expr: &hir::Expr) {\n+    pub fn print_expr(&mut self, expr: &hir::Expr<'_>) {\n         self.maybe_print_comment(expr.span.lo());\n         self.print_outer_attributes(&expr.attrs);\n         self.ibox(INDENT_UNIT);\n@@ -1187,8 +1186,8 @@ impl<'a> State<'a> {\n             hir::ExprKind::Repeat(ref element, ref count) => {\n                 self.print_expr_repeat(&element, count);\n             }\n-            hir::ExprKind::Struct(ref qpath, ref fields, ref wth) => {\n-                self.print_expr_struct(qpath, &fields[..], wth);\n+            hir::ExprKind::Struct(ref qpath, fields, ref wth) => {\n+                self.print_expr_struct(qpath, fields, wth);\n             }\n             hir::ExprKind::Tup(ref exprs) => {\n                 self.print_expr_tup(exprs);\n@@ -1251,7 +1250,7 @@ impl<'a> State<'a> {\n                 self.s.space();\n                 self.print_block(&blk);\n             }\n-            hir::ExprKind::Match(ref expr, ref arms, _) => {\n+            hir::ExprKind::Match(ref expr, arms, _) => {\n                 self.cbox(INDENT_UNIT);\n                 self.ibox(INDENT_UNIT);\n                 self.word_nbsp(\"match\");\n@@ -1418,7 +1417,7 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn print_local_decl(&mut self, loc: &hir::Local) {\n+    pub fn print_local_decl(&mut self, loc: &hir::Local<'_>) {\n         self.print_pat(&loc.pat);\n         if let Some(ref ty) = loc.ty {\n             self.word_space(\":\");\n@@ -1434,7 +1433,7 @@ impl<'a> State<'a> {\n         self.print_ident(ast::Ident::with_dummy_span(name))\n     }\n \n-    pub fn print_for_decl(&mut self, loc: &hir::Local, coll: &hir::Expr) {\n+    pub fn print_for_decl(&mut self, loc: &hir::Local<'_>, coll: &hir::Expr<'_>) {\n         self.print_local_decl(loc);\n         self.s.space();\n         self.word_space(\"in\");\n@@ -1599,7 +1598,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_pat(&mut self, pat: &hir::Pat) {\n+    pub fn print_pat(&mut self, pat: &hir::Pat<'_>) {\n         self.maybe_print_comment(pat.span.lo());\n         self.ann.pre(self, AnnNode::Pat(pat));\n         // Pat isn't normalized, but the beauty of it\n@@ -1761,12 +1760,12 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n-    pub fn print_param(&mut self, arg: &hir::Param) {\n+    pub fn print_param(&mut self, arg: &hir::Param<'_>) {\n         self.print_outer_attributes(&arg.attrs);\n         self.print_pat(&arg.pat);\n     }\n \n-    pub fn print_arm(&mut self, arm: &hir::Arm) {\n+    pub fn print_arm(&mut self, arm: &hir::Arm<'_>) {\n         // I have no idea why this check is necessary, but here it\n         // is :(\n         if arm.attrs.is_empty() {\n@@ -2212,7 +2211,7 @@ impl<'a> State<'a> {\n /// isn't parsed as (if true {...} else {...} | x) | 5\n //\n // Duplicated from `parse::classify`, but adapted for the HIR.\n-fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n+fn expr_requires_semi_to_be_stmt(e: &hir::Expr<'_>) -> bool {\n     match e.kind {\n         hir::ExprKind::Match(..) | hir::ExprKind::Block(..) | hir::ExprKind::Loop(..) => false,\n         _ => true,\n@@ -2222,7 +2221,7 @@ fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n /// This statement requires a semicolon after it.\n /// note that in one case (stmt_semi), we've already\n /// seen the semicolon, and thus don't need another.\n-fn stmt_ends_with_semi(stmt: &hir::StmtKind) -> bool {\n+fn stmt_ends_with_semi(stmt: &hir::StmtKind<'_>) -> bool {\n     match *stmt {\n         hir::StmtKind::Local(_) => true,\n         hir::StmtKind::Item(_) => false,\n@@ -2261,7 +2260,7 @@ fn bin_op_to_assoc_op(op: hir::BinOpKind) -> AssocOp {\n /// Expressions that syntactically contain an \"exterior\" struct literal, i.e., not surrounded by any\n /// parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n-fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n+fn contains_exterior_struct_lit(value: &hir::Expr<'_>) -> bool {\n     match value.kind {\n         hir::ExprKind::Struct(..) => true,\n "}, {"sha": "d7de226df59ec17778bb9324160b5314c0f812f0", "filename": "src/librustc/hir/upvars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fhir%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fupvars.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -46,7 +46,7 @@ impl Visitor<'tcx> for LocalCollector {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n         if let hir::PatKind::Binding(_, hir_id, ..) = pat.kind {\n             self.locals.insert(hir_id);\n         }\n@@ -81,7 +81,7 @@ impl Visitor<'tcx> for CaptureCollector<'a, 'tcx> {\n         intravisit::walk_path(self, path);\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         if let hir::ExprKind::Closure(..) = expr.kind {\n             let closure_def_id = self.tcx.hir().local_def_id(expr.hir_id);\n             if let Some(upvars) = self.tcx.upvars(closure_def_id) {"}, {"sha": "31d4f8513b2aa4aa9d3b579279f04f1b53baa30b", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -117,7 +117,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr<'_> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr { hir_id: _, ref span, ref kind, ref attrs } = *self;"}, {"sha": "6b977393806ee8d0993b8cacb467eb6257ee6d59", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -17,11 +17,11 @@ struct FindLocalByTypeVisitor<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     target_ty: Ty<'tcx>,\n     hir_map: &'a hir::map::Map<'tcx>,\n-    found_local_pattern: Option<&'tcx Pat>,\n-    found_arg_pattern: Option<&'tcx Pat>,\n+    found_local_pattern: Option<&'tcx Pat<'tcx>>,\n+    found_arg_pattern: Option<&'tcx Pat<'tcx>>,\n     found_ty: Option<Ty<'tcx>>,\n-    found_closure: Option<&'tcx ExprKind>,\n-    found_method_call: Option<&'tcx Expr>,\n+    found_closure: Option<&'tcx ExprKind<'tcx>>,\n+    found_method_call: Option<&'tcx Expr<'tcx>>,\n }\n \n impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n@@ -72,7 +72,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.hir_map)\n     }\n \n-    fn visit_local(&mut self, local: &'tcx Local) {\n+    fn visit_local(&mut self, local: &'tcx Local<'tcx>) {\n         if let (None, Some(ty)) = (self.found_local_pattern, self.node_matches_type(local.hir_id)) {\n             self.found_local_pattern = Some(&*local.pat);\n             self.found_ty = Some(ty);\n@@ -91,7 +91,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n         intravisit::walk_body(self, body);\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         if self.node_matches_type(expr.hir_id).is_some() {\n             match expr.kind {\n                 ExprKind::Closure(..) => self.found_closure = Some(&expr.kind),\n@@ -460,8 +460,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// needed, suggest annotating the call, otherwise point out the resulting type of the call.\n     fn annotate_method_call(\n         &self,\n-        segment: &hir::ptr::P<hir::PathSegment>,\n-        e: &Expr,\n+        segment: &hir::PathSegment,\n+        e: &Expr<'_>,\n         err: &mut DiagnosticBuilder<'_>,\n     ) {\n         if let (Ok(snippet), Some(tables), None) = ("}, {"sha": "638c8f5200719e9454250597eb4fd888f471ba0a", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -12,7 +12,7 @@ use syntax_pos::Span;\n #[derive(Debug)]\n pub(super) struct AnonymousParamInfo<'tcx> {\n     // the parameter corresponding to the anonymous region\n-    pub param: &'tcx hir::Param,\n+    pub param: &'tcx hir::Param<'tcx>,\n     // the type corresponding to the anonymopus region parameter\n     pub param_ty: Ty<'tcx>,\n     // the ty::BoundRegion corresponding to the anonymous region"}, {"sha": "4e1e62512acd26dafffc8e2b36d4b95f64d84578", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -894,7 +894,7 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n         self.context.tables = old_tables;\n     }\n \n-    fn visit_param(&mut self, param: &'tcx hir::Param) {\n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n         self.with_lint_attrs(param.hir_id, &param.attrs, |cx| {\n             lint_callback!(cx, check_param, param);\n             hir_visit::walk_param(cx, param);\n@@ -930,20 +930,20 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n         })\n     }\n \n-    fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n+    fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n         lint_callback!(self, check_pat, p);\n         hir_visit::walk_pat(self, p);\n     }\n \n-    fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n         self.with_lint_attrs(e.hir_id, &e.attrs, |cx| {\n             lint_callback!(cx, check_expr, e);\n             hir_visit::walk_expr(cx, e);\n             lint_callback!(cx, check_expr_post, e);\n         })\n     }\n \n-    fn visit_stmt(&mut self, s: &'tcx hir::Stmt) {\n+    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n         // statement attributes are actually just attributes on one of\n         // - item\n         // - local\n@@ -1020,20 +1020,20 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n         }\n     }\n \n-    fn visit_local(&mut self, l: &'tcx hir::Local) {\n+    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n         self.with_lint_attrs(l.hir_id, &l.attrs, |cx| {\n             lint_callback!(cx, check_local, l);\n             hir_visit::walk_local(cx, l);\n         })\n     }\n \n-    fn visit_block(&mut self, b: &'tcx hir::Block) {\n+    fn visit_block(&mut self, b: &'tcx hir::Block<'tcx>) {\n         lint_callback!(self, check_block, b);\n         hir_visit::walk_block(self, b);\n         lint_callback!(self, check_block_post, b);\n     }\n \n-    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n         lint_callback!(self, check_arm, a);\n         hir_visit::walk_arm(self, a);\n     }"}, {"sha": "97b38db4165979ab226e02fdf880606f5c1fb426", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -87,7 +87,7 @@ macro_rules! declare_lint_pass {\n macro_rules! late_lint_methods {\n     ($macro:path, $args:tt, [$hir:tt]) => (\n         $macro!($args, [$hir], [\n-            fn check_param(a: &$hir hir::Param);\n+            fn check_param(a: &$hir hir::Param<$hir>);\n             fn check_body(a: &$hir hir::Body<$hir>);\n             fn check_body_post(a: &$hir hir::Body<$hir>);\n             fn check_name(a: Span, b: ast::Name);\n@@ -99,14 +99,14 @@ macro_rules! late_lint_methods {\n             fn check_foreign_item_post(a: &$hir hir::ForeignItem<$hir>);\n             fn check_item(a: &$hir hir::Item<$hir>);\n             fn check_item_post(a: &$hir hir::Item<$hir>);\n-            fn check_local(a: &$hir hir::Local);\n-            fn check_block(a: &$hir hir::Block);\n-            fn check_block_post(a: &$hir hir::Block);\n-            fn check_stmt(a: &$hir hir::Stmt);\n-            fn check_arm(a: &$hir hir::Arm);\n-            fn check_pat(a: &$hir hir::Pat);\n-            fn check_expr(a: &$hir hir::Expr);\n-            fn check_expr_post(a: &$hir hir::Expr);\n+            fn check_local(a: &$hir hir::Local<$hir>);\n+            fn check_block(a: &$hir hir::Block<$hir>);\n+            fn check_block_post(a: &$hir hir::Block<$hir>);\n+            fn check_stmt(a: &$hir hir::Stmt<$hir>);\n+            fn check_arm(a: &$hir hir::Arm<$hir>);\n+            fn check_pat(a: &$hir hir::Pat<$hir>);\n+            fn check_expr(a: &$hir hir::Expr<$hir>);\n+            fn check_expr_post(a: &$hir hir::Expr<$hir>);\n             fn check_ty(a: &$hir hir::Ty);\n             fn check_generic_param(a: &$hir hir::GenericParam);\n             fn check_generics(a: &$hir hir::Generics);\n@@ -610,7 +610,7 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n         intravisit::NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n-    fn visit_param(&mut self, param: &'tcx hir::Param) {\n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n         self.with_lint_attrs(param.hir_id, &param.attrs, |builder| {\n             intravisit::walk_param(builder, param);\n         });\n@@ -628,7 +628,7 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n         })\n     }\n \n-    fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n         self.with_lint_attrs(e.hir_id, &e.attrs, |builder| {\n             intravisit::walk_expr(builder, e);\n         })\n@@ -651,13 +651,13 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n         })\n     }\n \n-    fn visit_local(&mut self, l: &'tcx hir::Local) {\n+    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n         self.with_lint_attrs(l.hir_id, &l.attrs, |builder| {\n             intravisit::walk_local(builder, l);\n         })\n     }\n \n-    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n         self.with_lint_attrs(a.hir_id, &a.attrs, |builder| {\n             intravisit::walk_arm(builder, a);\n         })"}, {"sha": "c6598f2d328bf47f5b9819bf17afa4d3af8008d3", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n         self.tables = old_tables;\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         let res = match expr.kind {\n             hir::ExprKind::Path(ref qpath) => Some(self.tables.qpath_res(qpath, expr.hir_id)),\n             hir::ExprKind::MethodCall(..) => self"}, {"sha": "5126d3f7fdefe68e85f649465ced9c0992b6f70b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -432,7 +432,7 @@ impl<'tcx> Visitor<'tcx> for ExprLocatorVisitor {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_pat(&mut self, pat: &'tcx Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx Pat<'tcx>) {\n         intravisit::walk_pat(self, pat);\n \n         self.expr_and_pat_count += 1;\n@@ -442,7 +442,7 @@ impl<'tcx> Visitor<'tcx> for ExprLocatorVisitor {\n         }\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         debug!(\"ExprLocatorVisitor - pre-increment {} expr = {:?}\", self.expr_and_pat_count, expr);\n \n         intravisit::walk_expr(self, expr);\n@@ -773,7 +773,7 @@ fn record_var_lifetime(\n     }\n }\n \n-fn resolve_block<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, blk: &'tcx hir::Block) {\n+fn resolve_block<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, blk: &'tcx hir::Block<'tcx>) {\n     debug!(\"resolve_block(blk.hir_id={:?})\", blk.hir_id);\n \n     let prev_cx = visitor.cx;\n@@ -837,7 +837,7 @@ fn resolve_block<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, blk: &'tcx h\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_arm<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, arm: &'tcx hir::Arm) {\n+fn resolve_arm<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, arm: &'tcx hir::Arm<'tcx>) {\n     let prev_cx = visitor.cx;\n \n     visitor.enter_scope(Scope { id: arm.hir_id.local_id, data: ScopeData::Node });\n@@ -854,7 +854,7 @@ fn resolve_arm<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, arm: &'tcx hir\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_pat<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, pat: &'tcx hir::Pat) {\n+fn resolve_pat<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, pat: &'tcx hir::Pat<'tcx>) {\n     visitor.record_child_scope(Scope { id: pat.hir_id.local_id, data: ScopeData::Node });\n \n     // If this is a binding then record the lifetime of that binding.\n@@ -871,7 +871,7 @@ fn resolve_pat<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, pat: &'tcx hir\n     debug!(\"resolve_pat - post-increment {} pat = {:?}\", visitor.expr_and_pat_count, pat);\n }\n \n-fn resolve_stmt<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, stmt: &'tcx hir::Stmt) {\n+fn resolve_stmt<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, stmt: &'tcx hir::Stmt<'tcx>) {\n     let stmt_id = stmt.hir_id.local_id;\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n@@ -890,7 +890,7 @@ fn resolve_stmt<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, stmt: &'tcx h\n     visitor.cx.parent = prev_parent;\n }\n \n-fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx hir::Expr) {\n+fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx hir::Expr<'tcx>) {\n     debug!(\"resolve_expr - pre-increment {} expr = {:?}\", visitor.expr_and_pat_count, expr);\n \n     let prev_cx = visitor.cx;\n@@ -1107,8 +1107,8 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n \n fn resolve_local<'tcx>(\n     visitor: &mut RegionResolutionVisitor<'tcx>,\n-    pat: Option<&'tcx hir::Pat>,\n-    init: Option<&'tcx hir::Expr>,\n+    pat: Option<&'tcx hir::Pat<'tcx>>,\n+    init: Option<&'tcx hir::Expr<'tcx>>,\n ) {\n     debug!(\"resolve_local(pat={:?}, init={:?})\", pat, init);\n \n@@ -1197,7 +1197,7 @@ fn resolve_local<'tcx>(\n     ///        | ( ..., P&, ... )\n     ///        | ... \"|\" P& \"|\" ...\n     ///        | box P&\n-    fn is_binding_pat(pat: &hir::Pat) -> bool {\n+    fn is_binding_pat(pat: &hir::Pat<'_>) -> bool {\n         // Note that the code below looks for *explicit* refs only, that is, it won't\n         // know about *implicit* refs as introduced in #42640.\n         //\n@@ -1263,20 +1263,20 @@ fn resolve_local<'tcx>(\n     ///        | ( E& )\n     fn record_rvalue_scope_if_borrow_expr<'tcx>(\n         visitor: &mut RegionResolutionVisitor<'tcx>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         blk_id: Option<Scope>,\n     ) {\n         match expr.kind {\n             hir::ExprKind::AddrOf(_, _, ref subexpr) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n                 record_rvalue_scope(visitor, &subexpr, blk_id);\n             }\n-            hir::ExprKind::Struct(_, ref fields, _) => {\n+            hir::ExprKind::Struct(_, fields, _) => {\n                 for field in fields {\n                     record_rvalue_scope_if_borrow_expr(visitor, &field.expr, blk_id);\n                 }\n             }\n-            hir::ExprKind::Array(ref subexprs) | hir::ExprKind::Tup(ref subexprs) => {\n+            hir::ExprKind::Array(subexprs) | hir::ExprKind::Tup(subexprs) => {\n                 for subexpr in subexprs {\n                     record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n                 }\n@@ -1310,7 +1310,7 @@ fn resolve_local<'tcx>(\n     /// Note: ET is intended to match \"rvalues or places based on rvalues\".\n     fn record_rvalue_scope<'tcx>(\n         visitor: &mut RegionResolutionVisitor<'tcx>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         blk_scope: Option<Scope>,\n     ) {\n         let mut expr = expr;\n@@ -1372,7 +1372,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_block(&mut self, b: &'tcx Block) {\n+    fn visit_block(&mut self, b: &'tcx Block<'tcx>) {\n         resolve_block(self, b);\n     }\n \n@@ -1444,19 +1444,19 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n         self.terminating_scopes = outer_ts;\n     }\n \n-    fn visit_arm(&mut self, a: &'tcx Arm) {\n+    fn visit_arm(&mut self, a: &'tcx Arm<'tcx>) {\n         resolve_arm(self, a);\n     }\n-    fn visit_pat(&mut self, p: &'tcx Pat) {\n+    fn visit_pat(&mut self, p: &'tcx Pat<'tcx>) {\n         resolve_pat(self, p);\n     }\n-    fn visit_stmt(&mut self, s: &'tcx Stmt) {\n+    fn visit_stmt(&mut self, s: &'tcx Stmt<'tcx>) {\n         resolve_stmt(self, s);\n     }\n-    fn visit_expr(&mut self, ex: &'tcx Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n         resolve_expr(self, ex);\n     }\n-    fn visit_local(&mut self, l: &'tcx Local) {\n+    fn visit_local(&mut self, l: &'tcx Local<'tcx>) {\n         resolve_local(self, Some(&l.pat), l.init.as_ref().map(|e| &**e));\n     }\n }"}, {"sha": "7950ff421b4a58d784a2b5129dad55870e71024f", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -1133,7 +1133,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n             NestedVisitorMap::None\n         }\n \n-        fn visit_expr(&mut self, ex: &hir::Expr) {\n+        fn visit_expr(&mut self, ex: &hir::Expr<'_>) {\n             if let Some(label) = expression_label(ex) {\n                 for prior_label in &self.labels_in_fn[..] {\n                     // FIXME (#24278): non-hygienic comparison\n@@ -1155,7 +1155,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n         }\n     }\n \n-    fn expression_label(ex: &hir::Expr) -> Option<ast::Ident> {\n+    fn expression_label(ex: &hir::Expr<'_>) -> Option<ast::Ident> {\n         if let hir::ExprKind::Loop(_, Some(label), _) = ex.kind { Some(label.ident) } else { None }\n     }\n "}, {"sha": "f7d9cb34fa9252091b60d0a9c16e912915f3b7cc", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -1331,19 +1331,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         msg: &str,\n     ) -> Option<String> {\n-        let get_name = |err: &mut DiagnosticBuilder<'_>, kind: &hir::PatKind| -> Option<String> {\n-            // Get the local name of this closure. This can be inaccurate because\n-            // of the possibility of reassignment, but this should be good enough.\n-            match &kind {\n-                hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, name, None) => {\n-                    Some(format!(\"{}\", name))\n-                }\n-                _ => {\n-                    err.note(&msg);\n-                    None\n+        let get_name =\n+            |err: &mut DiagnosticBuilder<'_>, kind: &hir::PatKind<'_>| -> Option<String> {\n+                // Get the local name of this closure. This can be inaccurate because\n+                // of the possibility of reassignment, but this should be good enough.\n+                match &kind {\n+                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, name, None) => {\n+                        Some(format!(\"{}\", name))\n+                    }\n+                    _ => {\n+                        err.note(&msg);\n+                        None\n+                    }\n                 }\n-            }\n-        };\n+            };\n \n         let hir = self.tcx.hir();\n         let hir_id = hir.as_local_hir_id(def_id)?;"}, {"sha": "2659caf030b0c6dc64bd31f9cdba27bd075bec60", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -553,11 +553,11 @@ impl<'tcx> TypeckTables<'tcx> {\n \n     // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n     // doesn't provide type parameter substitutions.\n-    pub fn pat_ty(&self, pat: &hir::Pat) -> Ty<'tcx> {\n+    pub fn pat_ty(&self, pat: &hir::Pat<'_>) -> Ty<'tcx> {\n         self.node_type(pat.hir_id)\n     }\n \n-    pub fn pat_ty_opt(&self, pat: &hir::Pat) -> Option<Ty<'tcx>> {\n+    pub fn pat_ty_opt(&self, pat: &hir::Pat<'_>) -> Option<Ty<'tcx>> {\n         self.node_type_opt(pat.hir_id)\n     }\n \n@@ -571,11 +571,11 @@ impl<'tcx> TypeckTables<'tcx> {\n     // NB (2): This type doesn't provide type parameter substitutions; e.g., if you\n     // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n     // instead of \"fn(ty) -> T with T = isize\".\n-    pub fn expr_ty(&self, expr: &hir::Expr) -> Ty<'tcx> {\n+    pub fn expr_ty(&self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n         self.node_type(expr.hir_id)\n     }\n \n-    pub fn expr_ty_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n+    pub fn expr_ty_opt(&self, expr: &hir::Expr<'_>) -> Option<Ty<'tcx>> {\n         self.node_type_opt(expr.hir_id)\n     }\n \n@@ -589,22 +589,22 @@ impl<'tcx> TypeckTables<'tcx> {\n         LocalTableInContextMut { local_id_root: self.local_id_root, data: &mut self.adjustments }\n     }\n \n-    pub fn expr_adjustments(&self, expr: &hir::Expr) -> &[ty::adjustment::Adjustment<'tcx>] {\n+    pub fn expr_adjustments(&self, expr: &hir::Expr<'_>) -> &[ty::adjustment::Adjustment<'tcx>] {\n         validate_hir_id_for_typeck_tables(self.local_id_root, expr.hir_id, false);\n         self.adjustments.get(&expr.hir_id.local_id).map_or(&[], |a| &a[..])\n     }\n \n     /// Returns the type of `expr`, considering any `Adjustment`\n     /// entry recorded for that expression.\n-    pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> Ty<'tcx> {\n+    pub fn expr_ty_adjusted(&self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n         self.expr_adjustments(expr).last().map_or_else(|| self.expr_ty(expr), |adj| adj.target)\n     }\n \n-    pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n+    pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr<'_>) -> Option<Ty<'tcx>> {\n         self.expr_adjustments(expr).last().map(|adj| adj.target).or_else(|| self.expr_ty_opt(expr))\n     }\n \n-    pub fn is_method_call(&self, expr: &hir::Expr) -> bool {\n+    pub fn is_method_call(&self, expr: &hir::Expr<'_>) -> bool {\n         // Only paths and method calls/overloaded operators have\n         // entries in type_dependent_defs, ignore the former here.\n         if let hir::ExprKind::Path(_) = expr.kind {"}, {"sha": "481ca43aa793af528fd0413f54c9e88ab04ea58d", "filename": "src/librustc_lint/array_into_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_lint%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_lint%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Farray_into_iter.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -25,7 +25,7 @@ declare_lint_pass!(\n );\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIntoIter {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'tcx>) {\n         // We only care about method call expressions.\n         if let hir::ExprKind::MethodCall(call, span, args) = &expr.kind {\n             if call.ident.name != sym::into_iter {"}, {"sha": "2d9e960716f4ea73351b317e40c8957fa5a88c0a", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -142,7 +142,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr<'_>) {\n         let ty = cx.tables.node_type(e.hir_id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n@@ -157,8 +157,8 @@ declare_lint! {\n declare_lint_pass!(NonShorthandFieldPatterns => [NON_SHORTHAND_FIELD_PATTERNS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n-    fn check_pat(&mut self, cx: &LateContext<'_, '_>, pat: &hir::Pat) {\n-        if let PatKind::Struct(ref qpath, ref field_pats, _) = pat.kind {\n+    fn check_pat(&mut self, cx: &LateContext<'_, '_>, pat: &hir::Pat<'_>) {\n+        if let PatKind::Struct(ref qpath, field_pats, _) = pat.kind {\n             let variant = cx\n                 .tables\n                 .pat_ty(pat)\n@@ -901,7 +901,7 @@ declare_lint! {\n declare_lint_pass!(MutableTransmutes => [MUTABLE_TRANSMUTES]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n         use rustc_target::spec::abi::Abi::RustIntrinsic;\n \n         let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n@@ -917,7 +917,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n \n         fn get_transmute_from_to<'a, 'tcx>(\n             cx: &LateContext<'a, 'tcx>,\n-            expr: &hir::Expr,\n+            expr: &hir::Expr<'_>,\n         ) -> Option<(Ty<'tcx>, Ty<'tcx>)> {\n             let def = if let hir::ExprKind::Path(ref qpath) = expr.kind {\n                 cx.tables.qpath_res(qpath, expr.hir_id)\n@@ -1840,7 +1840,7 @@ declare_lint! {\n declare_lint_pass!(InvalidValue => [INVALID_VALUE]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &hir::Expr<'_>) {\n         #[derive(Debug, Copy, Clone, PartialEq)]\n         enum InitKind {\n             Zeroed,\n@@ -1852,7 +1852,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n         type InitError = (String, Option<Span>);\n \n         /// Test if this constant is all-0.\n-        fn is_zero(expr: &hir::Expr) -> bool {\n+        fn is_zero(expr: &hir::Expr<'_>) -> bool {\n             use hir::ExprKind::*;\n             use syntax::ast::LitKind::*;\n             match &expr.kind {\n@@ -1869,7 +1869,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n         }\n \n         /// Determine if this expression is a \"dangerous initialization\".\n-        fn is_dangerous_init(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> Option<InitKind> {\n+        fn is_dangerous_init(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) -> Option<InitKind> {\n             // `transmute` is inside an anonymous module (the `extern` block?);\n             // `Invalid` represents the empty string and matches that.\n             // FIXME(#66075): use diagnostic items.  Somehow, that does not seem to work"}, {"sha": "2752be9a6de9903ff515865d8c80f330b782dc24", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -344,7 +344,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat) {\n+    fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat<'_>) {\n         if let &PatKind::Binding(_, _, ident, _) = &p.kind {\n             self.check_snake_case(cx, \"variable\", &ident);\n         }\n@@ -410,7 +410,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat) {\n+    fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat<'_>) {\n         // Lint for constants that look like binding identifiers (#7526)\n         if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.kind {\n             if let Res::Def(DefKind::Const, _) = path.res {"}, {"sha": "ba2087d2f2620a34db5e5875e62fdbea3cda59dd", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -65,8 +65,8 @@ fn lint_overflowing_range_endpoint<'a, 'tcx>(\n     lit: &hir::Lit,\n     lit_val: u128,\n     max: u128,\n-    expr: &'tcx hir::Expr,\n-    parent_expr: &'tcx hir::Expr,\n+    expr: &'tcx hir::Expr<'tcx>,\n+    parent_expr: &'tcx hir::Expr<'tcx>,\n     ty: &str,\n ) -> bool {\n     // We only want to handle exclusive (`..`) ranges,\n@@ -150,7 +150,7 @@ fn get_bin_hex_repr(cx: &LateContext<'_, '_>, lit: &hir::Lit) -> Option<String>\n \n fn report_bin_hex_error(\n     cx: &LateContext<'_, '_>,\n-    expr: &hir::Expr,\n+    expr: &hir::Expr<'_>,\n     ty: attr::IntType,\n     repr_str: String,\n     val: u128,\n@@ -244,7 +244,7 @@ fn get_type_suggestion(t: Ty<'_>, val: u128, negative: bool) -> Option<&'static\n fn lint_int_literal<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     type_limits: &TypeLimits,\n-    e: &'tcx hir::Expr,\n+    e: &'tcx hir::Expr<'tcx>,\n     lit: &hir::Lit,\n     t: ast::IntTy,\n     v: u128,\n@@ -284,7 +284,7 @@ fn lint_int_literal<'a, 'tcx>(\n \n fn lint_uint_literal<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    e: &'tcx hir::Expr,\n+    e: &'tcx hir::Expr<'tcx>,\n     lit: &hir::Lit,\n     t: ast::UintTy,\n ) {\n@@ -342,7 +342,7 @@ fn lint_uint_literal<'a, 'tcx>(\n fn lint_literal<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     type_limits: &TypeLimits,\n-    e: &'tcx hir::Expr,\n+    e: &'tcx hir::Expr<'tcx>,\n     lit: &hir::Lit,\n ) {\n     match cx.tables.node_type(e.hir_id).kind {\n@@ -377,7 +377,7 @@ fn lint_literal<'a, 'tcx>(\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr<'tcx>) {\n         match e.kind {\n             hir::ExprKind::Unary(hir::UnNeg, ref expr) => {\n                 // propagate negation, if the negation itself isn't negated\n@@ -425,8 +425,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n         fn check_limits(\n             cx: &LateContext<'_, '_>,\n             binop: hir::BinOp,\n-            l: &hir::Expr,\n-            r: &hir::Expr,\n+            l: &hir::Expr<'_>,\n+            r: &hir::Expr<'_>,\n         ) -> bool {\n             let (lit, expr, swap) = match (&l.kind, &r.kind) {\n                 (&hir::ExprKind::Lit(_), _) => (l, r, true),"}, {"sha": "5edb81c1e518d1c977aca971bae2d39083c19e47", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -37,7 +37,7 @@ declare_lint! {\n declare_lint_pass!(UnusedResults => [UNUSED_MUST_USE, UNUSED_RESULTS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n-    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt<'_>) {\n         let expr = match s.kind {\n             hir::StmtKind::Semi(ref expr) => &**expr,\n             _ => return,\n@@ -123,7 +123,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         fn check_must_use_ty<'tcx>(\n             cx: &LateContext<'_, 'tcx>,\n             ty: Ty<'tcx>,\n-            expr: &hir::Expr,\n+            expr: &hir::Expr<'_>,\n             span: Span,\n             descr_pre: &str,\n             descr_post: &str,\n@@ -245,7 +245,7 @@ declare_lint! {\n declare_lint_pass!(PathStatements => [PATH_STATEMENTS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathStatements {\n-    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt<'_>) {\n         if let hir::StmtKind::Semi(ref expr) = s.kind {\n             if let hir::ExprKind::Path(_) = expr.kind {\n                 cx.span_lint(PATH_STATEMENTS, s.span, \"path statement with no effect\");\n@@ -637,7 +637,7 @@ declare_lint! {\n declare_lint_pass!(UnusedAllocation => [UNUSED_ALLOCATION]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr<'_>) {\n         match e.kind {\n             hir::ExprKind::Box(_) => {}\n             _ => return,"}, {"sha": "84d5d529adf76e20ffe4609671a816decab7b7ba", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -1524,7 +1524,7 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n-    fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx hir::Expr<'tcx>) {\n         intravisit::walk_expr(self, ex);\n         self.encode_info_for_expr(ex);\n     }\n@@ -1587,7 +1587,7 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n-    fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n+    fn encode_info_for_expr(&mut self, expr: &hir::Expr<'_>) {\n         match expr.kind {\n             hir::ExprKind::Closure(..) => {\n                 let def_id = self.tcx.hir().local_def_id(expr.hir_id);"}, {"sha": "da8bb6adf84a9b1772ceb2751e9305d7ef7f2b2a", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -11,7 +11,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         destination: &Place<'tcx>,\n         block: BasicBlock,\n-        ast_block: &'tcx hir::Block,\n+        ast_block: &'tcx hir::Block<'tcx>,\n         source_info: SourceInfo,\n     ) -> BlockAnd<()> {\n         let Block {"}, {"sha": "f459ca8dbbaf504aa8ab998489f2ca68380b122d", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -29,8 +29,10 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n \n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span) = match tcx.hir().get(id) {\n-        Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(_, decl, body_id, _, _), .. })\n-        | Node::Item(hir::Item {\n+        Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(_, decl, body_id, _, _), .. }) => {\n+            (*body_id, decl.output.span())\n+        }\n+        Node::Item(hir::Item {\n             kind: hir::ItemKind::Fn(hir::FnSig { decl, .. }, _, body_id),\n             ..\n         })\n@@ -529,7 +531,12 @@ fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: DefId, _abi: Abi) -> bool {\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-struct ArgInfo<'tcx>(Ty<'tcx>, Option<Span>, Option<&'tcx hir::Param>, Option<ImplicitSelfKind>);\n+struct ArgInfo<'tcx>(\n+    Ty<'tcx>,\n+    Option<Span>,\n+    Option<&'tcx hir::Param<'tcx>>,\n+    Option<ImplicitSelfKind>,\n+);\n \n fn construct_fn<'a, 'tcx, A>(\n     hir: Cx<'a, 'tcx>,\n@@ -738,7 +745,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         fn_def_id: DefId,\n         arguments: &[ArgInfo<'tcx>],\n         argument_scope: region::Scope,\n-        ast_body: &'tcx hir::Expr,\n+        ast_body: &'tcx hir::Expr<'tcx>,\n     ) -> BlockAnd<()> {\n         // Allocate locals for the function arguments\n         for &ArgInfo(ty, _, arg_opt, _) in arguments.iter() {"}, {"sha": "14f6c3945304dee89f12eff3821ff5c42ccf2fc4", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -8,7 +8,7 @@ use rustc::ty;\n \n use rustc_index::vec::Idx;\n \n-impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n+impl<'tcx> Mirror<'tcx> for &'tcx hir::Block<'tcx> {\n     type Output = Block<'tcx>;\n \n     fn make_mirror(self, cx: &mut Cx<'_, 'tcx>) -> Block<'tcx> {\n@@ -37,7 +37,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n fn mirror_stmts<'a, 'tcx>(\n     cx: &mut Cx<'a, 'tcx>,\n     block_id: hir::ItemLocalId,\n-    stmts: &'tcx [hir::Stmt],\n+    stmts: &'tcx [hir::Stmt<'tcx>],\n ) -> Vec<StmtRef<'tcx>> {\n     let mut result = vec![];\n     for (index, stmt) in stmts.iter().enumerate() {\n@@ -101,7 +101,10 @@ fn mirror_stmts<'a, 'tcx>(\n     return result;\n }\n \n-pub fn to_expr_ref<'a, 'tcx>(cx: &mut Cx<'a, 'tcx>, block: &'tcx hir::Block) -> ExprRef<'tcx> {\n+pub fn to_expr_ref<'a, 'tcx>(\n+    cx: &mut Cx<'a, 'tcx>,\n+    block: &'tcx hir::Block<'tcx>,\n+) -> ExprRef<'tcx> {\n     let block_ty = cx.tables().node_type(block.hir_id);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(block.hir_id.local_id);\n     let expr = Expr {"}, {"sha": "124b788fe8dd2152ebfe15b43fcb59e5255b54b6", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -14,7 +14,7 @@ use rustc::ty::{self, AdtKind, Ty};\n use rustc_index::vec::Idx;\n use syntax_pos::Span;\n \n-impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n+impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr<'tcx> {\n     type Output = Expr<'tcx>;\n \n     fn make_mirror(self, cx: &mut Cx<'_, 'tcx>) -> Expr<'tcx> {\n@@ -65,7 +65,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n \n fn apply_adjustment<'a, 'tcx>(\n     cx: &mut Cx<'a, 'tcx>,\n-    hir_expr: &'tcx hir::Expr,\n+    hir_expr: &'tcx hir::Expr<'tcx>,\n     mut expr: Expr<'tcx>,\n     adjustment: &Adjustment<'tcx>,\n ) -> Expr<'tcx> {\n@@ -129,7 +129,10 @@ fn apply_adjustment<'a, 'tcx>(\n     Expr { temp_lifetime, ty: adjustment.target, span, kind }\n }\n \n-fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> Expr<'tcx> {\n+fn make_mirror_unadjusted<'a, 'tcx>(\n+    cx: &mut Cx<'a, 'tcx>,\n+    expr: &'tcx hir::Expr<'tcx>,\n+) -> Expr<'tcx> {\n     let expr_ty = cx.tables().expr_ty(expr);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n@@ -608,7 +611,7 @@ fn user_substs_applied_to_res(\n \n fn method_callee<'a, 'tcx>(\n     cx: &mut Cx<'a, 'tcx>,\n-    expr: &hir::Expr,\n+    expr: &hir::Expr<'_>,\n     span: Span,\n     overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n ) -> Expr<'tcx> {\n@@ -662,7 +665,7 @@ impl ToBorrowKind for hir::Mutability {\n     }\n }\n \n-fn convert_arm<'tcx>(cx: &mut Cx<'_, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n+fn convert_arm<'tcx>(cx: &mut Cx<'_, 'tcx>, arm: &'tcx hir::Arm<'tcx>) -> Arm<'tcx> {\n     Arm {\n         pattern: cx.pattern_from_hir(&arm.pat),\n         guard: match arm.guard {\n@@ -678,7 +681,7 @@ fn convert_arm<'tcx>(cx: &mut Cx<'_, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n \n fn convert_path_expr<'a, 'tcx>(\n     cx: &mut Cx<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n+    expr: &'tcx hir::Expr<'tcx>,\n     res: Res,\n ) -> ExprKind<'tcx> {\n     let substs = cx.tables().node_substs(expr.hir_id);\n@@ -771,7 +774,7 @@ fn convert_path_expr<'a, 'tcx>(\n \n fn convert_var(\n     cx: &mut Cx<'_, 'tcx>,\n-    expr: &'tcx hir::Expr,\n+    expr: &'tcx hir::Expr<'tcx>,\n     var_hir_id: hir::HirId,\n ) -> ExprKind<'tcx> {\n     let upvar_index = cx\n@@ -914,7 +917,7 @@ fn bin_op(op: hir::BinOpKind) -> BinOp {\n \n fn overloaded_operator<'a, 'tcx>(\n     cx: &mut Cx<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n+    expr: &'tcx hir::Expr<'tcx>,\n     args: Vec<ExprRef<'tcx>>,\n ) -> ExprKind<'tcx> {\n     let fun = method_callee(cx, expr, expr.span, None);\n@@ -923,7 +926,7 @@ fn overloaded_operator<'a, 'tcx>(\n \n fn overloaded_place<'a, 'tcx>(\n     cx: &mut Cx<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n+    expr: &'tcx hir::Expr<'tcx>,\n     place_ty: Ty<'tcx>,\n     overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n     args: Vec<ExprRef<'tcx>>,\n@@ -963,7 +966,7 @@ fn overloaded_place<'a, 'tcx>(\n \n fn capture_upvar<'tcx>(\n     cx: &mut Cx<'_, 'tcx>,\n-    closure_expr: &'tcx hir::Expr,\n+    closure_expr: &'tcx hir::Expr<'tcx>,\n     var_hir_id: hir::HirId,\n     upvar_ty: Ty<'tcx>,\n ) -> ExprRef<'tcx> {\n@@ -1002,7 +1005,7 @@ fn capture_upvar<'tcx>(\n /// Converts a list of named fields (i.e., for struct-like struct/enum ADTs) into FieldExprRef.\n fn field_refs<'a, 'tcx>(\n     cx: &mut Cx<'a, 'tcx>,\n-    fields: &'tcx [hir::Field],\n+    fields: &'tcx [hir::Field<'tcx>],\n ) -> Vec<FieldExprRef<'tcx>> {\n     fields\n         .iter()"}, {"sha": "5c3baaa6ddcd78dac30ef8635030e941348c8f3f", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -151,7 +151,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         }\n     }\n \n-    pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pat<'tcx> {\n+    pub fn pattern_from_hir(&mut self, p: &hir::Pat<'_>) -> Pat<'tcx> {\n         let p = match self.tcx.hir().get(p.hir_id) {\n             Node::Pat(p) | Node::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node),"}, {"sha": "e40e21e76c3760b46f576db07adfd63b0af13e4e", "filename": "src/librustc_mir/hair/cx/to_ref.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -1,22 +1,21 @@\n use crate::hair::*;\n \n use rustc::hir;\n-use rustc::hir::ptr::P;\n \n pub trait ToRef {\n     type Output;\n     fn to_ref(self) -> Self::Output;\n }\n \n-impl<'tcx> ToRef for &'tcx hir::Expr {\n+impl<'tcx> ToRef for &'tcx hir::Expr<'tcx> {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Hair(self)\n     }\n }\n \n-impl<'tcx> ToRef for &'tcx P<hir::Expr> {\n+impl<'tcx> ToRef for &'tcx &'tcx hir::Expr<'tcx> {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n@@ -54,7 +53,7 @@ where\n     }\n }\n \n-impl<'tcx, T, U> ToRef for &'tcx P<[T]>\n+impl<'tcx, T, U> ToRef for &'tcx [T]\n where\n     &'tcx T: ToRef<Output = U>,\n {"}, {"sha": "8973c19d58f633d3324aa47600c6357014c24af5", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -184,7 +184,7 @@ pub enum ExprKind<'tcx> {\n         arms: Vec<Arm<'tcx>>,\n     },\n     Block {\n-        body: &'tcx hir::Block,\n+        body: &'tcx hir::Block<'tcx>,\n     },\n     Assign {\n         lhs: ExprRef<'tcx>,\n@@ -289,7 +289,7 @@ pub enum ExprKind<'tcx> {\n \n #[derive(Clone, Debug)]\n pub enum ExprRef<'tcx> {\n-    Hair(&'tcx hir::Expr),\n+    Hair(&'tcx hir::Expr<'tcx>),\n     Mirror(Box<Expr<'tcx>>),\n }\n "}, {"sha": "47f2b480850d6adb36b1a05f09f427e34e52a86a", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -53,15 +53,15 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx hir::Expr<'tcx>) {\n         intravisit::walk_expr(self, ex);\n \n         if let hir::ExprKind::Match(ref scrut, ref arms, source) = ex.kind {\n             self.check_match(scrut, arms, source);\n         }\n     }\n \n-    fn visit_local(&mut self, loc: &'tcx hir::Local) {\n+    fn visit_local(&mut self, loc: &'tcx hir::Local<'tcx>) {\n         intravisit::walk_local(self, loc);\n \n         let (msg, sp) = match loc.source {\n@@ -121,15 +121,20 @@ impl PatCtxt<'_, '_> {\n }\n \n impl<'tcx> MatchVisitor<'_, 'tcx> {\n-    fn check_patterns(&mut self, has_guard: bool, pat: &Pat) {\n+    fn check_patterns(&mut self, has_guard: bool, pat: &Pat<'_>) {\n         check_legality_of_move_bindings(self, has_guard, pat);\n         check_borrow_conflicts_in_at_patterns(self, pat);\n         if !self.tcx.features().bindings_after_at {\n             check_legality_of_bindings_in_at_patterns(self, pat);\n         }\n     }\n \n-    fn check_match(&mut self, scrut: &hir::Expr, arms: &'tcx [hir::Arm], source: hir::MatchSource) {\n+    fn check_match(\n+        &mut self,\n+        scrut: &hir::Expr<'_>,\n+        arms: &'tcx [hir::Arm<'tcx>],\n+        source: hir::MatchSource,\n+    ) {\n         for arm in arms {\n             // First, check legality of move bindings.\n             self.check_patterns(arm.guard.is_some(), &arm.pat);\n@@ -178,7 +183,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         })\n     }\n \n-    fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str, sp: Option<Span>) {\n+    fn check_irrefutable(&self, pat: &'tcx Pat<'tcx>, origin: &str, sp: Option<Span>) {\n         let module = self.tcx.hir().get_module_parent(pat.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut patcx =\n@@ -246,7 +251,12 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n \n /// A path pattern was interpreted as a constant, not a new variable.\n /// This caused an irrefutable match failure in e.g. `let`.\n-fn const_not_var(err: &mut DiagnosticBuilder<'_>, tcx: TyCtxt<'_>, pat: &Pat, path: &hir::Path) {\n+fn const_not_var(\n+    err: &mut DiagnosticBuilder<'_>,\n+    tcx: TyCtxt<'_>,\n+    pat: &Pat<'_>,\n+    path: &hir::Path,\n+) {\n     let descr = path.res.descr();\n     err.span_label(\n         pat.span,\n@@ -268,7 +278,7 @@ fn const_not_var(err: &mut DiagnosticBuilder<'_>, tcx: TyCtxt<'_>, pat: &Pat, pa\n     }\n }\n \n-fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n+fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pat<'_>) {\n     pat.walk_always(|p| {\n         if let hir::PatKind::Binding(_, _, ident, None) = p.kind {\n             if let Some(ty::BindByValue(hir::Mutability::Not)) =\n@@ -307,7 +317,7 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n }\n \n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n-fn pat_is_catchall(pat: &Pat) -> bool {\n+fn pat_is_catchall(pat: &Pat<'_>) -> bool {\n     match pat.kind {\n         hir::PatKind::Binding(.., None) => true,\n         hir::PatKind::Binding(.., Some(ref s)) => pat_is_catchall(s),\n@@ -320,7 +330,7 @@ fn pat_is_catchall(pat: &Pat) -> bool {\n /// Check for unreachable patterns.\n fn check_arms<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n-    arms: &[(&'p super::Pat<'tcx>, &hir::Pat, bool)],\n+    arms: &[(&'p super::Pat<'tcx>, &hir::Pat<'_>, bool)],\n     source: hir::MatchSource,\n ) -> Matrix<'p, 'tcx> {\n     let mut seen = Matrix::empty();\n@@ -575,7 +585,7 @@ fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[super::Pat<'_>]) -> Vec<Span>\n }\n \n /// Check the legality of legality of by-move bindings.\n-fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: bool, pat: &Pat) {\n+fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: bool, pat: &Pat<'_>) {\n     let sess = cx.tcx.sess;\n     let tables = cx.tables;\n \n@@ -589,7 +599,7 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n \n     // Find bad by-move spans:\n     let by_move_spans = &mut Vec::new();\n-    let mut check_move = |p: &Pat, sub: Option<&Pat>| {\n+    let mut check_move = |p: &Pat<'_>, sub: Option<&Pat<'_>>| {\n         // Check legality of moving out of the enum.\n         //\n         // `x @ Foo(..)` is legal, but `x @ Foo(y)` isn't.\n@@ -638,7 +648,7 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n /// - `ref mut x @ Some(ref mut y)`.\n ///\n /// This analysis is *not* subsumed by NLL.\n-fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n+fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat<'_>) {\n     let tab = cx.tables;\n     let sess = cx.tcx.sess;\n     // Get the mutability of `p` if it's by-ref.\n@@ -709,7 +719,7 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n \n /// Forbids bindings in `@` patterns. This used to be is necessary for memory safety,\n /// because of the way rvalues were handled in the borrow check. (See issue #14587.)\n-fn check_legality_of_bindings_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n+fn check_legality_of_bindings_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat<'_>) {\n     AtBindingPatternVisitor { cx, bindings_allowed: true }.visit_pat(pat);\n \n     struct AtBindingPatternVisitor<'a, 'b, 'tcx> {\n@@ -722,7 +732,7 @@ fn check_legality_of_bindings_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pa\n             NestedVisitorMap::None\n         }\n \n-        fn visit_pat(&mut self, pat: &Pat) {\n+        fn visit_pat(&mut self, pat: &Pat<'_>) {\n             match pat.kind {\n                 hir::PatKind::Binding(.., ref subpat) => {\n                     if !self.bindings_allowed {"}, {"sha": "bf0de7e9ef0b15512a3cd64a3235418208f07a00", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -11,7 +11,6 @@ use crate::hair::util::UserAnnotatedTyHelpers;\n \n use rustc::hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n-use rustc::hir::ptr::P;\n use rustc::hir::{self, RangeEnd};\n use rustc::mir::interpret::{get_slice_bytes, sign_extend, ConstValue, ErrorHandled};\n use rustc::mir::UserTypeProjection;\n@@ -356,7 +355,7 @@ impl<'a, 'tcx> Pat<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n         tables: &'a ty::TypeckTables<'tcx>,\n-        pat: &'tcx hir::Pat,\n+        pat: &'tcx hir::Pat<'tcx>,\n     ) -> Self {\n         let mut pcx = PatCtxt::new(tcx, param_env_and_substs, tables);\n         let result = pcx.lower_pattern(pat);\n@@ -390,7 +389,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         self\n     }\n \n-    pub fn lower_pattern(&mut self, pat: &'tcx hir::Pat) -> Pat<'tcx> {\n+    pub fn lower_pattern(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n         // When implicit dereferences have been inserted in this pattern, the unadjusted lowered\n         // pattern has the type that results *after* dereferencing. For example, in this code:\n         //\n@@ -426,7 +425,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n     fn lower_range_expr(\n         &mut self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> (PatKind<'tcx>, Option<Ascription<'tcx>>) {\n         match self.lower_lit(expr) {\n             PatKind::AscribeUserType {\n@@ -437,7 +436,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat) -> Pat<'tcx> {\n+    fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n         let mut ty = self.tables.node_type(pat.hir_id);\n \n         if let ty::Error = ty.kind {\n@@ -616,7 +615,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n     fn lower_tuple_subpats(\n         &mut self,\n-        pats: &'tcx [P<hir::Pat>],\n+        pats: &'tcx [&'tcx hir::Pat<'tcx>],\n         expected_len: usize,\n         gap_pos: Option<usize>,\n     ) -> Vec<FieldPat<'tcx>> {\n@@ -629,21 +628,21 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n-    fn lower_patterns(&mut self, pats: &'tcx [P<hir::Pat>]) -> Vec<Pat<'tcx>> {\n+    fn lower_patterns(&mut self, pats: &'tcx [&'tcx hir::Pat<'tcx>]) -> Vec<Pat<'tcx>> {\n         pats.iter().map(|p| self.lower_pattern(p)).collect()\n     }\n \n-    fn lower_opt_pattern(&mut self, pat: &'tcx Option<P<hir::Pat>>) -> Option<Pat<'tcx>> {\n+    fn lower_opt_pattern(&mut self, pat: &'tcx Option<&'tcx hir::Pat<'tcx>>) -> Option<Pat<'tcx>> {\n         pat.as_ref().map(|p| self.lower_pattern(p))\n     }\n \n     fn slice_or_array_pattern(\n         &mut self,\n         span: Span,\n         ty: Ty<'tcx>,\n-        prefix: &'tcx [P<hir::Pat>],\n-        slice: &'tcx Option<P<hir::Pat>>,\n-        suffix: &'tcx [P<hir::Pat>],\n+        prefix: &'tcx [&'tcx hir::Pat<'tcx>],\n+        slice: &'tcx Option<&'tcx hir::Pat<'tcx>>,\n+        suffix: &'tcx [&'tcx hir::Pat<'tcx>],\n     ) -> PatKind<'tcx> {\n         let prefix = self.lower_patterns(prefix);\n         let slice = self.lower_opt_pattern(slice);\n@@ -795,7 +794,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     /// The special case for negation exists to allow things like `-128_i8`\n     /// which would overflow if we tried to evaluate `128_i8` and then negate\n     /// afterwards.\n-    fn lower_lit(&mut self, expr: &'tcx hir::Expr) -> PatKind<'tcx> {\n+    fn lower_lit(&mut self, expr: &'tcx hir::Expr<'tcx>) -> PatKind<'tcx> {\n         match expr.kind {\n             hir::ExprKind::Lit(ref lit) => {\n                 let ty = self.tables.expr_ty(expr);"}, {"sha": "8b8f1b6f670ef69def9222cb478cec0c02b7d2b1", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -479,7 +479,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'a> {\n         hir::intravisit::NestedVisitorMap::None\n     }\n \n-    fn visit_block(&mut self, block: &'tcx hir::Block) {\n+    fn visit_block(&mut self, block: &'tcx hir::Block<'tcx>) {\n         hir::intravisit::walk_block(self, block);\n \n         if let hir::UnsafeBlock(hir::UserProvided) = block.rules {"}, {"sha": "fbfe2135012959e9975ccbd3b481007711a9dc09", "filename": "src/librustc_passes/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_passes%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_passes%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_const.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -214,7 +214,7 @@ impl<'tcx> Visitor<'tcx> for CheckConstVisitor<'tcx> {\n         self.recurse_into(kind, |this| hir::intravisit::walk_body(this, body));\n     }\n \n-    fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n+    fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n         if self.const_kind.is_some() {\n             if let hir::PatKind::Or { .. } = p.kind {\n                 self.const_check_violated(NonConstExpr::OrPattern, p.span);\n@@ -223,7 +223,7 @@ impl<'tcx> Visitor<'tcx> for CheckConstVisitor<'tcx> {\n         hir::intravisit::walk_pat(self, p)\n     }\n \n-    fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n         match &e.kind {\n             // Skip the following checks if we are not currently in a const context.\n             _ if self.const_kind.is_none() => {}"}, {"sha": "a13c9aff70a229e9ae622370d5185d977ccca8e2", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -115,7 +115,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn handle_field_access(&mut self, lhs: &hir::Expr, hir_id: hir::HirId) {\n+    fn handle_field_access(&mut self, lhs: &hir::Expr<'_>, hir_id: hir::HirId) {\n         match self.tables.expr_ty_adjusted(lhs).kind {\n             ty::Adt(def, _) => {\n                 let index = self.tcx.field_index(hir_id, self.tables);\n@@ -126,7 +126,12 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, res: Res, pats: &[hir::FieldPat]) {\n+    fn handle_field_pattern_match(\n+        &mut self,\n+        lhs: &hir::Pat<'_>,\n+        res: Res,\n+        pats: &[hir::FieldPat<'_>],\n+    ) {\n         let variant = match self.tables.node_type(lhs.hir_id).kind {\n             ty::Adt(adt, _) => adt.variant_of_res(res),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\"),\n@@ -197,7 +202,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         self.inherited_pub_visibility = had_inherited_pub_visibility;\n     }\n \n-    fn mark_as_used_if_union(&mut self, adt: &ty::AdtDef, fields: &hir::HirVec<hir::Field>) {\n+    fn mark_as_used_if_union(&mut self, adt: &ty::AdtDef, fields: &[hir::Field<'_>]) {\n         if adt.is_union() && adt.non_enum_variant().fields.len() > 1 && adt.did.is_local() {\n             for field in fields {\n                 let index = self.tcx.field_index(field.hir_id, self.tables);\n@@ -239,7 +244,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         intravisit::walk_struct_def(self, def);\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         match expr.kind {\n             hir::ExprKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n                 let res = self.tables.qpath_res(qpath, expr.hir_id);\n@@ -262,7 +267,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n-    fn visit_arm(&mut self, arm: &'tcx hir::Arm) {\n+    fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n         // Inside the body, ignore constructions of variants\n         // necessary for the pattern to match. Those construction sites\n         // can't be reached unless the variant is constructed elsewhere.\n@@ -272,7 +277,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         self.ignore_variant_stack.truncate(len);\n     }\n \n-    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n         match pat.kind {\n             PatKind::Struct(ref path, ref fields, _) => {\n                 let res = self.tables.qpath_res(path, pat.hir_id);"}, {"sha": "5ec1d458a96dbb0ed554c93e7dd422445e4ad85a", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -86,7 +86,7 @@ impl<'k> StatCollector<'k> {\n }\n \n impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n-    fn visit_param(&mut self, param: &'v hir::Param) {\n+    fn visit_param(&mut self, param: &'v hir::Param<'v>) {\n         self.record(\"Param\", Id::Node(param.hir_id), param);\n         hir_visit::walk_param(self, param)\n     }\n@@ -130,32 +130,32 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_foreign_item(self, i)\n     }\n \n-    fn visit_local(&mut self, l: &'v hir::Local) {\n+    fn visit_local(&mut self, l: &'v hir::Local<'v>) {\n         self.record(\"Local\", Id::Node(l.hir_id), l);\n         hir_visit::walk_local(self, l)\n     }\n \n-    fn visit_block(&mut self, b: &'v hir::Block) {\n+    fn visit_block(&mut self, b: &'v hir::Block<'v>) {\n         self.record(\"Block\", Id::Node(b.hir_id), b);\n         hir_visit::walk_block(self, b)\n     }\n \n-    fn visit_stmt(&mut self, s: &'v hir::Stmt) {\n+    fn visit_stmt(&mut self, s: &'v hir::Stmt<'v>) {\n         self.record(\"Stmt\", Id::Node(s.hir_id), s);\n         hir_visit::walk_stmt(self, s)\n     }\n \n-    fn visit_arm(&mut self, a: &'v hir::Arm) {\n+    fn visit_arm(&mut self, a: &'v hir::Arm<'v>) {\n         self.record(\"Arm\", Id::Node(a.hir_id), a);\n         hir_visit::walk_arm(self, a)\n     }\n \n-    fn visit_pat(&mut self, p: &'v hir::Pat) {\n+    fn visit_pat(&mut self, p: &'v hir::Pat<'v>) {\n         self.record(\"Pat\", Id::Node(p.hir_id), p);\n         hir_visit::walk_pat(self, p)\n     }\n \n-    fn visit_expr(&mut self, ex: &'v hir::Expr) {\n+    fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n         self.record(\"Expr\", Id::Node(ex.hir_id), ex);\n         hir_visit::walk_expr(self, ex)\n     }"}, {"sha": "92903e95a0dc4ed6aee90f7770ad004819567a43", "filename": "src/librustc_passes/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_passes%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_passes%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fintrinsicck.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -142,7 +142,7 @@ impl Visitor<'tcx> for ExprVisitor<'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         let res = if let hir::ExprKind::Path(ref qpath) = expr.kind {\n             self.tables.qpath_res(qpath, expr.hir_id)\n         } else {"}, {"sha": "ea4479ef5ce7c67916cd6b53ce5751a9eb0602d8", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -100,7 +100,6 @@ use rustc::hir;\n use rustc::hir::def::*;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, FnKind, NestedVisitorMap, Visitor};\n-use rustc::hir::ptr::P;\n use rustc::hir::Node;\n use rustc::hir::{Expr, HirId};\n use rustc::lint;\n@@ -171,13 +170,13 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n         visit_fn(self, fk, fd, b, s, id);\n     }\n \n-    fn visit_local(&mut self, l: &'tcx hir::Local) {\n+    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n         visit_local(self, l);\n     }\n-    fn visit_expr(&mut self, ex: &'tcx Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n         visit_expr(self, ex);\n     }\n-    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n         visit_arm(self, a);\n     }\n }\n@@ -406,7 +405,7 @@ fn visit_fn<'tcx>(\n     lsets.warn_about_unused_args(body, entry_ln);\n }\n \n-fn add_from_pat(ir: &mut IrMaps<'_>, pat: &P<hir::Pat>) {\n+fn add_from_pat(ir: &mut IrMaps<'_>, pat: &hir::Pat<'_>) {\n     // For struct patterns, take note of which fields used shorthand\n     // (`x` rather than `x: x`).\n     let mut shorthand_field_ids = HirIdSet::default();\n@@ -447,17 +446,17 @@ fn add_from_pat(ir: &mut IrMaps<'_>, pat: &P<hir::Pat>) {\n     });\n }\n \n-fn visit_local<'tcx>(ir: &mut IrMaps<'tcx>, local: &'tcx hir::Local) {\n+fn visit_local<'tcx>(ir: &mut IrMaps<'tcx>, local: &'tcx hir::Local<'tcx>) {\n     add_from_pat(ir, &local.pat);\n     intravisit::walk_local(ir, local);\n }\n \n-fn visit_arm<'tcx>(ir: &mut IrMaps<'tcx>, arm: &'tcx hir::Arm) {\n+fn visit_arm<'tcx>(ir: &mut IrMaps<'tcx>, arm: &'tcx hir::Arm<'tcx>) {\n     add_from_pat(ir, &arm.pat);\n     intravisit::walk_arm(ir, arm);\n }\n \n-fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr) {\n+fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr<'tcx>) {\n     match expr.kind {\n         // live nodes required for uses or definitions of variables:\n         hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n@@ -714,7 +713,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.ir.variable(hir_id, span)\n     }\n \n-    fn define_bindings_in_pat(&mut self, pat: &hir::Pat, mut succ: LiveNode) -> LiveNode {\n+    fn define_bindings_in_pat(&mut self, pat: &hir::Pat<'_>, mut succ: LiveNode) -> LiveNode {\n         // In an or-pattern, only consider the first pattern; any later patterns\n         // must have the same bindings, and we also consider the first pattern\n         // to be the \"authoritative\" set of ids.\n@@ -891,7 +890,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.rwu_table.assign_unpacked(idx, rwu);\n     }\n \n-    fn compute(&mut self, body: &hir::Expr) -> LiveNode {\n+    fn compute(&mut self, body: &hir::Expr<'_>) -> LiveNode {\n         debug!(\n             \"compute: using id for body, {}\",\n             self.ir.tcx.hir().hir_to_pretty_string(body.hir_id)\n@@ -920,15 +919,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         entry_ln\n     }\n \n-    fn propagate_through_block(&mut self, blk: &hir::Block, succ: LiveNode) -> LiveNode {\n+    fn propagate_through_block(&mut self, blk: &hir::Block<'_>, succ: LiveNode) -> LiveNode {\n         if blk.targeted_by_break {\n             self.break_ln.insert(blk.hir_id, succ);\n         }\n         let succ = self.propagate_through_opt_expr(blk.expr.as_ref().map(|e| &**e), succ);\n         blk.stmts.iter().rev().fold(succ, |succ, stmt| self.propagate_through_stmt(stmt, succ))\n     }\n \n-    fn propagate_through_stmt(&mut self, stmt: &hir::Stmt, succ: LiveNode) -> LiveNode {\n+    fn propagate_through_stmt(&mut self, stmt: &hir::Stmt<'_>, succ: LiveNode) -> LiveNode {\n         match stmt.kind {\n             hir::StmtKind::Local(ref local) => {\n                 // Note: we mark the variable as defined regardless of whether\n@@ -955,15 +954,19 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn propagate_through_exprs(&mut self, exprs: &[Expr], succ: LiveNode) -> LiveNode {\n+    fn propagate_through_exprs(&mut self, exprs: &[Expr<'_>], succ: LiveNode) -> LiveNode {\n         exprs.iter().rev().fold(succ, |succ, expr| self.propagate_through_expr(&expr, succ))\n     }\n \n-    fn propagate_through_opt_expr(&mut self, opt_expr: Option<&Expr>, succ: LiveNode) -> LiveNode {\n+    fn propagate_through_opt_expr(\n+        &mut self,\n+        opt_expr: Option<&Expr<'_>>,\n+        succ: LiveNode,\n+    ) -> LiveNode {\n         opt_expr.map_or(succ, |expr| self.propagate_through_expr(expr, succ))\n     }\n \n-    fn propagate_through_expr(&mut self, expr: &Expr, succ: LiveNode) -> LiveNode {\n+    fn propagate_through_expr(&mut self, expr: &Expr<'_>, succ: LiveNode) -> LiveNode {\n         debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir().hir_to_pretty_string(expr.hir_id));\n \n         match expr.kind {\n@@ -1001,7 +1004,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             // at the label ident\n             hir::ExprKind::Loop(ref blk, _, _) => self.propagate_through_loop(expr, &blk, succ),\n \n-            hir::ExprKind::Match(ref e, ref arms, _) => {\n+            hir::ExprKind::Match(ref e, arms, _) => {\n                 //\n                 //      (e)\n                 //       |\n@@ -1023,7 +1026,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     let body_succ = self.propagate_through_expr(&arm.body, succ);\n \n                     let guard_succ = self.propagate_through_opt_expr(\n-                        arm.guard.as_ref().map(|hir::Guard::If(e)| &**e),\n+                        arm.guard.as_ref().map(|hir::Guard::If(e)| *e),\n                         body_succ,\n                     );\n                     let arm_succ = self.define_bindings_in_pat(&arm.pat, guard_succ);\n@@ -1162,8 +1165,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::InlineAsm(ref asm) => {\n                 let ia = &asm.inner;\n-                let outputs = &asm.outputs_exprs;\n-                let inputs = &asm.inputs_exprs;\n+                let outputs = asm.outputs_exprs;\n+                let inputs = asm.inputs_exprs;\n                 let succ = ia.outputs.iter().zip(outputs).rev().fold(succ, |succ, (o, output)| {\n                     // see comment on places\n                     // in propagate_through_place_components()\n@@ -1190,7 +1193,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn propagate_through_place_components(&mut self, expr: &Expr, succ: LiveNode) -> LiveNode {\n+    fn propagate_through_place_components(&mut self, expr: &Expr<'_>, succ: LiveNode) -> LiveNode {\n         // # Places\n         //\n         // In general, the full flow graph structure for an\n@@ -1248,7 +1251,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     // see comment on propagate_through_place()\n-    fn write_place(&mut self, expr: &Expr, succ: LiveNode, acc: u32) -> LiveNode {\n+    fn write_place(&mut self, expr: &Expr<'_>, succ: LiveNode, acc: u32) -> LiveNode {\n         match expr.kind {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 self.access_path(expr.hir_id, path, succ, acc)\n@@ -1301,8 +1304,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn propagate_through_loop(\n         &mut self,\n-        expr: &Expr,\n-        body: &hir::Block,\n+        expr: &Expr<'_>,\n+        body: &hir::Block<'_>,\n         succ: LiveNode,\n     ) -> LiveNode {\n         /*\n@@ -1351,7 +1354,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_local(&mut self, local: &'tcx hir::Local) {\n+    fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n         self.check_unused_vars_in_pat(&local.pat, None, |spans, hir_id, ln, var| {\n             if local.init.is_some() {\n                 self.warn_about_dead_assign(spans, hir_id, ln, var);\n@@ -1361,17 +1364,17 @@ impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n         intravisit::walk_local(self, local);\n     }\n \n-    fn visit_expr(&mut self, ex: &'tcx Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n         check_expr(self, ex);\n     }\n \n-    fn visit_arm(&mut self, arm: &'tcx hir::Arm) {\n+    fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n         self.check_unused_vars_in_pat(&arm.pat, None, |_, _, _, _| {});\n         intravisit::walk_arm(self, arm);\n     }\n }\n \n-fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr) {\n+fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr<'tcx>) {\n     match expr.kind {\n         hir::ExprKind::Assign(ref l, ..) => {\n             this.check_place(&l);\n@@ -1384,12 +1387,12 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr) {\n         }\n \n         hir::ExprKind::InlineAsm(ref asm) => {\n-            for input in &asm.inputs_exprs {\n+            for input in asm.inputs_exprs {\n                 this.visit_expr(input);\n             }\n \n             // Output operands must be places\n-            for (o, output) in asm.inner.outputs.iter().zip(&asm.outputs_exprs) {\n+            for (o, output) in asm.inner.outputs.iter().zip(asm.outputs_exprs) {\n                 if !o.is_indirect {\n                     this.check_place(output);\n                 }\n@@ -1430,7 +1433,7 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr) {\n }\n \n impl<'tcx> Liveness<'_, 'tcx> {\n-    fn check_place(&mut self, expr: &'tcx Expr) {\n+    fn check_place(&mut self, expr: &'tcx Expr<'tcx>) {\n         match expr.kind {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 if let Res::Local(var_hid) = path.res {\n@@ -1471,7 +1474,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n \n     fn check_unused_vars_in_pat(\n         &self,\n-        pat: &hir::Pat,\n+        pat: &hir::Pat<'_>,\n         entry_ln: Option<LiveNode>,\n         on_used_on_entry: impl Fn(Vec<Span>, HirId, LiveNode, Variable),\n     ) {"}, {"sha": "463e6899c4f743f4ab2ab5ec820c95fd420f000d", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n         self.with_context(AnonConst, |v| intravisit::walk_anon_const(v, c));\n     }\n \n-    fn visit_expr(&mut self, e: &'hir hir::Expr) {\n+    fn visit_expr(&mut self, e: &'hir hir::Expr<'hir>) {\n         match e.kind {\n             hir::ExprKind::Loop(ref b, _, source) => {\n                 self.with_context(Loop(source), |v| v.visit_block(&b));"}, {"sha": "a72b3b74cbbe400b45549f86482e8df8ce04769b", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -883,7 +883,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         self.prev_level = orig_level;\n     }\n \n-    fn visit_block(&mut self, b: &'tcx hir::Block) {\n+    fn visit_block(&mut self, b: &'tcx hir::Block<'tcx>) {\n         // Blocks can have public items, for example impls, but they always\n         // start as completely private regardless of publicity of a function,\n         // constant, type, field, etc., in which this block resides.\n@@ -1080,9 +1080,9 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n         self.tables = orig_tables;\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         match expr.kind {\n-            hir::ExprKind::Struct(ref qpath, ref fields, ref base) => {\n+            hir::ExprKind::Struct(ref qpath, fields, ref base) => {\n                 let res = self.tables.qpath_res(qpath, expr.hir_id);\n                 let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_res(res);\n@@ -1114,9 +1114,9 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n-    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n         match pat.kind {\n-            PatKind::Struct(ref qpath, ref fields, _) => {\n+            PatKind::Struct(ref qpath, fields, _) => {\n                 let res = self.tables.qpath_res(qpath, pat.hir_id);\n                 let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_res(res);\n@@ -1245,7 +1245,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     }\n \n     // Check types of expressions\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         if self.check_expr_pat_type(expr.hir_id, expr.span) {\n             // Do not check nested expressions if the error already happened.\n             return;\n@@ -1313,7 +1313,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     }\n \n     // Check types of patterns.\n-    fn visit_pat(&mut self, pattern: &'tcx hir::Pat) {\n+    fn visit_pat(&mut self, pattern: &'tcx hir::Pat<'tcx>) {\n         if self.check_expr_pat_type(pattern.hir_id, pattern.span) {\n             // Do not check nested patterns if the error already happened.\n             return;\n@@ -1322,7 +1322,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_pat(self, pattern);\n     }\n \n-    fn visit_local(&mut self, local: &'tcx hir::Local) {\n+    fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n         if let Some(ref init) = local.init {\n             if self.check_expr_pat_type(init.hir_id, init.span) {\n                 // Do not report duplicate errors for `let x = y`.\n@@ -1459,7 +1459,7 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a\n     }\n \n     // Don't want to recurse into `[, .. expr]`.\n-    fn visit_expr(&mut self, _: &hir::Expr) {}\n+    fn visit_expr(&mut self, _: &hir::Expr<'_>) {}\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n@@ -1708,8 +1708,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     // expression/block context can't possibly contain exported things.\n     // (Making them no-ops stops us from traversing the whole AST without\n     // having to be super careful about our `walk_...` calls above.)\n-    fn visit_block(&mut self, _: &'tcx hir::Block) {}\n-    fn visit_expr(&mut self, _: &'tcx hir::Expr) {}\n+    fn visit_block(&mut self, _: &'tcx hir::Block<'tcx>) {}\n+    fn visit_expr(&mut self, _: &'tcx hir::Expr<'tcx>) {}\n }\n \n ///////////////////////////////////////////////////////////////////////////////"}, {"sha": "8e0f5d17b9fb8652c2d13dbdc968c6f84c60d599", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -2648,7 +2648,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     }\n \n     /// Returns the `DefId` of the constant parameter that the provided expression is a path to.\n-    pub fn const_param_def_id(&self, expr: &hir::Expr) -> Option<DefId> {\n+    pub fn const_param_def_id(&self, expr: &hir::Expr<'_>) -> Option<DefId> {\n         // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n         // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n         let expr = match &expr.kind {"}, {"sha": "0d7ddd0fc48197b02334e9c9ea52e369271493f8", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -10,9 +10,9 @@ use syntax_pos::Span;\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_match(\n         &self,\n-        expr: &'tcx hir::Expr,\n-        discrim: &'tcx hir::Expr,\n-        arms: &'tcx [hir::Arm],\n+        expr: &'tcx hir::Expr<'tcx>,\n+        discrim: &'tcx hir::Expr<'tcx>,\n+        arms: &'tcx [hir::Arm<'tcx>],\n         expected: Expectation<'tcx>,\n         match_src: hir::MatchSource,\n     ) -> Ty<'tcx> {\n@@ -194,7 +194,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// When the previously checked expression (the scrutinee) diverges,\n     /// warn the user about the match arms being unreachable.\n-    fn warn_arms_when_scrutinee_diverges(&self, arms: &'tcx [hir::Arm], source: hir::MatchSource) {\n+    fn warn_arms_when_scrutinee_diverges(\n+        &self,\n+        arms: &'tcx [hir::Arm<'tcx>],\n+        source: hir::MatchSource,\n+    ) {\n         if self.diverges.get().is_always() {\n             use hir::MatchSource::*;\n             let msg = match source {\n@@ -214,8 +218,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn if_fallback_coercion(\n         &self,\n         span: Span,\n-        then_expr: &'tcx hir::Expr,\n-        coercion: &mut CoerceMany<'tcx, '_, rustc::hir::Arm>,\n+        then_expr: &'tcx hir::Expr<'tcx>,\n+        coercion: &mut CoerceMany<'tcx, '_, rustc::hir::Arm<'tcx>>,\n     ) -> bool {\n         // If this `if` expr is the parent's function return expr,\n         // the cause of the type coercion is the return type, point at it. (#25228)\n@@ -277,8 +281,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn if_cause(\n         &self,\n         span: Span,\n-        then_expr: &'tcx hir::Expr,\n-        else_expr: &'tcx hir::Expr,\n+        then_expr: &'tcx hir::Expr<'tcx>,\n+        else_expr: &'tcx hir::Expr<'tcx>,\n         then_ty: Ty<'tcx>,\n         else_ty: Ty<'tcx>,\n     ) -> ObligationCause<'tcx> {\n@@ -386,8 +390,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn demand_discriminant_type(\n         &self,\n-        arms: &'tcx [hir::Arm],\n-        discrim: &'tcx hir::Expr,\n+        arms: &'tcx [hir::Arm<'tcx>],\n+        discrim: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         // Not entirely obvious: if matches may create ref bindings, we want to\n         // use the *precise* type of the discriminant, *not* some supertype, as"}, {"sha": "116f5ffc2513d3725442b76cc991c4893d6bb64b", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -39,9 +39,9 @@ enum CallStep<'tcx> {\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_call(\n         &self,\n-        call_expr: &'tcx hir::Expr,\n-        callee_expr: &'tcx hir::Expr,\n-        arg_exprs: &'tcx [hir::Expr],\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        callee_expr: &'tcx hir::Expr<'tcx>,\n+        arg_exprs: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         let original_callee_ty = self.check_expr(callee_expr);\n@@ -81,9 +81,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn try_overloaded_call_step(\n         &self,\n-        call_expr: &'tcx hir::Expr,\n-        callee_expr: &'tcx hir::Expr,\n-        arg_exprs: &'tcx [hir::Expr],\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        callee_expr: &'tcx hir::Expr<'tcx>,\n+        arg_exprs: &'tcx [hir::Expr<'tcx>],\n         autoderef: &Autoderef<'a, 'tcx>,\n     ) -> Option<CallStep<'tcx>> {\n         let adjusted_ty = autoderef.unambiguous_final_ty(self);\n@@ -166,9 +166,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn try_overloaded_call_traits(\n         &self,\n-        call_expr: &hir::Expr,\n+        call_expr: &hir::Expr<'_>,\n         adjusted_ty: Ty<'tcx>,\n-        opt_arg_exprs: Option<&'tcx [hir::Expr]>,\n+        opt_arg_exprs: Option<&'tcx [hir::Expr<'tcx>]>,\n     ) -> Option<(Option<Adjustment<'tcx>>, MethodCallee<'tcx>)> {\n         // Try the options that are least restrictive on the caller first.\n         for &(opt_trait_def_id, method_name, borrow) in &[\n@@ -230,7 +230,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         err: &mut DiagnosticBuilder<'a>,\n         hir_id: hir::HirId,\n-        callee_node: &hir::ExprKind,\n+        callee_node: &hir::ExprKind<'_>,\n         callee_span: Span,\n     ) {\n         let hir_id = self.tcx.hir().get_parent_node(hir_id);\n@@ -253,9 +253,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn confirm_builtin_call(\n         &self,\n-        call_expr: &'tcx hir::Expr,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n         callee_ty: Ty<'tcx>,\n-        arg_exprs: &'tcx [hir::Expr],\n+        arg_exprs: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         let (fn_sig, def_span) = match callee_ty.kind {\n@@ -403,8 +403,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn confirm_deferred_closure_call(\n         &self,\n-        call_expr: &'tcx hir::Expr,\n-        arg_exprs: &'tcx [hir::Expr],\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        arg_exprs: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n         fn_sig: ty::FnSig<'tcx>,\n     ) -> Ty<'tcx> {\n@@ -436,8 +436,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn confirm_overloaded_call(\n         &self,\n-        call_expr: &'tcx hir::Expr,\n-        arg_exprs: &'tcx [hir::Expr],\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        arg_exprs: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n         method_callee: MethodCallee<'tcx>,\n     ) -> Ty<'tcx> {\n@@ -457,8 +457,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n #[derive(Debug)]\n pub struct DeferredCallResolution<'tcx> {\n-    call_expr: &'tcx hir::Expr,\n-    callee_expr: &'tcx hir::Expr,\n+    call_expr: &'tcx hir::Expr<'tcx>,\n+    callee_expr: &'tcx hir::Expr<'tcx>,\n     adjusted_ty: Ty<'tcx>,\n     adjustments: Vec<Adjustment<'tcx>>,\n     fn_sig: ty::FnSig<'tcx>,"}, {"sha": "f82bb1a751ff836116e9474ec89e64dc2228385b", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -51,7 +51,7 @@ use rustc_error_codes::*;\n /// Reifies a cast check to be checked once we have full type information for\n /// a function context.\n pub struct CastCheck<'tcx> {\n-    expr: &'tcx hir::Expr,\n+    expr: &'tcx hir::Expr<'tcx>,\n     expr_ty: Ty<'tcx>,\n     cast_ty: Ty<'tcx>,\n     cast_span: Span,\n@@ -193,7 +193,7 @@ fn make_invalid_casting_error<'a, 'tcx>(\n impl<'a, 'tcx> CastCheck<'tcx> {\n     pub fn new(\n         fcx: &FnCtxt<'a, 'tcx>,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expr_ty: Ty<'tcx>,\n         cast_ty: Ty<'tcx>,\n         cast_span: Span,"}, {"sha": "feb904ee71caed2323226753044fa5164107a0a0", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -35,7 +35,7 @@ struct ClosureSignatures<'tcx> {\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_expr_closure(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         _capture: hir::CaptureBy,\n         decl: &'tcx hir::FnDecl,\n         body_id: hir::BodyId,\n@@ -57,7 +57,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_closure(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         opt_kind: Option<ty::ClosureKind>,\n         decl: &'tcx hir::FnDecl,\n         body: &'tcx hir::Body<'tcx>,"}, {"sha": "1df6a495343a30641ddcdc09b178af17d292d23d", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -805,7 +805,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// The expressions *must not* have any pre-existing adjustments.\n     pub fn try_coerce(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expr_ty: Ty<'tcx>,\n         target: Ty<'tcx>,\n         allow_two_phase: AllowTwoPhase,\n@@ -844,7 +844,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         cause: &ObligationCause<'tcx>,\n         exprs: &[E],\n         prev_ty: Ty<'tcx>,\n-        new: &hir::Expr,\n+        new: &hir::Expr<'_>,\n         new_ty: Ty<'tcx>,\n     ) -> RelateResult<'tcx, Ty<'tcx>>\n     where\n@@ -1020,10 +1020,10 @@ pub struct CoerceMany<'tcx, 'exprs, E: AsCoercionSite> {\n \n /// The type of a `CoerceMany` that is storing up the expressions into\n /// a buffer. We use this in `check/mod.rs` for things like `break`.\n-pub type DynamicCoerceMany<'tcx> = CoerceMany<'tcx, 'tcx, P<hir::Expr>>;\n+pub type DynamicCoerceMany<'tcx> = CoerceMany<'tcx, 'tcx, &'tcx hir::Expr<'tcx>>;\n \n enum Expressions<'tcx, 'exprs, E: AsCoercionSite> {\n-    Dynamic(Vec<&'tcx hir::Expr>),\n+    Dynamic(Vec<&'tcx hir::Expr<'tcx>>),\n     UpFront(&'exprs [E]),\n }\n \n@@ -1077,7 +1077,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         &mut self,\n         fcx: &FnCtxt<'a, 'tcx>,\n         cause: &ObligationCause<'tcx>,\n-        expression: &'tcx hir::Expr,\n+        expression: &'tcx hir::Expr<'tcx>,\n         expression_ty: Ty<'tcx>,\n     ) {\n         self.coerce_inner(fcx, cause, Some(expression), expression_ty, None, false)\n@@ -1119,7 +1119,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         &mut self,\n         fcx: &FnCtxt<'a, 'tcx>,\n         cause: &ObligationCause<'tcx>,\n-        expression: Option<&'tcx hir::Expr>,\n+        expression: Option<&'tcx hir::Expr<'tcx>>,\n         mut expression_ty: Ty<'tcx>,\n         augment_error: Option<&mut dyn FnMut(&mut DiagnosticBuilder<'_>)>,\n         label_expression_as_expected: bool,\n@@ -1298,7 +1298,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         ty_err: TypeError<'tcx>,\n         fcx: &FnCtxt<'a, 'tcx>,\n         id: hir::HirId,\n-        expression: Option<(&'tcx hir::Expr, hir::HirId)>,\n+        expression: Option<(&'tcx hir::Expr<'tcx>, hir::HirId)>,\n     ) -> DiagnosticBuilder<'a> {\n         let mut err = fcx.report_mismatched_types(cause, expected, found, ty_err);\n \n@@ -1368,17 +1368,17 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n /// Something that can be converted into an expression to which we can\n /// apply a coercion.\n pub trait AsCoercionSite {\n-    fn as_coercion_site(&self) -> &hir::Expr;\n+    fn as_coercion_site(&self) -> &hir::Expr<'_>;\n }\n \n-impl AsCoercionSite for hir::Expr {\n-    fn as_coercion_site(&self) -> &hir::Expr {\n+impl AsCoercionSite for hir::Expr<'_> {\n+    fn as_coercion_site(&self) -> &hir::Expr<'_> {\n         self\n     }\n }\n \n-impl AsCoercionSite for P<hir::Expr> {\n-    fn as_coercion_site(&self) -> &hir::Expr {\n+impl AsCoercionSite for P<hir::Expr<'_>> {\n+    fn as_coercion_site(&self) -> &hir::Expr<'_> {\n         self\n     }\n }\n@@ -1387,19 +1387,19 @@ impl<'a, T> AsCoercionSite for &'a T\n where\n     T: AsCoercionSite,\n {\n-    fn as_coercion_site(&self) -> &hir::Expr {\n+    fn as_coercion_site(&self) -> &hir::Expr<'_> {\n         (**self).as_coercion_site()\n     }\n }\n \n impl AsCoercionSite for ! {\n-    fn as_coercion_site(&self) -> &hir::Expr {\n+    fn as_coercion_site(&self) -> &hir::Expr<'_> {\n         unreachable!()\n     }\n }\n \n-impl AsCoercionSite for hir::Arm {\n-    fn as_coercion_site(&self) -> &hir::Expr {\n+impl AsCoercionSite for hir::Arm<'_> {\n+    fn as_coercion_site(&self) -> &hir::Expr<'_> {\n         &self.body\n     }\n }"}, {"sha": "68f2943e9e1d25c1fd0b0562147434a6d7c5da29", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -16,7 +16,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn emit_coerce_suggestions(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expr_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n     ) {\n@@ -110,7 +110,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn demand_coerce(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n         allow_two_phase: AllowTwoPhase,\n@@ -129,7 +129,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // diverges flag is currently \"always\".\n     pub fn demand_coerce_diag(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n         allow_two_phase: AllowTwoPhase,\n@@ -157,7 +157,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (expected, Some(err))\n     }\n \n-    fn annotate_expected_due_to_let_ty(&self, err: &mut DiagnosticBuilder<'_>, expr: &hir::Expr) {\n+    fn annotate_expected_due_to_let_ty(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr<'_>,\n+    ) {\n         let parent = self.tcx.hir().get_parent_node(expr.hir_id);\n         if let Some(hir::Node::Local(hir::Local { ty: Some(ty), init: Some(init), .. })) =\n             self.tcx.hir().find(parent)\n@@ -170,7 +174,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Returns whether the expected type is `bool` and the expression is `x = y`.\n-    pub fn is_assign_to_bool(&self, expr: &hir::Expr, expected: Ty<'tcx>) -> bool {\n+    pub fn is_assign_to_bool(&self, expr: &hir::Expr<'_>, expected: Ty<'tcx>) -> bool {\n         if let hir::ExprKind::Assign(..) = expr.kind {\n             return expected == self.tcx.types.bool;\n         }\n@@ -182,7 +186,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn suggest_compatible_variants(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         expr_ty: Ty<'tcx>,\n     ) {\n@@ -282,7 +286,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ```\n     /// opt.map(|param| { takes_ref(param) });\n     /// ```\n-    fn can_use_as_ref(&self, expr: &hir::Expr) -> Option<(Span, &'static str, String)> {\n+    fn can_use_as_ref(&self, expr: &hir::Expr<'_>) -> Option<(Span, &'static str, String)> {\n         let path = match expr.kind {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => path,\n             _ => return None,\n@@ -352,7 +356,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let Node::Expr(hir::Expr { kind: hir::ExprKind::Struct(_, fields, ..), .. }) = parent\n             {\n                 if let Ok(src) = cm.span_to_snippet(sp) {\n-                    for field in fields {\n+                    for field in *fields {\n                         if field.ident.as_str() == src && field.is_shorthand {\n                             return true;\n                         }\n@@ -381,7 +385,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// `&mut`!\".\n     pub fn check_ref(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n     ) -> Option<(Span, &'static str, String)> {\n@@ -605,7 +609,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_for_cast(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n     ) -> bool {\n@@ -635,7 +639,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         })) = self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id))\n         {\n             // `expr` is a literal field for a struct, only suggest if appropriate\n-            for field in fields {\n+            for field in *fields {\n                 if field.expr.hir_id == expr.hir_id && field.is_shorthand {\n                     // This is a field literal\n                     prefix = format!(\"{}: \", field.ident);\n@@ -728,7 +732,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 expected_ty,\n                 if needs_paren { \")\" } else { \"\" },\n             );\n-            let literal_is_ty_suffixed = |expr: &hir::Expr| {\n+            let literal_is_ty_suffixed = |expr: &hir::Expr<'_>| {\n                 if let hir::ExprKind::Lit(lit) = &expr.kind {\n                     lit.node.is_suffixed()\n                 } else {"}, {"sha": "4da4ce7680bf54f0d25cb5e932d0634d9a33c60f", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 68, "deletions": 65, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -21,7 +21,6 @@ use errors::{pluralize, Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc::hir;\n use rustc::hir::def::{CtorKind, DefKind, Res};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::ptr::P;\n use rustc::hir::{ExprKind, QPath};\n use rustc::infer;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -43,14 +42,14 @@ use rustc_error_codes::*;\n use std::fmt::Display;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    fn check_expr_eq_type(&self, expr: &'tcx hir::Expr, expected: Ty<'tcx>) {\n+    fn check_expr_eq_type(&self, expr: &'tcx hir::Expr<'tcx>, expected: Ty<'tcx>) {\n         let ty = self.check_expr_with_hint(expr, expected);\n         self.demand_eqtype(expr.span, expected, ty);\n     }\n \n     pub fn check_expr_has_type_or_error(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n         extend_err: impl Fn(&mut DiagnosticBuilder<'_>),\n     ) -> Ty<'tcx> {\n@@ -59,7 +58,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_meets_expectation_or_error(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n         extend_err: impl Fn(&mut DiagnosticBuilder<'_>),\n     ) -> Ty<'tcx> {\n@@ -96,7 +95,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub(super) fn check_expr_coercable_to_type(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n     ) -> Ty<'tcx> {\n         let ty = self.check_expr_with_hint(expr, expected);\n@@ -106,25 +105,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub(super) fn check_expr_with_hint(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n     ) -> Ty<'tcx> {\n         self.check_expr_with_expectation(expr, ExpectHasType(expected))\n     }\n \n     pub(super) fn check_expr_with_expectation(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         self.check_expr_with_expectation_and_needs(expr, expected, Needs::None)\n     }\n \n-    pub(super) fn check_expr(&self, expr: &'tcx hir::Expr) -> Ty<'tcx> {\n+    pub(super) fn check_expr(&self, expr: &'tcx hir::Expr<'tcx>) -> Ty<'tcx> {\n         self.check_expr_with_expectation(expr, NoExpectation)\n     }\n \n-    pub(super) fn check_expr_with_needs(&self, expr: &'tcx hir::Expr, needs: Needs) -> Ty<'tcx> {\n+    pub(super) fn check_expr_with_needs(\n+        &self,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        needs: Needs,\n+    ) -> Ty<'tcx> {\n         self.check_expr_with_expectation_and_needs(expr, NoExpectation, needs)\n     }\n \n@@ -140,7 +143,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// that when err needs to be handled differently.\n     fn check_expr_with_expectation_and_needs(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n         needs: Needs,\n     ) -> Ty<'tcx> {\n@@ -208,7 +211,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_kind(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n         needs: Needs,\n     ) -> Ty<'tcx> {\n@@ -274,7 +277,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_expr_repeat(element, count, expected, expr)\n             }\n             ExprKind::Tup(ref elts) => self.check_expr_tuple(elts, expected, expr),\n-            ExprKind::Struct(ref qpath, ref fields, ref base_expr) => {\n+            ExprKind::Struct(ref qpath, fields, ref base_expr) => {\n                 self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n             }\n             ExprKind::Field(ref base, field) => self.check_field(expr, needs, &base, field),\n@@ -284,7 +287,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_expr_box(&self, expr: &'tcx hir::Expr, expected: Expectation<'tcx>) -> Ty<'tcx> {\n+    fn check_expr_box(&self, expr: &'tcx hir::Expr<'tcx>, expected: Expectation<'tcx>) -> Ty<'tcx> {\n         let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| match ty.kind {\n             ty::Adt(def, _) if def.is_box() => Expectation::rvalue_hint(self, ty.boxed_ty()),\n             _ => NoExpectation,\n@@ -296,10 +299,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_expr_unary(\n         &self,\n         unop: hir::UnOp,\n-        oprnd: &'tcx hir::Expr,\n+        oprnd: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n         needs: Needs,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let expected_inner = match unop {\n@@ -382,9 +385,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         kind: hir::BorrowKind,\n         mutbl: hir::Mutability,\n-        oprnd: &'tcx hir::Expr,\n+        oprnd: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n             match ty.kind {\n@@ -437,7 +440,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// * Contains a dereference\n     /// Note that the adjustments for the children of `expr` should already\n     /// have been resolved.\n-    fn check_named_place_expr(&self, oprnd: &'tcx hir::Expr) {\n+    fn check_named_place_expr(&self, oprnd: &'tcx hir::Expr<'tcx>) {\n         let is_named = oprnd.is_place_expr(|base| {\n             // Allow raw borrows if there are any deref adjustments.\n             //\n@@ -466,7 +469,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_expr_path(&self, qpath: &hir::QPath, expr: &'tcx hir::Expr) -> Ty<'tcx> {\n+    fn check_expr_path(&self, qpath: &hir::QPath, expr: &'tcx hir::Expr<'tcx>) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let (res, opt_ty, segs) = self.resolve_ty_and_res_ufcs(qpath, expr.hir_id, expr.span);\n         let ty = match res {\n@@ -538,8 +541,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_expr_break(\n         &self,\n         destination: hir::Destination,\n-        expr_opt: Option<&'tcx hir::Expr>,\n-        expr: &'tcx hir::Expr,\n+        expr_opt: Option<&'tcx hir::Expr<'tcx>>,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         if let Ok(target_id) = destination.target_id {\n@@ -669,8 +672,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_return(\n         &self,\n-        expr_opt: Option<&'tcx hir::Expr>,\n-        expr: &'tcx hir::Expr,\n+        expr_opt: Option<&'tcx hir::Expr<'tcx>>,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         if self.ret_coercion.is_none() {\n             struct_span_err!(\n@@ -710,7 +713,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.tcx.types.never\n     }\n \n-    pub(super) fn check_return_expr(&self, return_expr: &'tcx hir::Expr) {\n+    pub(super) fn check_return_expr(&self, return_expr: &'tcx hir::Expr<'tcx>) {\n         let ret_coercion = self.ret_coercion.as_ref().unwrap_or_else(|| {\n             span_bug!(return_expr.span, \"check_return_expr called outside fn body\")\n         });\n@@ -725,7 +728,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n     }\n \n-    fn is_destructuring_place_expr(&self, expr: &'tcx hir::Expr) -> bool {\n+    fn is_destructuring_place_expr(&self, expr: &'tcx hir::Expr<'tcx>) -> bool {\n         match &expr.kind {\n             ExprKind::Array(comps) | ExprKind::Tup(comps) => {\n                 comps.iter().all(|e| self.is_destructuring_place_expr(e))\n@@ -740,7 +743,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub(crate) fn check_lhs_assignable(\n         &self,\n-        lhs: &'tcx hir::Expr,\n+        lhs: &'tcx hir::Expr<'tcx>,\n         err_code: &'static str,\n         expr_span: &Span,\n     ) {\n@@ -763,10 +766,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// The expected type is `()` and is passsed to the function for the purposes of diagnostics.\n     fn check_expr_assign(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        lhs: &'tcx hir::Expr,\n-        rhs: &'tcx hir::Expr,\n+        lhs: &'tcx hir::Expr<'tcx>,\n+        rhs: &'tcx hir::Expr<'tcx>,\n         span: &Span,\n     ) -> Ty<'tcx> {\n         let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n@@ -804,10 +807,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_loop(\n         &self,\n-        body: &'tcx hir::Block,\n+        body: &'tcx hir::Block<'tcx>,\n         source: hir::LoopSource,\n         expected: Expectation<'tcx>,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let coerce = match source {\n             // you can only use break with a value from a normal `loop { }`\n@@ -849,10 +852,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Checks a method call.\n     fn check_method_call(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         segment: &hir::PathSegment,\n         span: Span,\n-        args: &'tcx [hir::Expr],\n+        args: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n         needs: Needs,\n     ) -> Ty<'tcx> {\n@@ -892,7 +895,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         segment: &hir::PathSegment,\n         span: Span,\n-        args: &'tcx [hir::Expr],\n+        args: &'tcx [hir::Expr<'tcx>],\n         rcvr_t: Ty<'tcx>,\n         error: MethodError<'tcx>,\n     ) {\n@@ -937,9 +940,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_cast(\n         &self,\n-        e: &'tcx hir::Expr,\n+        e: &'tcx hir::Expr<'tcx>,\n         t: &'tcx hir::Ty,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         // Find the type of `e`. Supply hints based on the type we are casting to,\n         // if appropriate.\n@@ -966,9 +969,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_array(\n         &self,\n-        args: &'tcx [hir::Expr],\n+        args: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let uty = expected.to_option(self).and_then(|uty| match uty.kind {\n             ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n@@ -1001,10 +1004,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_repeat(\n         &self,\n-        element: &'tcx hir::Expr,\n+        element: &'tcx hir::Expr<'tcx>,\n         count: &'tcx hir::AnonConst,\n         expected: Expectation<'tcx>,\n-        _expr: &'tcx hir::Expr,\n+        _expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let count_def_id = tcx.hir().local_def_id(count.hir_id);\n@@ -1048,9 +1051,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_tuple(\n         &self,\n-        elts: &'tcx [hir::Expr],\n+        elts: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let flds = expected.only_has_type(self).and_then(|ty| {\n             let ty = self.resolve_vars_with_obligations(ty);\n@@ -1082,11 +1085,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_struct(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expected: Expectation<'tcx>,\n         qpath: &QPath,\n-        fields: &'tcx [hir::Field],\n-        base_expr: &'tcx Option<P<hir::Expr>>,\n+        fields: &'tcx [hir::Field<'tcx>],\n+        base_expr: &'tcx Option<&'tcx hir::Expr<'tcx>>,\n     ) -> Ty<'tcx> {\n         // Find the relevant variant\n         let (variant, adt_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, expr.hir_id)\n@@ -1170,7 +1173,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr_id: hir::HirId,\n         span: Span,\n         variant: &'tcx ty::VariantDef,\n-        ast_fields: &'tcx [hir::Field],\n+        ast_fields: &'tcx [hir::Field<'tcx>],\n         check_completeness: bool,\n     ) -> bool {\n         let tcx = self.tcx;\n@@ -1288,8 +1291,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_struct_fields_on_error(\n         &self,\n-        fields: &'tcx [hir::Field],\n-        base_expr: &'tcx Option<P<hir::Expr>>,\n+        fields: &'tcx [hir::Field<'tcx>],\n+        base_expr: &'tcx Option<&'tcx hir::Expr<'tcx>>,\n     ) {\n         for field in fields {\n             self.check_expr(&field.expr);\n@@ -1303,8 +1306,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         ty: Ty<'tcx>,\n         variant: &'tcx ty::VariantDef,\n-        field: &hir::Field,\n-        skip_fields: &[hir::Field],\n+        field: &hir::Field<'_>,\n+        skip_fields: &[hir::Field<'_>],\n         kind_name: &str,\n         ty_span: Span,\n     ) {\n@@ -1441,9 +1444,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // Check field access expressions\n     fn check_field(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         needs: Needs,\n-        base: &'tcx hir::Expr,\n+        base: &'tcx hir::Expr<'tcx>,\n         field: ast::Ident,\n     ) -> Ty<'tcx> {\n         let expr_t = self.check_expr_with_needs(base, needs);\n@@ -1522,8 +1525,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn ban_nonexisting_field(\n         &self,\n         field: ast::Ident,\n-        base: &'tcx hir::Expr,\n-        expr: &'tcx hir::Expr,\n+        base: &'tcx hir::Expr<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expr_t: Ty<'tcx>,\n     ) {\n         let mut err = self.no_such_field_err(field.span, field, expr_t);\n@@ -1557,7 +1560,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn ban_private_field_access(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expr_t: Ty<'tcx>,\n         field: ast::Ident,\n         base_did: DefId,\n@@ -1590,7 +1593,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn ban_take_value_of_method(&self, expr: &hir::Expr, expr_t: Ty<'tcx>, field: ast::Ident) {\n+    fn ban_take_value_of_method(&self, expr: &hir::Expr<'_>, expr_t: Ty<'tcx>, field: ast::Ident) {\n         let mut err = type_error_struct!(\n             self.tcx().sess,\n             field.span,\n@@ -1664,8 +1667,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn maybe_suggest_array_indexing(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr,\n-        base: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n+        base: &hir::Expr<'_>,\n         field: ast::Ident,\n         len: &ty::Const<'tcx>,\n     ) {\n@@ -1692,8 +1695,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn suggest_first_deref_field(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr,\n-        base: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n+        base: &hir::Expr<'_>,\n         field: ast::Ident,\n     ) {\n         let base = self\n@@ -1726,10 +1729,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_index(\n         &self,\n-        base: &'tcx hir::Expr,\n-        idx: &'tcx hir::Expr,\n+        base: &'tcx hir::Expr<'tcx>,\n+        idx: &'tcx hir::Expr<'tcx>,\n         needs: Needs,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let base_t = self.check_expr_with_needs(&base, needs);\n         let idx_t = self.check_expr(&idx);\n@@ -1790,8 +1793,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_yield(\n         &self,\n-        value: &'tcx hir::Expr,\n-        expr: &'tcx hir::Expr,\n+        value: &'tcx hir::Expr<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n         src: &'tcx hir::YieldSource,\n     ) -> Ty<'tcx> {\n         match self.yield_ty {"}, {"sha": "3069f1b1d77d40444ed6fa4bff80e2459ed7b819", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -27,7 +27,7 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n         &mut self,\n         ty: Ty<'tcx>,\n         scope: Option<region::Scope>,\n-        expr: Option<&'tcx Expr>,\n+        expr: Option<&'tcx Expr<'tcx>>,\n         source_span: Span,\n     ) {\n         use syntax_pos::DUMMY_SP;\n@@ -196,7 +196,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_pat(&mut self, pat: &'tcx Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx Pat<'tcx>) {\n         intravisit::walk_pat(self, pat);\n \n         self.expr_count += 1;\n@@ -208,7 +208,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         let scope = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n         match &expr.kind {\n@@ -227,7 +227,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n                             self.expr_count += 1;\n \n                             // Record the rest of the call expression normally.\n-                            for arg in args {\n+                            for arg in *args {\n                                 self.visit_expr(arg);\n                             }\n                         }"}, {"sha": "98645b3463ef79ae358ea96925fb64a2926336ad", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -19,8 +19,8 @@ use std::ops::Deref;\n struct ConfirmContext<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     span: Span,\n-    self_expr: &'tcx hir::Expr,\n-    call_expr: &'tcx hir::Expr,\n+    self_expr: &'tcx hir::Expr<'tcx>,\n+    call_expr: &'tcx hir::Expr<'tcx>,\n }\n \n impl<'a, 'tcx> Deref for ConfirmContext<'a, 'tcx> {\n@@ -39,8 +39,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn confirm_method(\n         &self,\n         span: Span,\n-        self_expr: &'tcx hir::Expr,\n-        call_expr: &'tcx hir::Expr,\n+        self_expr: &'tcx hir::Expr<'tcx>,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n         unadjusted_self_ty: Ty<'tcx>,\n         pick: probe::Pick<'tcx>,\n         segment: &hir::PathSegment,\n@@ -59,8 +59,8 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     fn new(\n         fcx: &'a FnCtxt<'a, 'tcx>,\n         span: Span,\n-        self_expr: &'tcx hir::Expr,\n-        call_expr: &'tcx hir::Expr,\n+        self_expr: &'tcx hir::Expr<'tcx>,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n     ) -> ConfirmContext<'a, 'tcx> {\n         ConfirmContext { fcx, span, self_expr, call_expr }\n     }\n@@ -482,8 +482,8 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     fn convert_place_op_to_mutable(\n         &self,\n         op: PlaceOp,\n-        expr: &hir::Expr,\n-        base_expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &hir::Expr<'_>,\n         arg_tys: &[Ty<'tcx>],\n     ) {\n         debug!(\"convert_place_op_to_mutable({:?}, {:?}, {:?}, {:?})\", op, expr, base_expr, arg_tys);"}, {"sha": "41fd8d46346fd9a937af2f241b63752050ac0eaa", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -180,8 +180,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self_ty: Ty<'tcx>,\n         segment: &hir::PathSegment,\n         span: Span,\n-        call_expr: &'tcx hir::Expr,\n-        self_expr: &'tcx hir::Expr,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        self_expr: &'tcx hir::Expr<'tcx>,\n     ) -> Result<MethodCallee<'tcx>, MethodError<'tcx>> {\n         debug!(\n             \"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n@@ -260,7 +260,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         method_name: ast::Ident,\n         self_ty: Ty<'tcx>,\n-        call_expr: &'tcx hir::Expr,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n         scope: ProbeScope,\n     ) -> probe::PickResult<'tcx> {\n         let mode = probe::Mode::MethodCall;"}, {"sha": "f19e8c9ab1c78218e973833b572b9d8bd64bbd55", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         item_name: ast::Ident,\n         source: SelfSource<'b>,\n         error: MethodError<'tcx>,\n-        args: Option<&'tcx [hir::Expr]>,\n+        args: Option<&'tcx [hir::Expr<'tcx>]>,\n     ) -> Option<DiagnosticBuilder<'_>> {\n         let orig_span = span;\n         let mut span = span;\n@@ -954,7 +954,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n #[derive(Copy, Clone)]\n pub enum SelfSource<'a> {\n     QPath(&'a hir::Ty),\n-    MethodCall(&'a hir::Expr /* rcvr */),\n+    MethodCall(&'a hir::Expr<'a> /* rcvr */),\n }\n \n #[derive(Copy, Clone)]\n@@ -1131,7 +1131,7 @@ impl hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n \n fn print_disambiguation_help(\n     item_name: ast::Ident,\n-    args: Option<&'tcx [hir::Expr]>,\n+    args: Option<&'tcx [hir::Expr<'tcx>]>,\n     err: &mut DiagnosticBuilder<'_>,\n     trait_name: String,\n     rcvr_ty: Ty<'_>,"}, {"sha": "f8e494a6ccdd655e158284248008e579c30b1774", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -95,7 +95,6 @@ use rustc::hir::def::{CtorOf, DefKind, Res};\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::hir::ptr::P;\n use rustc::hir::{self, ExprKind, GenericArg, ItemKind, Node, PatKind, QPath};\n use rustc::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc::infer::error_reporting::TypeAnnotationNeeded::E0282;\n@@ -390,7 +389,7 @@ impl UnsafetyState {\n         UnsafetyState { def, unsafety, unsafe_push_count: 0, from_fn: true }\n     }\n \n-    pub fn recurse(&mut self, blk: &hir::Block) -> UnsafetyState {\n+    pub fn recurse(&mut self, blk: &hir::Block<'_>) -> UnsafetyState {\n         match self.unsafety {\n             // If this unsafe, then if the outer function was already marked as\n             // unsafe we shouldn't attribute the unsafe'ness to the block. This\n@@ -1136,7 +1135,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n     }\n \n     // Add explicitly-declared locals.\n-    fn visit_local(&mut self, local: &'tcx hir::Local) {\n+    fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n         let local_ty = match local.ty {\n             Some(ref ty) => {\n                 let o_ty = self.fcx.to_ty(&ty);\n@@ -1174,7 +1173,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n     }\n \n     // Add pattern bindings.\n-    fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n+    fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n         if let PatKind::Binding(_, _, ident, _) = p.kind {\n             let var_ty = self.assign(p.span, p.hir_id, None);\n \n@@ -2934,7 +2933,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn apply_adjustments(&self, expr: &hir::Expr, adj: Vec<Adjustment<'tcx>>) {\n+    pub fn apply_adjustments(&self, expr: &hir::Expr<'_>, adj: Vec<Adjustment<'tcx>>) {\n         debug!(\"apply_adjustments(expr={:?}, adj={:?})\", expr, adj);\n \n         if adj.is_empty() {\n@@ -3181,7 +3180,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Registers obligations that all types appearing in `substs` are well-formed.\n-    pub fn add_wf_bounds(&self, substs: SubstsRef<'tcx>, expr: &hir::Expr) {\n+    pub fn add_wf_bounds(&self, substs: SubstsRef<'tcx>, expr: &hir::Expr<'_>) {\n         for ty in substs.types() {\n             if !ty.references_error() {\n                 self.register_wf_obligation(ty, expr.span, traits::MiscObligation);\n@@ -3362,8 +3361,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn lookup_indexing(\n         &self,\n-        expr: &hir::Expr,\n-        base_expr: &'tcx hir::Expr,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &'tcx hir::Expr<'tcx>,\n         base_ty: Ty<'tcx>,\n         idx_ty: Ty<'tcx>,\n         needs: Needs,\n@@ -3388,8 +3387,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// is implemented by `lookup_indexing`.\n     fn try_index_step(\n         &self,\n-        expr: &hir::Expr,\n-        base_expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &hir::Expr<'_>,\n         autoderef: &Autoderef<'a, 'tcx>,\n         needs: Needs,\n         index_ty: Ty<'tcx>,\n@@ -3513,9 +3512,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_method_argument_types(\n         &self,\n         sp: Span,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         method: Result<MethodCallee<'tcx>, ()>,\n-        args_no_rcvr: &'tcx [hir::Expr],\n+        args_no_rcvr: &'tcx [hir::Expr<'tcx>],\n         tuple_arguments: TupleArgumentsFlag,\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n@@ -3641,10 +3640,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_argument_types(\n         &self,\n         sp: Span,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         fn_inputs: &[Ty<'tcx>],\n         expected_arg_tys: &[Ty<'tcx>],\n-        args: &'tcx [hir::Expr],\n+        args: &'tcx [hir::Expr<'tcx>],\n         c_variadic: bool,\n         tuple_arguments: TupleArgumentsFlag,\n         def_span: Option<Span>,\n@@ -3897,7 +3896,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         errors: &mut Vec<traits::FulfillmentError<'_>>,\n         final_arg_types: &[(usize, Ty<'tcx>, Ty<'tcx>)],\n         call_sp: Span,\n-        args: &'tcx [hir::Expr],\n+        args: &'tcx [hir::Expr<'tcx>],\n     ) {\n         // We *do not* do this for desugared call spans to keep good diagnostics when involving\n         // the `?` operator.\n@@ -3951,7 +3950,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn point_at_type_arg_instead_of_call_if_possible(\n         &self,\n         errors: &mut Vec<traits::FulfillmentError<'_>>,\n-        call_expr: &'tcx hir::Expr,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n     ) {\n         if let hir::ExprKind::Call(path, _) = &call_expr.kind {\n             if let hir::ExprKind::Path(qpath) = &path.kind {\n@@ -4248,8 +4247,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn check_decl_initializer(\n         &self,\n-        local: &'tcx hir::Local,\n-        init: &'tcx hir::Expr,\n+        local: &'tcx hir::Local<'tcx>,\n+        init: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         // FIXME(tschottdorf): `contains_explicit_ref_binding()` must be removed\n         // for #42640 (default match binding modes).\n@@ -4275,7 +4274,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn check_decl_local(&self, local: &'tcx hir::Local) {\n+    pub fn check_decl_local(&self, local: &'tcx hir::Local<'tcx>) {\n         let t = self.local_ty(local.span, local.hir_id).decl_ty;\n         self.write_ty(local.hir_id, t);\n \n@@ -4289,7 +4288,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.overwrite_local_ty_if_err(local, t, pat_ty);\n     }\n \n-    fn overwrite_local_ty_if_err(&self, local: &'tcx hir::Local, decl_ty: Ty<'tcx>, ty: Ty<'tcx>) {\n+    fn overwrite_local_ty_if_err(\n+        &self,\n+        local: &'tcx hir::Local<'tcx>,\n+        decl_ty: Ty<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) {\n         if ty.references_error() {\n             // Override the types everywhere with `types.err` to avoid knock down errors.\n             self.write_ty(local.hir_id, ty);\n@@ -4309,7 +4313,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n     }\n \n-    pub fn check_stmt(&self, stmt: &'tcx hir::Stmt) {\n+    pub fn check_stmt(&self, stmt: &'tcx hir::Stmt<'tcx>) {\n         // Don't do all the complex logic below for `DeclItem`.\n         match stmt.kind {\n             hir::StmtKind::Item(..) => return,\n@@ -4347,7 +4351,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.has_errors.set(self.has_errors.get() | old_has_errors);\n     }\n \n-    pub fn check_block_no_value(&self, blk: &'tcx hir::Block) {\n+    pub fn check_block_no_value(&self, blk: &'tcx hir::Block<'tcx>) {\n         let unit = self.tcx.mk_unit();\n         let ty = self.check_block_with_expected(blk, ExpectHasType(unit));\n \n@@ -4365,7 +4369,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// if false { return 0i32; } else { 1u32 }\n     /// //                               ^^^^ point at this instead of the whole `if` expression\n     /// ```\n-    fn get_expr_coercion_span(&self, expr: &hir::Expr) -> syntax_pos::Span {\n+    fn get_expr_coercion_span(&self, expr: &hir::Expr<'_>) -> syntax_pos::Span {\n         if let hir::ExprKind::Match(_, arms, _) = &expr.kind {\n             let arm_spans: Vec<Span> = arms\n                 .iter()\n@@ -4396,7 +4400,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_block_with_expected(\n         &self,\n-        blk: &'tcx hir::Block,\n+        blk: &'tcx hir::Block<'tcx>,\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         let prev = {\n@@ -4426,7 +4430,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let coerce = if blk.targeted_by_break {\n             CoerceMany::new(coerce_to_ty)\n         } else {\n-            let tail_expr: &[P<hir::Expr>] = match tail_expr {\n+            let tail_expr: &[&hir::Expr<'_>] = match tail_expr {\n                 Some(e) => slice::from_ref(e),\n                 None => &[],\n             };\n@@ -4437,7 +4441,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ctxt = BreakableCtxt { coerce: Some(coerce), may_break: false };\n \n         let (ctxt, ()) = self.with_breakable_ctxt(blk.hir_id, ctxt, || {\n-            for s in &blk.stmts {\n+            for s in blk.stmts {\n                 self.check_stmt(s);\n             }\n \n@@ -4588,7 +4592,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn suggest_mismatched_types_on_tail(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n         cause_span: Span,\n@@ -4613,7 +4617,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn suggest_fn_call(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) -> bool {\n@@ -4756,7 +4760,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn suggest_ref_or_into(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) {\n@@ -4819,7 +4823,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn suggest_boxing_when_appropriate(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) {\n@@ -4864,7 +4868,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn suggest_missing_semicolon(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expression: &'tcx hir::Expr,\n+        expression: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n         cause_span: Span,\n     ) {\n@@ -4970,7 +4974,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn suggest_missing_await(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) {\n@@ -5033,7 +5037,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// with `expected_ty`. If so, it suggests removing the semicolon.\n     fn consider_hint_about_removing_semicolon(\n         &self,\n-        blk: &'tcx hir::Block,\n+        blk: &'tcx hir::Block<'tcx>,\n         expected_ty: Ty<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n     ) {\n@@ -5047,7 +5051,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn could_remove_semicolon(&self, blk: &'tcx hir::Block, expected_ty: Ty<'tcx>) -> Option<Span> {\n+    fn could_remove_semicolon(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> Option<Span> {\n         // Be helpful when the user wrote `{... expr;}` and\n         // taking the `;` off is enough to fix the error.\n         let last_stmt = blk.stmts.last()?;"}, {"sha": "873a9b86fd60fac4cd8019d4bdec2a42748548b3", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -17,10 +17,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Checks a `a <op>= b`\n     pub fn check_binop_assign(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         op: hir::BinOp,\n-        lhs: &'tcx hir::Expr,\n-        rhs: &'tcx hir::Expr,\n+        lhs: &'tcx hir::Expr<'tcx>,\n+        rhs: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let (lhs_ty, rhs_ty, return_ty) =\n             self.check_overloaded_binop(expr, lhs, rhs, op, IsAssign::Yes);\n@@ -41,10 +41,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Checks a potentially overloaded binary operator.\n     pub fn check_binop(\n         &self,\n-        expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n         op: hir::BinOp,\n-        lhs_expr: &'tcx hir::Expr,\n-        rhs_expr: &'tcx hir::Expr,\n+        lhs_expr: &'tcx hir::Expr<'tcx>,\n+        rhs_expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n@@ -100,9 +100,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn enforce_builtin_binop_types(\n         &self,\n-        lhs_expr: &'tcx hir::Expr,\n+        lhs_expr: &'tcx hir::Expr<'tcx>,\n         lhs_ty: Ty<'tcx>,\n-        rhs_expr: &'tcx hir::Expr,\n+        rhs_expr: &'tcx hir::Expr<'tcx>,\n         rhs_ty: Ty<'tcx>,\n         op: hir::BinOp,\n     ) -> Ty<'tcx> {\n@@ -137,9 +137,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_overloaded_binop(\n         &self,\n-        expr: &'tcx hir::Expr,\n-        lhs_expr: &'tcx hir::Expr,\n-        rhs_expr: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        lhs_expr: &'tcx hir::Expr<'tcx>,\n+        rhs_expr: &'tcx hir::Expr<'tcx>,\n         op: hir::BinOp,\n         is_assign: IsAssign,\n     ) -> (Ty<'tcx>, Ty<'tcx>, Ty<'tcx>) {\n@@ -561,8 +561,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// to print the normal \"implementation of `std::ops::Add` might be missing\" note\n     fn check_str_addition(\n         &self,\n-        lhs_expr: &'tcx hir::Expr,\n-        rhs_expr: &'tcx hir::Expr,\n+        lhs_expr: &'tcx hir::Expr<'tcx>,\n+        rhs_expr: &'tcx hir::Expr<'tcx>,\n         lhs_ty: Ty<'tcx>,\n         rhs_ty: Ty<'tcx>,\n         err: &mut errors::DiagnosticBuilder<'_>,\n@@ -659,7 +659,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn check_user_unop(\n         &self,\n-        ex: &'tcx hir::Expr,\n+        ex: &'tcx hir::Expr<'tcx>,\n         operand_ty: Ty<'tcx>,\n         op: hir::UnOp,\n     ) -> Ty<'tcx> {"}, {"sha": "3fb6d5227f77b8a2f7ec369e7af0a65e625bcaa6", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 44, "deletions": 32, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -3,7 +3,6 @@ use crate::util::nodemap::FxHashMap;\n use errors::{pluralize, Applicability, DiagnosticBuilder};\n use rustc::hir::def::{CtorKind, DefKind, Res};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n-use rustc::hir::ptr::P;\n use rustc::hir::{self, HirId, Pat, PatKind};\n use rustc::infer;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -31,7 +30,12 @@ You can read more about trait objects in the Trait Objects section of the Refere\n https://doc.rust-lang.org/reference/types.html#trait-objects\";\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn check_pat_top(&self, pat: &'tcx Pat, expected: Ty<'tcx>, discrim_span: Option<Span>) {\n+    pub fn check_pat_top(\n+        &self,\n+        pat: &'tcx Pat<'tcx>,\n+        expected: Ty<'tcx>,\n+        discrim_span: Option<Span>,\n+    ) {\n         let def_bm = BindingMode::BindByValue(hir::Mutability::Not);\n         self.check_pat(pat, expected, def_bm, discrim_span);\n     }\n@@ -54,7 +58,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ```\n     fn check_pat(\n         &self,\n-        pat: &'tcx Pat,\n+        pat: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n         discrim_span: Option<Span>,\n@@ -97,13 +101,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_pat_struct(pat, qpath, fields, *etc, expected, def_bm, discrim_span)\n             }\n             PatKind::Or(pats) => {\n-                for pat in pats {\n+                for pat in *pats {\n                     self.check_pat(pat, expected, def_bm, discrim_span);\n                 }\n                 expected\n             }\n             PatKind::Tuple(elements, ddpos) => {\n-                self.check_pat_tuple(pat.span, elements, *ddpos, expected, def_bm, discrim_span)\n+                self.check_pat_tuple(pat.span, *elements, *ddpos, expected, def_bm, discrim_span)\n             }\n             PatKind::Box(inner) => {\n                 self.check_pat_box(pat.span, inner, expected, def_bm, discrim_span)\n@@ -113,7 +117,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             PatKind::Slice(before, slice, after) => {\n                 let slice = slice.as_deref();\n-                self.check_pat_slice(pat.span, before, slice, after, expected, def_bm, discrim_span)\n+                self.check_pat_slice(\n+                    pat.span,\n+                    *before,\n+                    slice,\n+                    *after,\n+                    expected,\n+                    def_bm,\n+                    discrim_span,\n+                )\n             }\n         };\n \n@@ -173,7 +185,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// as well as the pattern form we are currently checking.\n     fn calc_default_binding_mode(\n         &self,\n-        pat: &'tcx Pat,\n+        pat: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n         is_non_ref_pat: bool,\n@@ -203,7 +215,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Is the pattern a \"non reference pattern\"?\n     /// When the pattern is a path pattern, `opt_path_res` must be `Some(res)`.\n-    fn is_non_ref_pat(&self, pat: &'tcx Pat, opt_path_res: Option<Res>) -> bool {\n+    fn is_non_ref_pat(&self, pat: &'tcx Pat<'tcx>, opt_path_res: Option<Res>) -> bool {\n         match pat.kind {\n             PatKind::Struct(..)\n             | PatKind::TupleStruct(..)\n@@ -242,7 +254,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// The adjustments vector, if non-empty is stored in a table.\n     fn peel_off_references(\n         &self,\n-        pat: &'tcx Pat,\n+        pat: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         mut def_bm: BindingMode,\n     ) -> (Ty<'tcx>, BindingMode) {\n@@ -288,7 +300,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_lit(\n         &self,\n         span: Span,\n-        lt: &hir::Expr,\n+        lt: &hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n         discrim_span: Option<Span>,\n     ) -> Ty<'tcx> {\n@@ -341,8 +353,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_range(\n         &self,\n         span: Span,\n-        begin: &'tcx hir::Expr,\n-        end: &'tcx hir::Expr,\n+        begin: &'tcx hir::Expr<'tcx>,\n+        end: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n         discrim_span: Option<Span>,\n     ) -> Option<Ty<'tcx>> {\n@@ -422,10 +434,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_ident(\n         &self,\n-        pat: &Pat,\n+        pat: &Pat<'_>,\n         ba: hir::BindingAnnotation,\n         var_id: HirId,\n-        sub: Option<&'tcx Pat>,\n+        sub: Option<&'tcx Pat<'tcx>>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n         discrim_span: Option<Span>,\n@@ -477,8 +489,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn borrow_pat_suggestion(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        pat: &Pat,\n-        inner: &Pat,\n+        pat: &Pat<'_>,\n+        inner: &Pat<'_>,\n         expected: Ty<'tcx>,\n     ) {\n         let tcx = self.tcx;\n@@ -513,7 +525,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn check_dereferenceable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat) -> bool {\n+    pub fn check_dereferenceable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat<'_>) -> bool {\n         if let PatKind::Binding(..) = inner.kind {\n             if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n                 if let ty::Dynamic(..) = mt.ty.kind {\n@@ -541,9 +553,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_struct(\n         &self,\n-        pat: &'tcx Pat,\n+        pat: &'tcx Pat<'tcx>,\n         qpath: &hir::QPath,\n-        fields: &'tcx [hir::FieldPat],\n+        fields: &'tcx [hir::FieldPat<'tcx>],\n         etc: bool,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n@@ -574,7 +586,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_path(\n         &self,\n-        pat: &Pat,\n+        pat: &Pat<'_>,\n         path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment]),\n         qpath: &hir::QPath,\n         expected: Ty<'tcx>,\n@@ -609,9 +621,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_tuple_struct(\n         &self,\n-        pat: &Pat,\n+        pat: &Pat<'_>,\n         qpath: &hir::QPath,\n-        subpats: &'tcx [P<Pat>],\n+        subpats: &'tcx [&'tcx Pat<'tcx>],\n         ddpos: Option<usize>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n@@ -713,7 +725,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pat_span: Span,\n         res: Res,\n         qpath: &hir::QPath,\n-        subpats: &'tcx [P<Pat>],\n+        subpats: &'tcx [&'tcx Pat<'tcx>],\n         fields: &'tcx [ty::FieldDef],\n         expected: Ty<'tcx>,\n         had_err: bool,\n@@ -795,7 +807,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_tuple(\n         &self,\n         span: Span,\n-        elements: &'tcx [P<Pat>],\n+        elements: &'tcx [&'tcx Pat<'tcx>],\n         ddpos: Option<usize>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n@@ -843,7 +855,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pat_id: HirId,\n         span: Span,\n         variant: &'tcx ty::VariantDef,\n-        fields: &'tcx [hir::FieldPat],\n+        fields: &'tcx [hir::FieldPat<'tcx>],\n         etc: bool,\n         def_bm: BindingMode,\n     ) -> bool {\n@@ -1069,7 +1081,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_box(\n         &self,\n         span: Span,\n-        inner: &'tcx Pat,\n+        inner: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n         discrim_span: Option<Span>,\n@@ -1094,8 +1106,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_ref(\n         &self,\n-        pat: &Pat,\n-        inner: &'tcx Pat,\n+        pat: &Pat<'_>,\n+        inner: &'tcx Pat<'tcx>,\n         mutbl: hir::Mutability,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n@@ -1158,9 +1170,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_slice(\n         &self,\n         span: Span,\n-        before: &'tcx [P<Pat>],\n-        slice: Option<&'tcx Pat>,\n-        after: &'tcx [P<Pat>],\n+        before: &'tcx [&'tcx Pat<'tcx>],\n+        slice: Option<&'tcx Pat<'tcx>>,\n+        after: &'tcx [&'tcx Pat<'tcx>],\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n         discrim_span: Option<Span>,\n@@ -1208,7 +1220,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_array_pat_len(\n         &self,\n         span: Span,\n-        slice: Option<&'tcx Pat>,\n+        slice: Option<&'tcx Pat<'tcx>>,\n         len: &ty::Const<'tcx>,\n         min_len: u64,\n     ) -> Option<u64> {"}, {"sha": "1ce7748badbf1760e7c5738460d794d30a146c23", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     }\n \n     /// Try to resolve the type for the given node.\n-    pub fn resolve_expr_type_adjusted(&mut self, expr: &hir::Expr) -> Ty<'tcx> {\n+    pub fn resolve_expr_type_adjusted(&mut self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n         let ty = self.tables.borrow().expr_ty_adjusted(expr);\n         self.resolve_type(ty)\n     }\n@@ -367,7 +367,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         );\n     }\n \n-    fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n+    fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat<'_>) {\n         debug!(\"regionck::visit_pat(pat={:?})\", pat);\n         pat.each_binding(|_, hir_id, span, _| {\n             // If we have a variable that contains region'd data, that\n@@ -453,20 +453,20 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n \n     //visit_pat: visit_pat, // (..) see above\n \n-    fn visit_arm(&mut self, arm: &'tcx hir::Arm) {\n+    fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n         // see above\n         self.constrain_bindings_in_pat(&arm.pat);\n         intravisit::walk_arm(self, arm);\n     }\n \n-    fn visit_local(&mut self, l: &'tcx hir::Local) {\n+    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n         // see above\n         self.constrain_bindings_in_pat(&l.pat);\n         self.link_local(l);\n         intravisit::walk_local(self, l);\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         debug!(\"regionck::visit_expr(e={:?}, repeating_scope={:?})\", expr, self.repeating_scope);\n \n         // No matter what, the type of each expression must outlive the\n@@ -580,7 +580,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n             hir::ExprKind::Unary(hir::UnDeref, ref base) => {\n                 // For *a, the lifetime of a must enclose the deref\n                 if is_method_call {\n-                    self.constrain_call(expr, Some(base), None::<hir::Expr>.iter());\n+                    self.constrain_call(expr, Some(base), None::<hir::Expr<'_>>.iter());\n                 }\n                 // For overloaded derefs, base_ty is the input to `Deref::deref`,\n                 // but it's a reference type uing the same region as the output.\n@@ -594,7 +594,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n \n             hir::ExprKind::Unary(_, ref lhs) if is_method_call => {\n                 // As above.\n-                self.constrain_call(expr, Some(&lhs), None::<hir::Expr>.iter());\n+                self.constrain_call(expr, Some(&lhs), None::<hir::Expr<'_>>.iter());\n \n                 intravisit::walk_expr(self, expr);\n             }\n@@ -670,7 +670,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n-    fn constrain_cast(&mut self, cast_expr: &hir::Expr, source_expr: &hir::Expr) {\n+    fn constrain_cast(&mut self, cast_expr: &hir::Expr<'_>, source_expr: &hir::Expr<'_>) {\n         debug!(\"constrain_cast(cast_expr={:?}, source_expr={:?})\", cast_expr, source_expr);\n \n         let source_ty = self.resolve_node_type(source_expr.hir_id);\n@@ -679,7 +679,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         self.walk_cast(cast_expr, source_ty, target_ty);\n     }\n \n-    fn walk_cast(&mut self, cast_expr: &hir::Expr, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) {\n+    fn walk_cast(&mut self, cast_expr: &hir::Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) {\n         debug!(\"walk_cast(from_ty={:?}, to_ty={:?})\", from_ty, to_ty);\n         match (&from_ty.kind, &to_ty.kind) {\n             /*From:*/\n@@ -707,13 +707,13 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_expr_fn_block(&mut self, expr: &'tcx hir::Expr, body_id: hir::BodyId) {\n+    fn check_expr_fn_block(&mut self, expr: &'tcx hir::Expr<'tcx>, body_id: hir::BodyId) {\n         let repeating_scope = self.set_repeating_scope(body_id.hir_id);\n         intravisit::walk_expr(self, expr);\n         self.set_repeating_scope(repeating_scope);\n     }\n \n-    fn constrain_callee(&mut self, callee_expr: &hir::Expr) {\n+    fn constrain_callee(&mut self, callee_expr: &hir::Expr<'_>) {\n         let callee_ty = self.resolve_node_type(callee_expr.hir_id);\n         match callee_ty.kind {\n             ty::FnDef(..) | ty::FnPtr(_) => {}\n@@ -729,10 +729,10 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn constrain_call<'b, I: Iterator<Item = &'b hir::Expr>>(\n+    fn constrain_call<'b, I: Iterator<Item = &'b hir::Expr<'b>>>(\n         &mut self,\n-        call_expr: &hir::Expr,\n-        receiver: Option<&hir::Expr>,\n+        call_expr: &hir::Expr<'_>,\n+        receiver: Option<&hir::Expr<'_>>,\n         arg_exprs: I,\n     ) {\n         //! Invoked on every call site (i.e., normal calls, method calls,\n@@ -786,7 +786,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     /// Invoked on any adjustments that occur. Checks that if this is a region pointer being\n     /// dereferenced, the lifetime of the pointer includes the deref expr.\n-    fn constrain_adjustments(&mut self, expr: &hir::Expr) -> mc::McResult<mc::Place<'tcx>> {\n+    fn constrain_adjustments(&mut self, expr: &hir::Expr<'_>) -> mc::McResult<mc::Place<'tcx>> {\n         debug!(\"constrain_adjustments(expr={:?})\", expr);\n \n         let mut cmt = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n@@ -880,7 +880,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     /// Invoked on any index expression that occurs. Checks that if this is a slice\n     /// being indexed, the lifetime of the pointer includes the deref expr.\n-    fn constrain_index(&mut self, index_expr: &hir::Expr, indexed_ty: Ty<'tcx>) {\n+    fn constrain_index(&mut self, index_expr: &hir::Expr<'_>, indexed_ty: Ty<'tcx>) {\n         debug!(\"constrain_index(index_expr=?, indexed_ty={}\", self.ty_to_string(indexed_ty));\n \n         let r_index_expr = ty::ReScope(region::Scope {\n@@ -952,7 +952,12 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     /// Computes the guarantor for an expression `&base` and then ensures that the lifetime of the\n     /// resulting pointer is linked to the lifetime of its guarantor (if any).\n-    fn link_addr_of(&mut self, expr: &hir::Expr, mutability: hir::Mutability, base: &hir::Expr) {\n+    fn link_addr_of(\n+        &mut self,\n+        expr: &hir::Expr<'_>,\n+        mutability: hir::Mutability,\n+        base: &hir::Expr<'_>,\n+    ) {\n         debug!(\"link_addr_of(expr={:?}, base={:?})\", expr, base);\n \n         let cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(base)));\n@@ -965,7 +970,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     /// Computes the guarantors for any ref bindings in a `let` and\n     /// then ensures that the lifetime of the resulting pointer is\n     /// linked to the lifetime of the initialization expression.\n-    fn link_local(&self, local: &hir::Local) {\n+    fn link_local(&self, local: &hir::Local<'_>) {\n         debug!(\"regionck::for_local()\");\n         let init_expr = match local.init {\n             None => {\n@@ -980,7 +985,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     /// Computes the guarantors for any ref bindings in a match and\n     /// then ensures that the lifetime of the resulting pointer is\n     /// linked to the lifetime of its guarantor (if any).\n-    fn link_match(&self, discr: &hir::Expr, arms: &[hir::Arm]) {\n+    fn link_match(&self, discr: &hir::Expr<'_>, arms: &[hir::Arm<'_>]) {\n         debug!(\"regionck::for_match()\");\n         let discr_cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(discr)));\n         debug!(\"discr_cmt={:?}\", discr_cmt);\n@@ -992,7 +997,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     /// Computes the guarantors for any ref bindings in a match and\n     /// then ensures that the lifetime of the resulting pointer is\n     /// linked to the lifetime of its guarantor (if any).\n-    fn link_fn_params(&self, params: &[hir::Param]) {\n+    fn link_fn_params(&self, params: &[hir::Param<'_>]) {\n         for param in params {\n             let param_ty = self.node_ty(param.hir_id);\n             let param_cmt =\n@@ -1004,7 +1009,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     /// Link lifetimes of any ref bindings in `root_pat` to the pointers found\n     /// in the discriminant, if needed.\n-    fn link_pattern(&self, discr_cmt: mc::Place<'tcx>, root_pat: &hir::Pat) {\n+    fn link_pattern(&self, discr_cmt: mc::Place<'tcx>, root_pat: &hir::Pat<'_>) {\n         debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\", discr_cmt, root_pat);\n         ignore_err!(self.with_mc(|mc| {\n             mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, hir::Pat { kind, span, hir_id }| {\n@@ -1024,7 +1029,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     /// autoref'd.\n     fn link_autoref(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         expr_cmt: &mc::Place<'tcx>,\n         autoref: &adjustment::AutoBorrow<'tcx>,\n     ) {"}, {"sha": "bdccced42c4b34c4e33a6c1b36befe5d63a73667", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -63,7 +63,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InferBorrowKindVisitor<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         if let hir::ExprKind::Closure(cc, _, body_id, _, _) = expr.kind {\n             let body = self.fcx.tcx.hir().body(body_id);\n             self.visit_body(body);"}, {"sha": "ca9a4763ed0a44c33468dda1a6deead769b0b119", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -132,7 +132,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     // as potentially overloaded. But then, during writeback, if\n     // we observe that something like `a+b` is (known to be)\n     // operating on scalars, we clear the overload.\n-    fn fix_scalar_builtin_expr(&mut self, e: &hir::Expr) {\n+    fn fix_scalar_builtin_expr(&mut self, e: &hir::Expr<'_>) {\n         match e.kind {\n             hir::ExprKind::Unary(hir::UnNeg, ref inner)\n             | hir::ExprKind::Unary(hir::UnNot, ref inner) => {\n@@ -181,7 +181,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     // Here, correct cases where an indexing expression can be simplified\n     // to use builtin indexing because the index type is known to be\n     // usize-ish\n-    fn fix_index_builtin_expr(&mut self, e: &hir::Expr) {\n+    fn fix_index_builtin_expr(&mut self, e: &hir::Expr<'_>) {\n         if let hir::ExprKind::Index(ref base, ref index) = e.kind {\n             let mut tables = self.fcx.tables.borrow_mut();\n \n@@ -247,7 +247,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n         self.fix_scalar_builtin_expr(e);\n         self.fix_index_builtin_expr(e);\n \n@@ -262,7 +262,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n \n                 self.visit_body(body);\n             }\n-            hir::ExprKind::Struct(_, ref fields, _) => {\n+            hir::ExprKind::Struct(_, fields, _) => {\n                 for field in fields {\n                     self.visit_field_id(field.hir_id);\n                 }\n@@ -276,20 +276,20 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n         intravisit::walk_expr(self, e);\n     }\n \n-    fn visit_block(&mut self, b: &'tcx hir::Block) {\n+    fn visit_block(&mut self, b: &'tcx hir::Block<'tcx>) {\n         self.visit_node_id(b.span, b.hir_id);\n         intravisit::walk_block(self, b);\n     }\n \n-    fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n+    fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n         match p.kind {\n             hir::PatKind::Binding(..) => {\n                 let tables = self.fcx.tables.borrow();\n                 if let Some(bm) = tables.extract_binding_mode(self.tcx().sess, p.hir_id, p.span) {\n                     self.tables.pat_binding_modes_mut().insert(p.hir_id, bm);\n                 }\n             }\n-            hir::PatKind::Struct(_, ref fields, _) => {\n+            hir::PatKind::Struct(_, fields, _) => {\n                 for field in fields {\n                     self.visit_field_id(field.hir_id);\n                 }\n@@ -303,7 +303,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n         intravisit::walk_pat(self, p);\n     }\n \n-    fn visit_local(&mut self, l: &'tcx hir::Local) {\n+    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n         intravisit::walk_local(self, l);\n         let var_ty = self.fcx.local_ty(l.span, l.hir_id).decl_ty;\n         let var_ty = self.resolve(&var_ty, &l.span);"}, {"sha": "01f11f669f75b7c03f8df21efe7cee14fcdcc7fc", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -134,7 +134,7 @@ impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n         intravisit::walk_generics(self, generics);\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         if let hir::ExprKind::Closure(..) = expr.kind {\n             let def_id = self.tcx.hir().local_def_id(expr.hir_id);\n             self.tcx.generics_of(def_id);"}, {"sha": "b1467d508dcec0b14bba7dece8018a1b883a80f4", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -10,7 +10,6 @@ pub use mc::{Place, PlaceBase, Projection};\n \n use rustc::hir::def::Res;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::ptr::P;\n use rustc::hir::{self, PatKind};\n use rustc::infer::InferCtxt;\n use rustc::ty::{self, adjustment, TyCtxt};\n@@ -150,27 +149,27 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         self.delegate.consume(place, mode);\n     }\n \n-    fn consume_exprs(&mut self, exprs: &[hir::Expr]) {\n+    fn consume_exprs(&mut self, exprs: &[hir::Expr<'_>]) {\n         for expr in exprs {\n             self.consume_expr(&expr);\n         }\n     }\n \n-    pub fn consume_expr(&mut self, expr: &hir::Expr) {\n+    pub fn consume_expr(&mut self, expr: &hir::Expr<'_>) {\n         debug!(\"consume_expr(expr={:?})\", expr);\n \n         let place = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate_consume(&place);\n         self.walk_expr(expr);\n     }\n \n-    fn mutate_expr(&mut self, expr: &hir::Expr) {\n+    fn mutate_expr(&mut self, expr: &hir::Expr<'_>) {\n         let place = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate.mutate(&place);\n         self.walk_expr(expr);\n     }\n \n-    fn borrow_expr(&mut self, expr: &hir::Expr, bk: ty::BorrowKind) {\n+    fn borrow_expr(&mut self, expr: &hir::Expr<'_>, bk: ty::BorrowKind) {\n         debug!(\"borrow_expr(expr={:?}, bk={:?})\", expr, bk);\n \n         let place = return_if_err!(self.mc.cat_expr(expr));\n@@ -179,11 +178,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         self.walk_expr(expr)\n     }\n \n-    fn select_from_expr(&mut self, expr: &hir::Expr) {\n+    fn select_from_expr(&mut self, expr: &hir::Expr<'_>) {\n         self.walk_expr(expr)\n     }\n \n-    pub fn walk_expr(&mut self, expr: &hir::Expr) {\n+    pub fn walk_expr(&mut self, expr: &hir::Expr<'_>) {\n         debug!(\"walk_expr(expr={:?})\", expr);\n \n         self.walk_adjustment(expr);\n@@ -228,7 +227,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 self.consume_exprs(exprs);\n             }\n \n-            hir::ExprKind::Match(ref discr, ref arms, _) => {\n+            hir::ExprKind::Match(ref discr, arms, _) => {\n                 let discr_place = return_if_err!(self.mc.cat_expr(&discr));\n                 self.borrow_expr(&discr, ty::ImmBorrow);\n \n@@ -251,7 +250,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             }\n \n             hir::ExprKind::InlineAsm(ref ia) => {\n-                for (o, output) in ia.inner.outputs.iter().zip(&ia.outputs_exprs) {\n+                for (o, output) in ia.inner.outputs.iter().zip(ia.outputs_exprs) {\n                     if o.is_indirect {\n                         self.consume_expr(output);\n                     } else {\n@@ -326,7 +325,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn walk_callee(&mut self, call: &hir::Expr, callee: &hir::Expr) {\n+    fn walk_callee(&mut self, call: &hir::Expr<'_>, callee: &hir::Expr<'_>) {\n         let callee_ty = return_if_err!(self.mc.expr_ty_adjusted(callee));\n         debug!(\"walk_callee: callee={:?} callee_ty={:?}\", callee, callee_ty);\n         match callee_ty.kind {\n@@ -354,7 +353,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn walk_stmt(&mut self, stmt: &hir::Stmt) {\n+    fn walk_stmt(&mut self, stmt: &hir::Stmt<'_>) {\n         match stmt.kind {\n             hir::StmtKind::Local(ref local) => {\n                 self.walk_local(&local);\n@@ -371,7 +370,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn walk_local(&mut self, local: &hir::Local) {\n+    fn walk_local(&mut self, local: &hir::Local<'_>) {\n         if let Some(ref expr) = local.init {\n             // Variable declarations with\n             // initializers are considered\n@@ -385,10 +384,10 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n     /// Indicates that the value of `blk` will be consumed, meaning either copied or moved\n     /// depending on its type.\n-    fn walk_block(&mut self, blk: &hir::Block) {\n+    fn walk_block(&mut self, blk: &hir::Block<'_>) {\n         debug!(\"walk_block(blk.hir_id={})\", blk.hir_id);\n \n-        for stmt in &blk.stmts {\n+        for stmt in blk.stmts {\n             self.walk_stmt(stmt);\n         }\n \n@@ -397,7 +396,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn walk_struct_expr(&mut self, fields: &[hir::Field], opt_with: &Option<P<hir::Expr>>) {\n+    fn walk_struct_expr(\n+        &mut self,\n+        fields: &[hir::Field<'_>],\n+        opt_with: &Option<&'hir hir::Expr<'_>>,\n+    ) {\n         // Consume the expressions supplying values for each field.\n         for field in fields {\n             self.consume_expr(&field.expr);\n@@ -450,7 +453,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     // Invoke the appropriate delegate calls for anything that gets\n     // consumed or borrowed as part of the automatic adjustment\n     // process.\n-    fn walk_adjustment(&mut self, expr: &hir::Expr) {\n+    fn walk_adjustment(&mut self, expr: &hir::Expr<'_>) {\n         let adjustments = self.mc.tables.expr_adjustments(expr);\n         let mut place = return_if_err!(self.mc.cat_expr_unadjusted(expr));\n         for adjustment in adjustments {\n@@ -487,7 +490,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// after all relevant autoderefs have occurred.\n     fn walk_autoref(\n         &mut self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         base_place: &mc::Place<'tcx>,\n         autoref: &adjustment::AutoBorrow<'tcx>,\n     ) {\n@@ -509,7 +512,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn walk_arm(&mut self, discr_place: &Place<'tcx>, arm: &hir::Arm) {\n+    fn walk_arm(&mut self, discr_place: &Place<'tcx>, arm: &hir::Arm<'_>) {\n         self.walk_pat(discr_place, &arm.pat);\n \n         if let Some(hir::Guard::If(ref e)) = arm.guard {\n@@ -521,12 +524,12 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n     /// Walks a pat that occurs in isolation (i.e., top-level of fn argument or\n     /// let binding, and *not* a match arm or nested pat.)\n-    fn walk_irrefutable_pat(&mut self, discr_place: &Place<'tcx>, pat: &hir::Pat) {\n+    fn walk_irrefutable_pat(&mut self, discr_place: &Place<'tcx>, pat: &hir::Pat<'_>) {\n         self.walk_pat(discr_place, pat);\n     }\n \n     /// The core driver for walking a pattern\n-    fn walk_pat(&mut self, discr_place: &Place<'tcx>, pat: &hir::Pat) {\n+    fn walk_pat(&mut self, discr_place: &Place<'tcx>, pat: &hir::Pat<'_>) {\n         debug!(\"walk_pat(discr_place={:?}, pat={:?})\", discr_place, pat);\n \n         let tcx = self.tcx();\n@@ -565,7 +568,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }));\n     }\n \n-    fn walk_captures(&mut self, closure_expr: &hir::Expr, fn_decl_span: Span) {\n+    fn walk_captures(&mut self, closure_expr: &hir::Expr<'_>, fn_decl_span: Span) {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n         let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id);"}, {"sha": "4f5b55e4cd64e989b3be1f31988970c0263dd08b", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04c789f699a3470edd8cc76d016c68e99cfe4db/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=a04c789f699a3470edd8cc76d016c68e99cfe4db", "patch": "@@ -117,7 +117,7 @@ crate trait HirNode {\n     fn span(&self) -> Span;\n }\n \n-impl HirNode for hir::Expr {\n+impl HirNode for hir::Expr<'_> {\n     fn hir_id(&self) -> hir::HirId {\n         self.hir_id\n     }\n@@ -126,7 +126,7 @@ impl HirNode for hir::Expr {\n     }\n }\n \n-impl HirNode for hir::Pat {\n+impl HirNode for hir::Pat<'_> {\n     fn hir_id(&self) -> hir::HirId {\n         self.hir_id\n     }\n@@ -213,11 +213,11 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         self.resolve_type_vars_or_error(hir_id, self.tables.node_type_opt(hir_id))\n     }\n \n-    fn expr_ty(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n+    fn expr_ty(&self, expr: &hir::Expr<'_>) -> McResult<Ty<'tcx>> {\n         self.resolve_type_vars_or_error(expr.hir_id, self.tables.expr_ty_opt(expr))\n     }\n \n-    crate fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n+    crate fn expr_ty_adjusted(&self, expr: &hir::Expr<'_>) -> McResult<Ty<'tcx>> {\n         self.resolve_type_vars_or_error(expr.hir_id, self.tables.expr_ty_adjusted_opt(expr))\n     }\n \n@@ -231,7 +231,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     ///   implicit deref patterns attached (e.g., it is really\n     ///   `&Some(x)`). In that case, we return the \"outermost\" type\n     ///   (e.g., `&Option<T>).\n-    crate fn pat_ty_adjusted(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n+    crate fn pat_ty_adjusted(&self, pat: &hir::Pat<'_>) -> McResult<Ty<'tcx>> {\n         // Check for implicit `&` types wrapping the pattern; note\n         // that these are never attached to binding patterns, so\n         // actually this is somewhat \"disjoint\" from the code below\n@@ -247,7 +247,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     }\n \n     /// Like `pat_ty`, but ignores implicit `&` patterns.\n-    fn pat_ty_unadjusted(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n+    fn pat_ty_unadjusted(&self, pat: &hir::Pat<'_>) -> McResult<Ty<'tcx>> {\n         let base_ty = self.node_ty(pat.hir_id)?;\n         debug!(\"pat_ty(pat={:?}) base_ty={:?}\", pat, base_ty);\n \n@@ -280,12 +280,12 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         Ok(ret_ty)\n     }\n \n-    crate fn cat_expr(&self, expr: &hir::Expr) -> McResult<Place<'tcx>> {\n+    crate fn cat_expr(&self, expr: &hir::Expr<'_>) -> McResult<Place<'tcx>> {\n         // This recursion helper avoids going through *too many*\n         // adjustments, since *only* non-overloaded deref recurses.\n         fn helper<'a, 'tcx>(\n             mc: &MemCategorizationContext<'a, 'tcx>,\n-            expr: &hir::Expr,\n+            expr: &hir::Expr<'_>,\n             adjustments: &[adjustment::Adjustment<'tcx>],\n         ) -> McResult<Place<'tcx>> {\n             match adjustments.split_last() {\n@@ -301,7 +301,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n \n     crate fn cat_expr_adjusted(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         previous: Place<'tcx>,\n         adjustment: &adjustment::Adjustment<'tcx>,\n     ) -> McResult<Place<'tcx>> {\n@@ -310,7 +310,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n \n     fn cat_expr_adjusted_with<F>(\n         &self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         previous: F,\n         adjustment: &adjustment::Adjustment<'tcx>,\n     ) -> McResult<Place<'tcx>>\n@@ -342,7 +342,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n-    crate fn cat_expr_unadjusted(&self, expr: &hir::Expr) -> McResult<Place<'tcx>> {\n+    crate fn cat_expr_unadjusted(&self, expr: &hir::Expr<'_>) -> McResult<Place<'tcx>> {\n         debug!(\"cat_expr: id={} expr={:?}\", expr.hir_id, expr);\n \n         let expr_ty = self.expr_ty(expr)?;\n@@ -513,7 +513,11 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         ret\n     }\n \n-    fn cat_overloaded_place(&self, expr: &hir::Expr, base: &hir::Expr) -> McResult<Place<'tcx>> {\n+    fn cat_overloaded_place(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        base: &hir::Expr<'_>,\n+    ) -> McResult<Place<'tcx>> {\n         debug!(\"cat_overloaded_place(expr={:?}, base={:?})\", expr, base);\n \n         // Reconstruct the output assuming it's a reference with the\n@@ -557,17 +561,27 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         Ok(ret)\n     }\n \n-    crate fn cat_pattern<F>(&self, place: Place<'tcx>, pat: &hir::Pat, mut op: F) -> McResult<()>\n+    crate fn cat_pattern<F>(\n+        &self,\n+        place: Place<'tcx>,\n+        pat: &hir::Pat<'_>,\n+        mut op: F,\n+    ) -> McResult<()>\n     where\n-        F: FnMut(&Place<'tcx>, &hir::Pat),\n+        F: FnMut(&Place<'tcx>, &hir::Pat<'_>),\n     {\n         self.cat_pattern_(place, pat, &mut op)\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n-    fn cat_pattern_<F>(&self, mut place: Place<'tcx>, pat: &hir::Pat, op: &mut F) -> McResult<()>\n+    fn cat_pattern_<F>(\n+        &self,\n+        mut place: Place<'tcx>,\n+        pat: &hir::Pat<'_>,\n+        op: &mut F,\n+    ) -> McResult<()>\n     where\n-        F: FnMut(&Place<'tcx>, &hir::Pat),\n+        F: FnMut(&Place<'tcx>, &hir::Pat<'_>),\n     {\n         // Here, `place` is the `Place` being matched and pat is the pattern it\n         // is being matched against.\n@@ -638,7 +652,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 }\n             }\n \n-            PatKind::Struct(_, ref field_pats, _) => {\n+            PatKind::Struct(_, field_pats, _) => {\n                 // S { f1: p1, ..., fN: pN }\n                 for fp in field_pats {\n                     let field_ty = self.pat_ty_adjusted(&fp.pat)?;\n@@ -647,7 +661,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 }\n             }\n \n-            PatKind::Or(ref pats) => {\n+            PatKind::Or(pats) => {\n                 for pat in pats {\n                     self.cat_pattern_(place.clone(), &pat, op)?;\n                 }\n@@ -665,7 +679,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 self.cat_pattern_(subplace, &subpat, op)?;\n             }\n \n-            PatKind::Slice(ref before, ref slice, ref after) => {\n+            PatKind::Slice(before, ref slice, after) => {\n                 let element_ty = match place.ty.builtin_index() {\n                     Some(ty) => ty,\n                     None => {"}]}