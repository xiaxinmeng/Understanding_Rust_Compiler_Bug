{"sha": "720f19f2ec4282f636889b35beabf31272e3b1b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyMGYxOWYyZWM0MjgyZjYzNjg4OWIzNWJlYWJmMzEyNzJlM2IxYjI=", "commit": {"author": {"name": "rail", "email": "12975677+rail-rain@users.noreply.github.com", "date": "2020-06-10T03:58:12Z"}, "committer": {"name": "rail", "email": "12975677+rail-rain@users.noreply.github.com", "date": "2020-09-24T21:02:05Z"}, "message": "Implement detecting `manual_memcpy` with loop counters", "tree": {"sha": "da0f22bd0ccaaac1bf05e52091a7fc87b32acd84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da0f22bd0ccaaac1bf05e52091a7fc87b32acd84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/720f19f2ec4282f636889b35beabf31272e3b1b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/720f19f2ec4282f636889b35beabf31272e3b1b2", "html_url": "https://github.com/rust-lang/rust/commit/720f19f2ec4282f636889b35beabf31272e3b1b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/720f19f2ec4282f636889b35beabf31272e3b1b2/comments", "author": {"login": "rail-rain", "id": 12975677, "node_id": "MDQ6VXNlcjEyOTc1Njc3", "avatar_url": "https://avatars.githubusercontent.com/u/12975677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rail-rain", "html_url": "https://github.com/rail-rain", "followers_url": "https://api.github.com/users/rail-rain/followers", "following_url": "https://api.github.com/users/rail-rain/following{/other_user}", "gists_url": "https://api.github.com/users/rail-rain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rail-rain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rail-rain/subscriptions", "organizations_url": "https://api.github.com/users/rail-rain/orgs", "repos_url": "https://api.github.com/users/rail-rain/repos", "events_url": "https://api.github.com/users/rail-rain/events{/privacy}", "received_events_url": "https://api.github.com/users/rail-rain/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rail-rain", "id": 12975677, "node_id": "MDQ6VXNlcjEyOTc1Njc3", "avatar_url": "https://avatars.githubusercontent.com/u/12975677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rail-rain", "html_url": "https://github.com/rail-rain", "followers_url": "https://api.github.com/users/rail-rain/followers", "following_url": "https://api.github.com/users/rail-rain/following{/other_user}", "gists_url": "https://api.github.com/users/rail-rain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rail-rain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rail-rain/subscriptions", "organizations_url": "https://api.github.com/users/rail-rain/orgs", "repos_url": "https://api.github.com/users/rail-rain/repos", "events_url": "https://api.github.com/users/rail-rain/events{/privacy}", "received_events_url": "https://api.github.com/users/rail-rain/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4b4da162f19e9a4c63854a2b5a6167b83f9d8b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4b4da162f19e9a4c63854a2b5a6167b83f9d8b9", "html_url": "https://github.com/rust-lang/rust/commit/b4b4da162f19e9a4c63854a2b5a6167b83f9d8b9"}], "stats": {"total": 90, "additions": 66, "deletions": 24}, "files": [{"sha": "c036d63c335149100175332c3a506de0bad6f9d0", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 66, "deletions": 24, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/720f19f2ec4282f636889b35beabf31272e3b1b2/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720f19f2ec4282f636889b35beabf31272e3b1b2/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=720f19f2ec4282f636889b35beabf31272e3b1b2", "patch": "@@ -913,37 +913,62 @@ fn get_offset<'tcx>(\n     }\n }\n \n-fn get_assignments<'tcx>(body: &'tcx Expr<'tcx>) -> impl Iterator<Item = Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>> {\n-    fn get_assignment<'tcx>(e: &'tcx Expr<'tcx>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n-        if let ExprKind::Assign(lhs, rhs, _) = e.kind {\n-            Some((lhs, rhs))\n-        } else {\n-            None\n-        }\n+fn get_assignment<'tcx>(e: &'tcx Expr<'tcx>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+    if let ExprKind::Assign(lhs, rhs, _) = e.kind {\n+        Some((lhs, rhs))\n+    } else {\n+        None\n     }\n+}\n \n-    // This is one of few ways to return different iterators\n-    // derived from: https://stackoverflow.com/questions/29760668/conditionally-iterate-over-one-of-several-possible-iterators/52064434#52064434\n-    let mut iter_a = None;\n-    let mut iter_b = None;\n+fn get_assignments<'a: 'c, 'tcx: 'c, 'c>(\n+    cx: &'a LateContext<'a, 'tcx>,\n+    stmts: &'tcx [Stmt<'tcx>],\n+    expr: Option<&'tcx Expr<'tcx>>,\n+    loop_counters: &'c [Start<'tcx>],\n+) -> impl Iterator<Item = Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>> + 'c {\n+    stmts\n+        .iter()\n+        .filter_map(move |stmt| match stmt.kind {\n+            StmtKind::Local(..) | StmtKind::Item(..) => None,\n+            StmtKind::Expr(e) | StmtKind::Semi(e) => if_chain! {\n+                if let ExprKind::AssignOp(_, var, _) = e.kind;\n+                // skip StartKind::Range\n+                if loop_counters.iter().skip(1).any(|counter| Some(counter.id) == var_def_id(cx, var));\n+                then { None } else { Some(e) }\n+            },\n+        })\n+        .chain(expr.into_iter())\n+        .map(get_assignment)\n+}\n \n-    if let ExprKind::Block(b, _) = body.kind {\n-        let Block { stmts, expr, .. } = *b;\n+fn get_loop_counters<'a, 'tcx>(\n+    cx: &'a LateContext<'a, 'tcx>,\n+    body: &'tcx Block<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+) -> Option<impl Iterator<Item = Start<'tcx>> + 'a> {\n+    // Look for variables that are incremented once per loop iteration.\n+    let mut increment_visitor = IncrementVisitor::new(cx);\n+    walk_block(&mut increment_visitor, body);\n \n-        iter_a = stmts\n-            .iter()\n-            .filter_map(|stmt| match stmt.kind {\n-                StmtKind::Local(..) | StmtKind::Item(..) => None,\n-                StmtKind::Expr(e) | StmtKind::Semi(e) => Some(e),\n+    // For each candidate, check the parent block to see if\n+    // it's initialized to zero at the start of the loop.\n+    if let Some(block) = get_enclosing_block(&cx, expr.hir_id) {\n+        increment_visitor\n+            .into_results()\n+            .filter_map(move |var_id| {\n+                let mut initialize_visitor = InitializeVisitor::new(cx, expr, var_id);\n+                walk_block(&mut initialize_visitor, block);\n+\n+                initialize_visitor.get_result().map(|(_, initializer)| Start {\n+                    id: var_id,\n+                    kind: StartKind::Counter { initializer },\n+                })\n             })\n-            .chain(expr.into_iter())\n-            .map(get_assignment)\n             .into()\n     } else {\n-        iter_b = Some(get_assignment(body))\n+        None\n     }\n-\n-    iter_a.into_iter().flatten().chain(iter_b.into_iter())\n }\n \n fn build_manual_memcpy_suggestion<'tcx>(\n@@ -1047,9 +1072,26 @@ fn detect_manual_memcpy<'tcx>(\n                 id: canonical_id,\n                 kind: StartKind::Range,\n             }];\n+\n+            // This is one of few ways to return different iterators\n+            // derived from: https://stackoverflow.com/questions/29760668/conditionally-iterate-over-one-of-several-possible-iterators/52064434#52064434\n+            let mut iter_a = None;\n+            let mut iter_b = None;\n+\n+            if let ExprKind::Block(block, _) = body.kind {\n+                if let Some(loop_counters) = get_loop_counters(cx, block, expr) {\n+                    starts.extend(loop_counters);\n+                }\n+                iter_a = Some(get_assignments(cx, block.stmts, block.expr, &starts));\n+            } else {\n+                iter_b = Some(get_assignment(body));\n+            }\n+\n             // The only statements in the for loops can be indexed assignments from\n             // indexed retrievals.\n-            let big_sugg = get_assignments(body)\n+            let assignments = iter_a.into_iter().flatten().chain(iter_b.into_iter());\n+\n+            let big_sugg = assignments\n                 .map(|o| {\n                     o.and_then(|(lhs, rhs)| {\n                         let rhs = fetch_cloned_expr(rhs);"}]}