{"sha": "7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "node_id": "C_kwDOAAsO6NoAKDdhYzRiODJkZGQ1OTZhMjE4Y2FjOGNkNmI4OGE5MWI1NGZjZGNmMTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-16T11:06:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-16T11:06:02Z"}, "message": "Auto merge of #109206 - matthiaskrgr:rollup-oev8ax6, r=matthiaskrgr\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #108875 (rustdoc: fix type search for `Option` combinators)\n - #108971 (error-msg: impl better suggestion for `E0532`)\n - #109139 (rustdoc: DocFS: Replace rayon with threadpool and enable it for all targets)\n - #109151 (Assert def-kind is correct for alias types)\n - #109158 (error-msg: expand suggestion for `unused_def` lint)\n - #109166 (make `define_opaque_types` fully explicit)\n - #109171 (Some cleanups in our normalization logic)\n - #109180 (Unequal \u2192 Not equal)\n - #109185 (rustdoc: remove `std::` from primitive intra-doc link tooltips)\n - #109192 (Mention UEFI target promotion in release notes for 1.67.0)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "191fd952f333b9275766d48bab742a4208ec6ad4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/191fd952f333b9275766d48bab742a4208ec6ad4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "html_url": "https://github.com/rust-lang/rust/commit/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd6c574af3886c41f34086d90df42c3da0144693", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6c574af3886c41f34086d90df42c3da0144693", "html_url": "https://github.com/rust-lang/rust/commit/cd6c574af3886c41f34086d90df42c3da0144693"}, {"sha": "a70e138ed89fe5464bb372410c8418058783b9cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/a70e138ed89fe5464bb372410c8418058783b9cc", "html_url": "https://github.com/rust-lang/rust/commit/a70e138ed89fe5464bb372410c8418058783b9cc"}], "stats": {"total": 1202, "additions": 791, "deletions": 411}, "files": [{"sha": "49b89c71994a87f23b643f9f5d459c47d0352277", "filename": "Cargo.lock", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -5458,13 +5458,13 @@ dependencies = [\n  \"itertools\",\n  \"minifier\",\n  \"once_cell\",\n- \"rayon\",\n  \"regex\",\n  \"rustdoc-json-types\",\n  \"serde\",\n  \"serde_json\",\n  \"smallvec\",\n  \"tempfile\",\n+ \"threadpool\",\n  \"tracing\",\n  \"tracing-subscriber\",\n  \"tracing-tree\",\n@@ -6209,6 +6209,15 @@ dependencies = [\n  \"once_cell\",\n ]\n \n+[[package]]\n+name = \"threadpool\"\n+version = \"1.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d050e60b33d41c19108b32cea32164033a9013fe3b46cbd4457559bfbf77afaa\"\n+dependencies = [\n+ \"num_cpus\",\n+]\n+\n [[package]]\n name = \"tidy\"\n version = \"0.1.0\""}, {"sha": "a26dbbfa4f5ec98c1844c97edfb2c695b50df46e", "filename": "RELEASES.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -125,12 +125,13 @@ Compiler\n - [Optimize field ordering by grouping m\\*2^n-sized fields with equivalently aligned ones.](https://github.com/rust-lang/rust/pull/102750/)\n - [Stabilize native library modifier `verbatim`.](https://github.com/rust-lang/rust/pull/104360/)\n \n-Added and removed targets:\n+Added, updated, and removed targets:\n \n - [Add a tier 3 target for PowerPC on AIX](https://github.com/rust-lang/rust/pull/102293/), `powerpc64-ibm-aix`.\n - [Add a tier 3 target for the Sony PlayStation 1](https://github.com/rust-lang/rust/pull/102689/), `mipsel-sony-psx`.\n - [Add tier 3 `no_std` targets for the QNX Neutrino RTOS](https://github.com/rust-lang/rust/pull/102701/),\n   `aarch64-unknown-nto-qnx710` and `x86_64-pc-nto-qnx710`.\n+- [Promote UEFI targets to tier 2](https://github.com/rust-lang/rust/pull/103933/), `aarch64-unknown-uefi`, `i686-unknown-uefi`, and `x86_64-unknown-uefi`.\n - [Remove tier 3 `linuxkernel` targets](https://github.com/rust-lang/rust/pull/104015/) (not used by the actual kernel).\n \n Refer to Rust's [platform support page][platform-support-doc]"}, {"sha": "2cbd2e3bc0d86547ba9834ffcc1a439c9f424cdd", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -306,7 +306,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         }\n \n         // By passing `PlaceConflictBias::NoOverlap`, we conservatively assume that any given\n-        // pair of array indices are unequal, so that when `places_conflict` returns true, we\n+        // pair of array indices are not equal, so that when `places_conflict` returns true, we\n         // will be assured that two places being compared definitely denotes the same sets of\n         // locations.\n         let definitely_conflicting_borrows = other_borrows_of_local.filter(|&i| {"}, {"sha": "8c0edcee52147bd176139af3accbf478ef7d49e4", "filename": "compiler/rustc_error_codes/src/error_codes/E0416.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0416.md", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0416.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0416.md?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -23,6 +23,6 @@ Or maybe did you mean to unify? Consider using a guard:\n # let (A, B, C) = (1, 2, 3);\n match (A, B, C) {\n     (x, x2, see) if x == x2 => { /* A and B are equal, do one thing */ }\n-    (y, z, see) => { /* A and B unequal; do another thing */ }\n+    (y, z, see) => { /* A and B not equal; do another thing */ }\n }\n ```"}, {"sha": "a07cb65170dcae4fdacdee20f4f13c769f73447a", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -367,7 +367,7 @@ impl LockstepIterSize {\n ///\n /// Example: `$($($x $y)+*);+` -- we need to make sure that `x` and `y` repeat the same amount as\n /// each other at the given depth when the macro was invoked. If they don't it might mean they were\n-/// declared at unequal depths or there was a compile bug. For example, if we have 3 repetitions of\n+/// declared at depths which weren't equal or there was a compiler bug. For example, if we have 3 repetitions of\n /// the outer sequence and 4 repetitions of the inner sequence for `x`, we should have the same for\n /// `y`; otherwise, we can't transcribe them both at the given depth.\n fn lockstep_iter_size("}, {"sha": "0e1cf3e6c6a7d7cc02eba28a2c1593da74c3227f", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -9,8 +9,8 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::ItemKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::infer::{self, RegionResolutionError};\n+use rustc_infer::infer::{DefineOpaqueTypes, TyCtxtInferExt};\n use rustc_middle::ty::adjustment::CoerceUnsizedInfo;\n use rustc_middle::ty::{self, suggest_constraining_type_params, Ty, TyCtxt, TypeVisitableExt};\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n@@ -235,7 +235,8 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n     use rustc_type_ir::sty::TyKind::*;\n     match (source.kind(), target.kind()) {\n         (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n-            if infcx.at(&cause, param_env).eq(r_a, *r_b).is_ok() && mutbl_a == *mutbl_b => {}\n+            if infcx.at(&cause, param_env).eq(DefineOpaqueTypes::No, r_a, *r_b).is_ok()\n+                && mutbl_a == *mutbl_b => {}\n         (&RawPtr(tm_a), &RawPtr(tm_b)) if tm_a.mutbl == tm_b.mutbl => (),\n         (&Adt(def_a, substs_a), &Adt(def_b, substs_b))\n             if def_a.is_struct() && def_b.is_struct() =>\n@@ -278,7 +279,9 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n                         }\n                     }\n \n-                    if let Ok(ok) = infcx.at(&cause, param_env).eq(ty_a, ty_b) {\n+                    if let Ok(ok) =\n+                        infcx.at(&cause, param_env).eq(DefineOpaqueTypes::No, ty_a, ty_b)\n+                    {\n                         if ok.obligations.is_empty() {\n                             create_err(\n                                 \"the trait `DispatchFromDyn` may only be implemented \\\n@@ -504,7 +507,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                     // we may have to evaluate constraint\n                     // expressions in the course of execution.)\n                     // See e.g., #41936.\n-                    if let Ok(ok) = infcx.at(&cause, param_env).eq(a, b) {\n+                    if let Ok(ok) = infcx.at(&cause, param_env).eq(DefineOpaqueTypes::No, a, b) {\n                         if ok.obligations.is_empty() {\n                             return None;\n                         }"}, {"sha": "08786fe9b1ef90d6bdbf421208398f5ba48dbc2a", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -102,7 +102,7 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::Node;\n-use rustc_infer::infer::{InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk, TyCtxtInferExt};\n use rustc_macros::fluent_messages;\n use rustc_middle::middle;\n use rustc_middle::ty::query::Providers;\n@@ -165,7 +165,7 @@ fn require_same_types<'tcx>(\n ) -> bool {\n     let infcx = &tcx.infer_ctxt().build();\n     let param_env = ty::ParamEnv::empty();\n-    let errors = match infcx.at(cause, param_env).eq(expected, actual) {\n+    let errors = match infcx.at(cause, param_env).eq(DefineOpaqueTypes::No, expected, actual) {\n         Ok(InferOk { obligations, .. }) => traits::fully_solve_obligations(infcx, obligations),\n         Err(err) => {\n             infcx.err_ctxt().report_mismatched_types(cause, expected, actual, err).emit();"}, {"sha": "6becf4892acb20562d3911987f7f87be4ec21782", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -8,7 +8,7 @@ use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::LateBoundRegionConversionTime;\n+use rustc_infer::infer::{DefineOpaqueTypes, LateBoundRegionConversionTime};\n use rustc_infer::infer::{InferOk, InferResult};\n use rustc_macros::{TypeFoldable, TypeVisitable};\n use rustc_middle::ty::subst::InternalSubsts;\n@@ -563,10 +563,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ) {\n                 // Check that E' = S'.\n                 let cause = self.misc(hir_ty.span);\n-                let InferOk { value: (), obligations } = self\n-                    .at(&cause, self.param_env)\n-                    .define_opaque_types(true)\n-                    .eq(*expected_ty, supplied_ty)?;\n+                let InferOk { value: (), obligations } = self.at(&cause, self.param_env).eq(\n+                    DefineOpaqueTypes::Yes,\n+                    *expected_ty,\n+                    supplied_ty,\n+                )?;\n                 all_obligations.extend(obligations);\n             }\n \n@@ -576,10 +577,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 supplied_sig.output(),\n             );\n             let cause = &self.misc(decl.output.span());\n-            let InferOk { value: (), obligations } = self\n-                .at(cause, self.param_env)\n-                .define_opaque_types(true)\n-                .eq(expected_sigs.liberated_sig.output(), supplied_output_ty)?;\n+            let InferOk { value: (), obligations } = self.at(cause, self.param_env).eq(\n+                DefineOpaqueTypes::Yes,\n+                expected_sigs.liberated_sig.output(),\n+                supplied_output_ty,\n+            )?;\n             all_obligations.extend(obligations);\n \n             let inputs = inputs.into_iter().map(|ty| self.resolve_vars_if_possible(ty));"}, {"sha": "3d6274ede81466fe3fd6a71e65e465290f809d61", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -45,7 +45,7 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::Expr;\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{Coercion, InferOk, InferResult};\n+use rustc_infer::infer::{Coercion, DefineOpaqueTypes, InferOk, InferResult};\n use rustc_infer::traits::Obligation;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::adjustment::{\n@@ -143,11 +143,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         debug!(\"unify(a: {:?}, b: {:?}, use_lub: {})\", a, b, self.use_lub);\n         self.commit_if_ok(|_| {\n-            let at = self.at(&self.cause, self.fcx.param_env).define_opaque_types(true);\n+            let at = self.at(&self.cause, self.fcx.param_env);\n             if self.use_lub {\n-                at.lub(b, a)\n+                at.lub(DefineOpaqueTypes::Yes, b, a)\n             } else {\n-                at.sup(b, a)\n+                at.sup(DefineOpaqueTypes::Yes, b, a)\n                     .map(|InferOk { value: (), obligations }| InferOk { value: a, obligations })\n             }\n         })\n@@ -175,7 +175,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             // so this will have the side-effect of making sure we have no ambiguities\n             // due to `[type error]` and `_` not coercing together.\n             let _ = self.commit_if_ok(|_| {\n-                self.at(&self.cause, self.param_env).define_opaque_types(true).eq(a, b)\n+                self.at(&self.cause, self.param_env).eq(DefineOpaqueTypes::Yes, a, b)\n             });\n             return success(vec![], self.fcx.tcx.ty_error(guar), vec![]);\n         }\n@@ -1101,9 +1101,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (ty::FnDef(..), ty::FnDef(..)) => {\n                         // Don't reify if the function types have a LUB, i.e., they\n                         // are the same function and their parameters have a LUB.\n-                        match self\n-                            .commit_if_ok(|_| self.at(cause, self.param_env).lub(prev_ty, new_ty))\n-                        {\n+                        match self.commit_if_ok(|_| {\n+                            self.at(cause, self.param_env).lub(\n+                                DefineOpaqueTypes::No,\n+                                prev_ty,\n+                                new_ty,\n+                            )\n+                        }) {\n                             // We have a LUB of prev_ty and new_ty, just return it.\n                             Ok(ok) => return Ok(self.register_infer_ok_obligations(ok)),\n                             Err(_) => {\n@@ -1153,7 +1157,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let sig = self\n                 .at(cause, self.param_env)\n                 .trace(prev_ty, new_ty)\n-                .lub(a_sig, b_sig)\n+                .lub(DefineOpaqueTypes::No, a_sig, b_sig)\n                 .map(|ok| self.register_infer_ok_obligations(ok))?;\n \n             // Reify both sides and return the reified fn pointer type.\n@@ -1237,7 +1241,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n \n                 return self\n-                    .commit_if_ok(|_| self.at(cause, self.param_env).lub(prev_ty, new_ty))\n+                    .commit_if_ok(|_| {\n+                        self.at(cause, self.param_env).lub(DefineOpaqueTypes::No, prev_ty, new_ty)\n+                    })\n                     .map(|ok| self.register_infer_ok_obligations(ok));\n             }\n         }\n@@ -1248,8 +1254,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let Some(e) = first_error {\n                     Err(e)\n                 } else {\n-                    self.commit_if_ok(|_| self.at(cause, self.param_env).lub(prev_ty, new_ty))\n-                        .map(|ok| self.register_infer_ok_obligations(ok))\n+                    self.commit_if_ok(|_| {\n+                        self.at(cause, self.param_env).lub(DefineOpaqueTypes::No, prev_ty, new_ty)\n+                    })\n+                    .map(|ok| self.register_infer_ok_obligations(ok))\n                 }\n             }\n             Ok(ok) => {\n@@ -1487,8 +1495,12 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             assert!(expression_ty.is_unit(), \"if let hack without unit type\");\n             fcx.at(cause, fcx.param_env)\n                 // needed for tests/ui/type-alias-impl-trait/issue-65679-inst-opaque-ty-from-val-twice.rs\n-                .define_opaque_types(true)\n-                .eq_exp(label_expression_as_expected, expression_ty, self.merged_ty())\n+                .eq_exp(\n+                    DefineOpaqueTypes::Yes,\n+                    label_expression_as_expected,\n+                    expression_ty,\n+                    self.merged_ty(),\n+                )\n                 .map(|infer_ok| {\n                     fcx.register_infer_ok_obligations(infer_ok);\n                     expression_ty"}, {"sha": "f65f16e317d4977d2f56847eedbf5f243a5f3411", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::def::CtorKind;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{is_range_literal, Node};\n-use rustc_infer::infer::InferOk;\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n@@ -113,7 +113,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        match self.at(cause, self.param_env).define_opaque_types(true).sup(expected, actual) {\n+        match self.at(cause, self.param_env).sup(DefineOpaqueTypes::Yes, expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n                 None\n@@ -143,7 +143,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        match self.at(cause, self.param_env).define_opaque_types(true).eq(expected, actual) {\n+        match self.at(cause, self.param_env).eq(DefineOpaqueTypes::Yes, expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n                 None"}, {"sha": "afef331ec1d93ae61ba373f5fe3918028c22c077", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -36,6 +36,7 @@ use rustc_hir_analysis::astconv::AstConv as _;\n use rustc_hir_analysis::check::ty_kind_suggestion;\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::infer::InferOk;\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::middle::stability;\n@@ -1683,7 +1684,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             if let Some(_) = remaining_fields.remove(&ident) {\n                                 let target_ty = self.field_ty(base_expr.span, f, substs);\n                                 let cause = self.misc(base_expr.span);\n-                                match self.at(&cause, self.param_env).sup(target_ty, fru_ty) {\n+                                match self.at(&cause, self.param_env).sup(\n+                                    DefineOpaqueTypes::No,\n+                                    target_ty,\n+                                    fru_ty,\n+                                ) {\n                                     Ok(InferOk { obligations, value: () }) => {\n                                         self.register_predicates(obligations)\n                                     }"}, {"sha": "e539693402af9419e5db1b19e5177988a210826e", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -19,7 +19,7 @@ use rustc_hir_analysis::astconv::{\n };\n use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n-use rustc_infer::infer::InferResult;\n+use rustc_infer::infer::{DefineOpaqueTypes, InferResult};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n@@ -558,7 +558,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let span = self.tcx.hir().body(body_id).value.span;\n             let ok = self\n                 .at(&self.misc(span), self.param_env)\n-                .eq(interior, witness)\n+                .eq(DefineOpaqueTypes::No, interior, witness)\n                 .expect(\"Failed to unify generator interior type\");\n             let mut obligations = ok.obligations;\n \n@@ -1341,7 +1341,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // This also occurs for an enum variant on a type alias.\n             let impl_ty = self.normalize(span, tcx.type_of(impl_def_id).subst(tcx, substs));\n             let self_ty = self.normalize(span, self_ty);\n-            match self.at(&self.misc(span), self.param_env).eq(impl_ty, self_ty) {\n+            match self.at(&self.misc(span), self.param_env).eq(\n+                DefineOpaqueTypes::No,\n+                impl_ty,\n+                self_ty,\n+            ) {\n                 Ok(ok) => self.register_infer_ok_obligations(ok),\n                 Err(_) => {\n                     self.tcx.sess.delay_span_bug("}, {"sha": "7064ff6538487585b6628981bade14d47d786aa1", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -24,8 +24,8 @@ use rustc_hir_analysis::structured_errors::StructuredDiagnostic;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::error_reporting::{FailureCode, ObligationCauseExt};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::InferOk;\n use rustc_infer::infer::TypeTrace;\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, IsSuggestable, Ty};\n@@ -301,9 +301,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // 3. Check if the formal type is a supertype of the checked one\n             //    and register any such obligations for future type checks\n-            let supertype_error = self\n-                .at(&self.misc(provided_arg.span), self.param_env)\n-                .sup(formal_input_ty, coerced_ty);\n+            let supertype_error = self.at(&self.misc(provided_arg.span), self.param_env).sup(\n+                DefineOpaqueTypes::No,\n+                formal_input_ty,\n+                coerced_ty,\n+            );\n             let subtyping_error = match supertype_error {\n                 Ok(InferOk { obligations, value: () }) => {\n                     self.register_predicates(obligations);\n@@ -585,7 +587,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Using probe here, since we don't want this subtyping to affect inference.\n             let subtyping_error = self.probe(|_| {\n-                self.at(&self.misc(arg_span), self.param_env).sup(formal_input_ty, coerced_ty).err()\n+                self.at(&self.misc(arg_span), self.param_env)\n+                    .sup(DefineOpaqueTypes::No, formal_input_ty, coerced_ty)\n+                    .err()\n             });\n \n             // Same as above: if either the coerce type or the checked type is an error type,"}, {"sha": "9ecc870a70dbd949033a05b2900df13bc4a3500c", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::HirIdSet;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind};\n-use rustc_infer::infer::RegionVariableOrigin;\n+use rustc_infer::infer::{DefineOpaqueTypes, RegionVariableOrigin};\n use rustc_middle::middle::region::{self, Scope, ScopeData, YieldData};\n use rustc_middle::ty::fold::FnMutDelegate;\n use rustc_middle::ty::{self, BoundVariableKind, RvalueScopes, Ty, TyCtxt, TypeVisitableExt};\n@@ -327,7 +327,11 @@ pub fn resolve_interior<'a, 'tcx>(\n     );\n \n     // Unify the type variable inside the generator with the new witness\n-    match fcx.at(&fcx.misc(body.value.span), fcx.param_env).eq(interior, witness) {\n+    match fcx.at(&fcx.misc(body.value.span), fcx.param_env).eq(\n+        DefineOpaqueTypes::No,\n+        interior,\n+        witness,\n+    ) {\n         Ok(ok) => fcx.register_infer_ok_obligations(ok),\n         _ => bug!(\"failed to relate {interior} and {witness}\"),\n     }"}, {"sha": "a0aa43deadcfd2a2cd0ac3a3f468f41f9790ad4c", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -8,7 +8,7 @@ use rustc_hir_analysis::astconv::generics::{\n     check_generic_arg_count_for_call, create_substs_for_generic_args,\n };\n use rustc_hir_analysis::astconv::{AstConv, CreateSubstsForGenericArgsCtxt, IsMethodCall};\n-use rustc_infer::infer::{self, InferOk};\n+use rustc_infer::infer::{self, DefineOpaqueTypes, InferOk};\n use rustc_middle::traits::{ObligationCauseCode, UnifyReceiverContext};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n@@ -478,7 +478,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 substs,\n             })),\n         );\n-        match self.at(&cause, self.param_env).sup(method_self_ty, self_ty) {\n+        match self.at(&cause, self.param_env).sup(DefineOpaqueTypes::No, method_self_ty, self_ty) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n             }"}, {"sha": "8f31a79e7b39310141b7b0b11b3da41d775d056e", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -13,6 +13,7 @@ use rustc_hir_analysis::astconv::InferCtxtExt as _;\n use rustc_hir_analysis::autoderef::{self, Autoderef};\n use rustc_infer::infer::canonical::OriginalQueryValues;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n+use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n use rustc_middle::middle::stability;\n use rustc_middle::ty::fast_reject::TreatProjections;\n@@ -930,7 +931,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 if let Some(self_ty) = self_ty {\n                     if self\n                         .at(&ObligationCause::dummy(), self.param_env)\n-                        .sup(fty.inputs()[0], self_ty)\n+                        .sup(DefineOpaqueTypes::No, fty.inputs()[0], self_ty)\n                         .is_err()\n                     {\n                         return false;\n@@ -1436,9 +1437,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 CandidateSource::Trait(candidate.item.container_id(self.tcx))\n             }\n             TraitCandidate(trait_ref) => self.probe(|_| {\n-                let _ = self\n-                    .at(&ObligationCause::dummy(), self.param_env)\n-                    .sup(candidate.xform_self_ty, self_ty);\n+                let _ = self.at(&ObligationCause::dummy(), self.param_env).sup(\n+                    DefineOpaqueTypes::No,\n+                    candidate.xform_self_ty,\n+                    self_ty,\n+                );\n                 match self.select_trait_candidate(trait_ref) {\n                     Ok(Some(traits::ImplSource::UserDefined(ref impl_data))) => {\n                         // If only a single impl matches, make the error message point\n@@ -1465,10 +1468,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n         self.probe(|_| {\n             // First check that the self type can be related.\n-            let sub_obligations = match self\n-                .at(&ObligationCause::dummy(), self.param_env)\n-                .sup(probe.xform_self_ty, self_ty)\n-            {\n+            let sub_obligations = match self.at(&ObligationCause::dummy(), self.param_env).sup(\n+                DefineOpaqueTypes::No,\n+                probe.xform_self_ty,\n+                self_ty,\n+            ) {\n                 Ok(InferOk { obligations, value: () }) => obligations,\n                 Err(err) => {\n                     debug!(\"--> cannot relate self-types {:?}\", err);\n@@ -1683,7 +1687,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 if let ProbeResult::Match = result\n                     && self\n                     .at(&ObligationCause::dummy(), self.param_env)\n-                    .sup(return_ty, xform_ret_ty)\n+                    .sup(DefineOpaqueTypes::No, return_ty, xform_ret_ty)\n                     .is_err()\n                 {\n                     result = ProbeResult::BadReturnType;"}, {"sha": "0c8854e962abb85a8f55bb743156b8959dd11ba3", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 84, "deletions": 71, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -30,16 +30,20 @@ use super::*;\n use rustc_middle::ty::relate::{Relate, TypeRelation};\n use rustc_middle::ty::{Const, ImplSubject};\n \n+/// Whether we should define opaque types or just treat them opaquely.\n+///\n+/// Currently only used to prevent predicate matching from matching anything\n+/// against opaque types.\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+pub enum DefineOpaqueTypes {\n+    Yes,\n+    No,\n+}\n+\n pub struct At<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'tcx>,\n     pub cause: &'a ObligationCause<'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n-    /// Whether we should define opaque types\n-    /// or just treat them opaquely.\n-    /// Currently only used to prevent predicate\n-    /// matching from matching anything against opaque\n-    /// types.\n-    pub define_opaque_types: bool,\n }\n \n pub struct Trace<'a, 'tcx> {\n@@ -55,7 +59,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         cause: &'a ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> At<'a, 'tcx> {\n-        At { infcx: self, cause, param_env, define_opaque_types: false }\n+        At { infcx: self, cause, param_env }\n     }\n \n     /// Forks the inference context, creating a new inference context with the same inference\n@@ -84,7 +88,6 @@ impl<'tcx> InferCtxt<'tcx> {\n \n pub trait ToTrace<'tcx>: Relate<'tcx> + Copy {\n     fn to_trace(\n-        tcx: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -93,33 +96,21 @@ pub trait ToTrace<'tcx>: Relate<'tcx> + Copy {\n }\n \n impl<'a, 'tcx> At<'a, 'tcx> {\n-    pub fn define_opaque_types(self, define_opaque_types: bool) -> Self {\n-        Self { define_opaque_types, ..self }\n-    }\n-\n-    /// Hacky routine for equating two impl headers in coherence.\n-    pub fn eq_impl_headers(\n-        self,\n-        expected: &ty::ImplHeader<'tcx>,\n-        actual: &ty::ImplHeader<'tcx>,\n-    ) -> InferResult<'tcx, ()> {\n-        debug!(\"eq_impl_header({:?} = {:?})\", expected, actual);\n-        match (expected.trait_ref, actual.trait_ref) {\n-            (Some(a_ref), Some(b_ref)) => self.eq(a_ref, b_ref),\n-            (None, None) => self.eq(expected.self_ty, actual.self_ty),\n-            _ => bug!(\"mk_eq_impl_headers given mismatched impl kinds\"),\n-        }\n-    }\n-\n     /// Makes `a <: b`, where `a` may or may not be expected.\n     ///\n     /// See [`At::trace_exp`] and [`Trace::sub`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn sub_exp<T>(self, a_is_expected: bool, a: T, b: T) -> InferResult<'tcx, ()>\n+    pub fn sub_exp<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        a_is_expected: bool,\n+        a: T,\n+        b: T,\n+    ) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace_exp(a_is_expected, a, b).sub(a, b)\n+        self.trace_exp(a_is_expected, a, b).sub(define_opaque_types, a, b)\n     }\n \n     /// Makes `actual <: expected`. For example, if type-checking a\n@@ -129,54 +120,81 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     ///\n     /// See [`At::trace`] and [`Trace::sub`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn sup<T>(self, expected: T, actual: T) -> InferResult<'tcx, ()>\n+    pub fn sup<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        expected: T,\n+        actual: T,\n+    ) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.sub_exp(false, actual, expected)\n+        self.sub_exp(define_opaque_types, false, actual, expected)\n     }\n \n     /// Makes `expected <: actual`.\n     ///\n     /// See [`At::trace`] and [`Trace::sub`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn sub<T>(self, expected: T, actual: T) -> InferResult<'tcx, ()>\n+    pub fn sub<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        expected: T,\n+        actual: T,\n+    ) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.sub_exp(true, expected, actual)\n+        self.sub_exp(define_opaque_types, true, expected, actual)\n     }\n \n     /// Makes `expected <: actual`.\n     ///\n     /// See [`At::trace_exp`] and [`Trace::eq`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn eq_exp<T>(self, a_is_expected: bool, a: T, b: T) -> InferResult<'tcx, ()>\n+    pub fn eq_exp<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        a_is_expected: bool,\n+        a: T,\n+        b: T,\n+    ) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace_exp(a_is_expected, a, b).eq(a, b)\n+        self.trace_exp(a_is_expected, a, b).eq(define_opaque_types, a, b)\n     }\n \n     /// Makes `expected <: actual`.\n     ///\n     /// See [`At::trace`] and [`Trace::eq`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn eq<T>(self, expected: T, actual: T) -> InferResult<'tcx, ()>\n+    pub fn eq<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        expected: T,\n+        actual: T,\n+    ) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace(expected, actual).eq(expected, actual)\n+        self.trace(expected, actual).eq(define_opaque_types, expected, actual)\n     }\n \n-    pub fn relate<T>(self, expected: T, variance: ty::Variance, actual: T) -> InferResult<'tcx, ()>\n+    pub fn relate<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        expected: T,\n+        variance: ty::Variance,\n+        actual: T,\n+    ) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n         match variance {\n-            ty::Variance::Covariant => self.sub(expected, actual),\n-            ty::Variance::Invariant => self.eq(expected, actual),\n-            ty::Variance::Contravariant => self.sup(expected, actual),\n+            ty::Variance::Covariant => self.sub(define_opaque_types, expected, actual),\n+            ty::Variance::Invariant => self.eq(define_opaque_types, expected, actual),\n+            ty::Variance::Contravariant => self.sup(define_opaque_types, expected, actual),\n \n             // We could make this make sense but it's not readily\n             // exposed and I don't feel like dealing with it. Note\n@@ -195,11 +213,16 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     ///\n     /// See [`At::trace`] and [`Trace::lub`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn lub<T>(self, expected: T, actual: T) -> InferResult<'tcx, T>\n+    pub fn lub<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        expected: T,\n+        actual: T,\n+    ) -> InferResult<'tcx, T>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace(expected, actual).lub(expected, actual)\n+        self.trace(expected, actual).lub(define_opaque_types, expected, actual)\n     }\n \n     /// Computes the greatest-lower-bound, or mutual subtype, of two\n@@ -208,11 +231,16 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     ///\n     /// See [`At::trace`] and [`Trace::glb`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn glb<T>(self, expected: T, actual: T) -> InferResult<'tcx, T>\n+    pub fn glb<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        expected: T,\n+        actual: T,\n+    ) -> InferResult<'tcx, T>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace(expected, actual).glb(expected, actual)\n+        self.trace(expected, actual).glb(define_opaque_types, expected, actual)\n     }\n \n     /// Sets the \"trace\" values that will be used for\n@@ -233,7 +261,7 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        let trace = ToTrace::to_trace(self.infcx.tcx, self.cause, a_is_expected, a, b);\n+        let trace = ToTrace::to_trace(self.cause, a_is_expected, a, b);\n         Trace { at: self, trace, a_is_expected }\n     }\n }\n@@ -242,13 +270,13 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     /// Makes `a <: b` where `a` may or may not be expected (if\n     /// `a_is_expected` is true, then `a` is expected).\n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn sub<T>(self, a: T, b: T) -> InferResult<'tcx, ()>\n+    pub fn sub<T>(self, define_opaque_types: DefineOpaqueTypes, a: T, b: T) -> InferResult<'tcx, ()>\n     where\n         T: Relate<'tcx>,\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, define_opaque_types);\n             fields\n                 .sub(a_is_expected)\n                 .relate(a, b)\n@@ -259,13 +287,13 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     /// Makes `a == b`; the expectation is set by the call to\n     /// `trace()`.\n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn eq<T>(self, a: T, b: T) -> InferResult<'tcx, ()>\n+    pub fn eq<T>(self, define_opaque_types: DefineOpaqueTypes, a: T, b: T) -> InferResult<'tcx, ()>\n     where\n         T: Relate<'tcx>,\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, define_opaque_types);\n             fields\n                 .equate(a_is_expected)\n                 .relate(a, b)\n@@ -274,13 +302,13 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn lub<T>(self, a: T, b: T) -> InferResult<'tcx, T>\n+    pub fn lub<T>(self, define_opaque_types: DefineOpaqueTypes, a: T, b: T) -> InferResult<'tcx, T>\n     where\n         T: Relate<'tcx>,\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, define_opaque_types);\n             fields\n                 .lub(a_is_expected)\n                 .relate(a, b)\n@@ -289,13 +317,13 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn glb<T>(self, a: T, b: T) -> InferResult<'tcx, T>\n+    pub fn glb<T>(self, define_opaque_types: DefineOpaqueTypes, a: T, b: T) -> InferResult<'tcx, T>\n     where\n         T: Relate<'tcx>,\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, define_opaque_types);\n             fields\n                 .glb(a_is_expected)\n                 .relate(a, b)\n@@ -306,18 +334,17 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ImplSubject<'tcx> {\n     fn to_trace(\n-        tcx: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n         b: Self,\n     ) -> TypeTrace<'tcx> {\n         match (a, b) {\n             (ImplSubject::Trait(trait_ref_a), ImplSubject::Trait(trait_ref_b)) => {\n-                ToTrace::to_trace(tcx, cause, a_is_expected, trait_ref_a, trait_ref_b)\n+                ToTrace::to_trace(cause, a_is_expected, trait_ref_a, trait_ref_b)\n             }\n             (ImplSubject::Inherent(ty_a), ImplSubject::Inherent(ty_b)) => {\n-                ToTrace::to_trace(tcx, cause, a_is_expected, ty_a, ty_b)\n+                ToTrace::to_trace(cause, a_is_expected, ty_a, ty_b)\n             }\n             (ImplSubject::Trait(_), ImplSubject::Inherent(_))\n             | (ImplSubject::Inherent(_), ImplSubject::Trait(_)) => {\n@@ -329,7 +356,6 @@ impl<'tcx> ToTrace<'tcx> for ImplSubject<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for Ty<'tcx> {\n     fn to_trace(\n-        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -344,7 +370,6 @@ impl<'tcx> ToTrace<'tcx> for Ty<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::Region<'tcx> {\n     fn to_trace(\n-        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -356,7 +381,6 @@ impl<'tcx> ToTrace<'tcx> for ty::Region<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for Const<'tcx> {\n     fn to_trace(\n-        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -371,7 +395,6 @@ impl<'tcx> ToTrace<'tcx> for Const<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::GenericArg<'tcx> {\n     fn to_trace(\n-        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -399,7 +422,6 @@ impl<'tcx> ToTrace<'tcx> for ty::GenericArg<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::Term<'tcx> {\n     fn to_trace(\n-        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -411,7 +433,6 @@ impl<'tcx> ToTrace<'tcx> for ty::Term<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::TraitRef<'tcx> {\n     fn to_trace(\n-        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -426,7 +447,6 @@ impl<'tcx> ToTrace<'tcx> for ty::TraitRef<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::PolyTraitRef<'tcx> {\n     fn to_trace(\n-        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -441,24 +461,17 @@ impl<'tcx> ToTrace<'tcx> for ty::PolyTraitRef<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::AliasTy<'tcx> {\n     fn to_trace(\n-        tcx: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n         b: Self,\n     ) -> TypeTrace<'tcx> {\n-        let a_ty = tcx.mk_projection(a.def_id, a.substs);\n-        let b_ty = tcx.mk_projection(b.def_id, b.substs);\n-        TypeTrace {\n-            cause: cause.clone(),\n-            values: Terms(ExpectedFound::new(a_is_expected, a_ty.into(), b_ty.into())),\n-        }\n+        TypeTrace { cause: cause.clone(), values: Aliases(ExpectedFound::new(a_is_expected, a, b)) }\n     }\n }\n \n impl<'tcx> ToTrace<'tcx> for ty::FnSig<'tcx> {\n     fn to_trace(\n-        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,"}, {"sha": "156a7e68ed1a0c8de4effd0668d3497a5c1bd0ee", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -14,7 +14,7 @@ use crate::infer::canonical::{\n };\n use crate::infer::nll_relate::{TypeRelating, TypeRelatingDelegate};\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n-use crate::infer::{InferCtxt, InferOk, InferResult, NllRegionVariableOrigin};\n+use crate::infer::{DefineOpaqueTypes, InferCtxt, InferOk, InferResult, NllRegionVariableOrigin};\n use crate::traits::query::{Fallible, NoSolution};\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n use crate::traits::{PredicateObligations, TraitEngine, TraitEngineExt};\n@@ -510,7 +510,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             let b = substitute_value(self.tcx, &result_subst, b);\n             debug!(?a, ?b, \"constrain opaque type\");\n             obligations\n-                .extend(self.at(cause, param_env).define_opaque_types(true).eq(a, b)?.obligations);\n+                .extend(self.at(cause, param_env).eq(DefineOpaqueTypes::Yes, a, b)?.obligations);\n         }\n \n         Ok(InferOk { value: result_subst, obligations })\n@@ -603,20 +603,26 @@ impl<'tcx> InferCtxt<'tcx> {\n \n                 match (value1.unpack(), value2.unpack()) {\n                     (GenericArgKind::Type(v1), GenericArgKind::Type(v2)) => {\n-                        obligations\n-                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n+                        obligations.extend(\n+                            self.at(cause, param_env)\n+                                .eq(DefineOpaqueTypes::Yes, v1, v2)?\n+                                .into_obligations(),\n+                        );\n                     }\n                     (GenericArgKind::Lifetime(re1), GenericArgKind::Lifetime(re2))\n                         if re1.is_erased() && re2.is_erased() =>\n                     {\n                         // no action needed\n                     }\n                     (GenericArgKind::Lifetime(v1), GenericArgKind::Lifetime(v2)) => {\n-                        obligations\n-                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n+                        obligations.extend(\n+                            self.at(cause, param_env)\n+                                .eq(DefineOpaqueTypes::Yes, v1, v2)?\n+                                .into_obligations(),\n+                        );\n                     }\n                     (GenericArgKind::Const(v1), GenericArgKind::Const(v2)) => {\n-                        let ok = self.at(cause, param_env).eq(v1, v2)?;\n+                        let ok = self.at(cause, param_env).eq(DefineOpaqueTypes::Yes, v1, v2)?;\n                         obligations.extend(ok.into_obligations());\n                     }\n                     _ => {"}, {"sha": "bb6fdd2ffc2c9a092d06a664ca7fa36a88a7d53f", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -27,7 +27,7 @@ use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n use super::type_variable::TypeVariableValue;\n-use super::{InferCtxt, MiscVariable, TypeTrace};\n+use super::{DefineOpaqueTypes, InferCtxt, MiscVariable, TypeTrace};\n use crate::traits::{Obligation, PredicateObligations};\n use rustc_data_structures::sso::SsoHashMap;\n use rustc_hir::def_id::DefId;\n@@ -52,12 +52,7 @@ pub struct CombineFields<'infcx, 'tcx> {\n     pub cause: Option<ty::relate::Cause>,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub obligations: PredicateObligations<'tcx>,\n-    /// Whether we should define opaque types\n-    /// or just treat them opaquely.\n-    /// Currently only used to prevent predicate\n-    /// matching from matching anything against opaque\n-    /// types.\n-    pub define_opaque_types: bool,\n+    pub define_opaque_types: DefineOpaqueTypes,\n }\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "c92a74b6241a6758f0c8e2ee0a50709d6b339029", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -1,3 +1,4 @@\n+use crate::infer::DefineOpaqueTypes;\n use crate::traits::PredicateObligations;\n \n use super::combine::{CombineFields, ObligationEmittingRelation, RelationDir};\n@@ -110,7 +111,8 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n             }\n             (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n-                if self.fields.define_opaque_types && def_id.is_local() =>\n+                if self.fields.define_opaque_types == DefineOpaqueTypes::Yes\n+                    && def_id.is_local() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx"}, {"sha": "ac4986a577c6db75933aa3464661303d313f766e", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -1568,6 +1568,9 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     ValuePairs::TraitRefs(_) | ValuePairs::PolyTraitRefs(_) => {\n                         (false, Mismatch::Fixed(\"trait\"))\n                     }\n+                    ValuePairs::Aliases(infer::ExpectedFound { expected, .. }) => {\n+                        (false, Mismatch::Fixed(self.tcx.def_descr(expected.def_id)))\n+                    }\n                     ValuePairs::Regions(_) => (false, Mismatch::Fixed(\"lifetime\")),\n                 };\n                 let Some(vals) = self.values_str(values) else {\n@@ -2124,6 +2127,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         match values {\n             infer::Regions(exp_found) => self.expected_found_str(exp_found),\n             infer::Terms(exp_found) => self.expected_found_str_term(exp_found),\n+            infer::Aliases(exp_found) => self.expected_found_str(exp_found),\n             infer::TraitRefs(exp_found) => {\n                 let pretty_exp_found = ty::error::ExpectedFound {\n                     expected: exp_found.expected.print_only_trait_path(),"}, {"sha": "5c12351226aa592684d1344708fa092cdf530022", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -2,8 +2,8 @@\n \n use super::combine::{CombineFields, ObligationEmittingRelation};\n use super::lattice::{self, LatticeDir};\n-use super::InferCtxt;\n use super::Subtype;\n+use super::{DefineOpaqueTypes, InferCtxt};\n \n use crate::traits::{ObligationCause, PredicateObligations};\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n@@ -142,7 +142,7 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Glb<'combine, 'infcx,\n         Ok(())\n     }\n \n-    fn define_opaque_types(&self) -> bool {\n+    fn define_opaque_types(&self) -> DefineOpaqueTypes {\n         self.fields.define_opaque_types\n     }\n }"}, {"sha": "7f4c141b97af2fcac6b88f29fd39bdd5186e1b97", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -19,7 +19,7 @@\n \n use super::combine::ObligationEmittingRelation;\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use super::InferCtxt;\n+use super::{DefineOpaqueTypes, InferCtxt};\n \n use crate::traits::ObligationCause;\n use rustc_middle::ty::relate::RelateResult;\n@@ -36,7 +36,7 @@ pub trait LatticeDir<'f, 'tcx>: ObligationEmittingRelation<'tcx> {\n \n     fn cause(&self) -> &ObligationCause<'tcx>;\n \n-    fn define_opaque_types(&self) -> bool;\n+    fn define_opaque_types(&self) -> DefineOpaqueTypes;\n \n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n@@ -110,7 +110,7 @@ where\n         ) if a_def_id == b_def_id => infcx.super_combine_tys(this, a, b),\n         (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n         | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n-            if this.define_opaque_types() && def_id.is_local() =>\n+            if this.define_opaque_types() == DefineOpaqueTypes::Yes && def_id.is_local() =>\n         {\n             this.register_obligations(\n                 infcx"}, {"sha": "dbef42db8f1bfe4af6d9870392c2f6b8a1d69c81", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -2,8 +2,8 @@\n \n use super::combine::{CombineFields, ObligationEmittingRelation};\n use super::lattice::{self, LatticeDir};\n-use super::InferCtxt;\n use super::Subtype;\n+use super::{DefineOpaqueTypes, InferCtxt};\n \n use crate::traits::{ObligationCause, PredicateObligations};\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n@@ -142,7 +142,7 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Lub<'combine, 'infcx,\n         Ok(())\n     }\n \n-    fn define_opaque_types(&self) -> bool {\n+    fn define_opaque_types(&self) -> DefineOpaqueTypes {\n         self.fields.define_opaque_types\n     }\n }"}, {"sha": "96e7c095d341c2fb6c37c77bb7fbd383db58795b", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -1,3 +1,4 @@\n+pub use self::at::DefineOpaqueTypes;\n pub use self::freshen::TypeFreshener;\n pub use self::lexical_region_resolve::RegionResolutionError;\n pub use self::LateBoundRegionConversionTime::*;\n@@ -338,6 +339,7 @@ pub struct InferCtxt<'tcx> {\n pub enum ValuePairs<'tcx> {\n     Regions(ExpectedFound<ty::Region<'tcx>>),\n     Terms(ExpectedFound<ty::Term<'tcx>>),\n+    Aliases(ExpectedFound<ty::AliasTy<'tcx>>),\n     TraitRefs(ExpectedFound<ty::TraitRef<'tcx>>),\n     PolyTraitRefs(ExpectedFound<ty::PolyTraitRef<'tcx>>),\n     Sigs(ExpectedFound<ty::FnSig<'tcx>>),\n@@ -729,7 +731,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         &'a self,\n         trace: TypeTrace<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        define_opaque_types: bool,\n+        define_opaque_types: DefineOpaqueTypes,\n     ) -> CombineFields<'a, 'tcx> {\n         CombineFields {\n             infcx: self,\n@@ -864,15 +866,15 @@ impl<'tcx> InferCtxt<'tcx> {\n         T: at::ToTrace<'tcx>,\n     {\n         let origin = &ObligationCause::dummy();\n-        self.probe(|_| self.at(origin, param_env).sub(a, b).is_ok())\n+        self.probe(|_| self.at(origin, param_env).sub(DefineOpaqueTypes::No, a, b).is_ok())\n     }\n \n     pub fn can_eq<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> bool\n     where\n         T: at::ToTrace<'tcx>,\n     {\n         let origin = &ObligationCause::dummy();\n-        self.probe(|_| self.at(origin, param_env).eq(a, b).is_ok())\n+        self.probe(|_| self.at(origin, param_env).eq(DefineOpaqueTypes::No, a, b).is_ok())\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n@@ -967,7 +969,8 @@ impl<'tcx> InferCtxt<'tcx> {\n             let ty::SubtypePredicate { a_is_expected, a, b } =\n                 self.instantiate_binder_with_placeholders(predicate);\n \n-            let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n+            let ok =\n+                self.at(cause, param_env).sub_exp(DefineOpaqueTypes::No, a_is_expected, a, b)?;\n \n             Ok(ok.unit())\n         }))"}, {"sha": "ed4bc594d1a54d57348d0e7f70a5d509301efdf7", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -1,3 +1,5 @@\n+use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use super::{DefineOpaqueTypes, InferResult};\n use crate::errors::OpaqueHiddenTypeDiag;\n use crate::infer::{DefiningAnchor, InferCtxt, InferOk};\n use crate::traits;\n@@ -16,18 +18,13 @@ use rustc_middle::ty::{\n     TypeVisitable, TypeVisitableExt, TypeVisitor,\n };\n use rustc_span::Span;\n-\n use std::ops::ControlFlow;\n \n-pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n-\n mod table;\n \n+pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n pub use table::{OpaqueTypeStorage, OpaqueTypeTable};\n \n-use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use super::InferResult;\n-\n /// Information about the opaque types whose values we\n /// are inferring in this function (these are the `impl Trait` that\n /// appear in the return type).\n@@ -547,8 +544,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         if let Some(prev) = prev {\n             obligations = self\n                 .at(&cause, param_env)\n-                .define_opaque_types(true)\n-                .eq_exp(a_is_expected, prev, hidden_ty)?\n+                .eq_exp(DefineOpaqueTypes::Yes, a_is_expected, prev, hidden_ty)?\n                 .obligations;\n         }\n "}, {"sha": "230cadb11842e506a0ca4ff735d3db754c9a1604", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -1,5 +1,5 @@\n use super::combine::{CombineFields, RelationDir};\n-use super::{ObligationEmittingRelation, SubregionOrigin};\n+use super::{DefineOpaqueTypes, ObligationEmittingRelation, SubregionOrigin};\n \n use crate::traits::{Obligation, PredicateObligations};\n use rustc_middle::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n@@ -138,7 +138,8 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n             }\n             (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n-                if self.fields.define_opaque_types && def_id.is_local() =>\n+                if self.fields.define_opaque_types == DefineOpaqueTypes::Yes\n+                    && def_id.is_local() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx"}, {"sha": "308c02929ca42b2e469d5c01caf5a3ff55b3c086", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -1390,7 +1390,7 @@ pub struct UnusedOp<'a> {\n     pub op: &'a str,\n     #[label]\n     pub label: Span,\n-    #[suggestion(style = \"verbose\", code = \"let _ = \", applicability = \"machine-applicable\")]\n+    #[suggestion(style = \"verbose\", code = \"let _ = \", applicability = \"maybe-incorrect\")]\n     pub suggestion: Span,\n }\n \n@@ -1434,17 +1434,15 @@ pub struct UnusedDef<'a, 'b> {\n }\n \n #[derive(Subdiagnostic)]\n-pub enum UnusedDefSuggestion {\n-    #[suggestion(\n-        lint_suggestion,\n-        style = \"verbose\",\n-        code = \"let _ = \",\n-        applicability = \"machine-applicable\"\n-    )]\n-    Default {\n-        #[primary_span]\n-        span: Span,\n-    },\n+#[suggestion(\n+    lint_suggestion,\n+    style = \"verbose\",\n+    code = \"let _ = \",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub struct UnusedDefSuggestion {\n+    #[primary_span]\n+    pub span: Span,\n }\n \n // Needed because of def_path_str"}, {"sha": "faca61fc29bf97bcfc5b75380415b8753ea2376e", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -123,7 +123,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n         let must_use_result = is_ty_must_use(cx, ty, &expr, expr.span);\n         let type_lint_emitted_or_suppressed = match must_use_result {\n             Some(path) => {\n-                emit_must_use_untranslated(cx, &path, \"\", \"\", 1);\n+                emit_must_use_untranslated(cx, &path, \"\", \"\", 1, false);\n                 true\n             }\n             None => false,\n@@ -358,6 +358,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         descr_pre_path,\n                         descr_post_path,\n                         1,\n+                        false,\n                     )\n                 })\n                 .is_some()\n@@ -370,27 +371,30 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             descr_pre: &str,\n             descr_post: &str,\n             plural_len: usize,\n+            is_inner: bool,\n         ) {\n             let plural_suffix = pluralize!(plural_len);\n \n             match path {\n                 MustUsePath::Suppressed => {}\n                 MustUsePath::Boxed(path) => {\n                     let descr_pre = &format!(\"{}boxed \", descr_pre);\n-                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len, true);\n                 }\n                 MustUsePath::Opaque(path) => {\n                     let descr_pre = &format!(\"{}implementer{} of \", descr_pre, plural_suffix);\n-                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len, true);\n                 }\n                 MustUsePath::TraitObject(path) => {\n                     let descr_post = &format!(\" trait object{}{}\", plural_suffix, descr_post);\n-                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len, true);\n                 }\n                 MustUsePath::TupleElement(elems) => {\n                     for (index, path) in elems {\n                         let descr_post = &format!(\" in tuple element {}\", index);\n-                        emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                        emit_must_use_untranslated(\n+                            cx, path, descr_pre, descr_post, plural_len, true,\n+                        );\n                     }\n                 }\n                 MustUsePath::Array(path, len) => {\n@@ -401,6 +405,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         descr_pre,\n                         descr_post,\n                         plural_len.saturating_add(usize::try_from(*len).unwrap_or(usize::MAX)),\n+                        true,\n                     );\n                 }\n                 MustUsePath::Closure(span) => {\n@@ -418,19 +423,6 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     );\n                 }\n                 MustUsePath::Def(span, def_id, reason) => {\n-                    let suggestion = if matches!(\n-                        cx.tcx.get_diagnostic_name(*def_id),\n-                        Some(sym::add)\n-                            | Some(sym::sub)\n-                            | Some(sym::mul)\n-                            | Some(sym::div)\n-                            | Some(sym::rem)\n-                            | Some(sym::neg),\n-                    ) {\n-                        Some(UnusedDefSuggestion::Default { span: span.shrink_to_lo() })\n-                    } else {\n-                        None\n-                    };\n                     cx.emit_spanned_lint(\n                         UNUSED_MUST_USE,\n                         *span,\n@@ -440,7 +432,8 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                             cx,\n                             def_id: *def_id,\n                             note: *reason,\n-                            suggestion,\n+                            suggestion: (!is_inner)\n+                                .then_some(UnusedDefSuggestion { span: span.shrink_to_lo() }),\n                         },\n                     );\n                 }"}, {"sha": "a28ecfa9bdc47dc85adcefc03048facfc1551912", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -1081,7 +1081,7 @@ pub enum Rvalue<'tcx> {\n     /// Same as `BinaryOp`, but yields `(T, bool)` with a `bool` indicating an error condition.\n     ///\n     /// For addition, subtraction, and multiplication on integers the error condition is set when\n-    /// the infinite precision result would be unequal to the actual result.\n+    /// the infinite precision result would not be equal to the actual result.\n     ///\n     /// Other combinations of types and operators are unsupported.\n     CheckedBinaryOp(BinOp, Box<(Operand<'tcx>, Operand<'tcx>)>),"}, {"sha": "2cd791574417a89dc5ff57ee897d524688139c49", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -2215,7 +2215,7 @@ rustc_queries! {\n     }\n \n     /// Used in `super_combine_consts` to ICE if the type of the two consts are definitely not going to end up being\n-    /// equal to eachother. This might return `Ok` even if the types are unequal, but will never return `Err` if\n+    /// equal to eachother. This might return `Ok` even if the types are not equal, but will never return `Err` if\n     /// the types might be equal.\n     query check_tys_might_be_eq(arg: Canonical<'tcx, (ty::ParamEnv<'tcx>, Ty<'tcx>, Ty<'tcx>)>) -> Result<(), NoSolution> {\n         desc { \"check whether two const param are definitely not equal to eachother\"}"}, {"sha": "a7f38884ebcc4390b3f6df681feb92e0085e80ef", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -237,7 +237,7 @@ impl ScalarInt {\n     }\n \n     /// Tries to convert the `ScalarInt` to an unsigned integer of the given size.\n-    /// Fails if the size of the `ScalarInt` is unequal to `size` and returns the\n+    /// Fails if the size of the `ScalarInt` is not equal to `size` and returns the\n     /// `ScalarInt`s size in that case.\n     #[inline]\n     pub fn try_to_uint(self, size: Size) -> Result<u128, Size> {\n@@ -297,7 +297,7 @@ impl ScalarInt {\n     }\n \n     /// Tries to convert the `ScalarInt` to a signed integer of the given size.\n-    /// Fails if the size of the `ScalarInt` is unequal to `size` and returns the\n+    /// Fails if the size of the `ScalarInt` is not equal to `size` and returns the\n     /// `ScalarInt`s size in that case.\n     #[inline]\n     pub fn try_to_int(self, size: Size) -> Result<i128, Size> {\n@@ -306,35 +306,35 @@ impl ScalarInt {\n     }\n \n     /// Tries to convert the `ScalarInt` to i8.\n-    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 1 }`\n+    /// Fails if the size of the `ScalarInt` is not equal to `Size { raw: 1 }`\n     /// and returns the `ScalarInt`s size in that case.\n     pub fn try_to_i8(self) -> Result<i8, Size> {\n         self.try_to_int(Size::from_bits(8)).map(|v| i8::try_from(v).unwrap())\n     }\n \n     /// Tries to convert the `ScalarInt` to i16.\n-    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 2 }`\n+    /// Fails if the size of the `ScalarInt` is not equal to `Size { raw: 2 }`\n     /// and returns the `ScalarInt`s size in that case.\n     pub fn try_to_i16(self) -> Result<i16, Size> {\n         self.try_to_int(Size::from_bits(16)).map(|v| i16::try_from(v).unwrap())\n     }\n \n     /// Tries to convert the `ScalarInt` to i32.\n-    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 4 }`\n+    /// Fails if the size of the `ScalarInt` is not equal to `Size { raw: 4 }`\n     /// and returns the `ScalarInt`s size in that case.\n     pub fn try_to_i32(self) -> Result<i32, Size> {\n         self.try_to_int(Size::from_bits(32)).map(|v| i32::try_from(v).unwrap())\n     }\n \n     /// Tries to convert the `ScalarInt` to i64.\n-    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 8 }`\n+    /// Fails if the size of the `ScalarInt` is not equal to `Size { raw: 8 }`\n     /// and returns the `ScalarInt`s size in that case.\n     pub fn try_to_i64(self) -> Result<i64, Size> {\n         self.try_to_int(Size::from_bits(64)).map(|v| i64::try_from(v).unwrap())\n     }\n \n     /// Tries to convert the `ScalarInt` to i128.\n-    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 16 }`\n+    /// Fails if the size of the `ScalarInt` is not equal to `Size { raw: 16 }`\n     /// and returns the `ScalarInt`s size in that case.\n     pub fn try_to_i128(self) -> Result<i128, Size> {\n         self.try_to_int(Size::from_bits(128)).map(|v| i128::try_from(v).unwrap())"}, {"sha": "e4694809cd1a2c90ec60978c9b73a7b30248e205", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -71,6 +71,7 @@ use rustc_type_ir::WithCachedTypeInfo;\n use rustc_type_ir::{CollectAndApply, DynKind, Interner, TypeFlags};\n \n use std::any::Any;\n+use std::assert_matches::debug_assert_matches;\n use std::borrow::Borrow;\n use std::cmp::Ordering;\n use std::fmt;\n@@ -2049,6 +2050,12 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_alias(self, kind: ty::AliasKind, alias_ty: ty::AliasTy<'tcx>) -> Ty<'tcx> {\n+        debug_assert_matches!(\n+            (kind, self.def_kind(alias_ty.def_id)),\n+            (ty::Opaque, DefKind::OpaqueTy)\n+                | (ty::Projection, DefKind::AssocTy)\n+                | (ty::Opaque | ty::Projection, DefKind::ImplTraitPlaceholder)\n+        );\n         self.mk_ty_from_kind(Alias(kind, alias_ty))\n     }\n "}, {"sha": "df7681dc4267b5d1d3ff4976b1f2797cdb078427", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -1289,25 +1289,41 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 PathSource::Expr(_) | PathSource::TupleStruct(..) | PathSource::Pat => {\n                     let span = find_span(&source, err);\n                     err.span_label(self.r.def_span(def_id), &format!(\"`{path_str}` defined here\"));\n-                    let (tail, descr, applicability) = match source {\n-                        PathSource::Pat | PathSource::TupleStruct(..) => {\n-                            (\"\", \"pattern\", Applicability::MachineApplicable)\n-                        }\n-                        _ => (\": val\", \"literal\", Applicability::HasPlaceholders),\n-                    };\n \n+                    let (tail, descr, applicability, old_fields) = match source {\n+                        PathSource::Pat => (\"\", \"pattern\", Applicability::MachineApplicable, None),\n+                        PathSource::TupleStruct(_, args) => (\n+                            \"\",\n+                            \"pattern\",\n+                            Applicability::MachineApplicable,\n+                            Some(\n+                                args.iter()\n+                                    .map(|a| self.r.tcx.sess.source_map().span_to_snippet(*a).ok())\n+                                    .collect::<Vec<Option<String>>>(),\n+                            ),\n+                        ),\n+                        _ => (\": val\", \"literal\", Applicability::HasPlaceholders, None),\n+                    };\n                     let field_ids = self.r.field_def_ids(def_id);\n                     let (fields, applicability) = match field_ids {\n-                        Some(field_ids) => (\n-                            field_ids\n-                                .iter()\n-                                .map(|&field_id| {\n-                                    format!(\"{}{tail}\", self.r.tcx.item_name(field_id))\n-                                })\n-                                .collect::<Vec<String>>()\n-                                .join(\", \"),\n-                            applicability,\n-                        ),\n+                        Some(field_ids) => {\n+                            let fields = field_ids.iter().map(|&id| self.r.tcx.item_name(id));\n+\n+                            let fields = if let Some(old_fields) = old_fields {\n+                                fields\n+                                    .enumerate()\n+                                    .map(|(idx, new)| (new, old_fields.get(idx)))\n+                                    .map(|(new, old)| {\n+                                        let new = new.to_ident_string();\n+                                        if let Some(Some(old)) = old && new != *old { format!(\"{}: {}\", new, old) } else { new }\n+                                    })\n+                                    .collect::<Vec<String>>()\n+                            } else {\n+                                fields.map(|f| format!(\"{f}{tail}\")).collect::<Vec<String>>()\n+                            };\n+\n+                            (fields.join(\", \"), applicability)\n+                        }\n                         None => (\"/* fields */\".to_string(), Applicability::HasPlaceholders),\n                     };\n                     let pad = match field_ids {"}, {"sha": "856f1eec4433bb1c49435e7b169aca28fbab8df3", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -2,7 +2,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk, LateBoundRegionConversionTime};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n@@ -144,7 +144,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution> {\n         self.infcx\n             .at(&ObligationCause::dummy(), param_env)\n-            .eq(lhs, rhs)\n+            .eq(DefineOpaqueTypes::No, lhs, rhs)\n             .map(|InferOk { value: (), obligations }| {\n                 obligations.into_iter().map(|o| o.into()).collect()\n             })"}, {"sha": "a873060687d359a1a808a0752ad02b931022976e", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -19,7 +19,7 @@ use std::mem;\n \n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n-use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::traits::solve::{\n     CanonicalGoal, CanonicalResponse, Certainty, ExternalConstraints, ExternalConstraintsData,\n@@ -268,7 +268,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             let InferOk { value: (), obligations } = self\n                 .infcx\n                 .at(&ObligationCause::dummy(), goal.param_env)\n-                .sub(goal.predicate.a, goal.predicate.b)?;\n+                .sub(DefineOpaqueTypes::No, goal.predicate.a, goal.predicate.b)?;\n             self.evaluate_all_and_make_canonical_response(\n                 obligations.into_iter().map(|pred| pred.into()).collect(),\n             )"}, {"sha": "1870d3a2daf3235c2c31bdce5d231b1c2bc7b9ab", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -7,6 +7,7 @@ use crate::errors::UnableToConstructConstantValue;\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::InferCtxt;\n use crate::traits::project::ProjectAndUnifyResult;\n+use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::visit::TypeVisitableExt;\n@@ -814,7 +815,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n \n                     match (evaluate(c1), evaluate(c2)) {\n                         (Ok(c1), Ok(c2)) => {\n-                            match selcx.infcx.at(&obligation.cause, obligation.param_env).eq(c1, c2)\n+                            match selcx.infcx.at(&obligation.cause, obligation.param_env).eq(DefineOpaqueTypes::No,c1, c2)\n                             {\n                                 Ok(_) => (),\n                                 Err(_) => return false,"}, {"sha": "f4cfe4ec0b0ce65eb37b2a4a3dd9f3bb305d1b69", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -17,7 +17,7 @@ use crate::traits::{\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n-use rustc_infer::infer::{DefiningAnchor, InferCtxt, TyCtxtInferExt};\n+use rustc_infer::infer::{DefineOpaqueTypes, DefiningAnchor, InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::util;\n use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n@@ -181,7 +181,7 @@ fn overlap_within_probe<'cx, 'tcx>(\n     let impl1_header = with_fresh_ty_vars(selcx, param_env, impl1_def_id);\n     let impl2_header = with_fresh_ty_vars(selcx, param_env, impl2_def_id);\n \n-    let obligations = equate_impl_headers(selcx, &impl1_header, &impl2_header)?;\n+    let obligations = equate_impl_headers(selcx.infcx, &impl1_header, &impl2_header)?;\n     debug!(\"overlap: unification check succeeded\");\n \n     if overlap_mode.use_implicit_negative() {\n@@ -207,20 +207,25 @@ fn overlap_within_probe<'cx, 'tcx>(\n     Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })\n }\n \n-fn equate_impl_headers<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    impl1_header: &ty::ImplHeader<'tcx>,\n-    impl2_header: &ty::ImplHeader<'tcx>,\n+#[instrument(level = \"debug\", skip(infcx), ret)]\n+fn equate_impl_headers<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    impl1: &ty::ImplHeader<'tcx>,\n+    impl2: &ty::ImplHeader<'tcx>,\n ) -> Option<PredicateObligations<'tcx>> {\n-    // Do `a` and `b` unify? If not, no overlap.\n-    debug!(\"equate_impl_headers(impl1_header={:?}, impl2_header={:?}\", impl1_header, impl2_header);\n-    selcx\n-        .infcx\n-        .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n-        .define_opaque_types(true)\n-        .eq_impl_headers(impl1_header, impl2_header)\n-        .map(|infer_ok| infer_ok.obligations)\n-        .ok()\n+    let result = match (impl1.trait_ref, impl2.trait_ref) {\n+        (Some(impl1_ref), Some(impl2_ref)) => infcx\n+            .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n+            .eq(DefineOpaqueTypes::Yes, impl1_ref, impl2_ref),\n+        (None, None) => infcx.at(&ObligationCause::dummy(), ty::ParamEnv::empty()).eq(\n+            DefineOpaqueTypes::Yes,\n+            impl1.self_ty,\n+            impl2.self_ty,\n+        ),\n+        _ => bug!(\"mk_eq_impl_headers given mismatched impl kinds\"),\n+    };\n+\n+    result.map(|infer_ok| infer_ok.obligations).ok()\n }\n \n /// Given impl1 and impl2 check if both impls can be satisfied by a common type (including\n@@ -325,7 +330,7 @@ fn equate<'tcx>(\n ) -> bool {\n     // do the impls unify? If not, not disjoint.\n     let Ok(InferOk { obligations: more_obligations, .. }) =\n-        infcx.at(&ObligationCause::dummy(), impl_env).eq(subject1, subject2)\n+        infcx.at(&ObligationCause::dummy(), impl_env).eq(DefineOpaqueTypes::No,subject1, subject2)\n     else {\n         debug!(\"explicit_disjoint: {:?} does not unify with {:?}\", subject1, subject2);\n         return true;"}, {"sha": "8acc31cd410bdfa4d0372927671503989773144b", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -11,7 +11,7 @@ use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{\n     Canonical, CanonicalQueryResponse, CanonicalVarValues, QueryResponse,\n };\n-use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk};\n use rustc_infer::traits::query::Fallible;\n use rustc_infer::traits::{\n     FulfillmentError, Obligation, ObligationCause, PredicateObligation, TraitEngineExt as _,\n@@ -128,8 +128,7 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n     {\n         self.infcx\n             .at(cause, param_env)\n-            .define_opaque_types(true)\n-            .eq_exp(a_is_expected, a, b)\n+            .eq_exp(DefineOpaqueTypes::Yes, a_is_expected, a, b)\n             .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n \n@@ -142,8 +141,7 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n     ) -> Result<(), TypeError<'tcx>> {\n         self.infcx\n             .at(cause, param_env)\n-            .define_opaque_types(true)\n-            .eq(expected, actual)\n+            .eq(DefineOpaqueTypes::Yes, expected, actual)\n             .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n \n@@ -157,8 +155,7 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n     ) -> Result<(), TypeError<'tcx>> {\n         self.infcx\n             .at(cause, param_env)\n-            .define_opaque_types(true)\n-            .sub(expected, actual)\n+            .sub(DefineOpaqueTypes::Yes, expected, actual)\n             .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n \n@@ -172,8 +169,7 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n     ) -> Result<(), TypeError<'tcx>> {\n         self.infcx\n             .at(cause, param_env)\n-            .define_opaque_types(true)\n-            .sup(expected, actual)\n+            .sup(DefineOpaqueTypes::Yes, expected, actual)\n             .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n "}, {"sha": "1aaadae12ddd9641f353de2bbcb2147ace6997ac", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -2,6 +2,7 @@ use crate::infer::{InferCtxt, TyOrConstInferVar};\n use rustc_data_structures::obligation_forest::ProcessResult;\n use rustc_data_structures::obligation_forest::{Error, ForestObligation, Outcome};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n+use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::traits::ProjectionCacheKey;\n use rustc_infer::traits::{SelectionError, TraitEngine, TraitObligation};\n use rustc_middle::mir::interpret::ErrorHandled;\n@@ -515,7 +516,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                                 if let Ok(new_obligations) = infcx\n                                     .at(&obligation.cause, obligation.param_env)\n                                     .trace(c1, c2)\n-                                    .eq(a.substs, b.substs)\n+                                    .eq(DefineOpaqueTypes::No, a.substs, b.substs)\n                                 {\n                                     return ProcessResult::Changed(mk_pending(\n                                         new_obligations.into_obligations(),\n@@ -524,8 +525,9 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                             }\n                             (_, Unevaluated(_)) | (Unevaluated(_), _) => (),\n                             (_, _) => {\n-                                if let Ok(new_obligations) =\n-                                    infcx.at(&obligation.cause, obligation.param_env).eq(c1, c2)\n+                                if let Ok(new_obligations) = infcx\n+                                    .at(&obligation.cause, obligation.param_env)\n+                                    .eq(DefineOpaqueTypes::No, c1, c2)\n                                 {\n                                     return ProcessResult::Changed(mk_pending(\n                                         new_obligations.into_obligations(),\n@@ -565,12 +567,11 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n \n                     match (evaluate(c1), evaluate(c2)) {\n                         (Ok(c1), Ok(c2)) => {\n-                            match self\n-                                .selcx\n-                                .infcx\n-                                .at(&obligation.cause, obligation.param_env)\n-                                .eq(c1, c2)\n-                            {\n+                            match self.selcx.infcx.at(&obligation.cause, obligation.param_env).eq(\n+                                DefineOpaqueTypes::No,\n+                                c1,\n+                                c2,\n+                            ) {\n                                 Ok(inf_ok) => {\n                                     ProcessResult::Changed(mk_pending(inf_ok.into_obligations()))\n                                 }\n@@ -610,12 +611,11 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                     bug!(\"AliasEq is only used for new solver\")\n                 }\n                 ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n-                    match self\n-                        .selcx\n-                        .infcx\n-                        .at(&obligation.cause, obligation.param_env)\n-                        .eq(ct.ty(), ty)\n-                    {\n+                    match self.selcx.infcx.at(&obligation.cause, obligation.param_env).eq(\n+                        DefineOpaqueTypes::No,\n+                        ct.ty(),\n+                        ty,\n+                    ) {\n                         Ok(inf_ok) => ProcessResult::Changed(mk_pending(inf_ok.into_obligations())),\n                         Err(_) => ProcessResult::Error(FulfillmentErrorCode::CodeSelectionError(\n                             SelectionError::Unimplemented,"}, {"sha": "0f0cccea13075a4ac5bcb67064b961dd1fb99aa6", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -28,6 +28,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::at::At;\n use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n+use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::traits::ImplSourceBuiltinData;\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n@@ -285,12 +286,12 @@ fn project_and_unify_type<'cx, 'tcx>(\n         );\n     obligations.extend(new);\n \n-    match infcx\n-        .at(&obligation.cause, obligation.param_env)\n-        // This is needed to support nested opaque types like `impl Fn() -> impl Trait`\n-        .define_opaque_types(true)\n-        .eq(normalized, actual)\n-    {\n+    // Need to define opaque types to support nested opaque types like `impl Fn() -> impl Trait`\n+    match infcx.at(&obligation.cause, obligation.param_env).eq(\n+        DefineOpaqueTypes::Yes,\n+        normalized,\n+        actual,\n+    ) {\n         Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n             obligations.extend(inferred_obligations);\n             ProjectAndUnifyResult::Holds(obligations)\n@@ -467,6 +468,11 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n             return ty;\n         }\n \n+        let (kind, data) = match *ty.kind() {\n+            ty::Alias(kind, alias_ty) => (kind, alias_ty),\n+            _ => return ty.super_fold_with(self),\n+        };\n+\n         // We try to be a little clever here as a performance optimization in\n         // cases where there are nested projections under binders.\n         // For example:\n@@ -490,13 +496,11 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n         // replace bound vars if the current type is a `Projection` and we need\n         // to make sure we don't forget to fold the substs regardless.\n \n-        match *ty.kind() {\n+        match kind {\n             // This is really important. While we *can* handle this, this has\n             // severe performance implications for large opaque types with\n             // late-bound regions. See `issue-88862` benchmark.\n-            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. })\n-                if !substs.has_escaping_bound_vars() =>\n-            {\n+            ty::Opaque if !data.substs.has_escaping_bound_vars() => {\n                 // Only normalize `impl Trait` outside of type inference, usually in codegen.\n                 match self.param_env.reveal() {\n                     Reveal::UserFacing => ty.super_fold_with(self),\n@@ -512,8 +516,8 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n                             );\n                         }\n \n-                        let substs = substs.fold_with(self);\n-                        let generic_ty = self.interner().type_of(def_id);\n+                        let substs = data.substs.fold_with(self);\n+                        let generic_ty = self.interner().type_of(data.def_id);\n                         let concrete_ty = generic_ty.subst(self.interner(), substs);\n                         self.depth += 1;\n                         let folded_ty = self.fold_ty(concrete_ty);\n@@ -522,8 +526,9 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n                     }\n                 }\n             }\n+            ty::Opaque => ty.super_fold_with(self),\n \n-            ty::Alias(ty::Projection, data) if !data.has_escaping_bound_vars() => {\n+            ty::Projection if !data.has_escaping_bound_vars() => {\n                 // This branch is *mostly* just an optimization: when we don't\n                 // have escaping bound vars, we don't need to replace them with\n                 // placeholders (see branch below). *Also*, we know that we can\n@@ -562,7 +567,7 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n                 normalized_ty.ty().unwrap()\n             }\n \n-            ty::Alias(ty::Projection, data) => {\n+            ty::Projection => {\n                 // If there are escaping bound vars, we temporarily replace the\n                 // bound vars with placeholders. Note though, that in the case\n                 // that we still can't project for whatever reason (e.g. self\n@@ -611,8 +616,6 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n                 );\n                 normalized_ty\n             }\n-\n-            _ => ty.super_fold_with(self),\n         }\n     }\n \n@@ -2064,7 +2067,11 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n \n     debug!(?cache_projection, ?obligation_projection);\n \n-    match infcx.at(cause, param_env).eq(cache_projection, obligation_projection) {\n+    match infcx.at(cause, param_env).eq(\n+        DefineOpaqueTypes::No,\n+        cache_projection,\n+        obligation_projection,\n+    ) {\n         Ok(InferOk { value: _, obligations }) => {\n             nested_obligations.extend(obligations);\n             assoc_ty_own_obligations(selcx, obligation, &mut nested_obligations);"}, {"sha": "a986a9b6a71b13597cd72125de3684527845408b", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 36, "deletions": 67, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -197,23 +197,30 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n             return Ok(*ty);\n         }\n \n+        let (kind, data) = match *ty.kind() {\n+            ty::Alias(kind, data) => (kind, data),\n+            _ => {\n+                let res = ty.try_super_fold_with(self)?;\n+                self.cache.insert(ty, res);\n+                return Ok(res);\n+            }\n+        };\n+\n         // See note in `rustc_trait_selection::traits::project` about why we\n         // wait to fold the substs.\n \n         // Wrap this in a closure so we don't accidentally return from the outer function\n-        let res = match *ty.kind() {\n+        let res = match kind {\n             // This is really important. While we *can* handle this, this has\n             // severe performance implications for large opaque types with\n             // late-bound regions. See `issue-88862` benchmark.\n-            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. })\n-                if !substs.has_escaping_bound_vars() =>\n-            {\n+            ty::Opaque if !data.substs.has_escaping_bound_vars() => {\n                 // Only normalize `impl Trait` outside of type inference, usually in codegen.\n                 match self.param_env.reveal() {\n                     Reveal::UserFacing => ty.try_super_fold_with(self)?,\n \n                     Reveal::All => {\n-                        let substs = substs.try_fold_with(self)?;\n+                        let substs = data.substs.try_fold_with(self)?;\n                         let recursion_limit = self.interner().recursion_limit();\n                         if !recursion_limit.value_within_limit(self.anon_depth) {\n                             // A closure or generator may have itself as in its upvars.\n@@ -228,7 +235,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                             return ty.try_super_fold_with(self);\n                         }\n \n-                        let generic_ty = self.interner().type_of(def_id);\n+                        let generic_ty = self.interner().type_of(data.def_id);\n                         let concrete_ty = generic_ty.subst(self.interner(), substs);\n                         self.anon_depth += 1;\n                         if concrete_ty == ty {\n@@ -248,62 +255,22 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                 }\n             }\n \n-            ty::Alias(ty::Projection, data) if !data.has_escaping_bound_vars() => {\n-                // This branch is just an optimization: when we don't have escaping bound vars,\n-                // we don't need to replace them with placeholders (see branch below).\n-\n-                let tcx = self.infcx.tcx;\n-                let data = data.try_fold_with(self)?;\n-\n-                let mut orig_values = OriginalQueryValues::default();\n-                // HACK(matthewjasper) `'static` is special-cased in selection,\n-                // so we cannot canonicalize it.\n-                let c_data = self\n-                    .infcx\n-                    .canonicalize_query_keep_static(self.param_env.and(data), &mut orig_values);\n-                debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n-                debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n-                let result = tcx.normalize_projection_ty(c_data)?;\n-                // We don't expect ambiguity.\n-                if result.is_ambiguous() {\n-                    // Rustdoc normalizes possibly not well-formed types, so only\n-                    // treat this as a bug if we're not in rustdoc.\n-                    if !tcx.sess.opts.actually_rustdoc {\n-                        tcx.sess.delay_span_bug(\n-                            DUMMY_SP,\n-                            format!(\"unexpected ambiguity: {:?} {:?}\", c_data, result),\n-                        );\n-                    }\n-                    return Err(NoSolution);\n-                }\n-                let InferOk { value: result, obligations } =\n-                    self.infcx.instantiate_query_response_and_region_obligations(\n-                        self.cause,\n-                        self.param_env,\n-                        &orig_values,\n-                        result,\n-                    )?;\n-                debug!(\"QueryNormalizer: result = {:#?}\", result);\n-                debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n-                self.obligations.extend(obligations);\n-\n-                let res = result.normalized_ty;\n-                // `tcx.normalize_projection_ty` may normalize to a type that still has\n-                // unevaluated consts, so keep normalizing here if that's the case.\n-                if res != ty && res.has_type_flags(ty::TypeFlags::HAS_CT_PROJECTION) {\n-                    res.try_super_fold_with(self)?\n-                } else {\n-                    res\n-                }\n-            }\n+            ty::Opaque => ty.try_super_fold_with(self)?,\n \n-            ty::Alias(ty::Projection, data) => {\n+            ty::Projection => {\n                 // See note in `rustc_trait_selection::traits::project`\n \n                 let tcx = self.infcx.tcx;\n                 let infcx = self.infcx;\n-                let (data, mapped_regions, mapped_types, mapped_consts) =\n-                    BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n+                // Just an optimization: When we don't have escaping bound vars,\n+                // we don't need to replace them with placeholders.\n+                let (data, maps) = if data.has_escaping_bound_vars() {\n+                    let (data, mapped_regions, mapped_types, mapped_consts) =\n+                        BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n+                    (data, Some((mapped_regions, mapped_types, mapped_consts)))\n+                } else {\n+                    (data, None)\n+                };\n                 let data = data.try_fold_with(self)?;\n \n                 let mut orig_values = OriginalQueryValues::default();\n@@ -337,14 +304,18 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                 debug!(\"QueryNormalizer: result = {:#?}\", result);\n                 debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n                 self.obligations.extend(obligations);\n-                let res = PlaceholderReplacer::replace_placeholders(\n-                    infcx,\n-                    mapped_regions,\n-                    mapped_types,\n-                    mapped_consts,\n-                    &self.universes,\n-                    result.normalized_ty,\n-                );\n+                let res = if let Some((mapped_regions, mapped_types, mapped_consts)) = maps {\n+                    PlaceholderReplacer::replace_placeholders(\n+                        infcx,\n+                        mapped_regions,\n+                        mapped_types,\n+                        mapped_consts,\n+                        &self.universes,\n+                        result.normalized_ty,\n+                    )\n+                } else {\n+                    result.normalized_ty\n+                };\n                 // `tcx.normalize_projection_ty` may normalize to a type that still has\n                 // unevaluated consts, so keep normalizing here if that's the case.\n                 if res != ty && res.has_type_flags(ty::TypeFlags::HAS_CT_PROJECTION) {\n@@ -353,8 +324,6 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                     res\n                 }\n             }\n-\n-            _ => ty.try_super_fold_with(self)?,\n         };\n \n         self.cache.insert(ty, res);"}, {"sha": "3d5dd18f4c1d7355f81dcebf622e8efe5f98e844", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -8,8 +8,8 @@\n //! https://rustc-dev-guide.rust-lang.org/traits/resolution.html#confirmation\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir::lang_items::LangItem;\n-use rustc_infer::infer::InferOk;\n use rustc_infer::infer::LateBoundRegionConversionTime::HigherRankedType;\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n use rustc_middle::ty::{\n     self, Binder, GenericParamDefKind, InternalSubsts, SubstsRef, ToPolyTraitRef, ToPredicate,\n     TraitRef, Ty, TyCtxt, TypeVisitableExt,\n@@ -177,7 +177,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligations.extend(self.infcx.commit_if_ok(|_| {\n             self.infcx\n                 .at(&obligation.cause, obligation.param_env)\n-                .sup(placeholder_trait_predicate, candidate)\n+                .sup(DefineOpaqueTypes::No, placeholder_trait_predicate, candidate)\n                 .map(|InferOk { obligations, .. }| obligations)\n                 .map_err(|_| Unimplemented)\n         })?);\n@@ -462,7 +462,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         nested.extend(self.infcx.commit_if_ok(|_| {\n             self.infcx\n                 .at(&obligation.cause, obligation.param_env)\n-                .sup(obligation_trait_ref, upcast_trait_ref)\n+                .sup(DefineOpaqueTypes::No, obligation_trait_ref, upcast_trait_ref)\n                 .map(|InferOk { obligations, .. }| obligations)\n                 .map_err(|_| Unimplemented)\n         })?);\n@@ -827,11 +827,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 )\n             });\n \n+        // needed to define opaque types for tests/ui/type-alias-impl-trait/assoc-projection-ice.rs\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n-            // needed for tests/ui/type-alias-impl-trait/assoc-projection-ice.rs\n-            .define_opaque_types(true)\n-            .sup(obligation_trait_ref, expected_trait_ref)\n+            .sup(DefineOpaqueTypes::Yes, obligation_trait_ref, expected_trait_ref)\n             .map(|InferOk { mut obligations, .. }| {\n                 obligations.extend(nested);\n                 obligations\n@@ -896,7 +895,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n-                    .sup(target, source_trait)\n+                    .sup(DefineOpaqueTypes::No, target, source_trait)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n \n@@ -995,7 +994,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n-                    .sup(target, source_trait)\n+                    .sup(DefineOpaqueTypes::No, target, source_trait)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n \n@@ -1066,7 +1065,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n-                    .eq(b, a)\n+                    .eq(DefineOpaqueTypes::No, b, a)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n             }\n@@ -1114,7 +1113,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n-                    .eq(target, new_struct)\n+                    .eq(DefineOpaqueTypes::No, target, new_struct)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n \n@@ -1144,7 +1143,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n-                    .eq(target, new_tuple)\n+                    .eq(DefineOpaqueTypes::No, target, new_tuple)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n "}, {"sha": "bc1c72da1e175faeac50891fac5d22fab7cb8556", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -38,6 +38,7 @@ use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::traits::TraitEngine;\n use rustc_infer::traits::TraitEngineExt;\n@@ -912,7 +913,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     .infcx\n                                     .at(&obligation.cause, obligation.param_env)\n                                     .trace(c1, c2)\n-                                    .eq(a.substs, b.substs)\n+                                    .eq(DefineOpaqueTypes::No, a.substs, b.substs)\n                                 {\n                                     let mut obligations = new_obligations.obligations;\n                                     self.add_depth(\n@@ -930,7 +931,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                 if let Ok(new_obligations) = self\n                                     .infcx\n                                     .at(&obligation.cause, obligation.param_env)\n-                                    .eq(c1, c2)\n+                                    .eq(DefineOpaqueTypes::No, c1, c2)\n                                 {\n                                     let mut obligations = new_obligations.obligations;\n                                     self.add_depth(\n@@ -964,8 +965,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                     match (evaluate(c1), evaluate(c2)) {\n                         (Ok(c1), Ok(c2)) => {\n-                            match self.infcx.at(&obligation.cause, obligation.param_env).eq(c1, c2)\n-                            {\n+                            match self.infcx.at(&obligation.cause, obligation.param_env).eq(\n+                                DefineOpaqueTypes::No,\n+                                c1,\n+                                c2,\n+                            ) {\n                                 Ok(inf_ok) => self.evaluate_predicates_recursively(\n                                     previous_stack,\n                                     inf_ok.into_obligations(),\n@@ -993,7 +997,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n                 ty::PredicateKind::Ambiguous => Ok(EvaluatedToAmbig),\n                 ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n-                    match self.infcx.at(&obligation.cause, obligation.param_env).eq(ct.ty(), ty) {\n+                    match self.infcx.at(&obligation.cause, obligation.param_env).eq(\n+                        DefineOpaqueTypes::No,\n+                        ct.ty(),\n+                        ty,\n+                    ) {\n                         Ok(inf_ok) => self.evaluate_predicates_recursively(\n                             previous_stack,\n                             inf_ok.into_obligations(),\n@@ -1751,7 +1759,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         });\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n-            .sup(ty::Binder::dummy(placeholder_trait_ref), trait_bound)\n+            .sup(DefineOpaqueTypes::No, ty::Binder::dummy(placeholder_trait_ref), trait_bound)\n             .map(|InferOk { obligations: _, value: () }| {\n                 // This method is called within a probe, so we can't have\n                 // inference variables and placeholders escape.\n@@ -1813,7 +1821,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let is_match = self\n             .infcx\n             .at(&obligation.cause, obligation.param_env)\n-            .sup(obligation.predicate, infer_projection)\n+            .sup(DefineOpaqueTypes::No, obligation.predicate, infer_projection)\n             .map_or(false, |InferOk { obligations, value: () }| {\n                 self.evaluate_predicates_recursively(\n                     TraitObligationStackList::empty(&ProvisionalEvaluationCache::default()),\n@@ -2534,7 +2542,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n         let InferOk { obligations, .. } = self\n             .infcx\n             .at(&cause, obligation.param_env)\n-            .eq(placeholder_obligation_trait_ref, impl_trait_ref)\n+            .eq(DefineOpaqueTypes::No, placeholder_obligation_trait_ref, impl_trait_ref)\n             .map_err(|e| {\n                 debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e.to_string(self.tcx()))\n             })?;\n@@ -2584,7 +2592,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n     ) -> Result<Vec<PredicateObligation<'tcx>>, ()> {\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n-            .sup(obligation.predicate.to_poly_trait_ref(), poly_trait_ref)\n+            .sup(DefineOpaqueTypes::No, obligation.predicate.to_poly_trait_ref(), poly_trait_ref)\n             .map(|InferOk { obligations, .. }| obligations)\n             .map_err(|_| ())\n     }"}, {"sha": "8e229dd8d6b98aabaab20aae11d5e0ffab889d41", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -10,6 +10,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/specialization.html\n \n pub mod specialization_graph;\n+use rustc_infer::infer::DefineOpaqueTypes;\n use specialization_graph::GraphExt;\n \n use crate::errors::NegativePositiveConflict;\n@@ -193,7 +194,7 @@ fn fulfill_implication<'tcx>(\n \n     // do the impls unify? If not, no specialization.\n     let Ok(InferOk { obligations: more_obligations, .. }) =\n-        infcx.at(&ObligationCause::dummy(), param_env).eq(source_trait, target_trait)\n+        infcx.at(&ObligationCause::dummy(), param_env, ).eq(DefineOpaqueTypes::No,source_trait, target_trait)\n     else {\n         debug!(\n             \"fulfill_implication: {:?} does not unify with {:?}\","}, {"sha": "ab4c36975a0ecf07053efd85ae48a626498f1ec4", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -1,15 +1,14 @@\n-use rustc_errors::Diagnostic;\n-use rustc_span::Span;\n-use smallvec::SmallVec;\n-\n+use super::NormalizeExt;\n+use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext};\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Diagnostic;\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::InferOk;\n use rustc_middle::ty::{self, ImplSubject, ToPredicate, Ty, TyCtxt, TypeVisitableExt};\n use rustc_middle::ty::{GenericArg, SubstsRef};\n+use rustc_span::Span;\n+use smallvec::SmallVec;\n \n-use super::NormalizeExt;\n-use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext};\n-use rustc_infer::infer::InferOk;\n pub use rustc_infer::traits::{self, util::*};\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -201,6 +200,7 @@ pub fn impl_subject_and_oblig<'a, 'tcx>(\n ) -> (ImplSubject<'tcx>, impl Iterator<Item = PredicateObligation<'tcx>>) {\n     let subject = selcx.tcx().bound_impl_subject(impl_def_id);\n     let subject = subject.subst(selcx.tcx(), impl_substs);\n+\n     let InferOk { value: subject, obligations: normalization_obligations1 } =\n         selcx.infcx.at(&ObligationCause::dummy(), param_env).normalize(subject);\n "}, {"sha": "089b6b6418dc15002b820e5cbaf8e3391a49e14c", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -1738,11 +1738,11 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n \n     /// Inequality for two `Rc`s.\n     ///\n-    /// Two `Rc`s are unequal if their inner values are unequal.\n+    /// Two `Rc`s are not equal if their inner values are not equal.\n     ///\n     /// If `T` also implements `Eq` (implying reflexivity of equality),\n     /// two `Rc`s that point to the same allocation are\n-    /// never unequal.\n+    /// always equal.\n     ///\n     /// # Examples\n     ///"}, {"sha": "8a27a7ecdf653c69c851b9b87e48c1256bf5b808", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -2475,10 +2475,10 @@ impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n \n     /// Inequality for two `Arc`s.\n     ///\n-    /// Two `Arc`s are unequal if their inner values are unequal.\n+    /// Two `Arc`s are not equal if their inner values are not equal.\n     ///\n     /// If `T` also implements `Eq` (implying reflexivity of equality),\n-    /// two `Arc`s that point to the same value are never unequal.\n+    /// two `Arc`s that point to the same value are always equal.\n     ///\n     /// # Examples\n     ///"}, {"sha": "3bdde0993b9a28e315c938a3647061f5e215965d", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -158,7 +158,7 @@ mod sip;\n ///\n /// Implementations of `hash` should ensure that the data they\n /// pass to the `Hasher` are prefix-free. That is,\n-/// unequal values should cause two different sequences of values to be written,\n+/// values which are not equal should cause two different sequences of values to be written,\n /// and neither of the two sequences should be a prefix of the other.\n ///\n /// For example, the standard implementation of [`Hash` for `&str`][impl] passes an extra"}, {"sha": "e791158e25948385f9a37d943dc7d44b8fa32e25", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -3721,7 +3721,7 @@ pub trait Iterator {\n         }\n     }\n \n-    /// Determines if the elements of this [`Iterator`] are unequal to those of\n+    /// Determines if the elements of this [`Iterator`] are not equal to those of\n     /// another.\n     ///\n     /// # Examples"}, {"sha": "e12a3e378a6154dbea7013bd5c5e6c6438980a19", "filename": "library/core/src/primitive_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprimitive_docs.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -1110,7 +1110,7 @@ impl<T: Copy> Copy for (T,) {\n /// - [NaN (not a number)](#associatedconstant.NAN): this value results from\n ///   calculations like `(-1.0).sqrt()`. NaN has some potentially unexpected\n ///   behavior:\n-///   - It is unequal to any float, including itself! This is the reason `f32`\n+///   - It is not equal to any float, including itself! This is the reason `f32`\n ///     doesn't implement the `Eq` trait.\n ///   - It is also neither smaller nor greater than any float, making it\n ///     impossible to sort by the default comparison operation, which is the"}, {"sha": "e12a3e378a6154dbea7013bd5c5e6c6438980a19", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -1110,7 +1110,7 @@ impl<T: Copy> Copy for (T,) {\n /// - [NaN (not a number)](#associatedconstant.NAN): this value results from\n ///   calculations like `(-1.0).sqrt()`. NaN has some potentially unexpected\n ///   behavior:\n-///   - It is unequal to any float, including itself! This is the reason `f32`\n+///   - It is not equal to any float, including itself! This is the reason `f32`\n ///     doesn't implement the `Eq` trait.\n ///   - It is also neither smaller nor greater than any float, making it\n ///     impossible to sort by the default comparison operation, which is the"}, {"sha": "519ec2c32bd5d5b59ec50b5699851e141cd9f6f3", "filename": "library/std/src/sync/remutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/library%2Fstd%2Fsrc%2Fsync%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/library%2Fstd%2Fsrc%2Fsync%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fremutex.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -35,7 +35,7 @@ use crate::sys::locks as sys;\n /// `owner` can be checked by other threads that want to see if they already\n /// hold the lock, so needs to be atomic. If it compares equal, we're on the\n /// same thread that holds the mutex and memory access can use relaxed ordering\n-/// since we're not dealing with multiple threads. If it compares unequal,\n+/// since we're not dealing with multiple threads. If it's not equal,\n /// synchronization is left to the mutex, making relaxed memory ordering for\n /// the `owner` field fine in all cases.\n pub struct ReentrantMutex<T> {"}, {"sha": "29912b95703b2f8c48dada046dbfeb2642376127", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -20,15 +20,13 @@ smallvec = \"1.8.1\"\n tempfile = \"3\"\n tracing = \"0.1\"\n tracing-tree = \"0.2.0\"\n+threadpool = \"1.8.1\"\n \n [dependencies.tracing-subscriber]\n version = \"0.3.3\"\n default-features = false\n features = [\"fmt\", \"env-filter\", \"smallvec\", \"parking_lot\", \"ansi\"]\n \n-[target.'cfg(windows)'.dependencies]\n-rayon = \"1.5.1\"\n-\n [dev-dependencies]\n expect-test = \"1.4.0\"\n "}, {"sha": "3a3bf6a7ab9e862bd874c4e6aa0946271219861e", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -1,6 +1,6 @@\n use crate::rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_hir as hir;\n-use rustc_infer::infer::{InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk, TyCtxtInferExt};\n use rustc_infer::traits;\n use rustc_middle::ty::ToPredicate;\n use rustc_span::DUMMY_SP;\n@@ -47,8 +47,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n \n                 // Require the type the impl is implemented on to match\n                 // our type, and ignore the impl if there was a mismatch.\n-                let cause = traits::ObligationCause::dummy();\n-                let Ok(eq_result) = infcx.at(&cause, param_env).eq(impl_trait_ref.self_ty(), impl_ty) else {\n+                let Ok(eq_result) = infcx.at(&traits::ObligationCause::dummy(), param_env).eq(DefineOpaqueTypes::No, impl_trait_ref.self_ty(), impl_ty) else {\n                         continue\n                     };\n                 let InferOk { value: (), obligations } = eq_result;"}, {"sha": "d58b8dc6ad4a4473fde1991f3c0f19ad5716b00f", "filename": "src/librustdoc/docfs.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/src%2Flibrustdoc%2Fdocfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/src%2Flibrustdoc%2Fdocfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdocfs.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -2,18 +2,20 @@\n //!\n //! On Windows this indirects IO into threads to work around performance issues\n //! with Defender (and other similar virus scanners that do blocking operations).\n-//! On other platforms this is a thin shim to fs.\n //!\n //! Only calls needed to permit this workaround have been abstracted: thus\n //! fs::read is still done directly via the fs module; if in future rustdoc\n //! needs to read-after-write from a file, then it would be added to this\n //! abstraction.\n \n+use std::cmp::max;\n use std::fs;\n use std::io;\n use std::path::{Path, PathBuf};\n use std::string::ToString;\n use std::sync::mpsc::Sender;\n+use std::thread::available_parallelism;\n+use threadpool::ThreadPool;\n \n pub(crate) trait PathError {\n     fn new<S, P: AsRef<Path>>(e: S, path: P) -> Self\n@@ -24,11 +26,21 @@ pub(crate) trait PathError {\n pub(crate) struct DocFS {\n     sync_only: bool,\n     errors: Option<Sender<String>>,\n+    pool: ThreadPool,\n }\n \n impl DocFS {\n     pub(crate) fn new(errors: Sender<String>) -> DocFS {\n-        DocFS { sync_only: false, errors: Some(errors) }\n+        const MINIMUM_NB_THREADS: usize = 2;\n+        DocFS {\n+            sync_only: false,\n+            errors: Some(errors),\n+            pool: ThreadPool::new(\n+                available_parallelism()\n+                    .map(|nb| max(nb.get(), MINIMUM_NB_THREADS))\n+                    .unwrap_or(MINIMUM_NB_THREADS),\n+            ),\n+        }\n     }\n \n     pub(crate) fn set_sync_only(&mut self, sync_only: bool) {\n@@ -54,12 +66,11 @@ impl DocFS {\n     where\n         E: PathError,\n     {\n-        #[cfg(windows)]\n         if !self.sync_only {\n             // A possible future enhancement after more detailed profiling would\n             // be to create the file sync so errors are reported eagerly.\n             let sender = self.errors.clone().expect(\"can't write after closing\");\n-            rayon::spawn(move || {\n+            self.pool.execute(move || {\n                 fs::write(&path, contents).unwrap_or_else(|e| {\n                     sender.send(format!(\"\\\"{}\\\": {}\", path.display(), e)).unwrap_or_else(|_| {\n                         panic!(\"failed to send error on \\\"{}\\\"\", path.display())\n@@ -70,9 +81,12 @@ impl DocFS {\n             fs::write(&path, contents).map_err(|e| E::new(e, path))?;\n         }\n \n-        #[cfg(not(windows))]\n-        fs::write(&path, contents).map_err(|e| E::new(e, path))?;\n-\n         Ok(())\n     }\n }\n+\n+impl Drop for DocFS {\n+    fn drop(&mut self) {\n+        self.pool.join();\n+    }\n+}"}, {"sha": "27010b771d33b29462afeb36d01ec794197544d5", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -771,6 +771,12 @@ pub(crate) fn link_tooltip(did: DefId, fragment: &Option<UrlFragment>, cx: &Cont\n         .or_else(|| cache.external_paths.get(&did))\n         else { return String::new() };\n     let mut buf = Buffer::new();\n+    let fqp = if *shortty == ItemType::Primitive {\n+        // primitives are documented in a crate, but not actually part of it\n+        &fqp[fqp.len() - 1..]\n+    } else {\n+        &fqp\n+    };\n     if let &Some(UrlFragment::Item(id)) = fragment {\n         write!(buf, \"{} \", cx.tcx().def_descr(id));\n         for component in fqp {"}, {"sha": "08a0e1c377ef8231f4e5a60b03d1c1037ec5b7c6", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -486,7 +486,7 @@ fn add_generics_and_bounds_as_types<'tcx, 'a>(\n     }\n \n     // First, check if it's \"Self\".\n-    let arg = if let Some(self_) = self_ {\n+    let mut arg = if let Some(self_) = self_ {\n         match &*arg {\n             Type::BorrowedRef { type_, .. } if type_.is_self_type() => self_,\n             type_ if type_.is_self_type() => self_,\n@@ -496,11 +496,16 @@ fn add_generics_and_bounds_as_types<'tcx, 'a>(\n         arg\n     };\n \n+    // strip references from the argument type\n+    while let Type::BorrowedRef { type_, .. } = &*arg {\n+        arg = &*type_;\n+    }\n+\n     // If this argument is a type parameter and not a trait bound or a type, we need to look\n     // for its bounds.\n     if let Type::Generic(arg_s) = *arg {\n         // First we check if the bounds are in a `where` predicate...\n-        if let Some(where_pred) = generics.where_predicates.iter().find(|g| match g {\n+        for where_pred in generics.where_predicates.iter().filter(|g| match g {\n             WherePredicate::BoundPredicate { ty: Type::Generic(ty_s), .. } => *ty_s == arg_s,\n             _ => false,\n         }) {"}, {"sha": "6bf421a21356072eda42297d227e7de6bf7492f8", "filename": "tests/rustdoc-js-std/option-type-signatures.js", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Frustdoc-js-std%2Foption-type-signatures.js", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Frustdoc-js-std%2Foption-type-signatures.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Foption-type-signatures.js?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -1,7 +1,18 @@\n-const QUERY = 'option, fnonce -> option';\n+const QUERY = [\n+    'option, fnonce -> option',\n+    'option -> default',\n+];\n \n-const EXPECTED = {\n-    'others': [\n-        { 'path': 'std::option::Option', 'name': 'map' },\n-    ],\n-};\n+const EXPECTED = [\n+    {\n+        'others': [\n+            { 'path': 'std::option::Option', 'name': 'map' },\n+        ],\n+    },\n+    {\n+        'others': [\n+            { 'path': 'std::option::Option', 'name': 'unwrap_or_default' },\n+            { 'path': 'std::option::Option', 'name': 'get_or_insert_default' },\n+        ],\n+    },\n+];"}, {"sha": "86254a80e20f3623ac14e93bbba366cc4342bbde", "filename": "tests/rustdoc-js/where-clause.js", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Frustdoc-js%2Fwhere-clause.js", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Frustdoc-js%2Fwhere-clause.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fwhere-clause.js?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -1,4 +1,4 @@\n-const QUERY = ['trait<nested>', '-> trait<nested>', 't1, t2'];\n+const QUERY = ['trait<nested>', '-> trait<nested>', 't1, t2', '-> shazam', 'drizzel -> shazam'];\n \n const EXPECTED = [\n     {\n@@ -16,4 +16,15 @@ const EXPECTED = [\n             { 'path': 'where_clause', 'name': 'presto' },\n         ],\n     },\n+    {\n+        'others': [\n+            { 'path': 'where_clause', 'name': 'bippety' },\n+            { 'path': 'where_clause::Drizzel', 'name': 'boppety' },\n+        ],\n+    },\n+    {\n+        'others': [\n+            { 'path': 'where_clause::Drizzel', 'name': 'boppety' },\n+        ],\n+    },\n ];"}, {"sha": "56c01019fb69fb70fbcb2ff8b1483508da01094c", "filename": "tests/rustdoc-js/where-clause.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Frustdoc-js%2Fwhere-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Frustdoc-js%2Fwhere-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fwhere-clause.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -14,3 +14,17 @@ pub trait T2<'a, T> {\n }\n \n pub fn presto<A, B>(_: A, _: B) where A: T1, B: for <'b> T2<'b, Nested> {}\n+\n+pub trait Shazam {}\n+\n+pub fn bippety<X>() -> &'static X where X: Shazam {\n+    panic!()\n+}\n+\n+pub struct Drizzel<T>(T);\n+\n+impl<T> Drizzel<T> {\n+    pub fn boppety(&self) -> &T where T: Shazam {\n+        panic!();\n+    }\n+}"}, {"sha": "bc1965aac5594a167fd6fb49381fa2cddc7fd38a", "filename": "tests/rustdoc/intra-doc/prim-methods.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Frustdoc%2Fintra-doc%2Fprim-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Frustdoc%2Fintra-doc%2Fprim-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fintra-doc%2Fprim-methods.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -2,6 +2,8 @@\n \n // @has prim_methods/index.html\n // @has - '//*[@id=\"main-content\"]//a[@href=\"{{channel}}/std/primitive.char.html\"]' 'char'\n+// @has - '//*[@id=\"main-content\"]//a[@href=\"{{channel}}/std/primitive.char.html\"]/@title' 'primitive char'\n // @has - '//*[@id=\"main-content\"]//a[@href=\"{{channel}}/std/primitive.char.html#method.len_utf8\"]' 'char::len_utf8'\n+// @has - '//*[@id=\"main-content\"]//a[@href=\"{{channel}}/std/primitive.char.html#method.len_utf8\"]/@title' 'method char::len_utf8'\n \n //! A [`char`] and its [`char::len_utf8`]."}, {"sha": "123ce71727f67c0dd4641a046b73472abedb8376", "filename": "tests/ui/conditional-compilation/cfg-attr-multi-true.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-true.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-true.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-true.stderr?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -35,6 +35,10 @@ note: the lint level is defined here\n    |\n LL | #![warn(unused_must_use)]\n    |         ^^^^^^^^^^^^^^^\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = MustUseDeprecated::new();\n+   |     +++++++\n \n warning: 5 warnings emitted\n "}, {"sha": "90d0bb406554350793bc7537752184952bd29eab", "filename": "tests/ui/issues/issue-19086.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Fissues%2Fissue-19086.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Fissues%2Fissue-19086.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-19086.stderr?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -5,7 +5,7 @@ LL |     FooB { x: i32, y: i32 }\n    |     ----------------------- `FooB` defined here\n ...\n LL |         FooB(a, b) => println!(\"{} {}\", a, b),\n-   |         ^^^^^^^^^^ help: use struct pattern syntax instead: `FooB { x, y }`\n+   |         ^^^^^^^^^^ help: use struct pattern syntax instead: `FooB { x: a, y: b }`\n \n error: aborting due to previous error\n "}, {"sha": "e88c1a9b8a9b99c0d3e4fae7b8818b451a6db6ab", "filename": "tests/ui/lint/fn_must_use.stderr", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Flint%2Ffn_must_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Flint%2Ffn_must_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Ffn_must_use.stderr?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -10,12 +10,21 @@ note: the lint level is defined here\n    |\n LL | #![warn(unused_must_use)]\n    |         ^^^^^^^^^^^^^^^\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = need_to_use_this_value();\n+   |     +++++++\n \n warning: unused return value of `MyStruct::need_to_use_this_method_value` that must be used\n   --> $DIR/fn_must_use.rs:60:5\n    |\n LL |     m.need_to_use_this_method_value();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = m.need_to_use_this_method_value();\n+   |     +++++++\n \n warning: unused return value of `EvenNature::is_even` that must be used\n   --> $DIR/fn_must_use.rs:61:5\n@@ -24,24 +33,43 @@ LL |     m.is_even(); // trait method!\n    |     ^^^^^^^^^^^\n    |\n    = note: no side effects\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = m.is_even(); // trait method!\n+   |     +++++++\n \n warning: unused return value of `MyStruct::need_to_use_this_associated_function_value` that must be used\n   --> $DIR/fn_must_use.rs:64:5\n    |\n LL |     MyStruct::need_to_use_this_associated_function_value();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = MyStruct::need_to_use_this_associated_function_value();\n+   |     +++++++\n \n warning: unused return value of `std::cmp::PartialEq::eq` that must be used\n   --> $DIR/fn_must_use.rs:70:5\n    |\n LL |     2.eq(&3);\n    |     ^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = 2.eq(&3);\n+   |     +++++++\n \n warning: unused return value of `std::cmp::PartialEq::eq` that must be used\n   --> $DIR/fn_must_use.rs:71:5\n    |\n LL |     m.eq(&n);\n    |     ^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = m.eq(&n);\n+   |     +++++++\n \n warning: unused comparison that must be used\n   --> $DIR/fn_must_use.rs:74:5"}, {"sha": "4898db7fe3ddd7a76d49bc7b7061eb04961d4168", "filename": "tests/ui/lint/unused/must-use-box-from-raw.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Flint%2Funused%2Fmust-use-box-from-raw.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Flint%2Funused%2Fmust-use-box-from-raw.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Fmust-use-box-from-raw.stderr?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -10,6 +10,10 @@ note: the lint level is defined here\n    |\n LL | #![warn(unused_must_use)]\n    |         ^^^^^^^^^^^^^^^\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = Box::from_raw(ptr);\n+   |     +++++++\n \n warning: 1 warning emitted\n "}, {"sha": "993a19e5f04ed85f4816a4974965bd5149434f14", "filename": "tests/ui/lint/unused/must_use-unit.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Flint%2Funused%2Fmust_use-unit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Flint%2Funused%2Fmust_use-unit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Fmust_use-unit.stderr?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -9,12 +9,21 @@ note: the lint level is defined here\n    |\n LL | #![deny(unused_must_use)]\n    |         ^^^^^^^^^^^^^^^\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = foo();\n+   |     +++++++\n \n error: unused return value of `bar` that must be used\n   --> $DIR/must_use-unit.rs:15:5\n    |\n LL |     bar();\n    |     ^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = bar();\n+   |     +++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "1c3702ba265c0480fa3b36a7e59b36a5f7e693c1", "filename": "tests/ui/lint/unused/unused-async.stderr", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Flint%2Funused%2Funused-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Flint%2Funused%2Funused-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Funused-async.stderr?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -16,12 +16,22 @@ error: unused return value of `foo` that must be used\n    |\n LL |     foo();\n    |     ^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = foo();\n+   |     +++++++\n \n error: unused output of future returned by `foo` that must be used\n   --> $DIR/unused-async.rs:33:5\n    |\n LL |     foo().await;\n    |     ^^^^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = foo().await;\n+   |     +++++++\n \n error: unused implementer of `Future` that must be used\n   --> $DIR/unused-async.rs:34:5\n@@ -36,12 +46,22 @@ error: unused return value of `bar` that must be used\n    |\n LL |     bar();\n    |     ^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = bar();\n+   |     +++++++\n \n error: unused output of future returned by `bar` that must be used\n   --> $DIR/unused-async.rs:36:5\n    |\n LL |     bar().await;\n    |     ^^^^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = bar().await;\n+   |     +++++++\n \n error: unused implementer of `Future` that must be used\n   --> $DIR/unused-async.rs:37:5"}, {"sha": "f42995a65d13eadc51da96b262f48c8f9f9801f7", "filename": "tests/ui/lint/unused/unused-result.stderr", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Flint%2Funused%2Funused-result.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Flint%2Funused%2Funused-result.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Funused-result.stderr?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -9,6 +9,10 @@ note: the lint level is defined here\n    |\n LL | #![deny(unused_results, unused_must_use)]\n    |                         ^^^^^^^^^^^^^^^\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = foo::<MustUse>();\n+   |     +++++++\n \n error: unused `MustUseMsg` that must be used\n   --> $DIR/unused-result.rs:22:5\n@@ -17,6 +21,10 @@ LL |     foo::<MustUseMsg>();\n    |     ^^^^^^^^^^^^^^^^^^^\n    |\n    = note: some message\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = foo::<MustUseMsg>();\n+   |     +++++++\n \n error: unused result of type `isize`\n   --> $DIR/unused-result.rs:34:5\n@@ -35,6 +43,11 @@ error: unused `MustUse` that must be used\n    |\n LL |     foo::<MustUse>();\n    |     ^^^^^^^^^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = foo::<MustUse>();\n+   |     +++++++\n \n error: unused `MustUseMsg` that must be used\n   --> $DIR/unused-result.rs:36:5\n@@ -43,6 +56,10 @@ LL |     foo::<MustUseMsg>();\n    |     ^^^^^^^^^^^^^^^^^^^\n    |\n    = note: some message\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = foo::<MustUseMsg>();\n+   |     +++++++\n \n error: aborting due to 5 previous errors\n "}, {"sha": "9633767c4428767a162995e2c862ce7e6ab04eb5", "filename": "tests/ui/lint/unused/unused_attributes-must_use.stderr", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Flint%2Funused%2Funused_attributes-must_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Flint%2Funused%2Funused_attributes-must_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Funused_attributes-must_use.stderr?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -146,42 +146,76 @@ note: the lint level is defined here\n    |\n LL | #![deny(unused_attributes, unused_must_use)]\n    |                            ^^^^^^^^^^^^^^^\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = X;\n+   |     +++++++\n \n error: unused `Y` that must be used\n   --> $DIR/unused_attributes-must_use.rs:104:5\n    |\n LL |     Y::Z;\n    |     ^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = Y::Z;\n+   |     +++++++\n \n error: unused `U` that must be used\n   --> $DIR/unused_attributes-must_use.rs:105:5\n    |\n LL |     U { unit: () };\n    |     ^^^^^^^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = U { unit: () };\n+   |     +++++++\n \n error: unused return value of `U::method` that must be used\n   --> $DIR/unused_attributes-must_use.rs:106:5\n    |\n LL |     U::method();\n    |     ^^^^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = U::method();\n+   |     +++++++\n \n error: unused return value of `foo` that must be used\n   --> $DIR/unused_attributes-must_use.rs:107:5\n    |\n LL |     foo();\n    |     ^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = foo();\n+   |     +++++++\n \n error: unused return value of `foreign_foo` that must be used\n   --> $DIR/unused_attributes-must_use.rs:110:9\n    |\n LL |         foreign_foo();\n    |         ^^^^^^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |         let _ = foreign_foo();\n+   |         +++++++\n \n error: unused return value of `Use::get_four` that must be used\n   --> $DIR/unused_attributes-must_use.rs:118:5\n    |\n LL |     ().get_four();\n    |     ^^^^^^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = ().get_four();\n+   |     +++++++\n \n error: aborting due to 28 previous errors\n "}, {"sha": "9b27a61ffd06905be77f622acce6931455bddfde", "filename": "tests/ui/pattern/issue-106862.fixed", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Fpattern%2Fissue-106862.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Fpattern%2Fissue-106862.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fissue-106862.fixed?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -0,0 +1,44 @@\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+use Foo::{FooB, FooA};\n+\n+enum Foo {\n+    FooA { opt_x: Option<i32>, y: i32 },\n+    FooB { x: i32, y: i32 }\n+}\n+\n+fn main() {\n+    let f = FooB { x: 3, y: 4 };\n+\n+    match f {\n+        FooB { x: a, y: b } => println!(\"{} {}\", a, b),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooB`\n+        _ => (),\n+    }\n+\n+    match f {\n+        FooB { x, y } => println!(\"{} {}\", x, y),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooB`\n+        _ => (),\n+    }\n+\n+    match f {\n+        FooA { opt_x: Some(x), y } => println!(\"{} {}\", x, y),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooA`\n+        _ => (),\n+    }\n+\n+    match f {\n+        FooB { x: a, y: _ } => println!(\"{}\", a),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooB`\n+        _ => (),\n+    }\n+\n+    match f {\n+        FooB { x, y } => (),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooB`\n+        _ => (),\n+    }\n+}"}, {"sha": "590430a784314e1308869b79bb345fc607cba14a", "filename": "tests/ui/pattern/issue-106862.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Fpattern%2Fissue-106862.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Fpattern%2Fissue-106862.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fissue-106862.rs?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -0,0 +1,44 @@\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+use Foo::{FooB, FooA};\n+\n+enum Foo {\n+    FooA { opt_x: Option<i32>, y: i32 },\n+    FooB { x: i32, y: i32 }\n+}\n+\n+fn main() {\n+    let f = FooB { x: 3, y: 4 };\n+\n+    match f {\n+        FooB(a, b) => println!(\"{} {}\", a, b),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooB`\n+        _ => (),\n+    }\n+\n+    match f {\n+        FooB(x, y) => println!(\"{} {}\", x, y),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooB`\n+        _ => (),\n+    }\n+\n+    match f {\n+        FooA(Some(x), y) => println!(\"{} {}\", x, y),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooA`\n+        _ => (),\n+    }\n+\n+    match f {\n+        FooB(a, _, _) => println!(\"{}\", a),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooB`\n+        _ => (),\n+    }\n+\n+    match f {\n+        FooB() => (),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooB`\n+        _ => (),\n+    }\n+}"}, {"sha": "27f8ac97284ebd7063a15b629f64736e320bf1a2", "filename": "tests/ui/pattern/issue-106862.stderr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Fpattern%2Fissue-106862.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13/tests%2Fui%2Fpattern%2Fissue-106862.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fissue-106862.stderr?ref=7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "patch": "@@ -0,0 +1,48 @@\n+error[E0532]: expected tuple struct or tuple variant, found variant `FooB`\n+  --> $DIR/issue-106862.rs:16:9\n+   |\n+LL |     FooB { x: i32, y: i32 }\n+   |     ----------------------- `FooB` defined here\n+...\n+LL |         FooB(a, b) => println!(\"{} {}\", a, b),\n+   |         ^^^^^^^^^^ help: use struct pattern syntax instead: `FooB { x: a, y: b }`\n+\n+error[E0532]: expected tuple struct or tuple variant, found variant `FooB`\n+  --> $DIR/issue-106862.rs:22:9\n+   |\n+LL |     FooB { x: i32, y: i32 }\n+   |     ----------------------- `FooB` defined here\n+...\n+LL |         FooB(x, y) => println!(\"{} {}\", x, y),\n+   |         ^^^^^^^^^^ help: use struct pattern syntax instead: `FooB { x, y }`\n+\n+error[E0532]: expected tuple struct or tuple variant, found variant `FooA`\n+  --> $DIR/issue-106862.rs:28:9\n+   |\n+LL |     FooA { opt_x: Option<i32>, y: i32 },\n+   |     ----------------------------------- `FooA` defined here\n+...\n+LL |         FooA(Some(x), y) => println!(\"{} {}\", x, y),\n+   |         ^^^^^^^^^^^^^^^^ help: use struct pattern syntax instead: `FooA { opt_x: Some(x), y }`\n+\n+error[E0532]: expected tuple struct or tuple variant, found variant `FooB`\n+  --> $DIR/issue-106862.rs:34:9\n+   |\n+LL |     FooB { x: i32, y: i32 }\n+   |     ----------------------- `FooB` defined here\n+...\n+LL |         FooB(a, _, _) => println!(\"{}\", a),\n+   |         ^^^^^^^^^^^^^ help: use struct pattern syntax instead: `FooB { x: a, y: _ }`\n+\n+error[E0532]: expected tuple struct or tuple variant, found variant `FooB`\n+  --> $DIR/issue-106862.rs:40:9\n+   |\n+LL |     FooB { x: i32, y: i32 }\n+   |     ----------------------- `FooB` defined here\n+...\n+LL |         FooB() => (),\n+   |         ^^^^^^ help: use struct pattern syntax instead: `FooB { x, y }`\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0532`."}]}