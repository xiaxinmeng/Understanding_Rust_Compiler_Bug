{"sha": "30db4ebdc225521853889b50cc5164646bbe66ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZGI0ZWJkYzIyNTUyMTg1Mzg4OWI1MGNjNTE2NDY0NmJiZTY2ZWQ=", "commit": {"author": {"name": "Jakub Adam Wieczorek", "email": "jakub.adam.wieczorek@gmail.com", "date": "2019-08-09T20:21:45Z"}, "committer": {"name": "Jakub Adam Wieczorek", "email": "jakub.adam.wieczorek@gmail.com", "date": "2019-08-10T21:09:53Z"}, "message": "Apply suggestions from code review\n\nCo-Authored-By: Mazdak Farrokhzad <twingoow@gmail.com>", "tree": {"sha": "41825355d6080c6a198a63437ae7d9b06e99a869", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41825355d6080c6a198a63437ae7d9b06e99a869"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30db4ebdc225521853889b50cc5164646bbe66ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30db4ebdc225521853889b50cc5164646bbe66ed", "html_url": "https://github.com/rust-lang/rust/commit/30db4ebdc225521853889b50cc5164646bbe66ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30db4ebdc225521853889b50cc5164646bbe66ed/comments", "author": {"login": "jakubadamw", "id": 14150873, "node_id": "MDQ6VXNlcjE0MTUwODcz", "avatar_url": "https://avatars.githubusercontent.com/u/14150873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubadamw", "html_url": "https://github.com/jakubadamw", "followers_url": "https://api.github.com/users/jakubadamw/followers", "following_url": "https://api.github.com/users/jakubadamw/following{/other_user}", "gists_url": "https://api.github.com/users/jakubadamw/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubadamw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubadamw/subscriptions", "organizations_url": "https://api.github.com/users/jakubadamw/orgs", "repos_url": "https://api.github.com/users/jakubadamw/repos", "events_url": "https://api.github.com/users/jakubadamw/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubadamw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubadamw", "id": 14150873, "node_id": "MDQ6VXNlcjE0MTUwODcz", "avatar_url": "https://avatars.githubusercontent.com/u/14150873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubadamw", "html_url": "https://github.com/jakubadamw", "followers_url": "https://api.github.com/users/jakubadamw/followers", "following_url": "https://api.github.com/users/jakubadamw/following{/other_user}", "gists_url": "https://api.github.com/users/jakubadamw/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubadamw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubadamw/subscriptions", "organizations_url": "https://api.github.com/users/jakubadamw/orgs", "repos_url": "https://api.github.com/users/jakubadamw/repos", "events_url": "https://api.github.com/users/jakubadamw/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubadamw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53a6304c2a431ae97c3b584066804c6acd667541", "url": "https://api.github.com/repos/rust-lang/rust/commits/53a6304c2a431ae97c3b584066804c6acd667541", "html_url": "https://github.com/rust-lang/rust/commit/53a6304c2a431ae97c3b584066804c6acd667541"}], "stats": {"total": 70, "additions": 35, "deletions": 35}, "files": [{"sha": "9827ce6ef20f82723be9ac7cfa6b3d13e69b2c57", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/30db4ebdc225521853889b50cc5164646bbe66ed/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30db4ebdc225521853889b50cc5164646bbe66ed/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=30db4ebdc225521853889b50cc5164646bbe66ed", "patch": "@@ -207,10 +207,10 @@ impl<'a> Resolver<'a> {\n                 err\n             }\n             ResolutionError::VariableNotBoundInPattern(binding_error) => {\n-                let BindingError { name, target, origin, could_be_variant } = binding_error;\n+                let BindingError { name, target, origin, could_be_path } = binding_error;\n \n-                let target_sp = target.iter().cloned().collect::<Vec<_>>();\n-                let origin_sp = origin.iter().cloned().collect::<Vec<_>>();\n+                let target_sp = target.iter().copied().collect::<Vec<_>>();\n+                let origin_sp = origin.iter().copied().collect::<Vec<_>>();\n \n                 let msp = MultiSpan::from_spans(target_sp.clone());\n                 let msg = format!(\"variable `{}` is not bound in all patterns\", name);\n@@ -225,10 +225,12 @@ impl<'a> Resolver<'a> {\n                 for sp in origin_sp {\n                     err.span_label(sp, \"variable not in all patterns\");\n                 }\n-                if *could_be_variant {\n+                if *could_be_path {\n                     let help_msg = format!(\n-                        \"if you meant to match on a variant or a const, consider \\\n-                         making the path in the pattern qualified: `?::{}`\", name);\n+                        \"if you meant to match on a variant or a `const` item, consider \\\n+                         making the path in the pattern qualified: `?::{}`\",\n+                         name,\n+                     );\n                     err.span_help(span, &help_msg);\n                 }\n                 err"}, {"sha": "358eaae11e71275d860bcf74bb46a931f10b9b8d", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/30db4ebdc225521853889b50cc5164646bbe66ed/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30db4ebdc225521853889b50cc5164646bbe66ed/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=30db4ebdc225521853889b50cc5164646bbe66ed", "patch": "@@ -1136,40 +1136,35 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     // Checks that all of the arms in an or-pattern have exactly the\n     // same set of bindings, with the same binding modes for each.\n     fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) {\n-        if pats.len() <= 1 {\n-            return;\n-        }\n-\n         let mut missing_vars = FxHashMap::default();\n         let mut inconsistent_vars = FxHashMap::default();\n-        for p in pats.iter() {\n-            let map_i = self.binding_mode_map(&p);\n-            for q in pats.iter() {\n-                if p.id == q.id {\n-                    continue;\n-                }\n \n-                let map_j = self.binding_mode_map(&q);\n-                for (&key_j, &binding_j) in map_j.iter() {\n-                    match map_i.get(&key_j) {\n+        for pat_outer in pats.iter() {\n+            let map_outer = self.binding_mode_map(&pat_outer);\n+\n+            for pat_inner in pats.iter().filter(|pat| pat.id != pat_outer.id) {\n+                let map_inner = self.binding_mode_map(&pat_inner);\n+\n+                for (&key_inner, &binding_inner) in map_inner.iter() {\n+                    match map_outer.get(&key_inner) {\n                         None => {  // missing binding\n                             let binding_error = missing_vars\n-                                .entry(key_j.name)\n+                                .entry(key_inner.name)\n                                 .or_insert(BindingError {\n-                                    name: key_j.name,\n+                                    name: key_inner.name,\n                                     origin: BTreeSet::new(),\n                                     target: BTreeSet::new(),\n-                                    could_be_variant:\n-                                        key_j.name.as_str().starts_with(char::is_uppercase)\n+                                    could_be_path:\n+                                        key_inner.name.as_str().starts_with(char::is_uppercase)\n                                 });\n-                            binding_error.origin.insert(binding_j.span);\n-                            binding_error.target.insert(p.span);\n+                            binding_error.origin.insert(binding_inner.span);\n+                            binding_error.target.insert(pat_outer.span);\n                         }\n-                        Some(binding_i) => {  // check consistent binding\n-                            if binding_i.binding_mode != binding_j.binding_mode {\n+                        Some(binding_outer) => {  // check consistent binding\n+                            if binding_outer.binding_mode != binding_inner.binding_mode {\n                                 inconsistent_vars\n-                                    .entry(key_j.name)\n-                                    .or_insert((binding_j.span, binding_i.span));\n+                                    .entry(key_inner.name)\n+                                    .or_insert((binding_inner.span, binding_outer.span));\n                             }\n                         }\n                     }\n@@ -1181,12 +1176,13 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         missing_vars.sort();\n         for (name, mut v) in missing_vars {\n             if inconsistent_vars.contains_key(name) {\n-                v.could_be_variant = false;\n+                v.could_be_path = false;\n             }\n             self.r.report_error(\n                 *v.origin.iter().next().unwrap(),\n                 ResolutionError::VariableNotBoundInPattern(v));\n         }\n+\n         let mut inconsistent_vars = inconsistent_vars.iter().collect::<Vec<_>>();\n         inconsistent_vars.sort();\n         for (name, v) in inconsistent_vars {\n@@ -1214,7 +1210,9 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             self.resolve_pattern(pat, source, &mut bindings_list);\n         }\n         // This has to happen *after* we determine which pat_idents are variants\n-        self.check_consistent_bindings(pats);\n+        if pats.len() > 1 {\n+            self.check_consistent_bindings(pats);\n+        }\n     }\n \n     fn resolve_block(&mut self, block: &Block) {"}, {"sha": "98782dfbc7a5f451401cbdfbdd7461b2e38e8019", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30db4ebdc225521853889b50cc5164646bbe66ed/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30db4ebdc225521853889b50cc5164646bbe66ed/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=30db4ebdc225521853889b50cc5164646bbe66ed", "patch": "@@ -135,7 +135,7 @@ struct BindingError {\n     name: Name,\n     origin: BTreeSet<Span>,\n     target: BTreeSet<Span>,\n-    could_be_variant: bool\n+    could_be_path: bool\n }\n \n impl PartialOrd for BindingError {"}, {"sha": "f02867a0024b558d78b95be8e9e19235c42f8ca1", "filename": "src/test/ui/resolve/resolve-inconsistent-names.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30db4ebdc225521853889b50cc5164646bbe66ed/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30db4ebdc225521853889b50cc5164646bbe66ed/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr?ref=30db4ebdc225521853889b50cc5164646bbe66ed", "patch": "@@ -23,7 +23,7 @@ LL |         (A, B) | (ref B, c) | (c, A) => ()\n    |          |       pattern doesn't bind `A`\n    |          variable not in all patterns\n    |\n-help: if you meant to match on a variant or a const, consider making the path in the pattern qualified: `?::A`\n+help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `?::A`\n   --> $DIR/resolve-inconsistent-names.rs:19:10\n    |\n LL |         (A, B) | (ref B, c) | (c, A) => ()\n@@ -63,7 +63,7 @@ LL |         (CONST1, _) | (_, Const2) => ()\n    |          |\n    |          variable not in all patterns\n    |\n-help: if you meant to match on a variant or a const, consider making the path in the pattern qualified: `?::CONST1`\n+help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `?::CONST1`\n   --> $DIR/resolve-inconsistent-names.rs:30:10\n    |\n LL |         (CONST1, _) | (_, Const2) => ()\n@@ -77,7 +77,7 @@ LL |         (CONST1, _) | (_, Const2) => ()\n    |         |\n    |         pattern doesn't bind `Const2`\n    |\n-help: if you meant to match on a variant or a const, consider making the path in the pattern qualified: `?::Const2`\n+help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `?::Const2`\n   --> $DIR/resolve-inconsistent-names.rs:30:27\n    |\n LL |         (CONST1, _) | (_, Const2) => ()"}]}