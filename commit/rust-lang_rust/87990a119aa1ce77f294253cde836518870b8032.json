{"sha": "87990a119aa1ce77f294253cde836518870b8032", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3OTkwYTExOWFhMWNlNzdmMjk0MjUzY2RlODM2NTE4ODcwYjgwMzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-28T03:40:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-28T03:40:26Z"}, "message": "Auto merge of #47671 - alexcrichton:trans-c-api-only, r=Mark-Simulacrum\n\nrustc: Load the `rustc_trans` crate at runtime\n\nBuilding on the work of #45684 this commit updates the compiler to\nunconditionally load the `rustc_trans` crate at runtime instead of linking to it\nat compile time. The end goal of this work is to implement #46819 where rustc\nwill have multiple backends available to it to load.\n\nThis commit starts off by removing the `extern crate rustc_trans` from the\ndriver. This involved moving some miscellaneous functionality into the\n`TransCrate` trait and also required an implementation of how to locate and load\nthe trans backend. This ended up being a little tricky because the sysroot isn't\nalways the right location (for example `--sysroot` arguments) so some extra code\nwas added as well to probe a directory relative to the current dll (the\nrustc_driver dll).\n\nRustbuild has been updated accordingly as well to have a separate compilation\ninvocation for the `rustc_trans` crate and assembly it accordingly into the\nsysroot. Finally, the distribution logic for the `rustc` package was also\nupdated to slurp up the trans backends folder.\n\nA number of assorted fallout changes were included here as well to ensure tests\npass and such, and they should all be commented inline.", "tree": {"sha": "9cc0f3775d3ce6f585df20d20a1d3a2dbfd063fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cc0f3775d3ce6f585df20d20a1d3a2dbfd063fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87990a119aa1ce77f294253cde836518870b8032", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87990a119aa1ce77f294253cde836518870b8032", "html_url": "https://github.com/rust-lang/rust/commit/87990a119aa1ce77f294253cde836518870b8032", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87990a119aa1ce77f294253cde836518870b8032/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6beb06ee5ef6f031aab7586211f1818d346033d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6beb06ee5ef6f031aab7586211f1818d346033d6", "html_url": "https://github.com/rust-lang/rust/commit/6beb06ee5ef6f031aab7586211f1818d346033d6"}, {"sha": "884715c65420141dc06753f242a224462b120109", "url": "https://api.github.com/repos/rust-lang/rust/commits/884715c65420141dc06753f242a224462b120109", "html_url": "https://github.com/rust-lang/rust/commit/884715c65420141dc06753f242a224462b120109"}], "stats": {"total": 755, "additions": 553, "deletions": 202}, "files": [{"sha": "d26098903eec5a05931545f94a6a665c149c9290", "filename": "src/Cargo.lock", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -1933,7 +1933,6 @@ dependencies = [\n  \"rustc_privacy 0.0.0\",\n  \"rustc_resolve 0.0.0\",\n  \"rustc_save_analysis 0.0.0\",\n- \"rustc_trans 0.0.0\",\n  \"rustc_trans_utils 0.0.0\",\n  \"rustc_typeck 0.0.0\",\n  \"serialize 0.0.0\",\n@@ -1984,6 +1983,7 @@ dependencies = [\n  \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"build_helper 0.1.0\",\n  \"cc 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.36 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_cratesio_shim 0.0.0\",\n ]\n \n@@ -2121,6 +2121,7 @@ dependencies = [\n  \"cc 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jobserver 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.36 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\","}, {"sha": "c22ba7a37c8b07032f6b768be64101e7a2150c4d", "filename": "src/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -4,6 +4,7 @@ members = [\n   \"rustc\",\n   \"libstd\",\n   \"libtest\",\n+  \"librustc_trans\",\n   \"tools/cargotest\",\n   \"tools/clippy\",\n   \"tools/compiletest\","}, {"sha": "e6871764b2c78ffee2d47dcdab3e9c2c8b156dc7", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -94,7 +94,7 @@ impl Step for Rustc {\n         build.clear_if_dirty(&stage_out, &libtest_stamp(build, compiler, target));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"check\");\n-        rustc_cargo(build, target, &mut cargo);\n+        rustc_cargo(build, &mut cargo);\n         run_cargo(build,\n                   &mut cargo,\n                   &librustc_stamp(build, compiler, target),"}, {"sha": "0b247c6f7555762317546dcb782e5bc88fc38c61", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 184, "deletions": 50, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -300,7 +300,11 @@ impl Step for StartupObjects {\n         }\n \n         for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n-            copy(&compiler_file(build.cc(target), obj), &sysroot_dir.join(obj));\n+            let src = compiler_file(build,\n+                                    build.cc(target),\n+                                    target,\n+                                    obj);\n+            copy(&src, &sysroot_dir.join(obj));\n         }\n     }\n }\n@@ -454,10 +458,6 @@ impl Step for Rustc {\n \n         builder.ensure(Test { compiler, target });\n \n-        // Build LLVM for our target. This will implicitly build the host LLVM\n-        // if necessary.\n-        builder.ensure(native::Llvm { target });\n-\n         if build.force_use_stage1(compiler, target) {\n             builder.ensure(Rustc {\n                 compiler: builder.compiler(1, build.build),\n@@ -487,7 +487,7 @@ impl Step for Rustc {\n         build.clear_if_dirty(&stage_out, &libtest_stamp(build, compiler, target));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"build\");\n-        rustc_cargo(build, target, &mut cargo);\n+        rustc_cargo(build, &mut cargo);\n         run_cargo(build,\n                   &mut cargo,\n                   &librustc_stamp(build, compiler, target),\n@@ -501,14 +501,14 @@ impl Step for Rustc {\n     }\n }\n \n-/// Same as `std_cargo`, but for libtest\n-pub fn rustc_cargo(build: &Build,\n-                   target: Interned<String>,\n-                   cargo: &mut Command) {\n+pub fn rustc_cargo(build: &Build, cargo: &mut Command) {\n     cargo.arg(\"--features\").arg(build.rustc_features())\n          .arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/Cargo.toml\"));\n+    rustc_cargo_env(build, cargo);\n+}\n \n+fn rustc_cargo_env(build: &Build, cargo: &mut Command) {\n     // Set some configuration variables picked up by build scripts and\n     // the compiler alike\n     cargo.env(\"CFG_RELEASE\", build.rust_release())\n@@ -536,27 +536,6 @@ pub fn rustc_cargo(build: &Build,\n     if !build.unstable_features() {\n         cargo.env(\"CFG_DISABLE_UNSTABLE_FEATURES\", \"1\");\n     }\n-    // Flag that rust llvm is in use\n-    if build.is_rust_llvm(target) {\n-        cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n-    }\n-    cargo.env(\"LLVM_CONFIG\", build.llvm_config(target));\n-    let target_config = build.config.target_config.get(&target);\n-    if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n-        cargo.env(\"CFG_LLVM_ROOT\", s);\n-    }\n-    // Building with a static libstdc++ is only supported on linux right now,\n-    // not for MSVC or macOS\n-    if build.config.llvm_static_stdcpp &&\n-       !target.contains(\"freebsd\") &&\n-       !target.contains(\"windows\") &&\n-       !target.contains(\"apple\") {\n-        cargo.env(\"LLVM_STATIC_STDCPP\",\n-                  compiler_file(build.cxx(target).unwrap(), \"libstdc++.a\"));\n-    }\n-    if build.config.llvm_link_shared {\n-        cargo.env(\"LLVM_LINK_SHARED\", \"1\");\n-    }\n     if let Some(ref s) = build.config.rustc_default_linker {\n         cargo.env(\"CFG_DEFAULT_LINKER\", s);\n     }\n@@ -601,6 +580,137 @@ impl Step for RustcLink {\n     }\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct RustcTrans {\n+    pub compiler: Compiler,\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for RustcTrans {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/librustc_trans\").krate(\"rustc_trans\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(RustcTrans {\n+            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+            target: run.target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+        let target = self.target;\n+\n+        builder.ensure(Rustc { compiler, target });\n+\n+        // Build LLVM for our target. This will implicitly build the host LLVM\n+        // if necessary.\n+        builder.ensure(native::Llvm { target });\n+\n+        if build.force_use_stage1(compiler, target) {\n+            builder.ensure(RustcTrans {\n+                compiler: builder.compiler(1, build.build),\n+                target,\n+            });\n+            return;\n+        }\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-rustc_trans\", compiler.stage));\n+        println!(\"Building stage{} trans artifacts ({} -> {})\",\n+                 compiler.stage, &compiler.host, target);\n+\n+        let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"build\");\n+        cargo.arg(\"--manifest-path\")\n+            .arg(build.src.join(\"src/librustc_trans/Cargo.toml\"))\n+            .arg(\"--features\").arg(build.rustc_features());\n+        rustc_cargo_env(build, &mut cargo);\n+\n+        // Pass down configuration from the LLVM build into the build of\n+        // librustc_llvm and librustc_trans.\n+        if build.is_rust_llvm(target) {\n+            cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n+        }\n+        cargo.env(\"LLVM_CONFIG\", build.llvm_config(target));\n+        let target_config = build.config.target_config.get(&target);\n+        if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n+            cargo.env(\"CFG_LLVM_ROOT\", s);\n+        }\n+        // Building with a static libstdc++ is only supported on linux right now,\n+        // not for MSVC or macOS\n+        if build.config.llvm_static_stdcpp &&\n+           !target.contains(\"freebsd\") &&\n+           !target.contains(\"windows\") &&\n+           !target.contains(\"apple\") {\n+            let file = compiler_file(build,\n+                                     build.cxx(target).unwrap(),\n+                                     target,\n+                                     \"libstdc++.a\");\n+            cargo.env(\"LLVM_STATIC_STDCPP\", file);\n+        }\n+        if build.config.llvm_link_shared {\n+            cargo.env(\"LLVM_LINK_SHARED\", \"1\");\n+        }\n+\n+        run_cargo(build,\n+                  &mut cargo,\n+                  &librustc_trans_stamp(build, compiler, target),\n+                  false);\n+    }\n+}\n+\n+/// Creates the `codegen-backends` folder for a compiler that's about to be\n+/// assembled as a complete compiler.\n+///\n+/// This will take the codegen artifacts produced by `compiler` and link them\n+/// into an appropriate location for `target_compiler` to be a functional\n+/// compiler.\n+fn copy_codegen_backends_to_sysroot(builder: &Builder,\n+                                    compiler: Compiler,\n+                                    target_compiler: Compiler) {\n+    let build = builder.build;\n+    let target = target_compiler.host;\n+\n+    // Note that this step is different than all the other `*Link` steps in\n+    // that it's not assembling a bunch of libraries but rather is primarily\n+    // moving the codegen backend into place. The codegen backend of rustc is\n+    // not linked into the main compiler by default but is rather dynamically\n+    // selected at runtime for inclusion.\n+    //\n+    // Here we're looking for the output dylib of the `RustcTrans` step and\n+    // we're copying that into the `codegen-backends` folder.\n+    let libdir = builder.sysroot_libdir(target_compiler, target);\n+    let dst = libdir.join(\"codegen-backends\");\n+    t!(fs::create_dir_all(&dst));\n+    let stamp = librustc_trans_stamp(build, compiler, target);\n+\n+    let mut copied = None;\n+    for file in read_stamp_file(&stamp) {\n+        let filename = match file.file_name().and_then(|s| s.to_str()) {\n+            Some(s) => s,\n+            None => continue,\n+        };\n+        if !is_dylib(filename) || !filename.contains(\"rustc_trans-\") {\n+            continue\n+        }\n+        match copied {\n+            None => copied = Some(file.clone()),\n+            Some(ref s) => {\n+                panic!(\"copied two codegen backends:\\n{}\\n{}\",\n+                       s.display(),\n+                       file.display());\n+            }\n+        }\n+        copy(&file, &dst.join(filename));\n+    }\n+    assert!(copied.is_some(), \"failed to find a codegen backend to copy\");\n+}\n+\n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n pub fn libstd_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n@@ -619,9 +729,20 @@ pub fn librustc_stamp(build: &Build, compiler: Compiler, target: Interned<String\n     build.cargo_out(compiler, Mode::Librustc, target).join(\".librustc.stamp\")\n }\n \n-fn compiler_file(compiler: &Path, file: &str) -> PathBuf {\n-    let out = output(Command::new(compiler)\n-                            .arg(format!(\"-print-file-name={}\", file)));\n+pub fn librustc_trans_stamp(build: &Build,\n+                            compiler: Compiler,\n+                            target: Interned<String>) -> PathBuf {\n+    build.cargo_out(compiler, Mode::Librustc, target).join(\".librustc_trans.stamp\")\n+}\n+\n+fn compiler_file(build: &Build,\n+                 compiler: &Path,\n+                 target: Interned<String>,\n+                 file: &str) -> PathBuf {\n+    let mut cmd = Command::new(compiler);\n+    cmd.args(build.cflags(target));\n+    cmd.arg(format!(\"-print-file-name={}\", file));\n+    let out = output(&mut cmd);\n     PathBuf::from(out.trim())\n }\n \n@@ -690,20 +811,23 @@ impl Step for Assemble {\n         }\n \n         // Get the compiler that we'll use to bootstrap ourselves.\n-        let build_compiler = if target_compiler.host != build.build {\n-            // Build a compiler for the host platform. We cannot use the stage0\n-            // compiler for the host platform for this because it doesn't have\n-            // the libraries we need.  FIXME: Perhaps we should download those\n-            // libraries? It would make builds faster...\n-            // FIXME: It may be faster if we build just a stage 1\n-            // compiler and then use that to bootstrap this compiler\n-            // forward.\n-            builder.compiler(target_compiler.stage - 1, build.build)\n-        } else {\n-            // Build the compiler we'll use to build the stage requested. This\n-            // may build more than one compiler (going down to stage 0).\n-            builder.compiler(target_compiler.stage - 1, target_compiler.host)\n-        };\n+        //\n+        // Note that this is where the recursive nature of the bootstrap\n+        // happens, as this will request the previous stage's compiler on\n+        // downwards to stage 0.\n+        //\n+        // Also note that we're building a compiler for the host platform. We\n+        // only assume that we can run `build` artifacts, which means that to\n+        // produce some other architecture compiler we need to start from\n+        // `build` to get there.\n+        //\n+        // FIXME: Perhaps we should download those libraries?\n+        //        It would make builds faster...\n+        //\n+        // FIXME: It may be faster if we build just a stage 1 compiler and then\n+        //        use that to bootstrap this compiler forward.\n+        let build_compiler =\n+            builder.compiler(target_compiler.stage - 1, build.build);\n \n         // Build the libraries for this compiler to link to (i.e., the libraries\n         // it uses at runtime). NOTE: Crates the target compiler compiles don't\n@@ -721,7 +845,14 @@ impl Step for Assemble {\n                 builder.ensure(RustcLink { compiler, target_compiler, target });\n             }\n         } else {\n-            builder.ensure(Rustc { compiler: build_compiler, target: target_compiler.host });\n+            builder.ensure(Rustc {\n+                compiler: build_compiler,\n+                target: target_compiler.host,\n+            });\n+            builder.ensure(RustcTrans {\n+                compiler: build_compiler,\n+                target: target_compiler.host,\n+            });\n         }\n \n         let stage = target_compiler.stage;\n@@ -740,9 +871,12 @@ impl Step for Assemble {\n             }\n         }\n \n-        let out_dir = build.cargo_out(build_compiler, Mode::Librustc, host);\n+        copy_codegen_backends_to_sysroot(builder,\n+                                         build_compiler,\n+                                         target_compiler);\n \n         // Link the compiler binary itself into place\n+        let out_dir = build.cargo_out(build_compiler, Mode::Librustc, host);\n         let rustc = out_dir.join(exe(\"rustc\", &*host));\n         let bindir = sysroot.join(\"bin\");\n         t!(fs::create_dir_all(&bindir));"}, {"sha": "4127239dc49b87d27eed38ff93fa3f7302f290dd", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -434,6 +434,15 @@ impl Step for Rustc {\n                 }\n             }\n \n+            // Copy over the codegen backends\n+            let backends_src = builder.sysroot_libdir(compiler, host)\n+                .join(\"codegen-backends\");\n+            let backends_dst = image.join(\"lib/rustlib\")\n+                .join(&*host)\n+                .join(\"lib/codegen-backends\");\n+            t!(fs::create_dir_all(&backends_dst));\n+            cp_r(&backends_src, &backends_dst);\n+\n             // Man pages\n             t!(fs::create_dir_all(image.join(\"share/man/man1\")));\n             let man_src = build.src.join(\"src/doc/man\");\n@@ -581,7 +590,9 @@ impl Step for Std {\n         t!(fs::create_dir_all(&dst));\n         let mut src = builder.sysroot_libdir(compiler, target).to_path_buf();\n         src.pop(); // Remove the trailing /lib folder from the sysroot_libdir\n-        cp_r(&src, &dst);\n+        cp_filtered(&src, &dst, &|path| {\n+            path.file_name().and_then(|s| s.to_str()) != Some(\"codegen-backends\")\n+        });\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")"}, {"sha": "6a75fc5112f5c2d07043aaf0063cbc0744d3415e", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -617,7 +617,7 @@ impl Step for Rustc {\n         t!(symlink_dir_force(&my_out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"doc\");\n-        compile::rustc_cargo(build, target, &mut cargo);\n+        compile::rustc_cargo(build, &mut cargo);\n \n         if build.config.compiler_docs {\n             // src/rustc/Cargo.toml contains a bin crate called rustc which"}, {"sha": "8928bef9faa56b5d5172f58c10e6f0f869e000c1", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -432,9 +432,6 @@ impl Build {\n         if self.config.use_jemalloc {\n             features.push_str(\" jemalloc\");\n         }\n-        if self.config.llvm_enabled {\n-            features.push_str(\" llvm\");\n-        }\n         features\n     }\n "}, {"sha": "442098a7afa77d7bfd55342149e66ace16b163d7", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -57,11 +57,6 @@ impl Step for Llvm {\n         let build = builder.build;\n         let target = self.target;\n \n-        // If we're not compiling for LLVM bail out here.\n-        if !build.config.llvm_enabled {\n-            return;\n-        }\n-\n         // If we're using a custom LLVM bail out here, but we can only use a\n         // custom LLVM for the build triple.\n         if let Some(config) = build.config.target_config.get(&target) {"}, {"sha": "a316b0f7ef91b7ef1da39d9c64a6bc212b66e141", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -900,6 +900,8 @@ impl Step for Compiletest {\n             cmd.env(\"PROFILER_SUPPORT\", \"1\");\n         }\n \n+        cmd.env(\"RUST_TEST_TMPDIR\", build.out.join(\"tmp\"));\n+\n         cmd.arg(\"--adb-path\").arg(\"adb\");\n         cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n         if target.contains(\"android\") {\n@@ -1209,7 +1211,7 @@ impl Step for Crate {\n             }\n             Mode::Librustc => {\n                 builder.ensure(compile::Rustc { compiler, target });\n-                compile::rustc_cargo(build, target, &mut cargo);\n+                compile::rustc_cargo(build, &mut cargo);\n                 (\"librustc\", \"rustc-main\")\n             }\n             _ => panic!(\"can only test libraries\"),"}, {"sha": "2c4898cb2c006dc61f1dfbe69d9910c6d94bd319", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -14,7 +14,7 @@ bitflags = \"1.0\"\n fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n jobserver = \"0.1\"\n-log = \"0.4\"\n+log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n@@ -26,7 +26,6 @@ syntax_pos = { path = \"../libsyntax_pos\" }\n backtrace = \"0.3.3\"\n byteorder = { version = \"1.1\", features = [\"i128\"]}\n \n-\n # Note that these dependencies are a lie, they're just here to get linkage to\n # work.\n #"}, {"sha": "18493b8bb39406cab6e41d8b9a48c44a6dc93d97", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -11,7 +11,7 @@ crate-type = [\"dylib\"]\n [dependencies]\n arena = { path = \"../libarena\" }\n graphviz = { path = \"../libgraphviz\" }\n-log = { version = \"0.4\", features = [\"release_max_level_info\"] }\n+log = \"0.4\"\n env_logger = { version = \"0.4\", default-features = false }\n rustc = { path = \"../librustc\" }\n rustc_allocator = { path = \"../librustc_allocator\" }\n@@ -29,7 +29,6 @@ rustc_plugin = { path = \"../librustc_plugin\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n-rustc_trans = { path = \"../librustc_trans\", optional = true }\n rustc_trans_utils = { path = \"../librustc_trans_utils\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n serialize = { path = \"../libserialize\" }\n@@ -38,6 +37,3 @@ syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n \n ar = \"0.3.0\"\n-\n-[features]\n-llvm = [\"rustc_trans\"]"}, {"sha": "029cceda532e56add40a15bc1a50be1c5fc5ae43", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 242, "deletions": 48, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -47,8 +47,6 @@ extern crate rustc_metadata;\n extern crate rustc_mir;\n extern crate rustc_resolve;\n extern crate rustc_save_analysis;\n-#[cfg(feature=\"llvm\")]\n-pub extern crate rustc_trans;\n extern crate rustc_trans_utils;\n extern crate rustc_typeck;\n extern crate serialize;\n@@ -68,30 +66,36 @@ use rustc::session::{self, config, Session, build_session, CompileResult};\n use rustc::session::CompileIncomplete;\n use rustc::session::config::{Input, PrintRequest, ErrorOutputType};\n use rustc::session::config::nightly_options;\n+use rustc::session::filesearch;\n use rustc::session::{early_error, early_warn};\n use rustc::lint::Lint;\n use rustc::lint;\n use rustc::middle::cstore::CrateStore;\n use rustc_metadata::locator;\n use rustc_metadata::cstore::CStore;\n+use rustc_metadata::dynamic_lib::DynamicLibrary;\n use rustc::util::common::{time, ErrorReported};\n use rustc_trans_utils::trans_crate::TransCrate;\n \n use serialize::json::ToJson;\n \n use std::any::Any;\n-use std::cmp::max;\n use std::cmp::Ordering::Equal;\n+use std::cmp::max;\n use std::default::Default;\n+use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};\n use std::env;\n use std::ffi::OsString;\n use std::io::{self, Read, Write};\n use std::iter::repeat;\n+use std::mem;\n use std::panic;\n-use std::path::PathBuf;\n+use std::path::{PathBuf, Path};\n use std::process::{self, Command, Stdio};\n use std::rc::Rc;\n use std::str;\n+use std::sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Ordering};\n+use std::sync::{Once, ONCE_INIT};\n use std::thread;\n \n use syntax::ast;\n@@ -176,57 +180,247 @@ pub fn run<F>(run_compiler: F) -> isize\n     0\n }\n \n-#[cfg(not(feature=\"llvm\"))]\n-pub use rustc_trans_utils::trans_crate::MetadataOnlyTransCrate as DefaultTransCrate;\n-#[cfg(feature=\"llvm\")]\n-pub use rustc_trans::LlvmTransCrate as DefaultTransCrate;\n+fn load_backend_from_dylib(path: &Path) -> fn() -> Box<TransCrate> {\n+    // Note that we're specifically using `open_global_now` here rather than\n+    // `open`, namely we want the behavior on Unix of RTLD_GLOBAL and RTLD_NOW,\n+    // where NOW means \"bind everything right now\" because we don't want\n+    // surprises later on and RTLD_GLOBAL allows the symbols to be made\n+    // available for future dynamic libraries opened. This is currently used by\n+    // loading LLVM and then making its symbols available for other dynamic\n+    // libraries.\n+    let lib = match DynamicLibrary::open_global_now(path) {\n+        Ok(lib) => lib,\n+        Err(err) => {\n+            let err = format!(\"couldn't load codegen backend {:?}: {:?}\",\n+                              path,\n+                              err);\n+            early_error(ErrorOutputType::default(), &err);\n+        }\n+    };\n+    unsafe {\n+        match lib.symbol(\"__rustc_codegen_backend\") {\n+            Ok(f) => {\n+                mem::forget(lib);\n+                mem::transmute::<*mut u8, _>(f)\n+            }\n+            Err(e) => {\n+                let err = format!(\"couldn't load codegen backend as it \\\n+                                   doesn't export the `__rustc_codegen_backend` \\\n+                                   symbol: {:?}\", e);\n+                early_error(ErrorOutputType::default(), &err);\n+            }\n+        }\n+    }\n+}\n \n-#[cfg(not(feature=\"llvm\"))]\n-pub mod rustc_trans {\n-    pub use rustc_trans_utils::trans_crate::MetadataOnlyTransCrate as LlvmTransCrate;\n+pub fn get_trans(sess: &Session) -> Box<TransCrate> {\n+    static INIT: Once = ONCE_INIT;\n+    static mut LOAD: fn() -> Box<TransCrate> = || unreachable!();\n+\n+    INIT.call_once(|| {\n+        let trans_name = sess.opts.debugging_opts.codegen_backend.as_ref();\n+        let backend = match trans_name.map(|s| &**s) {\n+            None |\n+            Some(\"llvm\") => get_trans_default(),\n+            Some(\"metadata_only\") => {\n+                rustc_trans_utils::trans_crate::MetadataOnlyTransCrate::new\n+            }\n+            Some(filename) if filename.contains(\".\") => {\n+                load_backend_from_dylib(filename.as_ref())\n+            }\n+            Some(trans_name) => {\n+                sess.fatal(&format!(\"unknown codegen backend {}\", trans_name));\n+            }\n+        };\n \n-    pub fn print_version() {}\n-    pub fn print_passes() {}\n+        unsafe {\n+            LOAD = backend;\n+        }\n+    });\n+    let backend = unsafe { LOAD() };\n+    backend.init(sess);\n+    backend\n }\n \n-fn load_backend_from_dylib(sess: &Session, backend_name: &str) -> Box<TransCrate> {\n-    use std::path::Path;\n-    use rustc_metadata::dynamic_lib::DynamicLibrary;\n-\n-    match DynamicLibrary::open(Some(Path::new(backend_name))) {\n-        Ok(lib) => {\n-            unsafe {\n-                let trans = {\n-                    let __rustc_codegen_backend: unsafe fn(&Session) -> Box<TransCrate>;\n-                    __rustc_codegen_backend = match lib.symbol(\"__rustc_codegen_backend\") {\n-                        Ok(f) => ::std::mem::transmute::<*mut u8, _>(f),\n-                        Err(e) => sess.fatal(&format!(\"Couldnt load codegen backend as it\\\n-                        doesn't export the __rustc_backend_new symbol: {:?}\", e)),\n-                    };\n-                    __rustc_codegen_backend(sess)\n-                };\n-                ::std::mem::forget(lib);\n-                trans\n+fn get_trans_default() -> fn() -> Box<TransCrate> {\n+    // For now we only allow this function to be called once as it'll dlopen a\n+    // few things, which seems to work best if we only do that once. In\n+    // general this assertion never trips due to the once guard in `get_trans`,\n+    // but there's a few manual calls to this function in this file we protect\n+    // against.\n+    static LOADED: AtomicBool = ATOMIC_BOOL_INIT;\n+    assert!(!LOADED.fetch_or(true, Ordering::SeqCst),\n+            \"cannot load the default trans backend twice\");\n+\n+    // When we're compiling this library with `--test` it'll run as a binary but\n+    // not actually exercise much functionality. As a result most of the logic\n+    // here is defunkt (it assumes we're a dynamic library in a sysroot) so\n+    // let's just return a dummy creation function which won't be used in\n+    // general anyway.\n+    if cfg!(test) {\n+        return rustc_trans_utils::trans_crate::MetadataOnlyTransCrate::new\n+    }\n+\n+    let target = session::config::host_triple();\n+    let mut sysroot_candidates = vec![filesearch::get_or_default_sysroot()];\n+    let path = current_dll_path()\n+        .and_then(|s| s.canonicalize().ok());\n+    if let Some(dll) = path {\n+        // use `parent` twice to chop off the file name and then also the\n+        // directory containing the dll which should be either `lib` or `bin`.\n+        if let Some(path) = dll.parent().and_then(|p| p.parent()) {\n+            // The original `path` pointed at the `rustc_driver` crate's dll.\n+            // Now that dll should only be in one of two locations. The first is\n+            // in the compiler's libdir, for example `$sysroot/lib/*.dll`. The\n+            // other is the target's libdir, for example\n+            // `$sysroot/lib/rustlib/$target/lib/*.dll`.\n+            //\n+            // We don't know which, so let's assume that if our `path` above\n+            // ends in `$target` we *could* be in the target libdir, and always\n+            // assume that we may be in the main libdir.\n+            sysroot_candidates.push(path.to_owned());\n+\n+            if path.ends_with(target) {\n+                sysroot_candidates.extend(path.parent() // chop off `$target`\n+                    .and_then(|p| p.parent())           // chop off `rustlib`\n+                    .and_then(|p| p.parent())           // chop off `lib`\n+                    .map(|s| s.to_owned()));\n             }\n         }\n-        Err(err) => {\n-            sess.fatal(&format!(\"Couldnt load codegen backend {:?}: {:?}\", backend_name, err));\n+    }\n+\n+    let sysroot = sysroot_candidates.iter()\n+        .map(|sysroot| {\n+            let libdir = filesearch::relative_target_lib_path(&sysroot, &target);\n+            sysroot.join(&libdir).join(\"codegen-backends\")\n+        })\n+        .filter(|f| {\n+            info!(\"codegen backend candidate: {}\", f.display());\n+            f.exists()\n+        })\n+        .next();\n+    let sysroot = match sysroot {\n+        Some(path) => path,\n+        None => {\n+            let candidates = sysroot_candidates.iter()\n+                .map(|p| p.display().to_string())\n+                .collect::<Vec<_>>()\n+                .join(\"\\n* \");\n+            let err = format!(\"failed to find a `codegen-backends` folder \\\n+                               in the sysroot candidates:\\n* {}\", candidates);\n+            early_error(ErrorOutputType::default(), &err);\n+        }\n+    };\n+    info!(\"probing {} for a codegen backend\", sysroot.display());\n+\n+    let d = match sysroot.read_dir() {\n+        Ok(d) => d,\n+        Err(e) => {\n+            let err = format!(\"failed to load default codegen backend, couldn't \\\n+                               read `{}`: {}\", sysroot.display(), e);\n+            early_error(ErrorOutputType::default(), &err);\n         }\n+    };\n+\n+    let mut file: Option<PathBuf> = None;\n+\n+    for entry in d.filter_map(|e| e.ok()) {\n+        let path = entry.path();\n+        let filename = match path.file_name().and_then(|s| s.to_str()) {\n+            Some(s) => s,\n+            None => continue,\n+        };\n+        if !(filename.starts_with(DLL_PREFIX) && filename.ends_with(DLL_SUFFIX)) {\n+            continue\n+        }\n+        let name = &filename[DLL_PREFIX.len() .. filename.len() - DLL_SUFFIX.len()];\n+        if !name.starts_with(\"rustc_trans\") {\n+            continue\n+        }\n+        if let Some(ref prev) = file {\n+            let err = format!(\"duplicate codegen backends found\\n\\\n+                first:  {}\\n\\\n+                second: {}\\n\\\n+            \", prev.display(), path.display());\n+            early_error(ErrorOutputType::default(), &err);\n+        }\n+        file = Some(path.clone());\n     }\n-}\n \n-pub fn get_trans(sess: &Session) -> Box<TransCrate> {\n-    let trans_name = sess.opts.debugging_opts.codegen_backend.clone();\n-    match trans_name.as_ref().map(|s|&**s) {\n-        None => DefaultTransCrate::new(&sess),\n-        Some(\"llvm\") => rustc_trans::LlvmTransCrate::new(&sess),\n-        Some(\"metadata_only\") => {\n-            rustc_trans_utils::trans_crate::MetadataOnlyTransCrate::new(&sess)\n+    match file {\n+        Some(ref s) => return load_backend_from_dylib(s),\n+        None => {\n+            let err = format!(\"failed to load default codegen backend, no appropriate \\\n+                               codegen dylib found in `{}`\", sysroot.display());\n+            early_error(ErrorOutputType::default(), &err);\n         }\n-        Some(filename) if filename.contains(\".\") => {\n-            load_backend_from_dylib(&sess, &filename)\n+    }\n+\n+    #[cfg(unix)]\n+    fn current_dll_path() -> Option<PathBuf> {\n+        use std::ffi::{OsStr, CStr};\n+        use std::os::unix::prelude::*;\n+\n+        unsafe {\n+            let addr = current_dll_path as usize as *mut _;\n+            let mut info = mem::zeroed();\n+            if libc::dladdr(addr, &mut info) == 0 {\n+                info!(\"dladdr failed\");\n+                return None\n+            }\n+            if info.dli_fname.is_null() {\n+                info!(\"dladdr returned null pointer\");\n+                return None\n+            }\n+            let bytes = CStr::from_ptr(info.dli_fname).to_bytes();\n+            let os = OsStr::from_bytes(bytes);\n+            Some(PathBuf::from(os))\n+        }\n+    }\n+\n+    #[cfg(windows)]\n+    fn current_dll_path() -> Option<PathBuf> {\n+        use std::ffi::OsString;\n+        use std::os::windows::prelude::*;\n+\n+        extern \"system\" {\n+            fn GetModuleHandleExW(dwFlags: u32,\n+                                  lpModuleName: usize,\n+                                  phModule: *mut usize) -> i32;\n+            fn GetModuleFileNameW(hModule: usize,\n+                                  lpFilename: *mut u16,\n+                                  nSize: u32) -> u32;\n+        }\n+\n+        const GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS: u32 = 0x00000004;\n+\n+        unsafe {\n+            let mut module = 0;\n+            let r = GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n+                                       current_dll_path as usize,\n+                                       &mut module);\n+            if r == 0 {\n+                info!(\"GetModuleHandleExW failed: {}\", io::Error::last_os_error());\n+                return None\n+            }\n+            let mut space = Vec::with_capacity(1024);\n+            let r = GetModuleFileNameW(module,\n+                                       space.as_mut_ptr(),\n+                                       space.capacity() as u32);\n+            if r == 0 {\n+                info!(\"GetModuleFileNameW failed: {}\", io::Error::last_os_error());\n+                return None\n+            }\n+            let r = r as usize;\n+            if r >= space.capacity() {\n+                info!(\"our buffer was too small? {}\",\n+                      io::Error::last_os_error());\n+                return None\n+            }\n+            space.set_len(r);\n+            let os = OsString::from_wide(&space);\n+            Some(PathBuf::from(os))\n         }\n-        Some(trans_name) => sess.fatal(&format!(\"Unknown codegen backend {}\", trans_name)),\n     }\n }\n \n@@ -878,7 +1072,7 @@ pub fn version(binary: &str, matches: &getopts::Matches) {\n         println!(\"commit-date: {}\", unw(commit_date_str()));\n         println!(\"host: {}\", config::host_triple());\n         println!(\"release: {}\", unw(release_str()));\n-        rustc_trans::print_version();\n+        get_trans_default()().print_version();\n     }\n }\n \n@@ -1175,7 +1369,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     }\n \n     if cg_flags.contains(&\"passes=list\".to_string()) {\n-        rustc_trans::print_passes();\n+        get_trans_default()().print_passes();\n         return None;\n     }\n \n@@ -1284,8 +1478,8 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     all_errors.extend_from_slice(&rustc_typeck::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_resolve::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n-    #[cfg(feature=\"llvm\")]\n-    all_errors.extend_from_slice(&rustc_trans::DIAGNOSTICS);\n+    // FIXME: need to figure out a way to get these back in here\n+    // all_errors.extend_from_slice(get_trans(sess).diagnostics());\n     all_errors.extend_from_slice(&rustc_trans_utils::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_const_eval::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_metadata::DIAGNOSTICS);"}, {"sha": "4ae6a93d6983a12bd8535c7b19f1fca136ce4401", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -228,7 +228,8 @@ impl PpSourceMode {\n             }\n             PpmTyped => {\n                 let control = &driver::CompileController::basic();\n-                abort_on_err(driver::phase_3_run_analysis_passes(&*::DefaultTransCrate::new(&sess),\n+                let trans = ::get_trans(sess);\n+                abort_on_err(driver::phase_3_run_analysis_passes(&*trans,\n                                                                  control,\n                                                                  sess,\n                                                                  cstore,\n@@ -1081,7 +1082,8 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n     let mut out = Vec::new();\n \n     let control = &driver::CompileController::basic();\n-    abort_on_err(driver::phase_3_run_analysis_passes(&*::DefaultTransCrate::new(&sess),\n+    let trans = ::get_trans(sess);\n+    abort_on_err(driver::phase_3_run_analysis_passes(&*trans,\n                                                      control,\n                                                      sess,\n                                                      cstore,"}, {"sha": "45e97127ede7f81634e3861ff7171e8c8ad3a220", "filename": "src/librustc_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2FCargo.toml?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -7,13 +7,13 @@ build = \"build.rs\"\n [lib]\n name = \"rustc_llvm\"\n path = \"lib.rs\"\n-crate-type = [\"dylib\"]\n \n [features]\n static-libstdcpp = []\n \n [dependencies]\n bitflags = \"1.0\"\n+libc = \"0.2\"\n rustc_cratesio_shim = { path = \"../librustc_cratesio_shim\" }\n \n [build-dependencies]"}, {"sha": "49b93f3c7d6a248fd37b9020a5b606b582ef6849", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -146,6 +146,7 @@ fn main() {\n         cfg.define(&flag, None);\n     }\n \n+    println!(\"cargo:rerun-if-changed-env=LLVM_RUSTLLVM\");\n     if env::var_os(\"LLVM_RUSTLLVM\").is_some() {\n         cfg.define(\"LLVM_RUSTLLVM\", None);\n     }"}, {"sha": "d7da0d00012e15261e1ffd2f4c7df5271bf374a6", "filename": "src/librustc_metadata/dynamic_lib.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdynamic_lib.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -38,7 +38,17 @@ impl DynamicLibrary {\n         // run.\n         match maybe_library {\n             Err(err) => Err(err),\n-            Ok(handle) => Ok(DynamicLibrary { handle: handle })\n+            Ok(handle) => Ok(DynamicLibrary { handle })\n+        }\n+    }\n+\n+    /// Load a dynamic library into the global namespace (RTLD_GLOBAL on Unix)\n+    /// and do it now (don't use RTLD_LAZY on Unix).\n+    pub fn open_global_now(filename: &Path) -> Result<DynamicLibrary, String> {\n+        let maybe_library = dl::open_global_now(filename.as_os_str());\n+        match maybe_library {\n+            Err(err) => Err(err),\n+            Ok(handle) => Ok(DynamicLibrary { handle })\n         }\n     }\n \n@@ -145,15 +155,20 @@ mod dl {\n         })\n     }\n \n-    const LAZY: libc::c_int = 1;\n+    pub fn open_global_now(filename: &OsStr) -> Result<*mut u8, String> {\n+        check_for_errors_in(|| unsafe {\n+            let s = CString::new(filename.as_bytes()).unwrap();\n+            libc::dlopen(s.as_ptr(), libc::RTLD_GLOBAL | libc::RTLD_NOW) as *mut u8\n+        })\n+    }\n \n     unsafe fn open_external(filename: &OsStr) -> *mut u8 {\n         let s = CString::new(filename.as_bytes()).unwrap();\n-        libc::dlopen(s.as_ptr(), LAZY) as *mut u8\n+        libc::dlopen(s.as_ptr(), libc::RTLD_LAZY) as *mut u8\n     }\n \n     unsafe fn open_internal() -> *mut u8 {\n-        libc::dlopen(ptr::null(), LAZY) as *mut u8\n+        libc::dlopen(ptr::null(), libc::RTLD_LAZY) as *mut u8\n     }\n \n     pub fn check_for_errors_in<T, F>(f: F) -> Result<T, String> where\n@@ -224,6 +239,10 @@ mod dl {\n         fn FreeLibrary(handle: HMODULE) -> BOOL;\n     }\n \n+    pub fn open_global_now(filename: &OsStr) -> Result<*mut u8, String> {\n+        open(Some(filename))\n+    }\n+\n     pub fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n         // disable \"dll load failed\" error dialog.\n         let prev_error_mode = unsafe {"}, {"sha": "14591de31ca96efb13651121530e7e4a79f3c41f", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -13,6 +13,7 @@ test = false\n bitflags = \"1.0\"\n flate2 = \"1.0\"\n jobserver = \"0.1.5\"\n+libc = \"0.2\"\n log = \"0.4\"\n num_cpus = \"1.0\"\n rustc = { path = \"../librustc\" }\n@@ -36,3 +37,6 @@ tempdir = \"0.3\"\n \n [target.\"cfg(windows)\".dependencies]\n cc = \"1.0.1\"\n+\n+[features]\n+jemalloc = [\"rustc_back/jemalloc\"]"}, {"sha": "908d3790170acd110ba21fe75811844c1ad3c15a", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -69,7 +69,7 @@ extern crate tempdir;\n \n use back::bytecode::RLIB_BYTECODE_EXTENSION;\n \n-pub use llvm_util::{target_features, print_version, print_passes};\n+pub use llvm_util::target_features;\n \n use std::any::Any;\n use std::path::PathBuf;\n@@ -149,13 +149,16 @@ impl !Send for LlvmTransCrate {} // Llvm is on a per-thread basis\n impl !Sync for LlvmTransCrate {}\n \n impl LlvmTransCrate {\n-    pub fn new(sess: &Session) -> Box<TransCrate> {\n-        llvm_util::init(sess); // Make sure llvm is inited\n+    pub fn new() -> Box<TransCrate> {\n         box LlvmTransCrate(())\n     }\n }\n \n impl TransCrate for LlvmTransCrate {\n+    fn init(&self, sess: &Session) {\n+        llvm_util::init(sess); // Make sure llvm is inited\n+    }\n+\n     fn print(&self, req: PrintRequest, sess: &Session) {\n         match req {\n             PrintRequest::RelocationModels => {\n@@ -183,6 +186,19 @@ impl TransCrate for LlvmTransCrate {\n         }\n     }\n \n+    fn print_passes(&self) {\n+        llvm_util::print_passes();\n+    }\n+\n+    fn print_version(&self) {\n+        llvm_util::print_version();\n+    }\n+\n+    #[cfg(not(stage0))]\n+    fn diagnostics(&self) -> &[(&'static str, &'static str)] {\n+        &DIAGNOSTICS\n+    }\n+\n     fn target_features(&self, sess: &Session) -> Vec<Symbol> {\n         target_features(sess)\n     }\n@@ -252,8 +268,8 @@ impl TransCrate for LlvmTransCrate {\n \n /// This is the entrypoint for a hot plugged rustc_trans\n #[no_mangle]\n-pub fn __rustc_codegen_backend(sess: &Session) -> Box<TransCrate> {\n-    LlvmTransCrate::new(sess)\n+pub fn __rustc_codegen_backend() -> Box<TransCrate> {\n+    LlvmTransCrate::new()\n }\n \n struct ModuleTranslation {"}, {"sha": "e14abdff3391830cd130df181c2588ec3aa99803", "filename": "src/librustc_trans_utils/trans_crate.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Ftrans_crate.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -48,8 +48,12 @@ use rustc_mir::monomorphize::collector;\n use link::{build_link_meta, out_filename};\n \n pub trait TransCrate {\n+    fn init(&self, _sess: &Session) {}\n     fn print(&self, _req: PrintRequest, _sess: &Session) {}\n     fn target_features(&self, _sess: &Session) -> Vec<Symbol> { vec![] }\n+    fn print_passes(&self) {}\n+    fn print_version(&self) {}\n+    fn diagnostics(&self) -> &[(&'static str, &'static str)] { &[] }\n \n     fn metadata_loader(&self) -> Box<MetadataLoader>;\n     fn provide(&self, _providers: &mut Providers);\n@@ -168,7 +172,13 @@ pub struct OngoingCrateTranslation {\n }\n \n impl MetadataOnlyTransCrate {\n-    pub fn new(sess: &Session) -> Box<TransCrate> {\n+    pub fn new() -> Box<TransCrate> {\n+        box MetadataOnlyTransCrate(())\n+    }\n+}\n+\n+impl TransCrate for MetadataOnlyTransCrate {\n+    fn init(&self, sess: &Session) {\n         for cty in sess.opts.crate_types.iter() {\n             match *cty {\n                 CrateType::CrateTypeRlib | CrateType::CrateTypeDylib |\n@@ -180,12 +190,8 @@ impl MetadataOnlyTransCrate {\n                 },\n             }\n         }\n-\n-        box MetadataOnlyTransCrate(())\n     }\n-}\n \n-impl TransCrate for MetadataOnlyTransCrate {\n     fn metadata_loader(&self) -> Box<MetadataLoader> {\n         box NoLlvmMetadataLoader\n     }"}, {"sha": "0674a0b5a3b1096863cc3d4316a22e4a95de575f", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc_lint;\n-use rustc_driver::{driver, target_features, abort_on_err};\n+use rustc_driver::{self, driver, target_features, abort_on_err};\n use rustc::session::{self, config};\n use rustc::hir::def_id::DefId;\n use rustc::hir::def::Def;\n@@ -18,7 +18,6 @@ use rustc::ty::{self, TyCtxt, AllArenas};\n use rustc::hir::map as hir_map;\n use rustc::lint;\n use rustc::util::nodemap::FxHashMap;\n-use rustc_trans;\n use rustc_resolve as resolve;\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n@@ -151,7 +150,7 @@ pub fn run_core(search_paths: SearchPaths,\n     let mut sess = session::build_session_(\n         sessopts, cpath, diagnostic_handler, codemap,\n     );\n-    let trans = rustc_trans::LlvmTransCrate::new(&sess);\n+    let trans = rustc_driver::get_trans(&sess);\n     let cstore = Rc::new(CStore::new(trans.metadata_loader()));\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n "}, {"sha": "e39fe20310c2851a8288033b32fed37c2376e9a8", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -63,8 +63,6 @@ use std::path::{Path, PathBuf};\n use std::process;\n use std::sync::mpsc::channel;\n \n-use rustc_driver::rustc_trans;\n-\n use externalfiles::ExternalHtml;\n use rustc::session::search_paths::SearchPaths;\n use rustc::session::config::{ErrorOutputType, RustcOptGroup, nightly_options,"}, {"sha": "d61b80c9aa03efae6e6504473926a20c96fe68e8", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -33,7 +33,6 @@ use rustc_driver::{self, driver, Compilation};\n use rustc_driver::driver::phase_2_configure_and_expand;\n use rustc_metadata::cstore::CStore;\n use rustc_resolve::MakeGlobMap;\n-use rustc_trans;\n use syntax::ast;\n use syntax::codemap::CodeMap;\n use syntax::feature_gate::UnstableFeatures;\n@@ -84,7 +83,7 @@ pub fn run(input_path: &Path,\n     let mut sess = session::build_session_(\n         sessopts, Some(input_path.to_owned()), handler, codemap.clone(),\n     );\n-    let trans = rustc_trans::LlvmTransCrate::new(&sess);\n+    let trans = rustc_driver::get_trans(&sess);\n     let cstore = Rc::new(CStore::new(trans.metadata_loader()));\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     sess.parse_sess.config =\n@@ -249,7 +248,7 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n     let mut sess = session::build_session_(\n         sessopts, None, diagnostic_handler, codemap,\n     );\n-    let trans = rustc_trans::LlvmTransCrate::new(&sess);\n+    let trans = rustc_driver::get_trans(&sess);\n     let cstore = Rc::new(CStore::new(trans.metadata_loader()));\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n "}, {"sha": "bbc4c2ee43e079dd9cb0f2900aaf68e586c6d5bd", "filename": "src/rustc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Frustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Frustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.toml?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -7,12 +7,9 @@ version = \"0.0.0\"\n name = \"rustc\"\n path = \"rustc.rs\"\n \n-# All optional dependencies so the features passed to this Cargo.toml select\n-# what should actually be built.\n [dependencies]\n rustc_back = { path = \"../librustc_back\" }\n rustc_driver = { path = \"../librustc_driver\" }\n \n [features]\n jemalloc = [\"rustc_back/jemalloc\"]\n-llvm = [\"rustc_driver/llvm\"]"}, {"sha": "5972149590c23cfaf25903f161d3d0aab84bcb6e", "filename": "src/test/run-make/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Ftest%2Frun-make%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Ftest%2Frun-make%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -77,6 +77,6 @@ impl TransCrate for TheBackend {\n \n /// This is the entrypoint for a hot plugged rustc_trans\n #[no_mangle]\n-pub fn __rustc_codegen_backend(sess: &Session) -> Box<TransCrate> {\n-    Box::new(TheBackend(MetadataOnlyTransCrate::new(sess)))\n+pub fn __rustc_codegen_backend() -> Box<TransCrate> {\n+    Box::new(TheBackend(MetadataOnlyTransCrate::new()))\n }"}, {"sha": "b4b29e15ce174c4c08a14c07459d3d833df34c03", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -15,7 +15,6 @@ extern crate rustc_driver;\n extern crate rustc_lint;\n extern crate rustc_metadata;\n extern crate rustc_errors;\n-extern crate rustc_trans;\n extern crate rustc_trans_utils;\n extern crate syntax;\n \n@@ -63,7 +62,7 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>, Box<TransCrate>) {\n \n     let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n     let sess = build_session(opts, None, descriptions);\n-    let trans = rustc_trans::LlvmTransCrate::new(&sess);\n+    let trans = rustc_driver::get_trans(&sess);\n     let cstore = Rc::new(CStore::new(trans.metadata_loader()));\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     (sess, cstore, trans)"}, {"sha": "8a18aadf36a8bb635684927b165c09f869f0c862", "filename": "src/test/run-make/llvm-pass/Makefile", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Ftest%2Frun-make%2Fllvm-pass%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Ftest%2Frun-make%2Fllvm-pass%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fllvm-pass%2FMakefile?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -1,5 +1,9 @@\n -include ../tools.mk\n \n+ifeq ($(UNAME),Darwin)\n+PLUGIN_FLAGS := -C link-args=-Wl,-undefined,dynamic_lookup\n+endif\n+\n ifeq ($(findstring stage1,$(RUST_BUILD_STAGE)),stage1)\n # ignore stage1\n all:\n@@ -11,7 +15,7 @@ ifdef IS_WINDOWS\n all:\n else\n all: $(call NATIVE_STATICLIB,llvm-function-pass) $(call NATIVE_STATICLIB,llvm-module-pass)\n-\t$(RUSTC) plugin.rs -C prefer-dynamic\n+\t$(RUSTC) plugin.rs -C prefer-dynamic $(PLUGIN_FLAGS)\n \t$(RUSTC) main.rs\n \n $(TMPDIR)/libllvm-function-pass.o:"}, {"sha": "f77b2fca857a613e3759bb50b4fec40995186fc6", "filename": "src/test/run-make/llvm-pass/plugin.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Ftest%2Frun-make%2Fllvm-pass%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Ftest%2Frun-make%2Fllvm-pass%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fllvm-pass%2Fplugin.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -14,7 +14,6 @@\n \n extern crate rustc;\n extern crate rustc_plugin;\n-extern crate rustc_trans;\n \n #[link(name = \"llvm-function-pass\", kind = \"static\")]\n #[link(name = \"llvm-module-pass\", kind = \"static\")]"}, {"sha": "a35eed1f72d7913814a43ef64c2c8b62cf48802a", "filename": "src/test/run-pass-fulldeps/create-dir-all-bare.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Ftest%2Frun-pass-fulldeps%2Fcreate-dir-all-bare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Ftest%2Frun-pass-fulldeps%2Fcreate-dir-all-bare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcreate-dir-all-bare.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -8,18 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-cross-compile\n-\n-#![feature(rustc_private)]\n-\n-extern crate tempdir;\n-\n use std::env;\n use std::fs;\n-use tempdir::TempDir;\n+use std::path::PathBuf;\n \n fn main() {\n-    let td = TempDir::new(\"create-dir-all-bare\").unwrap();\n-    env::set_current_dir(td.path()).unwrap();\n+    let path = PathBuf::from(env::var_os(\"RUST_TEST_TMPDIR\").unwrap());\n+    env::set_current_dir(&path).unwrap();\n     fs::create_dir_all(\"create-dir-all-bare\").unwrap();\n }"}, {"sha": "15ac1d55cc8c41a2164112f0f917eac8dff55bda", "filename": "src/test/run-pass-fulldeps/issue-15149.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Ftest%2Frun-pass-fulldeps%2Fissue-15149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Ftest%2Frun-pass-fulldeps%2Fissue-15149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-15149.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -11,15 +11,11 @@\n // no-prefer-dynamic\n // ignore-cross-compile\n \n-#![feature(rustc_private)]\n-\n-extern crate tempdir;\n-\n use std::env;\n use std::fs;\n use std::process;\n use std::str;\n-use tempdir::TempDir;\n+use std::path::PathBuf;\n \n fn main() {\n     // If we're the child, make sure we were invoked correctly\n@@ -41,8 +37,9 @@ fn test() {\n     let my_path = env::current_exe().unwrap();\n     let my_dir  = my_path.parent().unwrap();\n \n-    let child_dir = TempDir::new_in(&my_dir, \"issue-15140-child\").unwrap();\n-    let child_dir = child_dir.path();\n+    let child_dir = PathBuf::from(env::var_os(\"RUST_TEST_TMPDIR\").unwrap());\n+    let child_dir = child_dir.join(\"issue-15140-child\");\n+    fs::create_dir_all(&child_dir).unwrap();\n \n     let child_path = child_dir.join(&format!(\"mytest{}\",\n                                              env::consts::EXE_SUFFIX));\n@@ -63,11 +60,4 @@ fn test() {\n             format!(\"child assertion failed\\n child stdout:\\n {}\\n child stderr:\\n {}\",\n                     str::from_utf8(&child_output.stdout).unwrap(),\n                     str::from_utf8(&child_output.stderr).unwrap()));\n-\n-    let res = fs::remove_dir_all(&child_dir);\n-    if res.is_err() {\n-        // On Windows deleting just executed mytest.exe can fail because it's still locked\n-        std::thread::sleep_ms(1000);\n-        fs::remove_dir_all(&child_dir).unwrap();\n-    }\n }"}, {"sha": "417707e89322c27611f685ec7a724d73c87a7a3c", "filename": "src/test/run-pass-fulldeps/rename-directory.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Ftest%2Frun-pass-fulldeps%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Ftest%2Frun-pass-fulldeps%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frename-directory.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -13,17 +13,13 @@\n \n // ignore-cross-compile\n \n-#![feature(rustc_private)]\n-\n-extern crate tempdir;\n-\n+use std::env;\n use std::ffi::CString;\n use std::fs::{self, File};\n-use tempdir::TempDir;\n+use std::path::PathBuf;\n \n fn rename_directory() {\n-    let tmpdir = TempDir::new(\"rename_directory\").ok().expect(\"rename_directory failed\");\n-    let tmpdir = tmpdir.path();\n+    let tmpdir = PathBuf::from(env::var_os(\"RUST_TEST_TMPDIR\").unwrap());\n     let old_path = tmpdir.join(\"foo/bar/baz\");\n     fs::create_dir_all(&old_path).unwrap();\n     let test_file = &old_path.join(\"temp.txt\");"}, {"sha": "5b28ce0f0c68da7ae13d20e28387493e5201f3d4", "filename": "src/test/run-pass-fulldeps/stdio-from.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Ftest%2Frun-pass-fulldeps%2Fstdio-from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Ftest%2Frun-pass-fulldeps%2Fstdio-from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fstdio-from.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -10,17 +10,12 @@\n \n // ignore-cross-compile\n \n-#![feature(rustc_private)]\n-\n-extern crate tempdir;\n-\n use std::env;\n use std::fs::File;\n use std::io;\n use std::io::{Read, Write};\n use std::process::{Command, Stdio};\n-\n-use tempdir::TempDir;\n+use std::path::PathBuf;\n \n fn main() {\n     if env::args().len() > 1 {\n@@ -31,9 +26,9 @@ fn main() {\n }\n \n fn parent() -> io::Result<()> {\n-    let td = TempDir::new(\"foo\").unwrap();\n-    let input = td.path().join(\"input\");\n-    let output = td.path().join(\"output\");\n+    let td = PathBuf::from(env::var_os(\"RUST_TEST_TMPDIR\").unwrap());\n+    let input = td.join(\"stdio-from-input\");\n+    let output = td.join(\"stdio-from-output\");\n \n     File::create(&input)?.write_all(b\"foo\\n\")?;\n "}, {"sha": "316b97f17ef94eeb44f0bcecfa24ddbec6ac6f05", "filename": "src/test/run-pass-fulldeps/switch-stdout.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Ftest%2Frun-pass-fulldeps%2Fswitch-stdout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Ftest%2Frun-pass-fulldeps%2Fswitch-stdout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fswitch-stdout.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -8,14 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_private)]\n-\n-extern crate tempdir;\n-\n+use std::env;\n use std::fs::File;\n use std::io::{Read, Write};\n-\n-use tempdir::TempDir;\n+use std::path::PathBuf;\n \n #[cfg(unix)]\n fn switch_stdout_to(file: File) {\n@@ -48,8 +44,8 @@ fn switch_stdout_to(file: File) {\n }\n \n fn main() {\n-    let td = TempDir::new(\"foo\").unwrap();\n-    let path = td.path().join(\"bar\");\n+    let path = PathBuf::from(env::var_os(\"RUST_TEST_TMPDIR\").unwrap());\n+    let path = path.join(\"switch-stdout-output\");\n     let f = File::create(&path).unwrap();\n \n     println!(\"foo\");"}, {"sha": "e3d453a991d802d3e23dbc5717ee4cc6cedbeba0", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/87990a119aa1ce77f294253cde836518870b8032/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87990a119aa1ce77f294253cde836518870b8032/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=87990a119aa1ce77f294253cde836518870b8032", "patch": "@@ -667,9 +667,16 @@ fn up_to_date(config: &Config, testpaths: &TestPaths, props: &EarlyProps) -> boo\n     for pretty_printer_file in &pretty_printer_files {\n         inputs.push(mtime(&rust_src_dir.join(pretty_printer_file)));\n     }\n-    for lib in config.run_lib_path.read_dir().unwrap() {\n-        let lib = lib.unwrap();\n-        inputs.push(mtime(&lib.path()));\n+    let mut entries = config.run_lib_path.read_dir().unwrap()\n+        .collect::<Vec<_>>();\n+    while let Some(entry) = entries.pop() {\n+        let entry = entry.unwrap();\n+        let path = entry.path();\n+        if entry.metadata().unwrap().is_file() {\n+            inputs.push(mtime(&path));\n+        } else {\n+            entries.extend(path.read_dir().unwrap());\n+        }\n     }\n     if let Some(ref rustdoc_path) = config.rustdoc_path {\n         inputs.push(mtime(&rustdoc_path));"}]}