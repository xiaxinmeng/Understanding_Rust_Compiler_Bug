{"sha": "82161cda33406ae8dda08b3e4afe97a44b193792", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyMTYxY2RhMzM0MDZhZThkZGEwOGIzZTRhZmU5N2E0NGIxOTM3OTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-15T23:28:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-15T23:28:50Z"}, "message": "Auto merge of #66326 - Nadrieril:refactor-intrange, r=varkor\n\nRefactor integer range handling in the usefulness algorithm\n\nInteger range handling had accumulated a lot of debt. This cleans up a lot of it.\n\nIn particular this:\n- removes unnecessary conversions between `Const` and `u128`, and between `Constructor` and `IntRange`\n- clearly distinguishes between on the one hand ranges of integers that may or may not be matched exhaustively, and on the other hand ranges of non-integers that are never matched exhaustively and are compared using Const-based shenanigans\n- cleans up some overly complicated code paths\n- generally tries to be more idiomatic.\n\nAs a nice side-effect, I measured a 10% perf increase on `unicode_normalization`.\n\nThere's one thing that I feel remains to clean up: the [overlapping range check](https://github.com/rust-lang/rust/pull/64007), which is currently quite ad-hoc. But that is intricate enough that I'm leaving it out of this PR.\n\nThere's also one little thing I'm not sure I understand: can `try_eval_bits` fail for an integer constant value in that code ? What would that mean, and how do I construct a test case for this possibility ?", "tree": {"sha": "2ae422e100de8b311906a73ddb011a143fa74ee6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ae422e100de8b311906a73ddb011a143fa74ee6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82161cda33406ae8dda08b3e4afe97a44b193792", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82161cda33406ae8dda08b3e4afe97a44b193792", "html_url": "https://github.com/rust-lang/rust/commit/82161cda33406ae8dda08b3e4afe97a44b193792", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82161cda33406ae8dda08b3e4afe97a44b193792/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bd30ce2aac40c7698aa4a1b9520aa649ff2d1c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bd30ce2aac40c7698aa4a1b9520aa649ff2d1c5", "html_url": "https://github.com/rust-lang/rust/commit/1bd30ce2aac40c7698aa4a1b9520aa649ff2d1c5"}, {"sha": "694a511df5e7473a696b50d30c3428bd0d54f140", "url": "https://api.github.com/repos/rust-lang/rust/commits/694a511df5e7473a696b50d30c3428bd0d54f140", "html_url": "https://github.com/rust-lang/rust/commit/694a511df5e7473a696b50d30c3428bd0d54f140"}], "stats": {"total": 602, "additions": 255, "deletions": 347}, "files": [{"sha": "e30d6819d04f1bfa7442b03ef0fbfe3f5f6a9a6e", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 233, "deletions": 346, "changes": 579, "blob_url": "https://github.com/rust-lang/rust/blob/82161cda33406ae8dda08b3e4afe97a44b193792/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82161cda33406ae8dda08b3e4afe97a44b193792/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=82161cda33406ae8dda08b3e4afe97a44b193792", "patch": "@@ -313,10 +313,11 @@ impl PatternFolder<'tcx> for LiteralExpander<'tcx> {\n             (\n                 &ty::Ref(_, rty, _),\n                 &PatKind::Constant {\n-                    value: Const {\n-                        val: ty::ConstKind::Value(val),\n-                        ty: ty::TyS { kind: ty::Ref(_, crty, _), .. }\n-                    },\n+                    value:\n+                        Const {\n+                            val: ty::ConstKind::Value(val),\n+                            ty: ty::TyS { kind: ty::Ref(_, crty, _), .. },\n+                        },\n                 },\n             ) => Pat {\n                 ty: pat.ty,\n@@ -328,7 +329,7 @@ impl PatternFolder<'tcx> for LiteralExpander<'tcx> {\n                         kind: box PatKind::Constant {\n                             value: self.tcx.mk_const(Const {\n                                 val: ty::ConstKind::Value(\n-                                    self.fold_const_value_deref(*val, rty, crty)\n+                                    self.fold_const_value_deref(*val, rty, crty),\n                                 ),\n                                 ty: rty,\n                             }),\n@@ -581,17 +582,19 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq)]\n enum Constructor<'tcx> {\n     /// The constructor of all patterns that don't vary by constructor,\n     /// e.g., struct patterns and fixed-length arrays.\n     Single,\n     /// Enum variants.\n     Variant(DefId),\n     /// Literal values.\n-    ConstantValue(&'tcx ty::Const<'tcx>, Span),\n-    /// Ranges of literal values (`2..=5` and `2..5`).\n-    ConstantRange(u128, u128, Ty<'tcx>, RangeEnd, Span),\n+    ConstantValue(&'tcx ty::Const<'tcx>),\n+    /// Ranges of integer literal values (`2`, `2..=5` or `2..5`).\n+    IntRange(IntRange<'tcx>),\n+    /// Ranges of floating-point literal values (`2.0..=5.2`).\n+    FloatRange(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>, RangeEnd),\n     /// Array patterns of length `n`.\n     FixedLenSlice(u64),\n     /// Slice patterns. Captures any array constructor of `length >= i + j`.\n@@ -600,28 +603,6 @@ enum Constructor<'tcx> {\n     NonExhaustive,\n }\n \n-// Ignore spans when comparing, they don't carry semantic information as they are only for lints.\n-impl<'tcx> std::cmp::PartialEq for Constructor<'tcx> {\n-    fn eq(&self, other: &Self) -> bool {\n-        match (self, other) {\n-            (Constructor::Single, Constructor::Single) => true,\n-            (Constructor::NonExhaustive, Constructor::NonExhaustive) => true,\n-            (Constructor::Variant(a), Constructor::Variant(b)) => a == b,\n-            (Constructor::ConstantValue(a, _), Constructor::ConstantValue(b, _)) => a == b,\n-            (\n-                Constructor::ConstantRange(a_start, a_end, a_ty, a_range_end, _),\n-                Constructor::ConstantRange(b_start, b_end, b_ty, b_range_end, _),\n-            ) => a_start == b_start && a_end == b_end && a_ty == b_ty && a_range_end == b_range_end,\n-            (Constructor::FixedLenSlice(a), Constructor::FixedLenSlice(b)) => a == b,\n-            (\n-                Constructor::VarLenSlice(a_prefix, a_suffix),\n-                Constructor::VarLenSlice(b_prefix, b_suffix),\n-            ) => a_prefix == b_prefix && a_suffix == b_suffix,\n-            _ => false,\n-        }\n-    }\n-}\n-\n impl<'tcx> Constructor<'tcx> {\n     fn is_slice(&self) -> bool {\n         match self {\n@@ -641,48 +622,20 @@ impl<'tcx> Constructor<'tcx> {\n                 assert!(!adt.is_enum());\n                 VariantIdx::new(0)\n             }\n-            ConstantValue(c, _) => crate::const_eval::const_variant_index(cx.tcx, cx.param_env, c),\n+            ConstantValue(c) => crate::const_eval::const_variant_index(cx.tcx, cx.param_env, c),\n             _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt),\n         }\n     }\n \n-    fn display(&self, tcx: TyCtxt<'tcx>) -> String {\n-        match self {\n-            Constructor::ConstantValue(val, _) => format!(\"{}\", val),\n-            Constructor::ConstantRange(lo, hi, ty, range_end, _) => {\n-                // Get the right sign on the output:\n-                let ty = ty::ParamEnv::empty().and(*ty);\n-                format!(\n-                    \"{}{}{}\",\n-                    ty::Const::from_bits(tcx, *lo, ty),\n-                    range_end,\n-                    ty::Const::from_bits(tcx, *hi, ty),\n-                )\n-            }\n-            Constructor::FixedLenSlice(val) => format!(\"[{}]\", val),\n-            Constructor::VarLenSlice(prefix, suffix) => format!(\"[{}, .., {}]\", prefix, suffix),\n-            _ => bug!(\"bad constructor being displayed: `{:?}\", self),\n-        }\n-    }\n-\n     // Returns the set of constructors covered by `self` but not by\n     // anything in `other_ctors`.\n-    fn subtract_ctors(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        other_ctors: &Vec<Constructor<'tcx>>,\n-    ) -> Vec<Constructor<'tcx>> {\n-        match *self {\n+    fn subtract_ctors(&self, other_ctors: &Vec<Constructor<'tcx>>) -> Vec<Constructor<'tcx>> {\n+        match self {\n             // Those constructors can only match themselves.\n-            Single | Variant(_) => {\n-                if other_ctors.iter().any(|c| c == self) {\n-                    vec![]\n-                } else {\n-                    vec![self.clone()]\n-                }\n+            Single | Variant(_) | ConstantValue(..) | FloatRange(..) => {\n+                if other_ctors.iter().any(|c| c == self) { vec![] } else { vec![self.clone()] }\n             }\n-            FixedLenSlice(self_len) => {\n+            &FixedLenSlice(self_len) => {\n                 let overlaps = |c: &Constructor<'_>| match *c {\n                     FixedLenSlice(other_len) => other_len == self_len,\n                     VarLenSlice(prefix, suffix) => prefix + suffix <= self_len,\n@@ -753,39 +706,38 @@ impl<'tcx> Constructor<'tcx> {\n \n                 remaining_ctors\n             }\n-            ConstantRange(..) | ConstantValue(..) => {\n-                let mut remaining_ctors = vec![self.clone()];\n+            IntRange(self_range) => {\n+                let mut remaining_ranges = vec![self_range.clone()];\n                 for other_ctor in other_ctors {\n-                    if other_ctor == self {\n-                        // If a constructor appears in a `match` arm, we can\n-                        // eliminate it straight away.\n-                        remaining_ctors = vec![]\n-                    } else if let Some(interval) = IntRange::from_ctor(tcx, param_env, other_ctor) {\n-                        // Refine the required constructors for the type by subtracting\n-                        // the range defined by the current constructor pattern.\n-                        remaining_ctors = interval.subtract_from(tcx, param_env, remaining_ctors);\n-                    }\n+                    if let IntRange(other_range) = other_ctor {\n+                        if other_range == self_range {\n+                            // If the `self` range appears directly in a `match` arm, we can\n+                            // eliminate it straight away.\n+                            remaining_ranges = vec![];\n+                        } else {\n+                            // Otherwise explicitely compute the remaining ranges.\n+                            remaining_ranges = other_range.subtract_from(remaining_ranges);\n+                        }\n \n-                    // If the constructor patterns that have been considered so far\n-                    // already cover the entire range of values, then we know the\n-                    // constructor is not missing, and we can move on to the next one.\n-                    if remaining_ctors.is_empty() {\n-                        break;\n+                        // If the ranges that have been considered so far already cover the entire\n+                        // range of values, we can return early.\n+                        if remaining_ranges.is_empty() {\n+                            break;\n+                        }\n                     }\n                 }\n \n-                // If a constructor has not been matched, then it is missing.\n-                // We add `remaining_ctors` instead of `self`, because then we can\n-                // provide more detailed error information about precisely which\n-                // ranges have been omitted.\n-                remaining_ctors\n+                // Convert the ranges back into constructors.\n+                remaining_ranges.into_iter().map(IntRange).collect()\n             }\n             // This constructor is never covered by anything else\n             NonExhaustive => vec![NonExhaustive],\n         }\n     }\n \n     /// This returns one wildcard pattern for each argument to this constructor.\n+    ///\n+    /// This must be consistent with `apply`, `specialize_one_pattern`, and `arity`.\n     fn wildcard_subpatterns<'a>(\n         &self,\n         cx: &MatchCheckCtxt<'a, 'tcx>,\n@@ -853,7 +805,7 @@ impl<'tcx> Constructor<'tcx> {\n                 }\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n             },\n-            ConstantValue(..) | ConstantRange(..) | NonExhaustive => vec![],\n+            ConstantValue(..) | FloatRange(..) | IntRange(..) | NonExhaustive => vec![],\n         }\n     }\n \n@@ -862,6 +814,8 @@ impl<'tcx> Constructor<'tcx> {\n     ///\n     /// For instance, a tuple pattern `(_, 42, Some([]))` has the arity of 3.\n     /// A struct pattern's arity is the number of fields it contains, etc.\n+    ///\n+    /// This must be consistent with `wildcard_subpatterns`, `specialize_one_pattern`, and `apply`.\n     fn arity<'a>(&self, cx: &MatchCheckCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> u64 {\n         debug!(\"Constructor::arity({:#?}, {:?})\", self, ty);\n         match self {\n@@ -876,13 +830,15 @@ impl<'tcx> Constructor<'tcx> {\n             },\n             FixedLenSlice(length) => *length,\n             VarLenSlice(prefix, suffix) => prefix + suffix,\n-            ConstantValue(..) | ConstantRange(..) | NonExhaustive => 0,\n+            ConstantValue(..) | FloatRange(..) | IntRange(..) | NonExhaustive => 0,\n         }\n     }\n \n     /// Apply a constructor to a list of patterns, yielding a new pattern. `pats`\n     /// must have as many elements as this constructor's arity.\n     ///\n+    /// This must be consistent with `wildcard_subpatterns`, `specialize_one_pattern`, and `arity`.\n+    ///\n     /// Examples:\n     /// `self`: `Constructor::Single`\n     /// `ty`: `(u32, u32, u32)`\n@@ -937,12 +893,9 @@ impl<'tcx> Constructor<'tcx> {\n                 let wild = Pat::wildcard_from_ty(ty);\n                 PatKind::Slice { prefix, slice: Some(wild), suffix }\n             }\n-            &ConstantValue(value, _) => PatKind::Constant { value },\n-            &ConstantRange(lo, hi, ty, end, _) => PatKind::Range(PatRange {\n-                lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n-                hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n-                end,\n-            }),\n+            &ConstantValue(value) => PatKind::Constant { value },\n+            &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n+            IntRange(range) => return range.to_pat(cx.tcx),\n             NonExhaustive => PatKind::Wild,\n         };\n \n@@ -1139,11 +1092,17 @@ fn all_constructors<'a, 'tcx>(\n     pcx: PatCtxt<'tcx>,\n ) -> Vec<Constructor<'tcx>> {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n+    let make_range = |start, end| {\n+        IntRange(\n+            // `unwrap()` is ok because we know the type is an integer.\n+            IntRange::from_range(cx.tcx, start, end, pcx.ty, &RangeEnd::Included, pcx.span)\n+                .unwrap(),\n+        )\n+    };\n     match pcx.ty.kind {\n-        ty::Bool => [true, false]\n-            .iter()\n-            .map(|&b| ConstantValue(ty::Const::from_bool(cx.tcx, b), pcx.span))\n-            .collect(),\n+        ty::Bool => {\n+            [true, false].iter().map(|&b| ConstantValue(ty::Const::from_bool(cx.tcx, b))).collect()\n+        }\n         ty::Array(ref sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n             let len = len.eval_usize(cx.tcx, cx.param_env);\n             if len != 0 && cx.is_uninhabited(sub_ty) { vec![] } else { vec![FixedLenSlice(len)] }\n@@ -1202,20 +1161,8 @@ fn all_constructors<'a, 'tcx>(\n         ty::Char => {\n             vec![\n                 // The valid Unicode Scalar Value ranges.\n-                ConstantRange(\n-                    '\\u{0000}' as u128,\n-                    '\\u{D7FF}' as u128,\n-                    cx.tcx.types.char,\n-                    RangeEnd::Included,\n-                    pcx.span,\n-                ),\n-                ConstantRange(\n-                    '\\u{E000}' as u128,\n-                    '\\u{10FFFF}' as u128,\n-                    cx.tcx.types.char,\n-                    RangeEnd::Included,\n-                    pcx.span,\n-                ),\n+                make_range('\\u{0000}' as u128, '\\u{D7FF}' as u128),\n+                make_range('\\u{E000}' as u128, '\\u{10FFFF}' as u128),\n             ]\n         }\n         ty::Int(_) | ty::Uint(_)\n@@ -1231,12 +1178,12 @@ fn all_constructors<'a, 'tcx>(\n             let bits = Integer::from_attr(&cx.tcx, SignedInt(ity)).size().bits() as u128;\n             let min = 1u128 << (bits - 1);\n             let max = min - 1;\n-            vec![ConstantRange(min, max, pcx.ty, RangeEnd::Included, pcx.span)]\n+            vec![make_range(min, max)]\n         }\n         ty::Uint(uty) => {\n             let size = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size();\n             let max = truncate(u128::max_value(), size);\n-            vec![ConstantRange(0, max, pcx.ty, RangeEnd::Included, pcx.span)]\n+            vec![make_range(0, max)]\n         }\n         _ => {\n             if cx.is_uninhabited(pcx.ty) {\n@@ -1274,6 +1221,20 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n+    fn is_singleton(&self) -> bool {\n+        self.range.start() == self.range.end()\n+    }\n+\n+    fn boundaries(&self) -> (u128, u128) {\n+        (*self.range.start(), *self.range.end())\n+    }\n+\n+    /// Don't treat `usize`/`isize` exhaustively unless the `precise_pointer_size_matching` feature\n+    /// is enabled.\n+    fn treat_exhaustively(&self, tcx: TyCtxt<'tcx>) -> bool {\n+        !self.ty.is_ptr_sized_integral() || tcx.features().precise_pointer_size_matching\n+    }\n+\n     #[inline]\n     fn integral_size_and_signed_bias(tcx: TyCtxt<'tcx>, ty: Ty<'_>) -> Option<(Size, u128)> {\n         match ty.kind {\n@@ -1296,9 +1257,9 @@ impl<'tcx> IntRange<'tcx> {\n     ) -> Option<IntRange<'tcx>> {\n         if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, value.ty) {\n             let ty = value.ty;\n-            let val = if let ty::ConstKind::Value(ConstValue::Scalar(\n-                Scalar::Raw { data, size }\n-            )) = value.val {\n+            let val = if let ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data, size })) =\n+                value.val\n+            {\n                 // For this specific pattern we can skip a lot of effort and go\n                 // straight to the result, after doing a bit of checking. (We\n                 // could remove this branch and just use the next branch, which\n@@ -1332,57 +1293,25 @@ impl<'tcx> IntRange<'tcx> {\n             // which makes the interval arithmetic simpler.\n             let bias = IntRange::signed_bias(tcx, ty);\n             let (lo, hi) = (lo ^ bias, hi ^ bias);\n-            // Make sure the interval is well-formed.\n-            if lo > hi || lo == hi && *end == RangeEnd::Excluded {\n-                None\n-            } else {\n-                let offset = (*end == RangeEnd::Excluded) as u128;\n-                Some(IntRange { range: lo..=(hi - offset), ty, span })\n+            let offset = (*end == RangeEnd::Excluded) as u128;\n+            if lo > hi || (lo == hi && *end == RangeEnd::Excluded) {\n+                // This should have been caught earlier by E0030.\n+                bug!(\"malformed range pattern: {}..={}\", lo, (hi - offset));\n             }\n+            Some(IntRange { range: lo..=(hi - offset), ty, span })\n         } else {\n             None\n         }\n     }\n \n-    fn from_ctor(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ctor: &Constructor<'tcx>,\n-    ) -> Option<IntRange<'tcx>> {\n-        // Floating-point ranges are permitted and we don't want\n-        // to consider them when constructing integer ranges.\n-        match ctor {\n-            ConstantRange(lo, hi, ty, end, span) => Self::from_range(tcx, *lo, *hi, ty, end, *span),\n-            ConstantValue(val, span) => Self::from_const(tcx, param_env, val, *span),\n-            _ => None,\n-        }\n-    }\n-\n     fn from_pat(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        mut pat: &Pat<'tcx>,\n+        pat: &Pat<'tcx>,\n     ) -> Option<IntRange<'tcx>> {\n-        loop {\n-            match pat.kind {\n-                box PatKind::Constant { value } => {\n-                    return Self::from_const(tcx, param_env, value, pat.span);\n-                }\n-                box PatKind::Range(PatRange { lo, hi, end }) => {\n-                    return Self::from_range(\n-                        tcx,\n-                        lo.eval_bits(tcx, param_env, lo.ty),\n-                        hi.eval_bits(tcx, param_env, hi.ty),\n-                        &lo.ty,\n-                        &end,\n-                        pat.span,\n-                    );\n-                }\n-                box PatKind::AscribeUserType { ref subpattern, .. } => {\n-                    pat = subpattern;\n-                }\n-                _ => return None,\n-            }\n+        match pat_constructor(tcx, param_env, pat)? {\n+            IntRange(range) => Some(range),\n+            _ => None,\n         }\n     }\n \n@@ -1397,83 +1326,53 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n-    /// Converts a `RangeInclusive` to a `ConstantValue` or inclusive `ConstantRange`.\n-    fn range_to_ctor(\n-        tcx: TyCtxt<'tcx>,\n-        ty: Ty<'tcx>,\n-        r: RangeInclusive<u128>,\n-        span: Span,\n-    ) -> Constructor<'tcx> {\n-        let bias = IntRange::signed_bias(tcx, ty);\n-        let (lo, hi) = r.into_inner();\n-        if lo == hi {\n-            let ty = ty::ParamEnv::empty().and(ty);\n-            ConstantValue(ty::Const::from_bits(tcx, lo ^ bias, ty), span)\n-        } else {\n-            ConstantRange(lo ^ bias, hi ^ bias, ty, RangeEnd::Included, span)\n-        }\n-    }\n-\n     /// Returns a collection of ranges that spans the values covered by `ranges`, subtracted\n     /// by the values covered by `self`: i.e., `ranges \\ self` (in set notation).\n-    fn subtract_from(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ranges: Vec<Constructor<'tcx>>,\n-    ) -> Vec<Constructor<'tcx>> {\n-        let ranges = ranges\n-            .into_iter()\n-            .filter_map(|r| IntRange::from_ctor(tcx, param_env, &r).map(|i| i.range));\n+    fn subtract_from(&self, ranges: Vec<IntRange<'tcx>>) -> Vec<IntRange<'tcx>> {\n         let mut remaining_ranges = vec![];\n         let ty = self.ty;\n-        let (lo, hi) = self.range.into_inner();\n+        let span = self.span;\n+        let (lo, hi) = self.boundaries();\n         for subrange in ranges {\n-            let (subrange_lo, subrange_hi) = subrange.into_inner();\n+            let (subrange_lo, subrange_hi) = subrange.range.into_inner();\n             if lo > subrange_hi || subrange_lo > hi {\n                 // The pattern doesn't intersect with the subrange at all,\n                 // so the subrange remains untouched.\n-                remaining_ranges.push(Self::range_to_ctor(\n-                    tcx,\n-                    ty,\n-                    subrange_lo..=subrange_hi,\n-                    self.span,\n-                ));\n+                remaining_ranges.push(IntRange { range: subrange_lo..=subrange_hi, ty, span });\n             } else {\n                 if lo > subrange_lo {\n                     // The pattern intersects an upper section of the\n                     // subrange, so a lower section will remain.\n-                    remaining_ranges.push(Self::range_to_ctor(\n-                        tcx,\n-                        ty,\n-                        subrange_lo..=(lo - 1),\n-                        self.span,\n-                    ));\n+                    remaining_ranges.push(IntRange { range: subrange_lo..=(lo - 1), ty, span });\n                 }\n                 if hi < subrange_hi {\n                     // The pattern intersects a lower section of the\n                     // subrange, so an upper section will remain.\n-                    remaining_ranges.push(Self::range_to_ctor(\n-                        tcx,\n-                        ty,\n-                        (hi + 1)..=subrange_hi,\n-                        self.span,\n-                    ));\n+                    remaining_ranges.push(IntRange { range: (hi + 1)..=subrange_hi, ty, span });\n                 }\n             }\n         }\n         remaining_ranges\n     }\n \n-    fn intersection(&self, other: &Self) -> Option<Self> {\n+    fn is_subrange(&self, other: &Self) -> bool {\n+        other.range.start() <= self.range.start() && self.range.end() <= other.range.end()\n+    }\n+\n+    fn intersection(&self, tcx: TyCtxt<'tcx>, other: &Self) -> Option<Self> {\n         let ty = self.ty;\n-        let (lo, hi) = (*self.range.start(), *self.range.end());\n-        let (other_lo, other_hi) = (*other.range.start(), *other.range.end());\n-        if lo <= other_hi && other_lo <= hi {\n-            let span = other.span;\n-            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi), ty, span })\n+        let (lo, hi) = self.boundaries();\n+        let (other_lo, other_hi) = other.boundaries();\n+        if self.treat_exhaustively(tcx) {\n+            if lo <= other_hi && other_lo <= hi {\n+                let span = other.span;\n+                Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi), ty, span })\n+            } else {\n+                None\n+            }\n         } else {\n-            None\n+            // If the range should not be treated exhaustively, fallback to checking for inclusion.\n+            if self.is_subrange(other) { Some(self.clone()) } else { None }\n         }\n     }\n \n@@ -1489,28 +1388,48 @@ impl<'tcx> IntRange<'tcx> {\n         // `true` in the following cases:\n         // 1 -------          // 1       -------\n         // 2       --------   // 2 -------\n-        let (lo, hi) = (*self.range.start(), *self.range.end());\n-        let (other_lo, other_hi) = (*other.range.start(), *other.range.end());\n+        let (lo, hi) = self.boundaries();\n+        let (other_lo, other_hi) = other.boundaries();\n         (lo == other_hi || hi == other_lo)\n     }\n+\n+    fn to_pat(&self, tcx: TyCtxt<'tcx>) -> Pat<'tcx> {\n+        let (lo, hi) = self.boundaries();\n+\n+        let bias = IntRange::signed_bias(tcx, self.ty);\n+        let (lo, hi) = (lo ^ bias, hi ^ bias);\n+\n+        let ty = ty::ParamEnv::empty().and(self.ty);\n+        let lo_const = ty::Const::from_bits(tcx, lo, ty);\n+        let hi_const = ty::Const::from_bits(tcx, hi, ty);\n+\n+        let kind = if lo == hi {\n+            PatKind::Constant { value: lo_const }\n+        } else {\n+            PatKind::Range(PatRange { lo: lo_const, hi: hi_const, end: RangeEnd::Included })\n+        };\n+\n+        // This is a brand new pattern, so we don't reuse `self.span`.\n+        Pat { ty: self.ty, span: DUMMY_SP, kind: Box::new(kind) }\n+    }\n+}\n+\n+/// Ignore spans when comparing, they don't carry semantic information as they are only for lints.\n+impl<'tcx> std::cmp::PartialEq for IntRange<'tcx> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.range == other.range && self.ty == other.ty\n+    }\n }\n \n // A struct to compute a set of constructors equivalent to `all_ctors \\ used_ctors`.\n struct MissingConstructors<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n     all_ctors: Vec<Constructor<'tcx>>,\n     used_ctors: Vec<Constructor<'tcx>>,\n }\n \n impl<'tcx> MissingConstructors<'tcx> {\n-    fn new(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        all_ctors: Vec<Constructor<'tcx>>,\n-        used_ctors: Vec<Constructor<'tcx>>,\n-    ) -> Self {\n-        MissingConstructors { tcx, param_env, all_ctors, used_ctors }\n+    fn new(all_ctors: Vec<Constructor<'tcx>>, used_ctors: Vec<Constructor<'tcx>>) -> Self {\n+        MissingConstructors { all_ctors, used_ctors }\n     }\n \n     fn into_inner(self) -> (Vec<Constructor<'tcx>>, Vec<Constructor<'tcx>>) {\n@@ -1528,9 +1447,7 @@ impl<'tcx> MissingConstructors<'tcx> {\n \n     /// Iterate over all_ctors \\ used_ctors\n     fn iter<'a>(&'a self) -> impl Iterator<Item = Constructor<'tcx>> + Captures<'a> {\n-        self.all_ctors.iter().flat_map(move |req_ctor| {\n-            req_ctor.subtract_ctors(self.tcx, self.param_env, &self.used_ctors)\n-        })\n+        self.all_ctors.iter().flat_map(move |req_ctor| req_ctor.subtract_ctors(&self.used_ctors))\n     }\n }\n \n@@ -1619,7 +1536,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n \n     debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v.head());\n \n-    if let Some(constructor) = pat_constructor(cx, v.head(), pcx) {\n+    if let Some(constructor) = pat_constructor(cx.tcx, cx.param_env, v.head()) {\n         debug!(\"is_useful - expanding constructor: {:#?}\", constructor);\n         split_grouped_constructors(\n             cx.tcx,\n@@ -1638,7 +1555,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         debug!(\"is_useful - expanding wildcard\");\n \n         let used_ctors: Vec<Constructor<'_>> =\n-            matrix.heads().filter_map(|p| pat_constructor(cx, p, pcx)).collect();\n+            matrix.heads().filter_map(|p| pat_constructor(cx.tcx, cx.param_env, p)).collect();\n         debug!(\"used_ctors = {:#?}\", used_ctors);\n         // `all_ctors` are all the constructors for the given type, which\n         // should all be represented (or caught with the wild pattern `_`).\n@@ -1656,7 +1573,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         // Missing constructors are those that are not matched by any non-wildcard patterns in the\n         // current column. We only fully construct them on-demand, because they're rarely used and\n         // can be big.\n-        let missing_ctors = MissingConstructors::new(cx.tcx, cx.param_env, all_ctors, used_ctors);\n+        let missing_ctors = MissingConstructors::new(all_ctors, used_ctors);\n \n         debug!(\"missing_ctors.empty()={:#?}\", missing_ctors.is_empty(),);\n \n@@ -1741,28 +1658,44 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n /// Determines the constructor that the given pattern can be specialized to.\n /// Returns `None` in case of a catch-all, which can't be specialized.\n fn pat_constructor<'tcx>(\n-    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     pat: &Pat<'tcx>,\n-    pcx: PatCtxt<'tcx>,\n ) -> Option<Constructor<'tcx>> {\n     match *pat.kind {\n-        PatKind::AscribeUserType { ref subpattern, .. } => pat_constructor(cx, subpattern, pcx),\n+        PatKind::AscribeUserType { ref subpattern, .. } => {\n+            pat_constructor(tcx, param_env, subpattern)\n+        }\n         PatKind::Binding { .. } | PatKind::Wild => None,\n         PatKind::Leaf { .. } | PatKind::Deref { .. } => Some(Single),\n         PatKind::Variant { adt_def, variant_index, .. } => {\n             Some(Variant(adt_def.variants[variant_index].def_id))\n         }\n-        PatKind::Constant { value } => Some(ConstantValue(value, pat.span)),\n-        PatKind::Range(PatRange { lo, hi, end }) => Some(ConstantRange(\n-            lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n-            hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n-            lo.ty,\n-            end,\n-            pat.span,\n-        )),\n-        PatKind::Array { .. } => match pcx.ty.kind {\n-            ty::Array(_, length) => Some(FixedLenSlice(length.eval_usize(cx.tcx, cx.param_env))),\n-            _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty),\n+        PatKind::Constant { value } => {\n+            if let Some(int_range) = IntRange::from_const(tcx, param_env, value, pat.span) {\n+                Some(IntRange(int_range))\n+            } else {\n+                Some(ConstantValue(value))\n+            }\n+        }\n+        PatKind::Range(PatRange { lo, hi, end }) => {\n+            let ty = lo.ty;\n+            if let Some(int_range) = IntRange::from_range(\n+                tcx,\n+                lo.eval_bits(tcx, param_env, lo.ty),\n+                hi.eval_bits(tcx, param_env, hi.ty),\n+                ty,\n+                &end,\n+                pat.span,\n+            ) {\n+                Some(IntRange(int_range))\n+            } else {\n+                Some(FloatRange(lo, hi, end))\n+            }\n+        }\n+        PatKind::Array { .. } => match pat.ty.kind {\n+            ty::Array(_, length) => Some(FixedLenSlice(length.eval_usize(tcx, param_env))),\n+            _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pat.ty),\n         },\n         PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n             let prefix = prefix.len() as u64;\n@@ -1851,21 +1784,6 @@ fn slice_pat_covered_by_const<'tcx>(\n     Ok(true)\n }\n \n-// Whether to evaluate a constructor using exhaustive integer matching. This is true if the\n-// constructor is a range or constant with an integer type.\n-fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx>, ctor: &Constructor<'tcx>) -> bool {\n-    let ty = match ctor {\n-        ConstantValue(value, _) => value.ty,\n-        ConstantRange(_, _, ty, _, _) => ty,\n-        _ => return false,\n-    };\n-    if let ty::Char | ty::Int(_) | ty::Uint(_) = ty.kind {\n-        !ty.is_ptr_sized_integral() || tcx.features().precise_pointer_size_matching\n-    } else {\n-        false\n-    }\n-}\n-\n /// For exhaustive integer matching, some constructors are grouped within other constructors\n /// (namely integer typed values are grouped within ranges). However, when specialising these\n /// constructors, we want to be specialising for the underlying constructors (the integers), not\n@@ -1917,11 +1835,13 @@ fn split_grouped_constructors<'p, 'tcx>(\n \n     for ctor in ctors.into_iter() {\n         match ctor {\n-            ConstantRange(..) if should_treat_range_exhaustively(tcx, &ctor) => {\n-                // We only care about finding all the subranges within the range of the constructor\n-                // range. Anything else is irrelevant, because it is guaranteed to result in\n-                // `NotUseful`, which is the default case anyway, and can be ignored.\n-                let ctor_range = IntRange::from_ctor(tcx, param_env, &ctor).unwrap();\n+            IntRange(ctor_range) if ctor_range.treat_exhaustively(tcx) => {\n+                // Fast-track if the range is trivial. In particular, don't do the overlapping\n+                // ranges check.\n+                if ctor_range.is_singleton() {\n+                    split_ctors.push(IntRange(ctor_range));\n+                    continue;\n+                }\n \n                 /// Represents a border between 2 integers. Because the intervals spanning borders\n                 /// must be able to cover every integer, we need to be able to represent\n@@ -1955,7 +1875,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n                         IntRange::from_pat(tcx, param_env, row.head()).map(|r| (r, row.len()))\n                     })\n                     .flat_map(|(range, row_len)| {\n-                        let intersection = ctor_range.intersection(&range);\n+                        let intersection = ctor_range.intersection(tcx, &range);\n                         let should_lint = ctor_range.suspicious_intersection(&range);\n                         if let (Some(range), 1, true) = (&intersection, row_len, should_lint) {\n                             // FIXME: for now, only check for overlapping ranges on simple range\n@@ -1980,23 +1900,24 @@ fn split_grouped_constructors<'p, 'tcx>(\n                 // We're going to iterate through every adjacent pair of borders, making sure that\n                 // each represents an interval of nonnegative length, and convert each such\n                 // interval into a constructor.\n-                for IntRange { range, .. } in\n-                    borders.windows(2).filter_map(|window| match (window[0], window[1]) {\n-                        (Border::JustBefore(n), Border::JustBefore(m)) => {\n-                            if n < m {\n-                                Some(IntRange { range: n..=(m - 1), ty, span })\n-                            } else {\n-                                None\n+                split_ctors.extend(\n+                    borders\n+                        .windows(2)\n+                        .filter_map(|window| match (window[0], window[1]) {\n+                            (Border::JustBefore(n), Border::JustBefore(m)) => {\n+                                if n < m {\n+                                    Some(IntRange { range: n..=(m - 1), ty, span })\n+                                } else {\n+                                    None\n+                                }\n                             }\n-                        }\n-                        (Border::JustBefore(n), Border::AfterMax) => {\n-                            Some(IntRange { range: n..=u128::MAX, ty, span })\n-                        }\n-                        (Border::AfterMax, _) => None,\n-                    })\n-                {\n-                    split_ctors.push(IntRange::range_to_ctor(tcx, ty, range, span));\n-                }\n+                            (Border::JustBefore(n), Border::AfterMax) => {\n+                                Some(IntRange { range: n..=u128::MAX, ty, span })\n+                            }\n+                            (Border::AfterMax, _) => None,\n+                        })\n+                        .map(IntRange),\n+                );\n             }\n             VarLenSlice(self_prefix, self_suffix) => {\n                 // The exhaustiveness-checking paper does not include any details on\n@@ -2076,10 +1997,10 @@ fn split_grouped_constructors<'p, 'tcx>(\n                                     max_fixed_len =\n                                         cmp::max(max_fixed_len, n.eval_usize(tcx, param_env))\n                                 }\n-                                (ty::ConstKind::Value(ConstValue::Slice { start, end, .. }),\n-                                 ty::Slice(_)) => {\n-                                    max_fixed_len = cmp::max(max_fixed_len, (end - start) as u64)\n-                                }\n+                                (\n+                                    ty::ConstKind::Value(ConstValue::Slice { start, end, .. }),\n+                                    ty::Slice(_),\n+                                ) => max_fixed_len = cmp::max(max_fixed_len, (end - start) as u64),\n                                 _ => {}\n                             }\n                         }\n@@ -2143,7 +2064,7 @@ fn lint_overlapping_patterns(\n                 int_range.span,\n                 &format!(\n                     \"this range overlaps on `{}`\",\n-                    IntRange::range_to_ctor(tcx, ty, int_range.range, DUMMY_SP).display(tcx),\n+                    IntRange { range: int_range.range, ty, span: DUMMY_SP }.to_pat(tcx),\n                 ),\n             );\n         }\n@@ -2156,57 +2077,28 @@ fn constructor_covered_by_range<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     ctor: &Constructor<'tcx>,\n     pat: &Pat<'tcx>,\n-) -> Result<bool, ErrorReported> {\n-    let (from, to, end, ty) = match pat.kind {\n-        box PatKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n-        box PatKind::Range(PatRange { lo, hi, end }) => (lo, hi, end, lo.ty),\n+) -> Option<()> {\n+    if let Single = ctor {\n+        return Some(());\n+    }\n+\n+    let (pat_from, pat_to, pat_end, ty) = match *pat.kind {\n+        PatKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n+        PatKind::Range(PatRange { lo, hi, end }) => (lo, hi, end, lo.ty),\n         _ => bug!(\"`constructor_covered_by_range` called with {:?}\", pat),\n     };\n-    trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, from, to, ty);\n-    let cmp_from = |c_from| {\n-        compare_const_vals(tcx, c_from, from, param_env, ty).map(|res| res != Ordering::Less)\n+    let (ctor_from, ctor_to, ctor_end) = match *ctor {\n+        ConstantValue(value) => (value, value, RangeEnd::Included),\n+        FloatRange(from, to, ctor_end) => (from, to, ctor_end),\n+        _ => bug!(\"`constructor_covered_by_range` called with {:?}\", ctor),\n     };\n-    let cmp_to = |c_to| compare_const_vals(tcx, c_to, to, param_env, ty);\n-    macro_rules! some_or_ok {\n-        ($e:expr) => {\n-            match $e {\n-                Some(to) => to,\n-                None => return Ok(false), // not char or int\n-            }\n-        };\n-    }\n-    match *ctor {\n-        ConstantValue(value, _) => {\n-            let to = some_or_ok!(cmp_to(value));\n-            let end =\n-                (to == Ordering::Less) || (end == RangeEnd::Included && to == Ordering::Equal);\n-            Ok(some_or_ok!(cmp_from(value)) && end)\n-        }\n-        ConstantRange(from, to, ty, RangeEnd::Included, _) => {\n-            let to =\n-                some_or_ok!(cmp_to(ty::Const::from_bits(tcx, to, ty::ParamEnv::empty().and(ty),)));\n-            let end =\n-                (to == Ordering::Less) || (end == RangeEnd::Included && to == Ordering::Equal);\n-            Ok(some_or_ok!(cmp_from(ty::Const::from_bits(\n-                tcx,\n-                from,\n-                ty::ParamEnv::empty().and(ty),\n-            ))) && end)\n-        }\n-        ConstantRange(from, to, ty, RangeEnd::Excluded, _) => {\n-            let to =\n-                some_or_ok!(cmp_to(ty::Const::from_bits(tcx, to, ty::ParamEnv::empty().and(ty))));\n-            let end =\n-                (to == Ordering::Less) || (end == RangeEnd::Excluded && to == Ordering::Equal);\n-            Ok(some_or_ok!(cmp_from(ty::Const::from_bits(\n-                tcx,\n-                from,\n-                ty::ParamEnv::empty().and(ty)\n-            ))) && end)\n-        }\n-        Single => Ok(true),\n-        _ => bug!(),\n-    }\n+    trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, pat_from, pat_to, ty);\n+\n+    let to = compare_const_vals(tcx, ctor_to, pat_to, param_env, ty)?;\n+    let from = compare_const_vals(tcx, ctor_from, pat_from, param_env, ty)?;\n+    let intersects = (from == Ordering::Greater || from == Ordering::Equal)\n+        && (to == Ordering::Less || (pat_end == ctor_end && to == Ordering::Equal));\n+    if intersects { Some(()) } else { None }\n }\n \n fn patterns_for_variant<'p, 'a: 'p, 'tcx>(\n@@ -2336,15 +2228,12 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n             // If the constructor is a:\n             // - Single value: add a row if the pattern contains the constructor.\n             // - Range: add a row if the constructor intersects the pattern.\n-            if should_treat_range_exhaustively(cx.tcx, constructor) {\n-                match (\n-                    IntRange::from_ctor(cx.tcx, cx.param_env, constructor),\n-                    IntRange::from_pat(cx.tcx, cx.param_env, pat),\n-                ) {\n-                    (Some(ctor), Some(pat)) => ctor.intersection(&pat).map(|_| {\n-                        let (pat_lo, pat_hi) = pat.range.into_inner();\n-                        let (ctor_lo, ctor_hi) = ctor.range.into_inner();\n-                        assert!(pat_lo <= ctor_lo && ctor_hi <= pat_hi);\n+            if let IntRange(ctor) = constructor {\n+                match IntRange::from_pat(cx.tcx, cx.param_env, pat) {\n+                    Some(pat) => ctor.intersection(cx.tcx, &pat).map(|_| {\n+                        // Constructor splitting should ensure that all intersections we encounter\n+                        // are actually inclusions.\n+                        assert!(ctor.is_subrange(&pat));\n                         PatStack::default()\n                     }),\n                     _ => None,\n@@ -2355,10 +2244,8 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n                 // by `IntRange`. For these cases, the constructor may not be a\n                 // range so intersection actually devolves into being covered\n                 // by the pattern.\n-                match constructor_covered_by_range(cx.tcx, cx.param_env, constructor, pat) {\n-                    Ok(true) => Some(PatStack::default()),\n-                    Ok(false) | Err(ErrorReported) => None,\n-                }\n+                constructor_covered_by_range(cx.tcx, cx.param_env, constructor, pat)\n+                    .map(|()| PatStack::default())\n             }\n         }\n \n@@ -2388,7 +2275,7 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n                     None\n                 }\n             }\n-            ConstantValue(cv, _) => {\n+            ConstantValue(cv) => {\n                 match slice_pat_covered_by_const(\n                     cx.tcx,\n                     pat.span,"}, {"sha": "d379dc44bf10b86682f460e9a3139eb885c6eb36", "filename": "src/test/ui/pattern/usefulness/exhaustive_integer_patterns.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/82161cda33406ae8dda08b3e4afe97a44b193792/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82161cda33406ae8dda08b3e4afe97a44b193792/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.rs?ref=82161cda33406ae8dda08b3e4afe97a44b193792", "patch": "@@ -154,4 +154,19 @@ fn main() {\n     match 0u128 { //~ ERROR non-exhaustive patterns\n         4 ..= u128::MAX => {}\n     }\n+\n+    const FOO: i32 = 42;\n+    const BAR: &i32 = &42;\n+    match &0 {\n+        &42 => {}\n+        &FOO => {} //~ ERROR unreachable pattern\n+        BAR => {} // Not detected as unreachable because `try_eval_bits` fails on `BAR`.\n+        _ => {}\n+    }\n+\n+    // Regression test, see https://github.com/rust-lang/rust/pull/66326#issuecomment-552889933\n+    match &0 {\n+        BAR => {} // ok\n+        _ => {}\n+    }\n }"}, {"sha": "0fbeb981ea015b5cb05f0f362c6f218a9bc6db26", "filename": "src/test/ui/pattern/usefulness/exhaustive_integer_patterns.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82161cda33406ae8dda08b3e4afe97a44b193792/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82161cda33406ae8dda08b3e4afe97a44b193792/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.stderr?ref=82161cda33406ae8dda08b3e4afe97a44b193792", "patch": "@@ -118,6 +118,12 @@ LL |     match 0u128 {\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error: aborting due to 14 previous errors\n+error: unreachable pattern\n+  --> $DIR/exhaustive_integer_patterns.rs:162:9\n+   |\n+LL |         &FOO => {}\n+   |         ^^^^\n+\n+error: aborting due to 15 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}]}