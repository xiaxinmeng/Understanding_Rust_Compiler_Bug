{"sha": "4c784796103173c503e44fcdb12cb79ef0aba820", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjNzg0Nzk2MTAzMTczYzUwM2U0NGZjZGIxMmNiNzllZjBhYmE4MjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-10T17:00:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-10T17:00:14Z"}, "message": "Auto merge of #1406 - RalfJung:miri-as-rustc, r=RalfJung\n\ncargo-miri: never invoke rustc\n\nAlways go through 'MIRI_BE_RUSTC=1 miri' instead. This is based on @oli-obk's great idea to add a way to make Miri behave like rustc, which already helped us in https://github.com/rust-lang/miri/pull/1405. Now it means in `cargo-miri` we run *all* crates through the same binary, and use the env var to determine if we compile or interpret them. This makes sure the compiler is consistent.\n\nThe `rustc` binary of the current toolchain is now not used at all, only the `miri` binary is. In particular this means we can kill the sysroot consistency check. :)", "tree": {"sha": "a661856cd5cc92ce14fed7fdc52574edc973ac31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a661856cd5cc92ce14fed7fdc52574edc973ac31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c784796103173c503e44fcdb12cb79ef0aba820", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c784796103173c503e44fcdb12cb79ef0aba820", "html_url": "https://github.com/rust-lang/rust/commit/4c784796103173c503e44fcdb12cb79ef0aba820", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c784796103173c503e44fcdb12cb79ef0aba820/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cbe1f4184f11028d64856bf20ece56ebef772e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cbe1f4184f11028d64856bf20ece56ebef772e0", "html_url": "https://github.com/rust-lang/rust/commit/4cbe1f4184f11028d64856bf20ece56ebef772e0"}, {"sha": "845b89c23607516b5cae90cc3c925c9ab32059c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/845b89c23607516b5cae90cc3c925c9ab32059c7", "html_url": "https://github.com/rust-lang/rust/commit/845b89c23607516b5cae90cc3c925c9ab32059c7"}], "stats": {"total": 134, "additions": 39, "deletions": 95}, "files": [{"sha": "26d9b39fdd8e948e43ce438ce84013552d7eb12d", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c784796103173c503e44fcdb12cb79ef0aba820/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/4c784796103173c503e44fcdb12cb79ef0aba820/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=4c784796103173c503e44fcdb12cb79ef0aba820", "patch": "@@ -156,7 +156,7 @@ Try deleting `~/.cache/miri`.\n This means the sysroot you are using was not compiled with Miri in mind.  This\n should never happen when you use `cargo miri` because that takes care of setting\n up the sysroot.  If you are using `miri` (the Miri driver) directly, see\n-[below][testing-miri] for how to set up the sysroot.\n+[CONTRIBUTING.md](CONTRIBUTING.md) for how to use `./miri`.\n \n \n ## Miri `-Z` flags and environment variables"}, {"sha": "ca7fafd3d9c2ddf1da116d0f0e3fe75060bb0f81", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 34, "deletions": 90, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/4c784796103173c503e44fcdb12cb79ef0aba820/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c784796103173c503e44fcdb12cb79ef0aba820/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=4c784796103173c503e44fcdb12cb79ef0aba820", "patch": "@@ -8,6 +8,8 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::ffi::OsString;\n \n+use rustc_version::VersionMeta;\n+\n const XARGO_MIN_VERSION: (u32, u32, u32) = (0, 3, 20);\n \n const CARGO_MIRI_HELP: &str = r#\"Interprets bin crates and tests in Miri\n@@ -97,6 +99,10 @@ fn miri() -> Command {\n     Command::new(find_miri())\n }\n \n+fn version_info() -> VersionMeta {\n+    VersionMeta::for_command(miri()).expect(\"failed to determine underlying rustc version of Miri\")\n+}\n+\n fn cargo() -> Command {\n     Command::new(env::var_os(\"CARGO\").unwrap_or_else(|| OsString::from(\"cargo\")))\n }\n@@ -105,10 +111,6 @@ fn xargo_check() -> Command {\n     Command::new(env::var_os(\"XARGO_CHECK\").unwrap_or_else(|| OsString::from(\"xargo-check\")))\n }\n \n-fn rustc() -> Command {\n-    Command::new(env::var_os(\"RUSTC\").unwrap_or_else(|| OsString::from(\"rustc\")))\n-}\n-\n fn list_targets() -> impl Iterator<Item = cargo_metadata::Target> {\n     // We need to get the manifest, and then the metadata, to enumerate targets.\n     let manifest_path =\n@@ -153,55 +155,6 @@ fn list_targets() -> impl Iterator<Item = cargo_metadata::Target> {\n     package.targets.into_iter()\n }\n \n-/// Make sure that the `miri` and `rustc` binary are from the same sysroot.\n-/// This can be violated e.g. when miri is locally built and installed with a different\n-/// toolchain than what is used when `cargo miri` is run.\n-fn test_sysroot_consistency() {\n-    fn get_sysroot(mut cmd: Command) -> PathBuf {\n-        let out = cmd\n-            .arg(\"--print\")\n-            .arg(\"sysroot\")\n-            .output()\n-            .expect(\"Failed to run rustc to get sysroot info\");\n-        let stdout = String::from_utf8(out.stdout).expect(\"stdout is not valid UTF-8\");\n-        let stderr = String::from_utf8(out.stderr).expect(\"stderr is not valid UTF-8\");\n-        assert!(\n-            out.status.success(),\n-            \"Bad status code {} when getting sysroot info via {:?}.\\nstdout:\\n{}\\nstderr:\\n{}\",\n-            out.status,\n-            cmd,\n-            stdout,\n-            stderr,\n-        );\n-        let stdout = stdout.trim();\n-        PathBuf::from(stdout)\n-            .canonicalize()\n-            .unwrap_or_else(|_| panic!(\"Failed to canonicalize sysroot: {}\", stdout))\n-    }\n-\n-    // Do not check sysroots if we got built as part of a Rust distribution.\n-    // During `bootstrap`, the sysroot does not match anyway, and then some distros\n-    // play symlink tricks so the sysroots may be different even for the final stage\n-    // (see <https://github.com/mozilla/nixpkgs-mozilla/issues/198>).\n-    if option_env!(\"RUSTC_STAGE\").is_some() {\n-        return;\n-    }\n-\n-    let rustc_sysroot = get_sysroot(rustc());\n-    let miri_sysroot = get_sysroot(miri());\n-\n-    if rustc_sysroot != miri_sysroot {\n-        show_error(format!(\n-            \"miri was built for a different sysroot than the rustc in your current toolchain.\\n\\\n-             Make sure you use the same toolchain to run miri that you used to build it!\\n\\\n-             rustc sysroot: `{}`\\n\\\n-             miri sysroot: `{}`\",\n-            rustc_sysroot.display(),\n-            miri_sysroot.display()\n-        ));\n-    }\n-}\n-\n fn xargo_version() -> Option<(u32, u32, u32)> {\n     let out = xargo_check().arg(\"--version\").output().ok()?;\n     if !out.status.success() {\n@@ -300,10 +253,10 @@ fn setup(subcommand: MiriCommand) {\n         Some(val) => PathBuf::from(val),\n         None => {\n             // Check for `rust-src` rustup component.\n-            let sysroot = rustc()\n+            let sysroot = miri()\n                 .args(&[\"--print\", \"sysroot\"])\n                 .output()\n-                .expect(\"failed to get rustc sysroot\")\n+                .expect(\"failed to determine sysroot\")\n                 .stdout;\n             let sysroot = std::str::from_utf8(&sysroot).unwrap();\n             let sysroot = Path::new(sysroot.trim_end_matches('\\n'));\n@@ -316,7 +269,7 @@ fn setup(subcommand: MiriCommand) {\n                 ask_to_run(\n                     cmd,\n                     ask_user,\n-                    \"install the rustc-src component for the selected toolchain\",\n+                    \"install the `rust-src` component for the selected toolchain\",\n                 );\n             }\n             rustup_src\n@@ -368,7 +321,7 @@ path = \"lib.rs\"\n \n     // Determine architectures.\n     // We always need to set a target so rustc bootstrap can tell apart host from target crates.\n-    let host = rustc_version::version_meta().unwrap().host;\n+    let host = version_info().host;\n     let target = get_arg_flag_value(\"--target\");\n     let target = target.as_ref().unwrap_or(&host);\n     // Now invoke xargo.\n@@ -389,7 +342,6 @@ path = \"lib.rs\"\n         command.env(\"RUSTC\", find_miri());\n     }\n     command.env(\"MIRI_BE_RUSTC\", \"1\");\n-    command.env(\"RUSTFLAGS\", miri::miri_default_args().join(\" \"));\n     // Finally run it!\n     if command.status().expect(\"failed to run xargo\").success().not() {\n         show_error(format!(\"Failed to run xargo\"));\n@@ -424,9 +376,6 @@ fn in_cargo_miri() {\n     };\n     let verbose = has_arg_flag(\"-v\");\n \n-    // Some basic sanity checks\n-    test_sysroot_consistency();\n-\n     // We always setup.\n     setup(subcommand);\n     if subcommand == MiriCommand::Setup {\n@@ -478,7 +427,7 @@ fn in_cargo_miri() {\n         if get_arg_flag_value(\"--target\").is_none() {\n             // When no `--target` is given, default to the host.\n             cmd.arg(\"--target\");\n-            cmd.arg(rustc_version::version_meta().unwrap().host);\n+            cmd.arg(version_info().host);\n         }\n \n         // Serialize the remaining args into a special environemt variable.\n@@ -540,51 +489,46 @@ fn inside_cargo_rustc() {\n     let verbose = std::env::var_os(\"MIRI_VERBOSE\").is_some();\n     let target_crate = is_target_crate();\n \n-    // Figure out which arguments we need to pass.\n-    let mut args: Vec<String> = std::env::args().skip(2).collect(); // skip `cargo-miri rustc`\n-    // We make sure to only specify our custom Xargo sysroot and\n-    // other args for target crates - that is, crates which are ultimately\n-    // going to get interpreted by Miri.\n+    let mut cmd = miri();\n+    // Forward arguments.\n+    cmd.args(std::env::args().skip(2)); // skip `cargo-miri rustc`\n+\n+    // We make sure to only specify our custom Xargo sysroot for target crates - that is,\n+    // crates which are ultimately going to get interpreted by Miri.\n     if target_crate {\n-        // FIXME: breaks for non-UTF-8 sysroots (use `var_os` instead).\n         let sysroot =\n-            std::env::var(\"MIRI_SYSROOT\").expect(\"The wrapper should have set MIRI_SYSROOT\");\n-        args.push(\"--sysroot\".to_owned());\n-        args.push(sysroot);\n-        args.splice(0..0, miri::miri_default_args().iter().map(ToString::to_string));\n+            env::var_os(\"MIRI_SYSROOT\").expect(\"The wrapper should have set MIRI_SYSROOT\");\n+        cmd.arg(\"--sysroot\");\n+        cmd.arg(sysroot);\n     }\n \n-    // Figure out the binary we need to call. If this is a runnable target crate, we want to call\n-    // Miri to start interpretation; otherwise we want to call rustc to build the crate as usual.\n-    let mut command = if target_crate && is_runnable_crate() {\n-        // This is the 'target crate' - the binary or test crate that\n-        // we want to interpret under Miri. We deserialize the user-provided arguments\n-        // from the special environment variable \"MIRI_ARGS\", and feed them\n-        // to the 'miri' binary.\n+    // If this is a runnable target crate, we want Miri to start interpretation;\n+    // otherwise we want Miri to behave like rustc and build the crate as usual.\n+    if target_crate && is_runnable_crate() {\n+        // This is the binary or test crate that we want to interpret under Miri.\n+        // We deserialize the arguments that are meant for Miri from the special environment\n+        // variable \"MIRI_ARGS\", and feed them to the 'miri' binary.\n         //\n         // `env::var` is okay here, well-formed JSON is always UTF-8.\n         let magic = std::env::var(\"MIRI_ARGS\").expect(\"missing MIRI_ARGS\");\n-        let mut user_args: Vec<String> =\n+        let miri_args: Vec<String> =\n             serde_json::from_str(&magic).expect(\"failed to deserialize MIRI_ARGS\");\n-        args.append(&mut user_args);\n-        // Run this in Miri.\n-        miri()\n+        cmd.args(miri_args);\n     } else {\n-        rustc()\n+        // We want to compile, not interpret.\n+        cmd.env(\"MIRI_BE_RUSTC\", \"1\");\n     };\n \n     // Run it.\n-    command.args(&args);\n     if verbose {\n-        eprintln!(\"+ {:?}\", command);\n+        eprintln!(\"+ {:?}\", cmd);\n     }\n-\n-    match command.status() {\n+    match cmd.status() {\n         Ok(exit) =>\n             if !exit.success() {\n                 std::process::exit(exit.code().unwrap_or(42));\n             },\n-        Err(e) => panic!(\"error running {:?}:\\n{:?}\", command, e),\n+        Err(e) => panic!(\"error running {:?}:\\n{:?}\", cmd, e),\n     }\n }\n \n@@ -609,6 +553,6 @@ fn main() {\n         // dependencies get dispatched to `rustc`, the final test/binary to `miri`.\n         inside_cargo_rustc();\n     } else {\n-        show_error(format!(\"must be called with either `miri` or `rustc` as first argument.\"))\n+        show_error(format!(\"`cargo-miri` must be called with either `miri` or `rustc` as first argument.\"))\n     }\n }"}, {"sha": "ff3872f2fd02cd91f82122453e6f19410ac9d80b", "filename": "src/bin/miri.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c784796103173c503e44fcdb12cb79ef0aba820/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c784796103173c503e44fcdb12cb79ef0aba820/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=4c784796103173c503e44fcdb12cb79ef0aba820", "patch": "@@ -139,6 +139,10 @@ fn run_compiler(mut args: Vec<String>, callbacks: &mut (dyn rustc_driver::Callba\n         }\n     }\n \n+    // Some options have different defaults in Miri than in plain rustc; apply those by making\n+    // them the first arguments after the binary name (but later arguments can overwrite them).\n+    args.splice(1..1, miri::miri_default_args().iter().map(ToString::to_string));\n+\n     // Invoke compiler, and handle return code.\n     let result = rustc_driver::catch_fatal_errors(move || {\n         rustc_driver::run_compiler(&args, callbacks, None, None)\n@@ -182,10 +186,6 @@ fn main() {\n         if rustc_args.is_empty() {\n             // Very first arg: binary name.\n             rustc_args.push(arg);\n-            // After this, push Miri default args (before everything else so they can be overwritten).\n-            for arg in miri::miri_default_args().iter() {\n-                rustc_args.push(arg.to_string());\n-            }\n         } else if after_dashdash {\n             // Everything that comes after `--` is forwarded to the interpreted crate.\n             crate_args.push(arg);"}]}