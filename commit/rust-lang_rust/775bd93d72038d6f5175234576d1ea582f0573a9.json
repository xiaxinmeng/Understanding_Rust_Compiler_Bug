{"sha": "775bd93d72038d6f5175234576d1ea582f0573a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3NWJkOTNkNzIwMzhkNmY1MTc1MjM0NTc2ZDFlYTU4MmYwNTczYTk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-07-27T18:36:21Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-10T00:28:45Z"}, "message": "make it possible to test if HIR is dirty\n\nThis requires passing in the dirty-node set explicitly since HIR nodes\nwind up added to the graph either way.", "tree": {"sha": "3a2575cbafc40fc0c6d3db7a99152debf033abef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a2575cbafc40fc0c6d3db7a99152debf033abef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/775bd93d72038d6f5175234576d1ea582f0573a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/775bd93d72038d6f5175234576d1ea582f0573a9", "html_url": "https://github.com/rust-lang/rust/commit/775bd93d72038d6f5175234576d1ea582f0573a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/775bd93d72038d6f5175234576d1ea582f0573a9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "html_url": "https://github.com/rust-lang/rust/commit/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0"}], "stats": {"total": 84, "additions": 68, "deletions": 16}, "files": [{"sha": "40fd3dede3d08b5399312d8fc2fa82719c188d42", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/775bd93d72038d6f5175234576d1ea582f0573a9/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/775bd93d72038d6f5175234576d1ea582f0573a9/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=775bd93d72038d6f5175234576d1ea582f0573a9", "patch": "@@ -150,6 +150,7 @@ impl<D: Clone + Debug> DepNode<D> {\n         check! {\n             CollectItem,\n             BorrowCheck,\n+            Hir,\n             TransCrateItem,\n             TypeckItemType,\n             TypeckItemBody,"}, {"sha": "fa363ecd1fdcb551ad8735ac130ff4794c14b2bf", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 64, "deletions": 14, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/775bd93d72038d6f5175234576d1ea582f0573a9/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/775bd93d72038d6f5175234576d1ea582f0573a9/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=775bd93d72038d6f5175234576d1ea582f0573a9", "patch": "@@ -24,10 +24,13 @@\n //! Errors are reported if we are in the suitable configuration but\n //! the required condition is not met.\n \n+use super::directory::RetracedDefIdDirectory;\n+use super::load::DirtyNodes;\n use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::Visitor;\n+use rustc_data_structures::fnv::FnvHashSet;\n use syntax::ast::{self, Attribute, MetaItem};\n use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::InternedString;\n@@ -38,19 +41,33 @@ const CLEAN: &'static str = \"rustc_clean\";\n const LABEL: &'static str = \"label\";\n const CFG: &'static str = \"cfg\";\n \n-pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                               dirty_inputs: &DirtyNodes,\n+                                               retraced: &RetracedDefIdDirectory) {\n+    // can't add `#[rustc_dirty]` etc without opting in to this feature\n+    if !tcx.sess.features.borrow().rustc_attrs {\n+        return;\n+    }\n+\n     let _ignore = tcx.dep_graph.in_ignore();\n+    let dirty_inputs: FnvHashSet<DepNode<DefId>> =\n+        dirty_inputs.iter()\n+                   .filter_map(|d| retraced.map(d))\n+                   .collect();\n     let query = tcx.dep_graph.query();\n+    debug!(\"query-nodes: {:?}\", query.nodes());\n     let krate = tcx.map.krate();\n     krate.visit_all_items(&mut DirtyCleanVisitor {\n         tcx: tcx,\n         query: &query,\n+        dirty_inputs: dirty_inputs,\n     });\n }\n \n pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     query: &'a DepGraphQuery<DefId>,\n+    dirty_inputs: FnvHashSet<DepNode<DefId>>,\n }\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n@@ -81,10 +98,13 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n                         return true;\n                     }\n                 }\n+                return false;\n             }\n         }\n-        debug!(\"check_config: no match found\");\n-        return false;\n+\n+        self.tcx.sess.span_fatal(\n+            attr.span,\n+            &format!(\"no cfg attribute\"));\n     }\n \n     fn dep_node(&self, attr: &Attribute, def_id: DefId) -> DepNode<DefId> {\n@@ -105,29 +125,59 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n         self.tcx.sess.span_fatal(attr.span, \"no `label` found\");\n     }\n \n-    fn dep_node_str(&self, dep_node: DepNode<DefId>) -> DepNode<String> {\n+    fn dep_node_str(&self, dep_node: &DepNode<DefId>) -> DepNode<String> {\n         dep_node.map_def(|&def_id| Some(self.tcx.item_path_str(def_id))).unwrap()\n     }\n \n     fn assert_dirty(&self, item: &hir::Item, dep_node: DepNode<DefId>) {\n         debug!(\"assert_dirty({:?})\", dep_node);\n \n-        if self.query.contains_node(&dep_node) {\n-            let dep_node_str = self.dep_node_str(dep_node);\n-            self.tcx.sess.span_err(\n-                item.span,\n-                &format!(\"`{:?}` found in dep graph, but should be dirty\", dep_node_str));\n+        match dep_node {\n+            DepNode::Hir(_) => {\n+                // HIR nodes are inputs, so if we are asserting that the HIR node is\n+                // dirty, we check the dirty input set.\n+                if !self.dirty_inputs.contains(&dep_node) {\n+                    let dep_node_str = self.dep_node_str(&dep_node);\n+                    self.tcx.sess.span_err(\n+                        item.span,\n+                        &format!(\"`{:?}` not found in dirty set, but should be dirty\", dep_node_str));\n+                }\n+            }\n+            _ => {\n+                // Other kinds of nodes would be targets, so check if\n+                // the dep-graph contains the node.\n+                if self.query.contains_node(&dep_node) {\n+                    let dep_node_str = self.dep_node_str(&dep_node);\n+                    self.tcx.sess.span_err(\n+                        item.span,\n+                        &format!(\"`{:?}` found in dep graph, but should be dirty\", dep_node_str));\n+                }\n+            }\n         }\n     }\n \n     fn assert_clean(&self, item: &hir::Item, dep_node: DepNode<DefId>) {\n         debug!(\"assert_clean({:?})\", dep_node);\n \n-        if !self.query.contains_node(&dep_node) {\n-            let dep_node_str = self.dep_node_str(dep_node);\n-            self.tcx.sess.span_err(\n-                item.span,\n-                &format!(\"`{:?}` not found in dep graph, but should be clean\", dep_node_str));\n+        match dep_node {\n+            DepNode::Hir(_) => {\n+                // For HIR nodes, check the inputs.\n+                if self.dirty_inputs.contains(&dep_node) {\n+                    let dep_node_str = self.dep_node_str(&dep_node);\n+                    self.tcx.sess.span_err(\n+                        item.span,\n+                        &format!(\"`{:?}` found in dirty-node set, but should be clean\", dep_node_str));\n+                }\n+            }\n+            _ => {\n+                // Otherwise, check if the dep-node exists.\n+                if !self.query.contains_node(&dep_node) {\n+                    let dep_node_str = self.dep_node_str(&dep_node);\n+                    self.tcx.sess.span_err(\n+                        item.span,\n+                        &format!(\"`{:?}` not found in dep graph, but should be clean\", dep_node_str));\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "48ddcd2c416b5c6c32f70005ee504147ee4fee7d", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/775bd93d72038d6f5175234576d1ea582f0573a9/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/775bd93d72038d6f5175234576d1ea582f0573a9/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=775bd93d72038d6f5175234576d1ea582f0573a9", "patch": "@@ -28,7 +28,7 @@ use super::dirty_clean;\n use super::hash::*;\n use super::util::*;\n \n-type DirtyNodes = FnvHashSet<DepNode<DefPathIndex>>;\n+pub type DirtyNodes = FnvHashSet<DepNode<DefPathIndex>>;\n \n type CleanEdges = Vec<(DepNode<DefId>, DepNode<DefId>)>;\n \n@@ -45,7 +45,6 @@ pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     let _ignore = tcx.dep_graph.in_ignore();\n     load_dep_graph_if_exists(tcx);\n-    dirty_clean::check_dirty_clean_annotations(tcx);\n }\n \n fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n@@ -184,6 +183,8 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let work_products = try!(<Vec<SerializedWorkProduct>>::decode(&mut work_product_decoder));\n     reconcile_work_products(tcx, work_products, &dirty_target_nodes);\n \n+    dirty_clean::check_dirty_clean_annotations(tcx, &dirty_raw_source_nodes, &retraced);\n+\n     Ok(())\n }\n "}]}