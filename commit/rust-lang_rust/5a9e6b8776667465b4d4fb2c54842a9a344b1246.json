{"sha": "5a9e6b8776667465b4d4fb2c54842a9a344b1246", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhOWU2Yjg3NzY2Njc0NjViNGQ0ZmIyYzU0ODQyYTlhMzQ0YjEyNDY=", "commit": {"author": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-08-02T14:48:44Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:10:53Z"}, "message": "rustc_codegen_llvm: begin generalizing over backend values.", "tree": {"sha": "b6d063c9984adce60db3595dcd35abdee5849d18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6d063c9984adce60db3595dcd35abdee5849d18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a9e6b8776667465b4d4fb2c54842a9a344b1246", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a9e6b8776667465b4d4fb2c54842a9a344b1246", "html_url": "https://github.com/rust-lang/rust/commit/5a9e6b8776667465b4d4fb2c54842a9a344b1246", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a9e6b8776667465b4d4fb2c54842a9a344b1246/comments", "author": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b9b97bd9b704f85f0184f7a213cc4d62bd9654c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b9b97bd9b704f85f0184f7a213cc4d62bd9654c", "html_url": "https://github.com/rust-lang/rust/commit/6b9b97bd9b704f85f0184f7a213cc4d62bd9654c"}], "stats": {"total": 182, "additions": 107, "deletions": 75}, "files": [{"sha": "b417f552f7d0ee8f0114d1bcf8dbdc1ba807a24b", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a9e6b8776667465b4d4fb2c54842a9a344b1246/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a9e6b8776667465b4d4fb2c54842a9a344b1246/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=5a9e6b8776667465b4d4fb2c54842a9a344b1246", "patch": "@@ -167,8 +167,13 @@ impl LlvmType for CastTarget {\n \n pub trait ArgTypeExt<'ll, 'tcx> {\n     fn memory_ty(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n-    fn store(&self, bx: &Builder<'_, 'll, 'tcx>, val: &'ll Value, dst: PlaceRef<'ll, 'tcx>);\n-    fn store_fn_arg(&self, bx: &Builder<'_, 'll, 'tcx>, idx: &mut usize, dst: PlaceRef<'ll, 'tcx>);\n+    fn store(&self, bx: &Builder<'_, 'll, 'tcx>, val: &'ll Value, dst: PlaceRef<'tcx, &'ll Value>);\n+    fn store_fn_arg(\n+        &self,\n+        bx: &Builder<'_, 'll, 'tcx>,\n+        idx: &mut usize,\n+       dst: PlaceRef<'tcx, &'ll Value>,\n+    );\n }\n \n impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n@@ -182,7 +187,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n     /// place for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n-    fn store(&self, bx: &Builder<'_, 'll, 'tcx>, val: &'ll Value, dst: PlaceRef<'ll, 'tcx>) {\n+    fn store(&self, bx: &Builder<'_, 'll, 'tcx>, val: &'ll Value, dst: PlaceRef<'tcx, &'ll Value>) {\n         if self.is_ignore() {\n             return;\n         }\n@@ -238,7 +243,12 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n         }\n     }\n \n-    fn store_fn_arg(&self, bx: &Builder<'a, 'll, 'tcx>, idx: &mut usize, dst: PlaceRef<'ll, 'tcx>) {\n+    fn store_fn_arg(\n+        &self,\n+        bx: &Builder<'a, 'll, 'tcx>,\n+        idx: &mut usize,\n+        dst: PlaceRef<'tcx, &'ll Value>,\n+    ) {\n         let mut next = || {\n             let val = llvm::get_param(bx.llfn(), *idx as c_uint);\n             *idx += 1;"}, {"sha": "b267114410734cc0e0a1f42652373ec46f22170d", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a9e6b8776667465b4d4fb2c54842a9a344b1246/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a9e6b8776667465b4d4fb2c54842a9a344b1246/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=5a9e6b8776667465b4d4fb2c54842a9a344b1246", "patch": "@@ -28,7 +28,7 @@ use libc::{c_uint, c_char};\n pub fn codegen_inline_asm(\n     bx: &Builder<'a, 'll, 'tcx>,\n     ia: &hir::InlineAsm,\n-    outputs: Vec<PlaceRef<'ll, 'tcx>>,\n+    outputs: Vec<PlaceRef<'tcx, &'ll Value>>,\n     mut inputs: Vec<&'ll Value>\n ) -> bool {\n     let mut ext_constraints = vec![];"}, {"sha": "50fb246a7d467ef8f040d6ed45ee806775c5639d", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a9e6b8776667465b4d4fb2c54842a9a344b1246/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a9e6b8776667465b4d4fb2c54842a9a344b1246/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=5a9e6b8776667465b4d4fb2c54842a9a344b1246", "patch": "@@ -275,8 +275,8 @@ pub fn unsize_thin_ptr(\n /// to a value of type `dst_ty` and store the result in `dst`\n pub fn coerce_unsized_into(\n     bx: &Builder<'a, 'll, 'tcx>,\n-    src: PlaceRef<'ll, 'tcx>,\n-    dst: PlaceRef<'ll, 'tcx>\n+    src: PlaceRef<'tcx, &'ll Value>,\n+    dst: PlaceRef<'tcx, &'ll Value>\n ) {\n     let src_ty = src.layout.ty;\n     let dst_ty = dst.layout.ty;"}, {"sha": "29831473ba2bb8f0c6d07365d2f0f5a604d71987", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a9e6b8776667465b4d4fb2c54842a9a344b1246/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a9e6b8776667465b4d4fb2c54842a9a344b1246/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=5a9e6b8776667465b4d4fb2c54842a9a344b1246", "patch": "@@ -91,7 +91,7 @@ pub fn codegen_intrinsic_call(\n     bx: &Builder<'a, 'll, 'tcx>,\n     callee_ty: Ty<'tcx>,\n     fn_ty: &FnType<'tcx, Ty<'tcx>>,\n-    args: &[OperandRef<'ll, 'tcx>],\n+    args: &[OperandRef<'tcx, &'ll Value>],\n     llresult: &'ll Value,\n     span: Span,\n ) {\n@@ -614,7 +614,7 @@ pub fn codegen_intrinsic_call(\n             fn modify_as_needed(\n                 bx: &Builder<'a, 'll, 'tcx>,\n                 t: &intrinsics::Type,\n-                arg: &OperandRef<'ll, 'tcx>,\n+                arg: &OperandRef<'tcx, &'ll Value>,\n             ) -> Vec<&'ll Value> {\n                 match *t {\n                     intrinsics::Type::Aggregate(true, ref contents) => {\n@@ -992,7 +992,7 @@ fn generic_simd_intrinsic(\n     bx: &Builder<'a, 'll, 'tcx>,\n     name: &str,\n     callee_ty: Ty<'tcx>,\n-    args: &[OperandRef<'ll, 'tcx>],\n+    args: &[OperandRef<'tcx, &'ll Value>],\n     ret_ty: Ty<'tcx>,\n     llret_ty: &'ll Type,\n     span: Span\n@@ -1167,7 +1167,7 @@ fn generic_simd_intrinsic(\n         in_len: usize,\n         bx: &Builder<'a, 'll, 'tcx>,\n         span: Span,\n-        args: &[OperandRef<'ll, 'tcx>],\n+        args: &[OperandRef<'tcx, &'ll Value>],\n     ) -> Result<&'ll Value, ()> {\n         macro_rules! emit_error {\n             ($msg: tt) => {"}, {"sha": "aeca4f1469ffc0ef73e139853b9d715b97de9f05", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a9e6b8776667465b4d4fb2c54842a9a344b1246/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a9e6b8776667465b4d4fb2c54842a9a344b1246/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=5a9e6b8776667465b4d4fb2c54842a9a344b1246", "patch": "@@ -115,7 +115,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n             fn_ty: FnType<'tcx, Ty<'tcx>>,\n             fn_ptr: &'ll Value,\n             llargs: &[&'ll Value],\n-            destination: Option<(ReturnDest<'ll, 'tcx>, mir::BasicBlock)>,\n+            destination: Option<(ReturnDest<'tcx, &'ll Value>, mir::BasicBlock)>,\n             cleanup: Option<mir::BasicBlock>\n         | {\n             if let Some(cleanup) = cleanup {\n@@ -731,7 +731,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n \n     fn codegen_argument(&mut self,\n                       bx: &Builder<'a, 'll, 'tcx>,\n-                      op: OperandRef<'ll, 'tcx>,\n+                      op: OperandRef<'tcx, &'ll Value>,\n                       llargs: &mut Vec<&'ll Value>,\n                       arg: &ArgType<'tcx, Ty<'tcx>>) {\n         // Fill padding with undef value, where applicable.\n@@ -843,7 +843,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn get_personality_slot(&mut self, bx: &Builder<'a, 'll, 'tcx>) -> PlaceRef<'ll, 'tcx> {\n+    fn get_personality_slot(&mut self, bx: &Builder<'a, 'll, 'tcx>) -> PlaceRef<'tcx, &'ll Value> {\n         let cx = bx.cx;\n         if let Some(slot) = self.personality_slot {\n             slot\n@@ -919,7 +919,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     fn make_return_dest(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n                         dest: &mir::Place<'tcx>, fn_ret: &ArgType<'tcx, Ty<'tcx>>,\n                         llargs: &mut Vec<&'ll Value>, is_intrinsic: bool)\n-                        -> ReturnDest<'ll, 'tcx> {\n+                        -> ReturnDest<'tcx, &'ll Value> {\n         // If the return is ignored, we can just return a do-nothing ReturnDest\n         if fn_ret.is_ignore() {\n             return ReturnDest::Nothing;\n@@ -1003,7 +1003,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n \n     fn codegen_transmute_into(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n                               src: &mir::Operand<'tcx>,\n-                              dst: PlaceRef<'ll, 'tcx>) {\n+                              dst: PlaceRef<'tcx, &'ll Value>) {\n         let src = self.codegen_operand(bx, src);\n         let llty = src.layout.llvm_type(bx.cx);\n         let cast_ptr = bx.pointercast(dst.llval, llty.ptr_to());\n@@ -1015,7 +1015,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     // Stores the return value of a function call into it's final location.\n     fn store_return(&mut self,\n                     bx: &Builder<'a, 'll, 'tcx>,\n-                    dest: ReturnDest<'ll, 'tcx>,\n+                    dest: ReturnDest<'tcx, &'ll Value>,\n                     ret_ty: &ArgType<'tcx, Ty<'tcx>>,\n                     llval: &'ll Value) {\n         use self::ReturnDest::*;\n@@ -1046,13 +1046,13 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     }\n }\n \n-enum ReturnDest<'ll, 'tcx> {\n+enum ReturnDest<'tcx, V> {\n     // Do nothing, the return value is indirect or ignored\n     Nothing,\n     // Store the return value to the pointer\n-    Store(PlaceRef<'ll, 'tcx>),\n+    Store(PlaceRef<'tcx, V>),\n     // Stores an indirect return value to an operand local place\n-    IndirectOperand(PlaceRef<'ll, 'tcx>, mir::Local),\n+    IndirectOperand(PlaceRef<'tcx, V>, mir::Local),\n     // Stores a direct return value to an operand local place\n     DirectOperand(mir::Local)\n }"}, {"sha": "b96305e08e0f97f308ab5128c8ff9e0429c2fdd4", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5a9e6b8776667465b4d4fb2c54842a9a344b1246/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a9e6b8776667465b4d4fb2c54842a9a344b1246/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=5a9e6b8776667465b4d4fb2c54842a9a344b1246", "patch": "@@ -64,7 +64,7 @@ pub struct FunctionCx<'a, 'll: 'a, 'tcx: 'll> {\n     /// don't really care about it very much. Anyway, this value\n     /// contains an alloca into which the personality is stored and\n     /// then later loaded when generating the DIVERGE_BLOCK.\n-    personality_slot: Option<PlaceRef<'ll, 'tcx>>,\n+    personality_slot: Option<PlaceRef<'tcx, &'ll Value>>,\n \n     /// A `Block` for each MIR `BasicBlock`\n     blocks: IndexVec<mir::BasicBlock, &'ll BasicBlock>,\n@@ -98,7 +98,7 @@ pub struct FunctionCx<'a, 'll: 'a, 'tcx: 'll> {\n     ///\n     /// Avoiding allocs can also be important for certain intrinsics,\n     /// notably `expect`.\n-    locals: IndexVec<mir::Local, LocalRef<'ll, 'tcx>>,\n+    locals: IndexVec<mir::Local, LocalRef<'tcx, &'ll Value>>,\n \n     /// Debug information for MIR scopes.\n     scopes: IndexVec<mir::SourceScope, debuginfo::MirDebugScope<'ll>>,\n@@ -179,18 +179,21 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     }\n }\n \n-enum LocalRef<'ll, 'tcx> {\n-    Place(PlaceRef<'ll, 'tcx>),\n+enum LocalRef<'tcx, V> {\n+    Place(PlaceRef<'tcx, V>),\n     /// `UnsizedPlace(p)`: `p` itself is a thin pointer (indirect place).\n     /// `*p` is the fat pointer that references the actual unsized place.\n     /// Every time it is initialized, we have to reallocate the place\n     /// and update the fat pointer. That's the reason why it is indirect.\n-    UnsizedPlace(PlaceRef<'ll, 'tcx>),\n-    Operand(Option<OperandRef<'ll, 'tcx>>),\n+    UnsizedPlace(PlaceRef<'tcx, V>),\n+    Operand(Option<OperandRef<'tcx, V>>),\n }\n \n-impl LocalRef<'ll, 'tcx> {\n-    fn new_operand(cx: &CodegenCx<'ll, 'tcx>, layout: TyLayout<'tcx>) -> LocalRef<'ll, 'tcx> {\n+impl LocalRef<'tcx, &'ll Value> {\n+    fn new_operand(\n+        cx: &CodegenCx<'ll, 'tcx>,\n+        layout: TyLayout<'tcx>,\n+    ) -> LocalRef<'tcx, &'ll Value> {\n         if layout.is_zst() {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n@@ -437,7 +440,7 @@ fn arg_local_refs(\n     fx: &FunctionCx<'a, 'll, 'tcx>,\n     scopes: &IndexVec<mir::SourceScope, debuginfo::MirDebugScope<'ll>>,\n     memory_locals: &BitSet<mir::Local>,\n-) -> Vec<LocalRef<'ll, 'tcx>> {\n+) -> Vec<LocalRef<'tcx, &'ll Value>> {\n     let mir = fx.mir;\n     let tcx = bx.tcx();\n     let mut idx = 0;"}, {"sha": "c24f101177a10da47b7b840face2ee9fdd0cddf5", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5a9e6b8776667465b4d4fb2c54842a9a344b1246/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a9e6b8776667465b4d4fb2c54842a9a344b1246/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=5a9e6b8776667465b4d4fb2c54842a9a344b1246", "patch": "@@ -31,16 +31,16 @@ use super::place::PlaceRef;\n /// uniquely determined by the value's type, but is kept as a\n /// safety check.\n #[derive(Copy, Clone, Debug)]\n-pub enum OperandValue<'ll> {\n+pub enum OperandValue<V> {\n     /// A reference to the actual operand. The data is guaranteed\n     /// to be valid for the operand's lifetime.\n     /// The second value, if any, is the extra data (vtable or length)\n     /// which indicates that it refers to an unsized rvalue.\n-    Ref(&'ll Value, Option<&'ll Value>, Align),\n+    Ref(V, Option<V>, Align),\n     /// A single LLVM value.\n-    Immediate(&'ll Value),\n+    Immediate(V),\n     /// A pair of immediate LLVM values. Used by fat pointers too.\n-    Pair(&'ll Value, &'ll Value)\n+    Pair(V, V)\n }\n \n /// An `OperandRef` is an \"SSA\" reference to a Rust value, along with\n@@ -52,23 +52,23 @@ pub enum OperandValue<'ll> {\n /// directly is sure to cause problems -- use `OperandRef::store`\n /// instead.\n #[derive(Copy, Clone)]\n-pub struct OperandRef<'ll, 'tcx> {\n+pub struct OperandRef<'tcx, V> {\n     // The value.\n-    pub val: OperandValue<'ll>,\n+    pub val: OperandValue<V>,\n \n     // The layout of value, based on its Rust type.\n     pub layout: TyLayout<'tcx>,\n }\n \n-impl fmt::Debug for OperandRef<'ll, 'tcx> {\n+impl fmt::Debug for OperandRef<'tcx, &'ll Value> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"OperandRef({:?} @ {:?})\", self.val, self.layout)\n     }\n }\n \n-impl OperandRef<'ll, 'tcx> {\n+impl OperandRef<'tcx, &'ll Value> {\n     pub fn new_zst(cx: &CodegenCx<'ll, 'tcx>,\n-                   layout: TyLayout<'tcx>) -> OperandRef<'ll, 'tcx> {\n+                   layout: TyLayout<'tcx>) -> OperandRef<'tcx, &'ll Value> {\n         assert!(layout.is_zst());\n         OperandRef {\n             val: OperandValue::Immediate(C_undef(layout.immediate_llvm_type(cx))),\n@@ -78,7 +78,7 @@ impl OperandRef<'ll, 'tcx> {\n \n     pub fn from_const(bx: &Builder<'a, 'll, 'tcx>,\n                       val: &'tcx ty::Const<'tcx>)\n-                      -> Result<OperandRef<'ll, 'tcx>, ErrorHandled> {\n+                      -> Result<OperandRef<'tcx, &'ll Value>, ErrorHandled> {\n         let layout = bx.cx.layout_of(val.ty);\n \n         if layout.is_zst() {\n@@ -140,7 +140,7 @@ impl OperandRef<'ll, 'tcx> {\n         }\n     }\n \n-    pub fn deref(self, cx: &CodegenCx<'ll, 'tcx>) -> PlaceRef<'ll, 'tcx> {\n+    pub fn deref(self, cx: &CodegenCx<'ll, 'tcx>) -> PlaceRef<'tcx, &'ll Value> {\n         let projected_ty = self.layout.ty.builtin_deref(true)\n             .unwrap_or_else(|| bug!(\"deref of non-pointer {:?}\", self)).ty;\n         let (llptr, llextra) = match self.val {\n@@ -178,7 +178,7 @@ impl OperandRef<'ll, 'tcx> {\n     pub fn from_immediate_or_packed_pair(bx: &Builder<'a, 'll, 'tcx>,\n                                          llval: &'ll Value,\n                                          layout: TyLayout<'tcx>)\n-                                         -> OperandRef<'ll, 'tcx> {\n+                                         -> OperandRef<'tcx, &'ll Value> {\n         let val = if let layout::Abi::ScalarPair(ref a, ref b) = layout.abi {\n             debug!(\"Operand::from_immediate_or_packed_pair: unpacking {:?} @ {:?}\",\n                     llval, layout);\n@@ -193,7 +193,11 @@ impl OperandRef<'ll, 'tcx> {\n         OperandRef { val, layout }\n     }\n \n-    pub fn extract_field(&self, bx: &Builder<'a, 'll, 'tcx>, i: usize) -> OperandRef<'ll, 'tcx> {\n+    pub fn extract_field(\n+        &self,\n+        bx: &Builder<'a, 'll, 'tcx>,\n+        i: usize,\n+    ) -> OperandRef<'tcx, &'ll Value> {\n         let field = self.layout.field(bx.cx, i);\n         let offset = self.layout.fields.offset(i);\n \n@@ -251,27 +255,31 @@ impl OperandRef<'ll, 'tcx> {\n     }\n }\n \n-impl OperandValue<'ll> {\n-    pub fn store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'ll, 'tcx>) {\n+impl OperandValue<&'ll Value> {\n+    pub fn store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'tcx, &'ll Value>) {\n         self.store_with_flags(bx, dest, MemFlags::empty());\n     }\n \n-    pub fn volatile_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'ll, 'tcx>) {\n+    pub fn volatile_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'tcx, &'ll Value>) {\n         self.store_with_flags(bx, dest, MemFlags::VOLATILE);\n     }\n \n-    pub fn unaligned_volatile_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'ll, 'tcx>) {\n+    pub fn unaligned_volatile_store(\n+        self,\n+        bx: &Builder<'a, 'll, 'tcx>,\n+        dest: PlaceRef<'tcx, &'ll Value>,\n+    ) {\n         self.store_with_flags(bx, dest, MemFlags::VOLATILE | MemFlags::UNALIGNED);\n     }\n \n-    pub fn nontemporal_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'ll, 'tcx>) {\n+    pub fn nontemporal_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'tcx, &'ll Value>) {\n         self.store_with_flags(bx, dest, MemFlags::NONTEMPORAL);\n     }\n \n     fn store_with_flags(\n         self,\n         bx: &Builder<'a, 'll, 'tcx>,\n-        dest: PlaceRef<'ll, 'tcx>,\n+        dest: PlaceRef<'tcx, &'ll Value>,\n         flags: MemFlags,\n     ) {\n         debug!(\"OperandRef::store: operand={:?}, dest={:?}\", self, dest);\n@@ -302,7 +310,11 @@ impl OperandValue<'ll> {\n         }\n     }\n \n-    pub fn store_unsized(self, bx: &Builder<'a, 'll, 'tcx>, indirect_dest: PlaceRef<'ll, 'tcx>) {\n+    pub fn store_unsized(\n+        self,\n+        bx: &Builder<'a, 'll, 'tcx>,\n+        indirect_dest: PlaceRef<'tcx, &'ll Value>,\n+    ) {\n         debug!(\"OperandRef::store_unsized: operand={:?}, indirect_dest={:?}\", self, indirect_dest);\n         let flags = MemFlags::empty();\n \n@@ -336,7 +348,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     fn maybe_codegen_consume_direct(&mut self,\n                                   bx: &Builder<'a, 'll, 'tcx>,\n                                   place: &mir::Place<'tcx>)\n-                                   -> Option<OperandRef<'ll, 'tcx>>\n+                                   -> Option<OperandRef<'tcx, &'ll Value>>\n     {\n         debug!(\"maybe_codegen_consume_direct(place={:?})\", place);\n \n@@ -384,7 +396,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_consume(&mut self,\n                          bx: &Builder<'a, 'll, 'tcx>,\n                          place: &mir::Place<'tcx>)\n-                         -> OperandRef<'ll, 'tcx>\n+                         -> OperandRef<'tcx, &'ll Value>\n     {\n         debug!(\"codegen_consume(place={:?})\", place);\n \n@@ -408,7 +420,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_operand(&mut self,\n                          bx: &Builder<'a, 'll, 'tcx>,\n                          operand: &mir::Operand<'tcx>)\n-                         -> OperandRef<'ll, 'tcx>\n+                         -> OperandRef<'tcx, &'ll Value>\n     {\n         debug!(\"codegen_operand(operand={:?})\", operand);\n "}, {"sha": "46108615562afcd382a4b8f76307c76e4dcdeb93", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5a9e6b8776667465b4d4fb2c54842a9a344b1246/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a9e6b8776667465b4d4fb2c54842a9a344b1246/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=5a9e6b8776667465b4d4fb2c54842a9a344b1246", "patch": "@@ -27,12 +27,12 @@ use super::{FunctionCx, LocalRef};\n use super::operand::{OperandRef, OperandValue};\n \n #[derive(Copy, Clone, Debug)]\n-pub struct PlaceRef<'ll, 'tcx> {\n+pub struct PlaceRef<'tcx, V> {\n     /// Pointer to the contents of the place\n-    pub llval: &'ll Value,\n+    pub llval: V,\n \n     /// This place's extra data if it is unsized, or null\n-    pub llextra: Option<&'ll Value>,\n+    pub llextra: Option<V>,\n \n     /// Monomorphized type of this place, including variant information\n     pub layout: TyLayout<'tcx>,\n@@ -41,12 +41,12 @@ pub struct PlaceRef<'ll, 'tcx> {\n     pub align: Align,\n }\n \n-impl PlaceRef<'ll, 'tcx> {\n+impl PlaceRef<'tcx, &'ll Value> {\n     pub fn new_sized(\n         llval: &'ll Value,\n         layout: TyLayout<'tcx>,\n         align: Align,\n-    ) -> PlaceRef<'ll, 'tcx> {\n+    ) -> PlaceRef<'tcx, &'ll Value> {\n         assert!(!layout.is_unsized());\n         PlaceRef {\n             llval,\n@@ -61,7 +61,7 @@ impl PlaceRef<'ll, 'tcx> {\n         layout: TyLayout<'tcx>,\n         alloc: &mir::interpret::Allocation,\n         offset: Size,\n-    ) -> PlaceRef<'ll, 'tcx> {\n+    ) -> PlaceRef<'tcx, &'ll Value> {\n         let init = const_alloc_to_llvm(bx.cx, alloc);\n         let base_addr = consts::addr_of(bx.cx, init, layout.align, None);\n \n@@ -75,16 +75,19 @@ impl PlaceRef<'ll, 'tcx> {\n     }\n \n     pub fn alloca(bx: &Builder<'a, 'll, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n-                  -> PlaceRef<'ll, 'tcx> {\n+                  -> PlaceRef<'tcx, &'ll Value> {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n         assert!(!layout.is_unsized(), \"tried to statically allocate unsized place\");\n         let tmp = bx.alloca(layout.llvm_type(bx.cx), name, layout.align);\n         Self::new_sized(tmp, layout, layout.align)\n     }\n \n     /// Returns a place for an indirect reference to an unsized place.\n-    pub fn alloca_unsized_indirect(bx: &Builder<'a, 'll, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n-                  -> PlaceRef<'ll, 'tcx> {\n+    pub fn alloca_unsized_indirect(\n+        bx: &Builder<'a, 'll, 'tcx>,\n+        layout: TyLayout<'tcx>,\n+        name: &str,\n+    ) -> PlaceRef<'tcx, &'ll Value> {\n         debug!(\"alloca_unsized_indirect({:?}: {:?})\", name, layout);\n         assert!(layout.is_unsized(), \"tried to allocate indirect place for sized values\");\n         let ptr_ty = bx.cx.tcx.mk_mut_ptr(layout.ty);\n@@ -105,7 +108,7 @@ impl PlaceRef<'ll, 'tcx> {\n         }\n     }\n \n-    pub fn load(&self, bx: &Builder<'a, 'll, 'tcx>) -> OperandRef<'ll, 'tcx> {\n+    pub fn load(&self, bx: &Builder<'a, 'll, 'tcx>) -> OperandRef<'tcx, &'ll Value> {\n         debug!(\"PlaceRef::load: {:?}\", self);\n \n         assert_eq!(self.llextra.is_some(), self.layout.is_unsized());\n@@ -169,7 +172,11 @@ impl PlaceRef<'ll, 'tcx> {\n     }\n \n     /// Access a field, at a point when the value's case is known.\n-    pub fn project_field(self, bx: &Builder<'a, 'll, 'tcx>, ix: usize) -> PlaceRef<'ll, 'tcx> {\n+    pub fn project_field(\n+        self,\n+        bx: &Builder<'a, 'll, 'tcx>,\n+        ix: usize,\n+    ) -> PlaceRef<'tcx, &'ll Value> {\n         let cx = bx.cx;\n         let field = self.layout.field(cx, ix);\n         let offset = self.layout.fields.offset(ix);\n@@ -393,7 +400,7 @@ impl PlaceRef<'ll, 'tcx> {\n     }\n \n     pub fn project_index(&self, bx: &Builder<'a, 'll, 'tcx>, llindex: &'ll Value)\n-                         -> PlaceRef<'ll, 'tcx> {\n+                         -> PlaceRef<'tcx, &'ll Value> {\n         PlaceRef {\n             llval: bx.inbounds_gep(self.llval, &[C_usize(bx.cx, 0), llindex]),\n             llextra: None,\n@@ -403,7 +410,7 @@ impl PlaceRef<'ll, 'tcx> {\n     }\n \n     pub fn project_downcast(&self, bx: &Builder<'a, 'll, 'tcx>, variant_index: VariantIdx)\n-                            -> PlaceRef<'ll, 'tcx> {\n+                            -> PlaceRef<'tcx, &'ll Value> {\n         let mut downcast = *self;\n         downcast.layout = self.layout.for_variant(bx.cx, variant_index);\n \n@@ -427,7 +434,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_place(&mut self,\n                         bx: &Builder<'a, 'll, 'tcx>,\n                         place: &mir::Place<'tcx>)\n-                        -> PlaceRef<'ll, 'tcx> {\n+                        -> PlaceRef<'tcx, &'ll Value> {\n         debug!(\"codegen_place(place={:?})\", place);\n \n         let cx = bx.cx;"}, {"sha": "580931fdbb3c57d70ca9e155a44a8c43303e7e8a", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a9e6b8776667465b4d4fb2c54842a9a344b1246/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a9e6b8776667465b4d4fb2c54842a9a344b1246/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=5a9e6b8776667465b4d4fb2c54842a9a344b1246", "patch": "@@ -35,7 +35,7 @@ use super::place::PlaceRef;\n impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_rvalue(&mut self,\n                         bx: Builder<'a, 'll, 'tcx>,\n-                        dest: PlaceRef<'ll, 'tcx>,\n+                        dest: PlaceRef<'tcx, &'ll Value>,\n                         rvalue: &mir::Rvalue<'tcx>)\n                         -> Builder<'a, 'll, 'tcx>\n     {\n@@ -178,12 +178,12 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn codegen_rvalue_unsized(&mut self,\n-                        bx: Builder<'a, 'll, 'tcx>,\n-                        indirect_dest: PlaceRef<'ll, 'tcx>,\n-                        rvalue: &mir::Rvalue<'tcx>)\n-                        -> Builder<'a, 'll, 'tcx>\n-    {\n+    pub fn codegen_rvalue_unsized(\n+        &mut self,\n+        bx: Builder<'a, 'll, 'tcx>,\n+        indirect_dest: PlaceRef<'tcx, &'ll Value>,\n+        rvalue: &mir::Rvalue<'tcx>,\n+    ) -> Builder<'a, 'll, 'tcx> {\n         debug!(\"codegen_rvalue_unsized(indirect_dest.llval={:?}, rvalue={:?})\",\n                indirect_dest.llval, rvalue);\n \n@@ -201,7 +201,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_rvalue_operand(&mut self,\n                                 bx: Builder<'a, 'll, 'tcx>,\n                                 rvalue: &mir::Rvalue<'tcx>)\n-                                -> (Builder<'a, 'll, 'tcx>, OperandRef<'ll, 'tcx>)\n+                                -> (Builder<'a, 'll, 'tcx>, OperandRef<'tcx, &'ll Value>)\n     {\n         assert!(self.rvalue_creates_operand(rvalue), \"cannot codegen {:?} to operand\", rvalue);\n \n@@ -677,7 +677,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                                       op: mir::BinOp,\n                                       lhs: &'ll Value,\n                                       rhs: &'ll Value,\n-                                      input_ty: Ty<'tcx>) -> OperandValue<'ll> {\n+                                      input_ty: Ty<'tcx>) -> OperandValue<&'ll Value> {\n         // This case can currently arise only from functions marked\n         // with #[rustc_inherit_overflow_checks] and inlined from\n         // another crate (mostly core::num generic/#[inline] fns),"}]}