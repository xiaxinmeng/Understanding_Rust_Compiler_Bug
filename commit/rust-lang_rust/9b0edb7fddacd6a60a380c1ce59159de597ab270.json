{"sha": "9b0edb7fddacd6a60a380c1ce59159de597ab270", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliMGVkYjdmZGRhY2Q2YTYwYTM4MGMxY2U1OTE1OWRlNTk3YWIyNzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-27T19:38:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-27T19:38:01Z"}, "message": "Auto merge of #83580 - Dylan-DPC:rollup-1zod4p7, r=Dylan-DPC\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #81351 (combine: stop eagerly evaluating consts)\n - #82525 (make unaligned_references future-incompat lint warn-by-default)\n - #82626 (update array missing `IntoIterator` msg)\n - #82917 (Add function core::iter::zip)\n - #82993 (rustdoc: Use diagnostics for error when including sources)\n - #83522 (Improve fs error open_from unix)\n - #83548 (Always preserve `None`-delimited groups in a captured `TokenStream`)\n - #83555 (Add #[inline] to io::Error methods)\n\nFailed merges:\n\n - #83130 (escape_ascii take 2)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "334eb1b9a4ec064bca2df01036caabb5d4b1ea09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/334eb1b9a4ec064bca2df01036caabb5d4b1ea09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b0edb7fddacd6a60a380c1ce59159de597ab270", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b0edb7fddacd6a60a380c1ce59159de597ab270", "html_url": "https://github.com/rust-lang/rust/commit/9b0edb7fddacd6a60a380c1ce59159de597ab270", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b0edb7fddacd6a60a380c1ce59159de597ab270/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afaf33dcafe9c7068b63eb997df221aa08db7c29", "url": "https://api.github.com/repos/rust-lang/rust/commits/afaf33dcafe9c7068b63eb997df221aa08db7c29", "html_url": "https://github.com/rust-lang/rust/commit/afaf33dcafe9c7068b63eb997df221aa08db7c29"}, {"sha": "7d6af6751c5726d884440d4e8d462a9ee6c5efc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d6af6751c5726d884440d4e8d462a9ee6c5efc1", "html_url": "https://github.com/rust-lang/rust/commit/7d6af6751c5726d884440d4e8d462a9ee6c5efc1"}], "stats": {"total": 1699, "additions": 884, "deletions": 815}, "files": [{"sha": "96277950cfe1a0fbf9489172436ddc6c49f18480", "filename": "compiler/rustc_apfloat/src/ieee.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -2273,6 +2273,7 @@ impl Loss {\n mod sig {\n     use super::{limbs_for_bits, ExpInt, Limb, Loss, LIMB_BITS};\n     use core::cmp::Ordering;\n+    use core::iter;\n     use core::mem;\n \n     pub(super) fn is_all_zeros(limbs: &[Limb]) -> bool {\n@@ -2483,7 +2484,7 @@ mod sig {\n     pub(super) fn add(a: &mut [Limb], b: &[Limb], mut c: Limb) -> Limb {\n         assert!(c <= 1);\n \n-        for (a, &b) in a.iter_mut().zip(b) {\n+        for (a, &b) in iter::zip(a, b) {\n             let (r, overflow) = a.overflowing_add(b);\n             let (r, overflow2) = r.overflowing_add(c);\n             *a = r;\n@@ -2497,7 +2498,7 @@ mod sig {\n     pub(super) fn sub(a: &mut [Limb], b: &[Limb], mut c: Limb) -> Limb {\n         assert!(c <= 1);\n \n-        for (a, &b) in a.iter_mut().zip(b) {\n+        for (a, &b) in iter::zip(a, b) {\n             let (r, overflow) = a.overflowing_sub(b);\n             let (r, overflow2) = r.overflowing_sub(c);\n             *a = r;"}, {"sha": "c648147d108fb4c0e14e440bf0e720db31dcc2cd", "filename": "compiler/rustc_apfloat/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -33,6 +33,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![no_std]\n #![forbid(unsafe_code)]\n+#![feature(iter_zip)]\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n "}, {"sha": "032a4e6c78211a15d89694173a08e448fd2003bd", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -14,6 +14,7 @@\n #![feature(const_fn_transmute)]\n #![feature(const_panic)]\n #![feature(crate_visibility_modifier)]\n+#![feature(iter_zip)]\n #![feature(label_break_value)]\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]"}, {"sha": "1e63ca172e7fc0224d5f9f851bf42dddd0bf3e82", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -341,7 +341,7 @@ impl TokenStream {\n     pub fn eq_unspanned(&self, other: &TokenStream) -> bool {\n         let mut t1 = self.trees();\n         let mut t2 = other.trees();\n-        for (t1, t2) in t1.by_ref().zip(t2.by_ref()) {\n+        for (t1, t2) in iter::zip(&mut t1, &mut t2) {\n             if !t1.eq_unspanned(&t2) {\n                 return false;\n             }"}, {"sha": "ea01632d75d6a975d19eea985306df7af3d101e8", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -18,6 +18,7 @@ use rustc_target::spec::abi;\n use smallvec::{smallvec, SmallVec};\n use tracing::debug;\n \n+use std::iter;\n use std::mem;\n \n pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n@@ -206,7 +207,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             UseTreeKind::Glob => {}\n             UseTreeKind::Simple(_, id1, id2) => {\n                 for (_, &id) in\n-                    self.expect_full_res_from_use(base_id).skip(1).zip([id1, id2].iter())\n+                    iter::zip(self.expect_full_res_from_use(base_id).skip(1), &[id1, id2])\n                 {\n                     vec.push(id);\n                 }\n@@ -537,7 +538,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // won't be dealing with macros in the rest of the compiler.\n                 // Essentially a single `use` which imports two names is desugared into\n                 // two imports.\n-                for (res, &new_node_id) in resolutions.zip([id1, id2].iter()) {\n+                for (res, &new_node_id) in iter::zip(resolutions, &[id1, id2]) {\n                     let ident = *ident;\n                     let mut path = path.clone();\n                     for seg in &mut path.segments {"}, {"sha": "192c32803271250ac2d307939a6efedca48392d6", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -33,6 +33,7 @@\n #![feature(crate_visibility_modifier)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(box_patterns)]\n+#![feature(iter_zip)]\n #![recursion_limit = \"256\"]\n \n use rustc_ast::node_id::NodeMap;"}, {"sha": "04753926c3e2a7d7bd5d2cee60d201a6fc4a5377", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1034,7 +1034,7 @@ impl<'a> MethodDef<'a> {\n         // make a series of nested matches, to destructure the\n         // structs. This is actually right-to-left, but it shouldn't\n         // matter.\n-        for (arg_expr, pat) in self_args.iter().zip(patterns) {\n+        for (arg_expr, pat) in iter::zip(self_args, patterns) {\n             body = cx.expr_match(\n                 trait_.span,\n                 arg_expr.clone(),\n@@ -1351,7 +1351,7 @@ impl<'a> MethodDef<'a> {\n             let mut discriminant_test = cx.expr_bool(sp, true);\n \n             let mut first_ident = None;\n-            for (&ident, self_arg) in vi_idents.iter().zip(&self_args) {\n+            for (&ident, self_arg) in iter::zip(&vi_idents, &self_args) {\n                 let self_addr = cx.expr_addr_of(sp, self_arg.clone());\n                 let variant_value =\n                     deriving::call_intrinsic(cx, sp, sym::discriminant_value, vec![self_addr]);\n@@ -1571,9 +1571,7 @@ impl<'a> TraitDef<'a> {\n         let subpats = self.create_subpatterns(cx, paths, mutbl, use_temporaries);\n         let pattern = match *struct_def {\n             VariantData::Struct(..) => {\n-                let field_pats = subpats\n-                    .into_iter()\n-                    .zip(&ident_exprs)\n+                let field_pats = iter::zip(subpats, &ident_exprs)\n                     .map(|(pat, &(sp, ident, ..))| {\n                         if ident.is_none() {\n                             cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");"}, {"sha": "d7926ed0e0bce1805d7afaee040aec8fd70f81ed", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -7,6 +7,7 @@\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n+#![feature(iter_zip)]\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(proc_macro_internals)]"}, {"sha": "4226ed7d99be13cd1731e63dccd408d1659eccb2", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -24,6 +24,7 @@ use tracing::{debug, info};\n use std::ffi::{CStr, CString};\n use std::fs::File;\n use std::io;\n+use std::iter;\n use std::path::Path;\n use std::ptr;\n use std::slice;\n@@ -916,9 +917,7 @@ impl ThinLTOKeysMap {\n         modules: &[llvm::ThinLTOModule],\n         names: &[CString],\n     ) -> Self {\n-        let keys = modules\n-            .iter()\n-            .zip(names.iter())\n+        let keys = iter::zip(modules, names)\n             .map(|(module, name)| {\n                 let key = build_string(|rust_str| unsafe {\n                     llvm::LLVMRustComputeLTOCacheKey(rust_str, module.identifier, data.0);"}, {"sha": "896e56a9a1e3a6410d128cb6fccccad337e47464", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -21,6 +21,7 @@ use rustc_target::abi::{self, Align, Size};\n use rustc_target::spec::{HasTargetSpec, Target};\n use std::borrow::Cow;\n use std::ffi::CStr;\n+use std::iter;\n use std::ops::{Deref, Range};\n use std::ptr;\n use tracing::debug;\n@@ -1352,18 +1353,14 @@ impl Builder<'a, 'll, 'tcx> {\n \n         let param_tys = self.cx.func_params_types(fn_ty);\n \n-        let all_args_match = param_tys\n-            .iter()\n-            .zip(args.iter().map(|&v| self.val_ty(v)))\n+        let all_args_match = iter::zip(&param_tys, args.iter().map(|&v| self.val_ty(v)))\n             .all(|(expected_ty, actual_ty)| *expected_ty == actual_ty);\n \n         if all_args_match {\n             return Cow::Borrowed(args);\n         }\n \n-        let casted_args: Vec<_> = param_tys\n-            .into_iter()\n-            .zip(args.iter())\n+        let casted_args: Vec<_> = iter::zip(param_tys, args)\n             .enumerate()\n             .map(|(i, (expected_ty, &actual_val))| {\n                 let actual_ty = self.val_ty(actual_val);"}, {"sha": "d90e93f116cc1c034aa015172af24e2fdc73ccfd", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1962,9 +1962,7 @@ fn prepare_enum_metadata(\n \n     let discriminant_type_metadata = |discr: Primitive| {\n         let enumerators_metadata: Vec<_> = match enum_type.kind() {\n-            ty::Adt(def, _) => def\n-                .discriminants(tcx)\n-                .zip(&def.variants)\n+            ty::Adt(def, _) => iter::zip(def.discriminants(tcx), &def.variants)\n                 .map(|((_, discr), v)| {\n                     let name = v.ident.as_str();\n                     let is_unsigned = match discr.ty.kind() {\n@@ -2336,9 +2334,7 @@ fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> &'ll DIAr\n         if substs.types().next().is_some() {\n             let generics = cx.tcx.generics_of(def.did);\n             let names = get_parameter_names(cx, generics);\n-            let template_params: Vec<_> = substs\n-                .iter()\n-                .zip(names)\n+            let template_params: Vec<_> = iter::zip(substs, names)\n                 .filter_map(|(kind, name)| {\n                     if let GenericArgKind::Type(ty) = kind.unpack() {\n                         let actual_type ="}, {"sha": "e157a38aa03d5838e58bb37f421e6b25f0a4ef3a", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -37,6 +37,7 @@ use rustc_target::abi::{LayoutOf, Primitive, Size};\n use libc::c_uint;\n use smallvec::SmallVec;\n use std::cell::RefCell;\n+use std::iter;\n use tracing::debug;\n \n mod create_scope_map;\n@@ -448,9 +449,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             // Again, only create type information if full debuginfo is enabled\n             let template_params: Vec<_> = if cx.sess().opts.debuginfo == DebugInfo::Full {\n                 let names = get_parameter_names(cx, generics);\n-                substs\n-                    .iter()\n-                    .zip(names)\n+                iter::zip(substs, names)\n                     .filter_map(|(kind, name)| {\n                         if let GenericArgKind::Type(ty) = kind.unpack() {\n                             let actual_type ="}, {"sha": "5ca4b226c38fba32a404b06182947fa1428fac09", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -11,6 +11,7 @@\n #![feature(extended_key_value_attributes)]\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]\n+#![feature(iter_zip)]\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![recursion_limit = \"256\"]"}, {"sha": "56b4ef7938312a068d95992e2a0513110fc96342", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -8,6 +8,7 @@\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(associated_type_bounds)]\n+#![feature(iter_zip)]\n #![recursion_limit = \"256\"]\n #![feature(box_syntax)]\n "}, {"sha": "91df67b53d21fb6192ebb162a72a327a3c0d587d", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -282,9 +282,7 @@ fn create_funclets<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>>,\n     IndexVec<mir::BasicBlock, Option<Bx::Funclet>>,\n ) {\n-    block_bxs\n-        .iter_enumerated()\n-        .zip(cleanup_kinds)\n+    iter::zip(block_bxs.iter_enumerated(), cleanup_kinds)\n         .map(|((bb, &llbb), cleanup_kind)| {\n             match *cleanup_kind {\n                 CleanupKind::Funclet if base::wants_msvc_seh(bx.sess()) => {}"}, {"sha": "633c64af3c59080d319975059fd52c6ce46f3a00", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -2214,9 +2214,7 @@ pub fn is_case_difference(sm: &SourceMap, suggested: &str, sp: Span) -> bool {\n     };\n     let ascii_confusables = &['c', 'f', 'i', 'k', 'o', 's', 'u', 'v', 'w', 'x', 'y', 'z'];\n     // All the chars that differ in capitalization are confusable (above):\n-    let confusable = found\n-        .chars()\n-        .zip(suggested.chars())\n+    let confusable = iter::zip(found.chars(), suggested.chars())\n         .filter(|(f, s)| f != s)\n         .all(|(f, s)| (ascii_confusables.contains(&f) || ascii_confusables.contains(&s)));\n     confusable && found.to_lowercase() == suggested.to_lowercase()"}, {"sha": "6f3ce20fc8ed28df5373a5490cf94872f0efff61", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -6,6 +6,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(backtrace)]\n #![feature(extended_key_value_attributes)]\n+#![feature(iter_zip)]\n #![feature(nll)]\n \n #[macro_use]"}, {"sha": "ec122e7be6e8efd52462a4ca5f5ec2685b9ec639", "filename": "compiler/rustc_errors/src/styled_buffer.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,6 +1,7 @@\n // Code for creating styled buffers\n \n use crate::snippet::{Style, StyledString};\n+use std::iter;\n \n #[derive(Debug)]\n pub struct StyledBuffer {\n@@ -20,11 +21,11 @@ impl StyledBuffer {\n         let mut output: Vec<Vec<StyledString>> = vec![];\n         let mut styled_vec: Vec<StyledString> = vec![];\n \n-        for (row, row_style) in self.text.iter().zip(&self.styles) {\n+        for (row, row_style) in iter::zip(&self.text, &self.styles) {\n             let mut current_style = Style::NoStyle;\n             let mut current_text = String::new();\n \n-            for (&c, &s) in row.iter().zip(row_style) {\n+            for (&c, &s) in iter::zip(row, row_style) {\n                 if s != current_style {\n                     if !current_text.is_empty() {\n                         styled_vec.push(StyledString { text: current_text, style: current_style });"}, {"sha": "5fb85867501673b5e03c36c74e75f3e8a5c3c2c0", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -2,6 +2,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(destructuring_assignment)]\n+#![feature(iter_zip)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(proc_macro_diagnostic)]\n #![feature(proc_macro_internals)]"}, {"sha": "3497e5ad543a1fcb6cb2b3f5d8df86086543f41d", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -116,6 +116,8 @@ use rustc_span::{symbol::MacroRulesNormalizedIdent, MultiSpan, Span};\n \n use smallvec::SmallVec;\n \n+use std::iter;\n+\n /// Stack represented as linked list.\n ///\n /// Those are used for environments because they grow incrementally and are not mutable.\n@@ -204,7 +206,7 @@ pub(super) fn check_meta_variables(\n         sess.span_diagnostic.span_bug(span, \"length mismatch between LHSes and RHSes\")\n     }\n     let mut valid = true;\n-    for (lhs, rhs) in lhses.iter().zip(rhses.iter()) {\n+    for (lhs, rhs) in iter::zip(lhses, rhses) {\n         let mut binders = Binders::default();\n         check_binders(sess, node_id, lhs, &Stack::Empty, &mut binders, &Stack::Empty, &mut valid);\n         check_occurrences(sess, node_id, rhs, &Stack::Empty, &binders, &Stack::Empty, &mut valid);"}, {"sha": "cfea5092bc30655f7cac2acf11e1bb7e99a9e9a1", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -356,7 +356,7 @@ where\n {\n     assert_eq!(out_vec.len(), in_vec.len());\n     let mut changed = false;\n-    for (out_elem, in_elem) in out_vec.iter_mut().zip(in_vec.iter()) {\n+    for (out_elem, in_elem) in iter::zip(out_vec, in_vec) {\n         let old_val = *out_elem;\n         let new_val = op(old_val, *in_elem);\n         *out_elem = new_val;\n@@ -842,7 +842,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n         let (write_start, write_end) = self.range(write);\n         let words = &mut self.words[..];\n         let mut changed = false;\n-        for (read_index, write_index) in (read_start..read_end).zip(write_start..write_end) {\n+        for (read_index, write_index) in iter::zip(read_start..read_end, write_start..write_end) {\n             let word = words[write_index];\n             let new_word = word | words[read_index];\n             words[write_index] = new_word;\n@@ -858,7 +858,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n         assert_eq!(with.domain_size(), self.num_columns);\n         let (write_start, write_end) = self.range(write);\n         let mut changed = false;\n-        for (read_index, write_index) in (0..with.words().len()).zip(write_start..write_end) {\n+        for (read_index, write_index) in iter::zip(0..with.words().len(), write_start..write_end) {\n             let word = self.words[write_index];\n             let new_word = word | with.words()[read_index];\n             self.words[write_index] = new_word;"}, {"sha": "3ced3920cfdfe82118fa0914c970dd0bf98c8b97", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -2,6 +2,7 @@\n #![feature(const_fn)]\n #![feature(const_panic)]\n #![feature(extend_one)]\n+#![feature(iter_zip)]\n #![feature(unboxed_closures)]\n #![feature(test)]\n #![feature(fn_traits)]"}, {"sha": "f000d491b99a6f69adedeb5716c773a813bc3ce8", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -27,6 +27,7 @@ use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n use rustc_middle::ty::{self, BoundVar, Const, ToPredicate, Ty, TyCtxt};\n use std::fmt::Debug;\n+use std::iter;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// This method is meant to be invoked as the final step of a canonical query\n@@ -418,7 +419,8 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n         // In terms of our example above, we are iterating over pairs like:\n         // [(?A, Vec<?0>), ('static, '?1), (?B, ?0)]\n-        for (original_value, result_value) in original_values.var_values.iter().zip(result_values) {\n+        for (original_value, result_value) in iter::zip(&original_values.var_values, result_values)\n+        {\n             match result_value.unpack() {\n                 GenericArgKind::Type(result_value) => {\n                     // e.g., here `result_value` might be `?0` in the example above..."}, {"sha": "ffe947d209dd605a5b3bbd0572f880684a1c528a", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -543,10 +543,6 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n         true\n     }\n \n-    fn visit_ct_substs(&self) -> bool {\n-        true\n-    }\n-\n     fn binders<T>(\n         &mut self,\n         a: ty::Binder<T>,\n@@ -737,6 +733,16 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                     }\n                 }\n             }\n+            ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted })\n+                if self.tcx().lazy_normalization() =>\n+            {\n+                assert_eq!(promoted, None);\n+                let substs = self.relate_with_variance(ty::Variance::Invariant, substs, substs)?;\n+                Ok(self.tcx().mk_const(ty::Const {\n+                    ty: c.ty,\n+                    val: ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }),\n+                }))\n+            }\n             _ => relate::super_relate_consts(self, c, c),\n         }\n     }\n@@ -822,10 +828,6 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n         true\n     }\n \n-    fn visit_ct_substs(&self) -> bool {\n-        true\n-    }\n-\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _variance: ty::Variance,\n@@ -959,6 +961,16 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                     }\n                 }\n             }\n+            ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted })\n+                if self.tcx().lazy_normalization() =>\n+            {\n+                assert_eq!(promoted, None);\n+                let substs = self.relate_with_variance(ty::Variance::Invariant, substs, substs)?;\n+                Ok(self.tcx().mk_const(ty::Const {\n+                    ty: c.ty,\n+                    val: ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }),\n+                }))\n+            }\n             _ => relate::super_relate_consts(self, c, c),\n         }\n     }"}, {"sha": "a18c9569a8cd37174947a9290a3048b2491e8511", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -73,7 +73,7 @@ use rustc_middle::ty::{\n use rustc_span::{sym, BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n use std::ops::ControlFlow;\n-use std::{cmp, fmt};\n+use std::{cmp, fmt, iter};\n \n mod note;\n \n@@ -963,7 +963,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             ty::GenericParamDefKind::Const { has_default: true } => Some(param.def_id),\n             _ => None,\n         });\n-        for (def_id, actual) in default_params.zip(substs.iter().rev()) {\n+        for (def_id, actual) in iter::zip(default_params, substs.iter().rev()) {\n             match actual.unpack() {\n                 GenericArgKind::Const(c) => {\n                     if self.tcx.const_param_default(def_id).subst(self.tcx, substs) != c {\n@@ -1040,7 +1040,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let len1 = sig1.inputs().len();\n         let len2 = sig2.inputs().len();\n         if len1 == len2 {\n-            for (i, (l, r)) in sig1.inputs().iter().zip(sig2.inputs().iter()).enumerate() {\n+            for (i, (l, r)) in iter::zip(sig1.inputs(), sig2.inputs()).enumerate() {\n                 let (x1, x2) = self.cmp(l, r);\n                 (values.0).0.extend(x1.0);\n                 (values.1).0.extend(x2.0);\n@@ -1161,12 +1161,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let common_len = cmp::min(len1, len2);\n                     let remainder1: Vec<_> = sub1.types().skip(common_len).collect();\n                     let remainder2: Vec<_> = sub2.types().skip(common_len).collect();\n-                    let common_default_params = remainder1\n-                        .iter()\n-                        .rev()\n-                        .zip(remainder2.iter().rev())\n-                        .filter(|(a, b)| a == b)\n-                        .count();\n+                    let common_default_params =\n+                        iter::zip(remainder1.iter().rev(), remainder2.iter().rev())\n+                            .filter(|(a, b)| a == b)\n+                            .count();\n                     let len = sub1.len() - common_default_params;\n                     let consts_offset = len - sub1.consts().count();\n \n@@ -1297,12 +1295,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                     const SEPARATOR: &str = \"::\";\n                     let separator_len = SEPARATOR.len();\n-                    let split_idx: usize = t1_str\n-                        .split(SEPARATOR)\n-                        .zip(t2_str.split(SEPARATOR))\n-                        .take_while(|(mod1_str, mod2_str)| mod1_str == mod2_str)\n-                        .map(|(mod_str, _)| mod_str.len() + separator_len)\n-                        .sum();\n+                    let split_idx: usize =\n+                        iter::zip(t1_str.split(SEPARATOR), t2_str.split(SEPARATOR))\n+                            .take_while(|(mod1_str, mod2_str)| mod1_str == mod2_str)\n+                            .map(|(mod_str, _)| mod_str.len() + separator_len)\n+                            .sum();\n \n                     debug!(\n                         \"cmp: separator_len={}, split_idx={}, min_len={}\",\n@@ -1907,7 +1904,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         .find_map(|(path, msg)| (&path_str == path).then_some(msg))\n                     {\n                         let mut show_suggestion = true;\n-                        for (exp_ty, found_ty) in exp_substs.types().zip(found_substs.types()) {\n+                        for (exp_ty, found_ty) in\n+                            iter::zip(exp_substs.types(), found_substs.types())\n+                        {\n                             match *exp_ty.kind() {\n                                 ty::Ref(_, exp_ty, _) => {\n                                     match (exp_ty.kind(), found_ty.kind()) {"}, {"sha": "d352214b57926f908eb36a59c4ac7cec7a4f71fc", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -19,6 +19,7 @@\n #![feature(const_fn)]\n #![feature(const_panic)]\n #![feature(extend_one)]\n+#![feature(iter_zip)]\n #![feature(never_type)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(in_band_lifetimes)]"}, {"sha": "0ac4b6b25bbfe54804ae045cd29dfdb8ff922f65", "filename": "compiler/rustc_infer/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -9,6 +9,7 @@ use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::Symbol;\n use rustc_span::{MultiSpan, Span};\n use std::fmt;\n+use std::iter;\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_extra_impl_obligation(\n@@ -94,7 +95,7 @@ pub fn report_object_safety_error(\n         note_span\n             .push_span_label(trait_span, \"this trait cannot be made into an object...\".to_string());\n     }\n-    for (span, msg) in multi_span.into_iter().zip(messages.into_iter()) {\n+    for (span, msg) in iter::zip(multi_span, messages) {\n         note_span.push_span_label(span, msg);\n     }\n     err.span_note("}, {"sha": "cf2f1489e0296da95e05d7efc2e08e39a382664f", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -45,6 +45,7 @@ use rustc_target::abi::LayoutOf;\n use tracing::debug;\n \n use std::cell::Cell;\n+use std::iter;\n use std::slice;\n \n /// Information about the registered lints.\n@@ -864,7 +865,7 @@ impl<'tcx> LateContext<'tcx> {\n     pub fn match_def_path(&self, def_id: DefId, path: &[Symbol]) -> bool {\n         let names = self.get_def_path(def_id);\n \n-        names.len() == path.len() && names.into_iter().zip(path.iter()).all(|(a, &b)| a == b)\n+        names.len() == path.len() && iter::zip(names, path).all(|(a, &b)| a == b)\n     }\n \n     /// Gets the absolute path of `def_id` as a vector of `Symbol`."}, {"sha": "e2724b52453a52c8488e2a929772406111f4326f", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -33,6 +33,7 @@\n #![feature(box_patterns)]\n #![feature(crate_visibility_modifier)]\n #![feature(iter_order_by)]\n+#![feature(iter_zip)]\n #![feature(never_type)]\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n@@ -325,6 +326,7 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n     store.register_renamed(\"exceeding_bitshifts\", \"arithmetic_overflow\");\n     store.register_renamed(\"redundant_semicolon\", \"redundant_semicolons\");\n     store.register_renamed(\"overlapping_patterns\", \"overlapping_range_endpoints\");\n+    store.register_renamed(\"safe_packed_borrows\", \"unaligned_references\");\n \n     // These were moved to tool lints, but rustc still sees them when compiling normally, before\n     // tool lints are registered, so `check_tool_name_for_backwards_compat` doesn't work. Use"}, {"sha": "9c94bab04e98f6401458c9856c5d66f4a92ef8d0", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -17,6 +17,7 @@ use rustc_target::abi::{Integer, LayoutOf, TagEncoding, VariantIdx, Variants};\n use rustc_target::spec::abi::Abi as SpecAbi;\n \n use std::cmp;\n+use std::iter;\n use std::ops::ControlFlow;\n use tracing::debug;\n \n@@ -1255,7 +1256,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         let sig = self.cx.tcx.fn_sig(def_id);\n         let sig = self.cx.tcx.erase_late_bound_regions(sig);\n \n-        for (input_ty, input_hir) in sig.inputs().iter().zip(decl.inputs) {\n+        for (input_ty, input_hir) in iter::zip(sig.inputs(), decl.inputs) {\n             self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty, false, false);\n         }\n \n@@ -1355,10 +1356,7 @@ impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n                 layout\n             );\n \n-            let (largest, slargest, largest_index) = enum_definition\n-                .variants\n-                .iter()\n-                .zip(variants)\n+            let (largest, slargest, largest_index) = iter::zip(enum_definition.variants, variants)\n                 .map(|(variant, variant_layout)| {\n                     // Subtract the size of the enum tag.\n                     let bytes = variant_layout.size.bytes().saturating_sub(tag_size);"}, {"sha": "3baafee46125de3bcd02b67d3cfac52202f2c204", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 11, "deletions": 54, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1057,6 +1057,7 @@ declare_lint! {\n     ///     unsafe {\n     ///         let foo = Foo { field1: 0, field2: 0 };\n     ///         let _ = &foo.field1;\n+    ///         println!(\"{}\", foo.field1); // An implicit `&` is added here, triggering the lint.\n     ///     }\n     /// }\n     /// ```\n@@ -1065,20 +1066,20 @@ declare_lint! {\n     ///\n     /// ### Explanation\n     ///\n-    /// Creating a reference to an insufficiently aligned packed field is\n-    /// [undefined behavior] and should be disallowed.\n-    ///\n-    /// This lint is \"allow\" by default because there is no stable\n-    /// alternative, and it is not yet certain how widespread existing code\n-    /// will trigger this lint.\n-    ///\n-    /// See [issue #27060] for more discussion.\n+    /// Creating a reference to an insufficiently aligned packed field is [undefined behavior] and\n+    /// should be disallowed. Using an `unsafe` block does not change anything about this. Instead,\n+    /// the code should do a copy of the data in the packed field or use raw pointers and unaligned\n+    /// accesses. See [issue #82523] for more information.\n     ///\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n-    /// [issue #27060]: https://github.com/rust-lang/rust/issues/27060\n+    /// [issue #82523]: https://github.com/rust-lang/rust/issues/82523\n     pub UNALIGNED_REFERENCES,\n-    Allow,\n+    Warn,\n     \"detects unaligned references to fields of packed structs\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #82523 <https://github.com/rust-lang/rust/issues/82523>\",\n+        edition: None,\n+    };\n     report_in_external_macro\n }\n \n@@ -1150,49 +1151,6 @@ declare_lint! {\n     \"detects attempts to mutate a `const` item\",\n }\n \n-declare_lint! {\n-    /// The `safe_packed_borrows` lint detects borrowing a field in the\n-    /// interior of a packed structure with alignment other than 1.\n-    ///\n-    /// ### Example\n-    ///\n-    /// ```rust\n-    /// #[repr(packed)]\n-    /// pub struct Unaligned<T>(pub T);\n-    ///\n-    /// pub struct Foo {\n-    ///     start: u8,\n-    ///     data: Unaligned<u32>,\n-    /// }\n-    ///\n-    /// fn main() {\n-    ///     let x = Foo { start: 0, data: Unaligned(1) };\n-    ///     let y = &x.data.0;\n-    /// }\n-    /// ```\n-    ///\n-    /// {{produces}}\n-    ///\n-    /// ### Explanation\n-    ///\n-    /// This type of borrow is unsafe and can cause errors on some platforms\n-    /// and violates some assumptions made by the compiler. This was\n-    /// previously allowed unintentionally. This is a [future-incompatible]\n-    /// lint to transition this to a hard error in the future. See [issue\n-    /// #46043] for more details, including guidance on how to solve the\n-    /// problem.\n-    ///\n-    /// [issue #46043]: https://github.com/rust-lang/rust/issues/46043\n-    /// [future-incompatible]: ../index.md#future-incompatible-lints\n-    pub SAFE_PACKED_BORROWS,\n-    Warn,\n-    \"safe borrows of fields of packed structs were erroneously allowed\",\n-    @future_incompatible = FutureIncompatibleInfo {\n-        reference: \"issue #46043 <https://github.com/rust-lang/rust/issues/46043>\",\n-        edition: None,\n-    };\n-}\n-\n declare_lint! {\n     /// The `patterns_in_fns_without_body` lint detects `mut` identifier\n     /// patterns as a parameter in functions without a body.\n@@ -2953,7 +2911,6 @@ declare_lint_pass! {\n         RENAMED_AND_REMOVED_LINTS,\n         UNALIGNED_REFERENCES,\n         CONST_ITEM_MUTATION,\n-        SAFE_PACKED_BORROWS,\n         PATTERNS_IN_FNS_WITHOUT_BODY,\n         MISSING_FRAGMENT_SPECIFIER,\n         LATE_BOUND_LIFETIME_ARGUMENTS,"}, {"sha": "842d2a977189d53e6a7e0102ef8a9e7e9823cd57", "filename": "compiler/rustc_macros/src/symbols/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -43,7 +43,7 @@ fn test_symbols_macro(input: TokenStream, expected_errors: &[&str]) {\n         \"Macro generated a different number of errors than expected\"\n     );\n \n-    for (found_error, &expected_error) in found_errors.iter().zip(expected_errors.iter()) {\n+    for (found_error, &expected_error) in found_errors.iter().zip(expected_errors) {\n         let found_error_str = format!(\"{}\", found_error);\n         assert_eq!(found_error_str, expected_error);\n     }"}, {"sha": "8a13ceec2211b5cd9e13b95d1614634702de026b", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -27,6 +27,7 @@ use crate::ty::{self, BoundVar, List, Region, TyCtxt};\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use smallvec::SmallVec;\n+use std::iter;\n use std::ops::Index;\n \n /// A \"canonicalized\" type `V` is one where all free inference\n@@ -315,10 +316,7 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n         use crate::ty::subst::GenericArgKind;\n \n         CanonicalVarValues {\n-            var_values: self\n-                .var_values\n-                .iter()\n-                .zip(0..)\n+            var_values: iter::zip(&self.var_values, 0..)\n                 .map(|(kind, i)| match kind.unpack() {\n                     GenericArgKind::Type(..) => {\n                         tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i).into())).into()"}, {"sha": "bd0749792db8bbffee6b24741bc5c3b0aa998669", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -51,6 +51,7 @@\n #![feature(exclusive_range_pattern)]\n #![feature(control_flow_enum)]\n #![feature(associated_type_defaults)]\n+#![feature(iter_zip)]\n #![recursion_limit = \"512\"]\n \n #[macro_use]"}, {"sha": "807d63948003a9cf877af2e8c8b708153e97842e", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -2329,7 +2329,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             CtorKind::Fn => fmt_tuple(fmt, &name),\n                             CtorKind::Fictive => {\n                                 let mut struct_fmt = fmt.debug_struct(&name);\n-                                for (field, place) in variant_def.fields.iter().zip(places) {\n+                                for (field, place) in iter::zip(&variant_def.fields, places) {\n                                     struct_fmt.field(&field.ident.as_str(), place);\n                                 }\n                                 struct_fmt.finish()\n@@ -2353,7 +2353,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             if let Some(upvars) = tcx.upvars_mentioned(def_id) {\n-                                for (&var_id, place) in upvars.keys().zip(places) {\n+                                for (&var_id, place) in iter::zip(upvars.keys(), places) {\n                                     let var_name = tcx.hir().name(var_id);\n                                     struct_fmt.field(&var_name.as_str(), place);\n                                 }\n@@ -2372,7 +2372,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             if let Some(upvars) = tcx.upvars_mentioned(def_id) {\n-                                for (&var_id, place) in upvars.keys().zip(places) {\n+                                for (&var_id, place) in iter::zip(upvars.keys(), places) {\n                                     let var_name = tcx.hir().name(var_id);\n                                     struct_fmt.field(&var_name.as_str(), place);\n                                 }"}, {"sha": "ad3baccf1549616b5ebd694f4728de2255dfb9cb", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -23,15 +23,9 @@ pub enum UnsafetyViolationKind {\n     General,\n     /// Permitted both in `const fn`s and regular `fn`s.\n     GeneralAndConstFn,\n-    /// Borrow of packed field.\n-    /// Has to be handled as a lint for backwards compatibility.\n-    BorrowPacked,\n     /// Unsafe operation in an `unsafe fn` but outside an `unsafe` block.\n     /// Has to be handled as a lint for backwards compatibility.\n     UnsafeFn,\n-    /// Borrow of packed field in an `unsafe fn` but outside an `unsafe` block.\n-    /// Has to be handled as a lint for backwards compatibility.\n-    UnsafeFnBorrowPacked,\n }\n \n #[derive(Copy, Clone, PartialEq, TyEncodable, TyDecodable, HashStable, Debug)]"}, {"sha": "c8db4aeb449b87e66b1a99e78572f7046a1dce98", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -67,7 +67,7 @@ impl SwitchTargets {\n     ///\n     /// Note that this may yield 0 elements. Only the `otherwise` branch is mandatory.\n     pub fn iter(&self) -> SwitchTargetsIter<'_> {\n-        SwitchTargetsIter { inner: self.values.iter().zip(self.targets.iter()) }\n+        SwitchTargetsIter { inner: iter::zip(&self.values, &self.targets) }\n     }\n \n     /// Returns a slice with all possible jump targets (including the fallback target)."}, {"sha": "8fdae695ceb7f99612dab1f6603e4b0df7d7f06d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -789,7 +789,7 @@ impl CanonicalUserType<'tcx> {\n                     return false;\n                 }\n \n-                user_substs.substs.iter().zip(BoundVar::new(0)..).all(|(kind, cvar)| {\n+                iter::zip(user_substs.substs, BoundVar::new(0)..).all(|(kind, cvar)| {\n                     match kind.unpack() {\n                         GenericArgKind::Type(ty) => match ty.kind() {\n                             ty::Bound(debruijn, b) => {"}, {"sha": "0d03cf4575fcf3db3e0fdd52c37b89d1fe4096f4", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1251,13 +1251,13 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 } else {\n                     // Try to use a ScalarPair for all tagged enums.\n                     let mut common_prim = None;\n-                    for (field_layouts, layout_variant) in variants.iter().zip(&layout_variants) {\n+                    for (field_layouts, layout_variant) in iter::zip(&variants, &layout_variants) {\n                         let offsets = match layout_variant.fields {\n                             FieldsShape::Arbitrary { ref offsets, .. } => offsets,\n                             _ => bug!(),\n                         };\n                         let mut fields =\n-                            field_layouts.iter().zip(offsets).filter(|p| !p.0.is_zst());\n+                            iter::zip(field_layouts, offsets).filter(|p| !p.0.is_zst());\n                         let (field, offset) = match (fields.next(), fields.next()) {\n                             (None, None) => continue,\n                             (Some(pair), None) => pair,\n@@ -1626,7 +1626,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 const INVALID_FIELD_IDX: u32 = !0;\n                 let mut combined_inverse_memory_index =\n                     vec![INVALID_FIELD_IDX; promoted_memory_index.len() + memory_index.len()];\n-                let mut offsets_and_memory_index = offsets.into_iter().zip(memory_index);\n+                let mut offsets_and_memory_index = iter::zip(offsets, memory_index);\n                 let combined_offsets = variant_fields\n                     .iter()\n                     .enumerate()"}, {"sha": "f23c64cb036cf8c0ed9f71e577d0f6032614d93f", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -19,6 +19,7 @@ use std::char;\n use std::collections::BTreeMap;\n use std::convert::TryFrom;\n use std::fmt::{self, Write as _};\n+use std::iter;\n use std::ops::{ControlFlow, Deref, DerefMut};\n \n // `pretty` is a separate module only for organization.\n@@ -1223,7 +1224,7 @@ pub trait PrettyPrinter<'tcx>:\n                             CtorKind::Fictive => {\n                                 p!(\" {{ \");\n                                 let mut first = true;\n-                                for (field_def, field) in variant_def.fields.iter().zip(fields) {\n+                                for (field_def, field) in iter::zip(&variant_def.fields, fields) {\n                                     if !first {\n                                         p!(\", \");\n                                     }"}, {"sha": "e2bbb31263a79c9060730d7f51ef7cc9b01a3304", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -33,15 +33,6 @@ pub trait TypeRelation<'tcx>: Sized {\n     /// relation. Just affects error messages.\n     fn a_is_expected(&self) -> bool;\n \n-    /// Whether we should look into the substs of unevaluated constants\n-    /// even if `feature(const_evaluatable_checked)` is active.\n-    ///\n-    /// This is needed in `combine` to prevent accidentially creating\n-    /// infinite types as we abuse `TypeRelation` to walk a type there.\n-    fn visit_ct_substs(&self) -> bool {\n-        false\n-    }\n-\n     fn with_cause<F, R>(&mut self, _cause: Cause, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,\n@@ -149,7 +140,7 @@ pub fn relate_substs<R: TypeRelation<'tcx>>(\n ) -> RelateResult<'tcx, SubstsRef<'tcx>> {\n     let tcx = relation.tcx();\n \n-    let params = a_subst.iter().zip(b_subst).enumerate().map(|(i, (a, b))| {\n+    let params = iter::zip(a_subst, b_subst).enumerate().map(|(i, (a, b))| {\n         let variance = variances.map_or(ty::Invariant, |v| v[i]);\n         relation.relate_with_variance(variance, a, b)\n     });\n@@ -179,12 +170,8 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n             return Err(TypeError::ArgCount);\n         }\n \n-        let inputs_and_output = a\n-            .inputs()\n-            .iter()\n-            .cloned()\n-            .zip(b.inputs().iter().cloned())\n-            .map(|x| (x, false))\n+        let inputs_and_output = iter::zip(a.inputs(), b.inputs())\n+            .map(|(&a, &b)| ((a, b), false))\n             .chain(iter::once(((a.output(), b.output()), true)))\n             .map(|((a, b), is_output)| {\n                 if is_output {\n@@ -308,7 +295,7 @@ impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n     ) -> RelateResult<'tcx, GeneratorWitness<'tcx>> {\n         assert_eq!(a.0.len(), b.0.len());\n         let tcx = relation.tcx();\n-        let types = tcx.mk_type_list(a.0.iter().zip(b.0).map(|(a, b)| relation.relate(a, b)))?;\n+        let types = tcx.mk_type_list(iter::zip(a.0, b.0).map(|(a, b)| relation.relate(a, b)))?;\n         Ok(GeneratorWitness(types))\n     }\n }\n@@ -432,9 +419,9 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n                     let sz_a = sz_a.try_eval_usize(tcx, relation.param_env());\n                     let sz_b = sz_b.try_eval_usize(tcx, relation.param_env());\n                     match (sz_a, sz_b) {\n-                        (Some(sz_a_val), Some(sz_b_val)) => Err(TypeError::FixedArraySize(\n-                            expected_found(relation, sz_a_val, sz_b_val),\n-                        )),\n+                        (Some(sz_a_val), Some(sz_b_val)) if sz_a_val != sz_b_val => Err(\n+                            TypeError::FixedArraySize(expected_found(relation, sz_a_val, sz_b_val)),\n+                        ),\n                         _ => Err(err),\n                     }\n                 }\n@@ -449,7 +436,7 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n         (&ty::Tuple(as_), &ty::Tuple(bs)) => {\n             if as_.len() == bs.len() {\n                 Ok(tcx.mk_tup(\n-                    as_.iter().zip(bs).map(|(a, b)| relation.relate(a.expect_ty(), b.expect_ty())),\n+                    iter::zip(as_, bs).map(|(a, b)| relation.relate(a.expect_ty(), b.expect_ty())),\n                 )?)\n             } else if !(as_.is_empty() || bs.is_empty()) {\n                 Err(TypeError::TupleSize(expected_found(relation, as_.len(), bs.len())))\n@@ -532,7 +519,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n         }\n \n         (ty::ConstKind::Unevaluated(au), ty::ConstKind::Unevaluated(bu))\n-            if tcx.features().const_evaluatable_checked && !relation.visit_ct_substs() =>\n+            if tcx.features().const_evaluatable_checked =>\n         {\n             tcx.try_unify_abstract_consts(((au.def, au.substs), (bu.def, bu.substs)))\n         }\n@@ -593,9 +580,7 @@ fn check_const_value_eq<R: TypeRelation<'tcx>>(\n \n             // Both the variant and each field have to be equal.\n             if a_destructured.variant == b_destructured.variant {\n-                for (a_field, b_field) in\n-                    a_destructured.fields.iter().zip(b_destructured.fields.iter())\n-                {\n+                for (a_field, b_field) in iter::zip(a_destructured.fields, b_destructured.fields) {\n                     relation.consts(a_field, b_field)?;\n                 }\n \n@@ -631,7 +616,7 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'\n             return Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)));\n         }\n \n-        let v = a_v.into_iter().zip(b_v.into_iter()).map(|(ep_a, ep_b)| {\n+        let v = iter::zip(a_v, b_v).map(|(ep_a, ep_b)| {\n             use crate::ty::ExistentialPredicate::*;\n             match (ep_a.skip_binder(), ep_b.skip_binder()) {\n                 (Trait(a), Trait(b)) => Ok(ty::Binder::bind(Trait("}, {"sha": "9926cca2f51c6b45f3e9de24a3142983832cc96d", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -21,7 +21,7 @@ use rustc_macros::HashStable;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, TargetDataLayout};\n use smallvec::SmallVec;\n-use std::{cmp, fmt};\n+use std::{cmp, fmt, iter};\n \n #[derive(Copy, Clone, Debug)]\n pub struct Discr<'tcx> {\n@@ -414,9 +414,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             _ => bug!(),\n         };\n \n-        let result = item_substs\n-            .iter()\n-            .zip(impl_substs.iter())\n+        let result = iter::zip(item_substs, impl_substs)\n             .filter(|&(_, k)| {\n                 match k.unpack() {\n                     GenericArgKind::Lifetime(&ty::RegionKind::ReEarlyBound(ref ebr)) => {"}, {"sha": "4f61b8d0910ff940467cfd0cdd051aa50c1f27f3", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -18,6 +18,7 @@ use rustc_span::{\n     Span,\n };\n use rustc_target::abi::VariantIdx;\n+use std::iter;\n \n use super::borrow_set::BorrowData;\n use super::MirBorrowckCtxt;\n@@ -970,13 +971,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let expr = &self.infcx.tcx.hir().expect_expr(hir_id).kind;\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(.., body_id, args_span, _) = expr {\n-            for (captured_place, place) in self\n-                .infcx\n-                .tcx\n-                .typeck(def_id.expect_local())\n-                .closure_min_captures_flattened(def_id)\n-                .zip(places)\n-            {\n+            for (captured_place, place) in iter::zip(\n+                self.infcx.tcx.typeck(def_id.expect_local()).closure_min_captures_flattened(def_id),\n+                places,\n+            ) {\n                 let upvar_hir_id = captured_place.get_root_variable();\n                 //FIXME(project-rfc-2229#8): Use better span from captured_place\n                 let span = self.infcx.tcx.upvars_mentioned(local_did)?[&upvar_hir_id].span;"}, {"sha": "1f168c612f16726f78b3f98ded96658f6be6926e", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,4 +1,5 @@\n use std::fmt::{self, Display};\n+use std::iter;\n \n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n@@ -536,7 +537,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 // just worry about trying to match up the rustc type\n                 // with the HIR types:\n                 (ty::Tuple(elem_tys), hir::TyKind::Tup(elem_hir_tys)) => {\n-                    search_stack.extend(elem_tys.iter().map(|k| k.expect_ty()).zip(*elem_hir_tys));\n+                    search_stack\n+                        .extend(iter::zip(elem_tys.iter().map(|k| k.expect_ty()), *elem_hir_tys));\n                 }\n \n                 (ty::Slice(elem_ty), hir::TyKind::Slice(elem_hir_ty))\n@@ -611,7 +613,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         args: &'hir hir::GenericArgs<'hir>,\n         search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty<'hir>)>,\n     ) -> Option<&'hir hir::Lifetime> {\n-        for (kind, hir_arg) in substs.iter().zip(args.args) {\n+        for (kind, hir_arg) in iter::zip(substs, args.args) {\n             match (kind.unpack(), hir_arg) {\n                 (GenericArgKind::Lifetime(r), hir::GenericArg::Lifetime(lt)) => {\n                     if r.to_region_vid() == needle_fr {"}, {"sha": "1055e30a3a44cf3fbf1b380364f587132d9048c6", "filename": "compiler/rustc_mir/src/borrow_check/invalidation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -5,6 +5,7 @@ use rustc_middle::mir::{BorrowKind, Mutability, Operand};\n use rustc_middle::mir::{InlineAsmOperand, Terminator, TerminatorKind};\n use rustc_middle::mir::{Statement, StatementKind};\n use rustc_middle::ty::TyCtxt;\n+use std::iter;\n \n use crate::dataflow::indexes::BorrowIndex;\n \n@@ -69,7 +70,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 self.mutate_place(location, **place, Shallow(None), JustWrite);\n             }\n             StatementKind::LlvmInlineAsm(asm) => {\n-                for (o, output) in asm.asm.outputs.iter().zip(asm.outputs.iter()) {\n+                for (o, output) in iter::zip(&asm.asm.outputs, &*asm.outputs) {\n                     if o.is_indirect {\n                         // FIXME(eddyb) indirect inline asm outputs should\n                         // be encoded through MIR place derefs instead."}, {"sha": "583f73d5775d1bb713d3e5e7d5d67fc1fbe7655d", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -25,6 +25,7 @@ use either::Either;\n use smallvec::SmallVec;\n use std::cell::RefCell;\n use std::collections::BTreeMap;\n+use std::iter;\n use std::mem;\n use std::rc::Rc;\n \n@@ -595,7 +596,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                 self.mutate_place(location, (**place, span), Shallow(None), JustWrite, flow_state);\n             }\n             StatementKind::LlvmInlineAsm(ref asm) => {\n-                for (o, output) in asm.asm.outputs.iter().zip(asm.outputs.iter()) {\n+                for (o, output) in iter::zip(&asm.asm.outputs, &*asm.outputs) {\n                     if o.is_indirect {\n                         // FIXME(eddyb) indirect inline asm outputs should\n                         // be encoded through MIR place derefs instead."}, {"sha": "3654b51949e70a03ec9d8e3d07c3bd055be45f35", "filename": "compiler/rustc_mir/src/borrow_check/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fplaces_conflict.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -5,6 +5,7 @@ use rustc_hir as hir;\n use rustc_middle::mir::{Body, BorrowKind, Local, Place, PlaceElem, PlaceRef, ProjectionElem};\n use rustc_middle::ty::{self, TyCtxt};\n use std::cmp::max;\n+use std::iter;\n \n /// When checking if a place conflicts with another place, this enum is used to influence decisions\n /// where a place might be equal or disjoint with another place, such as if `a[i] == a[j]`.\n@@ -139,7 +140,7 @@ fn place_components_conflict<'tcx>(\n \n     // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n     for (i, (borrow_c, &access_c)) in\n-        borrow_place.projection.iter().zip(access_place.projection.iter()).enumerate()\n+        iter::zip(borrow_place.projection, access_place.projection).enumerate()\n     {\n         debug!(\"borrow_conflicts_with_place: borrow_c = {:?}\", borrow_c);\n         let borrow_proj_base = &borrow_place.projection[..i];"}, {"sha": "fddd1401868832ce6e3002895e5dc3a9671f8ccd", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1770,7 +1770,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if args.len() < sig.inputs().len() || (args.len() > sig.inputs().len() && !sig.c_variadic) {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n-        for (n, (fn_arg, op_arg)) in sig.inputs().iter().zip(args).enumerate() {\n+        for (n, (fn_arg, op_arg)) in iter::zip(sig.inputs(), args).enumerate() {\n             let op_arg_ty = op_arg.ty(body, self.tcx());\n             let op_arg_ty = self.normalize(op_arg_ty, term_location);\n             let category = if from_hir_call {"}, {"sha": "68fa9d8bf9858af6679076fa13feedc9698875a3", "filename": "compiler/rustc_mir/src/borrow_check/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -580,7 +580,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         let global_mapping = iter::once((tcx.lifetimes.re_static, fr_static));\n         let subst_mapping =\n-            identity_substs.regions().zip(fr_substs.regions().map(|r| r.to_region_vid()));\n+            iter::zip(identity_substs.regions(), fr_substs.regions().map(|r| r.to_region_vid()));\n \n         UniversalRegionIndices { indices: global_mapping.chain(subst_mapping).collect() }\n     }"}, {"sha": "f937b31f4cfc9d00afb13f31958ec9ba856e8e4c", "filename": "compiler/rustc_mir/src/dataflow/framework/lattice.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Flattice.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -40,6 +40,7 @@\n \n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n+use std::iter;\n \n /// A [partially ordered set][poset] that has a [least upper bound][lub] for any pair of elements\n /// in the set.\n@@ -110,7 +111,7 @@ impl<I: Idx, T: JoinSemiLattice> JoinSemiLattice for IndexVec<I, T> {\n         assert_eq!(self.len(), other.len());\n \n         let mut changed = false;\n-        for (a, b) in self.iter_mut().zip(other.iter()) {\n+        for (a, b) in iter::zip(self, other) {\n             changed |= a.join(b);\n         }\n         changed\n@@ -122,7 +123,7 @@ impl<I: Idx, T: MeetSemiLattice> MeetSemiLattice for IndexVec<I, T> {\n         assert_eq!(self.len(), other.len());\n \n         let mut changed = false;\n-        for (a, b) in self.iter_mut().zip(other.iter()) {\n+        for (a, b) in iter::zip(self, other) {\n             changed |= a.meet(b);\n         }\n         changed"}, {"sha": "c92cff1433f1a50ef520de7fb21089063fea738d", "filename": "compiler/rustc_mir/src/dataflow/impls/borrows.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -11,6 +11,7 @@ use crate::borrow_check::{\n use crate::dataflow::{self, fmt::DebugWithContext, GenKill};\n \n use std::fmt;\n+use std::iter;\n \n rustc_index::newtype_index! {\n     pub struct BorrowIndex {\n@@ -292,7 +293,7 @@ impl<'tcx> dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n             }\n \n             mir::StatementKind::LlvmInlineAsm(ref asm) => {\n-                for (output, kind) in asm.outputs.iter().zip(&asm.asm.outputs) {\n+                for (output, kind) in iter::zip(&*asm.outputs, &asm.asm.outputs) {\n                     if !kind.is_indirect && !kind.is_rw {\n                         self.kill_borrows_on_place(trans, *output);\n                     }"}, {"sha": "52b6e9f3753bef4a848fbb2dcd0dacc0b2b3b54e", "filename": "compiler/rustc_mir/src/dataflow/move_paths/builder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -4,6 +4,7 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::{self, TyCtxt};\n use smallvec::{smallvec, SmallVec};\n \n+use std::iter;\n use std::mem;\n \n use super::abs_domain::Lift;\n@@ -296,7 +297,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 self.create_move_path(**place);\n             }\n             StatementKind::LlvmInlineAsm(ref asm) => {\n-                for (output, kind) in asm.outputs.iter().zip(&asm.asm.outputs) {\n+                for (output, kind) in iter::zip(&*asm.outputs, &asm.asm.outputs) {\n                     if !kind.is_indirect {\n                         self.gather_init(output.as_ref(), InitKind::Deep);\n                     }"}, {"sha": "b0db4f9e649b31b437a8461b7677540414095381", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -18,6 +18,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(decl_macro)]\n #![feature(exact_size_is_empty)]\n #![feature(exhaustive_patterns)]\n+#![feature(iter_zip)]\n #![feature(never_type)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]"}, {"sha": "13b7221046bda4deb87d7eddd1b0f3f7d9480984", "filename": "compiler/rustc_mir/src/transform/check_packed_ref.rs", "status": "modified", "additions": 69, "deletions": 20, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_packed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_packed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_packed_ref.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,11 +1,18 @@\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::*;\n+use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint::builtin::UNALIGNED_REFERENCES;\n+use rustc_span::symbol::sym;\n \n use crate::transform::MirPass;\n use crate::util;\n \n+pub(crate) fn provide(providers: &mut Providers) {\n+    *providers = Providers { unsafe_derive_on_repr_packed, ..*providers };\n+}\n+\n pub struct CheckPackedRef;\n \n impl<'tcx> MirPass<'tcx> for CheckPackedRef {\n@@ -24,6 +31,41 @@ struct PackedRefChecker<'a, 'tcx> {\n     source_info: SourceInfo,\n }\n \n+fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    let lint_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+\n+    tcx.struct_span_lint_hir(UNALIGNED_REFERENCES, lint_hir_id, tcx.def_span(def_id), |lint| {\n+        // FIXME: when we make this a hard error, this should have its\n+        // own error code.\n+        let message = if tcx.generics_of(def_id).own_requires_monomorphization() {\n+            \"`#[derive]` can't be used on a `#[repr(packed)]` struct with \\\n+             type or const parameters (error E0133)\"\n+                .to_string()\n+        } else {\n+            \"`#[derive]` can't be used on a `#[repr(packed)]` struct that \\\n+             does not derive Copy (error E0133)\"\n+                .to_string()\n+        };\n+        lint.build(&message).emit()\n+    });\n+}\n+\n+fn builtin_derive_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n+    debug!(\"builtin_derive_def_id({:?})\", def_id);\n+    if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n+        if tcx.has_attr(impl_def_id, sym::automatically_derived) {\n+            debug!(\"builtin_derive_def_id({:?}) - is {:?}\", def_id, impl_def_id);\n+            Some(impl_def_id)\n+        } else {\n+            debug!(\"builtin_derive_def_id({:?}) - not automatically derived\", def_id);\n+            None\n+        }\n+    } else {\n+        debug!(\"builtin_derive_def_id({:?}) - not a method\", def_id);\n+        None\n+    }\n+}\n+\n impl<'a, 'tcx> Visitor<'tcx> for PackedRefChecker<'a, 'tcx> {\n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n         // Make sure we know where in the MIR we are.\n@@ -40,26 +82,33 @@ impl<'a, 'tcx> Visitor<'tcx> for PackedRefChecker<'a, 'tcx> {\n     fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, _location: Location) {\n         if context.is_borrow() {\n             if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n-                let source_info = self.source_info;\n-                let lint_root = self.body.source_scopes[source_info.scope]\n-                    .local_data\n-                    .as_ref()\n-                    .assert_crate_local()\n-                    .lint_root;\n-                self.tcx.struct_span_lint_hir(\n-                    UNALIGNED_REFERENCES,\n-                    lint_root,\n-                    source_info.span,\n-                    |lint| {\n-                        lint.build(\"reference to packed field is unaligned\")\n-                            .note(\n-                                \"fields of packed structs are not properly aligned, and creating \\\n-                                a misaligned reference is undefined behavior (even if that \\\n-                                reference is never dereferenced)\",\n-                            )\n-                            .emit()\n-                    },\n-                );\n+                let def_id = self.body.source.instance.def_id();\n+                if let Some(impl_def_id) = builtin_derive_def_id(self.tcx, def_id) {\n+                    // If a method is defined in the local crate,\n+                    // the impl containing that method should also be.\n+                    self.tcx.ensure().unsafe_derive_on_repr_packed(impl_def_id.expect_local());\n+                } else {\n+                    let source_info = self.source_info;\n+                    let lint_root = self.body.source_scopes[source_info.scope]\n+                        .local_data\n+                        .as_ref()\n+                        .assert_crate_local()\n+                        .lint_root;\n+                    self.tcx.struct_span_lint_hir(\n+                        UNALIGNED_REFERENCES,\n+                        lint_root,\n+                        source_info.span,\n+                        |lint| {\n+                            lint.build(\"reference to packed field is unaligned\")\n+                                .note(\n+                                    \"fields of packed structs are not properly aligned, and creating \\\n+                                    a misaligned reference is undefined behavior (even if that \\\n+                                    reference is never dereferenced)\",\n+                                )\n+                                .emit()\n+                        },\n+                    );\n+                }\n             }\n         }\n     }"}, {"sha": "09da9b2e4d6ffd29a9cd470b06094f8069da3952", "filename": "compiler/rustc_mir/src/transform/check_unsafety.rs", "status": "modified", "additions": 7, "deletions": 123, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -10,14 +10,12 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_session::lint::builtin::{SAFE_PACKED_BORROWS, UNSAFE_OP_IN_UNSAFE_FN, UNUSED_UNSAFE};\n+use rustc_session::lint::builtin::{UNSAFE_OP_IN_UNSAFE_FN, UNUSED_UNSAFE};\n use rustc_session::lint::Level;\n-use rustc_span::symbol::sym;\n \n use std::ops::Bound;\n \n use crate::const_eval::is_min_const_fn;\n-use crate::util;\n \n pub struct UnsafetyChecker<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n@@ -182,18 +180,6 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             self.check_mut_borrowing_layout_constrained_field(*place, context.is_mutating_use());\n         }\n \n-        // Check for borrows to packed fields.\n-        // `is_disaligned` already traverses the place to consider all projections after the last\n-        // `Deref`, so this only needs to be called once at the top level.\n-        if context.is_borrow() {\n-            if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n-                self.require_unsafe(\n-                    UnsafetyViolationKind::BorrowPacked,\n-                    UnsafetyViolationDetails::BorrowOfPackedField,\n-                );\n-            }\n-        }\n-\n         // Some checks below need the extra metainfo of the local declaration.\n         let decl = &self.body.local_decls[place.local];\n \n@@ -317,25 +303,15 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n             // `unsafe` blocks are required in safe code\n             Safety::Safe => {\n                 for violation in violations {\n-                    let mut violation = *violation;\n                     match violation.kind {\n                         UnsafetyViolationKind::GeneralAndConstFn\n                         | UnsafetyViolationKind::General => {}\n-                        UnsafetyViolationKind::BorrowPacked => {\n-                            if self.min_const_fn {\n-                                // const fns don't need to be backwards compatible and can\n-                                // emit these violations as a hard error instead of a backwards\n-                                // compat lint\n-                                violation.kind = UnsafetyViolationKind::General;\n-                            }\n-                        }\n-                        UnsafetyViolationKind::UnsafeFn\n-                        | UnsafetyViolationKind::UnsafeFnBorrowPacked => {\n+                        UnsafetyViolationKind::UnsafeFn => {\n                             bug!(\"`UnsafetyViolationKind::UnsafeFn` in an `Safe` context\")\n                         }\n                     }\n-                    if !self.violations.contains(&violation) {\n-                        self.violations.push(violation)\n+                    if !self.violations.contains(violation) {\n+                        self.violations.push(*violation)\n                     }\n                 }\n                 false\n@@ -345,11 +321,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                 for violation in violations {\n                     let mut violation = *violation;\n \n-                    if violation.kind == UnsafetyViolationKind::BorrowPacked {\n-                        violation.kind = UnsafetyViolationKind::UnsafeFnBorrowPacked;\n-                    } else {\n-                        violation.kind = UnsafetyViolationKind::UnsafeFn;\n-                    }\n+                    violation.kind = UnsafetyViolationKind::UnsafeFn;\n                     if !self.violations.contains(&violation) {\n                         self.violations.push(violation)\n                     }\n@@ -369,8 +341,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                             // these unsafe things are stable in const fn\n                             UnsafetyViolationKind::GeneralAndConstFn => {}\n                             // these things are forbidden in const fns\n-                            UnsafetyViolationKind::General\n-                            | UnsafetyViolationKind::BorrowPacked => {\n+                            UnsafetyViolationKind::General => {\n                                 let mut violation = *violation;\n                                 // const fns don't need to be backwards compatible and can\n                                 // emit these violations as a hard error instead of a backwards\n@@ -380,8 +351,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                                     self.violations.push(violation)\n                                 }\n                             }\n-                            UnsafetyViolationKind::UnsafeFn\n-                            | UnsafetyViolationKind::UnsafeFnBorrowPacked => bug!(\n+                            UnsafetyViolationKind::UnsafeFn => bug!(\n                                 \"`UnsafetyViolationKind::UnsafeFn` in an `ExplicitUnsafe` context\"\n                             ),\n                         }\n@@ -464,7 +434,6 @@ pub(crate) fn provide(providers: &mut Providers) {\n                 ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n             )\n         },\n-        unsafe_derive_on_repr_packed,\n         ..*providers\n     };\n }\n@@ -544,25 +513,6 @@ fn unsafety_check_result<'tcx>(\n     })\n }\n \n-fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    let lint_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-\n-    tcx.struct_span_lint_hir(SAFE_PACKED_BORROWS, lint_hir_id, tcx.def_span(def_id), |lint| {\n-        // FIXME: when we make this a hard error, this should have its\n-        // own error code.\n-        let message = if tcx.generics_of(def_id).own_requires_monomorphization() {\n-            \"`#[derive]` can't be used on a `#[repr(packed)]` struct with \\\n-             type or const parameters (error E0133)\"\n-                .to_string()\n-        } else {\n-            \"`#[derive]` can't be used on a `#[repr(packed)]` struct that \\\n-             does not derive Copy (error E0133)\"\n-                .to_string()\n-        };\n-        lint.build(&message).emit()\n-    });\n-}\n-\n /// Returns the `HirId` for an enclosing scope that is also `unsafe`.\n fn is_enclosed(\n     tcx: TyCtxt<'_>,\n@@ -609,22 +559,6 @@ fn report_unused_unsafe(tcx: TyCtxt<'_>, used_unsafe: &FxHashSet<hir::HirId>, id\n     });\n }\n \n-fn builtin_derive_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n-    debug!(\"builtin_derive_def_id({:?})\", def_id);\n-    if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n-        if tcx.has_attr(impl_def_id, sym::automatically_derived) {\n-            debug!(\"builtin_derive_def_id({:?}) - is {:?}\", def_id, impl_def_id);\n-            Some(impl_def_id)\n-        } else {\n-            debug!(\"builtin_derive_def_id({:?}) - not automatically derived\", def_id);\n-            None\n-        }\n-    } else {\n-        debug!(\"builtin_derive_def_id({:?}) - not a method\", def_id);\n-        None\n-    }\n-}\n-\n pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     debug!(\"check_unsafety({:?})\", def_id);\n \n@@ -657,27 +591,6 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                 .note(note)\n                 .emit();\n             }\n-            UnsafetyViolationKind::BorrowPacked => {\n-                if let Some(impl_def_id) = builtin_derive_def_id(tcx, def_id.to_def_id()) {\n-                    // If a method is defined in the local crate,\n-                    // the impl containing that method should also be.\n-                    tcx.ensure().unsafe_derive_on_repr_packed(impl_def_id.expect_local());\n-                } else {\n-                    tcx.struct_span_lint_hir(\n-                        SAFE_PACKED_BORROWS,\n-                        lint_root,\n-                        source_info.span,\n-                        |lint| {\n-                            lint.build(&format!(\n-                                \"{} is unsafe and requires unsafe{} block (error E0133)\",\n-                                description, unsafe_fn_msg,\n-                            ))\n-                            .note(note)\n-                            .emit()\n-                        },\n-                    )\n-                }\n-            }\n             UnsafetyViolationKind::UnsafeFn => tcx.struct_span_lint_hir(\n                 UNSAFE_OP_IN_UNSAFE_FN,\n                 lint_root,\n@@ -692,35 +605,6 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                     .emit();\n                 },\n             ),\n-            UnsafetyViolationKind::UnsafeFnBorrowPacked => {\n-                // When `unsafe_op_in_unsafe_fn` is disallowed, the behavior of safe and unsafe functions\n-                // should be the same in terms of warnings and errors. Therefore, with `#[warn(safe_packed_borrows)]`,\n-                // a safe packed borrow should emit a warning *but not an error* in an unsafe function,\n-                // just like in a safe function, even if `unsafe_op_in_unsafe_fn` is `deny`.\n-                //\n-                // Also, `#[warn(unsafe_op_in_unsafe_fn)]` can't cause any new errors. Therefore, with\n-                // `#[deny(safe_packed_borrows)]` and `#[warn(unsafe_op_in_unsafe_fn)]`, a packed borrow\n-                // should only issue a warning for the sake of backwards compatibility.\n-                //\n-                // The solution those 2 expectations is to always take the minimum of both lints.\n-                // This prevent any new errors (unless both lints are explicitly set to `deny`).\n-                let lint = if tcx.lint_level_at_node(SAFE_PACKED_BORROWS, lint_root).0\n-                    <= tcx.lint_level_at_node(UNSAFE_OP_IN_UNSAFE_FN, lint_root).0\n-                {\n-                    SAFE_PACKED_BORROWS\n-                } else {\n-                    UNSAFE_OP_IN_UNSAFE_FN\n-                };\n-                tcx.struct_span_lint_hir(&lint, lint_root, source_info.span, |lint| {\n-                    lint.build(&format!(\n-                        \"{} is unsafe and requires unsafe block (error E0133)\",\n-                        description,\n-                    ))\n-                    .span_label(source_info.span, description)\n-                    .note(note)\n-                    .emit();\n-                })\n-            }\n         }\n     }\n "}, {"sha": "0e9728df73ca749520a62b7e873487f15d3fa3f3", "filename": "compiler/rustc_mir/src/transform/coverage/debug.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -121,6 +121,7 @@ use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::{self, BasicBlock, TerminatorKind};\n use rustc_middle::ty::TyCtxt;\n \n+use std::iter;\n use std::lazy::SyncOnceCell;\n \n pub const NESTED_INDENT: &str = \"    \";\n@@ -703,9 +704,7 @@ pub(super) fn dump_coverage_graphviz(\n         let edge_counters = from_terminator\n             .successors()\n             .map(|&successor_bb| graphviz_data.get_edge_counter(from_bcb, successor_bb));\n-        edge_labels\n-            .iter()\n-            .zip(edge_counters)\n+        iter::zip(&edge_labels, edge_counters)\n             .map(|(label, some_counter)| {\n                 if let Some(counter) = some_counter {\n                     format!(\"{}\\n{}\", label, debug_counters.format_counter(counter))"}, {"sha": "c41e71e09a4efc7d64186850460538b2b254d0cb", "filename": "compiler/rustc_mir/src/transform/deduplicate_blocks.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdeduplicate_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdeduplicate_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdeduplicate_blocks.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,7 +1,7 @@\n //! This pass finds basic blocks that are completely equal,\n //! and replaces all uses with just one of them.\n \n-use std::{collections::hash_map::Entry, hash::Hash, hash::Hasher};\n+use std::{collections::hash_map::Entry, hash::Hash, hash::Hasher, iter};\n \n use crate::transform::MirPass;\n \n@@ -115,11 +115,7 @@ impl<'tcx, 'a> PartialEq for BasicBlockHashable<'tcx, 'a> {\n     fn eq(&self, other: &Self) -> bool {\n         self.basic_block_data.statements.len() == other.basic_block_data.statements.len()\n             && &self.basic_block_data.terminator().kind == &other.basic_block_data.terminator().kind\n-            && self\n-                .basic_block_data\n-                .statements\n-                .iter()\n-                .zip(&other.basic_block_data.statements)\n+            && iter::zip(&self.basic_block_data.statements, &other.basic_block_data.statements)\n                 .all(|(x, y)| statement_eq(&x.kind, &y.kind))\n     }\n }"}, {"sha": "f7a9835353e5cff77c14c762641f2bf99103e088", "filename": "compiler/rustc_mir/src/transform/match_branches.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,6 +1,7 @@\n use crate::transform::MirPass;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n+use std::iter;\n \n use super::simplify::simplify_cfg;\n \n@@ -83,7 +84,7 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n             if first_stmts.len() != scnd_stmts.len() {\n                 continue;\n             }\n-            for (f, s) in first_stmts.iter().zip(scnd_stmts.iter()) {\n+            for (f, s) in iter::zip(first_stmts, scnd_stmts) {\n                 match (&f.kind, &s.kind) {\n                     // If two statements are exactly the same, we can optimize.\n                     (f_s, s_s) if f_s == s_s => {}\n@@ -113,7 +114,7 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n             // and bb_idx has a different terminator from both of them.\n             let (from, first, second) = bbs.pick3_mut(bb_idx, first, second);\n \n-            let new_stmts = first.statements.iter().zip(second.statements.iter()).map(|(f, s)| {\n+            let new_stmts = iter::zip(&first.statements, &second.statements).map(|(f, s)| {\n                 match (&f.kind, &s.kind) {\n                     (f_s, s_s) if f_s == s_s => (*f).clone(),\n "}, {"sha": "5c49ee69edc51622a24aec74be2f1bf6733e583e", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -59,6 +59,7 @@ pub use rustc_middle::mir::MirSource;\n \n pub(crate) fn provide(providers: &mut Providers) {\n     self::check_unsafety::provide(providers);\n+    self::check_packed_ref::provide(providers);\n     *providers = Providers {\n         mir_keys,\n         mir_const,"}, {"sha": "589a4467dcae1023d9170f09fe27020e62adf284", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -17,6 +17,8 @@ use rustc_target::abi::VariantIdx;\n \n use rustc_index::vec::Idx;\n \n+use std::iter;\n+\n /// The \"outermost\" place that holds this value.\n #[derive(Copy, Clone, Debug, PartialEq)]\n crate enum PlaceBase {\n@@ -140,7 +142,7 @@ fn is_ancestor_or_same_capture(\n         return false;\n     }\n \n-    proj_possible_ancestor.iter().zip(proj_capture).all(|(a, b)| a == b)\n+    iter::zip(proj_possible_ancestor, proj_capture).all(|(a, b)| a == b)\n }\n \n /// Computes the index of a capture within the desugared closure provided the closure's"}, {"sha": "2097f38c25d76fcbd2de94006aef21e2c9db4fde", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -10,6 +10,7 @@ use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation};\n+use std::iter;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n@@ -286,9 +287,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // MIR does not natively support FRU, so for each\n                     // base-supplied field, generate an operand that\n                     // reads it from the base.\n-                    field_names\n-                        .into_iter()\n-                        .zip(field_types.into_iter())\n+                    iter::zip(field_names, *field_types)\n                         .map(|(n, ty)| match fields_map.get(&n) {\n                             Some(v) => v.clone(),\n                             None => {"}, {"sha": "23bc1da09b5554975b1ac01a183f0a69ce621d83", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -9,6 +9,7 @@\n #![feature(control_flow_enum)]\n #![feature(crate_visibility_modifier)]\n #![feature(bool_to_option)]\n+#![feature(iter_zip)]\n #![feature(once_cell)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![recursion_limit = \"256\"]"}, {"sha": "36a0fda645805d747280f9f3849eaf824977ae1d", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -98,21 +98,46 @@ impl<'a> Parser<'a> {\n         }\n         impl CreateTokenStream for LazyTokenStreamImpl {\n             fn create_token_stream(&self) -> TokenStream {\n-                // The token produced by the final call to `next` or `next_desugared`\n-                // was not actually consumed by the callback. The combination\n-                // of chaining the initial token and using `take` produces the desired\n-                // result - we produce an empty `TokenStream` if no calls were made,\n-                // and omit the final token otherwise.\n+                if self.num_calls == 0 {\n+                    return TokenStream::new(vec![]);\n+                }\n+\n                 let mut cursor_snapshot = self.cursor_snapshot.clone();\n-                let tokens = std::iter::once(self.start_token.clone())\n-                    .chain((0..self.num_calls).map(|_| {\n-                        if self.desugar_doc_comments {\n+                // Don't skip `None` delimiters, since we want to pass them to\n+                // proc macros. Normally, we'll end up capturing `TokenKind::Interpolated`,\n+                // which gets converted to a `None`-delimited group when we invoke\n+                // a proc-macro. However, it's possible to already have a `None`-delimited\n+                // group in the stream (such as when parsing the output of a proc-macro,\n+                // or in certain unusual cases with cross-crate `macro_rules!` macros).\n+                cursor_snapshot.skip_none_delims = false;\n+\n+                // The token produced by the final call to `next` or `next_desugared`\n+                // was not actually consumed by the callback.\n+                let num_calls = self.num_calls - 1;\n+                let mut i = 0;\n+                let tokens =\n+                    std::iter::once(self.start_token.clone()).chain(std::iter::from_fn(|| {\n+                        if i >= num_calls {\n+                            return None;\n+                        }\n+\n+                        let token = if self.desugar_doc_comments {\n                             cursor_snapshot.next_desugared()\n                         } else {\n                             cursor_snapshot.next()\n+                        };\n+\n+                        // When the `LazyTokenStreamImpl` was original produced, we did *not*\n+                        // include `NoDelim` tokens in `num_calls`, since they are normally ignored\n+                        // by the parser. Therefore, we only increment our counter for other types of tokens.\n+                        if !matches!(\n+                            token.0.kind,\n+                            token::OpenDelim(token::NoDelim) | token::CloseDelim(token::NoDelim)\n+                        ) {\n+                            i += 1;\n                         }\n-                    }))\n-                    .take(self.num_calls);\n+                        Some(token)\n+                    }));\n \n                 make_token_stream(tokens, self.append_unglued_token.clone())\n             }"}, {"sha": "748a8e2bb490fbefa6e749c7686c4ac83729ec4b", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -172,6 +172,13 @@ struct TokenCursor {\n     // appended to the captured stream when\n     // we evaluate a `LazyTokenStream`\n     append_unglued_token: Option<TreeAndSpacing>,\n+    // If `true`, skip the delimiters for `None`-delimited groups,\n+    // and just yield the inner tokens. This is `true` during\n+    // normal parsing, since the parser code is not currently prepared\n+    // to handle `None` delimiters. When capturing a `TokenStream`,\n+    // however, we want to handle `None`-delimiters, since\n+    // proc-macros always see `None`-delimited groups.\n+    skip_none_delims: bool,\n }\n \n #[derive(Clone)]\n@@ -184,13 +191,13 @@ struct TokenCursorFrame {\n }\n \n impl TokenCursorFrame {\n-    fn new(span: DelimSpan, delim: DelimToken, tts: TokenStream) -> Self {\n+    fn new(span: DelimSpan, delim: DelimToken, tts: TokenStream, skip_none_delims: bool) -> Self {\n         TokenCursorFrame {\n             delim,\n             span,\n-            open_delim: delim == token::NoDelim,\n+            open_delim: delim == token::NoDelim && skip_none_delims,\n             tree_cursor: tts.into_trees(),\n-            close_delim: delim == token::NoDelim,\n+            close_delim: delim == token::NoDelim && skip_none_delims,\n         }\n     }\n }\n@@ -218,7 +225,7 @@ impl TokenCursor {\n                     return (token, spacing);\n                 }\n                 TokenTree::Delimited(sp, delim, tts) => {\n-                    let frame = TokenCursorFrame::new(sp, delim, tts);\n+                    let frame = TokenCursorFrame::new(sp, delim, tts, self.skip_none_delims);\n                     self.stack.push(mem::replace(&mut self.frame, frame));\n                 }\n             }\n@@ -276,6 +283,7 @@ impl TokenCursor {\n                         .cloned()\n                         .collect::<TokenStream>()\n                 },\n+                self.skip_none_delims,\n             ),\n         ));\n \n@@ -371,12 +379,19 @@ impl<'a> Parser<'a> {\n             prev_token: Token::dummy(),\n             restrictions: Restrictions::empty(),\n             expected_tokens: Vec::new(),\n+            // Skip over the delimiters for `None`-delimited groups\n             token_cursor: TokenCursor {\n-                frame: TokenCursorFrame::new(DelimSpan::dummy(), token::NoDelim, tokens),\n+                frame: TokenCursorFrame::new(\n+                    DelimSpan::dummy(),\n+                    token::NoDelim,\n+                    tokens,\n+                    /* skip_none_delims */ true,\n+                ),\n                 stack: Vec::new(),\n                 num_next_calls: 0,\n                 desugar_doc_comments,\n                 append_unglued_token: None,\n+                skip_none_delims: true,\n             },\n             desugar_doc_comments,\n             unmatched_angle_bracket_count: 0,"}, {"sha": "933e8ad1d727c4719baf896de0cdd220785d0091", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -9,6 +9,7 @@\n #![feature(const_panic)]\n #![feature(crate_visibility_modifier)]\n #![feature(in_band_lifetimes)]\n+#![feature(iter_zip)]\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![recursion_limit = \"256\"]"}, {"sha": "f24309fa950217e2a45a0105712c08de80c0e30c", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -103,6 +103,7 @@ use rustc_span::Span;\n use std::collections::VecDeque;\n use std::io;\n use std::io::prelude::*;\n+use std::iter;\n use std::rc::Rc;\n \n mod rwu_table;\n@@ -1093,7 +1094,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let ia = &asm.inner;\n                 let outputs = asm.outputs_exprs;\n                 let inputs = asm.inputs_exprs;\n-                let succ = ia.outputs.iter().zip(outputs).rev().fold(succ, |succ, (o, output)| {\n+                let succ = iter::zip(&ia.outputs, outputs).rev().fold(succ, |succ, (o, output)| {\n                     // see comment on places\n                     // in propagate_through_place_components()\n                     if o.is_indirect {\n@@ -1344,7 +1345,7 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr<'tcx>) {\n             }\n \n             // Output operands must be places\n-            for (o, output) in asm.inner.outputs.iter().zip(asm.outputs_exprs) {\n+            for (o, output) in iter::zip(&asm.inner.outputs, asm.outputs_exprs) {\n                 if !o.is_indirect {\n                     this.check_place(output);\n                 }"}, {"sha": "6d5983f53dc3947556a6aeea712e48404c67b0a8", "filename": "compiler/rustc_passes/src/liveness/rwu_table.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_passes%2Fsrc%2Fliveness%2Frwu_table.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_passes%2Fsrc%2Fliveness%2Frwu_table.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness%2Frwu_table.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,4 +1,5 @@\n use crate::liveness::{LiveNode, Variable};\n+use std::iter;\n \n #[derive(Clone, Copy)]\n pub(super) struct RWU {\n@@ -91,7 +92,7 @@ impl RWUTable {\n \n         let mut changed = false;\n         let (dst_row, src_row) = self.pick2_rows_mut(dst, src);\n-        for (dst_word, src_word) in dst_row.iter_mut().zip(src_row.iter()) {\n+        for (dst_word, src_word) in iter::zip(dst_row, &*src_row) {\n             let old = *dst_word;\n             let new = *dst_word | src_word;\n             *dst_word = new;"}, {"sha": "e54b1796aaa55349d20d6c1cc4152aef7bd4d328", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -22,6 +22,7 @@ use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n use std::cmp::Ordering;\n+use std::iter;\n use std::mem::replace;\n use std::num::NonZeroU32;\n \n@@ -214,7 +215,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             {\n                 // Explicit version of iter::order::lt to handle parse errors properly\n                 for (dep_v, stab_v) in\n-                    dep_since.as_str().split('.').zip(stab_since.as_str().split('.'))\n+                    iter::zip(dep_since.as_str().split('.'), stab_since.as_str().split('.'))\n                 {\n                     match stab_v.parse::<u64>() {\n                         Err(_) => {"}, {"sha": "3db57c0ab3a4c26b04321d6cccf142cedb790da9", "filename": "compiler/rustc_query_system/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -3,6 +3,7 @@\n #![feature(const_panic)]\n #![feature(core_intrinsics)]\n #![feature(hash_raw_entry)]\n+#![feature(iter_zip)]\n #![feature(min_specialization)]\n #![feature(stmt_expr_attributes)]\n "}, {"sha": "21f580db04f282920a808ba01f686dbd79e3163e", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -22,7 +22,7 @@ use {\n     rustc_data_structures::{jobserver, OnDrop},\n     rustc_rayon_core as rayon_core,\n     rustc_span::DUMMY_SP,\n-    std::iter::FromIterator,\n+    std::iter::{self, FromIterator},\n     std::{mem, process},\n };\n \n@@ -463,7 +463,7 @@ fn remove_cycle<D: DepKind>(\n         spans.rotate_right(1);\n \n         // Zip them back together\n-        let mut stack: Vec<_> = spans.into_iter().zip(queries).collect();\n+        let mut stack: Vec<_> = iter::zip(spans, queries).collect();\n \n         // Remove the queries in our cycle from the list of jobs to look at\n         for r in &stack {"}, {"sha": "1fb07bdae9d002ad650135cda30cf80a2afa5694", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -22,6 +22,8 @@ use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, MultiSpan, Span, DUMMY_SP};\n \n+use std::iter;\n+\n use tracing::debug;\n \n type Res = def::Res<ast::NodeId>;\n@@ -1004,9 +1006,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 if let Some(spans) =\n                     field_spans.filter(|spans| spans.len() > 0 && fields.len() == spans.len())\n                 {\n-                    let non_visible_spans: Vec<Span> = fields\n-                        .iter()\n-                        .zip(spans.iter())\n+                    let non_visible_spans: Vec<Span> = iter::zip(&fields, &spans)\n                         .filter(|(vis, _)| {\n                             !self.r.is_accessible_from(**vis, self.parent_scope.module)\n                         })"}, {"sha": "8210da7b6ce3cd8a5fd8e5a0b1dc04ea5a5d6734", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -14,6 +14,7 @@\n #![feature(control_flow_enum)]\n #![feature(crate_visibility_modifier)]\n #![feature(format_args_capture)]\n+#![feature(iter_zip)]\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![recursion_limit = \"256\"]"}, {"sha": "daecbe9225032b3faaaefc1e1e7365ae485177ab", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -413,7 +413,7 @@ pub fn update_dollar_crate_names(mut get_name: impl FnMut(SyntaxContext) -> Symb\n     let names: Vec<_> =\n         range_to_update.clone().map(|idx| get_name(SyntaxContext::from_u32(idx as u32))).collect();\n     HygieneData::with(|data| {\n-        range_to_update.zip(names.into_iter()).for_each(|(idx, name)| {\n+        range_to_update.zip(names).for_each(|(idx, name)| {\n             data.syntax_context_data[idx].dollar_crate_name = name;\n         })\n     })"}, {"sha": "4097e1577e1127372621742ecc43231cea25bef4", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -15,6 +15,7 @@\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n #![feature(in_band_lifetimes)]\n+#![feature(iter_zip)]\n #![feature(never_type)]\n #![feature(crate_visibility_modifier)]\n #![cfg_attr(bootstrap, feature(or_patterns))]"}, {"sha": "b38e3fbaab407b699265757489de1ab8ffac78b8", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -12,6 +12,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n \n use std::collections::hash_map::Entry;\n use std::collections::VecDeque;\n+use std::iter;\n \n // FIXME(twk): this is obviously not nice to duplicate like that\n #[derive(Eq, PartialEq, Hash, Copy, Clone, Debug)]\n@@ -428,7 +429,9 @@ impl AutoTraitFinder<'tcx> {\n                         return true;\n                     }\n \n-                    for (new_region, old_region) in new_substs.regions().zip(old_substs.regions()) {\n+                    for (new_region, old_region) in\n+                        iter::zip(new_substs.regions(), old_substs.regions())\n+                    {\n                         match (new_region, old_region) {\n                             // If both predicates have an `ReLateBound` (a HRTB) in the\n                             // same spot, we do nothing."}, {"sha": "38cb4ee66cac515a4949b14c392c2aab0863ff93", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -74,23 +74,22 @@ where\n     let impl2_ref = tcx.impl_trait_ref(impl2_def_id);\n \n     // Check if any of the input types definitely do not unify.\n-    if impl1_ref\n-        .iter()\n-        .flat_map(|tref| tref.substs.types())\n-        .zip(impl2_ref.iter().flat_map(|tref| tref.substs.types()))\n-        .any(|(ty1, ty2)| {\n-            let t1 = fast_reject::simplify_type(tcx, ty1, false);\n-            let t2 = fast_reject::simplify_type(tcx, ty2, false);\n-            if let (Some(t1), Some(t2)) = (t1, t2) {\n-                // Simplified successfully\n-                // Types cannot unify if they differ in their reference mutability or simplify to different types\n-                t1 != t2 || ty1.ref_mutability() != ty2.ref_mutability()\n-            } else {\n-                // Types might unify\n-                false\n-            }\n-        })\n-    {\n+    if iter::zip(\n+        impl1_ref.iter().flat_map(|tref| tref.substs.types()),\n+        impl2_ref.iter().flat_map(|tref| tref.substs.types()),\n+    )\n+    .any(|(ty1, ty2)| {\n+        let t1 = fast_reject::simplify_type(tcx, ty1, false);\n+        let t2 = fast_reject::simplify_type(tcx, ty2, false);\n+        if let (Some(t1), Some(t2)) = (t1, t2) {\n+            // Simplified successfully\n+            // Types cannot unify if they differ in their reference mutability or simplify to different types\n+            t1 != t2 || ty1.ref_mutability() != ty2.ref_mutability()\n+        } else {\n+            // Types might unify\n+            false\n+        }\n+    }) {\n         // Some types involved are definitely different, so the impls couldn't possibly overlap.\n         debug!(\"overlapping_impls: fast_reject early-exit\");\n         return no_overlap();"}, {"sha": "8961cdaebf345eb26f497802ba12e40a8905079d", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -23,6 +23,7 @@ use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::Span;\n \n use std::cmp;\n+use std::iter;\n use std::ops::ControlFlow;\n \n /// Check if a given constant can be evaluated.\n@@ -672,9 +673,7 @@ pub(super) fn try_unify<'tcx>(\n             if a_args.len() == b_args.len() =>\n         {\n             try_unify(tcx, a.subtree(a_f), b.subtree(b_f))\n-                && a_args\n-                    .iter()\n-                    .zip(b_args)\n+                && iter::zip(a_args, b_args)\n                     .all(|(&an, &bn)| try_unify(tcx, a.subtree(an), b.subtree(bn)))\n         }\n         _ => false,"}, {"sha": "93a37bd40902de7b52b6347ff901ee96a272db9f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -28,6 +28,7 @@ use rustc_session::DiagnosticMessageId;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{ExpnKind, MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n+use std::iter;\n \n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use crate::traits::query::normalize::AtExt as _;\n@@ -161,7 +162,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         }\n \n-        for (error, suppressed) in errors.iter().zip(is_suppressed) {\n+        for (error, suppressed) in iter::zip(errors, is_suppressed) {\n             if !suppressed {\n                 self.report_fulfillment_error(error, body_id, fallback_has_occurred);\n             }"}, {"sha": "1ea34e5814e7c737344bd8cb21f7f23e8b0c019a", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 57, "deletions": 53, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -7,6 +7,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, GenericParamDefKind};\n use rustc_span::symbol::sym;\n+use std::iter;\n \n use super::InferCtxtPrivExt;\n \n@@ -51,12 +52,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             if let Ok(..) = self.can_eq(param_env, trait_self_ty, impl_self_ty) {\n                 self_match_impls.push(def_id);\n \n-                if trait_ref\n-                    .substs\n-                    .types()\n-                    .skip(1)\n-                    .zip(impl_trait_ref.substs.types().skip(1))\n-                    .all(|(u, v)| self.fuzzy_match_tys(u, v))\n+                if iter::zip(\n+                    trait_ref.substs.types().skip(1),\n+                    impl_trait_ref.substs.types().skip(1),\n+                )\n+                .all(|(u, v)| self.fuzzy_match_tys(u, v))\n                 {\n                     fuzzy_match_impls.push(def_id);\n                 }\n@@ -163,61 +163,65 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             flags.push((sym::from_desugaring, None));\n             flags.push((sym::from_desugaring, Some(format!(\"{:?}\", k))));\n         }\n-        let generics = self.tcx.generics_of(def_id);\n-        let self_ty = trait_ref.self_ty();\n-        // This is also included through the generics list as `Self`,\n-        // but the parser won't allow you to use it\n-        flags.push((sym::_Self, Some(self_ty.to_string())));\n-        if let Some(def) = self_ty.ty_adt_def() {\n-            // We also want to be able to select self's original\n-            // signature with no type arguments resolved\n-            flags.push((sym::_Self, Some(self.tcx.type_of(def.did).to_string())));\n-        }\n \n-        for param in generics.params.iter() {\n-            let value = match param.kind {\n-                GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n-                    trait_ref.substs[param.index as usize].to_string()\n-                }\n-                GenericParamDefKind::Lifetime => continue,\n-            };\n-            let name = param.name;\n-            flags.push((name, Some(value)));\n-        }\n+        // Add all types without trimmed paths.\n+        ty::print::with_no_trimmed_paths(|| {\n+            let generics = self.tcx.generics_of(def_id);\n+            let self_ty = trait_ref.self_ty();\n+            // This is also included through the generics list as `Self`,\n+            // but the parser won't allow you to use it\n+            flags.push((sym::_Self, Some(self_ty.to_string())));\n+            if let Some(def) = self_ty.ty_adt_def() {\n+                // We also want to be able to select self's original\n+                // signature with no type arguments resolved\n+                flags.push((sym::_Self, Some(self.tcx.type_of(def.did).to_string())));\n+            }\n \n-        if let Some(true) = self_ty.ty_adt_def().map(|def| def.did.is_local()) {\n-            flags.push((sym::crate_local, None));\n-        }\n+            for param in generics.params.iter() {\n+                let value = match param.kind {\n+                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n+                        trait_ref.substs[param.index as usize].to_string()\n+                    }\n+                    GenericParamDefKind::Lifetime => continue,\n+                };\n+                let name = param.name;\n+                flags.push((name, Some(value)));\n+            }\n \n-        // Allow targeting all integers using `{integral}`, even if the exact type was resolved\n-        if self_ty.is_integral() {\n-            flags.push((sym::_Self, Some(\"{integral}\".to_owned())));\n-        }\n+            if let Some(true) = self_ty.ty_adt_def().map(|def| def.did.is_local()) {\n+                flags.push((sym::crate_local, None));\n+            }\n \n-        if let ty::Array(aty, len) = self_ty.kind() {\n-            flags.push((sym::_Self, Some(\"[]\".to_owned())));\n-            flags.push((sym::_Self, Some(format!(\"[{}]\", aty))));\n-            if let Some(def) = aty.ty_adt_def() {\n-                // We also want to be able to select the array's type's original\n-                // signature with no type arguments resolved\n-                let type_string = self.tcx.type_of(def.did).to_string();\n-                flags.push((sym::_Self, Some(format!(\"[{}]\", type_string))));\n+            // Allow targeting all integers using `{integral}`, even if the exact type was resolved\n+            if self_ty.is_integral() {\n+                flags.push((sym::_Self, Some(\"{integral}\".to_owned())));\n+            }\n \n-                let len = len.val.try_to_value().and_then(|v| v.try_to_machine_usize(self.tcx));\n-                let string = match len {\n-                    Some(n) => format!(\"[{}; {}]\", type_string, n),\n-                    None => format!(\"[{}; _]\", type_string),\n-                };\n-                flags.push((sym::_Self, Some(string)));\n+            if let ty::Array(aty, len) = self_ty.kind() {\n+                flags.push((sym::_Self, Some(\"[]\".to_owned())));\n+                flags.push((sym::_Self, Some(format!(\"[{}]\", aty))));\n+                if let Some(def) = aty.ty_adt_def() {\n+                    // We also want to be able to select the array's type's original\n+                    // signature with no type arguments resolved\n+                    let type_string = self.tcx.type_of(def.did).to_string();\n+                    flags.push((sym::_Self, Some(format!(\"[{}]\", type_string))));\n+\n+                    let len = len.val.try_to_value().and_then(|v| v.try_to_machine_usize(self.tcx));\n+                    let string = match len {\n+                        Some(n) => format!(\"[{}; {}]\", type_string, n),\n+                        None => format!(\"[{}; _]\", type_string),\n+                    };\n+                    flags.push((sym::_Self, Some(string)));\n+                }\n             }\n-        }\n-        if let ty::Dynamic(traits, _) = self_ty.kind() {\n-            for t in traits.iter() {\n-                if let ty::ExistentialPredicate::Trait(trait_ref) = t.skip_binder() {\n-                    flags.push((sym::_Self, Some(self.tcx.def_path_str(trait_ref.def_id))))\n+            if let ty::Dynamic(traits, _) = self_ty.kind() {\n+                for t in traits.iter() {\n+                    if let ty::ExistentialPredicate::Trait(trait_ref) = t.skip_binder() {\n+                        flags.push((sym::_Self, Some(self.tcx.def_path_str(trait_ref.def_id))))\n+                    }\n                 }\n             }\n-        }\n+        });\n \n         if let Ok(Some(command)) =\n             OnUnimplementedDirective::of_item(self.tcx, trait_ref.def_id, def_id)"}, {"sha": "45680c90cdc17008d5e0a9c3223f78369b8be65e", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1887,7 +1887,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // substitution if we find that any of the input types, when\n         // simplified, do not match.\n \n-        obligation.predicate.skip_binder().trait_ref.substs.iter().zip(impl_trait_ref.substs).any(\n+        iter::zip(obligation.predicate.skip_binder().trait_ref.substs, impl_trait_ref.substs).any(\n             |(obligation_arg, impl_arg)| {\n                 match (obligation_arg.unpack(), impl_arg.unpack()) {\n                     (GenericArgKind::Type(obligation_ty), GenericArgKind::Type(impl_ty)) => {"}, {"sha": "3d5f8d128dc4b85b3c8bbc267ad9710a1722526f", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -692,11 +692,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         let predicates = predicates.instantiate(self.infcx.tcx, substs);\n         debug_assert_eq!(predicates.predicates.len(), origins.len());\n \n-        predicates\n-            .predicates\n-            .into_iter()\n-            .zip(predicates.spans.into_iter())\n-            .zip(origins.into_iter().rev())\n+        iter::zip(iter::zip(predicates.predicates, predicates.spans), origins.into_iter().rev())\n             .map(|((pred, span), origin_def_id)| {\n                 let cause = self.cause(traits::BindingObligation(origin_def_id, span));\n                 traits::Obligation::with_depth(cause, self.recursion_depth, self.param_env, pred)"}, {"sha": "695132281c6bac81b364375a41c0a12c2dbbe046", "filename": "compiler/rustc_typeck/src/astconv/errors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -10,6 +10,7 @@ use rustc_span::symbol::{sym, Ident};\n use rustc_span::{Span, DUMMY_SP};\n \n use std::collections::BTreeSet;\n+use std::iter;\n \n impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// On missing type parameters, emit an E0393 error and provide a structured suggestion using\n@@ -309,7 +310,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // that the user forgot to give the associtated type's name. The canonical\n                 // example would be trying to use `Iterator<isize>` instead of\n                 // `Iterator<Item = isize>`.\n-                for (potential, item) in potential_assoc_types.iter().zip(assoc_items.iter()) {\n+                for (potential, item) in iter::zip(&potential_assoc_types, assoc_items) {\n                     if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(*potential) {\n                         suggestions.push((*potential, format!(\"{} = {}\", item.ident, snippet)));\n                     }"}, {"sha": "b48102e0fc9b8c900888abf5ebb9393120924d8d", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -17,6 +17,7 @@ use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_target::spec::abi;\n use rustc_trait_selection::autoderef::Autoderef;\n+use std::iter;\n \n /// Checks that it is legal to call methods of the trait corresponding\n /// to `trait_id` (this only cares about the trait, not the specific\n@@ -539,7 +540,7 @@ impl<'a, 'tcx> DeferredCallResolution<'tcx> {\n                 debug!(\"attempt_resolution: method_callee={:?}\", method_callee);\n \n                 for (method_arg_ty, self_arg_ty) in\n-                    method_sig.inputs().iter().skip(1).zip(self.fn_sig.inputs())\n+                    iter::zip(method_sig.inputs().iter().skip(1), self.fn_sig.inputs())\n                 {\n                     fcx.demand_eqtype(self.call_expr.span, &self_arg_ty, &method_arg_ty);\n                 }"}, {"sha": "892abb5a344659ff7107a84568e7fdffd41b6556", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -26,6 +26,7 @@ use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n+use std::iter;\n use std::ops::ControlFlow;\n \n pub fn check_wf_new(tcx: TyCtxt<'_>) {\n@@ -1472,7 +1473,7 @@ fn check_enum<'tcx>(\n     }\n \n     let mut disr_vals: Vec<Discr<'tcx>> = Vec::with_capacity(vs.len());\n-    for ((_, discr), v) in def.discriminants(tcx).zip(vs) {\n+    for ((_, discr), v) in iter::zip(def.discriminants(tcx), vs) {\n         // Check for duplicate discriminant values\n         if let Some(i) = disr_vals.iter().position(|&x| x.val == discr.val) {\n             let variant_did = def.variants[VariantIdx::new(i)].def_id;"}, {"sha": "4099ecd435d5160168bcbc49ef3cd920b387a771", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -492,13 +492,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // The liberated version of this signature should be a subtype\n             // of the liberated form of the expectation.\n-            for ((hir_ty, &supplied_ty), expected_ty) in decl\n-                .inputs\n-                .iter()\n-                .zip(supplied_sig.inputs().skip_binder()) // binder moved to (*) below\n-                .zip(expected_sigs.liberated_sig.inputs())\n-            // `liberated_sig` is E'.\n-            {\n+            for ((hir_ty, &supplied_ty), expected_ty) in iter::zip(\n+                iter::zip(\n+                    decl.inputs,\n+                    supplied_sig.inputs().skip_binder(), // binder moved to (*) below\n+                ),\n+                expected_sigs.liberated_sig.inputs(), // `liberated_sig` is E'.\n+            ) {\n                 // Instantiate (this part of..) S to S', i.e., with fresh variables.\n                 let (supplied_ty, _) = self.infcx.replace_bound_vars_with_fresh_vars(\n                     hir_ty.span,"}, {"sha": "70f850084a89ffbf1176c5a409e70c6abf6c68f9", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -14,6 +14,7 @@ use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt};\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n+use std::iter;\n \n use super::{potentially_plural_count, FnCtxt, Inherited};\n \n@@ -410,8 +411,7 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n                     _ => bug!(\"{:?} is not a TraitItemKind::Fn\", trait_m),\n                 };\n \n-                impl_m_iter\n-                    .zip(trait_m_iter)\n+                iter::zip(impl_m_iter, trait_m_iter)\n                     .find(|&(ref impl_arg, ref trait_arg)| {\n                         match (&impl_arg.kind, &trait_arg.kind) {\n                             (\n@@ -443,11 +443,8 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n \n                 let impl_iter = impl_sig.inputs().iter();\n                 let trait_iter = trait_sig.inputs().iter();\n-                impl_iter\n-                    .zip(trait_iter)\n-                    .zip(impl_m_iter)\n-                    .zip(trait_m_iter)\n-                    .find_map(|(((&impl_arg_ty, &trait_arg_ty), impl_arg), trait_arg)| match infcx\n+                iter::zip(iter::zip(impl_iter, trait_iter), iter::zip(impl_m_iter, trait_m_iter))\n+                    .find_map(|((&impl_arg_ty, &trait_arg_ty), (impl_arg, trait_arg))| match infcx\n                         .at(&cause, param_env)\n                         .sub(trait_arg_ty, impl_arg_ty)\n                     {\n@@ -799,7 +796,7 @@ fn compare_synthetic_generics<'tcx>(\n         GenericParamDefKind::Lifetime | GenericParamDefKind::Const { .. } => None,\n     });\n     for ((impl_def_id, impl_synthetic), (trait_def_id, trait_synthetic)) in\n-        impl_m_type_params.zip(trait_m_type_params)\n+        iter::zip(impl_m_type_params, trait_m_type_params)\n     {\n         if impl_synthetic != trait_synthetic {\n             let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_def_id.expect_local());"}, {"sha": "e64d8367676b0e90ae94d1fb4985d684795aaef0", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -42,6 +42,7 @@ use rustc_trait_selection::traits::{\n };\n \n use std::collections::hash_map::Entry;\n+use std::iter;\n use std::slice;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -1146,7 +1147,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (\n                         hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: last_bounds, .. }),\n                         hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: exp_bounds, .. }),\n-                    ) if last_bounds.iter().zip(exp_bounds.iter()).all(|(left, right)| {\n+                    ) if iter::zip(*last_bounds, *exp_bounds).all(|(left, right)| {\n                         match (left, right) {\n                             (\n                                 hir::GenericBound::Trait(tl, ml),"}, {"sha": "80b5a9d4e621a60a1d67c1f4ed8ff9a190dc7abd", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -23,6 +23,7 @@ use rustc_span::{self, MultiSpan, Span};\n use rustc_trait_selection::traits::{self, ObligationCauseCode, StatementAsExpression};\n \n use crate::structured_errors::StructuredDiagnostic;\n+use std::iter;\n use std::slice;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -108,7 +109,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // All the input types from the fn signature must outlive the call\n         // so as to validate implied bounds.\n-        for (&fn_input_ty, arg_expr) in fn_inputs.iter().zip(args.iter()) {\n+        for (&fn_input_ty, arg_expr) in iter::zip(fn_inputs, args) {\n             self.register_wf_obligation(fn_input_ty.into(), arg_expr.span, traits::MiscObligation);\n         }\n "}, {"sha": "bd89c7274e77bed93cb6ee0b8bfe282bd95d5d93", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -218,8 +218,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.is_hir_id_from_struct_pattern_shorthand_field(expr.hir_id, expr.span);\n             let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n             if let Ok(expr_text) = self.sess().source_map().span_to_snippet(expr.span) {\n-                let mut suggestions = iter::repeat(&expr_text)\n-                    .zip(methods.iter())\n+                let mut suggestions = iter::zip(iter::repeat(&expr_text), &methods)\n                     .filter_map(|(receiver, method)| {\n                         let method_call = format!(\".{}()\", method.ident);\n                         if receiver.ends_with(&method_call) {"}, {"sha": "fff659a91adfc861cb83ef90ee98e4216f364522", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -15,6 +15,7 @@ use rustc_middle::ty::{self, GenericParamDefKind, Ty};\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n \n+use std::iter;\n use std::ops::Deref;\n \n struct ConfirmContext<'a, 'tcx> {\n@@ -496,10 +497,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             // We don't care about regions here.\n             .filter_map(|obligation| match obligation.predicate.kind().skip_binder() {\n                 ty::PredicateKind::Trait(trait_pred, _) if trait_pred.def_id() == sized_def_id => {\n-                    let span = predicates\n-                        .predicates\n-                        .iter()\n-                        .zip(predicates.spans.iter())\n+                    let span = iter::zip(&predicates.predicates, &predicates.spans)\n                         .find_map(\n                             |(p, span)| {\n                                 if *p == obligation.predicate { Some(*span) } else { None }"}, {"sha": "91021b3f6f5899b5cc9201c086687add87511396", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -49,6 +49,8 @@ use rustc_span::{MultiSpan, Span, Symbol};\n use rustc_index::vec::Idx;\n use rustc_target::abi::VariantIdx;\n \n+use std::iter;\n+\n /// Describe the relationship between the paths of two places\n /// eg:\n /// - `foo` is ancestor of `foo.bar.baz`\n@@ -1631,7 +1633,7 @@ fn determine_place_ancestry_relation(\n     let projections_b = &place_b.projections;\n \n     let same_initial_projections =\n-        projections_a.iter().zip(projections_b.iter()).all(|(proj_a, proj_b)| proj_a == proj_b);\n+        iter::zip(projections_a, projections_b).all(|(proj_a, proj_b)| proj_a == proj_b);\n \n     if same_initial_projections {\n         // First min(n, m) projections are the same"}, {"sha": "e7e603c8bd510a00245f8aadce028ca6a6f959bc", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -24,6 +24,7 @@ use rustc_trait_selection::opaque_types::may_define_opaque_type;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n+use std::iter;\n use std::ops::ControlFlow;\n \n /// Helper type of a temporary returned by `.for_item(...)`.\n@@ -863,7 +864,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n     debug!(\"check_where_clauses: predicates={:?}\", predicates.predicates);\n     assert_eq!(predicates.predicates.len(), predicates.spans.len());\n     let wf_obligations =\n-        predicates.predicates.iter().zip(predicates.spans.iter()).flat_map(|(&p, &sp)| {\n+        iter::zip(&predicates.predicates, &predicates.spans).flat_map(|(&p, &sp)| {\n             traits::wf::predicate_obligations(fcx, fcx.param_env, fcx.body_id, p, sp)\n         });\n \n@@ -885,8 +886,8 @@ fn check_fn_or_method<'fcx, 'tcx>(\n     let sig = fcx.normalize_associated_types_in(span, sig);\n     let sig = fcx.tcx.liberate_late_bound_regions(def_id, sig);\n \n-    for (&input_ty, span) in sig.inputs().iter().zip(hir_decl.inputs.iter().map(|t| t.span)) {\n-        fcx.register_wf_obligation(input_ty.into(), span, ObligationCauseCode::MiscObligation);\n+    for (&input_ty, ty) in iter::zip(sig.inputs(), hir_decl.inputs) {\n+        fcx.register_wf_obligation(input_ty.into(), ty.span, ObligationCauseCode::MiscObligation);\n     }\n     implied_bounds.extend(sig.inputs());\n "}, {"sha": "9b3a933beb13eefcded293b2c0f1365d56987dee", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -50,6 +50,7 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits::error_reporting::suggestions::NextTypeParamName;\n+use std::iter;\n \n mod item_bounds;\n mod type_of;\n@@ -2439,7 +2440,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n                     .emit();\n             }\n         };\n-        for (input, ty) in decl.inputs.iter().zip(fty.inputs().skip_binder()) {\n+        for (input, ty) in iter::zip(decl.inputs, fty.inputs().skip_binder()) {\n             check(&input, ty)\n         }\n         if let hir::FnRetTy::Return(ref ty) = decl.output {"}, {"sha": "ab286bacd81893342ac266ffb765cb8b407fcead", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -18,6 +18,7 @@ use rustc_middle::hir::place::ProjectionKind;\n use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::{self, adjustment, TyCtxt};\n use rustc_target::abi::VariantIdx;\n+use std::iter;\n \n use crate::mem_categorization as mc;\n \n@@ -333,7 +334,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             }\n \n             hir::ExprKind::LlvmInlineAsm(ref ia) => {\n-                for (o, output) in ia.inner.outputs.iter().zip(ia.outputs_exprs) {\n+                for (o, output) in iter::zip(&ia.inner.outputs, ia.outputs_exprs) {\n                     if o.is_indirect {\n                         self.consume_expr(output);\n                     } else {"}, {"sha": "cb442344fa21c99e4fcbbb44ea83603a2e611d86", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -63,6 +63,7 @@ This API is completely unstable and subject to change.\n #![feature(format_args_capture)]\n #![feature(in_band_lifetimes)]\n #![feature(is_sorted)]\n+#![feature(iter_zip)]\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(try_blocks)]"}, {"sha": "fb243100990b97f7d5b61f313b829dad66813e22", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -108,6 +108,7 @@\n // that the feature-gate isn't enabled. Ideally, it wouldn't check for the feature gate for docs\n // from other crates, but since this can only appear for lang items, it doesn't seem worth fixing.\n #![feature(intra_doc_pointers)]\n+#![feature(iter_zip)]\n #![feature(lang_items)]\n #![feature(layout_for_ptr)]\n #![feature(maybe_uninit_ref)]"}, {"sha": "708898ad2e7809ee2cb948b7c2fb3ca06962559a", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -58,7 +58,7 @@ use core::convert::TryFrom;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::{arith_offset, assume};\n-use core::iter::FromIterator;\n+use core::iter::{self, FromIterator};\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop, MaybeUninit};\n use core::ops::{self, Index, IndexMut, Range, RangeBounds};\n@@ -2268,11 +2268,8 @@ impl<T: Clone, A: Allocator> ExtendFromWithinSpec for Vec<T, A> {\n         // - caller guaratees that src is a valid index\n         let to_clone = unsafe { this.get_unchecked(src) };\n \n-        to_clone\n-            .iter()\n-            .cloned()\n-            .zip(spare.iter_mut())\n-            .map(|(src, dst)| dst.write(src))\n+        iter::zip(to_clone, spare)\n+            .map(|(src, dst)| dst.write(src.clone()))\n             // Note:\n             // - Element was just initialized with `MaybeUninit::write`, so it's ok to increace len\n             // - len is increased after each element to prevent leaks (see issue #82533)"}, {"sha": "c36542f6314887946e1ebf0f3eadfd7298a08795", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -2,7 +2,7 @@\n \n use crate::{\n     fmt,\n-    iter::{ExactSizeIterator, FusedIterator, TrustedLen, TrustedRandomAccess},\n+    iter::{self, ExactSizeIterator, FusedIterator, TrustedLen, TrustedRandomAccess},\n     mem::{self, MaybeUninit},\n     ops::Range,\n     ptr,\n@@ -215,7 +215,7 @@ impl<T: Clone, const N: usize> Clone for IntoIter<T, N> {\n         let mut new = Self { data: MaybeUninit::uninit_array(), alive: 0..0 };\n \n         // Clone all alive elements.\n-        for (src, dst) in self.as_slice().iter().zip(&mut new.data) {\n+        for (src, dst) in iter::zip(self.as_slice(), &mut new.data) {\n             // Write a clone into the new array, then update its alive range.\n             // If cloning panics, we'll correctly drop the previous items.\n             dst.write(src.clone());"}, {"sha": "d696ffa82774b89a93ad6bacae7cd5200d33844e", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -4,6 +4,7 @@\n \n use crate::cell::{Cell, Ref, RefCell, RefMut, UnsafeCell};\n use crate::char::EscapeDebugExtArgs;\n+use crate::iter;\n use crate::marker::PhantomData;\n use crate::mem;\n use crate::num::flt2dec;\n@@ -1088,7 +1089,7 @@ pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n     match args.fmt {\n         None => {\n             // We can use default formatting parameters for all arguments.\n-            for (arg, piece) in args.args.iter().zip(args.pieces.iter()) {\n+            for (arg, piece) in iter::zip(args.args, args.pieces) {\n                 formatter.buf.write_str(*piece)?;\n                 (arg.formatter)(arg.value, &mut formatter)?;\n                 idx += 1;\n@@ -1097,7 +1098,7 @@ pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n         Some(fmt) => {\n             // Every spec has a corresponding argument that is preceded by\n             // a string piece.\n-            for (arg, piece) in fmt.iter().zip(args.pieces.iter()) {\n+            for (arg, piece) in iter::zip(fmt, args.pieces) {\n                 formatter.buf.write_str(*piece)?;\n                 // SAFETY: arg and args.args come from the same Arguments,\n                 // which guarantees the indexes are always within bounds."}, {"sha": "ba4050757cb9462233ad04d45e6bcd2882403815", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -51,6 +51,9 @@ pub use self::map_while::MapWhile;\n #[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n pub use self::zip::TrustedRandomAccess;\n \n+#[unstable(feature = \"iter_zip\", issue = \"83574\")]\n+pub use self::zip::zip;\n+\n /// This trait provides transitive access to source-stage in an interator-adapter pipeline\n /// under the conditions that\n /// * the iterator source `S` itself implements `SourceIter<Source = S>`"}, {"sha": "2f8f504d8fcaa1c3b630efad35eac7e43266ee5b", "filename": "library/core/src/iter/adapters/zip.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -5,8 +5,8 @@ use crate::iter::{InPlaceIterable, SourceIter, TrustedLen};\n \n /// An iterator that iterates two other iterators simultaneously.\n ///\n-/// This `struct` is created by [`Iterator::zip`]. See its documentation\n-/// for more.\n+/// This `struct` is created by [`zip`] or [`Iterator::zip`].\n+/// See their documentation for more.\n #[derive(Clone)]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -33,6 +33,37 @@ impl<A: Iterator, B: Iterator> Zip<A, B> {\n     }\n }\n \n+/// Converts the arguments to iterators and zips them.\n+///\n+/// See the documentation of [`Iterator::zip`] for more.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(iter_zip)]\n+/// use std::iter::zip;\n+///\n+/// let xs = [1, 2, 3];\n+/// let ys = [4, 5, 6];\n+/// for (x, y) in zip(&xs, &ys) {\n+///     println!(\"x:{}, y:{}\", x, y);\n+/// }\n+///\n+/// // Nested zips are also possible:\n+/// let zs = [7, 8, 9];\n+/// for ((x, y), z) in zip(zip(&xs, &ys), &zs) {\n+///     println!(\"x:{}, y:{}, z:{}\", x, y, z);\n+/// }\n+/// ```\n+#[unstable(feature = \"iter_zip\", issue = \"83574\")]\n+pub fn zip<A, B>(a: A, b: B) -> Zip<A::IntoIter, B::IntoIter>\n+where\n+    A: IntoIterator,\n+    B: IntoIterator,\n+{\n+    ZipImpl::new(a.into_iter(), b.into_iter())\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> Iterator for Zip<A, B>\n where"}, {"sha": "2a179f0b1d77b16c53f6116f3949d4c6ec42e19b", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -389,6 +389,8 @@ pub use self::traits::{\n     DoubleEndedIterator, ExactSizeIterator, Extend, FromIterator, IntoIterator, Product, Sum,\n };\n \n+#[unstable(feature = \"iter_zip\", issue = \"83574\")]\n+pub use self::adapters::zip;\n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n pub use self::adapters::Cloned;\n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]"}, {"sha": "e75a36477188c9bf776e7dfbc6cd6a0641f031f5", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -81,8 +81,8 @@ fn _assert_is_object_safe(_: &dyn Iterator<Item = ()>) {}\n     ),\n     on(\n         _Self = \"[]\",\n-        label = \"borrow the array with `&` or call `.iter()` on it to iterate over it\",\n-        note = \"arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\"\n+        label = \"arrays do not yet implement `IntoIterator`; try using `std::array::IntoIter::new(arr)`\",\n+        note = \"see <https://github.com/rust-lang/rust/pull/65819> for more details\"\n     ),\n     on(\n         _Self = \"{integral}\","}, {"sha": "197b85fba1fd72b02e49d63a0baf51d187b96863", "filename": "library/core/src/num/bignum.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fcore%2Fsrc%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fcore%2Fsrc%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fbignum.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -181,11 +181,12 @@ macro_rules! define_bignum {\n             /// Adds `other` to itself and returns its own mutable reference.\n             pub fn add<'a>(&'a mut self, other: &$name) -> &'a mut $name {\n                 use crate::cmp;\n+                use crate::iter;\n                 use crate::num::bignum::FullOps;\n \n                 let mut sz = cmp::max(self.size, other.size);\n                 let mut carry = false;\n-                for (a, b) in self.base[..sz].iter_mut().zip(&other.base[..sz]) {\n+                for (a, b) in iter::zip(&mut self.base[..sz], &other.base[..sz]) {\n                     let (c, v) = (*a).full_add(*b, carry);\n                     *a = v;\n                     carry = c;\n@@ -219,11 +220,12 @@ macro_rules! define_bignum {\n             /// Subtracts `other` from itself and returns its own mutable reference.\n             pub fn sub<'a>(&'a mut self, other: &$name) -> &'a mut $name {\n                 use crate::cmp;\n+                use crate::iter;\n                 use crate::num::bignum::FullOps;\n \n                 let sz = cmp::max(self.size, other.size);\n                 let mut noborrow = true;\n-                for (a, b) in self.base[..sz].iter_mut().zip(&other.base[..sz]) {\n+                for (a, b) in iter::zip(&mut self.base[..sz], &other.base[..sz]) {\n                     let (c, v) = (*a).full_add(!*b, noborrow);\n                     *a = v;\n                     noborrow = c;"}, {"sha": "2392f0174b6f0e175681b2515b7f30666ea156cc", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -767,6 +767,7 @@ pub const unsafe fn read<T>(src: *const T) -> T {\n ///     unaligned: 0x01020304,\n /// };\n ///\n+/// #[allow(unaligned_references)]\n /// let v = unsafe {\n ///     // Here we attempt to take the address of a 32-bit integer which is not aligned.\n ///     let unaligned =\n@@ -960,6 +961,7 @@ pub const unsafe fn write<T>(dst: *mut T, src: T) {\n /// let v = 0x01020304;\n /// let mut packed: Packed = unsafe { std::mem::zeroed() };\n ///\n+/// #[allow(unaligned_references)]\n /// let v = unsafe {\n ///     // Here we attempt to take the address of a 32-bit integer which is not aligned.\n ///     let unaligned ="}, {"sha": "009ef9e0a9c1f253f4fb34c9e5206daec2e4c01c", "filename": "library/core/src/slice/ascii.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,5 +1,6 @@\n //! Operations on ASCII `[u8]`.\n \n+use crate::iter;\n use crate::mem;\n \n #[lang = \"slice_u8\"]\n@@ -19,7 +20,7 @@ impl [u8] {\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool {\n-        self.len() == other.len() && self.iter().zip(other).all(|(a, b)| a.eq_ignore_ascii_case(b))\n+        self.len() == other.len() && iter::zip(self, other).all(|(a, b)| a.eq_ignore_ascii_case(b))\n     }\n \n     /// Converts this slice to its ASCII upper case equivalent in-place."}, {"sha": "97c92aa35069642012d2bcd2350985d4ad0cf553", "filename": "library/std/src/io/error.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -269,6 +269,7 @@ impl Error {\n     /// This function should maybe change to\n     /// `new_const<const MSG: &'static str>(kind: ErrorKind)`\n     /// in the future, when const generics allow that.\n+    #[inline]\n     pub(crate) const fn new_const(kind: ErrorKind, message: &'static &'static str) -> Error {\n         Self { repr: Repr::SimpleMessage(kind, message) }\n     }\n@@ -287,6 +288,7 @@ impl Error {\n     /// println!(\"last OS error: {:?}\", Error::last_os_error());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn last_os_error() -> Error {\n         Error::from_raw_os_error(sys::os::errno() as i32)\n     }\n@@ -317,6 +319,7 @@ impl Error {\n     /// # }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn from_raw_os_error(code: i32) -> Error {\n         Error { repr: Repr::Os(code) }\n     }\n@@ -351,6 +354,7 @@ impl Error {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn raw_os_error(&self) -> Option<i32> {\n         match self.repr {\n             Repr::Os(i) => Some(i),\n@@ -388,6 +392,7 @@ impl Error {\n     /// }\n     /// ```\n     #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n+    #[inline]\n     pub fn get_ref(&self) -> Option<&(dyn error::Error + Send + Sync + 'static)> {\n         match self.repr {\n             Repr::Os(..) => None,\n@@ -460,6 +465,7 @@ impl Error {\n     /// }\n     /// ```\n     #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n+    #[inline]\n     pub fn get_mut(&mut self) -> Option<&mut (dyn error::Error + Send + Sync + 'static)> {\n         match self.repr {\n             Repr::Os(..) => None,\n@@ -497,6 +503,7 @@ impl Error {\n     /// }\n     /// ```\n     #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n+    #[inline]\n     pub fn into_inner(self) -> Option<Box<dyn error::Error + Send + Sync>> {\n         match self.repr {\n             Repr::Os(..) => None,\n@@ -525,6 +532,7 @@ impl Error {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn kind(&self) -> ErrorKind {\n         match self.repr {\n             Repr::Os(code) => sys::decode_error_kind(code),"}, {"sha": "3719eeb1840beee553a05a2d8b584b1165395e32", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -278,6 +278,7 @@\n #![feature(integer_atomics)]\n #![feature(into_future)]\n #![feature(intra_doc_pointers)]\n+#![feature(iter_zip)]\n #![feature(lang_items)]\n #![feature(link_args)]\n #![feature(linkage)]"}, {"sha": "459f3590e647015f6edc2c1fe6f91f07a9407861", "filename": "library/std/src/sys/unix/ext/net/addr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Faddr.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -2,7 +2,7 @@ use crate::ffi::OsStr;\n use crate::os::unix::ffi::OsStrExt;\n use crate::path::Path;\n use crate::sys::cvt;\n-use crate::{ascii, fmt, io, mem};\n+use crate::{ascii, fmt, io, iter, mem};\n \n // FIXME(#43348): Make libc adapt #[doc(cfg(...))] so we don't need these fake definitions here?\n #[cfg(not(unix))]\n@@ -41,7 +41,7 @@ pub(super) unsafe fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un,\n             &\"path must be shorter than SUN_LEN\",\n         ));\n     }\n-    for (dst, src) in addr.sun_path.iter_mut().zip(bytes.iter()) {\n+    for (dst, src) in iter::zip(&mut addr.sun_path, bytes) {\n         *dst = *src as libc::c_char;\n     }\n     // null byte for pathname addresses is already there because we zeroed the"}, {"sha": "759565bab73f38a1b6964760735f45d2cc05e8da", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -2,7 +2,7 @@ use crate::os::unix::prelude::*;\n \n use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n-use crate::io::{self, Error, ErrorKind, IoSlice, IoSliceMut, SeekFrom};\n+use crate::io::{self, Error, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n use crate::path::{Path, PathBuf};\n use crate::ptr;\n@@ -1152,14 +1152,12 @@ pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n \n fn open_from(from: &Path) -> io::Result<(crate::fs::File, crate::fs::Metadata)> {\n     use crate::fs::File;\n+    use crate::sys_common::fs::NOT_FILE_ERROR;\n \n     let reader = File::open(from)?;\n     let metadata = reader.metadata()?;\n     if !metadata.is_file() {\n-        return Err(Error::new_const(\n-            ErrorKind::InvalidInput,\n-            &\"the source path is not an existing regular file\",\n-        ));\n+        return Err(NOT_FILE_ERROR);\n     }\n     Ok((reader, metadata))\n }"}, {"sha": "30908824dd663002b0718a5c75d790bfb255426d", "filename": "library/std/src/sys_common/fs.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fstd%2Fsrc%2Fsys_common%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/library%2Fstd%2Fsrc%2Fsys_common%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Ffs.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -4,15 +4,17 @@ use crate::fs;\n use crate::io::{self, Error, ErrorKind};\n use crate::path::Path;\n \n+pub(crate) const NOT_FILE_ERROR: Error = Error::new_const(\n+    ErrorKind::InvalidInput,\n+    &\"the source path is neither a regular file nor a symlink to a regular file\",\n+);\n+\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     let mut reader = fs::File::open(from)?;\n     let metadata = reader.metadata()?;\n \n     if !metadata.is_file() {\n-        return Err(Error::new_const(\n-            ErrorKind::InvalidInput,\n-            &\"the source path is not an existing regular file\",\n-        ));\n+        return Err(NOT_FILE_ERROR);\n     }\n \n     let mut writer = fs::File::create(to)?;"}, {"sha": "001c8b090448bed2bb20ce825f4295a5a5c9155c", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -54,12 +54,10 @@ impl DocFolder for SourceCollector<'_, '_> {\n             self.scx.include_sources = match self.emit_source(&filename) {\n                 Ok(()) => true,\n                 Err(e) => {\n-                    println!(\n-                        \"warning: source code was requested to be rendered, \\\n-                         but processing `{}` had an error: {}\",\n-                        filename, e\n+                    self.scx.tcx.sess.span_err(\n+                        item.span.inner(),\n+                        &format!(\"failed to render source code for `{}`: {}\", filename, e),\n                     );\n-                    println!(\"         skipping rendering of source code\");\n                     false\n                 }\n             };"}, {"sha": "ca4f0efd2392b3c20517eb9f3fb739aa4e092a5d", "filename": "src/test/ui/binding/issue-53114-safety-checks.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -20,13 +20,13 @@ fn let_wild_gets_unsafe_field() {\n     let u1 = U { a: I(0) };\n     let u2 = U { a: I(1) };\n     let p = P { a: &2, b: &3 };\n-    let _ = &p.b;  //~ WARN    E0133\n+    let _ = &p.b;  //~ WARN    reference to packed field\n     //~^  WARN will become a hard error\n     let _ = u1.a;  // #53114: should eventually signal error as well\n     let _ = &u2.a; //~ ERROR  [E0133]\n \n     // variation on above with `_` in substructure\n-    let (_,) = (&p.b,);  //~ WARN     E0133\n+    let (_,) = (&p.b,);  //~ WARN     reference to packed field\n     //~^  WARN will become a hard error\n     let (_,) = (u1.a,);  //~ ERROR   [E0133]\n     let (_,) = (&u2.a,); //~ ERROR   [E0133]\n@@ -36,13 +36,13 @@ fn match_unsafe_field_to_wild() {\n     let u1 = U { a: I(0) };\n     let u2 = U { a: I(1) };\n     let p = P { a: &2, b: &3 };\n-    match &p.b  { _ => { } } //~ WARN     E0133\n+    match &p.b  { _ => { } } //~ WARN     reference to packed field\n     //~^  WARN will become a hard error\n     match u1.a  { _ => { } } //~ ERROR   [E0133]\n     match &u2.a { _ => { } } //~ ERROR   [E0133]\n \n     // variation on above with `_` in substructure\n-    match (&p.b,)  { (_,) => { } } //~ WARN     E0133\n+    match (&p.b,)  { (_,) => { } } //~ WARN     reference to packed field\n     //~^  WARN will become a hard error\n     match (u1.a,)  { (_,) => { } } //~ ERROR   [E0133]\n     match (&u2.a,) { (_,) => { } } //~ ERROR   [E0133]"}, {"sha": "9e7deea4524cbeadb6d9fc51b7e999fbd80df301", "filename": "src/test/ui/binding/issue-53114-safety-checks.stderr", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,13 +1,43 @@\n-warning: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n+warning: reference to packed field is unaligned\n   --> $DIR/issue-53114-safety-checks.rs:23:13\n    |\n LL |     let _ = &p.b;\n    |             ^^^^\n    |\n-   = note: `#[warn(safe_packed_borrows)]` on by default\n+   = note: `#[warn(unaligned_references)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+\n+warning: reference to packed field is unaligned\n+  --> $DIR/issue-53114-safety-checks.rs:29:17\n+   |\n+LL |     let (_,) = (&p.b,);\n+   |                 ^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+\n+warning: reference to packed field is unaligned\n+  --> $DIR/issue-53114-safety-checks.rs:39:11\n+   |\n+LL |     match &p.b  { _ => { } }\n+   |           ^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+\n+warning: reference to packed field is unaligned\n+  --> $DIR/issue-53114-safety-checks.rs:45:12\n+   |\n+LL |     match (&p.b,)  { (_,) => { } }\n+   |            ^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n   --> $DIR/issue-53114-safety-checks.rs:26:13\n@@ -17,16 +47,6 @@ LL |     let _ = &u2.a;\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n-warning: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n-  --> $DIR/issue-53114-safety-checks.rs:29:17\n-   |\n-LL |     let (_,) = (&p.b,);\n-   |                 ^^^^\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n-\n error[E0133]: access to union field is unsafe and requires unsafe function or block\n   --> $DIR/issue-53114-safety-checks.rs:31:17\n    |\n@@ -43,16 +63,6 @@ LL |     let (_,) = (&u2.a,);\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n-warning: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n-  --> $DIR/issue-53114-safety-checks.rs:39:11\n-   |\n-LL |     match &p.b  { _ => { } }\n-   |           ^^^^\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n-\n error[E0133]: access to union field is unsafe and requires unsafe function or block\n   --> $DIR/issue-53114-safety-checks.rs:41:11\n    |\n@@ -69,16 +79,6 @@ LL |     match &u2.a { _ => { } }\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n-warning: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n-  --> $DIR/issue-53114-safety-checks.rs:45:12\n-   |\n-LL |     match (&p.b,)  { (_,) => { } }\n-   |            ^^^^\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n-\n error[E0133]: access to union field is unsafe and requires unsafe function or block\n   --> $DIR/issue-53114-safety-checks.rs:47:12\n    |"}, {"sha": "82ec60a2e790af65ac7ce2103c59d50e73ab5ddd", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/repr_packed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -23,7 +23,7 @@ fn test_missing_unsafe_warning_on_repr_packed() {\n \n     let c = || {\n         println!(\"{}\", foo.x);\n-        //~^ WARNING: borrow of packed field is unsafe and requires unsafe function or block\n+        //~^ WARNING: reference to packed field is unaligned\n         //~| WARNING: this was previously accepted by the compiler but is being phased out\n         let _z = foo.x;\n     };"}, {"sha": "e8cc164be8754fabbbec6c7dc47e07e998426186", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/repr_packed.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -7,16 +7,16 @@ LL | #![feature(capture_disjoint_fields)]\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n \n-warning: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n+warning: reference to packed field is unaligned\n   --> $DIR/repr_packed.rs:25:24\n    |\n LL |         println!(\"{}\", foo.x);\n    |                        ^^^^^\n    |\n-   = note: `#[warn(safe_packed_borrows)]` on by default\n+   = note: `#[warn(unaligned_references)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n warning: 2 warnings emitted\n "}, {"sha": "45318ca68fcc586f03da6804d73fbccac8cf0c03", "filename": "src/test/ui/const-generics/issues/issue-69654-run-pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-69654-run-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-69654-run-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-69654-run-pass.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,4 +1,3 @@\n-// run-pass\n #![feature(const_generics)]\n #![allow(incomplete_features, unused_braces)]\n \n@@ -15,4 +14,5 @@ where\n \n fn main() {\n     Foo::foo();\n+    //~^ ERROR the function or associated item\n }"}, {"sha": "a82a60696b36b1cb27ffbcf7129cded6e27d559e", "filename": "src/test/ui/const-generics/issues/issue-69654-run-pass.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-69654-run-pass.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-69654-run-pass.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-69654-run-pass.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -0,0 +1,15 @@\n+error[E0599]: the function or associated item `foo` exists for struct `Foo<{_: usize}>`, but its trait bounds were not satisfied\n+  --> $DIR/issue-69654-run-pass.rs:16:10\n+   |\n+LL | struct Foo<const N: usize> {}\n+   | -------------------------- function or associated item `foo` not found for this\n+...\n+LL |     Foo::foo();\n+   |          ^^^ function or associated item cannot be called on `Foo<{_: usize}>` due to unsatisfied trait bounds\n+   |\n+   = note: the following trait bounds were not satisfied:\n+           `[u8; _]: Bar<[(); _]>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "b1214b12a14403114b984c7358bbc7e3a2f3c1cd", "filename": "src/test/ui/const-generics/issues/issue-69654.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-69654.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-69654.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-69654.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -15,4 +15,5 @@ where\n \n fn main() {\n     Foo::foo();\n+    //~^ ERROR the function or associated item\n }"}, {"sha": "0ce7640f685774a07c20c5b6b8db7d6854d487d0", "filename": "src/test/ui/const-generics/issues/issue-69654.stderr", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-69654.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-69654.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-69654.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -4,6 +4,19 @@ error[E0423]: expected value, found type parameter `T`\n LL | impl<T> Bar<T> for [u8; T] {}\n    |                         ^ not a value\n \n-error: aborting due to previous error\n+error[E0599]: the function or associated item `foo` exists for struct `Foo<{_: usize}>`, but its trait bounds were not satisfied\n+  --> $DIR/issue-69654.rs:17:10\n+   |\n+LL | struct Foo<const N: usize> {}\n+   | -------------------------- function or associated item `foo` not found for this\n+...\n+LL |     Foo::foo();\n+   |          ^^^ function or associated item cannot be called on `Foo<{_: usize}>` due to unsatisfied trait bounds\n+   |\n+   = note: the following trait bounds were not satisfied:\n+           `[u8; _]: Bar<[(); _]>`\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0423`.\n+Some errors have detailed explanations: E0423, E0599.\n+For more information about an error, try `rustc --explain E0423`."}, {"sha": "6ded9f13bc4fadacbd90a041e571a7522bdaeb55", "filename": "src/test/ui/const-generics/occurs-check/unused-substs-1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-1.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,4 +1,3 @@\n-// build-pass\n #![feature(const_generics)]\n #![allow(incomplete_features)]\n \n@@ -10,5 +9,5 @@ where\n     A<N>: Bar<N>;\n \n fn main() {\n-    let _ = A;\n+    let _ = A; //~ERROR the trait bound\n }"}, {"sha": "6830288acc0ad25c49e82e5b1b7fcf36c5a085b1", "filename": "src/test/ui/const-generics/occurs-check/unused-substs-1.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-1.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -0,0 +1,17 @@\n+error[E0277]: the trait bound `A<{_: usize}>: Bar<{_: usize}>` is not satisfied\n+  --> $DIR/unused-substs-1.rs:12:13\n+   |\n+LL | / struct A<const N: usize>\n+LL | | where\n+LL | |     A<N>: Bar<N>;\n+   | |_________________- required by `A`\n+...\n+LL |       let _ = A;\n+   |               ^ the trait `Bar<{_: usize}>` is not implemented for `A<{_: usize}>`\n+   |\n+   = help: the following implementations were found:\n+             <A<7_usize> as Bar<N>>\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "2d00141fbf70bb1393262a56a7d2e1b76a1d6d60", "filename": "src/test/ui/const-generics/occurs-check/unused-substs-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-2.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,4 +1,3 @@\n-// check-pass\n #![feature(const_generics)]\n #![allow(incomplete_features)]\n \n@@ -24,4 +23,6 @@ fn main() {\n     // `t` is `ty::Infer(TyVar(_#1t))`\n     // `foo` contains `ty::Infer(TyVar(_#1t))` in its substs\n     t = foo;\n+    //~^ ERROR mismatched types\n+    //~| NOTE cyclic type\n }"}, {"sha": "9532fc21a31b70aebe4fbb69ee60b18f84c2627c", "filename": "src/test/ui/const-generics/occurs-check/unused-substs-2.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-2.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -0,0 +1,9 @@\n+error[E0308]: mismatched types\n+  --> $DIR/unused-substs-2.rs:25:9\n+   |\n+LL |     t = foo;\n+   |         ^^^ cyclic type of infinite size\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "2e306f8c4c88fd46eb1784c962b10d3df9384aa7", "filename": "src/test/ui/const-generics/occurs-check/unused-substs-3.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-3.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,4 +1,3 @@\n-// check-pass\n #![feature(const_generics)]\n #![allow(incomplete_features)]\n \n@@ -15,4 +14,6 @@ fn main() {\n     // `t` is `ty::Infer(TyVar(_#1t))`\n     // `foo` contains `ty::Infer(TyVar(_#1t))` in its substs\n     t = foo;\n+    //~^ ERROR mismatched types\n+    //~| NOTE cyclic type\n }"}, {"sha": "2551d68f9747499f22da42dfc54f41dc6c29b647", "filename": "src/test/ui/const-generics/occurs-check/unused-substs-3.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-3.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/unused-substs-3.rs:16:9\n+   |\n+LL |     t = foo;\n+   |         ^^^\n+   |         |\n+   |         cyclic type of infinite size\n+   |         help: try using a conversion method: `foo.to_vec()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "9c7f5ab91edb13298a6a868b4909ae6f201e6fdf", "filename": "src/test/ui/const-generics/occurs-check/unused-substs-4.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-4.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,4 +1,3 @@\n-// build-pass\n #![feature(const_generics)]\n #![allow(incomplete_features)]\n \n@@ -8,5 +7,5 @@ fn bind<const N: usize>(value: [u8; N]) -> [u8; 3 + 4] {\n \n fn main() {\n     let mut arr = Default::default();\n-    arr = bind(arr);\n+    arr = bind(arr); //~ ERROR mismatched type\n }"}, {"sha": "5685eedbdeca82b205fff2130f46f69612e52568", "filename": "src/test/ui/const-generics/occurs-check/unused-substs-4.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-4.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -0,0 +1,9 @@\n+error[E0308]: mismatched types\n+  --> $DIR/unused-substs-4.rs:10:11\n+   |\n+LL |     arr = bind(arr);\n+   |           ^^^^^^^^^ encountered a self-referencing constant\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "b78eeaa90551b067b35d85500e61c68ff2b0effe", "filename": "src/test/ui/derives/deriving-with-repr-packed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,4 +1,4 @@\n-#![deny(safe_packed_borrows)]\n+#![deny(unaligned_references)]\n \n // check that derive on a packed struct with non-Copy fields\n // correctly. This can't be made to work perfectly because"}, {"sha": "3caa563a08560c8ec8bd4126da7fe8a2d1df2116", "filename": "src/test/ui/derives/deriving-with-repr-packed.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -7,10 +7,10 @@ LL | #[derive(Copy, Clone, PartialEq, Eq)]\n note: the lint level is defined here\n   --> $DIR/deriving-with-repr-packed.rs:1:9\n    |\n-LL | #![deny(safe_packed_borrows)]\n-   |         ^^^^^^^^^^^^^^^^^^^\n+LL | #![deny(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `#[derive]` can't be used on a `#[repr(packed)]` struct with type or const parameters (error E0133)\n@@ -20,7 +20,7 @@ LL | #[derive(Copy, Clone, PartialEq, Eq)]\n    |                       ^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `#[derive]` can't be used on a `#[repr(packed)]` struct that does not derive Copy (error E0133)\n@@ -30,7 +30,7 @@ LL | #[derive(PartialEq, Eq)]\n    |          ^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `#[derive]` can't be used on a `#[repr(packed)]` struct that does not derive Copy (error E0133)\n@@ -40,7 +40,7 @@ LL | #[derive(PartialEq)]\n    |          ^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 4 previous errors"}, {"sha": "d9159f6669d60881355049da9582a0901a2e058d", "filename": "src/test/ui/issues/issue-27060-rpass.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fissues%2Fissue-27060-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fissues%2Fissue-27060-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27060-rpass.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -8,14 +8,12 @@ pub struct Good {\n }\n \n // kill this test when that turns to a hard error\n-#[allow(safe_packed_borrows)]\n+#[allow(unaligned_references)]\n fn main() {\n     let good = Good { data: &0, data2: [&0, &0], aligned: [0; 32] };\n \n-    unsafe {\n-        let _ = &good.data; // ok\n-        let _ = &good.data2[0]; // ok\n-    }\n+    let _ = &good.data; // ok\n+    let _ = &good.data2[0]; // ok\n \n     let _ = &good.data;\n     let _ = &good.data2[0];"}, {"sha": "5317a61671945b8ebffac9abb0cd73512b068cd9", "filename": "src/test/ui/issues/issue-27060.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fissues%2Fissue-27060.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fissues%2Fissue-27060.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27060.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -5,22 +5,22 @@ pub struct Good {\n     aligned: [u8; 32],\n }\n \n-#[deny(safe_packed_borrows)]\n+#[deny(unaligned_references)]\n fn main() {\n     let good = Good {\n         data: &0,\n         data2: [&0, &0],\n         aligned: [0; 32]\n     };\n \n-    unsafe {\n-        let _ = &good.data; // ok\n-        let _ = &good.data2[0]; // ok\n-    }\n+    let _ = &good.data; //~ ERROR reference to packed field\n+    //~| hard error\n+    let _ = &good.data2[0]; //~ ERROR reference to packed field\n+    //~| hard error\n \n-    let _ = &good.data; //~ ERROR borrow of packed field is unsafe\n+    let _ = &good.data; //~ ERROR reference to packed field\n                         //~| hard error\n-    let _ = &good.data2[0]; //~ ERROR borrow of packed field is unsafe\n+    let _ = &good.data2[0]; //~ ERROR reference to packed field\n                             //~| hard error\n     let _ = &*good.data; // ok, behind a pointer\n     let _ = &good.aligned; // ok, has align 1"}, {"sha": "09297884ed377bd6ce994dbfcf0c242476979986", "filename": "src/test/ui/issues/issue-27060.stderr", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fissues%2Fissue-27060.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fissues%2Fissue-27060.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27060.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,27 +1,47 @@\n-error: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n-  --> $DIR/issue-27060.rs:21:13\n+error: reference to packed field is unaligned\n+  --> $DIR/issue-27060.rs:16:13\n    |\n LL |     let _ = &good.data;\n    |             ^^^^^^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/issue-27060.rs:8:8\n    |\n-LL | #[deny(safe_packed_borrows)]\n-   |        ^^^^^^^^^^^^^^^^^^^\n+LL | #[deny(unaligned_references)]\n+   |        ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+\n+error: reference to packed field is unaligned\n+  --> $DIR/issue-27060.rs:18:13\n+   |\n+LL |     let _ = &good.data2[0];\n+   |             ^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+\n+error: reference to packed field is unaligned\n+  --> $DIR/issue-27060.rs:21:13\n+   |\n+LL |     let _ = &good.data;\n+   |             ^^^^^^^^^^\n+   |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n-error: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n+error: reference to packed field is unaligned\n   --> $DIR/issue-27060.rs:23:13\n    |\n LL |     let _ = &good.data2[0];\n    |             ^^^^^^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "7d58eb948ea815991b79245d2e926b075d1fd9c8", "filename": "src/test/ui/iterators/array-of-ranges.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fiterators%2Farray-of-ranges.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fiterators%2Farray-of-ranges.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Farray-of-ranges.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -13,43 +13,43 @@ error[E0277]: `[RangeInclusive<{integer}>; 1]` is not an iterator\n   --> $DIR/array-of-ranges.rs:4:14\n    |\n LL |     for _ in [0..=1] {}\n-   |              ^^^^^^^ borrow the array with `&` or call `.iter()` on it to iterate over it\n+   |              ^^^^^^^ if you meant to iterate between two values, remove the square brackets\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeInclusive<{integer}>; 1]`\n-   = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: `[start..=end]` is an array of one `RangeInclusive`; you might have meant to have a `RangeInclusive` without the brackets: `start..=end`\n    = note: required because of the requirements on the impl of `IntoIterator` for `[RangeInclusive<{integer}>; 1]`\n    = note: required by `into_iter`\n \n error[E0277]: `[RangeFrom<{integer}>; 1]` is not an iterator\n   --> $DIR/array-of-ranges.rs:6:14\n    |\n LL |     for _ in [0..] {}\n-   |              ^^^^^ borrow the array with `&` or call `.iter()` on it to iterate over it\n+   |              ^^^^^ if you meant to iterate from a value onwards, remove the square brackets\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeFrom<{integer}>; 1]`\n-   = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: `[start..]` is an array of one `RangeFrom`; you might have meant to have a `RangeFrom` without the brackets: `start..`, keeping in mind that iterating over an unbounded iterator will run forever unless you `break` or `return` from within the loop\n    = note: required because of the requirements on the impl of `IntoIterator` for `[RangeFrom<{integer}>; 1]`\n    = note: required by `into_iter`\n \n error[E0277]: `[RangeTo<{integer}>; 1]` is not an iterator\n   --> $DIR/array-of-ranges.rs:8:14\n    |\n LL |     for _ in [..1] {}\n-   |              ^^^^^ borrow the array with `&` or call `.iter()` on it to iterate over it\n+   |              ^^^^^ if you meant to iterate until a value, remove the square brackets and add a starting value\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeTo<{integer}>; 1]`\n-   = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: `[..end]` is an array of one `RangeTo`; you might have meant to have a bounded `Range` without the brackets: `0..end`\n    = note: required because of the requirements on the impl of `IntoIterator` for `[RangeTo<{integer}>; 1]`\n    = note: required by `into_iter`\n \n error[E0277]: `[RangeToInclusive<{integer}>; 1]` is not an iterator\n   --> $DIR/array-of-ranges.rs:10:14\n    |\n LL |     for _ in [..=1] {}\n-   |              ^^^^^^ borrow the array with `&` or call `.iter()` on it to iterate over it\n+   |              ^^^^^^ if you meant to iterate until a value (including it), remove the square brackets and add a starting value\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeToInclusive<{integer}>; 1]`\n-   = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: `[..=end]` is an array of one `RangeToInclusive`; you might have meant to have a bounded `RangeInclusive` without the brackets: `0..=end`\n    = note: required because of the requirements on the impl of `IntoIterator` for `[RangeToInclusive<{integer}>; 1]`\n    = note: required by `into_iter`\n \n@@ -79,21 +79,21 @@ error[E0277]: `[std::ops::Range<{integer}>; 2]` is not an iterator\n   --> $DIR/array-of-ranges.rs:19:14\n    |\n LL |     for _ in [0..1, 2..3] {}\n-   |              ^^^^^^^^^^^^ borrow the array with `&` or call `.iter()` on it to iterate over it\n+   |              ^^^^^^^^^^^^ arrays do not yet implement `IntoIterator`; try using `std::array::IntoIter::new(arr)`\n    |\n    = help: the trait `Iterator` is not implemented for `[std::ops::Range<{integer}>; 2]`\n-   = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: see <https://github.com/rust-lang/rust/pull/65819> for more details\n    = note: required because of the requirements on the impl of `IntoIterator` for `[std::ops::Range<{integer}>; 2]`\n    = note: required by `into_iter`\n \n error[E0277]: `[RangeInclusive<{integer}>; 1]` is not an iterator\n   --> $DIR/array-of-ranges.rs:21:14\n    |\n LL |     for _ in [0..=1] {}\n-   |              ^^^^^^^ borrow the array with `&` or call `.iter()` on it to iterate over it\n+   |              ^^^^^^^ if you meant to iterate between two values, remove the square brackets\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeInclusive<{integer}>; 1]`\n-   = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: `[start..=end]` is an array of one `RangeInclusive`; you might have meant to have a `RangeInclusive` without the brackets: `start..=end`\n    = note: required because of the requirements on the impl of `IntoIterator` for `[RangeInclusive<{integer}>; 1]`\n    = note: required by `into_iter`\n "}, {"sha": "7e2b600fb7af2be302796965fe9ca83211932396", "filename": "src/test/ui/iterators/array.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fiterators%2Farray.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fiterators%2Farray.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Farray.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -2,32 +2,32 @@ error[E0277]: `[{integer}; 2]` is not an iterator\n   --> $DIR/array.rs:2:14\n    |\n LL |     for _ in [1, 2] {}\n-   |              ^^^^^^ borrow the array with `&` or call `.iter()` on it to iterate over it\n+   |              ^^^^^^ arrays do not yet implement `IntoIterator`; try using `std::array::IntoIter::new(arr)`\n    |\n    = help: the trait `Iterator` is not implemented for `[{integer}; 2]`\n-   = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: see <https://github.com/rust-lang/rust/pull/65819> for more details\n    = note: required because of the requirements on the impl of `IntoIterator` for `[{integer}; 2]`\n    = note: required by `into_iter`\n \n error[E0277]: `[{integer}; 2]` is not an iterator\n   --> $DIR/array.rs:5:14\n    |\n LL |     for _ in x {}\n-   |              ^ borrow the array with `&` or call `.iter()` on it to iterate over it\n+   |              ^ arrays do not yet implement `IntoIterator`; try using `std::array::IntoIter::new(arr)`\n    |\n    = help: the trait `Iterator` is not implemented for `[{integer}; 2]`\n-   = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: see <https://github.com/rust-lang/rust/pull/65819> for more details\n    = note: required because of the requirements on the impl of `IntoIterator` for `[{integer}; 2]`\n    = note: required by `into_iter`\n \n error[E0277]: `[{float}; 2]` is not an iterator\n   --> $DIR/array.rs:7:14\n    |\n LL |     for _ in [1.0, 2.0] {}\n-   |              ^^^^^^^^^^ borrow the array with `&` or call `.iter()` on it to iterate over it\n+   |              ^^^^^^^^^^ arrays do not yet implement `IntoIterator`; try using `std::array::IntoIter::new(arr)`\n    |\n    = help: the trait `Iterator` is not implemented for `[{float}; 2]`\n-   = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: see <https://github.com/rust-lang/rust/pull/65819> for more details\n    = note: required because of the requirements on the impl of `IntoIterator` for `[{float}; 2]`\n    = note: required by `into_iter`\n "}, {"sha": "73844329e361d5d69c8773d8bae997318df9aa3e", "filename": "src/test/ui/iterators/ranges.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fiterators%2Franges.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fiterators%2Franges.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Franges.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -2,19 +2,21 @@ error[E0277]: `RangeTo<{integer}>` is not an iterator\n   --> $DIR/ranges.rs:2:14\n    |\n LL |     for _ in ..10 {}\n-   |              ^^^^ `RangeTo<{integer}>` is not an iterator\n+   |              ^^^^ if you meant to iterate until a value, add a starting value\n    |\n    = help: the trait `Iterator` is not implemented for `RangeTo<{integer}>`\n+   = note: `..end` is a `RangeTo`, which cannot be iterated on; you might have meant to have a bounded `Range`: `0..end`\n    = note: required because of the requirements on the impl of `IntoIterator` for `RangeTo<{integer}>`\n    = note: required by `into_iter`\n \n error[E0277]: `RangeToInclusive<{integer}>` is not an iterator\n   --> $DIR/ranges.rs:4:14\n    |\n LL |     for _ in ..=10 {}\n-   |              ^^^^^ `RangeToInclusive<{integer}>` is not an iterator\n+   |              ^^^^^ if you meant to iterate until a value (including it), add a starting value\n    |\n    = help: the trait `Iterator` is not implemented for `RangeToInclusive<{integer}>`\n+   = note: `..=end` is a `RangeToInclusive`, which cannot be iterated on; you might have meant to have a bounded `RangeInclusive`: `0..=end`\n    = note: required because of the requirements on the impl of `IntoIterator` for `RangeToInclusive<{integer}>`\n    = note: required by `into_iter`\n "}, {"sha": "1d77bcb753630f860ce28fd2999e59ce91a3751e", "filename": "src/test/ui/iterators/string.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fiterators%2Fstring.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fiterators%2Fstring.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fstring.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -2,7 +2,7 @@ error[E0277]: `String` is not an iterator\n   --> $DIR/string.rs:2:14\n    |\n LL |     for _ in \"\".to_owned() {}\n-   |              ^^^^^^^^^^^^^ `String` is not an iterator\n+   |              ^^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help: the trait `Iterator` is not implemented for `String`\n    = note: required because of the requirements on the impl of `IntoIterator` for `String`"}, {"sha": "ad38c21d96cf93c25131e092ab93240ceb2d80bd", "filename": "src/test/ui/lint/unaligned_references.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Flint%2Funaligned_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Flint%2Funaligned_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funaligned_references.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -13,14 +13,20 @@ fn main() {\n         let good = Good { data: 0, ptr: &0, data2: [0, 0], aligned: [0; 32] };\n \n         let _ = &good.ptr; //~ ERROR reference to packed field\n+        //~^ previously accepted\n         let _ = &good.data; //~ ERROR reference to packed field\n+        //~^ previously accepted\n         // Error even when turned into raw pointer immediately.\n         let _ = &good.data as *const _; //~ ERROR reference to packed field\n+        //~^ previously accepted\n         let _: *const _ = &good.data; //~ ERROR reference to packed field\n+        //~^ previously accepted\n         // Error on method call.\n         let _ = good.data.clone(); //~ ERROR reference to packed field\n+        //~^ previously accepted\n         // Error for nested fields.\n         let _ = &good.data2[0]; //~ ERROR reference to packed field\n+        //~^ previously accepted\n \n         let _ = &*good.ptr; // ok, behind a pointer\n         let _ = &good.aligned; // ok, has align 1"}, {"sha": "9ae25f5b59ed102485ad30d404cd00d7b853e79a", "filename": "src/test/ui/lint/unaligned_references.stderr", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Flint%2Funaligned_references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Flint%2Funaligned_references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funaligned_references.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -9,46 +9,58 @@ note: the lint level is defined here\n    |\n LL | #![deny(unaligned_references)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n error: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:16:17\n+  --> $DIR/unaligned_references.rs:17:17\n    |\n LL |         let _ = &good.data;\n    |                 ^^^^^^^^^^\n    |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n error: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:18:17\n+  --> $DIR/unaligned_references.rs:20:17\n    |\n LL |         let _ = &good.data as *const _;\n    |                 ^^^^^^^^^^\n    |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n error: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:19:27\n+  --> $DIR/unaligned_references.rs:22:27\n    |\n LL |         let _: *const _ = &good.data;\n    |                           ^^^^^^^^^^\n    |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n error: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:21:17\n+  --> $DIR/unaligned_references.rs:25:17\n    |\n LL |         let _ = good.data.clone();\n    |                 ^^^^^^^^^\n    |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n error: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:23:17\n+  --> $DIR/unaligned_references.rs:28:17\n    |\n LL |         let _ = &good.data2[0];\n    |                 ^^^^^^^^^^^^^^\n    |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n error: aborting due to 6 previous errors"}, {"sha": "cb597c38e779283a8ce6cf996ef18644f56bb2ae", "filename": "src/test/ui/lint/unaligned_references_external_macro.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Flint%2Funaligned_references_external_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Flint%2Funaligned_references_external_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funaligned_references_external_macro.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,10 +1,9 @@\n // aux-build:unaligned_references_external_crate.rs\n \n-#![allow(safe_packed_borrows)]\n-\n extern crate unaligned_references_external_crate;\n \n unaligned_references_external_crate::mac! { //~ERROR reference to packed field is unaligned\n+    //~^ previously accepted\n     #[repr(packed)]\n     pub struct X {\n         pub field: u16"}, {"sha": "4e7c6bfc98d9d2c68fcfc7bcf8e45aabe50d5865", "filename": "src/test/ui/lint/unaligned_references_external_macro.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Flint%2Funaligned_references_external_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Flint%2Funaligned_references_external_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funaligned_references_external_macro.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,7 +1,8 @@\n error: reference to packed field is unaligned\n-  --> $DIR/unaligned_references_external_macro.rs:7:1\n+  --> $DIR/unaligned_references_external_macro.rs:5:1\n    |\n LL | / unaligned_references_external_crate::mac! {\n+LL | |\n LL | |     #[repr(packed)]\n LL | |     pub struct X {\n LL | |         pub field: u16\n@@ -10,15 +11,18 @@ LL | | }\n    | |_^\n    |\n note: the lint level is defined here\n-  --> $DIR/unaligned_references_external_macro.rs:7:1\n+  --> $DIR/unaligned_references_external_macro.rs:5:1\n    |\n LL | / unaligned_references_external_crate::mac! {\n+LL | |\n LL | |     #[repr(packed)]\n LL | |     pub struct X {\n LL | |         pub field: u16\n LL | |     }\n LL | | }\n    | |_^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "fb3875e680496f9fb4adaf3d18a8cd97c961e6cf", "filename": "src/test/ui/packed/packed-struct-address-of-element.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-address-of-element.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-address-of-element.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-address-of-element.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n #![allow(dead_code)]\n-#![deny(safe_packed_borrows)]\n+#![deny(unaligned_references)]\n #![feature(raw_ref_op)]\n // ignore-emscripten weird assertion?\n "}, {"sha": "5dad084eecf6dd33cbbe6f08ced62730b6253544", "filename": "src/test/ui/packed/packed-struct-borrow-element.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -22,14 +22,17 @@ struct Foo4C {\n \n pub fn main() {\n     let foo = Foo1 { bar: 1, baz: 2 };\n-    let brw = unsafe { &foo.baz };\n+    let brw = &foo.baz; //~WARN reference to packed field is unaligned\n+    //~^ previously accepted\n     assert_eq!(*brw, 2);\n \n     let foo = Foo2 { bar: 1, baz: 2 };\n-    let brw = unsafe { &foo.baz };\n+    let brw = &foo.baz; //~WARN reference to packed field is unaligned\n+    //~^ previously accepted\n     assert_eq!(*brw, 2);\n \n     let foo = Foo4C { bar: 1, baz: 2 };\n-    let brw = unsafe { &foo.baz };\n+    let brw = &foo.baz; //~WARN reference to packed field is unaligned\n+    //~^ previously accepted\n     assert_eq!(*brw, 2);\n }"}, {"sha": "d9d9a71ff58e93ce359b0ed0dd517ff3d5e81788", "filename": "src/test/ui/packed/packed-struct-borrow-element.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -0,0 +1,33 @@\n+warning: reference to packed field is unaligned\n+  --> $DIR/packed-struct-borrow-element.rs:25:15\n+   |\n+LL |     let brw = &foo.baz;\n+   |               ^^^^^^^^\n+   |\n+   = note: `#[warn(unaligned_references)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+\n+warning: reference to packed field is unaligned\n+  --> $DIR/packed-struct-borrow-element.rs:30:15\n+   |\n+LL |     let brw = &foo.baz;\n+   |               ^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+\n+warning: reference to packed field is unaligned\n+  --> $DIR/packed-struct-borrow-element.rs:35:15\n+   |\n+LL |     let brw = &foo.baz;\n+   |               ^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+\n+warning: 3 warnings emitted\n+"}, {"sha": "27676a5cb8112e2a3a077d4f6279fd020ad38bbe", "filename": "src/test/ui/proc-macro/auxiliary/nested-macro-rules.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fnested-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fnested-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fnested-macro-rules.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -2,14 +2,15 @@ pub struct FirstStruct;\n \n #[macro_export]\n macro_rules! outer_macro {\n-    ($name:ident) => {\n+    ($name:ident, $attr_struct_name:ident) => {\n         #[macro_export]\n         macro_rules! inner_macro {\n-            ($wrapper:ident) => {\n-                $wrapper!($name)\n+            ($bang_macro:ident, $attr_macro:ident) => {\n+                $bang_macro!($name);\n+                #[$attr_macro] struct $attr_struct_name {}\n             }\n         }\n     }\n }\n \n-outer_macro!(FirstStruct);\n+outer_macro!(FirstStruct, FirstAttrStruct);"}, {"sha": "25ffcfad7c7eaac28500fec2c7c74cae7c9e9d16", "filename": "src/test/ui/proc-macro/nested-macro-rules.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fproc-macro%2Fnested-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fproc-macro%2Fnested-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnested-macro-rules.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,7 +1,7 @@\n // run-pass\n // aux-build:nested-macro-rules.rs\n // aux-build:test-macros.rs\n-// compile-flags: -Z span-debug\n+// compile-flags: -Z span-debug -Z macro-backtrace\n // edition:2018\n \n #![no_std] // Don't load unnecessary hygiene information from std\n@@ -10,14 +10,14 @@ extern crate std;\n extern crate nested_macro_rules;\n extern crate test_macros;\n \n-use test_macros::print_bang;\n+use test_macros::{print_bang, print_attr};\n \n use nested_macro_rules::FirstStruct;\n struct SecondStruct;\n \n fn main() {\n-    nested_macro_rules::inner_macro!(print_bang);\n+    nested_macro_rules::inner_macro!(print_bang, print_attr);\n \n-    nested_macro_rules::outer_macro!(SecondStruct);\n-    inner_macro!(print_bang);\n+    nested_macro_rules::outer_macro!(SecondStruct, SecondAttrStruct);\n+    inner_macro!(print_bang, print_attr);\n }"}, {"sha": "8292617fc1675687a360a71b3ee0fff04a7ba3f1", "filename": "src/test/ui/proc-macro/nested-macro-rules.stdout", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fproc-macro%2Fnested-macro-rules.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fproc-macro%2Fnested-macro-rules.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnested-macro-rules.stdout?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -5,10 +5,32 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n         stream: TokenStream [\n             Ident {\n                 ident: \"FirstStruct\",\n-                span: $DIR/auxiliary/nested-macro-rules.rs:15:14: 15:25 (#7),\n+                span: $DIR/auxiliary/nested-macro-rules.rs:16:14: 16:25 (#7),\n             },\n         ],\n-        span: $DIR/auxiliary/nested-macro-rules.rs:9:27: 9:32 (#6),\n+        span: $DIR/auxiliary/nested-macro-rules.rs:9:30: 9:35 (#6),\n+    },\n+]\n+PRINT-ATTR INPUT (DISPLAY): struct FirstAttrStruct { }\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Ident {\n+        ident: \"struct\",\n+        span: $DIR/auxiliary/nested-macro-rules.rs:10:32: 10:38 (#6),\n+    },\n+    Group {\n+        delimiter: None,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"FirstAttrStruct\",\n+                span: $DIR/auxiliary/nested-macro-rules.rs:16:27: 16:42 (#7),\n+            },\n+        ],\n+        span: $DIR/auxiliary/nested-macro-rules.rs:10:39: 10:56 (#6),\n+    },\n+    Group {\n+        delimiter: Brace,\n+        stream: TokenStream [],\n+        span: $DIR/auxiliary/nested-macro-rules.rs:10:57: 10:59 (#6),\n     },\n ]\n PRINT-BANG INPUT (DISPLAY): SecondStruct\n@@ -18,9 +40,31 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n         stream: TokenStream [\n             Ident {\n                 ident: \"SecondStruct\",\n-                span: $DIR/nested-macro-rules.rs:21:38: 21:50 (#13),\n+                span: $DIR/nested-macro-rules.rs:21:38: 21:50 (#16),\n             },\n         ],\n-        span: $DIR/auxiliary/nested-macro-rules.rs:9:27: 9:32 (#12),\n+        span: $DIR/auxiliary/nested-macro-rules.rs:9:30: 9:35 (#15),\n+    },\n+]\n+PRINT-ATTR INPUT (DISPLAY): struct SecondAttrStruct { }\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Ident {\n+        ident: \"struct\",\n+        span: $DIR/auxiliary/nested-macro-rules.rs:10:32: 10:38 (#15),\n+    },\n+    Group {\n+        delimiter: None,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"SecondAttrStruct\",\n+                span: $DIR/nested-macro-rules.rs:21:52: 21:68 (#16),\n+            },\n+        ],\n+        span: $DIR/auxiliary/nested-macro-rules.rs:10:39: 10:56 (#15),\n+    },\n+    Group {\n+        delimiter: Brace,\n+        stream: TokenStream [],\n+        span: $DIR/auxiliary/nested-macro-rules.rs:10:57: 10:59 (#15),\n     },\n ]"}, {"sha": "3786457fb1ae3ac5fc54a2d2f83cd59ec9e5944f", "filename": "src/test/ui/suggestions/expected-boxed-future-isnt-pinned.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -46,6 +46,7 @@ error[E0277]: `dyn Future<Output = i32> + Send` cannot be unpinned\n LL |     Pin::new(x)\n    |     ^^^^^^^^ the trait `Unpin` is not implemented for `dyn Future<Output = i32> + Send`\n    |\n+   = note: consider using `Box::pin`\n    = note: required by `Pin::<P>::new`\n \n error[E0277]: `dyn Future<Output = i32> + Send` cannot be unpinned\n@@ -54,6 +55,7 @@ error[E0277]: `dyn Future<Output = i32> + Send` cannot be unpinned\n LL |     Pin::new(Box::new(x))\n    |     ^^^^^^^^ the trait `Unpin` is not implemented for `dyn Future<Output = i32> + Send`\n    |\n+   = note: consider using `Box::pin`\n    = note: required by `Pin::<P>::new`\n \n error[E0308]: mismatched types"}, {"sha": "26efd50bb8fd3479c2eaaff85cf6e9109696a73b", "filename": "src/test/ui/suggestions/into-str.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -7,6 +7,7 @@ LL | fn foo<'a, T>(_t: T) where T: Into<&'a str> {}\n LL |     foo(String::new());\n    |     ^^^ the trait `From<String>` is not implemented for `&str`\n    |\n+   = note: to coerce a `String` into a `&str`, use `&*` as a prefix\n    = note: required because of the requirements on the impl of `Into<&str>` for `String`\n \n error: aborting due to previous error"}, {"sha": "3ee2860b4ffc7033b91131d17c06ce1bb59b5116", "filename": "src/test/ui/suggestions/path-display.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fsuggestions%2Fpath-display.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftest%2Fui%2Fsuggestions%2Fpath-display.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fpath-display.stderr?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -2,10 +2,10 @@ error[E0277]: `Path` doesn't implement `std::fmt::Display`\n   --> $DIR/path-display.rs:5:20\n    |\n LL |     println!(\"{}\", path);\n-   |                    ^^^^ `Path` cannot be formatted with the default formatter\n+   |                    ^^^^ `Path` cannot be formatted with the default formatter; call `.display()` on it\n    |\n    = help: the trait `std::fmt::Display` is not implemented for `Path`\n-   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n+   = note: call `.display()` or `.to_string_lossy()` to safely print paths, as they may contain non-Unicode data\n    = note: required because of the requirements on the impl of `std::fmt::Display` for `&Path`\n    = note: required by `std::fmt::Display::fmt`\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)"}, {"sha": "540612a7dce0576777c6ae080928f2a3fc9c4778", "filename": "src/test/ui/unsafe/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/afaf33dcafe9c7068b63eb997df221aa08db7c29/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-safe_packed_borrows-in-unsafe-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf33dcafe9c7068b63eb997df221aa08db7c29/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-safe_packed_borrows-in-unsafe-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-safe_packed_borrows-in-unsafe-fn.rs?ref=afaf33dcafe9c7068b63eb997df221aa08db7c29", "patch": "@@ -1,67 +0,0 @@\n-#![feature(unsafe_block_in_unsafe_fn)]\n-\n-#[repr(packed)]\n-pub struct Packed {\n-    data: &'static u32,\n-}\n-\n-const PACKED: Packed = Packed { data: &0 };\n-\n-#[allow(safe_packed_borrows)]\n-#[allow(unsafe_op_in_unsafe_fn)]\n-unsafe fn allow_allow() {\n-    &PACKED.data; // allowed\n-}\n-\n-#[allow(safe_packed_borrows)]\n-#[warn(unsafe_op_in_unsafe_fn)]\n-unsafe fn allow_warn() {\n-    &PACKED.data; // allowed\n-}\n-\n-#[allow(safe_packed_borrows)]\n-#[deny(unsafe_op_in_unsafe_fn)]\n-unsafe fn allow_deny() {\n-    &PACKED.data; // allowed\n-}\n-\n-#[warn(safe_packed_borrows)]\n-#[allow(unsafe_op_in_unsafe_fn)]\n-unsafe fn warn_allow() {\n-    &PACKED.data; // allowed\n-}\n-\n-#[warn(safe_packed_borrows)]\n-#[warn(unsafe_op_in_unsafe_fn)]\n-unsafe fn warn_warn() {\n-    &PACKED.data; //~ WARN\n-    //~| WARNING this was previously accepted by the compiler but is being phased out\n-}\n-\n-#[warn(safe_packed_borrows)]\n-#[deny(unsafe_op_in_unsafe_fn)]\n-unsafe fn warn_deny() {\n-    &PACKED.data; //~ WARN\n-    //~| WARNING this was previously accepted by the compiler but is being phased out\n-}\n-\n-#[deny(safe_packed_borrows)]\n-#[allow(unsafe_op_in_unsafe_fn)]\n-unsafe fn deny_allow() {\n-    &PACKED.data; // allowed\n-}\n-\n-#[deny(safe_packed_borrows)]\n-#[warn(unsafe_op_in_unsafe_fn)]\n-unsafe fn deny_warn() {\n-    &PACKED.data; //~ WARN\n-}\n-\n-#[deny(safe_packed_borrows)]\n-#[deny(unsafe_op_in_unsafe_fn)]\n-unsafe fn deny_deny() {\n-    &PACKED.data; //~ ERROR\n-    //~| WARNING this was previously accepted by the compiler but is being phased out\n-}\n-\n-fn main() {}"}, {"sha": "fda15159643b6ec2526a547a8d25ba49e244c882", "filename": "src/test/ui/unsafe/rfc-2585-safe_packed_borrows-in-unsafe-fn.stderr", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/afaf33dcafe9c7068b63eb997df221aa08db7c29/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-safe_packed_borrows-in-unsafe-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/afaf33dcafe9c7068b63eb997df221aa08db7c29/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-safe_packed_borrows-in-unsafe-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-safe_packed_borrows-in-unsafe-fn.stderr?ref=afaf33dcafe9c7068b63eb997df221aa08db7c29", "patch": "@@ -1,60 +0,0 @@\n-warning: borrow of packed field is unsafe and requires unsafe block (error E0133)\n-  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:37:5\n-   |\n-LL |     &PACKED.data;\n-   |     ^^^^^^^^^^^^ borrow of packed field\n-   |\n-note: the lint level is defined here\n-  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:34:8\n-   |\n-LL | #[warn(safe_packed_borrows)]\n-   |        ^^^^^^^^^^^^^^^^^^^\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n-\n-warning: borrow of packed field is unsafe and requires unsafe block (error E0133)\n-  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:44:5\n-   |\n-LL |     &PACKED.data;\n-   |     ^^^^^^^^^^^^ borrow of packed field\n-   |\n-note: the lint level is defined here\n-  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:41:8\n-   |\n-LL | #[warn(safe_packed_borrows)]\n-   |        ^^^^^^^^^^^^^^^^^^^\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n-\n-warning: borrow of packed field is unsafe and requires unsafe block (error E0133)\n-  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:57:5\n-   |\n-LL |     &PACKED.data;\n-   |     ^^^^^^^^^^^^ borrow of packed field\n-   |\n-note: the lint level is defined here\n-  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:55:8\n-   |\n-LL | #[warn(unsafe_op_in_unsafe_fn)]\n-   |        ^^^^^^^^^^^^^^^^^^^^^^\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n-\n-error: borrow of packed field is unsafe and requires unsafe block (error E0133)\n-  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:63:5\n-   |\n-LL |     &PACKED.data;\n-   |     ^^^^^^^^^^^^ borrow of packed field\n-   |\n-note: the lint level is defined here\n-  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:60:8\n-   |\n-LL | #[deny(safe_packed_borrows)]\n-   |        ^^^^^^^^^^^^^^^^^^^\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n-\n-error: aborting due to previous error; 3 warnings emitted\n-"}, {"sha": "73f71d88b05254a5d9ed0e6a4b6f88e767974b8f", "filename": "src/tools/clippy/clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -13,6 +13,7 @@ use rustc_middle::{\n     ty::{self, FloatTy, IntTy, PolyFnSig, Ty},\n };\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use std::iter;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of unconstrained numeric literals which may cause default numeric fallback in type\n@@ -107,7 +108,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n         match &expr.kind {\n             ExprKind::Call(func, args) => {\n                 if let Some(fn_sig) = fn_sig_opt(self.cx, func.hir_id) {\n-                    for (expr, bound) in args.iter().zip(fn_sig.skip_binder().inputs().iter()) {\n+                    for (expr, bound) in iter::zip(*args, fn_sig.skip_binder().inputs()) {\n                         // Push found arg type, then visit arg.\n                         self.ty_bounds.push(TyBound::Ty(bound));\n                         self.visit_expr(expr);\n@@ -120,7 +121,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n             ExprKind::MethodCall(_, _, args, _) => {\n                 if let Some(def_id) = self.cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n                     let fn_sig = self.cx.tcx.fn_sig(def_id).skip_binder();\n-                    for (expr, bound) in args.iter().zip(fn_sig.inputs().iter()) {\n+                    for (expr, bound) in iter::zip(*args, fn_sig.inputs()) {\n                         self.ty_bounds.push(TyBound::Ty(bound));\n                         self.visit_expr(expr);\n                         self.ty_bounds.pop();"}, {"sha": "a99ed7656bfb3619d10f1e12b80c2b282329b409", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -4,6 +4,7 @@\n #![feature(box_syntax)]\n #![feature(drain_filter)]\n #![feature(in_band_lifetimes)]\n+#![feature(iter_zip)]\n #![feature(once_cell)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(rustc_private)]"}, {"sha": "5447051926060dca553be8d6a45462db3b7972d2", "filename": "src/tools/clippy/clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -13,6 +13,7 @@ use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use std::iter;\n \n declare_clippy_lint! {\n     /// **What it does:** Warns if a long integral or floating-point constant does\n@@ -349,7 +350,7 @@ impl LiteralDigitGrouping {\n \n         let group_sizes: Vec<usize> = num_lit.integer.split('_').map(str::len).collect();\n         if UUID_GROUP_LENS.len() == group_sizes.len() {\n-            UUID_GROUP_LENS.iter().zip(&group_sizes).all(|(&a, &b)| a == b)\n+            iter::zip(&UUID_GROUP_LENS, &group_sizes).all(|(&a, &b)| a == b)\n         } else {\n             false\n         }"}, {"sha": "64ab3b6bfec026df969e46b585182213486833f7", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::hir::map::Map;\n use rustc_middle::middle::region;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::{sym, Symbol};\n-use std::iter::Iterator;\n+use std::iter::{self, Iterator};\n use std::mem;\n \n /// Checks for looping over a range and then indexing a sequence with it.\n@@ -369,7 +369,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n             },\n             ExprKind::MethodCall(_, _, args, _) => {\n                 let def_id = self.cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n-                for (ty, expr) in self.cx.tcx.fn_sig(def_id).inputs().skip_binder().iter().zip(args) {\n+                for (ty, expr) in iter::zip(self.cx.tcx.fn_sig(def_id).inputs().skip_binder(), args) {\n                     self.prefer_mutable = false;\n                     if let ty::Ref(_, _, mutbl) = *ty.kind() {\n                         if mutbl == Mutability::Mut {"}, {"sha": "2f2dc4cfc6b03eb972d95bbb573c8789897e038d", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -29,6 +29,7 @@ use rustc_span::source_map::{Span, Spanned};\n use rustc_span::sym;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry;\n+use std::iter;\n use std::ops::Bound;\n \n declare_clippy_lint! {\n@@ -1668,7 +1669,7 @@ where\n \n     values.sort();\n \n-    for (a, b) in values.iter().zip(values.iter().skip(1)) {\n+    for (a, b) in iter::zip(&values, &values[1..]) {\n         match (a, b) {\n             (&Kind::Start(_, ra), &Kind::End(_, rb)) => {\n                 if ra.node != rb.node {"}, {"sha": "4d3dff36a2069f34652acd5e7f3e20284bad27d9", "filename": "src/tools/clippy/clippy_lints/src/mut_key.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -6,6 +6,7 @@ use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{Adt, Array, RawPtr, Ref, Slice, Tuple, Ty, TypeAndMut};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use std::iter;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for sets/maps with mutable key types.\n@@ -87,7 +88,7 @@ impl<'tcx> LateLintPass<'tcx> for MutableKeyType {\n fn check_sig<'tcx>(cx: &LateContext<'tcx>, item_hir_id: hir::HirId, decl: &hir::FnDecl<'_>) {\n     let fn_def_id = cx.tcx.hir().local_def_id(item_hir_id);\n     let fn_sig = cx.tcx.fn_sig(fn_def_id);\n-    for (hir_ty, ty) in decl.inputs.iter().zip(fn_sig.inputs().skip_binder().iter()) {\n+    for (hir_ty, ty) in iter::zip(decl.inputs, fn_sig.inputs().skip_binder()) {\n         check_ty(cx, hir_ty.span, ty);\n     }\n     check_ty(cx, decl.output.span(), cx.tcx.erase_late_bound_regions(fn_sig.output()));"}, {"sha": "05457e80d52c960833eb9c853da293d7532b26cd", "filename": "src/tools/clippy/clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -4,6 +4,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use std::iter;\n \n declare_clippy_lint! {\n     /// **What it does:** Detects passing a mutable reference to a function that only\n@@ -64,7 +65,7 @@ fn check_arguments<'tcx>(\n     match type_definition.kind() {\n         ty::FnDef(..) | ty::FnPtr(_) => {\n             let parameters = type_definition.fn_sig(cx.tcx).skip_binder().inputs();\n-            for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n+            for (argument, parameter) in iter::zip(arguments, parameters) {\n                 match parameter.kind() {\n                     ty::Ref(_, _, Mutability::Not)\n                     | ty::RawPtr(ty::TypeAndMut {"}, {"sha": "e151f85a39137883b3f16e596b35086e25f89c08", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,4 +1,5 @@\n use std::cmp;\n+use std::iter;\n \n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::is_self_ty;\n@@ -122,7 +123,7 @@ impl<'tcx> PassByRefOrValue {\n \n         let fn_body = cx.enclosing_body.map(|id| cx.tcx.hir().body(id));\n \n-        for (index, (input, &ty)) in decl.inputs.iter().zip(fn_sig.inputs()).enumerate() {\n+        for (index, (input, &ty)) in iter::zip(decl.inputs, fn_sig.inputs()).enumerate() {\n             // All spans generated from a proc-macro invocation are the same...\n             match span {\n                 Some(s) if s == input.span => return,"}, {"sha": "c0c2ab67e382e0194906e80c4955867a84636b7c", "filename": "src/tools/clippy/clippy_lints/src/pattern_type_mismatch.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -10,6 +10,7 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{AdtDef, FieldDef, Ty, TyKind, VariantDef};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use std::iter;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for patterns that aren't exact representations of the types\n@@ -134,7 +135,7 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n         hir_id: HirId,\n     ) {\n         if let Some(fn_sig) = cx.typeck_results().liberated_fn_sigs().get(hir_id) {\n-            for (param, ty) in body.params.iter().zip(fn_sig.inputs().iter()) {\n+            for (param, ty) in iter::zip(body.params, fn_sig.inputs()) {\n                 apply_lint(cx, &param.pat, ty, DerefPossible::Impossible);\n             }\n         }"}, {"sha": "6becff9662a76ff79b74e191baf506b7788ee73b", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -9,6 +9,7 @@ use rustc_middle::ty::{self, subst::GenericArgKind};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n use rustc_span::symbol::Ident;\n+use std::iter;\n \n declare_clippy_lint! {\n     /// **What it does:**\n@@ -79,17 +80,15 @@ fn mirrored_exprs(\n             mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n         },\n         // Two arrays with mirrored contents\n-        (ExprKind::Array(left_exprs), ExprKind::Array(right_exprs)) => left_exprs\n-            .iter()\n-            .zip(right_exprs.iter())\n-            .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident)),\n+        (ExprKind::Array(left_exprs), ExprKind::Array(right_exprs)) => {\n+            iter::zip(*left_exprs, *right_exprs)\n+                .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+        }\n         // The two exprs are function calls.\n         // Check to see that the function itself and its arguments are mirrored\n         (ExprKind::Call(left_expr, left_args), ExprKind::Call(right_expr, right_args)) => {\n             mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n-                && left_args\n-                    .iter()\n-                    .zip(right_args.iter())\n+                && iter::zip(*left_args, *right_args)\n                     .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n         },\n         // The two exprs are method calls.\n@@ -100,16 +99,14 @@ fn mirrored_exprs(\n             ExprKind::MethodCall(right_segment, _, right_args, _),\n         ) => {\n             left_segment.ident == right_segment.ident\n-                && left_args\n-                    .iter()\n-                    .zip(right_args.iter())\n+                && iter::zip(*left_args, *right_args)\n                     .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n-        },\n+        }\n         // Two tuples with mirrored contents\n-        (ExprKind::Tup(left_exprs), ExprKind::Tup(right_exprs)) => left_exprs\n-            .iter()\n-            .zip(right_exprs.iter())\n-            .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident)),\n+        (ExprKind::Tup(left_exprs), ExprKind::Tup(right_exprs)) => {\n+            iter::zip(*left_exprs, *right_exprs)\n+                .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+        }\n         // Two binary ops, which are the same operation and which have mirrored arguments\n         (ExprKind::Binary(left_op, left_left, left_right), ExprKind::Binary(right_op, right_left, right_right)) => {\n             left_op.node == right_op.node\n@@ -146,9 +143,7 @@ fn mirrored_exprs(\n                 },\n             )),\n         ) => {\n-            (left_segments\n-                .iter()\n-                .zip(right_segments.iter())\n+            (iter::zip(*left_segments, *right_segments)\n                 .all(|(left, right)| left.ident == right.ident)\n                 && left_segments\n                     .iter()"}, {"sha": "8af10ebe777ea0ed4c2c9b54df7b6017558a9355", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -15,6 +15,7 @@ use rustc_span::symbol::Symbol;\n use std::cmp::Ordering::{self, Equal};\n use std::convert::TryInto;\n use std::hash::{Hash, Hasher};\n+use std::iter;\n \n /// A `LitKind`-like enum to fold constant `Expr`s into.\n #[derive(Debug, Clone)]\n@@ -139,12 +140,12 @@ impl Constant {\n             (&Self::F64(l), &Self::F64(r)) => l.partial_cmp(&r),\n             (&Self::F32(l), &Self::F32(r)) => l.partial_cmp(&r),\n             (&Self::Bool(ref l), &Self::Bool(ref r)) => Some(l.cmp(r)),\n-            (&Self::Tuple(ref l), &Self::Tuple(ref r)) | (&Self::Vec(ref l), &Self::Vec(ref r)) => l\n-                .iter()\n-                .zip(r.iter())\n-                .map(|(li, ri)| Self::partial_cmp(tcx, cmp_type, li, ri))\n-                .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n-                .unwrap_or_else(|| Some(l.len().cmp(&r.len()))),\n+            (&Self::Tuple(ref l), &Self::Tuple(ref r)) | (&Self::Vec(ref l), &Self::Vec(ref r)) => {\n+                iter::zip(l, r)\n+                    .map(|(li, ri)| Self::partial_cmp(tcx, cmp_type, li, ri))\n+                    .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n+                    .unwrap_or_else(|| Some(l.len().cmp(&r.len())))\n+            }\n             (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => {\n                 match Self::partial_cmp(tcx, cmp_type, lv, rv) {\n                     Some(Equal) => Some(ls.cmp(rs)),"}, {"sha": "b2655f8d797b1e67aa166d5cdb7d6c0ce873cfd5", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,5 +1,6 @@\n #![feature(box_patterns)]\n #![feature(in_band_lifetimes)]\n+#![feature(iter_zip)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(rustc_private)]\n #![recursion_limit = \"512\"]"}, {"sha": "268bc5b320533536ea5fba32dd5d7bcf8c0ce9bf", "filename": "src/tools/clippy/clippy_utils/src/numeric_literal.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b0edb7fddacd6a60a380c1ce59159de597ab270/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fnumeric_literal.rs?ref=9b0edb7fddacd6a60a380c1ce59159de597ab270", "patch": "@@ -1,4 +1,5 @@\n use rustc_ast::ast::{Lit, LitFloatType, LitIntType, LitKind};\n+use std::iter;\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n pub enum Radix {\n@@ -192,7 +193,7 @@ impl<'a> NumericLiteral<'a> {\n             }\n         }\n \n-        for (c, i) in digits.zip((0..group_size).cycle()) {\n+        for (c, i) in iter::zip(digits, (0..group_size).cycle()) {\n             if i == 0 {\n                 output.push('_');\n             }"}]}