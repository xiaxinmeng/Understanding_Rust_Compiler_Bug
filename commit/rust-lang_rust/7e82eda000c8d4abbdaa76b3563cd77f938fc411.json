{"sha": "7e82eda000c8d4abbdaa76b3563cd77f938fc411", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlODJlZGEwMDBjOGQ0YWJiZGFhNzZiMzU2M2NkNzdmOTM4ZmM0MTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-19T02:59:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-19T02:59:29Z"}, "message": "Auto merge of #56042 - petrochenkov:nuni, r=petrochenkov\n\n[nightly] resolve: Implement uniform paths 2.0\n\nForward-port of https://github.com/rust-lang/rust/pull/55884 to nightly.\n\nr? @ghost", "tree": {"sha": "b245a1f7b79958535f7d14d14039710e1d3b6991", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b245a1f7b79958535f7d14d14039710e1d3b6991"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e82eda000c8d4abbdaa76b3563cd77f938fc411", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e82eda000c8d4abbdaa76b3563cd77f938fc411", "html_url": "https://github.com/rust-lang/rust/commit/7e82eda000c8d4abbdaa76b3563cd77f938fc411", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e82eda000c8d4abbdaa76b3563cd77f938fc411/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9b791b3c0543120ed03e70600e6cf4f451b4124", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9b791b3c0543120ed03e70600e6cf4f451b4124", "html_url": "https://github.com/rust-lang/rust/commit/a9b791b3c0543120ed03e70600e6cf4f451b4124"}, {"sha": "38025e0dca8c2f049884eedc58792c4e321ed27c", "url": "https://api.github.com/repos/rust-lang/rust/commits/38025e0dca8c2f049884eedc58792c4e321ed27c", "html_url": "https://github.com/rust-lang/rust/commit/38025e0dca8c2f049884eedc58792c4e321ed27c"}], "stats": {"total": 3706, "additions": 2186, "deletions": 1520}, "files": [{"sha": "9979d7742291e50f35e6ce7cf2a1ea2cb89d4d27", "filename": "src/doc/unstable-book/src/language-features/extern-in-paths.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fextern-in-paths.md", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fextern-in-paths.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fextern-in-paths.md?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -11,8 +11,8 @@ introducing `extern crate` items, using keyword `extern`.\n \n For example, `extern::my_crat::a::b` will resolve to path `a::b` in crate `my_crate`.\n \n-`feature(extern_absolute_paths)` mode provides the same effect by resolving absolute paths like\n-`::my_crate::a::b` to paths from extern crates by default.\n+Absolute paths on 2018 edition (e.g. `::my_crate::a::b`) provide the same effect\n+and resolve to extern crates (built-in or passed with `--extern`).\n \n ```rust,ignore\n #![feature(extern_in_paths)]"}, {"sha": "50922ee601daf32d7dbfda2f391624cb08617020", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -128,14 +128,6 @@ impl PathResolution {\n     pub fn unresolved_segments(&self) -> usize {\n         self.unresolved_segments\n     }\n-\n-    pub fn kind_name(&self) -> &'static str {\n-        if self.unresolved_segments != 0 {\n-            \"associated item\"\n-        } else {\n-            self.base_def.kind_name()\n-        }\n-    }\n }\n \n /// Different kinds of symbols don't influence each other.\n@@ -269,27 +261,33 @@ impl NonMacroAttrKind {\n \n impl Def {\n     pub fn def_id(&self) -> DefId {\n+        self.opt_def_id().unwrap_or_else(|| {\n+            bug!(\"attempted .def_id() on invalid def: {:?}\", self)\n+        })\n+    }\n+\n+    pub fn opt_def_id(&self) -> Option<DefId> {\n         match *self {\n             Def::Fn(id) | Def::Mod(id) | Def::Static(id, _) |\n             Def::Variant(id) | Def::VariantCtor(id, ..) | Def::Enum(id) |\n             Def::TyAlias(id) | Def::TraitAlias(id) |\n             Def::AssociatedTy(id) | Def::TyParam(id) | Def::Struct(id) | Def::StructCtor(id, ..) |\n             Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n             Def::AssociatedConst(id) | Def::Macro(id, ..) |\n-            Def::Existential(id) | Def::AssociatedExistential(id) | Def::ForeignTy(id) |\n-            Def::SelfCtor(id) => {\n-                id\n+            Def::Existential(id) | Def::AssociatedExistential(id) | Def::ForeignTy(id) => {\n+                Some(id)\n             }\n \n             Def::Local(..) |\n             Def::Upvar(..) |\n             Def::Label(..)  |\n             Def::PrimTy(..) |\n             Def::SelfTy(..) |\n+            Def::SelfCtor(..) |\n             Def::ToolMod |\n             Def::NonMacroAttr(..) |\n             Def::Err => {\n-                bug!(\"attempted .def_id() on invalid def: {:?}\", self)\n+                None\n             }\n         }\n     }\n@@ -333,4 +331,13 @@ impl Def {\n             Def::Err => \"unresolved item\",\n         }\n     }\n+\n+    pub fn article(&self) -> &'static str {\n+        match *self {\n+            Def::AssociatedTy(..) | Def::AssociatedConst(..) | Def::AssociatedExistential(..) |\n+            Def::Enum(..) | Def::Existential(..) | Def::Err => \"an\",\n+            Def::Macro(.., macro_kind) => macro_kind.article(),\n+            _ => \"a\",\n+        }\n+    }\n }"}, {"sha": "319d63f66c465e6184f63e8ddc905abbd2ce0767", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -225,8 +225,8 @@ pub struct DefId {\n \n impl fmt::Debug for DefId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"DefId({:?}/{}:{}\",\n-               self.krate.index(),\n+        write!(f, \"DefId({}/{}:{}\",\n+               self.krate,\n                self.index.address_space().index(),\n                self.index.as_array_index())?;\n "}, {"sha": "282b5d13e2c61067601c6705f7b62d1a7b4b042c", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -80,7 +80,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 self.check_def_id(def.def_id());\n             }\n             _ if self.in_pat => (),\n-            Def::PrimTy(..) | Def::SelfTy(..) |\n+            Def::PrimTy(..) | Def::SelfTy(..) | Def::SelfCtor(..) |\n             Def::Local(..) | Def::Upvar(..) => {}\n             Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n                 if let Some(enum_id) = self.tcx.parent_def_id(variant_id) {"}, {"sha": "543d1053b55e60787b613258de7b13bcdf781398", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -781,10 +781,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n     fn visit_path(&mut self, path: &'tcx hir::Path, id: hir::HirId) {\n         let id = self.tcx.hir.hir_to_node_id(id);\n-        match path.def {\n-            Def::Local(..) | Def::Upvar(..) | Def::SelfCtor(..) |\n-            Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => {}\n-            _ => self.tcx.check_stability(path.def.def_id(), Some(id), path.span)\n+        if let Some(def_id) = path.def.opt_def_id() {\n+            self.tcx.check_stability(def_id, Some(id), path.span)\n         }\n         intravisit::walk_path(self, path)\n     }"}, {"sha": "bafabe4e9972cf474ff4752f02a89107033730c1", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -298,7 +298,8 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             let label_msg = match pat.node {\n                 PatKind::Path(hir::QPath::Resolved(None, ref path))\n                         if path.segments.len() == 1 && path.segments[0].args.is_none() => {\n-                    format!(\"interpreted as a {} pattern, not new variable\", path.def.kind_name())\n+                    format!(\"interpreted as {} {} pattern, not new variable\",\n+                            path.def.article(), path.def.kind_name())\n                 }\n                 _ => format!(\"pattern `{}` not covered\", pattern_string),\n             };"}, {"sha": "5f8c7daea6e9bbc13024836076bf9449ec362da1", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -361,9 +361,11 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             let def_id = self.tcx.hir.local_def_id(id);\n             if let Some(exports) = self.tcx.module_exports(def_id) {\n                 for export in exports.iter() {\n-                    if let Some(node_id) = self.tcx.hir.as_local_node_id(export.def.def_id()) {\n-                        if export.vis == ty::Visibility::Public {\n-                            self.update(node_id, Some(AccessLevel::Exported));\n+                    if export.vis == ty::Visibility::Public {\n+                        if let Some(def_id) = export.def.opt_def_id() {\n+                            if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                                self.update(node_id, Some(AccessLevel::Exported));\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "72fe7355e4c7ca6e2e7d39b01ff4c7ba75e35019", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 39, "deletions": 151, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -116,143 +116,35 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         id: NodeId,\n         parent_prefix: &[Segment],\n         nested: bool,\n-        mut uniform_paths_canary_emitted: bool,\n         // The whole `use` item\n         parent_scope: ParentScope<'a>,\n         item: &Item,\n         vis: ty::Visibility,\n         root_span: Span,\n     ) {\n-        debug!(\"build_reduced_graph_for_use_tree(parent_prefix={:?}, \\\n-                uniform_paths_canary_emitted={}, \\\n-                use_tree={:?}, nested={})\",\n-               parent_prefix, uniform_paths_canary_emitted, use_tree, nested);\n-\n-        let uniform_paths =\n-            self.session.rust_2018() &&\n-            self.session.features_untracked().uniform_paths;\n-\n-        let prefix_iter = || parent_prefix.iter().cloned()\n-            .chain(use_tree.prefix.segments.iter().map(|seg| seg.into()));\n-        let prefix_start = prefix_iter().next();\n-        let starts_with_non_keyword = prefix_start.map_or(false, |seg| {\n-            !seg.ident.is_path_segment_keyword()\n-        });\n-\n-        // Imports are resolved as global by default, prepend `CrateRoot`,\n-        // unless `#![feature(uniform_paths)]` is enabled.\n-        let inject_crate_root =\n-            !uniform_paths &&\n-            match use_tree.kind {\n-                // HACK(eddyb) special-case `use *` to mean `use ::*`.\n-                ast::UseTreeKind::Glob if prefix_start.is_none() => true,\n-                _ => starts_with_non_keyword,\n-            };\n-        let root = if inject_crate_root {\n-            let span = use_tree.prefix.span.shrink_to_lo();\n-            Some(Segment::from_ident(Ident::new(keywords::CrateRoot.name(), span)))\n+        debug!(\"build_reduced_graph_for_use_tree(parent_prefix={:?}, use_tree={:?}, nested={})\",\n+               parent_prefix, use_tree, nested);\n+\n+        let mut prefix_iter = parent_prefix.iter().cloned()\n+            .chain(use_tree.prefix.segments.iter().map(|seg| seg.into())).peekable();\n+\n+        // On 2015 edition imports are resolved as crate-relative by default,\n+        // so prefixes are prepended with crate root segment if necessary.\n+        // The root is prepended lazily, when the first non-empty prefix or terminating glob\n+        // appears, so imports in braced groups can have roots prepended independently.\n+        let is_glob = if let ast::UseTreeKind::Glob = use_tree.kind { true } else { false };\n+        let crate_root = if !self.session.rust_2018() &&\n+                prefix_iter.peek().map_or(is_glob, |seg| !seg.ident.is_path_segment_keyword()) {\n+            Some(Segment::from_ident(Ident::new(\n+                keywords::CrateRoot.name(), use_tree.prefix.span.shrink_to_lo()\n+            )))\n         } else {\n             None\n         };\n \n-        let prefix: Vec<_> = root.into_iter().chain(prefix_iter()).collect();\n-\n+        let prefix = crate_root.into_iter().chain(prefix_iter).collect::<Vec<_>>();\n         debug!(\"build_reduced_graph_for_use_tree: prefix={:?}\", prefix);\n \n-        // `#[feature(uniform_paths)]` allows an unqualified import path,\n-        // e.g. `use x::...;` to resolve not just globally (`use ::x::...;`)\n-        // but also relatively (`use self::x::...;`). To catch ambiguities\n-        // that might arise from both of these being available and resolution\n-        // silently picking one of them, an artificial `use self::x as _;`\n-        // import is injected as a \"canary\", and an error is emitted if it\n-        // successfully resolves while an `x` external crate exists.\n-        //\n-        // For each block scope around the `use` item, one special canary\n-        // import of the form `use x as _;` is also injected, having its\n-        // parent set to that scope; `resolve_imports` will only resolve\n-        // it within its appropriate scope; if any of them successfully\n-        // resolve, an ambiguity error is emitted, since the original\n-        // import can't see the item in the block scope (`self::x` only\n-        // looks in the enclosing module), but a non-`use` path could.\n-        //\n-        // Additionally, the canary might be able to catch limitations of the\n-        // current implementation, where `::x` may be chosen due to `self::x`\n-        // not existing, but `self::x` could appear later, from macro expansion.\n-        //\n-        // NB. The canary currently only errors if the `x::...` path *could*\n-        // resolve as a relative path through the extern crate, i.e. `x` is\n-        // in `extern_prelude`, *even though* `::x` might still forcefully\n-        // load a non-`extern_prelude` crate.\n-        // While always producing an ambiguity errors if `self::x` exists and\n-        // a crate *could* be loaded, would be more conservative, imports for\n-        // local modules named `test` (or less commonly, `syntax` or `log`),\n-        // would need to be qualified (e.g. `self::test`), which is considered\n-        // ergonomically unacceptable.\n-        let emit_uniform_paths_canary =\n-            !uniform_paths_canary_emitted &&\n-            self.session.rust_2018() &&\n-            starts_with_non_keyword;\n-        if emit_uniform_paths_canary {\n-            let source = prefix_start.unwrap();\n-\n-            // Helper closure to emit a canary with the given base path.\n-            let emit = |this: &mut Self, base: Option<Segment>| {\n-                let subclass = SingleImport {\n-                    target: Ident {\n-                        name: keywords::Underscore.name().gensymed(),\n-                        span: source.ident.span,\n-                    },\n-                    source: source.ident,\n-                    result: PerNS {\n-                        type_ns: Cell::new(Err(Undetermined)),\n-                        value_ns: Cell::new(Err(Undetermined)),\n-                        macro_ns: Cell::new(Err(Undetermined)),\n-                    },\n-                    type_ns_only: false,\n-                };\n-                this.add_import_directive(\n-                    base.into_iter().collect(),\n-                    subclass,\n-                    source.ident.span,\n-                    id,\n-                    root_span,\n-                    item.id,\n-                    ty::Visibility::Invisible,\n-                    parent_scope.clone(),\n-                    true, // is_uniform_paths_canary\n-                );\n-            };\n-\n-            // A single simple `self::x` canary.\n-            emit(self, Some(Segment {\n-                ident: Ident {\n-                    name: keywords::SelfValue.name(),\n-                    span: source.ident.span,\n-                },\n-                id: source.id\n-            }));\n-\n-            // One special unprefixed canary per block scope around\n-            // the import, to detect items unreachable by `self::x`.\n-            let orig_current_module = self.current_module;\n-            let mut span = source.ident.span.modern();\n-            loop {\n-                match self.current_module.kind {\n-                    ModuleKind::Block(..) => emit(self, None),\n-                    ModuleKind::Def(..) => break,\n-                }\n-                match self.hygienic_lexical_parent(self.current_module, &mut span) {\n-                    Some(module) => {\n-                        self.current_module = module;\n-                    }\n-                    None => break,\n-                }\n-            }\n-            self.current_module = orig_current_module;\n-\n-            uniform_paths_canary_emitted = true;\n-        }\n-\n         let empty_for_self = |prefix: &[Segment]| {\n             prefix.is_empty() ||\n             prefix.len() == 1 && prefix[0].ident.name == keywords::CrateRoot.name()\n@@ -350,7 +242,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     item.id,\n                     vis,\n                     parent_scope,\n-                    false, // is_uniform_paths_canary\n                 );\n             }\n             ast::UseTreeKind::Glob => {\n@@ -367,7 +258,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     item.id,\n                     vis,\n                     parent_scope,\n-                    false, // is_uniform_paths_canary\n                 );\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n@@ -396,7 +286,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 for &(ref tree, id) in items {\n                     self.build_reduced_graph_for_use_tree(\n                         // This particular use tree\n-                        tree, id, &prefix, true, uniform_paths_canary_emitted,\n+                        tree, id, &prefix, true,\n                         // The whole `use` item\n                         parent_scope.clone(), item, vis, root_span,\n                     );\n@@ -420,7 +310,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     };\n                     self.build_reduced_graph_for_use_tree(\n                         // This particular use tree\n-                        &tree, id, &prefix, true, uniform_paths_canary_emitted,\n+                        &tree, id, &prefix, true,\n                         // The whole `use` item\n                         parent_scope.clone(), item, ty::Visibility::Invisible, root_span,\n                     );\n@@ -441,7 +331,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             ItemKind::Use(ref use_tree) => {\n                 self.build_reduced_graph_for_use_tree(\n                     // This particular use tree\n-                    use_tree, item.id, &[], false, false,\n+                    use_tree, item.id, &[], false,\n                     // The whole `use` item\n                     parent_scope, item, vis, use_tree.span,\n                 );\n@@ -459,6 +349,23 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 let used = self.process_legacy_macro_imports(item, module, &parent_scope);\n                 let binding =\n                     (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.arenas);\n+                let directive = self.arenas.alloc_import_directive(ImportDirective {\n+                    root_id: item.id,\n+                    id: item.id,\n+                    parent_scope,\n+                    imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n+                    subclass: ImportDirectiveSubclass::ExternCrate {\n+                        source: orig_name,\n+                        target: ident,\n+                    },\n+                    root_span: item.span,\n+                    span: item.span,\n+                    module_path: Vec::new(),\n+                    vis: Cell::new(vis),\n+                    used: Cell::new(used),\n+                });\n+                self.potentially_unused_imports.push(directive);\n+                let imported_binding = self.import(binding, directive);\n                 if ptr::eq(self.current_module, self.graph_root) {\n                     if let Some(entry) = self.extern_prelude.get(&ident.modern()) {\n                         if expansion != Mark::root() && orig_name.is_some() &&\n@@ -473,29 +380,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         extern_crate_item: None,\n                         introduced_by_item: true,\n                     });\n-                    entry.extern_crate_item = Some(binding);\n+                    entry.extern_crate_item = Some(imported_binding);\n                     if orig_name.is_some() {\n                         entry.introduced_by_item = true;\n                     }\n                 }\n-                let directive = self.arenas.alloc_import_directive(ImportDirective {\n-                    root_id: item.id,\n-                    id: item.id,\n-                    parent_scope,\n-                    imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n-                    subclass: ImportDirectiveSubclass::ExternCrate {\n-                        source: orig_name,\n-                        target: ident,\n-                    },\n-                    root_span: item.span,\n-                    span: item.span,\n-                    module_path: Vec::new(),\n-                    vis: Cell::new(vis),\n-                    used: Cell::new(used),\n-                    is_uniform_paths_canary: false,\n-                });\n-                self.potentially_unused_imports.push(directive);\n-                let imported_binding = self.import(binding, directive);\n                 self.define(parent, ident, TypeNS, imported_binding);\n             }\n \n@@ -905,7 +794,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             module_path: Vec::new(),\n             vis: Cell::new(ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))),\n             used: Cell::new(false),\n-            is_uniform_paths_canary: false,\n         });\n \n         let allow_shadowing = parent_scope.expansion == Mark::root();\n@@ -923,6 +811,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     MacroNS,\n+                    None,\n                     false,\n                     span,\n                 );\n@@ -977,7 +866,6 @@ impl<'a, 'b, 'cl> BuildReducedGraphVisitor<'a, 'b, 'cl> {\n         let invocation = self.resolver.invocations[&mark];\n         invocation.module.set(self.resolver.current_module);\n         invocation.parent_legacy_scope.set(self.current_legacy_scope);\n-        invocation.output_legacy_scope.set(self.current_legacy_scope);\n         invocation\n     }\n }"}, {"sha": "2681295cf9bf17b181b42fbf11b3becb701dbbb3", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1253,7 +1253,7 @@ Erroneous code example:\n \n ```compile_fail,E0433\n let map = HashMap::new();\n-// error: failed to resolve. Use of undeclared type or module `HashMap`\n+// error: failed to resolve: use of undeclared type or module `HashMap`\n ```\n \n Please verify you didn't misspell the type/module's name or that you didn't"}, {"sha": "263d23d133e1cf2627340d59035e174b2bcbe8c2", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 38, "deletions": 48, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -11,54 +11,47 @@\n use {CrateLint, PathResult, Segment};\n use macros::ParentScope;\n \n-use std::collections::BTreeSet;\n-\n-use syntax::ast::Ident;\n-use syntax::symbol::{keywords, Symbol};\n+use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n use resolve_imports::ImportResolver;\n+use std::cmp::Reverse;\n \n impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     /// Add suggestions for a path that cannot be resolved.\n     pub(crate) fn make_path_suggestion(\n         &mut self,\n         span: Span,\n-        path: Vec<Segment>,\n+        mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         debug!(\"make_path_suggestion: span={:?} path={:?}\", span, path);\n-        // If we don't have a path to suggest changes to, then return.\n-        if path.is_empty() {\n-            return None;\n-        }\n-\n-        // Check whether a ident is a path segment that is not root.\n-        let is_special = |ident: Ident| ident.is_path_segment_keyword() &&\n-                                        ident.name != keywords::CrateRoot.name();\n \n         match (path.get(0), path.get(1)) {\n-            // Make suggestions that require at least two non-special path segments.\n-            (Some(fst), Some(snd)) if !is_special(fst.ident) && !is_special(snd.ident) => {\n-                debug!(\"make_path_suggestion: fst={:?} snd={:?}\", fst, snd);\n-\n-                self.make_missing_self_suggestion(span, path.clone(), parent_scope)\n-                    .or_else(|| self.make_missing_crate_suggestion(span, path.clone(),\n-                                                                   parent_scope))\n-                    .or_else(|| self.make_missing_super_suggestion(span, path.clone(),\n-                                                                   parent_scope))\n-                    .or_else(|| self.make_external_crate_suggestion(span, path, parent_scope))\n-            },\n-            _ => None,\n+            // `{{root}}::ident::...` on both editions.\n+            // On 2015 `{{root}}` is usually added implicitly.\n+            (Some(fst), Some(snd)) if fst.ident.name == keywords::CrateRoot.name() &&\n+                                      !snd.ident.is_path_segment_keyword() => {}\n+            // `ident::...` on 2018\n+            (Some(fst), _) if self.session.rust_2018() && !fst.ident.is_path_segment_keyword() => {\n+                // Insert a placeholder that's later replaced by `self`/`super`/etc.\n+                path.insert(0, Segment::from_ident(keywords::Invalid.ident()));\n+            }\n+            _ => return None,\n         }\n+\n+        self.make_missing_self_suggestion(span, path.clone(), parent_scope)\n+            .or_else(|| self.make_missing_crate_suggestion(span, path.clone(), parent_scope))\n+            .or_else(|| self.make_missing_super_suggestion(span, path.clone(), parent_scope))\n+            .or_else(|| self.make_external_crate_suggestion(span, path, parent_scope))\n     }\n \n     /// Suggest a missing `self::` if that resolves to an correct module.\n     ///\n     /// ```\n     ///    |\n     /// LL | use foo::Bar;\n-    ///    |     ^^^ Did you mean `self::foo`?\n+    ///    |     ^^^ did you mean `self::foo`?\n     /// ```\n     fn make_missing_self_suggestion(\n         &mut self,\n@@ -68,7 +61,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = keywords::SelfValue.name();\n-        let result = self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n+        let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((path, None))\n@@ -82,7 +75,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     /// ```\n     ///    |\n     /// LL | use foo::Bar;\n-    ///    |     ^^^ Did you mean `crate::foo`?\n+    ///    |     ^^^ did you mean `crate::foo`?\n     /// ```\n     fn make_missing_crate_suggestion(\n         &mut self,\n@@ -92,7 +85,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = keywords::Crate.name();\n-        let result = self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n+        let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((\n@@ -113,7 +106,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     /// ```\n     ///    |\n     /// LL | use foo::Bar;\n-    ///    |     ^^^ Did you mean `super::foo`?\n+    ///    |     ^^^ did you mean `super::foo`?\n     /// ```\n     fn make_missing_super_suggestion(\n         &mut self,\n@@ -123,7 +116,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = keywords::Super.name();\n-        let result = self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n+        let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((path, None))\n@@ -137,7 +130,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     /// ```\n     ///    |\n     /// LL | use foobar::Baz;\n-    ///    |     ^^^^^^ Did you mean `baz::foobar`?\n+    ///    |     ^^^^^^ did you mean `baz::foobar`?\n     /// ```\n     ///\n     /// Used when importing a submodule of an external crate but missing that crate's\n@@ -148,24 +141,21 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n-        // Need to clone else we can't call `resolve_path` without a borrow error. We also store\n-        // into a `BTreeMap` so we can get consistent ordering (and therefore the same diagnostic)\n-        // each time.\n-        let external_crate_names: BTreeSet<Symbol> = self.resolver.extern_prelude\n-            .iter().map(|(ident, _)| ident.name).collect();\n+        if !self.session.rust_2018() {\n+            return None;\n+        }\n \n-        // Insert a new path segment that we can replace.\n-        let new_path_segment = path[0].clone();\n-        path.insert(1, new_path_segment);\n+        // Sort extern crate names in reverse order to get\n+        // 1) some consistent ordering for emitted dignostics and\n+        // 2) `std` suggestions before `core` suggestions.\n+        let mut extern_crate_names =\n+            self.resolver.extern_prelude.iter().map(|(ident, _)| ident.name).collect::<Vec<_>>();\n+        extern_crate_names.sort_by_key(|name| Reverse(name.as_str()));\n \n-        // Iterate in reverse so that we start with crates at the end of the alphabet. This means\n-        // that we'll always get `std` before `core`.\n-        for name in external_crate_names.iter().rev() {\n-            // Replace the first after root (a placeholder we inserted) with a crate name\n-            // and check if that is valid.\n-            path[1].ident.name = *name;\n-            let result =\n-                self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n+        for name in extern_crate_names.into_iter() {\n+            // Replace first ident with a crate name and check if that is valid.\n+            path[0].ident.name = name;\n+            let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n             debug!(\"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                     name, path, result);\n             if let PathResult::Module(..) = result {"}, {"sha": "7b2d1d4a3d53f6c61c7b1178722e62fd387a4e09", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 297, "deletions": 111, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -97,6 +97,11 @@ fn is_known_tool(name: Name) -> bool {\n     [\"clippy\", \"rustfmt\"].contains(&&*name.as_str())\n }\n \n+enum Weak {\n+    Yes,\n+    No,\n+}\n+\n /// A free importable items suggested in case of resolution failure.\n struct ImportSuggestion {\n     path: Path,\n@@ -371,7 +376,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n         }\n         ResolutionError::FailedToResolve(msg) => {\n             let mut err = struct_span_err!(resolver.session, span, E0433,\n-                                           \"failed to resolve. {}\", msg);\n+                                           \"failed to resolve: {}\", msg);\n             err.span_label(span, msg);\n             err\n         }\n@@ -391,14 +396,13 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n             err\n         }\n         ResolutionError::BindingShadowsSomethingUnacceptable(what_binding, name, binding) => {\n-            let shadows_what = PathResolution::new(binding.def()).kind_name();\n-            let mut err = struct_span_err!(resolver.session,\n-                                           span,\n-                                           E0530,\n-                                           \"{}s cannot shadow {}s\", what_binding, shadows_what);\n-            err.span_label(span, format!(\"cannot be named the same as a {}\", shadows_what));\n+            let shadows_what = binding.descr();\n+            let mut err = struct_span_err!(resolver.session, span, E0530, \"{}s cannot shadow {}s\",\n+                                           what_binding, shadows_what);\n+            err.span_label(span, format!(\"cannot be named the same as {} {}\",\n+                                         binding.article(), shadows_what));\n             let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n-            let msg = format!(\"a {} `{}` is {} here\", shadows_what, name, participle);\n+            let msg = format!(\"the {} `{}` is {} here\", shadows_what, name, participle);\n             err.span_label(binding.span, msg);\n             err\n         }\n@@ -993,15 +997,34 @@ impl<'a> LexicalScopeBinding<'a> {\n     }\n }\n \n+\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+enum UniformRootKind {\n+    CurrentScope,\n+    ExternPrelude,\n+}\n+\n #[derive(Copy, Clone, Debug)]\n-pub enum ModuleOrUniformRoot<'a> {\n+enum ModuleOrUniformRoot<'a> {\n     /// Regular module.\n     Module(Module<'a>),\n \n-    /// The `{{root}}` (`CrateRoot` aka \"global\") / `extern` initial segment\n-    /// in which external crates resolve, and also `crate` (only in `{{root}}`,\n-    /// but *not* `extern`), in the Rust 2018 edition.\n-    UniformRoot(Name),\n+    /// This \"virtual module\" denotes either resolution in extern prelude\n+    /// for paths starting with `::` on 2018 edition or `extern::`,\n+    /// or resolution in current scope for single-segment imports.\n+    UniformRoot(UniformRootKind),\n+}\n+\n+impl<'a> PartialEq for ModuleOrUniformRoot<'a> {\n+    fn eq(&self, other: &Self) -> bool {\n+        match (*self, *other) {\n+            (ModuleOrUniformRoot::Module(lhs), ModuleOrUniformRoot::Module(rhs)) =>\n+                ptr::eq(lhs, rhs),\n+            (ModuleOrUniformRoot::UniformRoot(lhs), ModuleOrUniformRoot::UniformRoot(rhs)) =>\n+                lhs == rhs,\n+            _ => false,\n+        }\n+    }\n }\n \n #[derive(Clone, Debug)]\n@@ -1045,9 +1068,10 @@ pub struct ModuleData<'a> {\n     normal_ancestor_id: DefId,\n \n     resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n-    legacy_macro_resolutions: RefCell<Vec<(Ident, MacroKind, ParentScope<'a>,\n-                                           Option<&'a NameBinding<'a>>)>>,\n-    macro_resolutions: RefCell<Vec<(Vec<Segment>, ParentScope<'a>, Span)>>,\n+    single_segment_macro_resolutions: RefCell<Vec<(Ident, MacroKind, ParentScope<'a>,\n+                                                   Option<&'a NameBinding<'a>>)>>,\n+    multi_segment_macro_resolutions: RefCell<Vec<(Vec<Segment>, Span, MacroKind, ParentScope<'a>,\n+                                                  Option<Def>)>>,\n     builtin_attrs: RefCell<Vec<(Ident, ParentScope<'a>)>>,\n \n     // Macro invocations that can expand into items in this module.\n@@ -1085,8 +1109,8 @@ impl<'a> ModuleData<'a> {\n             kind,\n             normal_ancestor_id,\n             resolutions: Default::default(),\n-            legacy_macro_resolutions: RefCell::new(Vec::new()),\n-            macro_resolutions: RefCell::new(Vec::new()),\n+            single_segment_macro_resolutions: RefCell::new(Vec::new()),\n+            multi_segment_macro_resolutions: RefCell::new(Vec::new()),\n             builtin_attrs: RefCell::new(Vec::new()),\n             unresolved_invocations: Default::default(),\n             no_implicit_prelude: false,\n@@ -1195,6 +1219,7 @@ enum NameBindingKind<'a> {\n         used: Cell<bool>,\n     },\n     Ambiguity {\n+        kind: AmbiguityKind,\n         b1: &'a NameBinding<'a>,\n         b2: &'a NameBinding<'a>,\n     }\n@@ -1212,10 +1237,61 @@ struct UseError<'a> {\n     better: bool,\n }\n \n+#[derive(Clone, Copy, PartialEq, Debug)]\n+enum AmbiguityKind {\n+    Import,\n+    BuiltinAttr,\n+    DeriveHelper,\n+    LegacyHelperVsPrelude,\n+    LegacyVsModern,\n+    GlobVsOuter,\n+    GlobVsGlob,\n+    GlobVsExpanded,\n+    MoreExpandedVsOuter,\n+}\n+\n+impl AmbiguityKind {\n+    fn descr(self) -> &'static str {\n+        match self {\n+            AmbiguityKind::Import =>\n+                \"name vs any other name during import resolution\",\n+            AmbiguityKind::BuiltinAttr =>\n+                \"built-in attribute vs any other name\",\n+            AmbiguityKind::DeriveHelper =>\n+                \"derive helper attribute vs any other name\",\n+            AmbiguityKind::LegacyHelperVsPrelude =>\n+                \"legacy plugin helper attribute vs name from prelude\",\n+            AmbiguityKind::LegacyVsModern =>\n+                \"`macro_rules` vs non-`macro_rules` from other module\",\n+            AmbiguityKind::GlobVsOuter =>\n+                \"glob import vs any other name from outer scope during import/macro resolution\",\n+            AmbiguityKind::GlobVsGlob =>\n+                \"glob import vs glob import in the same module\",\n+            AmbiguityKind::GlobVsExpanded =>\n+                \"glob import vs macro-expanded name in the same \\\n+                 module during import/macro resolution\",\n+            AmbiguityKind::MoreExpandedVsOuter =>\n+                \"macro-expanded name vs less macro-expanded name \\\n+                 from outer scope during import/macro resolution\",\n+        }\n+    }\n+}\n+\n+/// Miscellaneous bits of metadata for better ambiguity error reporting.\n+#[derive(Clone, Copy, PartialEq)]\n+enum AmbiguityErrorMisc {\n+    SuggestSelf,\n+    FromPrelude,\n+    None,\n+}\n+\n struct AmbiguityError<'a> {\n+    kind: AmbiguityKind,\n     ident: Ident,\n     b1: &'a NameBinding<'a>,\n     b2: &'a NameBinding<'a>,\n+    misc1: AmbiguityErrorMisc,\n+    misc2: AmbiguityErrorMisc,\n }\n \n impl<'a> NameBinding<'a> {\n@@ -1268,6 +1344,9 @@ impl<'a> NameBinding<'a> {\n                     subclass: ImportDirectiveSubclass::ExternCrate { .. }, ..\n                 }, ..\n             } => true,\n+            NameBindingKind::Module(\n+                &ModuleData { kind: ModuleKind::Def(Def::Mod(def_id), _), .. }\n+            ) => def_id.index == CRATE_DEF_INDEX,\n             _ => false,\n         }\n     }\n@@ -1313,6 +1392,10 @@ impl<'a> NameBinding<'a> {\n         if self.is_extern_crate() { \"extern crate\" } else { self.def().kind_name() }\n     }\n \n+    fn article(&self) -> &'static str {\n+        if self.is_extern_crate() { \"an\" } else { self.def().article() }\n+    }\n+\n     // Suppose that we resolved macro invocation with `invoc_parent_expansion` to binding `binding`\n     // at some expansion round `max(invoc, binding)` when they both emerged from macros.\n     // Then this function returns `true` if `self` may emerge from a macro *after* that\n@@ -1423,6 +1506,9 @@ pub struct Resolver<'a, 'b: 'a> {\n     /// The current self item if inside an ADT (used for better errors).\n     current_self_item: Option<NodeId>,\n \n+    /// FIXME: Refactor things so that this is passed through arguments and not resolver.\n+    last_import_segment: bool,\n+\n     /// The idents for the primitive types.\n     primitive_type_table: PrimitiveTypeTable,\n \n@@ -1661,8 +1747,8 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         let segments = &path.segments;\n         let path = Segment::from_path(&path);\n         // FIXME (Manishearth): Intra doc links won't get warned of epoch changes\n-        let def = match self.resolve_path_without_parent_scope(None, &path, Some(namespace),\n-                                                               true, span, CrateLint::No) {\n+        let def = match self.resolve_path_without_parent_scope(&path, Some(namespace), true,\n+                                                               span, CrateLint::No) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n                 module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n@@ -1772,6 +1858,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             current_trait_ref: None,\n             current_self_type: None,\n             current_self_item: None,\n+            last_import_segment: false,\n \n             primitive_type_table: PrimitiveTypeTable::new(),\n \n@@ -1873,23 +1960,35 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         self.arenas.alloc_module(module)\n     }\n \n-    fn record_use(&mut self, ident: Ident, ns: Namespace, binding: &'a NameBinding<'a>)\n-                  -> bool /* true if an error was reported */ {\n-        match binding.kind {\n-            NameBindingKind::Import { directive, binding, ref used }\n-                    if !used.get() => {\n+    fn record_use(&mut self, ident: Ident, ns: Namespace,\n+                  used_binding: &'a NameBinding<'a>, is_lexical_scope: bool) {\n+        match used_binding.kind {\n+            NameBindingKind::Import { directive, binding, ref used } if !used.get() => {\n+                // Avoid marking `extern crate` items that refer to a name from extern prelude,\n+                // but not introduce it, as used if they are accessed from lexical scope.\n+                if is_lexical_scope {\n+                    if let Some(entry) = self.extern_prelude.get(&ident.modern()) {\n+                        if let Some(crate_item) = entry.extern_crate_item {\n+                            if ptr::eq(used_binding, crate_item) && !entry.introduced_by_item {\n+                                return;\n+                            }\n+                        }\n+                    }\n+                }\n                 used.set(true);\n                 directive.used.set(true);\n                 self.used_imports.insert((directive.id, ns));\n                 self.add_to_glob_map(directive.id, ident);\n-                self.record_use(ident, ns, binding)\n+                self.record_use(ident, ns, binding, false);\n             }\n-            NameBindingKind::Import { .. } => false,\n-            NameBindingKind::Ambiguity { b1, b2 } => {\n-                self.ambiguity_errors.push(AmbiguityError { ident, b1, b2 });\n-                true\n+            NameBindingKind::Ambiguity { kind, b1, b2 } => {\n+                self.ambiguity_errors.push(AmbiguityError {\n+                    kind, ident, b1, b2,\n+                    misc1: AmbiguityErrorMisc::None,\n+                    misc2: AmbiguityErrorMisc::None,\n+                });\n             }\n-            _ => false\n+            _ => {}\n         }\n     }\n \n@@ -1960,7 +2059,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n-                false,\n                 record_used,\n                 path_span,\n             );\n@@ -1991,7 +2089,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n-                false,\n                 record_used,\n                 path_span,\n             );\n@@ -2024,7 +2121,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n             if ns == TypeNS && is_known_tool(ident.name) {\n                 let binding = (Def::ToolMod, ty::Visibility::Public,\n-                               ident.span, Mark::root()).to_name_binding(self.arenas);\n+                               DUMMY_SP, Mark::root()).to_name_binding(self.arenas);\n                 return Some(LexicalScopeBinding::Item(binding));\n             }\n             if let Some(prelude) = self.prelude {\n@@ -2033,7 +2130,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     ident,\n                     ns,\n                     false,\n-                    false,\n                     path_span,\n                 ) {\n                     return Some(LexicalScopeBinding::Item(binding));\n@@ -2093,23 +2189,31 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         None\n     }\n \n-    fn resolve_ident_in_module(&mut self,\n-                               module: ModuleOrUniformRoot<'a>,\n-                               mut ident: Ident,\n-                               ns: Namespace,\n-                               record_used: bool,\n-                               span: Span)\n-                               -> Result<&'a NameBinding<'a>, Determinacy> {\n+    fn resolve_ident_in_module(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        mut ident: Ident,\n+        ns: Namespace,\n+        parent_scope: Option<&ParentScope<'a>>,\n+        record_used: bool,\n+        path_span: Span\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n         ident.span = ident.span.modern();\n         let orig_current_module = self.current_module;\n-        if let ModuleOrUniformRoot::Module(module) = module {\n-            if let Some(def) = ident.span.adjust(module.expansion) {\n-                self.current_module = self.macro_def_scope(def);\n+        match module {\n+            ModuleOrUniformRoot::Module(module) => {\n+                if let Some(def) = ident.span.adjust(module.expansion) {\n+                    self.current_module = self.macro_def_scope(def);\n+                }\n+            }\n+            ModuleOrUniformRoot::UniformRoot(UniformRootKind::ExternPrelude) => {\n+                ident.span.adjust(Mark::root());\n             }\n+            _ => {}\n         }\n-        let result = self.resolve_ident_in_module_unadjusted(\n-            module, ident, ns, false, record_used, span,\n-        );\n+        let result = self.resolve_ident_in_module_unadjusted_ext(\n+            module, ident, ns, parent_scope, false, record_used, path_span,\n+        ).map_err(|(determinacy, _)| determinacy);\n         self.current_module = orig_current_module;\n         result\n     }\n@@ -2250,6 +2354,36 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         });\n     }\n \n+    fn future_proof_import(&mut self, use_tree: &ast::UseTree) {\n+        if !self.session.rust_2018() {\n+            return;\n+        }\n+\n+        let segments = &use_tree.prefix.segments;\n+        if !segments.is_empty() {\n+            let ident = segments[0].ident;\n+            if ident.is_path_segment_keyword() {\n+                return;\n+            }\n+\n+            let nss = match use_tree.kind {\n+                ast::UseTreeKind::Simple(..) if segments.len() == 1 => &[TypeNS, ValueNS][..],\n+                _ => &[TypeNS],\n+            };\n+            for &ns in nss {\n+                if let Some(LexicalScopeBinding::Def(..)) =\n+                        self.resolve_ident_in_lexical_scope(ident, ns, None, use_tree.prefix.span) {\n+                    let what = if ns == TypeNS { \"type parameters\" } else { \"local variables\" };\n+                    self.session.span_err(ident.span, &format!(\"imports cannot refer to {}\", what));\n+                }\n+            }\n+        } else if let ast::UseTreeKind::Nested(use_trees) = &use_tree.kind {\n+            for (use_tree, _) in use_trees {\n+                self.future_proof_import(use_tree);\n+            }\n+        }\n+    }\n+\n     fn resolve_item(&mut self, item: &Item) {\n         let name = item.ident.name;\n         debug!(\"(resolving item) resolving {}\", name);\n@@ -2343,7 +2477,11 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 });\n             }\n \n-            ItemKind::Use(..) | ItemKind::ExternCrate(..) |\n+            ItemKind::Use(ref use_tree) => {\n+                self.future_proof_import(use_tree);\n+            }\n+\n+            ItemKind::ExternCrate(..) |\n             ItemKind::MacroDef(..) | ItemKind::GlobalAsm(..) => {\n                 // do nothing, these are just around to be encoded\n             }\n@@ -2466,7 +2604,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 let span = trait_ref.path.span;\n                 if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n                     self.resolve_path_without_parent_scope(\n-                        None,\n                         &path,\n                         Some(TypeNS),\n                         false,\n@@ -2607,6 +2744,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n+                None,\n                 false,\n                 span,\n             ).is_err() {\n@@ -2863,7 +3001,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                             Def::Const(..) if is_syntactic_ambiguity => {\n                                 // Disambiguate in favor of a unit struct/variant\n                                 // or constant pattern.\n-                                self.record_use(ident, ValueNS, binding.unwrap());\n+                                self.record_use(ident, ValueNS, binding.unwrap(), false);\n                                 Some(PathResolution::new(def))\n                             }\n                             Def::StructCtor(..) | Def::VariantCtor(..) |\n@@ -2991,7 +3129,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n                     let mod_prefix = match this.resolve_path_without_parent_scope(\n-                        None, mod_path, Some(TypeNS), false, span, CrateLint::No\n+                        mod_path, Some(TypeNS), false, span, CrateLint::No\n                     ) {\n                         PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n                             module.def(),\n@@ -3480,7 +3618,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         }\n \n         let result = match self.resolve_path_without_parent_scope(\n-            None,\n             &path,\n             Some(ns),\n             true,\n@@ -3527,7 +3664,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n            path[0].ident.name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n                 match self.resolve_path_without_parent_scope(\n-                    None,\n                     &[*path.last().unwrap()],\n                     Some(ns),\n                     false,\n@@ -3551,9 +3687,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n     fn resolve_path_without_parent_scope(\n         &mut self,\n-        base_module: Option<ModuleOrUniformRoot<'a>>,\n         path: &[Segment],\n-        opt_ns: Option<Namespace>, // `None` indicates a module path\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         record_used: bool,\n         path_span: Span,\n         crate_lint: CrateLint,\n@@ -3562,21 +3697,19 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         // other paths will do okay with parent module alone.\n         assert!(opt_ns != None && opt_ns != Some(MacroNS));\n         let parent_scope = ParentScope { module: self.current_module, ..self.dummy_parent_scope() };\n-        self.resolve_path(base_module, path, opt_ns, &parent_scope,\n-                          record_used, path_span, crate_lint)\n+        self.resolve_path(path, opt_ns, &parent_scope, record_used, path_span, crate_lint)\n     }\n \n     fn resolve_path(\n         &mut self,\n-        base_module: Option<ModuleOrUniformRoot<'a>>,\n         path: &[Segment],\n-        opt_ns: Option<Namespace>, // `None` indicates a module path\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         parent_scope: &ParentScope<'a>,\n         record_used: bool,\n         path_span: Span,\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n-        let mut module = base_module;\n+        let mut module = None;\n         let mut allow_super = true;\n         let mut second_binding = None;\n         self.current_module = parent_scope.module;\n@@ -3629,7 +3762,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                             continue;\n                         }\n                     }\n-                    let msg = \"There are too many initial `super`s.\".to_string();\n+                    let msg = \"there are too many initial `super`s.\".to_string();\n                     return PathResult::Failed(ident.span, msg, false);\n                 }\n                 if i == 0 {\n@@ -3640,9 +3773,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                         continue;\n                     }\n                     if name == keywords::Extern.name() ||\n-                       name == keywords::CrateRoot.name() &&\n-                       self.session.rust_2018() {\n-                        module = Some(ModuleOrUniformRoot::UniformRoot(name));\n+                       name == keywords::CrateRoot.name() && self.session.rust_2018() {\n+                        module =\n+                            Some(ModuleOrUniformRoot::UniformRoot(UniformRootKind::ExternPrelude));\n                         continue;\n                     }\n                     if name == keywords::CrateRoot.name() ||\n@@ -3672,11 +3805,12 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n \n             let binding = if let Some(module) = module {\n-                self.resolve_ident_in_module(module, ident, ns, record_used, path_span)\n-            } else if opt_ns == Some(MacroNS) {\n+                self.resolve_ident_in_module(module, ident, ns, None, record_used, path_span)\n+            } else if opt_ns.is_none() || opt_ns == Some(MacroNS) {\n                 assert!(ns == TypeNS);\n-                self.early_resolve_ident_in_lexical_scope(ident, ns, None, parent_scope,\n-                                                          record_used, record_used, path_span)\n+                self.early_resolve_ident_in_lexical_scope(ident, ns, None, opt_ns.is_none(),\n+                                                          parent_scope, record_used, record_used,\n+                                                          path_span)\n             } else {\n                 let record_used_id =\n                     if record_used { crate_lint.node_id().or(Some(CRATE_NODE_ID)) } else { None };\n@@ -3691,7 +3825,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                             def, path.len() - 1\n                         ));\n                     }\n-                    _ => Err(if record_used { Determined } else { Undetermined }),\n+                    _ => Err(Determinacy::determined(record_used)),\n                 }\n             };\n \n@@ -3722,7 +3856,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                         ));\n                     } else {\n                         return PathResult::Failed(ident.span,\n-                                                  format!(\"Not a module `{}`\", ident),\n+                                                  format!(\"not a module `{}`\", ident),\n                                                   is_last);\n                     }\n                 }\n@@ -3747,14 +3881,14 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                             (c.path.segments.len(), c.path.to_string())\n                         });\n                         if let Some(candidate) = candidates.get(0) {\n-                            format!(\"Did you mean `{}`?\", candidate.path)\n+                            format!(\"did you mean `{}`?\", candidate.path)\n                         } else {\n-                            format!(\"Maybe a missing `extern crate {};`?\", ident)\n+                            format!(\"maybe a missing `extern crate {};`?\", ident)\n                         }\n                     } else if i == 0 {\n-                        format!(\"Use of undeclared type or module `{}`\", ident)\n+                        format!(\"use of undeclared type or module `{}`\", ident)\n                     } else {\n-                        format!(\"Could not find `{}` in `{}`\", ident, path[i - 1].ident)\n+                        format!(\"could not find `{}` in `{}`\", ident, path[i - 1].ident)\n                     };\n                     return PathResult::Failed(ident.span, msg, is_last);\n                 }\n@@ -3763,9 +3897,12 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         self.lint_if_path_starts_with_module(crate_lint, path, path_span, second_binding);\n \n-        PathResult::Module(module.unwrap_or_else(|| {\n-            span_bug!(path_span, \"resolve_path: empty(?) path {:?} has no module\", path);\n-        }))\n+        PathResult::Module(match module {\n+            Some(module) => module,\n+            None if path.is_empty() =>\n+                ModuleOrUniformRoot::UniformRoot(UniformRootKind::CurrentScope),\n+            _ => span_bug!(path_span, \"resolve_path: non-empty path `{:?}` has no module\", path),\n+        })\n     }\n \n     fn lint_if_path_starts_with_module(\n@@ -3975,6 +4112,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     ns,\n+                    None,\n                     false,\n                     module.span,\n                 ) {\n@@ -4050,7 +4188,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n             if let PathResult::Module(module) = self.resolve_path_without_parent_scope(\n-                None, mod_path, Some(TypeNS), false, span, CrateLint::No\n+                mod_path, Some(TypeNS), false, span, CrateLint::No\n             ) {\n                 if let ModuleOrUniformRoot::Module(module) = module {\n                     add_module_candidates(module, &mut names);\n@@ -4297,6 +4435,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n+                None,\n                 false,\n                 module.span,\n             ).is_ok() {\n@@ -4352,7 +4491,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 ident,\n                 ns,\n                 false,\n-                false,\n                 module.span,\n             ).is_ok() {\n                 let import_id = match binding.kind {\n@@ -4634,43 +4772,88 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         }\n     }\n \n-    fn report_ambiguity_error(&self, ident: Ident, b1: &NameBinding, b2: &NameBinding) {\n-        let participle = |is_import: bool| if is_import { \"imported\" } else { \"defined\" };\n-        let msg1 =\n-            format!(\"`{}` could refer to the name {} here\", ident, participle(b1.is_import()));\n-        let msg2 =\n-            format!(\"`{}` could also refer to the name {} here\", ident, participle(b2.is_import()));\n-        let note = if b1.expansion != Mark::root() {\n-            Some(if let Def::Macro(..) = b1.def() {\n-                format!(\"macro-expanded {} do not shadow\",\n-                        if b1.is_import() { \"macro imports\" } else { \"macros\" })\n+    fn binding_description(&self, b: &NameBinding, ident: Ident, from_prelude: bool) -> String {\n+        if b.span.is_dummy() {\n+            let add_built_in = match b.def() {\n+                // These already contain the \"built-in\" prefix or look bad with it.\n+                Def::NonMacroAttr(..) | Def::PrimTy(..) | Def::ToolMod => false,\n+                _ => true,\n+            };\n+            let (built_in, from) = if from_prelude {\n+                (\"\", \" from prelude\")\n+            } else if b.is_extern_crate() && !b.is_import() &&\n+                        self.session.opts.externs.get(&ident.as_str()).is_some() {\n+                (\"\", \" passed with `--extern`\")\n+            } else if add_built_in {\n+                (\" built-in\", \"\")\n             } else {\n-                format!(\"macro-expanded {} do not shadow when used in a macro invocation path\",\n-                        if b1.is_import() { \"imports\" } else { \"items\" })\n-            })\n-        } else if b1.is_glob_import() {\n-            Some(format!(\"consider adding an explicit import of `{}` to disambiguate\", ident))\n+                (\"\", \"\")\n+            };\n+\n+            let article = if built_in.is_empty() { b.article() } else { \"a\" };\n+            format!(\"{a}{built_in} {thing}{from}\",\n+                    a = article, thing = b.descr(), built_in = built_in, from = from)\n         } else {\n-            None\n+            let introduced = if b.is_import() { \"imported\" } else { \"defined\" };\n+            format!(\"the {thing} {introduced} here\",\n+                    thing = b.descr(), introduced = introduced)\n+        }\n+    }\n+\n+    fn report_ambiguity_error(&self, ambiguity_error: &AmbiguityError) {\n+        let AmbiguityError { kind, ident, b1, b2, misc1, misc2 } = *ambiguity_error;\n+        let (b1, b2, misc1, misc2, swapped) = if b2.span.is_dummy() && !b1.span.is_dummy() {\n+            // We have to print the span-less alternative first, otherwise formatting looks bad.\n+            (b2, b1, misc2, misc1, true)\n+        } else {\n+            (b1, b2, misc1, misc2, false)\n         };\n \n-        let mut err = struct_span_err!(self.session, ident.span, E0659, \"`{}` is ambiguous\", ident);\n+        let mut err = struct_span_err!(self.session, ident.span, E0659,\n+                                       \"`{ident}` is ambiguous ({why})\",\n+                                       ident = ident, why = kind.descr());\n         err.span_label(ident.span, \"ambiguous name\");\n-        err.span_note(b1.span, &msg1);\n-        match b2.def() {\n-            Def::Macro(..) if b2.span.is_dummy() =>\n-                err.note(&format!(\"`{}` is also a builtin macro\", ident)),\n-            _ => err.span_note(b2.span, &msg2),\n+\n+        let mut could_refer_to = |b: &NameBinding, misc: AmbiguityErrorMisc, also: &str| {\n+            let what = self.binding_description(b, ident, misc == AmbiguityErrorMisc::FromPrelude);\n+            let note_msg = format!(\"`{ident}` could{also} refer to {what}\",\n+                                   ident = ident, also = also, what = what);\n+\n+            let mut help_msgs = Vec::new();\n+            if b.is_glob_import() && (kind == AmbiguityKind::GlobVsGlob ||\n+                                      kind == AmbiguityKind::GlobVsExpanded ||\n+                                      kind == AmbiguityKind::GlobVsOuter &&\n+                                      swapped != also.is_empty()) {\n+                help_msgs.push(format!(\"consider adding an explicit import of \\\n+                                        `{ident}` to disambiguate\", ident = ident))\n+            }\n+            if b.is_extern_crate() && self.session.rust_2018() {\n+                help_msgs.push(format!(\"use `::{ident}` to refer to this {thing} unambiguously\",\n+                                       ident = ident, thing = b.descr()))\n+            }\n+            if misc == AmbiguityErrorMisc::SuggestSelf {\n+                help_msgs.push(format!(\"use `self::{ident}` to refer to this {thing} unambiguously\",\n+                                       ident = ident, thing = b.descr()))\n+            }\n+\n+            if b.span.is_dummy() {\n+                err.note(&note_msg);\n+            } else {\n+                err.span_note(b.span, &note_msg);\n+            }\n+            for (i, help_msg) in help_msgs.iter().enumerate() {\n+                let or = if i == 0 { \"\" } else { \"or \" };\n+                err.help(&format!(\"{}{}\", or, help_msg));\n+            }\n         };\n-        if let Some(note) = note {\n-            err.note(&note);\n-        }\n+\n+        could_refer_to(b1, misc1, \"\");\n+        could_refer_to(b2, misc2, \" also\");\n         err.emit();\n     }\n \n     fn report_errors(&mut self, krate: &Crate) {\n         self.report_with_use_injections(krate);\n-        let mut reported_spans = FxHashSet::default();\n \n         for &(span_use, span_def) in &self.macro_expanded_macro_export_errors {\n             let msg = \"macro-expanded `macro_export` macros from the current crate \\\n@@ -4683,12 +4866,11 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             );\n         }\n \n-        for &AmbiguityError { ident, b1, b2 } in &self.ambiguity_errors {\n-            if reported_spans.insert(ident.span) {\n-                self.report_ambiguity_error(ident, b1, b2);\n-            }\n+        for ambiguity_error in &self.ambiguity_errors {\n+            self.report_ambiguity_error(ambiguity_error);\n         }\n \n+        let mut reported_spans = FxHashSet::default();\n         for &PrivacyError(dedup_span, ident, binding) in &self.privacy_errors {\n             if reported_spans.insert(dedup_span) {\n                 span_err!(self.session, ident.span, E0603, \"{} `{}` is private\",\n@@ -4842,6 +5024,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n     fn extern_prelude_get(&mut self, ident: Ident, speculative: bool, skip_feature_gate: bool)\n                           -> Option<&'a NameBinding<'a>> {\n+        if ident.is_path_segment_keyword() {\n+            // Make sure `self`, `super` etc produce an error when passed to here.\n+            return None;\n+        }\n         self.extern_prelude.get(&ident.modern()).cloned().and_then(|entry| {\n             if let Some(binding) = entry.extern_crate_item {\n                 if !speculative && !skip_feature_gate && entry.introduced_by_item &&\n@@ -4863,7 +5049,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 };\n                 let crate_root = self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n                 self.populate_module_if_necessary(&crate_root);\n-                Some((crate_root, ty::Visibility::Public, ident.span, Mark::root())\n+                Some((crate_root, ty::Visibility::Public, DUMMY_SP, Mark::root())\n                     .to_name_binding(self.arenas))\n             }\n         })"}, {"sha": "921f7568b5201ff99ff3d76d6cf717e14bf34802", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 297, "deletions": 196, "changes": 493, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {AmbiguityError, CrateLint, Resolver, ResolutionError, is_known_tool, resolve_error};\n-use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, Segment, ToNameBinding};\n+use {AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n+use {CrateLint, Resolver, ResolutionError, Segment, Weak};\n+use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, ToNameBinding};\n+use {is_known_tool, resolve_error};\n use ModuleOrUniformRoot;\n use Namespace::{self, *};\n use build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n@@ -53,8 +55,8 @@ pub struct InvocationData<'a> {\n     crate parent_legacy_scope: Cell<LegacyScope<'a>>,\n     /// Legacy scope *produced* by expanding this macro invocation,\n     /// includes all the macro_rules items, other invocations, etc generated by it.\n-    /// Set to the parent scope if the macro is not expanded yet (as if the macro produced nothing).\n-    crate output_legacy_scope: Cell<LegacyScope<'a>>,\n+    /// `None` if the macro is not expanded yet.\n+    crate output_legacy_scope: Cell<Option<LegacyScope<'a>>>,\n }\n \n impl<'a> InvocationData<'a> {\n@@ -63,7 +65,7 @@ impl<'a> InvocationData<'a> {\n             module: Cell::new(graph_root),\n             def_index: CRATE_DEF_INDEX,\n             parent_legacy_scope: Cell::new(LegacyScope::Empty),\n-            output_legacy_scope: Cell::new(LegacyScope::Empty),\n+            output_legacy_scope: Cell::new(Some(LegacyScope::Empty)),\n         }\n     }\n }\n@@ -109,7 +111,7 @@ pub struct ParentScope<'a> {\n // Macro namespace is separated into two sub-namespaces, one for bang macros and\n // one for attribute-like macros (attributes, derives).\n // We ignore resolutions from one sub-namespace when searching names in scope for another.\n-fn sub_namespace_mismatch(requirement: Option<MacroKind>, candidate: Option<MacroKind>) -> bool {\n+fn sub_namespace_match(candidate: Option<MacroKind>, requirement: Option<MacroKind>) -> bool {\n     #[derive(PartialEq)]\n     enum SubNS { Bang, AttrLike }\n     let sub_ns = |kind| match kind {\n@@ -120,7 +122,7 @@ fn sub_namespace_mismatch(requirement: Option<MacroKind>, candidate: Option<Macr\n     let requirement = requirement.and_then(|kind| sub_ns(kind));\n     let candidate = candidate.and_then(|kind| sub_ns(kind));\n     // \"No specific sub-namespace\" means \"matches anything\" for both requirements and candidates.\n-    candidate.is_some() && requirement.is_some() && candidate != requirement\n+    candidate.is_none() || requirement.is_none() || candidate == requirement\n }\n \n impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n@@ -135,7 +137,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n             module: Cell::new(module),\n             def_index: module.def_id().unwrap().index,\n             parent_legacy_scope: Cell::new(LegacyScope::Empty),\n-            output_legacy_scope: Cell::new(LegacyScope::Empty),\n+            output_legacy_scope: Cell::new(Some(LegacyScope::Empty)),\n         }));\n         mark\n     }\n@@ -211,7 +213,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n             expansion: mark,\n         };\n         fragment.visit_with(&mut visitor);\n-        invocation.output_legacy_scope.set(visitor.current_legacy_scope);\n+        invocation.output_legacy_scope.set(Some(visitor.current_legacy_scope));\n     }\n \n     fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>) {\n@@ -225,7 +227,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         let binding = self.arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Def(Def::Macro(def_id, kind), false),\n             span: DUMMY_SP,\n-            vis: ty::Visibility::Invisible,\n+            vis: ty::Visibility::Public,\n             expansion: Mark::root(),\n         });\n         if self.builtin_macros.insert(ident.name, binding).is_some() {\n@@ -325,7 +327,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         };\n \n         let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n-        let (def, ext) = self.resolve_macro_to_def(path, kind, &parent_scope, force)?;\n+        let (def, ext) = self.resolve_macro_to_def(path, kind, &parent_scope, true, force)?;\n \n         if let Def::Macro(def_id, _) = def {\n             if after_derive {\n@@ -348,7 +350,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n                           derives_in_scope: Vec<ast::Path>, force: bool)\n                           -> Result<Lrc<SyntaxExtension>, Determinacy> {\n         let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n-        Ok(self.resolve_macro_to_def(path, kind, &parent_scope, force)?.1)\n+        Ok(self.resolve_macro_to_def(path, kind, &parent_scope, false, force)?.1)\n     }\n \n     fn check_unused_macros(&self) {\n@@ -370,11 +372,11 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n }\n \n impl<'a, 'cl> Resolver<'a, 'cl> {\n-    pub fn dummy_parent_scope(&mut self) -> ParentScope<'a> {\n+    pub fn dummy_parent_scope(&self) -> ParentScope<'a> {\n         self.invoc_parent_scope(Mark::root(), Vec::new())\n     }\n \n-    fn invoc_parent_scope(&mut self, invoc_id: Mark, derives: Vec<ast::Path>) -> ParentScope<'a> {\n+    fn invoc_parent_scope(&self, invoc_id: Mark, derives: Vec<ast::Path>) -> ParentScope<'a> {\n         let invoc = self.invocations[&invoc_id];\n         ParentScope {\n             module: invoc.module.get().nearest_item_scope(),\n@@ -389,9 +391,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         path: &ast::Path,\n         kind: MacroKind,\n         parent_scope: &ParentScope<'a>,\n+        trace: bool,\n         force: bool,\n     ) -> Result<(Def, Lrc<SyntaxExtension>), Determinacy> {\n-        let def = self.resolve_macro_to_def_inner(path, kind, parent_scope, force);\n+        let def = self.resolve_macro_to_def_inner(path, kind, parent_scope, trace, force);\n \n         // Report errors and enforce feature gates for the resolved macro.\n         if def != Err(Determinacy::Undetermined) {\n@@ -463,6 +466,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         path: &ast::Path,\n         kind: MacroKind,\n         parent_scope: &ParentScope<'a>,\n+        trace: bool,\n         force: bool,\n     ) -> Result<Def, Determinacy> {\n         let path_span = path.span;\n@@ -477,45 +481,39 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         if path.len() > 1 {\n-            let def = match self.resolve_path(None, &path, Some(MacroNS), parent_scope,\n+            let def = match self.resolve_path(&path, Some(MacroNS), parent_scope,\n                                               false, path_span, CrateLint::No) {\n-                PathResult::NonModule(path_res) => match path_res.base_def() {\n-                    Def::Err => Err(Determinacy::Determined),\n-                    def @ _ => {\n-                        if path_res.unresolved_segments() > 0 {\n-                            self.found_unresolved_macro = true;\n-                            self.session.span_err(path_span,\n-                                                  \"fail to resolve non-ident macro path\");\n-                            Err(Determinacy::Determined)\n-                        } else {\n-                            Ok(def)\n-                        }\n-                    }\n-                },\n-                PathResult::Module(..) => unreachable!(),\n+                PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n+                    Ok(path_res.base_def())\n+                }\n                 PathResult::Indeterminate if !force => return Err(Determinacy::Undetermined),\n-                _ => {\n+                PathResult::NonModule(..) | PathResult::Indeterminate | PathResult::Failed(..) => {\n                     self.found_unresolved_macro = true;\n                     Err(Determinacy::Determined)\n-                },\n+                }\n+                PathResult::Module(..) => unreachable!(),\n             };\n \n-            parent_scope.module.macro_resolutions.borrow_mut()\n-                .push((path, parent_scope.clone(), path_span));\n+            if trace {\n+                parent_scope.module.multi_segment_macro_resolutions.borrow_mut()\n+                    .push((path, path_span, kind, parent_scope.clone(), def.ok()));\n+            }\n \n             def\n         } else {\n             let binding = self.early_resolve_ident_in_lexical_scope(\n-                path[0].ident, MacroNS, Some(kind), parent_scope, false, force, path_span\n+                path[0].ident, MacroNS, Some(kind), false, parent_scope, false, force, path_span\n             );\n             match binding {\n                 Ok(..) => {}\n                 Err(Determinacy::Determined) => self.found_unresolved_macro = true,\n                 Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n             }\n \n-            parent_scope.module.legacy_macro_resolutions.borrow_mut()\n-                .push((path[0].ident, kind, parent_scope.clone(), binding.ok()));\n+            if trace {\n+                parent_scope.module.single_segment_macro_resolutions.borrow_mut()\n+                    .push((path[0].ident, kind, parent_scope.clone(), binding.ok()));\n+            }\n \n             binding.map(|binding| binding.def_ignoring_ambiguity())\n         }\n@@ -525,12 +523,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     // This is a variation of `fn resolve_ident_in_lexical_scope` that can be run during\n     // expansion and import resolution (perhaps they can be merged in the future).\n     // The function is used for resolving initial segments of macro paths (e.g. `foo` in\n-    // `foo::bar!(); or `foo!();`) and can be used for \"uniform path\" imports in the future.\n+    // `foo::bar!(); or `foo!();`) and also for import paths on 2018 edition.\n     crate fn early_resolve_ident_in_lexical_scope(\n         &mut self,\n         mut ident: Ident,\n         ns: Namespace,\n-        kind: Option<MacroKind>,\n+        macro_kind: Option<MacroKind>,\n+        is_import: bool,\n         parent_scope: &ParentScope<'a>,\n         record_used: bool,\n         force: bool,\n@@ -596,16 +595,23 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         bitflags! {\n             struct Flags: u8 {\n-                const DERIVE_HELPERS = 1 << 0;\n-                const MACRO_RULES    = 1 << 1;\n-                const MODULE         = 1 << 2;\n-                const PRELUDE        = 1 << 3;\n+                const MACRO_RULES       = 1 << 0;\n+                const MODULE            = 1 << 1;\n+                const PRELUDE           = 1 << 2;\n+                const MISC_SUGGEST_SELF = 1 << 3;\n+                const MISC_FROM_PRELUDE = 1 << 4;\n             }\n         }\n \n         assert!(force || !record_used); // `record_used` implies `force`\n+        assert!(macro_kind.is_none() || !is_import); // `is_import` implies no macro kind\n         ident = ident.modern();\n \n+        // Make sure `self`, `super` etc produce an error when passed to here.\n+        if ident.is_path_segment_keyword() {\n+            return Err(Determinacy::Determined);\n+        }\n+\n         // This is *the* result, resolution from the scope closest to the resolved identifier.\n         // However, sometimes this result is \"weak\" because it comes from a glob import or\n         // a macro expansion, and in this case it cannot shadow names from outer scopes, e.g.\n@@ -617,72 +623,103 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // }\n         // So we have to save the innermost solution and continue searching in outer scopes\n         // to detect potential ambiguities.\n-        let mut innermost_result: Option<(&NameBinding, Flags, /* conflicts with */ Flags)> = None;\n+        let mut innermost_result: Option<(&NameBinding, Flags)> = None;\n \n         // Go through all the scopes and try to resolve the name.\n-        let mut where_to_resolve = WhereToResolve::DeriveHelpers;\n+        let mut where_to_resolve = if ns == MacroNS {\n+            WhereToResolve::DeriveHelpers\n+        } else {\n+            WhereToResolve::Module(parent_scope.module)\n+        };\n         let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n+        let mut determinacy = Determinacy::Determined;\n         loop {\n             let result = match where_to_resolve {\n                 WhereToResolve::DeriveHelpers => {\n                     let mut result = Err(Determinacy::Determined);\n                     for derive in &parent_scope.derives {\n                         let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n-                        if let Ok((_, ext)) = self.resolve_macro_to_def(derive, MacroKind::Derive,\n-                                                                        &parent_scope, force) {\n-                            if let SyntaxExtension::ProcMacroDerive(_, helper_attrs, _) = &*ext {\n-                                if helper_attrs.contains(&ident.name) {\n-                                    let binding =\n-                                        (Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n-                                        ty::Visibility::Public, derive.span, Mark::root())\n-                                        .to_name_binding(self.arenas);\n-                                    result = Ok((binding, Flags::DERIVE_HELPERS, Flags::all()));\n-                                    break;\n+                        match self.resolve_macro_to_def(derive, MacroKind::Derive,\n+                                                        &parent_scope, true, force) {\n+                            Ok((_, ext)) => {\n+                                if let SyntaxExtension::ProcMacroDerive(_, helpers, _) = &*ext {\n+                                    if helpers.contains(&ident.name) {\n+                                        let binding =\n+                                            (Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n+                                            ty::Visibility::Public, derive.span, Mark::root())\n+                                            .to_name_binding(self.arenas);\n+                                        result = Ok((binding, Flags::empty()));\n+                                        break;\n+                                    }\n                                 }\n                             }\n+                            Err(Determinacy::Determined) => {}\n+                            Err(Determinacy::Undetermined) =>\n+                                result = Err(Determinacy::Undetermined),\n                         }\n                     }\n                     result\n                 }\n                 WhereToResolve::MacroRules(legacy_scope) => match legacy_scope {\n                     LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n-                        Ok((legacy_binding.binding, Flags::MACRO_RULES, Flags::empty())),\n+                        Ok((legacy_binding.binding, Flags::MACRO_RULES)),\n+                    LegacyScope::Invocation(invoc) if invoc.output_legacy_scope.get().is_none() =>\n+                        Err(Determinacy::Undetermined),\n                     _ => Err(Determinacy::Determined),\n                 }\n                 WhereToResolve::Module(module) => {\n                     let orig_current_module = mem::replace(&mut self.current_module, module);\n-                    let binding = self.resolve_ident_in_module_unadjusted(\n+                    let binding = self.resolve_ident_in_module_unadjusted_ext(\n                         ModuleOrUniformRoot::Module(module),\n                         ident,\n                         ns,\n+                        None,\n                         true,\n                         record_used,\n                         path_span,\n                     );\n                     self.current_module = orig_current_module;\n-                    binding.map(|binding| (binding, Flags::MODULE, Flags::empty()))\n+                    match binding {\n+                        Ok(binding) => {\n+                            let misc_flags = if module.is_normal() {\n+                                Flags::MISC_SUGGEST_SELF\n+                            } else {\n+                                Flags::empty()\n+                            };\n+                            Ok((binding, Flags::MODULE | misc_flags))\n+                        }\n+                        Err((Determinacy::Undetermined, Weak::No)) =>\n+                            return Err(Determinacy::determined(force)),\n+                        Err((Determinacy::Undetermined, Weak::Yes)) =>\n+                            Err(Determinacy::Undetermined),\n+                        Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n+                    }\n                 }\n                 WhereToResolve::MacroUsePrelude => {\n-                    let mut result = Err(Determinacy::Determined);\n                     if use_prelude || self.session.rust_2015() {\n-                        if let Some(binding) = self.macro_use_prelude.get(&ident.name).cloned() {\n-                            result = Ok((binding, Flags::PRELUDE, Flags::empty()));\n+                        match self.macro_use_prelude.get(&ident.name).cloned() {\n+                            Some(binding) =>\n+                                Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE)),\n+                            None => Err(Determinacy::determined(\n+                                self.graph_root.unresolved_invocations.borrow().is_empty()\n+                            ))\n                         }\n+                    } else {\n+                        Err(Determinacy::Determined)\n                     }\n-                    result\n                 }\n                 WhereToResolve::BuiltinMacros => {\n                     match self.builtin_macros.get(&ident.name).cloned() {\n-                        Some(binding) => Ok((binding, Flags::PRELUDE, Flags::empty())),\n+                        Some(binding) => Ok((binding, Flags::PRELUDE)),\n                         None => Err(Determinacy::Determined),\n                     }\n                 }\n                 WhereToResolve::BuiltinAttrs => {\n                     if is_builtin_attr_name(ident.name) {\n                         let binding = (Def::NonMacroAttr(NonMacroAttrKind::Builtin),\n-                                       ty::Visibility::Public, ident.span, Mark::root())\n+                                       ty::Visibility::Public, DUMMY_SP, Mark::root())\n                                        .to_name_binding(self.arenas);\n-                        Ok((binding, Flags::PRELUDE, Flags::empty()))\n+                        Ok((binding, Flags::PRELUDE))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -692,28 +729,31 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                        self.session.plugin_attributes.borrow().iter()\n                                                      .any(|(name, _)| ident.name == &**name) {\n                         let binding = (Def::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n-                                       ty::Visibility::Public, ident.span, Mark::root())\n+                                       ty::Visibility::Public, DUMMY_SP, Mark::root())\n                                        .to_name_binding(self.arenas);\n-                        Ok((binding, Flags::PRELUDE, Flags::PRELUDE))\n+                        Ok((binding, Flags::PRELUDE))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n                 }\n                 WhereToResolve::ExternPrelude => {\n-                    let mut result = Err(Determinacy::Determined);\n                     if use_prelude {\n-                        if let Some(binding) = self.extern_prelude_get(ident, !record_used,\n-                                                                       innermost_result.is_some()) {\n-                            result = Ok((binding, Flags::PRELUDE, Flags::empty()));\n+                        match self.extern_prelude_get(ident, !record_used,\n+                                                      innermost_result.is_some()) {\n+                            Some(binding) => Ok((binding, Flags::PRELUDE)),\n+                            None => Err(Determinacy::determined(\n+                                self.graph_root.unresolved_invocations.borrow().is_empty()\n+                            )),\n                         }\n+                    } else {\n+                        Err(Determinacy::Determined)\n                     }\n-                    result\n                 }\n                 WhereToResolve::ToolPrelude => {\n                     if use_prelude && is_known_tool(ident.name) {\n                         let binding = (Def::ToolMod, ty::Visibility::Public,\n-                                       ident.span, Mark::root()).to_name_binding(self.arenas);\n-                        Ok((binding, Flags::PRELUDE, Flags::empty()))\n+                                       DUMMY_SP, Mark::root()).to_name_binding(self.arenas);\n+                        Ok((binding, Flags::PRELUDE))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -727,10 +767,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                                 ident,\n                                 ns,\n                                 false,\n-                                false,\n                                 path_span,\n                             ) {\n-                                result = Ok((binding, Flags::PRELUDE, Flags::empty()));\n+                                result = Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE));\n                             }\n                         }\n                     }\n@@ -740,105 +779,157 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     match self.primitive_type_table.primitive_types.get(&ident.name).cloned() {\n                         Some(prim_ty) => {\n                             let binding = (Def::PrimTy(prim_ty), ty::Visibility::Public,\n-                                           ident.span, Mark::root()).to_name_binding(self.arenas);\n-                            Ok((binding, Flags::PRELUDE, Flags::empty()))\n+                                           DUMMY_SP, Mark::root()).to_name_binding(self.arenas);\n+                            Ok((binding, Flags::PRELUDE))\n                         }\n                         None => Err(Determinacy::Determined)\n                     }\n                 }\n             };\n \n-            macro_rules! continue_search { () => {\n-                where_to_resolve = match where_to_resolve {\n-                    WhereToResolve::DeriveHelpers =>\n-                        WhereToResolve::MacroRules(parent_scope.legacy),\n-                    WhereToResolve::MacroRules(legacy_scope) => match legacy_scope {\n-                        LegacyScope::Binding(binding) =>\n-                            WhereToResolve::MacroRules(binding.parent_legacy_scope),\n-                        LegacyScope::Invocation(invocation) =>\n-                            WhereToResolve::MacroRules(invocation.output_legacy_scope.get()),\n-                        LegacyScope::Empty => WhereToResolve::Module(parent_scope.module),\n-                        LegacyScope::Uninitialized => unreachable!(),\n-                    }\n-                    WhereToResolve::Module(module) => {\n-                        match self.hygienic_lexical_parent(module, &mut ident.span) {\n-                            Some(parent_module) => WhereToResolve::Module(parent_module),\n-                            None => {\n-                                use_prelude = !module.no_implicit_prelude;\n-                                match ns {\n-                                    TypeNS => WhereToResolve::ExternPrelude,\n-                                    ValueNS => WhereToResolve::StdLibPrelude,\n-                                    MacroNS => WhereToResolve::MacroUsePrelude,\n-                                }\n-                            }\n-                        }\n-                    }\n-                    WhereToResolve::MacroUsePrelude => WhereToResolve::BuiltinMacros,\n-                    WhereToResolve::BuiltinMacros => WhereToResolve::BuiltinAttrs,\n-                    WhereToResolve::BuiltinAttrs => WhereToResolve::LegacyPluginHelpers,\n-                    WhereToResolve::LegacyPluginHelpers => break, // nowhere else to search\n-                    WhereToResolve::ExternPrelude => WhereToResolve::ToolPrelude,\n-                    WhereToResolve::ToolPrelude => WhereToResolve::StdLibPrelude,\n-                    WhereToResolve::StdLibPrelude => match ns {\n-                        TypeNS => WhereToResolve::BuiltinTypes,\n-                        ValueNS => break, // nowhere else to search\n-                        MacroNS => unreachable!(),\n-                    }\n-                    WhereToResolve::BuiltinTypes => break, // nowhere else to search\n-                };\n-\n-                continue;\n-            }}\n-\n             match result {\n-                Ok((binding, flags, ambig_flags)) => {\n-                    if sub_namespace_mismatch(kind, binding.macro_kind()) {\n-                        continue_search!();\n-                    }\n-\n+                Ok((binding, flags)) if sub_namespace_match(binding.macro_kind(), macro_kind) => {\n                     if !record_used {\n                         return Ok(binding);\n                     }\n \n-                    if let Some((innermost_binding, innermost_flags, innermost_ambig_flags))\n-                            = innermost_result {\n+                    if let Some((innermost_binding, innermost_flags)) = innermost_result {\n                         // Found another solution, if the first one was \"weak\", report an error.\n-                        if binding.def() != innermost_binding.def() &&\n-                           (innermost_binding.is_glob_import() ||\n-                            innermost_binding.may_appear_after(parent_scope.expansion, binding) ||\n-                            innermost_flags.intersects(ambig_flags) ||\n-                            flags.intersects(innermost_ambig_flags) ||\n-                            (innermost_flags.contains(Flags::MACRO_RULES) &&\n-                             flags.contains(Flags::MODULE) &&\n-                             !self.disambiguate_legacy_vs_modern(innermost_binding, binding))) {\n-                            self.ambiguity_errors.push(AmbiguityError {\n-                                ident,\n-                                b1: innermost_binding,\n-                                b2: binding,\n-                            });\n-                            return Ok(innermost_binding);\n+                        let (def, innermost_def) = (binding.def(), innermost_binding.def());\n+                        if def != innermost_def {\n+                            let builtin = Def::NonMacroAttr(NonMacroAttrKind::Builtin);\n+                            let derive_helper = Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n+                            let legacy_helper =\n+                                Def::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper);\n+\n+                            let ambiguity_error_kind = if is_import {\n+                                Some(AmbiguityKind::Import)\n+                            } else if innermost_def == builtin || def == builtin {\n+                                Some(AmbiguityKind::BuiltinAttr)\n+                            } else if innermost_def == derive_helper || def == derive_helper {\n+                                Some(AmbiguityKind::DeriveHelper)\n+                            } else if innermost_def == legacy_helper &&\n+                                      flags.contains(Flags::PRELUDE) ||\n+                                      def == legacy_helper &&\n+                                      innermost_flags.contains(Flags::PRELUDE) {\n+                                Some(AmbiguityKind::LegacyHelperVsPrelude)\n+                            } else if innermost_flags.contains(Flags::MACRO_RULES) &&\n+                                      flags.contains(Flags::MODULE) &&\n+                                      !self.disambiguate_legacy_vs_modern(innermost_binding,\n+                                                                          binding) {\n+                                Some(AmbiguityKind::LegacyVsModern)\n+                            } else if innermost_binding.is_glob_import() {\n+                                Some(AmbiguityKind::GlobVsOuter)\n+                            } else if innermost_binding.may_appear_after(parent_scope.expansion,\n+                                                                         binding) {\n+                                Some(AmbiguityKind::MoreExpandedVsOuter)\n+                            } else {\n+                                None\n+                            };\n+                            if let Some(kind) = ambiguity_error_kind {\n+                                let misc = |f: Flags| if f.contains(Flags::MISC_SUGGEST_SELF) {\n+                                    AmbiguityErrorMisc::SuggestSelf\n+                                } else if f.contains(Flags::MISC_FROM_PRELUDE) {\n+                                    AmbiguityErrorMisc::FromPrelude\n+                                } else {\n+                                    AmbiguityErrorMisc::None\n+                                };\n+                                self.ambiguity_errors.push(AmbiguityError {\n+                                    kind,\n+                                    ident,\n+                                    b1: innermost_binding,\n+                                    b2: binding,\n+                                    misc1: misc(innermost_flags),\n+                                    misc2: misc(flags),\n+                                });\n+                                return Ok(innermost_binding);\n+                            }\n                         }\n                     } else {\n                         // Found the first solution.\n-                        innermost_result = Some((binding, flags, ambig_flags));\n+                        innermost_result = Some((binding, flags));\n                     }\n-\n-                    continue_search!();\n-                },\n-                Err(Determinacy::Determined) => {\n-                    continue_search!();\n                 }\n-                Err(Determinacy::Undetermined) => return Err(Determinacy::determined(force)),\n+                Ok(..) | Err(Determinacy::Determined) => {}\n+                Err(Determinacy::Undetermined) => determinacy = Determinacy::Undetermined\n             }\n+\n+            where_to_resolve = match where_to_resolve {\n+                WhereToResolve::DeriveHelpers =>\n+                    WhereToResolve::MacroRules(parent_scope.legacy),\n+                WhereToResolve::MacroRules(legacy_scope) => match legacy_scope {\n+                    LegacyScope::Binding(binding) => WhereToResolve::MacroRules(\n+                        binding.parent_legacy_scope\n+                    ),\n+                    LegacyScope::Invocation(invoc) => WhereToResolve::MacroRules(\n+                        invoc.output_legacy_scope.get().unwrap_or(invoc.parent_legacy_scope.get())\n+                    ),\n+                    LegacyScope::Empty => WhereToResolve::Module(parent_scope.module),\n+                    LegacyScope::Uninitialized => unreachable!(),\n+                }\n+                WhereToResolve::Module(module) => {\n+                    match self.hygienic_lexical_parent(module, &mut ident.span) {\n+                        Some(parent_module) => WhereToResolve::Module(parent_module),\n+                        None => {\n+                            use_prelude = !module.no_implicit_prelude;\n+                            match ns {\n+                                TypeNS => WhereToResolve::ExternPrelude,\n+                                ValueNS => WhereToResolve::StdLibPrelude,\n+                                MacroNS => WhereToResolve::MacroUsePrelude,\n+                            }\n+                        }\n+                    }\n+                }\n+                WhereToResolve::MacroUsePrelude => WhereToResolve::BuiltinMacros,\n+                WhereToResolve::BuiltinMacros => WhereToResolve::BuiltinAttrs,\n+                WhereToResolve::BuiltinAttrs => WhereToResolve::LegacyPluginHelpers,\n+                WhereToResolve::LegacyPluginHelpers => break, // nowhere else to search\n+                WhereToResolve::ExternPrelude => WhereToResolve::ToolPrelude,\n+                WhereToResolve::ToolPrelude => WhereToResolve::StdLibPrelude,\n+                WhereToResolve::StdLibPrelude => match ns {\n+                    TypeNS => WhereToResolve::BuiltinTypes,\n+                    ValueNS => break, // nowhere else to search\n+                    MacroNS => unreachable!(),\n+                }\n+                WhereToResolve::BuiltinTypes => break, // nowhere else to search\n+            };\n+\n+            continue;\n         }\n \n         // The first found solution was the only one, return it.\n-        if let Some((binding, ..)) = innermost_result {\n+        if let Some((binding, flags)) = innermost_result {\n+            if is_import && !self.session.features_untracked().uniform_paths {\n+                // We get to here only if there's no ambiguity, in ambiguous cases an error will\n+                // be reported anyway, so there's no reason to report an additional feature error.\n+                // The `binding` can actually be introduced by something other than `--extern`,\n+                // but its `Def` should coincide with a crate passed with `--extern`\n+                // (otherwise there would be ambiguity) and we can skip feature error in this case.\n+                if ns != TypeNS || !use_prelude ||\n+                   self.extern_prelude_get(ident, true, false).is_none() {\n+                    let msg = \"imports can only refer to extern crate names \\\n+                               passed with `--extern` on stable channel\";\n+                    let mut err = feature_err(&self.session.parse_sess, \"uniform_paths\",\n+                                              ident.span, GateIssue::Language, msg);\n+\n+                    let what = self.binding_description(binding, ident,\n+                                                        flags.contains(Flags::MISC_FROM_PRELUDE));\n+                    let note_msg = format!(\"this import refers to {what}\", what = what);\n+                    if binding.span.is_dummy() {\n+                        err.note(&note_msg);\n+                    } else {\n+                        err.span_note(binding.span, &note_msg);\n+                        err.span_label(binding.span, \"not an extern crate passed with `--extern`\");\n+                    }\n+                    err.emit();\n+                }\n+            }\n+\n             return Ok(binding);\n         }\n \n-        let determinacy = Determinacy::determined(force);\n-        if determinacy == Determinacy::Determined && kind == Some(MacroKind::Attr) {\n+        let determinacy = Determinacy::determined(determinacy == Determinacy::Determined || force);\n+        if determinacy == Determinacy::Determined && macro_kind == Some(MacroKind::Attr) {\n             // For single-segment attributes interpret determinate \"no resolution\" as a custom\n             // attribute. (Lexical resolution implies the first segment and attr kind should imply\n             // the last segment, so we are certainly working with a single-segment attribute here.)\n@@ -855,50 +946,69 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n \n+        let check_consistency = |this: &mut Self, path: &[Segment], span,\n+                                 kind: MacroKind, initial_def, def| {\n+            if let Some(initial_def) = initial_def {\n+                if def != initial_def && def != Def::Err && this.ambiguity_errors.is_empty() {\n+                    // Make sure compilation does not succeed if preferred macro resolution\n+                    // has changed after the macro had been expanded. In theory all such\n+                    // situations should be reported as ambiguity errors, so this is a bug.\n+                    span_bug!(span, \"inconsistent resolution for a macro\");\n+                }\n+            } else {\n+                // It's possible that the macro was unresolved (indeterminate) and silently\n+                // expanded into a dummy fragment for recovery during expansion.\n+                // Now, post-expansion, the resolution may succeed, but we can't change the\n+                // past and need to report an error.\n+                // However, non-speculative `resolve_path` can successfully return private items\n+                // even if speculative `resolve_path` returned nothing previously, so we skip this\n+                // less informative error if the privacy error is reported elsewhere.\n+                if this.privacy_errors.is_empty() {\n+                    let msg = format!(\"cannot determine resolution for the {} `{}`\",\n+                                        kind.descr(), Segment::names_to_string(path));\n+                    let msg_note = \"import resolution is stuck, try simplifying macro imports\";\n+                    this.session.struct_span_err(span, &msg).note(msg_note).emit();\n+                }\n+            }\n+        };\n+\n         let macro_resolutions =\n-            mem::replace(&mut *module.macro_resolutions.borrow_mut(), Vec::new());\n-        for (mut path, parent_scope, path_span) in macro_resolutions {\n+            mem::replace(&mut *module.multi_segment_macro_resolutions.borrow_mut(), Vec::new());\n+        for (mut path, path_span, kind, parent_scope, initial_def) in macro_resolutions {\n             // FIXME: Path resolution will ICE if segment IDs present.\n             for seg in &mut path { seg.id = None; }\n-            match self.resolve_path(None, &path, Some(MacroNS), &parent_scope,\n+            match self.resolve_path(&path, Some(MacroNS), &parent_scope,\n                                     true, path_span, CrateLint::No) {\n-                PathResult::NonModule(_) => {},\n-                PathResult::Failed(span, msg, _) => {\n+                PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n+                    let def = path_res.base_def();\n+                    check_consistency(self, &path, path_span, kind, initial_def, def);\n+                }\n+                path_res @ PathResult::NonModule(..) | path_res @  PathResult::Failed(..) => {\n+                    let (span, msg) = if let PathResult::Failed(span, msg, ..) = path_res {\n+                        (span, msg)\n+                    } else {\n+                        (path_span, format!(\"partially resolved path in {} {}\",\n+                                            kind.article(), kind.descr()))\n+                    };\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n-                _ => unreachable!(),\n+                PathResult::Module(..) | PathResult::Indeterminate => unreachable!(),\n             }\n         }\n \n-        let legacy_macro_resolutions =\n-            mem::replace(&mut *module.legacy_macro_resolutions.borrow_mut(), Vec::new());\n-        for (ident, kind, parent_scope, initial_binding) in legacy_macro_resolutions {\n-            let binding = self.early_resolve_ident_in_lexical_scope(\n-                ident, MacroNS, Some(kind), &parent_scope, true, true, ident.span\n-            );\n-            match binding {\n+        let macro_resolutions =\n+            mem::replace(&mut *module.single_segment_macro_resolutions.borrow_mut(), Vec::new());\n+        for (ident, kind, parent_scope, initial_binding) in macro_resolutions {\n+            match self.early_resolve_ident_in_lexical_scope(ident, MacroNS, Some(kind), false,\n+                                                            &parent_scope, true, true, ident.span) {\n                 Ok(binding) => {\n+                    let initial_def = initial_binding.map(|initial_binding| {\n+                        self.record_use(ident, MacroNS, initial_binding, false);\n+                        initial_binding.def_ignoring_ambiguity()\n+                    });\n                     let def = binding.def_ignoring_ambiguity();\n-                    if let Some(initial_binding) = initial_binding {\n-                        self.record_use(ident, MacroNS, initial_binding);\n-                        let initial_def = initial_binding.def_ignoring_ambiguity();\n-                        if self.ambiguity_errors.is_empty() &&\n-                           def != initial_def && def != Def::Err {\n-                            // Make sure compilation does not succeed if preferred macro resolution\n-                            // has changed after the macro had been expanded. In theory all such\n-                            // situations should be reported as ambiguity errors, so this is a bug.\n-                            span_bug!(ident.span, \"inconsistent resolution for a macro\");\n-                        }\n-                    } else {\n-                        // It's possible that the macro was unresolved (indeterminate) and silently\n-                        // expanded into a dummy fragment for recovery during expansion.\n-                        // Now, post-expansion, the resolution may succeed, but we can't change the\n-                        // past and need to report an error.\n-                        let msg = format!(\"cannot determine resolution for the {} `{}`\",\n-                                          kind.descr(), ident);\n-                        let msg_note = \"import resolution is stuck, try simplifying macro imports\";\n-                        self.session.struct_span_err(ident.span, &msg).note(msg_note).emit();\n-                    }\n+                    let seg = Segment::from_ident(ident);\n+                    check_consistency(self, &[seg], ident.span, kind, initial_def, def);\n                 }\n                 Err(..) => {\n                     assert!(initial_binding.is_none());\n@@ -914,18 +1024,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         let builtin_attrs = mem::replace(&mut *module.builtin_attrs.borrow_mut(), Vec::new());\n         for (ident, parent_scope) in builtin_attrs {\n-            let binding = self.early_resolve_ident_in_lexical_scope(\n-                ident, MacroNS, Some(MacroKind::Attr), &parent_scope, true, true, ident.span\n+            let _ = self.early_resolve_ident_in_lexical_scope(\n+                ident, MacroNS, Some(MacroKind::Attr), false, &parent_scope, true, true, ident.span\n             );\n-            if let Ok(binding) = binding {\n-                if binding.def_ignoring_ambiguity() !=\n-                        Def::NonMacroAttr(NonMacroAttrKind::Builtin) {\n-                    let builtin_binding = (Def::NonMacroAttr(NonMacroAttrKind::Builtin),\n-                                           ty::Visibility::Public, ident.span, Mark::root())\n-                                           .to_name_binding(self.arenas);\n-                    self.report_ambiguity_error(ident, binding, builtin_binding);\n-                }\n-            }\n         }\n     }\n \n@@ -992,7 +1093,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     def_index: invoc.def_index,\n                     module: Cell::new(graph_root),\n                     parent_legacy_scope: Cell::new(LegacyScope::Uninitialized),\n-                    output_legacy_scope: Cell::new(LegacyScope::Uninitialized),\n+                    output_legacy_scope: Cell::new(None),\n                 })\n             });\n         };"}, {"sha": "9e5036b6e500e25d43b0fd51926247596f2adf77", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 270, "deletions": 374, "changes": 644, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -10,7 +10,8 @@\n \n use self::ImportDirectiveSubclass::*;\n \n-use {AmbiguityError, CrateLint, Module, ModuleOrUniformRoot, PerNS};\n+use {AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n+use {CrateLint, Module, ModuleOrUniformRoot, PerNS, UniformRootKind, Weak};\n use Namespace::{self, TypeNS, MacroNS};\n use {NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use {Resolver, Segment};\n@@ -22,7 +23,7 @@ use rustc_data_structures::ptr_key::PtrKey;\n use rustc::ty;\n use rustc::lint::builtin::BuiltinLintDiagnostics;\n use rustc::lint::builtin::{DUPLICATE_MACRO_EXPORTS, PUB_USE_OF_PRIVATE_EXTERN_CRATE};\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{CrateNum, DefId};\n use rustc::hir::def::*;\n use rustc::session::DiagnosticMessageId;\n use rustc::util::nodemap::FxHashSet;\n@@ -35,7 +36,6 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{MultiSpan, Span};\n \n use std::cell::{Cell, RefCell};\n-use std::collections::BTreeMap;\n use std::{mem, ptr};\n \n /// Contains data for specific types of import directives.\n@@ -61,7 +61,7 @@ pub enum ImportDirectiveSubclass<'a> {\n \n /// One import directive.\n #[derive(Debug,Clone)]\n-pub struct ImportDirective<'a> {\n+crate struct ImportDirective<'a> {\n     /// The id of the `extern crate`, `UseTree` etc that imported this `ImportDirective`.\n     ///\n     /// In the case where the `ImportDirective` was expanded from a \"nested\" use tree,\n@@ -95,13 +95,6 @@ pub struct ImportDirective<'a> {\n     pub subclass: ImportDirectiveSubclass<'a>,\n     pub vis: Cell<ty::Visibility>,\n     pub used: Cell<bool>,\n-\n-    /// Whether this import is a \"canary\" for the `uniform_paths` feature,\n-    /// i.e. `use x::...;` results in an `use self::x as _;` canary.\n-    /// This flag affects diagnostics: an error is reported if and only if\n-    /// the import resolves successfully and an external crate with the same\n-    /// name (`x` above) also exists; any resolution failures are ignored.\n-    pub is_uniform_paths_canary: bool,\n }\n \n impl<'a> ImportDirective<'a> {\n@@ -142,110 +135,81 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                .or_insert_with(|| self.arenas.alloc_name_resolution())\n     }\n \n+    crate fn resolve_ident_in_module_unadjusted(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        ident: Ident,\n+        ns: Namespace,\n+        record_used: bool,\n+        path_span: Span,\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n+        self.resolve_ident_in_module_unadjusted_ext(\n+            module, ident, ns, None, false, record_used, path_span\n+        ).map_err(|(determinacy, _)| determinacy)\n+    }\n+\n     /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n     /// Invariant: if `record_used` is `Some`, expansion and import resolution must be complete.\n-    pub fn resolve_ident_in_module_unadjusted(&mut self,\n-                                              module: ModuleOrUniformRoot<'a>,\n-                                              ident: Ident,\n-                                              ns: Namespace,\n-                                              restricted_shadowing: bool,\n-                                              record_used: bool,\n-                                              path_span: Span)\n-                                              -> Result<&'a NameBinding<'a>, Determinacy> {\n+    crate fn resolve_ident_in_module_unadjusted_ext(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        ident: Ident,\n+        ns: Namespace,\n+        parent_scope: Option<&ParentScope<'a>>,\n+        restricted_shadowing: bool,\n+        record_used: bool,\n+        path_span: Span,\n+    ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n         let module = match module {\n             ModuleOrUniformRoot::Module(module) => module,\n-            ModuleOrUniformRoot::UniformRoot(root) => {\n-                // HACK(eddyb): `resolve_path` uses `keywords::Invalid` to indicate\n-                // paths of length 0, and currently these are relative `use` paths.\n-                let can_be_relative = !ident.is_path_segment_keyword() &&\n-                    root == keywords::Invalid.name();\n-                if can_be_relative {\n-                    // Relative paths should only get here if the feature-gate is on.\n-                    assert!(self.session.rust_2018() &&\n-                            self.session.features_untracked().uniform_paths);\n-\n-                    // Try first to resolve relatively.\n-                    let mut ctxt = ident.span.ctxt().modern();\n-                    let self_module = self.resolve_self(&mut ctxt, self.current_module);\n-\n-                    let binding = self.resolve_ident_in_module_unadjusted(\n-                        ModuleOrUniformRoot::Module(self_module),\n-                        ident,\n-                        ns,\n-                        restricted_shadowing,\n-                        record_used,\n-                        path_span,\n-                    );\n-\n-                    // FIXME(eddyb) This may give false negatives, specifically\n-                    // if a crate with the same name is found in `extern_prelude`,\n-                    // preventing the check below this one from returning `binding`\n-                    // in all cases.\n-                    //\n-                    // That is, if there's no crate with the same name, `binding`\n-                    // is always returned, which is the result of doing the exact\n-                    // same lookup of `ident`, in the `self` module.\n-                    // But when a crate does exist, it will get chosen even when\n-                    // macro expansion could result in a success from the lookup\n-                    // in the `self` module, later on.\n-                    //\n-                    // NB. This is currently alleviated by the \"ambiguity canaries\"\n-                    // (see `is_uniform_paths_canary`) that get introduced for the\n-                    // maybe-relative imports handled here: if the false negative\n-                    // case were to arise, it would *also* cause an ambiguity error.\n-                    if binding.is_ok() {\n-                        return binding;\n+            ModuleOrUniformRoot::UniformRoot(uniform_root_kind) => {\n+                assert!(!restricted_shadowing);\n+                match uniform_root_kind {\n+                    UniformRootKind::ExternPrelude => {\n+                        return if let Some(binding) =\n+                                self.extern_prelude_get(ident, !record_used, false) {\n+                            Ok(binding)\n+                        } else if !self.graph_root.unresolved_invocations.borrow().is_empty() {\n+                            // Macro-expanded `extern crate` items can add names to extern prelude.\n+                            Err((Undetermined, Weak::No))\n+                        } else {\n+                            Err((Determined, Weak::No))\n+                        }\n                     }\n+                    UniformRootKind::CurrentScope => {\n+                        let parent_scope =\n+                            parent_scope.expect(\"no parent scope for a single-segment import\");\n+\n+                        if ns == TypeNS {\n+                            if ident.name == keywords::Crate.name() ||\n+                               ident.name == keywords::DollarCrate.name() {\n+                                let module = self.resolve_crate_root(ident);\n+                                let binding = (module, ty::Visibility::Public,\n+                                               module.span, Mark::root())\n+                                               .to_name_binding(self.arenas);\n+                                return Ok(binding);\n+                            } else if ident.name == keywords::Super.name() ||\n+                                      ident.name == keywords::SelfValue.name() {\n+                                // FIXME: Implement these with renaming requirements so that e.g.\n+                                // `use super;` doesn't work, but `use super as name;` does.\n+                                // Fall through here to get an error from `early_resolve_...`.\n+                            }\n+                        }\n \n-                    // Fall back to resolving to an external crate.\n-                    if !(\n-                        ns == TypeNS &&\n-                        !ident.is_path_segment_keyword() &&\n-                        self.extern_prelude.contains_key(&ident.modern())\n-                    ) {\n-                        // ... unless the crate name is not in the `extern_prelude`.\n-                        return binding;\n+                        let binding = self.early_resolve_ident_in_lexical_scope(\n+                            ident, ns, None, true, parent_scope, record_used, record_used, path_span\n+                        );\n+                        return binding.map_err(|determinacy| (determinacy, Weak::No));\n                     }\n                 }\n-\n-                let crate_root = if\n-                    ns == TypeNS &&\n-                    root != keywords::Extern.name() &&\n-                    (\n-                        ident.name == keywords::Crate.name() ||\n-                        ident.name == keywords::DollarCrate.name()\n-                    )\n-                {\n-                    self.resolve_crate_root(ident)\n-                } else if\n-                    ns == TypeNS &&\n-                    !ident.is_path_segment_keyword()\n-                {\n-                    if let Some(binding) = self.extern_prelude_get(ident, !record_used, false) {\n-                        let module = self.get_module(binding.def().def_id());\n-                        self.populate_module_if_necessary(module);\n-                        return Ok(binding);\n-                    } else if !self.graph_root.unresolved_invocations.borrow().is_empty() {\n-                        // Macro-expanded `extern crate`items still can add names to extern prelude.\n-                        return Err(Undetermined);\n-                    } else {\n-                        return Err(Determined);\n-                    }\n-                } else {\n-                    return Err(Determined);\n-                };\n-                self.populate_module_if_necessary(crate_root);\n-                let binding = (crate_root, ty::Visibility::Public,\n-                               ident.span, Mark::root()).to_name_binding(self.arenas);\n-                return Ok(binding);\n             }\n         };\n \n         self.populate_module_if_necessary(module);\n \n         let resolution = self.resolution(module, ident, ns)\n             .try_borrow_mut()\n-            .map_err(|_| Determined)?; // This happens when there is a cycle of imports\n+            .map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n \n         if let Some(binding) = resolution.binding {\n             if !restricted_shadowing && binding.expansion != Mark::root() {\n@@ -255,37 +219,46 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             }\n         }\n \n+        let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n+            // `extern crate` are always usable for backwards compatibility, see issue #37020,\n+            // remove this together with `PUB_USE_OF_PRIVATE_EXTERN_CRATE`.\n+            let usable = this.is_accessible(binding.vis) || binding.is_extern_crate();\n+            if usable { Ok(binding) } else { Err((Determined, Weak::No)) }\n+        };\n+\n         if record_used {\n-            if let Some(binding) = resolution.binding {\n-                if let Some(shadowed_glob) = resolution.shadowed_glob {\n-                    // Forbid expanded shadowing to avoid time travel.\n-                    if restricted_shadowing &&\n-                       binding.expansion != Mark::root() &&\n-                       ns != MacroNS && // In MacroNS, `try_define` always forbids this shadowing\n-                       binding.def() != shadowed_glob.def() {\n-                        self.ambiguity_errors.push(AmbiguityError {\n-                            ident,\n-                            b1: binding,\n-                            b2: shadowed_glob,\n-                        });\n+            return resolution.binding.ok_or((Determined, Weak::No)).and_then(|binding| {\n+                if self.last_import_segment && check_usable(self, binding).is_err() {\n+                    Err((Determined, Weak::No))\n+                } else {\n+                    self.record_use(ident, ns, binding, restricted_shadowing);\n+\n+                    if let Some(shadowed_glob) = resolution.shadowed_glob {\n+                        // Forbid expanded shadowing to avoid time travel.\n+                        if restricted_shadowing &&\n+                        binding.expansion != Mark::root() &&\n+                        binding.def() != shadowed_glob.def() {\n+                            self.ambiguity_errors.push(AmbiguityError {\n+                                kind: AmbiguityKind::GlobVsExpanded,\n+                                ident,\n+                                b1: binding,\n+                                b2: shadowed_glob,\n+                                misc1: AmbiguityErrorMisc::None,\n+                                misc2: AmbiguityErrorMisc::None,\n+                            });\n+                        }\n                     }\n-                }\n-                if self.record_use(ident, ns, binding) {\n-                    return Ok(self.dummy_binding);\n-                }\n-                if !self.is_accessible(binding.vis) {\n-                    self.privacy_errors.push(PrivacyError(path_span, ident, binding));\n-                }\n-            }\n \n-            return resolution.binding.ok_or(Determined);\n-        }\n+                    if !self.is_accessible(binding.vis) &&\n+                       // Remove this together with `PUB_USE_OF_PRIVATE_EXTERN_CRATE`\n+                       !(self.last_import_segment && binding.is_extern_crate()) {\n+                        self.privacy_errors.push(PrivacyError(path_span, ident, binding));\n+                    }\n \n-        let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n-            // `extern crate` are always usable for backwards compatibility, see issue #37020.\n-            let usable = this.is_accessible(binding.vis) || binding.is_extern_crate();\n-            if usable { Ok(binding) } else { Err(Determined) }\n-        };\n+                    Ok(binding)\n+                }\n+            })\n+        }\n \n         // Items and single imports are not shadowable, if we have one, then it's determined.\n         if let Some(binding) = resolution.binding {\n@@ -302,17 +275,19 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             if !self.is_accessible(single_import.vis.get()) {\n                 continue;\n             }\n-            let module = unwrap_or!(single_import.imported_module.get(), return Err(Undetermined));\n+            let module = unwrap_or!(single_import.imported_module.get(),\n+                                    return Err((Undetermined, Weak::No)));\n             let ident = match single_import.subclass {\n                 SingleImport { source, .. } => source,\n                 _ => unreachable!(),\n             };\n-            match self.resolve_ident_in_module(module, ident, ns, false, path_span) {\n+            match self.resolve_ident_in_module(module, ident, ns, Some(&single_import.parent_scope),\n+                                               false, path_span) {\n                 Err(Determined) => continue,\n                 Ok(binding) if !self.is_accessible_from(\n                     binding.vis, single_import.parent_scope.module\n                 ) => continue,\n-                Ok(_) | Err(Undetermined) => return Err(Undetermined),\n+                Ok(_) | Err(Undetermined) => return Err((Undetermined, Weak::No)),\n             }\n         }\n \n@@ -333,7 +308,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             if !unexpanded_macros || ns == MacroNS || restricted_shadowing {\n                 return check_usable(self, binding);\n             } else {\n-                return Err(Undetermined);\n+                return Err((Undetermined, Weak::No));\n             }\n         }\n \n@@ -342,17 +317,13 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         // Now we are in situation when new item/import can appear only from a glob or a macro\n         // expansion. With restricted shadowing names from globs and macro expansions cannot\n         // shadow names from outer scopes, so we can freely fallback from module search to search\n-        // in outer scopes. To continue search in outer scopes we have to lie a bit and return\n-        // `Determined` to `early_resolve_ident_in_lexical_scope` even if the correct answer\n-        // for in-module resolution could be `Undetermined`.\n-        if restricted_shadowing {\n-            return Err(Determined);\n-        }\n+        // in outer scopes. For `early_resolve_ident_in_lexical_scope` to continue search in outer\n+        // scopes we return `Undetermined` with `Weak::Yes`.\n \n         // Check if one of unexpanded macros can still define the name,\n         // if it can then our \"no resolution\" result is not determined and can be invalidated.\n         if unexpanded_macros {\n-            return Err(Undetermined);\n+            return Err((Undetermined, Weak::Yes));\n         }\n \n         // Check if one of glob imports can still define the name,\n@@ -364,7 +335,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             let module = match glob_import.imported_module.get() {\n                 Some(ModuleOrUniformRoot::Module(module)) => module,\n                 Some(ModuleOrUniformRoot::UniformRoot(_)) => continue,\n-                None => return Err(Undetermined),\n+                None => return Err((Undetermined, Weak::Yes)),\n             };\n             let (orig_current_module, mut ident) = (self.current_module, ident.modern());\n             match ident.span.glob_adjust(module.expansion, glob_import.span.ctxt().modern()) {\n@@ -377,7 +348,6 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                 ident,\n                 ns,\n                 false,\n-                false,\n                 path_span,\n             );\n             self.current_module = orig_current_module;\n@@ -387,12 +357,12 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                 Ok(binding) if !self.is_accessible_from(\n                     binding.vis, glob_import.parent_scope.module\n                 ) => continue,\n-                Ok(_) | Err(Undetermined) => return Err(Undetermined),\n+                Ok(_) | Err(Undetermined) => return Err((Undetermined, Weak::Yes)),\n             }\n         }\n \n         // No resolution and no one else can define the name - determinate error.\n-        Err(Determined)\n+        Err((Determined, Weak::No))\n     }\n \n     // Add an import directive to the current module.\n@@ -404,8 +374,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                                 root_span: Span,\n                                 root_id: NodeId,\n                                 vis: ty::Visibility,\n-                                parent_scope: ParentScope<'a>,\n-                                is_uniform_paths_canary: bool) {\n+                                parent_scope: ParentScope<'a>) {\n         let current_module = parent_scope.module;\n         let directive = self.arenas.alloc_import_directive(ImportDirective {\n             parent_scope,\n@@ -418,7 +387,6 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             root_id,\n             vis: Cell::new(vis),\n             used: Cell::new(false),\n-            is_uniform_paths_canary,\n         });\n \n         debug!(\"add_import_directive({:?})\", directive);\n@@ -441,8 +409,8 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n \n     // Given a binding and an import directive that resolves to it,\n     // return the corresponding binding defined by the import directive.\n-    pub fn import(&self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n-                  -> &'a NameBinding<'a> {\n+    crate fn import(&self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n+                    -> &'a NameBinding<'a> {\n         let vis = if binding.pseudo_vis().is_at_least(directive.vis.get(), self) ||\n                      // c.f. `PUB_USE_OF_PRIVATE_EXTERN_CRATE`\n                      !directive.is_glob() && binding.is_extern_crate() {\n@@ -490,38 +458,48 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         self.set_binding_parent_module(binding, module);\n         self.update_resolution(module, ident, ns, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n-                if binding.is_glob_import() {\n-                    if !old_binding.is_glob_import() &&\n-                       !(ns == MacroNS && old_binding.expansion != Mark::root()) {\n-                        resolution.shadowed_glob = Some(binding);\n-                    } else if binding.def() != old_binding.def() {\n-                        resolution.binding = Some(this.ambiguity(old_binding, binding));\n-                    } else if !old_binding.vis.is_at_least(binding.vis, &*this) {\n-                        // We are glob-importing the same item but with greater visibility.\n-                        resolution.binding = Some(binding);\n+                match (old_binding.is_glob_import(), binding.is_glob_import()) {\n+                    (true, true) => {\n+                        if binding.def() != old_binding.def() {\n+                            resolution.binding = Some(this.ambiguity(AmbiguityKind::GlobVsGlob,\n+                                                                     old_binding, binding));\n+                        } else if !old_binding.vis.is_at_least(binding.vis, &*this) {\n+                            // We are glob-importing the same item but with greater visibility.\n+                            resolution.binding = Some(binding);\n+                        }\n                     }\n-                } else if old_binding.is_glob_import() {\n-                    if ns == MacroNS && binding.expansion != Mark::root() &&\n-                       binding.def() != old_binding.def() {\n-                        resolution.binding = Some(this.ambiguity(binding, old_binding));\n-                    } else {\n-                        resolution.binding = Some(binding);\n-                        resolution.shadowed_glob = Some(old_binding);\n+                    (old_glob @ true, false) | (old_glob @ false, true) => {\n+                        let (glob_binding, nonglob_binding) = if old_glob {\n+                            (old_binding, binding)\n+                        } else {\n+                            (binding, old_binding)\n+                        };\n+                        if glob_binding.def() != nonglob_binding.def() &&\n+                           ns == MacroNS && nonglob_binding.expansion != Mark::root() {\n+                            resolution.binding = Some(this.ambiguity(AmbiguityKind::GlobVsExpanded,\n+                                                                    nonglob_binding, glob_binding));\n+                        } else {\n+                            resolution.binding = Some(nonglob_binding);\n+                            resolution.shadowed_glob = Some(glob_binding);\n+                        }\n+                    }\n+                    (false, false) => {\n+                        if let (&NameBindingKind::Def(_, true), &NameBindingKind::Def(_, true)) =\n+                               (&old_binding.kind, &binding.kind) {\n+\n+                            this.session.buffer_lint_with_diagnostic(\n+                                DUPLICATE_MACRO_EXPORTS,\n+                                CRATE_NODE_ID,\n+                                binding.span,\n+                                &format!(\"a macro named `{}` has already been exported\", ident),\n+                                BuiltinLintDiagnostics::DuplicatedMacroExports(\n+                                    ident, old_binding.span, binding.span));\n+\n+                            resolution.binding = Some(binding);\n+                        } else {\n+                            return Err(old_binding);\n+                        }\n                     }\n-                } else if let (&NameBindingKind::Def(_, true), &NameBindingKind::Def(_, true)) =\n-                        (&old_binding.kind, &binding.kind) {\n-\n-                    this.session.buffer_lint_with_diagnostic(\n-                        DUPLICATE_MACRO_EXPORTS,\n-                        CRATE_NODE_ID,\n-                        binding.span,\n-                        &format!(\"a macro named `{}` has already been exported\", ident),\n-                        BuiltinLintDiagnostics::DuplicatedMacroExports(\n-                            ident, old_binding.span, binding.span));\n-\n-                    resolution.binding = Some(binding);\n-                } else {\n-                    return Err(old_binding);\n                 }\n             } else {\n                 resolution.binding = Some(binding);\n@@ -531,10 +509,10 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         })\n     }\n \n-    pub fn ambiguity(&self, b1: &'a NameBinding<'a>, b2: &'a NameBinding<'a>)\n+    fn ambiguity(&self, kind: AmbiguityKind, b1: &'a NameBinding<'a>, b2: &'a NameBinding<'a>)\n                      -> &'a NameBinding<'a> {\n         self.arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Ambiguity { b1, b2 },\n+            kind: NameBindingKind::Ambiguity { kind, b1, b2 },\n             vis: if b1.vis.is_at_least(b2.vis, self) { b1.vis } else { b2.vis },\n             span: b1.span,\n             expansion: Mark::root(),\n@@ -648,65 +626,13 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             self.finalize_resolutions_in(module);\n         }\n \n-        struct UniformPathsCanaryResults<'a> {\n-            name: Name,\n-            module_scope: Option<&'a NameBinding<'a>>,\n-            block_scopes: Vec<&'a NameBinding<'a>>,\n-        }\n-\n-        // Collect all tripped `uniform_paths` canaries separately.\n-        let mut uniform_paths_canaries: BTreeMap<\n-            (Span, NodeId, Namespace),\n-            UniformPathsCanaryResults,\n-        > = BTreeMap::new();\n-\n         let mut errors = false;\n         let mut seen_spans = FxHashSet::default();\n         let mut error_vec = Vec::new();\n         let mut prev_root_id: NodeId = NodeId::from_u32(0);\n         for i in 0 .. self.determined_imports.len() {\n             let import = self.determined_imports[i];\n-            let error = self.finalize_import(import);\n-\n-            // For a `#![feature(uniform_paths)]` `use self::x as _` canary,\n-            // failure is ignored, while success may cause an ambiguity error.\n-            if import.is_uniform_paths_canary {\n-                if error.is_some() {\n-                    continue;\n-                }\n-\n-                let (name, result) = match import.subclass {\n-                    SingleImport { source, ref result, .. } => (source.name, result),\n-                    _ => bug!(),\n-                };\n-\n-                let has_explicit_self =\n-                    !import.module_path.is_empty() &&\n-                    import.module_path[0].ident.name == keywords::SelfValue.name();\n-\n-                self.per_ns(|_, ns| {\n-                    if let Some(result) = result[ns].get().ok() {\n-                        let canary_results =\n-                            uniform_paths_canaries.entry((import.span, import.id, ns))\n-                                .or_insert(UniformPathsCanaryResults {\n-                                    name,\n-                                    module_scope: None,\n-                                    block_scopes: vec![],\n-                                });\n-\n-                        // All the canaries with the same `id` should have the same `name`.\n-                        assert_eq!(canary_results.name, name);\n-\n-                        if has_explicit_self {\n-                            // There should only be one `self::x` (module-scoped) canary.\n-                            assert!(canary_results.module_scope.is_none());\n-                            canary_results.module_scope = Some(result);\n-                        } else {\n-                            canary_results.block_scopes.push(result);\n-                        }\n-                    }\n-                });\n-            } else if let Some((span, err, note)) = error {\n+            if let Some((span, err, note)) = self.finalize_import(import) {\n                 errors = true;\n \n                 if let SingleImport { source, ref result, .. } = import.subclass {\n@@ -743,71 +669,6 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             }\n         }\n \n-        let uniform_paths_feature = self.session.features_untracked().uniform_paths;\n-        for ((span, _, ns), results) in uniform_paths_canaries {\n-            let name = results.name;\n-            let external_crate = if ns == TypeNS {\n-                self.extern_prelude_get(Ident::with_empty_ctxt(name), true, false)\n-                    .map(|binding| binding.def())\n-            } else {\n-                None\n-            };\n-\n-            // Currently imports can't resolve in non-module scopes,\n-            // we only have canaries in them for future-proofing.\n-            if external_crate.is_none() && results.module_scope.is_none() {\n-                continue;\n-            }\n-\n-            {\n-                let mut all_results = external_crate.into_iter().chain(\n-                    results.module_scope.iter()\n-                        .chain(&results.block_scopes)\n-                        .map(|binding| binding.def())\n-                );\n-                let first = all_results.next().unwrap();\n-\n-                // An ambiguity requires more than one *distinct* possible resolution.\n-                let possible_resultions =\n-                    1 + all_results.filter(|&def| def != first).count();\n-                if possible_resultions <= 1 {\n-                    continue;\n-                }\n-            }\n-\n-            errors = true;\n-\n-            let msg = format!(\"`{}` import is ambiguous\", name);\n-            let mut err = self.session.struct_span_err(span, &msg);\n-            let mut suggestion_choices = vec![];\n-            if external_crate.is_some() {\n-                suggestion_choices.push(format!(\"`::{}`\", name));\n-                err.span_label(span,\n-                    format!(\"can refer to external crate `::{}`\", name));\n-            }\n-            if let Some(result) = results.module_scope {\n-                suggestion_choices.push(format!(\"`self::{}`\", name));\n-                if uniform_paths_feature {\n-                    err.span_label(result.span,\n-                        format!(\"can refer to `self::{}`\", name));\n-                } else {\n-                    err.span_label(result.span,\n-                        format!(\"may refer to `self::{}` in the future\", name));\n-                }\n-            }\n-            for result in results.block_scopes {\n-                err.span_label(result.span,\n-                    format!(\"shadowed by block-scoped `{}`\", name));\n-            }\n-            err.help(&format!(\"write {} explicitly instead\", suggestion_choices.join(\" or \")));\n-            if uniform_paths_feature {\n-                err.note(\"relative `use` paths enabled by `#![feature(uniform_paths)]`\");\n-            } else {\n-                err.note(\"in the future, `#![feature(uniform_paths)]` may become the default\");\n-            }\n-            err.emit();\n-        }\n-\n         if !error_vec.is_empty() {\n             self.throw_unresolved_import_error(error_vec.clone(), None);\n         }\n@@ -816,9 +677,6 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         // to avoid generating multiple errors on the same import.\n         if !errors {\n             for import in &self.indeterminate_imports {\n-                if import.is_uniform_paths_canary {\n-                    continue;\n-                }\n                 self.throw_unresolved_import_error(error_vec, Some(MultiSpan::from(import.span)));\n                 break;\n             }\n@@ -871,37 +729,31 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     /// If successful, the resolved bindings are written into the module.\n     fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> bool {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               Segment::names_to_string(&directive.module_path[..]),\n+               Segment::names_to_string(&directive.module_path),\n                module_to_string(self.current_module).unwrap_or_else(|| \"???\".to_string()));\n \n         self.current_module = directive.parent_scope.module;\n \n         let module = if let Some(module) = directive.imported_module.get() {\n             module\n         } else {\n-            let vis = directive.vis.get();\n-            // For better failure detection, pretend that the import will not define any names\n-            // while resolving its module path.\n-            directive.vis.set(ty::Visibility::Invisible);\n-            let result = self.resolve_path(\n-                Some(if directive.is_uniform_paths_canary {\n-                    ModuleOrUniformRoot::Module(directive.parent_scope.module)\n-                } else {\n-                    ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())\n-                }),\n-                &directive.module_path[..],\n+            // For better failure detection, pretend that the import will\n+            // not define any names while resolving its module path.\n+            let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+            let path_res = self.resolve_path(\n+                &directive.module_path,\n                 None,\n                 &directive.parent_scope,\n                 false,\n                 directive.span,\n                 directive.crate_lint(),\n             );\n-            directive.vis.set(vis);\n+            directive.vis.set(orig_vis);\n \n-            match result {\n+            match path_res {\n                 PathResult::Module(module) => module,\n                 PathResult::Indeterminate => return false,\n-                _ => return true,\n+                PathResult::NonModule(..) | PathResult::Failed(..) => return true,\n             }\n         };\n \n@@ -919,11 +771,15 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         let mut indeterminate = false;\n         self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n             if let Err(Undetermined) = result[ns].get() {\n-                result[ns].set(this.resolve_ident_in_module(module,\n-                                                            source,\n-                                                            ns,\n-                                                            false,\n-                                                            directive.span));\n+                // For better failure detection, pretend that the import will\n+                // not define any names while resolving its module path.\n+                let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+                let binding = this.resolve_ident_in_module(\n+                    module, source, ns, Some(&directive.parent_scope), false, directive.span\n+                );\n+                directive.vis.set(orig_vis);\n+\n+                result[ns].set(binding);\n             } else {\n                 return\n             };\n@@ -964,50 +820,62 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         directive: &'b ImportDirective<'b>\n     ) -> Option<(Span, String, Option<String>)> {\n         self.current_module = directive.parent_scope.module;\n-        let ImportDirective { ref module_path, span, .. } = *directive;\n \n-        let module_result = self.resolve_path(\n-            Some(if directive.is_uniform_paths_canary {\n-                ModuleOrUniformRoot::Module(directive.parent_scope.module)\n-            } else {\n-                ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())\n-            }),\n-            &module_path,\n-            None,\n-            &directive.parent_scope,\n-            true,\n-            span,\n-            directive.crate_lint(),\n-        );\n-        let module = match module_result {\n-            PathResult::Module(module) => module,\n+        let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+        let path_res = self.resolve_path(&directive.module_path, None, &directive.parent_scope,\n+                                         true, directive.span, directive.crate_lint());\n+        directive.vis.set(orig_vis);\n+        let module = match path_res {\n+            PathResult::Module(module) => {\n+                // Consistency checks, analogous to `finalize_current_module_macro_resolutions`.\n+                if let Some(initial_module) = directive.imported_module.get() {\n+                    if module != initial_module && self.ambiguity_errors.is_empty() {\n+                        span_bug!(directive.span, \"inconsistent resolution for an import\");\n+                    }\n+                } else {\n+                    if self.privacy_errors.is_empty() {\n+                        let msg = \"cannot determine resolution for the import\";\n+                        let msg_note = \"import resolution is stuck, try simplifying other imports\";\n+                        self.session.struct_span_err(directive.span, msg).note(msg_note).emit();\n+                    }\n+                }\n+\n+                module\n+            }\n             PathResult::Failed(span, msg, false) => {\n+                assert!(directive.imported_module.get().is_none());\n                 resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 return None;\n             }\n             PathResult::Failed(span, msg, true) => {\n+                assert!(directive.imported_module.get().is_none());\n                 return if let Some((suggested_path, note)) = self.make_path_suggestion(\n-                    span, module_path.clone(), &directive.parent_scope\n+                    span, directive.module_path.clone(), &directive.parent_scope\n                 ) {\n                     Some((\n                         span,\n-                        format!(\"Did you mean `{}`?\", Segment::names_to_string(&suggested_path)),\n+                        format!(\"did you mean `{}`?\", Segment::names_to_string(&suggested_path)),\n                         note,\n                     ))\n                 } else {\n                     Some((span, msg, None))\n                 };\n-            },\n-            _ => return None,\n+            }\n+            PathResult::NonModule(path_res) if path_res.base_def() == Def::Err => {\n+                // The error was already reported earlier.\n+                assert!(directive.imported_module.get().is_none());\n+                return None;\n+            }\n+            PathResult::Indeterminate | PathResult::NonModule(..) => unreachable!(),\n         };\n \n         let (ident, result, type_ns_only) = match directive.subclass {\n             SingleImport { source, ref result, type_ns_only, .. } => (source, result, type_ns_only),\n             GlobImport { is_prelude, ref max_vis } => {\n-                if module_path.len() <= 1 {\n+                if directive.module_path.len() <= 1 {\n                     // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n                     // 2 segments, so the `resolve_path` above won't trigger it.\n-                    let mut full_path = module_path.clone();\n+                    let mut full_path = directive.module_path.clone();\n                     full_path.push(Segment::from_ident(keywords::Invalid.ident()));\n                     self.lint_if_path_starts_with_module(\n                         directive.crate_lint(),\n@@ -1038,34 +906,58 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             _ => unreachable!(),\n         };\n \n-        // Do not record uses from canaries, to avoid interfering with other\n-        // diagnostics or suggestions that rely on some items not being used.\n-        let record_used = !directive.is_uniform_paths_canary;\n-\n         let mut all_ns_err = true;\n         self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-            if let Ok(binding) = result[ns].get() {\n-                all_ns_err = false;\n-                if record_used && this.record_use(ident, ns, binding) {\n-                    if let ModuleOrUniformRoot::Module(module) = module {\n-                        this.resolution(module, ident, ns).borrow_mut().binding =\n-                            Some(this.dummy_binding);\n+            let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+            let orig_last_import_segment = mem::replace(&mut this.last_import_segment, true);\n+            let binding = this.resolve_ident_in_module(\n+                module, ident, ns, Some(&directive.parent_scope), true, directive.span\n+            );\n+            this.last_import_segment = orig_last_import_segment;\n+            directive.vis.set(orig_vis);\n+\n+            match binding {\n+                Ok(binding) => {\n+                    // Consistency checks, analogous to `finalize_current_module_macro_resolutions`.\n+                    let initial_def = result[ns].get().map(|initial_binding| {\n+                        all_ns_err = false;\n+                        this.record_use(ident, ns, initial_binding,\n+                                        directive.module_path.is_empty());\n+                        initial_binding.def_ignoring_ambiguity()\n+                    });\n+                    let def = binding.def_ignoring_ambiguity();\n+                    if let Ok(initial_def) = initial_def {\n+                        if def != initial_def && this.ambiguity_errors.is_empty() {\n+                            span_bug!(directive.span, \"inconsistent resolution for an import\");\n+                        }\n+                    } else {\n+                        if def != Def::Err &&\n+                           this.ambiguity_errors.is_empty() && this.privacy_errors.is_empty() {\n+                            let msg = \"cannot determine resolution for the import\";\n+                            let msg_note =\n+                                \"import resolution is stuck, try simplifying other imports\";\n+                            this.session.struct_span_err(directive.span, msg).note(msg_note).emit();\n+                        }\n                     }\n                 }\n-                if record_used && ns == TypeNS {\n-                    if let ModuleOrUniformRoot::UniformRoot(..) = module {\n-                        // Make sure single-segment import is resolved non-speculatively\n-                        // at least once to report the feature error.\n-                        this.extern_prelude_get(ident, false, false);\n-                    }\n+                Err(..) => {\n+                    // FIXME: This assert may fire if public glob is later shadowed by a private\n+                    // single import (see test `issue-55884-2.rs`). In theory single imports should\n+                    // always block globs, even if they are not yet resolved, so that this kind of\n+                    // self-inconsistent resolution never happens.\n+                    // Reenable the assert when the issue is fixed.\n+                    // assert!(result[ns].get().is_err());\n                 }\n             }\n         });\n \n         if all_ns_err {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-                if this.resolve_ident_in_module(module, ident, ns, record_used, span).is_ok() {\n+                let binding = this.resolve_ident_in_module(\n+                    module, ident, ns, Some(&directive.parent_scope), true, directive.span\n+                );\n+                if binding.is_ok() {\n                     all_ns_failed = false;\n                 }\n             });\n@@ -1122,7 +1014,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                         }\n                     }\n                 };\n-                Some((span, msg, None))\n+                Some((directive.span, msg, None))\n             } else {\n                 // `resolve_ident_in_module` reported a privacy error.\n                 self.import_dummy_binding(directive);\n@@ -1171,10 +1063,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             }\n         }\n \n-        if module_path.len() <= 1 {\n+        if directive.module_path.len() <= 1 {\n             // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n             // 2 segments, so the `resolve_path` above won't trigger it.\n-            let mut full_path = module_path.clone();\n+            let mut full_path = directive.module_path.clone();\n             full_path.push(Segment::from_ident(ident));\n             self.per_ns(|this, ns| {\n                 if let Ok(binding) = result[ns].get() {\n@@ -1192,8 +1084,18 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n         self.per_ns(|this, ns| if let Some(binding) = result[ns].get().ok() {\n+            let mut def = binding.def();\n+            if let Def::Macro(def_id, _) = def {\n+                // `DefId`s from the \"built-in macro crate\" should not leak from resolve because\n+                // later stages are not ready to deal with them and produce lots of ICEs. Replace\n+                // them with `Def::Err` until some saner scheme is implemented for built-in macros.\n+                if def_id.krate == CrateNum::BuiltinMacros {\n+                    this.session.span_err(directive.span, \"cannot import a built-in macro\");\n+                    def = Def::Err;\n+                }\n+            }\n             let import = this.import_map.entry(directive.id).or_default();\n-            import[ns] = Some(PathResolution::new(binding.def()));\n+            import[ns] = Some(PathResolution::new(def));\n         });\n \n         debug!(\"(resolving single import) successfully resolved import\");\n@@ -1262,19 +1164,13 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 None => continue,\n             };\n \n-            // Don't reexport `uniform_path` canaries.\n-            let non_canary_import = match binding.kind {\n-                NameBindingKind::Import { directive, .. } => {\n-                    !directive.is_uniform_paths_canary\n-                }\n-                _ => false,\n-            };\n-\n-            if non_canary_import || binding.is_macro_def() {\n+            if binding.is_import() || binding.is_macro_def() {\n                 let def = binding.def();\n                 if def != Def::Err {\n-                    if !def.def_id().is_local() {\n-                        self.cstore.export_macros_untracked(def.def_id().krate);\n+                    if let Some(def_id) = def.opt_def_id() {\n+                        if !def_id.is_local() && def_id.krate != CrateNum::BuiltinMacros {\n+                            self.cstore.export_macros_untracked(def_id.krate);\n+                        }\n                     }\n                     reexports.push(Export {\n                         ident: ident.modern(),"}, {"sha": "85c9b6ee7285eabde8c48ffb5d9965638c8c08eb", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -477,7 +477,7 @@ fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n     let mut resolver = cx.resolver.borrow_mut();\n     let parent_scope = resolver.dummy_parent_scope();\n     if let Ok(def) = resolver.resolve_macro_to_def_inner(&path, MacroKind::Bang,\n-                                                         &parent_scope, false) {\n+                                                         &parent_scope, false, false) {\n         if let SyntaxExtension::DeclMacro { .. } = *resolver.get_macro(def) {\n             return Some(def);\n         }"}, {"sha": "bb927b62a181ed779e94b8393c4d2e5e4c88f918", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -595,6 +595,13 @@ impl MacroKind {\n             MacroKind::ProcMacroStub => \"crate-local procedural macro\",\n         }\n     }\n+\n+    pub fn article(self) -> &'static str {\n+        match self {\n+            MacroKind::Attr => \"an\",\n+            _ => \"a\",\n+        }\n+    }\n }\n \n /// An enum representing the different kinds of syntax extensions."}, {"sha": "8478ff1a6ae6c7616833547b4f4323bd5a1a6a18", "filename": "src/test/ui-fulldeps/custom-derive/derive-in-mod.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fderive-in-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fderive-in-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fderive-in-mod.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,13 @@\n+// compile-pass\n+// aux-build:plugin.rs\n+\n+extern crate plugin;\n+\n+mod inner {\n+    use plugin::WithHelper;\n+\n+    #[derive(WithHelper)]\n+    struct S;\n+}\n+\n+fn main() {}"}, {"sha": "ee98873064fc4a6253c7a348337cf31a5456ad23", "filename": "src/test/ui-fulldeps/custom-derive/helper-attr-blocked-by-import-ambig.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,19 +1,20 @@\n-error[E0659]: `helper` is ambiguous\n+error[E0659]: `helper` is ambiguous (derive helper attribute vs any other name)\n   --> $DIR/helper-attr-blocked-by-import-ambig.rs:10:3\n    |\n LL | #[helper] //~ ERROR `helper` is ambiguous\n    |   ^^^^^^ ambiguous name\n    |\n-note: `helper` could refer to the name defined here\n+note: `helper` could refer to the derive helper attribute defined here\n   --> $DIR/helper-attr-blocked-by-import-ambig.rs:9:10\n    |\n LL | #[derive(WithHelper)]\n    |          ^^^^^^^^^^\n-note: `helper` could also refer to the name imported here\n+note: `helper` could also refer to the attribute macro imported here\n   --> $DIR/helper-attr-blocked-by-import-ambig.rs:7:5\n    |\n LL | use plugin::helper;\n    |     ^^^^^^^^^^^^^^\n+   = help: use `self::helper` to refer to this attribute macro unambiguously\n \n error: aborting due to previous error\n "}, {"sha": "34b21ea26830c1e7458722e7e9486bb29aeac167", "filename": "src/test/ui-fulldeps/proc-macro/ambiguous-builtin-attrs.stderr", "status": "modified", "additions": 26, "deletions": 46, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,98 +1,78 @@\n-error[E0659]: `repr` is ambiguous\n+error[E0425]: cannot find value `NonExistent` in this scope\n+  --> $DIR/ambiguous-builtin-attrs.rs:30:5\n+   |\n+LL |     NonExistent; //~ ERROR cannot find value `NonExistent` in this scope\n+   |     ^^^^^^^^^^^ not found in this scope\n+\n+error[E0659]: `repr` is ambiguous (built-in attribute vs any other name)\n   --> $DIR/ambiguous-builtin-attrs.rs:9:3\n    |\n LL | #[repr(C)] //~ ERROR `repr` is ambiguous\n    |   ^^^^ ambiguous name\n    |\n-note: `repr` could refer to the name imported here\n+   = note: `repr` could refer to a built-in attribute\n+note: `repr` could also refer to the attribute macro imported here\n   --> $DIR/ambiguous-builtin-attrs.rs:7:5\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n-note: `repr` could also refer to the name defined here\n-  --> $DIR/ambiguous-builtin-attrs.rs:9:3\n-   |\n-LL | #[repr(C)] //~ ERROR `repr` is ambiguous\n-   |   ^^^^\n-   = note: consider adding an explicit import of `repr` to disambiguate\n+   = help: use `self::repr` to refer to this attribute macro unambiguously\n \n-error[E0659]: `repr` is ambiguous\n+error[E0659]: `repr` is ambiguous (built-in attribute vs any other name)\n   --> $DIR/ambiguous-builtin-attrs.rs:11:19\n    |\n LL | #[cfg_attr(all(), repr(C))] //~ ERROR `repr` is ambiguous\n    |                   ^^^^ ambiguous name\n    |\n-note: `repr` could refer to the name imported here\n+   = note: `repr` could refer to a built-in attribute\n+note: `repr` could also refer to the attribute macro imported here\n   --> $DIR/ambiguous-builtin-attrs.rs:7:5\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n-note: `repr` could also refer to the name defined here\n-  --> $DIR/ambiguous-builtin-attrs.rs:11:19\n-   |\n-LL | #[cfg_attr(all(), repr(C))] //~ ERROR `repr` is ambiguous\n-   |                   ^^^^\n-   = note: consider adding an explicit import of `repr` to disambiguate\n+   = help: use `self::repr` to refer to this attribute macro unambiguously\n \n-error[E0659]: `repr` is ambiguous\n+error[E0659]: `repr` is ambiguous (built-in attribute vs any other name)\n   --> $DIR/ambiguous-builtin-attrs.rs:20:34\n    |\n LL | fn non_macro_expanded_location<#[repr(C)] T>() { //~ ERROR `repr` is ambiguous\n    |                                  ^^^^ ambiguous name\n    |\n-note: `repr` could refer to the name imported here\n+   = note: `repr` could refer to a built-in attribute\n+note: `repr` could also refer to the attribute macro imported here\n   --> $DIR/ambiguous-builtin-attrs.rs:7:5\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n-note: `repr` could also refer to the name defined here\n-  --> $DIR/ambiguous-builtin-attrs.rs:20:34\n-   |\n-LL | fn non_macro_expanded_location<#[repr(C)] T>() { //~ ERROR `repr` is ambiguous\n-   |                                  ^^^^\n-   = note: consider adding an explicit import of `repr` to disambiguate\n+   = help: use `self::repr` to refer to this attribute macro unambiguously\n \n-error[E0659]: `repr` is ambiguous\n+error[E0659]: `repr` is ambiguous (built-in attribute vs any other name)\n   --> $DIR/ambiguous-builtin-attrs.rs:22:11\n    |\n LL |         #[repr(C)] //~ ERROR `repr` is ambiguous\n    |           ^^^^ ambiguous name\n    |\n-note: `repr` could refer to the name imported here\n+   = note: `repr` could refer to a built-in attribute\n+note: `repr` could also refer to the attribute macro imported here\n   --> $DIR/ambiguous-builtin-attrs.rs:7:5\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n-note: `repr` could also refer to the name defined here\n-  --> $DIR/ambiguous-builtin-attrs.rs:22:11\n-   |\n-LL |         #[repr(C)] //~ ERROR `repr` is ambiguous\n-   |           ^^^^\n-   = note: consider adding an explicit import of `repr` to disambiguate\n+   = help: use `self::repr` to refer to this attribute macro unambiguously\n \n-error[E0659]: `feature` is ambiguous\n+error[E0659]: `feature` is ambiguous (built-in attribute vs any other name)\n   --> $DIR/ambiguous-builtin-attrs.rs:3:4\n    |\n LL | #![feature(decl_macro)] //~ ERROR `feature` is ambiguous\n    |    ^^^^^^^ ambiguous name\n    |\n-note: `feature` could refer to the name imported here\n+   = note: `feature` could refer to a built-in attribute\n+note: `feature` could also refer to the attribute macro imported here\n   --> $DIR/ambiguous-builtin-attrs.rs:7:5\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n-note: `feature` could also refer to the name defined here\n-  --> $DIR/ambiguous-builtin-attrs.rs:3:4\n-   |\n-LL | #![feature(decl_macro)] //~ ERROR `feature` is ambiguous\n-   |    ^^^^^^^\n-   = note: consider adding an explicit import of `feature` to disambiguate\n-\n-error[E0425]: cannot find value `NonExistent` in this scope\n-  --> $DIR/ambiguous-builtin-attrs.rs:30:5\n-   |\n-LL |     NonExistent; //~ ERROR cannot find value `NonExistent` in this scope\n-   |     ^^^^^^^^^^^ not found in this scope\n+   = help: use `self::feature` to refer to this attribute macro unambiguously\n \n error: aborting due to 6 previous errors\n "}, {"sha": "f04782fac4d2d6d9b5ca44075f9d3d8493c23580", "filename": "src/test/ui-fulldeps/proc-macro/derive-helper-shadowing.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,19 +1,20 @@\n-error[E0659]: `my_attr` is ambiguous\n+error[E0659]: `my_attr` is ambiguous (derive helper attribute vs any other name)\n   --> $DIR/derive-helper-shadowing.rs:6:3\n    |\n LL | #[my_attr] //~ ERROR `my_attr` is ambiguous\n    |   ^^^^^^^ ambiguous name\n    |\n-note: `my_attr` could refer to the name defined here\n+note: `my_attr` could refer to the derive helper attribute defined here\n   --> $DIR/derive-helper-shadowing.rs:7:10\n    |\n LL | #[derive(MyTrait)]\n    |          ^^^^^^^\n-note: `my_attr` could also refer to the name imported here\n+note: `my_attr` could also refer to the attribute macro imported here\n   --> $DIR/derive-helper-shadowing.rs:4:5\n    |\n LL | use derive_helper_shadowing::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: use `self::my_attr` to refer to this attribute macro unambiguously\n \n error: aborting due to previous error\n "}, {"sha": "2bbd7b0ad3ad7bf05ffc2d6c7f1353ca041c49f9", "filename": "src/test/ui/absolute-paths-in-nested-use-groups.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fabsolute-paths-in-nested-use-groups.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fabsolute-paths-in-nested-use-groups.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fabsolute-paths-in-nested-use-groups.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,16 +1,16 @@\n-error[E0433]: failed to resolve. crate root in paths can only be used in start position\n+error[E0433]: failed to resolve: crate root in paths can only be used in start position\n   --> $DIR/absolute-paths-in-nested-use-groups.rs:16:5\n    |\n LL |     ::bar,       //~ ERROR crate root in paths can only be used in start position\n    |     ^ crate root in paths can only be used in start position\n \n-error[E0433]: failed to resolve. `super` in paths can only be used in start position\n+error[E0433]: failed to resolve: `super` in paths can only be used in start position\n   --> $DIR/absolute-paths-in-nested-use-groups.rs:17:5\n    |\n LL |     super::bar,  //~ ERROR `super` in paths can only be used in start position\n    |     ^^^^^ `super` in paths can only be used in start position\n \n-error[E0433]: failed to resolve. `self` in paths can only be used in start position\n+error[E0433]: failed to resolve: `self` in paths can only be used in start position\n   --> $DIR/absolute-paths-in-nested-use-groups.rs:18:5\n    |\n LL |     self::bar,   //~ ERROR `self` in paths can only be used in start position"}, {"sha": "4f38d4ce45e819105fd8fdc870caf765c2de7827", "filename": "src/test/ui/bad/bad-module.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fbad%2Fbad-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fbad%2Fbad-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-module.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -10,8 +10,8 @@\n \n fn main() {\n     let foo = thing::len(Vec::new());\n-    //~^ ERROR failed to resolve. Use of undeclared type or module `thing`\n+    //~^ ERROR failed to resolve: use of undeclared type or module `thing`\n \n     let foo = foo::bar::baz();\n-    //~^ ERROR failed to resolve. Use of undeclared type or module `foo`\n+    //~^ ERROR failed to resolve: use of undeclared type or module `foo`\n }"}, {"sha": "8bdcceaa1918c0fa40e19494e150be3ef9c44380", "filename": "src/test/ui/bad/bad-module.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fbad%2Fbad-module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fbad%2Fbad-module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-module.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,14 +1,14 @@\n-error[E0433]: failed to resolve. Use of undeclared type or module `thing`\n+error[E0433]: failed to resolve: use of undeclared type or module `thing`\n   --> $DIR/bad-module.rs:12:15\n    |\n LL |     let foo = thing::len(Vec::new());\n-   |               ^^^^^ Use of undeclared type or module `thing`\n+   |               ^^^^^ use of undeclared type or module `thing`\n \n-error[E0433]: failed to resolve. Use of undeclared type or module `foo`\n+error[E0433]: failed to resolve: use of undeclared type or module `foo`\n   --> $DIR/bad-module.rs:15:15\n    |\n LL |     let foo = foo::bar::baz();\n-   |               ^^^ Use of undeclared type or module `foo`\n+   |               ^^^ use of undeclared type or module `foo`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "354f7173872e68725ee41c6fe74e559b9ab03011", "filename": "src/test/ui/custom-attribute-multisegment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fcustom-attribute-multisegment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fcustom-attribute-multisegment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom-attribute-multisegment.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -14,5 +14,5 @@\n \n mod existent {}\n \n-#[existent::nonexistent] //~ ERROR failed to resolve. Could not find `nonexistent` in `existent`\n+#[existent::nonexistent] //~ ERROR failed to resolve: could not find `nonexistent` in `existent`\n fn main() {}"}, {"sha": "690ba4982ab74388677de7e4f080e2fd0a5883d7", "filename": "src/test/ui/custom-attribute-multisegment.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fcustom-attribute-multisegment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fcustom-attribute-multisegment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom-attribute-multisegment.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. Could not find `nonexistent` in `existent`\n+error[E0433]: failed to resolve: could not find `nonexistent` in `existent`\n   --> $DIR/custom-attribute-multisegment.rs:17:13\n    |\n-LL | #[existent::nonexistent] //~ ERROR failed to resolve. Could not find `nonexistent` in `existent`\n-   |             ^^^^^^^^^^^ Could not find `nonexistent` in `existent`\n+LL | #[existent::nonexistent] //~ ERROR failed to resolve: could not find `nonexistent` in `existent`\n+   |             ^^^^^^^^^^^ could not find `nonexistent` in `existent`\n \n error: aborting due to previous error\n "}, {"sha": "5c5422f091ba00c5290328cf12bdd8ef426fb2b5", "filename": "src/test/ui/derived-errors/issue-31997-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997-1.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. Use of undeclared type or module `HashMap`\n+error[E0433]: failed to resolve: use of undeclared type or module `HashMap`\n   --> $DIR/issue-31997-1.rs:30:19\n    |\n LL |     let mut map = HashMap::new();\n-   |                   ^^^^^^^ Use of undeclared type or module `HashMap`\n+   |                   ^^^^^^^ use of undeclared type or module `HashMap`\n \n error: aborting due to previous error\n "}, {"sha": "fe9af74c01d9e0ac45304dc940f60ab9e77dd800", "filename": "src/test/ui/dollar-crate/dollar-crate-is-keyword-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword-2.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,4 +1,4 @@\n-error[E0433]: failed to resolve. `$crate` in paths can only be used in start position\n+error[E0433]: failed to resolve: `$crate` in paths can only be used in start position\n   --> $DIR/dollar-crate-is-keyword-2.rs:16:16\n    |\n LL |         use a::$crate::b; //~ ERROR `$crate` in paths can only be used in start position\n@@ -16,7 +16,7 @@ LL |         use a::$crate; //~ ERROR unresolved import `a::$crate`\n LL | m!();\n    | ----- in this macro invocation\n \n-error[E0433]: failed to resolve. `$crate` in paths can only be used in start position\n+error[E0433]: failed to resolve: `$crate` in paths can only be used in start position\n   --> $DIR/dollar-crate-is-keyword-2.rs:17:21\n    |\n LL |         type A = a::$crate; //~ ERROR `$crate` in paths can only be used in start position"}, {"sha": "4297e1b43d3d1ee8a3c1526470928a469ee4bd23", "filename": "src/test/ui/dyn-trait-compatibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fdyn-trait-compatibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fdyn-trait-compatibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-trait-compatibility.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -11,14 +11,14 @@\n type A0 = dyn;\n //~^ ERROR cannot find type `dyn` in this scope\n type A1 = dyn::dyn;\n-//~^ ERROR Use of undeclared type or module `dyn`\n+//~^ ERROR use of undeclared type or module `dyn`\n type A2 = dyn<dyn, dyn>;\n //~^ ERROR cannot find type `dyn` in this scope\n //~| ERROR cannot find type `dyn` in this scope\n //~| ERROR cannot find type `dyn` in this scope\n type A3 = dyn<<dyn as dyn>::dyn>;\n //~^ ERROR cannot find type `dyn` in this scope\n //~| ERROR cannot find type `dyn` in this scope\n-//~| ERROR Use of undeclared type or module `dyn`\n+//~| ERROR use of undeclared type or module `dyn`\n \n fn main() {}"}, {"sha": "93048ccad6fa4233b55d0517db93c17c374bfbf6", "filename": "src/test/ui/dyn-trait-compatibility.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fdyn-trait-compatibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fdyn-trait-compatibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-trait-compatibility.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,14 +1,14 @@\n-error[E0433]: failed to resolve. Use of undeclared type or module `dyn`\n+error[E0433]: failed to resolve: use of undeclared type or module `dyn`\n   --> $DIR/dyn-trait-compatibility.rs:13:11\n    |\n LL | type A1 = dyn::dyn;\n-   |           ^^^ Use of undeclared type or module `dyn`\n+   |           ^^^ use of undeclared type or module `dyn`\n \n-error[E0433]: failed to resolve. Use of undeclared type or module `dyn`\n+error[E0433]: failed to resolve: use of undeclared type or module `dyn`\n   --> $DIR/dyn-trait-compatibility.rs:19:23\n    |\n LL | type A3 = dyn<<dyn as dyn>::dyn>;\n-   |                       ^^^ Use of undeclared type or module `dyn`\n+   |                       ^^^ use of undeclared type or module `dyn`\n \n error[E0412]: cannot find type `dyn` in this scope\n   --> $DIR/dyn-trait-compatibility.rs:11:11"}, {"sha": "3708aa36089693c08aad9a6e8a3171bf2c471bc6", "filename": "src/test/ui/empty/empty-struct-tuple-pat.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fempty%2Fempty-struct-tuple-pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fempty%2Fempty-struct-tuple-pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-struct-tuple-pat.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0530]: match bindings cannot shadow tuple structs\n   --> $DIR/empty-struct-tuple-pat.rs:32:9\n    |\n LL | struct Empty2();\n-   | ---------------- a tuple struct `Empty2` is defined here\n+   | ---------------- the tuple struct `Empty2` is defined here\n ...\n LL |         Empty2 => () //~ ERROR match bindings cannot shadow tuple structs\n    |         ^^^^^^ cannot be named the same as a tuple struct\n@@ -11,7 +11,7 @@ error[E0530]: match bindings cannot shadow tuple structs\n   --> $DIR/empty-struct-tuple-pat.rs:35:9\n    |\n LL | use empty_struct::*;\n-   |     --------------- a tuple struct `XEmpty6` is imported here\n+   |     --------------- the tuple struct `XEmpty6` is imported here\n ...\n LL |         XEmpty6 => () //~ ERROR match bindings cannot shadow tuple structs\n    |         ^^^^^^^ cannot be named the same as a tuple struct"}, {"sha": "b294aabb4edb9e48aaa5c0841c4ef5450d67d4c7", "filename": "src/test/ui/enum/enum-in-scope.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fenum%2Fenum-in-scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fenum%2Fenum-in-scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum%2Fenum-in-scope.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0530]: let bindings cannot shadow tuple structs\n   --> $DIR/enum-in-scope.rs:14:9\n    |\n LL | struct hello(isize);\n-   | -------------------- a tuple struct `hello` is defined here\n+   | -------------------- the tuple struct `hello` is defined here\n ...\n LL |     let hello = 0; //~ERROR let bindings cannot shadow tuple structs\n    |         ^^^^^ cannot be named the same as a tuple struct"}, {"sha": "d288cd086e77767b9ed07890983d3f94f6ca0134", "filename": "src/test/ui/error-codes/E0432.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ferror-codes%2FE0432.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ferror-codes%2FE0432.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0432.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0432]: unresolved import `something`\n   --> $DIR/E0432.rs:11:5\n    |\n LL | use something::Foo; //~ ERROR E0432\n-   |     ^^^^^^^^^ Maybe a missing `extern crate something;`?\n+   |     ^^^^^^^^^ maybe a missing `extern crate something;`?\n \n error: aborting due to previous error\n "}, {"sha": "8a66e749ba8cfa54d4a72d34913bc90c1427a036", "filename": "src/test/ui/error-codes/E0433.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ferror-codes%2FE0433.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ferror-codes%2FE0433.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0433.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. Use of undeclared type or module `HashMap`\n+error[E0433]: failed to resolve: use of undeclared type or module `HashMap`\n   --> $DIR/E0433.rs:12:15\n    |\n LL |     let map = HashMap::new(); //~ ERROR E0433\n-   |               ^^^^^^^ Use of undeclared type or module `HashMap`\n+   |               ^^^^^^^ use of undeclared type or module `HashMap`\n \n error: aborting due to previous error\n "}, {"sha": "96bc47a1afecfa595b8c1794a7bd8b21b69e62df", "filename": "src/test/ui/error-codes/E0530.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ferror-codes%2FE0530.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ferror-codes%2FE0530.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0530.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0530]: match bindings cannot shadow statics\n   --> $DIR/E0530.rs:16:9\n    |\n LL |     static TEST: i32 = 0;\n-   |     --------------------- a static `TEST` is defined here\n+   |     --------------------- the static `TEST` is defined here\n ...\n LL |         TEST => {} //~ ERROR E0530\n    |         ^^^^ cannot be named the same as a static"}, {"sha": "7bfe159405beae19a5a1c6417aadd8ffe2662198", "filename": "src/test/ui/error-codes/E0659.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ferror-codes%2FE0659.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ferror-codes%2FE0659.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0659.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,20 +1,21 @@\n-error[E0659]: `foo` is ambiguous\n+error[E0659]: `foo` is ambiguous (glob import vs glob import in the same module)\n   --> $DIR/E0659.rs:25:15\n    |\n LL |     collider::foo(); //~ ERROR E0659\n    |               ^^^ ambiguous name\n    |\n-note: `foo` could refer to the name imported here\n+note: `foo` could refer to the function imported here\n   --> $DIR/E0659.rs:20:13\n    |\n LL |     pub use moon::*;\n    |             ^^^^^^^\n-note: `foo` could also refer to the name imported here\n+   = help: consider adding an explicit import of `foo` to disambiguate\n+note: `foo` could also refer to the function imported here\n   --> $DIR/E0659.rs:21:13\n    |\n LL |     pub use earth::*;\n    |             ^^^^^^^^\n-   = note: consider adding an explicit import of `foo` to disambiguate\n+   = help: consider adding an explicit import of `foo` to disambiguate\n \n error: aborting due to previous error\n "}, {"sha": "422cd251de420f1eb9b5b2a7ecf53de77ecd6934", "filename": "src/test/ui/export-fully-qualified.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fexport-fully-qualified.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fexport-fully-qualified.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexport-fully-qualified.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -13,7 +13,7 @@\n // want to change eventually.\n \n mod foo {\n-    pub fn bar() { foo::baz(); } //~ ERROR failed to resolve. Use of undeclared type or module `foo`\n+    pub fn bar() { foo::baz(); } //~ ERROR failed to resolve: use of undeclared type or module `foo`\n \n     fn baz() { }\n }"}, {"sha": "477cb4b1dd1898e75fe69c665b6ee246a36be11e", "filename": "src/test/ui/export-fully-qualified.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fexport-fully-qualified.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fexport-fully-qualified.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexport-fully-qualified.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. Use of undeclared type or module `foo`\n+error[E0433]: failed to resolve: use of undeclared type or module `foo`\n   --> $DIR/export-fully-qualified.rs:16:20\n    |\n-LL |     pub fn bar() { foo::baz(); } //~ ERROR failed to resolve. Use of undeclared type or module `foo`\n-   |                    ^^^ Use of undeclared type or module `foo`\n+LL |     pub fn bar() { foo::baz(); } //~ ERROR failed to resolve: use of undeclared type or module `foo`\n+   |                    ^^^ use of undeclared type or module `foo`\n \n error: aborting due to previous error\n "}, {"sha": "4cc9762d975d9db48e9dd562c67ddc282b217830", "filename": "src/test/ui/export2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fexport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fexport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexport2.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n mod foo {\n-    pub fn x() { bar::x(); } //~ ERROR failed to resolve. Use of undeclared type or module `bar`\n+    pub fn x() { bar::x(); } //~ ERROR failed to resolve: use of undeclared type or module `bar`\n }\n \n mod bar {"}, {"sha": "7659183c8e02f59fb219eda7c313926a1564f664", "filename": "src/test/ui/export2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fexport2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fexport2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexport2.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. Use of undeclared type or module `bar`\n+error[E0433]: failed to resolve: use of undeclared type or module `bar`\n   --> $DIR/export2.rs:12:18\n    |\n-LL |     pub fn x() { bar::x(); } //~ ERROR failed to resolve. Use of undeclared type or module `bar`\n-   |                  ^^^ Use of undeclared type or module `bar`\n+LL |     pub fn x() { bar::x(); } //~ ERROR failed to resolve: use of undeclared type or module `bar`\n+   |                  ^^^ use of undeclared type or module `bar`\n \n error: aborting due to previous error\n "}, {"sha": "88a72778a85c6eae8922ee19a7732be12adc3860", "filename": "src/test/ui/extern/extern-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fextern%2Fextern-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fextern%2Fextern-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-macro.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -12,5 +12,5 @@\n \n fn main() {\n     enum Foo {}\n-    let _ = Foo::bar!(); //~ ERROR fail to resolve non-ident macro path\n+    let _ = Foo::bar!(); //~ ERROR failed to resolve: partially resolved path in a macro\n }"}, {"sha": "6123d970166072f9f5b298ee3dc36f3f5494f403", "filename": "src/test/ui/extern/extern-macro.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fextern%2Fextern-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fextern%2Fextern-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-macro.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,9 @@\n-error: fail to resolve non-ident macro path\n+error[E0433]: failed to resolve: partially resolved path in a macro\n   --> $DIR/extern-macro.rs:15:13\n    |\n-LL |     let _ = Foo::bar!(); //~ ERROR fail to resolve non-ident macro path\n-   |             ^^^^^^^^\n+LL |     let _ = Foo::bar!(); //~ ERROR failed to resolve: partially resolved path in a macro\n+   |             ^^^^^^^^ partially resolved path in a macro\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "7c94200f00f4fc99559dc5829fc05597029c66fb", "filename": "src/test/ui/feature-gates/feature-gate-extern_absolute_paths.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_absolute_paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_absolute_paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_absolute_paths.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,13 +2,13 @@ error[E0432]: unresolved import `core`\n   --> $DIR/feature-gate-extern_absolute_paths.rs:11:5\n    |\n LL | use core::default; //~ ERROR unresolved import `core`\n-   |     ^^^^ Maybe a missing `extern crate core;`?\n+   |     ^^^^ maybe a missing `extern crate core;`?\n \n-error[E0433]: failed to resolve. Maybe a missing `extern crate core;`?\n+error[E0433]: failed to resolve: maybe a missing `extern crate core;`?\n   --> $DIR/feature-gate-extern_absolute_paths.rs:14:19\n    |\n LL |     let _: u8 = ::core::default::Default(); //~ ERROR failed to resolve\n-   |                   ^^^^ Maybe a missing `extern crate core;`?\n+   |                   ^^^^ maybe a missing `extern crate core;`?\n \n error: aborting due to 2 previous errors\n "}, {"sha": "27b9a34ff4eb769f229f6e2581532648925c2c9d", "filename": "src/test/ui/feature-gates/feature-gate-extern_crate_item_prelude.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_crate_item_prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_crate_item_prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_crate_item_prelude.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,6 +1,6 @@\n // edition:2018\n \n-#![feature(alloc)]\n+#![feature(alloc, underscore_imports)]\n \n extern crate alloc;\n \n@@ -23,7 +23,7 @@ mod absolute {\n }\n \n mod import_in_scope {\n-    use alloc;\n+    use alloc as _;\n     //~^ ERROR use of extern prelude names introduced with `extern crate` items is unstable\n     use alloc::boxed;\n     //~^ ERROR use of extern prelude names introduced with `extern crate` items is unstable"}, {"sha": "103ab79ef84cb2fa96602e5d578547837071f203", "filename": "src/test/ui/feature-gates/feature-gate-extern_crate_item_prelude.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_crate_item_prelude.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_crate_item_prelude.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_crate_item_prelude.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,7 +1,7 @@\n error[E0658]: use of extern prelude names introduced with `extern crate` items is unstable (see issue #55599)\n   --> $DIR/feature-gate-extern_crate_item_prelude.rs:26:9\n    |\n-LL |     use alloc;\n+LL |     use alloc as _;\n    |         ^^^^^\n    |\n    = help: add #![feature(extern_crate_item_prelude)] to the crate attributes to enable"}, {"sha": "ca1cc1d2fd0e444ef960746d5131869863917724", "filename": "src/test/ui/feature-gates/feature-gate-uniform-paths.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-uniform-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-uniform-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-uniform-paths.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -8,15 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// edition:2018\n+\n pub mod foo {\n-    pub use bar::Bar;\n-    //~^ ERROR unresolved import `bar`\n+    pub use bar::Bar; //~ ERROR imports can only refer to extern crate names\n \n     pub mod bar {\n         pub struct Bar;\n     }\n }\n \n+use inline; //~ ERROR imports can only refer to extern crate names\n+\n+use Vec; //~ ERROR imports can only refer to extern crate names\n+\n+use vec; //~ ERROR imports can only refer to extern crate names\n+\n fn main() {\n     let _ = foo::Bar;\n }"}, {"sha": "ec8937bbc5f5c6612d2d0aecb32f7665026bb680", "filename": "src/test/ui/feature-gates/feature-gate-uniform-paths.stderr", "status": "modified", "additions": 59, "deletions": 6, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-uniform-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-uniform-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-uniform-paths.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,9 +1,62 @@\n-error[E0432]: unresolved import `bar`\n-  --> $DIR/feature-gate-uniform-paths.rs:12:13\n+error[E0658]: imports can only refer to extern crate names passed with `--extern` on stable channel (see issue #53130)\n+  --> $DIR/feature-gate-uniform-paths.rs:14:13\n    |\n-LL |     pub use bar::Bar;\n-   |             ^^^ Did you mean `self::bar`?\n+LL |       pub use bar::Bar; //~ ERROR imports can only refer to extern crate names\n+   |               ^^^\n+LL | \n+LL | /     pub mod bar {\n+LL | |         pub struct Bar;\n+LL | |     }\n+   | |_____- not an extern crate passed with `--extern`\n+   |\n+   = help: add #![feature(uniform_paths)] to the crate attributes to enable\n+note: this import refers to the module defined here\n+  --> $DIR/feature-gate-uniform-paths.rs:16:5\n+   |\n+LL | /     pub mod bar {\n+LL | |         pub struct Bar;\n+LL | |     }\n+   | |_____^\n+\n+error[E0658]: imports can only refer to extern crate names passed with `--extern` on stable channel (see issue #53130)\n+  --> $DIR/feature-gate-uniform-paths.rs:21:5\n+   |\n+LL | use inline; //~ ERROR imports can only refer to extern crate names\n+   |     ^^^^^^ not an extern crate passed with `--extern`\n+   |\n+   = help: add #![feature(uniform_paths)] to the crate attributes to enable\n+note: this import refers to the built-in attribute imported here\n+  --> $DIR/feature-gate-uniform-paths.rs:21:5\n+   |\n+LL | use inline; //~ ERROR imports can only refer to extern crate names\n+   |     ^^^^^^\n+\n+error[E0658]: imports can only refer to extern crate names passed with `--extern` on stable channel (see issue #53130)\n+  --> $DIR/feature-gate-uniform-paths.rs:23:5\n+   |\n+LL | use Vec; //~ ERROR imports can only refer to extern crate names\n+   |     ^^^ not an extern crate passed with `--extern`\n+   |\n+   = help: add #![feature(uniform_paths)] to the crate attributes to enable\n+note: this import refers to the struct imported here\n+  --> $DIR/feature-gate-uniform-paths.rs:23:5\n+   |\n+LL | use Vec; //~ ERROR imports can only refer to extern crate names\n+   |     ^^^\n+\n+error[E0658]: imports can only refer to extern crate names passed with `--extern` on stable channel (see issue #53130)\n+  --> $DIR/feature-gate-uniform-paths.rs:25:5\n+   |\n+LL | use vec; //~ ERROR imports can only refer to extern crate names\n+   |     ^^^ not an extern crate passed with `--extern`\n+   |\n+   = help: add #![feature(uniform_paths)] to the crate attributes to enable\n+note: this import refers to the macro imported here\n+  --> $DIR/feature-gate-uniform-paths.rs:25:5\n+   |\n+LL | use vec; //~ ERROR imports can only refer to extern crate names\n+   |     ^^^\n \n-error: aborting due to previous error\n+error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0432`.\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "73a63a2c7f59370cfe2eeccf60c82994570d2700", "filename": "src/test/ui/hygiene/no_implicit_prelude.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,11 +1,11 @@\n-error[E0433]: failed to resolve. Use of undeclared type or module `Vec`\n+error[E0433]: failed to resolve: use of undeclared type or module `Vec`\n   --> $DIR/no_implicit_prelude.rs:21:9\n    |\n LL |     fn f() { ::bar::m!(); }\n    |              ------------ in this macro invocation\n ...\n LL |         Vec::new(); //~ ERROR failed to resolve\n-   |         ^^^ Use of undeclared type or module `Vec`\n+   |         ^^^ use of undeclared type or module `Vec`\n \n error[E0599]: no method named `clone` found for type `()` in the current scope\n   --> $DIR/no_implicit_prelude.rs:22:12"}, {"sha": "d3bbdf15cd005c5b45884a8acb523a4180767805", "filename": "src/test/ui/import2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimport2.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use baz::zed::bar; //~ ERROR unresolved import `baz::zed` [E0432]\n-                   //~^ Could not find `zed` in `baz`\n+                   //~^ could not find `zed` in `baz`\n \n mod baz {}\n mod zed {"}, {"sha": "b19739377015d5181d7ca4f3965224c865f6c339", "filename": "src/test/ui/import2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimport2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimport2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimport2.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0432]: unresolved import `baz::zed`\n   --> $DIR/import2.rs:11:10\n    |\n LL | use baz::zed::bar; //~ ERROR unresolved import `baz::zed` [E0432]\n-   |          ^^^ Could not find `zed` in `baz`\n+   |          ^^^ could not find `zed` in `baz`\n \n error: aborting due to previous error\n "}, {"sha": "a4c367fb0736eee7eca6415d4ad3a80005fdd4ae", "filename": "src/test/ui/import3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimport3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimport3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimport3.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0432]: unresolved import `main`\n   --> $DIR/import3.rs:12:5\n    |\n LL | use main::bar;\n-   |     ^^^^ Maybe a missing `extern crate main;`?\n+   |     ^^^^ maybe a missing `extern crate main;`?\n \n error: aborting due to previous error\n "}, {"sha": "ac12ed9c81c77c29aaccf50a660477767152e295", "filename": "src/test/ui/imports/auxiliary/glob-conflict.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Fglob-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Fglob-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Fglob-conflict.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,9 @@\n+mod m1 {\n+    pub fn f() {}\n+}\n+mod m2 {\n+    pub fn f(_: u8) {}\n+}\n+\n+pub use m1::*;\n+pub use m2::*;"}, {"sha": "f53ba9cd5de8ea5b2c30d7ca1f4baed749096f7d", "filename": "src/test/ui/imports/duplicate.stderr", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fduplicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fduplicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fduplicate.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -12,77 +12,81 @@ help: you can use `as` to change the binding name of the import\n LL |     use a::foo as other_foo; //~ ERROR the name `foo` is defined multiple times\n    |         ^^^^^^^^^^^^^^^^^^^\n \n-error[E0659]: `foo` is ambiguous\n+error[E0659]: `foo` is ambiguous (glob import vs glob import in the same module)\n   --> $DIR/duplicate.rs:56:15\n    |\n LL |     use self::foo::bar; //~ ERROR `foo` is ambiguous\n    |               ^^^ ambiguous name\n    |\n-note: `foo` could refer to the name imported here\n+note: `foo` could refer to the module imported here\n   --> $DIR/duplicate.rs:53:9\n    |\n LL |     use self::m1::*;\n    |         ^^^^^^^^^^^\n-note: `foo` could also refer to the name imported here\n+   = help: consider adding an explicit import of `foo` to disambiguate\n+note: `foo` could also refer to the module imported here\n   --> $DIR/duplicate.rs:54:9\n    |\n LL |     use self::m2::*;\n    |         ^^^^^^^^^^^\n-   = note: consider adding an explicit import of `foo` to disambiguate\n+   = help: consider adding an explicit import of `foo` to disambiguate\n \n-error[E0659]: `foo` is ambiguous\n+error[E0659]: `foo` is ambiguous (glob import vs glob import in the same module)\n   --> $DIR/duplicate.rs:45:8\n    |\n LL |     f::foo(); //~ ERROR `foo` is ambiguous\n    |        ^^^ ambiguous name\n    |\n-note: `foo` could refer to the name imported here\n+note: `foo` could refer to the function imported here\n   --> $DIR/duplicate.rs:34:13\n    |\n LL |     pub use a::*;\n    |             ^^^^\n-note: `foo` could also refer to the name imported here\n+   = help: consider adding an explicit import of `foo` to disambiguate\n+note: `foo` could also refer to the function imported here\n   --> $DIR/duplicate.rs:35:13\n    |\n LL |     pub use b::*;\n    |             ^^^^\n-   = note: consider adding an explicit import of `foo` to disambiguate\n+   = help: consider adding an explicit import of `foo` to disambiguate\n \n-error[E0659]: `foo` is ambiguous\n+error[E0659]: `foo` is ambiguous (glob import vs glob import in the same module)\n   --> $DIR/duplicate.rs:46:8\n    |\n LL |     g::foo(); //~ ERROR `foo` is ambiguous\n    |        ^^^ ambiguous name\n    |\n-note: `foo` could refer to the name imported here\n+note: `foo` could refer to the function imported here\n   --> $DIR/duplicate.rs:39:13\n    |\n LL |     pub use a::*;\n    |             ^^^^\n-note: `foo` could also refer to the name imported here\n+   = help: consider adding an explicit import of `foo` to disambiguate\n+note: `foo` could also refer to the unresolved item imported here\n   --> $DIR/duplicate.rs:40:13\n    |\n LL |     pub use f::*;\n    |             ^^^^\n-   = note: consider adding an explicit import of `foo` to disambiguate\n+   = help: consider adding an explicit import of `foo` to disambiguate\n \n-error[E0659]: `foo` is ambiguous\n+error[E0659]: `foo` is ambiguous (glob import vs glob import in the same module)\n   --> $DIR/duplicate.rs:59:9\n    |\n LL |         foo::bar(); //~ ERROR `foo` is ambiguous\n    |         ^^^ ambiguous name\n    |\n-note: `foo` could refer to the name imported here\n+note: `foo` could refer to the module imported here\n   --> $DIR/duplicate.rs:53:9\n    |\n LL |     use self::m1::*;\n    |         ^^^^^^^^^^^\n-note: `foo` could also refer to the name imported here\n+   = help: consider adding an explicit import of `foo` to disambiguate\n+note: `foo` could also refer to the module imported here\n   --> $DIR/duplicate.rs:54:9\n    |\n LL |     use self::m2::*;\n    |         ^^^^^^^^^^^\n-   = note: consider adding an explicit import of `foo` to disambiguate\n+   = help: consider adding an explicit import of `foo` to disambiguate\n \n error: aborting due to 5 previous errors\n "}, {"sha": "6b70efe0c44866ad951b60b0afabb515fef0c2a0", "filename": "src/test/ui/imports/extern-prelude-extern-crate-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-fail.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -7,7 +7,7 @@ mod n {\n \n mod m {\n     fn check() {\n-        two_macros::m!(); //~ ERROR failed to resolve. Use of undeclared type or module `two_macros`\n+        two_macros::m!(); //~ ERROR failed to resolve: use of undeclared type or module `two_macros`\n     }\n }\n "}, {"sha": "baeed02517d1860b9c58e061783d9f0eb91cf9cd", "filename": "src/test/ui/imports/extern-prelude-extern-crate-fail.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-fail.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -7,11 +7,11 @@ LL |         extern crate std as non_existent;\n LL | define_std_as_non_existent!();\n    | ------------------------------ in this macro invocation\n \n-error[E0433]: failed to resolve. Use of undeclared type or module `two_macros`\n+error[E0433]: failed to resolve: use of undeclared type or module `two_macros`\n   --> $DIR/extern-prelude-extern-crate-fail.rs:10:9\n    |\n-LL |         two_macros::m!(); //~ ERROR failed to resolve. Use of undeclared type or module `two_macros`\n-   |         ^^^^^^^^^^ Use of undeclared type or module `two_macros`\n+LL |         two_macros::m!(); //~ ERROR failed to resolve: use of undeclared type or module `two_macros`\n+   |         ^^^^^^^^^^ use of undeclared type or module `two_macros`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "218dfb796f77ad3964915b2a834875a4c48b00bf", "filename": "src/test/ui/imports/extern-prelude-extern-crate-restricted-shadowing.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-restricted-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-restricted-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-restricted-shadowing.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,19 +1,18 @@\n-error[E0659]: `Vec` is ambiguous\n+error[E0659]: `Vec` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/extern-prelude-extern-crate-restricted-shadowing.rs:15:9\n    |\n LL |         Vec::panic!(); //~ ERROR `Vec` is ambiguous\n    |         ^^^ ambiguous name\n    |\n-note: `Vec` could refer to the name defined here\n+   = note: `Vec` could refer to a struct from prelude\n+note: `Vec` could also refer to the extern crate imported here\n   --> $DIR/extern-prelude-extern-crate-restricted-shadowing.rs:7:9\n    |\n LL |         extern crate std as Vec;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | define_vec!();\n    | -------------- in this macro invocation\n-note: `Vec` could also refer to the name defined here\n-   = note: macro-expanded items do not shadow when used in a macro invocation path\n \n error: aborting due to previous error\n "}, {"sha": "e02148b19f786e52bdbf359efa65d997867ed873", "filename": "src/test/ui/imports/glob-conflict-cross-crate.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fglob-conflict-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fglob-conflict-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fglob-conflict-cross-crate.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,7 @@\n+// aux-build:glob-conflict.rs\n+\n+extern crate glob_conflict;\n+\n+fn main() {\n+    glob_conflict::f(); //~ ERROR cannot find function `f` in module `glob_conflict`\n+}"}, {"sha": "f64637fd6f625c9cc83591b8375a7ff1f29ea75f", "filename": "src/test/ui/imports/glob-conflict-cross-crate.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fglob-conflict-cross-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fglob-conflict-cross-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fglob-conflict-cross-crate.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,9 @@\n+error[E0425]: cannot find function `f` in module `glob_conflict`\n+  --> $DIR/glob-conflict-cross-crate.rs:6:20\n+   |\n+LL |     glob_conflict::f(); //~ ERROR cannot find function `f` in module `glob_conflict`\n+   |                    ^ not found in `glob_conflict`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "6a4774facd77c79ea233452eecadf7662df4570d", "filename": "src/test/ui/imports/glob-shadowing.stderr", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fglob-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fglob-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fglob-shadowing.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,48 +1,50 @@\n-error[E0659]: `env` is ambiguous\n+error[E0659]: `env` is ambiguous (glob import vs any other name from outer scope during import/macro resolution)\n   --> $DIR/glob-shadowing.rs:21:17\n    |\n LL |         let x = env!(\"PATH\"); //~ ERROR `env` is ambiguous\n    |                 ^^^ ambiguous name\n    |\n-note: `env` could refer to the name imported here\n+   = note: `env` could refer to a built-in macro\n+note: `env` could also refer to the macro imported here\n   --> $DIR/glob-shadowing.rs:19:9\n    |\n LL |     use m::*;\n    |         ^^^^\n-   = note: `env` is also a builtin macro\n-   = note: consider adding an explicit import of `env` to disambiguate\n+   = help: consider adding an explicit import of `env` to disambiguate\n+   = help: or use `self::env` to refer to this macro unambiguously\n \n-error[E0659]: `env` is ambiguous\n+error[E0659]: `env` is ambiguous (glob import vs any other name from outer scope during import/macro resolution)\n   --> $DIR/glob-shadowing.rs:29:21\n    |\n LL |             let x = env!(\"PATH\"); //~ ERROR `env` is ambiguous\n    |                     ^^^ ambiguous name\n    |\n-note: `env` could refer to the name imported here\n+   = note: `env` could refer to a built-in macro\n+note: `env` could also refer to the macro imported here\n   --> $DIR/glob-shadowing.rs:27:13\n    |\n LL |         use m::*;\n    |             ^^^^\n-   = note: `env` is also a builtin macro\n-   = note: consider adding an explicit import of `env` to disambiguate\n+   = help: consider adding an explicit import of `env` to disambiguate\n \n-error[E0659]: `fenv` is ambiguous\n+error[E0659]: `fenv` is ambiguous (glob import vs any other name from outer scope during import/macro resolution)\n   --> $DIR/glob-shadowing.rs:39:21\n    |\n LL |             let x = fenv!(); //~ ERROR `fenv` is ambiguous\n    |                     ^^^^ ambiguous name\n    |\n-note: `fenv` could refer to the name imported here\n+note: `fenv` could refer to the macro imported here\n   --> $DIR/glob-shadowing.rs:37:13\n    |\n LL |         use m::*;\n    |             ^^^^\n-note: `fenv` could also refer to the name defined here\n+   = help: consider adding an explicit import of `fenv` to disambiguate\n+note: `fenv` could also refer to the macro defined here\n   --> $DIR/glob-shadowing.rs:35:5\n    |\n LL |     pub macro fenv($e: expr) { $e }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: consider adding an explicit import of `fenv` to disambiguate\n+   = help: use `self::fenv` to refer to this macro unambiguously\n \n error: aborting due to 3 previous errors\n "}, {"sha": "0ed26ea6fe64220d0b06bd9f982c729692d2311b", "filename": "src/test/ui/imports/issue-53269.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,24 +2,25 @@ error[E0432]: unresolved import `nonexistent_module`\n   --> $DIR/issue-53269.rs:16:9\n    |\n LL |     use nonexistent_module::mac; //~ ERROR unresolved import `nonexistent_module`\n-   |         ^^^^^^^^^^^^^^^^^^ Maybe a missing `extern crate nonexistent_module;`?\n+   |         ^^^^^^^^^^^^^^^^^^ maybe a missing `extern crate nonexistent_module;`?\n \n-error[E0659]: `mac` is ambiguous\n+error[E0659]: `mac` is ambiguous (`macro_rules` vs non-`macro_rules` from other module)\n   --> $DIR/issue-53269.rs:18:5\n    |\n LL |     mac!(); //~ ERROR `mac` is ambiguous\n    |     ^^^ ambiguous name\n    |\n-note: `mac` could refer to the name defined here\n+note: `mac` could refer to the macro defined here\n   --> $DIR/issue-53269.rs:13:1\n    |\n LL | macro_rules! mac { () => () }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: `mac` could also refer to the name imported here\n+note: `mac` could also refer to the unresolved item imported here\n   --> $DIR/issue-53269.rs:16:9\n    |\n LL |     use nonexistent_module::mac; //~ ERROR unresolved import `nonexistent_module`\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: use `self::mac` to refer to this unresolved item unambiguously\n \n error: aborting due to 2 previous errors\n "}, {"sha": "4ee0332d04bcd16f8a109f59bfa25d4a7e1d8f83", "filename": "src/test/ui/imports/issue-55457.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fissue-55457.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fissue-55457.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-55457.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -8,7 +8,7 @@ error[E0432]: unresolved import `non_existent`\n   --> $DIR/issue-55457.rs:2:5\n    |\n LL | use non_existent::non_existent; //~ ERROR unresolved import `non_existent`\n-   |     ^^^^^^^^^^^^ Maybe a missing `extern crate non_existent;`?\n+   |     ^^^^^^^^^^^^ maybe a missing `extern crate non_existent;`?\n \n error: cannot determine resolution for the derive macro `NonExistent`\n   --> $DIR/issue-55457.rs:5:10"}, {"sha": "21744aa5d7bfa51b73a2ccf7f9dc7fff7409a31b", "filename": "src/test/ui/imports/issue-55884-1.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fissue-55884-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fissue-55884-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-55884-1.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,21 @@\n+mod m {\n+    mod m1 {\n+        pub struct S {}\n+    }\n+    mod m2 {\n+        // Note this derive, it makes this struct macro-expanded,\n+        // so it doesn't appear in time to participate in the initial resolution of `use m::S`,\n+        // only in the later validation pass.\n+        #[derive(Default)]\n+        pub struct S {}\n+    }\n+\n+    // Create a glob vs glob ambiguity\n+    pub use self::m1::*;\n+    pub use self::m2::*;\n+}\n+\n+fn main() {\n+    use m::S; //~ ERROR `S` is ambiguous\n+    let s = S {};\n+}"}, {"sha": "477e859d0815ee774297fadda28bdfaa3464b049", "filename": "src/test/ui/imports/issue-55884-1.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fissue-55884-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fissue-55884-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-55884-1.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,22 @@\n+error[E0659]: `S` is ambiguous (glob import vs glob import in the same module)\n+  --> $DIR/issue-55884-1.rs:19:12\n+   |\n+LL |     use m::S; //~ ERROR `S` is ambiguous\n+   |            ^ ambiguous name\n+   |\n+note: `S` could refer to the struct imported here\n+  --> $DIR/issue-55884-1.rs:14:13\n+   |\n+LL |     pub use self::m1::*;\n+   |             ^^^^^^^^^^^\n+   = help: consider adding an explicit import of `S` to disambiguate\n+note: `S` could also refer to the struct imported here\n+  --> $DIR/issue-55884-1.rs:15:13\n+   |\n+LL |     pub use self::m2::*;\n+   |             ^^^^^^^^^^^\n+   = help: consider adding an explicit import of `S` to disambiguate\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "1b4f652c9fc2f1acf060f0224a074885a03a6e4a", "filename": "src/test/ui/imports/issue-55884-2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fissue-55884-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fissue-55884-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-55884-2.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,14 @@\n+mod options {\n+    pub struct ParseOptions {}\n+}\n+\n+mod parser {\n+    pub use options::*;\n+    // Private single import shadows public glob import, but arrives too late for initial\n+    // resolution of `use parser::ParseOptions` because it depends on that resolution itself.\n+    use ParseOptions;\n+}\n+\n+pub use parser::ParseOptions; //~ ERROR struct `ParseOptions` is private\n+\n+fn main() {}"}, {"sha": "f8a6cb4a580909b95d4b5905ba5b48b629181ec2", "filename": "src/test/ui/imports/issue-55884-2.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fissue-55884-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fissue-55884-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-55884-2.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,9 @@\n+error[E0603]: struct `ParseOptions` is private\n+  --> $DIR/issue-55884-2.rs:12:17\n+   |\n+LL | pub use parser::ParseOptions; //~ ERROR struct `ParseOptions` is private\n+   |                 ^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0603`."}, {"sha": "962294e48caef9a999dca37758ad41412915d3d4", "filename": "src/test/ui/imports/local-modularized-tricky-fail-1.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,10 +1,10 @@\n-error[E0659]: `exported` is ambiguous\n+error[E0659]: `exported` is ambiguous (glob import vs macro-expanded name in the same module during import/macro resolution)\n   --> $DIR/local-modularized-tricky-fail-1.rs:38:1\n    |\n LL | exported!(); //~ ERROR `exported` is ambiguous\n    | ^^^^^^^^ ambiguous name\n    |\n-note: `exported` could refer to the name defined here\n+note: `exported` could refer to the macro defined here\n   --> $DIR/local-modularized-tricky-fail-1.rs:15:5\n    |\n LL | /     macro_rules! exported {\n@@ -14,20 +14,21 @@ LL | |     }\n ...\n LL |       define_exported!();\n    |       ------------------- in this macro invocation\n-note: `exported` could also refer to the name imported here\n+note: `exported` could also refer to the macro imported here\n   --> $DIR/local-modularized-tricky-fail-1.rs:32:5\n    |\n LL | use inner1::*;\n    |     ^^^^^^^^^\n-   = note: macro-expanded macros do not shadow\n+   = help: consider adding an explicit import of `exported` to disambiguate\n \n-error[E0659]: `include` is ambiguous\n+error[E0659]: `include` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/local-modularized-tricky-fail-1.rs:56:1\n    |\n LL | include!(); //~ ERROR `include` is ambiguous\n    | ^^^^^^^ ambiguous name\n    |\n-note: `include` could refer to the name defined here\n+   = note: `include` could refer to a built-in macro\n+note: `include` could also refer to the macro defined here\n   --> $DIR/local-modularized-tricky-fail-1.rs:27:5\n    |\n LL | /     macro_rules! include {\n@@ -37,16 +38,16 @@ LL | |     }\n ...\n LL |       define_include!();\n    |       ------------------ in this macro invocation\n-   = note: `include` is also a builtin macro\n-   = note: macro-expanded macros do not shadow\n+   = help: use `self::include` to refer to this macro unambiguously\n \n-error[E0659]: `panic` is ambiguous\n+error[E0659]: `panic` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/local-modularized-tricky-fail-1.rs:45:5\n    |\n LL |     panic!(); //~ ERROR `panic` is ambiguous\n    |     ^^^^^ ambiguous name\n    |\n-note: `panic` could refer to the name defined here\n+   = note: `panic` could refer to a macro from prelude\n+note: `panic` could also refer to the macro defined here\n   --> $DIR/local-modularized-tricky-fail-1.rs:21:5\n    |\n LL | /     macro_rules! panic {\n@@ -56,16 +57,16 @@ LL | |     }\n ...\n LL |       define_panic!();\n    |       ---------------- in this macro invocation\n-   = note: `panic` is also a builtin macro\n-   = note: macro-expanded macros do not shadow\n+   = help: use `self::panic` to refer to this macro unambiguously\n \n-error[E0659]: `panic` is ambiguous\n+error[E0659]: `panic` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> <::std::macros::panic macros>:1:13\n    |\n LL | (  ) => ( { panic ! ( \"explicit panic\" ) } ) ; ( $ msg : expr ) => (\n    |             ^^^^^ ambiguous name\n    |\n-note: `panic` could refer to the name defined here\n+   = note: `panic` could refer to a macro from prelude\n+note: `panic` could also refer to the macro defined here\n   --> $DIR/local-modularized-tricky-fail-1.rs:21:5\n    |\n LL | /     macro_rules! panic {\n@@ -75,8 +76,7 @@ LL | |     }\n ...\n LL |       define_panic!();\n    |       ---------------- in this macro invocation\n-   = note: `panic` is also a builtin macro\n-   = note: macro-expanded macros do not shadow\n+   = help: use `self::panic` to refer to this macro unambiguously\n \n error: aborting due to 4 previous errors\n "}, {"sha": "8e8742f849bf07516564da3b00e5999f7b4dcda7", "filename": "src/test/ui/imports/macro-paths.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fmacro-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fmacro-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fmacro-paths.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,40 +1,40 @@\n-error[E0659]: `bar` is ambiguous\n+error[E0659]: `bar` is ambiguous (glob import vs macro-expanded name in the same module during import/macro resolution)\n   --> $DIR/macro-paths.rs:23:5\n    |\n LL |     bar::m! { //~ ERROR ambiguous\n    |     ^^^ ambiguous name\n    |\n-note: `bar` could refer to the name defined here\n+note: `bar` could refer to the module defined here\n   --> $DIR/macro-paths.rs:24:9\n    |\n LL |         mod bar { pub use two_macros::m; }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: `bar` could also refer to the name imported here\n+note: `bar` could also refer to the module imported here\n   --> $DIR/macro-paths.rs:22:9\n    |\n LL |     use foo::*;\n    |         ^^^^^^\n-   = note: macro-expanded items do not shadow when used in a macro invocation path\n+   = help: consider adding an explicit import of `bar` to disambiguate\n \n-error[E0659]: `baz` is ambiguous\n+error[E0659]: `baz` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/macro-paths.rs:33:5\n    |\n LL |     baz::m! { //~ ERROR ambiguous\n    |     ^^^ ambiguous name\n    |\n-note: `baz` could refer to the name defined here\n+note: `baz` could refer to the module defined here\n   --> $DIR/macro-paths.rs:34:9\n    |\n LL |         mod baz { pub use two_macros::m; }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: `baz` could also refer to the name defined here\n+note: `baz` could also refer to the module defined here\n   --> $DIR/macro-paths.rs:28:1\n    |\n LL | / pub mod baz {\n LL | |     pub use two_macros::m;\n LL | | }\n    | |_^\n-   = note: macro-expanded items do not shadow when used in a macro invocation path\n+   = help: use `self::baz` to refer to this module unambiguously\n \n error: aborting due to 2 previous errors\n "}, {"sha": "77a0311fa6055e93e6f7909d552cb236d5c46d0e", "filename": "src/test/ui/imports/macros.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,38 +1,38 @@\n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (glob import vs macro-expanded name in the same module during import/macro resolution)\n   --> $DIR/macros.rs:26:5\n    |\n LL |     m! { //~ ERROR ambiguous\n    |     ^ ambiguous name\n    |\n-note: `m` could refer to the name imported here\n+note: `m` could refer to the macro imported here\n   --> $DIR/macros.rs:27:13\n    |\n LL |         use foo::m;\n    |             ^^^^^^\n-note: `m` could also refer to the name imported here\n+note: `m` could also refer to the macro imported here\n   --> $DIR/macros.rs:25:9\n    |\n LL |     use two_macros::*;\n    |         ^^^^^^^^^^^^^\n-   = note: macro-expanded macro imports do not shadow\n+   = help: consider adding an explicit import of `m` to disambiguate\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/macros.rs:39:9\n    |\n LL |         m! { //~ ERROR ambiguous\n    |         ^ ambiguous name\n    |\n-note: `m` could refer to the name imported here\n+note: `m` could refer to the macro imported here\n   --> $DIR/macros.rs:40:17\n    |\n LL |             use two_macros::n as m;\n    |                 ^^^^^^^^^^^^^^^^^^\n-note: `m` could also refer to the name imported here\n+note: `m` could also refer to the macro imported here\n   --> $DIR/macros.rs:32:9\n    |\n LL |     use two_macros::m;\n    |         ^^^^^^^^^^^^^\n-   = note: macro-expanded macro imports do not shadow\n+   = help: use `self::m` to refer to this macro unambiguously\n \n error: aborting due to 2 previous errors\n "}, {"sha": "946dc084cd0f8c4fc6e53893cebe8ab40afc9310", "filename": "src/test/ui/imports/rfc-1560-warning-cycle.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Frfc-1560-warning-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Frfc-1560-warning-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Frfc-1560-warning-cycle.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,20 +1,21 @@\n-error[E0659]: `Foo` is ambiguous\n+error[E0659]: `Foo` is ambiguous (glob import vs glob import in the same module)\n   --> $DIR/rfc-1560-warning-cycle.rs:19:17\n    |\n LL |         fn f(_: Foo) {} //~ ERROR `Foo` is ambiguous\n    |                 ^^^ ambiguous name\n    |\n-note: `Foo` could refer to the name imported here\n+note: `Foo` could refer to the struct imported here\n   --> $DIR/rfc-1560-warning-cycle.rs:17:13\n    |\n LL |         use *;\n    |             ^\n-note: `Foo` could also refer to the name imported here\n+   = help: consider adding an explicit import of `Foo` to disambiguate\n+note: `Foo` could also refer to the struct imported here\n   --> $DIR/rfc-1560-warning-cycle.rs:18:13\n    |\n LL |         use bar::*;\n    |             ^^^^^^\n-   = note: consider adding an explicit import of `Foo` to disambiguate\n+   = help: consider adding an explicit import of `Foo` to disambiguate\n \n error: aborting due to previous error\n "}, {"sha": "b53b7e2700db8e8e32e02068a0c5778d1e1e620f", "filename": "src/test/ui/imports/shadow_builtin_macros.stderr", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,65 +1,66 @@\n-error[E0659]: `panic` is ambiguous\n+error[E0659]: `panic` is ambiguous (glob import vs any other name from outer scope during import/macro resolution)\n   --> $DIR/shadow_builtin_macros.rs:25:14\n    |\n LL |     fn f() { panic!(); } //~ ERROR ambiguous\n    |              ^^^^^ ambiguous name\n    |\n-note: `panic` could refer to the name imported here\n+   = note: `panic` could refer to a macro from prelude\n+note: `panic` could also refer to the macro imported here\n   --> $DIR/shadow_builtin_macros.rs:24:9\n    |\n LL |     use foo::*;\n    |         ^^^^^^\n-   = note: `panic` is also a builtin macro\n-   = note: consider adding an explicit import of `panic` to disambiguate\n+   = help: consider adding an explicit import of `panic` to disambiguate\n+   = help: or use `self::panic` to refer to this macro unambiguously\n \n-error[E0659]: `panic` is ambiguous\n+error[E0659]: `panic` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/shadow_builtin_macros.rs:30:14\n    |\n LL |     fn f() { panic!(); } //~ ERROR ambiguous\n    |              ^^^^^ ambiguous name\n    |\n-note: `panic` could refer to the name imported here\n+   = note: `panic` could refer to a macro from prelude\n+note: `panic` could also refer to the macro imported here\n   --> $DIR/shadow_builtin_macros.rs:29:26\n    |\n LL |     ::two_macros::m!(use foo::panic;);\n    |                          ^^^^^^^^^^\n-   = note: `panic` is also a builtin macro\n-   = note: macro-expanded macro imports do not shadow\n+   = help: use `self::panic` to refer to this macro unambiguously\n \n-error[E0659]: `panic` is ambiguous\n+error[E0659]: `panic` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/shadow_builtin_macros.rs:43:5\n    |\n LL |     panic!(); //~ ERROR `panic` is ambiguous\n    |     ^^^^^ ambiguous name\n    |\n-note: `panic` could refer to the name defined here\n+   = note: `panic` could refer to a macro from prelude\n+note: `panic` could also refer to the macro defined here\n   --> $DIR/shadow_builtin_macros.rs:40:9\n    |\n LL |         macro_rules! panic { () => {} }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |     } }\n LL |     m!();\n    |     ----- in this macro invocation\n-   = note: `panic` is also a builtin macro\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `n` is ambiguous\n+error[E0659]: `n` is ambiguous (glob import vs any other name from outer scope during import/macro resolution)\n   --> $DIR/shadow_builtin_macros.rs:59:5\n    |\n LL |     n!(); //~ ERROR ambiguous\n    |     ^ ambiguous name\n    |\n-note: `n` could refer to the name imported here\n+note: `n` could refer to the macro imported here\n   --> $DIR/shadow_builtin_macros.rs:58:9\n    |\n LL |     use bar::*;\n    |         ^^^^^^\n-note: `n` could also refer to the name imported here\n+   = help: consider adding an explicit import of `n` to disambiguate\n+   = help: or use `self::n` to refer to this macro unambiguously\n+note: `n` could also refer to the macro imported here\n   --> $DIR/shadow_builtin_macros.rs:46:13\n    |\n LL | #[macro_use(n)]\n    |             ^\n-   = note: consider adding an explicit import of `n` to disambiguate\n \n error: aborting due to 4 previous errors\n "}, {"sha": "284ed03552639a2e8ff049d562d947cc704c60a4", "filename": "src/test/ui/issues/issue-16149.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-16149.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-16149.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16149.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0530]: match bindings cannot shadow statics\n   --> $DIR/issue-16149.rs:17:9\n    |\n LL |     static externalValue: isize;\n-   |     ---------------------------- a static `externalValue` is defined here\n+   |     ---------------------------- the static `externalValue` is defined here\n ...\n LL |         externalValue => true,\n    |         ^^^^^^^^^^^^^ cannot be named the same as a static"}, {"sha": "43f92d8c3deed8937159160411028ab24ecaa49b", "filename": "src/test/ui/issues/issue-1697.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-1697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-1697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-1697.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -11,6 +11,6 @@\n // Testing that we don't fail abnormally after hitting the errors\n \n use unresolved::*; //~ ERROR unresolved import `unresolved` [E0432]\n-                   //~^ Maybe a missing `extern crate unresolved;`?\n+                   //~^ maybe a missing `extern crate unresolved;`?\n \n fn main() {}"}, {"sha": "b588c88326438c979ac4a693dbb5914aed8006f8", "filename": "src/test/ui/issues/issue-1697.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-1697.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-1697.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-1697.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0432]: unresolved import `unresolved`\n   --> $DIR/issue-1697.rs:13:5\n    |\n LL | use unresolved::*; //~ ERROR unresolved import `unresolved` [E0432]\n-   |     ^^^^^^^^^^ Maybe a missing `extern crate unresolved;`?\n+   |     ^^^^^^^^^^ maybe a missing `extern crate unresolved;`?\n \n error: aborting due to previous error\n "}, {"sha": "c49613eb33c51bf3afcc828e4343a630f2d466f2", "filename": "src/test/ui/issues/issue-17718-patterns.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-17718-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-17718-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17718-patterns.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0530]: match bindings cannot shadow statics\n   --> $DIR/issue-17718-patterns.rs:17:9\n    |\n LL | static A1: usize = 1;\n-   | --------------------- a static `A1` is defined here\n+   | --------------------- the static `A1` is defined here\n ...\n LL |         A1 => {} //~ ERROR: match bindings cannot shadow statics\n    |         ^^ cannot be named the same as a static\n@@ -11,7 +11,7 @@ error[E0530]: match bindings cannot shadow statics\n   --> $DIR/issue-17718-patterns.rs:18:9\n    |\n LL | static mut A2: usize = 1;\n-   | ------------------------- a static `A2` is defined here\n+   | ------------------------- the static `A2` is defined here\n ...\n LL |         A2 => {} //~ ERROR: match bindings cannot shadow statics\n    |         ^^ cannot be named the same as a static"}, {"sha": "c175f197034b436bc99fddfd05fc19177db750d9", "filename": "src/test/ui/issues/issue-23716.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-23716.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-23716.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23716.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0530]: function parameters cannot shadow statics\n   --> $DIR/issue-23716.rs:13:8\n    |\n LL | static foo: i32 = 0;\n-   | -------------------- a static `foo` is defined here\n+   | -------------------- the static `foo` is defined here\n LL | \n LL | fn bar(foo: i32) {}\n    |        ^^^ cannot be named the same as a static\n@@ -11,7 +11,7 @@ error[E0530]: function parameters cannot shadow statics\n   --> $DIR/issue-23716.rs:23:13\n    |\n LL | use self::submod::answer;\n-   |     -------------------- a static `answer` is imported here\n+   |     -------------------- the static `answer` is imported here\n LL | \n LL | fn question(answer: i32) {}\n    |             ^^^^^^ cannot be named the same as a static"}, {"sha": "dfd635d36e8c64304d04d17dcdf97e2e0ad06c49", "filename": "src/test/ui/issues/issue-27033.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-27033.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-27033.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27033.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -8,7 +8,7 @@ error[E0530]: match bindings cannot shadow constants\n   --> $DIR/issue-27033.rs:17:9\n    |\n LL |     const C: u8 = 1;\n-   |     ---------------- a constant `C` is defined here\n+   |     ---------------- the constant `C` is defined here\n LL |     match 1 {\n LL |         C @ 2 => { //~ ERROR match bindings cannot shadow constant\n    |         ^ cannot be named the same as a constant"}, {"sha": "f033666220d9152c16046ceaccca6d8748341bda", "filename": "src/test/ui/issues/issue-30560.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-30560.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-30560.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30560.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -11,10 +11,10 @@\n type Alias = ();\n use Alias::*;\n //~^ ERROR unresolved import `Alias` [E0432]\n-//~| Not a module `Alias`\n+//~| not a module `Alias`\n use std::io::Result::*;\n //~^ ERROR unresolved import `std::io::Result` [E0432]\n-//~| Not a module `Result`\n+//~| not a module `Result`\n \n trait T {}\n use T::*; //~ ERROR items in traits are not importable"}, {"sha": "880c565cf9f6900607d40b8af5cc2e3d9fefedea", "filename": "src/test/ui/issues/issue-30560.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-30560.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-30560.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30560.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -8,13 +8,13 @@ error[E0432]: unresolved import `Alias`\n   --> $DIR/issue-30560.rs:12:5\n    |\n LL | use Alias::*;\n-   |     ^^^^^ Not a module `Alias`\n+   |     ^^^^^ not a module `Alias`\n \n error[E0432]: unresolved import `std::io::Result`\n   --> $DIR/issue-30560.rs:15:14\n    |\n LL | use std::io::Result::*;\n-   |              ^^^^^^ Not a module `Result`\n+   |              ^^^^^^ not a module `Result`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "801ba7afcd600f15be8f759b0e8080fdab363990", "filename": "src/test/ui/issues/issue-33293.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-33293.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-33293.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33293.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -11,6 +11,6 @@\n fn main() {\n     match 0 {\n         aaa::bbb(_) => ()\n-        //~^ ERROR failed to resolve. Use of undeclared type or module `aaa`\n+        //~^ ERROR failed to resolve: use of undeclared type or module `aaa`\n     };\n }"}, {"sha": "dc288fa71ce8a3d48d61550569615ff94a765f25", "filename": "src/test/ui/issues/issue-33293.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-33293.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-33293.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33293.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. Use of undeclared type or module `aaa`\n+error[E0433]: failed to resolve: use of undeclared type or module `aaa`\n   --> $DIR/issue-33293.rs:13:9\n    |\n LL |         aaa::bbb(_) => ()\n-   |         ^^^ Use of undeclared type or module `aaa`\n+   |         ^^^ use of undeclared type or module `aaa`\n \n error: aborting due to previous error\n "}, {"sha": "f41a3973625504c8f336368683a084a3707031e4", "filename": "src/test/ui/issues/issue-33464.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-33464.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-33464.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33464.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,19 +2,19 @@ error[E0432]: unresolved import `abc`\n   --> $DIR/issue-33464.rs:13:5\n    |\n LL | use abc::one_el;\n-   |     ^^^ Maybe a missing `extern crate abc;`?\n+   |     ^^^ maybe a missing `extern crate abc;`?\n \n error[E0432]: unresolved import `abc`\n   --> $DIR/issue-33464.rs:15:5\n    |\n LL | use abc::{a, bbb, cccccc};\n-   |     ^^^ Maybe a missing `extern crate abc;`?\n+   |     ^^^ maybe a missing `extern crate abc;`?\n \n error[E0432]: unresolved import `a_very_long_name`\n   --> $DIR/issue-33464.rs:17:5\n    |\n LL | use a_very_long_name::{el, el2};\n-   |     ^^^^^^^^^^^^^^^^ Maybe a missing `extern crate a_very_long_name;`?\n+   |     ^^^^^^^^^^^^^^^^ maybe a missing `extern crate a_very_long_name;`?\n \n error: aborting due to 3 previous errors\n "}, {"sha": "10e4e9c1c1223e483bb85d72b06535d33ddc6f91", "filename": "src/test/ui/issues/issue-34047.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-34047.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-34047.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34047.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0530]: match bindings cannot shadow constants\n   --> $DIR/issue-34047.rs:15:13\n    |\n LL | const C: u8 = 0;\n-   | ---------------- a constant `C` is defined here\n+   | ---------------- the constant `C` is defined here\n ...\n LL |         mut C => {} //~ ERROR match bindings cannot shadow constants\n    |             ^ cannot be named the same as a constant"}, {"sha": "27effe9e342e03c8f7eebd7e13196a37929a3337", "filename": "src/test/ui/issues/issue-36881.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-36881.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-36881.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-36881.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0432]: unresolved import `issue_36881_aux`\n   --> $DIR/issue-36881.rs:16:9\n    |\n LL |     use issue_36881_aux::Foo; //~ ERROR unresolved import\n-   |         ^^^^^^^^^^^^^^^ Maybe a missing `extern crate issue_36881_aux;`?\n+   |         ^^^^^^^^^^^^^^^ maybe a missing `extern crate issue_36881_aux;`?\n \n error: aborting due to previous error\n "}, {"sha": "48fb6c2e6faa7404328f0d58077a17aaebf3f00f", "filename": "src/test/ui/issues/issue-37887.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-37887.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-37887.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37887.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0432]: unresolved import `libc`\n   --> $DIR/issue-37887.rs:13:9\n    |\n LL |     use libc::*; //~ ERROR unresolved import\n-   |         ^^^^ Maybe a missing `extern crate libc;`?\n+   |         ^^^^ maybe a missing `extern crate libc;`?\n \n error[E0658]: use of unstable library feature 'libc': use `libc` from crates.io (see issue #27783)\n   --> $DIR/issue-37887.rs:12:5"}, {"sha": "5217ddb9acb7d741bb455ea669ac8f52b3eaebba", "filename": "src/test/ui/issues/issue-38857.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-38857.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-38857.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38857.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -10,6 +10,6 @@\n \n fn main() {\n     let a = std::sys::imp::process::process_common::StdioPipes { ..panic!() };\n-    //~^ ERROR failed to resolve. Could not find `imp` in `sys` [E0433]\n+    //~^ ERROR failed to resolve: could not find `imp` in `sys` [E0433]\n     //~^^ ERROR module `sys` is private [E0603]\n }"}, {"sha": "65026344febeff45111b893a2ddbc0c015eb1fba", "filename": "src/test/ui/issues/issue-38857.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-38857.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fissues%2Fissue-38857.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38857.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. Could not find `imp` in `sys`\n+error[E0433]: failed to resolve: could not find `imp` in `sys`\n   --> $DIR/issue-38857.rs:12:23\n    |\n LL |     let a = std::sys::imp::process::process_common::StdioPipes { ..panic!() };\n-   |                       ^^^ Could not find `imp` in `sys`\n+   |                       ^^^ could not find `imp` in `sys`\n \n error[E0603]: module `sys` is private\n   --> $DIR/issue-38857.rs:12:18"}, {"sha": "d8941f3e532dddd77604e1087b240bbe06bea654", "filename": "src/test/ui/keyword/keyword-super-as-identifier.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-super-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-super-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-super-as-identifier.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    let super = 22; //~ ERROR failed to resolve. There are too many initial `super`s\n+    let super = 22; //~ ERROR failed to resolve: there are too many initial `super`s\n }"}, {"sha": "9b665748794c58ec8595c5df0b3ad14355013bdd", "filename": "src/test/ui/keyword/keyword-super-as-identifier.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-super-as-identifier.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-super-as-identifier.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-super-as-identifier.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. There are too many initial `super`s.\n+error[E0433]: failed to resolve: there are too many initial `super`s.\n   --> $DIR/keyword-super-as-identifier.rs:12:9\n    |\n-LL |     let super = 22; //~ ERROR failed to resolve. There are too many initial `super`s\n-   |         ^^^^^ There are too many initial `super`s.\n+LL |     let super = 22; //~ ERROR failed to resolve: there are too many initial `super`s\n+   |         ^^^^^ there are too many initial `super`s.\n \n error: aborting due to previous error\n "}, {"sha": "8764063081874a60f484eb2ad35e40246f73d8eb", "filename": "src/test/ui/keyword/keyword-super.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-super.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-super.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-super.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    let super: isize; //~ ERROR failed to resolve. There are too many initial `super`s\n+    let super: isize; //~ ERROR failed to resolve: there are too many initial `super`s\n }"}, {"sha": "690b684c133721a91393c901a7e245c8fa507504", "filename": "src/test/ui/keyword/keyword-super.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-super.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-super.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-super.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. There are too many initial `super`s.\n+error[E0433]: failed to resolve: there are too many initial `super`s.\n   --> $DIR/keyword-super.rs:12:9\n    |\n-LL |     let super: isize; //~ ERROR failed to resolve. There are too many initial `super`s\n-   |         ^^^^^ There are too many initial `super`s.\n+LL |     let super: isize; //~ ERROR failed to resolve: there are too many initial `super`s\n+   |         ^^^^^ there are too many initial `super`s.\n \n error: aborting due to previous error\n "}, {"sha": "2785594585dd8d85652e6b3f155d0ae10a3047d6", "filename": "src/test/ui/macros/ambiguity-legacy-vs-modern.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fambiguity-legacy-vs-modern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fambiguity-legacy-vs-modern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fambiguity-legacy-vs-modern.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,32 +1,32 @@\n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (`macro_rules` vs non-`macro_rules` from other module)\n   --> $DIR/ambiguity-legacy-vs-modern.rs:31:9\n    |\n LL |         m!() //~ ERROR `m` is ambiguous\n    |         ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/ambiguity-legacy-vs-modern.rs:26:5\n    |\n LL |     macro_rules! m { () => (()) }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/ambiguity-legacy-vs-modern.rs:29:9\n    |\n LL |         macro m() { 0 }\n    |         ^^^^^^^^^^^^^^^\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (`macro_rules` vs non-`macro_rules` from other module)\n   --> $DIR/ambiguity-legacy-vs-modern.rs:43:5\n    |\n LL |     m!() //~ ERROR `m` is ambiguous\n    |     ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/ambiguity-legacy-vs-modern.rs:40:9\n    |\n LL |         macro_rules! m { () => (()) }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/ambiguity-legacy-vs-modern.rs:36:5\n    |\n LL |     macro m() { 0 }"}, {"sha": "2a58fd55453beb63194acbdda7f413c1bd4d0e21", "filename": "src/test/ui/macros/macro-inner-attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fmacro-inner-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fmacro-inner-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-inner-attributes.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -25,6 +25,6 @@ test!(b,\n #[qux]\n fn main() {\n     a::bar();\n-    //~^ ERROR failed to resolve. Use of undeclared type or module `a`\n+    //~^ ERROR failed to resolve: use of undeclared type or module `a`\n     b::bar();\n }"}, {"sha": "47d9469779bb0b392008c4d6533c1608c57d64ba", "filename": "src/test/ui/macros/macro-inner-attributes.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fmacro-inner-attributes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fmacro-inner-attributes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-inner-attributes.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. Use of undeclared type or module `a`\n+error[E0433]: failed to resolve: use of undeclared type or module `a`\n   --> $DIR/macro-inner-attributes.rs:27:5\n    |\n LL |     a::bar();\n-   |     ^ Use of undeclared type or module `a`\n+   |     ^ use of undeclared type or module `a`\n \n error: aborting due to previous error\n "}, {"sha": "bdf3ac0f69f40aac1224ce337d16c3423098c229", "filename": "src/test/ui/macros/macro-path-prelude-fail-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-1.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -12,8 +12,8 @@\n \n mod m {\n     fn check() {\n-        Vec::clone!(); //~ ERROR failed to resolve. Not a module `Vec`\n-        u8::clone!(); //~ ERROR failed to resolve. Not a module `u8`\n+        Vec::clone!(); //~ ERROR failed to resolve: not a module `Vec`\n+        u8::clone!(); //~ ERROR failed to resolve: not a module `u8`\n     }\n }\n "}, {"sha": "590e4f0fd062ef93ac3fd13cd4c55391d1d43a29", "filename": "src/test/ui/macros/macro-path-prelude-fail-1.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-1.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,14 +1,14 @@\n-error[E0433]: failed to resolve. Not a module `Vec`\n+error[E0433]: failed to resolve: not a module `Vec`\n   --> $DIR/macro-path-prelude-fail-1.rs:15:9\n    |\n-LL |         Vec::clone!(); //~ ERROR failed to resolve. Not a module `Vec`\n-   |         ^^^ Not a module `Vec`\n+LL |         Vec::clone!(); //~ ERROR failed to resolve: not a module `Vec`\n+   |         ^^^ not a module `Vec`\n \n-error[E0433]: failed to resolve. Not a module `u8`\n+error[E0433]: failed to resolve: not a module `u8`\n   --> $DIR/macro-path-prelude-fail-1.rs:16:9\n    |\n-LL |         u8::clone!(); //~ ERROR failed to resolve. Not a module `u8`\n-   |         ^^ Not a module `u8`\n+LL |         u8::clone!(); //~ ERROR failed to resolve: not a module `u8`\n+   |         ^^ not a module `u8`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e27c061e19502ee9bcf22a9400557bffa63c87b4", "filename": "src/test/ui/macros/macro-path-prelude-fail-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-2.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -10,7 +10,7 @@\n \n mod m {\n     fn check() {\n-        Result::Ok!(); //~ ERROR fail to resolve non-ident macro path\n+        Result::Ok!(); //~ ERROR failed to resolve: partially resolved path in a macro\n     }\n }\n "}, {"sha": "cf123f43fea3dd2f899beb8c59702b3e900bfe60", "filename": "src/test/ui/macros/macro-path-prelude-fail-2.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-2.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,9 @@\n-error: fail to resolve non-ident macro path\n+error[E0433]: failed to resolve: partially resolved path in a macro\n   --> $DIR/macro-path-prelude-fail-2.rs:13:9\n    |\n-LL |         Result::Ok!(); //~ ERROR fail to resolve non-ident macro path\n-   |         ^^^^^^^^^^\n+LL |         Result::Ok!(); //~ ERROR failed to resolve: partially resolved path in a macro\n+   |         ^^^^^^^^^^ partially resolved path in a macro\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "904eed9f2499f51ebb79271a28849e955ee2dbc4", "filename": "src/test/ui/macros/macro-path-prelude-shadowing.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-shadowing.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,16 +1,17 @@\n-error[E0659]: `std` is ambiguous\n+error[E0659]: `std` is ambiguous (glob import vs any other name from outer scope during import/macro resolution)\n   --> $DIR/macro-path-prelude-shadowing.rs:39:9\n    |\n LL |         std::panic!(); //~ ERROR `std` is ambiguous\n    |         ^^^ ambiguous name\n    |\n-note: `std` could refer to the name imported here\n+   = note: `std` could refer to a built-in extern crate\n+note: `std` could also refer to the module imported here\n   --> $DIR/macro-path-prelude-shadowing.rs:37:9\n    |\n LL |     use m2::*; // glob-import user-defined `std`\n    |         ^^^^^\n-note: `std` could also refer to the name defined here\n-   = note: consider adding an explicit import of `std` to disambiguate\n+   = help: consider adding an explicit import of `std` to disambiguate\n+   = help: or use `self::std` to refer to this module unambiguously\n \n error: aborting due to previous error\n "}, {"sha": "6985dfcc6c27e5518960bef7c25b252850c4fe16", "filename": "src/test/ui/macros/macro-shadowing.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -9,26 +9,25 @@ LL | m1!();\n    |\n    = note: macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\n \n-error[E0659]: `foo` is ambiguous\n+error[E0659]: `foo` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/macro-shadowing.rs:27:1\n    |\n LL | foo!(); //~ ERROR `foo` is ambiguous\n    | ^^^ ambiguous name\n    |\n-note: `foo` could refer to the name defined here\n+note: `foo` could refer to the macro defined here\n   --> $DIR/macro-shadowing.rs:20:5\n    |\n LL |     macro_rules! foo { () => {} }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | m1!();\n    | ------ in this macro invocation\n-note: `foo` could also refer to the name defined here\n+note: `foo` could also refer to the macro defined here\n   --> $DIR/macro-shadowing.rs:15:1\n    |\n LL | macro_rules! foo { () => {} }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: macro-expanded macros do not shadow\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8b4fe9f200dce160b274f3ca53398a7df9b7baf8", "filename": "src/test/ui/macros/macro_path_as_generic_bound.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fmacro_path_as_generic_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Fmacro_path_as_generic_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro_path_as_generic_bound.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. Use of undeclared type or module `m`\n+error[E0433]: failed to resolve: use of undeclared type or module `m`\n   --> $DIR/macro_path_as_generic_bound.rs:17:6\n    |\n LL | foo!(m::m2::A); //~ ERROR failed to resolve\n-   |      ^ Use of undeclared type or module `m`\n+   |      ^ use of undeclared type or module `m`\n \n error: aborting due to previous error\n "}, {"sha": "2135d63c80ec28e4b96e4bde5f07fd1f503cc0eb", "filename": "src/test/ui/macros/restricted-shadowing-legacy.stderr", "status": "modified", "additions": 24, "deletions": 32, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-legacy.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,194 +1,186 @@\n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-legacy.rs:101:13\n    |\n LL |             m!(); //~ ERROR `m` is ambiguous\n    |             ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n    |\n LL |         macro_rules! m { () => { Right } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:97:9\n    |\n LL |         macro_rules! m { () => {} }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-legacy.rs:139:42\n    |\n LL |         macro_rules! gen_invoc { () => { m!() } } //~ ERROR `m` is ambiguous\n    |                                          ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n    |\n LL |         macro_rules! m { () => { Right } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:135:9\n    |\n LL |         macro_rules! m { () => {} }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-legacy.rs:148:9\n    |\n LL |         m!(); //~ ERROR `m` is ambiguous\n    |         ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n    |\n LL |         macro_rules! m { () => { Right } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:144:9\n    |\n LL |         macro_rules! m { () => {} }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-legacy.rs:164:9\n    |\n LL |         m!(); //~ ERROR `m` is ambiguous\n    |         ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n    |\n LL |         macro_rules! m { () => { Right } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:85:9\n    |\n LL |         macro_rules! m { () => { Wrong } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-legacy.rs:180:13\n    |\n LL |             m!(); //~ ERROR `m` is ambiguous\n    |             ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n    |\n LL |         macro_rules! m { () => { Right } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:85:9\n    |\n LL |         macro_rules! m { () => { Wrong } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-legacy.rs:218:42\n    |\n LL |         macro_rules! gen_invoc { () => { m!() } } //~ ERROR `m` is ambiguous\n    |                                          ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n    |\n LL |         macro_rules! m { () => { Right } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:85:9\n    |\n LL |         macro_rules! m { () => { Wrong } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-legacy.rs:232:9\n    |\n LL |         m!(); //~ ERROR `m` is ambiguous\n    |         ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n    |\n LL |         macro_rules! m { () => { Right } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:227:13\n    |\n LL |             macro_rules! m { () => {} }\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-legacy.rs:262:42\n    |\n LL |         macro_rules! gen_invoc { () => { m!() } } //~ ERROR `m` is ambiguous\n    |                                          ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n    |\n LL |         macro_rules! m { () => { Right } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:257:13\n    |\n LL |             macro_rules! m { () => {} }\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n error: aborting due to 8 previous errors\n "}, {"sha": "2449e8512d3cd1ed73f82238a75309e9a487f7a0", "filename": "src/test/ui/macros/restricted-shadowing-modern.stderr", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,146 +1,140 @@\n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-modern.rs:106:17\n    |\n LL |                 m!(); //~ ERROR `m` is ambiguous\n    |                 ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:91:9\n    |\n LL |         macro m() { Right }\n    |         ^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:101:9\n    |\n LL |         macro m() {}\n    |         ^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-modern.rs:149:33\n    |\n LL |             macro gen_invoc() { m!() } //~ ERROR `m` is ambiguous\n    |                                 ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:91:9\n    |\n LL |         macro m() { Right }\n    |         ^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:145:9\n    |\n LL |         macro m() {}\n    |         ^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-modern.rs:158:13\n    |\n LL |             m!(); //~ ERROR `m` is ambiguous\n    |             ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:91:9\n    |\n LL |         macro m() { Right }\n    |         ^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:155:9\n    |\n LL |         macro m() {}\n    |         ^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-modern.rs:174:13\n    |\n LL |             m!(); //~ ERROR `m` is ambiguous\n    |             ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:91:9\n    |\n LL |         macro m() { Right }\n    |         ^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:87:9\n    |\n LL |         macro m() { Wrong }\n    |         ^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-modern.rs:192:17\n    |\n LL |                 m!(); //~ ERROR `m` is ambiguous\n    |                 ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:91:9\n    |\n LL |         macro m() { Right }\n    |         ^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:87:9\n    |\n LL |         macro m() { Wrong }\n    |         ^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-modern.rs:235:33\n    |\n LL |             macro gen_invoc() { m!() } //~ ERROR `m` is ambiguous\n    |                                 ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:91:9\n    |\n LL |         macro m() { Right }\n    |         ^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:87:9\n    |\n LL |         macro m() { Wrong }\n    |         ^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n error: aborting due to 6 previous errors\n "}, {"sha": "4696e2057282a5f1c1c7576fb8a2bccb25239cd1", "filename": "src/test/ui/out-of-order-shadowing.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fout-of-order-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fout-of-order-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fout-of-order-shadowing.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,20 +1,19 @@\n-error[E0659]: `bar` is ambiguous\n+error[E0659]: `bar` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/out-of-order-shadowing.rs:15:1\n    |\n LL | bar!(); //~ ERROR `bar` is ambiguous\n    | ^^^ ambiguous name\n    |\n-note: `bar` could refer to the name defined here\n+note: `bar` could refer to the macro defined here\n   --> $DIR/out-of-order-shadowing.rs:14:1\n    |\n LL | define_macro!(bar);\n    | ^^^^^^^^^^^^^^^^^^^\n-note: `bar` could also refer to the name defined here\n+note: `bar` could also refer to the macro defined here\n   --> $DIR/out-of-order-shadowing.rs:13:1\n    |\n LL | macro_rules! bar { () => {} }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: macro-expanded macros do not shadow\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "994c78d575e27787a2f59e2e9413f5829c6d1dfd", "filename": "src/test/ui/pattern/pat-shadow-in-nested-binding.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fpattern%2Fpat-shadow-in-nested-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fpattern%2Fpat-shadow-in-nested-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-shadow-in-nested-binding.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0530]: let bindings cannot shadow tuple structs\n   --> $DIR/pat-shadow-in-nested-binding.rs:14:10\n    |\n LL | struct foo(usize);\n-   | ------------------ a tuple struct `foo` is defined here\n+   | ------------------ the tuple struct `foo` is defined here\n ...\n LL |     let (foo, _) = (2, 3); //~ ERROR let bindings cannot shadow tuple structs\n    |          ^^^ cannot be named the same as a tuple struct"}, {"sha": "5d14610b8a1ab3d79d4801dc5de87b2a826cf265", "filename": "src/test/ui/pattern/pattern-binding-disambiguation.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fpattern%2Fpattern-binding-disambiguation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fpattern%2Fpattern-binding-disambiguation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-binding-disambiguation.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0530]: match bindings cannot shadow tuple structs\n   --> $DIR/pattern-binding-disambiguation.rs:34:9\n    |\n LL | struct TupleStruct();\n-   | --------------------- a tuple struct `TupleStruct` is defined here\n+   | --------------------- the tuple struct `TupleStruct` is defined here\n ...\n LL |         TupleStruct => {} //~ ERROR match bindings cannot shadow tuple structs\n    |         ^^^^^^^^^^^ cannot be named the same as a tuple struct\n@@ -11,7 +11,7 @@ error[E0530]: match bindings cannot shadow tuple variants\n   --> $DIR/pattern-binding-disambiguation.rs:43:9\n    |\n LL | use E::*;\n-   |     ---- a tuple variant `TupleVariant` is imported here\n+   |     ---- the tuple variant `TupleVariant` is imported here\n ...\n LL |         TupleVariant => {} //~ ERROR match bindings cannot shadow tuple variants\n    |         ^^^^^^^^^^^^ cannot be named the same as a tuple variant\n@@ -20,7 +20,7 @@ error[E0530]: match bindings cannot shadow struct variants\n   --> $DIR/pattern-binding-disambiguation.rs:46:9\n    |\n LL | use E::*;\n-   |     ---- a struct variant `BracedVariant` is imported here\n+   |     ---- the struct variant `BracedVariant` is imported here\n ...\n LL |         BracedVariant => {} //~ ERROR match bindings cannot shadow struct variants\n    |         ^^^^^^^^^^^^^ cannot be named the same as a struct variant\n@@ -29,7 +29,7 @@ error[E0530]: match bindings cannot shadow statics\n   --> $DIR/pattern-binding-disambiguation.rs:52:9\n    |\n LL | static STATIC: () = ();\n-   | ----------------------- a static `STATIC` is defined here\n+   | ----------------------- the static `STATIC` is defined here\n ...\n LL |         STATIC => {} //~ ERROR match bindings cannot shadow statics\n    |         ^^^^^^ cannot be named the same as a static\n@@ -38,7 +38,7 @@ error[E0530]: let bindings cannot shadow tuple structs\n   --> $DIR/pattern-binding-disambiguation.rs:59:9\n    |\n LL | struct TupleStruct();\n-   | --------------------- a tuple struct `TupleStruct` is defined here\n+   | --------------------- the tuple struct `TupleStruct` is defined here\n ...\n LL |     let TupleStruct = doesnt_matter; //~ ERROR let bindings cannot shadow tuple structs\n    |         ^^^^^^^^^^^ cannot be named the same as a tuple struct\n@@ -47,7 +47,7 @@ error[E0530]: let bindings cannot shadow tuple variants\n   --> $DIR/pattern-binding-disambiguation.rs:62:9\n    |\n LL | use E::*;\n-   |     ---- a tuple variant `TupleVariant` is imported here\n+   |     ---- the tuple variant `TupleVariant` is imported here\n ...\n LL |     let TupleVariant = doesnt_matter; //~ ERROR let bindings cannot shadow tuple variants\n    |         ^^^^^^^^^^^^ cannot be named the same as a tuple variant\n@@ -56,7 +56,7 @@ error[E0530]: let bindings cannot shadow struct variants\n   --> $DIR/pattern-binding-disambiguation.rs:63:9\n    |\n LL | use E::*;\n-   |     ---- a struct variant `BracedVariant` is imported here\n+   |     ---- the struct variant `BracedVariant` is imported here\n ...\n LL |     let BracedVariant = doesnt_matter; //~ ERROR let bindings cannot shadow struct variants\n    |         ^^^^^^^^^^^^^ cannot be named the same as a struct variant\n@@ -65,7 +65,7 @@ error[E0530]: let bindings cannot shadow statics\n   --> $DIR/pattern-binding-disambiguation.rs:65:9\n    |\n LL | static STATIC: () = ();\n-   | ----------------------- a static `STATIC` is defined here\n+   | ----------------------- the static `STATIC` is defined here\n ...\n LL |     let STATIC = doesnt_matter; //~ ERROR let bindings cannot shadow statics\n    |         ^^^^^^ cannot be named the same as a static"}, {"sha": "c544ca4e304f09ef356a539021060b8eab35acc4", "filename": "src/test/ui/pattern/pattern-error-continue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -42,6 +42,6 @@ fn main() {\n     //~| expected char, found bool\n \n     match () {\n-        E::V => {} //~ ERROR failed to resolve. Use of undeclared type or module `E`\n+        E::V => {} //~ ERROR failed to resolve: use of undeclared type or module `E`\n     }\n }"}, {"sha": "f2c35ef872d36a21acf9d0602b55d1e53c624d6d", "filename": "src/test/ui/pattern/pattern-error-continue.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. Use of undeclared type or module `E`\n+error[E0433]: failed to resolve: use of undeclared type or module `E`\n   --> $DIR/pattern-error-continue.rs:45:9\n    |\n-LL |         E::V => {} //~ ERROR failed to resolve. Use of undeclared type or module `E`\n-   |         ^ Use of undeclared type or module `E`\n+LL |         E::V => {} //~ ERROR failed to resolve: use of undeclared type or module `E`\n+   |         ^ use of undeclared type or module `E`\n \n error[E0532]: expected tuple struct/variant, found unit variant `A::D`\n   --> $DIR/pattern-error-continue.rs:28:9"}, {"sha": "1eb49bd530176ea49eb3908ecc6b4eca3105b0cc", "filename": "src/test/ui/privacy/decl-macro.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fprivacy%2Fdecl-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fprivacy%2Fdecl-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fdecl-macro.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,9 @@\n+#![feature(decl_macro)]\n+\n+mod m {\n+    macro mac() {}\n+}\n+\n+fn main() {\n+    m::mac!(); //~ ERROR macro `mac` is private\n+}"}, {"sha": "c8b043d1b5f31f53e8eec683827db3e72134c369", "filename": "src/test/ui/privacy/decl-macro.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fprivacy%2Fdecl-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fprivacy%2Fdecl-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fdecl-macro.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,9 @@\n+error[E0603]: macro `mac` is private\n+  --> $DIR/decl-macro.rs:8:8\n+   |\n+LL |     m::mac!(); //~ ERROR macro `mac` is private\n+   |        ^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0603`."}, {"sha": "2b2d9b76bddad7bc4b157ee812b8e13524a2400b", "filename": "src/test/ui/privacy/restricted/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -57,6 +57,6 @@ fn main() {\n }\n \n mod pathological {\n-    pub(in bad::path) mod m1 {} //~ ERROR failed to resolve. Maybe a missing `extern crate bad;`?\n+    pub(in bad::path) mod m1 {} //~ ERROR failed to resolve: maybe a missing `extern crate bad;`?\n     pub(in foo) mod m2 {} //~ ERROR visibilities can only be restricted to ancestor modules\n }"}, {"sha": "01e224910a5eb776ae9a90b4798b59c898d63571", "filename": "src/test/ui/privacy/restricted/test.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. Maybe a missing `extern crate bad;`?\n+error[E0433]: failed to resolve: maybe a missing `extern crate bad;`?\n   --> $DIR/test.rs:60:12\n    |\n-LL |     pub(in bad::path) mod m1 {} //~ ERROR failed to resolve. Maybe a missing `extern crate bad;`?\n-   |            ^^^ Maybe a missing `extern crate bad;`?\n+LL |     pub(in bad::path) mod m1 {} //~ ERROR failed to resolve: maybe a missing `extern crate bad;`?\n+   |            ^^^ maybe a missing `extern crate bad;`?\n \n error: visibilities can only be restricted to ancestor modules\n   --> $DIR/test.rs:61:12"}, {"sha": "01f493e954b13570eaac596cb5cab08f1faf357e", "filename": "src/test/ui/resolve/resolve-variant-assoc-item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fresolve%2Fresolve-variant-assoc-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fresolve%2Fresolve-variant-assoc-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-variant-assoc-item.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -12,6 +12,6 @@ enum E { V }\n use E::V;\n \n fn main() {\n-    E::V::associated_item; //~ ERROR failed to resolve. Not a module `V`\n-    V::associated_item; //~ ERROR failed to resolve. Not a module `V`\n+    E::V::associated_item; //~ ERROR failed to resolve: not a module `V`\n+    V::associated_item; //~ ERROR failed to resolve: not a module `V`\n }"}, {"sha": "ef2d0a71b5b8509916e5c01192b47a6b4d49507c", "filename": "src/test/ui/resolve/resolve-variant-assoc-item.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fresolve%2Fresolve-variant-assoc-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fresolve%2Fresolve-variant-assoc-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-variant-assoc-item.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,14 +1,14 @@\n-error[E0433]: failed to resolve. Not a module `V`\n+error[E0433]: failed to resolve: not a module `V`\n   --> $DIR/resolve-variant-assoc-item.rs:15:8\n    |\n-LL |     E::V::associated_item; //~ ERROR failed to resolve. Not a module `V`\n-   |        ^ Not a module `V`\n+LL |     E::V::associated_item; //~ ERROR failed to resolve: not a module `V`\n+   |        ^ not a module `V`\n \n-error[E0433]: failed to resolve. Not a module `V`\n+error[E0433]: failed to resolve: not a module `V`\n   --> $DIR/resolve-variant-assoc-item.rs:16:5\n    |\n-LL |     V::associated_item; //~ ERROR failed to resolve. Not a module `V`\n-   |     ^ Not a module `V`\n+LL |     V::associated_item; //~ ERROR failed to resolve: not a module `V`\n+   |     ^ not a module `V`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2ce2d76583232ccfa26ffc7c8e9416715837ae4e", "filename": "src/test/ui/resolve_self_super_hint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fresolve_self_super_hint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fresolve_self_super_hint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve_self_super_hint.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -15,19 +15,19 @@ mod a {\n     extern crate alloc;\n     use alloc::HashMap;\n     //~^ ERROR unresolved import `alloc` [E0432]\n-    //~| Did you mean `self::alloc`?\n+    //~| did you mean `self::alloc`?\n     mod b {\n         use alloc::HashMap;\n         //~^ ERROR unresolved import `alloc` [E0432]\n-        //~| Did you mean `super::alloc`?\n+        //~| did you mean `super::alloc`?\n         mod c {\n             use alloc::HashMap;\n             //~^ ERROR unresolved import `alloc` [E0432]\n-            //~| Did you mean `std::alloc`?\n+            //~| did you mean `a::alloc`?\n             mod d {\n                 use alloc::HashMap;\n                 //~^ ERROR unresolved import `alloc` [E0432]\n-                //~| Did you mean `std::alloc`?\n+                //~| did you mean `a::alloc`?\n             }\n         }\n     }"}, {"sha": "613107712b2143a23749882a246bf437947e43bf", "filename": "src/test/ui/resolve_self_super_hint.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fresolve_self_super_hint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fresolve_self_super_hint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve_self_super_hint.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,25 +2,25 @@ error[E0432]: unresolved import `alloc`\n   --> $DIR/resolve_self_super_hint.rs:16:9\n    |\n LL |     use alloc::HashMap;\n-   |         ^^^^^ Did you mean `self::alloc`?\n+   |         ^^^^^ did you mean `self::alloc`?\n \n error[E0432]: unresolved import `alloc`\n   --> $DIR/resolve_self_super_hint.rs:20:13\n    |\n LL |         use alloc::HashMap;\n-   |             ^^^^^ Did you mean `super::alloc`?\n+   |             ^^^^^ did you mean `super::alloc`?\n \n error[E0432]: unresolved import `alloc`\n   --> $DIR/resolve_self_super_hint.rs:24:17\n    |\n LL |             use alloc::HashMap;\n-   |                 ^^^^^ Did you mean `std::alloc`?\n+   |                 ^^^^^ did you mean `a::alloc`?\n \n error[E0432]: unresolved import `alloc`\n   --> $DIR/resolve_self_super_hint.rs:28:21\n    |\n LL |                 use alloc::HashMap;\n-   |                     ^^^^^ Did you mean `std::alloc`?\n+   |                     ^^^^^ did you mean `a::alloc`?\n \n error: aborting due to 4 previous errors\n "}, {"sha": "2751d8cb285a3d7dee26b6565adf2e01ef73b8bd", "filename": "src/test/ui/rfc-2126-crate-paths/crate-path-non-absolute.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frfc-2126-crate-paths%2Fcrate-path-non-absolute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frfc-2126-crate-paths%2Fcrate-path-non-absolute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2126-crate-paths%2Fcrate-path-non-absolute.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,10 +1,10 @@\n-error[E0433]: failed to resolve. `crate` in paths can only be used in start position\n+error[E0433]: failed to resolve: `crate` in paths can only be used in start position\n   --> $DIR/crate-path-non-absolute.rs:17:22\n    |\n LL |         let s = ::m::crate::S; //~ ERROR failed to resolve\n    |                      ^^^^^ `crate` in paths can only be used in start position\n \n-error[E0433]: failed to resolve. global paths cannot start with `crate`\n+error[E0433]: failed to resolve: global paths cannot start with `crate`\n   --> $DIR/crate-path-non-absolute.rs:18:20\n    |\n LL |         let s1 = ::crate::S; //~ ERROR failed to resolve"}, {"sha": "39b2db7a19f7073fabed717193c40734887a2754", "filename": "src/test/ui/rfc-2126-extern-absolute-paths/non-existent-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnon-existent-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnon-existent-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnon-existent-1.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0432]: unresolved import `xcrate`\n   --> $DIR/non-existent-1.rs:13:5\n    |\n LL | use xcrate::S; //~ ERROR unresolved import `xcrate`\n-   |     ^^^^^^ Could not find `xcrate` in `{{root}}`\n+   |     ^^^^^^ use of undeclared type or module `xcrate`\n \n error: aborting due to previous error\n "}, {"sha": "a07c3f17d6f7bd6d4171185e0c476dfa8a0a9e75", "filename": "src/test/ui/rfc-2126-extern-absolute-paths/non-existent-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnon-existent-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnon-existent-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnon-existent-2.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -12,5 +12,5 @@\n \n fn main() {\n     let s = ::xcrate::S;\n-    //~^ ERROR failed to resolve. Could not find `xcrate` in `{{root}}`\n+    //~^ ERROR failed to resolve: could not find `xcrate` in `{{root}}`\n }"}, {"sha": "30e5b0ad1dfb7fc7fa88327d95685198f83c1ddc", "filename": "src/test/ui/rfc-2126-extern-absolute-paths/non-existent-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnon-existent-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnon-existent-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnon-existent-2.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. Could not find `xcrate` in `{{root}}`\n+error[E0433]: failed to resolve: could not find `xcrate` in `{{root}}`\n   --> $DIR/non-existent-2.rs:14:15\n    |\n LL |     let s = ::xcrate::S;\n-   |               ^^^^^^ Could not find `xcrate` in `{{root}}`\n+   |               ^^^^^^ could not find `xcrate` in `{{root}}`\n \n error: aborting due to previous error\n "}, {"sha": "bfe7e4da84562298b24533f3ae109532e36c28ef", "filename": "src/test/ui/rfc-2126-extern-absolute-paths/not-whitelisted.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnot-whitelisted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnot-whitelisted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnot-whitelisted.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -10,10 +10,12 @@\n \n // edition:2018\n \n+#![feature(uniform_paths)]\n+\n // Tests that arbitrary crates (other than `core`, `std` and `meta`)\n // aren't allowed without `--extern`, even if they're in the sysroot.\n use alloc; //~ ERROR unresolved import `alloc`\n-use test; //~ ERROR unresolved import `test`\n-use proc_macro; //~ ERROR unresolved import `proc_macro`\n+use test; //~ ERROR cannot import a built-in macro\n+use proc_macro; // OK, imports the built-in `proc_macro` attribute, but not the `proc_macro` crate.\n \n fn main() {}"}, {"sha": "06c11b894ddc3cad92830561bb120791708ba487", "filename": "src/test/ui/rfc-2126-extern-absolute-paths/not-whitelisted.stderr", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnot-whitelisted.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnot-whitelisted.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnot-whitelisted.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,21 +1,15 @@\n-error[E0432]: unresolved import `alloc`\n-  --> $DIR/not-whitelisted.rs:15:5\n-   |\n-LL | use alloc; //~ ERROR unresolved import `alloc`\n-   |     ^^^^^ no `alloc` external crate\n-\n-error[E0432]: unresolved import `test`\n-  --> $DIR/not-whitelisted.rs:16:5\n+error: cannot import a built-in macro\n+  --> $DIR/not-whitelisted.rs:18:5\n    |\n-LL | use test; //~ ERROR unresolved import `test`\n-   |     ^^^^ no `test` external crate\n+LL | use test; //~ ERROR cannot import a built-in macro\n+   |     ^^^^\n \n-error[E0432]: unresolved import `proc_macro`\n+error[E0432]: unresolved import `alloc`\n   --> $DIR/not-whitelisted.rs:17:5\n    |\n-LL | use proc_macro; //~ ERROR unresolved import `proc_macro`\n-   |     ^^^^^^^^^^ no `proc_macro` external crate\n+LL | use alloc; //~ ERROR unresolved import `alloc`\n+   |     ^^^^^ no `alloc` external crate\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0432`."}, {"sha": "47ea4b8dfcb8a4beba82ee6a1021dee68b25c7dc", "filename": "src/test/ui/rfc-2126-extern-in-paths/non-existent-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frfc-2126-extern-in-paths%2Fnon-existent-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frfc-2126-extern-in-paths%2Fnon-existent-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2126-extern-in-paths%2Fnon-existent-1.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0432]: unresolved import `extern::xcrate`\n   --> $DIR/non-existent-1.rs:13:13\n    |\n LL | use extern::xcrate::S; //~ ERROR unresolved import `extern::xcrate`\n-   |             ^^^^^^ Could not find `xcrate` in `extern`\n+   |             ^^^^^^ could not find `xcrate` in `extern`\n \n error: aborting due to previous error\n "}, {"sha": "8d7c3993c6273e7ba38451fd0508fafa844cb8b1", "filename": "src/test/ui/rfc-2126-extern-in-paths/non-existent-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frfc-2126-extern-in-paths%2Fnon-existent-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frfc-2126-extern-in-paths%2Fnon-existent-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2126-extern-in-paths%2Fnon-existent-2.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -12,5 +12,5 @@\n \n fn main() {\n     let s = extern::xcrate::S;\n-    //~^ ERROR failed to resolve. Could not find `xcrate` in `extern`\n+    //~^ ERROR failed to resolve: could not find `xcrate` in `extern`\n }"}, {"sha": "89630adb5a8249e1c041e0aca3eb394388a0fe9a", "filename": "src/test/ui/rfc-2126-extern-in-paths/non-existent-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frfc-2126-extern-in-paths%2Fnon-existent-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frfc-2126-extern-in-paths%2Fnon-existent-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2126-extern-in-paths%2Fnon-existent-2.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. Could not find `xcrate` in `extern`\n+error[E0433]: failed to resolve: could not find `xcrate` in `extern`\n   --> $DIR/non-existent-2.rs:14:21\n    |\n LL |     let s = extern::xcrate::S;\n-   |                     ^^^^^^ Could not find `xcrate` in `extern`\n+   |                     ^^^^^^ could not find `xcrate` in `extern`\n \n error: aborting due to previous error\n "}, {"sha": "d2e6dbbb95412ac260d8bb55407d3f7b976cd571", "filename": "src/test/ui/rust-2018/future-proofing-locals.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Ffuture-proofing-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Ffuture-proofing-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Ffuture-proofing-locals.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,49 @@\n+// edition:2018\n+\n+#![feature(uniform_paths, underscore_imports)]\n+\n+mod T {\n+    pub struct U;\n+}\n+mod x {\n+    pub struct y;\n+}\n+\n+fn type_param<T>() {\n+    use T as _; //~ ERROR imports cannot refer to type parameters\n+    use T::U; //~ ERROR imports cannot refer to type parameters\n+    use T::*; //~ ERROR imports cannot refer to type parameters\n+}\n+\n+fn self_import<T>() {\n+    use T; // FIXME Should be an error, but future-proofing fails due to `T` being \"self-shadowed\"\n+}\n+\n+fn let_binding() {\n+    let x = 10;\n+\n+    use x as _; //~ ERROR imports cannot refer to local variables\n+    use x::y; // OK\n+    use x::*; // OK\n+}\n+\n+fn param_binding(x: u8) {\n+    use x; //~ ERROR imports cannot refer to local variables\n+}\n+\n+fn match_binding() {\n+    match 0 {\n+        x => {\n+            use x; //~ ERROR imports cannot refer to local variables\n+        }\n+    }\n+}\n+\n+fn nested<T>() {\n+    let x = 10;\n+\n+    use {T as _, x}; //~ ERROR imports cannot refer to type parameters\n+                     //~| ERROR imports cannot refer to local variables\n+}\n+\n+fn main() {}"}, {"sha": "68354b332a9c68036c366f45b69f3efd787a8b20", "filename": "src/test/ui/rust-2018/future-proofing-locals.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Ffuture-proofing-locals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Ffuture-proofing-locals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Ffuture-proofing-locals.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,50 @@\n+error: imports cannot refer to type parameters\n+  --> $DIR/future-proofing-locals.rs:13:9\n+   |\n+LL |     use T as _; //~ ERROR imports cannot refer to type parameters\n+   |         ^\n+\n+error: imports cannot refer to type parameters\n+  --> $DIR/future-proofing-locals.rs:14:9\n+   |\n+LL |     use T::U; //~ ERROR imports cannot refer to type parameters\n+   |         ^\n+\n+error: imports cannot refer to type parameters\n+  --> $DIR/future-proofing-locals.rs:15:9\n+   |\n+LL |     use T::*; //~ ERROR imports cannot refer to type parameters\n+   |         ^\n+\n+error: imports cannot refer to local variables\n+  --> $DIR/future-proofing-locals.rs:25:9\n+   |\n+LL |     use x as _; //~ ERROR imports cannot refer to local variables\n+   |         ^\n+\n+error: imports cannot refer to local variables\n+  --> $DIR/future-proofing-locals.rs:31:9\n+   |\n+LL |     use x; //~ ERROR imports cannot refer to local variables\n+   |         ^\n+\n+error: imports cannot refer to local variables\n+  --> $DIR/future-proofing-locals.rs:37:17\n+   |\n+LL |             use x; //~ ERROR imports cannot refer to local variables\n+   |                 ^\n+\n+error: imports cannot refer to type parameters\n+  --> $DIR/future-proofing-locals.rs:45:10\n+   |\n+LL |     use {T as _, x}; //~ ERROR imports cannot refer to type parameters\n+   |          ^\n+\n+error: imports cannot refer to local variables\n+  --> $DIR/future-proofing-locals.rs:45:18\n+   |\n+LL |     use {T as _, x}; //~ ERROR imports cannot refer to type parameters\n+   |                  ^\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "5f92574c23ffef1485bbc9d7ec857430965c9b0a", "filename": "src/test/ui/rust-2018/issue-54006.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Fissue-54006.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Fissue-54006.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fissue-54006.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0432]: unresolved import `alloc`\n   --> $DIR/issue-54006.rs:16:5\n    |\n LL | use alloc::vec;\n-   |     ^^^^^ Did you mean `core::alloc`?\n+   |     ^^^^^ did you mean `core::alloc`?\n \n error: cannot determine resolution for the macro `vec`\n   --> $DIR/issue-54006.rs:20:18"}, {"sha": "741b2ca0826ce7d58d9bbd1e76b800637dfbf780", "filename": "src/test/ui/rust-2018/local-path-suggestions-2015.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2015.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0432]: unresolved import `foobar`\n   --> $DIR/local-path-suggestions-2015.rs:34:5\n    |\n LL | use foobar::Baz;\n-   |     ^^^^^^ Did you mean `aux_baz::foobar`?\n+   |     ^^^^^^ did you mean `aux_baz::foobar`?\n \n error: aborting due to previous error\n "}, {"sha": "0d4aefff9316c6954fa379ccb5f917dcbf02a30b", "filename": "src/test/ui/rust-2018/local-path-suggestions-2018.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -12,12 +12,14 @@\n // compile-flags:--extern baz\n // edition:2018\n \n+#![feature(uniform_paths)]\n+\n mod foo {\n     pub type Bar = u32;\n }\n \n-mod baz {\n-    use foo::Bar;\n+mod bazz {\n+    use foo::Bar; //~ ERROR unresolved import `foo`\n \n     fn baz() {\n         let x: Bar = 22;\n@@ -26,6 +28,6 @@ mod baz {\n \n use foo::Bar;\n \n-use foobar::Baz;\n+use foobar::Baz; //~ ERROR unresolved import `foobar`\n \n fn main() { }"}, {"sha": "a445a4c612bb997cbc119e3bd2005451ccbebd57", "filename": "src/test/ui/rust-2018/local-path-suggestions-2018.stderr", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,23 +1,17 @@\n error[E0432]: unresolved import `foo`\n-  --> $DIR/local-path-suggestions-2018.rs:20:9\n+  --> $DIR/local-path-suggestions-2018.rs:22:9\n    |\n-LL |     use foo::Bar;\n-   |         ^^^ Did you mean `crate::foo`?\n+LL |     use foo::Bar; //~ ERROR unresolved import `foo`\n+   |         ^^^ did you mean `crate::foo`?\n    |\n    = note: `use` statements changed in Rust 2018; read more at <https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html>\n \n-error[E0432]: unresolved import `foo`\n-  --> $DIR/local-path-suggestions-2018.rs:27:5\n-   |\n-LL | use foo::Bar;\n-   |     ^^^ Did you mean `self::foo`?\n-\n error[E0432]: unresolved import `foobar`\n-  --> $DIR/local-path-suggestions-2018.rs:29:5\n+  --> $DIR/local-path-suggestions-2018.rs:31:5\n    |\n-LL | use foobar::Baz;\n-   |     ^^^^^^ Did you mean `baz::foobar`?\n+LL | use foobar::Baz; //~ ERROR unresolved import `foobar`\n+   |     ^^^^^^ did you mean `baz::foobar`?\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0432`."}, {"sha": "4819711115c27a76a5f25123447bd20bf04cb70b", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-macros-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -14,7 +14,7 @@\n \n mod foo {\n     pub use std::io;\n-    //~^ ERROR `std` import is ambiguous\n+    //~^ ERROR `std` is ambiguous\n \n     macro_rules! m {\n         () => {"}, {"sha": "204e0a7e1411ed4c8437a4c66917e0c6a6913b93", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-macros-nested.stderr", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,16 +1,23 @@\n-error: `std` import is ambiguous\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/ambiguity-macros-nested.rs:16:13\n    |\n-LL |       pub use std::io;\n-   |               ^^^ can refer to external crate `::std`\n-...\n+LL |     pub use std::io;\n+   |             ^^^ ambiguous name\n+   |\n+   = note: `std` could refer to a built-in extern crate\n+   = help: use `::std` to refer to this extern crate unambiguously\n+note: `std` could also refer to the module defined here\n+  --> $DIR/ambiguity-macros-nested.rs:21:13\n+   |\n LL | /             mod std {\n LL | |                 pub struct io;\n LL | |             }\n-   | |_____________- may refer to `self::std` in the future\n-   |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: in the future, `#![feature(uniform_paths)]` may become the default\n+   | |_____________^\n+...\n+LL |       m!();\n+   |       ----- in this macro invocation\n+   = help: use `self::std` to refer to this module unambiguously\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "148320de556d30d4633d90afacbccedaf4da14ea", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -13,7 +13,7 @@\n // This test is similar to `ambiguity.rs`, but with macros defining local items.\n \n use std::io;\n-//~^ ERROR `std` import is ambiguous\n+//~^ ERROR `std` is ambiguous\n \n macro_rules! m {\n     () => {"}, {"sha": "ac8d3b9d0cbe4d0dc347f35a2c901d89e375f29b", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-macros.stderr", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,16 +1,23 @@\n-error: `std` import is ambiguous\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/ambiguity-macros.rs:15:5\n    |\n-LL |   use std::io;\n-   |       ^^^ can refer to external crate `::std`\n-...\n+LL | use std::io;\n+   |     ^^^ ambiguous name\n+   |\n+   = note: `std` could refer to a built-in extern crate\n+   = help: use `::std` to refer to this extern crate unambiguously\n+note: `std` could also refer to the module defined here\n+  --> $DIR/ambiguity-macros.rs:20:9\n+   |\n LL | /         mod std {\n LL | |             pub struct io;\n LL | |         }\n-   | |_________- may refer to `self::std` in the future\n-   |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: in the future, `#![feature(uniform_paths)]` may become the default\n+   | |_________^\n+...\n+LL |   m!();\n+   |   ----- in this macro invocation\n+   = help: use `self::std` to refer to this module unambiguously\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "2791d4580daf1a476deeff60b98c9cbbe4ab5faf", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -14,7 +14,7 @@\n \n mod foo {\n     pub use std::io;\n-    //~^ ERROR `std` import is ambiguous\n+    //~^ ERROR `std` is ambiguous\n \n     mod std {\n         pub struct io;"}, {"sha": "7bcfc563d39fc288da54189a482753efc48e984f", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-nested.stderr", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,16 +1,20 @@\n-error: `std` import is ambiguous\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/ambiguity-nested.rs:16:13\n    |\n-LL |       pub use std::io;\n-   |               ^^^ can refer to external crate `::std`\n-...\n+LL |     pub use std::io;\n+   |             ^^^ ambiguous name\n+   |\n+   = note: `std` could refer to a built-in extern crate\n+   = help: use `::std` to refer to this extern crate unambiguously\n+note: `std` could also refer to the module defined here\n+  --> $DIR/ambiguity-nested.rs:19:5\n+   |\n LL | /     mod std {\n LL | |         pub struct io;\n LL | |     }\n-   | |_____- may refer to `self::std` in the future\n-   |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: in the future, `#![feature(uniform_paths)]` may become the default\n+   | |_____^\n+   = help: use `self::std` to refer to this module unambiguously\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "2bfbb6b287153ded300d89545cab2ff528019c5e", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -11,7 +11,7 @@\n // edition:2018\n \n use std::io;\n-//~^ ERROR `std` import is ambiguous\n+//~^ ERROR `std` is ambiguous\n \n mod std {\n     pub struct io;"}, {"sha": "beeb74654e5b5bc7194dc9c2fba8a68703f7834c", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity.stderr", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,16 +1,20 @@\n-error: `std` import is ambiguous\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/ambiguity.rs:13:5\n    |\n-LL |   use std::io;\n-   |       ^^^ can refer to external crate `::std`\n-...\n+LL | use std::io;\n+   |     ^^^ ambiguous name\n+   |\n+   = note: `std` could refer to a built-in extern crate\n+   = help: use `::std` to refer to this extern crate unambiguously\n+note: `std` could also refer to the module defined here\n+  --> $DIR/ambiguity.rs:16:1\n+   |\n LL | / mod std {\n LL | |     pub struct io;\n LL | | }\n-   | |_- may refer to `self::std` in the future\n-   |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: in the future, `#![feature(uniform_paths)]` may become the default\n+   | |_^\n+   = help: use `self::std` to refer to this module unambiguously\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "2853b4b3a5b3f6c9dc4c242df7efe5ab3c95b389", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/block-scoped-shadow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -16,6 +16,6 @@ fn main() {\n     fn std() {}\n     enum std {}\n     use std as foo;\n-    //~^ ERROR `std` import is ambiguous\n-    //~| ERROR `std` import is ambiguous\n+    //~^ ERROR `std` is ambiguous\n+    //~| ERROR `std` is ambiguous\n }"}, {"sha": "5d539e2d59f1549ca3ba2498cba8236c33662059", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/block-scoped-shadow.stderr", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,31 +1,39 @@\n-error: `std` import is ambiguous\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/block-scoped-shadow.rs:18:9\n    |\n-LL | struct std;\n-   | ----------- may refer to `self::std` in the future\n-...\n-LL |     enum std {}\n-   |     ----------- shadowed by block-scoped `std`\n LL |     use std as foo;\n-   |         ^^^ can refer to external crate `::std`\n+   |         ^^^ ambiguous name\n    |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: in the future, `#![feature(uniform_paths)]` may become the default\n+note: `std` could refer to the enum defined here\n+  --> $DIR/block-scoped-shadow.rs:17:5\n+   |\n+LL |     enum std {}\n+   |     ^^^^^^^^^^^\n+note: `std` could also refer to the struct defined here\n+  --> $DIR/block-scoped-shadow.rs:13:1\n+   |\n+LL | struct std;\n+   | ^^^^^^^^^^^\n+   = help: use `self::std` to refer to this struct unambiguously\n \n-error: `std` import is ambiguous\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/block-scoped-shadow.rs:18:9\n    |\n-LL | struct std;\n-   | ----------- may refer to `self::std` in the future\n-...\n-LL |     fn std() {}\n-   |     ----------- shadowed by block-scoped `std`\n-LL |     enum std {}\n LL |     use std as foo;\n-   |         ^^^\n+   |         ^^^ ambiguous name\n+   |\n+note: `std` could refer to the function defined here\n+  --> $DIR/block-scoped-shadow.rs:16:5\n    |\n-   = help: write `self::std` explicitly instead\n-   = note: in the future, `#![feature(uniform_paths)]` may become the default\n+LL |     fn std() {}\n+   |     ^^^^^^^^^^^\n+note: `std` could also refer to the unit struct defined here\n+  --> $DIR/block-scoped-shadow.rs:13:1\n+   |\n+LL | struct std;\n+   | ^^^^^^^^^^^\n+   = help: use `self::std` to refer to this unit struct unambiguously\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "ef2a1e3c70c6f873153f220db5a07d7575df1493", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/issue-54253.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fissue-54253.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fissue-54253.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fissue-54253.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -10,7 +10,7 @@\n \n // edition:2018\n \n-// Dummy import to introduce `uniform_paths` canaries.\n+// Dummy import that previously introduced uniform path canaries.\n use std;\n \n // fn version() -> &'static str {\"\"}"}, {"sha": "4819711115c27a76a5f25123447bd20bf04cb70b", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros-nested.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -10,13 +10,11 @@\n \n // edition:2018\n \n-#![feature(uniform_paths)]\n-\n // This test is similar to `ambiguity-macros.rs`, but nested in a module.\n \n mod foo {\n     pub use std::io;\n-    //~^ ERROR `std` import is ambiguous\n+    //~^ ERROR `std` is ambiguous\n \n     macro_rules! m {\n         () => {"}, {"sha": "204e0a7e1411ed4c8437a4c66917e0c6a6913b93", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros-nested.stderr", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,16 +1,23 @@\n-error: `std` import is ambiguous\n-  --> $DIR/ambiguity-macros-nested.rs:18:13\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n+  --> $DIR/ambiguity-macros-nested.rs:16:13\n+   |\n+LL |     pub use std::io;\n+   |             ^^^ ambiguous name\n+   |\n+   = note: `std` could refer to a built-in extern crate\n+   = help: use `::std` to refer to this extern crate unambiguously\n+note: `std` could also refer to the module defined here\n+  --> $DIR/ambiguity-macros-nested.rs:21:13\n    |\n-LL |       pub use std::io;\n-   |               ^^^ can refer to external crate `::std`\n-...\n LL | /             mod std {\n LL | |                 pub struct io;\n LL | |             }\n-   | |_____________- can refer to `self::std`\n-   |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+   | |_____________^\n+...\n+LL |       m!();\n+   |       ----- in this macro invocation\n+   = help: use `self::std` to refer to this module unambiguously\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "148320de556d30d4633d90afacbccedaf4da14ea", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -10,12 +10,10 @@\n \n // edition:2018\n \n-#![feature(uniform_paths)]\n-\n // This test is similar to `ambiguity.rs`, but with macros defining local items.\n \n use std::io;\n-//~^ ERROR `std` import is ambiguous\n+//~^ ERROR `std` is ambiguous\n \n macro_rules! m {\n     () => {"}, {"sha": "ac8d3b9d0cbe4d0dc347f35a2c901d89e375f29b", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros.stderr", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,16 +1,23 @@\n-error: `std` import is ambiguous\n-  --> $DIR/ambiguity-macros.rs:17:5\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n+  --> $DIR/ambiguity-macros.rs:15:5\n+   |\n+LL | use std::io;\n+   |     ^^^ ambiguous name\n+   |\n+   = note: `std` could refer to a built-in extern crate\n+   = help: use `::std` to refer to this extern crate unambiguously\n+note: `std` could also refer to the module defined here\n+  --> $DIR/ambiguity-macros.rs:20:9\n    |\n-LL |   use std::io;\n-   |       ^^^ can refer to external crate `::std`\n-...\n LL | /         mod std {\n LL | |             pub struct io;\n LL | |         }\n-   | |_________- can refer to `self::std`\n-   |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+   | |_________^\n+...\n+LL |   m!();\n+   |   ----- in this macro invocation\n+   = help: use `self::std` to refer to this module unambiguously\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "2791d4580daf1a476deeff60b98c9cbbe4ab5faf", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-nested.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -10,13 +10,11 @@\n \n // edition:2018\n \n-#![feature(uniform_paths)]\n-\n // This test is similar to `ambiguity.rs`, but nested in a module.\n \n mod foo {\n     pub use std::io;\n-    //~^ ERROR `std` import is ambiguous\n+    //~^ ERROR `std` is ambiguous\n \n     mod std {\n         pub struct io;"}, {"sha": "7bcfc563d39fc288da54189a482753efc48e984f", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-nested.stderr", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,16 +1,20 @@\n-error: `std` import is ambiguous\n-  --> $DIR/ambiguity-nested.rs:18:13\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n+  --> $DIR/ambiguity-nested.rs:16:13\n+   |\n+LL |     pub use std::io;\n+   |             ^^^ ambiguous name\n+   |\n+   = note: `std` could refer to a built-in extern crate\n+   = help: use `::std` to refer to this extern crate unambiguously\n+note: `std` could also refer to the module defined here\n+  --> $DIR/ambiguity-nested.rs:19:5\n    |\n-LL |       pub use std::io;\n-   |               ^^^ can refer to external crate `::std`\n-...\n LL | /     mod std {\n LL | |         pub struct io;\n LL | |     }\n-   | |_____- can refer to `self::std`\n-   |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+   | |_____^\n+   = help: use `self::std` to refer to this module unambiguously\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "2bfbb6b287153ded300d89545cab2ff528019c5e", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -10,10 +10,8 @@\n \n // edition:2018\n \n-#![feature(uniform_paths)]\n-\n use std::io;\n-//~^ ERROR `std` import is ambiguous\n+//~^ ERROR `std` is ambiguous\n \n mod std {\n     pub struct io;"}, {"sha": "beeb74654e5b5bc7194dc9c2fba8a68703f7834c", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity.stderr", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,16 +1,20 @@\n-error: `std` import is ambiguous\n-  --> $DIR/ambiguity.rs:15:5\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n+  --> $DIR/ambiguity.rs:13:5\n+   |\n+LL | use std::io;\n+   |     ^^^ ambiguous name\n+   |\n+   = note: `std` could refer to a built-in extern crate\n+   = help: use `::std` to refer to this extern crate unambiguously\n+note: `std` could also refer to the module defined here\n+  --> $DIR/ambiguity.rs:16:1\n    |\n-LL |   use std::io;\n-   |       ^^^ can refer to external crate `::std`\n-...\n LL | / mod std {\n LL | |     pub struct io;\n LL | | }\n-   | |_- can refer to `self::std`\n-   |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+   | |_^\n+   = help: use `self::std` to refer to this module unambiguously\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "19be7dc9640409383dbfa8f560a0e16484485944", "filename": "src/test/ui/rust-2018/uniform-paths/block-scoped-shadow-nested.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow-nested.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,22 @@\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+mod my {\n+    pub mod sub {\n+        pub fn bar() {}\n+    }\n+}\n+\n+mod sub {\n+    pub fn bar() {}\n+}\n+\n+fn foo() {\n+    use my::sub;\n+    {\n+        use sub::bar; //~ ERROR `sub` is ambiguous\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "aa46947f93f4be0c9f89c9da00a6970a3dce6e0c", "filename": "src/test/ui/rust-2018/uniform-paths/block-scoped-shadow-nested.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow-nested.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,23 @@\n+error[E0659]: `sub` is ambiguous (name vs any other name during import resolution)\n+  --> $DIR/block-scoped-shadow-nested.rs:18:13\n+   |\n+LL |         use sub::bar; //~ ERROR `sub` is ambiguous\n+   |             ^^^ ambiguous name\n+   |\n+note: `sub` could refer to the module imported here\n+  --> $DIR/block-scoped-shadow-nested.rs:16:9\n+   |\n+LL |     use my::sub;\n+   |         ^^^^^^^\n+note: `sub` could also refer to the module defined here\n+  --> $DIR/block-scoped-shadow-nested.rs:11:1\n+   |\n+LL | / mod sub {\n+LL | |     pub fn bar() {}\n+LL | | }\n+   | |_^\n+   = help: use `self::sub` to refer to this module unambiguously\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "ec0479ce8f15eaaeb7718a805f7c5b5a61d886d8", "filename": "src/test/ui/rust-2018/uniform-paths/block-scoped-shadow.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -10,22 +10,20 @@\n \n // edition:2018\n \n-#![feature(uniform_paths)]\n-\n-enum Foo { A, B }\n+enum Foo {}\n \n struct std;\n \n fn main() {\n-    enum Foo {}\n+    enum Foo { A, B }\n     use Foo::*;\n-    //~^ ERROR `Foo` import is ambiguous\n+    //~^ ERROR `Foo` is ambiguous\n \n     let _ = (A, B);\n \n     fn std() {}\n     enum std {}\n     use std as foo;\n-    //~^ ERROR `std` import is ambiguous\n-    //~| ERROR `std` import is ambiguous\n+    //~^ ERROR `std` is ambiguous\n+    //~| ERROR `std` is ambiguous\n }"}, {"sha": "010b9efad393b43a3a90803fbc7b2e99b04a316a", "filename": "src/test/ui/rust-2018/uniform-paths/block-scoped-shadow.stderr", "status": "modified", "additions": 44, "deletions": 32, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,45 +1,57 @@\n-error: `Foo` import is ambiguous\n-  --> $DIR/block-scoped-shadow.rs:21:9\n-   |\n-LL | enum Foo { A, B }\n-   | ----------------- can refer to `self::Foo`\n-...\n-LL |     enum Foo {}\n-   |     ----------- shadowed by block-scoped `Foo`\n+error[E0659]: `Foo` is ambiguous (name vs any other name during import resolution)\n+  --> $DIR/block-scoped-shadow.rs:19:9\n+   |\n LL |     use Foo::*;\n-   |         ^^^\n+   |         ^^^ ambiguous name\n+   |\n+note: `Foo` could refer to the enum defined here\n+  --> $DIR/block-scoped-shadow.rs:18:5\n    |\n-   = help: write `self::Foo` explicitly instead\n-   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+LL |     enum Foo { A, B }\n+   |     ^^^^^^^^^^^^^^^^^\n+note: `Foo` could also refer to the enum defined here\n+  --> $DIR/block-scoped-shadow.rs:13:1\n+   |\n+LL | enum Foo {}\n+   | ^^^^^^^^^^^\n+   = help: use `self::Foo` to refer to this enum unambiguously\n \n-error: `std` import is ambiguous\n-  --> $DIR/block-scoped-shadow.rs:28:9\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n+  --> $DIR/block-scoped-shadow.rs:26:9\n    |\n-LL | struct std;\n-   | ----------- can refer to `self::std`\n-...\n-LL |     enum std {}\n-   |     ----------- shadowed by block-scoped `std`\n LL |     use std as foo;\n-   |         ^^^ can refer to external crate `::std`\n+   |         ^^^ ambiguous name\n    |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n-\n-error: `std` import is ambiguous\n-  --> $DIR/block-scoped-shadow.rs:28:9\n+note: `std` could refer to the enum defined here\n+  --> $DIR/block-scoped-shadow.rs:25:5\n    |\n-LL | struct std;\n-   | ----------- can refer to `self::std`\n-...\n-LL |     fn std() {}\n-   |     ----------- shadowed by block-scoped `std`\n LL |     enum std {}\n+   |     ^^^^^^^^^^^\n+note: `std` could also refer to the struct defined here\n+  --> $DIR/block-scoped-shadow.rs:15:1\n+   |\n+LL | struct std;\n+   | ^^^^^^^^^^^\n+   = help: use `self::std` to refer to this struct unambiguously\n+\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n+  --> $DIR/block-scoped-shadow.rs:26:9\n+   |\n LL |     use std as foo;\n-   |         ^^^\n+   |         ^^^ ambiguous name\n    |\n-   = help: write `self::std` explicitly instead\n-   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+note: `std` could refer to the function defined here\n+  --> $DIR/block-scoped-shadow.rs:24:5\n+   |\n+LL |     fn std() {}\n+   |     ^^^^^^^^^^^\n+note: `std` could also refer to the unit struct defined here\n+  --> $DIR/block-scoped-shadow.rs:15:1\n+   |\n+LL | struct std;\n+   | ^^^^^^^^^^^\n+   = help: use `self::std` to refer to this unit struct unambiguously\n \n error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "3228d799083fb228c255d26b1325cebe3498612d", "filename": "src/test/ui/rust-2018/uniform-paths/deadlock.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fdeadlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fdeadlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fdeadlock.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,7 @@\n+// edition:2018\n+// compile-flags:--extern foo --extern bar\n+\n+use foo::bar; //~ ERROR unresolved import\n+use bar::foo;\n+\n+fn main() {}"}, {"sha": "8bbc8f33039b946c9a76f0e24f2a38614422a06d", "filename": "src/test/ui/rust-2018/uniform-paths/deadlock.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fdeadlock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fdeadlock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fdeadlock.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,9 @@\n+error[E0432]: unresolved import\n+  --> $DIR/deadlock.rs:4:5\n+   |\n+LL | use foo::bar; //~ ERROR unresolved import\n+   |     ^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0432`."}, {"sha": "a7bc625bbf0a4480cb4482a9382bc3b61b5ffc94", "filename": "src/test/ui/rust-2018/uniform-paths/fn-local-enum.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Ffn-local-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Ffn-local-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Ffn-local-enum.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,15 @@\n+// compile-pass\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+fn main() {\n+    enum E { A, B, C }\n+\n+    use E::*;\n+    match A {\n+        A => {}\n+        B => {}\n+        C => {}\n+    }\n+}"}, {"sha": "5c3c753f9a7857eb5399e42a8dc5a9010bc0e167", "filename": "src/test/ui/rust-2018/uniform-paths/from-decl-macro.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Ffrom-decl-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Ffrom-decl-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Ffrom-decl-macro.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,12 @@\n+// compile-pass\n+// edition:2018\n+\n+#![feature(decl_macro)]\n+\n+macro check() {\n+    ::std::vec::Vec::<u8>::new()\n+}\n+\n+fn main() {\n+    check!();\n+}"}, {"sha": "ef2a1e3c70c6f873153f220db5a07d7575df1493", "filename": "src/test/ui/rust-2018/uniform-paths/issue-54253.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fissue-54253.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fissue-54253.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fissue-54253.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -10,9 +10,7 @@\n \n // edition:2018\n \n-#![feature(uniform_paths)]\n-\n-// Dummy import to introduce `uniform_paths` canaries.\n+// Dummy import that previously introduced uniform path canaries.\n use std;\n \n // fn version() -> &'static str {\"\"}"}, {"sha": "6dcc451c60a6125c45150ba350febf7ca78fd3d2", "filename": "src/test/ui/rust-2018/uniform-paths/issue-54253.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fissue-54253.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fissue-54253.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fissue-54253.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,5 +1,5 @@\n error[E0432]: unresolved import `crate::version`\n-  --> $DIR/issue-54253.rs:22:9\n+  --> $DIR/issue-54253.rs:20:9\n    |\n LL |     use crate::version; //~ ERROR unresolved import `crate::version`\n    |         ^^^^^^^^^^^^^^ no `version` in the root"}, {"sha": "536cc25e35ac1b4b4516a482e93d3c3b90015b0b", "filename": "src/test/ui/rust-2018/uniform-paths/issue-54390.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fissue-54390.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fissue-54390.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fissue-54390.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,11 @@\n+// edition:2018\n+\n+#![deny(unused)]\n+\n+use std::fmt;\n+\n+// No \"unresolved import\" + \"unused import\" combination here.\n+use fmt::Write; //~ ERROR imports can only refer to extern crate names\n+                //~| ERROR unused import: `fmt::Write`\n+\n+fn main() {}"}, {"sha": "8f86698c9c11a16e57ca83bab3a7f1a542736ed3", "filename": "src/test/ui/rust-2018/uniform-paths/issue-54390.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fissue-54390.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fissue-54390.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fissue-54390.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,32 @@\n+error[E0658]: imports can only refer to extern crate names passed with `--extern` on stable channel (see issue #53130)\n+  --> $DIR/issue-54390.rs:8:5\n+   |\n+LL | use std::fmt;\n+   |     -------- not an extern crate passed with `--extern`\n+...\n+LL | use fmt::Write; //~ ERROR imports can only refer to extern crate names\n+   |     ^^^\n+   |\n+   = help: add #![feature(uniform_paths)] to the crate attributes to enable\n+note: this import refers to the module imported here\n+  --> $DIR/issue-54390.rs:5:5\n+   |\n+LL | use std::fmt;\n+   |     ^^^^^^^^\n+\n+error: unused import: `fmt::Write`\n+  --> $DIR/issue-54390.rs:8:5\n+   |\n+LL | use fmt::Write; //~ ERROR imports can only refer to extern crate names\n+   |     ^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-54390.rs:3:9\n+   |\n+LL | #![deny(unused)]\n+   |         ^^^^^^\n+   = note: #[deny(unused_imports)] implied by #[deny(unused)]\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "e8098a467904e31ccef5d4bb5b9c7f314fc69a0a", "filename": "src/test/ui/rust-2018/uniform-paths/macro-rules.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fmacro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fmacro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fmacro-rules.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,44 @@\n+// edition:2018\n+\n+// For the time being `macro_rules` items are treated as *very* private...\n+\n+#![feature(underscore_imports, decl_macro, uniform_paths)]\n+\n+mod m1 {\n+    macro_rules! legacy_macro { () => () }\n+\n+    // ... so they can't be imported by themselves, ...\n+    use legacy_macro as _; //~ ERROR `legacy_macro` is private, and cannot be re-exported\n+}\n+\n+mod m2 {\n+    macro_rules! legacy_macro { () => () }\n+\n+    type legacy_macro = u8;\n+\n+    // ... but don't prevent names from other namespaces from being imported, ...\n+    use legacy_macro as _; // OK\n+}\n+\n+mod m3 {\n+    macro legacy_macro() {}\n+\n+    fn f() {\n+        macro_rules! legacy_macro { () => () }\n+\n+        // ... but still create ambiguities with other names in the same namespace.\n+        use legacy_macro as _; //~ ERROR `legacy_macro` is ambiguous\n+                               //~| ERROR `legacy_macro` is private, and cannot be re-exported\n+    }\n+}\n+\n+mod exported {\n+    // Exported macros are treated as private as well,\n+    // some better rules need to be figured out later.\n+    #[macro_export]\n+    macro_rules! legacy_macro { () => () }\n+\n+    use legacy_macro as _; //~ ERROR `legacy_macro` is private, and cannot be re-exported\n+}\n+\n+fn main() {}"}, {"sha": "d7bb233dfe99e507746e8ac5488ee57229485a3e", "filename": "src/test/ui/rust-2018/uniform-paths/macro-rules.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fmacro-rules.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fmacro-rules.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fmacro-rules.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,58 @@\n+error[E0364]: `legacy_macro` is private, and cannot be re-exported\n+  --> $DIR/macro-rules.rs:11:9\n+   |\n+LL |     use legacy_macro as _; //~ ERROR `legacy_macro` is private, and cannot be re-exported\n+   |         ^^^^^^^^^^^^^^^^^\n+   |\n+note: consider marking `legacy_macro` as `pub` in the imported module\n+  --> $DIR/macro-rules.rs:11:9\n+   |\n+LL |     use legacy_macro as _; //~ ERROR `legacy_macro` is private, and cannot be re-exported\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0364]: `legacy_macro` is private, and cannot be re-exported\n+  --> $DIR/macro-rules.rs:30:13\n+   |\n+LL |         use legacy_macro as _; //~ ERROR `legacy_macro` is ambiguous\n+   |             ^^^^^^^^^^^^^^^^^\n+   |\n+note: consider marking `legacy_macro` as `pub` in the imported module\n+  --> $DIR/macro-rules.rs:30:13\n+   |\n+LL |         use legacy_macro as _; //~ ERROR `legacy_macro` is ambiguous\n+   |             ^^^^^^^^^^^^^^^^^\n+\n+error[E0364]: `legacy_macro` is private, and cannot be re-exported\n+  --> $DIR/macro-rules.rs:41:9\n+   |\n+LL |     use legacy_macro as _; //~ ERROR `legacy_macro` is private, and cannot be re-exported\n+   |         ^^^^^^^^^^^^^^^^^\n+   |\n+note: consider marking `legacy_macro` as `pub` in the imported module\n+  --> $DIR/macro-rules.rs:41:9\n+   |\n+LL |     use legacy_macro as _; //~ ERROR `legacy_macro` is private, and cannot be re-exported\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0659]: `legacy_macro` is ambiguous (name vs any other name during import resolution)\n+  --> $DIR/macro-rules.rs:30:13\n+   |\n+LL |         use legacy_macro as _; //~ ERROR `legacy_macro` is ambiguous\n+   |             ^^^^^^^^^^^^ ambiguous name\n+   |\n+note: `legacy_macro` could refer to the macro defined here\n+  --> $DIR/macro-rules.rs:27:9\n+   |\n+LL |         macro_rules! legacy_macro { () => () }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: `legacy_macro` could also refer to the macro defined here\n+  --> $DIR/macro-rules.rs:24:5\n+   |\n+LL |     macro legacy_macro() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: use `self::legacy_macro` to refer to this macro unambiguously\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors occurred: E0364, E0659.\n+For more information about an error, try `rustc --explain E0364`."}, {"sha": "c5bd50f2f567f2f3675eacc0493532c45a9c8fc3", "filename": "src/test/ui/rust-2018/uniform-paths/prelude-fail.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fprelude-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fprelude-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fprelude-fail.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,13 @@\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+// Built-in macro\n+use env as env_imported; //~ ERROR cannot import a built-in macro\n+\n+// Tool attribute\n+use rustfmt::skip as imported_rustfmt_skip; //~ ERROR unresolved import `rustfmt`\n+\n+fn main() {\n+    env_imported!(\"PATH\");\n+}"}, {"sha": "794d986b82ef181e76baf4c8c78a4731d13664bf", "filename": "src/test/ui/rust-2018/uniform-paths/prelude-fail.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fprelude-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fprelude-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fprelude-fail.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,15 @@\n+error: cannot import a built-in macro\n+  --> $DIR/prelude-fail.rs:6:5\n+   |\n+LL | use env as env_imported; //~ ERROR cannot import a built-in macro\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error[E0432]: unresolved import `rustfmt`\n+  --> $DIR/prelude-fail.rs:9:5\n+   |\n+LL | use rustfmt::skip as imported_rustfmt_skip; //~ ERROR unresolved import `rustfmt`\n+   |     ^^^^^^^ not a module `rustfmt`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0432`."}, {"sha": "5aab5fc3a40187ac246368817eddd95612c20986", "filename": "src/test/ui/rust-2018/uniform-paths/prelude.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fprelude.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -0,0 +1,28 @@\n+// compile-pass\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+// Macro imported with `#[macro_use] extern crate`\n+use vec as imported_vec;\n+\n+// Built-in attribute\n+use inline as imported_inline;\n+\n+// Tool module\n+use rustfmt as imported_rustfmt;\n+\n+// Standard library prelude\n+use Vec as ImportedVec;\n+\n+// Built-in type\n+use u8 as imported_u8;\n+\n+type A = imported_u8;\n+\n+#[imported_inline]\n+#[imported_rustfmt::skip]\n+fn main() {\n+    imported_vec![0];\n+    ImportedVec::<u8>::new();\n+}"}, {"sha": "05048cfd451050e39382c4bf39b22df15476c412", "filename": "src/test/ui/rust-2018/uniform-paths/redundant.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fredundant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fredundant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fredundant.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -11,8 +11,6 @@\n // run-pass\n // edition:2018\n \n-#![feature(uniform_paths)]\n-\n use std;\n use std::io;\n "}, {"sha": "8a40556a6cd0e695f8625754f592837aa3f84a3d", "filename": "src/test/ui/span/macro-ty-params.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -4,6 +4,12 @@ error: unexpected generic arguments in path\n LL |     m!(MyTrait<>); //~ ERROR generic arguments in macro path\n    |        ^^^^^^^^^\n \n+error: generic arguments in macro path\n+  --> $DIR/macro-ty-params.rs:20:15\n+   |\n+LL |     m!(MyTrait<>); //~ ERROR generic arguments in macro path\n+   |               ^^\n+\n error: generic arguments in macro path\n   --> $DIR/macro-ty-params.rs:18:8\n    |\n@@ -16,11 +22,5 @@ error: generic arguments in macro path\n LL |     foo::<>!(); //~ ERROR generic arguments in macro path\n    |        ^^^^\n \n-error: generic arguments in macro path\n-  --> $DIR/macro-ty-params.rs:20:15\n-   |\n-LL |     m!(MyTrait<>); //~ ERROR generic arguments in macro path\n-   |               ^^\n-\n error: aborting due to 4 previous errors\n "}, {"sha": "1f001530f364c4e27427fdfc144081f4461ccf5d", "filename": "src/test/ui/span/non-existing-module-import.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fspan%2Fnon-existing-module-import.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fspan%2Fnon-existing-module-import.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fnon-existing-module-import.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0432]: unresolved import `std::bar`\n   --> $DIR/non-existing-module-import.rs:11:10\n    |\n LL | use std::bar::{foo1, foo2}; //~ ERROR unresolved import\n-   |          ^^^ Could not find `bar` in `std`\n+   |          ^^^ could not find `bar` in `std`\n \n error: aborting due to previous error\n "}, {"sha": "96dc06ee5241abf81c6696185fd7b868c09519ce", "filename": "src/test/ui/static/static-mut-not-pat.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fstatic%2Fstatic-mut-not-pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fstatic%2Fstatic-mut-not-pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fstatic-mut-not-pat.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0530]: match bindings cannot shadow statics\n   --> $DIR/static-mut-not-pat.rs:23:9\n    |\n LL | static mut a: isize = 3;\n-   | ------------------------ a static `a` is defined here\n+   | ------------------------ the static `a` is defined here\n ...\n LL |         a => {} //~ ERROR match bindings cannot shadow statics\n    |         ^ cannot be named the same as a static\n@@ -11,7 +11,7 @@ error[E0530]: match bindings cannot shadow statics\n   --> $DIR/static-mut-not-pat.rs:46:9\n    |\n LL | static mut STATIC_MUT_FOO: Foo = Foo { bar: Some(Direction::West), baz: NEW_FALSE };\n-   | ------------------------------------------------------------------------------------ a static `STATIC_MUT_FOO` is defined here\n+   | ------------------------------------------------------------------------------------ the static `STATIC_MUT_FOO` is defined here\n ...\n LL |         STATIC_MUT_FOO => (),\n    |         ^^^^^^^^^^^^^^ cannot be named the same as a static"}, {"sha": "96d099c765557b79250141d10150fb150e4ec911", "filename": "src/test/ui/super-at-top-level.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fsuper-at-top-level.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fsuper-at-top-level.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuper-at-top-level.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::f; //~ ERROR There are too many initial `super`s\n+use super::f; //~ ERROR there are too many initial `super`s\n \n fn main() {\n }"}, {"sha": "8402daad19e0b54bacb875b48bd23ef8c392ec30", "filename": "src/test/ui/super-at-top-level.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fsuper-at-top-level.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fsuper-at-top-level.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuper-at-top-level.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. There are too many initial `super`s.\n+error[E0433]: failed to resolve: there are too many initial `super`s.\n   --> $DIR/super-at-top-level.rs:11:5\n    |\n-LL | use super::f; //~ ERROR There are too many initial `super`s\n-   |     ^^^^^ There are too many initial `super`s.\n+LL | use super::f; //~ ERROR there are too many initial `super`s\n+   |     ^^^^^ there are too many initial `super`s.\n \n error: aborting due to previous error\n "}, {"sha": "11e28857afe036132532b28d7b80f04ef93d5fb1", "filename": "src/test/ui/tool-attributes/tool-attributes-shadowing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-shadowing.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -10,5 +10,5 @@\n \n mod rustfmt {}\n \n-#[rustfmt::skip] //~ ERROR failed to resolve. Could not find `skip` in `rustfmt`\n+#[rustfmt::skip] //~ ERROR failed to resolve: could not find `skip` in `rustfmt`\n fn main() {}"}, {"sha": "0839e363c36f96834b935ee2dc5dfc7d621a7f61", "filename": "src/test/ui/tool-attributes/tool-attributes-shadowing.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-shadowing.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. Could not find `skip` in `rustfmt`\n+error[E0433]: failed to resolve: could not find `skip` in `rustfmt`\n   --> $DIR/tool-attributes-shadowing.rs:13:12\n    |\n-LL | #[rustfmt::skip] //~ ERROR failed to resolve. Could not find `skip` in `rustfmt`\n-   |            ^^^^ Could not find `skip` in `rustfmt`\n+LL | #[rustfmt::skip] //~ ERROR failed to resolve: could not find `skip` in `rustfmt`\n+   |            ^^^^ could not find `skip` in `rustfmt`\n \n error: aborting due to previous error\n "}, {"sha": "df7d442239b397521162a1ff75c3af7e4fa5d8af", "filename": "src/test/ui/type/type-path-err-node-types.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ftype%2Ftype-path-err-node-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Ftype%2Ftype-path-err-node-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-path-err-node-types.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. Use of undeclared type or module `NonExistent`\n+error[E0433]: failed to resolve: use of undeclared type or module `NonExistent`\n   --> $DIR/type-path-err-node-types.rs:25:5\n    |\n LL |     NonExistent::Assoc::<u8>; //~ ERROR undeclared type or module `NonExistent`\n-   |     ^^^^^^^^^^^ Use of undeclared type or module `NonExistent`\n+   |     ^^^^^^^^^^^ use of undeclared type or module `NonExistent`\n \n error[E0412]: cannot find type `Nonexistent` in this scope\n   --> $DIR/type-path-err-node-types.rs:17:12"}, {"sha": "db10197ded1a7ee872449951f60dc45c62ae6024", "filename": "src/test/ui/ufcs/ufcs-partially-resolved.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fufcs%2Fufcs-partially-resolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fufcs%2Fufcs-partially-resolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fufcs%2Fufcs-partially-resolved.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -55,9 +55,9 @@ fn main() {\n     <u8 as E::N>::NN; //~ ERROR cannot find method or associated constant `NN` in `E::N`\n     <u8 as A::N>::NN; //~ ERROR cannot find method or associated constant `NN` in `A::N`\n     let _: <u8 as Tr::Y>::NN; //~ ERROR cannot find associated type `NN` in `Tr::Y`\n-    let _: <u8 as E::Y>::NN; //~ ERROR failed to resolve. Not a module `Y`\n+    let _: <u8 as E::Y>::NN; //~ ERROR failed to resolve: not a module `Y`\n     <u8 as Tr::Y>::NN; //~ ERROR cannot find method or associated constant `NN` in `Tr::Y`\n-    <u8 as E::Y>::NN; //~ ERROR failed to resolve. Not a module `Y`\n+    <u8 as E::Y>::NN; //~ ERROR failed to resolve: not a module `Y`\n \n     let _: <u8 as Dr>::Z; //~ ERROR expected associated type, found method `Dr::Z`\n     <u8 as Dr>::X; //~ ERROR expected method or associated constant, found associated type `Dr::X`"}, {"sha": "cb571be661d6ae0aa5e7d6c2e0bd7b619d4ac3fe", "filename": "src/test/ui/ufcs/ufcs-partially-resolved.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,14 +1,14 @@\n-error[E0433]: failed to resolve. Not a module `Y`\n+error[E0433]: failed to resolve: not a module `Y`\n   --> $DIR/ufcs-partially-resolved.rs:58:22\n    |\n-LL |     let _: <u8 as E::Y>::NN; //~ ERROR failed to resolve. Not a module `Y`\n-   |                      ^ Not a module `Y`\n+LL |     let _: <u8 as E::Y>::NN; //~ ERROR failed to resolve: not a module `Y`\n+   |                      ^ not a module `Y`\n \n-error[E0433]: failed to resolve. Not a module `Y`\n+error[E0433]: failed to resolve: not a module `Y`\n   --> $DIR/ufcs-partially-resolved.rs:60:15\n    |\n-LL |     <u8 as E::Y>::NN; //~ ERROR failed to resolve. Not a module `Y`\n-   |               ^ Not a module `Y`\n+LL |     <u8 as E::Y>::NN; //~ ERROR failed to resolve: not a module `Y`\n+   |               ^ not a module `Y`\n \n error[E0576]: cannot find associated type `N` in trait `Tr`\n   --> $DIR/ufcs-partially-resolved.rs:29:24"}, {"sha": "8d7a62255299cd295d45822368b99ada61f85d91", "filename": "src/test/ui/unknown-tool-name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Funknown-tool-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Funknown-tool-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funknown-tool-name.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[foo::bar] //~ ERROR failed to resolve. Use of undeclared type or module `foo`\n+#[foo::bar] //~ ERROR failed to resolve: use of undeclared type or module `foo`\n fn main() {}"}, {"sha": "55096614fcd3246d4465815691c84453d7acfb93", "filename": "src/test/ui/unknown-tool-name.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Funknown-tool-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Funknown-tool-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funknown-tool-name.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve. Use of undeclared type or module `foo`\n+error[E0433]: failed to resolve: use of undeclared type or module `foo`\n   --> $DIR/unknown-tool-name.rs:11:3\n    |\n-LL | #[foo::bar] //~ ERROR failed to resolve. Use of undeclared type or module `foo`\n-   |   ^^^ Use of undeclared type or module `foo`\n+LL | #[foo::bar] //~ ERROR failed to resolve: use of undeclared type or module `foo`\n+   |   ^^^ use of undeclared type or module `foo`\n \n error: aborting due to previous error\n "}, {"sha": "4592289beeb8778ad83b80c5459dc8520eb9e086", "filename": "src/test/ui/unresolved/unresolved-import.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Funresolved%2Funresolved-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Funresolved%2Funresolved-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funresolved%2Funresolved-import.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -11,7 +11,7 @@\n // ignore-tidy-linelength\n \n use foo::bar; //~ ERROR unresolved import `foo` [E0432]\n-              //~^ Maybe a missing `extern crate foo;`?\n+              //~^ maybe a missing `extern crate foo;`?\n \n use bar::Baz as x; //~ ERROR unresolved import `bar::Baz` [E0432]\n                    //~^ no `Baz` in `bar`. Did you mean to use `Bar`?\n@@ -42,7 +42,7 @@ mod m {\n     }\n \n     use MyEnum::*; //~ ERROR unresolved import `MyEnum` [E0432]\n-                   //~^ Did you mean `self::MyEnum`?\n+                   //~^ did you mean `self::MyEnum`?\n }\n \n mod items {\n@@ -51,7 +51,7 @@ mod items {\n     }\n \n     use Enum::*; //~ ERROR unresolved import `Enum` [E0432]\n-                 //~^ Did you mean `self::Enum`?\n+                 //~^ did you mean `self::Enum`?\n \n     fn item() {}\n }"}, {"sha": "7e98a41af10bd874448697507f9453f36708dbb8", "filename": "src/test/ui/unresolved/unresolved-import.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Funresolved%2Funresolved-import.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Funresolved%2Funresolved-import.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funresolved%2Funresolved-import.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -2,7 +2,7 @@ error[E0432]: unresolved import `foo`\n   --> $DIR/unresolved-import.rs:13:5\n    |\n LL | use foo::bar; //~ ERROR unresolved import `foo` [E0432]\n-   |     ^^^ Maybe a missing `extern crate foo;`?\n+   |     ^^^ maybe a missing `extern crate foo;`?\n \n error[E0432]: unresolved import `bar::Baz`\n   --> $DIR/unresolved-import.rs:16:5\n@@ -26,13 +26,13 @@ error[E0432]: unresolved import `MyEnum`\n   --> $DIR/unresolved-import.rs:44:9\n    |\n LL |     use MyEnum::*; //~ ERROR unresolved import `MyEnum` [E0432]\n-   |         ^^^^^^ Did you mean `self::MyEnum`?\n+   |         ^^^^^^ did you mean `self::MyEnum`?\n \n error[E0432]: unresolved import `Enum`\n   --> $DIR/unresolved-import.rs:53:9\n    |\n LL |     use Enum::*; //~ ERROR unresolved import `Enum` [E0432]\n-   |         ^^^^ Did you mean `self::Enum`?\n+   |         ^^^^ did you mean `self::Enum`?\n \n error: aborting due to 6 previous errors\n "}, {"sha": "6c643dff79602ba0987a1724d616f521c1c0d2a0", "filename": "src/test/ui/use/use-from-trait-xc.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fuse%2Fuse-from-trait-xc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fuse%2Fuse-from-trait-xc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-from-trait-xc.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -20,19 +20,19 @@ error[E0432]: unresolved import `use_from_trait_xc::Foo`\n   --> $DIR/use-from-trait-xc.rs:24:24\n    |\n LL | use use_from_trait_xc::Foo::new; //~ ERROR struct `Foo` is private\n-   |                        ^^^ Not a module `Foo`\n+   |                        ^^^ not a module `Foo`\n \n error[E0432]: unresolved import `use_from_trait_xc::Foo`\n   --> $DIR/use-from-trait-xc.rs:27:24\n    |\n LL | use use_from_trait_xc::Foo::C; //~ ERROR struct `Foo` is private\n-   |                        ^^^ Not a module `Foo`\n+   |                        ^^^ not a module `Foo`\n \n error[E0432]: unresolved import `use_from_trait_xc::Bar`\n   --> $DIR/use-from-trait-xc.rs:30:24\n    |\n LL | use use_from_trait_xc::Bar::new as bnew;\n-   |                        ^^^ Not a module `Bar`\n+   |                        ^^^ not a module `Bar`\n \n error[E0432]: unresolved import `use_from_trait_xc::Baz::new`\n   --> $DIR/use-from-trait-xc.rs:33:5"}, {"sha": "afa7632058257b2f0bf16aa9776595fc62a0162f", "filename": "src/test/ui/use/use-from-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fuse%2Fuse-from-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fuse%2Fuse-from-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-from-trait.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -18,11 +18,11 @@ use Trait::C;\n \n use Foo::new;\n //~^ ERROR unresolved import `Foo` [E0432]\n-//~| Not a module `Foo`\n+//~| not a module `Foo`\n \n use Foo::C2;\n //~^ ERROR unresolved import `Foo` [E0432]\n-//~| Not a module `Foo`\n+//~| not a module `Foo`\n \n pub trait Trait {\n     fn foo();"}, {"sha": "cb0fd94fa6e395144de3dd17ee6409699126b2e5", "filename": "src/test/ui/use/use-from-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fuse%2Fuse-from-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fuse%2Fuse-from-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-from-trait.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -20,13 +20,13 @@ error[E0432]: unresolved import `Foo`\n   --> $DIR/use-from-trait.rs:19:5\n    |\n LL | use Foo::new;\n-   |     ^^^ Not a module `Foo`\n+   |     ^^^ not a module `Foo`\n \n error[E0432]: unresolved import `Foo`\n   --> $DIR/use-from-trait.rs:23:5\n    |\n LL | use Foo::C2;\n-   |     ^^^ Not a module `Foo`\n+   |     ^^^ not a module `Foo`\n \n error: aborting due to 5 previous errors\n "}, {"sha": "33366b2457b54809defdaf6da4e2bcc6884cd208", "filename": "src/test/ui/use/use-mod/use-mod-4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fuse%2Fuse-mod%2Fuse-mod-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fuse%2Fuse-mod%2Fuse-mod-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-mod%2Fuse-mod-4.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -14,7 +14,7 @@ error[E0432]: unresolved import `foo`\n   --> $DIR/use-mod-4.rs:11:5\n    |\n LL | use foo::self; //~ ERROR unresolved import `foo`\n-   |     ^^^ Maybe a missing `extern crate foo;`?\n+   |     ^^^ maybe a missing `extern crate foo;`?\n \n error: aborting due to 3 previous errors\n "}, {"sha": "1b49d358261df3e39ff37c71318e599d6c1f67bb", "filename": "src/test/ui/use/use-self-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fuse%2Fuse-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fuse%2Fuse-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-self-type.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -14,7 +14,7 @@ impl S {\n     fn f() {}\n     fn g() {\n         use Self::f; //~ ERROR unresolved import\n-        pub(in Self::f) struct Z; //~ ERROR Use of undeclared type or module `Self`\n+        pub(in Self::f) struct Z; //~ ERROR use of undeclared type or module `Self`\n     }\n }\n "}, {"sha": "e4cb0f9f3d8351e935f594b5732fd0c70f029824", "filename": "src/test/ui/use/use-self-type.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fuse%2Fuse-self-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fuse%2Fuse-self-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-self-type.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,14 +1,14 @@\n-error[E0433]: failed to resolve. Use of undeclared type or module `Self`\n+error[E0433]: failed to resolve: use of undeclared type or module `Self`\n   --> $DIR/use-self-type.rs:17:16\n    |\n-LL |         pub(in Self::f) struct Z; //~ ERROR Use of undeclared type or module `Self`\n-   |                ^^^^ Use of undeclared type or module `Self`\n+LL |         pub(in Self::f) struct Z; //~ ERROR use of undeclared type or module `Self`\n+   |                ^^^^ use of undeclared type or module `Self`\n \n error[E0432]: unresolved import `Self`\n   --> $DIR/use-self-type.rs:16:13\n    |\n LL |         use Self::f; //~ ERROR unresolved import\n-   |             ^^^^ Use of undeclared type or module `Self`\n+   |             ^^^^ use of undeclared type or module `Self`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "fc4455c7d6e4eb44b0fec59e12baa66e90ca3814", "filename": "src/test/ui/use/use-super-global-path.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fuse%2Fuse-super-global-path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fuse%2Fuse-super-global-path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-super-global-path.stderr?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,10 +1,10 @@\n-error[E0433]: failed to resolve. global paths cannot start with `super`\n+error[E0433]: failed to resolve: global paths cannot start with `super`\n   --> $DIR/use-super-global-path.rs:17:11\n    |\n LL |     use ::super::{S, Z}; //~ ERROR global paths cannot start with `super`\n    |           ^^^^^ global paths cannot start with `super`\n \n-error[E0433]: failed to resolve. global paths cannot start with `super`\n+error[E0433]: failed to resolve: global paths cannot start with `super`\n   --> $DIR/use-super-global-path.rs:20:15\n    |\n LL |         use ::super::main; //~ ERROR global paths cannot start with `super`"}]}