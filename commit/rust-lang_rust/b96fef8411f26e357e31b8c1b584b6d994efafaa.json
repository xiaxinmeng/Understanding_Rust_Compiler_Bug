{"sha": "b96fef8411f26e357e31b8c1b584b6d994efafaa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NmZlZjg0MTFmMjZlMzU3ZTMxYjhjMWI1ODRiNmQ5OTRlZmFmYWE=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-03-10T13:06:24Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-03-28T17:38:55Z"}, "message": "End of pulldown switch and remove completely hoedown", "tree": {"sha": "f5a0436ec7a09ed1198c19a5047224d536f292a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5a0436ec7a09ed1198c19a5047224d536f292a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b96fef8411f26e357e31b8c1b584b6d994efafaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b96fef8411f26e357e31b8c1b584b6d994efafaa", "html_url": "https://github.com/rust-lang/rust/commit/b96fef8411f26e357e31b8c1b584b6d994efafaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b96fef8411f26e357e31b8c1b584b6d994efafaa/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9415eb98ff2a5cf679954e5eaf66274a24db1ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9415eb98ff2a5cf679954e5eaf66274a24db1ee", "html_url": "https://github.com/rust-lang/rust/commit/c9415eb98ff2a5cf679954e5eaf66274a24db1ee"}], "stats": {"total": 706, "additions": 216, "deletions": 490}, "files": [{"sha": "53d17874924093c298f0f111f1c4c4d680c68f55", "filename": ".gitmodules", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b96fef8411f26e357e31b8c1b584b6d994efafaa/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/b96fef8411f26e357e31b8c1b584b6d994efafaa/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=b96fef8411f26e357e31b8c1b584b6d994efafaa", "patch": "@@ -5,10 +5,6 @@\n [submodule \"src/compiler-rt\"]\n \tpath = src/compiler-rt\n \turl = https://github.com/rust-lang/compiler-rt.git\n-[submodule \"src/rt/hoedown\"]\n-\tpath = src/rt/hoedown\n-\turl = https://github.com/rust-lang/hoedown.git\n-\tbranch = rust-2015-09-21-do-not-delete\n [submodule \"src/jemalloc\"]\n \tpath = src/jemalloc\n \turl = https://github.com/rust-lang/jemalloc.git"}, {"sha": "ff18daa7aa0986bebd822f9b766cf65a0a217008", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b96fef8411f26e357e31b8c1b584b6d994efafaa/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b96fef8411f26e357e31b8c1b584b6d994efafaa/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=b96fef8411f26e357e31b8c1b584b6d994efafaa", "patch": "@@ -2,7 +2,6 @@\n authors = [\"The Rust Project Developers\"]\n name = \"rustdoc\"\n version = \"0.0.0\"\n-build = \"build.rs\"\n \n [lib]\n name = \"rustdoc\""}, {"sha": "9fa6406c1d8b69d14175484997cf569f76eec5f1", "filename": "src/librustdoc/build.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c9415eb98ff2a5cf679954e5eaf66274a24db1ee/src%2Flibrustdoc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9415eb98ff2a5cf679954e5eaf66274a24db1ee/src%2Flibrustdoc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fbuild.rs?ref=c9415eb98ff2a5cf679954e5eaf66274a24db1ee", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern crate build_helper;\n-extern crate gcc;\n-\n-fn main() {\n-    let src_dir = std::path::Path::new(\"../rt/hoedown/src\");\n-    build_helper::rerun_if_changed_anything_in_dir(src_dir);\n-    let mut cfg = gcc::Config::new();\n-    cfg.file(\"../rt/hoedown/src/autolink.c\")\n-       .file(\"../rt/hoedown/src/buffer.c\")\n-       .file(\"../rt/hoedown/src/document.c\")\n-       .file(\"../rt/hoedown/src/escape.c\")\n-       .file(\"../rt/hoedown/src/html.c\")\n-       .file(\"../rt/hoedown/src/html_blocks.c\")\n-       .file(\"../rt/hoedown/src/html_smartypants.c\")\n-       .file(\"../rt/hoedown/src/stack.c\")\n-       .file(\"../rt/hoedown/src/version.c\")\n-       .include(src_dir)\n-       .compile(\"libhoedown.a\");\n-}"}, {"sha": "9ae6c443f9e06a713a35e377b3c9f6082b32ce68", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 211, "deletions": 450, "changes": 661, "blob_url": "https://github.com/rust-lang/rust/blob/b96fef8411f26e357e31b8c1b584b6d994efafaa/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96fef8411f26e357e31b8c1b584b6d994efafaa/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=b96fef8411f26e357e31b8c1b584b6d994efafaa", "patch": "@@ -26,7 +26,7 @@\n \n #![allow(non_camel_case_types)]\n \n-use libc;\n+//use libc;\n use std::ascii::AsciiExt;\n use std::cell::RefCell;\n use std::default::Default;\n@@ -43,158 +43,19 @@ use html::highlight;\n use html::escape::Escape;\n use test;\n \n-use pulldown_cmark::{self, Event, Parser};\n+use pulldown_cmark::{self, Event, Parser, Tag};\n \n /// A unit struct which has the `fmt::Display` trait implemented. When\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n-pub struct Markdown<'a>(pub &'a str);\n+// The second parameter is whether we need a shorter version or not.\n+pub struct Markdown<'a>(pub &'a str, pub bool);\n /// A unit struct like `Markdown`, that renders the markdown with a\n /// table of contents.\n pub struct MarkdownWithToc<'a>(pub &'a str);\n /// A unit struct like `Markdown`, that renders the markdown escaping HTML tags.\n pub struct MarkdownHtml<'a>(pub &'a str);\n \n-/*const DEF_OUNIT: libc::size_t = 64;\n-const HOEDOWN_EXT_NO_INTRA_EMPHASIS: libc::c_uint = 1 << 11;\n-const HOEDOWN_EXT_TABLES: libc::c_uint = 1 << 0;\n-const HOEDOWN_EXT_FENCED_CODE: libc::c_uint = 1 << 1;\n-const HOEDOWN_EXT_AUTOLINK: libc::c_uint = 1 << 3;\n-const HOEDOWN_EXT_STRIKETHROUGH: libc::c_uint = 1 << 4;\n-const HOEDOWN_EXT_SUPERSCRIPT: libc::c_uint = 1 << 8;\n-const HOEDOWN_EXT_FOOTNOTES: libc::c_uint = 1 << 2;\n-const HOEDOWN_HTML_ESCAPE: libc::c_uint = 1 << 1;\n-\n-const HOEDOWN_EXTENSIONS: libc::c_uint =\n-    HOEDOWN_EXT_NO_INTRA_EMPHASIS | HOEDOWN_EXT_TABLES |\n-    HOEDOWN_EXT_FENCED_CODE | HOEDOWN_EXT_AUTOLINK |\n-    HOEDOWN_EXT_STRIKETHROUGH | HOEDOWN_EXT_SUPERSCRIPT |\n-    HOEDOWN_EXT_FOOTNOTES;\n-\n-enum hoedown_document {}\n-\n-type blockcodefn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                                 *const hoedown_buffer, *const hoedown_renderer_data,\n-                                 libc::size_t);\n-\n-type blockquotefn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                                  *const hoedown_renderer_data, libc::size_t);\n-\n-type headerfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                              libc::c_int, *const hoedown_renderer_data,\n-                              libc::size_t);\n-\n-type blockhtmlfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                                 *const hoedown_renderer_data, libc::size_t);\n-\n-type codespanfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                                *const hoedown_renderer_data, libc::size_t) -> libc::c_int;\n-\n-type linkfn = extern \"C\" fn (*mut hoedown_buffer, *const hoedown_buffer,\n-                             *const hoedown_buffer, *const hoedown_buffer,\n-                             *const hoedown_renderer_data, libc::size_t) -> libc::c_int;\n-\n-type entityfn = extern \"C\" fn (*mut hoedown_buffer, *const hoedown_buffer,\n-                               *const hoedown_renderer_data, libc::size_t);\n-\n-type normaltextfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                                  *const hoedown_renderer_data, libc::size_t);\n-\n-#[repr(C)]\n-struct hoedown_renderer_data {\n-    opaque: *mut libc::c_void,\n-}\n-\n-#[repr(C)]\n-struct hoedown_renderer {\n-    opaque: *mut libc::c_void,\n-\n-    blockcode: Option<blockcodefn>,\n-    blockquote: Option<blockquotefn>,\n-    header: Option<headerfn>,\n-\n-    other_block_level_callbacks: [libc::size_t; 11],\n-\n-    blockhtml: Option<blockhtmlfn>,\n-\n-    /* span level callbacks - NULL or return 0 prints the span verbatim */\n-    autolink: libc::size_t, // unused\n-    codespan: Option<codespanfn>,\n-    other_span_level_callbacks_1: [libc::size_t; 7],\n-    link: Option<linkfn>,\n-    other_span_level_callbacks_2: [libc::size_t; 6],\n-\n-    /* low level callbacks - NULL copies input directly into the output */\n-    entity: Option<entityfn>,\n-    normal_text: Option<normaltextfn>,\n-\n-    /* header and footer */\n-    other_callbacks: [libc::size_t; 2],\n-}\n-\n-#[repr(C)]\n-struct hoedown_html_renderer_state {\n-    opaque: *mut libc::c_void,\n-    toc_data: html_toc_data,\n-    flags: libc::c_uint,\n-    link_attributes: Option<extern \"C\" fn(*mut hoedown_buffer,\n-                                          *const hoedown_buffer,\n-                                          *const hoedown_renderer_data)>,\n-}\n-\n-#[repr(C)]\n-struct html_toc_data {\n-    header_count: libc::c_int,\n-    current_level: libc::c_int,\n-    level_offset: libc::c_int,\n-    nesting_level: libc::c_int,\n-}\n-\n-struct MyOpaque {\n-    dfltblk: extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                           *const hoedown_buffer, *const hoedown_renderer_data,\n-                           libc::size_t),\n-    toc_builder: Option<TocBuilder>,\n-}\n-\n-#[repr(C)]\n-struct hoedown_buffer {\n-    data: *const u8,\n-    size: libc::size_t,\n-    asize: libc::size_t,\n-    unit: libc::size_t,\n-}\n-\n-extern {\n-    fn hoedown_html_renderer_new(render_flags: libc::c_uint,\n-                                 nesting_level: libc::c_int)\n-        -> *mut hoedown_renderer;\n-    fn hoedown_html_renderer_free(renderer: *mut hoedown_renderer);\n-\n-    fn hoedown_document_new(rndr: *const hoedown_renderer,\n-                            extensions: libc::c_uint,\n-                            max_nesting: libc::size_t) -> *mut hoedown_document;\n-    fn hoedown_document_render(doc: *mut hoedown_document,\n-                               ob: *mut hoedown_buffer,\n-                               document: *const u8,\n-                               doc_size: libc::size_t);\n-    fn hoedown_document_free(md: *mut hoedown_document);\n-\n-    fn hoedown_buffer_new(unit: libc::size_t) -> *mut hoedown_buffer;\n-    /*fn hoedown_buffer_put(b: *mut hoedown_buffer, c: *const libc::c_char,\n-                          n: libc::size_t);*/\n-    fn hoedown_buffer_puts(b: *mut hoedown_buffer, c: *const libc::c_char);\n-    fn hoedown_buffer_free(b: *mut hoedown_buffer);\n-\n-}\n-\n-// hoedown_buffer helpers\n-impl hoedown_buffer {\n-    fn as_bytes(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts(self.data, self.size as usize) }\n-    }\n-}*/\n-\n /// Returns Some(code) if `s` is a line that should be stripped from\n /// documentation but used in example code. `code` is the portion of\n /// `s` that should be used in tests. (None for lines that should be\n@@ -228,213 +89,15 @@ thread_local!(pub static PLAYGROUND: RefCell<Option<(Option<String>, String)>> =\n pub fn render(w: &mut fmt::Formatter,\n               s: &str,\n               print_toc: bool,\n-              _html_flags: libc::c_uint) -> fmt::Result {\n-    /*extern fn block(ob: *mut hoedown_buffer, orig_text: *const hoedown_buffer,\n-                    lang: *const hoedown_buffer, data: *const hoedown_renderer_data,\n-                    line: libc::size_t) {\n-        unsafe {\n-            if orig_text.is_null() { return }\n-\n-            let opaque = (*data).opaque as *mut hoedown_html_renderer_state;\n-            let my_opaque: &MyOpaque = &*((*opaque).opaque as *const MyOpaque);\n-            let text = (*orig_text).as_bytes();\n-            let origtext = str::from_utf8(text).unwrap();\n-            let origtext = origtext.trim_left();\n-            debug!(\"docblock: ==============\\n{:?}\\n=======\", text);\n-            let rendered = if lang.is_null() || origtext.is_empty() {\n-                false\n-            } else {\n-                let rlang = (*lang).as_bytes();\n-                let rlang = str::from_utf8(rlang).unwrap();\n-                if !LangString::parse(rlang).rust {\n-                    (my_opaque.dfltblk)(ob, orig_text, lang,\n-                                        opaque as *const hoedown_renderer_data,\n-                                        line);\n-                    true\n-                } else {\n-                    false\n-                }\n-            };\n-\n-            let lines = origtext.lines().filter(|l| {\n-                stripped_filtered_line(*l).is_none()\n-            });\n-            let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n-            if rendered { return }\n-            PLAYGROUND.with(|play| {\n-                // insert newline to clearly separate it from the\n-                // previous block so we can shorten the html output\n-                let mut s = String::from(\"\\n\");\n-                let playground_button = play.borrow().as_ref().and_then(|&(ref krate, ref url)| {\n-                    if url.is_empty() {\n-                        return None;\n-                    }\n-                    let test = origtext.lines().map(|l| {\n-                        stripped_filtered_line(l).unwrap_or(l)\n-                    }).collect::<Vec<&str>>().join(\"\\n\");\n-                    let krate = krate.as_ref().map(|s| &**s);\n-                    let test = test::maketest(&test, krate, false,\n-                                              &Default::default());\n-                    let channel = if test.contains(\"#![feature(\") {\n-                        \"&amp;version=nightly\"\n-                    } else {\n-                        \"\"\n-                    };\n-                    // These characters don't need to be escaped in a URI.\n-                    // FIXME: use a library function for percent encoding.\n-                    fn dont_escape(c: u8) -> bool {\n-                        (b'a' <= c && c <= b'z') ||\n-                        (b'A' <= c && c <= b'Z') ||\n-                        (b'0' <= c && c <= b'9') ||\n-                        c == b'-' || c == b'_' || c == b'.' ||\n-                        c == b'~' || c == b'!' || c == b'\\'' ||\n-                        c == b'(' || c == b')' || c == b'*'\n-                    }\n-                    let mut test_escaped = String::new();\n-                    for b in test.bytes() {\n-                        if dont_escape(b) {\n-                            test_escaped.push(char::from(b));\n-                        } else {\n-                            write!(test_escaped, \"%{:02X}\", b).unwrap();\n-                        }\n-                    }\n-                    Some(format!(\n-                        r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}\">Run</a>\"#,\n-                        url, test_escaped, channel\n-                    ))\n-                });\n-                s.push_str(&highlight::render_with_highlighting(\n-                               &text,\n-                               Some(\"rust-example-rendered\"),\n-                               None,\n-                               playground_button.as_ref().map(String::as_str)));\n-                let output = CString::new(s).unwrap();\n-                hoedown_buffer_puts(ob, output.as_ptr());\n-            })\n-        }\n-    }\n-\n-    extern fn header(ob: *mut hoedown_buffer, text: *const hoedown_buffer,\n-                     level: libc::c_int, data: *const hoedown_renderer_data,\n-                     _: libc::size_t) {\n-        // hoedown does this, we may as well too\n-        unsafe { hoedown_buffer_puts(ob, \"\\n\\0\".as_ptr() as *const _); }\n-\n-        // Extract the text provided\n-        let s = if text.is_null() {\n-            \"\".to_owned()\n-        } else {\n-            let s = unsafe { (*text).as_bytes() };\n-            str::from_utf8(&s).unwrap().to_owned()\n-        };\n-\n-        // Discard '<em>', '<code>' tags and some escaped characters,\n-        // transform the contents of the header into a hyphenated string\n-        // without non-alphanumeric characters other than '-' and '_'.\n-        //\n-        // This is a terrible hack working around how hoedown gives us rendered\n-        // html for text rather than the raw text.\n-        let mut id = s.clone();\n-        let repl_sub = vec![\"<em>\", \"</em>\", \"<code>\", \"</code>\",\n-                            \"<strong>\", \"</strong>\",\n-                            \"&lt;\", \"&gt;\", \"&amp;\", \"&#39;\", \"&quot;\"];\n-        for sub in repl_sub {\n-            id = id.replace(sub, \"\");\n-        }\n-        let id = id.chars().filter_map(|c| {\n-            if c.is_alphanumeric() || c == '-' || c == '_' {\n-                if c.is_ascii() {\n-                    Some(c.to_ascii_lowercase())\n-                } else {\n-                    Some(c)\n-                }\n-            } else if c.is_whitespace() && c.is_ascii() {\n-                Some('-')\n-            } else {\n-                None\n-            }\n-        }).collect::<String>();\n-\n-        let opaque = unsafe { (*data).opaque as *mut hoedown_html_renderer_state };\n-        let opaque = unsafe { &mut *((*opaque).opaque as *mut MyOpaque) };\n-\n-        let id = derive_id(id);\n-\n-        let sec = opaque.toc_builder.as_mut().map_or(\"\".to_owned(), |builder| {\n-            format!(\"{} \", builder.push(level as u32, s.clone(), id.clone()))\n-        });\n-\n-        // Render the HTML\n-        let text = format!(\"<h{lvl} id='{id}' class='section-header'>\\\n-                           <a href='#{id}'>{sec}{}</a></h{lvl}>\",\n-                           s, lvl = level, id = id, sec = sec);\n-\n-        let text = CString::new(text).unwrap();\n-        unsafe { hoedown_buffer_puts(ob, text.as_ptr()) }\n-    }\n-\n-    extern fn codespan(\n-        ob: *mut hoedown_buffer,\n-        text: *const hoedown_buffer,\n-        _: *const hoedown_renderer_data,\n-        _: libc::size_t\n-    ) -> libc::c_int {\n-        let content = if text.is_null() {\n-            \"\".to_owned()\n-        } else {\n-            let bytes = unsafe { (*text).as_bytes() };\n-            let s = str::from_utf8(bytes).unwrap();\n-            collapse_whitespace(s)\n-        };\n-\n-        let content = format!(\"<code>{}</code>\", Escape(&content));\n-        let element = CString::new(content).unwrap();\n-        unsafe { hoedown_buffer_puts(ob, element.as_ptr()); }\n-        // Return anything except 0, which would mean \"also print the code span verbatim\".\n-        1\n-    }\n-\n-    unsafe {\n-        let ob = hoedown_buffer_new(DEF_OUNIT);\n-        let renderer = hoedown_html_renderer_new(html_flags, 0);\n-        let mut opaque = MyOpaque {\n-            dfltblk: (*renderer).blockcode.unwrap(),\n-            toc_builder: if print_toc {Some(TocBuilder::new())} else {None}\n-        };\n-        (*((*renderer).opaque as *mut hoedown_html_renderer_state)).opaque\n-                = &mut opaque as *mut _ as *mut libc::c_void;\n-        (*renderer).blockcode = Some(block);\n-        (*renderer).header = Some(header);\n-        (*renderer).codespan = Some(codespan);\n-\n-        let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n-        hoedown_document_render(document, ob, s.as_ptr(),\n-                                s.len() as libc::size_t);\n-        hoedown_document_free(document);\n-\n-        hoedown_html_renderer_free(renderer);\n-\n-        let mut ret = opaque.toc_builder.map_or(Ok(()), |builder| {\n-            write!(w, \"<nav id=\\\"TOC\\\">{}</nav>\", builder.into_toc())\n-        });\n-\n-        if ret.is_ok() {\n-            let buf = (*ob).as_bytes();\n-            ret = w.write_str(str::from_utf8(buf).unwrap());\n-        }\n-        hoedown_buffer_free(ob);\n-        ret\n-    }*/\n-\n-    fn block(parser: &mut Parser, lang: &str, buffer: &mut String) {\n+              shorter: bool) -> fmt::Result {\n+    fn block(parser: &mut Parser, buffer: &mut String, lang: &str) {\n         let mut origtext = String::new();\n         loop {\n             let event = parser.next();\n             if let Some(event) = event {\n                 match event {\n-                    pulldown_cmark::Event::End(\n-                        pulldown_cmark::Tag::CodeBlock(_)) => break,\n-                    pulldown_cmark::Event::Text(ref s) => {\n+                    Event::End(Tag::CodeBlock(_)) => break,\n+                    Event::Text(ref s) => {\n                         origtext.push_str(s);\n                     }\n                     _ => {}\n@@ -445,25 +108,21 @@ pub fn render(w: &mut fmt::Formatter,\n         }\n         let origtext = origtext.trim_left();\n         debug!(\"docblock: ==============\\n{:?}\\n=======\", origtext);\n-        let rendered = if lang.is_empty() || origtext.is_empty() {\n-            false\n-        } else {\n-            if !LangString::parse(lang).rust {\n-                /*(my_opaque.dfltblk)(ob, orig_text, lang,\n-                                    opaque as *const hoedown_renderer_data,\n-                                    line);*/\n-                // true\n-                false\n-            } else {\n-                false\n-            }\n-        };\n \n         let lines = origtext.lines().filter(|l| {\n             stripped_filtered_line(*l).is_none()\n         });\n         let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n-        if rendered { return }\n+        let block_info = if lang.is_empty() {\n+            LangString::all_false()\n+        } else {\n+            LangString::parse(lang)\n+        };\n+        if !block_info.rust {\n+            buffer.push_str(&format!(\"<pre><code class=\\\"language-{}\\\">{}</code></pre>\",\n+                            lang, text));\n+            return\n+        }\n         PLAYGROUND.with(|play| {\n             // insert newline to clearly separate it from the\n             // previous block so we can shorten the html output\n@@ -521,9 +180,8 @@ pub fn render(w: &mut fmt::Formatter,\n             let event = parser.next();\n             if let Some(event) = event {\n                 match event {\n-                    pulldown_cmark::Event::End(\n-                        pulldown_cmark::Tag::Header(_)) => break,\n-                    pulldown_cmark::Event::Text(ref s) => {\n+                    Event::End(Tag::Header(_)) => break,\n+                    Event::Text(ref s) => {\n                         ret.push_str(s);\n                     }\n                     _ => {}\n@@ -561,8 +219,8 @@ pub fn render(w: &mut fmt::Formatter,\n         });\n \n         // Render the HTML\n-        buffer.push_str(&format!(\"<h{lvl} id='{id}' class='section-header'>\\\n-                                  <a href='#{id}'>{sec}{}</a></h{lvl}>\",\n+        buffer.push_str(&format!(\"<h{lvl} id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n+                                  <a href=\\\"#{id}\\\">{sec}{}</a></h{lvl}>\",\n                                  ret, lvl = level, id = id, sec = sec));\n     }\n \n@@ -572,9 +230,8 @@ pub fn render(w: &mut fmt::Formatter,\n             let event = parser.next();\n             if let Some(event) = event {\n                 match event {\n-                    pulldown_cmark::Event::End(\n-                        pulldown_cmark::Tag::Code) => break,\n-                    pulldown_cmark::Event::Text(ref s) => {\n+                    Event::End(Tag::Code) => break,\n+                    Event::Text(ref s) => {\n                         content.push_str(s);\n                     }\n                     _ => {}\n@@ -591,9 +248,8 @@ pub fn render(w: &mut fmt::Formatter,\n             let event = parser.next();\n             if let Some(event) = event {\n                 match event {\n-                    pulldown_cmark::Event::End(\n-                        pulldown_cmark::Tag::Link(_, _)) => break,\n-                    pulldown_cmark::Event::Text(ref s) => {\n+                    Event::End(Tag::Link(_, _)) => break,\n+                    Event::Text(ref s) => {\n                         title.push_str(s);\n                     }\n                     _ => {}\n@@ -605,19 +261,19 @@ pub fn render(w: &mut fmt::Formatter,\n         buffer.push_str(&format!(\"<a href=\\\"{}\\\">{}</a>\", url, title));\n     }\n \n-    fn paragraph(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>) {\n+    fn paragraph(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+                 shorter: bool) {\n         let mut content = String::new();\n         loop {\n             let event = parser.next();\n             if let Some(event) = event {\n                 match event {\n-                    pulldown_cmark::Event::End(\n-                        pulldown_cmark::Tag::Paragraph) => break,\n-                    pulldown_cmark::Event::Text(ref s) => {\n+                    Event::End(Tag::Paragraph) => break,\n+                    Event::Text(ref s) => {\n                         content.push_str(s);\n                     }\n                     x => {\n-                        looper(parser, &mut content, Some(x), toc_builder);\n+                        looper(parser, &mut content, Some(x), toc_builder, shorter);\n                     }\n                 }\n             } else {\n@@ -627,28 +283,135 @@ pub fn render(w: &mut fmt::Formatter,\n         buffer.push_str(&format!(\"<p>{}</p>\", content));\n     }\n \n+    fn cell(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+            shorter: bool) {\n+        let mut content = String::new();\n+        loop {\n+            let event = parser.next();\n+            if let Some(event) = event {\n+                match event {\n+                    Event::End(Tag::TableHead) |\n+                        Event::End(Tag::Table(_)) |\n+                        Event::End(Tag::TableRow) |\n+                        Event::End(Tag::TableCell) => break,\n+                    Event::Text(ref s) => {\n+                        content.push_str(s);\n+                    }\n+                    x => {\n+                        looper(parser, &mut content, Some(x), toc_builder, shorter);\n+                    }\n+                }\n+            } else {\n+                break\n+            }\n+        }\n+        buffer.push_str(&format!(\"<td>{}</td>\", content.trim()));\n+    }\n+\n+    fn row(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+           shorter: bool) {\n+        let mut content = String::new();\n+        loop {\n+            let event = parser.next();\n+            if let Some(event) = event {\n+                match event {\n+                    Event::End(Tag::TableHead) |\n+                        Event::End(Tag::Table(_)) |\n+                        Event::End(Tag::TableRow) => break,\n+                    Event::Start(Tag::TableCell) => {\n+                        cell(parser, &mut content, toc_builder, shorter);\n+                    }\n+                    x => {\n+                        looper(parser, &mut content, Some(x), toc_builder, shorter);\n+                    }\n+                }\n+            } else {\n+                break\n+            }\n+        }\n+        buffer.push_str(&format!(\"<tr>{}</tr>\", content));\n+    }\n+\n+    fn head(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+            shorter: bool) {\n+        let mut content = String::new();\n+        loop {\n+            let event = parser.next();\n+            if let Some(event) = event {\n+                match event {\n+                    Event::End(Tag::TableHead) | Event::End(Tag::Table(_)) => break,\n+                    Event::Start(Tag::TableCell) => {\n+                        cell(parser, &mut content, toc_builder, shorter);\n+                    }\n+                    x => {\n+                        looper(parser, &mut content, Some(x), toc_builder, shorter);\n+                    }\n+                }\n+            } else {\n+                break\n+            }\n+        }\n+        if content.is_empty() {\n+            return\n+        }\n+        buffer.push_str(&format!(\"<thead><tr>{}</tr></thead>\", content.replace(\"td>\", \"th>\")));\n+    }\n+\n+    fn table(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+             shorter: bool) {\n+        let mut content = String::new();\n+        let mut rows = String::new();\n+        loop {\n+            let event = parser.next();\n+            if let Some(event) = event {\n+                match event {\n+                    Event::End(Tag::Table(_)) => break,\n+                    Event::Start(Tag::TableHead) => {\n+                        head(parser, &mut content, toc_builder, shorter);\n+                    }\n+                    Event::Start(Tag::TableRow) => {\n+                        row(parser, &mut rows, toc_builder, shorter);\n+                    }\n+                    _ => {}\n+                }\n+            } else {\n+                break\n+            }\n+        }\n+        buffer.push_str(&format!(\"<table>{}{}</table>\",\n+                                 content,\n+                                 if shorter || rows.is_empty() {\n+                                     String::new()\n+                                 } else {\n+                                     format!(\"<tbody>{}</tbody>\", rows)\n+                                 }));\n+    }\n+\n     fn looper<'a>(parser: &'a mut Parser, buffer: &mut String, next_event: Option<Event<'a>>,\n-                  toc_builder: &mut Option<TocBuilder>) -> bool {\n+                  toc_builder: &mut Option<TocBuilder>, shorter: bool) -> bool {\n         if let Some(event) = next_event {\n             match event {\n-                pulldown_cmark::Event::Start(pulldown_cmark::Tag::CodeBlock(s)) => {\n-                    block(parser, &*s, buffer);\n+                Event::Start(Tag::CodeBlock(lang)) => {\n+                    block(parser, buffer, &*lang);\n                 }\n-                pulldown_cmark::Event::Start(pulldown_cmark::Tag::Header(level)) => {\n+                Event::Start(Tag::Header(level)) => {\n                     header(parser, level, toc_builder, buffer);\n                 }\n-                pulldown_cmark::Event::Start(pulldown_cmark::Tag::Code) => {\n+                Event::Start(Tag::Code) => {\n                     codespan(parser, buffer);\n                 }\n-                pulldown_cmark::Event::Start(pulldown_cmark::Tag::Paragraph) => {\n-                    paragraph(parser, buffer, toc_builder);\n+                Event::Start(Tag::Paragraph) => {\n+                    paragraph(parser, buffer, toc_builder, shorter);\n                 }\n-                pulldown_cmark::Event::Start(pulldown_cmark::Tag::Link(ref url, ref t)) => {\n+                Event::Start(Tag::Link(ref url, ref t)) => {\n                     link(parser, buffer, url, t.as_ref().to_owned());\n                 }\n+                Event::Start(Tag::Table(_)) => {\n+                    table(parser, buffer, toc_builder, shorter);\n+                }\n                 _ => {}\n             }\n-            true\n+            shorter == false\n         } else {\n             false\n         }\n@@ -660,10 +423,10 @@ pub fn render(w: &mut fmt::Formatter,\n         None\n     };\n     let mut buffer = String::new();\n-    let mut parser = Parser::new(s);\n+    let mut parser = Parser::new_ext(s, pulldown_cmark::OPTION_ENABLE_TABLES);\n     loop {\n         let next_event = parser.next();\n-        if !looper(&mut parser, &mut buffer, next_event, &mut toc_builder) {\n+        if !looper(&mut parser, &mut buffer, next_event, &mut toc_builder, shorter) {\n             break\n         }\n     }\n@@ -684,67 +447,64 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Sp\n     let mut prev_offset = 0;\n     let mut nb_lines = 0;\n     let mut register_header = None;\n-    'main: loop {\n-        let next_event = parser.next();\n-        if let Some(event) = next_event {\n-            match event {\n-                pulldown_cmark::Event::Start(pulldown_cmark::Tag::CodeBlock(s)) => {\n-                    let block_info = if s.is_empty() {\n-                        LangString::all_false()\n-                    } else {\n-                        LangString::parse(&*s)\n-                    };\n-                    let mut test_s = String::new();\n-                    let mut offset = None;\n-                    loop {\n-                        let event = parser.next();\n-                        if let Some(event) = event {\n-                            match event {\n-                                pulldown_cmark::Event::End(\n-                                    pulldown_cmark::Tag::CodeBlock(_)) => break,\n-                                pulldown_cmark::Event::Text(ref s) => {\n-                                    test_s.push_str(s);\n-                                    if offset.is_none() {\n-                                        offset = Some(parser.get_offset());\n-                                    }\n+    'main: while let Some(event) = parser.next() {\n+        match event {\n+            Event::Start(Tag::CodeBlock(s)) => {\n+                let block_info = if s.is_empty() {\n+                    LangString::all_false()\n+                } else {\n+                    LangString::parse(&*s)\n+                };\n+                if !block_info.rust {\n+                    continue\n+                }\n+                let mut test_s = String::new();\n+                let mut offset = None;\n+                loop {\n+                    let event = parser.next();\n+                    if let Some(event) = event {\n+                        match event {\n+                            Event::End(Tag::CodeBlock(_)) => break,\n+                            Event::Text(ref s) => {\n+                                test_s.push_str(s);\n+                                if offset.is_none() {\n+                                    offset = Some(parser.get_offset());\n                                 }\n-                                _ => {}\n                             }\n-                        } else {\n-                            break 'main;\n+                            _ => {}\n                         }\n-                    }\n-                    let offset = offset.unwrap_or(0);\n-                    let lines = test_s.lines().map(|l| {\n-                        stripped_filtered_line(l).unwrap_or(l)\n-                    });\n-                    let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n-                    nb_lines += doc[prev_offset..offset].lines().count();\n-                    let line = tests.get_line() + (nb_lines - 1);\n-                    let filename = tests.get_filename();\n-                    tests.add_test(text.to_owned(),\n-                                   block_info.should_panic, block_info.no_run,\n-                                   block_info.ignore, block_info.test_harness,\n-                                   block_info.compile_fail, block_info.error_codes,\n-                                   line, filename);\n-                    prev_offset = offset;\n-                }\n-                pulldown_cmark::Event::Start(pulldown_cmark::Tag::Header(level)) => {\n-                    register_header = Some(level as u32);\n-                }\n-                pulldown_cmark::Event::Text(ref s) if register_header.is_some() => {\n-                    let level = register_header.unwrap();\n-                    if s.is_empty() {\n-                        tests.register_header(\"\", level);\n                     } else {\n-                        tests.register_header(s, level);\n+                        break 'main;\n                     }\n-                    register_header = None;\n                 }\n-                _ => {}\n+                let offset = offset.unwrap_or(0);\n+                let lines = test_s.lines().map(|l| {\n+                    stripped_filtered_line(l).unwrap_or(l)\n+                });\n+                let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n+                nb_lines += doc[prev_offset..offset].lines().count();\n+                let line = tests.get_line() + (nb_lines - 1);\n+                let filename = tests.get_filename();\n+                tests.add_test(text.to_owned(),\n+                               block_info.should_panic, block_info.no_run,\n+                               block_info.ignore, block_info.test_harness,\n+                               block_info.compile_fail, block_info.error_codes,\n+                               line, filename);\n+                prev_offset = offset;\n             }\n-        } else {\n-            break\n+            Event::Start(Tag::Header(level)) => {\n+                register_header = Some(level as u32);\n+            }\n+            Event::Text(ref s) if register_header.is_some() => {\n+                let level = register_header.unwrap();\n+                if s.is_empty() {\n+                    tests.register_header(\"\", level);\n+                } else {\n+                    tests.register_header(s, level);\n+                }\n+                register_header = None;\n+            }\n+            _ => {}\n         }\n     }\n }\n@@ -824,17 +584,17 @@ impl LangString {\n \n impl<'a> fmt::Display for Markdown<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let Markdown(md) = *self;\n+        let Markdown(md, shorter) = *self;\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n-        render(fmt, md, false, 0)\n+        render(fmt, md, false, shorter)\n     }\n }\n \n impl<'a> fmt::Display for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let MarkdownWithToc(md) = *self;\n-        render(fmt, md, true, 0)\n+        render(fmt, md, true, false)\n     }\n }\n \n@@ -843,7 +603,7 @@ impl<'a> fmt::Display for MarkdownHtml<'a> {\n         let MarkdownHtml(md) = *self;\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n-        render(fmt, md, false, /*HOEDOWN_HTML_ESCAPE*/0)\n+        render(fmt, md, false, false)\n     }\n }\n \n@@ -864,12 +624,13 @@ pub fn plain_summary_line(md: &str) -> String {\n             }\n             let next_event = next_event.unwrap();\n             let (ret, is_in) = match next_event {\n-                pulldown_cmark::Event::Start(pulldown_cmark::Tag::Paragraph) => (None, 1),\n-                pulldown_cmark::Event::Start(\n-                    pulldown_cmark::Tag::Link(_, ref t)) if !self.is_first => (Some(t.as_ref().to_owned()), 1),\n-                pulldown_cmark::Event::Text(ref s) if self.is_in > 0 => (Some(s.as_ref().to_owned()), 0),\n-                pulldown_cmark::Event::End(pulldown_cmark::Tag::Link(_, ref t)) => (Some(t.as_ref().to_owned()), -1),\n-                pulldown_cmark::Event::End(pulldown_cmark::Tag::Paragraph) => (None, -1),\n+                Event::Start(Tag::Paragraph) => (None, 1),\n+                Event::Start(Tag::Link(_, ref t)) if !self.is_first => {\n+                    (Some(t.as_ref().to_owned()), 1)\n+                }\n+                Event::Text(ref s) if self.is_in > 0 => (Some(s.as_ref().to_owned()), 0),\n+                Event::End(Tag::Link(_, ref t)) => (Some(t.as_ref().to_owned()), -1),\n+                Event::End(Tag::Paragraph) => (None, -1),\n                 _ => (None, 0),\n             };\n             if is_in > 0 || (is_in < 0 && self.is_in > 0) {"}, {"sha": "8c1416b8097997f843e5ed9b23cf32e8cac472b5", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b96fef8411f26e357e31b8c1b584b6d994efafaa/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96fef8411f26e357e31b8c1b584b6d994efafaa/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b96fef8411f26e357e31b8c1b584b6d994efafaa", "patch": "@@ -1650,7 +1650,7 @@ fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLin\n         } else {\n             format!(\"{}\", &plain_summary_line(Some(s)))\n         };\n-        write!(w, \"<div class='docblock'>{}</div>\", Markdown(&markdown))?;\n+        write!(w, \"<div class='docblock'>{}</div>\", Markdown(&markdown, false))?;\n     }\n     Ok(())\n }\n@@ -1683,7 +1683,7 @@ fn get_doc_value(item: &clean::Item) -> Option<&str> {\n fn document_full(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n     if let Some(s) = get_doc_value(item) {\n         write!(w, \"<div class='docblock'>{}</div>\",\n-               Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s)))?;\n+               Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s), false))?;\n     }\n     Ok(())\n }\n@@ -1871,7 +1871,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                        </tr>\",\n                        name = *myitem.name.as_ref().unwrap(),\n                        stab_docs = stab_docs,\n-                       docs = shorter(Some(&Markdown(doc_value).to_string())),\n+                       docs = shorter(Some(&Markdown(doc_value, true).to_string())),\n                        class = myitem.type_(),\n                        stab = myitem.stability_class().unwrap_or(\"\".to_string()),\n                        unsafety_flag = unsafety_flag,\n@@ -2901,7 +2901,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         write!(w, \"</span>\")?;\n         write!(w, \"</h3>\\n\")?;\n         if let Some(ref dox) = i.impl_item.doc_value() {\n-            write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox))?;\n+            write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox, false))?;\n         }\n     }\n "}, {"sha": "a048750279e26170f0d5ccb1cdd6845fb5b451a3", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b96fef8411f26e357e31b8c1b584b6d994efafaa/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96fef8411f26e357e31b8c1b584b6d994efafaa/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=b96fef8411f26e357e31b8c1b584b6d994efafaa", "patch": "@@ -94,7 +94,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n     let rendered = if include_toc {\n         format!(\"{}\", MarkdownWithToc(text))\n     } else {\n-        format!(\"{}\", Markdown(text))\n+        format!(\"{}\", Markdown(text, false))\n     };\n \n     let err = write!("}, {"sha": "da282f1bb7277b4d30fa1599ee29ad8eb4dd2a92", "filename": "src/rt/hoedown", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fhoedown?ref=c9415eb98ff2a5cf679954e5eaf66274a24db1ee", "patch": "@@ -1 +0,0 @@\n-Subproject commit da282f1bb7277b4d30fa1599ee29ad8eb4dd2a92"}]}