{"sha": "a9bb589cd678e034d194193fa892942315b10e2a", "node_id": "C_kwDOAAsO6NoAKGE5YmI1ODljZDY3OGUwMzRkMTk0MTkzZmE4OTI5NDIzMTViMTBlMmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-22T06:10:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-22T06:10:26Z"}, "message": "Auto merge of #100676 - lcnr:implied-bounds-yay, r=nikomatsakis\n\nimplied bounds: explicitly state which types are assumed to be wf\n\nAdds a new query which maps each definition to the types which that definition assumes to be well formed. The intent is to make it easier to reason about implied bounds.\n\nThis change should not influence the user-facing behavior of rustc. Notably, `borrowck` still only assumes that the function signature of associated functions is well formed while `wfcheck` assumes that the both the function signature and the impl trait ref is well formed. Not sure if that by itself can trigger UB or whether it's just annoying.\n\nAs a next step, we can add `WellFormed` predicates to `predicates_of` of these items and can stop adding the wf bounds at each place which uses them. I also intend to move the computation from `assumed_wf_types` to `implied_bounds` into the `param_env` computation. This requires me to take a deeper look at `compare_predicate_entailment` which is currently somewhat weird wrt implied bounds so I am not touching this here.\n\nr? `@nikomatsakis`", "tree": {"sha": "0841fc4ec790317a0bd5f9472916554b20bd8cfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0841fc4ec790317a0bd5f9472916554b20bd8cfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9bb589cd678e034d194193fa892942315b10e2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9bb589cd678e034d194193fa892942315b10e2a", "html_url": "https://github.com/rust-lang/rust/commit/a9bb589cd678e034d194193fa892942315b10e2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9bb589cd678e034d194193fa892942315b10e2a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0ea1d767925d53b2230e2ba81197821514781f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0ea1d767925d53b2230e2ba81197821514781f0", "html_url": "https://github.com/rust-lang/rust/commit/d0ea1d767925d53b2230e2ba81197821514781f0"}, {"sha": "736288f221ac9578f88a0c1d001f8febe0d33496", "url": "https://api.github.com/repos/rust-lang/rust/commits/736288f221ac9578f88a0c1d001f8febe0d33496", "html_url": "https://github.com/rust-lang/rust/commit/736288f221ac9578f88a0c1d001f8febe0d33496"}], "stats": {"total": 558, "additions": 321, "deletions": 237}, "files": [{"sha": "f78f62e31d286024d6043478e9834be9a041a0a8", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -765,6 +765,14 @@ rustc_queries! {\n         desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n+    /// Returns the types assumed to be well formed while \"inside\" of the given item.\n+    ///\n+    /// Note that we've liberated the late bound regions of function signatures, so\n+    /// this can not be used to check whether these types are well formed.\n+    query assumed_wf_types(key: DefId) -> &'tcx ty::List<Ty<'tcx>> {\n+        desc { |tcx| \"computing the implied bounds of {}\", tcx.def_path_str(key) }\n+    }\n+\n     /// Computes the signature of the function.\n     query fn_sig(key: DefId) -> ty::PolyFnSig<'tcx> {\n         desc { |tcx| \"computing function signature of `{}`\", tcx.def_path_str(key) }"}, {"sha": "79365ef281be792d2b9caa72912ad25c2bae60d2", "filename": "compiler/rustc_middle/src/ty/list.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -65,6 +65,10 @@ impl<T> List<T> {\n     pub fn len(&self) -> usize {\n         self.len\n     }\n+\n+    pub fn as_slice(&self) -> &[T] {\n+        self\n+    }\n }\n \n impl<T: Copy> List<T> {"}, {"sha": "136b94321459ee062840443e9534b30dc101f835", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -3,7 +3,8 @@ use std::cell::RefCell;\n use super::TraitEngine;\n use super::{ChalkFulfillmentContext, FulfillmentContext};\n use crate::infer::InferCtxtExt;\n-use rustc_hir::def_id::DefId;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::{InferCtxt, InferOk};\n use rustc_infer::traits::{\n     FulfillmentError, Obligation, ObligationCause, PredicateObligation, TraitEngineExt as _,\n@@ -12,6 +13,7 @@ use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::ToPredicate;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::Span;\n \n pub trait TraitEngineExt<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>) -> Box<Self>;\n@@ -109,4 +111,23 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n     pub fn select_all_or_error(&self) -> Vec<FulfillmentError<'tcx>> {\n         self.engine.borrow_mut().select_all_or_error(self.infcx)\n     }\n+\n+    pub fn assumed_wf_types(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        span: Span,\n+        def_id: LocalDefId,\n+    ) -> FxHashSet<Ty<'tcx>> {\n+        let tcx = self.infcx.tcx;\n+        let assumed_wf_types = tcx.assumed_wf_types(def_id);\n+        let mut implied_bounds = FxHashSet::default();\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        let cause = ObligationCause::misc(span, hir_id);\n+        for ty in assumed_wf_types {\n+            implied_bounds.insert(ty);\n+            let normalized = self.normalize(cause.clone(), param_env, ty);\n+            implied_bounds.insert(normalized);\n+        }\n+        implied_bounds\n+    }\n }"}, {"sha": "a77ea440aaaea90fb02f9d27c333a82eb8468c47", "filename": "compiler/rustc_ty_utils/src/implied_bounds.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -0,0 +1,60 @@\n+use crate::rustc_middle::ty::DefIdTree;\n+use rustc_hir::{def::DefKind, def_id::DefId};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+\n+pub fn provide(providers: &mut ty::query::Providers) {\n+    *providers = ty::query::Providers { assumed_wf_types, ..*providers };\n+}\n+\n+fn assumed_wf_types<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::List<Ty<'tcx>> {\n+    match tcx.def_kind(def_id) {\n+        DefKind::Fn => {\n+            let sig = tcx.fn_sig(def_id);\n+            let liberated_sig = tcx.liberate_late_bound_regions(def_id, sig);\n+            liberated_sig.inputs_and_output\n+        }\n+        DefKind::AssocFn => {\n+            let sig = tcx.fn_sig(def_id);\n+            let liberated_sig = tcx.liberate_late_bound_regions(def_id, sig);\n+            let mut assumed_wf_types: Vec<_> =\n+                tcx.assumed_wf_types(tcx.parent(def_id)).as_slice().into();\n+            assumed_wf_types.extend(liberated_sig.inputs_and_output);\n+            tcx.intern_type_list(&assumed_wf_types)\n+        }\n+        DefKind::Impl => match tcx.impl_trait_ref(def_id) {\n+            Some(trait_ref) => {\n+                let types: Vec<_> = trait_ref.substs.types().collect();\n+                tcx.intern_type_list(&types)\n+            }\n+            // Only the impl self type\n+            None => tcx.intern_type_list(&[tcx.type_of(def_id)]),\n+        },\n+        DefKind::AssocConst | DefKind::AssocTy => tcx.assumed_wf_types(tcx.parent(def_id)),\n+        DefKind::Mod\n+        | DefKind::Struct\n+        | DefKind::Union\n+        | DefKind::Enum\n+        | DefKind::Variant\n+        | DefKind::Trait\n+        | DefKind::TyAlias\n+        | DefKind::ForeignTy\n+        | DefKind::TraitAlias\n+        | DefKind::TyParam\n+        | DefKind::Const\n+        | DefKind::ConstParam\n+        | DefKind::Static(_)\n+        | DefKind::Ctor(_, _)\n+        | DefKind::Macro(_)\n+        | DefKind::ExternCrate\n+        | DefKind::Use\n+        | DefKind::ForeignMod\n+        | DefKind::AnonConst\n+        | DefKind::InlineConst\n+        | DefKind::OpaqueTy\n+        | DefKind::Field\n+        | DefKind::LifetimeParam\n+        | DefKind::GlobalAsm\n+        | DefKind::Closure\n+        | DefKind::Generator => ty::List::empty(),\n+    }\n+}"}, {"sha": "55d8269399403d1c1ea094978ca838ce7e962fc5", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -21,6 +21,7 @@ use rustc_middle::ty::query::Providers;\n mod assoc;\n mod common_traits;\n mod consts;\n+mod implied_bounds;\n pub mod instance;\n mod needs_drop;\n pub mod representability;\n@@ -30,6 +31,7 @@ pub fn provide(providers: &mut Providers) {\n     assoc::provide(providers);\n     common_traits::provide(providers);\n     consts::provide(providers);\n+    implied_bounds::provide(providers);\n     needs_drop::provide(providers);\n     ty::provide(providers);\n     instance::provide(providers);"}, {"sha": "db82be7a98fc662f3208413f806f722c80fed0a3", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 71, "deletions": 75, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -1,6 +1,5 @@\n use super::potentially_plural_count;\n use crate::check::regionck::OutlivesEnvironmentExt;\n-use crate::check::wfcheck;\n use crate::errors::LifetimesOrBoundsMismatchOnTrait;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, ErrorGuaranteed};\n@@ -71,6 +70,72 @@ pub(crate) fn compare_impl_method<'tcx>(\n     }\n }\n \n+/// This function is best explained by example. Consider a trait:\n+///\n+///     trait Trait<'t, T> {\n+///         // `trait_m`\n+///         fn method<'a, M>(t: &'t T, m: &'a M) -> Self;\n+///     }\n+///\n+/// And an impl:\n+///\n+///     impl<'i, 'j, U> Trait<'j, &'i U> for Foo {\n+///          // `impl_m`\n+///          fn method<'b, N>(t: &'j &'i U, m: &'b N) -> Foo;\n+///     }\n+///\n+/// We wish to decide if those two method types are compatible.\n+/// For this we have to show that, assuming the bounds of the impl hold, the\n+/// bounds of `trait_m` imply the bounds of `impl_m`.\n+///\n+/// We start out with `trait_to_impl_substs`, that maps the trait\n+/// type parameters to impl type parameters. This is taken from the\n+/// impl trait reference:\n+///\n+///     trait_to_impl_substs = {'t => 'j, T => &'i U, Self => Foo}\n+///\n+/// We create a mapping `dummy_substs` that maps from the impl type\n+/// parameters to fresh types and regions. For type parameters,\n+/// this is the identity transform, but we could as well use any\n+/// placeholder types. For regions, we convert from bound to free\n+/// regions (Note: but only early-bound regions, i.e., those\n+/// declared on the impl or used in type parameter bounds).\n+///\n+///     impl_to_placeholder_substs = {'i => 'i0, U => U0, N => N0 }\n+///\n+/// Now we can apply `placeholder_substs` to the type of the impl method\n+/// to yield a new function type in terms of our fresh, placeholder\n+/// types:\n+///\n+///     <'b> fn(t: &'i0 U0, m: &'b) -> Foo\n+///\n+/// We now want to extract and substitute the type of the *trait*\n+/// method and compare it. To do so, we must create a compound\n+/// substitution by combining `trait_to_impl_substs` and\n+/// `impl_to_placeholder_substs`, and also adding a mapping for the method\n+/// type parameters. We extend the mapping to also include\n+/// the method parameters.\n+///\n+///     trait_to_placeholder_substs = { T => &'i0 U0, Self => Foo, M => N0 }\n+///\n+/// Applying this to the trait method type yields:\n+///\n+///     <'a> fn(t: &'i0 U0, m: &'a) -> Foo\n+///\n+/// This type is also the same but the name of the bound region (`'a`\n+/// vs `'b`).  However, the normal subtyping rules on fn types handle\n+/// this kind of equivalency just fine.\n+///\n+/// We now use these substitutions to ensure that all declared bounds are\n+/// satisfied by the implementation's method.\n+///\n+/// We do this by creating a parameter environment which contains a\n+/// substitution corresponding to `impl_to_placeholder_substs`. We then build\n+/// `trait_to_placeholder_substs` and use it to convert the predicates contained\n+/// in the `trait_m` generics to the placeholder form.\n+///\n+/// Finally we register each of these predicates as an obligation and check that\n+/// they hold.\n fn compare_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n@@ -97,69 +162,6 @@ fn compare_predicate_entailment<'tcx>(\n         },\n     );\n \n-    // This code is best explained by example. Consider a trait:\n-    //\n-    //     trait Trait<'t, T> {\n-    //         fn method<'a, M>(t: &'t T, m: &'a M) -> Self;\n-    //     }\n-    //\n-    // And an impl:\n-    //\n-    //     impl<'i, 'j, U> Trait<'j, &'i U> for Foo {\n-    //          fn method<'b, N>(t: &'j &'i U, m: &'b N) -> Foo;\n-    //     }\n-    //\n-    // We wish to decide if those two method types are compatible.\n-    //\n-    // We start out with trait_to_impl_substs, that maps the trait\n-    // type parameters to impl type parameters. This is taken from the\n-    // impl trait reference:\n-    //\n-    //     trait_to_impl_substs = {'t => 'j, T => &'i U, Self => Foo}\n-    //\n-    // We create a mapping `dummy_substs` that maps from the impl type\n-    // parameters to fresh types and regions. For type parameters,\n-    // this is the identity transform, but we could as well use any\n-    // placeholder types. For regions, we convert from bound to free\n-    // regions (Note: but only early-bound regions, i.e., those\n-    // declared on the impl or used in type parameter bounds).\n-    //\n-    //     impl_to_placeholder_substs = {'i => 'i0, U => U0, N => N0 }\n-    //\n-    // Now we can apply placeholder_substs to the type of the impl method\n-    // to yield a new function type in terms of our fresh, placeholder\n-    // types:\n-    //\n-    //     <'b> fn(t: &'i0 U0, m: &'b) -> Foo\n-    //\n-    // We now want to extract and substitute the type of the *trait*\n-    // method and compare it. To do so, we must create a compound\n-    // substitution by combining trait_to_impl_substs and\n-    // impl_to_placeholder_substs, and also adding a mapping for the method\n-    // type parameters. We extend the mapping to also include\n-    // the method parameters.\n-    //\n-    //     trait_to_placeholder_substs = { T => &'i0 U0, Self => Foo, M => N0 }\n-    //\n-    // Applying this to the trait method type yields:\n-    //\n-    //     <'a> fn(t: &'i0 U0, m: &'a) -> Foo\n-    //\n-    // This type is also the same but the name of the bound region ('a\n-    // vs 'b).  However, the normal subtyping rules on fn types handle\n-    // this kind of equivalency just fine.\n-    //\n-    // We now use these substitutions to ensure that all declared bounds are\n-    // satisfied by the implementation's method.\n-    //\n-    // We do this by creating a parameter environment which contains a\n-    // substitution corresponding to impl_to_placeholder_substs. We then build\n-    // trait_to_placeholder_substs and use it to convert the predicates contained\n-    // in the trait_m.generics to the placeholder form.\n-    //\n-    // Finally we register each of these predicates as an obligation in\n-    // a fresh FulfillmentCtxt, and invoke select_all_or_error.\n-\n     // Create mapping from impl to placeholder.\n     let impl_to_placeholder_substs = InternalSubsts::identity_for_item(tcx, impl_m.def_id);\n \n@@ -1445,14 +1447,17 @@ pub fn check_type_bounds<'tcx>(\n     };\n     debug!(?normalize_param_env);\n \n+    let impl_ty_hir_id = tcx.hir().local_def_id_to_hir_id(impl_ty.def_id.expect_local());\n     let impl_ty_substs = InternalSubsts::identity_for_item(tcx, impl_ty.def_id);\n     let rebased_substs = impl_ty_substs.rebase_onto(tcx, container_id, impl_trait_ref.substs);\n \n     tcx.infer_ctxt().enter(move |infcx| {\n         let ocx = ObligationCtxt::new(&infcx);\n \n+        let assumed_wf_types =\n+            ocx.assumed_wf_types(param_env, impl_ty_span, impl_ty.def_id.expect_local());\n+\n         let mut selcx = traits::SelectionContext::new(&infcx);\n-        let impl_ty_hir_id = tcx.hir().local_def_id_to_hir_id(impl_ty.def_id.expect_local());\n         let normalize_cause = ObligationCause::new(\n             impl_ty_span,\n             impl_ty_hir_id,\n@@ -1508,17 +1513,8 @@ pub fn check_type_bounds<'tcx>(\n \n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n-        let implied_bounds = match impl_ty.container {\n-            ty::TraitContainer => FxHashSet::default(),\n-            ty::ImplContainer => wfcheck::impl_implied_bounds(\n-                tcx,\n-                param_env,\n-                container_id.expect_local(),\n-                impl_ty_span,\n-            ),\n-        };\n         let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-        outlives_environment.add_implied_bounds(&infcx, implied_bounds, impl_ty_hir_id);\n+        outlives_environment.add_implied_bounds(&infcx, assumed_wf_types, impl_ty_hir_id);\n         infcx.check_region_obligations_and_report_errors(\n             impl_ty.def_id.expect_local(),\n             &outlives_environment,"}, {"sha": "4814aea7afb9e6322e1ec1065948c2e11736011d", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 11, "deletions": 74, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -10,7 +10,6 @@ use rustc_hir::ItemKind;\n use rustc_infer::infer::outlives::env::{OutlivesEnvironment, RegionBoundPairs};\n use rustc_infer::infer::outlives::obligations::TypeOutlives;\n use rustc_infer::infer::{self, InferCtxt, TyCtxtInferExt};\n-use rustc_infer::traits::Normalized;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n@@ -24,8 +23,6 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::autoderef::Autoderef;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n-use rustc_trait_selection::traits::query::normalize::AtExt;\n-use rustc_trait_selection::traits::query::NoSolution;\n use rustc_trait_selection::traits::{\n     self, ObligationCause, ObligationCauseCode, ObligationCtxt, WellFormedLoc,\n };\n@@ -86,26 +83,29 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n     body_def_id: LocalDefId,\n     f: F,\n ) where\n-    F: for<'a> FnOnce(&WfCheckingCtxt<'a, 'tcx>) -> FxHashSet<Ty<'tcx>>,\n+    F: for<'a> FnOnce(&WfCheckingCtxt<'a, 'tcx>),\n {\n     let param_env = tcx.param_env(body_def_id);\n     let body_id = tcx.hir().local_def_id_to_hir_id(body_def_id);\n     tcx.infer_ctxt().enter(|ref infcx| {\n         let ocx = ObligationCtxt::new(infcx);\n+\n+        let assumed_wf_types = ocx.assumed_wf_types(param_env, span, body_def_id);\n+\n         let mut wfcx = WfCheckingCtxt { ocx, span, body_id, param_env };\n \n         if !tcx.features().trivial_bounds {\n             wfcx.check_false_global_bounds()\n         }\n-        let wf_tys = f(&mut wfcx);\n+        f(&mut wfcx);\n         let errors = wfcx.select_all_or_error();\n         if !errors.is_empty() {\n             infcx.report_fulfillment_errors(&errors, None, false);\n             return;\n         }\n \n         let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-        outlives_environment.add_implied_bounds(infcx, wf_tys, body_id);\n+        outlives_environment.add_implied_bounds(infcx, assumed_wf_types, body_id);\n         infcx.check_region_obligations_and_report_errors(body_def_id, &outlives_environment);\n     })\n }\n@@ -976,15 +976,9 @@ fn check_associated_item(\n     enter_wf_checking_ctxt(tcx, span, item_id, |wfcx| {\n         let item = tcx.associated_item(item_id);\n \n-        let (mut implied_bounds, self_ty) = match item.container {\n-            ty::TraitContainer => (FxHashSet::default(), tcx.types.self_param),\n-            ty::ImplContainer => {\n-                let def_id = item.container_id(tcx);\n-                (\n-                    impl_implied_bounds(tcx, wfcx.param_env, def_id.expect_local(), span),\n-                    tcx.type_of(def_id),\n-                )\n-            }\n+        let self_ty = match item.container {\n+            ty::TraitContainer => tcx.types.self_param,\n+            ty::ImplContainer => tcx.type_of(item.container_id(tcx)),\n         };\n \n         match item.kind {\n@@ -1002,7 +996,6 @@ fn check_associated_item(\n                     sig,\n                     hir_sig.decl,\n                     item.def_id.expect_local(),\n-                    &mut implied_bounds,\n                 );\n                 check_method_receiver(wfcx, hir_sig, item, self_ty);\n             }\n@@ -1017,8 +1010,6 @@ fn check_associated_item(\n                 }\n             }\n         }\n-\n-        implied_bounds\n     })\n }\n \n@@ -1118,9 +1109,6 @@ fn check_type_defn<'tcx, F>(\n         }\n \n         check_where_clauses(wfcx, item.span, item.def_id);\n-\n-        // No implied bounds in a struct definition.\n-        FxHashSet::default()\n     });\n }\n \n@@ -1144,9 +1132,7 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n     }\n \n     enter_wf_checking_ctxt(tcx, item.span, item.def_id, |wfcx| {\n-        check_where_clauses(wfcx, item.span, item.def_id);\n-\n-        FxHashSet::default()\n+        check_where_clauses(wfcx, item.span, item.def_id)\n     });\n \n     // Only check traits, don't check trait aliases\n@@ -1186,9 +1172,7 @@ fn check_item_fn(\n ) {\n     enter_wf_checking_ctxt(tcx, span, def_id, |wfcx| {\n         let sig = tcx.fn_sig(def_id);\n-        let mut implied_bounds = FxHashSet::default();\n-        check_fn_or_method(wfcx, ident.span, sig, decl, def_id, &mut implied_bounds);\n-        implied_bounds\n+        check_fn_or_method(wfcx, ident.span, sig, decl, def_id);\n     })\n }\n \n@@ -1231,9 +1215,6 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: LocalDefId, ty_span: Span, allow_fo\n                 tcx.require_lang_item(LangItem::Sync, Some(ty_span)),\n             );\n         }\n-\n-        // No implied bounds in a const, etc.\n-        FxHashSet::default()\n     });\n }\n \n@@ -1284,8 +1265,6 @@ fn check_impl<'tcx>(\n         }\n \n         check_where_clauses(wfcx, item.span, item.def_id);\n-\n-        impl_implied_bounds(tcx, wfcx.param_env, item.def_id, item.span)\n     });\n }\n \n@@ -1479,7 +1458,6 @@ fn check_fn_or_method<'tcx>(\n     sig: ty::PolyFnSig<'tcx>,\n     hir_decl: &hir::FnDecl<'_>,\n     def_id: LocalDefId,\n-    implied_bounds: &mut FxHashSet<Ty<'tcx>>,\n ) {\n     let tcx = wfcx.tcx();\n     let sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), sig);\n@@ -1521,15 +1499,8 @@ fn check_fn_or_method<'tcx>(\n         );\n     }\n \n-    implied_bounds.extend(sig.inputs());\n-\n     wfcx.register_wf_obligation(hir_decl.output.span(), None, sig.output().into());\n \n-    // FIXME(#27579) return types should not be implied bounds\n-    implied_bounds.insert(sig.output());\n-\n-    debug!(?implied_bounds);\n-\n     check_where_clauses(wfcx, span, def_id);\n }\n \n@@ -1924,40 +1895,6 @@ impl<'a, 'tcx> WfCheckingCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn impl_implied_bounds<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    impl_def_id: LocalDefId,\n-    span: Span,\n-) -> FxHashSet<Ty<'tcx>> {\n-    // We completely ignore any obligations caused by normalizing the types\n-    // we assume to be well formed. Considering that the user of the implied\n-    // bounds will also normalize them, we leave it to them to emit errors\n-    // which should result in better causes and spans.\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let cause = ObligationCause::misc(span, tcx.hir().local_def_id_to_hir_id(impl_def_id));\n-        match tcx.impl_trait_ref(impl_def_id) {\n-            Some(trait_ref) => {\n-                // Trait impl: take implied bounds from all types that\n-                // appear in the trait reference.\n-                match infcx.at(&cause, param_env).normalize(trait_ref) {\n-                    Ok(Normalized { value, obligations: _ }) => value.substs.types().collect(),\n-                    Err(NoSolution) => FxHashSet::default(),\n-                }\n-            }\n-\n-            None => {\n-                // Inherent impl: take implied bounds from the `self` type.\n-                let self_ty = tcx.type_of(impl_def_id);\n-                match infcx.at(&cause, param_env).normalize(self_ty) {\n-                    Ok(Normalized { value, obligations: _ }) => FxHashSet::from_iter([value]),\n-                    Err(NoSolution) => FxHashSet::default(),\n-                }\n-            }\n-        }\n-    })\n-}\n-\n fn error_392(\n     tcx: TyCtxt<'_>,\n     span: Span,"}, {"sha": "97346f0f834c88337da2a8e7b25171be3e463d03", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 48, "deletions": 43, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -66,26 +66,24 @@\n //! on traits with methods can.\n \n use crate::check::regionck::OutlivesEnvironmentExt;\n-use crate::check::wfcheck::impl_implied_bounds;\n use crate::constrained_generic_params as cgp;\n use crate::errors::SubstsOnOverriddenImpl;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::specialization_graph::Node;\n use rustc_middle::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n use rustc_span::Span;\n-use rustc_trait_selection::traits::{self, translate_substs, wf};\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n+use rustc_trait_selection::traits::{self, translate_substs, wf, ObligationCtxt};\n \n pub(super) fn check_min_specialization(tcx: TyCtxt<'_>, impl_def_id: LocalDefId) {\n     if let Some(node) = parent_specialization_node(tcx, impl_def_id) {\n-        tcx.infer_ctxt().enter(|infcx| {\n-            check_always_applicable(&infcx, impl_def_id, node);\n-        });\n+        check_always_applicable(tcx, impl_def_id, node);\n     }\n }\n \n@@ -105,16 +103,14 @@ fn parent_specialization_node(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId) -> Opti\n }\n \n /// Check that `impl1` is a sound specialization\n-fn check_always_applicable(infcx: &InferCtxt<'_, '_>, impl1_def_id: LocalDefId, impl2_node: Node) {\n-    if let Some((impl1_substs, impl2_substs)) = get_impl_substs(infcx, impl1_def_id, impl2_node) {\n+fn check_always_applicable(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node: Node) {\n+    if let Some((impl1_substs, impl2_substs)) = get_impl_substs(tcx, impl1_def_id, impl2_node) {\n         let impl2_def_id = impl2_node.def_id();\n         debug!(\n             \"check_always_applicable(\\nimpl1_def_id={:?},\\nimpl2_def_id={:?},\\nimpl2_substs={:?}\\n)\",\n             impl1_def_id, impl2_def_id, impl2_substs\n         );\n \n-        let tcx = infcx.tcx;\n-\n         let parent_substs = if impl2_node.is_from_trait() {\n             impl2_substs.to_vec()\n         } else {\n@@ -124,7 +120,7 @@ fn check_always_applicable(infcx: &InferCtxt<'_, '_>, impl1_def_id: LocalDefId,\n         let span = tcx.def_span(impl1_def_id);\n         check_static_lifetimes(tcx, &parent_substs, span);\n         check_duplicate_params(tcx, impl1_substs, &parent_substs, span);\n-        check_predicates(infcx, impl1_def_id, impl1_substs, impl2_node, impl2_substs, span);\n+        check_predicates(tcx, impl1_def_id, impl1_substs, impl2_node, impl2_substs, span);\n     }\n }\n \n@@ -139,32 +135,38 @@ fn check_always_applicable(infcx: &InferCtxt<'_, '_>, impl1_def_id: LocalDefId,\n ///\n /// Would return `S1 = [C]` and `S2 = [Vec<C>, C]`.\n fn get_impl_substs<'tcx>(\n-    infcx: &InferCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     impl1_def_id: LocalDefId,\n     impl2_node: Node,\n ) -> Option<(SubstsRef<'tcx>, SubstsRef<'tcx>)> {\n-    let tcx = infcx.tcx;\n-    let param_env = tcx.param_env(impl1_def_id);\n+    tcx.infer_ctxt().enter(|ref infcx| {\n+        let ocx = ObligationCtxt::new(infcx);\n+        let param_env = tcx.param_env(impl1_def_id);\n+        let impl1_hir_id = tcx.hir().local_def_id_to_hir_id(impl1_def_id);\n \n-    let impl1_substs = InternalSubsts::identity_for_item(tcx, impl1_def_id.to_def_id());\n-    let impl2_substs =\n-        translate_substs(infcx, param_env, impl1_def_id.to_def_id(), impl1_substs, impl2_node);\n+        let assumed_wf_types =\n+            ocx.assumed_wf_types(param_env, tcx.def_span(impl1_def_id), impl1_def_id);\n \n-    let mut outlives_env = OutlivesEnvironment::new(param_env);\n-    let implied_bounds =\n-        impl_implied_bounds(infcx.tcx, param_env, impl1_def_id, tcx.def_span(impl1_def_id));\n-    outlives_env.add_implied_bounds(\n-        infcx,\n-        implied_bounds,\n-        tcx.hir().local_def_id_to_hir_id(impl1_def_id),\n-    );\n-    infcx.check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n-    let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n-        let span = tcx.def_span(impl1_def_id);\n-        tcx.sess.emit_err(SubstsOnOverriddenImpl { span });\n-        return None;\n-    };\n-    Some((impl1_substs, impl2_substs))\n+        let impl1_substs = InternalSubsts::identity_for_item(tcx, impl1_def_id.to_def_id());\n+        let impl2_substs =\n+            translate_substs(infcx, param_env, impl1_def_id.to_def_id(), impl1_substs, impl2_node);\n+\n+        let errors = ocx.select_all_or_error();\n+        if !errors.is_empty() {\n+            ocx.infcx.report_fulfillment_errors(&errors, None, false);\n+            return None;\n+        }\n+\n+        let mut outlives_env = OutlivesEnvironment::new(param_env);\n+        outlives_env.add_implied_bounds(infcx, assumed_wf_types, impl1_hir_id);\n+        infcx.check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n+        let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n+            let span = tcx.def_span(impl1_def_id);\n+            tcx.sess.emit_err(SubstsOnOverriddenImpl { span });\n+            return None;\n+        };\n+        Some((impl1_substs, impl2_substs))\n+    })\n }\n \n /// Returns a list of all of the unconstrained subst of the given impl.\n@@ -279,14 +281,13 @@ fn check_static_lifetimes<'tcx>(\n /// * a well-formed predicate of a type argument of the trait being implemented,\n ///   including the `Self`-type.\n fn check_predicates<'tcx>(\n-    infcx: &InferCtxt<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     impl1_def_id: LocalDefId,\n     impl1_substs: SubstsRef<'tcx>,\n     impl2_node: Node,\n     impl2_substs: SubstsRef<'tcx>,\n     span: Span,\n ) {\n-    let tcx = infcx.tcx;\n     let instantiated = tcx.predicates_of(impl1_def_id).instantiate(tcx, impl1_substs);\n     let impl1_predicates: Vec<_> = traits::elaborate_predicates_with_span(\n         tcx,\n@@ -343,19 +344,23 @@ fn check_predicates<'tcx>(\n \n     // Include the well-formed predicates of the type parameters of the impl.\n     for arg in tcx.impl_trait_ref(impl1_def_id).unwrap().substs {\n-        if let Some(obligations) = wf::obligations(\n-            infcx,\n-            tcx.param_env(impl1_def_id),\n-            tcx.hir().local_def_id_to_hir_id(impl1_def_id),\n-            0,\n-            arg,\n-            span,\n-        ) {\n+        tcx.infer_ctxt().enter(|ref infcx| {\n+            let obligations = wf::obligations(\n+                infcx,\n+                tcx.param_env(impl1_def_id),\n+                tcx.hir().local_def_id_to_hir_id(impl1_def_id),\n+                0,\n+                arg,\n+                span,\n+            )\n+            .unwrap();\n+\n+            assert!(!obligations.needs_infer());\n             impl2_predicates.extend(\n                 traits::elaborate_obligations(tcx, obligations)\n                     .map(|obligation| obligation.predicate),\n             )\n-        }\n+        })\n     }\n     impl2_predicates.extend(\n         traits::elaborate_predicates_with_span(tcx, always_applicable_traits)"}, {"sha": "389cc7beddd83a5ccfce4cc1dbd079ed970fd82b", "filename": "src/test/ui/associated-types/associated-types-for-unimpl-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `Self: Get` is not satisfied\n-  --> $DIR/associated-types-for-unimpl-trait.rs:10:40\n+  --> $DIR/associated-types-for-unimpl-trait.rs:10:5\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |                                        ^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |"}, {"sha": "1feaa612ee688714a363c578f9900edca268067f", "filename": "src/test/ui/associated-types/associated-types-no-suitable-bound.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-bound.stderr?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `T: Get` is not satisfied\n-  --> $DIR/associated-types-no-suitable-bound.rs:11:21\n+  --> $DIR/associated-types-no-suitable-bound.rs:11:5\n    |\n LL |     fn uhoh<T>(foo: <T as Get>::Value) {}\n-   |                     ^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `T`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `T`\n    |\n help: consider restricting type parameter `T`\n    |"}, {"sha": "cc3ed556115bc472b0b22e887e0ce8a040b051c1", "filename": "src/test/ui/associated-types/associated-types-no-suitable-supertrait-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `Self: Get` is not satisfied\n-  --> $DIR/associated-types-no-suitable-supertrait-2.rs:17:40\n+  --> $DIR/associated-types-no-suitable-supertrait-2.rs:17:5\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |                                        ^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |"}, {"sha": "18f2830d8b21504515f21599a3f13dc9e9328639", "filename": "src/test/ui/associated-types/associated-types-no-suitable-supertrait.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -1,14 +1,14 @@\n error[E0277]: the trait bound `(T, U): Get` is not satisfied\n-  --> $DIR/associated-types-no-suitable-supertrait.rs:22:40\n+  --> $DIR/associated-types-no-suitable-supertrait.rs:22:5\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <(T, U) as Get>::Value) {}\n-   |                                        ^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `(T, U)`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `(T, U)`\n \n error[E0277]: the trait bound `Self: Get` is not satisfied\n-  --> $DIR/associated-types-no-suitable-supertrait.rs:17:40\n+  --> $DIR/associated-types-no-suitable-supertrait.rs:17:5\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |                                        ^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |"}, {"sha": "66d59bccdbb68861f6c356e4b0c11569b5e09bb4", "filename": "src/test/ui/associated-types/associated-types-projection-to-unrelated-trait-in-method-without-default.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.stderr?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `Self: Get` is not satisfied\n-  --> $DIR/associated-types-projection-to-unrelated-trait-in-method-without-default.rs:10:40\n+  --> $DIR/associated-types-projection-to-unrelated-trait-in-method-without-default.rs:10:5\n    |\n LL |     fn okay<U:Get>(&self, foo: U, bar: <Self as Get>::Value);\n-   |                                        ^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |"}, {"sha": "62cf1f37a77139e3ce71dab1e8587d329bcba70f", "filename": "src/test/ui/associated-types/issue-59324.stderr", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fassociated-types%2Fissue-59324.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fassociated-types%2Fissue-59324.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-59324.stderr?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -45,16 +45,20 @@ LL | pub trait ThriftService<Bug: NotFoo + Foo>:\n    |                                     +++++\n \n error[E0277]: the trait bound `(): Foo` is not satisfied\n-  --> $DIR/issue-59324.rs:23:29\n+  --> $DIR/issue-59324.rs:23:1\n    |\n LL | fn with_factory<H>(factory: dyn ThriftService<()>) {}\n-   |                             ^^^^^^^^^^^^^^^^^^^^^ the trait `Foo` is not implemented for `()`\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Foo` is not implemented for `()`\n \n error[E0277]: the trait bound `Bug: Foo` is not satisfied\n-  --> $DIR/issue-59324.rs:16:8\n+  --> $DIR/issue-59324.rs:16:5\n    |\n-LL |     fn get_service(\n-   |        ^^^^^^^^^^^ the trait `Foo` is not implemented for `Bug`\n+LL | /     fn get_service(\n+LL | |\n+LL | |\n+LL | |         &self,\n+LL | |     ) -> Self::AssocType;\n+   | |_________________________^ the trait `Foo` is not implemented for `Bug`\n    |\n help: consider further restricting this bound\n    |"}, {"sha": "22c3470b61edeb955e8cb92b46c1d837c4c241aa", "filename": "src/test/ui/issues/issue-18611.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fissues%2Fissue-18611.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fissues%2Fissue-18611.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18611.stderr?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -1,8 +1,10 @@\n error[E0277]: the trait bound `isize: HasState` is not satisfied\n-  --> $DIR/issue-18611.rs:1:18\n+  --> $DIR/issue-18611.rs:1:1\n    |\n-LL | fn add_state(op: <isize as HasState>::State) {\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `HasState` is not implemented for `isize`\n+LL | / fn add_state(op: <isize as HasState>::State) {\n+LL | |\n+LL | | }\n+   | |_^ the trait `HasState` is not implemented for `isize`\n \n error: aborting due to previous error\n "}, {"sha": "ef62dece8364002a54f8cb4b760740c426bf57d7", "filename": "src/test/ui/issues/issue-20831-debruijn.stderr", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -1,8 +1,14 @@\n error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n-  --> $DIR/issue-20831-debruijn.rs:28:8\n+  --> $DIR/issue-20831-debruijn.rs:28:5\n    |\n-LL |     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n-   |        ^^^^^^^^^\n+LL | /     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n+LL | |         // Not obvious, but there is an implicit lifetime here -------^\n+LL | |\n+LL | |         //\n+...  |\n+LL | |         self.sub = t;\n+LL | |     }\n+   | |_____^\n    |\n note: first, the lifetime cannot outlive the anonymous lifetime defined here...\n   --> $DIR/issue-20831-debruijn.rs:28:58\n@@ -15,10 +21,16 @@ note: ...but the lifetime must also be valid for the lifetime `'a` as defined he\n LL | impl<'a> Publisher<'a> for MyStruct<'a> {\n    |      ^^\n note: ...so that the types are compatible\n-  --> $DIR/issue-20831-debruijn.rs:28:8\n+  --> $DIR/issue-20831-debruijn.rs:28:5\n    |\n-LL |     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n-   |        ^^^^^^^^^\n+LL | /     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n+LL | |         // Not obvious, but there is an implicit lifetime here -------^\n+LL | |\n+LL | |         //\n+...  |\n+LL | |         self.sub = t;\n+LL | |     }\n+   | |_____^\n    = note: expected `<MyStruct<'a> as Publisher<'_>>`\n               found `<MyStruct<'_> as Publisher<'_>>`\n "}, {"sha": "a2b0222d4f395466a8b7e9e4e903f34724f30883", "filename": "src/test/ui/issues/issue-35570.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fissues%2Fissue-35570.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fissues%2Fissue-35570.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35570.rs?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -6,7 +6,8 @@ trait Trait2<'a> {\n }\n \n fn _ice(param: Box<dyn for <'a> Trait1<<() as Trait2<'a>>::Ty>>) {\n-//~^ the trait bound `for<'a> (): Trait2<'a>` is not satisfied\n+    //~^ ERROR the trait bound `for<'a> (): Trait2<'a>` is not satisfied\n+    //~| ERROR the trait bound `for<'a> (): Trait2<'a>` is not satisfied\n     let _e: (usize, usize) = unsafe{mem::transmute(param)};\n }\n "}, {"sha": "ebc40f6786fd0a403bfe52554028f0cce3299195", "filename": "src/test/ui/issues/issue-35570.stderr", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fissues%2Fissue-35570.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fissues%2Fissue-35570.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35570.stderr?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -1,9 +1,19 @@\n+error[E0277]: the trait bound `for<'a> (): Trait2<'a>` is not satisfied\n+  --> $DIR/issue-35570.rs:8:1\n+   |\n+LL | / fn _ice(param: Box<dyn for <'a> Trait1<<() as Trait2<'a>>::Ty>>) {\n+LL | |\n+LL | |\n+LL | |     let _e: (usize, usize) = unsafe{mem::transmute(param)};\n+LL | | }\n+   | |_^ the trait `for<'a> Trait2<'a>` is not implemented for `()`\n+\n error[E0277]: the trait bound `for<'a> (): Trait2<'a>` is not satisfied\n   --> $DIR/issue-35570.rs:8:40\n    |\n LL | fn _ice(param: Box<dyn for <'a> Trait1<<() as Trait2<'a>>::Ty>>) {\n    |                                        ^^^^^^^^^^^^^^^^^^^^^^ the trait `for<'a> Trait2<'a>` is not implemented for `()`\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "6abe53127c3fb080cc64083a53995d62ff289312", "filename": "src/test/ui/nll/normalization-bounds-error.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fnll%2Fnormalization-bounds-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fnll%2Fnormalization-bounds-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fnormalization-bounds-error.stderr?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -1,8 +1,8 @@\n error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'d` due to conflicting requirements\n-  --> $DIR/normalization-bounds-error.rs:12:4\n+  --> $DIR/normalization-bounds-error.rs:12:1\n    |\n LL | fn visit_seq<'d, 'a: 'd>() -> <&'a () as Visitor<'d>>::Value {}\n-   |    ^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: first, the lifetime cannot outlive the lifetime `'d` as defined here...\n   --> $DIR/normalization-bounds-error.rs:12:14\n@@ -15,10 +15,10 @@ note: ...but the lifetime must also be valid for the lifetime `'a` as defined he\n LL | fn visit_seq<'d, 'a: 'd>() -> <&'a () as Visitor<'d>>::Value {}\n    |                  ^^\n note: ...so that the types are compatible\n-  --> $DIR/normalization-bounds-error.rs:12:4\n+  --> $DIR/normalization-bounds-error.rs:12:1\n    |\n LL | fn visit_seq<'d, 'a: 'd>() -> <&'a () as Visitor<'d>>::Value {}\n-   |    ^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: expected `Visitor<'d>`\n               found `Visitor<'_>`\n "}, {"sha": "1106352037a080a43e02905ddd3ebe207d13b03e", "filename": "src/test/ui/regions/regions-implied-bounds-projection-gap-hr-1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-hr-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-hr-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-hr-1.rs?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -19,7 +19,8 @@ trait Trait2<'a, 'b> {\n // since for it to be WF, we would need to know that `'y: 'x`, but we\n // do not infer that.\n fn callee<'x, 'y, T>(t: &'x dyn for<'z> Trait1< <T as Trait2<'y, 'z>>::Foo >)\n-    //~^ the trait bound `for<'z> T: Trait2<'y, 'z>` is not satisfied\n+    //~^ ERROR the trait bound `for<'z> T: Trait2<'y, 'z>` is not satisfied\n+    //~| ERROR the trait bound `for<'z> T: Trait2<'y, 'z>` is not satisfied\n {\n }\n "}, {"sha": "66f592c34dd070ada24e0e826d4dd25c017eac99", "filename": "src/test/ui/regions/regions-implied-bounds-projection-gap-hr-1.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-hr-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-hr-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-hr-1.stderr?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -1,3 +1,18 @@\n+error[E0277]: the trait bound `for<'z> T: Trait2<'y, 'z>` is not satisfied\n+  --> $DIR/regions-implied-bounds-projection-gap-hr-1.rs:21:1\n+   |\n+LL | / fn callee<'x, 'y, T>(t: &'x dyn for<'z> Trait1< <T as Trait2<'y, 'z>>::Foo >)\n+LL | |\n+LL | |\n+LL | | {\n+LL | | }\n+   | |_^ the trait `for<'z> Trait2<'y, 'z>` is not implemented for `T`\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn callee<'x, 'y, T: for<'z> Trait2<'y, 'z>>(t: &'x dyn for<'z> Trait1< <T as Trait2<'y, 'z>>::Foo >)\n+   |                    ++++++++++++++++++++++++\n+\n error[E0277]: the trait bound `for<'z> T: Trait2<'y, 'z>` is not satisfied\n   --> $DIR/regions-implied-bounds-projection-gap-hr-1.rs:21:49\n    |\n@@ -9,6 +24,6 @@ help: consider restricting type parameter `T`\n LL | fn callee<'x, 'y, T: for<'z> Trait2<'y, 'z>>(t: &'x dyn for<'z> Trait1< <T as Trait2<'y, 'z>>::Foo >)\n    |                    ++++++++++++++++++++++++\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "fd34a59d2bd6df2252a7a238d155f7d6499b2e19", "filename": "src/test/ui/specialization/min_specialization/issue-79224.stderr", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fissue-79224.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fissue-79224.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fissue-79224.stderr?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -1,8 +1,12 @@\n error[E0277]: the trait bound `B: Clone` is not satisfied\n-  --> $DIR/issue-79224.rs:18:17\n+  --> $DIR/issue-79224.rs:18:1\n    |\n-LL | impl<B: ?Sized> Display for Cow<'_, B> {\n-   |                 ^^^^^^^ the trait `Clone` is not implemented for `B`\n+LL | / impl<B: ?Sized> Display for Cow<'_, B> {\n+LL | |     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+LL | |         write!(f, \"foo\")\n+LL | |     }\n+LL | | }\n+   | |_^ the trait `Clone` is not implemented for `B`\n    |\n    = note: required for `B` to implement `ToOwned`\n help: consider further restricting this bound\n@@ -11,10 +15,12 @@ LL | impl<B: ?Sized + std::clone::Clone> Display for Cow<'_, B> {\n    |                +++++++++++++++++++\n \n error[E0277]: the trait bound `B: Clone` is not satisfied\n-  --> $DIR/issue-79224.rs:19:12\n+  --> $DIR/issue-79224.rs:19:5\n    |\n-LL |     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-   |            ^^^^^ the trait `Clone` is not implemented for `B`\n+LL | /     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+LL | |         write!(f, \"foo\")\n+LL | |     }\n+   | |_____^ the trait `Clone` is not implemented for `B`\n    |\n    = note: required for `B` to implement `ToOwned`\n help: consider further restricting this bound"}, {"sha": "5fcd090a8349fe181c5e4e252c83f8a479bee39b", "filename": "src/test/ui/traits/issue-91594.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Ftraits%2Fissue-91594.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Ftraits%2Fissue-91594.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-91594.stderr?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `Foo: HasComponent<()>` is not satisfied\n-  --> $DIR/issue-91594.rs:10:6\n+  --> $DIR/issue-91594.rs:10:1\n    |\n LL | impl HasComponent<<Foo as Component<Foo>>::Interface> for Foo {}\n-   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `HasComponent<()>` is not implemented for `Foo`\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `HasComponent<()>` is not implemented for `Foo`\n    |\n    = help: the trait `HasComponent<<Foo as Component<Foo>>::Interface>` is implemented for `Foo`\n note: required for `Foo` to implement `Component<Foo>`"}, {"sha": "78312a0910594105190791d871ecc48b7a1a1814", "filename": "src/test/ui/wf/wf-foreign-fn-decl-ret.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fwf%2Fwf-foreign-fn-decl-ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftest%2Fui%2Fwf%2Fwf-foreign-fn-decl-ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-foreign-fn-decl-ret.stderr?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `(): Foo` is not satisfied\n-  --> $DIR/wf-foreign-fn-decl-ret.rs:11:25\n+  --> $DIR/wf-foreign-fn-decl-ret.rs:11:5\n    |\n LL |     pub fn lint_me() -> <() as Foo>::Assoc;\n-   |                         ^^^^^^^^^^^^^^^^^^ the trait `Foo` is not implemented for `()`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Foo` is not implemented for `()`\n \n error[E0277]: the trait bound `u32: Unsatisfied` is not satisfied\n   --> $DIR/wf-foreign-fn-decl-ret.rs:14:32"}]}