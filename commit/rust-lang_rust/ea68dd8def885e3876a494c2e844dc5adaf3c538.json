{"sha": "ea68dd8def885e3876a494c2e844dc5adaf3c538", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhNjhkZDhkZWY4ODVlMzg3NmE0OTRjMmU4NDRkYzVhZGFmM2M1Mzg=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-14T09:57:47Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-14T09:57:47Z"}, "message": "Rollup merge of #33552 - dotdash:scfg, r=luqmana\n\n[MIR] Enhance the SimplifyCfg pass to merge consecutive blocks\n\nUpdated from #30238, including the changes suggested by @Aatch.", "tree": {"sha": "c6796a3819ef5a2b956a3a56dfba0c3df0b475c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6796a3819ef5a2b956a3a56dfba0c3df0b475c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea68dd8def885e3876a494c2e844dc5adaf3c538", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea68dd8def885e3876a494c2e844dc5adaf3c538", "html_url": "https://github.com/rust-lang/rust/commit/ea68dd8def885e3876a494c2e844dc5adaf3c538", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea68dd8def885e3876a494c2e844dc5adaf3c538/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36c4c6d433aadb3645ac790b5f2fcb830881c9c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/36c4c6d433aadb3645ac790b5f2fcb830881c9c9", "html_url": "https://github.com/rust-lang/rust/commit/36c4c6d433aadb3645ac790b5f2fcb830881c9c9"}, {"sha": "8ad6d27f87ad497f4f97fbaffd72a404303dd6b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ad6d27f87ad497f4f97fbaffd72a404303dd6b3", "html_url": "https://github.com/rust-lang/rust/commit/8ad6d27f87ad497f4f97fbaffd72a404303dd6b3"}], "stats": {"total": 183, "additions": 124, "deletions": 59}, "files": [{"sha": "526157a49c734252cb1417605bb48d40056233e8", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 124, "deletions": 59, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/ea68dd8def885e3876a494c2e844dc5adaf3c538/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea68dd8def885e3876a494c2e844dc5adaf3c538/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=ea68dd8def885e3876a494c2e844dc5adaf3c538", "patch": "@@ -8,73 +8,155 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc_data_structures::bitvec::BitVector;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use pretty;\n+use std::mem;\n \n use super::remove_dead_blocks::RemoveDeadBlocks;\n \n+use traversal;\n+\n pub struct SimplifyCfg;\n \n impl SimplifyCfg {\n     pub fn new() -> SimplifyCfg {\n         SimplifyCfg\n     }\n+}\n+\n+impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n+        simplify_branches(mir);\n+        RemoveDeadBlocks.run_pass(tcx, src, mir);\n+        merge_consecutive_blocks(mir);\n+        RemoveDeadBlocks.run_pass(tcx, src, mir);\n+        pretty::dump_mir(tcx, \"simplify_cfg\", &0, src, mir, None);\n+\n+        // FIXME: Should probably be moved into some kind of pass manager\n+        mir.basic_blocks.shrink_to_fit();\n+    }\n+}\n+\n+impl Pass for SimplifyCfg {}\n+\n+fn merge_consecutive_blocks(mir: &mut Mir) {\n+    // Build the precedecessor map for the MIR\n+    let mut pred_count = vec![0u32; mir.basic_blocks.len()];\n+    for (_, data) in traversal::preorder(mir) {\n+        if let Some(ref term) = data.terminator {\n+            for &tgt in term.successors().iter() {\n+                pred_count[tgt.index()] += 1;\n+            }\n+        }\n+    }\n+\n+    loop {\n+        let mut changed = false;\n+        let mut seen = BitVector::new(mir.basic_blocks.len());\n+        let mut worklist = vec![START_BLOCK];\n+        while let Some(bb) = worklist.pop() {\n+            // Temporarily take ownership of the terminator we're modifying to keep borrowck happy\n+            let mut terminator = mir.basic_block_data_mut(bb).terminator.take()\n+                .expect(\"invalid terminator state\");\n+\n+            // See if we can merge the target block into this one\n+            loop {\n+                let mut inner_change = false;\n \n-    fn remove_goto_chains(&self, mir: &mut Mir) -> bool {\n-        // Find the target at the end of the jump chain, return None if there is a loop\n-        fn final_target(mir: &Mir, mut target: BasicBlock) -> Option<BasicBlock> {\n-            // Keep track of already seen blocks to detect loops\n-            let mut seen: Vec<BasicBlock> = Vec::with_capacity(8);\n-\n-            while mir.basic_block_data(target).statements.is_empty() {\n-                // NB -- terminator may have been swapped with `None`\n-                // below, in which case we have a cycle and just want\n-                // to stop\n-                if let Some(ref terminator) = mir.basic_block_data(target).terminator {\n-                    match terminator.kind {\n-                        TerminatorKind::Goto { target: next } => {\n-                            if seen.contains(&next) {\n-                                return None;\n+                if let TerminatorKind::Goto { target } = terminator.kind {\n+                    // Don't bother trying to merge a block into itself\n+                    if target == bb {\n+                        break;\n+                    }\n+\n+                    let num_insts = mir.basic_block_data(target).statements.len();\n+                    match mir.basic_block_data(target).terminator().kind {\n+                        TerminatorKind::Goto { target: new_target } if num_insts == 0 => {\n+                            inner_change = true;\n+                            terminator.kind = TerminatorKind::Goto { target: new_target };\n+                            pred_count[target.index()] -= 1;\n+                            pred_count[new_target.index()] += 1;\n+                        }\n+                        _ if pred_count[target.index()] == 1 => {\n+                            inner_change = true;\n+                            let mut stmts = Vec::new();\n+                            {\n+                                let target_data = mir.basic_block_data_mut(target);\n+                                mem::swap(&mut stmts, &mut target_data.statements);\n+                                mem::swap(&mut terminator, target_data.terminator_mut());\n                             }\n-                            seen.push(next);\n-                            target = next;\n+\n+                            mir.basic_block_data_mut(bb).statements.append(&mut stmts);\n                         }\n-                        _ => break\n+                        _ => {}\n+                    };\n+                }\n+\n+                for target in terminator.successors_mut() {\n+                    let new_target = match final_target(mir, *target) {\n+                        Some(new_target) => new_target,\n+                        None if mir.basic_block_data(bb).statements.is_empty() => bb,\n+                        None => continue\n+                    };\n+                    if *target != new_target {\n+                        inner_change = true;\n+                        pred_count[target.index()] -= 1;\n+                        pred_count[new_target.index()] += 1;\n+                        *target = new_target;\n                     }\n-                } else {\n-                    break\n+                }\n+\n+                changed |= inner_change;\n+                if !inner_change {\n+                    break;\n                 }\n             }\n \n-            Some(target)\n+            mir.basic_block_data_mut(bb).terminator = Some(terminator);\n+\n+            for succ in mir.basic_block_data(bb).terminator().successors().iter() {\n+                if seen.insert(succ.index()) {\n+                    worklist.push(*succ);\n+                }\n+            }\n         }\n \n-        let mut changed = false;\n-        for bb in mir.all_basic_blocks() {\n-            // Temporarily take ownership of the terminator we're modifying to keep borrowck happy\n-            let mut terminator = mir.basic_block_data_mut(bb).terminator.take()\n-                                    .expect(\"invalid terminator state\");\n-\n-            debug!(\"remove_goto_chains: bb={:?} terminator={:?}\", bb, terminator);\n-\n-            for target in terminator.successors_mut() {\n-                let new_target = match final_target(mir, *target) {\n-                    Some(new_target) => new_target,\n-                    None if mir.basic_block_data(bb).statements.is_empty() => bb,\n-                    None => continue\n-                };\n-                changed |= *target != new_target;\n-                *target = new_target;\n+        if !changed {\n+            break;\n+        }\n+    }\n+}\n+\n+// Find the target at the end of the jump chain, return None if there is a loop\n+fn final_target(mir: &Mir, mut target: BasicBlock) -> Option<BasicBlock> {\n+    // Keep track of already seen blocks to detect loops\n+    let mut seen: Vec<BasicBlock> = Vec::with_capacity(8);\n+\n+    while mir.basic_block_data(target).statements.is_empty() {\n+        // NB -- terminator may have been swapped with `None` in\n+        // merge_consecutive_blocks, in which case we have a cycle and just want\n+        // to stop\n+        match mir.basic_block_data(target).terminator {\n+            Some(Terminator { kind: TerminatorKind::Goto { target: next }, .. }) =>  {\n+                if seen.contains(&next) {\n+                    return None;\n+                }\n+                seen.push(next);\n+                target = next;\n             }\n-            mir.basic_block_data_mut(bb).terminator = Some(terminator);\n+            _ => break\n         }\n-        changed\n     }\n \n-    fn simplify_branches(&self, mir: &mut Mir) -> bool {\n+    Some(target)\n+}\n+\n+fn simplify_branches(mir: &mut Mir) {\n+    loop {\n         let mut changed = false;\n \n         for bb in mir.all_basic_blocks() {\n@@ -106,25 +188,8 @@ impl SimplifyCfg {\n             }\n         }\n \n-        changed\n-    }\n-}\n-\n-impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    src: MirSource, mir: &mut Mir<'tcx>) {\n-        let mut counter = 0;\n-        let mut changed = true;\n-        while changed {\n-            pretty::dump_mir(tcx, \"simplify_cfg\", &counter, src, mir, None);\n-            counter += 1;\n-            changed = self.simplify_branches(mir);\n-            changed |= self.remove_goto_chains(mir);\n-            RemoveDeadBlocks.run_pass(tcx, src, mir);\n+        if !changed {\n+            break;\n         }\n-        // FIXME: Should probably be moved into some kind of pass manager\n-        mir.basic_blocks.shrink_to_fit();\n     }\n }\n-\n-impl Pass for SimplifyCfg {}"}]}