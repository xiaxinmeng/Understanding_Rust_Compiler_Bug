{"sha": "c10474525526a275e6bf71a69a9a6d36b294c876", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMDQ3NDUyNTUyNmEyNzVlNmJmNzFhNjlhOWE2ZDM2YjI5NGM4NzY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-10T18:14:24Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-10T18:15:36Z"}, "message": "Make moves explicit in vec\n\nI'm continuing to make moves explicit, despite #3413, because that\nseems like the most reliable way to make these changes. Once I've made\nall the moves explicit, the test for #3413 will be that I can remove them.", "tree": {"sha": "67d426e106a089bc64ede97c40e31ab487adde3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67d426e106a089bc64ede97c40e31ab487adde3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c10474525526a275e6bf71a69a9a6d36b294c876", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c10474525526a275e6bf71a69a9a6d36b294c876", "html_url": "https://github.com/rust-lang/rust/commit/c10474525526a275e6bf71a69a9a6d36b294c876", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c10474525526a275e6bf71a69a9a6d36b294c876/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5cb6cc1237caeaa998a632c0dcf0bb067e6afef", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5cb6cc1237caeaa998a632c0dcf0bb067e6afef", "html_url": "https://github.com/rust-lang/rust/commit/e5cb6cc1237caeaa998a632c0dcf0bb067e6afef"}], "stats": {"total": 104, "additions": 52, "deletions": 52}, "files": [{"sha": "0907041809a68ee42b27370fc6bd7d648d44c340", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/c10474525526a275e6bf71a69a9a6d36b294c876/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c10474525526a275e6bf71a69a9a6d36b294c876/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=c10474525526a275e6bf71a69a9a6d36b294c876", "patch": "@@ -190,7 +190,7 @@ pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n     let mut i: uint = 0u;\n     while i < n_elts unsafe { unsafe::set(v, i, op(i)); i += 1u; }\n     unsafe { unsafe::set_len(v, n_elts); }\n-    return v;\n+    move v\n }\n \n /**\n@@ -207,7 +207,7 @@ pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> ~[T] {\n         while i < n_elts { unsafe::set(v, i, t); i += 1u; }\n         unsafe { unsafe::set_len(v, n_elts); }\n     }\n-    return v;\n+    move v\n }\n \n /// Creates a new unique vector with the same contents as the slice\n@@ -231,8 +231,8 @@ pure fn from_slice<T: Copy>(t: &[T]) -> ~[T] {\n pure fn build_sized<A>(size: uint, builder: fn(push: pure fn(+A))) -> ~[A] {\n     let mut vec = ~[];\n     unchecked { reserve(vec, size); }\n-    builder(|+x| unchecked { push(vec, x) });\n-    return vec;\n+    builder(|+x| unchecked { push(vec, move x) });\n+    move vec\n }\n \n /**\n@@ -325,7 +325,7 @@ pure fn slice<T: Copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n     unchecked {\n         for uint::range(start, end) |i| { vec::push(result, v[i]) }\n     }\n-    return result;\n+    move result\n }\n \n /// Return a slice that points into another slice.\n@@ -381,7 +381,7 @@ fn split<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n         }\n     }\n     push(result, slice(v, start, ln));\n-    result\n+    move result\n }\n \n /**\n@@ -407,7 +407,7 @@ fn splitn<T: Copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n         }\n     }\n     push(result, slice(v, start, ln));\n-    result\n+    move result\n }\n \n /**\n@@ -458,7 +458,7 @@ fn rsplitn<T: Copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     }\n     push(result, slice(v, 0u, end));\n     reverse(result);\n-    return from_mut(result);\n+    move from_mut(move result)\n }\n \n // Mutators\n@@ -479,18 +479,18 @@ fn shift<T>(&v: ~[T]) -> T {\n \n             for uint::range(1, ln) |i| {\n                 let r <- *ptr::offset(vv, i);\n-                push(v, r);\n+                push(v, move r);\n             }\n         }\n         unsafe::set_len(vv, 0);\n \n-        rr\n+        move rr\n     }\n }\n \n /// Prepend an element to the vector\n fn unshift<T>(&v: ~[T], +x: T) {\n-    let mut vv = ~[x];\n+    let mut vv = ~[move x];\n     v <-> vv;\n     while len(vv) > 0 {\n         push(v, shift(vv));\n@@ -501,7 +501,7 @@ fn consume<T>(+v: ~[T], f: fn(uint, +T)) unsafe {\n     do as_buf(v) |p, ln| {\n         for uint::range(0, ln) |i| {\n             let x <- *ptr::offset(p, i);\n-            f(i, x);\n+            f(i, move x);\n         }\n     }\n \n@@ -512,7 +512,7 @@ fn consume_mut<T>(+v: ~[mut T], f: fn(uint, +T)) unsafe {\n     do as_buf(v) |p, ln| {\n         for uint::range(0, ln) |i| {\n             let x <- *ptr::offset(p, i);\n-            f(i, x);\n+            f(i, move x);\n         }\n     }\n \n@@ -529,7 +529,7 @@ fn pop<T>(&v: ~[const T]) -> T {\n     unsafe {\n         let val <- *valptr;\n         unsafe::set_len(v, ln - 1u);\n-        val\n+        move val\n     }\n }\n \n@@ -552,7 +552,7 @@ fn swap_remove<T>(&v: ~[const T], index: uint) -> T {\n             *valptr <-> val;\n         }\n         unsafe::set_len(v, ln - 1);\n-        val\n+        move val\n     }\n }\n \n@@ -563,10 +563,10 @@ fn push<T>(&v: ~[const T], +initval: T) {\n         let repr: **unsafe::VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n         let fill = (**repr).fill;\n         if (**repr).alloc > fill {\n-            push_fast(v, initval);\n+            push_fast(v, move initval);\n         }\n         else {\n-            push_slow(v, initval);\n+            push_slow(v, move initval);\n         }\n     }\n }\n@@ -585,7 +585,7 @@ unsafe fn push_fast<T>(&v: ~[const T], +initval: T) {\n #[inline(never)]\n fn push_slow<T>(&v: ~[const T], +initval: T) {\n     reserve_at_least(v, v.len() + 1u);\n-    unsafe { push_fast(v, initval) }\n+    unsafe { push_fast(v, move initval) }\n }\n \n #[inline(always)]\n@@ -604,7 +604,7 @@ fn push_all_move<T>(&v: ~[const T], -rhs: ~[const T]) {\n         do as_buf(rhs) |p, len| {\n             for uint::range(0, len) |i| {\n                 let x <- *ptr::offset(p, i);\n-                push(v, x);\n+                push(v, move x);\n             }\n         }\n         unsafe::set_len(rhs, 0);\n@@ -632,14 +632,14 @@ pure fn append<T: Copy>(+lhs: ~[T], rhs: &[const T]) -> ~[T] {\n     unchecked {\n         push_all(v, rhs);\n     }\n-    return v;\n+    move v\n }\n \n #[inline(always)]\n pure fn append_one<T>(+lhs: ~[T], +x: T) -> ~[T] {\n     let mut v <- lhs;\n-    unchecked { push(v, x); }\n-    v\n+    unchecked { push(v, move x); }\n+    move v\n }\n \n #[inline(always)]\n@@ -659,7 +659,7 @@ pure fn append_mut<T: Copy>(lhs: &[mut T], rhs: &[const T]) -> ~[mut T] {\n         }\n         i += 1u;\n     }\n-    return v;\n+    move v\n }\n \n /**\n@@ -717,23 +717,23 @@ pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> ~[U] {\n     let mut result = ~[];\n     unchecked{reserve(result, len(v));}\n     for each(v) |elem| { unsafe { push(result, f(elem)); } }\n-    return result;\n+    move result\n }\n \n fn map_consume<T, U>(+v: ~[T], f: fn(+T) -> U) -> ~[U] {\n     let mut result = ~[];\n-    do consume(v) |_i, x| {\n-        vec::push(result, f(x));\n+    do consume(move v) |_i, x| {\n+        vec::push(result, f(move x));\n     }\n-    result\n+    move result\n }\n \n /// Apply a function to each element of a vector and return the results\n pure fn mapi<T, U>(v: &[T], f: fn(uint, T) -> U) -> ~[U] {\n     let mut result = ~[];\n     unchecked{reserve(result, len(v));}\n     for eachi(v) |i, elem| { unsafe { push(result, f(i, elem)); } }\n-    return result;\n+    move result\n }\n \n /**\n@@ -743,7 +743,7 @@ pure fn mapi<T, U>(v: &[T], f: fn(uint, T) -> U) -> ~[U] {\n pure fn flat_map<T, U>(v: &[T], f: fn(T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n     for each(v) |elem| { unchecked{ push_all_move(result, f(elem)); } }\n-    return result;\n+    move result\n }\n \n /// Apply a function to each pair of elements and return the results\n@@ -757,7 +757,7 @@ pure fn map2<T: Copy, U: Copy, V>(v0: &[T], v1: &[U],\n         unsafe { push(u, f(copy v0[i], copy v1[i])) };\n         i += 1u;\n     }\n-    return u;\n+    move u\n }\n \n /**\n@@ -775,7 +775,7 @@ pure fn filter_map<T, U: Copy>(v: &[T], f: fn(T) -> Option<U>)\n           Some(result_elem) => unsafe { push(result, result_elem); }\n         }\n     }\n-    return result;\n+    move result\n }\n \n /**\n@@ -790,7 +790,7 @@ pure fn filter<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[T] {\n     for each(v) |elem| {\n         if f(elem) { unsafe { push(result, elem); } }\n     }\n-    return result;\n+    move result\n }\n \n /**\n@@ -801,7 +801,7 @@ pure fn filter<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[T] {\n pure fn concat<T: Copy>(v: &[~[T]]) -> ~[T] {\n     let mut r = ~[];\n     for each(v) |inner| { unsafe { push_all(r, inner); } }\n-    return r;\n+    move r\n }\n \n /// Concatenate a vector of vectors, placing a given separator between each\n@@ -812,7 +812,7 @@ pure fn connect<T: Copy>(v: &[~[T]], sep: T) -> ~[T] {\n         if first { first = false; } else { unsafe { push(r, sep); } }\n         unchecked { push_all(r, inner) };\n     }\n-    return r;\n+    move r\n }\n \n /// Reduce a vector from left to right\n@@ -1037,7 +1037,7 @@ pure fn unzip_slice<T: Copy, U: Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n             vec::push(bs, b);\n         }\n     }\n-    return (as_, bs);\n+    return (move as_, move bs);\n }\n \n /**\n@@ -1051,13 +1051,13 @@ pure fn unzip_slice<T: Copy, U: Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n pure fn unzip<T,U>(+v: ~[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[], us = ~[];\n     unchecked {\n-        do consume(v) |_i, p| {\n-            let (a,b) = p;\n-            push(ts, a);\n-            push(us, b);\n+        do consume(move v) |_i, p| {\n+            let (a,b) = move p;\n+            push(ts, move a);\n+            push(us, move b);\n         }\n     }\n-    (ts, us)\n+    (move ts, move us)\n }\n \n /**\n@@ -1070,7 +1070,7 @@ pure fn zip_slice<T: Copy, U: Copy>(v: &[const T], u: &[const U])\n     let mut i = 0u;\n     assert sz == len(u);\n     while i < sz unchecked { vec::push(zipped, (v[i], u[i])); i += 1u; }\n-    return zipped;\n+    move zipped\n }\n \n /**\n@@ -1080,15 +1080,15 @@ pure fn zip_slice<T: Copy, U: Copy>(v: &[const T], u: &[const U])\n  * i-th elements from each of the input vectors.\n  */\n pure fn zip<T, U>(+v: ~[const T], +u: ~[const U]) -> ~[(T, U)] {\n-    let mut v = v, u = u, i = len(v);\n+    let mut v = move v, u = move u, i = len(v);\n     assert i == len(u);\n     let mut w = ~[mut];\n     while i > 0 {\n         unchecked { push(w, (pop(v),pop(u))); }\n         i -= 1;\n     }\n     unchecked { reverse(w); }\n-    from_mut(w)\n+    from_mut(move w)\n }\n \n /**\n@@ -1116,12 +1116,12 @@ fn reverse<T>(v: ~[mut T]) {\n pure fn reversed<T: Copy>(v: &[const T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n     let mut i = len::<T>(v);\n-    if i == 0u { return rs; } else { i -= 1u; }\n+    if i == 0 { return (move rs); } else { i -= 1; }\n     unchecked {\n-        while i != 0u { vec::push(rs, v[i]); i -= 1u; }\n+        while i != 0 { vec::push(rs, v[i]); i -= 1; }\n         vec::push(rs, v[0]);\n     }\n-    return rs;\n+    move rs\n }\n \n /**\n@@ -1346,7 +1346,7 @@ pure fn windowed<TT: Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n             vec::push(ww, vec::slice(xx, ii, ii+nn));\n         }\n     });\n-    return ww;\n+    move ww\n }\n \n /**\n@@ -1617,7 +1617,7 @@ impl<T> &[T]: ImmutableVector<T> {\n             push(r, f(&self[i]));\n             i += 1;\n         }\n-        r\n+        move r\n     }\n \n     /**\n@@ -1730,7 +1730,7 @@ mod unsafe {\n         reserve(dst, elts);\n         set_len(dst, elts);\n         as_buf(dst, |p_dst, _len_dst| ptr::memcpy(p_dst, ptr, elts));\n-        dst\n+        move dst\n     }\n \n     /**\n@@ -1794,12 +1794,12 @@ mod unsafe {\n      */\n     #[inline(always)]\n     unsafe fn set<T>(v: &[mut T], i: uint, +val: T) {\n-        let mut box = Some(val);\n+        let mut box = Some(move val);\n         do as_mut_buf(v) |p, _len| {\n             let mut box2 = None;\n             box2 <-> box;\n             rusti::move_val_init(*ptr::mut_offset(p, i),\n-                                 option::unwrap(box2));\n+                                 option::unwrap(move box2));\n         }\n     }\n \n@@ -1926,7 +1926,7 @@ impl<A> &[const A]: iter::ExtendedIter<A> {\n     pure fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n     pure fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }\n     pure fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B {\n-        iter::foldl(self, b0, blk)\n+        iter::foldl(self, move b0, blk)\n     }\n }\n "}]}