{"sha": "4e515c14af8598f5e0d8e62847741523e7c14ba5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNTE1YzE0YWY4NTk4ZjVlMGQ4ZTYyODQ3NzQxNTIzZTdjMTRiYTU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-05T18:20:04Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-05T18:20:04Z"}, "message": "doc: Split out the FFI part of the tutorial\n\nThe tutorial should perhaps contain an FFI section, but this one is too long.", "tree": {"sha": "e719e126f52f1445fbbf29ed8a99caee52464747", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e719e126f52f1445fbbf29ed8a99caee52464747"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e515c14af8598f5e0d8e62847741523e7c14ba5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e515c14af8598f5e0d8e62847741523e7c14ba5", "html_url": "https://github.com/rust-lang/rust/commit/4e515c14af8598f5e0d8e62847741523e7c14ba5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e515c14af8598f5e0d8e62847741523e7c14ba5/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c9c32782d7dddadfbb9dd9dd149b33e28308439", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c9c32782d7dddadfbb9dd9dd149b33e28308439", "html_url": "https://github.com/rust-lang/rust/commit/1c9c32782d7dddadfbb9dd9dd149b33e28308439"}], "stats": {"total": 490, "additions": 250, "deletions": 240}, "files": [{"sha": "ce9eaf130faee92a9f6cf1283f15ad49b1d4f10d", "filename": "doc/tutorial-ffi.md", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/4e515c14af8598f5e0d8e62847741523e7c14ba5/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e515c14af8598f5e0d8e62847741523e7c14ba5/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=4e515c14af8598f5e0d8e62847741523e7c14ba5", "patch": "@@ -0,0 +1,240 @@\n+# Interacting with foreign code\n+\n+One of Rust's aims, as a system programming language, is to\n+interoperate well with C code.\n+\n+We'll start with an example. It's a bit bigger than usual, and\n+contains a number of new concepts. We'll go over it one piece at a\n+time.\n+\n+This is a program that uses OpenSSL's `SHA1` function to compute the\n+hash of its first command-line argument, which it then converts to a\n+hexadecimal string and prints to standard output. If you have the\n+OpenSSL libraries installed, it should 'just work'.\n+\n+~~~~ {.xfail-test}\n+use std;\n+import libc::c_uint;\n+\n+extern mod crypto {\n+    fn SHA1(src: *u8, sz: c_uint, out: *u8) -> *u8;\n+}\n+\n+fn as_hex(data: ~[u8]) -> ~str {\n+    let mut acc = ~\"\";\n+    for data.each |byte| { acc += fmt!(\"%02x\", byte as uint); }\n+    return acc;\n+}\n+\n+fn sha1(data: ~str) -> ~str unsafe {\n+    let bytes = str::to_bytes(data);\n+    let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n+                            vec::len(bytes) as c_uint, ptr::null());\n+    return as_hex(vec::unsafe::from_buf(hash, 20u));\n+}\n+\n+fn main(args: ~[~str]) {\n+    io::println(sha1(args[1]));\n+}\n+~~~~\n+\n+## Foreign modules\n+\n+Before we can call `SHA1`, we have to declare it. That is what this\n+part of the program is responsible for:\n+\n+~~~~ {.xfail-test}\n+extern mod crypto {\n+    fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n+}\n+~~~~\n+\n+An `extern` module declaration containing function signatures introduces\n+the functions listed as _foreign functions_, that are implemented in some\n+other language (usually C) and accessed through Rust's foreign function\n+interface (FFI). An extern module like this is called a foreign module, and\n+implicitly tells the compiler to link with a library with the same name as\n+the module, and that it will find the foreign functions in that library.\n+\n+In this case, it'll change the name `crypto` to a shared library name\n+in a platform-specific way (`libcrypto.so` on Linux, for example), and\n+link that in. If you want the module to have a different name from the\n+actual library, you can use the `\"link_name\"` attribute, like:\n+\n+~~~~ {.xfail-test}\n+#[link_name = \"crypto\"]\n+extern mod something {\n+    fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n+}\n+~~~~\n+\n+## Foreign calling conventions\n+\n+Most foreign code will be C code, which usually uses the `cdecl` calling\n+convention, so that is what Rust uses by default when calling foreign\n+functions. Some foreign functions, most notably the Windows API, use other\n+calling conventions, so Rust provides a way to hint to the compiler which\n+is expected by using the `\"abi\"` attribute:\n+\n+~~~~\n+#[cfg(target_os = \"win32\")]\n+#[abi = \"stdcall\"]\n+extern mod kernel32 {\n+    fn SetEnvironmentVariableA(n: *u8, v: *u8) -> int;\n+}\n+~~~~\n+\n+The `\"abi\"` attribute applies to a foreign module (it can not be applied\n+to a single function within a module), and must be either `\"cdecl\"`\n+or `\"stdcall\"`. Other conventions may be defined in the future.\n+\n+## Unsafe pointers\n+\n+The foreign `SHA1` function is declared to take three arguments, and\n+return a pointer.\n+\n+~~~~ {.xfail-test}\n+# extern mod crypto {\n+fn SHA1(src: *u8, sz: libc::c_uint, out: *u8) -> *u8;\n+# }\n+~~~~\n+\n+When declaring the argument types to a foreign function, the Rust\n+compiler has no way to check whether your declaration is correct, so\n+you have to be careful. If you get the number or types of the\n+arguments wrong, you're likely to get a segmentation fault. Or,\n+probably even worse, your code will work on one platform, but break on\n+another.\n+\n+In this case, `SHA1` is defined as taking two `unsigned char*`\n+arguments and one `unsigned long`. The rust equivalents are `*u8`\n+unsafe pointers and an `uint` (which, like `unsigned long`, is a\n+machine-word-sized type).\n+\n+Unsafe pointers can be created through various functions in the\n+standard lib, usually with `unsafe` somewhere in their name. You can\n+dereference an unsafe pointer with `*` operator, but use\n+caution\u2014unlike Rust's other pointer types, unsafe pointers are\n+completely unmanaged, so they might point at invalid memory, or be\n+null pointers.\n+\n+## Unsafe blocks\n+\n+The `sha1` function is the most obscure part of the program.\n+\n+~~~~\n+# mod crypto { fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8 { out } }\n+# fn as_hex(data: ~[u8]) -> ~str { ~\"hi\" }\n+fn sha1(data: ~str) -> ~str {\n+    unsafe {\n+        let bytes = str::to_bytes(data);\n+        let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n+                                vec::len(bytes), ptr::null());\n+        return as_hex(vec::unsafe::from_buf(hash, 20u));\n+    }\n+}\n+~~~~\n+\n+Firstly, what does the `unsafe` keyword at the top of the function\n+mean? `unsafe` is a block modifier\u2014it declares the block following it\n+to be known to be unsafe.\n+\n+Some operations, like dereferencing unsafe pointers or calling\n+functions that have been marked unsafe, are only allowed inside unsafe\n+blocks. With the `unsafe` keyword, you're telling the compiler 'I know\n+what I'm doing'. The main motivation for such an annotation is that\n+when you have a memory error (and you will, if you're using unsafe\n+constructs), you have some idea where to look\u2014it will most likely be\n+caused by some unsafe code.\n+\n+Unsafe blocks isolate unsafety. Unsafe functions, on the other hand,\n+advertise it to the world. An unsafe function is written like this:\n+\n+~~~~\n+unsafe fn kaboom() { ~\"I'm harmless!\"; }\n+~~~~\n+\n+This function can only be called from an unsafe block or another\n+unsafe function.\n+\n+## Pointer fiddling\n+\n+The standard library defines a number of helper functions for dealing\n+with unsafe data, casting between types, and generally subverting\n+Rust's safety mechanisms.\n+\n+Let's look at our `sha1` function again.\n+\n+~~~~\n+# mod crypto { fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8 { out } }\n+# fn as_hex(data: ~[u8]) -> ~str { ~\"hi\" }\n+# fn x(data: ~str) -> ~str {\n+# unsafe {\n+let bytes = str::to_bytes(data);\n+let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n+                        vec::len(bytes), ptr::null());\n+return as_hex(vec::unsafe::from_buf(hash, 20u));\n+# }\n+# }\n+~~~~\n+\n+The `str::to_bytes` function is perfectly safe: it converts a string to\n+a `[u8]`. This byte array is then fed to `vec::unsafe::to_ptr`, which\n+returns an unsafe pointer to its contents.\n+\n+This pointer will become invalid as soon as the vector it points into\n+is cleaned up, so you should be very careful how you use it. In this\n+case, the local variable `bytes` outlives the pointer, so we're good.\n+\n+Passing a null pointer as the third argument to `SHA1` makes it use a\n+static buffer, and thus save us the effort of allocating memory\n+ourselves. `ptr::null` is a generic function that will return an\n+unsafe null pointer of the correct type (Rust generics are awesome\n+like that\u2014they can take the right form depending on the type that they\n+are expected to return).\n+\n+Finally, `vec::unsafe::from_buf` builds up a new `[u8]` from the\n+unsafe pointer that was returned by `SHA1`. SHA1 digests are always\n+twenty bytes long, so we can pass `20u` for the length of the new\n+vector.\n+\n+## Passing structures\n+\n+C functions often take pointers to structs as arguments. Since Rust\n+records are binary-compatible with C structs, Rust programs can call\n+such functions directly.\n+\n+This program uses the POSIX function `gettimeofday` to get a\n+microsecond-resolution timer.\n+\n+~~~~\n+use std;\n+import libc::c_ulonglong;\n+\n+type timeval = {mut tv_sec: c_ulonglong,\n+                mut tv_usec: c_ulonglong};\n+#[nolink]\n+extern mod lib_c {\n+    fn gettimeofday(tv: *timeval, tz: *()) -> i32;\n+}\n+fn unix_time_in_microseconds() -> u64 unsafe {\n+    let x = {mut tv_sec: 0 as c_ulonglong, mut tv_usec: 0 as c_ulonglong};\n+    lib_c::gettimeofday(ptr::addr_of(x), ptr::null());\n+    return (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\n+}\n+\n+# fn main() { assert fmt!(\"%?\", unix_time_in_microseconds()) != ~\"\"; }\n+~~~~\n+\n+The `#[nolink]` attribute indicates that there's no foreign library to\n+link in. The standard C library is already linked with Rust programs.\n+\n+A `timeval`, in C, is a struct with two 32-bit integers. Thus, we\n+define a record type with the same contents, and declare\n+`gettimeofday` to take a pointer to such a record.\n+\n+The second argument to `gettimeofday` (the time zone) is not used by\n+this program, so it simply declares it to be a pointer to the nil\n+type. Since all null pointers have the same representation regardless of\n+their referent type, this is safe.\n+"}, {"sha": "96539ea8e900d4da8b18cd23ee3221bfe8c532df", "filename": "doc/tutorial.md", "status": "modified", "additions": 0, "deletions": 240, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/4e515c14af8598f5e0d8e62847741523e7c14ba5/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e515c14af8598f5e0d8e62847741523e7c14ba5/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=4e515c14af8598f5e0d8e62847741523e7c14ba5", "patch": "@@ -2071,246 +2071,6 @@ type, and the receiver type is a named type (i.e., an enum or a\n class); [single-variant enums](#single_variant_enum) are a common\n choice.\n \n-# Interacting with foreign code\n-\n-One of Rust's aims, as a system programming language, is to\n-interoperate well with C code.\n-\n-We'll start with an example. It's a bit bigger than usual, and\n-contains a number of new concepts. We'll go over it one piece at a\n-time.\n-\n-This is a program that uses OpenSSL's `SHA1` function to compute the\n-hash of its first command-line argument, which it then converts to a\n-hexadecimal string and prints to standard output. If you have the\n-OpenSSL libraries installed, it should 'just work'.\n-\n-~~~~ {.xfail-test}\n-use std;\n-import libc::c_uint;\n-\n-extern mod crypto {\n-    fn SHA1(src: *u8, sz: c_uint, out: *u8) -> *u8;\n-}\n-\n-fn as_hex(data: ~[u8]) -> ~str {\n-    let mut acc = ~\"\";\n-    for data.each |byte| { acc += fmt!(\"%02x\", byte as uint); }\n-    return acc;\n-}\n-\n-fn sha1(data: ~str) -> ~str unsafe {\n-    let bytes = str::to_bytes(data);\n-    let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n-                            vec::len(bytes) as c_uint, ptr::null());\n-    return as_hex(vec::unsafe::from_buf(hash, 20u));\n-}\n-\n-fn main(args: ~[~str]) {\n-    io::println(sha1(args[1]));\n-}\n-~~~~\n-\n-## Foreign modules\n-\n-Before we can call `SHA1`, we have to declare it. That is what this\n-part of the program is responsible for:\n-\n-~~~~ {.xfail-test}\n-extern mod crypto {\n-    fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n-}\n-~~~~\n-\n-An `extern` module declaration containing function signatures introduces\n-the functions listed as _foreign functions_, that are implemented in some\n-other language (usually C) and accessed through Rust's foreign function\n-interface (FFI). An extern module like this is called a foreign module, and\n-implicitly tells the compiler to link with a library with the same name as\n-the module, and that it will find the foreign functions in that library.\n-\n-In this case, it'll change the name `crypto` to a shared library name\n-in a platform-specific way (`libcrypto.so` on Linux, for example), and\n-link that in. If you want the module to have a different name from the\n-actual library, you can use the `\"link_name\"` attribute, like:\n-\n-~~~~ {.xfail-test}\n-#[link_name = \"crypto\"]\n-extern mod something {\n-    fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n-}\n-~~~~\n-\n-## Foreign calling conventions\n-\n-Most foreign code will be C code, which usually uses the `cdecl` calling\n-convention, so that is what Rust uses by default when calling foreign\n-functions. Some foreign functions, most notably the Windows API, use other\n-calling conventions, so Rust provides a way to hint to the compiler which\n-is expected by using the `\"abi\"` attribute:\n-\n-~~~~\n-#[cfg(target_os = \"win32\")]\n-#[abi = \"stdcall\"]\n-extern mod kernel32 {\n-    fn SetEnvironmentVariableA(n: *u8, v: *u8) -> int;\n-}\n-~~~~\n-\n-The `\"abi\"` attribute applies to a foreign module (it can not be applied\n-to a single function within a module), and must be either `\"cdecl\"`\n-or `\"stdcall\"`. Other conventions may be defined in the future.\n-\n-## Unsafe pointers\n-\n-The foreign `SHA1` function is declared to take three arguments, and\n-return a pointer.\n-\n-~~~~ {.xfail-test}\n-# extern mod crypto {\n-fn SHA1(src: *u8, sz: libc::c_uint, out: *u8) -> *u8;\n-# }\n-~~~~\n-\n-When declaring the argument types to a foreign function, the Rust\n-compiler has no way to check whether your declaration is correct, so\n-you have to be careful. If you get the number or types of the\n-arguments wrong, you're likely to get a segmentation fault. Or,\n-probably even worse, your code will work on one platform, but break on\n-another.\n-\n-In this case, `SHA1` is defined as taking two `unsigned char*`\n-arguments and one `unsigned long`. The rust equivalents are `*u8`\n-unsafe pointers and an `uint` (which, like `unsigned long`, is a\n-machine-word-sized type).\n-\n-Unsafe pointers can be created through various functions in the\n-standard lib, usually with `unsafe` somewhere in their name. You can\n-dereference an unsafe pointer with `*` operator, but use\n-caution\u2014unlike Rust's other pointer types, unsafe pointers are\n-completely unmanaged, so they might point at invalid memory, or be\n-null pointers.\n-\n-## Unsafe blocks\n-\n-The `sha1` function is the most obscure part of the program.\n-\n-~~~~\n-# mod crypto { fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8 { out } }\n-# fn as_hex(data: ~[u8]) -> ~str { ~\"hi\" }\n-fn sha1(data: ~str) -> ~str {\n-    unsafe {\n-        let bytes = str::to_bytes(data);\n-        let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n-                                vec::len(bytes), ptr::null());\n-        return as_hex(vec::unsafe::from_buf(hash, 20u));\n-    }\n-}\n-~~~~\n-\n-Firstly, what does the `unsafe` keyword at the top of the function\n-mean? `unsafe` is a block modifier\u2014it declares the block following it\n-to be known to be unsafe.\n-\n-Some operations, like dereferencing unsafe pointers or calling\n-functions that have been marked unsafe, are only allowed inside unsafe\n-blocks. With the `unsafe` keyword, you're telling the compiler 'I know\n-what I'm doing'. The main motivation for such an annotation is that\n-when you have a memory error (and you will, if you're using unsafe\n-constructs), you have some idea where to look\u2014it will most likely be\n-caused by some unsafe code.\n-\n-Unsafe blocks isolate unsafety. Unsafe functions, on the other hand,\n-advertise it to the world. An unsafe function is written like this:\n-\n-~~~~\n-unsafe fn kaboom() { ~\"I'm harmless!\"; }\n-~~~~\n-\n-This function can only be called from an unsafe block or another\n-unsafe function.\n-\n-## Pointer fiddling\n-\n-The standard library defines a number of helper functions for dealing\n-with unsafe data, casting between types, and generally subverting\n-Rust's safety mechanisms.\n-\n-Let's look at our `sha1` function again.\n-\n-~~~~\n-# mod crypto { fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8 { out } }\n-# fn as_hex(data: ~[u8]) -> ~str { ~\"hi\" }\n-# fn x(data: ~str) -> ~str {\n-# unsafe {\n-let bytes = str::to_bytes(data);\n-let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n-                        vec::len(bytes), ptr::null());\n-return as_hex(vec::unsafe::from_buf(hash, 20u));\n-# }\n-# }\n-~~~~\n-\n-The `str::to_bytes` function is perfectly safe: it converts a string to\n-a `[u8]`. This byte array is then fed to `vec::unsafe::to_ptr`, which\n-returns an unsafe pointer to its contents.\n-\n-This pointer will become invalid as soon as the vector it points into\n-is cleaned up, so you should be very careful how you use it. In this\n-case, the local variable `bytes` outlives the pointer, so we're good.\n-\n-Passing a null pointer as the third argument to `SHA1` makes it use a\n-static buffer, and thus save us the effort of allocating memory\n-ourselves. `ptr::null` is a generic function that will return an\n-unsafe null pointer of the correct type (Rust generics are awesome\n-like that\u2014they can take the right form depending on the type that they\n-are expected to return).\n-\n-Finally, `vec::unsafe::from_buf` builds up a new `[u8]` from the\n-unsafe pointer that was returned by `SHA1`. SHA1 digests are always\n-twenty bytes long, so we can pass `20u` for the length of the new\n-vector.\n-\n-## Passing structures\n-\n-C functions often take pointers to structs as arguments. Since Rust\n-records are binary-compatible with C structs, Rust programs can call\n-such functions directly.\n-\n-This program uses the POSIX function `gettimeofday` to get a\n-microsecond-resolution timer.\n-\n-~~~~\n-use std;\n-import libc::c_ulonglong;\n-\n-type timeval = {mut tv_sec: c_ulonglong,\n-                mut tv_usec: c_ulonglong};\n-#[nolink]\n-extern mod lib_c {\n-    fn gettimeofday(tv: *timeval, tz: *()) -> i32;\n-}\n-fn unix_time_in_microseconds() -> u64 unsafe {\n-    let x = {mut tv_sec: 0 as c_ulonglong, mut tv_usec: 0 as c_ulonglong};\n-    lib_c::gettimeofday(ptr::addr_of(x), ptr::null());\n-    return (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\n-}\n-\n-# fn main() { assert fmt!(\"%?\", unix_time_in_microseconds()) != ~\"\"; }\n-~~~~\n-\n-The `#[nolink]` attribute indicates that there's no foreign library to\n-link in. The standard C library is already linked with Rust programs.\n-\n-A `timeval`, in C, is a struct with two 32-bit integers. Thus, we\n-define a record type with the same contents, and declare\n-`gettimeofday` to take a pointer to such a record.\n-\n-The second argument to `gettimeofday` (the time zone) is not used by\n-this program, so it simply declares it to be a pointer to the nil\n-type. Since all null pointers have the same representation regardless of\n-their referent type, this is safe.\n-\n # Tasks\n \n Rust supports a system of lightweight tasks, similar to what is found"}, {"sha": "18ea696e5027d6ce84641a05740ff35ddb6c3d2e", "filename": "mk/docs.mk", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4e515c14af8598f5e0d8e62847741523e7c14ba5/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4e515c14af8598f5e0d8e62847741523e7c14ba5/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=4e515c14af8598f5e0d8e62847741523e7c14ba5", "patch": "@@ -93,6 +93,16 @@ doc/tutorial-macros.html: tutorial-macros.md doc/version_info.html \\\n \t   --include-before-body=doc/version_info.html \\\n            --output=$@\n \n+DOCS += doc/tutorial-ffi.html\n+doc/tutorial-ffi.html: tutorial-ffi.md doc/version_info.html doc/rust.css\n+\t@$(call E, pandoc: $@)\n+\t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n+          $(CFG_PANDOC) --standalone --toc \\\n+           --section-divs --number-sections \\\n+           --from=markdown --to=html --css=rust.css \\\n+\t   --include-before-body=doc/version_info.html \\\n+           --output=$@\n+\n   endif\n endif\n "}]}