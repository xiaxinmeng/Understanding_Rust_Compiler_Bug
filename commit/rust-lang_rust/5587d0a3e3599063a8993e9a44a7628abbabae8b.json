{"sha": "5587d0a3e3599063a8993e9a44a7628abbabae8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ODdkMGEzZTM1OTkwNjNhODk5M2U5YTQ0YTc2MjhhYmJhYmFlOGI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-25T20:33:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-25T20:33:21Z"}, "message": "Merge #8973\n\n8973: internal: move diagnostics to hir r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "77d3d645249361e8a4730be803338caccddeefa0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77d3d645249361e8a4730be803338caccddeefa0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5587d0a3e3599063a8993e9a44a7628abbabae8b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgrV8RCRBK7hj4Ov3rIwAARoUIAH613ZaYoDSgTfEkGpgXKeBj\n2tHJFTWo3q713lJ6gAQd+DPlS5FvYLOisNpjhJw08ziLhBz3Rn73mRTdUnHEdVtb\nMm+Ok+p23dgiEjgWpxAYKm3HcYF2ez3BhrBFIhX3tIeQfnZ3Bqlia/4zIOCBHM0H\ngwE7690za/sDU2bTWA0Zc6sxB5syKk3szsjMIiiXhoIFRxIbT/upNrz4F0RPAy7h\ner2xUg4T4RrHdfZdJOmV6FaLHaNaz0hMCKEZbEyu7Gb17N/uRsVs5n5oBZbG5P9B\nlCD7rzJdFEzTZfzZTc5szizVf7LSZtuA6M/48ndjUwpn/xSPLj3RbXu0s5oiji0=\n=brpL\n-----END PGP SIGNATURE-----\n", "payload": "tree 77d3d645249361e8a4730be803338caccddeefa0\nparent e23083f39813f9559c041b295d23534cd2125913\nparent 5c9f31d4c28478b4373e6cf5ec155745c840ee3f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1621974801 +0000\ncommitter GitHub <noreply@github.com> 1621974801 +0000\n\nMerge #8973\n\n8973: internal: move diagnostics to hir r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5587d0a3e3599063a8993e9a44a7628abbabae8b", "html_url": "https://github.com/rust-lang/rust/commit/5587d0a3e3599063a8993e9a44a7628abbabae8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5587d0a3e3599063a8993e9a44a7628abbabae8b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e23083f39813f9559c041b295d23534cd2125913", "url": "https://api.github.com/repos/rust-lang/rust/commits/e23083f39813f9559c041b295d23534cd2125913", "html_url": "https://github.com/rust-lang/rust/commit/e23083f39813f9559c041b295d23534cd2125913"}, {"sha": "5c9f31d4c28478b4373e6cf5ec155745c840ee3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c9f31d4c28478b4373e6cf5ec155745c840ee3f", "html_url": "https://github.com/rust-lang/rust/commit/5c9f31d4c28478b4373e6cf5ec155745c840ee3f"}], "stats": {"total": 1369, "additions": 693, "deletions": 676}, "files": [{"sha": "22ec7c6acaf9bcaefbde9a8c300141c0cc8a34a1", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 223, "deletions": 9, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -3,13 +3,227 @@\n //!\n //! This probably isn't the best way to do this -- ideally, diagnistics should\n //! be expressed in terms of hir types themselves.\n-pub use hir_def::diagnostics::{\n-    InactiveCode, UnresolvedMacroCall, UnresolvedModule, UnresolvedProcMacro,\n-};\n-pub use hir_expand::diagnostics::{\n-    Diagnostic, DiagnosticCode, DiagnosticSink, DiagnosticSinkBuilder,\n-};\n-pub use hir_ty::diagnostics::{\n-    IncorrectCase, MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr,\n-    NoSuchField, RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap,\n+use std::any::Any;\n+\n+use cfg::{CfgExpr, CfgOptions, DnfExpr};\n+use hir_def::path::ModPath;\n+use hir_expand::{HirFileId, InFile};\n+use stdx::format_to;\n+use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n+\n+pub use hir_ty::{\n+    diagnostics::{\n+        IncorrectCase, MismatchedArgCount, MissingFields, MissingMatchArms,\n+        MissingOkOrSomeInTailExpr, NoSuchField, RemoveThisSemicolon,\n+        ReplaceFilterMapNextWithFindMap,\n+    },\n+    diagnostics_sink::{Diagnostic, DiagnosticCode, DiagnosticSink, DiagnosticSinkBuilder},\n };\n+\n+// Diagnostic: unresolved-module\n+//\n+// This diagnostic is triggered if rust-analyzer is unable to discover referred module.\n+#[derive(Debug)]\n+pub struct UnresolvedModule {\n+    pub file: HirFileId,\n+    pub decl: AstPtr<ast::Module>,\n+    pub candidate: String,\n+}\n+\n+impl Diagnostic for UnresolvedModule {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"unresolved-module\")\n+    }\n+    fn message(&self) -> String {\n+        \"unresolved module\".to_string()\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile::new(self.file, self.decl.clone().into())\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+// Diagnostic: unresolved-extern-crate\n+//\n+// This diagnostic is triggered if rust-analyzer is unable to discover referred extern crate.\n+#[derive(Debug)]\n+pub struct UnresolvedExternCrate {\n+    pub file: HirFileId,\n+    pub item: AstPtr<ast::ExternCrate>,\n+}\n+\n+impl Diagnostic for UnresolvedExternCrate {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"unresolved-extern-crate\")\n+    }\n+    fn message(&self) -> String {\n+        \"unresolved extern crate\".to_string()\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile::new(self.file, self.item.clone().into())\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct UnresolvedImport {\n+    pub file: HirFileId,\n+    pub node: AstPtr<ast::UseTree>,\n+}\n+\n+impl Diagnostic for UnresolvedImport {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"unresolved-import\")\n+    }\n+    fn message(&self) -> String {\n+        \"unresolved import\".to_string()\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile::new(self.file, self.node.clone().into())\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+    fn is_experimental(&self) -> bool {\n+        // This currently results in false positives in the following cases:\n+        // - `cfg_if!`-generated code in libstd (we don't load the sysroot correctly)\n+        // - `core::arch` (we don't handle `#[path = \"../<path>\"]` correctly)\n+        // - proc macros and/or proc macro generated code\n+        true\n+    }\n+}\n+\n+// Diagnostic: unresolved-macro-call\n+//\n+// This diagnostic is triggered if rust-analyzer is unable to resolve the path to a\n+// macro in a macro invocation.\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct UnresolvedMacroCall {\n+    pub file: HirFileId,\n+    pub node: AstPtr<ast::MacroCall>,\n+    pub path: ModPath,\n+}\n+\n+impl Diagnostic for UnresolvedMacroCall {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"unresolved-macro-call\")\n+    }\n+    fn message(&self) -> String {\n+        format!(\"unresolved macro `{}!`\", self.path)\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile::new(self.file, self.node.clone().into())\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+    fn is_experimental(&self) -> bool {\n+        true\n+    }\n+}\n+\n+// Diagnostic: inactive-code\n+//\n+// This diagnostic is shown for code with inactive `#[cfg]` attributes.\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct InactiveCode {\n+    pub file: HirFileId,\n+    pub node: SyntaxNodePtr,\n+    pub cfg: CfgExpr,\n+    pub opts: CfgOptions,\n+}\n+\n+impl Diagnostic for InactiveCode {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"inactive-code\")\n+    }\n+    fn message(&self) -> String {\n+        let inactive = DnfExpr::new(self.cfg.clone()).why_inactive(&self.opts);\n+        let mut buf = \"code is inactive due to #[cfg] directives\".to_string();\n+\n+        if let Some(inactive) = inactive {\n+            format_to!(buf, \": {}\", inactive);\n+        }\n+\n+        buf\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile::new(self.file, self.node.clone())\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+// Diagnostic: unresolved-proc-macro\n+//\n+// This diagnostic is shown when a procedural macro can not be found. This usually means that\n+// procedural macro support is simply disabled (and hence is only a weak hint instead of an error),\n+// but can also indicate project setup problems.\n+//\n+// If you are seeing a lot of \"proc macro not expanded\" warnings, you can add this option to the\n+// `rust-analyzer.diagnostics.disabled` list to prevent them from showing. Alternatively you can\n+// enable support for procedural macros (see `rust-analyzer.procMacro.enable`).\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct UnresolvedProcMacro {\n+    pub file: HirFileId,\n+    pub node: SyntaxNodePtr,\n+    /// If the diagnostic can be pinpointed more accurately than via `node`, this is the `TextRange`\n+    /// to use instead.\n+    pub precise_location: Option<TextRange>,\n+    pub macro_name: Option<String>,\n+}\n+\n+impl Diagnostic for UnresolvedProcMacro {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"unresolved-proc-macro\")\n+    }\n+\n+    fn message(&self) -> String {\n+        match &self.macro_name {\n+            Some(name) => format!(\"proc macro `{}` not expanded\", name),\n+            None => \"proc macro not expanded\".to_string(),\n+        }\n+    }\n+\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile::new(self.file, self.node.clone())\n+    }\n+\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+// Diagnostic: macro-error\n+//\n+// This diagnostic is shown for macro expansion errors.\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct MacroError {\n+    pub file: HirFileId,\n+    pub node: SyntaxNodePtr,\n+    pub message: String,\n+}\n+\n+impl Diagnostic for MacroError {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"macro-error\")\n+    }\n+    fn message(&self) -> String {\n+        self.message.clone()\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile::new(self.file, self.node.clone())\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+    fn is_experimental(&self) -> bool {\n+        // Newly added and not very well-tested, might contain false positives.\n+        true\n+    }\n+}"}, {"sha": "1ecd2391b0f37f090d24ed753c14fa86f965d1f5", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 172, "deletions": 4, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -35,12 +35,18 @@ use std::{iter, sync::Arc};\n \n use arrayvec::ArrayVec;\n use base_db::{CrateDisplayName, CrateId, Edition, FileId};\n+use diagnostics::{\n+    InactiveCode, MacroError, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n+    UnresolvedModule, UnresolvedProcMacro,\n+};\n use either::Either;\n use hir_def::{\n     adt::{ReprKind, VariantData},\n+    body::BodyDiagnostic,\n     expr::{BindingAnnotation, LabelId, Pat, PatId},\n     item_tree::ItemTreeNode,\n     lang_item::LangItemTarget,\n+    nameres,\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n     src::HasSource as _,\n@@ -50,11 +56,12 @@ use hir_def::{\n     LocalEnumVariantId, LocalFieldId, Lookup, ModuleId, StaticId, StructId, TraitId, TypeAliasId,\n     TypeParamId, UnionId,\n };\n-use hir_expand::{diagnostics::DiagnosticSink, name::name, MacroDefKind};\n+use hir_expand::{name::name, MacroCallKind, MacroDefKind};\n use hir_ty::{\n     autoderef,\n     consteval::ConstExt,\n     could_unify,\n+    diagnostics_sink::DiagnosticSink,\n     method_resolution::{self, def_crates, TyFingerprint},\n     primitive::UintTy,\n     subst_prefix,\n@@ -65,11 +72,12 @@ use hir_ty::{\n     WhereClause,\n };\n use itertools::Itertools;\n+use nameres::diagnostics::DefDiagnosticKind;\n use rustc_hash::FxHashSet;\n use stdx::{format_to, impl_from};\n use syntax::{\n     ast::{self, AttrsOwner, NameOwner},\n-    AstNode, SmolStr,\n+    AstNode, AstPtr, SmolStr, SyntaxKind, SyntaxNodePtr,\n };\n use tt::{Ident, Leaf, Literal, TokenTree};\n \n@@ -442,7 +450,137 @@ impl Module {\n             format!(\"{:?}\", self.name(db).map_or(\"<unknown>\".into(), |name| name.to_string()))\n         });\n         let def_map = self.id.def_map(db.upcast());\n-        def_map.add_diagnostics(db.upcast(), self.id.local_id, sink);\n+        for diag in def_map.diagnostics() {\n+            if diag.in_module != self.id.local_id {\n+                // FIXME: This is accidentally quadratic.\n+                continue;\n+            }\n+            match &diag.kind {\n+                DefDiagnosticKind::UnresolvedModule { ast: declaration, candidate } => {\n+                    let decl = declaration.to_node(db.upcast());\n+                    sink.push(UnresolvedModule {\n+                        file: declaration.file_id,\n+                        decl: AstPtr::new(&decl),\n+                        candidate: candidate.clone(),\n+                    })\n+                }\n+                DefDiagnosticKind::UnresolvedExternCrate { ast } => {\n+                    let item = ast.to_node(db.upcast());\n+                    sink.push(UnresolvedExternCrate {\n+                        file: ast.file_id,\n+                        item: AstPtr::new(&item),\n+                    });\n+                }\n+\n+                DefDiagnosticKind::UnresolvedImport { ast, index } => {\n+                    let use_item = ast.to_node(db.upcast());\n+                    let hygiene = Hygiene::new(db.upcast(), ast.file_id);\n+                    let mut cur = 0;\n+                    let mut tree = None;\n+                    ModPath::expand_use_item(\n+                        db.upcast(),\n+                        InFile::new(ast.file_id, use_item),\n+                        &hygiene,\n+                        |_mod_path, use_tree, _is_glob, _alias| {\n+                            if cur == *index {\n+                                tree = Some(use_tree.clone());\n+                            }\n+\n+                            cur += 1;\n+                        },\n+                    );\n+\n+                    if let Some(tree) = tree {\n+                        sink.push(UnresolvedImport { file: ast.file_id, node: AstPtr::new(&tree) });\n+                    }\n+                }\n+\n+                DefDiagnosticKind::UnconfiguredCode { ast, cfg, opts } => {\n+                    let item = ast.to_node(db.upcast());\n+                    sink.push(InactiveCode {\n+                        file: ast.file_id,\n+                        node: AstPtr::new(&item).into(),\n+                        cfg: cfg.clone(),\n+                        opts: opts.clone(),\n+                    });\n+                }\n+\n+                DefDiagnosticKind::UnresolvedProcMacro { ast } => {\n+                    let mut precise_location = None;\n+                    let (file, ast, name) = match ast {\n+                        MacroCallKind::FnLike { ast_id, .. } => {\n+                            let node = ast_id.to_node(db.upcast());\n+                            (ast_id.file_id, SyntaxNodePtr::from(AstPtr::new(&node)), None)\n+                        }\n+                        MacroCallKind::Derive { ast_id, derive_name, .. } => {\n+                            let node = ast_id.to_node(db.upcast());\n+\n+                            // Compute the precise location of the macro name's token in the derive\n+                            // list.\n+                            // FIXME: This does not handle paths to the macro, but neither does the\n+                            // rest of r-a.\n+                            let derive_attrs =\n+                                node.attrs().filter_map(|attr| match attr.as_simple_call() {\n+                                    Some((name, args)) if name == \"derive\" => Some(args),\n+                                    _ => None,\n+                                });\n+                            'outer: for attr in derive_attrs {\n+                                let tokens =\n+                                    attr.syntax().children_with_tokens().filter_map(|elem| {\n+                                        match elem {\n+                                            syntax::NodeOrToken::Node(_) => None,\n+                                            syntax::NodeOrToken::Token(tok) => Some(tok),\n+                                        }\n+                                    });\n+                                for token in tokens {\n+                                    if token.kind() == SyntaxKind::IDENT\n+                                        && token.text() == derive_name.as_str()\n+                                    {\n+                                        precise_location = Some(token.text_range());\n+                                        break 'outer;\n+                                    }\n+                                }\n+                            }\n+\n+                            (\n+                                ast_id.file_id,\n+                                SyntaxNodePtr::from(AstPtr::new(&node)),\n+                                Some(derive_name.clone()),\n+                            )\n+                        }\n+                    };\n+                    sink.push(UnresolvedProcMacro {\n+                        file,\n+                        node: ast,\n+                        precise_location,\n+                        macro_name: name,\n+                    });\n+                }\n+\n+                DefDiagnosticKind::UnresolvedMacroCall { ast, path } => {\n+                    let node = ast.to_node(db.upcast());\n+                    sink.push(UnresolvedMacroCall {\n+                        file: ast.file_id,\n+                        node: AstPtr::new(&node),\n+                        path: path.clone(),\n+                    });\n+                }\n+\n+                DefDiagnosticKind::MacroError { ast, message } => {\n+                    let (file, ast) = match ast {\n+                        MacroCallKind::FnLike { ast_id, .. } => {\n+                            let node = ast_id.to_node(db.upcast());\n+                            (ast_id.file_id, SyntaxNodePtr::from(AstPtr::new(&node)))\n+                        }\n+                        MacroCallKind::Derive { ast_id, .. } => {\n+                            let node = ast_id.to_node(db.upcast());\n+                            (ast_id.file_id, SyntaxNodePtr::from(AstPtr::new(&node)))\n+                        }\n+                    };\n+                    sink.push(MacroError { file, node: ast, message: message.clone() });\n+                }\n+            }\n+        }\n         for decl in self.declarations(db) {\n             match decl {\n                 crate::ModuleDef::Function(f) => f.diagnostics(db, sink),\n@@ -865,7 +1003,37 @@ impl Function {\n \n     pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n         let krate = self.module(db).id.krate();\n-        hir_def::diagnostics::validate_body(db.upcast(), self.id.into(), sink);\n+\n+        let source_map = db.body_with_source_map(self.id.into()).1;\n+        for diag in source_map.diagnostics() {\n+            match diag {\n+                BodyDiagnostic::InactiveCode { node, cfg, opts } => sink.push(InactiveCode {\n+                    file: node.file_id,\n+                    node: node.value.clone(),\n+                    cfg: cfg.clone(),\n+                    opts: opts.clone(),\n+                }),\n+                BodyDiagnostic::MacroError { node, message } => sink.push(MacroError {\n+                    file: node.file_id,\n+                    node: node.value.clone().into(),\n+                    message: message.to_string(),\n+                }),\n+                BodyDiagnostic::UnresolvedProcMacro { node } => sink.push(UnresolvedProcMacro {\n+                    file: node.file_id,\n+                    node: node.value.clone().into(),\n+                    precise_location: None,\n+                    macro_name: None,\n+                }),\n+                BodyDiagnostic::UnresolvedMacroCall { node, path } => {\n+                    sink.push(UnresolvedMacroCall {\n+                        file: node.file_id,\n+                        node: node.value.clone(),\n+                        path: path.clone(),\n+                    })\n+                }\n+            }\n+        }\n+\n         hir_ty::diagnostics::validate_module_item(db, krate, self.id.into(), sink);\n         hir_ty::diagnostics::validate_body(db, self.id.into(), sink);\n     }"}, {"sha": "c521879c873101ed847afaea5d16fd419d91b435", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -1,25 +1,23 @@\n //! Defines `Body`: a lowered representation of bodies of functions, statics and\n //! consts.\n mod lower;\n-mod diagnostics;\n #[cfg(test)]\n mod tests;\n pub mod scope;\n \n use std::{mem, ops::Index, sync::Arc};\n \n use base_db::CrateId;\n-use cfg::CfgOptions;\n+use cfg::{CfgExpr, CfgOptions};\n use drop_bomb::DropBomb;\n use either::Either;\n use hir_expand::{\n-    ast_id_map::AstIdMap, diagnostics::DiagnosticSink, hygiene::Hygiene, AstId, ExpandResult,\n-    HirFileId, InFile, MacroDefId,\n+    ast_id_map::AstIdMap, hygiene::Hygiene, AstId, ExpandResult, HirFileId, InFile, MacroDefId,\n };\n use la_arena::{Arena, ArenaMap};\n use profile::Count;\n use rustc_hash::FxHashMap;\n-use syntax::{ast, AstNode, AstPtr};\n+use syntax::{ast, AstNode, AstPtr, SyntaxNodePtr};\n \n use crate::{\n     attr::{Attrs, RawAttrs},\n@@ -273,12 +271,20 @@ pub struct BodySourceMap {\n \n     /// Diagnostics accumulated during body lowering. These contain `AstPtr`s and so are stored in\n     /// the source map (since they're just as volatile).\n-    diagnostics: Vec<diagnostics::BodyDiagnostic>,\n+    diagnostics: Vec<BodyDiagnostic>,\n }\n \n #[derive(Default, Debug, Eq, PartialEq, Clone, Copy)]\n pub struct SyntheticSyntax;\n \n+#[derive(Debug, Eq, PartialEq)]\n+pub enum BodyDiagnostic {\n+    InactiveCode { node: InFile<SyntaxNodePtr>, cfg: CfgExpr, opts: CfgOptions },\n+    MacroError { node: InFile<AstPtr<ast::MacroCall>>, message: String },\n+    UnresolvedProcMacro { node: InFile<AstPtr<ast::MacroCall>> },\n+    UnresolvedMacroCall { node: InFile<AstPtr<ast::MacroCall>>, path: ModPath },\n+}\n+\n impl Body {\n     pub(crate) fn body_with_source_map_query(\n         db: &dyn DefDatabase,\n@@ -416,9 +422,8 @@ impl BodySourceMap {\n         self.field_map.get(&src).cloned()\n     }\n \n-    pub(crate) fn add_diagnostics(&self, _db: &dyn DefDatabase, sink: &mut DiagnosticSink<'_>) {\n-        for diag in &self.diagnostics {\n-            diag.add_to(sink);\n-        }\n+    /// Get a reference to the body source map's diagnostics.\n+    pub fn diagnostics(&self) -> &[BodyDiagnostic] {\n+        &self.diagnostics\n     }\n }"}, {"sha": "f6992c9a8a946c9a03e3c551aa4de492020f8b8d", "filename": "crates/hir_def/src/body/diagnostics.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e23083f39813f9559c041b295d23534cd2125913/crates%2Fhir_def%2Fsrc%2Fbody%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e23083f39813f9559c041b295d23534cd2125913/crates%2Fhir_def%2Fsrc%2Fbody%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Fdiagnostics.rs?ref=e23083f39813f9559c041b295d23534cd2125913", "patch": "@@ -1,32 +0,0 @@\n-//! Diagnostics emitted during body lowering.\n-\n-use hir_expand::diagnostics::DiagnosticSink;\n-\n-use crate::diagnostics::{InactiveCode, MacroError, UnresolvedMacroCall, UnresolvedProcMacro};\n-\n-#[derive(Debug, Eq, PartialEq)]\n-pub(crate) enum BodyDiagnostic {\n-    InactiveCode(InactiveCode),\n-    MacroError(MacroError),\n-    UnresolvedProcMacro(UnresolvedProcMacro),\n-    UnresolvedMacroCall(UnresolvedMacroCall),\n-}\n-\n-impl BodyDiagnostic {\n-    pub(crate) fn add_to(&self, sink: &mut DiagnosticSink<'_>) {\n-        match self {\n-            BodyDiagnostic::InactiveCode(diag) => {\n-                sink.push(diag.clone());\n-            }\n-            BodyDiagnostic::MacroError(diag) => {\n-                sink.push(diag.clone());\n-            }\n-            BodyDiagnostic::UnresolvedProcMacro(diag) => {\n-                sink.push(diag.clone());\n-            }\n-            BodyDiagnostic::UnresolvedMacroCall(diag) => {\n-                sink.push(diag.clone());\n-            }\n-        }\n-    }\n-}"}, {"sha": "da1fdac33aec5371dfb1d336cdb23278143fad7c", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -8,7 +8,7 @@ use hir_expand::{\n     ast_id_map::{AstIdMap, FileAstId},\n     hygiene::Hygiene,\n     name::{name, AsName, Name},\n-    ExpandError, HirFileId,\n+    ExpandError, HirFileId, InFile,\n };\n use la_arena::Arena;\n use profile::Count;\n@@ -23,9 +23,9 @@ use syntax::{\n use crate::{\n     adt::StructKind,\n     body::{Body, BodySourceMap, Expander, LabelSource, PatPtr, SyntheticSyntax},\n+    body::{BodyDiagnostic, ExprSource, PatSource},\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n-    diagnostics::{InactiveCode, MacroError, UnresolvedMacroCall, UnresolvedProcMacro},\n     expr::{\n         dummy_expr_id, ArithOp, Array, BinaryOp, BindingAnnotation, CmpOp, Expr, ExprId, Label,\n         LabelId, Literal, LogicOp, MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField,\n@@ -38,8 +38,6 @@ use crate::{\n     AdtId, BlockLoc, ModuleDefId, UnresolvedMacro,\n };\n \n-use super::{diagnostics::BodyDiagnostic, ExprSource, PatSource};\n-\n pub struct LowerCtx<'a> {\n     pub db: &'a dyn DefDatabase,\n     hygiene: Hygiene,\n@@ -592,35 +590,26 @@ impl ExprCollector<'_> {\n         let res = match res {\n             Ok(res) => res,\n             Err(UnresolvedMacro { path }) => {\n-                self.source_map.diagnostics.push(BodyDiagnostic::UnresolvedMacroCall(\n-                    UnresolvedMacroCall {\n-                        file: outer_file,\n-                        node: syntax_ptr.cast().unwrap(),\n-                        path,\n-                    },\n-                ));\n+                self.source_map.diagnostics.push(BodyDiagnostic::UnresolvedMacroCall {\n+                    node: InFile::new(outer_file, syntax_ptr),\n+                    path,\n+                });\n                 collector(self, None);\n                 return;\n             }\n         };\n \n         match &res.err {\n             Some(ExpandError::UnresolvedProcMacro) => {\n-                self.source_map.diagnostics.push(BodyDiagnostic::UnresolvedProcMacro(\n-                    UnresolvedProcMacro {\n-                        file: outer_file,\n-                        node: syntax_ptr.into(),\n-                        precise_location: None,\n-                        macro_name: None,\n-                    },\n-                ));\n+                self.source_map.diagnostics.push(BodyDiagnostic::UnresolvedProcMacro {\n+                    node: InFile::new(outer_file, syntax_ptr),\n+                });\n             }\n             Some(err) => {\n-                self.source_map.diagnostics.push(BodyDiagnostic::MacroError(MacroError {\n-                    file: outer_file,\n-                    node: syntax_ptr.into(),\n+                self.source_map.diagnostics.push(BodyDiagnostic::MacroError {\n+                    node: InFile::new(outer_file, syntax_ptr),\n                     message: err.to_string(),\n-                }));\n+                });\n             }\n             None => {}\n         }\n@@ -945,12 +934,14 @@ impl ExprCollector<'_> {\n                     return Some(());\n                 }\n \n-                self.source_map.diagnostics.push(BodyDiagnostic::InactiveCode(InactiveCode {\n-                    file: self.expander.current_file_id,\n-                    node: SyntaxNodePtr::new(owner.syntax()),\n+                self.source_map.diagnostics.push(BodyDiagnostic::InactiveCode {\n+                    node: InFile::new(\n+                        self.expander.current_file_id,\n+                        SyntaxNodePtr::new(owner.syntax()),\n+                    ),\n                     cfg,\n                     opts: self.expander.cfg_options().clone(),\n-                }));\n+                });\n \n                 None\n             }"}, {"sha": "d4fae05a69928a6e55ac90ef7987dfc54c1ab868", "filename": "crates/hir_def/src/body/tests.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -96,26 +96,26 @@ fn f() {\n     // The three g\u0336e\u0336n\u0336d\u0336e\u0336r\u0336s\u0336 statements:\n \n     #[cfg(a)] fn f() {}  // Item statement\n-  //^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+  //^^^^^^^^^^^^^^^^^^^ InactiveCode\n     #[cfg(a)] {}         // Expression statement\n-  //^^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+  //^^^^^^^^^^^^ InactiveCode\n     #[cfg(a)] let x = 0; // let statement\n-  //^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+  //^^^^^^^^^^^^^^^^^^^^ InactiveCode\n \n     abc(#[cfg(a)] 0);\n-      //^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+      //^^^^^^^^^^^ InactiveCode\n     let x = Struct {\n         #[cfg(a)] f: 0,\n-      //^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+      //^^^^^^^^^^^^^^ InactiveCode\n     };\n     match () {\n         () => (),\n         #[cfg(a)] () => (),\n-      //^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+      //^^^^^^^^^^^^^^^^^^ InactiveCode\n     }\n \n     #[cfg(a)] 0          // Trailing expression of block\n-  //^^^^^^^^^^^ code is inactive due to #[cfg] directives: a is disabled\n+  //^^^^^^^^^^^ InactiveCode\n }\n     \",\n     );\n@@ -188,7 +188,7 @@ fn unresolved_macro_diag() {\n         r#\"\n fn f() {\n     m!();\n-  //^^^^ unresolved macro `m!`\n+  //^^^^ UnresolvedMacroCall\n }\n       \"#,\n     );"}, {"sha": "a71ae266845a753044521e7f519561270200f3e5", "filename": "crates/hir_def/src/diagnostics.rs", "status": "removed", "additions": 0, "deletions": 227, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/e23083f39813f9559c041b295d23534cd2125913/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e23083f39813f9559c041b295d23534cd2125913/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs?ref=e23083f39813f9559c041b295d23534cd2125913", "patch": "@@ -1,227 +0,0 @@\n-//! Diagnostics produced by `hir_def`.\n-\n-use std::any::Any;\n-use stdx::format_to;\n-\n-use cfg::{CfgExpr, CfgOptions, DnfExpr};\n-use hir_expand::diagnostics::{Diagnostic, DiagnosticCode, DiagnosticSink};\n-use hir_expand::{HirFileId, InFile};\n-use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n-\n-use crate::{db::DefDatabase, path::ModPath, DefWithBodyId};\n-\n-pub fn validate_body(db: &dyn DefDatabase, owner: DefWithBodyId, sink: &mut DiagnosticSink<'_>) {\n-    let source_map = db.body_with_source_map(owner).1;\n-    source_map.add_diagnostics(db, sink);\n-}\n-\n-// Diagnostic: unresolved-module\n-//\n-// This diagnostic is triggered if rust-analyzer is unable to discover referred module.\n-#[derive(Debug)]\n-pub struct UnresolvedModule {\n-    pub file: HirFileId,\n-    pub decl: AstPtr<ast::Module>,\n-    pub candidate: String,\n-}\n-\n-impl Diagnostic for UnresolvedModule {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"unresolved-module\")\n-    }\n-    fn message(&self) -> String {\n-        \"unresolved module\".to_string()\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file, self.decl.clone().into())\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-// Diagnostic: unresolved-extern-crate\n-//\n-// This diagnostic is triggered if rust-analyzer is unable to discover referred extern crate.\n-#[derive(Debug)]\n-pub struct UnresolvedExternCrate {\n-    pub file: HirFileId,\n-    pub item: AstPtr<ast::ExternCrate>,\n-}\n-\n-impl Diagnostic for UnresolvedExternCrate {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"unresolved-extern-crate\")\n-    }\n-    fn message(&self) -> String {\n-        \"unresolved extern crate\".to_string()\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file, self.item.clone().into())\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-// Diagnostic: unresolved-import\n-//\n-// This diagnostic is triggered if rust-analyzer is unable to discover imported module.\n-#[derive(Debug)]\n-pub struct UnresolvedImport {\n-    pub file: HirFileId,\n-    pub node: AstPtr<ast::UseTree>,\n-}\n-\n-impl Diagnostic for UnresolvedImport {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"unresolved-import\")\n-    }\n-    fn message(&self) -> String {\n-        \"unresolved import\".to_string()\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file, self.node.clone().into())\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-    fn is_experimental(&self) -> bool {\n-        // This currently results in false positives in the following cases:\n-        // - `cfg_if!`-generated code in libstd (we don't load the sysroot correctly)\n-        // - `core::arch` (we don't handle `#[path = \"../<path>\"]` correctly)\n-        // - proc macros and/or proc macro generated code\n-        true\n-    }\n-}\n-\n-// Diagnostic: unresolved-macro-call\n-//\n-// This diagnostic is triggered if rust-analyzer is unable to resolve the path to a\n-// macro in a macro invocation.\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct UnresolvedMacroCall {\n-    pub file: HirFileId,\n-    pub node: AstPtr<ast::MacroCall>,\n-    pub path: ModPath,\n-}\n-\n-impl Diagnostic for UnresolvedMacroCall {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"unresolved-macro-call\")\n-    }\n-    fn message(&self) -> String {\n-        format!(\"unresolved macro `{}!`\", self.path)\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file, self.node.clone().into())\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-    fn is_experimental(&self) -> bool {\n-        true\n-    }\n-}\n-\n-// Diagnostic: inactive-code\n-//\n-// This diagnostic is shown for code with inactive `#[cfg]` attributes.\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct InactiveCode {\n-    pub file: HirFileId,\n-    pub node: SyntaxNodePtr,\n-    pub cfg: CfgExpr,\n-    pub opts: CfgOptions,\n-}\n-\n-impl Diagnostic for InactiveCode {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"inactive-code\")\n-    }\n-    fn message(&self) -> String {\n-        let inactive = DnfExpr::new(self.cfg.clone()).why_inactive(&self.opts);\n-        let mut buf = \"code is inactive due to #[cfg] directives\".to_string();\n-\n-        if let Some(inactive) = inactive {\n-            format_to!(buf, \": {}\", inactive);\n-        }\n-\n-        buf\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file, self.node.clone())\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-// Diagnostic: unresolved-proc-macro\n-//\n-// This diagnostic is shown when a procedural macro can not be found. This usually means that\n-// procedural macro support is simply disabled (and hence is only a weak hint instead of an error),\n-// but can also indicate project setup problems.\n-//\n-// If you are seeing a lot of \"proc macro not expanded\" warnings, you can add this option to the\n-// `rust-analyzer.diagnostics.disabled` list to prevent them from showing. Alternatively you can\n-// enable support for procedural macros (see `rust-analyzer.procMacro.enable`).\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct UnresolvedProcMacro {\n-    pub file: HirFileId,\n-    pub node: SyntaxNodePtr,\n-    /// If the diagnostic can be pinpointed more accurately than via `node`, this is the `TextRange`\n-    /// to use instead.\n-    pub precise_location: Option<TextRange>,\n-    pub macro_name: Option<String>,\n-}\n-\n-impl Diagnostic for UnresolvedProcMacro {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"unresolved-proc-macro\")\n-    }\n-\n-    fn message(&self) -> String {\n-        match &self.macro_name {\n-            Some(name) => format!(\"proc macro `{}` not expanded\", name),\n-            None => \"proc macro not expanded\".to_string(),\n-        }\n-    }\n-\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file, self.node.clone())\n-    }\n-\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-// Diagnostic: macro-error\n-//\n-// This diagnostic is shown for macro expansion errors.\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct MacroError {\n-    pub file: HirFileId,\n-    pub node: SyntaxNodePtr,\n-    pub message: String,\n-}\n-\n-impl Diagnostic for MacroError {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"macro-error\")\n-    }\n-    fn message(&self) -> String {\n-        self.message.clone()\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file, self.node.clone())\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-    fn is_experimental(&self) -> bool {\n-        // Newly added and not very well-tested, might contain false positives.\n-        true\n-    }\n-}"}, {"sha": "9aa95720af65681956b025d637ce44a0aed63988", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -19,7 +19,6 @@ pub mod path;\n pub mod type_ref;\n pub mod builtin_type;\n pub mod builtin_attr;\n-pub mod diagnostics;\n pub mod per_ns;\n pub mod item_scope;\n \n@@ -56,7 +55,6 @@ use std::{\n     sync::Arc,\n };\n \n-use adt::VariantData;\n use base_db::{impl_intern_key, salsa, CrateId};\n use hir_expand::{\n     ast_id_map::FileAstId,\n@@ -67,15 +65,18 @@ use hir_expand::{\n use la_arena::Idx;\n use nameres::DefMap;\n use path::ModPath;\n+use stdx::impl_from;\n use syntax::ast;\n \n-use crate::attr::AttrId;\n-use crate::builtin_type::BuiltinType;\n-use item_tree::{\n-    Const, Enum, Function, Impl, ItemTreeId, ItemTreeNode, ModItem, Static, Struct, Trait,\n-    TypeAlias, Union,\n+use crate::{\n+    adt::VariantData,\n+    attr::AttrId,\n+    builtin_type::BuiltinType,\n+    item_tree::{\n+        Const, Enum, Function, Impl, ItemTreeId, ItemTreeNode, ModItem, Static, Struct, Trait,\n+        TypeAlias, Union,\n+    },\n };\n-use stdx::impl_from;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ModuleId {"}, {"sha": "ebfcc26c413f3044272286e908a26f98897ea9b1", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 8, "deletions": 244, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -47,18 +47,19 @@\n //! path and, upon success, we run macro expansion and \"collect module\" phase on\n //! the result\n \n+pub mod diagnostics;\n mod collector;\n mod mod_resolution;\n mod path_resolution;\n+mod proc_macro;\n \n #[cfg(test)]\n mod tests;\n-mod proc_macro;\n \n use std::sync::Arc;\n \n use base_db::{CrateId, Edition, FileId};\n-use hir_expand::{diagnostics::DiagnosticSink, name::Name, InFile, MacroDefId};\n+use hir_expand::{name::Name, InFile, MacroDefId};\n use la_arena::Arena;\n use profile::Count;\n use rustc_hash::FxHashMap;\n@@ -254,15 +255,6 @@ impl DefMap {\n         }\n     }\n \n-    pub fn add_diagnostics(\n-        &self,\n-        db: &dyn DefDatabase,\n-        module: LocalModuleId,\n-        sink: &mut DiagnosticSink,\n-    ) {\n-        self.diagnostics.iter().for_each(|it| it.add_to(db, module, sink))\n-    }\n-\n     pub fn modules_for_file(&self, file_id: FileId) -> impl Iterator<Item = LocalModuleId> + '_ {\n         self.modules\n             .iter()\n@@ -448,6 +440,11 @@ impl DefMap {\n             module.scope.shrink_to_fit();\n         }\n     }\n+\n+    /// Get a reference to the def map's diagnostics.\n+    pub fn diagnostics(&self) -> &[DefDiagnostic] {\n+        self.diagnostics.as_slice()\n+    }\n }\n \n impl ModuleData {\n@@ -471,236 +468,3 @@ pub enum ModuleSource {\n     Module(ast::Module),\n     BlockExpr(ast::BlockExpr),\n }\n-\n-mod diagnostics {\n-    use cfg::{CfgExpr, CfgOptions};\n-    use hir_expand::diagnostics::DiagnosticSink;\n-    use hir_expand::hygiene::Hygiene;\n-    use hir_expand::{InFile, MacroCallKind};\n-    use syntax::ast::AttrsOwner;\n-    use syntax::{ast, AstNode, AstPtr, SyntaxKind, SyntaxNodePtr};\n-\n-    use crate::path::ModPath;\n-    use crate::{db::DefDatabase, diagnostics::*, nameres::LocalModuleId, AstId};\n-\n-    #[derive(Debug, PartialEq, Eq)]\n-    enum DiagnosticKind {\n-        UnresolvedModule { declaration: AstId<ast::Module>, candidate: String },\n-\n-        UnresolvedExternCrate { ast: AstId<ast::ExternCrate> },\n-\n-        UnresolvedImport { ast: AstId<ast::Use>, index: usize },\n-\n-        UnconfiguredCode { ast: AstId<ast::Item>, cfg: CfgExpr, opts: CfgOptions },\n-\n-        UnresolvedProcMacro { ast: MacroCallKind },\n-\n-        UnresolvedMacroCall { ast: AstId<ast::MacroCall>, path: ModPath },\n-\n-        MacroError { ast: MacroCallKind, message: String },\n-    }\n-\n-    #[derive(Debug, PartialEq, Eq)]\n-    pub(super) struct DefDiagnostic {\n-        in_module: LocalModuleId,\n-        kind: DiagnosticKind,\n-    }\n-\n-    impl DefDiagnostic {\n-        pub(super) fn unresolved_module(\n-            container: LocalModuleId,\n-            declaration: AstId<ast::Module>,\n-            candidate: String,\n-        ) -> Self {\n-            Self {\n-                in_module: container,\n-                kind: DiagnosticKind::UnresolvedModule { declaration, candidate },\n-            }\n-        }\n-\n-        pub(super) fn unresolved_extern_crate(\n-            container: LocalModuleId,\n-            declaration: AstId<ast::ExternCrate>,\n-        ) -> Self {\n-            Self {\n-                in_module: container,\n-                kind: DiagnosticKind::UnresolvedExternCrate { ast: declaration },\n-            }\n-        }\n-\n-        pub(super) fn unresolved_import(\n-            container: LocalModuleId,\n-            ast: AstId<ast::Use>,\n-            index: usize,\n-        ) -> Self {\n-            Self { in_module: container, kind: DiagnosticKind::UnresolvedImport { ast, index } }\n-        }\n-\n-        pub(super) fn unconfigured_code(\n-            container: LocalModuleId,\n-            ast: AstId<ast::Item>,\n-            cfg: CfgExpr,\n-            opts: CfgOptions,\n-        ) -> Self {\n-            Self { in_module: container, kind: DiagnosticKind::UnconfiguredCode { ast, cfg, opts } }\n-        }\n-\n-        pub(super) fn unresolved_proc_macro(container: LocalModuleId, ast: MacroCallKind) -> Self {\n-            Self { in_module: container, kind: DiagnosticKind::UnresolvedProcMacro { ast } }\n-        }\n-\n-        pub(super) fn macro_error(\n-            container: LocalModuleId,\n-            ast: MacroCallKind,\n-            message: String,\n-        ) -> Self {\n-            Self { in_module: container, kind: DiagnosticKind::MacroError { ast, message } }\n-        }\n-\n-        pub(super) fn unresolved_macro_call(\n-            container: LocalModuleId,\n-            ast: AstId<ast::MacroCall>,\n-            path: ModPath,\n-        ) -> Self {\n-            Self { in_module: container, kind: DiagnosticKind::UnresolvedMacroCall { ast, path } }\n-        }\n-\n-        pub(super) fn add_to(\n-            &self,\n-            db: &dyn DefDatabase,\n-            target_module: LocalModuleId,\n-            sink: &mut DiagnosticSink,\n-        ) {\n-            if self.in_module != target_module {\n-                return;\n-            }\n-\n-            match &self.kind {\n-                DiagnosticKind::UnresolvedModule { declaration, candidate } => {\n-                    let decl = declaration.to_node(db.upcast());\n-                    sink.push(UnresolvedModule {\n-                        file: declaration.file_id,\n-                        decl: AstPtr::new(&decl),\n-                        candidate: candidate.clone(),\n-                    })\n-                }\n-\n-                DiagnosticKind::UnresolvedExternCrate { ast } => {\n-                    let item = ast.to_node(db.upcast());\n-                    sink.push(UnresolvedExternCrate {\n-                        file: ast.file_id,\n-                        item: AstPtr::new(&item),\n-                    });\n-                }\n-\n-                DiagnosticKind::UnresolvedImport { ast, index } => {\n-                    let use_item = ast.to_node(db.upcast());\n-                    let hygiene = Hygiene::new(db.upcast(), ast.file_id);\n-                    let mut cur = 0;\n-                    let mut tree = None;\n-                    ModPath::expand_use_item(\n-                        db,\n-                        InFile::new(ast.file_id, use_item),\n-                        &hygiene,\n-                        |_mod_path, use_tree, _is_glob, _alias| {\n-                            if cur == *index {\n-                                tree = Some(use_tree.clone());\n-                            }\n-\n-                            cur += 1;\n-                        },\n-                    );\n-\n-                    if let Some(tree) = tree {\n-                        sink.push(UnresolvedImport { file: ast.file_id, node: AstPtr::new(&tree) });\n-                    }\n-                }\n-\n-                DiagnosticKind::UnconfiguredCode { ast, cfg, opts } => {\n-                    let item = ast.to_node(db.upcast());\n-                    sink.push(InactiveCode {\n-                        file: ast.file_id,\n-                        node: AstPtr::new(&item).into(),\n-                        cfg: cfg.clone(),\n-                        opts: opts.clone(),\n-                    });\n-                }\n-\n-                DiagnosticKind::UnresolvedProcMacro { ast } => {\n-                    let mut precise_location = None;\n-                    let (file, ast, name) = match ast {\n-                        MacroCallKind::FnLike { ast_id, .. } => {\n-                            let node = ast_id.to_node(db.upcast());\n-                            (ast_id.file_id, SyntaxNodePtr::from(AstPtr::new(&node)), None)\n-                        }\n-                        MacroCallKind::Derive { ast_id, derive_name, .. } => {\n-                            let node = ast_id.to_node(db.upcast());\n-\n-                            // Compute the precise location of the macro name's token in the derive\n-                            // list.\n-                            // FIXME: This does not handle paths to the macro, but neither does the\n-                            // rest of r-a.\n-                            let derive_attrs =\n-                                node.attrs().filter_map(|attr| match attr.as_simple_call() {\n-                                    Some((name, args)) if name == \"derive\" => Some(args),\n-                                    _ => None,\n-                                });\n-                            'outer: for attr in derive_attrs {\n-                                let tokens =\n-                                    attr.syntax().children_with_tokens().filter_map(|elem| {\n-                                        match elem {\n-                                            syntax::NodeOrToken::Node(_) => None,\n-                                            syntax::NodeOrToken::Token(tok) => Some(tok),\n-                                        }\n-                                    });\n-                                for token in tokens {\n-                                    if token.kind() == SyntaxKind::IDENT\n-                                        && token.text() == derive_name.as_str()\n-                                    {\n-                                        precise_location = Some(token.text_range());\n-                                        break 'outer;\n-                                    }\n-                                }\n-                            }\n-\n-                            (\n-                                ast_id.file_id,\n-                                SyntaxNodePtr::from(AstPtr::new(&node)),\n-                                Some(derive_name.clone()),\n-                            )\n-                        }\n-                    };\n-                    sink.push(UnresolvedProcMacro {\n-                        file,\n-                        node: ast,\n-                        precise_location,\n-                        macro_name: name,\n-                    });\n-                }\n-\n-                DiagnosticKind::UnresolvedMacroCall { ast, path } => {\n-                    let node = ast.to_node(db.upcast());\n-                    sink.push(UnresolvedMacroCall {\n-                        file: ast.file_id,\n-                        node: AstPtr::new(&node),\n-                        path: path.clone(),\n-                    });\n-                }\n-\n-                DiagnosticKind::MacroError { ast, message } => {\n-                    let (file, ast) = match ast {\n-                        MacroCallKind::FnLike { ast_id, .. } => {\n-                            let node = ast_id.to_node(db.upcast());\n-                            (ast_id.file_id, SyntaxNodePtr::from(AstPtr::new(&node)))\n-                        }\n-                        MacroCallKind::Derive { ast_id, .. } => {\n-                            let node = ast_id.to_node(db.upcast());\n-                            (ast_id.file_id, SyntaxNodePtr::from(AstPtr::new(&node)))\n-                        }\n-                    };\n-                    sink.push(MacroError { file, node: ast, message: message.clone() });\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "3ea4729080390d8bfeba5b8fa9e19e8eb425f50e", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -33,7 +33,10 @@ use crate::{\n     },\n     macro_call_as_call_id,\n     nameres::{\n-        diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n+        diagnostics::DefDiagnostic,\n+        mod_resolution::ModDir,\n+        path_resolution::ReachedFixedPoint,\n+        proc_macro::{ProcMacroDef, ProcMacroKind},\n         BuiltinShadowMode, DefMap, ModuleData, ModuleOrigin, ResolveMode,\n     },\n     path::{ImportAlias, ModPath, PathKind},\n@@ -44,8 +47,6 @@ use crate::{\n     UnresolvedMacro,\n };\n \n-use super::proc_macro::{ProcMacroDef, ProcMacroKind};\n-\n const GLOB_RECURSION_LIMIT: usize = 100;\n const EXPANSION_DEPTH_LIMIT: usize = 128;\n const FIXED_POINT_LIMIT: usize = 8192;"}, {"sha": "8f2f0ff9f57f77bf4a0d5e0148443e8db0f4e26e", "filename": "crates/hir_def/src/nameres/diagnostics.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fdiagnostics.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -0,0 +1,90 @@\n+//! Diagnostics emitted during DefMap construction.\n+\n+use cfg::{CfgExpr, CfgOptions};\n+use hir_expand::MacroCallKind;\n+use syntax::ast;\n+\n+use crate::{nameres::LocalModuleId, path::ModPath, AstId};\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum DefDiagnosticKind {\n+    UnresolvedModule { ast: AstId<ast::Module>, candidate: String },\n+\n+    UnresolvedExternCrate { ast: AstId<ast::ExternCrate> },\n+\n+    UnresolvedImport { ast: AstId<ast::Use>, index: usize },\n+\n+    UnconfiguredCode { ast: AstId<ast::Item>, cfg: CfgExpr, opts: CfgOptions },\n+\n+    UnresolvedProcMacro { ast: MacroCallKind },\n+\n+    UnresolvedMacroCall { ast: AstId<ast::MacroCall>, path: ModPath },\n+\n+    MacroError { ast: MacroCallKind, message: String },\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct DefDiagnostic {\n+    pub in_module: LocalModuleId,\n+    pub kind: DefDiagnosticKind,\n+}\n+\n+impl DefDiagnostic {\n+    pub(super) fn unresolved_module(\n+        container: LocalModuleId,\n+        declaration: AstId<ast::Module>,\n+        candidate: String,\n+    ) -> Self {\n+        Self {\n+            in_module: container,\n+            kind: DefDiagnosticKind::UnresolvedModule { ast: declaration, candidate },\n+        }\n+    }\n+\n+    pub(super) fn unresolved_extern_crate(\n+        container: LocalModuleId,\n+        declaration: AstId<ast::ExternCrate>,\n+    ) -> Self {\n+        Self {\n+            in_module: container,\n+            kind: DefDiagnosticKind::UnresolvedExternCrate { ast: declaration },\n+        }\n+    }\n+\n+    pub(super) fn unresolved_import(\n+        container: LocalModuleId,\n+        ast: AstId<ast::Use>,\n+        index: usize,\n+    ) -> Self {\n+        Self { in_module: container, kind: DefDiagnosticKind::UnresolvedImport { ast, index } }\n+    }\n+\n+    pub(super) fn unconfigured_code(\n+        container: LocalModuleId,\n+        ast: AstId<ast::Item>,\n+        cfg: CfgExpr,\n+        opts: CfgOptions,\n+    ) -> Self {\n+        Self { in_module: container, kind: DefDiagnosticKind::UnconfiguredCode { ast, cfg, opts } }\n+    }\n+\n+    pub(super) fn unresolved_proc_macro(container: LocalModuleId, ast: MacroCallKind) -> Self {\n+        Self { in_module: container, kind: DefDiagnosticKind::UnresolvedProcMacro { ast } }\n+    }\n+\n+    pub(super) fn macro_error(\n+        container: LocalModuleId,\n+        ast: MacroCallKind,\n+        message: String,\n+    ) -> Self {\n+        Self { in_module: container, kind: DefDiagnosticKind::MacroError { ast, message } }\n+    }\n+\n+    pub(super) fn unresolved_macro_call(\n+        container: LocalModuleId,\n+        ast: AstId<ast::MacroCall>,\n+        path: ModPath,\n+    ) -> Self {\n+        Self { in_module: container, kind: DefDiagnosticKind::UnresolvedMacroCall { ast, path } }\n+    }\n+}"}, {"sha": "ec66709528490182a6b537dcf0cd0302152bf127", "filename": "crates/hir_def/src/nameres/tests/diagnostics.rs", "status": "modified", "additions": 15, "deletions": 42, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -18,48 +18,21 @@ fn unresolved_import() {\n         r\"\n         use does_exist;\n         use does_not_exist;\n-          //^^^^^^^^^^^^^^ unresolved import\n+      //^^^^^^^^^^^^^^^^^^^ UnresolvedImport\n \n         mod does_exist {}\n         \",\n     );\n }\n \n-#[test]\n-fn unresolved_import_in_use_tree() {\n-    // Only the relevant part of a nested `use` item should be highlighted.\n-    check_diagnostics(\n-        r\"\n-        use does_exist::{Exists, DoesntExist};\n-                               //^^^^^^^^^^^ unresolved import\n-\n-        use {does_not_exist::*, does_exist};\n-           //^^^^^^^^^^^^^^^^^ unresolved import\n-\n-        use does_not_exist::{\n-            a,\n-          //^ unresolved import\n-            b,\n-          //^ unresolved import\n-            c,\n-          //^ unresolved import\n-        };\n-\n-        mod does_exist {\n-            pub struct Exists;\n-        }\n-        \",\n-    );\n-}\n-\n #[test]\n fn unresolved_extern_crate() {\n     check_diagnostics(\n         r\"\n         //- /main.rs crate:main deps:core\n         extern crate core;\n           extern crate doesnotexist;\n-        //^^^^^^^^^^^^^^^^^^^^^^^^^^ unresolved extern crate\n+        //^^^^^^^^^^^^^^^^^^^^^^^^^^ UnresolvedExternCrate\n         //- /lib.rs crate:core\n         \",\n     );\n@@ -72,7 +45,7 @@ fn extern_crate_self_as() {\n         r\"\n         //- /lib.rs\n           extern crate doesnotexist;\n-        //^^^^^^^^^^^^^^^^^^^^^^^^^^ unresolved extern crate\n+        //^^^^^^^^^^^^^^^^^^^^^^^^^^ UnresolvedExternCrate\n         // Should not error.\n         extern crate self as foo;\n         struct Foo;\n@@ -88,18 +61,18 @@ fn dedup_unresolved_import_from_unresolved_crate() {\n         //- /main.rs crate:main\n         mod a {\n             extern crate doesnotexist;\n-          //^^^^^^^^^^^^^^^^^^^^^^^^^^ unresolved extern crate\n+          //^^^^^^^^^^^^^^^^^^^^^^^^^^ UnresolvedExternCrate\n \n             // Should not error, since we already errored for the missing crate.\n             use doesnotexist::{self, bla, *};\n \n             use crate::doesnotexist;\n-              //^^^^^^^^^^^^^^^^^^^ unresolved import\n+          //^^^^^^^^^^^^^^^^^^^^^^^^ UnresolvedImport\n         }\n \n         mod m {\n             use super::doesnotexist;\n-              //^^^^^^^^^^^^^^^^^^^ unresolved import\n+          //^^^^^^^^^^^^^^^^^^^^^^^^ UnresolvedImport\n         }\n         \",\n     );\n@@ -112,7 +85,7 @@ fn unresolved_module() {\n         //- /lib.rs\n         mod foo;\n           mod bar;\n-        //^^^^^^^^ unresolved module\n+        //^^^^^^^^ UnresolvedModule\n         mod baz {}\n         //- /foo.rs\n         \",\n@@ -127,16 +100,16 @@ fn inactive_item() {\n         r#\"\n         //- /lib.rs\n           #[cfg(no)] pub fn f() {}\n-        //^^^^^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: no is disabled\n+        //^^^^^^^^^^^^^^^^^^^^^^^^ UnconfiguredCode\n \n           #[cfg(no)] #[cfg(no2)] mod m;\n-        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: no and no2 are disabled\n+        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UnconfiguredCode\n \n           #[cfg(all(not(a), b))] enum E {}\n-        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: b is disabled\n+        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UnconfiguredCode\n \n           #[cfg(feature = \"std\")] use std;\n-        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: feature = \"std\" is disabled\n+        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UnconfiguredCode\n         \"#,\n     );\n }\n@@ -149,14 +122,14 @@ fn inactive_via_cfg_attr() {\n         r#\"\n         //- /lib.rs\n           #[cfg_attr(not(never), cfg(no))] fn f() {}\n-        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: no is disabled\n+        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UnconfiguredCode\n \n           #[cfg_attr(not(never), cfg(not(no)))] fn f() {}\n \n           #[cfg_attr(never, cfg(no))] fn g() {}\n \n           #[cfg_attr(not(never), inline, cfg(no))] fn h() {}\n-        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: no is disabled\n+        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UnconfiguredCode\n         \"#,\n     );\n }\n@@ -170,7 +143,7 @@ fn unresolved_legacy_scope_macro() {\n \n           m!();\n           m2!();\n-        //^^^^^^ unresolved macro `self::m2!`\n+        //^^^^^^ UnresolvedMacroCall\n         \"#,\n     );\n }\n@@ -187,7 +160,7 @@ fn unresolved_module_scope_macro() {\n \n           self::m!();\n           self::m2!();\n-        //^^^^^^^^^^^^ unresolved macro `self::m2!`\n+        //^^^^^^^^^^^^ UnresolvedMacroCall\n         \"#,\n     );\n }"}, {"sha": "d9ec03d2daef1fcb5722fe133057dc8e74e1d5d2", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -71,7 +71,7 @@ impl ModPath {\n     }\n \n     /// Calls `cb` with all paths, represented by this use item.\n-    pub(crate) fn expand_use_item(\n+    pub fn expand_use_item(\n         db: &dyn DefDatabase,\n         item_src: InFile<ast::Use>,\n         hygiene: &Hygiene,"}, {"sha": "6c357c915b5d367eeccdc68ee58138aaa18fecf8", "filename": "crates/hir_def/src/test_db.rs", "status": "modified", "additions": 64, "deletions": 19, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftest_db.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -5,19 +5,20 @@ use std::{\n     sync::{Arc, Mutex},\n };\n \n-use base_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, FilePosition, Upcast};\n+use base_db::{\n+    salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, FilePosition, FileRange, Upcast,\n+};\n use base_db::{AnchoredPath, SourceDatabase};\n-use hir_expand::diagnostics::Diagnostic;\n-use hir_expand::diagnostics::DiagnosticSinkBuilder;\n use hir_expand::{db::AstDatabase, InFile};\n use rustc_hash::FxHashMap;\n use rustc_hash::FxHashSet;\n-use syntax::{algo, ast, AstNode, TextRange, TextSize};\n+use syntax::{algo, ast, AstNode, SyntaxNode, SyntaxNodePtr, TextRange, TextSize};\n use test_utils::extract_annotations;\n \n use crate::{\n+    body::BodyDiagnostic,\n     db::DefDatabase,\n-    nameres::{DefMap, ModuleSource},\n+    nameres::{diagnostics::DefDiagnosticKind, DefMap, ModuleSource},\n     src::HasSource,\n     LocalModuleId, Lookup, ModuleDefId, ModuleId,\n };\n@@ -262,19 +263,70 @@ impl TestDB {\n             .collect()\n     }\n \n-    pub(crate) fn diagnostics<F: FnMut(&dyn Diagnostic)>(&self, mut cb: F) {\n+    pub(crate) fn diagnostics(&self, cb: &mut dyn FnMut(FileRange, String)) {\n         let crate_graph = self.crate_graph();\n         for krate in crate_graph.iter() {\n             let crate_def_map = self.crate_def_map(krate);\n \n-            let mut sink = DiagnosticSinkBuilder::new().build(&mut cb);\n-            for (module_id, module) in crate_def_map.modules() {\n-                crate_def_map.add_diagnostics(self, module_id, &mut sink);\n+            for diag in crate_def_map.diagnostics() {\n+                let (node, message): (InFile<SyntaxNode>, &str) = match &diag.kind {\n+                    DefDiagnosticKind::UnresolvedModule { ast, .. } => {\n+                        let node = ast.to_node(self.upcast());\n+                        (InFile::new(ast.file_id, node.syntax().clone()), \"UnresolvedModule\")\n+                    }\n+                    DefDiagnosticKind::UnresolvedExternCrate { ast, .. } => {\n+                        let node = ast.to_node(self.upcast());\n+                        (InFile::new(ast.file_id, node.syntax().clone()), \"UnresolvedExternCrate\")\n+                    }\n+                    DefDiagnosticKind::UnresolvedImport { ast, .. } => {\n+                        let node = ast.to_node(self.upcast());\n+                        (InFile::new(ast.file_id, node.syntax().clone()), \"UnresolvedImport\")\n+                    }\n+                    DefDiagnosticKind::UnconfiguredCode { ast, .. } => {\n+                        let node = ast.to_node(self.upcast());\n+                        (InFile::new(ast.file_id, node.syntax().clone()), \"UnconfiguredCode\")\n+                    }\n+                    DefDiagnosticKind::UnresolvedProcMacro { ast, .. } => {\n+                        (ast.to_node(self.upcast()), \"UnresolvedProcMacro\")\n+                    }\n+                    DefDiagnosticKind::UnresolvedMacroCall { ast, .. } => {\n+                        let node = ast.to_node(self.upcast());\n+                        (InFile::new(ast.file_id, node.syntax().clone()), \"UnresolvedMacroCall\")\n+                    }\n+                    DefDiagnosticKind::MacroError { ast, message } => {\n+                        (ast.to_node(self.upcast()), message.as_str())\n+                    }\n+                };\n+\n+                let frange = node.as_ref().original_file_range(self);\n+                cb(frange, message.to_string())\n+            }\n \n+            for (_module_id, module) in crate_def_map.modules() {\n                 for decl in module.scope.declarations() {\n                     if let ModuleDefId::FunctionId(it) = decl {\n                         let source_map = self.body_with_source_map(it.into()).1;\n-                        source_map.add_diagnostics(self, &mut sink);\n+                        for diag in source_map.diagnostics() {\n+                            let (ptr, message): (InFile<SyntaxNodePtr>, &str) = match diag {\n+                                BodyDiagnostic::InactiveCode { node, .. } => {\n+                                    (node.clone().map(|it| it.into()), \"InactiveCode\")\n+                                }\n+                                BodyDiagnostic::MacroError { node, message } => {\n+                                    (node.clone().map(|it| it.into()), message.as_str())\n+                                }\n+                                BodyDiagnostic::UnresolvedProcMacro { node } => {\n+                                    (node.clone().map(|it| it.into()), \"UnresolvedProcMacro\")\n+                                }\n+                                BodyDiagnostic::UnresolvedMacroCall { node, .. } => {\n+                                    (node.clone().map(|it| it.into()), \"UnresolvedMacroCall\")\n+                                }\n+                            };\n+\n+                            let root = self.parse_or_expand(ptr.file_id).unwrap();\n+                            let node = ptr.map(|ptr| ptr.to_node(&root));\n+                            let frange = node.as_ref().original_file_range(self);\n+                            cb(frange, message.to_string())\n+                        }\n                     }\n                 }\n             }\n@@ -287,14 +339,7 @@ impl TestDB {\n         assert!(!annotations.is_empty());\n \n         let mut actual: FxHashMap<FileId, Vec<(TextRange, String)>> = FxHashMap::default();\n-        db.diagnostics(|d| {\n-            let src = d.display_source();\n-            let root = db.parse_or_expand(src.file_id).unwrap();\n-\n-            let node = src.map(|ptr| ptr.to_node(&root));\n-            let frange = node.as_ref().original_file_range(db);\n-\n-            let message = d.message();\n+        db.diagnostics(&mut |frange, message| {\n             actual.entry(frange.file_id).or_default().push((frange.range, message));\n         });\n \n@@ -319,7 +364,7 @@ impl TestDB {\n         assert!(annotations.is_empty());\n \n         let mut has_diagnostics = false;\n-        db.diagnostics(|_| {\n+        db.diagnostics(&mut |_, _| {\n             has_diagnostics = true;\n         });\n "}, {"sha": "e8f4af309518285a0820ad854b1e33748caaf577", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -186,7 +186,7 @@ fn parse_macro_expansion(\n         // The final goal we would like to make all parse_macro success,\n         // such that the following log will not call anyway.\n         let loc: MacroCallLoc = db.lookup_intern_macro(macro_file.macro_call_id);\n-        let node = loc.kind.node(db);\n+        let node = loc.kind.to_node(db);\n \n         // collect parent information for warning log\n         let parents ="}, {"sha": "10d37234e77622a0ad47e9cb98de2499f2927f06", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -8,7 +8,6 @@ pub mod db;\n pub mod ast_id_map;\n pub mod name;\n pub mod hygiene;\n-pub mod diagnostics;\n pub mod builtin_derive;\n pub mod builtin_macro;\n pub mod proc_macro;\n@@ -108,7 +107,7 @@ impl HirFileId {\n             HirFileIdRepr::FileId(_) => None,\n             HirFileIdRepr::MacroFile(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro(macro_file.macro_call_id);\n-                Some(loc.kind.node(db))\n+                Some(loc.kind.to_node(db))\n             }\n         }\n     }\n@@ -153,7 +152,7 @@ impl HirFileId {\n             HirFileIdRepr::MacroFile(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro(macro_file.macro_call_id);\n                 let item = match loc.def.kind {\n-                    MacroDefKind::BuiltInDerive(..) => loc.kind.node(db),\n+                    MacroDefKind::BuiltInDerive(..) => loc.kind.to_node(db),\n                     _ => return None,\n                 };\n                 Some(item.with_value(ast::Item::cast(item.value.clone())?))\n@@ -269,7 +268,7 @@ impl MacroCallKind {\n         }\n     }\n \n-    fn node(&self, db: &dyn db::AstDatabase) -> InFile<SyntaxNode> {\n+    pub fn to_node(&self, db: &dyn db::AstDatabase) -> InFile<SyntaxNode> {\n         match self {\n             MacroCallKind::FnLike { ast_id, .. } => {\n                 ast_id.with_value(ast_id.to_node(db).syntax().clone())"}, {"sha": "7598e2193aa17781122eb199477eb1f77b401b20", "filename": "crates/hir_ty/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -8,12 +8,14 @@ use std::{any::Any, fmt};\n \n use base_db::CrateId;\n use hir_def::{DefWithBodyId, ModuleDefId};\n-use hir_expand::diagnostics::{Diagnostic, DiagnosticCode, DiagnosticSink};\n use hir_expand::{name::Name, HirFileId, InFile};\n use stdx::format_to;\n use syntax::{ast, AstPtr, SyntaxNodePtr};\n \n-use crate::db::HirDatabase;\n+use crate::{\n+    db::HirDatabase,\n+    diagnostics_sink::{Diagnostic, DiagnosticCode, DiagnosticSink},\n+};\n \n pub use crate::diagnostics::expr::{record_literal_missing_fields, record_pattern_missing_fields};\n \n@@ -446,15 +448,13 @@ impl Diagnostic for ReplaceFilterMapNextWithFindMap {\n mod tests {\n     use base_db::{fixture::WithFixture, FileId, SourceDatabase, SourceDatabaseExt};\n     use hir_def::{db::DefDatabase, AssocItemId, ModuleDefId};\n-    use hir_expand::{\n-        db::AstDatabase,\n-        diagnostics::{Diagnostic, DiagnosticSinkBuilder},\n-    };\n+    use hir_expand::db::AstDatabase;\n     use rustc_hash::FxHashMap;\n     use syntax::{TextRange, TextSize};\n \n     use crate::{\n         diagnostics::{validate_body, validate_module_item},\n+        diagnostics_sink::{Diagnostic, DiagnosticSinkBuilder},\n         test_db::TestDB,\n     };\n "}, {"sha": "ef982cbcd4fe42118e4d33284d88ad4275eed5f3", "filename": "crates/hir_ty/src/diagnostics/decl_check.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -19,10 +19,7 @@ use hir_def::{\n     src::HasSource,\n     AdtId, AttrDefId, ConstId, EnumId, FunctionId, Lookup, ModuleDefId, StaticId, StructId,\n };\n-use hir_expand::{\n-    diagnostics::DiagnosticSink,\n-    name::{AsName, Name},\n-};\n+use hir_expand::name::{AsName, Name};\n use stdx::{always, never};\n use syntax::{\n     ast::{self, NameOwner},\n@@ -32,6 +29,7 @@ use syntax::{\n use crate::{\n     db::HirDatabase,\n     diagnostics::{decl_check::case_conv::*, CaseType, IdentType, IncorrectCase},\n+    diagnostics_sink::DiagnosticSink,\n };\n \n mod allow {"}, {"sha": "86f82e3fa4505885ef51711a83ac9f77b1cc9bc6", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -5,7 +5,7 @@\n use std::sync::Arc;\n \n use hir_def::{expr::Statement, path::path, resolver::HasResolver, AssocItemId, DefWithBodyId};\n-use hir_expand::{diagnostics::DiagnosticSink, name};\n+use hir_expand::name;\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstPtr};\n \n@@ -16,6 +16,7 @@ use crate::{\n         MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr,\n         MissingPatFields, RemoveThisSemicolon,\n     },\n+    diagnostics_sink::DiagnosticSink,\n     AdtId, InferenceResult, Interner, TyExt, TyKind,\n };\n "}, {"sha": "c3c483425e73eae0a4284844b2df4e1d4551be5e", "filename": "crates/hir_ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -9,10 +9,10 @@ use hir_def::{\n     resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n     DefWithBodyId,\n };\n-use hir_expand::diagnostics::DiagnosticSink;\n \n use crate::{\n-    db::HirDatabase, diagnostics::MissingUnsafe, InferenceResult, Interner, TyExt, TyKind,\n+    db::HirDatabase, diagnostics::MissingUnsafe, diagnostics_sink::DiagnosticSink, InferenceResult,\n+    Interner, TyExt, TyKind,\n };\n \n pub(super) struct UnsafeValidator<'a, 'b: 'a> {"}, {"sha": "084fa8b06aa2c4eb53abcf8ba1cb624c2cc5d640", "filename": "crates/hir_ty/src/diagnostics_sink.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics_sink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics_sink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics_sink.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -16,10 +16,9 @@\n \n use std::{any::Any, fmt};\n \n+use hir_expand::InFile;\n use syntax::SyntaxNodePtr;\n \n-use crate::InFile;\n-\n #[derive(Copy, Clone, Debug, PartialEq)]\n pub struct DiagnosticCode(pub &'static str);\n ", "previous_filename": "crates/hir_expand/src/diagnostics.rs"}, {"sha": "8cefd80f3ab4b7ff9707c2ef937718175a4cf107", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -28,13 +28,14 @@ use hir_def::{\n     AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule, Lookup,\n     TraitId, TypeAliasId, VariantId,\n };\n-use hir_expand::{diagnostics::DiagnosticSink, name::name};\n+use hir_expand::name::name;\n use la_arena::ArenaMap;\n use rustc_hash::FxHashMap;\n use stdx::impl_from;\n use syntax::SmolStr;\n \n use super::{DomainGoal, InEnvironment, ProjectionTy, TraitEnvironment, TraitRef, Ty};\n+use crate::diagnostics_sink::DiagnosticSink;\n use crate::{\n     db::HirDatabase, fold_tys, infer::diagnostics::InferenceDiagnostic,\n     lower::ImplTraitLoweringMode, to_assoc_type_id, AliasEq, AliasTy, Goal, Interner, Substitution,\n@@ -798,11 +799,11 @@ impl std::ops::BitOrAssign for Diverges {\n \n mod diagnostics {\n     use hir_def::{expr::ExprId, DefWithBodyId};\n-    use hir_expand::diagnostics::DiagnosticSink;\n \n     use crate::{\n         db::HirDatabase,\n         diagnostics::{BreakOutsideOfLoop, NoSuchField},\n+        diagnostics_sink::DiagnosticSink,\n     };\n \n     #[derive(Debug, PartialEq, Eq, Clone)]"}, {"sha": "50e0d633333febfe639084aa595dcd52343564d8", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -21,6 +21,7 @@ mod utils;\n mod walk;\n pub mod db;\n pub mod diagnostics;\n+pub mod diagnostics_sink;\n pub mod display;\n pub mod method_resolution;\n pub mod primitive;"}, {"sha": "dcac7c76d20ccd67542a070f675dae2850468030", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 45, "deletions": 20, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5587d0a3e3599063a8993e9a44a7628abbabae8b/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=5587d0a3e3599063a8993e9a44a7628abbabae8b", "patch": "@@ -299,10 +299,10 @@ fn unresolved_fix(id: &'static str, label: &str, target: TextRange) -> Assist {\n \n #[cfg(test)]\n mod tests {\n-    use expect_test::{expect, Expect};\n+    use expect_test::Expect;\n     use ide_assists::AssistResolveStrategy;\n     use stdx::trim_indent;\n-    use test_utils::assert_eq_text;\n+    use test_utils::{assert_eq_text, extract_annotations};\n \n     use crate::{fixture, DiagnosticsConfig};\n \n@@ -396,26 +396,51 @@ mod tests {\n         expect.assert_debug_eq(&diagnostics)\n     }\n \n+    pub(crate) fn check_diagnostics(ra_fixture: &str) {\n+        let (analysis, file_id) = fixture::file(ra_fixture);\n+        let diagnostics = analysis\n+            .diagnostics(&DiagnosticsConfig::default(), AssistResolveStrategy::All, file_id)\n+            .unwrap();\n+\n+        let expected = extract_annotations(&*analysis.file_text(file_id).unwrap());\n+        let actual = diagnostics.into_iter().map(|d| (d.range, d.message)).collect::<Vec<_>>();\n+        assert_eq!(expected, actual);\n+    }\n+\n     #[test]\n     fn test_unresolved_macro_range() {\n-        check_expect(\n-            r#\"foo::bar!(92);\"#,\n-            expect![[r#\"\n-                [\n-                    Diagnostic {\n-                        message: \"unresolved macro `foo::bar!`\",\n-                        range: 5..8,\n-                        severity: Error,\n-                        fixes: None,\n-                        unused: false,\n-                        code: Some(\n-                            DiagnosticCode(\n-                                \"unresolved-macro-call\",\n-                            ),\n-                        ),\n-                    },\n-                ]\n-            \"#]],\n+        check_diagnostics(\n+            r#\"\n+foo::bar!(92);\n+   //^^^ unresolved macro `foo::bar!`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unresolved_import_in_use_tree() {\n+        // Only the relevant part of a nested `use` item should be highlighted.\n+        check_diagnostics(\n+            r#\"\n+use does_exist::{Exists, DoesntExist};\n+                       //^^^^^^^^^^^ unresolved import\n+\n+use {does_not_exist::*, does_exist};\n+   //^^^^^^^^^^^^^^^^^ unresolved import\n+\n+use does_not_exist::{\n+    a,\n+  //^ unresolved import\n+    b,\n+  //^ unresolved import\n+    c,\n+  //^ unresolved import\n+};\n+\n+mod does_exist {\n+    pub struct Exists;\n+}\n+\"#,\n         );\n     }\n "}]}