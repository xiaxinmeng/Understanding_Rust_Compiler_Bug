{"sha": "01836a0f35fa163025c64cabe1d0c34bb4f69c92", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxODM2YTBmMzVmYTE2MzAyNWM2NGNhYmUxZDBjMzRiYjRmNjljOTI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-02-09T11:35:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-09T11:35:08Z"}, "message": "Merge #3050\n\n3050: Refactor type parameters, implement argument position impl trait r=matklad a=flodiebold\n\nI wanted to implement APIT by lowering to type parameters because we need to do that anyway for correctness and don't need Chalk support for it; this grew into some more wide-ranging refactoring of how type parameters are handled :sweat_smile: \r\n\r\n - use Ty::Bound instead of Ty::Param to represent polymorphism, and explicitly\r\n   count binders. This gets us closer to Chalk's way of doing things, and means\r\n   that we now only use Param as a placeholder for an unknown type, e.g. within\r\n   a generic function. I.e. we're never using Param in a situation where we want\r\n   to substitute it, and the method to do that is gone; `subst` now always works\r\n   on bound variables. (This changes how the types of generic functions print; \r\n   previously, you'd get something like `fn identity<i32>(T) -> T`, but now we\r\n   display the substituted signature `fn identity<i32>(i32) -> i32`, which I think \r\n   makes more sense.)\r\n - once we do this, it's more natural to represent `Param` by a globally unique\r\n   ID; the use of indices was mostly to make substituting easier. This also\r\n   means we fix the bug where `Param` loses its name when going through Chalk.\r\n - I would actually like to rename `Param` to `Placeholder` to better reflect its use and\r\n   get closer to Chalk, but I'll leave that to a follow-up.\r\n - introduce a context for type lowering, to allow lowering `impl Trait` to\r\n   different things depending on where we are. And since we have that, we can\r\n   also lower type parameters directly to variables instead of placeholders.\r\n   Also, we'll be able to use this later to collect diagnostics.\r\n - implement argument position impl trait by lowering it to type parameters.\r\n   I've realized that this is necessary to correctly implement it; e.g. consider\r\n   `fn foo(impl Display) -> impl Something`. It's observable that the return\r\n   type of e.g. `foo(1u32)` unifies with itself, but doesn't unify with e.g.\r\n   `foo(1i32)`; so the return type needs to be parameterized by the argument\r\n   type.\r\n\r\n   \r\nThis fixes a few bugs as well:\r\n - type parameters 'losing' their name when they go through Chalk, as mentioned\r\n   above (i.e. getting `[missing name]` somewhere)\r\n - impl trait not being considered as implementing the super traits (very\r\n   noticeable for the `db` in RA)\r\n - the fact that argument impl trait was only turned into variables when the\r\n   function got called caused type mismatches when the function was used as a\r\n   value (fixes a few type mismatches in RA)\r\n\r\nThe one thing I'm not so happy with here is how we're lowering `impl Trait` types to variables; since `TypeRef`s don't have an identity currently, we just count how many of them we have seen while going through the function signature. That's quite fragile though, since we have to do it while desugaring generics and while lowering the type signature, and in the exact same order in both cases. We could consider either giving only `TypeRef::ImplTrait` a local id, or maybe just giving all `TypeRef`s an identity after all (we talked about this before)...\r\n\r\nFollow-up tasks:\r\n - handle return position impl trait; we basically need to create a variable and some trait obligations for that variable\r\n - rename `Param` to `Placeholder`\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "aa1a3cf97173b2885f8b6d23002c73196f9a0b61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa1a3cf97173b2885f8b6d23002c73196f9a0b61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01836a0f35fa163025c64cabe1d0c34bb4f69c92", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeP+5rCRBK7hj4Ov3rIwAAdHIIADzSvERrdK4qBFcj0WjZqrXb\nJIFJKRvbOzT2mxApt3mVowa9W5j44BhzBxLDK0nzhInfUbpIR0oWFLBWp7/r3363\nfWQc522j+B5ZyKKb8GhsESHjiecaYepGG9n65POmj3kUnYCIlN9s50CAwLDJaQKz\n4Y9il6RQZFCAzaB7F/7Qyfw/yniFqDVmeqp8HagUof0EvCO96xI9xdRtw3Hs6vrT\nTUIruzFD2l+pM1InvJNe2yqEwRhbfPQtxroD1oqE6sOrbPpPfNoP9NSfR3+yrIep\nXer/rjqDdaWyQaxJwwsTJlwMbMm1OF18QK9CRBT84EIKUF+CgzvvgxASM45djrY=\n=4Ic+\n-----END PGP SIGNATURE-----\n", "payload": "tree aa1a3cf97173b2885f8b6d23002c73196f9a0b61\nparent 961a69b88f923d4477ca4f746a793217a0cc8576\nparent eefe02ce6e1750b771cf99125429358e87485745\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1581248108 +0000\ncommitter GitHub <noreply@github.com> 1581248108 +0000\n\nMerge #3050\n\n3050: Refactor type parameters, implement argument position impl trait r=matklad a=flodiebold\n\nI wanted to implement APIT by lowering to type parameters because we need to do that anyway for correctness and don't need Chalk support for it; this grew into some more wide-ranging refactoring of how type parameters are handled :sweat_smile: \r\n\r\n - use Ty::Bound instead of Ty::Param to represent polymorphism, and explicitly\r\n   count binders. This gets us closer to Chalk's way of doing things, and means\r\n   that we now only use Param as a placeholder for an unknown type, e.g. within\r\n   a generic function. I.e. we're never using Param in a situation where we want\r\n   to substitute it, and the method to do that is gone; `subst` now always works\r\n   on bound variables. (This changes how the types of generic functions print; \r\n   previously, you'd get something like `fn identity<i32>(T) -> T`, but now we\r\n   display the substituted signature `fn identity<i32>(i32) -> i32`, which I think \r\n   makes more sense.)\r\n - once we do this, it's more natural to represent `Param` by a globally unique\r\n   ID; the use of indices was mostly to make substituting easier. This also\r\n   means we fix the bug where `Param` loses its name when going through Chalk.\r\n - I would actually like to rename `Param` to `Placeholder` to better reflect its use and\r\n   get closer to Chalk, but I'll leave that to a follow-up.\r\n - introduce a context for type lowering, to allow lowering `impl Trait` to\r\n   different things depending on where we are. And since we have that, we can\r\n   also lower type parameters directly to variables instead of placeholders.\r\n   Also, we'll be able to use this later to collect diagnostics.\r\n - implement argument position impl trait by lowering it to type parameters.\r\n   I've realized that this is necessary to correctly implement it; e.g. consider\r\n   `fn foo(impl Display) -> impl Something`. It's observable that the return\r\n   type of e.g. `foo(1u32)` unifies with itself, but doesn't unify with e.g.\r\n   `foo(1i32)`; so the return type needs to be parameterized by the argument\r\n   type.\r\n\r\n   \r\nThis fixes a few bugs as well:\r\n - type parameters 'losing' their name when they go through Chalk, as mentioned\r\n   above (i.e. getting `[missing name]` somewhere)\r\n - impl trait not being considered as implementing the super traits (very\r\n   noticeable for the `db` in RA)\r\n - the fact that argument impl trait was only turned into variables when the\r\n   function got called caused type mismatches when the function was used as a\r\n   value (fixes a few type mismatches in RA)\r\n\r\nThe one thing I'm not so happy with here is how we're lowering `impl Trait` types to variables; since `TypeRef`s don't have an identity currently, we just count how many of them we have seen while going through the function signature. That's quite fragile though, since we have to do it while desugaring generics and while lowering the type signature, and in the exact same order in both cases. We could consider either giving only `TypeRef::ImplTrait` a local id, or maybe just giving all `TypeRef`s an identity after all (we talked about this before)...\r\n\r\nFollow-up tasks:\r\n - handle return position impl trait; we basically need to create a variable and some trait obligations for that variable\r\n - rename `Param` to `Placeholder`\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01836a0f35fa163025c64cabe1d0c34bb4f69c92", "html_url": "https://github.com/rust-lang/rust/commit/01836a0f35fa163025c64cabe1d0c34bb4f69c92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01836a0f35fa163025c64cabe1d0c34bb4f69c92/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "961a69b88f923d4477ca4f746a793217a0cc8576", "url": "https://api.github.com/repos/rust-lang/rust/commits/961a69b88f923d4477ca4f746a793217a0cc8576", "html_url": "https://github.com/rust-lang/rust/commit/961a69b88f923d4477ca4f746a793217a0cc8576"}, {"sha": "eefe02ce6e1750b771cf99125429358e87485745", "url": "https://api.github.com/repos/rust-lang/rust/commits/eefe02ce6e1750b771cf99125429358e87485745", "html_url": "https://github.com/rust-lang/rust/commit/eefe02ce6e1750b771cf99125429358e87485745"}], "stats": {"total": 1788, "additions": 1174, "deletions": 614}, "files": [{"sha": "2701eddb80c53a043244bd589c07813101668457", "filename": "crates/ra_assists/src/handlers/add_new.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -1,5 +1,5 @@\n use format_buf::format;\n-use hir::InFile;\n+use hir::{Adt, InFile};\n use join_to_string::join;\n use ra_syntax::{\n     ast::{\n@@ -135,16 +135,22 @@ fn find_struct_impl(ctx: &AssistCtx, strukt: &ast::StructDef) -> Option<Option<a\n     })?;\n     let mut sb = ctx.source_binder();\n \n-    let struct_ty = {\n+    let struct_def = {\n         let src = InFile { file_id: ctx.frange.file_id.into(), value: strukt.clone() };\n-        sb.to_def(src)?.ty(db)\n+        sb.to_def(src)?\n     };\n \n     let block = module.descendants().filter_map(ast::ImplBlock::cast).find_map(|impl_blk| {\n         let src = InFile { file_id: ctx.frange.file_id.into(), value: impl_blk.clone() };\n         let blk = sb.to_def(src)?;\n \n-        let same_ty = blk.target_ty(db) == struct_ty;\n+        // FIXME: handle e.g. `struct S<T>; impl<U> S<U> {}`\n+        // (we currently use the wrong type parameter)\n+        // also we wouldn't want to use e.g. `impl S<u32>`\n+        let same_ty = match blk.target_ty(db).as_adt() {\n+            Some(def) => def == Adt::Struct(struct_def),\n+            None => false,\n+        };\n         let not_trait_impl = blk.target_trait(db).is_none();\n \n         if !(same_ty && not_trait_impl) {"}, {"sha": "4d96417285420cdb1e60862e97d6560491aee445", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -10,9 +10,9 @@ use hir_def::{\n     per_ns::PerNs,\n     resolver::HasResolver,\n     type_ref::{Mutability, TypeRef},\n-    AdtId, ConstId, DefWithBodyId, EnumId, FunctionId, HasModule, ImplId, LocalEnumVariantId,\n-    LocalModuleId, LocalStructFieldId, Lookup, ModuleId, StaticId, StructId, TraitId, TypeAliasId,\n-    TypeParamId, UnionId,\n+    AdtId, ConstId, DefWithBodyId, EnumId, FunctionId, GenericDefId, HasModule, ImplId,\n+    LocalEnumVariantId, LocalModuleId, LocalStructFieldId, Lookup, ModuleId, StaticId, StructId,\n+    TraitId, TypeAliasId, TypeParamId, UnionId,\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n@@ -21,7 +21,7 @@ use hir_expand::{\n };\n use hir_ty::{\n     autoderef, display::HirFormatter, expr::ExprValidator, method_resolution, ApplicationTy,\n-    Canonical, InEnvironment, TraitEnvironment, Ty, TyDefId, TypeCtor, TypeWalk,\n+    Canonical, InEnvironment, Substs, TraitEnvironment, Ty, TyDefId, TypeCtor,\n };\n use ra_db::{CrateId, Edition, FileId};\n use ra_prof::profile;\n@@ -270,7 +270,13 @@ impl StructField {\n \n     pub fn ty(&self, db: &impl HirDatabase) -> Type {\n         let var_id = self.parent.into();\n-        let ty = db.field_types(var_id)[self.id].clone();\n+        let generic_def_id: GenericDefId = match self.parent {\n+            VariantDef::Struct(it) => it.id.into(),\n+            VariantDef::Union(it) => it.id.into(),\n+            VariantDef::EnumVariant(it) => it.parent.id.into(),\n+        };\n+        let substs = Substs::type_params(db, generic_def_id);\n+        let ty = db.field_types(var_id)[self.id].clone().subst(&substs);\n         Type::new(db, self.parent.module(db).id.krate.into(), var_id, ty)\n     }\n \n@@ -755,7 +761,7 @@ pub struct TypeParam {\n impl TypeParam {\n     pub fn name(self, db: &impl HirDatabase) -> Name {\n         let params = db.generic_params(self.id.parent);\n-        params.types[self.id.local_id].name.clone()\n+        params.types[self.id.local_id].name.clone().unwrap_or_else(Name::missing)\n     }\n \n     pub fn module(self, db: &impl HirDatabase) -> Module {\n@@ -789,8 +795,9 @@ impl ImplBlock {\n     pub fn target_ty(&self, db: &impl HirDatabase) -> Type {\n         let impl_data = db.impl_data(self.id);\n         let resolver = self.id.resolver(db);\n+        let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n         let environment = TraitEnvironment::lower(db, &resolver);\n-        let ty = Ty::from_hir(db, &resolver, &impl_data.target_type);\n+        let ty = Ty::from_hir(&ctx, &impl_data.target_type);\n         Type {\n             krate: self.id.lookup(db).container.module(db).krate,\n             ty: InEnvironment { value: ty, environment },\n@@ -851,9 +858,10 @@ impl Type {\n     fn from_def(\n         db: &impl HirDatabase,\n         krate: CrateId,\n-        def: impl HasResolver + Into<TyDefId>,\n+        def: impl HasResolver + Into<TyDefId> + Into<GenericDefId>,\n     ) -> Type {\n-        let ty = db.ty(def.into());\n+        let substs = Substs::type_params(db, def);\n+        let ty = db.ty(def.into()).subst(&substs);\n         Type::new(db, krate, def, ty)\n     }\n \n@@ -950,7 +958,7 @@ impl Type {\n             match a_ty.ctor {\n                 TypeCtor::Tuple { .. } => {\n                     for ty in a_ty.parameters.iter() {\n-                        let ty = ty.clone().subst(&a_ty.parameters);\n+                        let ty = ty.clone();\n                         res.push(self.derived(ty));\n                     }\n                 }"}, {"sha": "bb9a35c5d1224de747bca1bf29fb4d52e0bb6c0e", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -178,6 +178,10 @@ impl SourceAnalyzer {\n         }\n     }\n \n+    fn trait_env(&self, db: &impl HirDatabase) -> Arc<TraitEnvironment> {\n+        TraitEnvironment::lower(db, &self.resolver)\n+    }\n+\n     pub fn type_of(&self, db: &impl HirDatabase, expr: &ast::Expr) -> Option<Type> {\n         let expr_id = if let Some(expr) = self.expand_expr(db, InFile::new(self.file_id, expr)) {\n             self.body_source_map.as_ref()?.node_expr(expr.as_ref())?\n@@ -186,14 +190,14 @@ impl SourceAnalyzer {\n         };\n \n         let ty = self.infer.as_ref()?[expr_id].clone();\n-        let environment = TraitEnvironment::lower(db, &self.resolver);\n+        let environment = self.trait_env(db);\n         Some(Type { krate: self.resolver.krate()?, ty: InEnvironment { value: ty, environment } })\n     }\n \n     pub fn type_of_pat(&self, db: &impl HirDatabase, pat: &ast::Pat) -> Option<Type> {\n         let pat_id = self.pat_id(pat)?;\n         let ty = self.infer.as_ref()?[pat_id].clone();\n-        let environment = TraitEnvironment::lower(db, &self.resolver);\n+        let environment = self.trait_env(db);\n         Some(Type { krate: self.resolver.krate()?, ty: InEnvironment { value: ty, environment } })\n     }\n "}, {"sha": "f765e6edc202b84e38543ea5ec8d45e3262a3835", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 66, "deletions": 7, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -27,8 +27,16 @@ use crate::{\n /// Data about a generic parameter (to a function, struct, impl, ...).\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct TypeParamData {\n-    pub name: Name,\n+    pub name: Option<Name>,\n     pub default: Option<TypeRef>,\n+    pub provenance: TypeParamProvenance,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum TypeParamProvenance {\n+    TypeParamList,\n+    TraitSelf,\n+    ArgumentImplTrait,\n }\n \n /// Data about the generic parameters of a function, struct, impl, etc.\n@@ -45,10 +53,17 @@ pub struct GenericParams {\n /// associated type bindings like `Iterator<Item = u32>`.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct WherePredicate {\n-    pub type_ref: TypeRef,\n+    pub target: WherePredicateTarget,\n     pub bound: TypeBound,\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum WherePredicateTarget {\n+    TypeRef(TypeRef),\n+    /// For desugared where predicates that can directly refer to a type param.\n+    TypeParam(LocalTypeParamId),\n+}\n+\n type SourceMap = ArenaMap<LocalTypeParamId, Either<ast::TraitDef, ast::TypeParam>>;\n \n impl GenericParams {\n@@ -68,6 +83,11 @@ impl GenericParams {\n             GenericDefId::FunctionId(it) => {\n                 let src = it.lookup(db).source(db);\n                 generics.fill(&mut sm, &src.value);\n+                // lower `impl Trait` in arguments\n+                let data = db.function_data(it);\n+                for param in &data.params {\n+                    generics.fill_implicit_impl_trait_args(param);\n+                }\n                 src.file_id\n             }\n             GenericDefId::AdtId(AdtId::StructId(it)) => {\n@@ -89,8 +109,11 @@ impl GenericParams {\n                 let src = it.lookup(db).source(db);\n \n                 // traits get the Self type as an implicit first type parameter\n-                let self_param_id =\n-                    generics.types.alloc(TypeParamData { name: name![Self], default: None });\n+                let self_param_id = generics.types.alloc(TypeParamData {\n+                    name: Some(name![Self]),\n+                    default: None,\n+                    provenance: TypeParamProvenance::TraitSelf,\n+                });\n                 sm.insert(self_param_id, Either::Left(src.value.clone()));\n                 // add super traits as bounds on Self\n                 // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n@@ -142,7 +165,11 @@ impl GenericParams {\n             let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n             // FIXME: Use `Path::from_src`\n             let default = type_param.default_type().map(TypeRef::from_ast);\n-            let param = TypeParamData { name: name.clone(), default };\n+            let param = TypeParamData {\n+                name: Some(name.clone()),\n+                default,\n+                provenance: TypeParamProvenance::TypeParamList,\n+            };\n             let param_id = self.types.alloc(param);\n             sm.insert(param_id, Either::Right(type_param.clone()));\n \n@@ -170,11 +197,43 @@ impl GenericParams {\n             return;\n         }\n         let bound = TypeBound::from_ast(bound);\n-        self.where_predicates.push(WherePredicate { type_ref, bound });\n+        self.where_predicates\n+            .push(WherePredicate { target: WherePredicateTarget::TypeRef(type_ref), bound });\n+    }\n+\n+    fn fill_implicit_impl_trait_args(&mut self, type_ref: &TypeRef) {\n+        type_ref.walk(&mut |type_ref| {\n+            if let TypeRef::ImplTrait(bounds) = type_ref {\n+                let param = TypeParamData {\n+                    name: None,\n+                    default: None,\n+                    provenance: TypeParamProvenance::ArgumentImplTrait,\n+                };\n+                let param_id = self.types.alloc(param);\n+                for bound in bounds {\n+                    self.where_predicates.push(WherePredicate {\n+                        target: WherePredicateTarget::TypeParam(param_id),\n+                        bound: bound.clone(),\n+                    });\n+                }\n+            }\n+        });\n     }\n \n     pub fn find_by_name(&self, name: &Name) -> Option<LocalTypeParamId> {\n-        self.types.iter().find_map(|(id, p)| if &p.name == name { Some(id) } else { None })\n+        self.types\n+            .iter()\n+            .find_map(|(id, p)| if p.name.as_ref() == Some(name) { Some(id) } else { None })\n+    }\n+\n+    pub fn find_trait_self_param(&self) -> Option<LocalTypeParamId> {\n+        self.types.iter().find_map(|(id, p)| {\n+            if p.provenance == TypeParamProvenance::TraitSelf {\n+                Some(id)\n+            } else {\n+                None\n+            }\n+        })\n     }\n }\n "}, {"sha": "05cf4646a897ab16ea2ce26a7c1f7676818dc7f3", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -490,10 +490,12 @@ impl Scope {\n             }\n             Scope::GenericParams { params, def } => {\n                 for (local_id, param) in params.types.iter() {\n-                    f(\n-                        param.name.clone(),\n-                        ScopeDef::GenericParam(TypeParamId { local_id, parent: *def }),\n-                    )\n+                    if let Some(name) = &param.name {\n+                        f(\n+                            name.clone(),\n+                            ScopeDef::GenericParam(TypeParamId { local_id, parent: *def }),\n+                        )\n+                    }\n                 }\n             }\n             Scope::ImplBlockScope(i) => {"}, {"sha": "102fdb13d72f5ed70e1f20e6100ac10739328b32", "filename": "crates/ra_hir_def/src/type_ref.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -124,6 +124,48 @@ impl TypeRef {\n     pub(crate) fn unit() -> TypeRef {\n         TypeRef::Tuple(Vec::new())\n     }\n+\n+    pub fn walk(&self, f: &mut impl FnMut(&TypeRef)) {\n+        go(self, f);\n+\n+        fn go(type_ref: &TypeRef, f: &mut impl FnMut(&TypeRef)) {\n+            f(type_ref);\n+            match type_ref {\n+                TypeRef::Fn(types) | TypeRef::Tuple(types) => types.iter().for_each(|t| go(t, f)),\n+                TypeRef::RawPtr(type_ref, _)\n+                | TypeRef::Reference(type_ref, _)\n+                | TypeRef::Array(type_ref)\n+                | TypeRef::Slice(type_ref) => go(&type_ref, f),\n+                TypeRef::ImplTrait(bounds) | TypeRef::DynTrait(bounds) => {\n+                    for bound in bounds {\n+                        match bound {\n+                            TypeBound::Path(path) => go_path(path, f),\n+                            TypeBound::Error => (),\n+                        }\n+                    }\n+                }\n+                TypeRef::Path(path) => go_path(path, f),\n+                TypeRef::Never | TypeRef::Placeholder | TypeRef::Error => {}\n+            };\n+        }\n+\n+        fn go_path(path: &Path, f: &mut impl FnMut(&TypeRef)) {\n+            if let Some(type_ref) = path.type_anchor() {\n+                go(type_ref, f);\n+            }\n+            for segment in path.segments().iter() {\n+                if let Some(args_and_bindings) = segment.args_and_bindings {\n+                    for arg in &args_and_bindings.args {\n+                        let crate::path::GenericArg::Type(type_ref) = arg;\n+                        go(type_ref, f);\n+                    }\n+                    for (_, type_ref) in &args_and_bindings.bindings {\n+                        go(type_ref, f);\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n pub(crate) fn type_bounds_from_ast(type_bounds_opt: Option<ast::TypeBoundList>) -> Vec<TypeBound> {"}, {"sha": "e9bfcfa176808b661bbfb310c6abba6253656d14", "filename": "crates/ra_hir_ty/src/db.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -3,17 +3,18 @@\n use std::sync::Arc;\n \n use hir_def::{\n-    db::DefDatabase, DefWithBodyId, GenericDefId, ImplId, LocalStructFieldId, TraitId, VariantId,\n+    db::DefDatabase, DefWithBodyId, GenericDefId, ImplId, LocalStructFieldId, TraitId, TypeParamId,\n+    VariantId,\n };\n use ra_arena::map::ArenaMap;\n-use ra_db::{salsa, CrateId};\n+use ra_db::{impl_intern_key, salsa, CrateId};\n use ra_prof::profile;\n \n use crate::{\n     method_resolution::CrateImplBlocks,\n     traits::{chalk, AssocTyValue, Impl},\n-    CallableDef, FnSig, GenericPredicate, InferenceResult, Substs, TraitRef, Ty, TyDefId, TypeCtor,\n-    ValueTyDefId,\n+    Binders, CallableDef, GenericPredicate, InferenceResult, PolyFnSig, Substs, TraitRef, Ty,\n+    TyDefId, TypeCtor, ValueTyDefId,\n };\n \n #[salsa::query_group(HirDatabaseStorage)]\n@@ -27,34 +28,33 @@ pub trait HirDatabase: DefDatabase {\n \n     #[salsa::invoke(crate::lower::ty_query)]\n     #[salsa::cycle(crate::lower::ty_recover)]\n-    fn ty(&self, def: TyDefId) -> Ty;\n+    fn ty(&self, def: TyDefId) -> Binders<Ty>;\n \n     #[salsa::invoke(crate::lower::value_ty_query)]\n-    fn value_ty(&self, def: ValueTyDefId) -> Ty;\n+    fn value_ty(&self, def: ValueTyDefId) -> Binders<Ty>;\n \n     #[salsa::invoke(crate::lower::impl_self_ty_query)]\n     #[salsa::cycle(crate::lower::impl_self_ty_recover)]\n-    fn impl_self_ty(&self, def: ImplId) -> Ty;\n+    fn impl_self_ty(&self, def: ImplId) -> Binders<Ty>;\n \n     #[salsa::invoke(crate::lower::impl_trait_query)]\n-    fn impl_trait(&self, def: ImplId) -> Option<TraitRef>;\n+    fn impl_trait(&self, def: ImplId) -> Option<Binders<TraitRef>>;\n \n     #[salsa::invoke(crate::lower::field_types_query)]\n-    fn field_types(&self, var: VariantId) -> Arc<ArenaMap<LocalStructFieldId, Ty>>;\n+    fn field_types(&self, var: VariantId) -> Arc<ArenaMap<LocalStructFieldId, Binders<Ty>>>;\n \n     #[salsa::invoke(crate::callable_item_sig)]\n-    fn callable_item_signature(&self, def: CallableDef) -> FnSig;\n+    fn callable_item_signature(&self, def: CallableDef) -> PolyFnSig;\n \n     #[salsa::invoke(crate::lower::generic_predicates_for_param_query)]\n     #[salsa::cycle(crate::lower::generic_predicates_for_param_recover)]\n     fn generic_predicates_for_param(\n         &self,\n-        def: GenericDefId,\n-        param_idx: u32,\n-    ) -> Arc<[GenericPredicate]>;\n+        param_id: TypeParamId,\n+    ) -> Arc<[Binders<GenericPredicate>]>;\n \n     #[salsa::invoke(crate::lower::generic_predicates_query)]\n-    fn generic_predicates(&self, def: GenericDefId) -> Arc<[GenericPredicate]>;\n+    fn generic_predicates(&self, def: GenericDefId) -> Arc<[Binders<GenericPredicate>]>;\n \n     #[salsa::invoke(crate::lower::generic_defaults_query)]\n     fn generic_defaults(&self, def: GenericDefId) -> Substs;\n@@ -77,6 +77,8 @@ pub trait HirDatabase: DefDatabase {\n     #[salsa::interned]\n     fn intern_type_ctor(&self, type_ctor: TypeCtor) -> crate::TypeCtorId;\n     #[salsa::interned]\n+    fn intern_type_param_id(&self, param_id: TypeParamId) -> GlobalTypeParamId;\n+    #[salsa::interned]\n     fn intern_chalk_impl(&self, impl_: Impl) -> crate::traits::GlobalImplId;\n     #[salsa::interned]\n     fn intern_assoc_ty_value(&self, assoc_ty_value: AssocTyValue) -> crate::traits::AssocTyValueId;\n@@ -117,3 +119,7 @@ fn infer(db: &impl HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult> {\n fn hir_database_is_object_safe() {\n     fn _assert_object_safe(_: &dyn HirDatabase) {}\n }\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct GlobalTypeParamId(salsa::InternId);\n+impl_intern_key!(GlobalTypeParamId);"}, {"sha": "a9d958c8bcdad9f1689ab5d427905b22ed60a386", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 28, "deletions": 38, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -34,15 +34,16 @@ use hir_expand::{diagnostics::DiagnosticSink, name::name};\n use ra_arena::map::ArenaMap;\n use ra_prof::profile;\n use ra_syntax::SmolStr;\n-use test_utils::tested_by;\n \n use super::{\n     primitive::{FloatTy, IntTy},\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n     ApplicationTy, GenericPredicate, InEnvironment, ProjectionTy, Substs, TraitEnvironment,\n     TraitRef, Ty, TypeCtor, TypeWalk, Uncertain,\n };\n-use crate::{db::HirDatabase, infer::diagnostics::InferenceDiagnostic};\n+use crate::{\n+    db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode,\n+};\n \n pub(crate) use unify::unify;\n \n@@ -271,38 +272,21 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.result.diagnostics.push(diagnostic);\n     }\n \n-    fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n-        let ty = Ty::from_hir(\n-            self.db,\n-            // FIXME use right resolver for block\n-            &self.resolver,\n-            type_ref,\n-        );\n+    fn make_ty_with_mode(\n+        &mut self,\n+        type_ref: &TypeRef,\n+        impl_trait_mode: ImplTraitLoweringMode,\n+    ) -> Ty {\n+        // FIXME use right resolver for block\n+        let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver)\n+            .with_impl_trait_mode(impl_trait_mode);\n+        let ty = Ty::from_hir(&ctx, type_ref);\n         let ty = self.insert_type_vars(ty);\n         self.normalize_associated_types_in(ty)\n     }\n \n-    /// Replaces `impl Trait` in `ty` by type variables and obligations for\n-    /// those variables. This is done for function arguments when calling a\n-    /// function, and for return types when inside the function body, i.e. in\n-    /// the cases where the `impl Trait` is 'transparent'. In other cases, `impl\n-    /// Trait` is represented by `Ty::Opaque`.\n-    fn insert_vars_for_impl_trait(&mut self, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty {\n-            Ty::Opaque(preds) => {\n-                tested_by!(insert_vars_for_impl_trait);\n-                let var = self.table.new_type_var();\n-                let var_subst = Substs::builder(1).push(var.clone()).build();\n-                self.obligations.extend(\n-                    preds\n-                        .iter()\n-                        .map(|pred| pred.clone().subst_bound_vars(&var_subst))\n-                        .filter_map(Obligation::from_predicate),\n-                );\n-                var\n-            }\n-            _ => ty,\n-        })\n+    fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n+        self.make_ty_with_mode(type_ref, ImplTraitLoweringMode::Disallowed)\n     }\n \n     /// Replaces Ty::Unknown by a new type var, so we can maybe still infer it.\n@@ -446,19 +430,20 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             None => return (Ty::Unknown, None),\n         };\n         let resolver = &self.resolver;\n+        let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         // FIXME: this should resolve assoc items as well, see this example:\n         // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n         match resolver.resolve_path_in_type_ns_fully(self.db, path.mod_path()) {\n             Some(TypeNs::AdtId(AdtId::StructId(strukt))) => {\n-                let substs = Ty::substs_from_path(self.db, resolver, path, strukt.into());\n+                let substs = Ty::substs_from_path(&ctx, path, strukt.into());\n                 let ty = self.db.ty(strukt.into());\n-                let ty = self.insert_type_vars(ty.apply_substs(substs));\n+                let ty = self.insert_type_vars(ty.subst(&substs));\n                 (ty, Some(strukt.into()))\n             }\n             Some(TypeNs::EnumVariantId(var)) => {\n-                let substs = Ty::substs_from_path(self.db, resolver, path, var.into());\n+                let substs = Ty::substs_from_path(&ctx, path, var.into());\n                 let ty = self.db.ty(var.parent.into());\n-                let ty = self.insert_type_vars(ty.apply_substs(substs));\n+                let ty = self.insert_type_vars(ty.subst(&substs));\n                 (ty, Some(var.into()))\n             }\n             Some(_) | None => (Ty::Unknown, None),\n@@ -471,13 +456,18 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn collect_fn(&mut self, data: &FunctionData) {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n-        for (type_ref, pat) in data.params.iter().zip(body.params.iter()) {\n-            let ty = self.make_ty(type_ref);\n+        let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver)\n+            .with_impl_trait_mode(ImplTraitLoweringMode::Param);\n+        let param_tys =\n+            data.params.iter().map(|type_ref| Ty::from_hir(&ctx, type_ref)).collect::<Vec<_>>();\n+        for (ty, pat) in param_tys.into_iter().zip(body.params.iter()) {\n+            let ty = self.insert_type_vars(ty);\n+            let ty = self.normalize_associated_types_in(ty);\n \n             self.infer_pat(*pat, &ty, BindingMode::default());\n         }\n-        let return_ty = self.make_ty(&data.ret_type);\n-        self.return_ty = self.insert_vars_for_impl_trait(return_ty);\n+        let return_ty = self.make_ty_with_mode(&data.ret_type, ImplTraitLoweringMode::Disallowed); // FIXME implement RPIT\n+        self.return_ty = return_ty;\n     }\n \n     fn infer_body(&mut self) {"}, {"sha": "f68a1439f8f132ae86bcd2cdd1dd348b21a9a508", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -57,18 +57,16 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let trait_ref = db.impl_trait(impl_id)?;\n \n                 // `CoerseUnsized` has one generic parameter for the target type.\n-                let cur_from_ty = trait_ref.substs.0.get(0)?;\n-                let cur_to_ty = trait_ref.substs.0.get(1)?;\n+                let cur_from_ty = trait_ref.value.substs.0.get(0)?;\n+                let cur_to_ty = trait_ref.value.substs.0.get(1)?;\n \n                 match (&cur_from_ty, cur_to_ty) {\n                     (ty_app!(ctor1, st1), ty_app!(ctor2, st2)) => {\n                         // FIXME: We return the first non-equal bound as the type parameter to coerce to unsized type.\n                         // This works for smart-pointer-like coercion, which covers all impls from std.\n                         st1.iter().zip(st2.iter()).enumerate().find_map(|(i, (ty1, ty2))| {\n                             match (ty1, ty2) {\n-                                (Ty::Param { idx: p1, .. }, Ty::Param { idx: p2, .. })\n-                                    if p1 != p2 =>\n-                                {\n+                                (Ty::Bound(idx1), Ty::Bound(idx2)) if idx1 != idx2 => {\n                                     Some(((*ctor1, *ctor2), i))\n                                 }\n                                 _ => None,\n@@ -256,8 +254,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let unsize_generic_index = {\n                     let mut index = None;\n                     let mut multiple_param = false;\n-                    field_tys[last_field_id].walk(&mut |ty| match ty {\n-                        &Ty::Param { idx, .. } => {\n+                    field_tys[last_field_id].value.walk(&mut |ty| match ty {\n+                        &Ty::Bound(idx) => {\n                             if index.is_none() {\n                                 index = Some(idx);\n                             } else if Some(idx) != index {\n@@ -276,10 +274,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 // Check other fields do not involve it.\n                 let mut multiple_used = false;\n                 fields.for_each(|(field_id, _data)| {\n-                    field_tys[field_id].walk(&mut |ty| match ty {\n-                        &Ty::Param { idx, .. } if idx == unsize_generic_index => {\n-                            multiple_used = true\n-                        }\n+                    field_tys[field_id].value.walk(&mut |ty| match ty {\n+                        &Ty::Bound(idx) if idx == unsize_generic_index => multiple_used = true,\n                         _ => {}\n                     })\n                 });"}, {"sha": "3c9c02d03ed516bce3a4ff12ef9c9547da644697", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -10,7 +10,7 @@ use hir_def::{\n     resolver::resolver_for_expr,\n     AdtId, AssocContainerId, Lookup, StructFieldId,\n };\n-use hir_expand::name::{name, Name};\n+use hir_expand::name::Name;\n use ra_syntax::ast::RangeOp;\n \n use crate::{\n@@ -19,8 +19,8 @@ use crate::{\n     method_resolution, op,\n     traits::InEnvironment,\n     utils::{generics, variant_data, Generics},\n-    ApplicationTy, CallableDef, InferTy, IntTy, Mutability, Obligation, Substs, TraitRef, Ty,\n-    TypeCtor, TypeWalk, Uncertain,\n+    ApplicationTy, Binders, CallableDef, InferTy, IntTy, Mutability, Obligation, Substs, TraitRef,\n+    Ty, TypeCtor, Uncertain,\n };\n \n use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};\n@@ -236,8 +236,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         self.result.record_field_resolutions.insert(field.expr, field_def);\n                     }\n                     let field_ty = field_def\n-                        .map_or(Ty::Unknown, |it| field_types[it.local_id].clone())\n-                        .subst(&substs);\n+                        .map_or(Ty::Unknown, |it| field_types[it.local_id].clone().subst(&substs));\n                     self.infer_expr_coerce(field.expr, &Expectation::has_type(field_ty));\n                 }\n                 if let Some(expr) = spread {\n@@ -588,10 +587,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 self.write_method_resolution(tgt_expr, func);\n                 (ty, self.db.value_ty(func.into()), Some(generics(self.db, func.into())))\n             }\n-            None => (receiver_ty, Ty::Unknown, None),\n+            None => (receiver_ty, Binders::new(0, Ty::Unknown), None),\n         };\n         let substs = self.substs_for_method_call(def_generics, generic_args, &derefed_receiver_ty);\n-        let method_ty = method_ty.apply_substs(substs);\n+        let method_ty = method_ty.subst(&substs);\n         let method_ty = self.insert_type_vars(method_ty);\n         self.register_obligations_for_call(&method_ty);\n         let (expected_receiver_ty, param_tys, ret_ty) = match method_ty.callable_sig(self.db) {\n@@ -635,7 +634,6 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     continue;\n                 }\n \n-                let param_ty = self.insert_vars_for_impl_trait(param_ty);\n                 let param_ty = self.normalize_associated_types_in(param_ty);\n                 self.infer_expr_coerce(arg, &Expectation::has_type(param_ty.clone()));\n             }\n@@ -648,13 +646,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         generic_args: Option<&GenericArgs>,\n         receiver_ty: &Ty,\n     ) -> Substs {\n-        let (total_len, _parent_len, child_len) =\n-            def_generics.as_ref().map_or((0, 0, 0), |g| g.len_split());\n+        let (parent_params, self_params, type_params, impl_trait_params) =\n+            def_generics.as_ref().map_or((0, 0, 0, 0), |g| g.provenance_split());\n+        assert_eq!(self_params, 0); // method shouldn't have another Self param\n+        let total_len = parent_params + type_params + impl_trait_params;\n         let mut substs = Vec::with_capacity(total_len);\n         // Parent arguments are unknown, except for the receiver type\n         if let Some(parent_generics) = def_generics.as_ref().map(|p| p.iter_parent()) {\n             for (_id, param) in parent_generics {\n-                if param.name == name![Self] {\n+                if param.provenance == hir_def::generics::TypeParamProvenance::TraitSelf {\n                     substs.push(receiver_ty.clone());\n                 } else {\n                     substs.push(Ty::Unknown);\n@@ -664,7 +664,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         // handle provided type arguments\n         if let Some(generic_args) = generic_args {\n             // if args are provided, it should be all of them, but we can't rely on that\n-            for arg in generic_args.args.iter().take(child_len) {\n+            for arg in generic_args.args.iter().take(type_params) {\n                 match arg {\n                     GenericArg::Type(type_ref) => {\n                         let ty = self.make_ty(type_ref);"}, {"sha": "e7283f24cd35ef71ddbf0f4fc48d1583cb52a95f", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -12,7 +12,7 @@ use hir_expand::name::Name;\n use test_utils::tested_by;\n \n use super::{BindingMode, InferenceContext};\n-use crate::{db::HirDatabase, utils::variant_data, Substs, Ty, TypeCtor, TypeWalk};\n+use crate::{db::HirDatabase, utils::variant_data, Substs, Ty, TypeCtor};\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn infer_tuple_struct_pat(\n@@ -34,8 +34,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             let expected_ty = var_data\n                 .as_ref()\n                 .and_then(|d| d.field(&Name::new_tuple_field(i)))\n-                .map_or(Ty::Unknown, |field| field_tys[field].clone())\n-                .subst(&substs);\n+                .map_or(Ty::Unknown, |field| field_tys[field].clone().subst(&substs));\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat, &expected_ty, default_bm);\n         }\n@@ -65,7 +64,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         for subpat in subpats {\n             let matching_field = var_data.as_ref().and_then(|it| it.field(&subpat.name));\n             let expected_ty =\n-                matching_field.map_or(Ty::Unknown, |field| field_tys[field].clone()).subst(&substs);\n+                matching_field.map_or(Ty::Unknown, |field| field_tys[field].clone().subst(&substs));\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat.pat, &expected_ty, default_bm);\n         }"}, {"sha": "686ce7a218b2d4ca50fd8b45670b38be800bebdc", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -9,9 +9,9 @@ use hir_def::{\n };\n use hir_expand::name::Name;\n \n-use crate::{db::HirDatabase, method_resolution, Substs, Ty, TypeWalk, ValueTyDefId};\n+use crate::{db::HirDatabase, method_resolution, Substs, Ty, ValueTyDefId};\n \n-use super::{ExprOrPatId, InferenceContext, TraitEnvironment, TraitRef};\n+use super::{ExprOrPatId, InferenceContext, TraitRef};\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     pub(super) fn infer_path(\n@@ -39,7 +39,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             let ty = self.make_ty(type_ref);\n             let remaining_segments_for_ty = path.segments().take(path.segments().len() - 1);\n-            let ty = Ty::from_type_relative_path(self.db, resolver, ty, remaining_segments_for_ty);\n+            let ctx = crate::lower::TyLoweringContext::new(self.db, &resolver);\n+            let ty = Ty::from_type_relative_path(&ctx, ty, remaining_segments_for_ty);\n             self.resolve_ty_assoc_item(\n                 ty,\n                 &path.segments().last().expect(\"path had at least one segment\").name,\n@@ -69,12 +70,16 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             ValueNs::EnumVariantId(it) => it.into(),\n         };\n \n-        let mut ty = self.db.value_ty(typable);\n-        if let Some(self_subst) = self_subst {\n-            ty = ty.subst(&self_subst);\n-        }\n-        let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n-        let ty = ty.subst(&substs);\n+        let ty = self.db.value_ty(typable);\n+        // self_subst is just for the parent\n+        let parent_substs = self_subst.unwrap_or_else(Substs::empty);\n+        let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n+        let substs = Ty::substs_from_path(&ctx, path, typable);\n+        let full_substs = Substs::builder(substs.len())\n+            .use_parent_substs(&parent_substs)\n+            .fill(substs.0[parent_substs.len()..].iter().cloned())\n+            .build();\n+        let ty = ty.subst(&full_substs);\n         Some(ty)\n     }\n \n@@ -98,13 +103,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             (TypeNs::TraitId(trait_), true) => {\n                 let segment =\n                     remaining_segments.last().expect(\"there should be at least one segment here\");\n-                let trait_ref = TraitRef::from_resolved_path(\n-                    self.db,\n-                    &self.resolver,\n-                    trait_.into(),\n-                    resolved_segment,\n-                    None,\n-                );\n+                let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n+                let trait_ref =\n+                    TraitRef::from_resolved_path(&ctx, trait_.into(), resolved_segment, None);\n                 self.resolve_trait_assoc_item(trait_ref, segment, id)\n             }\n             (def, _) => {\n@@ -114,9 +115,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 // as Iterator>::Item::default`)\n                 let remaining_segments_for_ty =\n                     remaining_segments.take(remaining_segments.len() - 1);\n+                let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n                 let ty = Ty::from_partly_resolved_hir_path(\n-                    self.db,\n-                    &self.resolver,\n+                    &ctx,\n                     def,\n                     resolved_segment,\n                     remaining_segments_for_ty,\n@@ -173,13 +174,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             AssocItemId::ConstId(c) => ValueNs::ConstId(c),\n             AssocItemId::TypeAliasId(_) => unreachable!(),\n         };\n-        let substs = Substs::build_for_def(self.db, item)\n-            .use_parent_substs(&trait_ref.substs)\n-            .fill_with_params()\n-            .build();\n \n         self.write_assoc_resolution(id, item);\n-        Some((def, Some(substs)))\n+        Some((def, Some(trait_ref.substs)))\n     }\n \n     fn resolve_ty_assoc_item(\n@@ -193,14 +190,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n \n         let canonical_ty = self.canonicalizer().canonicalize_ty(ty.clone());\n-        let env = TraitEnvironment::lower(self.db, &self.resolver);\n         let krate = self.resolver.krate()?;\n         let traits_in_scope = self.resolver.traits_in_scope(self.db);\n \n         method_resolution::iterate_method_candidates(\n             &canonical_ty.value,\n             self.db,\n-            env,\n+            self.trait_env.clone(),\n             krate,\n             &traits_in_scope,\n             Some(name),\n@@ -219,28 +215,20 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             .fill(iter::repeat_with(|| self.table.new_type_var()))\n                             .build();\n                         let impl_self_ty = self.db.impl_self_ty(impl_id).subst(&impl_substs);\n-                        let substs = Substs::build_for_def(self.db, item)\n-                            .use_parent_substs(&impl_substs)\n-                            .fill_with_params()\n-                            .build();\n                         self.unify(&impl_self_ty, &ty);\n-                        Some(substs)\n+                        Some(impl_substs)\n                     }\n                     AssocContainerId::TraitId(trait_) => {\n                         // we're picking this method\n                         let trait_substs = Substs::build_for_def(self.db, trait_)\n                             .push(ty.clone())\n                             .fill(std::iter::repeat_with(|| self.table.new_type_var()))\n                             .build();\n-                        let substs = Substs::build_for_def(self.db, item)\n-                            .use_parent_substs(&trait_substs)\n-                            .fill_with_params()\n-                            .build();\n                         self.obligations.push(super::Obligation::Trait(TraitRef {\n                             trait_,\n-                            substs: trait_substs,\n+                            substs: trait_substs.clone(),\n                         }));\n-                        Some(substs)\n+                        Some(trait_substs)\n                     }\n                     AssocContainerId::ContainerId(_) => None,\n                 };"}, {"sha": "c5fe18c8550d3468c1c8e162d829079c42524153", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 154, "deletions": 108, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -44,8 +44,8 @@ use std::sync::Arc;\n use std::{fmt, iter, mem};\n \n use hir_def::{\n-    expr::ExprId, type_ref::Mutability, AdtId, AssocContainerId, DefWithBodyId, GenericDefId,\n-    HasModule, Lookup, TraitId, TypeAliasId,\n+    expr::ExprId, generics::TypeParamProvenance, type_ref::Mutability, AdtId, AssocContainerId,\n+    DefWithBodyId, GenericDefId, HasModule, Lookup, TraitId, TypeAliasId, TypeParamId,\n };\n use hir_expand::name::Name;\n use ra_db::{impl_intern_key, salsa, CrateId};\n@@ -60,7 +60,9 @@ use display::{HirDisplay, HirFormatter};\n pub use autoderef::autoderef;\n pub use infer::{do_infer_query, InferTy, InferenceResult};\n pub use lower::CallableDef;\n-pub use lower::{callable_item_sig, TyDefId, ValueTyDefId};\n+pub use lower::{\n+    callable_item_sig, ImplTraitLoweringMode, TyDefId, TyLoweringContext, ValueTyDefId,\n+};\n pub use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n \n /// A type constructor or type name: this might be something like the primitive\n@@ -285,22 +287,20 @@ pub enum Ty {\n     /// trait and all its parameters are fully known.\n     Projection(ProjectionTy),\n \n-    /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n-    Param {\n-        /// The index of the parameter (starting with parameters from the\n-        /// surrounding impl, then the current function).\n-        idx: u32,\n-        /// The name of the parameter, for displaying.\n-        // FIXME get rid of this\n-        name: Name,\n-    },\n-\n-    /// A bound type variable. Used during trait resolution to represent Chalk\n-    /// variables, and in `Dyn` and `Opaque` bounds to represent the `Self` type.\n+    /// A placeholder for a type parameter; for example, `T` in `fn f<T>(x: T)\n+    /// {}` when we're type-checking the body of that function. In this\n+    /// situation, we know this stands for *some* type, but don't know the exact\n+    /// type.\n+    Param(TypeParamId),\n+\n+    /// A bound type variable. This is used in various places: when representing\n+    /// some polymorphic type like the type of function `fn f<T>`, the type\n+    /// parameters get turned into variables; during trait resolution, inference\n+    /// variables get turned into bound variables and back; and in `Dyn` the\n+    /// `Self` type is represented with a bound variable as well.\n     Bound(u32),\n \n-    /// A type variable used during type checking. Not to be confused with a\n-    /// type parameter.\n+    /// A type variable used during type checking.\n     Infer(InferTy),\n \n     /// A trait object (`dyn Trait` or bare `Trait` in pre-2018 Rust).\n@@ -364,15 +364,19 @@ impl Substs {\n     }\n \n     /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n-    pub(crate) fn identity(generic_params: &Generics) -> Substs {\n-        Substs(\n-            generic_params.iter().map(|(idx, p)| Ty::Param { idx, name: p.name.clone() }).collect(),\n-        )\n+    pub(crate) fn type_params_for_generics(generic_params: &Generics) -> Substs {\n+        Substs(generic_params.iter().map(|(id, _)| Ty::Param(id)).collect())\n+    }\n+\n+    /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n+    pub fn type_params(db: &impl HirDatabase, def: impl Into<GenericDefId>) -> Substs {\n+        let params = generics(db, def.into());\n+        Substs::type_params_for_generics(&params)\n     }\n \n     /// Return Substs that replace each parameter by a bound variable.\n     pub(crate) fn bound_vars(generic_params: &Generics) -> Substs {\n-        Substs(generic_params.iter().map(|(idx, _p)| Ty::Bound(idx)).collect())\n+        Substs(generic_params.iter().enumerate().map(|(idx, _)| Ty::Bound(idx as u32)).collect())\n     }\n \n     pub fn build_for_def(db: &impl HirDatabase, def: impl Into<GenericDefId>) -> SubstsBuilder {\n@@ -420,11 +424,6 @@ impl SubstsBuilder {\n         self.fill((starting_from..).map(Ty::Bound))\n     }\n \n-    pub fn fill_with_params(self) -> Self {\n-        let start = self.vec.len() as u32;\n-        self.fill((start..).map(|idx| Ty::Param { idx, name: Name::missing() }))\n-    }\n-\n     pub fn fill_with_unknown(self) -> Self {\n         self.fill(iter::repeat(Ty::Unknown))\n     }\n@@ -451,6 +450,32 @@ impl Deref for Substs {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct Binders<T> {\n+    pub num_binders: usize,\n+    pub value: T,\n+}\n+\n+impl<T> Binders<T> {\n+    pub fn new(num_binders: usize, value: T) -> Self {\n+        Self { num_binders, value }\n+    }\n+}\n+\n+impl<T: TypeWalk> Binders<T> {\n+    /// Substitutes all variables.\n+    pub fn subst(self, subst: &Substs) -> T {\n+        assert_eq!(subst.len(), self.num_binders);\n+        self.value.subst_bound_vars(subst)\n+    }\n+\n+    /// Substitutes just a prefix of the variables (shifting the rest).\n+    pub fn subst_prefix(self, subst: &Substs) -> Binders<T> {\n+        assert!(subst.len() < self.num_binders);\n+        Binders::new(self.num_binders - subst.len(), self.value.subst_bound_vars(subst))\n+    }\n+}\n+\n /// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n /// Name to be bikeshedded: TraitBound? TraitImplements?\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n@@ -551,6 +576,9 @@ pub struct FnSig {\n     params_and_return: Arc<[Ty]>,\n }\n \n+/// A polymorphic function signature.\n+pub type PolyFnSig = Binders<FnSig>;\n+\n impl FnSig {\n     pub fn from_params_and_return(mut params: Vec<Ty>, ret: Ty) -> FnSig {\n         params.push(ret);\n@@ -730,22 +758,7 @@ pub trait TypeWalk {\n         self\n     }\n \n-    /// Replaces type parameters in this type using the given `Substs`. (So e.g.\n-    /// if `self` is `&[T]`, where type parameter T has index 0, and the\n-    /// `Substs` contain `u32` at index 0, we'll have `&[u32]` afterwards.)\n-    fn subst(self, substs: &Substs) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.fold(&mut |ty| match ty {\n-            Ty::Param { idx, name } => {\n-                substs.get(idx as usize).cloned().unwrap_or(Ty::Param { idx, name })\n-            }\n-            ty => ty,\n-        })\n-    }\n-\n-    /// Substitutes `Ty::Bound` vars (as opposed to type parameters).\n+    /// Substitutes `Ty::Bound` vars with the given substitution.\n     fn subst_bound_vars(mut self, substs: &Substs) -> Self\n     where\n         Self: Sized,\n@@ -755,6 +768,9 @@ pub trait TypeWalk {\n                 &mut Ty::Bound(idx) => {\n                     if idx as usize >= binders && (idx as usize - binders) < substs.len() {\n                         *ty = substs.0[idx as usize - binders].clone();\n+                    } else if idx as usize >= binders + substs.len() {\n+                        // shift free binders\n+                        *ty = Ty::Bound(idx - substs.len() as u32);\n                     }\n                 }\n                 _ => {}\n@@ -880,7 +896,7 @@ impl HirDisplay for ApplicationTy {\n                 write!(f, \") -> {}\", sig.ret().display(f.db))?;\n             }\n             TypeCtor::FnDef(def) => {\n-                let sig = f.db.callable_item_signature(def);\n+                let sig = f.db.callable_item_signature(def).subst(&self.parameters);\n                 let name = match def {\n                     CallableDef::FunctionId(ff) => f.db.function_data(ff).name.clone(),\n                     CallableDef::StructId(s) => f.db.struct_data(s).name.clone(),\n@@ -896,9 +912,16 @@ impl HirDisplay for ApplicationTy {\n                     }\n                 }\n                 if self.parameters.len() > 0 {\n-                    write!(f, \"<\")?;\n-                    f.write_joined(&*self.parameters.0, \", \")?;\n-                    write!(f, \">\")?;\n+                    let generics = generics(f.db, def.into());\n+                    let (parent_params, self_param, type_params, _impl_trait_params) =\n+                        generics.provenance_split();\n+                    let total_len = parent_params + self_param + type_params;\n+                    // We print all params except implicit impl Trait params. Still a bit weird; should we leave out parent and self?\n+                    if total_len > 0 {\n+                        write!(f, \"<\")?;\n+                        f.write_joined(&self.parameters.0[..total_len], \", \")?;\n+                        write!(f, \">\")?;\n+                    }\n                 }\n                 write!(f, \"(\")?;\n                 f.write_joined(sig.params(), \", \")?;\n@@ -1009,74 +1032,32 @@ impl HirDisplay for Ty {\n         match self {\n             Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n             Ty::Projection(p_ty) => p_ty.hir_fmt(f)?,\n-            Ty::Param { name, .. } => write!(f, \"{}\", name)?,\n+            Ty::Param(id) => {\n+                let generics = generics(f.db, id.parent);\n+                let param_data = &generics.params.types[id.local_id];\n+                match param_data.provenance {\n+                    TypeParamProvenance::TypeParamList | TypeParamProvenance::TraitSelf => {\n+                        write!(f, \"{}\", param_data.name.clone().unwrap_or_else(Name::missing))?\n+                    }\n+                    TypeParamProvenance::ArgumentImplTrait => {\n+                        write!(f, \"impl \")?;\n+                        let bounds = f.db.generic_predicates_for_param(*id);\n+                        let substs = Substs::type_params_for_generics(&generics);\n+                        write_bounds_like_dyn_trait(\n+                            &bounds.iter().map(|b| b.clone().subst(&substs)).collect::<Vec<_>>(),\n+                            f,\n+                        )?;\n+                    }\n+                }\n+            }\n             Ty::Bound(idx) => write!(f, \"?{}\", idx)?,\n             Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n                 match self {\n                     Ty::Dyn(_) => write!(f, \"dyn \")?,\n                     Ty::Opaque(_) => write!(f, \"impl \")?,\n                     _ => unreachable!(),\n                 };\n-                // Note: This code is written to produce nice results (i.e.\n-                // corresponding to surface Rust) for types that can occur in\n-                // actual Rust. It will have weird results if the predicates\n-                // aren't as expected (i.e. self types = $0, projection\n-                // predicates for a certain trait come after the Implemented\n-                // predicate for that trait).\n-                let mut first = true;\n-                let mut angle_open = false;\n-                for p in predicates.iter() {\n-                    match p {\n-                        GenericPredicate::Implemented(trait_ref) => {\n-                            if angle_open {\n-                                write!(f, \">\")?;\n-                            }\n-                            if !first {\n-                                write!(f, \" + \")?;\n-                            }\n-                            // We assume that the self type is $0 (i.e. the\n-                            // existential) here, which is the only thing that's\n-                            // possible in actual Rust, and hence don't print it\n-                            write!(f, \"{}\", f.db.trait_data(trait_ref.trait_).name.clone())?;\n-                            if trait_ref.substs.len() > 1 {\n-                                write!(f, \"<\")?;\n-                                f.write_joined(&trait_ref.substs[1..], \", \")?;\n-                                // there might be assoc type bindings, so we leave the angle brackets open\n-                                angle_open = true;\n-                            }\n-                        }\n-                        GenericPredicate::Projection(projection_pred) => {\n-                            // in types in actual Rust, these will always come\n-                            // after the corresponding Implemented predicate\n-                            if angle_open {\n-                                write!(f, \", \")?;\n-                            } else {\n-                                write!(f, \"<\")?;\n-                                angle_open = true;\n-                            }\n-                            let name =\n-                                f.db.type_alias_data(projection_pred.projection_ty.associated_ty)\n-                                    .name\n-                                    .clone();\n-                            write!(f, \"{} = \", name)?;\n-                            projection_pred.ty.hir_fmt(f)?;\n-                        }\n-                        GenericPredicate::Error => {\n-                            if angle_open {\n-                                // impl Trait<X, {error}>\n-                                write!(f, \", \")?;\n-                            } else if !first {\n-                                // impl Trait + {error}\n-                                write!(f, \" + \")?;\n-                            }\n-                            p.hir_fmt(f)?;\n-                        }\n-                    }\n-                    first = false;\n-                }\n-                if angle_open {\n-                    write!(f, \">\")?;\n-                }\n+                write_bounds_like_dyn_trait(&predicates, f)?;\n             }\n             Ty::Unknown => write!(f, \"{{unknown}}\")?,\n             Ty::Infer(..) => write!(f, \"_\")?,\n@@ -1085,6 +1066,71 @@ impl HirDisplay for Ty {\n     }\n }\n \n+fn write_bounds_like_dyn_trait(\n+    predicates: &[GenericPredicate],\n+    f: &mut HirFormatter<impl HirDatabase>,\n+) -> fmt::Result {\n+    // Note: This code is written to produce nice results (i.e.\n+    // corresponding to surface Rust) for types that can occur in\n+    // actual Rust. It will have weird results if the predicates\n+    // aren't as expected (i.e. self types = $0, projection\n+    // predicates for a certain trait come after the Implemented\n+    // predicate for that trait).\n+    let mut first = true;\n+    let mut angle_open = false;\n+    for p in predicates.iter() {\n+        match p {\n+            GenericPredicate::Implemented(trait_ref) => {\n+                if angle_open {\n+                    write!(f, \">\")?;\n+                }\n+                if !first {\n+                    write!(f, \" + \")?;\n+                }\n+                // We assume that the self type is $0 (i.e. the\n+                // existential) here, which is the only thing that's\n+                // possible in actual Rust, and hence don't print it\n+                write!(f, \"{}\", f.db.trait_data(trait_ref.trait_).name.clone())?;\n+                if trait_ref.substs.len() > 1 {\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&trait_ref.substs[1..], \", \")?;\n+                    // there might be assoc type bindings, so we leave the angle brackets open\n+                    angle_open = true;\n+                }\n+            }\n+            GenericPredicate::Projection(projection_pred) => {\n+                // in types in actual Rust, these will always come\n+                // after the corresponding Implemented predicate\n+                if angle_open {\n+                    write!(f, \", \")?;\n+                } else {\n+                    write!(f, \"<\")?;\n+                    angle_open = true;\n+                }\n+                let name =\n+                    f.db.type_alias_data(projection_pred.projection_ty.associated_ty).name.clone();\n+                write!(f, \"{} = \", name)?;\n+                projection_pred.ty.hir_fmt(f)?;\n+            }\n+            GenericPredicate::Error => {\n+                if angle_open {\n+                    // impl Trait<X, {error}>\n+                    write!(f, \", \")?;\n+                } else if !first {\n+                    // impl Trait + {error}\n+                    write!(f, \" + \")?;\n+                }\n+                p.hir_fmt(f)?;\n+            }\n+        }\n+        first = false;\n+    }\n+    if angle_open {\n+        write!(f, \">\")?;\n+    }\n+    Ok(())\n+}\n+\n impl TraitRef {\n     fn hir_fmt_ext(&self, f: &mut HirFormatter<impl HirDatabase>, use_as: bool) -> fmt::Result {\n         if f.should_truncate() {"}, {"sha": "c68c5852be77bba8828a4b93c737327d27cd3518", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 370, "deletions": 207, "changes": 577, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -10,12 +10,13 @@ use std::sync::Arc;\n \n use hir_def::{\n     builtin_type::BuiltinType,\n-    generics::WherePredicate,\n+    generics::{TypeParamProvenance, WherePredicate, WherePredicateTarget},\n     path::{GenericArg, Path, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n     AdtId, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule, ImplId,\n-    LocalStructFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId, UnionId, VariantId,\n+    LocalStructFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId, TypeParamId, UnionId,\n+    VariantId,\n };\n use ra_arena::map::ArenaMap;\n use ra_db::CrateId;\n@@ -27,63 +28,158 @@ use crate::{\n         all_super_traits, associated_type_by_name_including_super_traits, generics, make_mut_slice,\n         variant_data,\n     },\n-    FnSig, GenericPredicate, ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, TraitRef,\n-    Ty, TypeCtor, TypeWalk,\n+    Binders, FnSig, GenericPredicate, PolyFnSig, ProjectionPredicate, ProjectionTy, Substs,\n+    TraitEnvironment, TraitRef, Ty, TypeCtor,\n };\n \n+#[derive(Debug)]\n+pub struct TyLoweringContext<'a, DB: HirDatabase> {\n+    pub db: &'a DB,\n+    pub resolver: &'a Resolver,\n+    /// Note: Conceptually, it's thinkable that we could be in a location where\n+    /// some type params should be represented as placeholders, and others\n+    /// should be converted to variables. I think in practice, this isn't\n+    /// possible currently, so this should be fine for now.\n+    pub type_param_mode: TypeParamLoweringMode,\n+    pub impl_trait_mode: ImplTraitLoweringMode,\n+    pub impl_trait_counter: std::cell::Cell<u16>,\n+}\n+\n+impl<'a, DB: HirDatabase> TyLoweringContext<'a, DB> {\n+    pub fn new(db: &'a DB, resolver: &'a Resolver) -> Self {\n+        let impl_trait_counter = std::cell::Cell::new(0);\n+        let impl_trait_mode = ImplTraitLoweringMode::Disallowed;\n+        let type_param_mode = TypeParamLoweringMode::Placeholder;\n+        Self { db, resolver, impl_trait_mode, impl_trait_counter, type_param_mode }\n+    }\n+\n+    pub fn with_impl_trait_mode(self, impl_trait_mode: ImplTraitLoweringMode) -> Self {\n+        Self { impl_trait_mode, ..self }\n+    }\n+\n+    pub fn with_type_param_mode(self, type_param_mode: TypeParamLoweringMode) -> Self {\n+        Self { type_param_mode, ..self }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum ImplTraitLoweringMode {\n+    /// `impl Trait` gets lowered into an opaque type that doesn't unify with\n+    /// anything except itself. This is used in places where values flow 'out',\n+    /// i.e. for arguments of the function we're currently checking, and return\n+    /// types of functions we're calling.\n+    Opaque,\n+    /// `impl Trait` gets lowered into a type variable. Used for argument\n+    /// position impl Trait when inside the respective function, since it allows\n+    /// us to support that without Chalk.\n+    Param,\n+    /// `impl Trait` gets lowered into a variable that can unify with some\n+    /// type. This is used in places where values flow 'in', i.e. for arguments\n+    /// of functions we're calling, and the return type of the function we're\n+    /// currently checking.\n+    Variable,\n+    /// `impl Trait` is disallowed and will be an error.\n+    Disallowed,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum TypeParamLoweringMode {\n+    Placeholder,\n+    Variable,\n+}\n+\n impl Ty {\n-    pub fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n+    pub fn from_hir(ctx: &TyLoweringContext<'_, impl HirDatabase>, type_ref: &TypeRef) -> Self {\n         match type_ref {\n             TypeRef::Never => Ty::simple(TypeCtor::Never),\n             TypeRef::Tuple(inner) => {\n-                let inner_tys: Arc<[Ty]> =\n-                    inner.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect();\n+                let inner_tys: Arc<[Ty]> = inner.iter().map(|tr| Ty::from_hir(ctx, tr)).collect();\n                 Ty::apply(\n                     TypeCtor::Tuple { cardinality: inner_tys.len() as u16 },\n                     Substs(inner_tys),\n                 )\n             }\n-            TypeRef::Path(path) => Ty::from_hir_path(db, resolver, path),\n+            TypeRef::Path(path) => Ty::from_hir_path(ctx, path),\n             TypeRef::RawPtr(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, resolver, inner);\n+                let inner_ty = Ty::from_hir(ctx, inner);\n                 Ty::apply_one(TypeCtor::RawPtr(*mutability), inner_ty)\n             }\n             TypeRef::Array(inner) => {\n-                let inner_ty = Ty::from_hir(db, resolver, inner);\n+                let inner_ty = Ty::from_hir(ctx, inner);\n                 Ty::apply_one(TypeCtor::Array, inner_ty)\n             }\n             TypeRef::Slice(inner) => {\n-                let inner_ty = Ty::from_hir(db, resolver, inner);\n+                let inner_ty = Ty::from_hir(ctx, inner);\n                 Ty::apply_one(TypeCtor::Slice, inner_ty)\n             }\n             TypeRef::Reference(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, resolver, inner);\n+                let inner_ty = Ty::from_hir(ctx, inner);\n                 Ty::apply_one(TypeCtor::Ref(*mutability), inner_ty)\n             }\n             TypeRef::Placeholder => Ty::Unknown,\n             TypeRef::Fn(params) => {\n-                let sig = Substs(params.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect());\n+                let sig = Substs(params.iter().map(|tr| Ty::from_hir(ctx, tr)).collect());\n                 Ty::apply(TypeCtor::FnPtr { num_args: sig.len() as u16 - 1 }, sig)\n             }\n             TypeRef::DynTrait(bounds) => {\n                 let self_ty = Ty::Bound(0);\n                 let predicates = bounds\n                     .iter()\n-                    .flat_map(|b| {\n-                        GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone())\n-                    })\n+                    .flat_map(|b| GenericPredicate::from_type_bound(ctx, b, self_ty.clone()))\n                     .collect();\n                 Ty::Dyn(predicates)\n             }\n             TypeRef::ImplTrait(bounds) => {\n-                let self_ty = Ty::Bound(0);\n-                let predicates = bounds\n-                    .iter()\n-                    .flat_map(|b| {\n-                        GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone())\n-                    })\n-                    .collect();\n-                Ty::Opaque(predicates)\n+                match ctx.impl_trait_mode {\n+                    ImplTraitLoweringMode::Opaque => {\n+                        let self_ty = Ty::Bound(0);\n+                        let predicates = bounds\n+                            .iter()\n+                            .flat_map(|b| {\n+                                GenericPredicate::from_type_bound(ctx, b, self_ty.clone())\n+                            })\n+                            .collect();\n+                        Ty::Opaque(predicates)\n+                    }\n+                    ImplTraitLoweringMode::Param => {\n+                        let idx = ctx.impl_trait_counter.get();\n+                        ctx.impl_trait_counter.set(idx + 1);\n+                        if let Some(def) = ctx.resolver.generic_def() {\n+                            let generics = generics(ctx.db, def);\n+                            let param = generics\n+                                .iter()\n+                                .filter(|(_, data)| {\n+                                    data.provenance == TypeParamProvenance::ArgumentImplTrait\n+                                })\n+                                .nth(idx as usize)\n+                                .map_or(Ty::Unknown, |(id, _)| Ty::Param(id));\n+                            param\n+                        } else {\n+                            Ty::Unknown\n+                        }\n+                    }\n+                    ImplTraitLoweringMode::Variable => {\n+                        let idx = ctx.impl_trait_counter.get();\n+                        ctx.impl_trait_counter.set(idx + 1);\n+                        let (parent_params, self_params, list_params, _impl_trait_params) =\n+                            if let Some(def) = ctx.resolver.generic_def() {\n+                                let generics = generics(ctx.db, def);\n+                                generics.provenance_split()\n+                            } else {\n+                                (0, 0, 0, 0)\n+                            };\n+                        Ty::Bound(\n+                            idx as u32\n+                                + parent_params as u32\n+                                + self_params as u32\n+                                + list_params as u32,\n+                        )\n+                    }\n+                    ImplTraitLoweringMode::Disallowed => {\n+                        // FIXME: report error\n+                        Ty::Unknown\n+                    }\n+                }\n             }\n             TypeRef::Error => Ty::Unknown,\n         }\n@@ -93,10 +189,9 @@ impl Ty {\n     /// lower the self types of the predicates since that could lead to cycles.\n     /// So we just check here if the `type_ref` resolves to a generic param, and which.\n     fn from_hir_only_param(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         type_ref: &TypeRef,\n-    ) -> Option<u32> {\n+    ) -> Option<TypeParamId> {\n         let path = match type_ref {\n             TypeRef::Path(path) => path,\n             _ => return None,\n@@ -107,29 +202,26 @@ impl Ty {\n         if path.segments().len() > 1 {\n             return None;\n         }\n-        let resolution = match resolver.resolve_path_in_type_ns(db, path.mod_path()) {\n+        let resolution = match ctx.resolver.resolve_path_in_type_ns(ctx.db, path.mod_path()) {\n             Some((it, None)) => it,\n             _ => return None,\n         };\n         if let TypeNs::GenericParam(param_id) = resolution {\n-            let generics = generics(db, resolver.generic_def().expect(\"generics in scope\"));\n-            let idx = generics.param_idx(param_id);\n-            Some(idx)\n+            Some(param_id)\n         } else {\n             None\n         }\n     }\n \n     pub(crate) fn from_type_relative_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         ty: Ty,\n         remaining_segments: PathSegments<'_>,\n     ) -> Ty {\n         if remaining_segments.len() == 1 {\n             // resolve unselected assoc types\n             let segment = remaining_segments.first().unwrap();\n-            Ty::select_associated_type(db, resolver, ty, segment)\n+            Ty::select_associated_type(ctx, ty, segment)\n         } else if remaining_segments.len() > 1 {\n             // FIXME report error (ambiguous associated type)\n             Ty::Unknown\n@@ -139,20 +231,18 @@ impl Ty {\n     }\n \n     pub(crate) fn from_partly_resolved_hir_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         resolution: TypeNs,\n         resolved_segment: PathSegment<'_>,\n         remaining_segments: PathSegments<'_>,\n     ) -> Ty {\n         let ty = match resolution {\n             TypeNs::TraitId(trait_) => {\n-                let trait_ref =\n-                    TraitRef::from_resolved_path(db, resolver, trait_, resolved_segment, None);\n+                let trait_ref = TraitRef::from_resolved_path(ctx, trait_, resolved_segment, None);\n                 return if remaining_segments.len() == 1 {\n                     let segment = remaining_segments.first().unwrap();\n                     let associated_ty = associated_type_by_name_including_super_traits(\n-                        db,\n+                        ctx.db,\n                         trait_ref.trait_,\n                         &segment.name,\n                     );\n@@ -177,37 +267,55 @@ impl Ty {\n                 };\n             }\n             TypeNs::GenericParam(param_id) => {\n-                let generics = generics(db, resolver.generic_def().expect(\"generics in scope\"));\n-                let idx = generics.param_idx(param_id);\n-                // FIXME: maybe return name in resolution?\n-                let name = generics.param_name(param_id);\n-                Ty::Param { idx, name }\n+                let generics =\n+                    generics(ctx.db, ctx.resolver.generic_def().expect(\"generics in scope\"));\n+                match ctx.type_param_mode {\n+                    TypeParamLoweringMode::Placeholder => Ty::Param(param_id),\n+                    TypeParamLoweringMode::Variable => {\n+                        let idx = generics.param_idx(param_id).expect(\"matching generics\");\n+                        Ty::Bound(idx)\n+                    }\n+                }\n             }\n-            TypeNs::SelfType(impl_id) => db.impl_self_ty(impl_id).clone(),\n-            TypeNs::AdtSelfType(adt) => db.ty(adt.into()),\n-\n-            TypeNs::AdtId(it) => Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into()),\n-            TypeNs::BuiltinType(it) => {\n-                Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into())\n+            TypeNs::SelfType(impl_id) => {\n+                let generics = generics(ctx.db, impl_id.into());\n+                let substs = match ctx.type_param_mode {\n+                    TypeParamLoweringMode::Placeholder => {\n+                        Substs::type_params_for_generics(&generics)\n+                    }\n+                    TypeParamLoweringMode::Variable => Substs::bound_vars(&generics),\n+                };\n+                ctx.db.impl_self_ty(impl_id).subst(&substs)\n             }\n-            TypeNs::TypeAliasId(it) => {\n-                Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into())\n+            TypeNs::AdtSelfType(adt) => {\n+                let generics = generics(ctx.db, adt.into());\n+                let substs = match ctx.type_param_mode {\n+                    TypeParamLoweringMode::Placeholder => {\n+                        Substs::type_params_for_generics(&generics)\n+                    }\n+                    TypeParamLoweringMode::Variable => Substs::bound_vars(&generics),\n+                };\n+                ctx.db.ty(adt.into()).subst(&substs)\n             }\n+\n+            TypeNs::AdtId(it) => Ty::from_hir_path_inner(ctx, resolved_segment, it.into()),\n+            TypeNs::BuiltinType(it) => Ty::from_hir_path_inner(ctx, resolved_segment, it.into()),\n+            TypeNs::TypeAliasId(it) => Ty::from_hir_path_inner(ctx, resolved_segment, it.into()),\n             // FIXME: report error\n             TypeNs::EnumVariantId(_) => return Ty::Unknown,\n         };\n \n-        Ty::from_type_relative_path(db, resolver, ty, remaining_segments)\n+        Ty::from_type_relative_path(ctx, ty, remaining_segments)\n     }\n \n-    pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Ty {\n+    pub(crate) fn from_hir_path(ctx: &TyLoweringContext<'_, impl HirDatabase>, path: &Path) -> Ty {\n         // Resolve the path (in type namespace)\n         if let Some(type_ref) = path.type_anchor() {\n-            let ty = Ty::from_hir(db, resolver, &type_ref);\n-            return Ty::from_type_relative_path(db, resolver, ty, path.segments());\n+            let ty = Ty::from_hir(ctx, &type_ref);\n+            return Ty::from_type_relative_path(ctx, ty, path.segments());\n         }\n         let (resolution, remaining_index) =\n-            match resolver.resolve_path_in_type_ns(db, path.mod_path()) {\n+            match ctx.resolver.resolve_path_in_type_ns(ctx.db, path.mod_path()) {\n                 Some(it) => it,\n                 None => return Ty::Unknown,\n             };\n@@ -218,39 +326,44 @@ impl Ty {\n             ),\n             Some(i) => (path.segments().get(i - 1).unwrap(), path.segments().skip(i)),\n         };\n-        Ty::from_partly_resolved_hir_path(\n-            db,\n-            resolver,\n-            resolution,\n-            resolved_segment,\n-            remaining_segments,\n-        )\n+        Ty::from_partly_resolved_hir_path(ctx, resolution, resolved_segment, remaining_segments)\n     }\n \n     fn select_associated_type(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         self_ty: Ty,\n         segment: PathSegment<'_>,\n     ) -> Ty {\n-        let param_idx = match self_ty {\n-            Ty::Param { idx, .. } => idx,\n-            _ => return Ty::Unknown, // Error: Ambiguous associated type\n-        };\n-        let def = match resolver.generic_def() {\n+        let def = match ctx.resolver.generic_def() {\n             Some(def) => def,\n             None => return Ty::Unknown, // this can't actually happen\n         };\n-        let predicates = db.generic_predicates_for_param(def.into(), param_idx);\n-        let traits_from_env = predicates.iter().filter_map(|pred| match pred {\n-            GenericPredicate::Implemented(tr) if tr.self_ty() == &self_ty => Some(tr.trait_),\n+        let param_id = match self_ty {\n+            Ty::Param(id) if ctx.type_param_mode == TypeParamLoweringMode::Placeholder => id,\n+            Ty::Bound(idx) if ctx.type_param_mode == TypeParamLoweringMode::Variable => {\n+                let generics = generics(ctx.db, def);\n+                let param_id = if let Some((id, _)) = generics.iter().nth(idx as usize) {\n+                    id\n+                } else {\n+                    return Ty::Unknown;\n+                };\n+                param_id\n+            }\n+            _ => return Ty::Unknown, // Error: Ambiguous associated type\n+        };\n+        let predicates = ctx.db.generic_predicates_for_param(param_id);\n+        let traits_from_env = predicates.iter().filter_map(|pred| match &pred.value {\n+            GenericPredicate::Implemented(tr) => Some(tr.trait_),\n             _ => None,\n         });\n-        let traits = traits_from_env.flat_map(|t| all_super_traits(db, t));\n+        let traits = traits_from_env.flat_map(|t| all_super_traits(ctx.db, t));\n         for t in traits {\n-            if let Some(associated_ty) = db.trait_data(t).associated_type_by_name(&segment.name) {\n-                let substs =\n-                    Substs::build_for_def(db, t).push(self_ty.clone()).fill_with_unknown().build();\n+            if let Some(associated_ty) = ctx.db.trait_data(t).associated_type_by_name(&segment.name)\n+            {\n+                let substs = Substs::build_for_def(ctx.db, t)\n+                    .push(self_ty.clone())\n+                    .fill_with_unknown()\n+                    .build();\n                 // FIXME handle type parameters on the segment\n                 return Ty::Projection(ProjectionTy { associated_ty, parameters: substs });\n             }\n@@ -259,8 +372,7 @@ impl Ty {\n     }\n \n     fn from_hir_path_inner(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         segment: PathSegment<'_>,\n         typable: TyDefId,\n     ) -> Ty {\n@@ -269,15 +381,14 @@ impl Ty {\n             TyDefId::AdtId(it) => Some(it.into()),\n             TyDefId::TypeAliasId(it) => Some(it.into()),\n         };\n-        let substs = substs_from_path_segment(db, resolver, segment, generic_def, false);\n-        db.ty(typable).subst(&substs)\n+        let substs = substs_from_path_segment(ctx, segment, generic_def, false);\n+        ctx.db.ty(typable).subst(&substs)\n     }\n \n     /// Collect generic arguments from a path into a `Substs`. See also\n     /// `create_substs_for_ast_path` and `def_to_ty` in rustc.\n     pub(super) fn substs_from_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         path: &Path,\n         // Note that we don't call `db.value_type(resolved)` here,\n         // `ValueTyDefId` is just a convenient way to pass generics and\n@@ -305,52 +416,49 @@ impl Ty {\n                 (segment, Some(var.parent.into()))\n             }\n         };\n-        substs_from_path_segment(db, resolver, segment, generic_def, false)\n+        substs_from_path_segment(ctx, segment, generic_def, false)\n     }\n }\n \n pub(super) fn substs_from_path_segment(\n-    db: &impl HirDatabase,\n-    resolver: &Resolver,\n+    ctx: &TyLoweringContext<'_, impl HirDatabase>,\n     segment: PathSegment<'_>,\n     def_generic: Option<GenericDefId>,\n-    add_self_param: bool,\n+    _add_self_param: bool,\n ) -> Substs {\n     let mut substs = Vec::new();\n-    let def_generics = def_generic.map(|def| generics(db, def.into()));\n-\n-    let (total_len, parent_len, child_len) = def_generics.map_or((0, 0, 0), |g| g.len_split());\n-    substs.extend(iter::repeat(Ty::Unknown).take(parent_len));\n-    if add_self_param {\n-        // FIXME this add_self_param argument is kind of a hack: Traits have the\n-        // Self type as an implicit first type parameter, but it can't be\n-        // actually provided in the type arguments\n-        // (well, actually sometimes it can, in the form of type-relative paths: `<Foo as Default>::default()`)\n-        substs.push(Ty::Unknown);\n-    }\n+    let def_generics = def_generic.map(|def| generics(ctx.db, def.into()));\n+\n+    let (parent_params, self_params, type_params, impl_trait_params) =\n+        def_generics.map_or((0, 0, 0, 0), |g| g.provenance_split());\n+    substs.extend(iter::repeat(Ty::Unknown).take(parent_params));\n     if let Some(generic_args) = &segment.args_and_bindings {\n+        if !generic_args.has_self_type {\n+            substs.extend(iter::repeat(Ty::Unknown).take(self_params));\n+        }\n+        let expected_num =\n+            if generic_args.has_self_type { self_params + type_params } else { type_params };\n+        let skip = if generic_args.has_self_type && self_params == 0 { 1 } else { 0 };\n         // if args are provided, it should be all of them, but we can't rely on that\n-        let self_param_correction = if add_self_param { 1 } else { 0 };\n-        let child_len = child_len - self_param_correction;\n-        for arg in generic_args.args.iter().take(child_len) {\n+        for arg in generic_args.args.iter().skip(skip).take(expected_num) {\n             match arg {\n                 GenericArg::Type(type_ref) => {\n-                    let ty = Ty::from_hir(db, resolver, type_ref);\n+                    let ty = Ty::from_hir(ctx, type_ref);\n                     substs.push(ty);\n                 }\n             }\n         }\n     }\n+    let total_len = parent_params + self_params + type_params + impl_trait_params;\n     // add placeholders for args that were not provided\n-    let supplied_params = substs.len();\n-    for _ in supplied_params..total_len {\n+    for _ in substs.len()..total_len {\n         substs.push(Ty::Unknown);\n     }\n     assert_eq!(substs.len(), total_len);\n \n     // handle defaults\n     if let Some(def_generic) = def_generic {\n-        let default_substs = db.generic_defaults(def_generic.into());\n+        let default_substs = ctx.db.generic_defaults(def_generic.into());\n         assert_eq!(substs.len(), default_substs.len());\n \n         for (i, default_ty) in default_substs.iter().enumerate() {\n@@ -365,99 +473,105 @@ pub(super) fn substs_from_path_segment(\n \n impl TraitRef {\n     fn from_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         path: &Path,\n         explicit_self_ty: Option<Ty>,\n     ) -> Option<Self> {\n-        let resolved = match resolver.resolve_path_in_type_ns_fully(db, path.mod_path())? {\n+        let resolved = match ctx.resolver.resolve_path_in_type_ns_fully(ctx.db, path.mod_path())? {\n             TypeNs::TraitId(tr) => tr,\n             _ => return None,\n         };\n         let segment = path.segments().last().expect(\"path should have at least one segment\");\n-        Some(TraitRef::from_resolved_path(db, resolver, resolved.into(), segment, explicit_self_ty))\n+        Some(TraitRef::from_resolved_path(ctx, resolved.into(), segment, explicit_self_ty))\n     }\n \n     pub(crate) fn from_resolved_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         resolved: TraitId,\n         segment: PathSegment<'_>,\n         explicit_self_ty: Option<Ty>,\n     ) -> Self {\n-        let mut substs = TraitRef::substs_from_path(db, resolver, segment, resolved);\n+        let mut substs = TraitRef::substs_from_path(ctx, segment, resolved);\n         if let Some(self_ty) = explicit_self_ty {\n             make_mut_slice(&mut substs.0)[0] = self_ty;\n         }\n         TraitRef { trait_: resolved, substs }\n     }\n \n     fn from_hir(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         type_ref: &TypeRef,\n         explicit_self_ty: Option<Ty>,\n     ) -> Option<Self> {\n         let path = match type_ref {\n             TypeRef::Path(path) => path,\n             _ => return None,\n         };\n-        TraitRef::from_path(db, resolver, path, explicit_self_ty)\n+        TraitRef::from_path(ctx, path, explicit_self_ty)\n     }\n \n     fn substs_from_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         segment: PathSegment<'_>,\n         resolved: TraitId,\n     ) -> Substs {\n         let has_self_param =\n             segment.args_and_bindings.as_ref().map(|a| a.has_self_type).unwrap_or(false);\n-        substs_from_path_segment(db, resolver, segment, Some(resolved.into()), !has_self_param)\n+        substs_from_path_segment(ctx, segment, Some(resolved.into()), !has_self_param)\n     }\n \n     pub(crate) fn from_type_bound(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         bound: &TypeBound,\n         self_ty: Ty,\n     ) -> Option<TraitRef> {\n         match bound {\n-            TypeBound::Path(path) => TraitRef::from_path(db, resolver, path, Some(self_ty)),\n+            TypeBound::Path(path) => TraitRef::from_path(ctx, path, Some(self_ty)),\n             TypeBound::Error => None,\n         }\n     }\n }\n \n impl GenericPredicate {\n     pub(crate) fn from_where_predicate<'a>(\n-        db: &'a impl HirDatabase,\n-        resolver: &'a Resolver,\n+        ctx: &'a TyLoweringContext<'a, impl HirDatabase>,\n         where_predicate: &'a WherePredicate,\n     ) -> impl Iterator<Item = GenericPredicate> + 'a {\n-        let self_ty = Ty::from_hir(db, resolver, &where_predicate.type_ref);\n-        GenericPredicate::from_type_bound(db, resolver, &where_predicate.bound, self_ty)\n+        let self_ty = match &where_predicate.target {\n+            WherePredicateTarget::TypeRef(type_ref) => Ty::from_hir(ctx, type_ref),\n+            WherePredicateTarget::TypeParam(param_id) => {\n+                let generic_def = ctx.resolver.generic_def().expect(\"generics in scope\");\n+                let generics = generics(ctx.db, generic_def);\n+                let param_id = hir_def::TypeParamId { parent: generic_def, local_id: *param_id };\n+                match ctx.type_param_mode {\n+                    TypeParamLoweringMode::Placeholder => Ty::Param(param_id),\n+                    TypeParamLoweringMode::Variable => {\n+                        let idx = generics.param_idx(param_id).expect(\"matching generics\");\n+                        Ty::Bound(idx)\n+                    }\n+                }\n+            }\n+        };\n+        GenericPredicate::from_type_bound(ctx, &where_predicate.bound, self_ty)\n     }\n \n     pub(crate) fn from_type_bound<'a>(\n-        db: &'a impl HirDatabase,\n-        resolver: &'a Resolver,\n+        ctx: &'a TyLoweringContext<'a, impl HirDatabase>,\n         bound: &'a TypeBound,\n         self_ty: Ty,\n     ) -> impl Iterator<Item = GenericPredicate> + 'a {\n-        let trait_ref = TraitRef::from_type_bound(db, &resolver, bound, self_ty);\n+        let trait_ref = TraitRef::from_type_bound(ctx, bound, self_ty);\n         iter::once(trait_ref.clone().map_or(GenericPredicate::Error, GenericPredicate::Implemented))\n             .chain(\n-                trait_ref.into_iter().flat_map(move |tr| {\n-                    assoc_type_bindings_from_type_bound(db, resolver, bound, tr)\n-                }),\n+                trait_ref\n+                    .into_iter()\n+                    .flat_map(move |tr| assoc_type_bindings_from_type_bound(ctx, bound, tr)),\n             )\n     }\n }\n \n fn assoc_type_bindings_from_type_bound<'a>(\n-    db: &'a impl HirDatabase,\n-    resolver: &'a Resolver,\n+    ctx: &'a TyLoweringContext<'a, impl HirDatabase>,\n     bound: &'a TypeBound,\n     trait_ref: TraitRef,\n ) -> impl Iterator<Item = GenericPredicate> + 'a {\n@@ -471,21 +585,21 @@ fn assoc_type_bindings_from_type_bound<'a>(\n         .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n         .map(move |(name, type_ref)| {\n             let associated_ty =\n-                associated_type_by_name_including_super_traits(db, trait_ref.trait_, &name);\n+                associated_type_by_name_including_super_traits(ctx.db, trait_ref.trait_, &name);\n             let associated_ty = match associated_ty {\n                 None => return GenericPredicate::Error,\n                 Some(t) => t,\n             };\n             let projection_ty =\n                 ProjectionTy { associated_ty, parameters: trait_ref.substs.clone() };\n-            let ty = Ty::from_hir(db, resolver, type_ref);\n+            let ty = Ty::from_hir(ctx, type_ref);\n             let projection_predicate = ProjectionPredicate { projection_ty, ty };\n             GenericPredicate::Projection(projection_predicate)\n         })\n }\n \n /// Build the signature of a callable item (function, struct or enum variant).\n-pub fn callable_item_sig(db: &impl HirDatabase, def: CallableDef) -> FnSig {\n+pub fn callable_item_sig(db: &impl HirDatabase, def: CallableDef) -> PolyFnSig {\n     match def {\n         CallableDef::FunctionId(f) => fn_sig_for_fn(db, f),\n         CallableDef::StructId(s) => fn_sig_for_struct_constructor(db, s),\n@@ -497,16 +611,19 @@ pub fn callable_item_sig(db: &impl HirDatabase, def: CallableDef) -> FnSig {\n pub(crate) fn field_types_query(\n     db: &impl HirDatabase,\n     variant_id: VariantId,\n-) -> Arc<ArenaMap<LocalStructFieldId, Ty>> {\n+) -> Arc<ArenaMap<LocalStructFieldId, Binders<Ty>>> {\n     let var_data = variant_data(db, variant_id);\n-    let resolver = match variant_id {\n-        VariantId::StructId(it) => it.resolver(db),\n-        VariantId::UnionId(it) => it.resolver(db),\n-        VariantId::EnumVariantId(it) => it.parent.resolver(db),\n+    let (resolver, def): (_, GenericDefId) = match variant_id {\n+        VariantId::StructId(it) => (it.resolver(db), it.into()),\n+        VariantId::UnionId(it) => (it.resolver(db), it.into()),\n+        VariantId::EnumVariantId(it) => (it.parent.resolver(db), it.parent.into()),\n     };\n+    let generics = generics(db, def);\n     let mut res = ArenaMap::default();\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     for (field_id, field_data) in var_data.fields().iter() {\n-        res.insert(field_id, Ty::from_hir(db, &resolver, &field_data.type_ref))\n+        res.insert(field_id, Binders::new(generics.len(), Ty::from_hir(&ctx, &field_data.type_ref)))\n     }\n     Arc::new(res)\n }\n@@ -521,32 +638,43 @@ pub(crate) fn field_types_query(\n /// these are fine: `T: Foo<U::Item>, U: Foo<()>`.\n pub(crate) fn generic_predicates_for_param_query(\n     db: &impl HirDatabase,\n-    def: GenericDefId,\n-    param_idx: u32,\n-) -> Arc<[GenericPredicate]> {\n-    let resolver = def.resolver(db);\n+    param_id: TypeParamId,\n+) -> Arc<[Binders<GenericPredicate>]> {\n+    let resolver = param_id.parent.resolver(db);\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+    let generics = generics(db, param_id.parent);\n     resolver\n         .where_predicates_in_scope()\n         // we have to filter out all other predicates *first*, before attempting to lower them\n-        .filter(|pred| Ty::from_hir_only_param(db, &resolver, &pred.type_ref) == Some(param_idx))\n-        .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n+        .filter(|pred| match &pred.target {\n+            WherePredicateTarget::TypeRef(type_ref) => {\n+                Ty::from_hir_only_param(&ctx, type_ref) == Some(param_id)\n+            }\n+            WherePredicateTarget::TypeParam(local_id) => *local_id == param_id.local_id,\n+        })\n+        .flat_map(|pred| {\n+            GenericPredicate::from_where_predicate(&ctx, pred)\n+                .map(|p| Binders::new(generics.len(), p))\n+        })\n         .collect()\n }\n \n pub(crate) fn generic_predicates_for_param_recover(\n     _db: &impl HirDatabase,\n     _cycle: &[String],\n-    _def: &GenericDefId,\n-    _param_idx: &u32,\n-) -> Arc<[GenericPredicate]> {\n+    _param_id: &TypeParamId,\n+) -> Arc<[Binders<GenericPredicate>]> {\n     Arc::new([])\n }\n \n impl TraitEnvironment {\n     pub fn lower(db: &impl HirDatabase, resolver: &Resolver) -> Arc<TraitEnvironment> {\n+        let ctx = TyLoweringContext::new(db, &resolver)\n+            .with_type_param_mode(TypeParamLoweringMode::Placeholder);\n         let predicates = resolver\n             .where_predicates_in_scope()\n-            .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n+            .flat_map(|pred| GenericPredicate::from_where_predicate(&ctx, pred))\n             .collect::<Vec<_>>();\n \n         Arc::new(TraitEnvironment { predicates })\n@@ -557,57 +685,74 @@ impl TraitEnvironment {\n pub(crate) fn generic_predicates_query(\n     db: &impl HirDatabase,\n     def: GenericDefId,\n-) -> Arc<[GenericPredicate]> {\n+) -> Arc<[Binders<GenericPredicate>]> {\n     let resolver = def.resolver(db);\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+    let generics = generics(db, def);\n     resolver\n         .where_predicates_in_scope()\n-        .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n+        .flat_map(|pred| {\n+            GenericPredicate::from_where_predicate(&ctx, pred)\n+                .map(|p| Binders::new(generics.len(), p))\n+        })\n         .collect()\n }\n \n /// Resolve the default type params from generics\n pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDefId) -> Substs {\n     let resolver = def.resolver(db);\n+    let ctx = TyLoweringContext::new(db, &resolver);\n     let generic_params = generics(db, def.into());\n \n     let defaults = generic_params\n         .iter()\n-        .map(|(_idx, p)| p.default.as_ref().map_or(Ty::Unknown, |t| Ty::from_hir(db, &resolver, t)))\n+        .map(|(_idx, p)| p.default.as_ref().map_or(Ty::Unknown, |t| Ty::from_hir(&ctx, t)))\n         .collect();\n \n     Substs(defaults)\n }\n \n-fn fn_sig_for_fn(db: &impl HirDatabase, def: FunctionId) -> FnSig {\n+fn fn_sig_for_fn(db: &impl HirDatabase, def: FunctionId) -> PolyFnSig {\n     let data = db.function_data(def);\n     let resolver = def.resolver(db);\n-    let params = data.params.iter().map(|tr| Ty::from_hir(db, &resolver, tr)).collect::<Vec<_>>();\n-    let ret = Ty::from_hir(db, &resolver, &data.ret_type);\n-    FnSig::from_params_and_return(params, ret)\n+    let ctx_params = TyLoweringContext::new(db, &resolver)\n+        .with_impl_trait_mode(ImplTraitLoweringMode::Variable)\n+        .with_type_param_mode(TypeParamLoweringMode::Variable);\n+    let params = data.params.iter().map(|tr| Ty::from_hir(&ctx_params, tr)).collect::<Vec<_>>();\n+    let ctx_ret = ctx_params.with_impl_trait_mode(ImplTraitLoweringMode::Opaque);\n+    let ret = Ty::from_hir(&ctx_ret, &data.ret_type);\n+    let generics = generics(db, def.into());\n+    let num_binders = generics.len();\n+    Binders::new(num_binders, FnSig::from_params_and_return(params, ret))\n }\n \n /// Build the declared type of a function. This should not need to look at the\n /// function body.\n-fn type_for_fn(db: &impl HirDatabase, def: FunctionId) -> Ty {\n+fn type_for_fn(db: &impl HirDatabase, def: FunctionId) -> Binders<Ty> {\n     let generics = generics(db, def.into());\n-    let substs = Substs::identity(&generics);\n-    Ty::apply(TypeCtor::FnDef(def.into()), substs)\n+    let substs = Substs::bound_vars(&generics);\n+    Binders::new(substs.len(), Ty::apply(TypeCtor::FnDef(def.into()), substs))\n }\n \n /// Build the declared type of a const.\n-fn type_for_const(db: &impl HirDatabase, def: ConstId) -> Ty {\n+fn type_for_const(db: &impl HirDatabase, def: ConstId) -> Binders<Ty> {\n     let data = db.const_data(def);\n+    let generics = generics(db, def.into());\n     let resolver = def.resolver(db);\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n \n-    Ty::from_hir(db, &resolver, &data.type_ref)\n+    Binders::new(generics.len(), Ty::from_hir(&ctx, &data.type_ref))\n }\n \n /// Build the declared type of a static.\n-fn type_for_static(db: &impl HirDatabase, def: StaticId) -> Ty {\n+fn type_for_static(db: &impl HirDatabase, def: StaticId) -> Binders<Ty> {\n     let data = db.static_data(def);\n     let resolver = def.resolver(db);\n+    let ctx = TyLoweringContext::new(db, &resolver);\n \n-    Ty::from_hir(db, &resolver, &data.type_ref)\n+    Binders::new(0, Ty::from_hir(&ctx, &data.type_ref))\n }\n \n /// Build the declared type of a static.\n@@ -621,68 +766,69 @@ fn type_for_builtin(def: BuiltinType) -> Ty {\n     })\n }\n \n-fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> FnSig {\n+fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> PolyFnSig {\n     let struct_data = db.struct_data(def.into());\n     let fields = struct_data.variant_data.fields();\n     let resolver = def.resolver(db);\n-    let params = fields\n-        .iter()\n-        .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n-        .collect::<Vec<_>>();\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+    let params =\n+        fields.iter().map(|(_, field)| Ty::from_hir(&ctx, &field.type_ref)).collect::<Vec<_>>();\n     let ret = type_for_adt(db, def.into());\n-    FnSig::from_params_and_return(params, ret)\n+    Binders::new(ret.num_binders, FnSig::from_params_and_return(params, ret.value))\n }\n \n /// Build the type of a tuple struct constructor.\n-fn type_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> Ty {\n+fn type_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> Binders<Ty> {\n     let struct_data = db.struct_data(def.into());\n     if struct_data.variant_data.is_unit() {\n         return type_for_adt(db, def.into()); // Unit struct\n     }\n     let generics = generics(db, def.into());\n-    let substs = Substs::identity(&generics);\n-    Ty::apply(TypeCtor::FnDef(def.into()), substs)\n+    let substs = Substs::bound_vars(&generics);\n+    Binders::new(substs.len(), Ty::apply(TypeCtor::FnDef(def.into()), substs))\n }\n \n-fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId) -> FnSig {\n+fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId) -> PolyFnSig {\n     let enum_data = db.enum_data(def.parent);\n     let var_data = &enum_data.variants[def.local_id];\n     let fields = var_data.variant_data.fields();\n     let resolver = def.parent.resolver(db);\n-    let params = fields\n-        .iter()\n-        .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n-        .collect::<Vec<_>>();\n-    let generics = generics(db, def.parent.into());\n-    let substs = Substs::identity(&generics);\n-    let ret = type_for_adt(db, def.parent.into()).subst(&substs);\n-    FnSig::from_params_and_return(params, ret)\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+    let params =\n+        fields.iter().map(|(_, field)| Ty::from_hir(&ctx, &field.type_ref)).collect::<Vec<_>>();\n+    let ret = type_for_adt(db, def.parent.into());\n+    Binders::new(ret.num_binders, FnSig::from_params_and_return(params, ret.value))\n }\n \n /// Build the type of a tuple enum variant constructor.\n-fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId) -> Ty {\n+fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId) -> Binders<Ty> {\n     let enum_data = db.enum_data(def.parent);\n     let var_data = &enum_data.variants[def.local_id].variant_data;\n     if var_data.is_unit() {\n         return type_for_adt(db, def.parent.into()); // Unit variant\n     }\n     let generics = generics(db, def.parent.into());\n-    let substs = Substs::identity(&generics);\n-    Ty::apply(TypeCtor::FnDef(EnumVariantId::from(def).into()), substs)\n+    let substs = Substs::bound_vars(&generics);\n+    Binders::new(substs.len(), Ty::apply(TypeCtor::FnDef(EnumVariantId::from(def).into()), substs))\n }\n \n-fn type_for_adt(db: &impl HirDatabase, adt: AdtId) -> Ty {\n+fn type_for_adt(db: &impl HirDatabase, adt: AdtId) -> Binders<Ty> {\n     let generics = generics(db, adt.into());\n-    Ty::apply(TypeCtor::Adt(adt), Substs::identity(&generics))\n+    let substs = Substs::bound_vars(&generics);\n+    Binders::new(substs.len(), Ty::apply(TypeCtor::Adt(adt), substs))\n }\n \n-fn type_for_type_alias(db: &impl HirDatabase, t: TypeAliasId) -> Ty {\n+fn type_for_type_alias(db: &impl HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n     let generics = generics(db, t.into());\n     let resolver = t.resolver(db);\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let type_ref = &db.type_alias_data(t).type_ref;\n-    let substs = Substs::identity(&generics);\n-    let inner = Ty::from_hir(db, &resolver, type_ref.as_ref().unwrap_or(&TypeRef::Error));\n-    inner.subst(&substs)\n+    let substs = Substs::bound_vars(&generics);\n+    let inner = Ty::from_hir(&ctx, type_ref.as_ref().unwrap_or(&TypeRef::Error));\n+    Binders::new(substs.len(), inner)\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n@@ -736,19 +882,24 @@ impl_froms!(ValueTyDefId: FunctionId, StructId, EnumVariantId, ConstId, StaticId\n /// `struct Foo(usize)`, we have two types: The type of the struct itself, and\n /// the constructor function `(usize) -> Foo` which lives in the values\n /// namespace.\n-pub(crate) fn ty_query(db: &impl HirDatabase, def: TyDefId) -> Ty {\n+pub(crate) fn ty_query(db: &impl HirDatabase, def: TyDefId) -> Binders<Ty> {\n     match def {\n-        TyDefId::BuiltinType(it) => type_for_builtin(it),\n+        TyDefId::BuiltinType(it) => Binders::new(0, type_for_builtin(it)),\n         TyDefId::AdtId(it) => type_for_adt(db, it),\n         TyDefId::TypeAliasId(it) => type_for_type_alias(db, it),\n     }\n }\n \n-pub(crate) fn ty_recover(_db: &impl HirDatabase, _cycle: &[String], _def: &TyDefId) -> Ty {\n-    Ty::Unknown\n+pub(crate) fn ty_recover(db: &impl HirDatabase, _cycle: &[String], def: &TyDefId) -> Binders<Ty> {\n+    let num_binders = match *def {\n+        TyDefId::BuiltinType(_) => 0,\n+        TyDefId::AdtId(it) => generics(db, it.into()).len(),\n+        TyDefId::TypeAliasId(it) => generics(db, it.into()).len(),\n+    };\n+    Binders::new(num_binders, Ty::Unknown)\n }\n \n-pub(crate) fn value_ty_query(db: &impl HirDatabase, def: ValueTyDefId) -> Ty {\n+pub(crate) fn value_ty_query(db: &impl HirDatabase, def: ValueTyDefId) -> Binders<Ty> {\n     match def {\n         ValueTyDefId::FunctionId(it) => type_for_fn(db, it),\n         ValueTyDefId::StructId(it) => type_for_struct_constructor(db, it),\n@@ -758,24 +909,36 @@ pub(crate) fn value_ty_query(db: &impl HirDatabase, def: ValueTyDefId) -> Ty {\n     }\n }\n \n-pub(crate) fn impl_self_ty_query(db: &impl HirDatabase, impl_id: ImplId) -> Ty {\n+pub(crate) fn impl_self_ty_query(db: &impl HirDatabase, impl_id: ImplId) -> Binders<Ty> {\n     let impl_data = db.impl_data(impl_id);\n     let resolver = impl_id.resolver(db);\n-    Ty::from_hir(db, &resolver, &impl_data.target_type)\n+    let generics = generics(db, impl_id.into());\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+    Binders::new(generics.len(), Ty::from_hir(&ctx, &impl_data.target_type))\n }\n \n pub(crate) fn impl_self_ty_recover(\n-    _db: &impl HirDatabase,\n+    db: &impl HirDatabase,\n     _cycle: &[String],\n-    _impl_id: &ImplId,\n-) -> Ty {\n-    Ty::Unknown\n+    impl_id: &ImplId,\n+) -> Binders<Ty> {\n+    let generics = generics(db, (*impl_id).into());\n+    Binders::new(generics.len(), Ty::Unknown)\n }\n \n-pub(crate) fn impl_trait_query(db: &impl HirDatabase, impl_id: ImplId) -> Option<TraitRef> {\n+pub(crate) fn impl_trait_query(\n+    db: &impl HirDatabase,\n+    impl_id: ImplId,\n+) -> Option<Binders<TraitRef>> {\n     let impl_data = db.impl_data(impl_id);\n     let resolver = impl_id.resolver(db);\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let self_ty = db.impl_self_ty(impl_id);\n     let target_trait = impl_data.target_trait.as_ref()?;\n-    TraitRef::from_hir(db, &resolver, target_trait, Some(self_ty.clone()))\n+    Some(Binders::new(\n+        self_ty.num_binders,\n+        TraitRef::from_hir(&ctx, target_trait, Some(self_ty.value.clone()))?,\n+    ))\n }"}, {"sha": "0f754eb9c75515c3ed8767723127102802a6da16", "filename": "crates/ra_hir_ty/src/marks.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -6,5 +6,4 @@ test_utils::marks!(\n     type_var_resolves_to_int_var\n     match_ergonomics_ref\n     coerce_merge_fail_fallback\n-    insert_vars_for_impl_trait\n );"}, {"sha": "5283bff28f3ab4e2b1635f4364a2f39cc626230d", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -61,11 +61,11 @@ impl CrateImplBlocks {\n             for impl_id in module_data.scope.impls() {\n                 match db.impl_trait(impl_id) {\n                     Some(tr) => {\n-                        res.impls_by_trait.entry(tr.trait_).or_default().push(impl_id);\n+                        res.impls_by_trait.entry(tr.value.trait_).or_default().push(impl_id);\n                     }\n                     None => {\n                         let self_ty = db.impl_self_ty(impl_id);\n-                        if let Some(self_ty_fp) = TyFingerprint::for_impl(&self_ty) {\n+                        if let Some(self_ty_fp) = TyFingerprint::for_impl(&self_ty.value) {\n                             res.impls.entry(self_ty_fp).or_default().push(impl_id);\n                         }\n                     }\n@@ -496,7 +496,7 @@ fn transform_receiver_ty(\n         AssocContainerId::ContainerId(_) => unreachable!(),\n     };\n     let sig = db.callable_item_signature(function_id.into());\n-    Some(sig.params()[0].clone().subst(&substs))\n+    Some(sig.value.params()[0].clone().subst_bound_vars(&substs))\n }\n \n pub fn implements_trait("}, {"sha": "fc5ef36a59f5ae0d1c5019999214a57e312b5f2c", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -75,7 +75,7 @@ fn test2() {\n     [124; 131) 'loop {}': !\n     [129; 131) '{}': ()\n     [160; 173) '{     gen() }': *mut [U]\n-    [166; 169) 'gen': fn gen<U>() -> *mut [T; _]\n+    [166; 169) 'gen': fn gen<U>() -> *mut [U; _]\n     [166; 171) 'gen()': *mut [U; _]\n     [186; 420) '{     ...rr); }': ()\n     [196; 199) 'arr': &[u8; _]\n@@ -85,14 +85,14 @@ fn test2() {\n     [227; 228) 'a': &[u8]\n     [237; 240) 'arr': &[u8; _]\n     [250; 251) 'b': u8\n-    [254; 255) 'f': fn f<u8>(&[T]) -> T\n+    [254; 255) 'f': fn f<u8>(&[u8]) -> u8\n     [254; 260) 'f(arr)': u8\n     [256; 259) 'arr': &[u8; _]\n     [270; 271) 'c': &[u8]\n     [280; 287) '{ arr }': &[u8]\n     [282; 285) 'arr': &[u8; _]\n     [297; 298) 'd': u8\n-    [301; 302) 'g': fn g<u8>(S<&[T]>) -> T\n+    [301; 302) 'g': fn g<u8>(S<&[u8]>) -> u8\n     [301; 316) 'g(S { a: arr })': u8\n     [303; 315) 'S { a: arr }': S<&[u8]>\n     [310; 313) 'arr': &[u8; _]\n@@ -164,15 +164,15 @@ fn test(a: A<[u8; 2]>, b: B<[u8; 2]>, c: C<[u8; 2]>) {\n     [400; 401) 'c': C<[u8; _]>\n     [415; 481) '{     ...(c); }': ()\n     [425; 426) 'd': A<[{unknown}]>\n-    [429; 433) 'foo1': fn foo1<{unknown}>(A<[T]>) -> A<[T]>\n+    [429; 433) 'foo1': fn foo1<{unknown}>(A<[{unknown}]>) -> A<[{unknown}]>\n     [429; 436) 'foo1(a)': A<[{unknown}]>\n     [434; 435) 'a': A<[u8; _]>\n     [446; 447) 'e': B<[u8]>\n-    [450; 454) 'foo2': fn foo2<u8>(B<[T]>) -> B<[T]>\n+    [450; 454) 'foo2': fn foo2<u8>(B<[u8]>) -> B<[u8]>\n     [450; 457) 'foo2(b)': B<[u8]>\n     [455; 456) 'b': B<[u8; _]>\n     [467; 468) 'f': C<[u8]>\n-    [471; 475) 'foo3': fn foo3<u8>(C<[T]>) -> C<[T]>\n+    [471; 475) 'foo3': fn foo3<u8>(C<[u8]>) -> C<[u8]>\n     [471; 478) 'foo3(c)': C<[u8]>\n     [476; 477) 'c': C<[u8; _]>\n     \"###\n@@ -202,7 +202,7 @@ fn test() {\n     [64; 123) 'if tru...     }': &[i32]\n     [67; 71) 'true': bool\n     [72; 97) '{     ...     }': &[i32]\n-    [82; 85) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [82; 85) 'foo': fn foo<i32>(&[i32]) -> &[i32]\n     [82; 91) 'foo(&[1])': &[i32]\n     [86; 90) '&[1]': &[i32; _]\n     [87; 90) '[1]': [i32; _]\n@@ -242,7 +242,7 @@ fn test() {\n     [83; 86) '[1]': [i32; _]\n     [84; 85) '1': i32\n     [98; 123) '{     ...     }': &[i32]\n-    [108; 111) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [108; 111) 'foo': fn foo<i32>(&[i32]) -> &[i32]\n     [108; 117) 'foo(&[1])': &[i32]\n     [112; 116) '&[1]': &[i32; _]\n     [113; 116) '[1]': [i32; _]\n@@ -275,7 +275,7 @@ fn test(i: i32) {\n     [70; 147) 'match ...     }': &[i32]\n     [76; 77) 'i': i32\n     [88; 89) '2': i32\n-    [93; 96) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [93; 96) 'foo': fn foo<i32>(&[i32]) -> &[i32]\n     [93; 102) 'foo(&[2])': &[i32]\n     [97; 101) '&[2]': &[i32; _]\n     [98; 101) '[2]': [i32; _]\n@@ -320,7 +320,7 @@ fn test(i: i32) {\n     [94; 97) '[1]': [i32; _]\n     [95; 96) '1': i32\n     [107; 108) '2': i32\n-    [112; 115) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [112; 115) 'foo': fn foo<i32>(&[i32]) -> &[i32]\n     [112; 121) 'foo(&[2])': &[i32]\n     [116; 120) '&[2]': &[i32; _]\n     [117; 120) '[2]': [i32; _]\n@@ -438,16 +438,16 @@ fn test() {\n     [43; 45) '*x': T\n     [44; 45) 'x': &T\n     [58; 127) '{     ...oo); }': ()\n-    [64; 73) 'takes_ref': fn takes_ref<Foo>(&T) -> T\n+    [64; 73) 'takes_ref': fn takes_ref<Foo>(&Foo) -> Foo\n     [64; 79) 'takes_ref(&Foo)': Foo\n     [74; 78) '&Foo': &Foo\n     [75; 78) 'Foo': Foo\n-    [85; 94) 'takes_ref': fn takes_ref<&Foo>(&T) -> T\n+    [85; 94) 'takes_ref': fn takes_ref<&Foo>(&&Foo) -> &Foo\n     [85; 101) 'takes_...&&Foo)': &Foo\n     [95; 100) '&&Foo': &&Foo\n     [96; 100) '&Foo': &Foo\n     [97; 100) 'Foo': Foo\n-    [107; 116) 'takes_ref': fn takes_ref<&&Foo>(&T) -> T\n+    [107; 116) 'takes_ref': fn takes_ref<&&Foo>(&&&Foo) -> &&Foo\n     [107; 124) 'takes_...&&Foo)': &&Foo\n     [117; 123) '&&&Foo': &&&Foo\n     [118; 123) '&&Foo': &&Foo"}, {"sha": "1722563aa15d8a8de1d00af38470c519080ff4ff", "filename": "crates/ra_hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -27,7 +27,7 @@ fn test() {\n     [66; 73) 'loop {}': !\n     [71; 73) '{}': ()\n     [133; 160) '{     ...o\"); }': ()\n-    [139; 149) '<[_]>::foo': fn foo<u8>(&[T]) -> T\n+    [139; 149) '<[_]>::foo': fn foo<u8>(&[u8]) -> u8\n     [139; 157) '<[_]>:...\"foo\")': u8\n     [150; 156) 'b\"foo\"': &[u8]\n     \"###\n@@ -175,7 +175,7 @@ fn test() {\n     [98; 101) 'val': T\n     [123; 155) '{     ...32); }': ()\n     [133; 134) 'a': Gen<u32>\n-    [137; 146) 'Gen::make': fn make<u32>(T) -> Gen<T>\n+    [137; 146) 'Gen::make': fn make<u32>(u32) -> Gen<u32>\n     [137; 152) 'Gen::make(0u32)': Gen<u32>\n     [147; 151) '0u32': u32\n     \"###\n@@ -206,7 +206,7 @@ fn test() {\n     [95; 98) '{ }': ()\n     [118; 146) '{     ...e(); }': ()\n     [128; 129) 'a': Gen<u32>\n-    [132; 141) 'Gen::make': fn make<u32>() -> Gen<T>\n+    [132; 141) 'Gen::make': fn make<u32>() -> Gen<u32>\n     [132; 143) 'Gen::make()': Gen<u32>\n     \"###\n     );\n@@ -260,7 +260,7 @@ fn test() {\n     [91; 94) '{ }': ()\n     [114; 149) '{     ...e(); }': ()\n     [124; 125) 'a': Gen<u32>\n-    [128; 144) 'Gen::<...::make': fn make<u32>() -> Gen<T>\n+    [128; 144) 'Gen::<...::make': fn make<u32>() -> Gen<u32>\n     [128; 146) 'Gen::<...make()': Gen<u32>\n     \"###\n     );\n@@ -291,7 +291,7 @@ fn test() {\n     [117; 120) '{ }': ()\n     [140; 180) '{     ...e(); }': ()\n     [150; 151) 'a': Gen<u32, u64>\n-    [154; 175) 'Gen::<...::make': fn make<u64>() -> Gen<u32, T>\n+    [154; 175) 'Gen::<...::make': fn make<u64>() -> Gen<u32, u64>\n     [154; 177) 'Gen::<...make()': Gen<u32, u64>\n     \"###\n     );\n@@ -475,7 +475,7 @@ fn test() {\n         @r###\"\n     [33; 37) 'self': &Self\n     [102; 127) '{     ...d(); }': ()\n-    [108; 109) 'S': S<u32>(T) -> S<T>\n+    [108; 109) 'S': S<u32>(u32) -> S<u32>\n     [108; 115) 'S(1u32)': S<u32>\n     [108; 124) 'S(1u32...thod()': u32\n     [110; 114) '1u32': u32\n@@ -501,13 +501,13 @@ fn test() {\n         @r###\"\n     [87; 193) '{     ...t(); }': ()\n     [97; 99) 's1': S\n-    [105; 121) 'Defaul...efault': fn default<S>() -> Self\n+    [105; 121) 'Defaul...efault': fn default<S>() -> S\n     [105; 123) 'Defaul...ault()': S\n     [133; 135) 's2': S\n-    [138; 148) 'S::default': fn default<S>() -> Self\n+    [138; 148) 'S::default': fn default<S>() -> S\n     [138; 150) 'S::default()': S\n     [160; 162) 's3': S\n-    [165; 188) '<S as ...efault': fn default<S>() -> Self\n+    [165; 188) '<S as ...efault': fn default<S>() -> S\n     [165; 190) '<S as ...ault()': S\n     \"###\n     );\n@@ -533,13 +533,13 @@ fn test() {\n         @r###\"\n     [127; 211) '{     ...e(); }': ()\n     [137; 138) 'a': u32\n-    [141; 148) 'S::make': fn make<S, u32>() -> T\n+    [141; 148) 'S::make': fn make<S, u32>() -> u32\n     [141; 150) 'S::make()': u32\n     [160; 161) 'b': u64\n-    [164; 178) 'G::<u64>::make': fn make<G<u64>, u64>() -> T\n+    [164; 178) 'G::<u64>::make': fn make<G<u64>, u64>() -> u64\n     [164; 180) 'G::<u6...make()': u64\n     [190; 191) 'c': f64\n-    [199; 206) 'G::make': fn make<G<f64>, f64>() -> T\n+    [199; 206) 'G::make': fn make<G<f64>, f64>() -> f64\n     [199; 208) 'G::make()': f64\n     \"###\n     );\n@@ -567,19 +567,19 @@ fn test() {\n         @r###\"\n     [135; 313) '{     ...e(); }': ()\n     [145; 146) 'a': (u32, i64)\n-    [149; 163) 'S::make::<i64>': fn make<S, u32, i64>() -> (T, U)\n+    [149; 163) 'S::make::<i64>': fn make<S, u32, i64>() -> (u32, i64)\n     [149; 165) 'S::mak...i64>()': (u32, i64)\n     [175; 176) 'b': (u32, i64)\n-    [189; 196) 'S::make': fn make<S, u32, i64>() -> (T, U)\n+    [189; 196) 'S::make': fn make<S, u32, i64>() -> (u32, i64)\n     [189; 198) 'S::make()': (u32, i64)\n     [208; 209) 'c': (u32, i64)\n-    [212; 233) 'G::<u3...:<i64>': fn make<G<u32>, u32, i64>() -> (T, U)\n+    [212; 233) 'G::<u3...:<i64>': fn make<G<u32>, u32, i64>() -> (u32, i64)\n     [212; 235) 'G::<u3...i64>()': (u32, i64)\n     [245; 246) 'd': (u32, i64)\n-    [259; 273) 'G::make::<i64>': fn make<G<u32>, u32, i64>() -> (T, U)\n+    [259; 273) 'G::make::<i64>': fn make<G<u32>, u32, i64>() -> (u32, i64)\n     [259; 275) 'G::mak...i64>()': (u32, i64)\n     [285; 286) 'e': (u32, i64)\n-    [301; 308) 'G::make': fn make<G<u32>, u32, i64>() -> (T, U)\n+    [301; 308) 'G::make': fn make<G<u32>, u32, i64>() -> (u32, i64)\n     [301; 310) 'G::make()': (u32, i64)\n     \"###\n     );\n@@ -601,7 +601,7 @@ fn test() {\n         @r###\"\n     [101; 127) '{     ...e(); }': ()\n     [111; 112) 'a': (S<i32>, i64)\n-    [115; 122) 'S::make': fn make<S<i32>, i64>() -> (Self, T)\n+    [115; 122) 'S::make': fn make<S<i32>, i64>() -> (S<i32>, i64)\n     [115; 124) 'S::make()': (S<i32>, i64)\n     \"###\n     );\n@@ -625,10 +625,10 @@ fn test() {\n         @r###\"\n     [131; 203) '{     ...e(); }': ()\n     [141; 142) 'a': (S<u64>, i64)\n-    [158; 165) 'S::make': fn make<S<u64>, i64>() -> (Self, T)\n+    [158; 165) 'S::make': fn make<S<u64>, i64>() -> (S<u64>, i64)\n     [158; 167) 'S::make()': (S<u64>, i64)\n     [177; 178) 'b': (S<u32>, i32)\n-    [191; 198) 'S::make': fn make<S<u32>, i32>() -> (Self, T)\n+    [191; 198) 'S::make': fn make<S<u32>, i32>() -> (S<u32>, i32)\n     [191; 200) 'S::make()': (S<u32>, i32)\n     \"###\n     );\n@@ -651,10 +651,10 @@ fn test() {\n         @r###\"\n     [107; 211) '{     ...>(); }': ()\n     [117; 118) 'a': (S<u64>, i64, u8)\n-    [121; 150) '<S as ...::<u8>': fn make<S<u64>, i64, u8>() -> (Self, T, U)\n+    [121; 150) '<S as ...::<u8>': fn make<S<u64>, i64, u8>() -> (S<u64>, i64, u8)\n     [121; 152) '<S as ...<u8>()': (S<u64>, i64, u8)\n     [162; 163) 'b': (S<u64>, i64, u8)\n-    [182; 206) 'Trait:...::<u8>': fn make<S<u64>, i64, u8>() -> (Self, T, U)\n+    [182; 206) 'Trait:...::<u8>': fn make<S<u64>, i64, u8>() -> (S<u64>, i64, u8)\n     [182; 208) 'Trait:...<u8>()': (S<u64>, i64, u8)\n     \"###\n     );\n@@ -697,7 +697,7 @@ fn test<U, T: Trait<U>>(t: T) {\n     [71; 72) 't': T\n     [77; 96) '{     ...d(); }': ()\n     [83; 84) 't': T\n-    [83; 93) 't.method()': [missing name]\n+    [83; 93) 't.method()': U\n     \"###\n     );\n }\n@@ -728,7 +728,7 @@ fn test() {\n     [157; 158) 'S': S\n     [157; 165) 'S.into()': u64\n     [175; 176) 'z': u64\n-    [179; 196) 'Into::...::into': fn into<S, u64>(Self) -> T\n+    [179; 196) 'Into::...::into': fn into<S, u64>(S) -> u64\n     [179; 199) 'Into::...nto(S)': u64\n     [197; 198) 'S': S\n     \"###"}, {"sha": "e25d6dbc43d46b32f092c401e8f4db7f631a0596", "filename": "crates/ra_hir_ty/src/tests/patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -96,13 +96,13 @@ fn test() {\n     [38; 42) 'A(n)': A<i32>\n     [40; 41) 'n': &i32\n     [45; 50) '&A(1)': &A<i32>\n-    [46; 47) 'A': A<i32>(T) -> A<T>\n+    [46; 47) 'A': A<i32>(i32) -> A<i32>\n     [46; 50) 'A(1)': A<i32>\n     [48; 49) '1': i32\n     [60; 64) 'A(n)': A<i32>\n     [62; 63) 'n': &mut i32\n     [67; 76) '&mut A(1)': &mut A<i32>\n-    [72; 73) 'A': A<i32>(T) -> A<T>\n+    [72; 73) 'A': A<i32>(i32) -> A<i32>\n     [72; 76) 'A(1)': A<i32>\n     [74; 75) '1': i32\n     \"###"}, {"sha": "14c8ed3a9b7a942ebe00731fb43db7f6d3792e62", "filename": "crates/ra_hir_ty/src/tests/regression.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -346,7 +346,7 @@ pub fn main_loop() {\n     @r###\"\n     [144; 146) '{}': ()\n     [169; 198) '{     ...t(); }': ()\n-    [175; 193) 'FxHash...efault': fn default<{unknown}, FxHasher>() -> HashSet<T, H>\n+    [175; 193) 'FxHash...efault': fn default<{unknown}, FxHasher>() -> HashSet<{unknown}, FxHasher>\n     [175; 195) 'FxHash...ault()': HashSet<{unknown}, FxHasher>\n     \"###\n     );"}, {"sha": "3803f5938cfa75bd546a7ef32c4598208e3c5ead", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -754,15 +754,15 @@ fn test() {\n     [289; 295) 'self.0': T\n     [315; 353) '{     ...))); }': ()\n     [325; 326) 't': &i32\n-    [329; 335) 'A::foo': fn foo<i32>(&A<T>) -> &T\n+    [329; 335) 'A::foo': fn foo<i32>(&A<i32>) -> &i32\n     [329; 350) 'A::foo...42))))': &i32\n     [336; 349) '&&B(B(A(42)))': &&B<B<A<i32>>>\n     [337; 349) '&B(B(A(42)))': &B<B<A<i32>>>\n-    [338; 339) 'B': B<B<A<i32>>>(T) -> B<T>\n+    [338; 339) 'B': B<B<A<i32>>>(B<A<i32>>) -> B<B<A<i32>>>\n     [338; 349) 'B(B(A(42)))': B<B<A<i32>>>\n-    [340; 341) 'B': B<A<i32>>(T) -> B<T>\n+    [340; 341) 'B': B<A<i32>>(A<i32>) -> B<A<i32>>\n     [340; 348) 'B(A(42))': B<A<i32>>\n-    [342; 343) 'A': A<i32>(T) -> A<T>\n+    [342; 343) 'A': A<i32>(i32) -> A<i32>\n     [342; 347) 'A(42)': A<i32>\n     [344; 346) '42': i32\n     \"###\n@@ -817,16 +817,16 @@ fn test(a: A<i32>) {\n     [326; 327) 'a': A<i32>\n     [337; 383) '{     ...))); }': ()\n     [347; 348) 't': &i32\n-    [351; 352) 'A': A<i32>(*mut T) -> A<T>\n+    [351; 352) 'A': A<i32>(*mut i32) -> A<i32>\n     [351; 365) 'A(0 as *mut _)': A<i32>\n     [351; 380) 'A(0 as...B(a)))': &i32\n     [353; 354) '0': i32\n     [353; 364) '0 as *mut _': *mut i32\n     [370; 379) '&&B(B(a))': &&B<B<A<i32>>>\n     [371; 379) '&B(B(a))': &B<B<A<i32>>>\n-    [372; 373) 'B': B<B<A<i32>>>(T) -> B<T>\n+    [372; 373) 'B': B<B<A<i32>>>(B<A<i32>>) -> B<B<A<i32>>>\n     [372; 379) 'B(B(a))': B<B<A<i32>>>\n-    [374; 375) 'B': B<A<i32>>(T) -> B<T>\n+    [374; 375) 'B': B<A<i32>>(A<i32>) -> B<A<i32>>\n     [374; 378) 'B(a)': B<A<i32>>\n     [376; 377) 'a': A<i32>\n     \"###\n@@ -1169,16 +1169,16 @@ fn test() {\n \"#),\n         @r###\"\n     [76; 184) '{     ...one; }': ()\n-    [82; 83) 'A': A<i32>(T) -> A<T>\n+    [82; 83) 'A': A<i32>(i32) -> A<i32>\n     [82; 87) 'A(42)': A<i32>\n     [84; 86) '42': i32\n-    [93; 94) 'A': A<u128>(T) -> A<T>\n+    [93; 94) 'A': A<u128>(u128) -> A<u128>\n     [93; 102) 'A(42u128)': A<u128>\n     [95; 101) '42u128': u128\n-    [108; 112) 'Some': Some<&str>(T) -> Option<T>\n+    [108; 112) 'Some': Some<&str>(&str) -> Option<&str>\n     [108; 117) 'Some(\"x\")': Option<&str>\n     [113; 116) '\"x\"': &str\n-    [123; 135) 'Option::Some': Some<&str>(T) -> Option<T>\n+    [123; 135) 'Option::Some': Some<&str>(&str) -> Option<&str>\n     [123; 140) 'Option...e(\"x\")': Option<&str>\n     [136; 139) '\"x\"': &str\n     [146; 150) 'None': Option<{unknown}>\n@@ -1205,22 +1205,22 @@ fn test() {\n     [21; 26) '{ t }': T\n     [23; 24) 't': T\n     [38; 98) '{     ...(1); }': ()\n-    [44; 46) 'id': fn id<u32>(T) -> T\n+    [44; 46) 'id': fn id<u32>(u32) -> u32\n     [44; 52) 'id(1u32)': u32\n     [47; 51) '1u32': u32\n-    [58; 68) 'id::<i128>': fn id<i128>(T) -> T\n+    [58; 68) 'id::<i128>': fn id<i128>(i128) -> i128\n     [58; 71) 'id::<i128>(1)': i128\n     [69; 70) '1': i128\n     [81; 82) 'x': u64\n-    [90; 92) 'id': fn id<u64>(T) -> T\n+    [90; 92) 'id': fn id<u64>(u64) -> u64\n     [90; 95) 'id(1)': u64\n     [93; 94) '1': u64\n     \"###\n     );\n }\n \n #[test]\n-fn infer_impl_generics() {\n+fn infer_impl_generics_basic() {\n     assert_snapshot!(\n         infer(r#\"\n struct A<T1, T2> {\n@@ -1349,16 +1349,16 @@ fn test() -> i128 {\n     [146; 147) 'x': i128\n     [150; 151) '1': i128\n     [162; 163) 'y': i128\n-    [166; 168) 'id': fn id<i128>(T) -> T\n+    [166; 168) 'id': fn id<i128>(i128) -> i128\n     [166; 171) 'id(x)': i128\n     [169; 170) 'x': i128\n     [182; 183) 'a': A<i128>\n     [186; 200) 'A { x: id(y) }': A<i128>\n-    [193; 195) 'id': fn id<i128>(T) -> T\n+    [193; 195) 'id': fn id<i128>(i128) -> i128\n     [193; 198) 'id(y)': i128\n     [196; 197) 'y': i128\n     [211; 212) 'z': i128\n-    [215; 217) 'id': fn id<i128>(T) -> T\n+    [215; 217) 'id': fn id<i128>(i128) -> i128\n     [215; 222) 'id(a.x)': i128\n     [218; 219) 'a': A<i128>\n     [218; 221) 'a.x': i128\n@@ -1502,14 +1502,14 @@ fn test() {\n     [78; 158) '{     ...(1); }': ()\n     [88; 89) 'y': u32\n     [92; 97) '10u32': u32\n-    [103; 105) 'id': fn id<u32>(T) -> T\n+    [103; 105) 'id': fn id<u32>(u32) -> u32\n     [103; 108) 'id(y)': u32\n     [106; 107) 'y': u32\n     [118; 119) 'x': bool\n-    [128; 133) 'clone': fn clone<bool>(&T) -> T\n+    [128; 133) 'clone': fn clone<bool>(&bool) -> bool\n     [128; 136) 'clone(z)': bool\n     [134; 135) 'z': &bool\n-    [142; 152) 'id::<i128>': fn id<i128>(T) -> T\n+    [142; 152) 'id::<i128>': fn id<i128>(i128) -> i128\n     [142; 155) 'id::<i128>(1)': i128\n     [153; 154) '1': i128\n     \"###"}, {"sha": "17611ddbfa4217338b6792ee31ac43f17c20b199", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 257, "deletions": 55, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -1,7 +1,6 @@\n use insta::assert_snapshot;\n \n use ra_db::fixture::WithFixture;\n-use test_utils::covers;\n \n use super::{infer, infer_with_mismatches, type_at, type_at_pos};\n use crate::test_db::TestDB;\n@@ -261,10 +260,10 @@ fn test() {\n     [92; 94) '{}': ()\n     [105; 144) '{     ...(s); }': ()\n     [115; 116) 's': S<u32>\n-    [119; 120) 'S': S<u32>(T) -> S<T>\n+    [119; 120) 'S': S<u32>(u32) -> S<u32>\n     [119; 129) 'S(unknown)': S<u32>\n     [121; 128) 'unknown': u32\n-    [135; 138) 'foo': fn foo<S<u32>>(T) -> ()\n+    [135; 138) 'foo': fn foo<S<u32>>(S<u32>) -> ()\n     [135; 141) 'foo(s)': ()\n     [139; 140) 's': S<u32>\n     \"###\n@@ -289,11 +288,11 @@ fn test() {\n     [98; 100) '{}': ()\n     [111; 163) '{     ...(s); }': ()\n     [121; 122) 's': S<u32>\n-    [125; 126) 'S': S<u32>(T) -> S<T>\n+    [125; 126) 'S': S<u32>(u32) -> S<u32>\n     [125; 135) 'S(unknown)': S<u32>\n     [127; 134) 'unknown': u32\n     [145; 146) 'x': u32\n-    [154; 157) 'foo': fn foo<u32, S<u32>>(T) -> U\n+    [154; 157) 'foo': fn foo<u32, S<u32>>(S<u32>) -> u32\n     [154; 160) 'foo(s)': u32\n     [158; 159) 's': S<u32>\n     \"###\n@@ -358,15 +357,15 @@ fn test() {\n     [221; 223) '{}': ()\n     [234; 300) '{     ...(S); }': ()\n     [244; 245) 'x': u32\n-    [248; 252) 'foo1': fn foo1<S>(T) -> <T as Iterable>::Item\n+    [248; 252) 'foo1': fn foo1<S>(S) -> <S as Iterable>::Item\n     [248; 255) 'foo1(S)': u32\n     [253; 254) 'S': S\n     [265; 266) 'y': u32\n-    [269; 273) 'foo2': fn foo2<S>(T) -> <T as Iterable>::Item\n+    [269; 273) 'foo2': fn foo2<S>(S) -> <S as Iterable>::Item\n     [269; 276) 'foo2(S)': u32\n     [274; 275) 'S': S\n     [286; 287) 'z': u32\n-    [290; 294) 'foo3': fn foo3<S>(T) -> <T as Iterable>::Item\n+    [290; 294) 'foo3': fn foo3<S>(S) -> <S as Iterable>::Item\n     [290; 297) 'foo3(S)': u32\n     [295; 296) 'S': S\n     \"###\n@@ -822,8 +821,7 @@ fn test<T: ApplyL>() {\n \"#,\n     );\n     // inside the generic function, the associated type gets normalized to a placeholder `ApplL::Out<T>` [https://rust-lang.github.io/rustc-guide/traits/associated-types.html#placeholder-associated-types].\n-    // FIXME: fix type parameter names going missing when going through Chalk\n-    assert_eq!(t, \"ApplyL::Out<[missing name]>\");\n+    assert_eq!(t, \"ApplyL::Out<T>\");\n }\n \n #[test]\n@@ -849,6 +847,197 @@ fn test<T: ApplyL>(t: T) {\n     assert_eq!(t, \"{unknown}\");\n }\n \n+#[test]\n+fn argument_impl_trait() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+    fn foo2(&self) -> i64;\n+}\n+fn bar(x: impl Trait<u16>) {}\n+struct S<T>(T);\n+impl<T> Trait<T> for S<T> {}\n+\n+fn test(x: impl Trait<u64>, y: &impl Trait<u32>) {\n+    x;\n+    y;\n+    let z = S(1);\n+    bar(z);\n+    x.foo();\n+    y.foo();\n+    z.foo();\n+    x.foo2();\n+    y.foo2();\n+    z.foo2();\n+}\n+\"#, true),\n+        @r###\"\n+    [30; 34) 'self': &Self\n+    [55; 59) 'self': &Self\n+    [78; 79) 'x': impl Trait<u16>\n+    [98; 100) '{}': ()\n+    [155; 156) 'x': impl Trait<u64>\n+    [175; 176) 'y': &impl Trait<u32>\n+    [196; 324) '{     ...2(); }': ()\n+    [202; 203) 'x': impl Trait<u64>\n+    [209; 210) 'y': &impl Trait<u32>\n+    [220; 221) 'z': S<u16>\n+    [224; 225) 'S': S<u16>(u16) -> S<u16>\n+    [224; 228) 'S(1)': S<u16>\n+    [226; 227) '1': u16\n+    [234; 237) 'bar': fn bar(S<u16>) -> ()\n+    [234; 240) 'bar(z)': ()\n+    [238; 239) 'z': S<u16>\n+    [246; 247) 'x': impl Trait<u64>\n+    [246; 253) 'x.foo()': u64\n+    [259; 260) 'y': &impl Trait<u32>\n+    [259; 266) 'y.foo()': u32\n+    [272; 273) 'z': S<u16>\n+    [272; 279) 'z.foo()': u16\n+    [285; 286) 'x': impl Trait<u64>\n+    [285; 293) 'x.foo2()': i64\n+    [299; 300) 'y': &impl Trait<u32>\n+    [299; 307) 'y.foo2()': i64\n+    [313; 314) 'z': S<u16>\n+    [313; 321) 'z.foo2()': i64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn argument_impl_trait_type_args_1() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+trait Trait {}\n+trait Foo {\n+    // this function has an implicit Self param, an explicit type param,\n+    // and an implicit impl Trait param!\n+    fn bar<T>(x: impl Trait) -> T { loop {} }\n+}\n+fn foo<T>(x: impl Trait) -> T { loop {} }\n+struct S;\n+impl Trait for S {}\n+struct F;\n+impl Foo for F {}\n+\n+fn test() {\n+    Foo::bar(S);\n+    <F as Foo>::bar(S);\n+    F::bar(S);\n+    Foo::bar::<u32>(S);\n+    <F as Foo>::bar::<u32>(S);\n+\n+    foo(S);\n+    foo::<u32>(S);\n+    foo::<u32, i32>(S); // we should ignore the extraneous i32\n+}\n+\"#, true),\n+        @r###\"\n+    [156; 157) 'x': impl Trait\n+    [176; 187) '{ loop {} }': T\n+    [178; 185) 'loop {}': !\n+    [183; 185) '{}': ()\n+    [200; 201) 'x': impl Trait\n+    [220; 231) '{ loop {} }': T\n+    [222; 229) 'loop {}': !\n+    [227; 229) '{}': ()\n+    [301; 510) '{     ... i32 }': ()\n+    [307; 315) 'Foo::bar': fn bar<{unknown}, {unknown}>(S) -> {unknown}\n+    [307; 318) 'Foo::bar(S)': {unknown}\n+    [316; 317) 'S': S\n+    [324; 339) '<F as Foo>::bar': fn bar<F, {unknown}>(S) -> {unknown}\n+    [324; 342) '<F as ...bar(S)': {unknown}\n+    [340; 341) 'S': S\n+    [348; 354) 'F::bar': fn bar<F, {unknown}>(S) -> {unknown}\n+    [348; 357) 'F::bar(S)': {unknown}\n+    [355; 356) 'S': S\n+    [363; 378) 'Foo::bar::<u32>': fn bar<{unknown}, u32>(S) -> u32\n+    [363; 381) 'Foo::b...32>(S)': u32\n+    [379; 380) 'S': S\n+    [387; 409) '<F as ...:<u32>': fn bar<F, u32>(S) -> u32\n+    [387; 412) '<F as ...32>(S)': u32\n+    [410; 411) 'S': S\n+    [419; 422) 'foo': fn foo<{unknown}>(S) -> {unknown}\n+    [419; 425) 'foo(S)': {unknown}\n+    [423; 424) 'S': S\n+    [431; 441) 'foo::<u32>': fn foo<u32>(S) -> u32\n+    [431; 444) 'foo::<u32>(S)': u32\n+    [442; 443) 'S': S\n+    [450; 465) 'foo::<u32, i32>': fn foo<u32>(S) -> u32\n+    [450; 468) 'foo::<...32>(S)': u32\n+    [466; 467) 'S': S\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn argument_impl_trait_type_args_2() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+trait Trait {}\n+struct S;\n+impl Trait for S {}\n+struct F<T>;\n+impl<T> F<T> {\n+    fn foo<U>(self, x: impl Trait) -> (T, U) { loop {} }\n+}\n+\n+fn test() {\n+    F.foo(S);\n+    F::<u32>.foo(S);\n+    F::<u32>.foo::<i32>(S);\n+    F::<u32>.foo::<i32, u32>(S); // extraneous argument should be ignored\n+}\n+\"#, true),\n+        @r###\"\n+    [88; 92) 'self': F<T>\n+    [94; 95) 'x': impl Trait\n+    [119; 130) '{ loop {} }': (T, U)\n+    [121; 128) 'loop {}': !\n+    [126; 128) '{}': ()\n+    [144; 284) '{     ...ored }': ()\n+    [150; 151) 'F': F<{unknown}>\n+    [150; 158) 'F.foo(S)': ({unknown}, {unknown})\n+    [156; 157) 'S': S\n+    [164; 172) 'F::<u32>': F<u32>\n+    [164; 179) 'F::<u32>.foo(S)': (u32, {unknown})\n+    [177; 178) 'S': S\n+    [185; 193) 'F::<u32>': F<u32>\n+    [185; 207) 'F::<u3...32>(S)': (u32, i32)\n+    [205; 206) 'S': S\n+    [213; 221) 'F::<u32>': F<u32>\n+    [213; 240) 'F::<u3...32>(S)': (u32, i32)\n+    [238; 239) 'S': S\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn argument_impl_trait_to_fn_pointer() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+trait Trait {}\n+fn foo(x: impl Trait) { loop {} }\n+struct S;\n+impl Trait for S {}\n+\n+fn test() {\n+    let f: fn(S) -> () = foo;\n+}\n+\"#, true),\n+        @r###\"\n+    [23; 24) 'x': impl Trait\n+    [38; 49) '{ loop {} }': ()\n+    [40; 47) 'loop {}': !\n+    [45; 47) '{}': ()\n+    [91; 124) '{     ...foo; }': ()\n+    [101; 102) 'f': fn(S) -> ()\n+    [118; 121) 'foo': fn foo(S) -> ()\n+    \"###\n+    );\n+}\n+\n #[test]\n #[ignore]\n fn impl_trait() {\n@@ -994,29 +1183,17 @@ fn weird_bounds() {\n     assert_snapshot!(\n         infer(r#\"\n trait Trait {}\n-fn test() {\n-    let a: impl Trait + 'lifetime = foo;\n-    let b: impl 'lifetime = foo;\n-    let b: impl (Trait) = foo;\n-    let b: impl ('lifetime) = foo;\n-    let d: impl ?Sized = foo;\n-    let e: impl Trait + ?Sized = foo;\n+fn test(a: impl Trait + 'lifetime, b: impl 'lifetime, c: impl (Trait), d: impl ('lifetime), e: impl ?Sized, f: impl Trait + ?Sized) {\n }\n \"#),\n         @r###\"\n-    [26; 237) '{     ...foo; }': ()\n-    [36; 37) 'a': impl Trait + {error}\n-    [64; 67) 'foo': impl Trait + {error}\n-    [77; 78) 'b': impl {error}\n-    [97; 100) 'foo': impl {error}\n-    [110; 111) 'b': impl Trait\n-    [128; 131) 'foo': impl Trait\n-    [141; 142) 'b': impl {error}\n-    [163; 166) 'foo': impl {error}\n-    [176; 177) 'd': impl {error}\n-    [193; 196) 'foo': impl {error}\n-    [206; 207) 'e': impl Trait + {error}\n-    [231; 234) 'foo': impl Trait + {error}\n+    [24; 25) 'a': impl Trait + {error}\n+    [51; 52) 'b': impl {error}\n+    [70; 71) 'c': impl Trait\n+    [87; 88) 'd': impl {error}\n+    [108; 109) 'e': impl {error}\n+    [124; 125) 'f': impl Trait + {error}\n+    [148; 151) '{ }': ()\n     \"###\n     );\n }\n@@ -1078,26 +1255,26 @@ fn test<T: Trait<Type = u32>>(x: T, y: impl Trait<Type = i64>) {\n     [296; 299) 'get': fn get<T>(T) -> <T as Trait>::Type\n     [296; 302) 'get(x)': {unknown}\n     [300; 301) 'x': T\n-    [308; 312) 'get2': fn get2<{unknown}, T>(T) -> U\n+    [308; 312) 'get2': fn get2<{unknown}, T>(T) -> {unknown}\n     [308; 315) 'get2(x)': {unknown}\n     [313; 314) 'x': T\n-    [321; 324) 'get': fn get<impl Trait<Type = i64>>(T) -> <T as Trait>::Type\n+    [321; 324) 'get': fn get<impl Trait<Type = i64>>(impl Trait<Type = i64>) -> <impl Trait<Type = i64> as Trait>::Type\n     [321; 327) 'get(y)': {unknown}\n     [325; 326) 'y': impl Trait<Type = i64>\n-    [333; 337) 'get2': fn get2<{unknown}, impl Trait<Type = i64>>(T) -> U\n+    [333; 337) 'get2': fn get2<{unknown}, impl Trait<Type = i64>>(impl Trait<Type = i64>) -> {unknown}\n     [333; 340) 'get2(y)': {unknown}\n     [338; 339) 'y': impl Trait<Type = i64>\n-    [346; 349) 'get': fn get<S<u64>>(T) -> <T as Trait>::Type\n+    [346; 349) 'get': fn get<S<u64>>(S<u64>) -> <S<u64> as Trait>::Type\n     [346; 357) 'get(set(S))': u64\n-    [350; 353) 'set': fn set<S<u64>>(T) -> T\n+    [350; 353) 'set': fn set<S<u64>>(S<u64>) -> S<u64>\n     [350; 356) 'set(S)': S<u64>\n     [354; 355) 'S': S<u64>\n-    [363; 367) 'get2': fn get2<u64, S<u64>>(T) -> U\n+    [363; 367) 'get2': fn get2<u64, S<u64>>(S<u64>) -> u64\n     [363; 375) 'get2(set(S))': u64\n-    [368; 371) 'set': fn set<S<u64>>(T) -> T\n+    [368; 371) 'set': fn set<S<u64>>(S<u64>) -> S<u64>\n     [368; 374) 'set(S)': S<u64>\n     [372; 373) 'S': S<u64>\n-    [381; 385) 'get2': fn get2<str, S<str>>(T) -> U\n+    [381; 385) 'get2': fn get2<str, S<str>>(S<str>) -> str\n     [381; 395) 'get2(S::<str>)': str\n     [386; 394) 'S::<str>': S<str>\n     \"###\n@@ -1224,6 +1401,32 @@ fn test<T: Trait1, U: Trait2>(x: T, y: U) {\n     );\n }\n \n+#[test]\n+fn super_trait_impl_trait_method_resolution() {\n+    assert_snapshot!(\n+        infer(r#\"\n+mod foo {\n+    trait SuperTrait {\n+        fn foo(&self) -> u32 {}\n+    }\n+}\n+trait Trait1: foo::SuperTrait {}\n+\n+fn test(x: &impl Trait1) {\n+    x.foo();\n+}\n+\"#),\n+        @r###\"\n+    [50; 54) 'self': &Self\n+    [63; 65) '{}': ()\n+    [116; 117) 'x': &impl Trait1\n+    [133; 149) '{     ...o(); }': ()\n+    [139; 140) 'x': &impl Trait1\n+    [139; 146) 'x.foo()': u32\n+    \"###\n+    );\n+}\n+\n #[test]\n fn super_trait_cycle() {\n     // This just needs to not crash\n@@ -1270,9 +1473,9 @@ fn test() {\n     [157; 160) '{t}': T\n     [158; 159) 't': T\n     [259; 280) '{     ...S)); }': ()\n-    [265; 269) 'get2': fn get2<u64, S<u64>>(T) -> U\n+    [265; 269) 'get2': fn get2<u64, S<u64>>(S<u64>) -> u64\n     [265; 277) 'get2(set(S))': u64\n-    [270; 273) 'set': fn set<S<u64>>(T) -> T\n+    [270; 273) 'set': fn set<S<u64>>(S<u64>) -> S<u64>\n     [270; 276) 'set(S)': S<u64>\n     [274; 275) 'S': S<u64>\n     \"###\n@@ -1334,7 +1537,7 @@ fn test() {\n     [173; 175) '{}': ()\n     [189; 308) '{     ... 1); }': ()\n     [199; 200) 'x': Option<u32>\n-    [203; 215) 'Option::Some': Some<u32>(T) -> Option<T>\n+    [203; 215) 'Option::Some': Some<u32>(u32) -> Option<u32>\n     [203; 221) 'Option...(1u32)': Option<u32>\n     [216; 220) '1u32': u32\n     [227; 228) 'x': Option<u32>\n@@ -1444,15 +1647,15 @@ fn test() {\n     [340; 342) '{}': ()\n     [356; 515) '{     ... S); }': ()\n     [366; 368) 'x1': u64\n-    [371; 375) 'foo1': fn foo1<S, u64, |S| -> u64>(T, F) -> U\n+    [371; 375) 'foo1': fn foo1<S, u64, |S| -> u64>(S, |S| -> u64) -> u64\n     [371; 394) 'foo1(S...hod())': u64\n     [376; 377) 'S': S\n     [379; 393) '|s| s.method()': |S| -> u64\n     [380; 381) 's': S\n     [383; 384) 's': S\n     [383; 393) 's.method()': u64\n     [404; 406) 'x2': u64\n-    [409; 413) 'foo2': fn foo2<S, u64, |S| -> u64>(F, T) -> U\n+    [409; 413) 'foo2': fn foo2<S, u64, |S| -> u64>(|S| -> u64, S) -> u64\n     [409; 432) 'foo2(|...(), S)': u64\n     [414; 428) '|s| s.method()': |S| -> u64\n     [415; 416) 's': S\n@@ -1605,7 +1808,6 @@ fn test<T, U>() where T: Trait<U::Item>, U: Trait<T::Item> {\n \n #[test]\n fn unify_impl_trait() {\n-    covers!(insert_vars_for_impl_trait);\n     assert_snapshot!(\n         infer_with_mismatches(r#\"\n trait Trait<T> {}\n@@ -1637,26 +1839,26 @@ fn test() -> impl Trait<i32> {\n     [172; 183) '{ loop {} }': T\n     [174; 181) 'loop {}': !\n     [179; 181) '{}': ()\n-    [214; 310) '{     ...t()) }': S<i32>\n+    [214; 310) '{     ...t()) }': S<{unknown}>\n     [224; 226) 's1': S<u32>\n-    [229; 230) 'S': S<u32>(T) -> S<T>\n+    [229; 230) 'S': S<u32>(u32) -> S<u32>\n     [229; 241) 'S(default())': S<u32>\n-    [231; 238) 'default': fn default<u32>() -> T\n+    [231; 238) 'default': fn default<u32>() -> u32\n     [231; 240) 'default()': u32\n-    [247; 250) 'foo': fn foo(impl Trait<u32>) -> ()\n+    [247; 250) 'foo': fn foo(S<u32>) -> ()\n     [247; 254) 'foo(s1)': ()\n     [251; 253) 's1': S<u32>\n     [264; 265) 'x': i32\n-    [273; 276) 'bar': fn bar<i32>(impl Trait<T>) -> T\n+    [273; 276) 'bar': fn bar<i32>(S<i32>) -> i32\n     [273; 290) 'bar(S(...lt()))': i32\n-    [277; 278) 'S': S<i32>(T) -> S<T>\n+    [277; 278) 'S': S<i32>(i32) -> S<i32>\n     [277; 289) 'S(default())': S<i32>\n-    [279; 286) 'default': fn default<i32>() -> T\n+    [279; 286) 'default': fn default<i32>() -> i32\n     [279; 288) 'default()': i32\n-    [296; 297) 'S': S<i32>(T) -> S<T>\n-    [296; 308) 'S(default())': S<i32>\n-    [298; 305) 'default': fn default<i32>() -> T\n-    [298; 307) 'default()': i32\n+    [296; 297) 'S': S<{unknown}>({unknown}) -> S<{unknown}>\n+    [296; 308) 'S(default())': S<{unknown}>\n+    [298; 305) 'default': fn default<{unknown}>() -> {unknown}\n+    [298; 307) 'default()': {unknown}\n     \"###\n     );\n }"}, {"sha": "4974c565be18e2eb03c6edc7e72a1da8f515c0f7", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -14,7 +14,7 @@ use ra_db::{\n use super::{builtin, AssocTyValue, Canonical, ChalkContext, Impl, Obligation};\n use crate::{\n     db::HirDatabase, display::HirDisplay, utils::generics, ApplicationTy, GenericPredicate,\n-    ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n+    ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n };\n \n #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]\n@@ -142,9 +142,13 @@ impl ToChalk for Ty {\n                 let substitution = proj_ty.parameters.to_chalk(db);\n                 chalk_ir::AliasTy { associated_ty_id, substitution }.cast().intern()\n             }\n-            Ty::Param { idx, .. } => {\n-                PlaceholderIndex { ui: UniverseIndex::ROOT, idx: idx as usize }\n-                    .to_ty::<TypeFamily>()\n+            Ty::Param(id) => {\n+                let interned_id = db.intern_type_param_id(id);\n+                PlaceholderIndex {\n+                    ui: UniverseIndex::ROOT,\n+                    idx: interned_id.as_intern_id().as_usize(),\n+                }\n+                .to_ty::<TypeFamily>()\n             }\n             Ty::Bound(idx) => chalk_ir::TyData::BoundVar(idx as usize).intern(),\n             Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n@@ -177,7 +181,10 @@ impl ToChalk for Ty {\n             },\n             chalk_ir::TyData::Placeholder(idx) => {\n                 assert_eq!(idx.ui, UniverseIndex::ROOT);\n-                Ty::Param { idx: idx.idx as u32, name: crate::Name::missing() }\n+                let interned_id = crate::db::GlobalTypeParamId::from_intern_id(\n+                    crate::salsa::InternId::from(idx.idx),\n+                );\n+                Ty::Param(db.lookup_intern_type_param_id(interned_id))\n             }\n             chalk_ir::TyData::Alias(proj) => {\n                 let associated_ty = from_chalk(db, proj.associated_ty_id);\n@@ -520,7 +527,7 @@ fn convert_where_clauses(\n     let generic_predicates = db.generic_predicates(def);\n     let mut result = Vec::with_capacity(generic_predicates.len());\n     for pred in generic_predicates.iter() {\n-        if pred.is_error() {\n+        if pred.value.is_error() {\n             // skip errored predicates completely\n             continue;\n         }\n@@ -709,12 +716,12 @@ fn impl_block_datum(\n     let trait_ref = db\n         .impl_trait(impl_id)\n         // ImplIds for impls where the trait ref can't be resolved should never reach Chalk\n-        .expect(\"invalid impl passed to Chalk\");\n+        .expect(\"invalid impl passed to Chalk\")\n+        .value;\n     let impl_data = db.impl_data(impl_id);\n \n     let generic_params = generics(db, impl_id.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n-    let trait_ref = trait_ref.subst(&bound_vars);\n     let trait_ = trait_ref.trait_;\n     let impl_type = if impl_id.lookup(db).container.module(db).krate == krate {\n         chalk_rust_ir::ImplType::Local\n@@ -789,20 +796,18 @@ fn type_alias_associated_ty_value(\n         _ => panic!(\"assoc ty value should be in impl\"),\n     };\n \n-    let trait_ref = db.impl_trait(impl_id).expect(\"assoc ty value should not exist\"); // we don't return any assoc ty values if the impl'd trait can't be resolved\n+    let trait_ref = db.impl_trait(impl_id).expect(\"assoc ty value should not exist\").value; // we don't return any assoc ty values if the impl'd trait can't be resolved\n \n     let assoc_ty = db\n         .trait_data(trait_ref.trait_)\n         .associated_type_by_name(&type_alias_data.name)\n         .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n-    let generic_params = generics(db, impl_id.into());\n-    let bound_vars = Substs::bound_vars(&generic_params);\n-    let ty = db.ty(type_alias.into()).subst(&bound_vars);\n-    let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) };\n+    let ty = db.ty(type_alias.into());\n+    let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: ty.value.to_chalk(db) };\n     let value = chalk_rust_ir::AssociatedTyValue {\n         impl_id: Impl::ImplBlock(impl_id.into()).to_chalk(db),\n         associated_ty_id: assoc_ty.to_chalk(db),\n-        value: make_binders(value_bound, bound_vars.len()),\n+        value: make_binders(value_bound, ty.num_binders),\n     };\n     Arc::new(value)\n }"}, {"sha": "508ae90465d7a9f8fcaa2547713fe7cef0b9001f", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 68, "deletions": 23, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01836a0f35fa163025c64cabe1d0c34bb4f69c92/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=01836a0f35fa163025c64cabe1d0c34bb4f69c92", "patch": "@@ -2,10 +2,11 @@\n //! query, but can't be computed directly from `*Data` (ie, which need a `db`).\n use std::sync::Arc;\n \n+use hir_def::generics::WherePredicateTarget;\n use hir_def::{\n     adt::VariantData,\n     db::DefDatabase,\n-    generics::{GenericParams, TypeParamData},\n+    generics::{GenericParams, TypeParamData, TypeParamProvenance},\n     path::Path,\n     resolver::{HasResolver, TypeNs},\n     type_ref::TypeRef,\n@@ -19,11 +20,18 @@ fn direct_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n     // lifetime problems, but since there usually shouldn't be more than a\n     // few direct traits this should be fine (we could even use some kind of\n     // SmallVec if performance is a concern)\n-    db.generic_params(trait_.into())\n+    let generic_params = db.generic_params(trait_.into());\n+    let trait_self = generic_params.find_trait_self_param();\n+    generic_params\n         .where_predicates\n         .iter()\n-        .filter_map(|pred| match &pred.type_ref {\n-            TypeRef::Path(p) if p == &Path::from(name![Self]) => pred.bound.as_path(),\n+        .filter_map(|pred| match &pred.target {\n+            WherePredicateTarget::TypeRef(TypeRef::Path(p)) if p == &Path::from(name![Self]) => {\n+                pred.bound.as_path()\n+            }\n+            WherePredicateTarget::TypeParam(local_id) if Some(*local_id) == trait_self => {\n+                pred.bound.as_path()\n+            }\n             _ => None,\n         })\n         .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path.mod_path()) {\n@@ -95,41 +103,77 @@ pub(crate) struct Generics {\n }\n \n impl Generics {\n-    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = (u32, &'a TypeParamData)> + 'a {\n+    pub(crate) fn iter<'a>(\n+        &'a self,\n+    ) -> impl Iterator<Item = (TypeParamId, &'a TypeParamData)> + 'a {\n         self.parent_generics\n             .as_ref()\n             .into_iter()\n-            .flat_map(|it| it.params.types.iter())\n-            .chain(self.params.types.iter())\n-            .enumerate()\n-            .map(|(i, (_local_id, p))| (i as u32, p))\n+            .flat_map(|it| {\n+                it.params\n+                    .types\n+                    .iter()\n+                    .map(move |(local_id, p)| (TypeParamId { parent: it.def, local_id }, p))\n+            })\n+            .chain(\n+                self.params\n+                    .types\n+                    .iter()\n+                    .map(move |(local_id, p)| (TypeParamId { parent: self.def, local_id }, p)),\n+            )\n     }\n \n-    pub(crate) fn iter_parent<'a>(&'a self) -> impl Iterator<Item = (u32, &'a TypeParamData)> + 'a {\n-        self.parent_generics\n-            .as_ref()\n-            .into_iter()\n-            .flat_map(|it| it.params.types.iter())\n-            .enumerate()\n-            .map(|(i, (_local_id, p))| (i as u32, p))\n+    pub(crate) fn iter_parent<'a>(\n+        &'a self,\n+    ) -> impl Iterator<Item = (TypeParamId, &'a TypeParamData)> + 'a {\n+        self.parent_generics.as_ref().into_iter().flat_map(|it| {\n+            it.params\n+                .types\n+                .iter()\n+                .map(move |(local_id, p)| (TypeParamId { parent: it.def, local_id }, p))\n+        })\n     }\n \n     pub(crate) fn len(&self) -> usize {\n         self.len_split().0\n     }\n+\n     /// (total, parents, child)\n     pub(crate) fn len_split(&self) -> (usize, usize, usize) {\n         let parent = self.parent_generics.as_ref().map_or(0, |p| p.len());\n         let child = self.params.types.len();\n         (parent + child, parent, child)\n     }\n-    pub(crate) fn param_idx(&self, param: TypeParamId) -> u32 {\n-        self.find_param(param).0\n+\n+    /// (parent total, self param, type param list, impl trait)\n+    pub(crate) fn provenance_split(&self) -> (usize, usize, usize, usize) {\n+        let parent = self.parent_generics.as_ref().map_or(0, |p| p.len());\n+        let self_params = self\n+            .params\n+            .types\n+            .iter()\n+            .filter(|(_, p)| p.provenance == TypeParamProvenance::TraitSelf)\n+            .count();\n+        let list_params = self\n+            .params\n+            .types\n+            .iter()\n+            .filter(|(_, p)| p.provenance == TypeParamProvenance::TypeParamList)\n+            .count();\n+        let impl_trait_params = self\n+            .params\n+            .types\n+            .iter()\n+            .filter(|(_, p)| p.provenance == TypeParamProvenance::ArgumentImplTrait)\n+            .count();\n+        (parent, self_params, list_params, impl_trait_params)\n     }\n-    pub(crate) fn param_name(&self, param: TypeParamId) -> Name {\n-        self.find_param(param).1.name.clone()\n+\n+    pub(crate) fn param_idx(&self, param: TypeParamId) -> Option<u32> {\n+        Some(self.find_param(param)?.0)\n     }\n-    fn find_param(&self, param: TypeParamId) -> (u32, &TypeParamData) {\n+\n+    fn find_param(&self, param: TypeParamId) -> Option<(u32, &TypeParamData)> {\n         if param.parent == self.def {\n             let (idx, (_local_id, data)) = self\n                 .params\n@@ -139,9 +183,10 @@ impl Generics {\n                 .find(|(_, (idx, _))| *idx == param.local_id)\n                 .unwrap();\n             let (_total, parent_len, _child) = self.len_split();\n-            return ((parent_len + idx) as u32, data);\n+            Some(((parent_len + idx) as u32, data))\n+        } else {\n+            self.parent_generics.as_ref().and_then(|g| g.find_param(param))\n         }\n-        self.parent_generics.as_ref().unwrap().find_param(param)\n     }\n }\n "}]}