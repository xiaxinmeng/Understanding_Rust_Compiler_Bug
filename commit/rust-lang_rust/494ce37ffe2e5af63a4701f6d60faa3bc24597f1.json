{"sha": "494ce37ffe2e5af63a4701f6d60faa3bc24597f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5NGNlMzdmZmUyZTVhZjYzYTQ3MDFmNmQ2MGZhYTNiYzI0NTk3ZjE=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-06-10T09:42:48Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-07-28T14:15:51Z"}, "message": "Reduced the Lvalue constructors to a kernel of three constructors.\n\nUpdated all call sites that used the other contructors to uniformly\ncall `Lvalue::new_with_hint`, passing along the appropriate kind\nof hint for each context.\n\nPlacated tidy in a few other places in datum.rs.", "tree": {"sha": "9d85114fc80f1c5507f268f78a0e4bfe885916a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d85114fc80f1c5507f268f78a0e4bfe885916a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/494ce37ffe2e5af63a4701f6d60faa3bc24597f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/494ce37ffe2e5af63a4701f6d60faa3bc24597f1", "html_url": "https://github.com/rust-lang/rust/commit/494ce37ffe2e5af63a4701f6d60faa3bc24597f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/494ce37ffe2e5af63a4701f6d60faa3bc24597f1/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff14eaf0542b94dce2b4afce1b5443795c11884a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff14eaf0542b94dce2b4afce1b5443795c11884a", "html_url": "https://github.com/rust-lang/rust/commit/ff14eaf0542b94dce2b4afce1b5443795c11884a"}], "stats": {"total": 160, "additions": 65, "deletions": 95}, "files": [{"sha": "d5305b29d75c08bed16020436a6d99b9576894fa", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/494ce37ffe2e5af63a4701f6d60faa3bc24597f1/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ce37ffe2e5af63a4701f6d60faa3bc24597f1/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=494ce37ffe2e5af63a4701f6d60faa3bc24597f1", "patch": "@@ -950,8 +950,15 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 let lvalue = match binding_info.trmode {\n                     TrByCopy(..) =>\n                         Lvalue::new(\"_match::insert_lllocals\"),\n-                    TrByMoveIntoCopy(..) =>\n-                        Lvalue::match_input(\"_match::insert_lllocals\", bcx, binding_info.id),\n+                    TrByMoveIntoCopy(..) => {\n+                        // match_input moves from the input into a\n+                        // separate stack slot; it must zero (at least\n+                        // until we track drop flags for a fragmented\n+                        // parent match input expression).\n+                        let hint_kind = HintKind::ZeroAndMaintain;\n+                        Lvalue::new_with_hint(\"_match::insert_lllocals (match_input)\",\n+                                              bcx, binding_info.id, hint_kind)\n+                    }\n                     _ => unreachable!(),\n                 };\n                 let datum = Datum::new(llval, binding_info.ty, lvalue);\n@@ -971,10 +978,22 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             TrByRef => (binding_info.llmatch, true),\n         };\n \n-        let lvalue = Lvalue::local(\"_match::insert_lllocals\",\n-                                   bcx,\n-                                   binding_info.id,\n-                                   aliases_other_state);\n+\n+        // A local that aliases some other state must be zeroed, since\n+        // the other state (e.g. some parent data that we matched\n+        // into) will still have its subcomponents (such as this\n+        // local) destructed at the end of the parent's scope. Longer\n+        // term, we will properly map such parents to the set of\n+        // unique drop flags for its fragments.\n+        let hint_kind = if aliases_other_state {\n+            HintKind::ZeroAndMaintain\n+        } else {\n+            HintKind::DontZeroJustUse\n+        };\n+        let lvalue = Lvalue::new_with_hint(\"_match::insert_lllocals (local)\",\n+                                           bcx,\n+                                           binding_info.id,\n+                                           hint_kind);\n         let datum = Datum::new(llval, binding_info.ty, lvalue);\n         if let Some(cs) = cs {\n             let opt_datum = lvalue.dropflag_hint(bcx);\n@@ -1709,7 +1728,7 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n \n     // Allocate memory on stack for the binding.\n     let llval = alloc_ty(bcx, var_ty, &bcx.name(name));\n-    let lvalue = Lvalue::binding(caller_name, bcx, p_id, name);\n+    let lvalue = Lvalue::new_with_hint(caller_name, bcx, p_id, HintKind::DontZeroJustUse);\n     let datum = Datum::new(llval, var_ty, lvalue);\n \n     // Subtle: be sure that we *populate* the memory *before*"}, {"sha": "d2daca816b751d88a8891aeeed2de216c2d96e28", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 37, "deletions": 87, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/494ce37ffe2e5af63a4701f6d60faa3bc24597f1/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ce37ffe2e5af63a4701f6d60faa3bc24597f1/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=494ce37ffe2e5af63a4701f6d60faa3bc24597f1", "patch": "@@ -189,96 +189,42 @@ pub struct Rvalue {\n     pub mode: RvalueMode\n }\n \n-// XXX: reduce this to a smaller kernel of constructors.\n-impl Lvalue { // These are all constructors for various Lvalues.\n-    pub fn new(source: &'static str) -> Lvalue {\n-        Lvalue { source: source, drop_flag_info: DropFlagInfo::None }\n-    }\n-\n-    pub fn upvar<'blk, 'tcx>(source: &'static str,\n-                             bcx: Block<'blk, 'tcx>,\n-                             id: ast::NodeId) -> Lvalue {\n-        let info = if Lvalue::has_dropflag_hint(bcx, id) {\n-            DropFlagInfo::ZeroAndMaintain(id)\n-        } else {\n-            DropFlagInfo::None\n-        };\n-        let info = if bcx.tcx().sess.nonzeroing_move_hints() { info } else { DropFlagInfo::None };\n-        debug!(\"upvar Lvalue at {}, id: {} info: {:?}\", source, id, info);\n-        Lvalue { source: source, drop_flag_info: info }\n-    }\n-\n-    pub fn match_input<'blk, 'tcx>(source: &'static str,\n-                                   bcx: Block<'blk, 'tcx>,\n-                                   id: ast::NodeId) -> Lvalue\n-    {\n-        let info = if Lvalue::has_dropflag_hint(bcx, id) {\n-            // match_input is used to move from the input into a\n-            // separate stack slot; it must zero (at least until we\n-            // improve things to track drop flags for the fragmented\n-            // parent match input expression).\n-            DropFlagInfo::ZeroAndMaintain(id)\n-        } else {\n-            DropFlagInfo::None\n-        };\n-        let info = if bcx.tcx().sess.nonzeroing_move_hints() { info } else { DropFlagInfo::None };\n-        debug!(\"match_input Lvalue at {}, id: {} info: {:?}\", source, id, info);\n-        Lvalue { source: source, drop_flag_info: info }\n-    }\n+#[derive(Copy, Clone, Debug)]\n+pub enum HintKind {\n+    ZeroAndMaintain,\n+    DontZeroJustUse,\n+}\n \n-    pub fn local<'blk, 'tcx>(source: &'static str,\n-                             bcx: Block<'blk, 'tcx>,\n-                             id: ast::NodeId,\n-                             aliases_other_state: bool)\n-                             -> Lvalue\n-    {\n-        let info = if Lvalue::has_dropflag_hint(bcx, id) {\n-            if aliases_other_state {\n-                DropFlagInfo::ZeroAndMaintain(id)\n-            } else {\n-                DropFlagInfo::DontZeroJustUse(id)\n-            }\n-        } else {\n-            DropFlagInfo::None\n-        };\n-        let info = if bcx.tcx().sess.nonzeroing_move_hints() { info } else { DropFlagInfo::None };\n-        debug!(\"local Lvalue at {}, id: {} info: {:?}\", source, id, info);\n-        Lvalue { source: source, drop_flag_info: info }\n+impl Lvalue { // Constructors for various Lvalues.\n+    pub fn new<'blk, 'tcx>(source: &'static str) -> Lvalue {\n+        debug!(\"Lvalue at {} no drop flag info\", source);\n+        Lvalue { source: source, drop_flag_info: DropFlagInfo::None }\n     }\n \n-    pub fn store_arg<'blk, 'tcx>(source: &'static str,\n-                                 bcx: Block<'blk, 'tcx>,\n-                                 id: ast::NodeId) -> Lvalue\n-    {\n-        let info = if Lvalue::has_dropflag_hint(bcx, id) {\n-            DropFlagInfo::ZeroAndMaintain(id)\n-        } else {\n-            DropFlagInfo::None\n-        };\n-        let info = if bcx.tcx().sess.nonzeroing_move_hints() { info } else { DropFlagInfo::None };\n-        debug!(\"store_arg Lvalue at {}, id: {} info: {:?}\", source, id, info);\n-        Lvalue { source: source, drop_flag_info: info }\n+    pub fn new_dropflag_hint(source: &'static str) -> Lvalue {\n+        debug!(\"Lvalue at {} is drop flag hint\", source);\n+        Lvalue { source: source, drop_flag_info: DropFlagInfo::None }\n     }\n \n-    pub fn binding<'blk, 'tcx>(source: &'static str,\n-                               bcx: Block<'blk, 'tcx>,\n-                               id: ast::NodeId,\n-                               name: ast::Name) -> Lvalue {\n-        let info = if Lvalue::has_dropflag_hint(bcx, id) {\n-            DropFlagInfo::DontZeroJustUse(id)\n-        } else {\n-            DropFlagInfo::None\n+    pub fn new_with_hint<'blk, 'tcx>(source: &'static str,\n+                                     bcx: Block<'blk, 'tcx>,\n+                                     id: ast::NodeId,\n+                                     k: HintKind) -> Lvalue {\n+        let (opt_id, info) = {\n+            let hint_available = Lvalue::has_dropflag_hint(bcx, id) &&\n+                bcx.tcx().sess.nonzeroing_move_hints();\n+            let info = match k {\n+                HintKind::ZeroAndMaintain if hint_available =>\n+                    DropFlagInfo::ZeroAndMaintain(id),\n+                HintKind::DontZeroJustUse if hint_available =>\n+                    DropFlagInfo::DontZeroJustUse(id),\n+                _ => DropFlagInfo::None,\n+            };\n+            (Some(id), info)\n         };\n-        let info = if bcx.tcx().sess.nonzeroing_move_hints() { info } else { DropFlagInfo::None };\n-        debug!(\"binding Lvalue at {}, id: {} name: {} info: {:?}\",\n-               source, id, name, info);\n+        debug!(\"Lvalue at {}, id: {:?} info: {:?}\", source, opt_id, info);\n         Lvalue { source: source, drop_flag_info: info }\n     }\n-\n-    pub fn new_dropflag_hint(source: &'static str) -> Lvalue {\n-        debug!(\"dropflag hint Lvalue at {}\", source);\n-        Lvalue { source: source, drop_flag_info: DropFlagInfo::None }\n-    }\n } // end Lvalue constructor methods.\n \n impl Lvalue {\n@@ -454,11 +400,15 @@ impl KindOps for Lvalue {\n             }\n             bcx\n         } else {\n-            // XXX would be nice to assert this, but we currently are\n-            // adding e.g.  DontZeroJustUse flags. (The dropflag hint\n-            // construction should be taking !type_needs_drop into\n-            // account; earlier analysis phases may not have all the\n-            // info they need to do it properly, I think...)\n+            // FIXME (#5016) would be nice to assert this, but we have\n+            // to allow for e.g. DontZeroJustUse flags, for now.\n+            //\n+            // (The dropflag hint construction should be taking\n+            // !type_needs_drop into account; earlier analysis phases\n+            // may not have all the info they need to include such\n+            // information properly, I think; in particular the\n+            // fragments analysis works on a non-monomorphized view of\n+            // the code.)\n             //\n             // assert_eq!(self.drop_flag_info, DropFlagInfo::None);\n             bcx"}, {"sha": "35e3c96d09c8013cd9e4360bccec1ce2c99810df", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/494ce37ffe2e5af63a4701f6d60faa3bc24597f1/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494ce37ffe2e5af63a4701f6d60faa3bc24597f1/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=494ce37ffe2e5af63a4701f6d60faa3bc24597f1", "patch": "@@ -1321,7 +1321,8 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         def::DefUpvar(nid, _) => {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n-            let lval = Lvalue::upvar(\"expr::trans_local_var\", bcx, nid);\n+            let lval = Lvalue::new_with_hint(\"expr::trans_local_var (upvar)\",\n+                                             bcx, nid, HintKind::ZeroAndMaintain);\n             match bcx.fcx.llupvars.borrow().get(&nid) {\n                 Some(&val) => Datum::new(val, local_ty, lval),\n                 None => {"}]}