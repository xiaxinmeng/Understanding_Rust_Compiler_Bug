{"sha": "823210901d1664dee1e78e2b37b95488341c5075", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyMzIxMDkwMWQxNjY0ZGVlMWU3OGUyYjM3Yjk1NDg4MzQxYzUwNzU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-12-21T01:47:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-21T01:47:50Z"}, "message": "Rollup merge of #80244 - jyn514:spans, r=bugadani\n\nCleanup markdown span handling\n\n1. Get rid of `locate()` in markdown handling\n\nThis function was unfortunate for several reasons:\n\n- It used `unsafe` because it wanted to tell whether a string came from\n  the same *allocation* as another, not just whether it was a textual match.\n- It recalculated spans even though they were already available from pulldown\n- It sometimes *failed* to calculate the span, which meant it was always possible for the span to be `None`, even though in practice that should never happen.\n\nThis has several cleanups:\n\n- Make the span required\n- Pass through the span from pulldown in the `HeadingLinks` and `Footnotes` iterators\n- Only add iterator bounds on the `impl Iterator`, not on `new` and the struct itself.\n\n2. Remove unnecessary scope in `markdown_links`\n\nI recommend reading a single commit at a time.\n\ncc ``@bugadani`` - this will conflict with https://github.com/rust-lang/rust/pull/77859, I'll try to make sure that gets merged first.", "tree": {"sha": "62e41fa45dc8a1f4252d34e970975e9a9279b5a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62e41fa45dc8a1f4252d34e970975e9a9279b5a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/823210901d1664dee1e78e2b37b95488341c5075", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf3/7HCRBK7hj4Ov3rIwAAdHIIAB+EzAtghivrNWS3781Fmil9\nDu5DH34y6ZbxfPeNoNKDrZFKG+3hWp6syV+SSSc7dIh/hrkLU6F/2aHAbCq8pKzp\nb6NrkM3jG/CKwI6JfnN0TiJmmNkQRJUyA0bVJF/BVattg3ubwrbYK+mcm2cX2Nza\n/Qnec+9mARdOBHrDTocXyjzts49hMd7rOiqL39ndcabtX8m9stONDwTZ5PXjoToq\nkJvtE0jpIyP1WAsvyCrMe2/pVEM6xnKfXzXY9NAUJUbHRr6aVnduZW6CQ2QTxWUI\nnVeJfGngb2v9J1KVjzjoHB6c1aieQ2H9BLI3w7lPv6UY/fSn6C3wiiZzpfq5z9A=\n=2jFR\n-----END PGP SIGNATURE-----\n", "payload": "tree 62e41fa45dc8a1f4252d34e970975e9a9279b5a8\nparent c4b34eebefc79d01d75efea0f5159b22a35891cf\nparent 60d55671602fcff089a7b9199608a1b397877836\nauthor Dylan DPC <dylan.dpc@gmail.com> 1608515270 +0100\ncommitter GitHub <noreply@github.com> 1608515270 +0100\n\nRollup merge of #80244 - jyn514:spans, r=bugadani\n\nCleanup markdown span handling\n\n1. Get rid of `locate()` in markdown handling\n\nThis function was unfortunate for several reasons:\n\n- It used `unsafe` because it wanted to tell whether a string came from\n  the same *allocation* as another, not just whether it was a textual match.\n- It recalculated spans even though they were already available from pulldown\n- It sometimes *failed* to calculate the span, which meant it was always possible for the span to be `None`, even though in practice that should never happen.\n\nThis has several cleanups:\n\n- Make the span required\n- Pass through the span from pulldown in the `HeadingLinks` and `Footnotes` iterators\n- Only add iterator bounds on the `impl Iterator`, not on `new` and the struct itself.\n\n2. Remove unnecessary scope in `markdown_links`\n\nI recommend reading a single commit at a time.\n\ncc ``@bugadani`` - this will conflict with https://github.com/rust-lang/rust/pull/77859, I'll try to make sure that gets merged first.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/823210901d1664dee1e78e2b37b95488341c5075", "html_url": "https://github.com/rust-lang/rust/commit/823210901d1664dee1e78e2b37b95488341c5075", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/823210901d1664dee1e78e2b37b95488341c5075/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4b34eebefc79d01d75efea0f5159b22a35891cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4b34eebefc79d01d75efea0f5159b22a35891cf", "html_url": "https://github.com/rust-lang/rust/commit/c4b34eebefc79d01d75efea0f5159b22a35891cf"}, {"sha": "60d55671602fcff089a7b9199608a1b397877836", "url": "https://api.github.com/repos/rust-lang/rust/commits/60d55671602fcff089a7b9199608a1b397877836", "html_url": "https://github.com/rust-lang/rust/commit/60d55671602fcff089a7b9199608a1b397877836"}], "stats": {"total": 197, "additions": 94, "deletions": 103}, "files": [{"sha": "0e87dd72ef1f2035990215ea645f77f2877905a5", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 66, "deletions": 69, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/823210901d1664dee1e78e2b37b95488341c5075/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823210901d1664dee1e78e2b37b95488341c5075/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=823210901d1664dee1e78e2b37b95488341c5075", "patch": "@@ -447,61 +447,61 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, I> {\n }\n \n /// Make headings links with anchor IDs and build up TOC.\n-struct HeadingLinks<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> {\n+struct HeadingLinks<'a, 'b, 'ids, I> {\n     inner: I,\n     toc: Option<&'b mut TocBuilder>,\n-    buf: VecDeque<Event<'a>>,\n+    buf: VecDeque<(Event<'a>, Range<usize>)>,\n     id_map: &'ids mut IdMap,\n }\n \n-impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> HeadingLinks<'a, 'b, 'ids, I> {\n+impl<'a, 'b, 'ids, I> HeadingLinks<'a, 'b, 'ids, I> {\n     fn new(iter: I, toc: Option<&'b mut TocBuilder>, ids: &'ids mut IdMap) -> Self {\n         HeadingLinks { inner: iter, toc, buf: VecDeque::new(), id_map: ids }\n     }\n }\n \n-impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a, 'b, 'ids, I> {\n-    type Item = Event<'a>;\n+impl<'a, 'b, 'ids, I: Iterator<Item = (Event<'a>, Range<usize>)>> Iterator\n+    for HeadingLinks<'a, 'b, 'ids, I>\n+{\n+    type Item = (Event<'a>, Range<usize>);\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if let Some(e) = self.buf.pop_front() {\n             return Some(e);\n         }\n \n         let event = self.inner.next();\n-        if let Some(Event::Start(Tag::Heading(level))) = event {\n+        if let Some((Event::Start(Tag::Heading(level)), _)) = event {\n             let mut id = String::new();\n             for event in &mut self.inner {\n-                match &event {\n+                match &event.0 {\n                     Event::End(Tag::Heading(..)) => break,\n+                    Event::Start(Tag::Link(_, _, _)) | Event::End(Tag::Link(..)) => {}\n                     Event::Text(text) | Event::Code(text) => {\n                         id.extend(text.chars().filter_map(slugify));\n+                        self.buf.push_back(event);\n                     }\n-                    _ => {}\n-                }\n-                match event {\n-                    Event::Start(Tag::Link(_, _, _)) | Event::End(Tag::Link(..)) => {}\n-                    event => self.buf.push_back(event),\n+                    _ => self.buf.push_back(event),\n                 }\n             }\n             let id = self.id_map.derive(id);\n \n             if let Some(ref mut builder) = self.toc {\n                 let mut html_header = String::new();\n-                html::push_html(&mut html_header, self.buf.iter().cloned());\n+                html::push_html(&mut html_header, self.buf.iter().map(|(ev, _)| ev.clone()));\n                 let sec = builder.push(level as u32, html_header, id.clone());\n-                self.buf.push_front(Event::Html(format!(\"{} \", sec).into()));\n+                self.buf.push_front((Event::Html(format!(\"{} \", sec).into()), 0..0));\n             }\n \n-            self.buf.push_back(Event::Html(format!(\"</a></h{}>\", level).into()));\n+            self.buf.push_back((Event::Html(format!(\"</a></h{}>\", level).into()), 0..0));\n \n             let start_tags = format!(\n                 \"<h{level} id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n                     <a href=\\\"#{id}\\\">\",\n                 id = id,\n                 level = level\n             );\n-            return Some(Event::Html(start_tags.into()));\n+            return Some((Event::Html(start_tags.into()), 0..0));\n         }\n         event\n     }\n@@ -575,39 +575,40 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for SummaryLine<'a, I> {\n \n /// Moves all footnote definitions to the end and add back links to the\n /// references.\n-struct Footnotes<'a, I: Iterator<Item = Event<'a>>> {\n+struct Footnotes<'a, I> {\n     inner: I,\n     footnotes: FxHashMap<String, (Vec<Event<'a>>, u16)>,\n }\n \n-impl<'a, I: Iterator<Item = Event<'a>>> Footnotes<'a, I> {\n+impl<'a, I> Footnotes<'a, I> {\n     fn new(iter: I) -> Self {\n         Footnotes { inner: iter, footnotes: FxHashMap::default() }\n     }\n+\n     fn get_entry(&mut self, key: &str) -> &mut (Vec<Event<'a>>, u16) {\n         let new_id = self.footnotes.keys().count() + 1;\n         let key = key.to_owned();\n         self.footnotes.entry(key).or_insert((Vec::new(), new_id as u16))\n     }\n }\n \n-impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n-    type Item = Event<'a>;\n+impl<'a, I: Iterator<Item = (Event<'a>, Range<usize>)>> Iterator for Footnotes<'a, I> {\n+    type Item = (Event<'a>, Range<usize>);\n \n     fn next(&mut self) -> Option<Self::Item> {\n         loop {\n             match self.inner.next() {\n-                Some(Event::FootnoteReference(ref reference)) => {\n+                Some((Event::FootnoteReference(ref reference), range)) => {\n                     let entry = self.get_entry(&reference);\n                     let reference = format!(\n                         \"<sup id=\\\"fnref{0}\\\"><a href=\\\"#fn{0}\\\">{0}</a></sup>\",\n                         (*entry).1\n                     );\n-                    return Some(Event::Html(reference.into()));\n+                    return Some((Event::Html(reference.into()), range));\n                 }\n-                Some(Event::Start(Tag::FootnoteDefinition(def))) => {\n+                Some((Event::Start(Tag::FootnoteDefinition(def)), _)) => {\n                     let mut content = Vec::new();\n-                    for event in &mut self.inner {\n+                    for (event, _) in &mut self.inner {\n                         if let Event::End(Tag::FootnoteDefinition(..)) = event {\n                             break;\n                         }\n@@ -638,7 +639,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n                             ret.push_str(\"</li>\");\n                         }\n                         ret.push_str(\"</ol></div>\");\n-                        return Some(Event::Html(ret.into()));\n+                        return Some((Event::Html(ret.into()), 0..0));\n                     } else {\n                         return None;\n                     }\n@@ -946,13 +947,14 @@ impl Markdown<'_> {\n         };\n \n         let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut replacer));\n+        let p = p.into_offset_iter();\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let p = HeadingLinks::new(p, None, &mut ids);\n-        let p = LinkReplacer::new(p, links);\n-        let p = CodeBlocks::new(p, codes, edition, playground);\n         let p = Footnotes::new(p);\n+        let p = LinkReplacer::new(p.map(|(ev, _)| ev), links);\n+        let p = CodeBlocks::new(p, codes, edition, playground);\n         html::push_html(&mut s, p);\n \n         s\n@@ -963,16 +965,16 @@ impl MarkdownWithToc<'_> {\n     crate fn into_string(self) -> String {\n         let MarkdownWithToc(md, mut ids, codes, edition, playground) = self;\n \n-        let p = Parser::new_ext(md, opts());\n+        let p = Parser::new_ext(md, opts()).into_offset_iter();\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let mut toc = TocBuilder::new();\n \n         {\n             let p = HeadingLinks::new(p, Some(&mut toc), &mut ids);\n-            let p = CodeBlocks::new(p, codes, edition, playground);\n             let p = Footnotes::new(p);\n+            let p = CodeBlocks::new(p.map(|(ev, _)| ev), codes, edition, playground);\n             html::push_html(&mut s, p);\n         }\n \n@@ -988,19 +990,19 @@ impl MarkdownHtml<'_> {\n         if md.is_empty() {\n             return String::new();\n         }\n-        let p = Parser::new_ext(md, opts());\n+        let p = Parser::new_ext(md, opts()).into_offset_iter();\n \n         // Treat inline HTML as plain text.\n-        let p = p.map(|event| match event {\n-            Event::Html(text) => Event::Text(text),\n+        let p = p.map(|event| match event.0 {\n+            Event::Html(text) => (Event::Text(text), event.1),\n             _ => event,\n         });\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let p = HeadingLinks::new(p, None, &mut ids);\n-        let p = CodeBlocks::new(p, codes, edition, playground);\n         let p = Footnotes::new(p);\n+        let p = CodeBlocks::new(p.map(|(ev, _)| ev), codes, edition, playground);\n         html::push_html(&mut s, p);\n \n         s\n@@ -1153,50 +1155,45 @@ crate fn plain_text_summary(md: &str) -> String {\n     s\n }\n \n-crate fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n+crate fn markdown_links(md: &str) -> Vec<(String, Range<usize>)> {\n     if md.is_empty() {\n         return vec![];\n     }\n \n     let mut links = vec![];\n+    // Used to avoid mutable borrow issues in the `push` closure\n+    // Probably it would be more efficient to use a `RefCell` but it doesn't seem worth the churn.\n     let mut shortcut_links = vec![];\n \n-    {\n-        let locate = |s: &str| unsafe {\n-            let s_start = s.as_ptr();\n-            let s_end = s_start.add(s.len());\n-            let md_start = md.as_ptr();\n-            let md_end = md_start.add(md.len());\n-            if md_start <= s_start && s_end <= md_end {\n-                let start = s_start.offset_from(md_start) as usize;\n-                let end = s_end.offset_from(md_start) as usize;\n-                Some(start..end)\n-            } else {\n-                None\n-            }\n-        };\n-\n-        let mut push = |link: BrokenLink<'_>| {\n-            // FIXME: use `link.span` instead of `locate`\n-            // (doing it now includes the `[]` as well as the text)\n-            shortcut_links.push((link.reference.to_owned(), locate(link.reference)));\n-            None\n-        };\n-        let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut push));\n-\n-        // There's no need to thread an IdMap through to here because\n-        // the IDs generated aren't going to be emitted anywhere.\n-        let mut ids = IdMap::new();\n-        let iter = Footnotes::new(HeadingLinks::new(p, None, &mut ids));\n-\n-        for ev in iter {\n-            if let Event::Start(Tag::Link(_, dest, _)) = ev {\n-                debug!(\"found link: {}\", dest);\n-                links.push(match dest {\n-                    CowStr::Borrowed(s) => (s.to_owned(), locate(s)),\n-                    s @ (CowStr::Boxed(..) | CowStr::Inlined(..)) => (s.into_string(), None),\n-                });\n+    let span_for_link = |link: &str, span: Range<usize>| {\n+        // Pulldown includes the `[]` as well as the URL. Only highlight the relevant span.\n+        // NOTE: uses `rfind` in case the title and url are the same: `[Ok][Ok]`\n+        match md[span.clone()].rfind(link) {\n+            Some(start) => {\n+                let start = span.start + start;\n+                start..start + link.len()\n             }\n+            // This can happen for things other than intra-doc links, like `#1` expanded to `https://github.com/rust-lang/rust/issues/1`.\n+            None => span,\n+        }\n+    };\n+    let mut push = |link: BrokenLink<'_>| {\n+        let span = span_for_link(link.reference, link.span);\n+        shortcut_links.push((link.reference.to_owned(), span));\n+        None\n+    };\n+    let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut push));\n+\n+    // There's no need to thread an IdMap through to here because\n+    // the IDs generated aren't going to be emitted anywhere.\n+    let mut ids = IdMap::new();\n+    let iter = Footnotes::new(HeadingLinks::new(p.into_offset_iter(), None, &mut ids));\n+\n+    for ev in iter {\n+        if let Event::Start(Tag::Link(_, dest, _)) = ev.0 {\n+            debug!(\"found link: {}\", dest);\n+            let span = span_for_link(&dest, ev.1);\n+            links.push((dest.into_string(), span));\n         }\n     }\n "}, {"sha": "a8adfe08b2561168c42f00904cc7a5f5ba75b371", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/823210901d1664dee1e78e2b37b95488341c5075/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823210901d1664dee1e78e2b37b95488341c5075/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=823210901d1664dee1e78e2b37b95488341c5075", "patch": "@@ -180,7 +180,7 @@ struct DiagnosticInfo<'a> {\n     item: &'a Item,\n     dox: &'a str,\n     ori_link: &'a str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n }\n \n #[derive(Clone, Debug, Hash)]\n@@ -920,7 +920,7 @@ impl LinkCollector<'_, '_> {\n         parent_node: Option<DefId>,\n         krate: CrateNum,\n         ori_link: String,\n-        link_range: Option<Range<usize>>,\n+        link_range: Range<usize>,\n     ) -> Option<ItemLink> {\n         trace!(\"considering link '{}'\", ori_link);\n \n@@ -1566,7 +1566,7 @@ fn report_diagnostic(\n     msg: &str,\n     item: &Item,\n     dox: &str,\n-    link_range: &Option<Range<usize>>,\n+    link_range: &Range<usize>,\n     decorate: impl FnOnce(&mut DiagnosticBuilder<'_>, Option<rustc_span::Span>),\n ) {\n     let hir_id = match cx.as_local_hir_id(item.def_id) {\n@@ -1584,31 +1584,26 @@ fn report_diagnostic(\n     cx.tcx.struct_span_lint_hir(lint, hir_id, sp, |lint| {\n         let mut diag = lint.build(msg);\n \n-        let span = link_range\n-            .as_ref()\n-            .and_then(|range| super::source_span_for_markdown_range(cx, dox, range, attrs));\n-\n-        if let Some(link_range) = link_range {\n-            if let Some(sp) = span {\n-                diag.set_span(sp);\n-            } else {\n-                // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n-                //                       ^     ~~~~\n-                //                       |     link_range\n-                //                       last_new_line_offset\n-                let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n-                let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n-\n-                // Print the line containing the `link_range` and manually mark it with '^'s.\n-                diag.note(&format!(\n-                    \"the link appears in this line:\\n\\n{line}\\n\\\n-                     {indicator: <before$}{indicator:^<found$}\",\n-                    line = line,\n-                    indicator = \"\",\n-                    before = link_range.start - last_new_line_offset,\n-                    found = link_range.len(),\n-                ));\n-            }\n+        let span = super::source_span_for_markdown_range(cx, dox, link_range, attrs);\n+        if let Some(sp) = span {\n+            diag.set_span(sp);\n+        } else {\n+            // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n+            //                       ^     ~~~~\n+            //                       |     link_range\n+            //                       last_new_line_offset\n+            let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n+            let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n+\n+            // Print the line containing the `link_range` and manually mark it with '^'s.\n+            diag.note(&format!(\n+                \"the link appears in this line:\\n\\n{line}\\n\\\n+                    {indicator: <before$}{indicator:^<found$}\",\n+                line = line,\n+                indicator = \"\",\n+                before = link_range.start - last_new_line_offset,\n+                found = link_range.len(),\n+            ));\n         }\n \n         decorate(&mut diag, span);\n@@ -1628,7 +1623,7 @@ fn resolution_failure(\n     path_str: &str,\n     disambiguator: Option<Disambiguator>,\n     dox: &str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n     kinds: SmallVec<[ResolutionFailure<'_>; 3]>,\n ) {\n     report_diagnostic(\n@@ -1862,7 +1857,7 @@ fn anchor_failure(\n     item: &Item,\n     path_str: &str,\n     dox: &str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n     failure: AnchorFailure,\n ) {\n     let msg = match failure {\n@@ -1887,7 +1882,7 @@ fn ambiguity_error(\n     item: &Item,\n     path_str: &str,\n     dox: &str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n     candidates: Vec<Res>,\n ) {\n     let mut msg = format!(\"`{}` is \", path_str);\n@@ -1936,13 +1931,12 @@ fn suggest_disambiguator(\n     path_str: &str,\n     dox: &str,\n     sp: Option<rustc_span::Span>,\n-    link_range: &Option<Range<usize>>,\n+    link_range: &Range<usize>,\n ) {\n     let suggestion = disambiguator.suggestion();\n     let help = format!(\"to link to the {}, {}\", disambiguator.descr(), suggestion.descr());\n \n     if let Some(sp) = sp {\n-        let link_range = link_range.as_ref().expect(\"must have a link range if we have a span\");\n         let msg = if dox.bytes().nth(link_range.start) == Some(b'`') {\n             format!(\"`{}`\", suggestion.as_help(path_str))\n         } else {\n@@ -1961,7 +1955,7 @@ fn privacy_error(\n     item: &Item,\n     path_str: &str,\n     dox: &str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n ) {\n     let sym;\n     let item_name = match item.name {"}]}