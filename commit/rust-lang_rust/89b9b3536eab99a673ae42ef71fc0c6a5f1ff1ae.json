{"sha": "89b9b3536eab99a673ae42ef71fc0c6a5f1ff1ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5YjliMzUzNmVhYjk5YTY3M2FlNDJlZjcxZmMwYzZhNWYxZmYxYWU=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-09-20T01:40:56Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-09-22T05:14:31Z"}, "message": "Remove more eval_operand_to_ptr.", "tree": {"sha": "5e08f24ebb1070fc324ea12b9402a954db770fce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e08f24ebb1070fc324ea12b9402a954db770fce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89b9b3536eab99a673ae42ef71fc0c6a5f1ff1ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89b9b3536eab99a673ae42ef71fc0c6a5f1ff1ae", "html_url": "https://github.com/rust-lang/rust/commit/89b9b3536eab99a673ae42ef71fc0c6a5f1ff1ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89b9b3536eab99a673ae42ef71fc0c6a5f1ff1ae/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5e44712a454dd19bfde00c6cce109ee3f664f8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5e44712a454dd19bfde00c6cce109ee3f664f8e", "html_url": "https://github.com/rust-lang/rust/commit/d5e44712a454dd19bfde00c6cce109ee3f664f8e"}], "stats": {"total": 114, "additions": 65, "deletions": 49}, "files": [{"sha": "f7d6b464cda3caf5835aecc39db340699fbbe94c", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/89b9b3536eab99a673ae42ef71fc0c6a5f1ff1ae/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b9b3536eab99a673ae42ef71fc0c6a5f1ff1ae/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=89b9b3536eab99a673ae42ef71fc0c6a5f1ff1ae", "patch": "@@ -779,31 +779,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     // remove it as soon as PrimVal can represent fat pointers.\n     fn eval_operand_to_ptr(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Pointer> {\n         let value = self.eval_operand(op)?;\n-        match value {\n-            Value::ByRef(ptr) => Ok(ptr),\n-\n-            Value::ByVal(primval) => {\n-                let ty = self.operand_ty(op);\n-                let size = self.type_size(ty);\n-                let align = self.type_align(ty);\n-                let ptr = self.memory.allocate(size, align)?;\n-                self.memory.write_primval(ptr, primval)?;\n-                Ok(ptr)\n-            }\n-\n-            Value::ByValPair(primval1, primval2) => {\n-                let ty = self.operand_ty(op);\n-                let size = self.type_size(ty);\n-                let align = self.type_align(ty);\n-                let ptr = self.memory.allocate(size, align)?;\n-\n-                // FIXME(solson): Major dangerous assumptions here. Ideally obliterate this\n-                // function.\n-                self.memory.write_primval(ptr, primval1)?;\n-                self.memory.write_primval(ptr.offset((size / 2) as isize), primval2)?;\n-                Ok(ptr)\n-            }\n-        }\n+        let ty = self.operand_ty(op);\n+        self.value_to_ptr(value, ty)\n     }\n \n     fn eval_operand_to_primval(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, PrimVal> {\n@@ -980,6 +957,34 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n+    // FIXME(solson): This method unnecessarily allocates and should not be necessary. We can\n+    // remove it as soon as PrimVal can represent fat pointers.\n+    fn value_to_ptr(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Pointer> {\n+        match value {\n+            Value::ByRef(ptr) => Ok(ptr),\n+\n+            Value::ByVal(primval) => {\n+                let size = self.type_size(ty);\n+                let align = self.type_align(ty);\n+                let ptr = self.memory.allocate(size, align)?;\n+                self.memory.write_primval(ptr, primval)?;\n+                Ok(ptr)\n+            }\n+\n+            Value::ByValPair(primval1, primval2) => {\n+                let size = self.type_size(ty);\n+                let align = self.type_align(ty);\n+                let ptr = self.memory.allocate(size, align)?;\n+\n+                // FIXME(solson): Major dangerous assumptions here. Ideally obliterate this\n+                // function.\n+                self.memory.write_primval(ptr, primval1)?;\n+                self.memory.write_primval(ptr.offset((size / 2) as isize), primval2)?;\n+                Ok(ptr)\n+            }\n+        }\n+    }\n+\n     fn value_to_primval(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         match value {\n             Value::ByRef(ptr) => self.read_primval(ptr, ty),"}, {"sha": "b8d46323bfa87aabe8a77ee54aa2593ade56a96d", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/89b9b3536eab99a673ae42ef71fc0c6a5f1ff1ae/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b9b3536eab99a673ae42ef71fc0c6a5f1ff1ae/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=89b9b3536eab99a673ae42ef71fc0c6a5f1ff1ae", "patch": "@@ -13,7 +13,8 @@ use syntax::{ast, attr};\n \n use error::{EvalError, EvalResult};\n use memory::Pointer;\n-use super::{EvalContext, IntegerExt, StackPopCleanup};\n+use primval::PrimVal;\n+use super::{EvalContext, IntegerExt, StackPopCleanup, Value};\n \n mod intrinsics;\n \n@@ -154,7 +155,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         substs: &'tcx Substs<'tcx>,\n         fn_ty: &'tcx BareFnTy,\n         destination: Option<(Pointer, mir::BasicBlock)>,\n-        args: &[mir::Operand<'tcx>],\n+        arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n     ) -> EvalResult<'tcx, ()> {\n         use syntax::abi::Abi;\n@@ -163,7 +164,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty = fn_ty.sig.0.output;\n                 let layout = self.type_layout(ty);\n                 let (ret, target) = destination.unwrap();\n-                self.call_intrinsic(def_id, substs, args, ret, layout)?;\n+                self.call_intrinsic(def_id, substs, arg_operands, ret, layout)?;\n                 self.goto_block(target);\n                 Ok(())\n             }\n@@ -172,23 +173,23 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty = fn_ty.sig.0.output;\n                 let size = self.type_size(ty);\n                 let (ret, target) = destination.unwrap();\n-                self.call_c_abi(def_id, args, ret, size)?;\n+                self.call_c_abi(def_id, arg_operands, ret, size)?;\n                 self.goto_block(target);\n                 Ok(())\n             }\n \n             Abi::Rust | Abi::RustCall => {\n-                let mut arg_srcs = Vec::new();\n-                for arg in args {\n-                    let src = self.eval_operand_to_ptr(arg)?;\n-                    let src_ty = self.operand_ty(arg);\n-                    arg_srcs.push((src, src_ty));\n+                let mut args = Vec::new();\n+                for arg in arg_operands {\n+                    let arg_val = self.eval_operand(arg)?;\n+                    let arg_ty = self.operand_ty(arg);\n+                    args.push((arg_val, arg_ty));\n                 }\n \n                 // Only trait methods can have a Self parameter.\n                 let (resolved_def_id, resolved_substs) =\n                     if let Some(trait_id) = self.tcx.trait_of_item(def_id) {\n-                        self.trait_method(trait_id, def_id, substs, &mut arg_srcs)?\n+                        self.trait_method(trait_id, def_id, substs, &mut args)?\n                     } else {\n                         (def_id, substs)\n                     };\n@@ -200,9 +201,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 self.push_stack_frame(resolved_def_id, span, mir, resolved_substs, return_ptr, return_to_block)?;\n \n-                for (i, (src, src_ty)) in arg_srcs.into_iter().enumerate() {\n+                for (i, (arg_val, arg_ty)) in args.into_iter().enumerate() {\n                     let dest = self.frame().locals[i];\n-                    self.move_(src, dest, src_ty)?;\n+                    self.write_value(arg_val, dest, arg_ty)?;\n                 }\n \n                 Ok(())\n@@ -344,7 +345,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         })\n     }\n \n-    fn unpack_fn_args(&self, args: &mut Vec<(Pointer, Ty<'tcx>)>) {\n+    fn unpack_fn_args(&self, args: &mut Vec<(Value, Ty<'tcx>)>) {\n         if let Some((last, last_ty)) = args.pop() {\n             let last_layout = self.type_layout(last_ty);\n             match (&last_ty.sty, last_layout) {\n@@ -353,9 +354,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let offsets = iter::once(0)\n                         .chain(variant.offset_after_field.iter()\n                             .map(|s| s.bytes()));\n+                    let last_ptr = match last {\n+                        Value::ByRef(ptr) => ptr,\n+                        _ => bug!(\"rust-call ABI tuple argument wasn't Value::ByRef\"),\n+                    };\n                     for (offset, ty) in offsets.zip(fields) {\n-                        let src = last.offset(offset as isize);\n-                        args.push((src, ty));\n+                        let arg = Value::ByRef(last_ptr.offset(offset as isize));\n+                        args.push((arg, ty));\n                     }\n                 }\n                 ty => bug!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),\n@@ -369,7 +374,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         trait_id: DefId,\n         def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n-        args: &mut Vec<(Pointer, Ty<'tcx>)>,\n+        args: &mut Vec<(Value, Ty<'tcx>)>,\n     ) -> EvalResult<'tcx, (DefId, &'tcx Substs<'tcx>)> {\n         let trait_ref = ty::TraitRef::from_method(self.tcx, trait_id, substs);\n         let trait_ref = self.tcx.normalize_associated_type(&ty::Binder(trait_ref));\n@@ -398,6 +403,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n                     (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) |\n                     (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {} // No adapter needed.\n+\n                     (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n                     (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n                         // The closure fn is a `fn(&self, ...)` or `fn(&mut self, ...)`.\n@@ -409,13 +415,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         //\n                         // These are both the same at trans time.\n \n-                        // interpreter magic: insert an intermediate pointer, so we can skip the intermediate function call\n-                        // FIXME: this is a memory leak, should probably add the pointer to the current stack\n-                        let ptr_size = self.memory.pointer_size();\n-                        let first = self.memory.allocate(ptr_size, ptr_size)?;\n-                        self.memory.copy(args[0].0, first, ptr_size, ptr_size)?;\n-                        self.memory.write_ptr(args[0].0, first)?;\n+                        // Interpreter magic: insert an intermediate pointer, so we can skip the\n+                        // intermediate function call.\n+                        // FIXME: this is a memory leak, should probably add the pointer to the\n+                        // current stack.\n+                        let first = self.value_to_ptr(args[0].0, args[0].1)?;\n+                        args[0].0 = Value::ByVal(PrimVal::AbstractPtr(first));\n+                        args[0].1 = self.tcx.mk_mut_ptr(args[0].1);\n                     }\n+\n                     _ => bug!(\"cannot convert {:?} to {:?}\", closure_kind, trait_closure_kind),\n                 }\n                 Ok((vtable_closure.closure_def_id, vtable_closure.substs.func_substs))\n@@ -433,8 +441,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             traits::VtableObject(ref data) => {\n                 let idx = self.tcx.get_vtable_index_of_object_method(data, def_id);\n-                if let Some(&mut(first_arg, ref mut first_ty)) = args.get_mut(0) {\n-                    let (_, vtable) = self.get_fat_ptr(first_arg);\n+                if let Some(&mut(ref mut first_arg, ref mut first_ty)) = args.get_mut(0) {\n+                    // FIXME(solson): Remove this allocating hack.\n+                    let ptr = self.value_to_ptr(*first_arg, *first_ty)?;\n+                    *first_arg = Value::ByRef(ptr);\n+                    let (_, vtable) = self.get_fat_ptr(ptr);\n                     let vtable = self.memory.read_ptr(vtable)?;\n                     let idx = idx + 3;\n                     let offset = idx * self.memory.pointer_size();"}]}