{"sha": "6d15c6749c30d9077c6e12af3be64c5f68fafcff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkMTVjNjc0OWMzMGQ5MDc3YzZlMTJhZjNiZTY0YzVmNjhmYWZjZmY=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-05-24T23:16:10Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-06-09T21:29:29Z"}, "message": "Implement #[plugin_registrar]\n\nSee RFC 22.\n\n[breaking-change]", "tree": {"sha": "15a479a8e999df0149e8d58a9843f36635cab115", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15a479a8e999df0149e8d58a9843f36635cab115"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d15c6749c30d9077c6e12af3be64c5f68fafcff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d15c6749c30d9077c6e12af3be64c5f68fafcff", "html_url": "https://github.com/rust-lang/rust/commit/6d15c6749c30d9077c6e12af3be64c5f68fafcff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d15c6749c30d9077c6e12af3be64c5f68fafcff/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e55f64f99726a44283211d91a702081fe4a1855b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e55f64f99726a44283211d91a702081fe4a1855b", "html_url": "https://github.com/rust-lang/rust/commit/e55f64f99726a44283211d91a702081fe4a1855b"}], "stats": {"total": 567, "additions": 331, "deletions": 236}, "files": [{"sha": "45e9c7b562d0f1631b36f976bc0cd115bcfb12d1", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -18,12 +18,14 @@ use front;\n use lib::llvm::{ContextRef, ModuleRef};\n use metadata::common::LinkMeta;\n use metadata::creader;\n-use metadata::creader::Loader;\n use middle::cfg;\n use middle::cfg::graphviz::LabelledCFG;\n use middle::{trans, freevars, kind, ty, typeck, lint, reachable};\n use middle::dependency_format;\n use middle;\n+use plugin::load::Plugins;\n+use plugin::registry::Registry;\n+use plugin;\n use util::common::time;\n use util::ppaux;\n use util::nodemap::{NodeSet};\n@@ -39,7 +41,6 @@ use syntax::ast;\n use syntax::attr;\n use syntax::attr::{AttrMetaMethods};\n use syntax::crateid::CrateId;\n-use syntax::ext::base::CrateLoader;\n use syntax::parse;\n use syntax::parse::token;\n use syntax::print::{pp, pprust};\n@@ -75,11 +76,10 @@ pub fn compile_input(sess: Session,\n                                                  output,\n                                                  krate.attrs.as_slice(),\n                                                  &sess);\n-            let loader = &mut Loader::new(&sess);\n             let id = link::find_crate_id(krate.attrs.as_slice(),\n                                          outputs.out_filestem.as_slice());\n             let (expanded_crate, ast_map) =\n-                phase_2_configure_and_expand(&sess, loader, krate, &id);\n+                phase_2_configure_and_expand(&sess, krate, &id);\n             (outputs, expanded_crate, ast_map)\n         };\n         write_out_deps(&sess, input, &outputs, &expanded_crate);\n@@ -172,7 +172,6 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n /// harness if one is to be provided and injection of a dependency on the\n /// standard library and prelude.\n pub fn phase_2_configure_and_expand(sess: &Session,\n-                                    loader: &mut CrateLoader,\n                                     mut krate: ast::Crate,\n                                     crate_id: &CrateId)\n                                     -> (ast::Crate, syntax::ast_map::Map) {\n@@ -197,25 +196,42 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     krate = time(time_passes, \"configuration 1\", krate, |krate|\n                  front::config::strip_unconfigured_items(krate));\n \n-    krate = time(time_passes, \"expansion\", krate, |krate| {\n-        // Windows dlls do not have rpaths, so they don't know how to find their\n-        // dependencies. It's up to us to tell the system where to find all the\n-        // dependent dlls. Note that this uses cfg!(windows) as opposed to\n-        // targ_cfg because syntax extensions are always loaded for the host\n-        // compiler, not for the target.\n-        if cfg!(windows) {\n-            sess.host_filesearch().add_dylib_search_paths();\n+    let Plugins { macros, registrars }\n+        = time(time_passes, \"plugin loading\", (), |_|\n+               plugin::load::load_plugins(sess, &krate));\n+\n+    let mut registry = Registry::new(&krate);\n+\n+    time(time_passes, \"plugin registration\", (), |_| {\n+        for &registrar in registrars.iter() {\n+            registrar(&mut registry);\n         }\n-        let cfg = syntax::ext::expand::ExpansionConfig {\n-            loader: loader,\n-            deriving_hash_type_parameter: sess.features.default_type_params.get(),\n-            crate_id: crate_id.clone(),\n-        };\n-        syntax::ext::expand::expand_crate(&sess.parse_sess,\n-                                          cfg,\n-                                          krate)\n     });\n \n+    let Registry { syntax_exts, .. } = registry;\n+\n+    krate = time(time_passes, \"expansion\", (krate, macros, syntax_exts),\n+        |(krate, macros, syntax_exts)| {\n+            // Windows dlls do not have rpaths, so they don't know how to find their\n+            // dependencies. It's up to us to tell the system where to find all the\n+            // dependent dlls. Note that this uses cfg!(windows) as opposed to\n+            // targ_cfg because syntax extensions are always loaded for the host\n+            // compiler, not for the target.\n+            if cfg!(windows) {\n+                sess.host_filesearch().add_dylib_search_paths();\n+            }\n+            let cfg = syntax::ext::expand::ExpansionConfig {\n+                deriving_hash_type_parameter: sess.features.default_type_params.get(),\n+                crate_id: crate_id.clone(),\n+            };\n+            syntax::ext::expand::expand_crate(&sess.parse_sess,\n+                                              cfg,\n+                                              macros,\n+                                              syntax_exts,\n+                                              krate)\n+        }\n+    );\n+\n     // strip again, in case expansion added anything with a #[cfg].\n     krate = time(time_passes, \"configuration 2\", krate, |krate|\n                  front::config::strip_unconfigured_items(krate));\n@@ -281,9 +297,9 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     time(time_passes, \"looking for entry point\", (),\n          |_| middle::entry::find_entry_point(&sess, krate, &ast_map));\n \n-    sess.macro_registrar_fn.set(\n-        time(time_passes, \"looking for macro registrar\", (), |_|\n-            syntax::ext::registrar::find_macro_registrar(\n+    sess.plugin_registrar_fn.set(\n+        time(time_passes, \"looking for plugin registrar\", (), |_|\n+            plugin::build::find_plugin_registrar(\n                 sess.diagnostic(), krate)));\n \n     let freevars = time(time_passes, \"freevar finding\", (), |_|\n@@ -596,9 +612,7 @@ pub fn pretty_print_input(sess: Session,\n \n     let (krate, ast_map, is_expanded) = match ppm {\n         PpmExpanded | PpmExpandedIdentified | PpmTyped | PpmFlowGraph(_) => {\n-            let loader = &mut Loader::new(&sess);\n             let (krate, ast_map) = phase_2_configure_and_expand(&sess,\n-                                                                loader,\n                                                                 krate,\n                                                                 &id);\n             (krate, Some(ast_map), true)"}, {"sha": "773b9e6e0aac4022055e64b6cfea8afa95b38009", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -36,7 +36,7 @@ pub struct Session {\n     // For a library crate, this is always none\n     pub entry_fn: RefCell<Option<(NodeId, codemap::Span)>>,\n     pub entry_type: Cell<Option<config::EntryFnType>>,\n-    pub macro_registrar_fn: Cell<Option<ast::NodeId>>,\n+    pub plugin_registrar_fn: Cell<Option<ast::NodeId>>,\n     pub default_sysroot: Option<Path>,\n     // The name of the root source file of the crate, in the local file system. The path is always\n     // expected to be absolute. `None` means that there is no source file.\n@@ -232,7 +232,7 @@ pub fn build_session_(sopts: config::Options,\n         // For a library crate, this is always none\n         entry_fn: RefCell::new(None),\n         entry_type: Cell::new(None),\n-        macro_registrar_fn: Cell::new(None),\n+        plugin_registrar_fn: Cell::new(None),\n         default_sysroot: default_sysroot,\n         local_crate_source_file: local_crate_source_file,\n         working_dir: os::getcwd(),"}, {"sha": "11dd6a86cd811df749a1f9fdbd6538d6f4e113ac", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -46,7 +46,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"thread_local\", Active),\n     (\"link_args\", Active),\n     (\"phase\", Active),\n-    (\"macro_registrar\", Active),\n+    (\"plugin_registrar\", Active),\n     (\"log_syntax\", Active),\n     (\"trace_macros\", Active),\n     (\"concat_idents\", Active),\n@@ -192,10 +192,9 @@ impl<'a> Visitor<()> for Context<'a> {\n             }\n \n             ast::ItemFn(..) => {\n-                if attr::contains_name(i.attrs.as_slice(), \"macro_registrar\") {\n-                    self.gate_feature(\"macro_registrar\", i.span,\n-                                      \"cross-crate macro exports are \\\n-                                       experimental and possibly buggy\");\n+                if attr::contains_name(i.attrs.as_slice(), \"plugin_registrar\") {\n+                    self.gate_feature(\"plugin_registrar\", i.span,\n+                                      \"compiler plugins are experimental and possibly buggy\");\n                 }\n             }\n "}, {"sha": "0514f7de505ef59b6baedfc161a0c171f0b3255a", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -81,7 +81,7 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n                 attr::mk_attr_outer(attr::mk_attr_id(), attr::mk_list_item(\n                         InternedString::new(\"phase\"),\n                         vec!(\n-                            attr::mk_word_item(InternedString::new(\"syntax\")),\n+                            attr::mk_word_item(InternedString::new(\"plugin\")),\n                             attr::mk_word_item(InternedString::new(\"link\")\n                         ))))),\n             vis: ast::Inherited,"}, {"sha": "174bcc86d263a4f0f9c82fe18a0dcdc452e7a941", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -16,7 +16,6 @@\n use driver::session::Session;\n use front::config;\n use front::std_inject::with_version;\n-use metadata::creader::Loader;\n \n use std::cell::RefCell;\n use std::slice;\n@@ -150,12 +149,10 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n \n fn generate_test_harness(sess: &Session, krate: ast::Crate)\n                          -> ast::Crate {\n-    let loader = &mut Loader::new(sess);\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         ext_cx: ExtCtxt::new(&sess.parse_sess, sess.opts.cfg.clone(),\n                              ExpansionConfig {\n-                                 loader: loader,\n                                  deriving_hash_type_parameter: false,\n                                  crate_id: from_str(\"test\").unwrap(),\n                              }),"}, {"sha": "b82dace62efff15fe224cb9db8dbd55a9bc83775", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -109,6 +109,14 @@ pub mod metadata;\n \n pub mod driver;\n \n+pub mod plugin {\n+    pub use self::registry::Registry;\n+\n+    pub mod registry;\n+    pub mod load;\n+    pub mod build;\n+}\n+\n pub mod util {\n     pub mod common;\n     pub mod ppaux;"}, {"sha": "2ff656853c3bdbffb9617dbc56ef6bb320642452", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -198,7 +198,7 @@ pub static tag_native_libraries_lib: uint = 0x88;\n pub static tag_native_libraries_name: uint = 0x89;\n pub static tag_native_libraries_kind: uint = 0x8a;\n \n-pub static tag_macro_registrar_fn: uint = 0x8b;\n+pub static tag_plugin_registrar_fn: uint = 0x8b;\n pub static tag_exported_macros: uint = 0x8c;\n pub static tag_macro_def: uint = 0x8d;\n "}, {"sha": "4df21fbc974be7f20f78d5d57eab24c1ff7d19e6", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -21,6 +21,7 @@ use metadata::cstore::{CStore, CrateSource};\n use metadata::decoder;\n use metadata::loader;\n use metadata::loader::CratePaths;\n+use plugin::load::PluginMetadata;\n \n use std::rc::Rc;\n use std::collections::HashMap;\n@@ -30,7 +31,6 @@ use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{Span};\n use syntax::diagnostic::SpanHandler;\n-use syntax::ext::base::{CrateLoader, MacroCrate};\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::crateid::CrateId;\n@@ -379,23 +379,21 @@ fn resolve_crate_deps(e: &mut Env,\n     }).collect()\n }\n \n-pub struct Loader<'a> {\n+pub struct PluginMetadataReader<'a> {\n     env: Env<'a>,\n }\n \n-impl<'a> Loader<'a> {\n-    pub fn new(sess: &'a Session) -> Loader<'a> {\n-        Loader {\n+impl<'a> PluginMetadataReader<'a> {\n+    pub fn new(sess: &'a Session) -> PluginMetadataReader<'a> {\n+        PluginMetadataReader {\n             env: Env {\n                 sess: sess,\n                 next_crate_num: sess.cstore.next_crate_num(),\n             }\n         }\n     }\n-}\n \n-impl<'a> CrateLoader for Loader<'a> {\n-    fn load_crate(&mut self, krate: &ast::ViewItem) -> MacroCrate {\n+    pub fn read_plugin_metadata(&mut self, krate: &ast::ViewItem) -> PluginMetadata {\n         let info = extract_crate_info(&self.env, krate).unwrap();\n         let target_triple = self.env.sess.targ_cfg.target_strs.target_triple.as_slice();\n         let is_cross = target_triple != driver::host_triple();\n@@ -425,8 +423,8 @@ impl<'a> CrateLoader for Loader<'a> {\n                 load_ctxt.os = config::cfg_os_to_meta_os(self.env.sess.targ_cfg.os);\n                 load_ctxt.filesearch = self.env.sess.target_filesearch();\n                 let lib = load_ctxt.load_library_crate();\n-                if decoder::get_macro_registrar_fn(lib.metadata.as_slice()).is_some() {\n-                    let message = format!(\"crate `{}` contains a macro_registrar fn but \\\n+                if decoder::get_plugin_registrar_fn(lib.metadata.as_slice()).is_some() {\n+                    let message = format!(\"crate `{}` contains a plugin_registrar fn but \\\n                                   only a version for triple `{}` could be found (need {})\",\n                                   info.ident, target_triple, driver::host_triple());\n                     self.env.sess.span_err(krate.span, message.as_slice());\n@@ -441,10 +439,10 @@ impl<'a> CrateLoader for Loader<'a> {\n             None => { load_ctxt.report_load_errs(); unreachable!() },\n         };\n         let macros = decoder::get_exported_macros(library.metadata.as_slice());\n-        let registrar = decoder::get_macro_registrar_fn(library.metadata.as_slice()).map(|id| {\n+        let registrar = decoder::get_plugin_registrar_fn(library.metadata.as_slice()).map(|id| {\n             decoder::get_symbol(library.metadata.as_slice(), id).to_string()\n         });\n-        let mc = MacroCrate {\n+        let pc = PluginMetadata {\n             lib: library.dylib.clone(),\n             macros: macros.move_iter().map(|x| x.to_string()).collect(),\n             registrar_symbol: registrar,\n@@ -454,6 +452,6 @@ impl<'a> CrateLoader for Loader<'a> {\n             register_crate(&mut self.env, &None, info.ident.as_slice(),\n                            &info.crate_id, krate.span, library);\n         }\n-        mc\n+        pc\n     }\n }"}, {"sha": "846f879104f64f7ba559e62815d7b025d65b024e", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -139,9 +139,6 @@ impl CStore {\n             .map(|source| source.clone())\n     }\n \n-    pub fn dump_phase_syntax_crates(&self) {\n-    }\n-\n     pub fn reset(&self) {\n         self.metas.borrow_mut().clear();\n         self.extern_mod_crate_map.borrow_mut().clear();"}, {"sha": "8a2c3c08d419ae8b1c319366173901758b1332d7", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -1255,8 +1255,8 @@ pub fn get_native_libraries(cdata: Cmd)\n     return result;\n }\n \n-pub fn get_macro_registrar_fn(data: &[u8]) -> Option<ast::NodeId> {\n-    reader::maybe_get_doc(ebml::Doc::new(data), tag_macro_registrar_fn)\n+pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<ast::NodeId> {\n+    reader::maybe_get_doc(ebml::Doc::new(data), tag_plugin_registrar_fn)\n         .map(|doc| FromPrimitive::from_u32(reader::doc_as_u32(doc)).unwrap())\n }\n "}, {"sha": "1846c9c881bc570fd3611dc83bf8c33629d3fd93", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -1582,9 +1582,9 @@ fn encode_native_libraries(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n     ebml_w.end_tag();\n }\n \n-fn encode_macro_registrar_fn(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n-    match ecx.tcx.sess.macro_registrar_fn.get() {\n-        Some(id) => { ebml_w.wr_tagged_u32(tag_macro_registrar_fn, id); }\n+fn encode_plugin_registrar_fn(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n+    match ecx.tcx.sess.plugin_registrar_fn.get() {\n+        Some(id) => { ebml_w.wr_tagged_u32(tag_plugin_registrar_fn, id); }\n         None => {}\n     }\n }\n@@ -1791,7 +1791,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n         dep_bytes: u64,\n         lang_item_bytes: u64,\n         native_lib_bytes: u64,\n-        macro_registrar_fn_bytes: u64,\n+        plugin_registrar_fn_bytes: u64,\n         macro_defs_bytes: u64,\n         impl_bytes: u64,\n         misc_bytes: u64,\n@@ -1805,7 +1805,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n         dep_bytes: 0,\n         lang_item_bytes: 0,\n         native_lib_bytes: 0,\n-        macro_registrar_fn_bytes: 0,\n+        plugin_registrar_fn_bytes: 0,\n         macro_defs_bytes: 0,\n         impl_bytes: 0,\n         misc_bytes: 0,\n@@ -1870,10 +1870,10 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n     encode_native_libraries(&ecx, &mut ebml_w);\n     stats.native_lib_bytes = ebml_w.writer.tell().unwrap() - i;\n \n-    // Encode the macro registrar function\n+    // Encode the plugin registrar function\n     i = ebml_w.writer.tell().unwrap();\n-    encode_macro_registrar_fn(&ecx, &mut ebml_w);\n-    stats.macro_registrar_fn_bytes = ebml_w.writer.tell().unwrap() - i;\n+    encode_plugin_registrar_fn(&ecx, &mut ebml_w);\n+    stats.plugin_registrar_fn_bytes = ebml_w.writer.tell().unwrap() - i;\n \n     // Encode macro definitions\n     i = ebml_w.writer.tell().unwrap();\n@@ -1912,18 +1912,18 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n         }\n \n         println!(\"metadata stats:\");\n-        println!(\"      attribute bytes: {}\", stats.attr_bytes);\n-        println!(\"            dep bytes: {}\", stats.dep_bytes);\n-        println!(\"      lang item bytes: {}\", stats.lang_item_bytes);\n-        println!(\"         native bytes: {}\", stats.native_lib_bytes);\n-        println!(\"macro registrar bytes: {}\", stats.macro_registrar_fn_bytes);\n-        println!(\"      macro def bytes: {}\", stats.macro_defs_bytes);\n-        println!(\"           impl bytes: {}\", stats.impl_bytes);\n-        println!(\"           misc bytes: {}\", stats.misc_bytes);\n-        println!(\"           item bytes: {}\", stats.item_bytes);\n-        println!(\"          index bytes: {}\", stats.index_bytes);\n-        println!(\"           zero bytes: {}\", stats.zero_bytes);\n-        println!(\"          total bytes: {}\", stats.total_bytes);\n+        println!(\"       attribute bytes: {}\", stats.attr_bytes);\n+        println!(\"             dep bytes: {}\", stats.dep_bytes);\n+        println!(\"       lang item bytes: {}\", stats.lang_item_bytes);\n+        println!(\"          native bytes: {}\", stats.native_lib_bytes);\n+        println!(\"plugin registrar bytes: {}\", stats.plugin_registrar_fn_bytes);\n+        println!(\"       macro def bytes: {}\", stats.macro_defs_bytes);\n+        println!(\"            impl bytes: {}\", stats.impl_bytes);\n+        println!(\"            misc bytes: {}\", stats.misc_bytes);\n+        println!(\"            item bytes: {}\", stats.item_bytes);\n+        println!(\"           index bytes: {}\", stats.index_bytes);\n+        println!(\"            zero bytes: {}\", stats.zero_bytes);\n+        println!(\"           total bytes: {}\", stats.total_bytes);\n     }\n }\n "}, {"sha": "a27632882fc37c072b526f851727b149f39ca15b", "filename": "src/librustc/plugin/build.rs", "status": "renamed", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fplugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fplugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fbuild.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -8,23 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast;\n-use attr;\n-use codemap::Span;\n-use diagnostic;\n-use visit;\n-use visit::Visitor;\n+use syntax::ast;\n+use syntax::attr;\n+use syntax::codemap::Span;\n+use syntax::diagnostic;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n \n-struct MacroRegistrarContext {\n+struct RegistrarFinder {\n     registrars: Vec<(ast::NodeId, Span)> ,\n }\n \n-impl Visitor<()> for MacroRegistrarContext {\n+impl Visitor<()> for RegistrarFinder {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         match item.node {\n             ast::ItemFn(..) => {\n                 if attr::contains_name(item.attrs.as_slice(),\n-                                       \"macro_registrar\") {\n+                                       \"plugin_registrar\") {\n                     self.registrars.push((item.id, item.span));\n                 }\n             }\n@@ -35,20 +35,22 @@ impl Visitor<()> for MacroRegistrarContext {\n     }\n }\n \n-pub fn find_macro_registrar(diagnostic: &diagnostic::SpanHandler,\n-                            krate: &ast::Crate) -> Option<ast::NodeId> {\n-    let mut ctx = MacroRegistrarContext { registrars: Vec::new() };\n-    visit::walk_crate(&mut ctx, krate, ());\n+/// Find the function marked with `#[plugin_registrar]`, if any.\n+/// Used while compiling a crate which defines a registrar.\n+pub fn find_plugin_registrar(diagnostic: &diagnostic::SpanHandler,\n+                             krate: &ast::Crate) -> Option<ast::NodeId> {\n+    let mut finder = RegistrarFinder { registrars: Vec::new() };\n+    visit::walk_crate(&mut finder, krate, ());\n \n-    match ctx.registrars.len() {\n+    match finder.registrars.len() {\n         0 => None,\n         1 => {\n-            let (node_id, _) = ctx.registrars.pop().unwrap();\n+            let (node_id, _) = finder.registrars.pop().unwrap();\n             Some(node_id)\n         },\n         _ => {\n-            diagnostic.handler().err(\"multiple macro registration functions found\");\n-            for &(_, span) in ctx.registrars.iter() {\n+            diagnostic.handler().err(\"multiple plugin registration functions found\");\n+            for &(_, span) in finder.registrars.iter() {\n                 diagnostic.span_note(span, \"one is here\");\n             }\n             diagnostic.handler().abort_if_errors();", "previous_filename": "src/libsyntax/ext/registrar.rs"}, {"sha": "c80f8f96c4b2f8679e3ca0064df68f0dc2b076c4", "filename": "src/librustc/plugin/load.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -0,0 +1,131 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use plugin::registry::PluginRegistrarFun;\n+use driver::session::Session;\n+use metadata::creader::PluginMetadataReader;\n+\n+use std::mem;\n+use std::os;\n+use std::unstable::dynamic_lib::DynamicLibrary;\n+use syntax::ast;\n+use syntax::attr;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n+use syntax::ext::expand::ExportedMacros;\n+use syntax::attr::AttrMetaMethods;\n+\n+pub struct PluginMetadata {\n+    pub macros: Vec<String>,\n+    pub lib: Option<Path>,\n+    pub registrar_symbol: Option<String>,\n+}\n+\n+pub struct Plugins {\n+    pub macros: Vec<ExportedMacros>,\n+    pub registrars: Vec<PluginRegistrarFun>,\n+}\n+\n+struct PluginLoader<'a> {\n+    sess: &'a Session,\n+    reader: PluginMetadataReader<'a>,\n+    plugins: Plugins,\n+}\n+\n+impl<'a> PluginLoader<'a> {\n+    fn new(sess: &'a Session) -> PluginLoader<'a> {\n+        PluginLoader {\n+            sess: sess,\n+            reader: PluginMetadataReader::new(sess),\n+            plugins: Plugins {\n+                macros: vec!(),\n+                registrars: vec!(),\n+            },\n+        }\n+    }\n+}\n+\n+pub fn load_plugins(sess: &Session, krate: &ast::Crate) -> Plugins {\n+    let mut loader = PluginLoader::new(sess);\n+    visit::walk_crate(&mut loader, krate, ());\n+    loader.plugins\n+}\n+\n+impl<'a> Visitor<()> for PluginLoader<'a> {\n+    fn visit_view_item(&mut self, vi: &ast::ViewItem, _: ()) {\n+        match vi.node {\n+            ast::ViewItemExternCrate(name, _, _) => {\n+                let mut plugin_phase = false;\n+\n+                for attr in vi.attrs.iter().filter(|a| a.check_name(\"phase\")) {\n+                    let phases = attr.meta_item_list().unwrap_or(&[]);\n+                    if attr::contains_name(phases, \"plugin\") {\n+                        plugin_phase = true;\n+                    }\n+                    if attr::contains_name(phases, \"syntax\") {\n+                        plugin_phase = true;\n+                        self.sess.span_warn(attr.span,\n+                            \"phase(syntax) is a deprecated synonym for phase(plugin)\");\n+                    }\n+                }\n+\n+                if !plugin_phase { return; }\n+\n+                let PluginMetadata { macros, lib, registrar_symbol } =\n+                    self.reader.read_plugin_metadata(vi);\n+\n+                self.plugins.macros.push(ExportedMacros {\n+                    crate_name: name,\n+                    macros: macros,\n+                });\n+\n+                match (lib, registrar_symbol) {\n+                    (Some(lib), Some(symbol))\n+                        => self.dylink_registrar(vi, lib, symbol),\n+                    _ => (),\n+                }\n+            }\n+            _ => (),\n+        }\n+    }\n+}\n+\n+impl<'a> PluginLoader<'a> {\n+    // Dynamically link a registrar function into the compiler process.\n+    fn dylink_registrar(&mut self, vi: &ast::ViewItem, path: Path, symbol: String) {\n+        // Make sure the path contains a / or the linker will search for it.\n+        let path = os::make_absolute(&path);\n+\n+        let lib = match DynamicLibrary::open(Some(&path)) {\n+            Ok(lib) => lib,\n+            // this is fatal: there are almost certainly macros we need\n+            // inside this crate, so continue would spew \"macro undefined\"\n+            // errors\n+            Err(err) => self.sess.span_fatal(vi.span, err.as_slice())\n+        };\n+\n+        unsafe {\n+            let registrar: PluginRegistrarFun =\n+                match lib.symbol(symbol.as_slice()) {\n+                    Ok(registrar) => registrar,\n+                    // again fatal if we can't register macros\n+                    Err(err) => self.sess.span_fatal(vi.span, err.as_slice())\n+                };\n+\n+            self.plugins.registrars.push(registrar);\n+\n+            // Intentionally leak the dynamic library. We can't ever unload it\n+            // since the library can make things that will live arbitrarily long\n+            // (e.g. an @-box cycle or a task).\n+            mem::forget(lib);\n+\n+        }\n+    }\n+}"}, {"sha": "6402b116536015228a0dfe1f8dd464789df526ac", "filename": "src/librustc/plugin/registry.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fplugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustc%2Fplugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fregistry.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT};\n+use syntax::ext::base::{IdentTT, ItemDecorator, ItemModifier, BasicMacroExpander};\n+use syntax::ext::base::{MacroExpanderFn};\n+use syntax::codemap::Span;\n+use syntax::parse::token;\n+use syntax::ast;\n+\n+pub struct Registry {\n+    #[doc(hidden)]\n+    pub krate_span: Span,\n+\n+    #[doc(hidden)]\n+    pub syntax_exts: Vec<NamedSyntaxExtension>,\n+}\n+\n+pub type PluginRegistrarFun =\n+    fn(&mut Registry);\n+\n+impl Registry {\n+    #[doc(hidden)]\n+    pub fn new(krate: &ast::Crate) -> Registry {\n+        Registry {\n+            krate_span: krate.span,\n+            syntax_exts: vec!(),\n+        }\n+    }\n+\n+    pub fn register_syntax_extension(&mut self, name: ast::Name, extension: SyntaxExtension) {\n+        self.syntax_exts.push((name, match extension {\n+            NormalTT(ext, _) => NormalTT(ext, Some(self.krate_span)),\n+            IdentTT(ext, _) => IdentTT(ext, Some(self.krate_span)),\n+            ItemDecorator(ext) => ItemDecorator(ext),\n+            ItemModifier(ext) => ItemModifier(ext),\n+        }));\n+    }\n+\n+    pub fn register_macro(&mut self, name: &str, expander: MacroExpanderFn) {\n+        self.register_syntax_extension(\n+            token::intern(name),\n+            NormalTT(box BasicMacroExpander {\n+                expander: expander,\n+                span: None,\n+            }, None));\n+    }\n+}"}, {"sha": "f848c5224b7c8318552fb1f404e3d0000709ac6a", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -10,7 +10,6 @@\n \n use rustc;\n use rustc::{driver, middle};\n-use rustc::metadata::creader::Loader;\n use rustc::middle::privacy;\n use rustc::middle::lint;\n \n@@ -100,8 +99,8 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n     }\n \n     let krate = phase_1_parse_input(&sess, cfg, &input);\n-    let (krate, ast_map) = phase_2_configure_and_expand(&sess, &mut Loader::new(&sess),\n-                                                        krate, &from_str(\"rustdoc\").unwrap());\n+    let (krate, ast_map) = phase_2_configure_and_expand(&sess, krate,\n+                                                        &from_str(\"rustdoc\").unwrap());\n     let driver::driver::CrateAnalysis {\n         exported_items, public_items, ty_cx, ..\n     } = phase_3_run_analysis_passes(sess, &krate, ast_map);"}, {"sha": "3436305829791456662c98b6cc355ced2f88b37d", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -23,7 +23,6 @@ use rustc::back::link;\n use rustc::driver::config;\n use rustc::driver::driver;\n use rustc::driver::session;\n-use rustc::metadata::creader::Loader;\n use syntax::ast;\n use syntax::codemap::{CodeMap, dummy_spanned};\n use syntax::diagnostic;\n@@ -68,7 +67,7 @@ pub fn run(input: &str,\n         @dummy_spanned(ast::MetaWord(cfg_))\n     }));\n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n-    let (krate, _) = driver::phase_2_configure_and_expand(&sess, &mut Loader::new(&sess), krate,\n+    let (krate, _) = driver::phase_2_configure_and_expand(&sess, krate,\n                                                           &from_str(\"rustdoc-test\").unwrap());\n \n     let ctx = @core::DocContext {"}, {"sha": "e81421cff043deb894c9bf60bba926c1473565ae", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -95,9 +95,6 @@ impl IdentMacroExpander for BasicIdentMacroExpander {\n pub type IdentMacroExpanderFn =\n     fn(&mut ExtCtxt, Span, ast::Ident, Vec<ast::TokenTree>) -> Box<MacResult>;\n \n-pub type MacroCrateRegistrationFun =\n-    fn(|ast::Name, SyntaxExtension|);\n-\n /// The result of a macro expansion. The return values of the various\n /// methods are spliced into the AST at the callsite of the macro (or\n /// just into the compiler's internal macro table, for `make_def`).\n@@ -268,6 +265,8 @@ pub enum SyntaxExtension {\n     IdentTT(Box<IdentMacroExpander:'static>, Option<Span>),\n }\n \n+pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n+\n pub struct BlockInfo {\n     // should macros escape from this scope?\n     pub macros_escape: bool,\n@@ -392,32 +391,22 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n     syntax_expanders\n }\n \n-pub struct MacroCrate {\n-    pub lib: Option<Path>,\n-    pub macros: Vec<String>,\n-    pub registrar_symbol: Option<String>,\n-}\n-\n-pub trait CrateLoader {\n-    fn load_crate(&mut self, krate: &ast::ViewItem) -> MacroCrate;\n-}\n-\n // One of these is made during expansion and incrementally updated as we go;\n // when a macro expansion occurs, the resulting nodes have the backtrace()\n // -> expn_info of their expansion context stored into their span.\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n     pub cfg: ast::CrateConfig,\n     pub backtrace: Option<@ExpnInfo>,\n-    pub ecfg: expand::ExpansionConfig<'a>,\n+    pub ecfg: expand::ExpansionConfig,\n \n     pub mod_path: Vec<ast::Ident> ,\n     pub trace_mac: bool,\n }\n \n impl<'a> ExtCtxt<'a> {\n     pub fn new<'a>(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n-                   ecfg: expand::ExpansionConfig<'a>) -> ExtCtxt<'a> {\n+                   ecfg: expand::ExpansionConfig) -> ExtCtxt<'a> {\n         ExtCtxt {\n             parse_sess: parse_sess,\n             cfg: cfg,"}, {"sha": "bb335e7bed0cf9bf8b9dd91fbc470c59899bb113", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 30, "deletions": 122, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -29,10 +29,6 @@ use visit;\n use visit::Visitor;\n use util::small_vector::SmallVector;\n \n-use std::mem;\n-use std::os;\n-use std::unstable::dynamic_lib::DynamicLibrary;\n-\n pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n     match e.node {\n         // expr_mac should really be expr_ext or something; it's the\n@@ -497,96 +493,6 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n     return items;\n }\n \n-// load macros from syntax-phase crates\n-pub fn expand_view_item(vi: &ast::ViewItem,\n-                        fld: &mut MacroExpander)\n-                        -> ast::ViewItem {\n-    match vi.node {\n-        ast::ViewItemExternCrate(..) => {\n-            let should_load = vi.attrs.iter().any(|attr| {\n-                attr.check_name(\"phase\") &&\n-                    attr.meta_item_list().map_or(false, |phases| {\n-                        attr::contains_name(phases, \"syntax\")\n-                    })\n-            });\n-\n-            if should_load {\n-                load_extern_macros(vi, fld);\n-            }\n-        }\n-        ast::ViewItemUse(_) => {}\n-    }\n-\n-    noop_fold_view_item(vi, fld)\n-}\n-\n-fn load_extern_macros(krate: &ast::ViewItem, fld: &mut MacroExpander) {\n-    let MacroCrate { lib, macros, registrar_symbol } =\n-        fld.cx.ecfg.loader.load_crate(krate);\n-\n-    let crate_name = match krate.node {\n-        ast::ViewItemExternCrate(name, _, _) => name,\n-        _ => unreachable!()\n-    };\n-    let name = format!(\"<{} macros>\", token::get_ident(crate_name));\n-    let name = name.to_string();\n-\n-    for source in macros.iter() {\n-        let item = parse::parse_item_from_source_str(name.clone(),\n-                                                     (*source).clone(),\n-                                                     fld.cx.cfg(),\n-                                                     fld.cx.parse_sess())\n-                .expect(\"expected a serialized item\");\n-        expand_item_mac(item, fld);\n-    }\n-\n-    let path = match lib {\n-        Some(path) => path,\n-        None => return\n-    };\n-    // Make sure the path contains a / or the linker will search for it.\n-    let path = os::make_absolute(&path);\n-\n-    let registrar = match registrar_symbol {\n-        Some(registrar) => registrar,\n-        None => return\n-    };\n-\n-    debug!(\"load_extern_macros: mapped crate {} to path {} and registrar {:s}\",\n-           crate_name, path.display(), registrar);\n-\n-    let lib = match DynamicLibrary::open(Some(&path)) {\n-        Ok(lib) => lib,\n-        // this is fatal: there are almost certainly macros we need\n-        // inside this crate, so continue would spew \"macro undefined\"\n-        // errors\n-        Err(err) => fld.cx.span_fatal(krate.span, err.as_slice())\n-    };\n-\n-    unsafe {\n-        let registrar: MacroCrateRegistrationFun =\n-            match lib.symbol(registrar.as_slice()) {\n-                Ok(registrar) => registrar,\n-                // again fatal if we can't register macros\n-                Err(err) => fld.cx.span_fatal(krate.span, err.as_slice())\n-            };\n-        registrar(|name, extension| {\n-            let extension = match extension {\n-                NormalTT(ext, _) => NormalTT(ext, Some(krate.span)),\n-                IdentTT(ext, _) => IdentTT(ext, Some(krate.span)),\n-                ItemDecorator(ext) => ItemDecorator(ext),\n-                ItemModifier(ext) => ItemModifier(ext),\n-            };\n-            fld.extsbox.insert(name, extension);\n-        });\n-\n-        // Intentionally leak the dynamic library. We can't ever unload it\n-        // since the library can do things that will outlive the expansion\n-        // phase (e.g. make an @-box cycle or launch a task).\n-        mem::forget(lib);\n-    }\n-}\n-\n // expand a stmt\n pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n     // why the copying here and not in expand_expr?\n@@ -969,10 +875,6 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_item(item, self)\n     }\n \n-    fn fold_view_item(&mut self, vi: &ast::ViewItem) -> ast::ViewItem {\n-        expand_view_item(vi, self)\n-    }\n-\n     fn fold_stmt(&mut self, stmt: &ast::Stmt) -> SmallVector<@ast::Stmt> {\n         expand_stmt(stmt, self)\n     }\n@@ -986,21 +888,45 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     }\n }\n \n-pub struct ExpansionConfig<'a> {\n-    pub loader: &'a mut CrateLoader,\n+pub struct ExpansionConfig {\n     pub deriving_hash_type_parameter: bool,\n     pub crate_id: CrateId,\n }\n \n+pub struct ExportedMacros {\n+    pub crate_name: Ident,\n+    pub macros: Vec<String>,\n+}\n+\n pub fn expand_crate(parse_sess: &parse::ParseSess,\n                     cfg: ExpansionConfig,\n+                    macros: Vec<ExportedMacros>,\n+                    user_exts: Vec<NamedSyntaxExtension>,\n                     c: Crate) -> Crate {\n     let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg);\n     let mut expander = MacroExpander {\n         extsbox: syntax_expander_table(),\n         cx: &mut cx,\n     };\n \n+    for ExportedMacros { crate_name, macros } in macros.move_iter() {\n+        let name = format!(\"<{} macros>\", token::get_ident(crate_name))\n+            .into_string();\n+\n+        for source in macros.move_iter() {\n+            let item = parse::parse_item_from_source_str(name.clone(),\n+                                                         source,\n+                                                         expander.cx.cfg(),\n+                                                         expander.cx.parse_sess())\n+                    .expect(\"expected a serialized item\");\n+            expand_item_mac(item, &mut expander);\n+        }\n+    }\n+\n+    for (name, extension) in user_exts.move_iter() {\n+        expander.extsbox.insert(name, extension);\n+    }\n+\n     let ret = expander.fold_crate(c);\n     parse_sess.span_diagnostic.handler().abort_if_errors();\n     return ret;\n@@ -1093,7 +1019,6 @@ mod test {\n     use attr;\n     use codemap;\n     use codemap::Spanned;\n-    use ext::base::{CrateLoader, MacroCrate};\n     use ext::mtwt;\n     use parse;\n     use parse::token;\n@@ -1137,14 +1062,6 @@ mod test {\n         }\n     }\n \n-    struct ErrLoader;\n-\n-    impl CrateLoader for ErrLoader {\n-        fn load_crate(&mut self, _: &ast::ViewItem) -> MacroCrate {\n-            fail!(\"lolwut\")\n-        }\n-    }\n-\n     // these following tests are quite fragile, in that they don't test what\n     // *kind* of failure occurs.\n \n@@ -1159,13 +1076,11 @@ mod test {\n             src,\n             Vec::new(), &sess);\n         // should fail:\n-        let mut loader = ErrLoader;\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n-            loader: &mut loader,\n             deriving_hash_type_parameter: false,\n             crate_id: from_str(\"test\").unwrap(),\n         };\n-        expand_crate(&sess,cfg,crate_ast);\n+        expand_crate(&sess,cfg,vec!(),vec!(),crate_ast);\n     }\n \n     // make sure that macros can leave scope for modules\n@@ -1178,14 +1093,11 @@ mod test {\n             \"<test>\".to_string(),\n             src,\n             Vec::new(), &sess);\n-        // should fail:\n-        let mut loader = ErrLoader;\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n-            loader: &mut loader,\n             deriving_hash_type_parameter: false,\n             crate_id: from_str(\"test\").unwrap(),\n         };\n-        expand_crate(&sess,cfg,crate_ast);\n+        expand_crate(&sess,cfg,vec!(),vec!(),crate_ast);\n     }\n \n     // macro_escape modules shouldn't cause macros to leave scope\n@@ -1198,13 +1110,11 @@ mod test {\n             src,\n             Vec::new(), &sess);\n         // should fail:\n-        let mut loader = ErrLoader;\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n-            loader: &mut loader,\n             deriving_hash_type_parameter: false,\n             crate_id: from_str(\"test\").unwrap(),\n         };\n-        expand_crate(&sess, cfg, crate_ast);\n+        expand_crate(&sess, cfg, vec!(), vec!(), crate_ast);\n     }\n \n     #[test] fn test_contains_flatten (){\n@@ -1237,13 +1147,11 @@ mod test {\n         let ps = parse::new_parse_sess();\n         let crate_ast = string_to_parser(&ps, crate_str).parse_crate_mod();\n         // the cfg argument actually does matter, here...\n-        let mut loader = ErrLoader;\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n-            loader: &mut loader,\n             deriving_hash_type_parameter: false,\n             crate_id: from_str(\"test\").unwrap(),\n         };\n-        expand_crate(&ps,cfg,crate_ast)\n+        expand_crate(&ps,cfg,vec!(),vec!(),crate_ast)\n     }\n \n     //fn expand_and_resolve(crate_str: @str) -> ast::crate {"}, {"sha": "7fe67ad6f87baeab8c3513d53c5bb9897acc012e", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d15c6749c30d9077c6e12af3be64c5f68fafcff/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=6d15c6749c30d9077c6e12af3be64c5f68fafcff", "patch": "@@ -74,7 +74,6 @@ pub mod ext {\n     pub mod asm;\n     pub mod base;\n     pub mod expand;\n-    pub mod registrar;\n \n     pub mod quote;\n "}]}