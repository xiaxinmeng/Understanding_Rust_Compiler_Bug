{"sha": "d32993afe81a49701edd6f2b8f018020ca50da1a", "node_id": "C_kwDOAAsO6NoAKGQzMjk5M2FmZTgxYTQ5NzAxZWRkNmYyYjhmMDE4MDIwY2E1MGRhMWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-05T22:12:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-05T22:12:31Z"}, "message": "Auto merge of #90631 - matthiaskrgr:rollup-a5tzjh3, r=matthiaskrgr\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #89942 (Reorder `widening_impl`s to make the doc clearer)\n - #90569 (Fix tests using `only-i686` to use the correct `only-x86` directive)\n - #90597 (Warn for variables that are no longer captured)\n - #90623 (Remove more checks for LLVM < 12)\n - #90626 (Properly register text_direction_codepoint_in_comment lint.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "359ab46c3e67e59e847f579fbb0b7745800ff438", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/359ab46c3e67e59e847f579fbb0b7745800ff438"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d32993afe81a49701edd6f2b8f018020ca50da1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d32993afe81a49701edd6f2b8f018020ca50da1a", "html_url": "https://github.com/rust-lang/rust/commit/d32993afe81a49701edd6f2b8f018020ca50da1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d32993afe81a49701edd6f2b8f018020ca50da1a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d1754e8bf6942b4c1d24d7c923438782129ba5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d1754e8bf6942b4c1d24d7c923438782129ba5a", "html_url": "https://github.com/rust-lang/rust/commit/0d1754e8bf6942b4c1d24d7c923438782129ba5a"}, {"sha": "f5f6f73faf7d38b4d4c6cdccd6bd8a12ff23d5be", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5f6f73faf7d38b4d4c6cdccd6bd8a12ff23d5be", "html_url": "https://github.com/rust-lang/rust/commit/f5f6f73faf7d38b4d4c6cdccd6bd8a12ff23d5be"}], "stats": {"total": 580, "additions": 384, "deletions": 196}, "files": [{"sha": "bedd3523d899e89f0f8205c28b72ad7e03307c17", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -1,7 +1,6 @@\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n use crate::llvm::{self, AttributePlace};\n-use crate::llvm_util;\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n@@ -53,15 +52,10 @@ pub trait ArgAttributesExt {\n }\n \n fn should_use_mutable_noalias(cx: &CodegenCx<'_, '_>) -> bool {\n-    // LLVM prior to version 12 has known miscompiles in the presence of\n-    // noalias attributes (see #54878). Only enable mutable noalias by\n-    // default for versions we believe to be safe.\n-    cx.tcx\n-        .sess\n-        .opts\n-        .debugging_opts\n-        .mutable_noalias\n-        .unwrap_or_else(|| llvm_util::get_version() >= (12, 0, 0))\n+    // LLVM prior to version 12 had known miscompiles in the presence of\n+    // noalias attributes (see #54878), but we don't support earlier\n+    // versions at all anymore. We now enable mutable noalias by default.\n+    cx.tcx.sess.opts.debugging_opts.mutable_noalias.unwrap_or(true)\n }\n \n impl ArgAttributesExt for ArgAttributes {"}, {"sha": "6c74163fb496c18bf33923b9c2fc0c5f949a2e30", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -731,7 +731,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn fptoui_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n-        if llvm_util::get_version() >= (12, 0, 0) && !self.fptoint_sat_broken_in_llvm() {\n+        if !self.fptoint_sat_broken_in_llvm() {\n             let src_ty = self.cx.val_ty(val);\n             let float_width = self.cx.float_width(src_ty);\n             let int_width = self.cx.int_width(dest_ty);\n@@ -743,7 +743,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn fptosi_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n-        if llvm_util::get_version() >= (12, 0, 0) && !self.fptoint_sat_broken_in_llvm() {\n+        if !self.fptoint_sat_broken_in_llvm() {\n             let src_ty = self.cx.val_ty(val);\n             let float_width = self.cx.float_width(src_ty);\n             let int_width = self.cx.int_width(dest_ty);"}, {"sha": "1dba264a9614a32a5ae9fa62dce679a1d3fc5318", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -134,9 +134,6 @@ pub unsafe fn create_module(\n     let llmod = llvm::LLVMModuleCreateWithNameInContext(mod_name.as_ptr(), llcx);\n \n     let mut target_data_layout = sess.target.data_layout.clone();\n-    if llvm_util::get_version() < (12, 0, 0) && sess.target.arch == \"powerpc64\" {\n-        target_data_layout = target_data_layout.replace(\"-v256:256:256-v512:512:512\", \"\");\n-    }\n     if llvm_util::get_version() < (13, 0, 0) {\n         if sess.target.arch == \"powerpc64\" {\n             target_data_layout = target_data_layout.replace(\"-S128\", \"\");"}, {"sha": "3e0ea92ab81ed08ad61c8e814823a2c3f9b708d8", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -406,11 +406,6 @@ pub fn llvm_global_features(sess: &Session) -> Vec<String> {\n     // -Ctarget-features\n     features.extend(sess.opts.cg.target_feature.split(',').flat_map(&filter));\n \n-    // FIXME: Move outline-atomics to target definition when earliest supported LLVM is 12.\n-    if get_version() >= (12, 0, 0) && sess.target.llvm_target.contains(\"aarch64-unknown-linux\") {\n-        features.push(\"+outline-atomics\".to_string());\n-    }\n-\n     features\n }\n "}, {"sha": "c1a53c34b7a244d27cfbcdb8bc8289108b5debf4", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -3054,6 +3054,7 @@ declare_lint_pass! {\n         BREAK_WITH_LABEL_AND_LOOP,\n         UNUSED_ATTRIBUTES,\n         NON_EXHAUSTIVE_OMITTED_PATTERNS,\n+        TEXT_DIRECTION_CODEPOINT_IN_COMMENT,\n         DEREF_INTO_DYN_SUPERTRAIT,\n     ]\n }"}, {"sha": "b87e23af72b702076ea2ea84f8d5b48bf87b6f43", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -3060,9 +3060,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     // LLVM's definition of `noalias` is based solely on memory\n                     // dependencies rather than pointer equality\n                     //\n-                    // Due to miscompiles in LLVM < 12, we apply a separate NoAliasMutRef attribute\n-                    // for UniqueBorrowed arguments, so that the codegen backend can decide\n-                    // whether or not to actually emit the attribute.\n+                    // Due to past miscompiles in LLVM, we apply a separate NoAliasMutRef attribute\n+                    // for UniqueBorrowed arguments, so that the codegen backend can decide whether\n+                    // or not to actually emit the attribute. It can also be controlled with the\n+                    // `-Zmutable-noalias` debugging option.\n                     let no_alias = match kind {\n                         PointerKind::Shared | PointerKind::UniqueBorrowed => false,\n                         PointerKind::UniqueOwned => true,"}, {"sha": "3add3e861484e82b862ec6f156497847143fa6ad", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -1193,7 +1193,7 @@ options! {\n     move_size_limit: Option<usize> = (None, parse_opt_number, [TRACKED],\n         \"the size at which the `large_assignments` lint starts to be emitted\"),\n     mutable_noalias: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"emit noalias metadata for mutable references (default: yes for LLVM >= 12, otherwise no)\"),\n+        \"emit noalias metadata for mutable references (default: yes)\"),\n     new_llvm_pass_manager: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"use new LLVM pass manager (default: no)\"),\n     nll_facts: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "4768c9e2db5e109ddca539d463d9b8fb381968ed", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -68,8 +68,10 @@ mod attr_impl {\n             const NonNull   = 1 << 3;\n             const ReadOnly  = 1 << 4;\n             const InReg     = 1 << 5;\n-            // NoAlias on &mut arguments can only be used with LLVM >= 12 due to miscompiles\n-            // in earlier versions. FIXME: Remove this distinction once possible.\n+            // Due to past miscompiles in LLVM, we use a separate attribute for\n+            // &mut arguments, so that the codegen backend can decide whether\n+            // or not to actually emit the attribute. It can also be controlled\n+            // with the `-Zmutable-noalias` debugging option.\n             const NoAliasMutRef = 1 << 6;\n         }\n     }"}, {"sha": "a393858879bfe725ab4c239e6da04dbec1622cb5", "filename": "compiler/rustc_target/src/spec/aarch64_be_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_be_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_be_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_be_unknown_linux_gnu.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -8,6 +8,7 @@ pub fn target() -> Target {\n         data_layout: \"E-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n         options: TargetOptions {\n+            features: \"+outline-atomics\".to_string(),\n             max_atomic_width: Some(128),\n             mcount: \"\\u{1}_mcount\".to_string(),\n             endian: Endian::Big,"}, {"sha": "e75100f1435115300f61dd274db7b86988d5ed17", "filename": "compiler/rustc_target/src/spec/aarch64_be_unknown_linux_gnu_ilp32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_be_unknown_linux_gnu_ilp32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_be_unknown_linux_gnu_ilp32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_be_unknown_linux_gnu_ilp32.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -12,6 +12,7 @@ pub fn target() -> Target {\n         arch: \"aarch64\".to_string(),\n         options: TargetOptions {\n             abi: \"ilp32\".to_string(),\n+            features: \"+outline-atomics\".to_string(),\n             mcount: \"\\u{1}_mcount\".to_string(),\n             endian: Endian::Big,\n             ..base"}, {"sha": "850381f7fb073e6fb12c3dd1dc736cc7cdcb2dc5", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_gnu.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -7,6 +7,7 @@ pub fn target() -> Target {\n         data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n         options: TargetOptions {\n+            features: \"+outline-atomics\".to_string(),\n             mcount: \"\\u{1}_mcount\".to_string(),\n             max_atomic_width: Some(128),\n             supported_sanitizers: SanitizerSet::ADDRESS"}, {"sha": "1c931d5a705f0df3b95f75363f15ffb93bedf7c4", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_linux_gnu_ilp32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_gnu_ilp32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_gnu_ilp32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_gnu_ilp32.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -8,6 +8,7 @@ pub fn target() -> Target {\n         arch: \"aarch64\".to_string(),\n         options: TargetOptions {\n             abi: \"ilp32\".to_string(),\n+            features: \"+outline-atomics\".to_string(),\n             max_atomic_width: Some(128),\n             mcount: \"\\u{1}_mcount\".to_string(),\n             ..super::linux_gnu_base::opts()"}, {"sha": "0770f3496c2792bc87fbed8dc393fa6c4e9e385d", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_linux_musl.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_musl.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -9,6 +9,10 @@ pub fn target() -> Target {\n         pointer_width: 64,\n         data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n-        options: TargetOptions { mcount: \"\\u{1}_mcount\".to_string(), ..base },\n+        options: TargetOptions {\n+            features: \"+outline-atomics\".to_string(),\n+            mcount: \"\\u{1}_mcount\".to_string(),\n+            ..base\n+        },\n     }\n }"}, {"sha": "774d8078e52ca31171213b8070848902040aae07", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 153, "deletions": 78, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -86,18 +86,55 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n /// Intermediate format to store the hir_id pointing to the use that resulted in the\n /// corresponding place being captured and a String which contains the captured value's\n /// name (i.e: a.b.c)\n-type CapturesInfo = (Option<hir::HirId>, String);\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+enum UpvarMigrationInfo {\n+    /// We previously captured all of `x`, but now we capture some sub-path.\n+    CapturingPrecise { source_expr: Option<hir::HirId>, var_name: String },\n+    CapturingNothing {\n+        // where the variable appears in the closure (but is not captured)\n+        use_span: Span,\n+    },\n+}\n+\n+/// Reasons that we might issue a migration warning.\n+#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+struct MigrationWarningReason {\n+    /// When we used to capture `x` in its entirety, we implemented the auto-trait(s)\n+    /// in this vec, but now we don't.\n+    auto_traits: Vec<&'static str>,\n+\n+    /// When we used to capture `x` in its entirety, we would execute some destructors\n+    /// at a different time.\n+    drop_order: bool,\n+}\n+\n+impl MigrationWarningReason {\n+    fn migration_message(&self) -> String {\n+        let base = \"changes to closure capture in Rust 2021 will affect\";\n+        if !self.auto_traits.is_empty() && self.drop_order {\n+            format!(\"{} drop order and which traits the closure implements\", base)\n+        } else if self.drop_order {\n+            format!(\"{} drop order\", base)\n+        } else {\n+            format!(\"{} which traits the closure implements\", base)\n+        }\n+    }\n+}\n \n-/// Intermediate format to store information needed to generate migration lint. The tuple\n-/// contains the hir_id pointing to the use that resulted in the\n-/// corresponding place being captured, a String which contains the captured value's\n-/// name (i.e: a.b.c) and a String which contains the reason why migration is needed for that\n-/// capture\n-type MigrationNeededForCapture = (Option<hir::HirId>, String, String);\n+/// Intermediate format to store information needed to generate a note in the migration lint.\n+struct MigrationLintNote {\n+    captures_info: UpvarMigrationInfo,\n+\n+    /// reasons why migration is needed for this capture\n+    reason: MigrationWarningReason,\n+}\n \n /// Intermediate format to store the hir id of the root variable and a HashSet containing\n /// information on why the root variable should be fully captured\n-type MigrationDiagnosticInfo = (hir::HirId, Vec<MigrationNeededForCapture>);\n+struct NeededMigration {\n+    var_hir_id: hir::HirId,\n+    diagnostics_info: Vec<MigrationLintNote>,\n+}\n \n struct InferBorrowKindVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n@@ -707,47 +744,66 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                  closure_head_span,\n                 |lint| {\n                     let mut diagnostics_builder = lint.build(\n-                        format!(\n-                            \"changes to closure capture in Rust 2021 will affect {}\",\n-                            reasons\n-                        )\n-                        .as_str(),\n+                        &reasons.migration_message(),\n                     );\n-                    for (var_hir_id, diagnostics_info) in need_migrations.iter() {\n+                    for NeededMigration { var_hir_id, diagnostics_info } in &need_migrations {\n                         // Labels all the usage of the captured variable and why they are responsible\n                         // for migration being needed\n-                        for (captured_hir_id, captured_name, reasons) in diagnostics_info.iter() {\n-                            if let Some(captured_hir_id) = captured_hir_id {\n-                                let cause_span = self.tcx.hir().span(*captured_hir_id);\n-                                diagnostics_builder.span_label(cause_span, format!(\"in Rust 2018, this closure captures all of `{}`, but in Rust 2021, it will only capture `{}`\",\n-                                    self.tcx.hir().name(*var_hir_id),\n-                                    captured_name,\n-                                ));\n+                        for lint_note in diagnostics_info.iter() {\n+                            match &lint_note.captures_info {\n+                                UpvarMigrationInfo::CapturingPrecise { source_expr: Some(capture_expr_id), var_name: captured_name } => {\n+                                    let cause_span = self.tcx.hir().span(*capture_expr_id);\n+                                    diagnostics_builder.span_label(cause_span, format!(\"in Rust 2018, this closure captures all of `{}`, but in Rust 2021, it will only capture `{}`\",\n+                                        self.tcx.hir().name(*var_hir_id),\n+                                        captured_name,\n+                                    ));\n+                                }\n+                                UpvarMigrationInfo::CapturingNothing { use_span } => {\n+                                    diagnostics_builder.span_label(*use_span, format!(\"in Rust 2018, this causes the closure to capture `{}`, but in Rust 2021, it has no effect\",\n+                                        self.tcx.hir().name(*var_hir_id),\n+                                    ));\n+                                }\n+\n+                                _ => { }\n                             }\n \n                             // Add a label pointing to where a captured variable affected by drop order\n                             // is dropped\n-                            if reasons.contains(\"drop order\") {\n+                            if lint_note.reason.drop_order {\n                                 let drop_location_span = drop_location_span(self.tcx, &closure_hir_id);\n \n-                                diagnostics_builder.span_label(drop_location_span, format!(\"in Rust 2018, `{}` is dropped here, but in Rust 2021, only `{}` will be dropped here as part of the closure\",\n-                                    self.tcx.hir().name(*var_hir_id),\n-                                    captured_name,\n-                                ));\n+                                match &lint_note.captures_info {\n+                                    UpvarMigrationInfo::CapturingPrecise { var_name: captured_name, .. } => {\n+                                        diagnostics_builder.span_label(drop_location_span, format!(\"in Rust 2018, `{}` is dropped here, but in Rust 2021, only `{}` will be dropped here as part of the closure\",\n+                                            self.tcx.hir().name(*var_hir_id),\n+                                            captured_name,\n+                                        ));\n+                                    }\n+                                    UpvarMigrationInfo::CapturingNothing { use_span: _ } => {\n+                                        diagnostics_builder.span_label(drop_location_span, format!(\"in Rust 2018, `{v}` is dropped here along with the closure, but in Rust 2021 `{v}` is not part of the closure\",\n+                                            v = self.tcx.hir().name(*var_hir_id),\n+                                        ));\n+                                    }\n+                                }\n                             }\n \n                             // Add a label explaining why a closure no longer implements a trait\n-                            if reasons.contains(\"trait implementation\") {\n-                                let missing_trait = &reasons[..reasons.find(\"trait implementation\").unwrap() - 1];\n-\n-                                diagnostics_builder.span_label(closure_head_span, format!(\"in Rust 2018, this closure implements {} as `{}` implements {}, but in Rust 2021, this closure will no longer implement {} as `{}` does not implement {}\",\n-                                    missing_trait,\n-                                    self.tcx.hir().name(*var_hir_id),\n-                                    missing_trait,\n-                                    missing_trait,\n-                                    captured_name,\n-                                    missing_trait,\n-                                ));\n+                            for &missing_trait in &lint_note.reason.auto_traits {\n+                                // not capturing something anymore cannot cause a trait to fail to be implemented:\n+                                match &lint_note.captures_info {\n+                                    UpvarMigrationInfo::CapturingPrecise { var_name: captured_name, .. } => {\n+                                        let var_name = self.tcx.hir().name(*var_hir_id);\n+                                        diagnostics_builder.span_label(closure_head_span, format!(\"\\\n+                                        in Rust 2018, this closure implements {missing_trait} \\\n+                                        as `{var_name}` implements {missing_trait}, but in Rust 2021, \\\n+                                        this closure will no longer implement {missing_trait} \\\n+                                        because `{var_name}` is not fully captured \\\n+                                        and `{captured_name}` does not implement {missing_trait}\"));\n+                                    }\n+\n+                                    // Cannot happen: if we don't capture a variable, we impl strictly more traits\n+                                    UpvarMigrationInfo::CapturingNothing { use_span } => span_bug!(*use_span, \"missing trait from not capturing something\"),\n+                                }\n                             }\n                         }\n                     }\n@@ -840,25 +896,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Combines all the reasons for 2229 migrations\n     fn compute_2229_migrations_reasons(\n         &self,\n-        auto_trait_reasons: FxHashSet<&str>,\n-        drop_reason: bool,\n-    ) -> String {\n-        let mut reasons = String::new();\n-\n-        if !auto_trait_reasons.is_empty() {\n-            reasons = format!(\n-                \"{} trait implementation for closure\",\n-                auto_trait_reasons.clone().into_iter().collect::<Vec<&str>>().join(\", \")\n-            );\n-        }\n+        auto_trait_reasons: FxHashSet<&'static str>,\n+        drop_order: bool,\n+    ) -> MigrationWarningReason {\n+        let mut reasons = MigrationWarningReason::default();\n \n-        if !auto_trait_reasons.is_empty() && drop_reason {\n-            reasons = format!(\"{} and \", reasons);\n+        for auto_trait in auto_trait_reasons {\n+            reasons.auto_traits.push(auto_trait);\n         }\n \n-        if drop_reason {\n-            reasons = format!(\"{}drop order\", reasons);\n-        }\n+        reasons.drop_order = drop_order;\n \n         reasons\n     }\n@@ -874,7 +921,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n         var_hir_id: hir::HirId,\n         closure_clause: hir::CaptureBy,\n-    ) -> Option<FxHashMap<CapturesInfo, FxHashSet<&str>>> {\n+    ) -> Option<FxHashMap<UpvarMigrationInfo, FxHashSet<&'static str>>> {\n         let auto_traits_def_id = vec![\n             self.tcx.lang_items().clone_trait(),\n             self.tcx.lang_items().sync_trait(),\n@@ -963,7 +1010,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             if !capture_problems.is_empty() {\n                 problematic_captures.insert(\n-                    (capture.info.path_expr_id, capture.to_string(self.tcx)),\n+                    UpvarMigrationInfo::CapturingPrecise {\n+                        source_expr: capture.info.path_expr_id,\n+                        var_name: capture.to_string(self.tcx),\n+                    },\n                     capture_problems,\n                 );\n             }\n@@ -986,32 +1036,49 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// This function only returns a HashSet of CapturesInfo for significant drops. If there\n     /// are no significant drops than None is returned\n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_2229_migrations_for_drop(\n         &self,\n         closure_def_id: DefId,\n         closure_span: Span,\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n         closure_clause: hir::CaptureBy,\n         var_hir_id: hir::HirId,\n-    ) -> Option<FxHashSet<CapturesInfo>> {\n+    ) -> Option<FxHashSet<UpvarMigrationInfo>> {\n         let ty = self.infcx.resolve_vars_if_possible(self.node_ty(var_hir_id));\n \n         if !ty.has_significant_drop(self.tcx, self.tcx.param_env(closure_def_id.expect_local())) {\n+            debug!(\"does not have significant drop\");\n             return None;\n         }\n \n         let Some(root_var_min_capture_list) = min_captures.and_then(|m| m.get(&var_hir_id)) else {\n             // The upvar is mentioned within the closure but no path starting from it is\n-            // used.\n+            // used. This occurs when you have (e.g.)\n+            //\n+            // ```\n+            // let x = move || {\n+            //     let _ = y;\n+            // });\n+            // ```\n+            debug!(\"no path starting from it is used\");\n+\n \n             match closure_clause {\n                 // Only migrate if closure is a move closure\n-                hir::CaptureBy::Value => return Some(FxHashSet::default()),\n+                hir::CaptureBy::Value => {\n+                    let mut diagnostics_info = FxHashSet::default();\n+                    let upvars = self.tcx.upvars_mentioned(closure_def_id).expect(\"must be an upvar\");\n+                    let upvar = upvars[&var_hir_id];\n+                    diagnostics_info.insert(UpvarMigrationInfo::CapturingNothing { use_span: upvar.span });\n+                    return Some(diagnostics_info);\n+                }\n                 hir::CaptureBy::Ref => {}\n             }\n \n             return None;\n         };\n+        debug!(?root_var_min_capture_list);\n \n         let mut projections_list = Vec::new();\n         let mut diagnostics_info = FxHashSet::default();\n@@ -1021,19 +1088,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Only care about captures that are moved into the closure\n                 ty::UpvarCapture::ByValue(..) => {\n                     projections_list.push(captured_place.place.projections.as_slice());\n-                    diagnostics_info.insert((\n-                        captured_place.info.path_expr_id,\n-                        captured_place.to_string(self.tcx),\n-                    ));\n+                    diagnostics_info.insert(UpvarMigrationInfo::CapturingPrecise {\n+                        source_expr: captured_place.info.path_expr_id,\n+                        var_name: captured_place.to_string(self.tcx),\n+                    });\n                 }\n                 ty::UpvarCapture::ByRef(..) => {}\n             }\n         }\n \n+        debug!(?projections_list);\n+        debug!(?diagnostics_info);\n+\n         let is_moved = !projections_list.is_empty();\n+        debug!(?is_moved);\n \n         let is_not_completely_captured =\n             root_var_min_capture_list.iter().any(|capture| !capture.place.projections.is_empty());\n+        debug!(?is_not_completely_captured);\n \n         if is_moved\n             && is_not_completely_captured\n@@ -1066,15 +1138,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Returns a tuple containing a vector of MigrationDiagnosticInfo, as well as a String\n     /// containing the reason why root variables whose HirId is contained in the vector should\n     /// be captured\n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_2229_migrations(\n         &self,\n         closure_def_id: DefId,\n         closure_span: Span,\n         closure_clause: hir::CaptureBy,\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n-    ) -> (Vec<MigrationDiagnosticInfo>, String) {\n+    ) -> (Vec<NeededMigration>, MigrationWarningReason) {\n         let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) else {\n-            return (Vec::new(), String::new());\n+            return (Vec::new(), MigrationWarningReason::default());\n         };\n \n         let mut need_migrations = Vec::new();\n@@ -1083,7 +1156,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Perform auto-trait analysis\n         for (&var_hir_id, _) in upvars.iter() {\n-            let mut responsible_captured_hir_ids = Vec::new();\n+            let mut diagnostics_info = Vec::new();\n \n             let auto_trait_diagnostic = if let Some(diagnostics_info) =\n                 self.compute_2229_migrations_for_trait(min_captures, var_hir_id, closure_clause)\n@@ -1115,34 +1188,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             let mut capture_diagnostic = capture_diagnostic.into_iter().collect::<Vec<_>>();\n             capture_diagnostic.sort();\n-            for captured_info in capture_diagnostic.iter() {\n+            for captures_info in capture_diagnostic {\n                 // Get the auto trait reasons of why migration is needed because of that capture, if there are any\n                 let capture_trait_reasons =\n-                    if let Some(reasons) = auto_trait_diagnostic.get(captured_info) {\n+                    if let Some(reasons) = auto_trait_diagnostic.get(&captures_info) {\n                         reasons.clone()\n                     } else {\n                         FxHashSet::default()\n                     };\n \n                 // Check if migration is needed because of drop reorder as a result of that capture\n-                let capture_drop_reorder_reason = drop_reorder_diagnostic.contains(captured_info);\n+                let capture_drop_reorder_reason = drop_reorder_diagnostic.contains(&captures_info);\n \n                 // Combine all the reasons of why the root variable should be captured as a result of\n                 // auto trait implementation issues\n                 auto_trait_migration_reasons.extend(capture_trait_reasons.clone());\n \n-                responsible_captured_hir_ids.push((\n-                    captured_info.0,\n-                    captured_info.1.clone(),\n-                    self.compute_2229_migrations_reasons(\n+                diagnostics_info.push(MigrationLintNote {\n+                    captures_info,\n+                    reason: self.compute_2229_migrations_reasons(\n                         capture_trait_reasons,\n                         capture_drop_reorder_reason,\n                     ),\n-                ));\n+                });\n             }\n \n-            if !capture_diagnostic.is_empty() {\n-                need_migrations.push((var_hir_id, responsible_captured_hir_ids));\n+            if !diagnostics_info.is_empty() {\n+                need_migrations.push(NeededMigration { var_hir_id, diagnostics_info });\n             }\n         }\n         (\n@@ -2087,6 +2159,7 @@ fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n     tcx.hir().name(var_hir_id)\n }\n \n+#[instrument(level = \"debug\", skip(tcx))]\n fn should_do_rust_2021_incompatible_closure_captures_analysis(\n     tcx: TyCtxt<'_>,\n     closure_id: hir::HirId,\n@@ -2102,10 +2175,12 @@ fn should_do_rust_2021_incompatible_closure_captures_analysis(\n /// - s2: Comma separated names of the variables being migrated.\n fn migration_suggestion_for_2229(\n     tcx: TyCtxt<'_>,\n-    need_migrations: &Vec<MigrationDiagnosticInfo>,\n+    need_migrations: &Vec<NeededMigration>,\n ) -> (String, String) {\n-    let need_migrations_variables =\n-        need_migrations.iter().map(|(v, _)| var_name(tcx, *v)).collect::<Vec<_>>();\n+    let need_migrations_variables = need_migrations\n+        .iter()\n+        .map(|NeededMigration { var_hir_id: v, .. }| var_name(tcx, *v))\n+        .collect::<Vec<_>>();\n \n     let migration_ref_concat =\n         need_migrations_variables.iter().map(|v| format!(\"&{}\", v)).collect::<Vec<_>>().join(\", \");"}, {"sha": "0c00db5fdf37aa38142116eeb970919bb320fda3", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -201,33 +201,33 @@ macro_rules! widening_impl {\n \n #[lang = \"i8\"]\n impl i8 {\n-    widening_impl! { i8, i16, 8, signed }\n     int_impl! { i8, i8, u8, 8, 7, -128, 127, 2, \"-0x7e\", \"0xa\", \"0x12\", \"0x12\", \"0x48\",\n     \"[0x12]\", \"[0x12]\", \"\", \"\" }\n+    widening_impl! { i8, i16, 8, signed }\n }\n \n #[lang = \"i16\"]\n impl i16 {\n-    widening_impl! { i16, i32, 16, signed }\n     int_impl! { i16, i16, u16, 16, 15, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\", \"0x3412\",\n     \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n+    widening_impl! { i16, i32, 16, signed }\n }\n \n #[lang = \"i32\"]\n impl i32 {\n-    widening_impl! { i32, i64, 32, signed }\n     int_impl! { i32, i32, u32, 32, 31, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n     \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n+    widening_impl! { i32, i64, 32, signed }\n }\n \n #[lang = \"i64\"]\n impl i64 {\n-    widening_impl! { i64, i128, 64, signed }\n     int_impl! { i64, i64, u64, 64, 63, -9223372036854775808, 9223372036854775807, 12,\n     \"0xaa00000000006e1\", \"0x6e10aa\", \"0x1234567890123456\", \"0x5634129078563412\",\n     \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\", \"\", \"\" }\n+    widening_impl! { i64, i128, 64, signed }\n }\n \n #[lang = \"i128\"]\n@@ -245,41 +245,41 @@ impl i128 {\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"isize\"]\n impl isize {\n-    widening_impl! { isize, i32, 16, signed }\n     int_impl! { isize, i16, usize, 16, 15, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\",\n     \"0x3412\", \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n+    widening_impl! { isize, i32, 16, signed }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"isize\"]\n impl isize {\n-    widening_impl! { isize, i64, 32, signed }\n     int_impl! { isize, i32, usize, 32, 31, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n     \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n+    widening_impl! { isize, i64, 32, signed }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"isize\"]\n impl isize {\n-    widening_impl! { isize, i128, 64, signed }\n     int_impl! { isize, i64, usize, 64, 63, -9223372036854775808, 9223372036854775807,\n     12, \"0xaa00000000006e1\", \"0x6e10aa\",  \"0x1234567890123456\", \"0x5634129078563412\",\n-     \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-     \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n-     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n+    \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n+    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n+    widening_impl! { isize, i128, 64, signed }\n }\n \n /// If 6th bit set ascii is upper case.\n const ASCII_CASE_MASK: u8 = 0b0010_0000;\n \n #[lang = \"u8\"]\n impl u8 {\n-    widening_impl! { u8, u16, 8, unsigned }\n     uint_impl! { u8, u8, i8, 8, 255, 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\", \"[0x12]\",\n     \"[0x12]\", \"\", \"\" }\n+    widening_impl! { u8, u16, 8, unsigned }\n \n     /// Checks if the value is within the ASCII range.\n     ///\n@@ -826,26 +826,26 @@ impl u8 {\n \n #[lang = \"u16\"]\n impl u16 {\n-    widening_impl! { u16, u32, 16, unsigned }\n     uint_impl! { u16, u16, i16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n     \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n+    widening_impl! { u16, u32, 16, unsigned }\n }\n \n #[lang = \"u32\"]\n impl u32 {\n-    widening_impl! { u32, u64, 32, unsigned }\n     uint_impl! { u32, u32, i32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n     \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n+    widening_impl! { u32, u64, 32, unsigned }\n }\n \n #[lang = \"u64\"]\n impl u64 {\n-    widening_impl! { u64, u128, 64, unsigned }\n     uint_impl! { u64, u64, i64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n     \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n     \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n     \"\", \"\"}\n+    widening_impl! { u64, u128, 64, unsigned }\n }\n \n #[lang = \"u128\"]\n@@ -863,29 +863,29 @@ impl u128 {\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n-    widening_impl! { usize, u32, 16, unsigned }\n     uint_impl! { usize, u16, isize, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n     \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n+    widening_impl! { usize, u32, 16, unsigned }\n }\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n-    widening_impl! { usize, u64, 32, unsigned }\n     uint_impl! { usize, u32, isize, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n     \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n+    widening_impl! { usize, u64, 32, unsigned }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n-    widening_impl! { usize, u128, 64, unsigned }\n     uint_impl! { usize, u64, isize, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n     \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n     \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-     \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n+    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n+    widening_impl! { usize, u128, 64, unsigned }\n }\n \n /// A classification of floating point numbers."}, {"sha": "4e0b18e72338ad881e95e67d708c90dcd70b56fa", "filename": "src/test/ui/closures/2229_closure_analysis/issue-90465.fixed", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-90465.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-90465.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-90465.fixed?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -0,0 +1,35 @@\n+// run-rustfix\n+\n+#![deny(rust_2021_incompatible_closure_captures)]\n+//~^ NOTE lint level is defined here\n+\n+fn main() {\n+    struct Foo(u32);\n+    impl Drop for Foo {\n+        fn drop(&mut self) {\n+            println!(\"dropped {}\", self.0);\n+        }\n+    }\n+\n+    let f0 = Foo(0);\n+    let f1 = Foo(1);\n+\n+    let c0 = move || {\n+        let _ = &f0;\n+        //~^ ERROR changes to closure capture in Rust 2021 will affect drop order\n+        //~| NOTE for more information\n+        let _ = f0;\n+        //~^ NOTE in Rust 2018, this causes the closure to capture `f0`, but in Rust 2021, it has no effect\n+    };\n+\n+    let c1 = move || {\n+        let _ = &f1;\n+    };\n+\n+    println!(\"dropping 0\");\n+    drop(c0);\n+    println!(\"dropping 1\");\n+    drop(c1);\n+    println!(\"dropped all\");\n+}\n+//~^ NOTE in Rust 2018, `f0` is dropped here along with the closure, but in Rust 2021 `f0` is not part of the closure"}, {"sha": "466e6dbabc5021ac47d7748c57cb2787909e5bca", "filename": "src/test/ui/closures/2229_closure_analysis/issue-90465.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-90465.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-90465.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-90465.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -0,0 +1,34 @@\n+// run-rustfix\n+\n+#![deny(rust_2021_incompatible_closure_captures)]\n+//~^ NOTE lint level is defined here\n+\n+fn main() {\n+    struct Foo(u32);\n+    impl Drop for Foo {\n+        fn drop(&mut self) {\n+            println!(\"dropped {}\", self.0);\n+        }\n+    }\n+\n+    let f0 = Foo(0);\n+    let f1 = Foo(1);\n+\n+    let c0 = move || {\n+        //~^ ERROR changes to closure capture in Rust 2021 will affect drop order\n+        //~| NOTE for more information\n+        let _ = f0;\n+        //~^ NOTE in Rust 2018, this causes the closure to capture `f0`, but in Rust 2021, it has no effect\n+    };\n+\n+    let c1 = move || {\n+        let _ = &f1;\n+    };\n+\n+    println!(\"dropping 0\");\n+    drop(c0);\n+    println!(\"dropping 1\");\n+    drop(c1);\n+    println!(\"dropped all\");\n+}\n+//~^ NOTE in Rust 2018, `f0` is dropped here along with the closure, but in Rust 2021 `f0` is not part of the closure"}, {"sha": "3e921dc0f8a664f299e8fb2be5a31811234de677", "filename": "src/test/ui/closures/2229_closure_analysis/issue-90465.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-90465.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-90465.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-90465.stderr?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -0,0 +1,26 @@\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/issue-90465.rs:17:14\n+   |\n+LL |     let c0 = move || {\n+   |              ^^^^^^^\n+...\n+LL |         let _ = f0;\n+   |                 -- in Rust 2018, this causes the closure to capture `f0`, but in Rust 2021, it has no effect\n+...\n+LL | }\n+   | - in Rust 2018, `f0` is dropped here along with the closure, but in Rust 2021 `f0` is not part of the closure\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-90465.rs:3:9\n+   |\n+LL | #![deny(rust_2021_incompatible_closure_captures)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n+help: add a dummy let to cause `f0` to be fully captured\n+   |\n+LL ~     let c0 = move || {\n+LL +         let _ = &f0;\n+   |\n+\n+error: aborting due to previous error\n+"}, {"sha": "26703fbf81193603e2a471b5a5d055b20bcc93db", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.fixed", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -20,8 +20,8 @@ fn test_send_trait() {\n     let mut f = 10;\n     let fptr = SendPointer(&mut f as *mut i32);\n     thread::spawn(move || { let _ = &fptr; unsafe {\n-        //~^ ERROR: `Send` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Send` as `fptr` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` as `fptr.0` does not implement `Send`\n+        //~^ ERROR: changes to closure capture\n+        //~| NOTE: in Rust 2018, this closure implements `Send`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0 = 20;\n@@ -40,8 +40,9 @@ fn test_sync_trait() {\n     let f = CustomInt(&mut f as *mut i32);\n     let fptr = SyncPointer(f);\n     thread::spawn(move || { let _ = &fptr; unsafe {\n-        //~^ ERROR: `Sync`, `Send` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Sync`, `Send` as `fptr` implements `Sync`, `Send`, but in Rust 2021, this closure will no longer implement `Sync`, `Send` as `fptr.0.0` does not implement `Sync`, `Send`\n+        //~^ ERROR: changes to closure capture\n+        //~| NOTE: in Rust 2018, this closure implements `Sync`\n+        //~| NOTE: in Rust 2018, this closure implements `Send`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0.0 = 20;\n@@ -65,8 +66,8 @@ fn test_clone_trait() {\n     let f = U(S(Foo(0)), T(0));\n     let c = || {\n         let _ = &f;\n-        //~^ ERROR: `Clone` trait implementation for closure and drop order\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f.1` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect drop order and which traits the closure implements\n+        //~| NOTE: in Rust 2018, this closure implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f` to be fully captured\n         let f_1 = f.1;"}, {"sha": "932db51d437130699e7256ef92cf104542b34940", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -20,8 +20,8 @@ fn test_send_trait() {\n     let mut f = 10;\n     let fptr = SendPointer(&mut f as *mut i32);\n     thread::spawn(move || unsafe {\n-        //~^ ERROR: `Send` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Send` as `fptr` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` as `fptr.0` does not implement `Send`\n+        //~^ ERROR: changes to closure capture\n+        //~| NOTE: in Rust 2018, this closure implements `Send`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0 = 20;\n@@ -40,8 +40,9 @@ fn test_sync_trait() {\n     let f = CustomInt(&mut f as *mut i32);\n     let fptr = SyncPointer(f);\n     thread::spawn(move || unsafe {\n-        //~^ ERROR: `Sync`, `Send` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Sync`, `Send` as `fptr` implements `Sync`, `Send`, but in Rust 2021, this closure will no longer implement `Sync`, `Send` as `fptr.0.0` does not implement `Sync`, `Send`\n+        //~^ ERROR: changes to closure capture\n+        //~| NOTE: in Rust 2018, this closure implements `Sync`\n+        //~| NOTE: in Rust 2018, this closure implements `Send`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0.0 = 20;\n@@ -64,8 +65,8 @@ impl Clone for U {\n fn test_clone_trait() {\n     let f = U(S(Foo(0)), T(0));\n     let c = || {\n-        //~^ ERROR: `Clone` trait implementation for closure and drop order\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f.1` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect drop order and which traits the closure implements\n+        //~| NOTE: in Rust 2018, this closure implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f` to be fully captured\n         let f_1 = f.1;"}, {"sha": "ee4907bb755cc115005945b6af0d7fa14e964da4", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.stderr", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -1,8 +1,8 @@\n-error: changes to closure capture in Rust 2021 will affect `Send` trait implementation for closure\n+error: changes to closure capture in Rust 2021 will affect which traits the closure implements\n   --> $DIR/auto_traits.rs:22:19\n    |\n LL |     thread::spawn(move || unsafe {\n-   |                   ^^^^^^^^^^^^^^ in Rust 2018, this closure implements `Send` as `fptr` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` as `fptr.0` does not implement `Send`\n+   |                   ^^^^^^^^^^^^^^ in Rust 2018, this closure implements `Send` as `fptr` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` because `fptr` is not fully captured and `fptr.0` does not implement `Send`\n ...\n LL |         *fptr.0 = 20;\n    |         ------- in Rust 2018, this closure captures all of `fptr`, but in Rust 2021, it will only capture `fptr.0`\n@@ -23,11 +23,14 @@ LL |\n LL |         *fptr.0 = 20;\n  ...\n \n-error: changes to closure capture in Rust 2021 will affect `Sync`, `Send` trait implementation for closure\n+error: changes to closure capture in Rust 2021 will affect which traits the closure implements\n   --> $DIR/auto_traits.rs:42:19\n    |\n LL |     thread::spawn(move || unsafe {\n-   |                   ^^^^^^^^^^^^^^ in Rust 2018, this closure implements `Sync`, `Send` as `fptr` implements `Sync`, `Send`, but in Rust 2021, this closure will no longer implement `Sync`, `Send` as `fptr.0.0` does not implement `Sync`, `Send`\n+   |                   ^^^^^^^^^^^^^^\n+   |                   |\n+   |                   in Rust 2018, this closure implements `Sync` as `fptr` implements `Sync`, but in Rust 2021, this closure will no longer implement `Sync` because `fptr` is not fully captured and `fptr.0.0` does not implement `Sync`\n+   |                   in Rust 2018, this closure implements `Send` as `fptr` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` because `fptr` is not fully captured and `fptr.0.0` does not implement `Send`\n ...\n LL |         *fptr.0.0 = 20;\n    |         --------- in Rust 2018, this closure captures all of `fptr`, but in Rust 2021, it will only capture `fptr.0.0`\n@@ -40,14 +43,14 @@ LL |\n LL |\n LL |\n LL |\n-LL |         *fptr.0.0 = 20;\n+LL |\n  ...\n \n-error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure and drop order\n-  --> $DIR/auto_traits.rs:66:13\n+error: changes to closure capture in Rust 2021 will affect drop order and which traits the closure implements\n+  --> $DIR/auto_traits.rs:67:13\n    |\n LL |     let c = || {\n-   |             ^^ in Rust 2018, this closure implements `Clone` as `f` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f.1` does not implement `Clone`\n+   |             ^^ in Rust 2018, this closure implements `Clone` as `f` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` because `f` is not fully captured and `f.1` does not implement `Clone`\n ...\n LL |         let f_1 = f.1;\n    |                   --- in Rust 2018, this closure captures all of `f`, but in Rust 2021, it will only capture `f.1`"}, {"sha": "7df0dd76b44564b768e8989ece9e037c962d9136", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/mir_calls_to_shims.fixed", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.fixed?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -19,8 +19,9 @@ where\n     let f = panic::AssertUnwindSafe(f);\n     let result = panic::catch_unwind(move || {\n         let _ = &f;\n-        //~^ ERROR: `UnwindSafe`, `RefUnwindSafe` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `UnwindSafe`, `RefUnwindSafe` as `f` implements `UnwindSafe`, `RefUnwindSafe`, but in Rust 2021, this closure will no longer implement `UnwindSafe`, `RefUnwindSafe` as `f.0` does not implement `UnwindSafe`, `RefUnwindSafe`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect which traits the closure implements [rust_2021_incompatible_closure_captures]\n+        //~| NOTE: in Rust 2018, this closure implements `UnwindSafe`\n+        //~| NOTE: in Rust 2018, this closure implements `RefUnwindSafe`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f` to be fully captured\n         f.0()"}, {"sha": "d02fac7c66952606048a19827fcd9c37050b3c23", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/mir_calls_to_shims.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -18,8 +18,9 @@ where\n {\n     let f = panic::AssertUnwindSafe(f);\n     let result = panic::catch_unwind(move || {\n-        //~^ ERROR: `UnwindSafe`, `RefUnwindSafe` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `UnwindSafe`, `RefUnwindSafe` as `f` implements `UnwindSafe`, `RefUnwindSafe`, but in Rust 2021, this closure will no longer implement `UnwindSafe`, `RefUnwindSafe` as `f.0` does not implement `UnwindSafe`, `RefUnwindSafe`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect which traits the closure implements [rust_2021_incompatible_closure_captures]\n+        //~| NOTE: in Rust 2018, this closure implements `UnwindSafe`\n+        //~| NOTE: in Rust 2018, this closure implements `RefUnwindSafe`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f` to be fully captured\n         f.0()"}, {"sha": "74f85b6ebaac50e5f3de999ef10a17f90740d93d", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/mir_calls_to_shims.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.stderr?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -1,8 +1,11 @@\n-error: changes to closure capture in Rust 2021 will affect `UnwindSafe`, `RefUnwindSafe` trait implementation for closure\n+error: changes to closure capture in Rust 2021 will affect which traits the closure implements\n   --> $DIR/mir_calls_to_shims.rs:20:38\n    |\n LL |     let result = panic::catch_unwind(move || {\n-   |                                      ^^^^^^^ in Rust 2018, this closure implements `UnwindSafe`, `RefUnwindSafe` as `f` implements `UnwindSafe`, `RefUnwindSafe`, but in Rust 2021, this closure will no longer implement `UnwindSafe`, `RefUnwindSafe` as `f.0` does not implement `UnwindSafe`, `RefUnwindSafe`\n+   |                                      ^^^^^^^\n+   |                                      |\n+   |                                      in Rust 2018, this closure implements `UnwindSafe` as `f` implements `UnwindSafe`, but in Rust 2021, this closure will no longer implement `UnwindSafe` because `f` is not fully captured and `f.0` does not implement `UnwindSafe`\n+   |                                      in Rust 2018, this closure implements `RefUnwindSafe` as `f` implements `RefUnwindSafe`, but in Rust 2021, this closure will no longer implement `RefUnwindSafe` because `f` is not fully captured and `f.0` does not implement `RefUnwindSafe`\n ...\n LL |         f.0()\n    |         --- in Rust 2018, this closure captures all of `f`, but in Rust 2021, it will only capture `f.0`"}, {"sha": "2b86b0ddade2367196e542f83ac91b65cfc2b2b7", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.fixed", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -18,7 +18,6 @@ impl Foo {\n     }\n }\n \n-\n struct S(Foo);\n \n #[derive(Clone)]\n@@ -37,8 +36,8 @@ fn test_multi_issues() {\n     let f2 = U(S(Foo::from(\"bar\")), T(0));\n     let c = || {\n         let _ = (&f1, &f2);\n-        //~^ ERROR: `Clone` trait implementation for closure and drop order\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f1`, `f2` to be fully captured\n         let _f_1 = f1.0;\n@@ -57,8 +56,8 @@ fn test_capturing_all_disjoint_fields_individually() {\n     let f1 = U(S(Foo::from(\"foo\")), T(0));\n     let c = || {\n         let _ = &f1;\n-        //~^ ERROR: `Clone` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect which traits the closure implements [rust_2021_incompatible_closure_captures]\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f1` to be fully captured\n         let _f_1 = f1.0;\n@@ -83,9 +82,9 @@ fn test_capturing_several_disjoint_fields_individually_1() {\n     let f1 = U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")));\n     let c = || {\n         let _ = &f1;\n-        //~^ ERROR: `Clone` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.2` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect which traits the closure implements [rust_2021_incompatible_closure_captures]\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f1` to be fully captured\n         let _f_0 = f1.0;\n@@ -103,8 +102,8 @@ fn test_capturing_several_disjoint_fields_individually_2() {\n     let f1 = U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")));\n     let c = || {\n         let _ = &f1;\n-        //~^ ERROR: `Clone` trait implementation for closure and drop order\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect drop order and which traits the closure implements\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f1` to be fully captured\n         let _f_0 = f1.0;\n@@ -136,9 +135,10 @@ fn test_multi_traits_issues() {\n     let mut f2 = 10;\n     let fptr2 = SendPointer(&mut f2 as *mut i32);\n     thread::spawn(move || { let _ = (&fptr1, &fptr2); unsafe {\n-        //~^ ERROR: `Sync`, `Send` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Sync`, `Send` as `fptr1` implements `Sync`, `Send`, but in Rust 2021, this closure will no longer implement `Sync`, `Send` as `fptr1.0.0` does not implement `Sync`, `Send`\n-        //~| NOTE: in Rust 2018, this closure implements `Send` as `fptr2` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` as `fptr2.0` does not implement `Send`\n+        //~^ ERROR: changes to closure capture in Rust 2021\n+        //~| NOTE: in Rust 2018, this closure implements `Sync` as `fptr1` implements `Sync`\n+        //~| NOTE: in Rust 2018, this closure implements `Send` as `fptr1` implements `Send`\n+        //~| NOTE: in Rust 2018, this closure implements `Send` as `fptr2` implements `Send`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `fptr1`, `fptr2` to be fully captured\n         *fptr1.0.0 = 20;"}, {"sha": "3cac4abfad7c2a5def2e614517d6d30684481719", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -18,7 +18,6 @@ impl Foo {\n     }\n }\n \n-\n struct S(Foo);\n \n #[derive(Clone)]\n@@ -36,8 +35,8 @@ fn test_multi_issues() {\n     let f1 = U(S(Foo::from(\"foo\")), T(0));\n     let f2 = U(S(Foo::from(\"bar\")), T(0));\n     let c = || {\n-        //~^ ERROR: `Clone` trait implementation for closure and drop order\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f1`, `f2` to be fully captured\n         let _f_1 = f1.0;\n@@ -55,8 +54,8 @@ fn test_multi_issues() {\n fn test_capturing_all_disjoint_fields_individually() {\n     let f1 = U(S(Foo::from(\"foo\")), T(0));\n     let c = || {\n-        //~^ ERROR: `Clone` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect which traits the closure implements [rust_2021_incompatible_closure_captures]\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f1` to be fully captured\n         let _f_1 = f1.0;\n@@ -80,9 +79,9 @@ impl Clone for U1 {\n fn test_capturing_several_disjoint_fields_individually_1() {\n     let f1 = U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")));\n     let c = || {\n-        //~^ ERROR: `Clone` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.2` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect which traits the closure implements [rust_2021_incompatible_closure_captures]\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f1` to be fully captured\n         let _f_0 = f1.0;\n@@ -99,8 +98,8 @@ fn test_capturing_several_disjoint_fields_individually_1() {\n fn test_capturing_several_disjoint_fields_individually_2() {\n     let f1 = U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")));\n     let c = || {\n-        //~^ ERROR: `Clone` trait implementation for closure and drop order\n-        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~^ ERROR: changes to closure capture in Rust 2021 will affect drop order and which traits the closure implements\n+        //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f1` to be fully captured\n         let _f_0 = f1.0;\n@@ -132,9 +131,10 @@ fn test_multi_traits_issues() {\n     let mut f2 = 10;\n     let fptr2 = SendPointer(&mut f2 as *mut i32);\n     thread::spawn(move || unsafe {\n-        //~^ ERROR: `Sync`, `Send` trait implementation for closure\n-        //~| NOTE: in Rust 2018, this closure implements `Sync`, `Send` as `fptr1` implements `Sync`, `Send`, but in Rust 2021, this closure will no longer implement `Sync`, `Send` as `fptr1.0.0` does not implement `Sync`, `Send`\n-        //~| NOTE: in Rust 2018, this closure implements `Send` as `fptr2` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` as `fptr2.0` does not implement `Send`\n+        //~^ ERROR: changes to closure capture in Rust 2021\n+        //~| NOTE: in Rust 2018, this closure implements `Sync` as `fptr1` implements `Sync`\n+        //~| NOTE: in Rust 2018, this closure implements `Send` as `fptr1` implements `Send`\n+        //~| NOTE: in Rust 2018, this closure implements `Send` as `fptr2` implements `Send`\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `fptr1`, `fptr2` to be fully captured\n         *fptr1.0.0 = 20;"}, {"sha": "0008f1b2c07ed5811544fd27f9767c75c6bcfec0", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.stderr", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -1,8 +1,8 @@\n-error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure and drop order\n-  --> $DIR/multi_diagnostics.rs:38:13\n+error: changes to closure capture in Rust 2021 will affect drop order and which traits the closure implements\n+  --> $DIR/multi_diagnostics.rs:37:13\n    |\n LL |     let c = || {\n-   |             ^^ in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n+   |             ^^ in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` because `f1` is not fully captured and `f1.0` does not implement `Clone`\n ...\n LL |         let _f_1 = f1.0;\n    |                    ---- in Rust 2018, this closure captures all of `f1`, but in Rust 2021, it will only capture `f1.0`\n@@ -25,11 +25,11 @@ LL ~     let c = || {\n LL +         let _ = (&f1, &f2);\n    |\n \n-error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure\n-  --> $DIR/multi_diagnostics.rs:57:13\n+error: changes to closure capture in Rust 2021 will affect which traits the closure implements\n+  --> $DIR/multi_diagnostics.rs:56:13\n    |\n LL |     let c = || {\n-   |             ^^ in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n+   |             ^^ in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` because `f1` is not fully captured and `f1.0` does not implement `Clone`\n ...\n LL |         let _f_1 = f1.0;\n    |                    ---- in Rust 2018, this closure captures all of `f1`, but in Rust 2021, it will only capture `f1.0`\n@@ -41,14 +41,14 @@ LL ~     let c = || {\n LL +         let _ = &f1;\n    |\n \n-error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure\n-  --> $DIR/multi_diagnostics.rs:82:13\n+error: changes to closure capture in Rust 2021 will affect which traits the closure implements\n+  --> $DIR/multi_diagnostics.rs:81:13\n    |\n LL |     let c = || {\n    |             ^^\n    |             |\n-   |             in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n-   |             in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.2` does not implement `Clone`\n+   |             in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` because `f1` is not fully captured and `f1.0` does not implement `Clone`\n+   |             in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` because `f1` is not fully captured and `f1.2` does not implement `Clone`\n ...\n LL |         let _f_0 = f1.0;\n    |                    ---- in Rust 2018, this closure captures all of `f1`, but in Rust 2021, it will only capture `f1.0`\n@@ -63,11 +63,11 @@ LL ~     let c = || {\n LL +         let _ = &f1;\n    |\n \n-error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure and drop order\n-  --> $DIR/multi_diagnostics.rs:101:13\n+error: changes to closure capture in Rust 2021 will affect drop order and which traits the closure implements\n+  --> $DIR/multi_diagnostics.rs:100:13\n    |\n LL |     let c = || {\n-   |             ^^ in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n+   |             ^^ in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` because `f1` is not fully captured and `f1.0` does not implement `Clone`\n ...\n LL |         let _f_0 = f1.0;\n    |                    ---- in Rust 2018, this closure captures all of `f1`, but in Rust 2021, it will only capture `f1.0`\n@@ -88,14 +88,15 @@ LL ~     let c = || {\n LL +         let _ = &f1;\n    |\n \n-error: changes to closure capture in Rust 2021 will affect `Sync`, `Send` trait implementation for closure\n-  --> $DIR/multi_diagnostics.rs:134:19\n+error: changes to closure capture in Rust 2021 will affect which traits the closure implements\n+  --> $DIR/multi_diagnostics.rs:133:19\n    |\n LL |     thread::spawn(move || unsafe {\n    |                   ^^^^^^^^^^^^^^\n    |                   |\n-   |                   in Rust 2018, this closure implements `Sync`, `Send` as `fptr1` implements `Sync`, `Send`, but in Rust 2021, this closure will no longer implement `Sync`, `Send` as `fptr1.0.0` does not implement `Sync`, `Send`\n-   |                   in Rust 2018, this closure implements `Send` as `fptr2` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` as `fptr2.0` does not implement `Send`\n+   |                   in Rust 2018, this closure implements `Sync` as `fptr1` implements `Sync`, but in Rust 2021, this closure will no longer implement `Sync` because `fptr1` is not fully captured and `fptr1.0.0` does not implement `Sync`\n+   |                   in Rust 2018, this closure implements `Send` as `fptr1` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` because `fptr1` is not fully captured and `fptr1.0.0` does not implement `Send`\n+   |                   in Rust 2018, this closure implements `Send` as `fptr2` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` because `fptr2` is not fully captured and `fptr2.0` does not implement `Send`\n ...\n LL |         *fptr1.0.0 = 20;\n    |         ---------- in Rust 2018, this closure captures all of `fptr1`, but in Rust 2021, it will only capture `fptr1.0.0`"}, {"sha": "22792c11366ba3dda38e1d4102b264d8f2e661c9", "filename": "src/test/ui/extern/extern-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fextern%2Fextern-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fextern%2Fextern-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-methods.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-// only-i686\n+// only-x86\n \n trait A {\n     extern \"fastcall\" fn test1(i: i32);"}, {"sha": "717df57ec48485d2b57e56a729927dca03abfb38", "filename": "src/test/ui/extern/extern-thiscall.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fextern%2Fextern-thiscall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fextern%2Fextern-thiscall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-thiscall.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-// only-i686\n+// only-x86\n \n #![feature(abi_thiscall)]\n "}, {"sha": "a283573c9fbd11afa437bf2884445766af3ecdbb", "filename": "src/test/ui/extern/extern-vectorcall.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fextern%2Fextern-vectorcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Fextern%2Fextern-vectorcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-vectorcall.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -1,7 +1,7 @@\n // run-pass\n // revisions: x64 x32\n // [x64]only-x86_64\n-// [x32]only-i686\n+// [x32]only-x86\n \n #![feature(abi_vectorcall)]\n "}, {"sha": "425e2703c94c45dc3924fd99e4614089a097b9b5", "filename": "src/test/ui/lint/issue-90614-accept-allow-text-direction-codepoint-in-comment-lint.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Flint%2Fissue-90614-accept-allow-text-direction-codepoint-in-comment-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftest%2Fui%2Flint%2Fissue-90614-accept-allow-text-direction-codepoint-in-comment-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-90614-accept-allow-text-direction-codepoint-in-comment-lint.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+// Allowing the code lint should work without warning and\n+// the text flow char in the comment should be ignored.\n+\n+#![allow(text_direction_codepoint_in_comment)]\n+\n+fn main() {\n+    // U+2066 LEFT-TO-RIGHT ISOLATE follows:\u2066\u2066\n+}"}, {"sha": "157b42e2d17f5a52f3bfdb8870178c7a0f28c7ba", "filename": "src/tools/compiletest/src/header/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d32993afe81a49701edd6f2b8f018020ca50da1a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs?ref=d32993afe81a49701edd6f2b8f018020ca50da1a", "patch": "@@ -168,7 +168,7 @@ fn only_target() {\n     let mut config = config();\n     config.target = \"x86_64-pc-windows-gnu\".to_owned();\n \n-    assert!(check_ignore(&config, \"// only-i686\"));\n+    assert!(check_ignore(&config, \"// only-x86\"));\n     assert!(check_ignore(&config, \"// only-linux\"));\n     assert!(check_ignore(&config, \"// only-msvc\"));\n     assert!(check_ignore(&config, \"// only-32bit\"));"}]}