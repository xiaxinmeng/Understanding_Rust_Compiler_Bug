{"sha": "ab112cab03a119ff092100cd3e472c7de1968f0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiMTEyY2FiMDNhMTE5ZmYwOTIxMDBjZDNlNDcyYzdkZTE5NjhmMGI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-29T14:51:20Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-06T13:59:08Z"}, "message": "Improve documentation for built-in macros", "tree": {"sha": "c42f6e0ff97f7b29d3c739777a901e64983a5eff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c42f6e0ff97f7b29d3c739777a901e64983a5eff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab112cab03a119ff092100cd3e472c7de1968f0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab112cab03a119ff092100cd3e472c7de1968f0b", "html_url": "https://github.com/rust-lang/rust/commit/ab112cab03a119ff092100cd3e472c7de1968f0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab112cab03a119ff092100cd3e472c7de1968f0b/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22d6d8ac76d5b86601d09917b83789cf88ea043a", "url": "https://api.github.com/repos/rust-lang/rust/commits/22d6d8ac76d5b86601d09917b83789cf88ea043a", "html_url": "https://github.com/rust-lang/rust/commit/22d6d8ac76d5b86601d09917b83789cf88ea043a"}], "stats": {"total": 690, "additions": 614, "deletions": 76}, "files": [{"sha": "782627431cb567dc4058e205f4e4374ae76c11e0", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab112cab03a119ff092100cd3e472c7de1968f0b/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab112cab03a119ff092100cd3e472c7de1968f0b/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=ab112cab03a119ff092100cd3e472c7de1968f0b", "patch": "@@ -75,6 +75,7 @@\n #![feature(const_fn)]\n #![feature(const_fn_union)]\n #![feature(custom_inner_attributes)]\n+#![feature(decl_macro)]\n #![feature(doc_cfg)]\n #![feature(doc_spotlight)]\n #![feature(extern_types)]"}, {"sha": "33ffd84e521f297acfac98449c41aad78cde1b3b", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 613, "deletions": 76, "changes": 689, "blob_url": "https://github.com/rust-lang/rust/blob/ab112cab03a119ff092100cd3e472c7de1968f0b/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab112cab03a119ff092100cd3e472c7de1968f0b/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=ab112cab03a119ff092100cd3e472c7de1968f0b", "patch": "@@ -642,183 +642,720 @@ macro_rules! uninitialized_array {\n /// These macros do not have any corresponding definition with a `macro_rules!`\n /// macro, but are documented here. Their implementations can be found hardcoded\n /// into libsyntax itself.\n-///\n-/// For more information, see documentation for `std`'s macros.\n #[cfg(rustdoc)]\n mod builtin {\n \n     /// Causes compilation to fail with the given error message when encountered.\n     ///\n-    /// For more information, see the documentation for [`std::compile_error!`].\n+    /// This macro should be used when a crate uses a conditional compilation strategy to provide\n+    /// better error messages for erroneous conditions. It's the compiler-level form of [`panic!`],\n+    /// which emits an error at *runtime*, rather than during compilation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Two such examples are macros and `#[cfg]` environments.\n+    ///\n+    /// Emit better compiler error if a macro is passed invalid values. Without the final branch,\n+    /// the compiler would still emit an error, but the error's message would not mention the two\n+    /// valid values.\n+    ///\n+    /// ```compile_fail\n+    /// macro_rules! give_me_foo_or_bar {\n+    ///     (foo) => {};\n+    ///     (bar) => {};\n+    ///     ($x:ident) => {\n+    ///         compile_error!(\"This macro only accepts `foo` or `bar`\");\n+    ///     }\n+    /// }\n     ///\n-    /// [`std::compile_error!`]: ../std/macro.compile_error.html\n+    /// give_me_foo_or_bar!(neither);\n+    /// // ^ will fail at compile time with message \"This macro only accepts `foo` or `bar`\"\n+    /// ```\n+    ///\n+    /// Emit compiler error if one of a number of features isn't available.\n+    ///\n+    /// ```compile_fail\n+    /// #[cfg(not(any(feature = \"foo\", feature = \"bar\")))]\n+    /// compile_error!(\"Either feature \\\"foo\\\" or \\\"bar\\\" must be enabled for this crate.\");\n+    /// ```\n+    ///\n+    /// [`panic!`]: ../std/macro.panic.html\n     #[stable(feature = \"compile_error_macro\", since = \"1.20.0\")]\n     #[rustc_builtin_macro]\n-    macro_rules! compile_error {\n-        ($msg:expr) => ({ /* compiler built-in */ });\n-        ($msg:expr,) => ({ /* compiler built-in */ });\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro compile_error {\n+        ($msg:expr) => ({ /* compiler built-in */ }),\n+        ($msg:expr,) => ({ /* compiler built-in */ })\n     }\n \n     /// Constructs parameters for the other string-formatting macros.\n     ///\n-    /// For more information, see the documentation for [`std::format_args!`].\n+    /// This macro functions by taking a formatting string literal containing\n+    /// `{}` for each additional argument passed. `format_args!` prepares the\n+    /// additional parameters to ensure the output can be interpreted as a string\n+    /// and canonicalizes the arguments into a single type. Any value that implements\n+    /// the [`Display`] trait can be passed to `format_args!`, as can any\n+    /// [`Debug`] implementation be passed to a `{:?}` within the formatting string.\n+    ///\n+    /// This macro produces a value of type [`fmt::Arguments`]. This value can be\n+    /// passed to the macros within [`std::fmt`] for performing useful redirection.\n+    /// All other formatting macros ([`format!`], [`write!`], [`println!`], etc) are\n+    /// proxied through this one. `format_args!`, unlike its derived macros, avoids\n+    /// heap allocations.\n     ///\n-    /// [`std::format_args!`]: ../std/macro.format_args.html\n+    /// You can use the [`fmt::Arguments`] value that `format_args!` returns\n+    /// in `Debug` and `Display` contexts as seen below. The example also shows\n+    /// that `Debug` and `Display` format to the same thing: the interpolated\n+    /// format string in `format_args!`.\n+    ///\n+    /// ```rust\n+    /// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n+    /// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n+    /// assert_eq!(\"1 foo 2\", display);\n+    /// assert_eq!(display, debug);\n+    /// ```\n+    ///\n+    /// For more information, see the documentation in [`std::fmt`].\n+    ///\n+    /// [`Display`]: ../std/fmt/trait.Display.html\n+    /// [`Debug`]: ../std/fmt/trait.Debug.html\n+    /// [`fmt::Arguments`]: ../std/fmt/struct.Arguments.html\n+    /// [`std::fmt`]: ../std/fmt/index.html\n+    /// [`format!`]: ../std/macro.format.html\n+    /// [`write!`]: ../std/macro.write.html\n+    /// [`println!`]: ../std/macro.println.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n+    /// assert_eq!(s, format!(\"hello {}\", \"world\"));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(fmt_internals)]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro format_args {\n+        ($fmt:expr) => ({ /* compiler built-in */ }),\n+        ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+    }\n+\n+    /// Same as `format_args`, but adds a newline in the end.\n+    #[unstable(feature = \"format_args_nl\", issue = \"0\",\n+               reason = \"`format_args_nl` is only for internal \\\n+                         language use and is subject to change\")]\n+    #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n-    macro_rules! format_args {\n-        ($fmt:expr) => ({ /* compiler built-in */ });\n-        ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ });\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro format_args_nl {\n+        ($fmt:expr) => ({ /* compiler built-in */ }),\n+        ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n     }\n \n     /// Inspects an environment variable at compile time.\n     ///\n-    /// For more information, see the documentation for [`std::env!`].\n+    /// This macro will expand to the value of the named environment variable at\n+    /// compile time, yielding an expression of type `&'static str`.\n     ///\n-    /// [`std::env!`]: ../std/macro.env.html\n+    /// If the environment variable is not defined, then a compilation error\n+    /// will be emitted. To not emit a compile error, use the [`option_env!`]\n+    /// macro instead.\n+    ///\n+    /// [`option_env!`]: ../std/macro.option_env.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let path: &'static str = env!(\"PATH\");\n+    /// println!(\"the $PATH variable at the time of compiling was: {}\", path);\n+    /// ```\n+    ///\n+    /// You can customize the error message by passing a string as the second\n+    /// parameter:\n+    ///\n+    /// ```compile_fail\n+    /// let doc: &'static str = env!(\"documentation\", \"what's that?!\");\n+    /// ```\n+    ///\n+    /// If the `documentation` environment variable is not defined, you'll get\n+    /// the following error:\n+    ///\n+    /// ```text\n+    /// error: what's that?!\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    macro_rules! env {\n-        ($name:expr) => ({ /* compiler built-in */ });\n-        ($name:expr,) => ({ /* compiler built-in */ });\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro env {\n+        ($name:expr) => ({ /* compiler built-in */ }),\n+        ($name:expr,) => ({ /* compiler built-in */ })\n     }\n \n     /// Optionally inspects an environment variable at compile time.\n     ///\n-    /// For more information, see the documentation for [`std::option_env!`].\n+    /// If the named environment variable is present at compile time, this will\n+    /// expand into an expression of type `Option<&'static str>` whose value is\n+    /// `Some` of the value of the environment variable. If the environment\n+    /// variable is not present, then this will expand to `None`. See\n+    /// [`Option<T>`][option] for more information on this type.\n+    ///\n+    /// A compile time error is never emitted when using this macro regardless\n+    /// of whether the environment variable is present or not.\n+    ///\n+    /// [option]: ../std/option/enum.Option.html\n     ///\n-    /// [`std::option_env!`]: ../std/macro.option_env.html\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let key: Option<&'static str> = option_env!(\"SECRET_KEY\");\n+    /// println!(\"the secret key might be: {:?}\", key);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    macro_rules! option_env {\n-        ($name:expr) => ({ /* compiler built-in */ });\n-        ($name:expr,) => ({ /* compiler built-in */ });\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro option_env {\n+        ($name:expr) => ({ /* compiler built-in */ }),\n+        ($name:expr,) => ({ /* compiler built-in */ })\n     }\n \n     /// Concatenates identifiers into one identifier.\n     ///\n-    /// For more information, see the documentation for [`std::concat_idents!`].\n+    /// This macro takes any number of comma-separated identifiers, and\n+    /// concatenates them all into one, yielding an expression which is a new\n+    /// identifier. Note that hygiene makes it such that this macro cannot\n+    /// capture local variables. Also, as a general rule, macros are only\n+    /// allowed in item, statement or expression position. That means while\n+    /// you may use this macro for referring to existing variables, functions or\n+    /// modules etc, you cannot define a new one with it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(concat_idents)]\n+    ///\n+    /// # fn main() {\n+    /// fn foobar() -> u32 { 23 }\n+    ///\n+    /// let f = concat_idents!(foo, bar);\n+    /// println!(\"{}\", f());\n     ///\n-    /// [`std::concat_idents!`]: ../std/macro.concat_idents.html\n-    #[unstable(feature = \"concat_idents_macro\", issue = \"29599\")]\n+    /// // fn concat_idents!(new, fun, name) { } // not usable in this way!\n+    /// # }\n+    /// ```\n+    #[unstable(feature = \"concat_idents\", issue = \"29599\",\n+               reason = \"`concat_idents` is not stable enough for use and is subject to change\")]\n     #[rustc_builtin_macro]\n-    macro_rules! concat_idents {\n-        ($($e:ident),+) => ({ /* compiler built-in */ });\n-        ($($e:ident,)+) => ({ /* compiler built-in */ });\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro concat_idents {\n+        ($($e:ident),+) => ({ /* compiler built-in */ }),\n+        ($($e:ident,)+) => ({ /* compiler built-in */ })\n     }\n \n     /// Concatenates literals into a static string slice.\n     ///\n-    /// For more information, see the documentation for [`std::concat!`].\n+    /// This macro takes any number of comma-separated literals, yielding an\n+    /// expression of type `&'static str` which represents all of the literals\n+    /// concatenated left-to-right.\n     ///\n-    /// [`std::concat!`]: ../std/macro.concat.html\n+    /// Integer and floating point literals are stringified in order to be\n+    /// concatenated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = concat!(\"test\", 10, 'b', true);\n+    /// assert_eq!(s, \"test10btrue\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    macro_rules! concat {\n-        ($($e:expr),*) => ({ /* compiler built-in */ });\n-        ($($e:expr,)*) => ({ /* compiler built-in */ });\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro concat {\n+        ($($e:expr),*) => ({ /* compiler built-in */ }),\n+        ($($e:expr,)*) => ({ /* compiler built-in */ })\n     }\n \n     /// Expands to the line number on which it was invoked.\n     ///\n-    /// For more information, see the documentation for [`std::line!`].\n+    /// With [`column!`] and [`file!`], these macros provide debugging information for\n+    /// developers about the location within the source.\n+    ///\n+    /// The expanded expression has type `u32` and is 1-based, so the first line\n+    /// in each file evaluates to 1, the second to 2, etc. This is consistent\n+    /// with error messages by common compilers or popular editors.\n+    /// The returned line is *not necessarily* the line of the `line!` invocation itself,\n+    /// but rather the first macro invocation leading up to the invocation\n+    /// of the `line!` macro.\n+    ///\n+    /// [`column!`]: macro.column.html\n+    /// [`file!`]: macro.file.html\n     ///\n-    /// [`std::line!`]: ../std/macro.line.html\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let current_line = line!();\n+    /// println!(\"defined on line: {}\", current_line);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    macro_rules! line { () => ({ /* compiler built-in */ }) }\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro line() { /* compiler built-in */ }\n \n-    /// Expands to the column number on which it was invoked.\n+    /// Expands to the column number at which it was invoked.\n+    ///\n+    /// With [`line!`] and [`file!`], these macros provide debugging information for\n+    /// developers about the location within the source.\n+    ///\n+    /// The expanded expression has type `u32` and is 1-based, so the first column\n+    /// in each line evaluates to 1, the second to 2, etc. This is consistent\n+    /// with error messages by common compilers or popular editors.\n+    /// The returned column is *not necessarily* the line of the `column!` invocation itself,\n+    /// but rather the first macro invocation leading up to the invocation\n+    /// of the `column!` macro.\n     ///\n-    /// For more information, see the documentation for [`std::column!`].\n+    /// [`line!`]: macro.line.html\n+    /// [`file!`]: macro.file.html\n     ///\n-    /// [`std::column!`]: ../std/macro.column.html\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let current_col = column!();\n+    /// println!(\"defined on column: {}\", current_col);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    macro_rules! column { () => ({ /* compiler built-in */ }) }\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro column() { /* compiler built-in */ }\n \n-    /// Expands to the file name from which it was invoked.\n+    /// Same as `column`, but less likely to be shadowed.\n+    #[unstable(feature = \"__rust_unstable_column\", issue = \"0\",\n+               reason = \"internal implementation detail of the `column` macro\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro __rust_unstable_column() { /* compiler built-in */ }\n+\n+    /// Expands to the file name in which it was invoked.\n+    ///\n+    /// With [`line!`] and [`column!`], these macros provide debugging information for\n+    /// developers about the location within the source.\n+    ///\n+    ///\n+    /// The expanded expression has type `&'static str`, and the returned file\n+    /// is not the invocation of the `file!` macro itself, but rather the\n+    /// first macro invocation leading up to the invocation of the `file!`\n+    /// macro.\n     ///\n-    /// For more information, see the documentation for [`std::file!`].\n+    /// [`line!`]: macro.line.html\n+    /// [`column!`]: macro.column.html\n     ///\n-    /// [`std::file!`]: ../std/macro.file.html\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let this_file = file!();\n+    /// println!(\"defined in file: {}\", this_file);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    macro_rules! file { () => ({ /* compiler built-in */ }) }\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro file() { /* compiler built-in */ }\n \n     /// Stringifies its arguments.\n     ///\n-    /// For more information, see the documentation for [`std::stringify!`].\n+    /// This macro will yield an expression of type `&'static str` which is the\n+    /// stringification of all the tokens passed to the macro. No restrictions\n+    /// are placed on the syntax of the macro invocation itself.\n+    ///\n+    /// Note that the expanded results of the input tokens may change in the\n+    /// future. You should be careful if you rely on the output.\n+    ///\n+    /// # Examples\n     ///\n-    /// [`std::stringify!`]: ../std/macro.stringify.html\n+    /// ```\n+    /// let one_plus_one = stringify!(1 + 1);\n+    /// assert_eq!(one_plus_one, \"1 + 1\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    macro_rules! stringify { ($($t:tt)*) => ({ /* compiler built-in */ }) }\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro stringify($($t:tt)*) { /* compiler built-in */ }\n \n     /// Includes a utf8-encoded file as a string.\n     ///\n-    /// For more information, see the documentation for [`std::include_str!`].\n+    /// The file is located relative to the current file. (similarly to how\n+    /// modules are found)\n+    ///\n+    /// This macro will yield an expression of type `&'static str` which is the\n+    /// contents of the file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Assume there are two files in the same directory with the following\n+    /// contents:\n+    ///\n+    /// File 'spanish.in':\n+    ///\n+    /// ```text\n+    /// adi\u00f3s\n+    /// ```\n+    ///\n+    /// File 'main.rs':\n     ///\n-    /// [`std::include_str!`]: ../std/macro.include_str.html\n+    /// ```ignore (cannot-doctest-external-file-dependency)\n+    /// fn main() {\n+    ///     let my_str = include_str!(\"spanish.in\");\n+    ///     assert_eq!(my_str, \"adi\u00f3s\\n\");\n+    ///     print!(\"{}\", my_str);\n+    /// }\n+    /// ```\n+    ///\n+    /// Compiling 'main.rs' and running the resulting binary will print \"adi\u00f3s\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    macro_rules! include_str {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ });\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro include_str {\n+        ($file:expr) => ({ /* compiler built-in */ }),\n+        ($file:expr,) => ({ /* compiler built-in */ })\n     }\n \n     /// Includes a file as a reference to a byte array.\n     ///\n-    /// For more information, see the documentation for [`std::include_bytes!`].\n+    /// The file is located relative to the current file. (similarly to how\n+    /// modules are found)\n+    ///\n+    /// This macro will yield an expression of type `&'static [u8; N]` which is\n+    /// the contents of the file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Assume there are two files in the same directory with the following\n+    /// contents:\n+    ///\n+    /// File 'spanish.in':\n     ///\n-    /// [`std::include_bytes!`]: ../std/macro.include_bytes.html\n+    /// ```text\n+    /// adi\u00f3s\n+    /// ```\n+    ///\n+    /// File 'main.rs':\n+    ///\n+    /// ```ignore (cannot-doctest-external-file-dependency)\n+    /// fn main() {\n+    ///     let bytes = include_bytes!(\"spanish.in\");\n+    ///     assert_eq!(bytes, b\"adi\\xc3\\xb3s\\n\");\n+    ///     print!(\"{}\", String::from_utf8_lossy(bytes));\n+    /// }\n+    /// ```\n+    ///\n+    /// Compiling 'main.rs' and running the resulting binary will print \"adi\u00f3s\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    macro_rules! include_bytes {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ });\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro include_bytes {\n+        ($file:expr) => ({ /* compiler built-in */ }),\n+        ($file:expr,) => ({ /* compiler built-in */ })\n     }\n \n     /// Expands to a string that represents the current module path.\n     ///\n-    /// For more information, see the documentation for [`std::module_path!`].\n+    /// The current module path can be thought of as the hierarchy of modules\n+    /// leading back up to the crate root. The first component of the path\n+    /// returned is the name of the crate currently being compiled.\n+    ///\n+    /// # Examples\n     ///\n-    /// [`std::module_path!`]: ../std/macro.module_path.html\n+    /// ```\n+    /// mod test {\n+    ///     pub fn foo() {\n+    ///         assert!(module_path!().ends_with(\"test\"));\n+    ///     }\n+    /// }\n+    ///\n+    /// test::foo();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro module_path() { /* compiler built-in */ }\n \n-    /// Evaluates boolean combinations of configuration flags, at compile-time.\n+    /// Evaluates boolean combinations of configuration flags at compile-time.\n+    ///\n+    /// In addition to the `#[cfg]` attribute, this macro is provided to allow\n+    /// boolean expression evaluation of configuration flags. This frequently\n+    /// leads to less duplicated code.\n+    ///\n+    /// The syntax given to this macro is the same syntax as the [`cfg`]\n+    /// attribute.\n     ///\n-    /// For more information, see the documentation for [`std::cfg!`].\n+    /// [`cfg`]: ../reference/conditional-compilation.html#the-cfg-attribute\n     ///\n-    /// [`std::cfg!`]: ../std/macro.cfg.html\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let my_directory = if cfg!(windows) {\n+    ///     \"windows-specific-directory\"\n+    /// } else {\n+    ///     \"unix-directory\"\n+    /// };\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    macro_rules! cfg { ($($cfg:tt)*) => ({ /* compiler built-in */ }) }\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro cfg($($cfg:tt)*) { /* compiler built-in */ }\n \n     /// Parses a file as an expression or an item according to the context.\n     ///\n-    /// For more information, see the documentation for [`std::include!`].\n+    /// The file is located relative to the current file (similarly to how\n+    /// modules are found).\n+    ///\n+    /// Using this macro is often a bad idea, because if the file is\n+    /// parsed as an expression, it is going to be placed in the\n+    /// surrounding code unhygienically. This could result in variables\n+    /// or functions being different from what the file expected if\n+    /// there are variables or functions that have the same name in\n+    /// the current file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Assume there are two files in the same directory with the following\n+    /// contents:\n+    ///\n+    /// File 'monkeys.in':\n+    ///\n+    /// ```ignore (only-for-syntax-highlight)\n+    /// ['\ud83d\ude48', '\ud83d\ude4a', '\ud83d\ude49']\n+    ///     .iter()\n+    ///     .cycle()\n+    ///     .take(6)\n+    ///     .collect::<String>()\n+    /// ```\n     ///\n-    /// [`std::include!`]: ../std/macro.include.html\n+    /// File 'main.rs':\n+    ///\n+    /// ```ignore (cannot-doctest-external-file-dependency)\n+    /// fn main() {\n+    ///     let my_string = include!(\"monkeys.in\");\n+    ///     assert_eq!(\"\ud83d\ude48\ud83d\ude4a\ud83d\ude49\ud83d\ude48\ud83d\ude4a\ud83d\ude49\", my_string);\n+    ///     println!(\"{}\", my_string);\n+    /// }\n+    /// ```\n+    ///\n+    /// Compiling 'main.rs' and running the resulting binary will print\n+    /// \"\ud83d\ude48\ud83d\ude4a\ud83d\ude49\ud83d\ude48\ud83d\ude4a\ud83d\ude49\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    macro_rules! include {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ });\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro include {\n+        ($file:expr) => ({ /* compiler built-in */ }),\n+        ($file:expr,) => ({ /* compiler built-in */ })\n     }\n \n     /// Asserts that a boolean expression is `true` at runtime.\n     ///\n-    /// For more information, see the documentation for [`std::assert!`].\n+    /// This will invoke the [`panic!`] macro if the provided expression cannot be\n+    /// evaluated to `true` at runtime.\n     ///\n-    /// [`std::assert!`]: ../std/macro.assert.html\n-    #[rustc_builtin_macro]\n+    /// # Uses\n+    ///\n+    /// Assertions are always checked in both debug and release builds, and cannot\n+    /// be disabled. See [`debug_assert!`] for assertions that are not enabled in\n+    /// release builds by default.\n+    ///\n+    /// Unsafe code relies on `assert!` to enforce run-time invariants that, if\n+    /// violated could lead to unsafety.\n+    ///\n+    /// Other use-cases of `assert!` include testing and enforcing run-time\n+    /// invariants in safe code (whose violation cannot result in unsafety).\n+    ///\n+    /// # Custom Messages\n+    ///\n+    /// This macro has a second form, where a custom panic message can\n+    /// be provided with or without arguments for formatting. See [`std::fmt`]\n+    /// for syntax for this form.\n+    ///\n+    /// [`panic!`]: macro.panic.html\n+    /// [`debug_assert!`]: macro.debug_assert.html\n+    /// [`std::fmt`]: ../std/fmt/index.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// // the panic message for these assertions is the stringified value of the\n+    /// // expression given.\n+    /// assert!(true);\n+    ///\n+    /// fn some_computation() -> bool { true } // a very simple function\n+    ///\n+    /// assert!(some_computation());\n+    ///\n+    /// // assert with a custom message\n+    /// let x = true;\n+    /// assert!(x, \"x wasn't true!\");\n+    ///\n+    /// let a = 3; let b = 27;\n+    /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    macro_rules! assert {\n-        ($cond:expr) => ({ /* compiler built-in */ });\n-        ($cond:expr,) => ({ /* compiler built-in */ });\n-        ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ });\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro assert {\n+        ($cond:expr) => ({ /* compiler built-in */ }),\n+        ($cond:expr,) => ({ /* compiler built-in */ }),\n+        ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ })\n+    }\n+\n+    /// Inline assembly.\n+    #[unstable(feature = \"asm\", issue = \"29722\",\n+               reason = \"inline assembly is not stable enough for use and is subject to change\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro asm(\"assembly template\"\n+                  : $(\"output\"(operand),)*\n+                  : $(\"input\"(operand),)*\n+                  : $(\"clobbers\",)*\n+                  : $(\"options\",)*) { /* compiler built-in */ }\n+\n+    /// Module-level inline assembly.\n+    #[unstable(feature = \"global_asm\", issue = \"35119\",\n+               reason = \"`global_asm!` is not stable enough for use and is subject to change\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro global_asm(\"assembly\") { /* compiler built-in */ }\n+\n+    /// Prints passed tokens into the standard output.\n+    #[unstable(feature = \"log_syntax\", issue = \"29598\",\n+               reason = \"`log_syntax!` is not stable enough for use and is subject to change\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro log_syntax($($arg:tt)*) { /* compiler built-in */ }\n+\n+    /// Enables or disables tracing functionality used for debugging other macros.\n+    #[unstable(feature = \"trace_macros\", issue = \"29598\",\n+               reason = \"`trace_macros` is not stable enough for use and is subject to change\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro trace_macros {\n+        (true) => ({ /* compiler built-in */ }),\n+        (false) => ({ /* compiler built-in */ })\n     }\n+\n+    /// Attribute macro applied to a function to turn it into a unit test.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro test($item:item) { /* compiler built-in */ }\n+\n+    /// Attribute macro applied to a function to turn it into a benchmark test.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro bench($item:item) { /* compiler built-in */ }\n+\n+    /// An implementation detail of the `#[test]` and `#[bench]` macros.\n+    #[unstable(feature = \"custom_test_frameworks\", issue = \"50297\",\n+               reason = \"custom test frameworks are an unstable feature\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro test_case($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Clone`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n+    pub macro Clone($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Copy`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n+    pub macro Copy($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Debug`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro Debug($item:item) { /* compiler built-in */ }\n+\n+    /// Unstable implementation detail of the `rustc` compiler, do not use.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(\n+        since = \"1.0.0\",\n+        reason = \"derive(Decodable) is deprecated in favor of derive(RustcDecodable)\",\n+        suggestion = \"RustcDecodable\",\n+    )]\n+    #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n+    pub macro Decodable($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Default`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro Default($item:item) { /* compiler built-in */ }\n+\n+    /// Unstable implementation detail of the `rustc` compiler, do not use.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(\n+        since = \"1.0.0\",\n+        reason = \"derive(Encodable) is deprecated in favor of derive(RustcEncodable)\",\n+        suggestion = \"RustcEncodable\",\n+    )]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro Encodable($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Eq`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics, derive_eq)]\n+    pub macro Eq($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Hash`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro Hash($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Ord`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro Ord($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `PartialEq`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro PartialEq($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `PartialOrd`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro PartialOrd($item:item) { /* compiler built-in */ }\n+\n+    /// Unstable implementation detail of the `rustc` compiler, do not use.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n+    pub macro RustcDecodable($item:item) { /* compiler built-in */ }\n+\n+    /// Unstable implementation detail of the `rustc` compiler, do not use.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro RustcEncodable($item:item) { /* compiler built-in */ }\n }"}]}