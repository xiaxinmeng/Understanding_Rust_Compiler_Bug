{"sha": "5d6aeb9799c4e459807f36f9acfdfe56016c87be", "node_id": "C_kwDOAAsO6NoAKDVkNmFlYjk3OTljNGU0NTk4MDdmMzZmOWFjZmRmZTU2MDE2Yzg3YmU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-12T20:04:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-12T20:04:34Z"}, "message": "Rollup merge of #110133 - compiler-errors:issue-110131, r=petrochenkov\n\nDo not use ImplDerivedObligationCause for inherent impl method error reporting\n\nWe were constructing a `TraitRef` out of impl substs, for an *inherent* impl that has no corresponding trait. Instead of doing that, let's construct a meaningful obligation cause code, and instead adjust the error reporting machinery to handle that correctly.\n\nFixes #110131\ncc #106702, which introduced this regression", "tree": {"sha": "46a7cc54d2c932386df9d907b2d60373de242b01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46a7cc54d2c932386df9d907b2d60373de242b01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d6aeb9799c4e459807f36f9acfdfe56016c87be", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkNw7SCRBK7hj4Ov3rIwAAF/oIALEop56h28oX/4D2UN5nC6LF\nWaU6tjPaSLqP0JeNQHMSMJ5c2FfLb4xVo2cQq4gJEEf0CzfIMiorQXZ4CyKO9Any\n/U9sedNEjz6SOkb6OcggBLKeshxHa1J1rFniZeQ6u9w+p+YO7CgdJM2hAtEm8Y9t\nQWzZ9SqHHKo0WucDLJxS9h7zn62cOwXG7u66hRqg/3QqoCApZIBLkxrj+2L0rrOo\nrulv6873B+AxmsenlAf8aWEsGqvkhOXYdfn5PdBcdQI+0vhB2wviDRo2zu4Gb0no\njz/mDMwDeseUoOUSFF8A3lce30YGvyNJ4+xo/dMIJbXfQN+KzHnH4mp2ijc2JFI=\n=h18Z\n-----END PGP SIGNATURE-----\n", "payload": "tree 46a7cc54d2c932386df9d907b2d60373de242b01\nparent c47937d32cb877003098e498490911e8070692b9\nparent b369c8ecbde710ab23977137c71b3c974a94d445\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1681329874 +0200\ncommitter GitHub <noreply@github.com> 1681329874 +0200\n\nRollup merge of #110133 - compiler-errors:issue-110131, r=petrochenkov\n\nDo not use ImplDerivedObligationCause for inherent impl method error reporting\n\nWe were constructing a `TraitRef` out of impl substs, for an *inherent* impl that has no corresponding trait. Instead of doing that, let's construct a meaningful obligation cause code, and instead adjust the error reporting machinery to handle that correctly.\n\nFixes #110131\ncc #106702, which introduced this regression\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d6aeb9799c4e459807f36f9acfdfe56016c87be", "html_url": "https://github.com/rust-lang/rust/commit/5d6aeb9799c4e459807f36f9acfdfe56016c87be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d6aeb9799c4e459807f36f9acfdfe56016c87be/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c47937d32cb877003098e498490911e8070692b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c47937d32cb877003098e498490911e8070692b9", "html_url": "https://github.com/rust-lang/rust/commit/c47937d32cb877003098e498490911e8070692b9"}, {"sha": "b369c8ecbde710ab23977137c71b3c974a94d445", "url": "https://api.github.com/repos/rust-lang/rust/commits/b369c8ecbde710ab23977137c71b3c974a94d445", "html_url": "https://github.com/rust-lang/rust/commit/b369c8ecbde710ab23977137c71b3c974a94d445"}], "stats": {"total": 159, "additions": 124, "deletions": 35}, "files": [{"sha": "4fd778910bacbc53611eb21553cc7c8f6e1e3c11", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5d6aeb9799c4e459807f36f9acfdfe56016c87be/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d6aeb9799c4e459807f36f9acfdfe56016c87be/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=5d6aeb9799c4e459807f36f9acfdfe56016c87be", "patch": "@@ -1531,23 +1531,18 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n                     // Convert the bounds into obligations.\n                     let impl_obligations = traits::predicates_for_generics(\n-                        |_idx, span| {\n-                            let misc = traits::ObligationCause::misc(span, self.body_id);\n-                            let parent_trait_pred = ty::Binder::dummy(ty::TraitPredicate {\n-                                trait_ref: ty::TraitRef::from_method(self.tcx, impl_def_id, substs),\n-                                constness: ty::BoundConstness::NotConst,\n-                                polarity: ty::ImplPolarity::Positive,\n-                            });\n-                            misc.derived_cause(parent_trait_pred, |derived| {\n-                                traits::ImplDerivedObligation(Box::new(\n-                                    traits::ImplDerivedObligationCause {\n-                                        derived,\n-                                        impl_or_alias_def_id: impl_def_id,\n-                                        impl_def_predicate_index: None,\n-                                        span,\n-                                    },\n-                                ))\n-                            })\n+                        |idx, span| {\n+                            let code = if span.is_dummy() {\n+                                traits::ExprItemObligation(impl_def_id, self.scope_expr_id, idx)\n+                            } else {\n+                                traits::ExprBindingObligation(\n+                                    impl_def_id,\n+                                    span,\n+                                    self.scope_expr_id,\n+                                    idx,\n+                                )\n+                            };\n+                            ObligationCause::new(self.span, self.body_id, code)\n                         },\n                         self.param_env,\n                         impl_bounds,"}, {"sha": "6e77c7281074fcb769575f07aeaf135d123d773b", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5d6aeb9799c4e459807f36f9acfdfe56016c87be/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d6aeb9799c4e459807f36f9acfdfe56016c87be/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=5d6aeb9799c4e459807f36f9acfdfe56016c87be", "patch": "@@ -661,19 +661,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Find all the requirements that come from a local `impl` block.\n             let mut skip_list: FxHashSet<_> = Default::default();\n             let mut spanned_predicates = FxHashMap::default();\n-            for (p, parent_p, impl_def_id, cause) in unsatisfied_predicates\n-                .iter()\n-                .filter_map(|(p, parent, c)| c.as_ref().map(|c| (p, parent, c)))\n-                .filter_map(|(p, parent, c)| match c.code() {\n-                    ObligationCauseCode::ImplDerivedObligation(data)\n-                        if matches!(p.kind().skip_binder(), ty::PredicateKind::Clause(_)) =>\n-                    {\n-                        Some((p, parent, data.impl_or_alias_def_id, data))\n+            for (p, parent_p, cause) in unsatisfied_predicates {\n+                // Extract the predicate span and parent def id of the cause,\n+                // if we have one.\n+                let (item_def_id, cause_span) = match cause.as_ref().map(|cause| cause.code()) {\n+                    Some(ObligationCauseCode::ImplDerivedObligation(data)) => {\n+                        (data.impl_or_alias_def_id, data.span)\n                     }\n-                    _ => None,\n-                })\n-            {\n-                match self.tcx.hir().get_if_local(impl_def_id) {\n+                    Some(\n+                        ObligationCauseCode::ExprBindingObligation(def_id, span, _, _)\n+                        | ObligationCauseCode::BindingObligation(def_id, span),\n+                    ) => (*def_id, *span),\n+                    _ => continue,\n+                };\n+\n+                // Don't point out the span of `WellFormed` predicates.\n+                if !matches!(p.kind().skip_binder(), ty::PredicateKind::Clause(_)) {\n+                    continue;\n+                };\n+\n+                match self.tcx.hir().get_if_local(item_def_id) {\n                     // Unmet obligation comes from a `derive` macro, point at it once to\n                     // avoid multiple span labels pointing at the same place.\n                     Some(Node::Item(hir::Item {\n@@ -718,7 +725,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 }\n                             });\n                         for param in generics.params {\n-                            if param.span == cause.span && sized_pred {\n+                            if param.span == cause_span && sized_pred {\n                                 let (sp, sugg) = match param.colon_span {\n                                     Some(sp) => (sp.shrink_to_hi(), \" ?Sized +\"),\n                                     None => (param.span.shrink_to_hi(), \": ?Sized\"),\n@@ -741,9 +748,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             (FxHashSet::default(), FxHashSet::default(), Vec::new())\n                         });\n                         entry.2.push(p);\n-                        if cause.span != *item_span {\n-                            entry.0.insert(cause.span);\n-                            entry.1.insert((cause.span, \"unsatisfied trait bound introduced here\"));\n+                        if cause_span != *item_span {\n+                            entry.0.insert(cause_span);\n+                            entry.1.insert((cause_span, \"unsatisfied trait bound introduced here\"));\n                         } else {\n                             if let Some(trait_ref) = of_trait {\n                                 entry.0.insert(trait_ref.path.span);\n@@ -775,9 +782,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let entry = entry.or_insert_with(|| {\n                             (FxHashSet::default(), FxHashSet::default(), Vec::new())\n                         });\n-                        entry.0.insert(cause.span);\n+                        entry.0.insert(cause_span);\n                         entry.1.insert((ident.span, \"\"));\n-                        entry.1.insert((cause.span, \"unsatisfied trait bound introduced here\"));\n+                        entry.1.insert((cause_span, \"unsatisfied trait bound introduced here\"));\n                         entry.2.push(p);\n                     }\n                     Some(node) => unreachable!(\"encountered `{node:?}`\"),"}, {"sha": "81a99ca010e5d2e33f677fc0e0a5b305d102fd23", "filename": "tests/ui/methods/inherent-bound-in-probe.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5d6aeb9799c4e459807f36f9acfdfe56016c87be/tests%2Fui%2Fmethods%2Finherent-bound-in-probe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d6aeb9799c4e459807f36f9acfdfe56016c87be/tests%2Fui%2Fmethods%2Finherent-bound-in-probe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Finherent-bound-in-probe.rs?ref=5d6aeb9799c4e459807f36f9acfdfe56016c87be", "patch": "@@ -0,0 +1,49 @@\n+// normalize-stderr-test: \"long-type-\\d+\" -> \"long-type-hash\"\n+\n+// Fixes #110131\n+//\n+// The issue is that we were constructing an `ImplDerived` cause code for the\n+// `&'a T: IntoIterator<Item = &'a u8>` obligation for `Helper::new`, which is\n+// incorrect because derived obligations are only expected to come from *traits*.\n+\n+struct SeqBuffer<'a, T>\n+where\n+    &'a T: IntoIterator<Item = &'a u8>,\n+{\n+    iter: <&'a T as IntoIterator>::IntoIter,\n+}\n+\n+struct Helper<'a, T>\n+where\n+    &'a T: IntoIterator<Item = &'a u8>,\n+{\n+    buf: SeqBuffer<'a, T>,\n+}\n+\n+impl<'a, T> Helper<'a, T>\n+where\n+    &'a T: IntoIterator<Item = &'a u8>,\n+{\n+    fn new(sq: &'a T) -> Self {\n+        loop {}\n+    }\n+}\n+\n+struct BitReaderWrapper<T>(T);\n+\n+impl<'a, T> IntoIterator for &'a BitReaderWrapper<T>\n+where\n+    &'a T: IntoIterator<Item = &'a u8>,\n+{\n+    type Item = u32;\n+\n+    type IntoIter = Helper<'a, T>;\n+    //~^ ERROR `Helper<'a, T>` is not an iterator\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        Helper::new(&self.0)\n+        //~^ ERROR overflow evaluating the requirement `&_: IntoIterator`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ff03a7edb05425642d3e4958510501b5fa2607ea", "filename": "tests/ui/methods/inherent-bound-in-probe.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5d6aeb9799c4e459807f36f9acfdfe56016c87be/tests%2Fui%2Fmethods%2Finherent-bound-in-probe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5d6aeb9799c4e459807f36f9acfdfe56016c87be/tests%2Fui%2Fmethods%2Finherent-bound-in-probe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Finherent-bound-in-probe.stderr?ref=5d6aeb9799c4e459807f36f9acfdfe56016c87be", "patch": "@@ -0,0 +1,38 @@\n+error[E0277]: `Helper<'a, T>` is not an iterator\n+  --> $DIR/inherent-bound-in-probe.rs:40:21\n+   |\n+LL |     type IntoIter = Helper<'a, T>;\n+   |                     ^^^^^^^^^^^^^ `Helper<'a, T>` is not an iterator\n+   |\n+   = help: the trait `Iterator` is not implemented for `Helper<'a, T>`\n+note: required by a bound in `std::iter::IntoIterator::IntoIter`\n+  --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+\n+error[E0275]: overflow evaluating the requirement `&_: IntoIterator`\n+  --> $DIR/inherent-bound-in-probe.rs:44:17\n+   |\n+LL |         Helper::new(&self.0)\n+   |                 ^^^\n+   |\n+   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`inherent_bound_in_probe`)\n+note: required for `&BitReaderWrapper<_>` to implement `IntoIterator`\n+  --> $DIR/inherent-bound-in-probe.rs:34:13\n+   |\n+LL | impl<'a, T> IntoIterator for &'a BitReaderWrapper<T>\n+   |             ^^^^^^^^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^\n+LL | where\n+LL |     &'a T: IntoIterator<Item = &'a u8>,\n+   |                         ------------- unsatisfied trait bound introduced here\n+   = note: 126 redundant requirements hidden\n+   = note: required for `&BitReaderWrapper<BitReaderWrapper<BitReaderWrapper<BitReaderWrapper<BitReaderWrapper<...>>>>>` to implement `IntoIterator`\n+   = note: the full type name has been written to '$TEST_BUILD_DIR/methods/inherent-bound-in-probe/inherent-bound-in-probe.long-type-hash.txt'\n+note: required by a bound in `Helper<'a, T>`\n+  --> $DIR/inherent-bound-in-probe.rs:25:25\n+   |\n+LL |     &'a T: IntoIterator<Item = &'a u8>,\n+   |                         ^^^^^^^^^^^^^ required by this bound in `Helper<'a, T>`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0275, E0277.\n+For more information about an error, try `rustc --explain E0275`."}]}