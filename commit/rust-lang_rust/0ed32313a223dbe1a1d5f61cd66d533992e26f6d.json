{"sha": "0ed32313a223dbe1a1d5f61cd66d533992e26f6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlZDMyMzEzYTIyM2RiZTFhMWQ1ZjYxY2Q2NmQ1MzM5OTJlMjZmNmQ=", "commit": {"author": {"name": "Jorge Aparicio", "email": "jorge@japaric.io", "date": "2018-07-05T21:44:13Z"}, "committer": {"name": "Jorge Aparicio", "email": "jorge@japaric.io", "date": "2018-07-05T21:52:46Z"}, "message": "#[cfg(target_has_atomic_cas)] -> #[cfg(target_has_atomic = \"cas\")]", "tree": {"sha": "7fc70f68da53f422210720afc4a3a0c0dd291c6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fc70f68da53f422210720afc4a3a0c0dd291c6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ed32313a223dbe1a1d5f61cd66d533992e26f6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ed32313a223dbe1a1d5f61cd66d533992e26f6d", "html_url": "https://github.com/rust-lang/rust/commit/0ed32313a223dbe1a1d5f61cd66d533992e26f6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ed32313a223dbe1a1d5f61cd66d533992e26f6d/comments", "author": {"login": "japaric", "id": 5018213, "node_id": "MDQ6VXNlcjUwMTgyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5018213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/japaric", "html_url": "https://github.com/japaric", "followers_url": "https://api.github.com/users/japaric/followers", "following_url": "https://api.github.com/users/japaric/following{/other_user}", "gists_url": "https://api.github.com/users/japaric/gists{/gist_id}", "starred_url": "https://api.github.com/users/japaric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/japaric/subscriptions", "organizations_url": "https://api.github.com/users/japaric/orgs", "repos_url": "https://api.github.com/users/japaric/repos", "events_url": "https://api.github.com/users/japaric/events{/privacy}", "received_events_url": "https://api.github.com/users/japaric/received_events", "type": "User", "site_admin": false}, "committer": {"login": "japaric", "id": 5018213, "node_id": "MDQ6VXNlcjUwMTgyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5018213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/japaric", "html_url": "https://github.com/japaric", "followers_url": "https://api.github.com/users/japaric/followers", "following_url": "https://api.github.com/users/japaric/following{/other_user}", "gists_url": "https://api.github.com/users/japaric/gists{/gist_id}", "starred_url": "https://api.github.com/users/japaric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/japaric/subscriptions", "organizations_url": "https://api.github.com/users/japaric/orgs", "repos_url": "https://api.github.com/users/japaric/repos", "events_url": "https://api.github.com/users/japaric/events{/privacy}", "received_events_url": "https://api.github.com/users/japaric/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbf688a84de7001d033764b848a50cbad42f3d5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbf688a84de7001d033764b848a50cbad42f3d5a", "html_url": "https://github.com/rust-lang/rust/commit/bbf688a84de7001d033764b848a50cbad42f3d5a"}], "stats": {"total": 67, "additions": 34, "deletions": 33}, "files": [{"sha": "35bf8d1b792f9605aa5c4764e154c5e92bbce165", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ed32313a223dbe1a1d5f61cd66d533992e26f6d/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed32313a223dbe1a1d5f61cd66d533992e26f6d/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=0ed32313a223dbe1a1d5f61cd66d533992e26f6d", "patch": "@@ -86,7 +86,6 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(cfg_target_has_atomic)]\n-#![cfg_attr(not(stage0), feature(cfg_target_has_atomic_cas))]\n #![feature(coerce_unsized)]\n #![feature(collections_range)]\n #![feature(const_fn)]\n@@ -163,8 +162,10 @@ mod boxed {\n #[cfg(test)]\n mod boxed_test;\n pub mod collections;\n-#[cfg_attr(stage0, cfg(target_has_atomic = \"ptr\"))]\n-#[cfg_attr(not(stage0), cfg(all(target_has_atomic = \"ptr\", target_has_atomic_cas)))]\n+#[cfg(any(\n+    all(stage0, target_has_atomic = \"ptr\"),\n+    all(not(stage0), target_has_atomic = \"ptr\", target_has_atomic = \"cas\")\n+))]\n pub mod sync;\n pub mod rc;\n pub mod raw_vec;"}, {"sha": "9792d52dd66d26c658bc5e3fbcb380f0f5022081", "filename": "src/liballoc/task.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0ed32313a223dbe1a1d5f61cd66d533992e26f6d/src%2Fliballoc%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed32313a223dbe1a1d5f61cd66d533992e26f6d/src%2Fliballoc%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftask.rs?ref=0ed32313a223dbe1a1d5f61cd66d533992e26f6d", "patch": "@@ -12,12 +12,16 @@\n \n pub use core::task::*;\n \n-#[cfg_attr(stage0, cfg(target_has_atomic = \"ptr\"))]\n-#[cfg_attr(not(stage0), cfg(all(target_has_atomic = \"ptr\", target_has_atomic_cas)))]\n+#[cfg(any(\n+    all(stage0, target_has_atomic = \"ptr\"),\n+    all(not(stage0), target_has_atomic = \"ptr\", target_has_atomic = \"cas\")\n+))]\n pub use self::if_arc::*;\n \n-#[cfg_attr(stage0, cfg(target_has_atomic = \"ptr\"))]\n-#[cfg_attr(not(stage0), cfg(all(target_has_atomic = \"ptr\", target_has_atomic_cas)))]\n+#[cfg(any(\n+    all(stage0, target_has_atomic = \"ptr\"),\n+    all(not(stage0), target_has_atomic = \"ptr\", target_has_atomic = \"cas\")\n+))]\n mod if_arc {\n     use super::*;\n     use core::marker::PhantomData;\n@@ -49,8 +53,10 @@ mod if_arc {\n         }\n     }\n \n-    #[cfg_attr(stage0, cfg(target_has_atomic = \"ptr\"))]\n-    #[cfg_attr(not(stage0), cfg(all(target_has_atomic = \"ptr\", target_has_atomic_cas)))]\n+    #[cfg(any(\n+        all(stage0, target_has_atomic = \"ptr\"),\n+        all(not(stage0), target_has_atomic = \"ptr\", target_has_atomic = \"cas\")\n+    ))]\n     struct ArcWrapped<T>(PhantomData<T>);\n \n     unsafe impl<T: Wake + 'static> UnsafeWake for ArcWrapped<T> {"}, {"sha": "b2b38820a89ccd2982cbb8664410a744c41dbfeb", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ed32313a223dbe1a1d5f61cd66d533992e26f6d/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed32313a223dbe1a1d5f61cd66d533992e26f6d/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=0ed32313a223dbe1a1d5f61cd66d533992e26f6d", "patch": "@@ -79,7 +79,6 @@\n #![feature(associated_type_defaults)]\n #![feature(attr_literals)]\n #![feature(cfg_target_has_atomic)]\n-#![cfg_attr(not(stage0), feature(cfg_target_has_atomic_cas))]\n #![feature(concat_idents)]\n #![feature(const_fn)]\n #![feature(const_int_ops)]"}, {"sha": "e9d1fb89115041c858b8b88b18310eda7c478046", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0ed32313a223dbe1a1d5f61cd66d533992e26f6d/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed32313a223dbe1a1d5f61cd66d533992e26f6d/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=0ed32313a223dbe1a1d5f61cd66d533992e26f6d", "patch": "@@ -371,7 +371,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg_attr(not(stage0), cfg(target_has_atomic_cas))]\n+    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -402,7 +402,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg_attr(not(stage0), cfg(target_has_atomic_cas))]\n+    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n     pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n             Ok(x) => x,\n@@ -448,7 +448,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg_attr(not(stage0), cfg(target_has_atomic_cas))]\n+    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n     pub fn compare_exchange(&self,\n                             current: bool,\n                             new: bool,\n@@ -540,7 +540,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg_attr(not(stage0), cfg(target_has_atomic_cas))]\n+    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_and(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -572,7 +572,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg_attr(not(stage0), cfg(target_has_atomic_cas))]\n+    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n     pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n         // We can't use atomic_nand here because it can result in a bool with\n         // an invalid value. This happens because the atomic operation is done\n@@ -615,7 +615,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg_attr(not(stage0), cfg(target_has_atomic_cas))]\n+    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_or(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -646,7 +646,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg_attr(not(stage0), cfg(target_has_atomic_cas))]\n+    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -793,7 +793,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg_attr(not(stage0), cfg(target_has_atomic_cas))]\n+    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n     }\n@@ -823,7 +823,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg_attr(not(stage0), cfg(target_has_atomic_cas))]\n+    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n     pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n             Ok(x) => x,\n@@ -862,7 +862,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg_attr(not(stage0), cfg(target_has_atomic_cas))]\n+    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n     pub fn compare_exchange(&self,\n                             current: *mut T,\n                             new: *mut T,\n@@ -1148,7 +1148,7 @@ assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg_attr(not(stage0), cfg(target_has_atomic_cas))]\n+                #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n                 pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_swap(self.v.get(), val, order) }\n                 }\n@@ -1181,7 +1181,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg_attr(not(stage0), cfg(target_has_atomic_cas))]\n+                #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n                 pub fn compare_and_swap(&self,\n                                         current: $int_type,\n                                         new: $int_type,\n@@ -1235,7 +1235,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\"),\n                 #[inline]\n                 #[$stable_cxchg]\n-                #[cfg_attr(not(stage0), cfg(target_has_atomic_cas))]\n+                #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n                 pub fn compare_exchange(&self,\n                                         current: $int_type,\n                                         new: $int_type,\n@@ -1690,7 +1690,7 @@ atomic_int!{\n }\n \n #[inline]\n-#[cfg_attr(not(stage0), cfg(target_has_atomic_cas))]\n+#[cfg(any(stage0, target_has_atomic = \"cas\"))]\n fn strongest_failure_ordering(order: Ordering) -> Ordering {\n     match order {\n         Release => Relaxed,\n@@ -1727,7 +1727,7 @@ unsafe fn atomic_load<T>(dst: *const T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg_attr(not(stage0), cfg(target_has_atomic_cas))]\n+#[cfg(any(stage0, target_has_atomic = \"cas\"))]\n unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n@@ -1766,7 +1766,7 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg_attr(not(stage0), cfg(target_has_atomic_cas))]\n+#[cfg(any(stage0, target_has_atomic = \"cas\"))]\n unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n                                      old: T,\n                                      new: T,"}, {"sha": "342799d41bb56b872e87febb755fe33d1e082011", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ed32313a223dbe1a1d5f61cd66d533992e26f6d/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed32313a223dbe1a1d5f61cd66d533992e26f6d/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=0ed32313a223dbe1a1d5f61cd66d533992e26f6d", "patch": "@@ -1408,7 +1408,7 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n         }\n     }\n     if atomic_cas {\n-        ret.insert((Symbol::intern(\"target_has_atomic_cas\"), None));\n+        ret.insert((Symbol::intern(\"target_has_atomic\"), Some(Symbol::intern(\"cas\"))));\n     }\n     if sess.opts.debug_assertions {\n         ret.insert((Symbol::intern(\"debug_assertions\"), None));"}, {"sha": "3ac4c459c63841dcbff1eafea39f8c2e6c4e783b", "filename": "src/librustc_target/spec/msp430_none_elf.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ed32313a223dbe1a1d5f61cd66d533992e26f6d/src%2Flibrustc_target%2Fspec%2Fmsp430_none_elf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed32313a223dbe1a1d5f61cd66d533992e26f6d/src%2Flibrustc_target%2Fspec%2Fmsp430_none_elf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmsp430_none_elf.rs?ref=0ed32313a223dbe1a1d5f61cd66d533992e26f6d", "patch": "@@ -37,7 +37,6 @@ pub fn target() -> TargetResult {\n             // There are no atomic CAS instructions available in the MSP430\n             // instruction set\n             max_atomic_width: Some(16),\n-\n             atomic_cas: false,\n \n             // Because these devices have very little resources having an"}, {"sha": "26812501814f535b863a24fbea689124de91ab27", "filename": "src/librustc_target/spec/thumbv6m_none_eabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ed32313a223dbe1a1d5f61cd66d533992e26f6d/src%2Flibrustc_target%2Fspec%2Fthumbv6m_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed32313a223dbe1a1d5f61cd66d533992e26f6d/src%2Flibrustc_target%2Fspec%2Fthumbv6m_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fthumbv6m_none_eabi.rs?ref=0ed32313a223dbe1a1d5f61cd66d533992e26f6d", "patch": "@@ -29,7 +29,7 @@ pub fn target() -> TargetResult {\n             // The ARMv6-M architecture doesn't support unaligned loads/stores so we disable them\n             // with +strict-align.\n             features: \"+strict-align\".to_string(),\n-            // There are no atomic instructions available in the instruction set of the ARMv6-M\n+            // There are no atomic CAS instructions available in the instruction set of the ARMv6-M\n             // architecture\n             atomic_cas: false,\n             .. super::thumb_base::opts()"}, {"sha": "2ae0e669fd031a3c0282c22f9f87c7b3ca63befd", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ed32313a223dbe1a1d5f61cd66d533992e26f6d/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed32313a223dbe1a1d5f61cd66d533992e26f6d/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=0ed32313a223dbe1a1d5f61cd66d533992e26f6d", "patch": "@@ -479,9 +479,6 @@ declare_features! (\n \n     // Allows async and await syntax\n     (active, async_await, \"1.28.0\", Some(50547), None),\n-\n-    // Allows async and await syntax\n-    (active, cfg_target_has_atomic_cas, \"1.28.0\", Some(0), None),\n );\n \n declare_features! (\n@@ -1102,7 +1099,6 @@ const GATED_CFGS: &[(&str, &str, fn(&Features) -> bool)] = &[\n     (\"target_vendor\", \"cfg_target_vendor\", cfg_fn!(cfg_target_vendor)),\n     (\"target_thread_local\", \"cfg_target_thread_local\", cfg_fn!(cfg_target_thread_local)),\n     (\"target_has_atomic\", \"cfg_target_has_atomic\", cfg_fn!(cfg_target_has_atomic)),\n-    (\"target_has_atomic_cas\", \"cfg_target_has_atomic_cas\", cfg_fn!(cfg_target_has_atomic_cas)),\n ];\n \n #[derive(Debug, Eq, PartialEq)]"}]}