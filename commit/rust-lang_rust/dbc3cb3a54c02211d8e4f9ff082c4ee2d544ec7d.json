{"sha": "dbc3cb3a54c02211d8e4f9ff082c4ee2d544ec7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYzNjYjNhNTRjMDIyMTFkOGU0ZjlmZjA4MmM0ZWUyZDU0NGVjN2Q=", "commit": {"author": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2014-07-01T13:10:22Z"}, "committer": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2014-09-14T19:35:48Z"}, "message": "Add support for in-place map for `Vec`s of types with same size\n\nThis is implemented using a new struct `PartialVec` which implements the proper\ndrop semantics in case the conversion is interrupted by an unwind.", "tree": {"sha": "3102fbb0e62625cc31092cbd3bf51d66b82ed2cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3102fbb0e62625cc31092cbd3bf51d66b82ed2cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbc3cb3a54c02211d8e4f9ff082c4ee2d544ec7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc3cb3a54c02211d8e4f9ff082c4ee2d544ec7d", "html_url": "https://github.com/rust-lang/rust/commit/dbc3cb3a54c02211d8e4f9ff082c4ee2d544ec7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbc3cb3a54c02211d8e4f9ff082c4ee2d544ec7d/comments", "author": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21d1f4d7c0e637d8ae073798e666b880d31781b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/21d1f4d7c0e637d8ae073798e666b880d31781b1", "html_url": "https://github.com/rust-lang/rust/commit/21d1f4d7c0e637d8ae073798e666b880d31781b1"}], "stats": {"total": 258, "additions": 258, "deletions": 0}, "files": [{"sha": "96592798f7a1b65a025860189fea2c5353932915", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cb3a54c02211d8e4f9ff082c4ee2d544ec7d/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cb3a54c02211d8e4f9ff082c4ee2d544ec7d/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=dbc3cb3a54c02211d8e4f9ff082c4ee2d544ec7d", "patch": "@@ -1710,6 +1710,252 @@ pub mod raw {\n     }\n }\n \n+// TODO: Find some way to statically assert that `T` and `U` have the same\n+// size.\n+//\n+/// An owned, partially type-converted vector.\n+///\n+/// No allocations are performed by usage, only a deallocation happens in the\n+/// destructor which should only run when unwinding.\n+///\n+/// It can be used to convert a vector of `T`s into a vector of `U`s, by\n+/// converting the individual elements one-by-one.\n+///\n+/// You may call the `push` method as often as you get a `Some(t)` from `pop`.\n+/// After pushing the same number of `U`s as you got `T`s, you can `unwrap` the\n+/// vector.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// let pv = PartialVec::new(vec![0u, 1]);\n+/// assert_eq!(pv.pop(), Some(0));\n+/// assert_eq!(pv.pop(), Some(1));\n+/// assert_eq!(pv.pop(), None);\n+/// pv.push(2u);\n+/// pv.push(3);\n+/// assert_eq!(pv.unwrap(), vec![2, 3]);\n+/// ```\n+//\n+// Upheld invariants:\n+//\n+// (a) `vec` isn't modified except when the `PartialVec` goes out of scope, the\n+//     only thing it is used for is keeping the memory which the `PartialVec`\n+//     uses for the inplace conversion.\n+//\n+// (b) `start_u` points to the start of the vector.\n+//\n+// (c) `end_u` points to one element beyond the vector.\n+//\n+// (d) `start_u` <= `end_u` <= `start_t` <= `end_t`.\n+//\n+// (e) From `start_u` (incl.) to `end_u` (excl.) there are sequential instances\n+//     of type `U`.\n+//\n+// (f) From `start_t` (incl.) to `end_t` (excl.) there are sequential instances\n+//     of type `T`.\n+\n+pub struct PartialVec<T,U> {\n+    vec: Vec<T>,\n+\n+    start_u: *mut U,\n+    end_u: *mut U,\n+    start_t: *mut T,\n+    end_t: *mut T,\n+}\n+\n+impl<T,U> PartialVec<T,U> {\n+    /// Creates a `PartialVec` from a `Vec`.\n+    pub fn new(mut vec: Vec<T>) -> PartialVec<T,U> {\n+        // TODO: do this statically\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(mem::size_of::<U>() != 0);\n+        assert!(mem::size_of::<T>() == mem::size_of::<U>());\n+\n+        let start = vec.as_mut_ptr();\n+\n+        // This `as int` cast is safe, because the size of the elements of the\n+        // vector is not 0, and:\n+        //\n+        // 1) If the size of the elements in the vector is 1, the `int` may\n+        //    overflow, but it has the correct bit pattern so that the\n+        //    `.offset()` function will work.\n+        //\n+        //    Example:\n+        //        Address space 0x0-0xF.\n+        //        `u8` array at: 0x1.\n+        //        Size of `u8` array: 0x8.\n+        //        Calculated `offset`: -0x8.\n+        //        After `array.offset(offset)`: 0x9.\n+        //        (0x1 + 0x8 = 0x1 - 0x8)\n+        //\n+        // 2) If the size of the elements in the vector is >1, the `uint` ->\n+        //    `int` conversion can't overflow.\n+        let offset = vec.len() as int;\n+\n+        let start_u = start as *mut U;\n+        let end_u = start as *mut U;\n+        let start_t = start;\n+        let end_t = unsafe { start_t.offset(offset) };\n+\n+        // (b) is satisfied, `start_u` points to the start of `vec`.\n+\n+        // (c) is also satisfied, `end_t` points to the end of `vec`.\n+\n+        // `start_u == end_u == start_t <= end_t`, so also `start_u <= end_u <=\n+        // start_t <= end_t`, thus (b).\n+\n+        // As `start_u == end_u`, it is represented correctly that there are no\n+        // instances of `U` in `vec`, thus (e) is satisfied.\n+\n+        // At start, there are only elements of type `T` in `vec`, so (f) is\n+        // satisfied, as `start_t` points to the start of `vec` and `end_t` to\n+        // the end of it.\n+\n+        // This points inside the vector, as the vector has length `offset`.\n+\n+        PartialVec {\n+            // (a) is satisfied, `vec` isn't modified in the function.\n+            vec: vec,\n+            start_u: start_u,\n+            end_u: end_u,\n+            start_t: start_t,\n+            end_t: end_t,\n+        }\n+    }\n+\n+    /// Pops a `T` from the `PartialVec`.\n+    ///\n+    /// Returns `Some(t)` if there are more `T`s in the vector, otherwise\n+    /// `None`.\n+    fn pop(&mut self) -> Option<T> {\n+        // The `if` ensures that there are more `T`s in `vec`.\n+        if self.start_t < self.end_t {\n+            let result;\n+            unsafe {\n+                // (f) is satisfied before, so in this if branch there actually\n+                // is a `T` at `start_t`.  After shifting the pointer by one,\n+                // (f) is again satisfied.\n+                result = ptr::read(self.start_t as *const T);\n+                self.start_t = self.start_t.offset(1);\n+            }\n+            Some(result)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Pushes a new `U` to the `PartialVec`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if not enough `T`s were popped to have enough space for the new\n+    /// `U`.\n+    pub fn push(&mut self, value: U) {\n+        // The assert assures that still `end_u <= start_t` (d) after\n+        // the function.\n+        assert!(self.end_u as *const () < self.start_t as *const (),\n+            \"writing more elements to PartialVec than reading from it\")\n+        unsafe {\n+            // (e) is satisfied before, and after writing one `U`\n+            // to `end_u` and shifting it by one, it's again\n+            // satisfied.\n+            ptr::write(self.end_u, value);\n+            self.end_u = self.end_u.offset(1);\n+        }\n+    }\n+\n+    /// Unwraps the new `Vec` of `U`s after having pushed enough `U`s and\n+    /// popped all `T`s.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if not all `T`s were popped, also fails if not the same amount of\n+    /// `U`s was pushed before calling `unwrap`.\n+    pub fn unwrap(self) -> Vec<U> {\n+        // If `self.end_u == self.end_t`, we know from (e) that there are no\n+        // more `T`s in `vec`, we also know that the whole length of `vec` is\n+        // now used by `U`s, thus we can just transmute `vec` from a vector of\n+        // `T`s to a vector of `U`s safely.\n+\n+        assert!(self.end_u as *const () == self.end_t as *const (),\n+            \"trying to unwrap a PartialVec before completing the writes to it\");\n+\n+        // Extract `vec` and prevent the destructor of `PartialVec` from\n+        // running.\n+        unsafe {\n+            let vec = ptr::read(&self.vec);\n+            mem::forget(self);\n+            mem::transmute(vec)\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T,U> Drop for PartialVec<T,U> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            // As per (a) `vec` hasn't been modified until now. As it has a\n+            // length currently, this would run destructors of `T`s which might\n+            // not be there. So at first, set `vec`s length to `0`. This must\n+            // be done at first to remain memory-safe as the destructors of `U`\n+            // or `T` might cause unwinding where `vec`s destructor would be\n+            // executed.\n+            self.vec.set_len(0);\n+\n+            // As per (e) and (f) we have instances of `U`s and `T`s in `vec`.\n+            // Destruct them.\n+            while self.start_u < self.end_u {\n+                let _ = ptr::read(self.start_u as *const U); // Run a `U` destructor.\n+                self.start_u = self.start_u.offset(1);\n+            }\n+            while self.start_t < self.end_t {\n+                let _ = ptr::read(self.start_t as *const T); // Run a `T` destructor.\n+                self.start_t = self.start_t.offset(1);\n+            }\n+            // After this destructor ran, the destructor of `vec` will run,\n+            // deallocating the underlying memory.\n+        }\n+    }\n+}\n+\n+impl<T,U> Iterator<T> for PartialVec<T,U> {\n+    fn next(&mut self) -> Option<T> {\n+        self.pop()\n+    }\n+}\n+\n+impl<T> Vec<T> {\n+    /// Converts a `Vec<T>` to a `Vec<U>` where `T` and `U` have the same size.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v = vec![0u, 1, 2];\n+    /// let w = v.map_inplace(|i| i + 3);\n+    /// assert_eq!(w.as_slice() == &[3, 4, 5]);\n+    ///\n+    /// let big_endian_u16s = vec![0x1122u16, 0x3344];\n+    /// let u8s = big_endian_u16s.map_inplace(|x| [\n+    ///     ((x >> 8) & 0xff) as u8,\n+    ///     (x & 0xff) as u8\n+    /// ]);\n+    /// assert_eq!(u8s.as_slice() == &[[0x11, 0x22], [0x33, 0x44]]);\n+    /// ```\n+    pub fn map_inplace<U>(self, f: |T| -> U) -> Vec<U> {\n+        let mut pv = PartialVec::new(self);\n+        loop {\n+            // TODO: need this extra assignment for borrowck to pass\n+            let maybe_t = pv.pop();\n+            match maybe_t {\n+                Some(t) => pv.push(f(t)),\n+                None => return pv.unwrap(),\n+            };\n+        }\n+    }\n+}\n+\n+\n #[cfg(test)]\n mod tests {\n     extern crate test;\n@@ -2039,6 +2285,18 @@ mod tests {\n         assert_eq!(vec.as_ptr(), ptr);\n         assert_eq!(vec.capacity(), 7);\n         assert_eq!(vec.len(), 0);\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_map_inplace_incompatible_types_fail() {\n+        let v = vec![0u, 1, 2];\n+        v.map_inplace(|_| ());\n+    }\n+\n+    #[test]\n+    fn test_map_inplace() {\n+        let v = vec![0u, 1, 2];\n+        assert_eq!(v.map_inplace(|i: uint| i as int - 1).as_slice, &[-1i, 0, 1]);\n     }\n \n     #[bench]"}]}