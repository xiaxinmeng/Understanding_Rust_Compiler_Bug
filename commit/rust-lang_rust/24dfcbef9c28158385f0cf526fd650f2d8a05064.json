{"sha": "24dfcbef9c28158385f0cf526fd650f2d8a05064", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZGZjYmVmOWMyODE1ODM4NWYwY2Y1MjZmZDY1MGYyZDhhMDUwNjQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-05-25T15:19:31Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-06-01T07:32:24Z"}, "message": "Make const decoding from the incremental cache thread-safe.", "tree": {"sha": "fc79f42376a0a823795719d2c6e0eac283428189", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc79f42376a0a823795719d2c6e0eac283428189"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24dfcbef9c28158385f0cf526fd650f2d8a05064", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24dfcbef9c28158385f0cf526fd650f2d8a05064", "html_url": "https://github.com/rust-lang/rust/commit/24dfcbef9c28158385f0cf526fd650f2d8a05064", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24dfcbef9c28158385f0cf526fd650f2d8a05064/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9f90ede826e24a9b314ca7bf0bc04856e11aadb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9f90ede826e24a9b314ca7bf0bc04856e11aadb", "html_url": "https://github.com/rust-lang/rust/commit/f9f90ede826e24a9b314ca7bf0bc04856e11aadb"}], "stats": {"total": 223, "additions": 181, "deletions": 42}, "files": [{"sha": "10e8905054d11399c8e6246c2ecebf14e6edab8e", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24dfcbef9c28158385f0cf526fd650f2d8a05064/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24dfcbef9c28158385f0cf526fd650f2d8a05064/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=24dfcbef9c28158385f0cf526fd650f2d8a05064", "patch": "@@ -68,6 +68,7 @@\n #![feature(trace_macros)]\n #![feature(trusted_len)]\n #![feature(catch_expr)]\n+#![feature(integer_atomics)]\n #![feature(test)]\n #![feature(in_band_lifetimes)]\n #![feature(macro_at_most_once_rep)]"}, {"sha": "11dd6d1389ad5e2915641db1932e46b7dbf60316", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/24dfcbef9c28158385f0cf526fd650f2d8a05064/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24dfcbef9c28158385f0cf526fd650f2d8a05064/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=24dfcbef9c28158385f0cf526fd650f2d8a05064", "patch": "@@ -26,7 +26,12 @@ use syntax::ast::Mutability;\n use rustc_serialize::{Encoder, Decoder, Decodable, Encodable};\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::{Lock as Mutex, HashMapExt};\n+use rustc_data_structures::tiny_list::TinyList;\n use byteorder::{WriteBytesExt, ReadBytesExt, LittleEndian, BigEndian};\n+use ty::codec::TyDecoder;\n+use std::sync::atomic::{AtomicU32, Ordering};\n+use std::num::NonZeroU32;\n \n #[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Lock {\n@@ -245,6 +250,166 @@ pub fn specialized_decode_alloc_id<\n     }\n }\n \n+// Used to avoid infinite recursion when decoding cyclic allocations.\n+type DecodingSessionId = NonZeroU32;\n+\n+#[derive(Clone)]\n+enum State {\n+    Empty,\n+    InProgressNonAlloc(TinyList<DecodingSessionId>),\n+    InProgress(TinyList<DecodingSessionId>, AllocId),\n+    Done(AllocId),\n+}\n+\n+pub struct AllocDecodingState {\n+    // For each AllocId we keep track of which decoding state it's currently in.\n+    decoding_state: Vec<Mutex<State>>,\n+    // The offsets of each allocation in the data stream.\n+    data_offsets: Vec<u32>,\n+}\n+\n+impl AllocDecodingState {\n+\n+    pub fn new_decoding_session(&self) -> AllocDecodingSession {\n+        static DECODER_SESSION_ID: AtomicU32 = AtomicU32::new(0);\n+        let counter = DECODER_SESSION_ID.fetch_add(1, Ordering::SeqCst);\n+\n+        // Make sure this is never zero\n+        let session_id = DecodingSessionId::new((counter & 0x7FFFFFFF) + 1).unwrap();\n+\n+        AllocDecodingSession {\n+            state: self,\n+            session_id,\n+        }\n+    }\n+\n+    pub fn new(data_offsets: Vec<u32>) -> AllocDecodingState {\n+        let decoding_state: Vec<_> = ::std::iter::repeat(Mutex::new(State::Empty))\n+            .take(data_offsets.len())\n+            .collect();\n+\n+        AllocDecodingState {\n+            decoding_state: decoding_state,\n+            data_offsets,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct AllocDecodingSession<'s> {\n+    state: &'s AllocDecodingState,\n+    session_id: DecodingSessionId,\n+}\n+\n+impl<'s> AllocDecodingSession<'s> {\n+\n+    // Decodes an AllocId in a thread-safe way.\n+    pub fn decode_alloc_id<'a, 'tcx, D>(&self,\n+                                        decoder: &mut D)\n+                                        -> Result<AllocId, D::Error>\n+        where D: TyDecoder<'a, 'tcx>,\n+              'tcx: 'a,\n+    {\n+        // Read the index of the allocation\n+        let idx = decoder.read_u32()? as usize;\n+        let pos = self.state.data_offsets[idx] as usize;\n+\n+        // Decode the AllocKind now so that we know if we have to reserve an\n+        // AllocId.\n+        let (alloc_kind, pos) = decoder.with_position(pos, |decoder| {\n+            let alloc_kind = AllocKind::decode(decoder)?;\n+            Ok((alloc_kind, decoder.position()))\n+        })?;\n+\n+        // Check the decoding state, see if it's already decoded or if we should\n+        // decode it here.\n+        let alloc_id = {\n+            let mut entry = self.state.decoding_state[idx].lock();\n+\n+            match *entry {\n+                State::Done(alloc_id) => {\n+                    return Ok(alloc_id);\n+                }\n+                ref mut entry @ State::Empty => {\n+                    // We are allowed to decode\n+                    match alloc_kind {\n+                        AllocKind::Alloc => {\n+                            // If this is an allocation, we need to reserve an\n+                            // AllocId so we can decode cyclic graphs.\n+                            let alloc_id = decoder.tcx().alloc_map.lock().reserve();\n+                            *entry = State::InProgress(\n+                                TinyList::new_single(self.session_id),\n+                                alloc_id);\n+                            Some(alloc_id)\n+                        },\n+                        AllocKind::Fn | AllocKind::Static => {\n+                            // Fns and statics cannot be cyclic and their AllocId\n+                            // is determined later by interning\n+                            *entry = State::InProgressNonAlloc(\n+                                TinyList::new_single(self.session_id));\n+                            None\n+                        }\n+                    }\n+                }\n+                State::InProgressNonAlloc(ref mut sessions) => {\n+                    if sessions.contains(&self.session_id) {\n+                        bug!(\"This should be unreachable\")\n+                    } else {\n+                        // Start decoding concurrently\n+                        sessions.insert(self.session_id);\n+                        None\n+                    }\n+                }\n+                State::InProgress(ref mut sessions, alloc_id) => {\n+                    if sessions.contains(&self.session_id) {\n+                        // Don't recurse.\n+                        return Ok(alloc_id)\n+                    } else {\n+                        // Start decoding concurrently\n+                        sessions.insert(self.session_id);\n+                        Some(alloc_id)\n+                    }\n+                }\n+            }\n+        };\n+\n+        // Now decode the actual data\n+        let alloc_id = decoder.with_position(pos, |decoder| {\n+            match alloc_kind {\n+                AllocKind::Alloc => {\n+                    let allocation = <&'tcx Allocation as Decodable>::decode(decoder)?;\n+                    // We already have a reserved AllocId.\n+                    let alloc_id = alloc_id.unwrap();\n+                    trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n+                    decoder.tcx().alloc_map.lock().set_id_same_memory(alloc_id, allocation);\n+                    Ok(alloc_id)\n+                },\n+                AllocKind::Fn => {\n+                    assert!(alloc_id.is_none());\n+                    trace!(\"creating fn alloc id\");\n+                    let instance = ty::Instance::decode(decoder)?;\n+                    trace!(\"decoded fn alloc instance: {:?}\", instance);\n+                    let alloc_id = decoder.tcx().alloc_map.lock().create_fn_alloc(instance);\n+                    Ok(alloc_id)\n+                },\n+                AllocKind::Static => {\n+                    assert!(alloc_id.is_none());\n+                    trace!(\"creating extern static alloc id at\");\n+                    let did = DefId::decode(decoder)?;\n+                    let alloc_id = decoder.tcx().alloc_map.lock().intern_static(did);\n+                    Ok(alloc_id)\n+                }\n+            }\n+        })?;\n+\n+        self.state.decoding_state[idx].with_lock(|entry| {\n+            *entry = State::Done(alloc_id);\n+        });\n+\n+        Ok(alloc_id)\n+    }\n+}\n+\n impl fmt::Display for AllocId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.0)\n@@ -340,6 +505,10 @@ impl<'tcx, M: fmt::Debug + Eq + Hash + Clone> AllocMap<'tcx, M> {\n             bug!(\"tried to set allocation id {}, but it was already existing as {:#?}\", id, old);\n         }\n     }\n+\n+    pub fn set_id_same_memory(&mut self, id: AllocId, mem: M) {\n+       self.id_to_type.insert_same(id, AllocType::Memory(mem));\n+    }\n }\n \n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]"}, {"sha": "cd317ff6cdbef04c307cba312f82a2731882f076", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 10, "deletions": 41, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/24dfcbef9c28158385f0cf526fd650f2d8a05064/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24dfcbef9c28158385f0cf526fd650f2d8a05064/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=24dfcbef9c28158385f0cf526fd650f2d8a05064", "patch": "@@ -16,14 +16,14 @@ use hir::def_id::{CrateNum, DefIndex, DefId, LocalDefId,\n use hir::map::definitions::DefPathHash;\n use ich::{CachingCodemapView, Fingerprint};\n use mir::{self, interpret};\n+use mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{Lrc, Lock, HashMapExt, Once};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder, opaque,\n                       SpecializedDecoder, SpecializedEncoder,\n                       UseSpecializedDecodable, UseSpecializedEncodable};\n use session::{CrateDisambiguator, Session};\n-use std::cell::RefCell;\n use std::mem;\n use syntax::ast::NodeId;\n use syntax::codemap::{CodeMap, StableFilemapId};\n@@ -77,11 +77,7 @@ pub struct OnDiskCache<'sess> {\n     // `serialized_data`.\n     prev_diagnostics_index: FxHashMap<SerializedDepNodeIndex, AbsoluteBytePos>,\n \n-    // Alloc indices to memory location map\n-    prev_interpret_alloc_index: Vec<AbsoluteBytePos>,\n-\n-    /// Deserialization: A cache to ensure we don't read allocations twice\n-    interpret_alloc_cache: RefCell<FxHashMap<usize, interpret::AllocId>>,\n+    alloc_decoding_state: AllocDecodingState,\n }\n \n // This type is used only for (de-)serialization.\n@@ -92,7 +88,7 @@ struct Footer {\n     query_result_index: EncodedQueryResultIndex,\n     diagnostics_index: EncodedQueryResultIndex,\n     // the location of all allocations\n-    interpret_alloc_index: Vec<AbsoluteBytePos>,\n+    interpret_alloc_index: Vec<u32>,\n }\n \n type EncodedQueryResultIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n@@ -149,8 +145,7 @@ impl<'sess> OnDiskCache<'sess> {\n             query_result_index: footer.query_result_index.into_iter().collect(),\n             prev_diagnostics_index: footer.diagnostics_index.into_iter().collect(),\n             synthetic_expansion_infos: Lock::new(FxHashMap()),\n-            prev_interpret_alloc_index: footer.interpret_alloc_index,\n-            interpret_alloc_cache: RefCell::new(FxHashMap::default()),\n+            alloc_decoding_state: AllocDecodingState::new(footer.interpret_alloc_index),\n         }\n     }\n \n@@ -166,8 +161,7 @@ impl<'sess> OnDiskCache<'sess> {\n             query_result_index: FxHashMap(),\n             prev_diagnostics_index: FxHashMap(),\n             synthetic_expansion_infos: Lock::new(FxHashMap()),\n-            prev_interpret_alloc_index: Vec::new(),\n-            interpret_alloc_cache: RefCell::new(FxHashMap::default()),\n+            alloc_decoding_state: AllocDecodingState::new(Vec::new()),\n         }\n     }\n \n@@ -291,7 +285,7 @@ impl<'sess> OnDiskCache<'sess> {\n                     }\n                     for idx in n..new_n {\n                         let id = encoder.interpret_allocs_inverse[idx];\n-                        let pos = AbsoluteBytePos::new(encoder.position());\n+                        let pos = encoder.position() as u32;\n                         interpret_alloc_index.push(pos);\n                         interpret::specialized_encode_alloc_id(\n                             &mut encoder,\n@@ -424,8 +418,7 @@ impl<'sess> OnDiskCache<'sess> {\n             file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,\n             synthetic_expansion_infos: &self.synthetic_expansion_infos,\n-            prev_interpret_alloc_index: &self.prev_interpret_alloc_index,\n-            interpret_alloc_cache: &self.interpret_alloc_cache,\n+            alloc_decoding_session: self.alloc_decoding_state.new_decoding_session(),\n         };\n \n         match decode_tagged(&mut decoder, dep_node_index) {\n@@ -487,9 +480,7 @@ struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n     synthetic_expansion_infos: &'x Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n     file_index_to_file: &'x Lock<FxHashMap<FileMapIndex, Lrc<FileMap>>>,\n     file_index_to_stable_id: &'x FxHashMap<FileMapIndex, StableFilemapId>,\n-    interpret_alloc_cache: &'x RefCell<FxHashMap<usize, interpret::AllocId>>,\n-    /// maps from index in the cache file to location in the cache file\n-    prev_interpret_alloc_index: &'x [AbsoluteBytePos],\n+    alloc_decoding_session: AllocDecodingSession<'x>,\n }\n \n impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n@@ -612,30 +603,8 @@ implement_ty_decoder!( CacheDecoder<'a, 'tcx, 'x> );\n \n impl<'a, 'tcx, 'x> SpecializedDecoder<interpret::AllocId> for CacheDecoder<'a, 'tcx, 'x> {\n     fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n-        let tcx = self.tcx;\n-        let idx = usize::decode(self)?;\n-        trace!(\"loading index {}\", idx);\n-\n-        if let Some(cached) = self.interpret_alloc_cache.borrow().get(&idx).cloned() {\n-            trace!(\"loading alloc id {:?} from alloc_cache\", cached);\n-            return Ok(cached);\n-        }\n-        let pos = self.prev_interpret_alloc_index[idx].to_usize();\n-        trace!(\"loading position {}\", pos);\n-        self.with_position(pos, |this| {\n-            interpret::specialized_decode_alloc_id(\n-                this,\n-                tcx,\n-                |this, alloc_id| {\n-                    trace!(\"caching idx {} for alloc id {} at position {}\", idx, alloc_id, pos);\n-                    assert!(this\n-                        .interpret_alloc_cache\n-                        .borrow_mut()\n-                        .insert(idx, alloc_id)\n-                        .is_none());\n-                },\n-            )\n-        })\n+        let alloc_decoding_session = self.alloc_decoding_session;\n+        alloc_decoding_session.decode_alloc_id(self)\n     }\n }\n impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {"}, {"sha": "5b1b2aadec5638d433168f2de54a7d0083a889b6", "filename": "src/librustc_data_structures/tiny_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24dfcbef9c28158385f0cf526fd650f2d8a05064/src%2Flibrustc_data_structures%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24dfcbef9c28158385f0cf526fd650f2d8a05064/src%2Flibrustc_data_structures%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list.rs?ref=24dfcbef9c28158385f0cf526fd650f2d8a05064", "patch": "@@ -174,7 +174,7 @@ mod test {\n                 }\n             }\n \n-            assert!(!list.contains(i));\n+            assert!(!list.contains(&i));\n \n             if do_insert(i) {\n                 list.insert(i);"}]}