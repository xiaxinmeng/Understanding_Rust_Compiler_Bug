{"sha": "e09a843973f8dfc5766c0d36bb68ee1136cbf54c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwOWE4NDM5NzNmOGRmYzU3NjZjMGQzNmJiNjhlZTExMzZjYmY1NGM=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-02-25T00:24:07Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-07T04:37:59Z"}, "message": "Handle unit-like types specially.\n\nThis change remains separate from the addition of adt.rs, even though\nit's necessary for compatibility with pre-trans::adt representation,\nto serve as an example of a change to the representation logic.", "tree": {"sha": "a40a500b040a5c65cebb7dffdc9503a3bf49fb95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a40a500b040a5c65cebb7dffdc9503a3bf49fb95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e09a843973f8dfc5766c0d36bb68ee1136cbf54c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e09a843973f8dfc5766c0d36bb68ee1136cbf54c", "html_url": "https://github.com/rust-lang/rust/commit/e09a843973f8dfc5766c0d36bb68ee1136cbf54c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e09a843973f8dfc5766c0d36bb68ee1136cbf54c/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b2b4faba84c1d43af35397d0103747fe085ee45", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b2b4faba84c1d43af35397d0103747fe085ee45", "html_url": "https://github.com/rust-lang/rust/commit/7b2b4faba84c1d43af35397d0103747fe085ee45"}], "stats": {"total": 25, "additions": 19, "deletions": 6}, "files": [{"sha": "b32111f6bf47537b23865e5725f7a293b5a57fad", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e09a843973f8dfc5766c0d36bb68ee1136cbf54c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e09a843973f8dfc5766c0d36bb68ee1136cbf54c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=e09a843973f8dfc5766c0d36bb68ee1136cbf54c", "patch": "@@ -24,6 +24,7 @@ use util::ppaux::ty_to_str;\n \n // XXX: should this be done with boxed traits instead of ML-style?\n pub enum Repr {\n+    Unit(int),\n     CEnum(int, int), /* discriminant range */\n     Univariant(Struct, Destructor),\n     General(~[Struct])\n@@ -77,8 +78,11 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> Repr {\n             if cases.len() == 0 {\n                 // Uninhabitable; represent as unit\n                 Univariant(mk_struct(cx, ~[]), NoDtor)\n-            } else if cases.len() == 1 && cases[0].discr == 0 {\n+            } else if cases.len() == 1 && cases[0].tys.len() == 0 {\n+                Unit(cases[0].discr)\n+            } else if cases.len() == 1 {\n                 // struct, tuple, newtype, etc.\n+                assert cases[0].discr == 0;\n                 Univariant(mk_struct(cx, cases[0].tys), NoDtor)\n             } else if cases.all(|c| c.tys.len() == 0) {\n                 let discrs = cases.map(|c| c.discr);\n@@ -116,6 +120,7 @@ pub fn fields_of(cx: @CrateContext, r: &Repr) -> ~[TypeRef] {\n fn generic_fields_of(cx: @CrateContext, r: &Repr, sizing: bool)\n     -> ~[TypeRef] {\n     match *r {\n+        Unit(*) => ~[],\n         CEnum(*) => ~[T_enum_discrim(cx)],\n         Univariant(ref st, dt) => {\n             let f = if sizing {\n@@ -160,7 +165,7 @@ pub fn trans_switch(bcx: block, r: &Repr, scrutinee: ValueRef) ->\n         CEnum(min, max) => {\n             (_match::switch, Some(load_discr(bcx, scrutinee, min, max)))\n         }\n-        Univariant(*) => {\n+        Unit(*) | Univariant(*) => {\n             (_match::single, None)\n         }\n         General(ref cases) => {\n@@ -175,7 +180,7 @@ pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n         CEnum(*) => {\n             _match::single_result(rslt(bcx, C_int(bcx.ccx(), discr)))\n         }\n-        Univariant(*) => {\n+        Unit(*) | Univariant(*)=> {\n             bcx.ccx().sess.bug(~\"no cases for univariants or structs\")\n         }\n         General(*) => {\n@@ -186,6 +191,9 @@ pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n \n pub fn trans_set_discr(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n     match *r {\n+        Unit(the_discr) => {\n+            assert discr == the_discr;\n+        }\n         CEnum(min, max) => {\n             assert min <= discr && discr <= max;\n             Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n@@ -205,7 +213,7 @@ pub fn trans_set_discr(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n \n pub fn num_args(r: &Repr, discr: int) -> uint {\n     match *r {\n-        CEnum(*) => 0,\n+        Unit(*) | CEnum(*) => 0,\n         Univariant(ref st, _dt) => { assert discr == 0; st.fields.len() }\n         General(ref cases) => cases[discr as uint].fields.len()\n     }\n@@ -217,7 +225,7 @@ pub fn trans_GEP(bcx: block, r: &Repr, val: ValueRef, discr: int, ix: uint)\n     // decide to do some kind of cdr-coding-like non-unique repr\n     // someday), it'll need to return a possibly-new bcx as well.\n     match *r {\n-        CEnum(*) => {\n+        Unit(*) | CEnum(*) => {\n             bcx.ccx().sess.bug(~\"element access in C-like enum\")\n         }\n         Univariant(ref st, dt) => {\n@@ -253,6 +261,9 @@ fn struct_GEP(bcx: block, st: &Struct, val: ValueRef, ix: uint,\n pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n                    vals: &[ValueRef]) -> ValueRef {\n     match *r {\n+        Unit(*) => {\n+            C_struct(~[])\n+        }\n         CEnum(min, max) => {\n             assert vals.len() == 0;\n             assert min <= discr && discr <= max;\n@@ -312,6 +323,7 @@ fn roundup(x: u64, a: u64) -> u64 { ((x + (a - 1)) / a) * a }\n pub fn const_get_discrim(ccx: @CrateContext, r: &Repr, val: ValueRef)\n     -> int {\n     match *r {\n+        Unit(discr) => discr,\n         CEnum(*) => const_to_int(val) as int,\n         Univariant(*) => 0,\n         General(*) => const_to_int(const_get_elt(ccx, val, [0])) as int,\n@@ -322,7 +334,8 @@ pub fn const_get_element(ccx: @CrateContext, r: &Repr, val: ValueRef,\n                          _discr: int, ix: uint) -> ValueRef {\n     // Not to be confused with common::const_get_elt.\n     match *r {\n-        CEnum(*) => ccx.sess.bug(~\"element access in C-like enum const\"),\n+        Unit(*) | CEnum(*) => ccx.sess.bug(~\"element access in C-like enum \\\n+                                             const\"),\n         Univariant(*) => const_struct_field(ccx, val, ix),\n         General(*) => const_struct_field(ccx, const_get_elt(ccx, val,\n                                                             [1, 0]), ix)"}]}