{"sha": "91a707390045eb29e5392de1f7f5b9d5fdb64e65", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYTcwNzM5MDA0NWViMjllNTM5MmRlMWY3ZjViOWQ1ZmRiNjRlNjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-31T18:34:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-31T18:34:46Z"}, "message": "auto merge of #6857 : alexcrichton/rust/ebml-fixes, r=pcwalton\n\nAlso provides a method of serializing `char`.", "tree": {"sha": "8f494efc9c65023e548f569f306c53a4df042876", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f494efc9c65023e548f569f306c53a4df042876"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91a707390045eb29e5392de1f7f5b9d5fdb64e65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91a707390045eb29e5392de1f7f5b9d5fdb64e65", "html_url": "https://github.com/rust-lang/rust/commit/91a707390045eb29e5392de1f7f5b9d5fdb64e65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91a707390045eb29e5392de1f7f5b9d5fdb64e65/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5028ac73966ac82d0eeb7bebe450e44d43c62d18", "url": "https://api.github.com/repos/rust-lang/rust/commits/5028ac73966ac82d0eeb7bebe450e44d43c62d18", "html_url": "https://github.com/rust-lang/rust/commit/5028ac73966ac82d0eeb7bebe450e44d43c62d18"}, {"sha": "e86ac24e7ba71c488c243d2715b825ec1935aa33", "url": "https://api.github.com/repos/rust-lang/rust/commits/e86ac24e7ba71c488c243d2715b825ec1935aa33", "html_url": "https://github.com/rust-lang/rust/commit/e86ac24e7ba71c488c243d2715b825ec1935aa33"}], "stats": {"total": 181, "additions": 108, "deletions": 73}, "files": [{"sha": "641f01dfb0b6ede1b9c1da7c368d204812972d6a", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 79, "deletions": 71, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/91a707390045eb29e5392de1f7f5b9d5fdb64e65/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a707390045eb29e5392de1f7f5b9d5fdb64e65/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=91a707390045eb29e5392de1f7f5b9d5fdb64e65", "patch": "@@ -51,32 +51,34 @@ pub enum EbmlEncoderTag {\n     EsI16,      // 8\n     EsI8,       // 9\n     EsBool,     // 10\n-    EsStr,      // 11\n-    EsF64,      // 12\n-    EsF32,      // 13\n-    EsFloat,    // 14\n-    EsEnum,     // 15\n-    EsEnumVid,  // 16\n-    EsEnumBody, // 17\n-    EsVec,      // 18\n-    EsVecLen,   // 19\n-    EsVecElt,   // 20\n+    EsChar,     // 11\n+    EsStr,      // 12\n+    EsF64,      // 13\n+    EsF32,      // 14\n+    EsFloat,    // 15\n+    EsEnum,     // 16\n+    EsEnumVid,  // 17\n+    EsEnumBody, // 18\n+    EsVec,      // 19\n+    EsVecLen,   // 20\n+    EsVecElt,   // 21\n+    EsMap,      // 22\n+    EsMapLen,   // 23\n+    EsMapKey,   // 24\n+    EsMapVal,   // 25\n \n     EsOpaque,\n \n-    EsLabel // Used only when debugging\n+    EsLabel, // Used only when debugging\n }\n // --------------------------------------\n \n pub mod reader {\n-    use core::prelude::*;\n+    use super::*;\n \n-    use ebml::{Doc, EbmlEncoderTag, EsBool, EsEnum, EsEnumBody, EsEnumVid};\n-    use ebml::{EsI16, EsI32, EsI64, EsI8, EsInt};\n-    use ebml::{EsLabel, EsOpaque, EsStr, EsU16, EsU32, EsU64, EsU8, EsUint};\n-    use ebml::{EsVec, EsVecElt, EsVecLen, TaggedDoc};\n     use serialize;\n \n+    use core::prelude::*;\n     use core::cast::transmute;\n     use core::int;\n     use core::io;\n@@ -321,12 +323,14 @@ pub mod reader {\n             r_doc\n         }\n \n-        fn push_doc<T>(&mut self, d: Doc, f: &fn() -> T) -> T {\n+        fn push_doc<T>(&mut self, exp_tag: EbmlEncoderTag,\n+                       f: &fn(&mut Decoder) -> T) -> T {\n+            let d = self.next_doc(exp_tag);\n             let old_parent = self.parent;\n             let old_pos = self.pos;\n             self.parent = d;\n             self.pos = d.start;\n-            let r = f();\n+            let r = f(self);\n             self.parent = old_parent;\n             self.pos = old_pos;\n             r\n@@ -395,10 +399,21 @@ pub mod reader {\n             doc_as_u8(self.next_doc(EsBool)) as bool\n         }\n \n-        fn read_f64(&mut self) -> f64 { fail!(\"read_f64()\"); }\n-        fn read_f32(&mut self) -> f32 { fail!(\"read_f32()\"); }\n-        fn read_float(&mut self) -> float { fail!(\"read_float()\"); }\n-        fn read_char(&mut self) -> char { fail!(\"read_char()\"); }\n+        fn read_f64(&mut self) -> f64 {\n+            let bits = doc_as_u64(self.next_doc(EsF64));\n+            unsafe { transmute(bits) }\n+        }\n+        fn read_f32(&mut self) -> f32 {\n+            let bits = doc_as_u32(self.next_doc(EsF32));\n+            unsafe { transmute(bits) }\n+        }\n+        fn read_float(&mut self) -> float {\n+            let bits = doc_as_u64(self.next_doc(EsFloat));\n+            (unsafe { transmute::<u64, f64>(bits) }) as float\n+        }\n+        fn read_char(&mut self) -> char {\n+            doc_as_u32(self.next_doc(EsChar)) as char\n+        }\n         fn read_str(&mut self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n \n         // Compound types:\n@@ -541,66 +556,50 @@ pub mod reader {\n \n         fn read_seq<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n             debug!(\"read_seq()\");\n-            let doc = self.next_doc(EsVec);\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let len = self._next_uint(EsVecLen);\n-            debug!(\"  len=%u\", len);\n-            let result = f(self, len);\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            result\n+            do self.push_doc(EsVec) |d| {\n+                let len = d._next_uint(EsVecLen);\n+                debug!(\"  len=%u\", len);\n+                f(d, len)\n+            }\n         }\n \n         fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n                            -> T {\n             debug!(\"read_seq_elt(idx=%u)\", idx);\n-            let doc = self.next_doc(EsVecElt);\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let result = f(self);\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            result\n+            self.push_doc(EsVecElt, f)\n         }\n \n-        fn read_map<T>(&mut self, _: &fn(&mut Decoder, uint) -> T) -> T {\n+        fn read_map<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n             debug!(\"read_map()\");\n-            fail!(\"read_map is unimplemented\");\n+            do self.push_doc(EsMap) |d| {\n+                let len = d._next_uint(EsMapLen);\n+                debug!(\"  len=%u\", len);\n+                f(d, len)\n+            }\n         }\n \n         fn read_map_elt_key<T>(&mut self,\n                                idx: uint,\n-                               _: &fn(&mut Decoder) -> T)\n+                               f: &fn(&mut Decoder) -> T)\n                                -> T {\n             debug!(\"read_map_elt_key(idx=%u)\", idx);\n-            fail!(\"read_map_elt_val is unimplemented\");\n+            self.push_doc(EsMapKey, f)\n         }\n \n         fn read_map_elt_val<T>(&mut self,\n                                idx: uint,\n-                               _: &fn(&mut Decoder) -> T)\n+                               f: &fn(&mut Decoder) -> T)\n                                -> T {\n             debug!(\"read_map_elt_val(idx=%u)\", idx);\n-            fail!(\"read_map_elt_val is unimplemented\");\n+            self.push_doc(EsMapVal, f)\n         }\n     }\n }\n \n pub mod writer {\n-    use ebml::{EbmlEncoderTag, EsBool, EsEnum, EsEnumBody, EsEnumVid};\n-    use ebml::{EsI16, EsI32, EsI64, EsI8, EsInt};\n-    use ebml::{EsLabel, EsOpaque, EsStr, EsU16, EsU32, EsU64, EsU8, EsUint};\n-    use ebml::{EsVec, EsVecElt, EsVecLen};\n+    use super::*;\n \n+    use core::cast;\n     use core::io;\n     use core::str;\n \n@@ -806,19 +805,21 @@ pub mod writer {\n             self.wr_tagged_u8(EsBool as uint, v as u8)\n         }\n \n-        // FIXME (#2742): implement these\n-        fn emit_f64(&mut self, _v: f64) {\n-            fail!(\"Unimplemented: serializing an f64\");\n+        fn emit_f64(&mut self, v: f64) {\n+            let bits = unsafe { cast::transmute(v) };\n+            self.wr_tagged_u64(EsF64 as uint, bits);\n         }\n-        fn emit_f32(&mut self, _v: f32) {\n-            fail!(\"Unimplemented: serializing an f32\");\n+        fn emit_f32(&mut self, v: f32) {\n+            let bits = unsafe { cast::transmute(v) };\n+            self.wr_tagged_u32(EsF32 as uint, bits);\n         }\n-        fn emit_float(&mut self, _v: float) {\n-            fail!(\"Unimplemented: serializing a float\");\n+        fn emit_float(&mut self, v: float) {\n+            let bits = unsafe { cast::transmute(v as f64) };\n+            self.wr_tagged_u64(EsFloat as uint, bits);\n         }\n \n-        fn emit_char(&mut self, _v: char) {\n-            fail!(\"Unimplemented: serializing a char\");\n+        fn emit_char(&mut self, v: char) {\n+            self.wr_tagged_u32(EsChar as uint, v as u32);\n         }\n \n         fn emit_str(&mut self, v: &str) {\n@@ -914,16 +915,23 @@ pub mod writer {\n             self.end_tag();\n         }\n \n-        fn emit_map(&mut self, _len: uint, _f: &fn(&mut Encoder)) {\n-            fail!(\"emit_map is unimplemented\");\n+        fn emit_map(&mut self, len: uint, f: &fn(&mut Encoder)) {\n+            self.start_tag(EsMap as uint);\n+            self._emit_tagged_uint(EsMapLen, len);\n+            f(self);\n+            self.end_tag();\n         }\n \n-        fn emit_map_elt_key(&mut self, _idx: uint, _f: &fn(&mut Encoder)) {\n-            fail!(\"emit_map_elt_key is unimplemented\");\n+        fn emit_map_elt_key(&mut self, _idx: uint, f: &fn(&mut Encoder)) {\n+            self.start_tag(EsMapKey as uint);\n+            f(self);\n+            self.end_tag();\n         }\n \n-        fn emit_map_elt_val(&mut self, _idx: uint, _f: &fn(&mut Encoder)) {\n-            fail!(\"emit_map_elt_val is unimplemented\");\n+        fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut Encoder)) {\n+            self.start_tag(EsMapVal as uint);\n+            f(self);\n+            self.end_tag();\n         }\n     }\n }"}, {"sha": "a54db07261a6aeaaeb078fc2fbda390982c8ff92", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91a707390045eb29e5392de1f7f5b9d5fdb64e65/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a707390045eb29e5392de1f7f5b9d5fdb64e65/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=91a707390045eb29e5392de1f7f5b9d5fdb64e65", "patch": "@@ -375,6 +375,18 @@ impl<D:Decoder> Decodable<D> for bool {\n     }\n }\n \n+impl<S:Encoder> Encodable<S> for char {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_char(*self)\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for char {\n+    fn decode(d: &mut D) -> char {\n+        d.read_char()\n+    }\n+}\n+\n impl<S:Encoder> Encodable<S> for () {\n     fn encode(&self, s: &mut S) {\n         s.emit_nil()"}, {"sha": "899c97b825ff8307f19d4de0b3090757e1176245", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/91a707390045eb29e5392de1f7f5b9d5fdb64e65/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a707390045eb29e5392de1f7f5b9d5fdb64e65/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=91a707390045eb29e5392de1f7f5b9d5fdb64e65", "patch": "@@ -17,13 +17,13 @@ extern mod extra;\n // These tests used to be separate files, but I wanted to refactor all\n // the common code.\n \n+use std::hashmap::{HashMap, HashSet};\n+\n use EBReader = extra::ebml::reader;\n use EBWriter = extra::ebml::writer;\n use std::cmp::Eq;\n use std::cmp;\n-use std::io::Writer;\n use std::io;\n-use extra::ebml;\n use extra::serialize::{Decodable, Encodable};\n use extra::time;\n \n@@ -158,4 +158,19 @@ pub fn main() {\n \n     let a = &time::now();\n     test_ebml(a);\n+\n+    test_ebml(&1.0f32);\n+    test_ebml(&1.0f64);\n+    test_ebml(&1.0f);\n+    test_ebml(&'a');\n+\n+    let mut a = HashMap::new();\n+    test_ebml(&a);\n+    a.insert(1, 2);\n+    test_ebml(&a);\n+\n+    let mut a = HashSet::new();\n+    test_ebml(&a);\n+    a.insert(1);\n+    test_ebml(&a);\n }"}]}