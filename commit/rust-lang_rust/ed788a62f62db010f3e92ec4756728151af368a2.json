{"sha": "ed788a62f62db010f3e92ec4756728151af368a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNzg4YTYyZjYyZGIwMTBmM2U5MmVjNDc1NjcyODE1MWFmMzY4YTI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-17T16:34:28Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:31Z"}, "message": "rustc: store CachedLayout for each variant of enum Layout's instead of Struct.", "tree": {"sha": "ebe5407eea80f8271dca2170b2c57f0cb7001864", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebe5407eea80f8271dca2170b2c57f0cb7001864"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed788a62f62db010f3e92ec4756728151af368a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed788a62f62db010f3e92ec4756728151af368a2", "html_url": "https://github.com/rust-lang/rust/commit/ed788a62f62db010f3e92ec4756728151af368a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed788a62f62db010f3e92ec4756728151af368a2/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd51a2bc192f323d0da2ea7716860b1699d315d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd51a2bc192f323d0da2ea7716860b1699d315d8", "html_url": "https://github.com/rust-lang/rust/commit/bd51a2bc192f323d0da2ea7716860b1699d315d8"}], "stats": {"total": 312, "additions": 134, "deletions": 178}, "files": [{"sha": "9ad5e07d8feab626718d42981e400be4736b5fa0", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed788a62f62db010f3e92ec4756728151af368a2/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed788a62f62db010f3e92ec4756728151af368a2/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ed788a62f62db010f3e92ec4756728151af368a2", "patch": "@@ -78,7 +78,7 @@ use hir;\n /// Internal storage\n pub struct GlobalArenas<'tcx> {\n     // internings\n-    layout: TypedArena<Layout>,\n+    layout: TypedArena<Layout<'tcx>>,\n \n     // references\n     generics: TypedArena<ty::Generics>,\n@@ -918,7 +918,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     stability_interner: RefCell<FxHashSet<&'tcx attr::Stability>>,\n \n-    layout_interner: RefCell<FxHashSet<&'tcx Layout>>,\n+    layout_interner: RefCell<FxHashSet<&'tcx Layout<'tcx>>>,\n \n     /// A vector of every trait accessible in the whole crate\n     /// (i.e. including those from subcrates). This is used only for\n@@ -1016,7 +1016,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         interned\n     }\n \n-    pub fn intern_layout(self, layout: Layout) -> &'gcx Layout {\n+    pub fn intern_layout(self, layout: Layout<'gcx>) -> &'gcx Layout<'gcx> {\n         if let Some(layout) = self.layout_interner.borrow().get(&layout) {\n             return layout;\n         }"}, {"sha": "096c74a6163cfac1eaefed232f7a09a9978e473c", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ed788a62f62db010f3e92ec4756728151af368a2/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed788a62f62db010f3e92ec4756728151af368a2/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=ed788a62f62db010f3e92ec4756728151af368a2", "patch": "@@ -1004,7 +1004,7 @@ pub const FAT_PTR_ADDR: usize = 0;\n pub const FAT_PTR_EXTRA: usize = 1;\n \n /// Describes how the fields of a type are located in memory.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum FieldPlacement<'a> {\n     /// Array-like placement. Can also express\n     /// unions, by using a stride of zero bytes.\n@@ -1058,7 +1058,7 @@ impl<'a> FieldPlacement<'a> {\n \n /// Describes how values of the type are passed by target ABIs,\n /// in terms of categories of C types there are ABI rules for.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Abi {\n     Scalar(Primitive),\n     Vector {\n@@ -1141,8 +1141,8 @@ impl Abi {\n /// For ADTs, it also includes field placement and enum optimizations.\n /// NOTE: Because Layout is interned, redundant information should be\n /// kept to a minimum, e.g. it includes no sub-component Ty or Layout.\n-#[derive(Debug, PartialEq, Eq, Hash)]\n-pub enum Layout {\n+#[derive(PartialEq, Eq, Hash, Debug)]\n+pub enum Layout<'a> {\n     /// TyBool, TyChar, TyInt, TyUint, TyFloat, TyRawPtr, TyRef or TyFnPtr.\n     Scalar(Primitive),\n \n@@ -1184,7 +1184,7 @@ pub enum Layout {\n         // the largest space between two consecutive discriminants and\n         // taking everything else as the (shortest) discriminant range.\n         discr_range: RangeInclusive<u64>,\n-        variants: Vec<Struct>,\n+        variants: Vec<CachedLayout<'a>>,\n         size: Size,\n         align: Align,\n         primitive_align: Align,\n@@ -1202,7 +1202,7 @@ pub enum Layout {\n         nndiscr: u64,\n         discr: Primitive,\n         discr_offset: Size,\n-        variants: Vec<Struct>,\n+        variants: Vec<CachedLayout<'a>>,\n         size: Size,\n         align: Align,\n         primitive_align: Align,\n@@ -1228,9 +1228,9 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct CachedLayout<'tcx> {\n-    pub layout: &'tcx Layout,\n+    pub layout: &'tcx Layout<'tcx>,\n     pub fields: FieldPlacement<'tcx>,\n     pub abi: Abi,\n }\n@@ -1262,7 +1262,7 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n     };\n }\n \n-impl<'a, 'tcx> Layout {\n+impl<'a, 'tcx> Layout<'tcx> {\n     fn compute_uncached(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         param_env: ty::ParamEnv<'tcx>,\n                         ty: Ty<'tcx>)\n@@ -1624,7 +1624,9 @@ impl<'a, 'tcx> Layout {\n                             size: st[discr].stride(),\n                             align,\n                             primitive_align,\n-                            variants: st,\n+                            variants: st.into_iter().map(|variant| {\n+                                success(Univariant(variant))\n+                            }).collect::<Result<Vec<_>, _>>()?,\n                         });\n                     }\n                 }\n@@ -1730,7 +1732,9 @@ impl<'a, 'tcx> Layout {\n \n                     // FIXME: should be u128?\n                     discr_range: (min as u64)..=(max as u64),\n-                    variants,\n+                    variants: variants.into_iter().map(|variant| {\n+                        success(Univariant(variant))\n+                    }).collect::<Result<Vec<_>, _>>()?,\n                     size,\n                     align,\n                     primitive_align,\n@@ -1897,6 +1901,10 @@ impl<'a, 'tcx> Layout {\n                                                        .iter()\n                                                        .map(|f| (f.name, f.ty(tcx, substs)))\n                                                        .collect();\n+                                        let variant_layout = match *variant_layout.layout {\n+                                            Univariant(ref variant) => variant,\n+                                            _ => bug!()\n+                                        };\n                                         build_variant_info(Some(variant_def.name),\n                                                            &fields,\n                                                            variant_layout)\n@@ -2084,7 +2092,7 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n pub struct FullLayout<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub variant_index: Option<usize>,\n-    pub layout: &'tcx Layout,\n+    pub layout: &'tcx Layout<'tcx>,\n     pub fields: FieldPlacement<'tcx>,\n     pub abi: Abi,\n }\n@@ -2198,27 +2206,22 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n             variants[variant_index].fields.len()\n         };\n \n-        let (fields, abi) = match *self.layout {\n-            Univariant(_) => (self.fields, self.abi),\n+        let (layout, fields, abi) = match *self.layout {\n+            Univariant(_) => (self.layout, self.fields, self.abi),\n \n             NullablePointer { ref variants, .. } |\n             General { ref variants, .. } => {\n-                let variant = &variants[variant_index];\n-                (FieldPlacement::Arbitrary {\n-                    offsets: &variant.offsets\n-                }, Abi::Aggregate {\n-                    sized: true,\n-                    align: variant.align,\n-                    primitive_align: variant.primitive_align,\n-                    size: variant.stride(),\n-                })\n+                let variant = variants[variant_index];\n+                (variant.layout, variant.fields, variant.abi)\n             }\n \n-            _ => (FieldPlacement::union(count), self.abi)\n+            _ => bug!()\n         };\n+        assert_eq!(fields.count(), count);\n \n         FullLayout {\n             variant_index: Some(variant_index),\n+            layout,\n             fields,\n             abi,\n             ..*self\n@@ -2348,8 +2351,7 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout\n-{\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {"}, {"sha": "f59b372e7d5311291d13938481069b2e37fdb65a", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed788a62f62db010f3e92ec4756728151af368a2/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed788a62f62db010f3e92ec4756728151af368a2/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=ed788a62f62db010f3e92ec4756728151af368a2", "patch": "@@ -764,7 +764,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                         .zip(variants)\n                         .map(|(variant, variant_layout)| {\n                             // Subtract the size of the enum discriminant\n-                            let bytes = variant_layout.min_size\n+                            let bytes = variant_layout.abi.size(cx.tcx)\n                                 .bytes()\n                                 .saturating_sub(discr_size);\n "}, {"sha": "ff66090dc8c16897b86c563c9e57c74b5a219341", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed788a62f62db010f3e92ec4756728151af368a2/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed788a62f62db010f3e92ec4756728151af368a2/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=ed788a62f62db010f3e92ec4756728151af368a2", "patch": "@@ -87,7 +87,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             } else {\n                 l\n             };\n-            llty.set_struct_body(&struct_llfields(cx, variant_layout, variant), variant.packed)\n+            llty.set_struct_body(&struct_llfields(cx, variant_layout), variant.packed)\n         },\n         _ => bug!(\"This function cannot handle {} with layout {:#?}\", t, l)\n     }\n@@ -105,8 +105,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         layout::Univariant(ref variant) => {\n             match name {\n                 None => {\n-                    Type::struct_(cx, &struct_llfields(cx, l, &variant),\n-                                  variant.packed)\n+                    Type::struct_(cx, &struct_llfields(cx, l), variant.packed)\n                 }\n                 Some(name) => {\n                     Type::named_struct(cx, name)\n@@ -166,8 +165,11 @@ pub fn memory_index_to_gep(index: u64) -> u64 {\n }\n \n pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                 layout: FullLayout<'tcx>,\n-                                 variant: &layout::Struct) -> Vec<Type> {\n+                                 layout: FullLayout<'tcx>) -> Vec<Type> {\n+    let variant = match *layout.layout {\n+        layout::Univariant(ref variant) => variant,\n+        _ => bug!(\"unexpected {:#?}\", layout)\n+    };\n     let field_count = layout.fields.count();\n     debug!(\"struct_llfields: variant: {:?}\", variant);\n     let mut offset = Size::from_bytes(0);"}, {"sha": "89f1bb6fd51120ba42ed079f6eca3594613aec36", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 52, "deletions": 91, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/ed788a62f62db010f3e92ec4756728151af368a2/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed788a62f62db010f3e92ec4756728151af368a2/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=ed788a62f62db010f3e92ec4756728151af368a2", "patch": "@@ -1153,47 +1153,41 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n             layout::General { ref variants, .. } => {\n                 let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n                     .expect(\"\"));\n-                variants\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, struct_def)| {\n-                        let (variant_type_metadata, member_desc_factory) =\n-                            describe_enum_variant(cx,\n-                                                  self.enum_type,\n-                                                  struct_def,\n-                                                  i,\n-                                                  &adt.variants[i],\n-                                                  discriminant_info,\n-                                                  self.containing_scope,\n-                                                  self.span);\n-\n-                        let member_descriptions = member_desc_factory\n-                            .create_member_descriptions(cx);\n-\n-                        set_members_of_composite_type(cx,\n-                                                      variant_type_metadata,\n-                                                      &member_descriptions);\n-                        MemberDescription {\n-                            name: \"\".to_string(),\n-                            type_metadata: variant_type_metadata,\n-                            offset: Size::from_bytes(0),\n-                            size: struct_def.stride(),\n-                            align: struct_def.align,\n-                            flags: DIFlags::FlagZero\n-                        }\n-                    }).collect()\n+                (0..variants.len()).map(|i| {\n+                    let variant = self.type_rep.for_variant(i);\n+                    let (variant_type_metadata, member_desc_factory) =\n+                        describe_enum_variant(cx,\n+                                              variant,\n+                                              &adt.variants[i],\n+                                              discriminant_info,\n+                                              self.containing_scope,\n+                                              self.span);\n+\n+                    let member_descriptions = member_desc_factory\n+                        .create_member_descriptions(cx);\n+\n+                    set_members_of_composite_type(cx,\n+                                                  variant_type_metadata,\n+                                                  &member_descriptions);\n+                    MemberDescription {\n+                        name: \"\".to_string(),\n+                        type_metadata: variant_type_metadata,\n+                        offset: Size::from_bytes(0),\n+                        size: variant.size(cx),\n+                        align: variant.align(cx),\n+                        flags: DIFlags::FlagZero\n+                    }\n+                }).collect()\n             },\n-            layout::Univariant(ref variant) => {\n+            layout::Univariant(_) => {\n                 assert!(adt.variants.len() <= 1);\n \n                 if adt.variants.is_empty() {\n                     vec![]\n                 } else {\n                     let (variant_type_metadata, member_description_factory) =\n                         describe_enum_variant(cx,\n-                                              self.enum_type,\n-                                              variant,\n-                                              0,\n+                                              self.type_rep,\n                                               &adt.variants[0],\n                                               NoDiscriminant,\n                                               self.containing_scope,\n@@ -1210,8 +1204,8 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                             name: \"\".to_string(),\n                             type_metadata: variant_type_metadata,\n                             offset: Size::from_bytes(0),\n-                            size: variant.stride(),\n-                            align: variant.align,\n+                            size: self.type_rep.size(cx),\n+                            align: self.type_rep.align(cx),\n                             flags: DIFlags::FlagZero\n                         }\n                     ]\n@@ -1221,16 +1215,13 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 nndiscr,\n                 discr,\n                 discr_offset,\n-                ref variants,\n                 ..\n             } => {\n-                let struct_def = &variants[nndiscr as usize];\n+                let variant = self.type_rep.for_variant(nndiscr as usize);\n                 // Create a description of the non-null variant\n                 let (variant_type_metadata, member_description_factory) =\n                     describe_enum_variant(cx,\n-                                          self.enum_type,\n-                                          struct_def,\n-                                          nndiscr as usize,\n+                                          variant,\n                                           &adt.variants[nndiscr as usize],\n                                           OptimizedDiscriminant,\n                                           self.containing_scope,\n@@ -1278,8 +1269,8 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         name,\n                         type_metadata: variant_type_metadata,\n                         offset: Size::from_bytes(0),\n-                        size: struct_def.stride(),\n-                        align: struct_def.align,\n+                        size: variant.size(cx),\n+                        align: variant.align(cx),\n                         flags: DIFlags::FlagZero\n                     }\n                 ]\n@@ -1330,78 +1321,48 @@ enum EnumDiscriminantInfo {\n // descriptions of the fields of the variant. This is a rudimentary version of a\n // full RecursiveTypeDescription.\n fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                   enum_type: Ty<'tcx>,\n-                                   struct_def: &'tcx layout::Struct,\n-                                   variant_index: usize,\n+                                   layout: layout::FullLayout<'tcx>,\n                                    variant: &'tcx ty::VariantDef,\n                                    discriminant_info: EnumDiscriminantInfo,\n                                    containing_scope: DIScope,\n                                    span: Span)\n                                    -> (DICompositeType, MemberDescriptionFactory<'tcx>) {\n-    let layout = cx.layout_of(enum_type);\n-    let maybe_discr = match *layout.layout {\n-        layout::General { .. } => Some(layout.field(cx, 0).ty),\n-        _ => None,\n-    };\n-\n-    let layout = layout.for_variant(variant_index);\n-    let mut field_tys = (0..layout.fields.count()).map(|i| {\n-        layout.field(cx, i).ty\n-    }).collect::<Vec<_>>();\n-\n-    if let Some(discr) = maybe_discr {\n-        field_tys.insert(0, discr);\n-    }\n-\n-    // Could do some consistency checks here: size, align, field count, discr type\n-\n     let variant_name = variant.name.as_str();\n     let unique_type_id = debug_context(cx).type_map\n                                           .borrow_mut()\n                                           .get_unique_type_id_of_enum_variant(\n                                               cx,\n-                                              enum_type,\n+                                              layout.ty,\n                                               &variant_name);\n \n     let metadata_stub = create_struct_stub(cx,\n-                                           enum_type,\n+                                           layout.ty,\n                                            &variant_name,\n                                            unique_type_id,\n                                            containing_scope);\n \n-    // Get the argument names from the enum variant info\n-    let mut arg_names: Vec<_> = match variant.ctor_kind {\n-        CtorKind::Const => vec![],\n-        CtorKind::Fn => {\n-            variant.fields\n-                   .iter()\n-                   .enumerate()\n-                   .map(|(i, _)| format!(\"__{}\", i))\n-                   .collect()\n-        }\n-        CtorKind::Fictive => {\n-            variant.fields\n-                   .iter()\n-                   .map(|f| f.name.to_string())\n-                   .collect()\n-        }\n-    };\n-\n     // If this is not a univariant enum, there is also the discriminant field.\n-    let mut offsets = struct_def.offsets.clone();\n-    match discriminant_info {\n+    let (discr_offset, discr_arg) = match discriminant_info {\n         RegularDiscriminant(_) => {\n-            arg_names.insert(0, \"RUST$ENUM$DISR\".to_string());\n-            offsets.insert(0, Size::from_bytes(0));\n+            let enum_layout = cx.layout_of(layout.ty);\n+            (Some(enum_layout.fields.offset(0)),\n+             Some((\"RUST$ENUM$DISR\".to_string(), enum_layout.field(cx, 0).ty)))\n         }\n-        _ => { /* do nothing */ }\n+        _ => (None, None),\n     };\n+    let offsets = discr_offset.into_iter().chain((0..layout.fields.count()).map(|i| {\n+        layout.fields.offset(i)\n+    })).collect();\n \n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n-    let args: Vec<(String, Ty)> = arg_names.iter()\n-        .zip(field_tys.iter())\n-        .map(|(s, &t)| (s.to_string(), t))\n-        .collect();\n+    let args = discr_arg.into_iter().chain((0..layout.fields.count()).map(|i| {\n+        let name = if variant.ctor_kind == CtorKind::Fn {\n+            format!(\"__{}\", i)\n+        } else {\n+            variant.fields[i].name.to_string()\n+        };\n+        (name, layout.field(cx, i).ty)\n+    })).collect();\n \n     let member_description_factory =\n         VariantMDF(VariantMemberDescriptionFactory {"}, {"sha": "8924fc3b5acb8ca5f48e390e85db25511a1262b5", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ed788a62f62db010f3e92ec4756728151af368a2/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed788a62f62db010f3e92ec4756728151af368a2/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=ed788a62f62db010f3e92ec4756728151af368a2", "patch": "@@ -1091,7 +1091,7 @@ fn trans_const_adt<'a, 'tcx>(\n         _ => 0,\n     };\n     match *l.layout {\n-        layout::General { ref variants, .. } => {\n+        layout::General { .. } => {\n             let discr = match *kind {\n                 mir::AggregateKind::Adt(adt_def, _, _, _) => {\n                     adt_def.discriminant_for_variant(ccx.tcx(), variant_index)\n@@ -1105,7 +1105,7 @@ fn trans_const_adt<'a, 'tcx>(\n             if let layout::Abi::Scalar(_) = l.abi {\n                 discr\n             } else {\n-                build_const_struct(ccx, l, &variants[variant_index], vals, Some(discr))\n+                build_const_struct(ccx, l.for_variant(variant_index), vals, Some(discr))\n             }\n         }\n         layout::UntaggedUnion(ref un) => {\n@@ -1117,16 +1117,16 @@ fn trans_const_adt<'a, 'tcx>(\n \n             Const::new(C_struct(ccx, &contents, un.packed), t)\n         }\n-        layout::Univariant(ref variant) => {\n+        layout::Univariant(_) => {\n             assert_eq!(variant_index, 0);\n-            build_const_struct(ccx, l, &variant, vals, None)\n+            build_const_struct(ccx, l, vals, None)\n         }\n         layout::Vector { .. } => {\n             Const::new(C_vector(&vals.iter().map(|x| x.llval).collect::<Vec<_>>()), t)\n         }\n-        layout::NullablePointer { ref variants, nndiscr, .. } => {\n+        layout::NullablePointer { nndiscr, .. } => {\n             if variant_index as u64 == nndiscr {\n-                build_const_struct(ccx, l, &variants[variant_index], vals, None)\n+                build_const_struct(ccx, l.for_variant(variant_index), vals, None)\n             } else {\n                 // Always use null even if it's not the `discrfield`th\n                 // field; see #8506.\n@@ -1147,33 +1147,36 @@ fn trans_const_adt<'a, 'tcx>(\n /// will read the wrong memory.\n fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 layout: layout::FullLayout<'tcx>,\n-                                st: &layout::Struct,\n                                 vals: &[Const<'tcx>],\n                                 discr: Option<Const<'tcx>>)\n                                 -> Const<'tcx> {\n-    assert_eq!(vals.len(), st.offsets.len());\n+    assert_eq!(vals.len(), layout.fields.count());\n \n     // offset of current value\n     let mut offset = Size::from_bytes(0);\n     let mut cfields = Vec::new();\n-    cfields.reserve(discr.is_some() as usize + 1 + st.offsets.len() * 2);\n+    cfields.reserve(discr.is_some() as usize + 1 + layout.fields.count() * 2);\n \n     if let Some(discr) = discr {\n         cfields.push(discr.llval);\n         offset = ccx.size_of(discr.ty);\n     }\n \n+    let st = match *layout.layout {\n+        layout::Univariant(ref variant) => variant,\n+        _ => bug!(\"unexpected {:#?}\", layout)\n+    };\n     let parts = st.field_index_by_increasing_offset().map(|i| {\n-        (vals[i], st.offsets[i])\n+        (vals[i], layout.fields.offset(i))\n     });\n     for (val, target_offset) in parts {\n         cfields.push(padding(ccx, target_offset - offset));\n         cfields.push(val.llval);\n         offset = target_offset + ccx.size_of(val.ty);\n     }\n \n-    let size = layout.size(ccx);\n-    cfields.push(padding(ccx, size - offset));\n+    // Pad to the size of the whole type, not e.g. the variant.\n+    cfields.push(padding(ccx, ccx.size_of(layout.ty) - offset));\n \n     Const::new(C_struct(ccx, &cfields, st.packed), layout.ty)\n }"}, {"sha": "ab31bcde52aebbbc10c5393e171141ab31d0c5b8", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ed788a62f62db010f3e92ec4756728151af368a2/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed788a62f62db010f3e92ec4756728151af368a2/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=ed788a62f62db010f3e92ec4756728151af368a2", "patch": "@@ -55,7 +55,7 @@ impl ops::BitOr for Alignment {\n     }\n }\n \n-impl<'a> From<&'a Layout> for Alignment {\n+impl<'a> From<&'a Layout<'a>> for Alignment {\n     fn from(layout: &Layout) -> Self {\n         let (packed, align) = match *layout {\n             Layout::UntaggedUnion(ref un) => (un.packed, un.align),\n@@ -234,27 +234,24 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         }\n \n         // Discriminant field of enums.\n-        match *l.layout {\n-            layout::NullablePointer { .. } if l.variant_index.is_none() => {\n-                let ty = ccx.llvm_type_of(field.ty);\n-                let size = field.size(ccx).bytes();\n-\n-                // If the discriminant is not on a multiple of the primitive's size,\n-                // we need to go through i8*. Also assume the worst alignment.\n-                if offset % size != 0 {\n-                    let byte_ptr = bcx.pointercast(self.llval, Type::i8p(ccx));\n-                    let byte_ptr = bcx.inbounds_gep(byte_ptr, &[C_usize(ccx, offset)]);\n-                    let byte_align = Alignment::Packed(Align::from_bytes(1, 1).unwrap());\n-                    return LvalueRef::new_sized(\n-                        bcx.pointercast(byte_ptr, ty.ptr_to()), field.ty, byte_align);\n-                }\n-\n-                let discr_ptr = bcx.pointercast(self.llval, ty.ptr_to());\n+        if let layout::NullablePointer { .. } = *l.layout {\n+            let ty = ccx.llvm_type_of(field.ty);\n+            let size = field.size(ccx).bytes();\n+\n+            // If the discriminant is not on a multiple of the primitive's size,\n+            // we need to go through i8*. Also assume the worst alignment.\n+            if offset % size != 0 {\n+                let byte_ptr = bcx.pointercast(self.llval, Type::i8p(ccx));\n+                let byte_ptr = bcx.inbounds_gep(byte_ptr, &[C_usize(ccx, offset)]);\n+                let byte_align = Alignment::Packed(Align::from_bytes(1, 1).unwrap());\n                 return LvalueRef::new_sized(\n-                    bcx.inbounds_gep(discr_ptr, &[C_usize(ccx, offset / size)]),\n-                    field.ty, alignment);\n+                    bcx.pointercast(byte_ptr, ty.ptr_to()), field.ty, byte_align);\n             }\n-            _ => {}\n+\n+            let discr_ptr = bcx.pointercast(self.llval, ty.ptr_to());\n+            return LvalueRef::new_sized(\n+                bcx.inbounds_gep(discr_ptr, &[C_usize(ccx, offset / size)]),\n+                field.ty, alignment);\n         }\n \n         let simple = || {\n@@ -271,10 +268,8 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         };\n \n         // Check whether the variant being used is packed, if applicable.\n-        let is_packed = match (l.layout, l.variant_index) {\n-            (&layout::Univariant(ref variant), _) => variant.packed,\n-            (&layout::NullablePointer { ref variants, .. }, Some(v)) |\n-            (&layout::General { ref variants, .. }, Some(v)) => variants[v].packed,\n+        let is_packed = match *l.layout {\n+            layout::Univariant(ref variant) => variant.packed,\n             _ => return simple()\n         };\n \n@@ -470,13 +465,13 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             };\n \n             // If this is an enum, cast to the appropriate variant struct type.\n-            let layout = bcx.ccx.layout_of(ty).for_variant(variant_index);\n-            match *layout.layout {\n-                layout::NullablePointer { ref variants, .. } |\n-                layout::General { ref variants, .. } => {\n-                    let st = &variants[variant_index];\n+            let layout = bcx.ccx.layout_of(ty);\n+            let variant_layout = layout.for_variant(variant_index);\n+            match (layout.layout, variant_layout.layout) {\n+                (&layout::NullablePointer { .. }, &layout::Univariant(ref st)) |\n+                (&layout::General { .. }, &layout::Univariant(ref st)) => {\n                     let variant_ty = Type::struct_(bcx.ccx,\n-                        &adt::struct_llfields(bcx.ccx, layout, st), st.packed);\n+                        &adt::struct_llfields(bcx.ccx, variant_layout), st.packed);\n                     downcast.llval = bcx.pointercast(downcast.llval, variant_ty.ptr_to());\n                 }\n                 _ => {}"}, {"sha": "679632d91133c35986d96f661987f663e1b07a88", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed788a62f62db010f3e92ec4756728151af368a2/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed788a62f62db010f3e92ec4756728151af368a2/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=ed788a62f62db010f3e92ec4756728151af368a2", "patch": "@@ -242,7 +242,9 @@ impl<'tcx> LayoutLlvmExt for FullLayout<'tcx> {\n         }\n         match *self.layout {\n             Layout::Scalar { .. } |\n-            Layout::UntaggedUnion { .. } => {\n+            Layout::UntaggedUnion { .. } |\n+            Layout::NullablePointer { .. } |\n+            Layout::General { .. } => {\n                 bug!(\"FullLayout::llvm_field_index({:?}): not applicable\", self)\n             }\n \n@@ -258,15 +260,6 @@ impl<'tcx> LayoutLlvmExt for FullLayout<'tcx> {\n             Layout::Univariant(ref variant) => {\n                 adt::memory_index_to_gep(variant.memory_index[index] as u64)\n             }\n-\n-            Layout::NullablePointer { ref variants, .. } |\n-            Layout::General { ref variants, .. } => {\n-                if let Some(v) = self.variant_index {\n-                    adt::memory_index_to_gep(variants[v].memory_index[index] as u64)\n-                } else {\n-                    bug!(\"FullLayout::llvm_field_index({:?}): not applicable\", self)\n-                }\n-            }\n         }\n     }\n }"}]}