{"sha": "b0ed151539cddb1c191f67f9f9597942919d44eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwZWQxNTE1MzljZGRiMWMxOTFmNjdmOWY5NTk3OTQyOTE5ZDQ0ZWI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-11-05T04:41:00Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-11-06T16:56:29Z"}, "message": "Cleanup how we handle proto in types, remove unsound subtyping\n\nFixes #1896 which was never truly fixed, just masked.\nThe given tests would have failed had they used `~fn()` and\nnot `@fn()`.  They now result in compilation errors.\n\nFixes #2978.\n\nNecessary first step for #2202, #2263.", "tree": {"sha": "976ed7cab726c0cdae81e0a18e28a27cbd5e4664", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/976ed7cab726c0cdae81e0a18e28a27cbd5e4664"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0ed151539cddb1c191f67f9f9597942919d44eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0ed151539cddb1c191f67f9f9597942919d44eb", "html_url": "https://github.com/rust-lang/rust/commit/b0ed151539cddb1c191f67f9f9597942919d44eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0ed151539cddb1c191f67f9f9597942919d44eb/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53ec6c3f9b495dd930cd061784251534bef58d74", "url": "https://api.github.com/repos/rust-lang/rust/commits/53ec6c3f9b495dd930cd061784251534bef58d74", "html_url": "https://github.com/rust-lang/rust/commit/53ec6c3f9b495dd930cd061784251534bef58d74"}], "stats": {"total": 1949, "additions": 947, "deletions": 1002}, "files": [{"sha": "8fcb9300b52e971bd802df9d54a41a4fa483e8ad", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -410,18 +410,24 @@ impl mutability : cmp::Eq {\n \n #[auto_serialize]\n #[auto_deserialize]\n-enum proto {\n-    proto_bare,    // foreign fn\n-    proto_uniq,    // fn~\n-    proto_box,     // fn@\n-    proto_block,   // fn&\n+pub enum Proto {\n+    ProtoBare,     // bare functions (deprecated)\n+    ProtoUniq,     // ~fn\n+    ProtoBox,      // @fn\n+    ProtoBorrowed, // &fn\n }\n \n-impl proto : cmp::Eq {\n-    pure fn eq(other: &proto) -> bool {\n+impl Proto : cmp::Eq {\n+    pure fn eq(other: &Proto) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n-    pure fn ne(other: &proto) -> bool { !self.eq(other) }\n+    pure fn ne(other: &Proto) -> bool { !self.eq(other) }\n+}\n+\n+impl Proto : to_bytes::IterBytes {\n+    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n+        (self as uint).iter_bytes(lsb0, f);\n+    }\n }\n \n #[auto_serialize]\n@@ -444,10 +450,10 @@ enum expr_vstore {\n     expr_vstore_slice                  // &[1,2,3,4]\n }\n \n-pure fn is_blockish(p: ast::proto) -> bool {\n+pure fn is_blockish(p: ast::Proto) -> bool {\n     match p {\n-      proto_block => true,\n-      proto_bare | proto_uniq | proto_box => false\n+        ProtoBorrowed => true,\n+        ProtoBare | ProtoUniq | ProtoBox => false\n     }\n }\n \n@@ -678,7 +684,7 @@ enum expr_ {\n        (implicit) condition is always true. */\n     expr_loop(blk, Option<ident>),\n     expr_match(@expr, ~[arm]),\n-    expr_fn(proto, fn_decl, blk, capture_clause),\n+    expr_fn(Proto, fn_decl, blk, capture_clause),\n     expr_fn_block(fn_decl, blk, capture_clause),\n     // Inner expr is always an expr_fn_block. We need the wrapping node to\n     // easily type this (a function returning nil on the inside but bool on\n@@ -1078,6 +1084,17 @@ impl Onceness : cmp::Eq {\n     }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n+struct TyFn {\n+    proto: Proto,\n+    region: Option<@region>,\n+    purity: purity,\n+    onceness: Onceness,\n+    bounds: @~[ty_param_bound],\n+    decl: fn_decl\n+}\n+\n #[auto_serialize]\n #[auto_deserialize]\n enum ty_ {\n@@ -1086,13 +1103,13 @@ enum ty_ {\n     ty_box(mt),\n     ty_uniq(mt),\n     ty_vec(mt),\n+    ty_fixed_length_vec(mt, uint),\n     ty_ptr(mt),\n     ty_rptr(@region, mt),\n     ty_rec(~[ty_field]),\n-    ty_fn(proto, purity, Onceness, @~[ty_param_bound], fn_decl),\n+    ty_fn(@TyFn),\n     ty_tup(~[@Ty]),\n     ty_path(@path, node_id),\n-    ty_fixed_length(@Ty, Option<uint>),\n     ty_mac(mac),\n     // ty_infer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not"}, {"sha": "3879e70cb288806431e8aeb313e459c6238b9d50", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -524,15 +524,19 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n       ty_ptr(mt) => ty_ptr(fold_mt(mt, fld)),\n       ty_rptr(region, mt) => ty_rptr(region, fold_mt(mt, fld)),\n       ty_rec(fields) => ty_rec(vec::map(fields, |f| fold_field(*f, fld))),\n-      ty_fn(proto, purity, onceness, bounds, decl) =>\n-        ty_fn(proto,\n-              purity,\n-              onceness,\n-              @vec::map(*bounds, |x| fold_ty_param_bound(*x, fld)),\n-              fold_fn_decl(decl, fld)),\n+      ty_fn(f) =>\n+        ty_fn(@TyFn {\n+            proto: f.proto,\n+            purity: f.purity,\n+            region: f.region,\n+            onceness: f.onceness,\n+            bounds: @vec::map(*f.bounds, |x| fold_ty_param_bound(*x, fld)),\n+            decl: fold_fn_decl(f.decl, fld)\n+        }),\n       ty_tup(tys) => ty_tup(vec::map(tys, |ty| fld.fold_ty(*ty))),\n       ty_path(path, id) => ty_path(fld.fold_path(path), fld.new_id(id)),\n-      ty_fixed_length(t, vs) => ty_fixed_length(fld.fold_ty(t), vs),\n+      ty_fixed_length_vec(mt, vs) =>\n+        ty_fixed_length_vec(fold_mt(mt, fld), vs),\n       ty_mac(mac) => ty_mac(fold_mac(mac))\n     }\n }"}, {"sha": "e5f6cf8ee253756689198fc008b74e75237cfe05", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -24,7 +24,6 @@ pub enum ObsoleteSyntax {\n     ObsoletePrivSection,\n     ObsoleteModeInFnType,\n     ObsoleteByMutRefMode,\n-    ObsoleteFixedLengthVec,\n     ObsoleteMoveInit,\n     ObsoleteBinaryMove\n }\n@@ -102,11 +101,6 @@ impl Parser : ObsoleteReporter {\n                 \"by-mutable-reference mode\",\n                 \"Declare an argument of type &mut T instead\"\n             ),\n-            ObsoleteFixedLengthVec => (\n-                \"fixed-length vector\",\n-                \"Fixed-length types are now written `[T * N]`, and instances \\\n-                 are type-inferred\"\n-            ),\n             ObsoleteMoveInit => (\n                 \"initializer-by-move\",\n                 \"Write `let foo = move bar` instead\"\n@@ -200,65 +194,5 @@ impl Parser : ObsoleteReporter {\n         }\n     }\n \n-    fn try_parse_obsolete_fixed_vstore() -> Option<Option<uint>> {\n-        if self.token == token::BINOP(token::SLASH) {\n-            self.bump();\n-            match copy self.token {\n-                token::UNDERSCORE => {\n-                    self.obsolete(copy self.last_span,\n-                                  ObsoleteFixedLengthVec);\n-                    self.bump(); Some(None)\n-                }\n-                token::LIT_INT_UNSUFFIXED(i) if i >= 0i64 => {\n-                    self.obsolete(copy self.last_span,\n-                                  ObsoleteFixedLengthVec);\n-                    self.bump(); Some(Some(i as uint))\n-                }\n-                _ => None\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn try_convert_ty_to_obsolete_fixed_length_vstore(sp: span, t: ast::ty_)\n-        -> ast::ty_ {\n-        match self.try_parse_obsolete_fixed_vstore() {\n-            // Consider a fixed length vstore suffix (/N or /_)\n-            None => t,\n-            Some(v) => {\n-                ast::ty_fixed_length(\n-                    @{id: self.get_id(), node: t, span: sp}, v)\n-            }\n-        }\n-    }\n-\n-    fn try_convert_expr_to_obsolete_fixed_length_vstore(\n-        lo: uint, hi: uint, ex: ast::expr_\n-    ) -> (uint, ast::expr_) {\n-\n-        let mut hi = hi;\n-        let mut ex = ex;\n-\n-        // Vstore is legal following expr_lit(lit_str(...)) and expr_vec(...)\n-        // only.\n-        match ex {\n-            ast::expr_lit(@{node: ast::lit_str(_), span: _}) |\n-            ast::expr_vec(_, _)  => {\n-                match self.try_parse_obsolete_fixed_vstore() {\n-                    None => (),\n-                    Some(v) => {\n-                        hi = self.span.hi;\n-                        ex = ast::expr_vstore(self.mk_expr(lo, hi, ex),\n-                                              ast::expr_vstore_fixed(v));\n-                    }\n-                }\n-            }\n-            _ => ()\n-        }\n-\n-        return (hi, ex);\n-    }\n-\n }\n "}, {"sha": "db3f6abbf7b79aa13cb7d916a8531b6a24bb0a63", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 173, "deletions": 102, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -50,8 +50,8 @@ use ast::{_mod, add, arg, arm, attribute,\n              match_tok, method, mode, module_ns, mt, mul, mutability,\n              named_field, neg, noreturn, not, pat, pat_box, pat_enum,\n              pat_ident, pat_lit, pat_range, pat_rec, pat_region, pat_struct,\n-             pat_tup, pat_uniq, pat_wild, path, private, proto, proto_bare,\n-             proto_block, proto_box, proto_uniq, provided, public, pure_fn,\n+             pat_tup, pat_uniq, pat_wild, path, private, Proto, ProtoBare,\n+             ProtoBorrowed, ProtoBox, ProtoUniq, provided, public, pure_fn,\n              purity, re_static, re_self, re_anon, re_named, region,\n              rem, required, ret_style,\n              return_val, self_ty, shl, shr, stmt, stmt_decl, stmt_expr,\n@@ -61,14 +61,14 @@ use ast::{_mod, add, arg, arm, attribute,\n              tt_tok, tt_nonterminal, tuple_variant_kind, Ty, ty_, ty_bot,\n              ty_box, ty_field, ty_fn, ty_infer, ty_mac, ty_method, ty_nil,\n              ty_param, ty_param_bound, ty_path, ty_ptr, ty_rec, ty_rptr,\n-             ty_tup, ty_u32, ty_uniq, ty_vec, ty_fixed_length, type_value_ns,\n-             uniq, unnamed_field, unsafe_blk, unsafe_fn,\n+             ty_tup, ty_u32, ty_uniq, ty_vec, ty_fixed_length_vec,\n+             type_value_ns, uniq, unnamed_field, unsafe_blk, unsafe_fn,\n              variant, view_item, view_item_, view_item_export,\n              view_item_import, view_item_use, view_path, view_path_glob,\n              view_path_list, view_path_simple, visibility, vstore, vstore_box,\n              vstore_fixed, vstore_slice, vstore_uniq,\n              expr_vstore_fixed, expr_vstore_slice, expr_vstore_box,\n-             expr_vstore_uniq};\n+             expr_vstore_uniq, TyFn, Onceness, Once, Many};\n \n export file_type;\n export Parser;\n@@ -287,30 +287,90 @@ impl Parser {\n \n     pure fn id_to_str(id: ident) -> @~str { self.sess.interner.get(id) }\n \n-    fn parse_ty_fn(purity: ast::purity, onceness: ast::Onceness) -> ty_ {\n-        let proto, bounds;\n+    fn token_is_fn_keyword(+tok: token::Token) -> bool {\n+        self.token_is_keyword(~\"pure\", tok) ||\n+            self.token_is_keyword(~\"unsafe\", tok) ||\n+            self.token_is_keyword(~\"once\", tok) ||\n+            self.token_is_keyword(~\"fn\", tok) ||\n+            self.token_is_keyword(~\"extern\", tok)\n+    }\n+\n+    fn parse_ty_fn(pre_proto: Option<ast::Proto>,\n+                       pre_region_name: Option<ident>) -> ty_\n+    {\n+        /*\n+\n+        (&|~|@) [r/] [pure|unsafe] [once] fn [:K] (S) -> T\n+        ^~~~~~^ ^~~^ ^~~~~~~~~~~~^ ^~~~~^    ^~~^ ^~^    ^\n+           |     |     |             |        |    |     |\n+           |     |     |             |        |    |   Return type\n+           |     |     |             |        |  Argument types\n+           |     |     |             |    Environment bounds\n+           |     |     |          Once-ness (a.k.a., affine)\n+           |     |   Purity\n+           | Lifetime bound\n+        Allocation type\n+\n+        */\n+\n+        // At this point, the allocation type and lifetime bound have been\n+        // parsed.\n+\n+        let purity = parse_purity(&self);\n+        let onceness = parse_onceness(&self);\n+\n+        let bounds, post_proto;\n         if self.eat_keyword(~\"extern\") {\n             self.expect_keyword(~\"fn\");\n-            proto = ast::proto_bare;\n+            post_proto = Some(ast::ProtoBare);\n             bounds = @~[];\n         } else {\n             self.expect_keyword(~\"fn\");\n-            proto = self.parse_fn_ty_proto();\n+            post_proto = self.parse_fn_ty_proto();\n             bounds = self.parse_optional_ty_param_bounds();\n         };\n-        ty_fn(proto, purity, onceness, bounds, self.parse_ty_fn_decl())\n-    }\n \n-    fn parse_ty_fn_with_onceness(purity: ast::purity) -> ty_ {\n-        let onceness = self.parse_optional_onceness();\n-        self.parse_ty_fn(purity, onceness)\n-    }\n+        let proto = match (pre_proto, post_proto) {\n+            (None, None) => ast::ProtoBorrowed,\n+            (Some(p), None) | (None, Some(p)) => p,\n+            (Some(_), Some(_)) => {\n+                self.fatal(~\"cannot combine prefix and postfix \\\n+                             syntax for closure kind; note that \\\n+                             postfix syntax is obsolete\");\n+            }\n+        };\n+\n+        let region = if pre_region_name.is_some() {\n+            Some(self.region_from_name(pre_region_name))\n+        } else {\n+            None\n+        };\n+\n+        return ty_fn(@TyFn {\n+            proto: proto,\n+            region: region,\n+            purity: purity,\n+            onceness: onceness,\n+            bounds: bounds,\n+            decl: self.parse_ty_fn_decl()\n+        });\n+\n+        fn parse_purity(self: &Parser) -> purity {\n+            if self.eat_keyword(~\"pure\") {\n+                return pure_fn;\n+            } else if self.eat_keyword(~\"unsafe\") {\n+                return unsafe_fn;\n+            } else {\n+                return impure_fn;\n+            }\n+        }\n \n-    fn parse_ty_fn_with_purity_and_onceness() -> ty_ {\n-        let purity = self.parse_optional_purity();\n-        self.parse_ty_fn_with_onceness(purity)\n+        fn parse_onceness(self: &Parser) -> Onceness {\n+            if self.eat_keyword(~\"once\") {Once} else {Many}\n+        }\n     }\n \n+\n     fn parse_ty_fn_decl() -> fn_decl {\n         let inputs = do self.parse_unspanned_seq(\n             token::LPAREN, token::RPAREN,\n@@ -449,23 +509,6 @@ impl Parser {\n         }\n     }\n \n-    // Parses something like \"&x/\" (note the trailing slash)\n-    fn parse_region_with_sep() -> @region {\n-        let name =\n-            match copy self.token {\n-              token::IDENT(sid, _) => {\n-                if self.look_ahead(1u) == token::BINOP(token::SLASH) {\n-                    self.bump(); self.bump();\n-                    Some(sid)\n-                } else {\n-                    None\n-                }\n-              }\n-              _ => { None }\n-            };\n-        self.region_from_name(name)\n-    }\n-\n     fn parse_ty(colons_before_params: bool) -> @Ty {\n         maybe_whole!(self, nt_ty);\n \n@@ -498,10 +541,10 @@ impl Parser {\n             }\n         } else if self.token == token::AT {\n             self.bump();\n-            ty_box(self.parse_mt())\n+            self.parse_box_or_uniq_pointee(ast::ProtoBox, ty_box)\n         } else if self.token == token::TILDE {\n             self.bump();\n-            ty_uniq(self.parse_mt())\n+            self.parse_box_or_uniq_pointee(ast::ProtoUniq, ty_uniq)\n         } else if self.token == token::BINOP(token::STAR) {\n             self.bump();\n             ty_ptr(self.parse_mt())\n@@ -516,51 +559,77 @@ impl Parser {\n             ty_rec(elems)\n         } else if self.token == token::LBRACKET {\n             self.expect(token::LBRACKET);\n-            let mut t = ty_vec(self.parse_mt());\n+            let mt = self.parse_mt();\n \n             // Parse the `* 3` in `[ int * 3 ]`\n-            match self.maybe_parse_fixed_vstore_with_star() {\n-                None => {}\n-                Some(suffix) => {\n-                    t = ty_fixed_length(@{\n-                        id: self.get_id(),\n-                        node: t,\n-                        span: mk_sp(lo, self.last_span.hi)\n-                    }, suffix)\n-                }\n-            }\n+            let t = match self.maybe_parse_fixed_vstore_with_star() {\n+                None => ty_vec(mt),\n+                Some(suffix) => ty_fixed_length_vec(mt, suffix)\n+            };\n             self.expect(token::RBRACKET);\n             t\n         } else if self.token == token::BINOP(token::AND) {\n             self.bump();\n-            let region = self.parse_region_with_sep();\n-            let mt = self.parse_mt();\n-            ty_rptr(region, mt)\n-        } else if self.eat_keyword(~\"once\") {\n-            self.parse_ty_fn(ast::impure_fn, ast::Once)\n-        } else if self.eat_keyword(~\"pure\") {\n-            self.parse_ty_fn_with_onceness(ast::pure_fn)\n-        } else if self.eat_keyword(~\"unsafe\") {\n-            self.parse_ty_fn_with_onceness(ast::unsafe_fn)\n-        } else if self.is_keyword(~\"fn\") {\n-            self.parse_ty_fn_with_onceness(ast::impure_fn)\n-        } else if self.eat_keyword(~\"extern\") {\n-            self.expect_keyword(~\"fn\");\n-            ty_fn(proto_bare, ast::impure_fn, ast::Many, @~[],\n-                  self.parse_ty_fn_decl())\n+            self.parse_borrowed_pointee()\n+        } else if self.token_is_fn_keyword(self.token) {\n+            self.parse_ty_fn(None, None)\n         } else if self.token == token::MOD_SEP || is_ident(self.token) {\n             let path = self.parse_path_with_tps(colons_before_params);\n             ty_path(path, self.get_id())\n         } else { self.fatal(~\"expected type\"); };\n \n         let sp = mk_sp(lo, self.last_span.hi);\n-        return {\n-            let node =\n-                self.try_convert_ty_to_obsolete_fixed_length_vstore(sp, t);\n-            @{id: self.get_id(),\n-              node: node,\n-              span: sp}\n+        return @{id: self.get_id(), node: t, span: sp};\n+    }\n+\n+    fn parse_box_or_uniq_pointee(\n+        proto: ast::Proto,\n+        ctor: &fn(+v: mt) -> ty_) -> ty_\n+    {\n+        // @foo/fn() or @fn() are parsed directly as fn types:\n+        match copy self.token {\n+            token::IDENT(rname, _) => {\n+                if self.look_ahead(1u) == token::BINOP(token::SLASH) &&\n+                    self.token_is_fn_keyword(self.look_ahead(2u))\n+                {\n+                    self.bump(); self.bump();\n+                    return self.parse_ty_fn(Some(proto), Some(rname));\n+                } else if self.token_is_fn_keyword(self.token) {\n+                    return self.parse_ty_fn(Some(proto), None);\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        // other things are parsed as @ + a type.  Note that constructs like\n+        // @[] and @str will be resolved during typeck to slices and so forth,\n+        // rather than boxed ptrs.  But the special casing of str/vec is not\n+        // reflected in the AST type.\n+        let mt = self.parse_mt();\n+        ctor(mt)\n+    }\n+\n+    fn parse_borrowed_pointee() -> ty_ {\n+        // look for `&foo/` and interpret `foo` as the region name:\n+        let rname = match copy self.token {\n+            token::IDENT(sid, _) => {\n+                if self.look_ahead(1u) == token::BINOP(token::SLASH) {\n+                    self.bump(); self.bump();\n+                    Some(sid)\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => { None }\n         };\n+\n+        if self.token_is_fn_keyword(self.token) {\n+            return self.parse_ty_fn(Some(ProtoBorrowed), rname);\n+        }\n+\n+        let r = self.region_from_name(rname);\n+        let mt = self.parse_mt();\n+        return ty_rptr(r, mt);\n     }\n \n     fn parse_arg_mode() -> mode {\n@@ -691,16 +760,19 @@ impl Parser {\n         }\n     }\n \n-    fn maybe_parse_fixed_vstore_with_star() -> Option<Option<uint>> {\n+    fn maybe_parse_fixed_vstore_with_star() -> Option<uint> {\n         if self.eat(token::BINOP(token::STAR)) {\n             match copy self.token {\n-              token::UNDERSCORE => {\n-                self.bump(); Some(None)\n-              }\n-              token::LIT_INT_UNSUFFIXED(i) if i >= 0i64 => {\n-                self.bump(); Some(Some(i as uint))\n-              }\n-              _ => None\n+                token::LIT_INT_UNSUFFIXED(i) if i >= 0i64 => {\n+                    self.bump();\n+                    Some(i as uint)\n+                }\n+                _ => {\n+                    self.fatal(\n+                        fmt!(\"expected integral vector length \\\n+                              but found `%s`\",\n+                             token_to_str(self.reader, self.token)));\n+                }\n             }\n         } else {\n             None\n@@ -909,11 +981,13 @@ impl Parser {\n         } else if self.eat_keyword(~\"match\") {\n             return self.parse_alt_expr();\n         } else if self.eat_keyword(~\"fn\") {\n-            let proto = self.parse_fn_ty_proto();\n-            match proto {\n-              proto_bare => self.fatal(~\"fn expr are deprecated, use fn@\"),\n-              _ => { /* fallthrough */ }\n-            }\n+            let opt_proto = self.parse_fn_ty_proto();\n+            let proto = match opt_proto {\n+                None | Some(ast::ProtoBare) => {\n+                    self.fatal(~\"fn expr are deprecated, use fn@\")\n+                }\n+                Some(p) => { p }\n+            };\n             return self.parse_fn_expr(proto);\n         } else if self.eat_keyword(~\"unsafe\") {\n             return self.parse_block_expr(lo, unsafe_blk);\n@@ -1055,9 +1129,6 @@ impl Parser {\n             ex = expr_lit(@lit);\n         }\n \n-        let (hi, ex) =\n-            self.try_convert_expr_to_obsolete_fixed_length_vstore(lo, hi, ex);\n-\n         return self.mk_expr(lo, hi, ex);\n     }\n \n@@ -1495,7 +1566,7 @@ impl Parser {\n         return self.mk_expr(q.lo, q.hi, expr_if(q.cond, q.then, q.els));\n     }\n \n-    fn parse_fn_expr(proto: proto) -> @expr {\n+    fn parse_fn_expr(proto: Proto) -> @expr {\n         let lo = self.last_span.lo;\n \n         // if we want to allow fn expression argument types to be inferred in\n@@ -3188,23 +3259,23 @@ impl Parser {\n         (id, item_enum(enum_definition, ty_params), None)\n     }\n \n-    fn parse_fn_ty_proto() -> proto {\n+    fn parse_fn_ty_proto() -> Option<Proto> {\n         match self.token {\n-          token::AT => {\n-            self.bump();\n-            proto_box\n-          }\n-          token::TILDE => {\n-            self.bump();\n-            proto_uniq\n-          }\n-          token::BINOP(token::AND) => {\n-            self.bump();\n-            proto_block\n-          }\n-          _ => {\n-            proto_block\n-          }\n+            token::AT => {\n+                self.bump();\n+                Some(ProtoBox)\n+            }\n+            token::TILDE => {\n+                self.bump();\n+                Some(ProtoUniq)\n+            }\n+            token::BINOP(token::AND) => {\n+                self.bump();\n+                Some(ProtoBorrowed)\n+            }\n+            _ => {\n+                None\n+            }\n         }\n     }\n "}, {"sha": "ed64d02cea36e4ae4ecceba0f974c3cb234ef3e3", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 87, "deletions": 63, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -7,6 +7,7 @@ use ast_util::{operator_prec};\n use dvec::DVec;\n use parse::classify::*;\n use parse::token::ident_interner;\n+use str::{push_str, push_char};\n \n // The ps is stored here to prevent recursive type.\n enum ann_node {\n@@ -211,7 +212,9 @@ fn head(s: ps, w: ~str) {\n     // head-box is inconsistent\n     ibox(s, str::len(w) + 1);\n     // keyword that starts the head\n-    word_nbsp(s, w);\n+    if !w.is_empty() {\n+        word_nbsp(s, w);\n+    }\n }\n \n fn bopen(s: ps) {\n@@ -328,20 +331,19 @@ fn print_foreign_mod(s: ps, nmod: ast::foreign_mod,\n     for nmod.items.each |item| { print_foreign_item(s, *item); }\n }\n \n-fn print_region(s: ps, region: @ast::region, sep: ~str) {\n+fn print_region(s: ps, prefix: ~str, region: @ast::region, sep: ~str) {\n+    word(s.s, prefix);\n     match region.node {\n         ast::re_anon => {\n-            word_space(s, ~\"&\");\n             return;\n         }\n         ast::re_static => {\n-            word_space(s, ~\"&static\")\n+            word_space(s, ~\"static\")\n         }\n         ast::re_self => {\n-            word_space(s, ~\"&self\")\n+            word_space(s, ~\"self\")\n         }\n         ast::re_named(name) => {\n-            word(s.s, ~\"&\");\n             print_ident(s, name);\n         }\n     }\n@@ -372,7 +374,7 @@ fn print_type_ex(s: ps, &&ty: @ast::Ty, print_colons: bool) {\n       }\n       ast::ty_ptr(mt) => { word(s.s, ~\"*\"); print_mt(s, mt); }\n       ast::ty_rptr(region, mt) => {\n-          print_region(s, region, ~\"/\");\n+          print_region(s, ~\"&\", region, ~\"/\");\n           print_mt(s, mt);\n       }\n       ast::ty_rec(fields) => {\n@@ -394,26 +396,21 @@ fn print_type_ex(s: ps, &&ty: @ast::Ty, print_colons: bool) {\n         commasep(s, inconsistent, elts, print_type);\n         pclose(s);\n       }\n-      ast::ty_fn(proto, purity, onceness, bounds, d) => {\n-        print_ty_fn(s, Some(proto), purity, onceness, bounds, d, None, None,\n-                    None);\n+      ast::ty_fn(f) => {\n+        print_ty_fn(s, Some(f.proto), f.region, f.purity,\n+                    f.onceness, f.bounds, f.decl, None, None, None);\n       }\n       ast::ty_path(path, _) => print_path(s, path, print_colons),\n-      ast::ty_fixed_length(t, v) => {\n+      ast::ty_fixed_length_vec(mt, v) => {\n         word(s.s, ~\"[\");\n-        match t.node {\n-          ast::ty_vec(mt) => {\n-            match mt.mutbl {\n-              ast::m_mutbl => word_space(s, ~\"mut\"),\n-              ast::m_const => word_space(s, ~\"const\"),\n-              ast::m_imm => ()\n-            }\n-            print_type(s, mt.ty);\n-          }\n-          _ => fail ~\"ty_fixed_length can only contain ty_vec as type\"\n+        match mt.mutbl {\n+            ast::m_mutbl => word_space(s, ~\"mut\"),\n+            ast::m_const => word_space(s, ~\"const\"),\n+            ast::m_imm => ()\n         }\n+        print_type(s, mt.ty);\n         word(s.s, ~\" * \");\n-        print_vstore(s, ast::vstore_fixed(v));\n+        word(s.s, fmt!(\"%u\", v));\n         word(s.s, ~\"]\");\n       }\n       ast::ty_mac(_) => {\n@@ -805,7 +802,7 @@ fn print_ty_method(s: ps, m: ast::ty_method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n-    print_ty_fn(s, None, m.purity, ast::Many,\n+    print_ty_fn(s, None, None, m.purity, ast::Many,\n                 @~[], m.decl, Some(m.ident), Some(m.tps),\n                 Some(m.self_ty.node));\n     word(s.s, ~\";\");\n@@ -1023,7 +1020,7 @@ fn print_vstore(s: ps, t: ast::vstore) {\n         ast::vstore_fixed(None) => word(s.s, ~\"_\"),\n         ast::vstore_uniq => word(s.s, ~\"~\"),\n         ast::vstore_box => word(s.s, ~\"@\"),\n-        ast::vstore_slice(r) => print_region(s, r, ~\"/\")\n+        ast::vstore_slice(r) => print_region(s, ~\"&\", r, ~\"/\")\n     }\n }\n \n@@ -1274,8 +1271,8 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         cbox(s, indent_unit);\n         // head-box, will be closed by print-block at start\n         ibox(s, 0u);\n-        word(s.s, fn_header_info_to_str(None, None, Some(proto), ast::Many,\n-                                        ast::inherited));\n+        print_fn_header_info(s, None, None, ast::Many,\n+                             Some(proto), ast::inherited);\n         print_fn_args_and_ret(s, decl, *cap_clause, None);\n         space(s.s);\n         print_block(s, body);\n@@ -1481,7 +1478,7 @@ fn print_path(s: ps, &&path: @ast::path, colons_before_params: bool) {\n           None => { /* ok */ }\n           Some(r) => {\n             word(s.s, ~\"/\");\n-            print_region(s, r, ~\"\");\n+            print_region(s, ~\"&\", r, ~\"\");\n           }\n         }\n \n@@ -1614,8 +1611,9 @@ fn print_fn(s: ps,\n             typarams: ~[ast::ty_param],\n             opt_self_ty: Option<ast::self_ty_>,\n             vis: ast::visibility) {\n-    head(s, fn_header_info_to_str(opt_self_ty, purity, None, ast::Many,\n-                                  vis));\n+    head(s, ~\"\");\n+    print_fn_header_info(s, opt_self_ty, purity, ast::Many, None, vis);\n+    nbsp(s);\n     print_ident(s, name);\n     print_type_params(s, typarams);\n     print_fn_args_and_ret(s, decl, ~[], opt_self_ty);\n@@ -1836,16 +1834,24 @@ fn print_arg(s: ps, input: ast::arg) {\n }\n \n fn print_ty_fn(s: ps,\n-               opt_proto: Option<ast::proto>,\n+               opt_proto: Option<ast::Proto>,\n+               opt_region: Option<@ast::region>,\n                purity: ast::purity,\n                onceness: ast::Onceness,\n                bounds: @~[ast::ty_param_bound],\n                decl: ast::fn_decl, id: Option<ast::ident>,\n                tps: Option<~[ast::ty_param]>,\n                opt_self_ty: Option<ast::self_ty_>) {\n     ibox(s, indent_unit);\n-    word(s.s, fn_header_info_to_str(opt_self_ty, Some(purity), opt_proto,\n-                                    onceness, ast::inherited));\n+\n+    // Duplicates the logic in `print_fn_header_info()`.  This is because that\n+    // function prints the proto in the wrong place.  That should be fixed.\n+    print_self_ty_if_static(s, opt_self_ty);\n+    print_opt_proto(s, opt_proto);\n+    for opt_region.each |r| { print_region(s, ~\"\", *r, ~\"/\"); }\n+    print_purity(s, purity);\n+    print_onceness(s, onceness);\n+    word(s.s, ~\"fn\");\n     print_bounds(s, bounds);\n     match id { Some(id) => { word(s.s, ~\" \"); print_ident(s, id); } _ => () }\n     match tps { Some(tps) => print_type_params(s, tps), _ => () }\n@@ -2066,39 +2072,50 @@ fn next_comment(s: ps) -> Option<comments::cmnt> {\n     }\n }\n \n-fn fn_header_info_to_str(opt_sty: Option<ast::self_ty_>,\n-                         opt_purity: Option<ast::purity>,\n-                         opt_p: Option<ast::proto>,\n-                         onceness: ast::Onceness,\n-                         vis: ast::visibility) -> ~str {\n-\n-    let mut s = visibility_qualified(vis, ~\"\");\n-\n-    match opt_sty {\n-        Some(ast::sty_static) => str::push_str(&mut s, ~\"static \"),\n-        _ => ()\n-    };\n+fn print_self_ty_if_static(s: ps,\n+                           opt_self_ty: Option<ast::self_ty_>) {\n+    match opt_self_ty {\n+        Some(ast::sty_static) => { word(s.s, ~\"static \"); }\n+        _ => {}\n+    }\n+}\n \n+fn print_opt_purity(s: ps, opt_purity: Option<ast::purity>) {\n     match opt_purity {\n-      Some(ast::impure_fn) => { }\n-      Some(purity) => {\n-        str::push_str(&mut s, purity_to_str(purity));\n-        str::push_char(&mut s, ' ');\n-      }\n-      None => {}\n+        Some(ast::impure_fn) => { }\n+        Some(purity) => {\n+            word_nbsp(s, purity_to_str(purity));\n+        }\n+        None => {}\n     }\n+}\n \n-    str::push_str(&mut s, opt_proto_to_str(opt_p));\n-\n-    match onceness {\n-        ast::Once => str::push_str(&mut s, ~\"once \"),\n-        ast::Many => {}\n-    }\n+fn print_opt_proto(s: ps, opt_proto: Option<ast::Proto>) {\n+    match opt_proto {\n+        Some(ast::ProtoBare) => { word(s.s, ~\"extern \"); }\n+        Some(ast::ProtoBorrowed) => { word(s.s, ~\"&\"); }\n+        Some(ast::ProtoUniq) => { word(s.s, ~\"~\"); }\n+        Some(ast::ProtoBox) => { word(s.s, ~\"@\"); }\n+        None => {}\n+    };\n+}\n \n-    return s;\n+fn print_fn_header_info(s: ps,\n+                        opt_sty: Option<ast::self_ty_>,\n+                        opt_purity: Option<ast::purity>,\n+                        onceness: ast::Onceness,\n+                        opt_proto: Option<ast::Proto>,\n+                        vis: ast::visibility)\n+{\n+    word(s.s, visibility_qualified(vis, ~\"\"));\n+    print_self_ty_if_static(s, opt_sty);\n+    print_opt_purity(s, opt_purity);\n+    print_onceness(s, onceness);\n+    word(s.s, ~\"fn\");\n+    print_opt_proto(s, opt_proto);\n }\n \n-fn opt_proto_to_str(opt_p: Option<ast::proto>) -> ~str {\n+fn opt_proto_to_str(opt_p: Option<ast::Proto>) -> ~str {\n     match opt_p {\n       None => ~\"fn\",\n       Some(p) => proto_to_str(p)\n@@ -2128,12 +2145,19 @@ fn print_purity(s: ps, p: ast::purity) {\n     }\n }\n \n-fn proto_to_str(p: ast::proto) -> ~str {\n+fn print_onceness(s: ps, o: ast::Onceness) {\n+    match o {\n+        ast::Once => { word_nbsp(s, ~\"once\"); }\n+        ast::Many => {}\n+    }\n+}\n+\n+fn proto_to_str(p: ast::Proto) -> ~str {\n     return match p {\n-      ast::proto_bare => ~\"extern fn\",\n-      ast::proto_block => ~\"fn&\",\n-      ast::proto_uniq => ~\"fn~\",\n-      ast::proto_box => ~\"fn@\"\n+      ast::ProtoBare => ~\"extern fn\",\n+      ast::ProtoBorrowed => ~\"fn&\",\n+      ast::ProtoUniq => ~\"fn~\",\n+      ast::ProtoBox => ~\"fn@\"\n     };\n }\n "}, {"sha": "97cc52bd35a1606009d6b901fd6c68a23298e3cc", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -15,7 +15,7 @@ enum vt<E> { mk_vt(visitor<E>), }\n enum fn_kind {\n     fk_item_fn(ident, ~[ty_param], purity), //< an item declared with fn()\n     fk_method(ident, ~[ty_param], @method),\n-    fk_anon(proto, capture_clause),  //< an anonymous function like fn@(...)\n+    fk_anon(Proto, capture_clause),  //< an anonymous function like fn@(...)\n     fk_fn_block(capture_clause),     //< a block {||...}\n     fk_dtor(~[ty_param], ~[attribute], node_id /* self id */,\n             def_id /* parent class id */) // class destructor\n@@ -203,13 +203,13 @@ fn visit_ty<E>(t: @Ty, e: E, v: vt<E>) {\n       ty_tup(ts) => for ts.each |tt| {\n         v.visit_ty(*tt, e, v);\n       },\n-      ty_fn(_, _, _, bounds, decl) => {\n-        for decl.inputs.each |a| { v.visit_ty(a.ty, e, v); }\n-        visit_ty_param_bounds(bounds, e, v);\n-        v.visit_ty(decl.output, e, v);\n+      ty_fn(f) => {\n+        for f.decl.inputs.each |a| { v.visit_ty(a.ty, e, v); }\n+        visit_ty_param_bounds(f.bounds, e, v);\n+        v.visit_ty(f.decl.output, e, v);\n       }\n       ty_path(p, _) => visit_path(p, e, v),\n-      ty_fixed_length(t, _) => v.visit_ty(t, e, v),\n+      ty_fixed_length_vec(mt, _) => v.visit_ty(mt.ty, e, v),\n       ty_nil |\n       ty_bot |\n       ty_mac(_) |"}, {"sha": "c839be0739f9ce5ed5c5f7d2345398f256cefb42", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -406,7 +406,7 @@ fn mk_test_wrapper(cx: test_ctxt,\n     let wrapper_expr: ast::expr = {\n         id: cx.sess.next_node_id(),\n         callee_id: cx.sess.next_node_id(),\n-        node: ast::expr_fn(ast::proto_bare, wrapper_decl,\n+        node: ast::expr_fn(ast::ProtoBare, wrapper_decl,\n                            wrapper_body, @~[]),\n         span: span\n     };"}, {"sha": "51c56cb8a649c9b4e97ccc5425ecea58787defb1", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -103,11 +103,13 @@ fn parse_ty_rust_fn(st: @pstate, conv: conv_did) -> ty::t {\n     return ty::mk_fn(st.tcx, parse_ty_fn(st, conv));\n }\n \n-fn parse_proto(st: @pstate) -> ty::fn_proto {\n+fn parse_proto(st: @pstate) -> ast::Proto {\n     match next(st) {\n-        'n' => ty::proto_bare,\n-        'v' => ty::proto_vstore(parse_vstore(st)),\n-        c => fail ~\"illegal proto type kind \" + str::from_char(c)\n+        '_' => ast::ProtoBare,\n+        '@' => ast::ProtoBox,\n+        '~' => ast::ProtoUniq,\n+        '&' => ast::ProtoBorrowed,\n+        _ => fail ~\"parse_proto(): bad input\"\n     }\n }\n \n@@ -293,13 +295,8 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       }\n       'Y' => return ty::mk_type(st.tcx),\n       'C' => {\n-        let ck = match next(st) {\n-          '&' => ty::ck_block,\n-          '@' => ty::ck_box,\n-          '~' => ty::ck_uniq,\n-          _ => fail ~\"parse_ty: bad closure kind\"\n-        };\n-        return ty::mk_opaque_closure_ptr(st.tcx, ck);\n+        let proto = parse_proto(st);\n+        return ty::mk_opaque_closure_ptr(st.tcx, proto);\n       }\n       '#' => {\n         let pos = parse_hex(st);\n@@ -415,6 +412,7 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::FnTy {\n     let proto = parse_proto(st);\n     let purity = parse_purity(next(st));\n     let onceness = parse_onceness(next(st));\n+    let region = parse_region(st);\n     let bounds = parse_bounds(st, conv);\n     assert (next(st) == '[');\n     let mut inputs: ~[ty::arg] = ~[];\n@@ -429,6 +427,7 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::FnTy {\n                       proto: proto,\n                       onceness: onceness,\n                       bounds: bounds,\n+                      region: region,\n                       ret_style: ret_style},\n         sig: FnSig {inputs: inputs,\n                     output: ret_ty}"}, {"sha": "4129066ff2863eca54c377bfb7144bc5ba55cd60", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -296,9 +296,10 @@ fn enc_sty(w: io::Writer, cx: @ctxt, st: ty::sty) {\n         w.write_char('s');\n       }\n       ty::ty_type => w.write_char('Y'),\n-      ty::ty_opaque_closure_ptr(ty::ck_block) => w.write_str(&\"C&\"),\n-      ty::ty_opaque_closure_ptr(ty::ck_box) => w.write_str(&\"C@\"),\n-      ty::ty_opaque_closure_ptr(ty::ck_uniq) => w.write_str(&\"C~\"),\n+      ty::ty_opaque_closure_ptr(p) => {\n+          w.write_str(&\"C&\");\n+          enc_proto(w, p);\n+      }\n       ty::ty_opaque_box => w.write_char('B'),\n       ty::ty_class(def, substs) => {\n           debug!(\"~~~~ %s\", ~\"a[\");\n@@ -315,14 +316,13 @@ fn enc_sty(w: io::Writer, cx: @ctxt, st: ty::sty) {\n     }\n }\n \n-fn enc_proto(w: io::Writer, cx: @ctxt, proto: ty::fn_proto) {\n+fn enc_proto(w: io::Writer, proto: Proto) {\n     w.write_str(&\"f\");\n     match proto {\n-        ty::proto_bare => w.write_str(&\"n\"),\n-        ty::proto_vstore(vstore) => {\n-            w.write_str(&\"v\");\n-            enc_vstore(w, cx, vstore);\n-        }\n+        ProtoBare => w.write_str(&\"_\"),\n+        ProtoBox => w.write_str(&\"@\"),\n+        ProtoUniq => w.write_str(&\"~\"),\n+        ProtoBorrowed => w.write_str(&\"&\"),\n     }\n }\n \n@@ -357,9 +357,10 @@ fn enc_onceness(w: io::Writer, o: Onceness) {\n }\n \n fn enc_ty_fn(w: io::Writer, cx: @ctxt, ft: ty::FnTy) {\n-    enc_proto(w, cx, ft.meta.proto);\n+    enc_proto(w, ft.meta.proto);\n     enc_purity(w, ft.meta.purity);\n     enc_onceness(w, ft.meta.onceness);\n+    enc_region(w, cx, ft.meta.region);\n     enc_bounds(w, cx, ft.meta.bounds);\n     w.write_char('[');\n     for ft.sig.inputs.each |arg| {"}, {"sha": "d63f52a4a583839e1a91b8284897b158ed8413bf", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -234,7 +234,7 @@ impl check_loan_ctxt {\n     fn is_stack_closure(id: ast::node_id) -> bool {\n         let fn_ty = ty::node_id_to_type(self.tcx(), id);\n         let proto = ty::ty_fn_proto(fn_ty);\n-        return ty::is_blockish(proto);\n+        return proto == ast::ProtoBorrowed;\n     }\n \n     fn is_allowed_pure_arg(expr: @ast::expr) -> bool {"}, {"sha": "9875e8600ea02c9e5fa93cc824837f273d9e708e", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -241,12 +241,18 @@ impl gather_loan_ctxt {\n                                              autoref.mutbl,\n                                              autoref.region)\n                     }\n-                    ty::AutoSlice => {\n+                    ty::AutoBorrowVec => {\n                         let cmt_index = mcx.cat_index(expr, cmt);\n                         self.guarantee_valid(cmt_index,\n                                              autoref.mutbl,\n                                              autoref.region)\n                     }\n+                    ty::AutoBorrowFn => {\n+                        let cmt_deref = mcx.cat_deref_fn(expr, cmt, 0);\n+                        self.guarantee_valid(cmt_deref,\n+                                             autoref.mutbl,\n+                                             autoref.region)\n+                    }\n                 }\n             }\n         }"}, {"sha": "dae17f66d15fdf5441be6a11b0d0376754af48b0", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -58,7 +58,7 @@ fn check_capture_clause(tcx: ty::ctxt,\n \n fn compute_capture_vars(tcx: ty::ctxt,\n                         fn_expr_id: ast::node_id,\n-                        fn_proto: ty::fn_proto,\n+                        fn_proto: ast::Proto,\n                         cap_clause: ast::capture_clause) -> ~[capture_var] {\n     let freevars = freevars::get_freevars(tcx, fn_expr_id);\n     let cap_map = map::HashMap();\n@@ -101,7 +101,7 @@ fn compute_capture_vars(tcx: ty::ctxt,\n     // named and add that\n \n     let implicit_mode;\n-    if ty::is_blockish(fn_proto) {\n+    if fn_proto == ast::ProtoBorrowed {\n         implicit_mode = cap_ref;\n     } else {\n         implicit_mode = cap_copy;"}, {"sha": "de275fdcfc48498aeb34bb6b38c558d6cd5e1744", "filename": "src/rustc/middle/check_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_loop.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -24,8 +24,8 @@ fn check_crate(tcx: ty::ctxt, crate: @crate) {\n                 v.visit_block(b, {in_loop: false, can_ret: false}, v);\n               }\n               expr_loop_body(@{node: expr_fn_block(_, b, _), _}) => {\n-                let blk = ty::is_blockish(ty::ty_fn_proto(ty::expr_ty(tcx,\n-                                                                      e)));\n+                let proto = ty::ty_fn_proto(ty::expr_ty(tcx, e));\n+                let blk = (proto == ProtoBorrowed);\n                 v.visit_block(b, {in_loop: true, can_ret: blk}, v);\n               }\n               expr_break(_) => {"}, {"sha": "16f4a66ff0b4334beeb14373140bbdc10b7ef5e4", "filename": "src/rustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffreevars.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -40,7 +40,7 @@ fn collect_freevars(def_map: resolve::DefMap, blk: ast::blk)\n     let walk_expr = fn@(expr: @ast::expr, &&depth: int, v: visit::vt<int>) {\n             match expr.node {\n               ast::expr_fn(proto, _, _, _) => {\n-                if proto != ast::proto_bare {\n+                if proto != ast::ProtoBare {\n                     visit::visit_expr(expr, depth + 1, v);\n                 }\n               }"}, {"sha": "c0887150f24f2590a0b3118134c7c2bfee7d77ab", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -159,12 +159,10 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n \n     let fty = ty::node_id_to_type(cx.tcx, id);\n     match ty::ty_fn_proto(fty) {\n-      ty::proto_vstore(ty::vstore_uniq) => b(check_for_uniq),\n-      ty::proto_vstore(ty::vstore_box) => b(check_for_box),\n-      ty::proto_bare => b(check_for_bare),\n-      ty::proto_vstore(ty::vstore_slice(_)) => b(check_for_block),\n-      ty::proto_vstore(ty::vstore_fixed(_)) =>\n-        fail ~\"fixed vstore not allowed here\"\n+        ProtoUniq => b(check_for_uniq),\n+        ProtoBox => b(check_for_box),\n+        ProtoBare => b(check_for_bare),\n+        ProtoBorrowed => b(check_for_block),\n     }\n }\n "}, {"sha": "3be1e6d1a6189c947a772b077b86cba4449bcefe", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -841,29 +841,15 @@ fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: ast::fn_decl,\n                         let span = arg_ast.ty.span;\n                         // Recurse to check fn-type argument\n                         match arg_ast.ty.node {\n-                            ast::ty_fn(_, _, _, _, decl) => {\n+                            ast::ty_fn(f) => {\n                                 check_fn_deprecated_modes(tcx, arg_ty.ty,\n-                                                          decl, span, id);\n+                                                          f.decl, span, id);\n                             }\n                             ast::ty_path(*) => {\n                                 // This is probably a typedef, so we can't\n                                 // see the actual fn decl\n                                 // e.g. fn foo(f: InitOp<T>)\n                             }\n-                            ast::ty_rptr(_, mt)\n-                            | ast::ty_box(mt)\n-                            | ast::ty_uniq(mt) => {\n-                                // Functions with preceding sigil are parsed\n-                                // as pointers of functions\n-                                match mt.ty.node {\n-                                    ast::ty_fn(_, _, _, _, decl) => {\n-                                        check_fn_deprecated_modes(\n-                                            tcx, arg_ty.ty,\n-                                            decl, span, id);\n-                                    }\n-                                    _ => fail\n-                                }\n-                            }\n                             _ => {\n                                 tcx.sess.span_warn(span, ~\"what\");\n                                 error!(\"arg %d, ty=%s, mode=%s\",\n@@ -889,10 +875,10 @@ fn check_item_deprecated_modes(tcx: ty::ctxt, it: @ast::item) {\n     match it.node {\n         ast::item_ty(ty, _) => {\n             match ty.node {\n-                ast::ty_fn(_, _, _, _, decl) => {\n+                ast::ty_fn(f) => {\n                     let fn_ty = ty::node_id_to_type(tcx, it.id);\n                     check_fn_deprecated_modes(\n-                        tcx, fn_ty, decl, ty.span, it.id)\n+                        tcx, fn_ty, f.decl, ty.span, it.id)\n                 }\n                 _ => ()\n             }"}, {"sha": "a43dc0747de9dad7d7ff07682fe9c59e04af1465", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 63, "deletions": 27, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -305,18 +305,30 @@ fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n         Some(deref_ptr(uniq_ptr))\n       }\n \n+      ty::ty_fn(f) if f.meta.proto == ast::ProtoUniq => {\n+        Some(deref_ptr(uniq_ptr))\n+      }\n+\n       ty::ty_rptr(r, _) |\n       ty::ty_evec(_, ty::vstore_slice(r)) |\n       ty::ty_estr(ty::vstore_slice(r)) => {\n         Some(deref_ptr(region_ptr(r)))\n       }\n \n+      ty::ty_fn(f) if f.meta.proto == ast::ProtoBorrowed => {\n+        Some(deref_ptr(region_ptr(f.meta.region)))\n+      }\n+\n       ty::ty_box(*) |\n       ty::ty_evec(_, ty::vstore_box) |\n       ty::ty_estr(ty::vstore_box) => {\n         Some(deref_ptr(gc_ptr))\n       }\n \n+      ty::ty_fn(f) if f.meta.proto == ast::ProtoBox => {\n+        Some(deref_ptr(gc_ptr))\n+      }\n+\n       ty::ty_ptr(*) => {\n         Some(deref_ptr(unsafe_ptr))\n       }\n@@ -563,22 +575,23 @@ impl &mem_categorization_ctxt {\n             let ty = ty::node_id_to_type(self.tcx, fn_node_id);\n             let proto = ty::ty_fn_proto(ty);\n             match proto {\n-              ty::proto_vstore(ty::vstore_slice(_)) => {\n-                let upcmt = self.cat_def(id, span, expr_ty, *inner);\n-                @{id:id, span:span,\n-                  cat:cat_stack_upvar(upcmt), lp:upcmt.lp,\n-                  mutbl:upcmt.mutbl, ty:upcmt.ty}\n-              }\n-              ty::proto_bare |\n-              ty::proto_vstore(ty::vstore_uniq) |\n-              ty::proto_vstore(ty::vstore_box) => {\n-                // FIXME #2152 allow mutation of moved upvars\n-                @{id:id, span:span,\n-                  cat:cat_special(sk_heap_upvar), lp:None,\n-                  mutbl:m_imm, ty:expr_ty}\n-              }\n-              ty::proto_vstore(ty::vstore_fixed(_)) =>\n-                fail ~\"fixed vstore not allowed here\"\n+                ast::ProtoBorrowed => {\n+                    let upcmt = self.cat_def(id, span, expr_ty, *inner);\n+                    @{id:id, span:span,\n+                      cat:cat_stack_upvar(upcmt), lp:upcmt.lp,\n+                      mutbl:upcmt.mutbl, ty:upcmt.ty}\n+                }\n+                ast::ProtoUniq | ast::ProtoBox => {\n+                    // FIXME #2152 allow mutation of moved upvars\n+                    @{id:id, span:span,\n+                      cat:cat_special(sk_heap_upvar), lp:None,\n+                      mutbl:m_imm, ty:expr_ty}\n+                }\n+                ast::ProtoBare => {\n+                    self.tcx.sess.span_bug(\n+                        span,\n+                        fmt!(\"Upvar in a bare closure?\"));\n+                }\n             }\n           }\n \n@@ -648,16 +661,16 @@ impl &mem_categorization_ctxt {\n                              base_cmt: cmt,\n                              f_name: ast::ident,\n                              field_id: ast::node_id) -> cmt {\n-        let f_mutbl = match field_mutbl(self.tcx, base_cmt.ty, f_name,\n-                                        field_id) {\n-          Some(f_mutbl) => f_mutbl,\n-          None => {\n-            self.tcx.sess.span_bug(\n-                node.span(),\n-                fmt!(\"Cannot find field `%s` in type `%s`\",\n-                     self.tcx.sess.str_of(f_name),\n-                     ty_to_str(self.tcx, base_cmt.ty)));\n-          }\n+        let f_mutbl = match field_mutbl(self.tcx, base_cmt.ty,\n+                                        f_name, field_id) {\n+            Some(f_mutbl) => f_mutbl,\n+            None => {\n+                self.tcx.sess.span_bug(\n+                    node.span(),\n+                    fmt!(\"Cannot find field `%s` in type `%s`\",\n+                         self.tcx.sess.str_of(f_name),\n+                         ty_to_str(self.tcx, base_cmt.ty)));\n+            }\n         };\n         let m = self.inherited_mutability(base_cmt.mutbl, f_mutbl);\n         let f_comp = comp_field(f_name, f_mutbl);\n@@ -667,9 +680,24 @@ impl &mem_categorization_ctxt {\n           mutbl: m, ty: self.tcx.ty(node)}\n     }\n \n+    fn cat_deref_fn<N:ast_node>(node: N,\n+                                base_cmt: cmt,\n+                                deref_cnt: uint) -> cmt\n+    {\n+        // Bit of a hack: the \"dereference\" of a function pointer like\n+        // `@fn()` is a mere logical concept. We interpret it as\n+        // dereferencing the environment pointer; of course, we don't\n+        // know what type lies at the other end, so we just call it\n+        // `()` (the empty tuple).\n+\n+        let mt = {ty: ty::mk_tup(self.tcx, ~[]), mutbl: m_imm};\n+        return self.cat_deref_common(node, base_cmt, deref_cnt, mt);\n+    }\n+\n     fn cat_deref<N:ast_node>(node: N,\n                              base_cmt: cmt,\n-                             deref_cnt: uint) -> cmt {\n+                             deref_cnt: uint) -> cmt\n+    {\n         let mt = match ty::deref(self.tcx, base_cmt.ty, true) {\n             Some(mt) => mt,\n             None => {\n@@ -680,6 +708,14 @@ impl &mem_categorization_ctxt {\n             }\n         };\n \n+        return self.cat_deref_common(node, base_cmt, deref_cnt, mt);\n+    }\n+\n+    fn cat_deref_common<N:ast_node>(node: N,\n+                                    base_cmt: cmt,\n+                                    deref_cnt: uint,\n+                                    mt: ty::mt) -> cmt\n+    {\n         match deref_kind(self.tcx, base_cmt.ty) {\n             deref_ptr(ptr) => {\n                 let lp = do base_cmt.lp.chain_ref |l| {"}, {"sha": "0be27483a107eb5d17e726648b3d49fa00853a7a", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -615,23 +615,35 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n     // region is expected (and hence is a supertype of those\n     // locations)\n     match ty.node {\n-      ast::ty_rptr(r, _) => {\n-        debug!(\"referenced rptr type %s\",\n-               pprust::ty_to_str(ty, cx.sess.intr()));\n+        ast::ty_rptr(r, _) => {\n+            debug!(\"referenced rptr type %s\",\n+                   pprust::ty_to_str(ty, cx.sess.intr()));\n \n-        if cx.region_is_relevant(r) {\n-            cx.add_rp(cx.item_id, cx.add_variance(rv_contravariant))\n+            if cx.region_is_relevant(r) {\n+                cx.add_rp(cx.item_id, cx.add_variance(rv_contravariant))\n+            }\n         }\n-      }\n \n-      ast::ty_fn(ast::proto_bare, _, _, _, _) |\n-      ast::ty_fn(ast::proto_block, _, _, _, _) if cx.anon_implies_rp => {\n-        debug!(\"referenced bare fn type with regions %s\",\n-               pprust::ty_to_str(ty, cx.sess.intr()));\n-        cx.add_rp(cx.item_id, cx.add_variance(rv_contravariant));\n-      }\n+        ast::ty_fn(f) => {\n+            debug!(\"referenced fn type: %s\",\n+                   pprust::ty_to_str(ty, cx.sess.intr()));\n+            match f.region {\n+                Some(r) => {\n+                    if cx.region_is_relevant(r) {\n+                        cx.add_rp(cx.item_id,\n+                                  cx.add_variance(rv_contravariant))\n+                    }\n+                }\n+                None => {\n+                    if f.proto == ast::ProtoBorrowed && cx.anon_implies_rp {\n+                        cx.add_rp(cx.item_id,\n+                                  cx.add_variance(rv_contravariant));\n+                    }\n+                }\n+            }\n+        }\n \n-      _ => {}\n+        _ => {}\n     }\n \n     // if this references another named type, add the dependency\n@@ -666,25 +678,6 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n       _ => {}\n     }\n \n-    // temporary hack: right now, fn() is short for &fn(), but @(fn())\n-    // is `@fn()`, so catch this and set anon_implies_rp to none in\n-    // that case\n-    match ty.node {\n-      ast::ty_box(mt) | ast::ty_uniq(mt) => {\n-        match mt.ty.node {\n-          ast::ty_fn(ast::proto_bare, _, _, _, _) |\n-          ast::ty_fn(ast::proto_block, _, _, _, _) => {\n-            do cx.with(cx.item_id, false) {\n-                visit_mt(mt, cx, visitor);\n-            }\n-            return;\n-          }\n-          _ => {}\n-        }\n-      }\n-      _ => {}\n-    }\n-\n     match ty.node {\n       ast::ty_box(mt) | ast::ty_uniq(mt) | ast::ty_vec(mt) |\n       ast::ty_rptr(_, mt) | ast::ty_ptr(mt) => {\n@@ -706,18 +699,18 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n         }\n       }\n \n-      ast::ty_fn(_, _, _, bounds, decl) => {\n+      ast::ty_fn(f) => {\n         // fn() binds the & region, so do not consider &T types that\n         // appear *inside* a fn() type to affect the enclosing item:\n         do cx.with(cx.item_id, false) {\n             // parameters are contravariant\n             do cx.with_ambient_variance(rv_contravariant) {\n-                for decl.inputs.each |a| {\n+                for f.decl.inputs.each |a| {\n                     visitor.visit_ty(a.ty, cx, visitor);\n                 }\n             }\n-            visit::visit_ty_param_bounds(bounds, cx, visitor);\n-            visitor.visit_ty(decl.output, cx, visitor);\n+            visit::visit_ty_param_bounds(f.bounds, cx, visitor);\n+            visitor.visit_ty(f.decl.output, cx, visitor);\n         }\n       }\n "}, {"sha": "b42d823f0c62cb845a4acd54c219ea02c00c125b", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 77, "deletions": 74, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -144,9 +144,7 @@ fn mk_closure_tys(tcx: ty::ctxt,\n     return cdata_ty;\n }\n \n-fn allocate_cbox(bcx: block,\n-                 ck: ty::closure_kind,\n-                 cdata_ty: ty::t)\n+fn allocate_cbox(bcx: block, proto: ast::Proto, cdata_ty: ty::t)\n     -> Result\n {\n     let _icx = bcx.insn_ctxt(\"closure::allocate_cbox\");\n@@ -163,15 +161,23 @@ fn allocate_cbox(bcx: block,\n     }\n \n     // Allocate and initialize the box:\n-    match ck {\n-      ty::ck_box => malloc_raw(bcx, cdata_ty, heap_shared),\n-      ty::ck_uniq => malloc_raw(bcx, cdata_ty, heap_exchange),\n-      ty::ck_block => {\n-          let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n-          let llbox = base::alloc_ty(bcx, cbox_ty);\n-          nuke_ref_count(bcx, llbox);\n-          rslt(bcx, llbox)\n-      }\n+    match proto {\n+        ast::ProtoBox => {\n+            malloc_raw(bcx, cdata_ty, heap_shared)\n+        }\n+        ast::ProtoUniq => {\n+            malloc_raw(bcx, cdata_ty, heap_exchange)\n+        }\n+        ast::ProtoBorrowed => {\n+            let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n+            let llbox = base::alloc_ty(bcx, cbox_ty);\n+            nuke_ref_count(bcx, llbox);\n+            rslt(bcx, llbox)\n+        }\n+        ast::ProtoBare => {\n+            let cdata_llty = type_of(bcx.ccx(), cdata_ty);\n+            rslt(bcx, C_null(cdata_llty))\n+        }\n     }\n }\n \n@@ -187,15 +193,15 @@ type closure_result = {\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n fn store_environment(bcx: block,\n                      bound_values: ~[EnvValue],\n-                     ck: ty::closure_kind) -> closure_result {\n+                     proto: ast::Proto) -> closure_result {\n     let _icx = bcx.insn_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n     // compute the shape of the closure\n     let cdata_ty = mk_closure_tys(tcx, bound_values);\n \n     // allocate closure in the heap\n-    let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, ck, cdata_ty);\n+    let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, proto, cdata_ty);\n     let mut temp_cleanups = ~[];\n \n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n@@ -243,7 +249,7 @@ fn store_environment(bcx: block,\n // collects the upvars and packages them up for store_environment.\n fn build_closure(bcx0: block,\n                  cap_vars: ~[capture::capture_var],\n-                 ck: ty::closure_kind,\n+                 proto: ast::Proto,\n                  include_ret_handle: Option<ValueRef>) -> closure_result {\n     let _icx = bcx0.insn_ctxt(\"closure::build_closure\");\n     // If we need to, package up the iterator body to call\n@@ -257,7 +263,7 @@ fn build_closure(bcx0: block,\n         let datum = expr::trans_local_var(bcx, cap_var.def);\n         match cap_var.mode {\n             capture::cap_ref => {\n-                assert ck == ty::ck_block;\n+                assert proto == ast::ProtoBorrowed;\n                 env_vals.push(EnvValue {action: EnvRef,\n                                         datum: datum});\n             }\n@@ -298,7 +304,7 @@ fn build_closure(bcx0: block,\n                                 datum: ret_datum});\n     }\n \n-    return store_environment(bcx, env_vals, ck);\n+    return store_environment(bcx, env_vals, proto);\n }\n \n // Given an enclosing block context, a new function context, a closure type,\n@@ -308,7 +314,7 @@ fn load_environment(fcx: fn_ctxt,\n                     cdata_ty: ty::t,\n                     cap_vars: ~[capture::capture_var],\n                     load_ret_handle: bool,\n-                    ck: ty::closure_kind) {\n+                    proto: ast::Proto) {\n     let _icx = fcx.insn_ctxt(\"closure::load_environment\");\n     let bcx = raw_block(fcx, false, fcx.llloadenv);\n \n@@ -322,9 +328,9 @@ fn load_environment(fcx: fn_ctxt,\n           capture::cap_drop => { /* ignore */ }\n           _ => {\n             let mut upvarptr = GEPi(bcx, llcdata, [0u, i]);\n-            match ck {\n-              ty::ck_block => { upvarptr = Load(bcx, upvarptr); }\n-              ty::ck_uniq | ty::ck_box => ()\n+            match proto {\n+                ast::ProtoBorrowed => { upvarptr = Load(bcx, upvarptr); }\n+                ast::ProtoBox | ast::ProtoUniq | ast::ProtoBare => {}\n             }\n             let def_id = ast_util::def_id_of_def(cap_var.def);\n             fcx.llupvars.insert(def_id.node, upvarptr);\n@@ -341,7 +347,7 @@ fn load_environment(fcx: fn_ctxt,\n }\n \n fn trans_expr_fn(bcx: block,\n-                 proto: ty::fn_proto,\n+                 proto: ast::Proto,\n                  decl: ast::fn_decl,\n                  body: ast::blk,\n                  id: ast::node_id,\n@@ -365,16 +371,16 @@ fn trans_expr_fn(bcx: block,\n     let s = mangle_internal_name_by_path_and_seq(ccx, sub_path, ~\"expr_fn\");\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n \n-    let trans_closure_env = fn@(ck: ty::closure_kind) -> Result {\n+    let trans_closure_env = fn@(proto: ast::Proto) -> Result {\n         let cap_vars = capture::compute_capture_vars(ccx.tcx, id, proto,\n                                                      cap_clause);\n         let ret_handle = match is_loop_body { Some(x) => x, None => None };\n-        let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, ck,\n+        let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, proto,\n                                                    ret_handle);\n         trans_closure(ccx, sub_path, decl, body, llfn, no_self,\n                       bcx.fcx.param_substs, id, None, |fcx| {\n             load_environment(fcx, cdata_ty, cap_vars,\n-                             ret_handle.is_some(), ck);\n+                             ret_handle.is_some(), proto);\n                       }, |bcx| {\n             if is_loop_body.is_some() {\n                 Store(bcx, C_bool(true), bcx.fcx.llretptr);\n@@ -384,23 +390,14 @@ fn trans_expr_fn(bcx: block,\n     };\n \n     let Result {bcx: bcx, val: closure} = match proto {\n-        ty::proto_vstore(ty::vstore_slice(_)) => {\n-            trans_closure_env(ty::ck_block)\n-        }\n-        ty::proto_vstore(ty::vstore_box) => {\n-            trans_closure_env(ty::ck_box)\n-        }\n-        ty::proto_vstore(ty::vstore_uniq) => {\n-            trans_closure_env(ty::ck_uniq)\n+        ast::ProtoBorrowed | ast::ProtoBox | ast::ProtoUniq => {\n+            trans_closure_env(proto)\n         }\n-        ty::proto_bare => {\n+        ast::ProtoBare => {\n             trans_closure(ccx, sub_path, decl, body, llfn, no_self, None,\n                           id, None, |_fcx| { }, |_bcx| { });\n             rslt(bcx, C_null(T_opaque_box_ptr(ccx)))\n         }\n-        ty::proto_vstore(ty::vstore_fixed(_)) => {\n-            fail ~\"vstore_fixed unexpected\"\n-        }\n     };\n     fill_fn_pair(bcx, dest_addr, llfn, closure);\n \n@@ -412,48 +409,48 @@ fn make_fn_glue(\n     v: ValueRef,\n     t: ty::t,\n     glue_fn: fn@(block, v: ValueRef, t: ty::t) -> block)\n-    -> block {\n+    -> block\n+{\n     let _icx = cx.insn_ctxt(\"closure::make_fn_glue\");\n     let bcx = cx;\n     let tcx = cx.tcx();\n \n-    let fn_env = fn@(ck: ty::closure_kind) -> block {\n-        let box_cell_v = GEPi(cx, v, [0u, abi::fn_field_box]);\n-        let box_ptr_v = Load(cx, box_cell_v);\n-        do with_cond(cx, IsNotNull(cx, box_ptr_v)) |bcx| {\n-            let closure_ty = ty::mk_opaque_closure_ptr(tcx, ck);\n-            glue_fn(bcx, box_cell_v, closure_ty)\n-        }\n-    };\n-\n     let proto = ty::ty_fn_proto(t);\n     match proto {\n-        ty::proto_bare | ty::proto_vstore(ty::vstore_slice(_)) => bcx,\n-        ty::proto_vstore(ty::vstore_uniq) => fn_env(ty::ck_uniq),\n-        ty::proto_vstore(ty::vstore_box) => fn_env(ty::ck_box),\n-        ty::proto_vstore(ty::vstore_fixed(_)) => {\n-            cx.sess().bug(~\"Closure with fixed vstore\");\n+        ast::ProtoBare | ast::ProtoBorrowed => bcx,\n+        ast::ProtoUniq | ast::ProtoBox => {\n+            let box_cell_v = GEPi(cx, v, [0u, abi::fn_field_box]);\n+            let box_ptr_v = Load(cx, box_cell_v);\n+            do with_cond(cx, IsNotNull(cx, box_ptr_v)) |bcx| {\n+                let closure_ty = ty::mk_opaque_closure_ptr(tcx, proto);\n+                glue_fn(bcx, box_cell_v, closure_ty)\n+            }\n         }\n     }\n }\n \n fn make_opaque_cbox_take_glue(\n     bcx: block,\n-    ck: ty::closure_kind,\n+    proto: ast::Proto,\n     cboxptr: ValueRef)     // ptr to ptr to the opaque closure\n-    -> block {\n+    -> block\n+{\n     // Easy cases:\n     let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_take_glue\");\n-    match ck {\n-        ty::ck_block => return bcx,\n-        ty::ck_box => {\n+    match proto {\n+        ast::ProtoBare | ast::ProtoBorrowed => {\n+            return bcx;\n+        }\n+        ast::ProtoBox => {\n             glue::incr_refcnt_of_boxed(bcx, Load(bcx, cboxptr));\n             return bcx;\n         }\n-        ty::ck_uniq => { /* hard case: */ }\n+        ast::ProtoUniq => {\n+            /* hard case: fallthrough to code below */\n+        }\n     }\n \n-    // Hard case, a deep copy:\n+    // fn~ requires a deep copy.\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n     let llopaquecboxty = T_opaque_box_ptr(ccx);\n     let cbox_in = Load(bcx, cboxptr);\n@@ -492,34 +489,38 @@ fn make_opaque_cbox_take_glue(\n \n fn make_opaque_cbox_drop_glue(\n     bcx: block,\n-    ck: ty::closure_kind,\n+    proto: ast::Proto,\n     cboxptr: ValueRef)     // ptr to the opaque closure\n     -> block {\n     let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_drop_glue\");\n-    match ck {\n-        ty::ck_block => bcx,\n-        ty::ck_box => {\n+    match proto {\n+        ast::ProtoBare | ast::ProtoBorrowed => bcx,\n+        ast::ProtoBox => {\n             glue::decr_refcnt_maybe_free(\n                 bcx, Load(bcx, cboxptr),\n-                ty::mk_opaque_closure_ptr(bcx.tcx(), ck))\n+                ty::mk_opaque_closure_ptr(bcx.tcx(), proto))\n         }\n-        ty::ck_uniq => {\n+        ast::ProtoUniq => {\n             glue::free_ty(\n                 bcx, cboxptr,\n-                ty::mk_opaque_closure_ptr(bcx.tcx(), ck))\n+                ty::mk_opaque_closure_ptr(bcx.tcx(), proto))\n         }\n     }\n }\n \n fn make_opaque_cbox_free_glue(\n     bcx: block,\n-    ck: ty::closure_kind,\n+    proto: ast::Proto,\n     cbox: ValueRef)     // ptr to ptr to the opaque closure\n     -> block {\n     let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_free_glue\");\n-    match ck {\n-      ty::ck_block => return bcx,\n-      ty::ck_box | ty::ck_uniq => { /* hard cases: */ }\n+    match proto {\n+        ast::ProtoBare | ast::ProtoBorrowed => {\n+            return bcx;\n+        }\n+        ast::ProtoBox | ast::ProtoUniq => {\n+            /* hard cases: fallthrough to code below */\n+        }\n     }\n \n     let ccx = bcx.ccx();\n@@ -537,10 +538,12 @@ fn make_opaque_cbox_free_glue(\n                                     abi::tydesc_field_drop_glue, None);\n \n         // Free the ty descr (if necc) and the box itself\n-        match ck {\n-            ty::ck_block => fail ~\"Impossible\",\n-            ty::ck_box => glue::trans_free(bcx, cbox),\n-            ty::ck_uniq => glue::trans_unique_free(bcx, cbox)\n+        match proto {\n+            ast::ProtoBox => glue::trans_free(bcx, cbox),\n+            ast::ProtoUniq => glue::trans_unique_free(bcx, cbox),\n+            ast::ProtoBare | ast::ProtoBorrowed => {\n+                bcx.sess().bug(~\"impossible\")\n+            }\n         }\n     }\n }"}, {"sha": "06d56f4542fd9f6edc32dd6f500b9673f5626a49", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -109,7 +109,7 @@ use base::*;\n use syntax::print::pprust::{expr_to_str};\n use util::ppaux::ty_to_str;\n use util::common::indenter;\n-use ty::{AutoPtr, AutoSlice};\n+use ty::{AutoPtr, AutoBorrowVec, AutoBorrowFn};\n use callee::{AutorefArg, DoAutorefArg, DontAutorefArg};\n \n // The primary two functions for translating expressions:\n@@ -188,9 +188,15 @@ fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n                         AutoPtr => {\n                             unpack_datum!(bcx, auto_ref(bcx, datum))\n                         }\n-                        AutoSlice => {\n+                        AutoBorrowVec => {\n                             unpack_datum!(bcx, auto_slice(bcx, datum))\n                         }\n+                        AutoBorrowFn => {\n+                            // currently, all closure types are\n+                            // represented precisely the same, so no\n+                            // runtime adjustment is required:\n+                            datum\n+                        }\n                     }\n                 }\n             };\n@@ -520,20 +526,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         ast::expr_fn(proto, decl, body, cap_clause) => {\n             // Don't use this function for anything real. Use the one in\n             // astconv instead.\n-            fn ast_proto_to_proto_simple(ast_proto: ast::proto)\n-                -> ty::fn_proto {\n-                match ast_proto {\n-                    ast::proto_bare => ty::proto_bare,\n-                    ast::proto_uniq => ty::proto_vstore(ty::vstore_uniq),\n-                    ast::proto_box => ty::proto_vstore(ty::vstore_box),\n-                    ast::proto_block => {\n-                        ty::proto_vstore(ty::vstore_slice(ty::re_static))\n-                    }\n-                }\n-            }\n-\n-            return closure::trans_expr_fn(bcx,\n-                                          ast_proto_to_proto_simple(proto),\n+            return closure::trans_expr_fn(bcx, proto,\n                                           decl, body, expr.id, cap_clause,\n                                           None, dest);\n         }"}, {"sha": "b4aeface943bdc38ace5356feb3a0ee28a6ac999", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -997,10 +997,9 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n                 ty::mk_mach_uint(bcx.tcx(), ast::ty_u8));\n             let fty = ty::mk_fn(bcx.tcx(), FnTyBase {\n                 meta: FnMeta {purity: ast::impure_fn,\n-                              proto:\n-                                  ty::proto_vstore(ty::vstore_slice(\n-                                      ty::re_bound(ty::br_anon(0)))),\n+                              proto: ast::ProtoBorrowed,\n                               onceness: ast::Many,\n+                              region: ty::re_bound(ty::br_anon(0)),\n                               bounds: @~[],\n                               ret_style: ast::return_val},\n                 sig: FnSig {inputs: ~[{mode: ast::expl(ast::by_val),"}, {"sha": "2e18fb2a2e9e20b3486750e1b068712cb60bd219", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -251,18 +251,19 @@ fn normalize_for_monomorphization(tcx: ty::ctxt, ty: ty::t) -> Option<ty::t> {\n                 FnTyBase {meta: FnMeta {purity: ast::impure_fn,\n                                         proto: fty.meta.proto,\n                                         onceness: ast::Many,\n+                                        region: ty::re_static,\n                                         bounds: @~[],\n                                         ret_style: ast::return_val},\n                           sig: FnSig {inputs: ~[],\n                                       output: ty::mk_nil(tcx)}}))\n         }\n         ty::ty_trait(_, _, _) => {\n-            let box_proto = ty::proto_vstore(ty::vstore_box);\n             Some(ty::mk_fn(\n                 tcx,\n                 FnTyBase {meta: FnMeta {purity: ast::impure_fn,\n-                                        proto: box_proto,\n+                                        proto: ast::ProtoBox,\n                                         onceness: ast::Many,\n+                                        region: ty::re_static,\n                                         bounds: @~[],\n                                         ret_style: ast::return_val},\n                           sig: FnSig {inputs: ~[],"}, {"sha": "5724c5ada22f388b4b58be2f45213e4449553a94", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -186,14 +186,7 @@ impl reflector {\n               ast::impure_fn => 2u,\n               ast::extern_fn => 3u\n             };\n-            let protoval = match fty.meta.proto {\n-              ty::proto_bare => 0u,\n-              ty::proto_vstore(ty::vstore_uniq) => 2u,\n-              ty::proto_vstore(ty::vstore_box) => 3u,\n-              ty::proto_vstore(ty::vstore_slice(_)) => 4u,\n-              ty::proto_vstore(ty::vstore_fixed(_)) =>\n-                fail ~\"fixed unexpected\"\n-            };\n+            let protoval = ast_proto_constant(fty.meta.proto);\n             let retval = match fty.meta.ret_style {\n               ast::noreturn => 0u,\n               ast::return_val => 1u\n@@ -278,11 +271,7 @@ impl reflector {\n           ty::ty_type => self.leaf(~\"type\"),\n           ty::ty_opaque_box => self.leaf(~\"opaque_box\"),\n           ty::ty_opaque_closure_ptr(ck) => {\n-            let ckval = match ck {\n-              ty::ck_block => 0u,\n-              ty::ck_box => 1u,\n-              ty::ck_uniq => 2u\n-            };\n+            let ckval = ast_proto_constant(ck);\n             self.visit(~\"closure_ptr\", ~[self.c_uint(ckval)])\n           }\n         }\n@@ -309,3 +298,12 @@ fn emit_calls_to_trait_visit_ty(bcx: block, t: ty::t,\n     Br(r.bcx, final.llbb);\n     return final;\n }\n+\n+fn ast_proto_constant(proto: ast::Proto) -> uint {\n+    match proto {\n+        ast::ProtoBare => 0u,\n+        ast::ProtoUniq => 2u,\n+        ast::ProtoBox => 3u,\n+        ast::ProtoBorrowed => 4u,\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "53889369361fde6091d4955a407dc0aeeb64f1de", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -213,16 +213,13 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n       }\n       expr_fn(*) | expr_fn_block(*) => {\n         match ty::ty_fn_proto(ty::expr_ty(cx.ccx.tcx, e)) {\n-          ty::proto_bare | ty::proto_vstore(ty::vstore_uniq) => {}\n-          ty::proto_vstore(ty::vstore_box) |\n-          ty::proto_vstore(ty::vstore_slice(_)) => {\n+          ast::ProtoBare | ast::ProtoUniq => {}\n+          ast::ProtoBox | ast::ProtoBorrowed => {\n             for vec::each(*freevars::get_freevars(cx.ccx.tcx, e.id)) |fv| {\n                 let node_id = ast_util::def_id_of_def(fv.def).node;\n                 node_type_needs(cx, use_repr, node_id);\n             }\n           }\n-          ty::proto_vstore(ty::vstore_fixed(_)) =>\n-            fail ~\"vstore_fixed not allowed here\"\n         }\n       }\n       expr_assign(val, _) | expr_swap(val, _) | expr_assign_op(_, val, _) |"}, {"sha": "14c5ed5e71e01c6a839a1b32ee107af6880b0cd8", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 83, "deletions": 141, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -157,10 +157,6 @@ export set_default_mode;\n export variant_info;\n export walk_ty, maybe_walk_ty;\n export occurs_check;\n-export closure_kind;\n-export ck_block;\n-export ck_box;\n-export ck_uniq;\n export param_ty;\n export param_bound, param_bounds, bound_copy, bound_owned;\n export param_bounds_to_str, param_bound_to_str;\n@@ -190,20 +186,19 @@ export purity_to_str;\n export onceness_to_str;\n export param_tys_in_type;\n export eval_repeat_count;\n-export fn_proto, proto_bare, proto_vstore;\n export ast_proto_to_proto;\n-export is_blockish;\n export method_call_bounds;\n export hash_region;\n export region_variance, rv_covariant, rv_invariant, rv_contravariant;\n export opt_region_variance;\n export determine_inherited_purity;\n export provided_trait_methods;\n export trait_supertraits;\n-export AutoAdjustment;\n-export AutoRef, AutoRefKind, AutoSlice, AutoPtr;\n export DerivedMethodInfo;\n export DerivedFieldInfo;\n+export AutoAdjustment;\n+export AutoRef;\n+export AutoRefKind, AutoPtr, AutoBorrowVec, AutoBorrowFn;\n \n // Data types\n \n@@ -304,14 +299,14 @@ impl region_variance : cmp::Eq {\n \n #[auto_serialize]\n #[auto_deserialize]\n-type AutoAdjustment = {\n+pub type AutoAdjustment = {\n     autoderefs: uint,\n     autoref: Option<AutoRef>\n };\n \n #[auto_serialize]\n #[auto_deserialize]\n-type AutoRef = {\n+pub type AutoRef = {\n     kind: AutoRefKind,\n     region: Region,\n     mutbl: ast::mutability\n@@ -320,11 +315,14 @@ type AutoRef = {\n #[auto_serialize]\n #[auto_deserialize]\n enum AutoRefKind {\n+    /// Convert from T to &T\n+    AutoPtr,\n+\n     /// Convert from @[]/~[] to &[] (or str)\n-    AutoSlice,\n+    AutoBorrowVec,\n \n-    /// Convert from T to &T\n-    AutoPtr\n+    /// Convert from @fn()/~fn() to &fn()\n+    AutoBorrowFn,\n }\n \n struct ProvidedMethodSource {\n@@ -450,75 +448,21 @@ pure fn type_has_regions(t: t) -> bool { tbox_has_flag(get(t), has_regions) }\n pure fn type_def_id(t: t) -> Option<ast::def_id> { get(t).o_def_id }\n pure fn type_id(t: t) -> uint { get(t).id }\n \n-enum closure_kind {\n-    ck_block,\n-    ck_box,\n-    ck_uniq,\n-}\n-\n-impl closure_kind : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        (self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl closure_kind : cmp::Eq {\n-    pure fn eq(other: &closure_kind) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(other: &closure_kind) -> bool { !self.eq(other) }\n-}\n-\n-enum fn_proto {\n-    proto_bare,             // supertype of all other protocols\n-    proto_vstore(vstore)\n-}\n-\n-impl fn_proto : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        match self {\n-          proto_bare =>\n-          0u8.iter_bytes(lsb0, f),\n-\n-          proto_vstore(ref v) =>\n-          to_bytes::iter_bytes_2(&1u8, v, lsb0, f)\n-        }\n-    }\n-}\n-\n-impl fn_proto : cmp::Eq {\n-    pure fn eq(other: &fn_proto) -> bool {\n-        match self {\n-            proto_bare => {\n-                match (*other) {\n-                    proto_bare => true,\n-                    _ => false\n-                }\n-            }\n-            proto_vstore(e0a) => {\n-                match (*other) {\n-                    proto_vstore(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(other: &fn_proto) -> bool { !self.eq(other) }\n-}\n-\n /**\n  * Meta information about a closure.\n  *\n  * - `purity` is the function's effect (pure, impure, unsafe).\n  * - `proto` is the protocol (fn@, fn~, etc).\n  * - `onceness` indicates whether the function can be called one time or many\n  *   times.\n+ * - `region` is the region bound on the function's upvars (often &static).\n  * - `bounds` is the parameter bounds on the function's upvars.\n  * - `ret_style` indicates whether the function returns a value or fails. */\n struct FnMeta {\n     purity: ast::purity,\n-    proto: fn_proto,\n+    proto: ast::Proto,\n     onceness: ast::Onceness,\n+    region: Region,\n     bounds: @~[param_bound],\n     ret_style: ret_style\n }\n@@ -671,7 +615,7 @@ enum sty {\n     // \"Fake\" types, used for trans purposes\n     ty_type, // type_desc*\n     ty_opaque_box, // used by monomorphizer to represent any @ box\n-    ty_opaque_closure_ptr(closure_kind), // ptr to env for fn, fn@, fn~\n+    ty_opaque_closure_ptr(ast::Proto), // ptr to env for fn, fn@, fn~\n     ty_unboxed_vec(mt),\n }\n \n@@ -691,7 +635,7 @@ enum type_err {\n     terr_purity_mismatch(expected_found<purity>),\n     terr_onceness_mismatch(expected_found<Onceness>),\n     terr_mutability,\n-    terr_proto_mismatch(expected_found<ty::fn_proto>),\n+    terr_proto_mismatch(expected_found<ast::Proto>),\n     terr_box_mutability,\n     terr_ptr_mutability,\n     terr_ref_mutability,\n@@ -1036,10 +980,7 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n       ty_rec(flds) => for flds.each |f| { flags |= get(f.mt.ty).flags; },\n       ty_tup(ts) => for ts.each |tt| { flags |= get(*tt).flags; },\n       ty_fn(ref f) => {\n-        match f.meta.proto {\n-            ty::proto_vstore(vstore_slice(r)) => flags |= rflags(r),\n-            ty::proto_bare | ty::proto_vstore(_) => {}\n-        }\n+        flags |= rflags(f.meta.region);\n         for f.sig.inputs.each |a| { flags |= get(a.ty).flags; }\n         flags |= get(f.sig.output).flags;\n       }\n@@ -1172,8 +1113,8 @@ fn mk_param(cx: ctxt, n: uint, k: def_id) -> t {\n \n fn mk_type(cx: ctxt) -> t { mk_t(cx, ty_type) }\n \n-fn mk_opaque_closure_ptr(cx: ctxt, ck: closure_kind) -> t {\n-    mk_t(cx, ty_opaque_closure_ptr(ck))\n+fn mk_opaque_closure_ptr(cx: ctxt, proto: ast::Proto) -> t {\n+    mk_t(cx, ty_opaque_closure_ptr(proto))\n }\n \n fn mk_opaque_box(cx: ctxt) -> t { mk_t(cx, ty_opaque_box) }\n@@ -1197,8 +1138,10 @@ fn default_arg_mode_for_ty(tcx: ctxt, ty: ty::t) -> ast::rmode {\n         // memory leak that otherwise results when @fn is upcast to &fn.\n     if type_is_fn(ty) {\n         match ty_fn_proto(ty) {\n-           proto_vstore(vstore_slice(_)) => return ast::by_ref,\n-            _ => ()\n+            ast::ProtoBorrowed => {\n+                return ast::by_ref;\n+            }\n+            _ => {}\n         }\n     }\n     return if tcx.legacy_modes {\n@@ -1409,25 +1352,18 @@ fn fold_regions_and_ty(\n         ty::mk_trait(cx, def_id, fold_substs(substs, fldr, fldt), vst)\n       }\n       ty_fn(ref f) => {\n-        let new_proto;\n-        match f.meta.proto {\n-            proto_bare =>\n-                new_proto = proto_bare,\n-            proto_vstore(vstore_slice(r)) =>\n-                new_proto = proto_vstore(vstore_slice(fldr(r))),\n-            proto_vstore(old_vstore) =>\n-                new_proto = proto_vstore(old_vstore)\n-        }\n-        let new_args = vec::map(f.sig.inputs, |a| {\n-            let new_ty = fldfnt(a.ty);\n-            {mode: a.mode, ty: new_ty}\n-        });\n-        let new_output = fldfnt(f.sig.output);\n-        ty::mk_fn(cx, FnTyBase {\n-            meta: FnMeta {proto: new_proto, ..f.meta},\n-            sig: FnSig {inputs: new_args,\n-                        output: new_output}\n-        })\n+          let new_region = fldr(f.meta.region);\n+          let new_args = vec::map(f.sig.inputs, |a| {\n+              let new_ty = fldfnt(a.ty);\n+              {mode: a.mode, ty: new_ty}\n+          });\n+          let new_output = fldfnt(f.sig.output);\n+          ty::mk_fn(cx, FnTyBase {\n+              meta: FnMeta {region: new_region,\n+                            ..f.meta},\n+              sig: FnSig {inputs: new_args,\n+                          output: new_output}\n+          })\n       }\n       ref sty => {\n         fold_sty_to_ty(cx, sty, |t| fldt(t))\n@@ -1789,8 +1725,8 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n       }\n       ty_fn(ref fty) => {\n         match fty.meta.proto {\n-          proto_bare | proto_vstore(vstore_slice(_)) => false,\n-          _ => true\n+          ast::ProtoBare | ast::ProtoBorrowed => false,\n+          ast::ProtoBox | ast::ProtoUniq => true,\n         }\n       }\n     };\n@@ -2016,16 +1952,18 @@ pure fn kind_is_owned(k: Kind) -> bool {\n \n fn meta_kind(p: FnMeta) -> Kind {\n     match p.proto { // XXX consider the kind bounds!\n-      proto_vstore(vstore_slice(_)) =>\n-        kind_noncopyable() | kind_(KIND_MASK_DEFAULT_MODE),\n-      proto_vstore(vstore_box) =>\n-        kind_safe_for_default_mode() | kind_owned(),\n-      proto_vstore(vstore_uniq) =>\n-        kind_send_copy() | kind_owned(),\n-      proto_vstore(vstore_fixed(_)) =>\n-        fail ~\"fixed vstore protos are not allowed\",\n-      proto_bare =>\n-        kind_safe_for_default_mode_send() | kind_const() | kind_owned()\n+        ast::ProtoBare => {\n+            kind_safe_for_default_mode_send() | kind_const() | kind_owned()\n+        }\n+        ast::ProtoBorrowed => {\n+            kind_noncopyable() | kind_(KIND_MASK_DEFAULT_MODE)\n+        }\n+        ast::ProtoBox => {\n+            kind_safe_for_default_mode() | kind_owned()\n+        }\n+        ast::ProtoUniq => {\n+            kind_send_copy() | kind_owned()\n+        }\n     }\n }\n \n@@ -2721,8 +2659,27 @@ impl field : to_bytes::IterBytes {\n \n impl arg : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-          to_bytes::iter_bytes_2(&self.mode,\n-                                 &self.ty, lsb0, f)\n+        to_bytes::iter_bytes_2(&self.mode,\n+                               &self.ty, lsb0, f)\n+    }\n+}\n+\n+impl FnMeta : to_bytes::IterBytes {\n+    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_5(&self.purity,\n+                               &self.proto,\n+                               &self.region,\n+                               &self.bounds,\n+                               &self.ret_style,\n+                               lsb0, f);\n+    }\n+}\n+\n+impl FnSig : to_bytes::IterBytes {\n+    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.inputs,\n+                               &self.output,\n+                               lsb0, f);\n     }\n }\n \n@@ -2763,13 +2720,9 @@ impl sty : to_bytes::IterBytes {\n           to_bytes::iter_bytes_2(&11u8, fs, lsb0, f),\n \n           ty_fn(ref ft) =>\n-          to_bytes::iter_bytes_7(&12u8,\n-                                 &ft.meta.purity,\n-                                 &ft.meta.proto,\n-                                 &ft.meta.bounds,\n-                                 &ft.sig.inputs,\n-                                 &ft.sig.output,\n-                                 &ft.meta.ret_style,\n+          to_bytes::iter_bytes_3(&12u8,\n+                                 &ft.meta,\n+                                 &ft.sig,\n                                  lsb0, f),\n \n           ty_self => 13u8.iter_bytes(lsb0, f),\n@@ -2840,7 +2793,7 @@ fn ty_fn_args(fty: t) -> ~[arg] {\n     }\n }\n \n-fn ty_fn_proto(fty: t) -> fn_proto {\n+fn ty_fn_proto(fty: t) -> Proto {\n     match get(fty).sty {\n       ty_fn(ref f) => f.meta.proto,\n       _ => fail ~\"ty_fn_proto() called on non-fn type\"\n@@ -4091,12 +4044,11 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n             mk_rptr(cx, re_static, normalize_mt(cx, mt)),\n \n         ty_fn(ref fn_ty) => {\n-            let proto = match fn_ty.meta.proto {\n-                proto_bare => proto_bare,\n-                proto_vstore(vstore) => proto_vstore(normalize_vstore(vstore))\n-            };\n             mk_fn(cx, FnTyBase {\n-                meta: FnMeta {proto: proto, ..fn_ty.meta},\n+                meta: FnMeta {\n+                    region: ty::re_static,\n+                    ..fn_ty.meta\n+                },\n                 sig: fn_ty.sig\n             })\n         }\n@@ -4160,27 +4112,17 @@ fn eval_repeat_count(tcx: ctxt, count_expr: @ast::expr, span: span) -> uint {\n     }\n }\n \n-pure fn is_blockish(proto: fn_proto) -> bool {\n-    match proto {\n-        proto_vstore(vstore_slice(_)) =>\n-            true,\n-        proto_vstore(vstore_box) | proto_vstore(vstore_uniq) | proto_bare =>\n-            false,\n-        proto_vstore(vstore_fixed(_)) =>\n-            fail ~\"fixed vstore not allowed here\"\n-    }\n-}\n-\n // Determine what purity to check a nested function under\n pure fn determine_inherited_purity(parent_purity: ast::purity,\n                                    child_purity: ast::purity,\n-                                   child_proto: ty::fn_proto) -> ast::purity {\n+                                   child_proto: ast::Proto) -> ast::purity {\n     // If the closure is a stack closure and hasn't had some non-standard\n     // purity inferred for it, then check it under its parent's purity.\n     // Otherwise, use its own\n-    if ty::is_blockish(child_proto) && child_purity == ast::impure_fn {\n-        parent_purity\n-    } else { child_purity }\n+    match child_proto {\n+        ast::ProtoBorrowed if child_purity == ast::impure_fn => parent_purity,\n+        _ => child_purity\n+    }\n }\n \n impl mt : cmp::Eq {"}, {"sha": "f80b655a860b7ff406f8ab0a091ad126ebe92c3c", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 84, "deletions": 116, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -166,76 +166,57 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n     // Handle @, ~, and & being able to mean estrs and evecs.\n     // If a_seq_ty is a str or a vec, make it an estr/evec.\n     // Also handle function sigils and first-class trait types.\n-    fn mk_maybe_vstore<AC: ast_conv, RS: region_scope Copy Owned>(\n-        self: AC, rscope: RS, a_seq_ty: ast::mt, vst: ty::vstore,\n-        span: span, constr: fn(ty::mt) -> ty::t) -> ty::t {\n-\n+    fn mk_pointer<AC: ast_conv, RS: region_scope Copy Owned>(\n+        self: AC,\n+        rscope: RS,\n+        a_seq_ty: ast::mt,\n+        vst: ty::vstore,\n+        constr: fn(ty::mt) -> ty::t) -> ty::t\n+    {\n         let tcx = self.tcx();\n \n         match a_seq_ty.ty.node {\n-          // to convert to an e{vec,str}, there can't be a mutability argument\n-          _ if a_seq_ty.mutbl != ast::m_imm => (),\n-          ast::ty_vec(mt) => {\n-            return ty::mk_evec(tcx, ast_mt_to_mt(self, rscope, mt), vst);\n-          }\n-          ast::ty_path(path, id) => {\n-            match tcx.def_map.find(id) {\n-              Some(ast::def_prim_ty(ast::ty_str)) => {\n-                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                return ty::mk_estr(tcx, vst);\n-              }\n-              Some(ast::def_ty(type_def_id)) => {\n-                let result = ast_path_to_substs_and_ty(self, rscope,\n-                                                       type_def_id, path);\n-                match ty::get(result.ty).sty {\n-                    ty::ty_trait(trait_def_id, substs, _) => {\n-                        match vst {\n-                            ty::vstore_box | ty::vstore_slice(*) |\n-                            ty::vstore_uniq => {}\n-                            _ => {\n-                                tcx.sess.span_err(path.span,\n-                                                  ~\"@trait, ~trait or &trait \\\n-                                                    are the only supported \\\n-                                                    forms of casting-to-\\\n-                                                    trait\");\n+            // to convert to an e{vec,str}, there can't be a\n+            // mutability argument\n+            _ if a_seq_ty.mutbl != ast::m_imm => (),\n+            ast::ty_vec(mt) => {\n+                return ty::mk_evec(tcx, ast_mt_to_mt(self, rscope, mt), vst);\n+            }\n+            ast::ty_path(path, id) => {\n+                match tcx.def_map.find(id) {\n+                    Some(ast::def_prim_ty(ast::ty_str)) => {\n+                        check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                        return ty::mk_estr(tcx, vst);\n+                    }\n+                    Some(ast::def_ty(type_def_id)) => {\n+                        let result = ast_path_to_substs_and_ty(\n+                            self, rscope,\n+                            type_def_id, path);\n+                        match ty::get(result.ty).sty {\n+                            ty::ty_trait(trait_def_id, substs, _) => {\n+                                match vst {\n+                                    ty::vstore_box | ty::vstore_slice(*) |\n+                                    ty::vstore_uniq => {}\n+                                    _ => {\n+                                        tcx.sess.span_err(\n+                                            path.span,\n+                                            ~\"@trait, ~trait or &trait \\\n+                                              are the only supported \\\n+                                              forms of casting-to-\\\n+                                              trait\");\n+                                    }\n+                                }\n+                                return ty::mk_trait(tcx, trait_def_id,\n+                                                    substs, vst);\n+\n                             }\n+                            _ => {}\n                         }\n-                        return ty::mk_trait(tcx, trait_def_id, substs, vst);\n                     }\n                     _ => {}\n                 }\n-              }\n-              _ => ()\n             }\n-          }\n-          ast::ty_fn(ast::proto_block, purity, onceness, ast_bounds,\n-                     ast_fn_decl) => {\n-            let new_proto;\n-            match vst {\n-                ty::vstore_fixed(_) => {\n-                    tcx.sess.span_err(span, ~\"fixed-length functions are not \\\n-                                              allowed\");\n-                    new_proto = ast::proto_block;\n-                }\n-                ty::vstore_uniq => new_proto = ast::proto_uniq,\n-                ty::vstore_box => new_proto = ast::proto_box,\n-                ty::vstore_slice(_) => new_proto = ast::proto_block\n-            }\n-\n-            // Run through the normal function type conversion process.\n-            let bounds = collect::compute_bounds(self.ccx(), ast_bounds);\n-            let fn_decl = ty_of_fn_decl(self,\n-                                        rscope,\n-                                        new_proto,\n-                                        purity,\n-                                        onceness,\n-                                        bounds,\n-                                        ast_fn_decl,\n-                                        None,\n-                                        span);\n-            return ty::mk_fn(tcx, fn_decl);\n-          }\n-          _ => ()\n+            _ => {}\n         }\n \n         let seq_ty = ast_mt_to_mt(self, rscope, a_seq_ty);\n@@ -279,12 +260,12 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n       ast::ty_nil => ty::mk_nil(tcx),\n       ast::ty_bot => ty::mk_bot(tcx),\n       ast::ty_box(mt) => {\n-        mk_maybe_vstore(self, rscope, mt, ty::vstore_box, ast_ty.span,\n-                        |tmt| ty::mk_box(tcx, tmt))\n+        mk_pointer(self, rscope, mt, ty::vstore_box,\n+                   |tmt| ty::mk_box(tcx, tmt))\n       }\n       ast::ty_uniq(mt) => {\n-        mk_maybe_vstore(self, rscope, mt, ty::vstore_uniq, ast_ty.span,\n-                        |tmt| ty::mk_uniq(tcx, tmt))\n+        mk_pointer(self, rscope, mt, ty::vstore_uniq,\n+                   |tmt| ty::mk_uniq(tcx, tmt))\n       }\n       ast::ty_vec(mt) => {\n         tcx.sess.span_err(ast_ty.span,\n@@ -298,12 +279,8 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n       }\n       ast::ty_rptr(region, mt) => {\n         let r = ast_region_to_region(self, rscope, ast_ty.span, region);\n-        mk_maybe_vstore(self,\n-                        in_anon_rscope(rscope, r),\n-                        mt,\n-                        ty::vstore_slice(r),\n-                        ast_ty.span,\n-                        |tmt| ty::mk_rptr(tcx, r, tmt))\n+        mk_pointer(self, in_anon_rscope(rscope, r), mt, ty::vstore_slice(r),\n+                   |tmt| ty::mk_rptr(tcx, r, tmt))\n       }\n       ast::ty_tup(fields) => {\n         let flds = vec::map(fields, |t| ast_ty_to_ty(self, rscope, *t));\n@@ -316,10 +293,11 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n         };\n         ty::mk_rec(tcx, flds)\n       }\n-      ast::ty_fn(proto, purity, onceness, ast_bounds, decl) => {\n-        let bounds = collect::compute_bounds(self.ccx(), ast_bounds);\n-        let fn_decl = ty_of_fn_decl(self, rscope, proto, purity,\n-                                    onceness, bounds, decl, None,\n+      ast::ty_fn(f) => {\n+        let bounds = collect::compute_bounds(self.ccx(), f.bounds);\n+        let fn_decl = ty_of_fn_decl(self, rscope, f.proto,\n+                                    f.purity, f.onceness,\n+                                    bounds, f.region, f.decl, None,\n                                     ast_ty.span);\n         ty::mk_fn(tcx, fn_decl)\n       }\n@@ -377,22 +355,9 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n           }\n         }\n       }\n-      ast::ty_fixed_length(a_t, Some(u)) => {\n-        mk_maybe_vstore(self, rscope, {ty: a_t, mutbl: ast::m_imm},\n-                        ty::vstore_fixed(u),\n-                        ast_ty.span,\n-                        |ty| {\n-                            tcx.sess.span_err(\n-                                a_t.span,\n-                                fmt!(\"bound not allowed on a %s\",\n-                                     ty::ty_sort_str(tcx, ty.ty)));\n-                            ty.ty\n-                        })\n-      }\n-      ast::ty_fixed_length(_, None) => {\n-        tcx.sess.span_bug(\n-            ast_ty.span,\n-            ~\"implied fixed length for bound\");\n+      ast::ty_fixed_length_vec(a_mt, u) => {\n+        ty::mk_evec(tcx, ast_mt_to_mt(self, rscope, a_mt),\n+                    ty::vstore_fixed(u))\n       }\n       ast::ty_infer => {\n         // ty_infer should only appear as the type of arguments or return\n@@ -459,38 +424,44 @@ fn ty_of_arg<AC: ast_conv, RS: region_scope Copy Owned>(\n     {mode: mode, ty: ty}\n }\n \n-fn ast_proto_to_proto<AC: ast_conv, RS: region_scope Copy Owned>(\n-    self: AC, rscope: RS, span: span, ast_proto: ast::proto) -> ty::fn_proto {\n-    match ast_proto {\n-        ast::proto_bare =>\n-            ty::proto_bare,\n-        ast::proto_uniq =>\n-            ty::proto_vstore(ty::vstore_uniq),\n-        ast::proto_box =>\n-            ty::proto_vstore(ty::vstore_box),\n-        ast::proto_block => {\n-            let result = rscope.anon_region(span);\n-            let region = get_region_reporting_err(self.tcx(), span, result);\n-            ty::proto_vstore(ty::vstore_slice(region))\n-        }\n-    }\n-}\n-\n type expected_tys = Option<{inputs: ~[ty::arg],\n                             output: ty::t}>;\n \n fn ty_of_fn_decl<AC: ast_conv, RS: region_scope Copy Owned>(\n     self: AC, rscope: RS,\n-    ast_proto: ast::proto,\n+    ast_proto: ast::Proto,\n     purity: ast::purity,\n     onceness: ast::Onceness,\n     bounds: @~[ty::param_bound],\n+    opt_region: Option<@ast::region>,\n     decl: ast::fn_decl,\n     expected_tys: expected_tys,\n-    span: span) -> ty::FnTy {\n-\n+    span: span) -> ty::FnTy\n+{\n     debug!(\"ty_of_fn_decl\");\n     do indent {\n+        // resolve the function bound region in the original region\n+        // scope `rscope`, not the scope of the function parameters\n+        let bound_region = match opt_region {\n+            Some(region) => {\n+                ast_region_to_region(self, rscope, span, region)\n+            }\n+            None => {\n+                match ast_proto {\n+                    ast::ProtoBare | ast::ProtoUniq | ast::ProtoBox => {\n+                        // @fn(), ~fn() default to static as the bound\n+                        // on their upvars:\n+                        ty::re_static\n+                    }\n+                    ast::ProtoBorrowed => {\n+                        // &fn() defaults to an anonymous region:\n+                        let r_result = rscope.anon_region(span);\n+                        get_region_reporting_err(self.tcx(), span, r_result)\n+                    }\n+                }\n+            }\n+        };\n+\n         // new region names that appear inside of the fn decl are bound to\n         // that function type\n         let rb = in_binding_rscope(rscope);\n@@ -511,18 +482,15 @@ fn ty_of_fn_decl<AC: ast_conv, RS: region_scope Copy Owned>(\n           _ => ast_ty_to_ty(self, rb, decl.output)\n         };\n \n-        let proto = ast_proto_to_proto(self, rscope, span, ast_proto);\n-\n         FnTyBase {\n             meta: FnMeta {purity: purity,\n-                          proto: proto,\n+                          proto: ast_proto,\n                           onceness: onceness,\n+                          region: bound_region,\n                           bounds: bounds,\n                           ret_style: decl.cf},\n             sig: FnSig {inputs: input_tys,\n                         output: output_ty}\n         }\n     }\n }\n-\n-"}, {"sha": "3de99554554118063777ec905a5a7070e863576c", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 35, "deletions": 51, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -1294,7 +1294,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n     fn check_expr_fn(fcx: @fn_ctxt,\n                      expr: @ast::expr,\n-                     ast_proto_opt: Option<ast::proto>,\n+                     ast_proto_opt: Option<ast::Proto>,\n                      decl: ast::fn_decl,\n                      body: ast::blk,\n                      is_loop_body: bool,\n@@ -1313,56 +1313,39 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let (expected_tys,\n              expected_purity,\n              expected_proto,\n-             expected_onceness) =\n+             expected_onceness) = {\n             match expected_sty {\n-              Some(ty::ty_fn(ref fn_ty)) => {\n-                let {fn_ty, _} =\n-                    replace_bound_regions_in_fn_ty(\n-                        tcx, @Nil, None, fn_ty,\n-                        |br| ty::re_bound(ty::br_cap_avoid(expr.id, @br)));\n-                (Some({inputs: fn_ty.sig.inputs,\n-                       output: fn_ty.sig.output}),\n-                 fn_ty.meta.purity,\n-                 fn_ty.meta.proto,\n-                 fn_ty.meta.onceness)\n-              }\n-              _ => {\n-                (None,\n-                 ast::impure_fn,\n-                 ty::proto_vstore(ty::vstore_box),\n-                 ast::Many)\n-              }\n-            };\n-\n+                Some(ty::ty_fn(ref fn_ty)) => {\n+                    let id = expr.id;\n+                    let {fn_ty, _} =\n+                        replace_bound_regions_in_fn_ty(\n+                            tcx, @Nil, None, fn_ty,\n+                            |br| ty::re_bound(ty::br_cap_avoid(id, @br)));\n+                    (Some({inputs: fn_ty.sig.inputs,\n+                           output: fn_ty.sig.output}),\n+                     fn_ty.meta.purity,\n+                     fn_ty.meta.proto,\n+                     fn_ty.meta.onceness)\n+                }\n+                _ => {\n+                    (None, ast::impure_fn, ast::ProtoBox, ast::Many)\n+                }\n+            }\n+        };\n \n-        // Generate AST prototypes and purity.\n-        // If this is a block lambda (ast_proto == none), these values\n-        // are bogus. We'll fill in the type with the real one later.\n-        // XXX: This is a hack.\n-        let ast_proto = ast_proto_opt.get_default(ast::proto_box);\n-        let ast_purity = ast::impure_fn;\n-        let ast_onceness = ast::Many;\n+        // If the proto is specified, use that, otherwise select a\n+        // proto based on inference.\n+        let (proto, purity) = match ast_proto_opt {\n+            Some(p) => (p, ast::impure_fn),\n+            None => (expected_proto, expected_purity)\n+        };\n \n         // construct the function type\n-        let mut fn_ty = astconv::ty_of_fn_decl(fcx,\n-                                               fcx,\n-                                               ast_proto,\n-                                               ast_purity,\n-                                               ast_onceness,\n-                                               @~[],\n-                                               decl,\n-                                               expected_tys,\n-                                               expr.span);\n-\n-        // Patch up the function declaration, if necessary.\n-        match ast_proto_opt {\n-          None => {\n-            fn_ty.meta.purity = expected_purity;\n-            fn_ty.meta.proto = expected_proto;\n-            fn_ty.meta.onceness = expected_onceness;\n-          }\n-          Some(_) => { }\n-        }\n+        let mut fn_ty = astconv::ty_of_fn_decl(\n+            fcx, fcx,\n+            proto, purity, expected_onceness,\n+            /*bounds:*/ @~[], /*opt_region:*/ None,\n+            decl, expected_tys, expr.span);\n \n         let fty = ty::mk_fn(tcx, fn_ty);\n \n@@ -2815,9 +2798,9 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n       ~\"frame_address\" => {\n         let fty = ty::mk_fn(ccx.tcx, FnTyBase {\n             meta: FnMeta {purity: ast::impure_fn,\n-                          proto: ty::proto_vstore(ty::vstore_slice(\n-                              ty::re_bound(ty::br_anon(0)))),\n-                          onceness: ast::Many,\n+                          proto: ast::ProtoBorrowed,\n+                          onceness: ast::Once,\n+                          region: ty::re_bound(ty::br_anon(0)),\n                           bounds: @~[],\n                           ret_style: ast::return_val},\n             sig: FnSig {inputs: ~[{mode: ast::expl(ast::by_val),\n@@ -2840,8 +2823,9 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n     };\n     let fty = ty::mk_fn(tcx, FnTyBase {\n         meta: FnMeta {purity: ast::impure_fn,\n-                      proto: ty::proto_bare,\n+                      proto: ast::ProtoBare,\n                       onceness: ast::Many,\n+                      region: ty::re_static,\n                       bounds: @~[],\n                       ret_style: ast::return_val},\n         sig: FnSig {inputs: inputs,"}, {"sha": "dd3f4069a9c35cea63cbf50db7b046bde8fbaa8c", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -625,7 +625,7 @@ impl LookupContext {\n             ty_evec(mt, vstore_uniq) |\n             ty_evec(mt, vstore_fixed(_)) => {\n                 self.search_for_some_kind_of_autorefd_method(\n-                    AutoSlice, autoderefs, [m_const, m_imm, m_mutbl],\n+                    AutoBorrowVec, autoderefs, [m_const, m_imm, m_mutbl],\n                     |m,r| ty::mk_evec(tcx,\n                                       {ty:mt.ty, mutbl:m},\n                                       vstore_slice(r)))\n@@ -635,7 +635,7 @@ impl LookupContext {\n             ty_estr(vstore_uniq) |\n             ty_estr(vstore_fixed(_)) => {\n                 self.search_for_some_kind_of_autorefd_method(\n-                    AutoSlice, autoderefs, [m_imm],\n+                    AutoBorrowVec, autoderefs, [m_imm],\n                     |_m,r| ty::mk_estr(tcx, vstore_slice(r)))\n             }\n "}, {"sha": "970e86d00de91fff3803ca6beb76b0f7f0df6c1a", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -22,10 +22,11 @@ use ppaux::{note_and_explain_region, ty_to_str};\n use syntax::print::pprust;\n use infer::{resolve_and_force_all_but_regions, fres};\n use syntax::ast::{def_arg, def_binding, def_local, def_self, def_upvar};\n+use syntax::ast::{ProtoBare, ProtoBox, ProtoUniq, ProtoBorrowed};\n use middle::freevars::get_freevars;\n use middle::kind::check_owned;\n use middle::pat_util::pat_bindings;\n-use middle::ty::{encl_region, proto_bare, proto_vstore, re_scope};\n+use middle::ty::{encl_region, re_scope};\n use middle::ty::{ty_fn_proto, vstore_box, vstore_fixed, vstore_slice};\n use middle::ty::{vstore_uniq};\n \n@@ -40,14 +41,9 @@ fn encl_region_of_def(fcx: @fn_ctxt, def: ast::def) -> ty::Region {\n             return encl_region(tcx, node_id),\n         def_upvar(_, subdef, closure_id, body_id) => {\n             match ty_fn_proto(fcx.node_ty(closure_id)) {\n-                proto_bare =>\n-                    tcx.sess.bug(~\"proto_bare in encl_region_of_def?!\"),\n-                proto_vstore(vstore_fixed(_)) =>\n-                    tcx.sess.bug(~\"vstore_fixed in encl_region_of_def?!\"),\n-                proto_vstore(vstore_slice(_)) =>\n-                    encl_region_of_def(fcx, *subdef),\n-                proto_vstore(vstore_uniq) | proto_vstore(vstore_box) =>\n-                    re_scope(body_id)\n+                ProtoBare => tcx.sess.bug(~\"ProtoBare with upvars?!\"),\n+                ProtoBorrowed => encl_region_of_def(fcx, *subdef),\n+                ProtoBox | ProtoUniq => re_scope(body_id)\n             }\n         }\n         _ => {\n@@ -244,12 +240,9 @@ fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n                 result::Ok(function_type) => {\n                     match ty::get(function_type).sty {\n                         ty::ty_fn(ref fn_ty) => {\n-                            match fn_ty.meta.proto {\n-                                proto_vstore(vstore_slice(region)) => {\n-                                    constrain_free_variables(rcx, region,\n-                                                             expr);\n-                                }\n-                                _ => {}\n+                            if fn_ty.meta.proto == ast::ProtoBorrowed {\n+                                constrain_free_variables(\n+                                    rcx, fn_ty.meta.region, expr);\n                             }\n                         }\n                         _ => ()"}, {"sha": "ebc26d4b4df233fa2bb05cb1f22cb0e0473a14f9", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -133,9 +133,10 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n                 });\n                 result_ty = Some(ty::mk_fn(tcx, FnTyBase {\n                     meta: FnMeta {purity: ast::pure_fn,\n-                                  proto: ty::proto_vstore(ty::vstore_box),\n+                                  proto: ast::ProtoBare,\n                                   onceness: ast::Many,\n                                   bounds: @~[],\n+                                  region: ty::re_static,\n                                   ret_style: ast::return_val},\n                     sig: FnSig {inputs: args,\n                                 output: enum_ty}\n@@ -604,9 +605,11 @@ fn convert_struct(ccx: @crate_ctxt,\n         // Write the dtor type\n         let t_dtor = ty::mk_fn(\n             tcx,\n-            ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_bare,\n-                          ast::impure_fn, ast::Many, @~[],\n-                          ast_util::dtor_dec(), None, dtor.span));\n+            ty_of_fn_decl(\n+                ccx, type_rscope(rp), ast::ProtoBare,\n+                ast::impure_fn, ast::Many,\n+                /*bounds:*/ @~[], /*opt_region:*/ None,\n+                ast_util::dtor_dec(), None, dtor.span));\n         write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n         tcx.tcache.insert(local_def(dtor.node.id),\n                           {bounds: tpt.bounds,\n@@ -643,9 +646,10 @@ fn convert_struct(ccx: @crate_ctxt,\n                 let ctor_fn_ty = ty::mk_fn(tcx, FnTyBase {\n                     meta: FnMeta {\n                         purity: ast::pure_fn,\n-                        proto: ty::proto_bare,\n+                        proto: ast::ProtoBare,\n                         onceness: ast::Many,\n                         bounds: @~[],\n+                        region: ty::re_static,\n                         ret_style: ast::return_val,\n                     },\n                     sig: FnSig {\n@@ -684,15 +688,10 @@ fn ty_of_method(ccx: @crate_ctxt,\n                 rp: Option<ty::region_variance>) -> ty::method {\n     {ident: m.ident,\n      tps: ty_param_bounds(ccx, m.tps),\n-     fty: ty_of_fn_decl(ccx,\n-                        type_rscope(rp),\n-                        ast::proto_bare,\n-                        m.purity,\n-                        ast::Many,\n-                        @~[],\n-                        m.decl,\n-                        None,\n-                        m.span),\n+     fty: ty_of_fn_decl(ccx, type_rscope(rp), ast::ProtoBare,\n+                        m.purity, ast::Many,\n+                        /*bounds:*/ @~[], /*opt_region:*/ None,\n+                        m.decl, None, m.span),\n      self_ty: m.self_ty.node,\n      vis: m.vis,\n      def_id: local_def(m.id)}\n@@ -704,15 +703,10 @@ fn ty_of_ty_method(self: @crate_ctxt,\n                    id: ast::def_id) -> ty::method {\n     {ident: m.ident,\n      tps: ty_param_bounds(self, m.tps),\n-     fty: ty_of_fn_decl(self,\n-                        type_rscope(rp),\n-                        ast::proto_bare,\n-                        m.purity,\n-                        ast::Many,\n-                        @~[],\n-                        m.decl,\n-                        None,\n-                        m.span),\n+     fty: ty_of_fn_decl(self, type_rscope(rp), ast::ProtoBare,\n+                        m.purity, ast::Many,\n+                        /*bounds:*/ @~[], /*opt_region:*/ None,\n+                        m.decl, None, m.span),\n      // assume public, because this is only invoked on trait methods\n      self_ty: m.self_ty.node,\n      vis: ast::public,\n@@ -767,15 +761,10 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n       }\n       ast::item_fn(decl, purity, tps, _) => {\n         let bounds = ty_param_bounds(ccx, tps);\n-        let tofd = ty_of_fn_decl(ccx,\n-                                 empty_rscope,\n-                                 ast::proto_bare,\n-                                 purity,\n-                                 ast::Many,\n-                                 @~[],\n-                                 decl,\n-                                 None,\n-                                 it.span);\n+        let tofd = ty_of_fn_decl(ccx, empty_rscope,\n+                                 ast::ProtoBare, purity, ast::Many,\n+                                 /*bounds:*/ @~[], /*opt_region:*/ None,\n+                                 decl, None, it.span);\n         let tpt = {bounds: bounds,\n                    region_param: None,\n                    ty: ty::mk_fn(ccx.tcx, tofd)};\n@@ -930,9 +919,10 @@ fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n \n     let t_fn = ty::mk_fn(ccx.tcx, FnTyBase {\n         meta: FnMeta {purity: purity,\n-                      proto: ty::proto_bare,\n                       onceness: ast::Many,\n+                      proto: ast::ProtoBare,\n                       bounds: @~[],\n+                      region: ty::re_static,\n                       ret_style: ast::return_val},\n         sig: FnSig {inputs: input_tys,\n                     output: output_ty}"}, {"sha": "e5be4c7a19df655a6b79078e3680c4ad771db775", "filename": "src/rustc/middle/typeck/infer/assignment.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -126,6 +126,14 @@ priv impl Assign {\n             }\n         }\n \n+        fn borrowable_protos(a_p: ast::Proto, b_p: ast::Proto) -> bool {\n+            match (a_p, b_p) {\n+                (ast::ProtoBox, ast::ProtoBorrowed) => true,\n+                (ast::ProtoUniq, ast::ProtoBorrowed) => true,\n+                _ => false\n+            }\n+        }\n+\n         match (a_bnd, b_bnd) {\n             (Some(a_bnd), Some(b_bnd)) => {\n                 // check for a case where a non-region pointer (@, ~) is\n@@ -149,7 +157,7 @@ priv impl Assign {\n                      ty::ty_estr(ty::vstore_slice(r_b)))\n                     if is_borrowable(vs_a) => {\n                         let nr_b = ty::mk_estr(self.infcx.tcx, vs_a);\n-                        self.try_assign(0, ty::AutoSlice,\n+                        self.try_assign(0, ty::AutoBorrowVec,\n                                         a, nr_b,\n                                         m_imm, r_b)\n                     }\n@@ -160,11 +168,22 @@ priv impl Assign {\n                         let nr_b = ty::mk_evec(self.infcx.tcx,\n                                                {ty: mt_b.ty, mutbl: m_const},\n                                                vs_a);\n-                        self.try_assign(0, ty::AutoSlice,\n+                        self.try_assign(0, ty::AutoBorrowVec,\n                                         a, nr_b,\n                                         mt_b.mutbl, r_b)\n                     }\n \n+                    (ty::ty_fn(ref a_f), ty::ty_fn(ref b_f))\n+                    if borrowable_protos(a_f.meta.proto, b_f.meta.proto) => {\n+                        let nr_b = ty::mk_fn(self.infcx.tcx, ty::FnTyBase {\n+                            meta: ty::FnMeta {proto: a_f.meta.proto,\n+                                              ..b_f.meta},\n+                            sig: b_f.sig\n+                        });\n+                        self.try_assign(0, ty::AutoBorrowFn,\n+                                        a, nr_b, m_imm, b_f.meta.region)\n+                    }\n+\n                     _ => {\n                         // otherwise, assignment follows normal subtype rules:\n                         to_ares(Sub(*self).tys(a, b))"}, {"sha": "c43f1e9c3865ca36582426c8293904d793ead5f9", "filename": "src/rustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -48,6 +48,8 @@ use to_str::ToStr;\n use ty::{FnTyBase, FnMeta, FnSig};\n use syntax::ast::Onceness;\n \n+fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n+\n trait combine {\n     fn infcx() -> infer_ctxt;\n     fn tag() -> ~str;\n@@ -70,7 +72,7 @@ trait combine {\n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field>;\n     fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode>;\n     fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg>;\n-    fn protos(p1: ty::fn_proto, p2: ty::fn_proto) -> cres<ty::fn_proto>;\n+    fn protos(p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto>;\n     fn ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style>;\n     fn purities(a: purity, b: purity) -> cres<purity>;\n     fn oncenesses(a: Onceness, b: Onceness) -> cres<Onceness>;\n@@ -310,20 +312,17 @@ fn super_vstores<C:combine>(\n fn super_fn_metas<C:combine>(\n     self: &C, a_f: &ty::FnMeta, b_f: &ty::FnMeta) -> cres<ty::FnMeta>\n {\n-    do self.protos(a_f.proto, b_f.proto).chain |p| {\n-        do self.ret_styles(a_f.ret_style, b_f.ret_style).chain |rs| {\n-            do self.purities(a_f.purity, b_f.purity).chain |purity| {\n-                do self.oncenesses(a_f.onceness, b_f.onceness).chain\n-                        |onceness| {\n-                    Ok(FnMeta {purity: purity,\n-                               proto: p,\n-                               onceness: onceness,\n-                               bounds: a_f.bounds, // XXX: This is wrong!\n-                               ret_style: rs})\n-                }\n-            }\n-        }\n-    }\n+    let p = if_ok!(self.protos(a_f.proto, b_f.proto));\n+    let r = if_ok!(self.contraregions(a_f.region, b_f.region));\n+    let rs = if_ok!(self.ret_styles(a_f.ret_style, b_f.ret_style));\n+    let purity = if_ok!(self.purities(a_f.purity, b_f.purity));\n+    let onceness = if_ok!(self.oncenesses(a_f.onceness, b_f.onceness));\n+    Ok(FnMeta {purity: purity,\n+               proto: p,\n+               region: r,\n+               onceness: onceness,\n+               bounds: a_f.bounds, // XXX: This is wrong!\n+               ret_style: rs})\n }\n \n fn super_fn_sigs<C:combine>("}, {"sha": "fb4bd1af199d0180741f2ea89a30674c8f66322f", "filename": "src/rustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -71,22 +71,8 @@ impl Glb: combine {\n         Lub(*self).tys(a, b)\n     }\n \n-    fn protos(p1: ty::fn_proto, p2: ty::fn_proto) -> cres<ty::fn_proto> {\n-        match (p1, p2) {\n-            (ty::proto_vstore(ty::vstore_slice(_)), _) => Ok(p2),\n-            (_, ty::proto_vstore(ty::vstore_slice(_))) => Ok(p1),\n-            (ty::proto_vstore(v1), ty::proto_vstore(v2)) => {\n-                self.infcx.try(|| {\n-                    do self.vstores(terr_fn, v1, v2).chain |vs| {\n-                        Ok(ty::proto_vstore(vs))\n-                    }\n-                }).chain_err(|_err| {\n-                    // XXX: Totally unsound, but fixed up later.\n-                    Ok(ty::proto_bare)\n-                })\n-            }\n-            _ => Ok(ty::proto_bare)\n-        }\n+    fn protos(p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto> {\n+        if p1 == p2 {Ok(p1)} else {Ok(ast::ProtoBare)}\n     }\n \n     fn purities(a: purity, b: purity) -> cres<purity> {"}, {"sha": "a323ae720b2825d939e5b865828860edb7249ee7", "filename": "src/rustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -54,21 +54,12 @@ impl Lub: combine {\n         Glb(*self).tys(a, b)\n     }\n \n-    // XXX: Wrong.\n-    fn protos(p1: ty::fn_proto, p2: ty::fn_proto) -> cres<ty::fn_proto> {\n+    fn protos(p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto> {\n         match (p1, p2) {\n-            (ty::proto_bare, _) => Ok(p2),\n-            (_, ty::proto_bare) => Ok(p1),\n-            (ty::proto_vstore(v1), ty::proto_vstore(v2)) => {\n-                self.infcx.try(|| {\n-                    do self.vstores(terr_fn, v1, v2).chain |vs| {\n-                        Ok(ty::proto_vstore(vs))\n-                    }\n-                }).chain_err(|_err| {\n-                    // XXX: Totally unsound, but fixed up later.\n-                    Ok(ty::proto_vstore(ty::vstore_slice(ty::re_static)))\n-                })\n-            }\n+            (ast::ProtoBare, _) => Ok(p2),\n+            (_, ast::ProtoBare) => Ok(p1),\n+            _ if p1 == p2 => Ok(p1),\n+            _ => Err(ty::terr_proto_mismatch(expected_found(&self, p1, p2)))\n         }\n     }\n "}, {"sha": "80f9eb85aab20a2cc1123eb541a4749e250056cd", "filename": "src/rustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -63,27 +63,11 @@ impl Sub: combine {\n         }\n     }\n \n-    fn protos(a: ty::fn_proto, b: ty::fn_proto) -> cres<ty::fn_proto> {\n-        match (a, b) {\n-            (ty::proto_bare, _) =>\n-                Ok(ty::proto_bare),\n-\n-            (ty::proto_vstore(ty::vstore_box),\n-             ty::proto_vstore(ty::vstore_slice(_))) =>\n-                Ok(ty::proto_vstore(ty::vstore_box)),\n-\n-            (ty::proto_vstore(ty::vstore_uniq),\n-             ty::proto_vstore(ty::vstore_slice(_))) =>\n-                Ok(ty::proto_vstore(ty::vstore_uniq)),\n-\n-            (_, ty::proto_bare) =>\n-                Err(ty::terr_proto_mismatch(expected_found(&self, a, b))),\n-\n-            (ty::proto_vstore(vs_a), ty::proto_vstore(vs_b)) => {\n-                do self.vstores(ty::terr_fn, vs_a, vs_b).chain |vs_c| {\n-                    Ok(ty::proto_vstore(vs_c))\n-                }\n-            }\n+    fn protos(p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto> {\n+        match (p1, p2) {\n+            (ast::ProtoBare, _) => Ok(p1),\n+            _ if p1 == p2 => Ok(p1),\n+            _ => Err(ty::terr_proto_mismatch(expected_found(&self, p1, p2)))\n         }\n     }\n "}, {"sha": "a9b67a7ff29c994c00ef20812aa612326cf73849", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 55, "deletions": 38, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -4,7 +4,7 @@ use middle::ty::{arg, canon_mode};\n use middle::ty::{bound_copy, bound_const, bound_owned, bound_send,\n         bound_trait};\n use middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid};\n-use middle::ty::{ck_block, ck_box, ck_uniq, ctxt, field, method};\n+use middle::ty::{ctxt, field, method};\n use middle::ty::{mt, t, param_bound};\n use middle::ty::{re_bound, re_free, re_scope, re_infer, re_static, Region};\n use middle::ty::{ReSkolemized, ReVar};\n@@ -111,22 +111,19 @@ fn explain_region_and_span(cx: ctxt, region: ty::Region)\n }\n \n fn bound_region_to_str(cx: ctxt, br: bound_region) -> ~str {\n-    match br {\n-      br_named(id)                   => fmt!(\"&%s\", cx.sess.str_of(id)),\n-      br_self if cx.sess.verbose() => ~\"&<self>\",\n-      br_self                        => ~\"&self\",\n+    bound_region_to_str_adorned(cx, ~\"&\", br, ~\"\")\n+}\n \n-      br_anon(idx) => {\n-        if cx.sess.verbose() {fmt!(\"&%u\", idx)} else {~\"&\"}\n-      }\n+fn bound_region_to_str_adorned(cx: ctxt, prefix: ~str,\n+                               br: bound_region, sep: ~str) -> ~str {\n+    if cx.sess.verbose() { return fmt!(\"%s%?%s\", prefix, br, sep); }\n \n-      br_cap_avoid(id, br) => {\n-        if cx.sess.verbose() {\n-            fmt!(\"br_cap_avoid(%?, %s)\", id, bound_region_to_str(cx, *br))\n-        } else {\n-            bound_region_to_str(cx, *br)\n-        }\n-      }\n+    match br {\n+      br_named(id)         => fmt!(\"%s%s%s\", prefix, cx.sess.str_of(id), sep),\n+      br_self              => fmt!(\"%sself%s\", prefix, sep),\n+      br_anon(_)           => prefix,\n+      br_cap_avoid(_, br)  => bound_region_to_str_adorned(cx, prefix,\n+                                                          *br, sep)\n     }\n }\n \n@@ -174,21 +171,28 @@ fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n // you should use `explain_region()` or, better yet,\n // `note_and_explain_region()`\n fn region_to_str(cx: ctxt, region: Region) -> ~str {\n+    region_to_str_adorned(cx, ~\"&\", region, ~\"\")\n+}\n+\n+fn region_to_str_adorned(cx: ctxt, prefix: ~str,\n+                         region: Region, sep: ~str) -> ~str {\n     if cx.sess.verbose() {\n-        return fmt!(\"&%?\", region);\n+        return fmt!(\"%s%?%s\", prefix, region, sep);\n     }\n \n     // These printouts are concise.  They do not contain all the information\n     // the user might want to diagnose an error, but there is basically no way\n     // to fit that into a short string.  Hence the recommendation to use\n     // `explain_region()` or `note_and_explain_region()`.\n     match region {\n-      re_scope(_) => ~\"&\",\n-      re_bound(br) => bound_region_to_str(cx, br),\n-      re_free(_, br) => bound_region_to_str(cx, br),\n-      re_infer(ReSkolemized(_, br)) => bound_region_to_str(cx, br),\n-      re_infer(ReVar(_)) => ~\"&\",\n-      re_static => ~\"&static\"\n+        re_scope(_) => prefix,\n+        re_bound(br) => bound_region_to_str_adorned(cx, prefix, br, sep),\n+        re_free(_, br) => bound_region_to_str_adorned(cx, prefix, br, sep),\n+        re_infer(ReSkolemized(_, br)) => {\n+            bound_region_to_str_adorned(cx, prefix, br, sep)\n+        }\n+        re_infer(ReVar(_)) => prefix,\n+        re_static => fmt!(\"%sstatic%s\", prefix, sep)\n     }\n }\n \n@@ -222,10 +226,12 @@ fn vstore_ty_to_str(cx: ctxt, ty: ~str, vs: ty::vstore) -> ~str {\n     }\n }\n \n-fn proto_ty_to_str(cx: ctxt, proto: ty::fn_proto) -> ~str {\n+fn proto_ty_to_str(_cx: ctxt, proto: ast::Proto) -> ~str {\n     match proto {\n-      ty::proto_bare => ~\"\",\n-      ty::proto_vstore(vstore) => vstore_to_str(cx, vstore)\n+        ast::ProtoBare => ~\"\",\n+        ast::ProtoBox => ~\"@\",\n+        ast::ProtoBorrowed => ~\"&\",\n+        ast::ProtoUniq => ~\"~\",\n     }\n }\n \n@@ -268,8 +274,9 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         modestr + ty_to_str(cx, ty)\n     }\n     fn fn_to_str(cx: ctxt,\n+                 proto: ast::Proto,\n+                 region: ty::Region,\n                  purity: ast::purity,\n-                 proto: ty::fn_proto,\n                  onceness: ast::Onceness,\n                  ident: Option<ast::ident>,\n                  inputs: ~[arg],\n@@ -287,9 +294,21 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n             ast::Once => onceness_to_str(onceness) + ~\" \"\n         };\n \n+        s += proto_ty_to_str(cx, proto);\n+\n+        match (proto, region) {\n+            (ast::ProtoBox, ty::re_static) |\n+            (ast::ProtoUniq, ty::re_static) |\n+            (ast::ProtoBare, ty::re_static) => {\n+            }\n+\n+            (_, region) => {\n+                s += region_to_str_adorned(cx, ~\"\", region, ~\"/\");\n+            }\n+        }\n+\n         s += ~\"fn\";\n \n-        s += proto_ty_to_str(cx, proto);\n         match ident {\n           Some(i) => { s += ~\" \"; s += cx.sess.str_of(i); }\n           _ => { }\n@@ -310,8 +329,9 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     fn method_to_str(cx: ctxt, m: method) -> ~str {\n         return fn_to_str(\n             cx,\n-            m.fty.meta.purity,\n             m.fty.meta.proto,\n+            m.fty.meta.region,\n+            m.fty.meta.purity,\n             m.fty.meta.onceness,\n             Some(m.ident),\n             m.fty.sig.inputs,\n@@ -345,12 +365,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_uniq(tm) => ~\"~\" + mt_to_str(cx, tm),\n       ty_ptr(tm) => ~\"*\" + mt_to_str(cx, tm),\n       ty_rptr(r, tm) => {\n-        let rs = region_to_str(cx, r);\n-        if rs == ~\"&\" {\n-            rs + mt_to_str(cx, tm)\n-        } else {\n-            rs + ~\"/\" + mt_to_str(cx, tm)\n-        }\n+        region_to_str_adorned(cx, ~\"&\", r, ~\"/\") + mt_to_str(cx, tm)\n       }\n       ty_unboxed_vec(tm) => { ~\"unboxed_vec<\" + mt_to_str(cx, tm) + ~\">\" }\n       ty_type => ~\"type\",\n@@ -364,8 +379,9 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       }\n       ty_fn(ref f) => {\n         fn_to_str(cx,\n-                  f.meta.purity,\n                   f.meta.proto,\n+                  f.meta.region,\n+                  f.meta.purity,\n                   f.meta.onceness,\n                   None,\n                   f.sig.inputs,\n@@ -393,9 +409,10 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       }\n       ty_estr(vs) => vstore_ty_to_str(cx, ~\"str\", vs),\n       ty_opaque_box => ~\"@?\",\n-      ty_opaque_closure_ptr(ck_block) => ~\"closure&\",\n-      ty_opaque_closure_ptr(ck_box) => ~\"closure@\",\n-      ty_opaque_closure_ptr(ck_uniq) => ~\"closure~\"\n+      ty_opaque_closure_ptr(ast::ProtoBorrowed) => ~\"closure&\",\n+      ty_opaque_closure_ptr(ast::ProtoBox) => ~\"closure@\",\n+      ty_opaque_closure_ptr(ast::ProtoUniq) => ~\"closure~\",\n+      ty_opaque_closure_ptr(ast::ProtoBare) => ~\"closure\"\n     }\n }\n "}, {"sha": "94375d4ffcbf0ce739a196a118f6ed4875855e1f", "filename": "src/test/compile-fail/block-coerce-no.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -2,11 +2,11 @@\n // other tycons.\n \n fn coerce(b: fn()) -> extern fn() {\n-    fn lol(f: extern fn(fn()) -> extern fn(),\n-           g: fn()) -> extern fn() { return f(g); }\n-    fn fn_id(f: extern fn()) -> extern fn() { return f }\n+    fn lol(+f: extern fn(+v: fn()) -> extern fn(),\n+           +g: fn()) -> extern fn() { return f(g); }\n+    fn fn_id(+f: extern fn()) -> extern fn() { return f }\n     return lol(fn_id, b);\n-    //~^ ERROR mismatched types: expected `fn(fn&()) -> fn()`\n+    //~^ ERROR mismatched types\n }\n \n fn main() {"}, {"sha": "c9bcfc411190222ddedb013517e13fad4021fd11", "filename": "src/test/compile-fail/extern-wrong-value-type.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -1,8 +1,7 @@\n-// error-pattern:expected `fn&()` but found `*u8`\n extern fn f() {\n }\n \n fn main() {\n     // extern functions are *u8 types\n-    let _x: fn() = f;\n+    let _x: fn() = f; //~ ERROR mismatched types: expected `&fn()` but found `*u8`\n }"}, {"sha": "d95611cbeb77c79f6826cdef3e4cc63e041b78e4", "filename": "src/test/compile-fail/issue-1896-1.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -1,7 +1,7 @@\n type boxedFn = { theFn: fn () -> uint };\n \n fn createClosure (closedUint: uint) -> boxedFn {\n-    { theFn: fn@ () -> uint { closedUint } }\n+    { theFn: fn@ () -> uint { closedUint } } //~ ERROR mismatched types\n }\n \n fn main () {", "previous_filename": "src/test/run-pass/issue-1896-1.rs"}, {"sha": "af245dbeae8a0195f8bc5555b9d00d2629bf1c04", "filename": "src/test/compile-fail/issue-1896-2.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fissue-1896-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fissue-1896-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1896-2.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -5,6 +5,6 @@ fn add(n: int) -> fn@(int) -> int {\n fn main()\n {\n       assert add(3)(4) == 7;\n-        let add3 : fn(int)->int = add(3);\n-          assert add3(4) == 7;\n+      let add3 : fn(int)->int = add(3); //~ ERROR mismatched types\n+      assert add3(4) == 7;\n }\n\\ No newline at end of file", "previous_filename": "src/test/run-pass/issue-1896-2.rs"}, {"sha": "05aea8f0fca54c823fcbe224d3965f4467942650", "filename": "src/test/compile-fail/issue-1896-3.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fissue-1896-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fissue-1896-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1896-3.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -12,6 +12,6 @@ fn main()\n     let add2 : &(fn@(int)->int) = &add(2);\n     assert (*add2)(5) == 7;\n \n-    let add3 : fn(int)->int = add(3);\n+    let add3 : fn(int)->int = add(3); //~ ERROR mismatched types\n     assert add3(4) == 7;\n }", "previous_filename": "src/test/run-pass/issue-1896-3.rs"}, {"sha": "cd00b0088a732af248e05e33f6021619aaa9f077", "filename": "src/test/compile-fail/issue-1896.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fissue-1896.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fissue-1896.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1896.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -3,6 +3,7 @@ type t<T> = { f: fn() -> T };\n fn f<T>(_x: t<T>) {}\n \n fn main() {\n-    let x: t<()> = { f: { || () } };\n-    f(x); //~ ERROR copying a noncopyable value\n+    let x: t<()> = { f: { || () } }; //~ ERROR expected & closure, found @ closure\n+    //~^ ERROR in field `f`, expected & closure, found @ closure\n+    f(x);\n }\n\\ No newline at end of file"}, {"sha": "1726a527d146d1072b494060562e5c3f7268461e", "filename": "src/test/compile-fail/missing-do.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -4,6 +4,6 @@ fn foo(f: fn()) { f() }\n \n fn main() {\n     ~\"\" || 42; //~ ERROR binary operation || cannot be applied to type `~str`\n-    foo || {}; //~ ERROR binary operation || cannot be applied to type `fn(fn&())`\n+    foo || {}; //~ ERROR binary operation || cannot be applied to type `fn(&fn())`\n     //~^ NOTE did you forget the 'do' keyword for the call?\n }"}, {"sha": "96fb676e42525cd083a8118c5ebf34159cbda2cc", "filename": "src/test/compile-fail/obsolete-syntax.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -56,22 +56,11 @@ fn obsolete_with() {\n     //~^ ERROR obsolete syntax: with\n }\n \n-fn obsolete_fixed_length_vec() {\n-    let foo: [int]/1;\n-    //~^ ERROR obsolete syntax: fixed-length vector\n-    foo = [1]/_;\n-    //~^ ERROR obsolete syntax: fixed-length vector\n-    let foo: [int]/1;\n-    //~^ ERROR obsolete syntax: fixed-length vector\n-    foo = [1]/1;\n-    //~^ ERROR obsolete syntax: fixed-length vector\n-}\n-\n fn obsolete_moves() {\n     let mut x = 0;\n     let y <- x;\n     //~^ ERROR obsolete syntax: initializer-by-move\n-    y <- x; \n+    y <- x;\n     //~^ ERROR obsolete syntax: binary move\n }\n "}, {"sha": "efc4a720ab19c9125caf87c9482d854f7a80adc0", "filename": "src/test/compile-fail/pure-subtyping.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fpure-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fpure-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-subtyping.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -1,35 +1,37 @@\n // Test rules governing higher-order pure fns.\n \n+fn take<T>(_v: T) {}\n+\n fn assign_to_pure(x: pure fn(), y: fn(), z: unsafe fn()) {\n-    let a: pure fn() = x;\n-    let b: pure fn() = y; //~ ERROR expected pure fn but found impure fn\n-    let c: pure fn() = z; //~ ERROR expected pure fn but found unsafe fn\n+    take::<pure fn()>(x);\n+    take::<pure fn()>(y); //~ ERROR expected pure fn but found impure fn\n+    take::<pure fn()>(z); //~ ERROR expected pure fn but found unsafe fn\n }\n \n fn assign_to_impure(x: pure fn(), y: fn(), z: unsafe fn()) {\n-    let h: fn() = x;\n-    let i: fn() = y;\n-    let j: fn() = z; //~ ERROR expected impure fn but found unsafe fn\n+    take::<fn()>(x);\n+    take::<fn()>(y);\n+    take::<fn()>(z); //~ ERROR expected impure fn but found unsafe fn\n }\n \n fn assign_to_unsafe(x: pure fn(), y: fn(), z: unsafe fn()) {\n-    let m: unsafe fn() = x;\n-    let n: unsafe fn() = y;\n-    let o: unsafe fn() = z;\n+    take::<unsafe fn()>(x);\n+    take::<unsafe fn()>(y);\n+    take::<unsafe fn()>(z);\n }\n \n fn assign_to_pure2(x: pure fn@(), y: fn@(), z: unsafe fn@()) {\n-    let a: pure fn() = x;\n-    let b: pure fn() = y; //~ ERROR expected pure fn but found impure fn\n-    let c: pure fn() = z; //~ ERROR expected pure fn but found unsafe fn\n+    take::<pure fn()>(x);\n+    take::<pure fn()>(y); //~ ERROR expected pure fn but found impure fn\n+    take::<pure fn()>(z); //~ ERROR expected pure fn but found unsafe fn\n \n-    let a: pure fn~() = x; //~ ERROR fn storage differs: expected ~ but found @\n-    let b: pure fn~() = y; //~ ERROR fn storage differs: expected ~ but found @\n-    let c: pure fn~() = z; //~ ERROR fn storage differs: expected ~ but found @\n+    take::<pure fn~()>(x); //~ ERROR expected ~ closure, found @ closure\n+    take::<pure fn~()>(y); //~ ERROR expected ~ closure, found @ closure\n+    take::<pure fn~()>(z); //~ ERROR expected ~ closure, found @ closure\n \n-    let a: unsafe fn~() = x; //~ ERROR fn storage differs: expected ~ but found @\n-    let b: unsafe fn~() = y; //~ ERROR fn storage differs: expected ~ but found @\n-    let c: unsafe fn~() = z; //~ ERROR fn storage differs: expected ~ but found @\n+    take::<unsafe fn~()>(x); //~ ERROR expected ~ closure, found @ closure\n+    take::<unsafe fn~()>(y); //~ ERROR expected ~ closure, found @ closure\n+    take::<unsafe fn~()>(z); //~ ERROR expected ~ closure, found @ closure\n }\n \n fn main() {"}, {"sha": "ce2839b1caf6312ee1099413cd165577d8cce579", "filename": "src/test/compile-fail/regions-fn-bound.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fregions-fn-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fregions-fn-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fn-bound.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -0,0 +1,21 @@\n+fn of<T>() -> @fn(T) { fail; }\n+fn subtype<T>(x: @fn(T)) { fail; }\n+\n+fn test_fn<T>(_x: &x/T, _y: &y/T, _z: &z/T) {\n+    // Here, x, y, and z are free.  Other letters\n+    // are bound.  Note that the arrangement\n+    // subtype::<T1>(of::<T2>()) will typecheck\n+    // iff T1 <: T2.\n+\n+    // should be the default:\n+    subtype::<@static/fn()>(of::<@fn()>());\n+    subtype::<@fn()>(of::<@static/fn()>());\n+\n+    //\n+    subtype::<@x/fn()>(of::<@fn()>());    //~ ERROR mismatched types\n+    subtype::<@x/fn()>(of::<@y/fn()>());  //~ ERROR mismatched types\n+\n+    subtype::<@x/fn()>(of::<@static/fn()>()); //~ ERROR mismatched types\n+    subtype::<@static/fn()>(of::<@x/fn()>());\n+\n+}"}, {"sha": "e5b33d725c7c00e6f7912c84edd83955abed84ac", "filename": "src/test/compile-fail/regions-freevar.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -2,8 +2,7 @@ fn wants_static_fn(_x: &static/fn()) {}\n \n fn main() {\n     let i = 3;\n-    do wants_static_fn {\n+    do wants_static_fn { //~ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n         debug!(\"i=%d\", i);\n-          //~^ ERROR captured variable does not outlive the enclosing closure\n     }\n }"}, {"sha": "f47cf51b4be2441292741129b72999046fca6b10", "filename": "src/test/compile-fail/sendfn-is-not-a-lambda.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fsendfn-is-not-a-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fcompile-fail%2Fsendfn-is-not-a-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsendfn-is-not-a-lambda.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -4,5 +4,5 @@ fn test(f: fn@(uint) -> uint) -> uint {\n \n fn main() {\n     let f = fn~(x: uint) -> uint { return 4u; };\n-    log(debug, test(f)); //~ ERROR expected `fn@(uint) -> uint`\n+    log(debug, test(f)); //~ ERROR expected @ closure, found ~ closure\n }"}, {"sha": "9fb898991e8abe7b0dbac7312a6ee4becbf3080f", "filename": "src/test/pretty/disamb-stmt-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -4,7 +4,7 @@\n // preserved.  They are needed to disambiguate `{return n+1}; - 0` from\n // `({return n+1}-0)`.\n \n-fn id(f: fn&() -> int) -> int { f() }\n+fn id(f: &fn() -> int) -> int { f() }\n \n fn wsucc(n: int) -> int { (do id || { 1 }) - 0 }\n fn main() { }"}, {"sha": "a1fdf5094c12c952e01132b8b18e03330186a7c7", "filename": "src/test/pretty/fn-types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fpretty%2Ffn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Fpretty%2Ffn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Ffn-types.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -1,7 +1,7 @@\n // pp-exact\n \n fn from_foreign_fn(x: extern fn()) { }\n-fn from_stack_closure(x: fn&()) { }\n-fn from_box_closure(x: fn@()) { }\n-fn from_unique_closure(x: fn~()) { }\n+fn from_stack_closure(x: &fn()) { }\n+fn from_box_closure(x: @fn()) { }\n+fn from_unique_closure(x: ~fn()) { }\n fn main() { }"}, {"sha": "c95e84179545fe8cff6c9cb160b554cb85232d25", "filename": "src/test/run-pass/issue-2185.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2185.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -1,3 +1,4 @@\n+// xfail-test FIXME #2263\n // xfail-fast\n // This test had to do with an outdated version of the iterable trait.\n // However, the condition it was testing seemed complex enough to"}, {"sha": "1e8da40b5b309cae01e894668a9512789c555d52", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ed151539cddb1c191f67f9f9597942919d44eb/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=b0ed151539cddb1c191f67f9f9597942919d44eb", "patch": "@@ -37,7 +37,7 @@ fn joinable(+f: fn~()) -> comm::Port<bool> {\n     }\n     let p = comm::Port();\n     let c = comm::Chan(&p);\n-    do task::spawn_unlinked { wrapper(c, copy f) };\n+    do task::spawn_unlinked { wrapper(c, f) };\n     p\n }\n "}]}