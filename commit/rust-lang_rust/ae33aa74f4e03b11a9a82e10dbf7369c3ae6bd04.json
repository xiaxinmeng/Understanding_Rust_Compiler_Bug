{"sha": "ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMzNhYTc0ZjRlMDNiMTFhOWE4MmUxMGRiZjczNjljM2FlNmJkMDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-16T23:21:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-16T23:21:09Z"}, "message": "Auto merge of #32875 - jseyfried:1422_implementation, r=nikomatsakis\n\nImplement `pub(restricted)` privacy (RFC 1422)\n\nThis implements `pub(restricted)` privacy from RFC 1422 (cc #32409) behind a feature gate.\n\n`pub(restricted)` paths currently cannot use re-exported modules both for simplicity of implementation and for future compatibility with RFC 1560 (cf #31783).\n\nr? @nikomatsakis", "tree": {"sha": "285c01dd08e9c3f426d99beeacba4e1e288297b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/285c01dd08e9c3f426d99beeacba4e1e288297b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "html_url": "https://github.com/rust-lang/rust/commit/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7c3a294bf33880d27fc7c3f662a981b1625c0bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7c3a294bf33880d27fc7c3f662a981b1625c0bb", "html_url": "https://github.com/rust-lang/rust/commit/a7c3a294bf33880d27fc7c3f662a981b1625c0bb"}, {"sha": "e14504a113b55c09686a5986c51bbdd6ae9c5da4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e14504a113b55c09686a5986c51bbdd6ae9c5da4", "html_url": "https://github.com/rust-lang/rust/commit/e14504a113b55c09686a5986c51bbdd6ae9c5da4"}], "stats": {"total": 674, "additions": 478, "deletions": 196}, "files": [{"sha": "6e6f845abd368d06ba8e3821815c83223041858a", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -203,6 +203,9 @@ pub trait Visitor<'v> : Sized {\n     fn visit_macro_def(&mut self, macro_def: &'v MacroDef) {\n         walk_macro_def(self, macro_def)\n     }\n+    fn visit_vis(&mut self, vis: &'v Visibility) {\n+        walk_vis(self, vis)\n+    }\n }\n \n pub fn walk_opt_name<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n@@ -288,6 +291,7 @@ pub fn walk_trait_ref<'v, V>(visitor: &mut V, trait_ref: &'v TraitRef)\n }\n \n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n+    visitor.visit_vis(&item.vis);\n     visitor.visit_name(item.span, item.name);\n     match item.node {\n         ItemExternCrate(opt_name) => {\n@@ -529,6 +533,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n }\n \n pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem) {\n+    visitor.visit_vis(&foreign_item.vis);\n     visitor.visit_name(foreign_item.span, foreign_item.name);\n \n     match foreign_item.node {\n@@ -662,6 +667,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n }\n \n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n+    visitor.visit_vis(&impl_item.vis);\n     visitor.visit_name(impl_item.span, impl_item.name);\n     walk_list!(visitor, visit_attribute, &impl_item.attrs);\n     match impl_item.node {\n@@ -690,6 +696,7 @@ pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V, struct_definition: &\n }\n \n pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V, struct_field: &'v StructField) {\n+    visitor.visit_vis(&struct_field.vis);\n     visitor.visit_name(struct_field.span, struct_field.name);\n     visitor.visit_ty(&struct_field.ty);\n     walk_list!(visitor, visit_attribute, &struct_field.attrs);\n@@ -839,6 +846,12 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n     walk_list!(visitor, visit_attribute, &arm.attrs);\n }\n \n+pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility) {\n+    if let Visibility::Restricted { ref path, id } = *vis {\n+        visitor.visit_path(path, id)\n+    }\n+}\n+\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct IdRange {\n     pub min: NodeId,"}, {"sha": "7c47665704118cebb165497bc873349f594825f0", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -1708,8 +1708,10 @@ pub fn lower_capture_clause(_lctx: &LoweringContext, c: CaptureBy) -> hir::Captu\n pub fn lower_visibility(lctx: &LoweringContext, v: &Visibility) -> hir::Visibility {\n     match *v {\n         Visibility::Public => hir::Public,\n+        Visibility::Crate(_) => hir::Visibility::Crate,\n+        Visibility::Restricted { ref path, id } =>\n+            hir::Visibility::Restricted { path: P(lower_path(lctx, path)), id: id },\n         Visibility::Inherited => hir::Inherited,\n-        _ => panic!(lctx.diagnostic().fatal(\"pub(restricted) is not implemented yet!\"))\n     }\n }\n "}, {"sha": "4e7520035238f81f8bbd39a64344fe62c8016d8f", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -30,7 +30,7 @@ pub use self::TyParamBound::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n pub use self::ViewPath_::*;\n-pub use self::Visibility::*;\n+pub use self::Visibility::{Public, Inherited};\n pub use self::PathParameters::*;\n \n use hir::def::Def;\n@@ -1434,6 +1434,8 @@ pub struct PolyTraitRef {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Visibility {\n     Public,\n+    Crate,\n+    Restricted { path: P<Path>, id: NodeId },\n     Inherited,\n }\n "}, {"sha": "e595c619e859bb895328d0cfaa98f3c5d209e194", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -325,6 +325,8 @@ pub fn arg_to_string(arg: &hir::Arg) -> String {\n pub fn visibility_qualified(vis: &hir::Visibility, s: &str) -> String {\n     match *vis {\n         hir::Public => format!(\"pub {}\", s),\n+        hir::Visibility::Crate => format!(\"pub(crate) {}\", s),\n+        hir::Visibility::Restricted { ref path, .. } => format!(\"pub({}) {}\", path, s),\n         hir::Inherited => s.to_string(),\n     }\n }\n@@ -898,6 +900,9 @@ impl<'a> State<'a> {\n     pub fn print_visibility(&mut self, vis: &hir::Visibility) -> io::Result<()> {\n         match *vis {\n             hir::Public => self.word_nbsp(\"pub\"),\n+            hir::Visibility::Crate => self.word_nbsp(\"pub(crate)\"),\n+            hir::Visibility::Restricted { ref path, .. } =>\n+                self.word_nbsp(&format!(\"pub({})\", path)),\n             hir::Inherited => Ok(()),\n         }\n     }"}, {"sha": "0377ef92a6f2f36a0587a7c380652394e43fc11d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -287,6 +287,15 @@ impl Visibility {\n     pub fn from_hir(visibility: &hir::Visibility, id: NodeId, tcx: &TyCtxt) -> Self {\n         match *visibility {\n             hir::Public => Visibility::Public,\n+            hir::Visibility::Crate => Visibility::Restricted(ast::CRATE_NODE_ID),\n+            hir::Visibility::Restricted { id, .. } => match tcx.def_map.borrow().get(&id) {\n+                Some(resolution) => Visibility::Restricted({\n+                    tcx.map.as_local_node_id(resolution.base_def.def_id()).unwrap()\n+                }),\n+                // If there is no resolution, `resolve` will have already reported an error, so\n+                // assume that the visibility is public to avoid reporting more privacy errors.\n+                None => Visibility::Public,\n+            },\n             hir::Inherited => Visibility::Restricted(tcx.map.get_module_parent(id)),\n         }\n     }"}, {"sha": "d55d0d53b8c48d8c51d3eb84ddf3b60fbb24467e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -1023,7 +1023,8 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n                             self.min_visibility = vis;\n                         }\n                         if !vis.is_at_least(self.required_visibility, &self.tcx.map) {\n-                            if self.old_error_set.contains(&ty.id) {\n+                            if self.tcx.sess.features.borrow().pub_restricted ||\n+                               self.old_error_set.contains(&ty.id) {\n                                 span_err!(self.tcx.sess, ty.span, E0446,\n                                           \"private type in public interface\");\n                             } else {\n@@ -1053,7 +1054,8 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n                 self.min_visibility = vis;\n             }\n             if !vis.is_at_least(self.required_visibility, &self.tcx.map) {\n-                if self.old_error_set.contains(&trait_ref.ref_id) {\n+                if self.tcx.sess.features.borrow().pub_restricted ||\n+                   self.old_error_set.contains(&trait_ref.ref_id) {\n                     span_err!(self.tcx.sess, trait_ref.path.span, E0445,\n                               \"private trait in public interface\");\n                 } else {"}, {"sha": "2bec7725b76b72c1e3c8e4003ec19c77a73750bf", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 50, "deletions": 68, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -53,10 +53,10 @@ impl<'a> ToNameBinding<'a> for (Module<'a>, Span) {\n     }\n }\n \n-impl<'a> ToNameBinding<'a> for (Def, Span, DefModifiers) {\n+impl<'a> ToNameBinding<'a> for (Def, Span, DefModifiers, ty::Visibility) {\n     fn to_name_binding(self) -> NameBinding<'a> {\n         let kind = NameBindingKind::Def(self.0);\n-        NameBinding { modifiers: self.2, kind: kind, span: Some(self.1) }\n+        NameBinding { modifiers: self.2, kind: kind, span: Some(self.1), vis: self.3 }\n     }\n }\n \n@@ -105,12 +105,9 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n         let parent = *parent_ref;\n         let name = item.name;\n         let sp = item.span;\n-        let is_public = item.vis == hir::Public;\n-        let modifiers = if is_public {\n-            DefModifiers::PUBLIC\n-        } else {\n-            DefModifiers::empty()\n-        } | DefModifiers::IMPORTABLE;\n+        let modifiers = DefModifiers::IMPORTABLE;\n+        self.current_module = parent;\n+        let vis = self.resolve_visibility(&item.vis);\n \n         match item.node {\n             ItemUse(ref view_path) => {\n@@ -172,7 +169,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                                                     subclass,\n                                                     view_path.span,\n                                                     item.id,\n-                                                    is_public,\n+                                                    vis,\n                                                     is_prelude);\n                     }\n                     ViewPathList(_, ref source_items) => {\n@@ -223,7 +220,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                                                         subclass,\n                                                         source_item.span,\n                                                         source_item.node.id(),\n-                                                        is_public,\n+                                                        vis,\n                                                         is_prelude);\n                         }\n                     }\n@@ -233,7 +230,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                                                     GlobImport,\n                                                     view_path.span,\n                                                     item.id,\n-                                                    is_public,\n+                                                    vis,\n                                                     is_prelude);\n                     }\n                 }\n@@ -249,7 +246,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                     };\n                     let parent_link = ModuleParentLink(parent, name);\n                     let def = Def::Mod(def_id);\n-                    let module = self.new_extern_crate_module(parent_link, def, is_public, item.id);\n+                    let module = self.new_extern_crate_module(parent_link, def, vis, item.id);\n                     self.define(parent, name, TypeNS, (module, sp));\n \n                     self.build_reduced_graph_for_external_crate(module);\n@@ -259,7 +256,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             ItemMod(..) => {\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Mod(self.ast_map.local_def_id(item.id));\n-                let module = self.new_module(parent_link, Some(def), false, is_public);\n+                let module = self.new_module(parent_link, Some(def), false, vis);\n                 self.define(parent, name, TypeNS, (module, sp));\n                 parent.module_children.borrow_mut().insert(item.id, module);\n                 *parent_ref = module;\n@@ -271,59 +268,53 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             ItemStatic(_, m, _) => {\n                 let mutbl = m == hir::MutMutable;\n                 let def = Def::Static(self.ast_map.local_def_id(item.id), mutbl);\n-                self.define(parent, name, ValueNS, (def, sp, modifiers));\n+                self.define(parent, name, ValueNS, (def, sp, modifiers, vis));\n             }\n             ItemConst(_, _) => {\n                 let def = Def::Const(self.ast_map.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, sp, modifiers));\n+                self.define(parent, name, ValueNS, (def, sp, modifiers, vis));\n             }\n             ItemFn(_, _, _, _, _, _) => {\n                 let def = Def::Fn(self.ast_map.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, sp, modifiers));\n+                self.define(parent, name, ValueNS, (def, sp, modifiers, vis));\n             }\n \n             // These items live in the type namespace.\n             ItemTy(..) => {\n                 let def = Def::TyAlias(self.ast_map.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, sp, modifiers));\n+                self.define(parent, name, TypeNS, (def, sp, modifiers, vis));\n             }\n \n             ItemEnum(ref enum_definition, _) => {\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Enum(self.ast_map.local_def_id(item.id));\n-                let module = self.new_module(parent_link, Some(def), false, is_public);\n+                let module = self.new_module(parent_link, Some(def), false, vis);\n                 self.define(parent, name, TypeNS, (module, sp));\n \n-                let variant_modifiers = if is_public {\n-                    DefModifiers::empty()\n-                } else {\n-                    DefModifiers::PRIVATE_VARIANT\n-                };\n                 for variant in &(*enum_definition).variants {\n                     let item_def_id = self.ast_map.local_def_id(item.id);\n-                    self.build_reduced_graph_for_variant(variant, item_def_id,\n-                                                         module, variant_modifiers);\n+                    self.build_reduced_graph_for_variant(variant, item_def_id, module);\n                 }\n             }\n \n             // These items live in both the type and value namespaces.\n             ItemStruct(ref struct_def, _) => {\n                 // Define a name in the type namespace.\n                 let def = Def::Struct(self.ast_map.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, sp, modifiers));\n+                self.define(parent, name, TypeNS, (def, sp, modifiers, vis));\n \n                 // If this is a newtype or unit-like struct, define a name\n                 // in the value namespace as well\n                 if !struct_def.is_struct() {\n                     let def = Def::Struct(self.ast_map.local_def_id(struct_def.id()));\n-                    self.define(parent, name, ValueNS, (def, sp, modifiers));\n+                    self.define(parent, name, ValueNS, (def, sp, modifiers, vis));\n                 }\n \n                 // Record the def ID and fields of this struct.\n-                let field_names = struct_def.fields()\n-                                            .iter()\n-                                            .map(|f| f.name)\n-                                            .collect();\n+                let field_names = struct_def.fields().iter().map(|field| {\n+                    self.resolve_visibility(&field.vis);\n+                    field.name\n+                }).collect();\n                 let item_def_id = self.ast_map.local_def_id(item.id);\n                 self.structs.insert(item_def_id, field_names);\n             }\n@@ -336,7 +327,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 // Add all the items within to a new module.\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Trait(def_id);\n-                let module_parent = self.new_module(parent_link, Some(def), false, is_public);\n+                let module_parent = self.new_module(parent_link, Some(def), false, vis);\n                 self.define(parent, name, TypeNS, (module_parent, sp));\n \n                 // Add the names of all the items to the trait info.\n@@ -348,8 +339,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                         hir::TypeTraitItem(..) => (Def::AssociatedTy(def_id, item_def_id), TypeNS),\n                     };\n \n-                    let modifiers = DefModifiers::PUBLIC; // NB: not DefModifiers::IMPORTABLE\n-                    self.define(module_parent, item.name, ns, (def, item.span, modifiers));\n+                    let modifiers = DefModifiers::empty(); // NB: not DefModifiers::IMPORTABLE\n+                    self.define(module_parent, item.name, ns, (def, item.span, modifiers, vis));\n \n                     self.trait_item_map.insert((item.name, def_id), item_def_id);\n                 }\n@@ -362,8 +353,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n     fn build_reduced_graph_for_variant(&mut self,\n                                        variant: &Variant,\n                                        item_id: DefId,\n-                                       parent: Module<'b>,\n-                                       variant_modifiers: DefModifiers) {\n+                                       parent: Module<'b>) {\n         let name = variant.node.name;\n         if variant.node.data.is_struct() {\n             // Not adding fields for variants as they are not accessed with a self receiver\n@@ -373,24 +363,19 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n \n         // Variants are always treated as importable to allow them to be glob used.\n         // All variants are defined in both type and value namespaces as future-proofing.\n-        let modifiers = DefModifiers::PUBLIC | DefModifiers::IMPORTABLE | variant_modifiers;\n+        let modifiers = DefModifiers::IMPORTABLE;\n         let def = Def::Variant(item_id, self.ast_map.local_def_id(variant.node.data.id()));\n \n-        self.define(parent, name, ValueNS, (def, variant.span, modifiers));\n-        self.define(parent, name, TypeNS, (def, variant.span, modifiers));\n+        self.define(parent, name, ValueNS, (def, variant.span, modifiers, parent.vis));\n+        self.define(parent, name, TypeNS, (def, variant.span, modifiers, parent.vis));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self,\n                                             foreign_item: &ForeignItem,\n                                             parent: Module<'b>) {\n         let name = foreign_item.name;\n-        let is_public = foreign_item.vis == hir::Public;\n-        let modifiers = if is_public {\n-            DefModifiers::PUBLIC\n-        } else {\n-            DefModifiers::empty()\n-        } | DefModifiers::IMPORTABLE;\n+        let modifiers = DefModifiers::IMPORTABLE;\n \n         let def = match foreign_item.node {\n             ForeignItemFn(..) => {\n@@ -400,7 +385,9 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 Def::Static(self.ast_map.local_def_id(foreign_item.id), m)\n             }\n         };\n-        self.define(parent, name, ValueNS, (def, foreign_item.span, modifiers));\n+        self.current_module = parent;\n+        let vis = self.resolve_visibility(&foreign_item.vis);\n+        self.define(parent, name, ValueNS, (def, foreign_item.span, modifiers, vis));\n     }\n \n     fn build_reduced_graph_for_block(&mut self, block: &Block, parent: &mut Module<'b>) {\n@@ -412,7 +399,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                    block_id);\n \n             let parent_link = BlockParentLink(parent, block_id);\n-            let new_module = self.new_module(parent_link, None, false, false);\n+            let new_module = self.new_module(parent_link, None, false, parent.vis);\n             parent.module_children.borrow_mut().insert(block_id, new_module);\n             *parent = new_module;\n         }\n@@ -434,32 +421,27 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n         }\n \n         let name = xcdef.name;\n-        let is_public = xcdef.vis == ty::Visibility::Public || parent.is_trait();\n-\n-        let mut modifiers = DefModifiers::empty();\n-        if is_public {\n-            modifiers = modifiers | DefModifiers::PUBLIC;\n-        }\n-        if parent.is_normal() {\n-            modifiers = modifiers | DefModifiers::IMPORTABLE;\n-        }\n+        let vis = if parent.is_trait() { ty::Visibility::Public } else { xcdef.vis };\n+        let modifiers = match parent.is_normal() {\n+            true => DefModifiers::IMPORTABLE,\n+            false => DefModifiers::empty(),\n+        };\n \n         match def {\n             Def::Mod(_) | Def::ForeignMod(_) | Def::Enum(..) => {\n-                debug!(\"(building reduced graph for external crate) building module {} {}\",\n-                       name,\n-                       is_public);\n+                debug!(\"(building reduced graph for external crate) building module {} {:?}\",\n+                       name, vis);\n                 let parent_link = ModuleParentLink(parent, name);\n-                let module = self.new_module(parent_link, Some(def), true, is_public);\n+                let module = self.new_module(parent_link, Some(def), true, vis);\n                 self.try_define(parent, name, TypeNS, (module, DUMMY_SP));\n             }\n             Def::Variant(_, variant_id) => {\n                 debug!(\"(building reduced graph for external crate) building variant {}\", name);\n                 // Variants are always treated as importable to allow them to be glob used.\n                 // All variants are defined in both type and value namespaces as future-proofing.\n-                let modifiers = DefModifiers::PUBLIC | DefModifiers::IMPORTABLE;\n-                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers));\n-                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers));\n+                let modifiers = DefModifiers::IMPORTABLE;\n+                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers, vis));\n+                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers, vis));\n                 if self.session.cstore.variant_kind(variant_id) == Some(VariantKind::Struct) {\n                     // Not adding fields for variants as they are not accessed with a self receiver\n                     self.structs.insert(variant_id, Vec::new());\n@@ -472,7 +454,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             Def::Method(..) => {\n                 debug!(\"(building reduced graph for external crate) building value (fn/static) {}\",\n                        name);\n-                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers));\n+                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers, vis));\n             }\n             Def::Trait(def_id) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\", name);\n@@ -493,21 +475,21 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 }\n \n                 let parent_link = ModuleParentLink(parent, name);\n-                let module = self.new_module(parent_link, Some(def), true, is_public);\n+                let module = self.new_module(parent_link, Some(def), true, vis);\n                 self.try_define(parent, name, TypeNS, (module, DUMMY_SP));\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\", name);\n-                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers));\n+                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers, vis));\n             }\n             Def::Struct(def_id)\n                 if self.session.cstore.tuple_struct_definition_if_ctor(def_id).is_none() => {\n                 debug!(\"(building reduced graph for external crate) building type and value for {}\",\n                        name);\n-                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers));\n+                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers, vis));\n                 if let Some(ctor_def_id) = self.session.cstore.struct_ctor_def_id(def_id) {\n                     let def = Def::Struct(ctor_def_id);\n-                    self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers));\n+                    self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers, vis));\n                 }\n \n                 // Record the def ID and fields of this struct."}, {"sha": "2147331d441d98b729c8e570b21148e2f31065f3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 86, "deletions": 57, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -55,6 +55,7 @@ use rustc::middle::cstore::CrateStore;\n use rustc::hir::def::*;\n use rustc::hir::def_id::DefId;\n use rustc::hir::pat_util::pat_bindings;\n+use rustc::ty;\n use rustc::ty::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::hir::{Freevar, FreevarMap, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, FnvHashMap, FnvHashSet};\n@@ -820,7 +821,7 @@ enum ParentLink<'a> {\n pub struct ModuleS<'a> {\n     parent_link: ParentLink<'a>,\n     def: Option<Def>,\n-    is_public: bool,\n+    vis: ty::Visibility,\n \n     // If the module is an extern crate, `def` is root of the external crate and `extern_crate_id`\n     // is the NodeId of the local `extern crate` item (otherwise, `extern_crate_id` is None).\n@@ -864,12 +865,12 @@ impl<'a> ModuleS<'a> {\n     fn new(parent_link: ParentLink<'a>,\n            def: Option<Def>,\n            external: bool,\n-           is_public: bool,\n+           vis: ty::Visibility,\n            arenas: &'a ResolverArenas<'a>) -> Self {\n         ModuleS {\n             parent_link: parent_link,\n             def: def,\n-            is_public: is_public,\n+            vis: vis,\n             extern_crate_id: None,\n             resolutions: RefCell::new(HashMap::new()),\n             unresolved_imports: RefCell::new(Vec::new()),\n@@ -892,9 +893,10 @@ impl<'a> ModuleS<'a> {\n         self.def.as_ref().map(Def::def_id)\n     }\n \n+    // `self` resolves to the first module ancestor that `is_normal`.\n     fn is_normal(&self) -> bool {\n         match self.def {\n-            Some(Def::Mod(_)) | Some(Def::ForeignMod(_)) => true,\n+            Some(Def::Mod(_)) => true,\n             _ => false,\n         }\n     }\n@@ -905,40 +907,18 @@ impl<'a> ModuleS<'a> {\n             _ => false,\n         }\n     }\n-\n-    fn is_ancestor_of(&self, module: Module<'a>) -> bool {\n-        if self.def_id() == module.def_id() { return true }\n-        match module.parent_link {\n-            ParentLink::BlockParentLink(parent, _) |\n-            ParentLink::ModuleParentLink(parent, _) => self.is_ancestor_of(parent),\n-            _ => false,\n-        }\n-    }\n }\n \n impl<'a> fmt::Debug for ModuleS<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f,\n-               \"{:?}, {}\",\n-               self.def,\n-               if self.is_public {\n-                   \"public\"\n-               } else {\n-                   \"private\"\n-               })\n+        write!(f, \"{:?}, {:?}\", self.def, self.vis)\n     }\n }\n \n bitflags! {\n     #[derive(Debug)]\n     flags DefModifiers: u8 {\n-        // Enum variants are always considered `PUBLIC`, this is needed for `use Enum::Variant`\n-        // or `use Enum::*` to work on private enums.\n-        const PUBLIC     = 1 << 0,\n         const IMPORTABLE = 1 << 1,\n-        // Variants are considered `PUBLIC`, but some of them live in private enums.\n-        // We need to track them to prohibit reexports like `pub use PrivEnum::Variant`.\n-        const PRIVATE_VARIANT = 1 << 2,\n         const GLOB_IMPORTED = 1 << 3,\n     }\n }\n@@ -949,6 +929,7 @@ pub struct NameBinding<'a> {\n     modifiers: DefModifiers,\n     kind: NameBindingKind<'a>,\n     span: Option<Span>,\n+    vis: ty::Visibility,\n }\n \n #[derive(Clone, Debug)]\n@@ -968,13 +949,12 @@ struct PrivacyError<'a>(Span, Name, &'a NameBinding<'a>);\n \n impl<'a> NameBinding<'a> {\n     fn create_from_module(module: Module<'a>, span: Option<Span>) -> Self {\n-        let modifiers = if module.is_public {\n-            DefModifiers::PUBLIC\n-        } else {\n-            DefModifiers::empty()\n-        } | DefModifiers::IMPORTABLE;\n-\n-        NameBinding { modifiers: modifiers, kind: NameBindingKind::Module(module), span: span }\n+        NameBinding {\n+            modifiers: DefModifiers::IMPORTABLE,\n+            kind: NameBindingKind::Module(module),\n+            span: span,\n+            vis: module.vis,\n+        }\n     }\n \n     fn module(&self) -> Option<Module<'a>> {\n@@ -997,8 +977,20 @@ impl<'a> NameBinding<'a> {\n         self.modifiers.contains(modifiers)\n     }\n \n-    fn is_public(&self) -> bool {\n-        self.defined_with(DefModifiers::PUBLIC)\n+    fn is_pseudo_public(&self) -> bool {\n+        self.pseudo_vis() == ty::Visibility::Public\n+    }\n+\n+    // We sometimes need to treat variants as `pub` for backwards compatibility\n+    fn pseudo_vis(&self) -> ty::Visibility {\n+        if self.is_variant() { ty::Visibility::Public } else { self.vis }\n+    }\n+\n+    fn is_variant(&self) -> bool {\n+        match self.kind {\n+            NameBindingKind::Def(Def::Variant(..)) => true,\n+            _ => false,\n+        }\n     }\n \n     fn is_extern_crate(&self) -> bool {\n@@ -1148,8 +1140,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n            arenas: &'a ResolverArenas<'a>)\n            -> Resolver<'a, 'tcx> {\n         let root_def_id = ast_map.local_def_id(CRATE_NODE_ID);\n+        let vis = ty::Visibility::Public;\n         let graph_root =\n-            ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false, true, arenas);\n+            ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false, vis, arenas);\n         let graph_root = arenas.alloc_module(graph_root);\n \n         Resolver {\n@@ -1209,17 +1202,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                   parent_link: ParentLink<'a>,\n                   def: Option<Def>,\n                   external: bool,\n-                  is_public: bool) -> Module<'a> {\n-        self.arenas.alloc_module(ModuleS::new(parent_link, def, external, is_public, self.arenas))\n+                  vis: ty::Visibility) -> Module<'a> {\n+        self.arenas.alloc_module(ModuleS::new(parent_link, def, external, vis, self.arenas))\n     }\n \n     fn new_extern_crate_module(&self,\n                                parent_link: ParentLink<'a>,\n                                def: Def,\n-                               is_public: bool,\n+                               vis: ty::Visibility,\n                                local_node_id: NodeId)\n                                -> Module<'a> {\n-        let mut module = ModuleS::new(parent_link, Some(def), false, is_public, self.arenas);\n+        let mut module = ModuleS::new(parent_link, Some(def), false, vis, self.arenas);\n         module.extern_crate_id = Some(local_node_id);\n         self.arenas.modules.alloc(module)\n     }\n@@ -1335,7 +1328,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // Check to see whether there are type bindings, and, if\n                     // so, whether there is a module within.\n                     if let Some(module_def) = binding.module() {\n-                        self.check_privacy(search_module, name, binding, span);\n+                        self.check_privacy(name, binding, span);\n                         search_module = module_def;\n                     } else {\n                         let msg = format!(\"Not a module `{}`\", name);\n@@ -1466,7 +1459,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     /// Returns the nearest normal module parent of the given module.\n-    fn get_nearest_normal_module_parent(&mut self, module_: Module<'a>) -> Option<Module<'a>> {\n+    fn get_nearest_normal_module_parent(&self, module_: Module<'a>) -> Option<Module<'a>> {\n         let mut module_ = module_;\n         loop {\n             match module_.parent_link {\n@@ -1485,7 +1478,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// Returns the nearest normal module parent of the given module, or the\n     /// module itself if it is a normal module.\n-    fn get_nearest_normal_module_parent_or_self(&mut self, module_: Module<'a>) -> Module<'a> {\n+    fn get_nearest_normal_module_parent_or_self(&self, module_: Module<'a>) -> Module<'a> {\n         if module_.is_normal() {\n             return module_;\n         }\n@@ -1617,7 +1610,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn resolve_crate(&mut self, krate: &hir::Crate) {\n         debug!(\"(resolving crate) starting\");\n-\n+        self.current_module = self.graph_root;\n         intravisit::walk_crate(self, krate);\n     }\n \n@@ -1980,6 +1973,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 this.with_self_rib(Def::SelfTy(trait_id, Some((item_id, self_type.id))), |this| {\n                     this.with_current_self_type(self_type, |this| {\n                         for impl_item in impl_items {\n+                            this.resolve_visibility(&impl_item.vis);\n                             match impl_item.node {\n                                 hir::ImplItemKind::Const(..) => {\n                                     // If this is a trait impl, ensure the const\n@@ -2772,7 +2766,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let name = segments.last().unwrap().identifier.name;\n         let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n         result.success().map(|binding| {\n-            self.check_privacy(containing_module, name, binding, span);\n+            self.check_privacy(name, binding, span);\n             binding.def().unwrap()\n         }).ok_or(false)\n     }\n@@ -2822,7 +2816,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let name = segments.last().unwrap().identifier.name;\n         let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n         result.success().map(|binding| {\n-            self.check_privacy(containing_module, name, binding, span);\n+            self.check_privacy(name, binding, span);\n             binding.def().unwrap()\n         }).ok_or(false)\n     }\n@@ -3314,7 +3308,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // only if both the module is public and the entity is\n                         // declared as public (due to pruning, we don't explore\n                         // outside crate private modules => no need to check this)\n-                        if !in_module_is_extern || name_binding.is_public() {\n+                        if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                             lookup_results.push(path);\n                         }\n                     }\n@@ -3339,7 +3333,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         _ => bug!(),\n                     };\n \n-                    if !in_module_is_extern || name_binding.is_public() {\n+                    if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                         // add the module to the lookup\n                         let is_extern = in_module_is_extern || name_binding.is_extern_crate();\n                         worklist.push((module, path_segments, is_extern));\n@@ -3379,16 +3373,51 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    fn is_visible(&self, binding: &'a NameBinding<'a>, parent: Module<'a>) -> bool {\n-        binding.is_public() || parent.is_ancestor_of(self.current_module)\n+    fn resolve_visibility(&mut self, vis: &hir::Visibility) -> ty::Visibility {\n+        let (path, id) = match *vis {\n+            hir::Public => return ty::Visibility::Public,\n+            hir::Visibility::Crate => return ty::Visibility::Restricted(ast::CRATE_NODE_ID),\n+            hir::Visibility::Restricted { ref path, id } => (path, id),\n+            hir::Inherited => {\n+                let current_module =\n+                    self.get_nearest_normal_module_parent_or_self(self.current_module);\n+                let id = self.ast_map.as_local_node_id(current_module.def_id().unwrap()).unwrap();\n+                return ty::Visibility::Restricted(id);\n+            }\n+        };\n+\n+        let segments: Vec<_> = path.segments.iter().map(|seg| seg.identifier.name).collect();\n+        let vis = match self.resolve_module_path(&segments, DontUseLexicalScope, path.span) {\n+            Success(module) => {\n+                let def = module.def.unwrap();\n+                let path_resolution = PathResolution { base_def: def, depth: 0 };\n+                self.def_map.borrow_mut().insert(id, path_resolution);\n+                ty::Visibility::Restricted(self.ast_map.as_local_node_id(def.def_id()).unwrap())\n+            }\n+            Failed(Some((span, msg))) => {\n+                self.session.span_err(span, &format!(\"failed to resolve module path. {}\", msg));\n+                ty::Visibility::Public\n+            }\n+            _ => {\n+                self.session.span_err(path.span, \"unresolved module path\");\n+                ty::Visibility::Public\n+            }\n+        };\n+        if !self.is_accessible(vis) {\n+            let msg = format!(\"visibilities can only be restricted to ancestor modules\");\n+            self.session.span_err(path.span, &msg);\n+        }\n+        vis\n+    }\n+\n+    fn is_accessible(&self, vis: ty::Visibility) -> bool {\n+        let current_module = self.get_nearest_normal_module_parent_or_self(self.current_module);\n+        let node_id = self.ast_map.as_local_node_id(current_module.def_id().unwrap()).unwrap();\n+        vis.is_accessible_from(node_id, &self.ast_map)\n     }\n \n-    fn check_privacy(&mut self,\n-                     module: Module<'a>,\n-                     name: Name,\n-                     binding: &'a NameBinding<'a>,\n-                     span: Span) {\n-        if !self.is_visible(binding, module) {\n+    fn check_privacy(&mut self, name: Name, binding: &'a NameBinding<'a>, span: Span) {\n+        if !self.is_accessible(binding.vis) {\n             self.privacy_errors.push(PrivacyError(span, name, binding));\n         }\n     }"}, {"sha": "e712dbdcbf7af52a7d7597f29f12ece959d9f276", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -21,6 +21,7 @@ use UseLexicalScopeFlag::DontUseLexicalScope;\n use {names_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n \n+use rustc::ty;\n use rustc::lint;\n use rustc::hir::def::*;\n \n@@ -63,7 +64,7 @@ pub struct ImportDirective<'a> {\n     subclass: ImportDirectiveSubclass,\n     span: Span,\n     id: NodeId,\n-    is_public: bool, // see note in ImportResolutionPerNamespace about how to use this\n+    vis: ty::Visibility, // see note in ImportResolutionPerNamespace about how to use this\n     is_prelude: bool,\n }\n \n@@ -72,10 +73,7 @@ impl<'a> ImportDirective<'a> {\n     // this returns the binding for the name this directive defines in that namespace.\n     fn import(&self, binding: &'a NameBinding<'a>, privacy_error: Option<Box<PrivacyError<'a>>>)\n               -> NameBinding<'a> {\n-        let mut modifiers = match self.is_public {\n-            true => DefModifiers::PUBLIC | DefModifiers::IMPORTABLE,\n-            false => DefModifiers::empty(),\n-        };\n+        let mut modifiers = DefModifiers::IMPORTABLE;\n         if let GlobImport = self.subclass {\n             modifiers = modifiers | DefModifiers::GLOB_IMPORTED;\n         }\n@@ -88,6 +86,7 @@ impl<'a> ImportDirective<'a> {\n             },\n             span: Some(self.span),\n             modifiers: modifiers,\n+            vis: self.vis,\n         }\n     }\n }\n@@ -184,8 +183,8 @@ impl<'a> NameResolution<'a> {\n                 // If (1) we don't allow private imports, (2) no public single import can define\n                 // the name, and (3) no public glob has defined the name, the resolution depends\n                 // on whether more globs can define the name.\n-                if !allow_private_imports && !directive.is_public &&\n-                   !self.binding.map(NameBinding::is_public).unwrap_or(false) {\n+                if !allow_private_imports && directive.vis != ty::Visibility::Public &&\n+                   !self.binding.map(NameBinding::is_pseudo_public).unwrap_or(false) {\n                     return None;\n                 }\n \n@@ -243,14 +242,15 @@ impl<'a> ::ModuleS<'a> {\n         if let Some(result) = resolution.try_result(ns, allow_private_imports) {\n             // If the resolution doesn't depend on glob definability, check privacy and return.\n             return result.and_then(|binding| {\n-                let allowed = allow_private_imports || !binding.is_import() || binding.is_public();\n+                let allowed = allow_private_imports || !binding.is_import() ||\n+                                                       binding.is_pseudo_public();\n                 if allowed { Success(binding) } else { Failed(None) }\n             });\n         }\n \n         // Check if the globs are determined\n         for directive in self.globs.borrow().iter() {\n-            if !allow_private_imports && !directive.is_public { continue }\n+            if !allow_private_imports && directive.vis != ty::Visibility::Public { continue }\n             match directive.target_module.get() {\n                 None => return Indeterminate,\n                 Some(target_module) => match target_module.resolve_name(name, ns, false) {\n@@ -285,15 +285,15 @@ impl<'a> ::ModuleS<'a> {\n                                 subclass: ImportDirectiveSubclass,\n                                 span: Span,\n                                 id: NodeId,\n-                                is_public: bool,\n+                                vis: ty::Visibility,\n                                 is_prelude: bool) {\n         let directive = self.arenas.alloc_import_directive(ImportDirective {\n             module_path: module_path,\n             target_module: Cell::new(None),\n             subclass: subclass,\n             span: span,\n             id: id,\n-            is_public: is_public,\n+            vis: vis,\n             is_prelude: is_prelude,\n         });\n \n@@ -337,7 +337,7 @@ impl<'a> ::ModuleS<'a> {\n     }\n \n     fn define_in_glob_importers(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>) {\n-        if !binding.defined_with(DefModifiers::PUBLIC | DefModifiers::IMPORTABLE) { return }\n+        if !binding.defined_with(DefModifiers::IMPORTABLE) || !binding.is_pseudo_public() { return }\n         for &(importer, directive) in self.glob_importers.borrow_mut().iter() {\n             let _ = importer.try_define_child(name, ns, directive.import(binding, None));\n         }\n@@ -413,6 +413,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 modifiers: DefModifiers::GLOB_IMPORTED,\n                 kind: NameBindingKind::Def(Def::Err),\n                 span: None,\n+                vis: ty::Visibility::Public,\n             });\n             let dummy_binding = e.import_directive.import(dummy_binding, None);\n \n@@ -521,7 +522,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     span_err!(self.resolver.session, directive.span, E0253, \"{}\", &msg);\n                 }\n \n-                let privacy_error = if !self.resolver.is_visible(binding, target_module) {\n+                let privacy_error = if !self.resolver.is_accessible(binding.vis) {\n                     Some(Box::new(PrivacyError(directive.span, source, binding)))\n                 } else {\n                     None\n@@ -567,10 +568,10 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             _ => (),\n         }\n \n+        let ast_map = self.resolver.ast_map;\n         match (&value_result, &type_result) {\n-            (&Success(name_binding), _) if !name_binding.is_import() &&\n-                                           directive.is_public &&\n-                                           !name_binding.is_public() => {\n+            (&Success(binding), _) if !binding.pseudo_vis().is_at_least(directive.vis, ast_map) &&\n+                                      self.resolver.is_accessible(binding.vis) => {\n                 let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                 let note_msg = format!(\"consider marking `{}` as `pub` in the imported module\",\n                                         source);\n@@ -579,10 +580,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     .emit();\n             }\n \n-            (_, &Success(name_binding)) if !name_binding.is_import() &&\n-                                           directive.is_public &&\n-                                           !name_binding.is_public() => {\n-                if name_binding.is_extern_crate() {\n+            (_, &Success(binding)) if !binding.pseudo_vis().is_at_least(directive.vis, ast_map) &&\n+                                      self.resolver.is_accessible(binding.vis) => {\n+                if binding.is_extern_crate() {\n                     let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring with `pub`\",\n                                        source);\n@@ -662,7 +662,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             resolution.borrow().binding().map(|binding| (*name, binding))\n         }).collect::<Vec<_>>();\n         for ((name, ns), binding) in bindings {\n-            if binding.defined_with(DefModifiers::IMPORTABLE | DefModifiers::PUBLIC) {\n+            if binding.defined_with(DefModifiers::IMPORTABLE) && binding.is_pseudo_public() {\n                 let _ = module_.try_define_child(name, ns, directive.import(binding, None));\n             }\n         }\n@@ -698,15 +698,16 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 None => continue,\n             };\n \n-            if binding.is_public() && (binding.is_import() || binding.is_extern_crate()) {\n+            if binding.vis == ty::Visibility::Public &&\n+               (binding.is_import() || binding.is_extern_crate()) {\n                 if let Some(def) = binding.def() {\n                     reexports.push(Export { name: name, def_id: def.def_id() });\n                 }\n             }\n \n             if let NameBindingKind::Import { binding: orig_binding, id, .. } = binding.kind {\n-                if ns == TypeNS && binding.is_public() &&\n-                   orig_binding.defined_with(DefModifiers::PRIVATE_VARIANT) {\n+                if ns == TypeNS && orig_binding.is_variant() &&\n+                   !orig_binding.vis.is_at_least(binding.vis, &self.resolver.ast_map) {\n                     let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring its enum as `pub`\",\n                                       name);"}, {"sha": "1e9796c5f66f993cd0ee8aae0672f443bb18ad8b", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -122,7 +122,7 @@ fn try_inline_def(cx: &DocContext, tcx: &TyCtxt,\n         name: Some(tcx.item_name(did).to_string()),\n         attrs: load_attrs(cx, tcx, did),\n         inner: inner,\n-        visibility: Some(hir::Public),\n+        visibility: Some(clean::Public),\n         stability: stability::lookup_stability(tcx, did).clean(cx),\n         deprecation: stability::lookup_deprecation(tcx, did).clean(cx),\n         def_id: did,\n@@ -323,7 +323,7 @@ pub fn build_impl(cx: &DocContext,\n             source: clean::Span::empty(),\n             name: None,\n             attrs: attrs,\n-            visibility: Some(hir::Inherited),\n+            visibility: Some(clean::Inherited),\n             stability: stability::lookup_stability(tcx, did).clean(cx),\n             deprecation: stability::lookup_deprecation(tcx, did).clean(cx),\n             def_id: did,\n@@ -444,7 +444,7 @@ pub fn build_impl(cx: &DocContext,\n         source: clean::Span::empty(),\n         name: None,\n         attrs: attrs,\n-        visibility: Some(hir::Inherited),\n+        visibility: Some(clean::Inherited),\n         stability: stability::lookup_stability(tcx, did).clean(cx),\n         deprecation: stability::lookup_deprecation(tcx, did).clean(cx),\n         def_id: did,"}, {"sha": "42db93e180344a8bb1b7224e2f0d86bf8af14c49", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -22,6 +22,7 @@ pub use self::Attribute::*;\n pub use self::TyParamBound::*;\n pub use self::SelfTy::*;\n pub use self::FunctionRetTy::*;\n+pub use self::Visibility::*;\n \n use syntax;\n use syntax::abi::Abi;\n@@ -183,7 +184,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n                     source: Span::empty(),\n                     name: Some(prim.to_url_str().to_string()),\n                     attrs: child.attrs.clone(),\n-                    visibility: Some(hir::Public),\n+                    visibility: Some(Public),\n                     stability: None,\n                     deprecation: None,\n                     def_id: DefId::local(prim.to_def_index()),\n@@ -1391,7 +1392,7 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n \n         Item {\n             name: Some(self.name.clean(cx)),\n-            visibility: Some(hir::Inherited),\n+            visibility: Some(Inherited),\n             stability: get_stability(cx, self.def_id),\n             deprecation: get_deprecation(cx, self.def_id),\n             def_id: self.def_id,\n@@ -1777,17 +1778,21 @@ impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n     }\n }\n \n-pub type Visibility = hir::Visibility;\n+#[derive(Clone, PartialEq, Eq, RustcDecodable, RustcEncodable, Debug)]\n+pub enum Visibility {\n+    Public,\n+    Inherited,\n+}\n \n impl Clean<Option<Visibility>> for hir::Visibility {\n     fn clean(&self, _: &DocContext) -> Option<Visibility> {\n-        Some(self.clone())\n+        Some(if *self == hir::Visibility::Public { Public } else { Inherited })\n     }\n }\n \n impl Clean<Option<Visibility>> for ty::Visibility {\n     fn clean(&self, _: &DocContext) -> Option<Visibility> {\n-        Some(if *self == ty::Visibility::Public { hir::Public } else { hir::Inherited })\n+        Some(if *self == ty::Visibility::Public { Public } else { Inherited })\n     }\n }\n \n@@ -1919,7 +1924,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n             name: Some(self.name.clean(cx)),\n             attrs: inline::load_attrs(cx, cx.tcx(), self.did),\n             source: Span::empty(),\n-            visibility: Some(hir::Inherited),\n+            visibility: Some(Inherited),\n             def_id: self.did,\n             inner: VariantItem(Variant { kind: kind }),\n             stability: get_stability(cx, self.did),\n@@ -2341,7 +2346,7 @@ impl Clean<Item> for doctree::DefaultImpl {\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n             def_id: cx.map.local_def_id(self.id),\n-            visibility: Some(hir::Public),\n+            visibility: Some(Public),\n             stability: None,\n             deprecation: None,\n             inner: DefaultImplItem(DefaultImpl {\n@@ -2700,7 +2705,7 @@ impl Clean<Item> for doctree::Macro {\n             name: Some(name.clone()),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            visibility: hir::Public.clean(cx),\n+            visibility: Some(Public),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n             def_id: cx.map.local_def_id(self.id),"}, {"sha": "d2b43ae5bda1539a966d8e6b128286b38b42eae7", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -31,7 +31,7 @@ use html::render::{cache, CURRENT_LOCATION_KEY};\n /// Helper to render an optional visibility with a space after it (if the\n /// visibility is preset)\n #[derive(Copy, Clone)]\n-pub struct VisSpace<'a>(pub &'a Option<hir::Visibility>);\n+pub struct VisSpace<'a>(pub &'a Option<clean::Visibility>);\n /// Similarly to VisSpace, this structure is used to render a function style with a\n /// space after it.\n #[derive(Copy, Clone)]\n@@ -57,7 +57,7 @@ pub struct CommaSep<'a, T: 'a>(pub &'a [T]);\n pub struct AbiSpace(pub Abi);\n \n impl<'a> VisSpace<'a> {\n-    pub fn get(self) -> &'a Option<hir::Visibility> {\n+    pub fn get(self) -> &'a Option<clean::Visibility> {\n         let VisSpace(v) = self; v\n     }\n }\n@@ -639,8 +639,8 @@ impl<'a> fmt::Display for Method<'a> {\n impl<'a> fmt::Display for VisSpace<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self.get() {\n-            Some(hir::Public) => write!(f, \"pub \"),\n-            Some(hir::Inherited) | None => Ok(())\n+            Some(clean::Public) => write!(f, \"pub \"),\n+            Some(clean::Inherited) | None => Ok(())\n         }\n     }\n }"}, {"sha": "864e10407d5ca780828e34b5fdcd9dc1aa3a5256", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -1408,7 +1408,8 @@ impl Context {\n         match it.inner {\n             clean::StrippedItem(..) => true,\n             clean::ModuleItem(ref m) => {\n-                it.doc_value().is_none() && m.items.is_empty() && it.visibility != Some(hir::Public)\n+                it.doc_value().is_none() && m.items.is_empty()\n+                                         && it.visibility != Some(clean::Public)\n             },\n             _ => false,\n         }"}, {"sha": "0042afb1fd5147695274e7151c2c9265a5ff6587", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -14,7 +14,6 @@ use rustc::util::nodemap::DefIdSet;\n use std::cmp;\n use std::string::String;\n use std::usize;\n-use rustc::hir;\n \n use clean::{self, Attributes, GetDefId};\n use clean::Item;\n@@ -133,13 +132,13 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             }\n \n             clean::StructFieldItem(..) => {\n-                if i.visibility != Some(hir::Public) {\n+                if i.visibility != Some(clean::Public) {\n                     return Strip(i).fold();\n                 }\n             }\n \n             clean::ModuleItem(..) => {\n-                if i.def_id.is_local() && i.visibility != Some(hir::Public) {\n+                if i.def_id.is_local() && i.visibility != Some(clean::Public) {\n                     return Strip(self.fold_item_recur(i).unwrap()).fold()\n                 }\n             }\n@@ -226,7 +225,7 @@ impl fold::DocFolder for ImportStripper {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match i.inner {\n             clean::ExternCrateItem(..) |\n-            clean::ImportItem(..) if i.visibility != Some(hir::Public) => None,\n+            clean::ImportItem(..) if i.visibility != Some(clean::Public) => None,\n             _ => self.fold_item_recur(i)\n         }\n     }"}, {"sha": "df9f935446d71a4dde4293b7023a513dc4f0dc01", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -1887,7 +1887,7 @@ pub struct PolyTraitRef {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Visibility {\n     Public,\n-    Crate,\n+    Crate(Span),\n     Restricted { path: P<Path>, id: NodeId },\n     Inherited,\n }"}, {"sha": "d8352430eb94ed3281fa1b03fa8f8e6018156fe7", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -256,6 +256,9 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n \n     // impl specialization (RFC 1210)\n     (\"specialization\", \"1.7.0\", Some(31844), Active),\n+\n+    // pub(restricted) visibilities (RFC 1422)\n+    (\"pub_restricted\", \"1.9.0\", Some(32409), Active),\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -608,6 +611,7 @@ pub struct Features {\n     pub deprecated: bool,\n     pub question_mark: bool,\n     pub specialization: bool,\n+    pub pub_restricted: bool,\n }\n \n impl Features {\n@@ -644,6 +648,7 @@ impl Features {\n             deprecated: false,\n             question_mark: false,\n             specialization: false,\n+            pub_restricted: false,\n         }\n     }\n }\n@@ -1159,6 +1164,15 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         }\n         visit::walk_impl_item(self, ii);\n     }\n+\n+    fn visit_vis(&mut self, vis: &'v ast::Visibility) {\n+        let span = match *vis {\n+            ast::Visibility::Crate(span) => span,\n+            ast::Visibility::Restricted { ref path, .. } => path.span,\n+            _ => return,\n+        };\n+        self.gate_feature(\"pub_restricted\", span, \"`pub(restricted)` syntax is experimental\");\n+    }\n }\n \n fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n@@ -1256,6 +1270,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n         deprecated: cx.has_feature(\"deprecated\"),\n         question_mark: cx.has_feature(\"question_mark\"),\n         specialization: cx.has_feature(\"specialization\"),\n+        pub_restricted: cx.has_feature(\"pub_restricted\"),\n     }\n }\n "}, {"sha": "89451e795503f0c272b562f74af7201d95deca0f", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -850,7 +850,7 @@ pub fn noop_fold_struct_field<T: Folder>(f: StructField, fld: &mut T) -> StructF\n         span: fld.new_span(f.span),\n         id: fld.new_id(f.id),\n         ident: f.ident.map(|ident| fld.fold_ident(ident)),\n-        vis: f.vis,\n+        vis: fld.fold_vis(f.vis),\n         ty: fld.fold_ty(f.ty),\n         attrs: fold_attrs(f.attrs, fld),\n     }"}, {"sha": "05cd53a8a8eb5bde339d3503e32f9d3785eb976e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -70,6 +70,7 @@ bitflags! {\n         const RESTRICTION_STMT_EXPR         = 1 << 0,\n         const RESTRICTION_NO_STRUCT_LITERAL = 1 << 1,\n         const NO_NONINLINE_MOD  = 1 << 2,\n+        const ALLOW_MODULE_PATHS = 1 << 3,\n     }\n }\n \n@@ -560,7 +561,9 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_ident(&mut self) -> PResult<'a, ast::Ident> {\n-        self.check_strict_keywords();\n+        if !self.restrictions.contains(Restrictions::ALLOW_MODULE_PATHS) {\n+            self.check_strict_keywords();\n+        }\n         self.check_reserved_keywords();\n         match self.token {\n             token::Ident(i, _) => {\n@@ -4937,7 +4940,7 @@ impl<'a> Parser<'a> {\n \n         let mut attrs = self.parse_outer_attributes()?;\n         let lo = self.span.lo;\n-        let vis = self.parse_visibility()?;\n+        let vis = self.parse_visibility(true)?;\n         let defaultness = self.parse_defaultness()?;\n         let (name, node) = if self.eat_keyword(keywords::Type) {\n             let name = self.parse_ident()?;\n@@ -5249,7 +5252,7 @@ impl<'a> Parser<'a> {\n             |p| {\n                 let attrs = p.parse_outer_attributes()?;\n                 let lo = p.span.lo;\n-                let vis = p.parse_visibility()?;\n+                let vis = p.parse_visibility(false)?;\n                 let ty = p.parse_ty_sum()?;\n                 Ok(StructField {\n                     span: mk_sp(lo, p.span.hi),\n@@ -5289,20 +5292,26 @@ impl<'a> Parser<'a> {\n \n     /// Parse an element of a struct definition\n     fn parse_struct_decl_field(&mut self) -> PResult<'a, StructField> {\n-\n         let attrs = self.parse_outer_attributes()?;\n-\n-        if self.eat_keyword(keywords::Pub) {\n-            return self.parse_single_struct_field(Visibility::Public, attrs);\n-        }\n-\n-        return self.parse_single_struct_field(Visibility::Inherited, attrs);\n+        let vis = self.parse_visibility(true)?;\n+        self.parse_single_struct_field(vis, attrs)\n     }\n \n-    /// Parse visibility: PUB or nothing\n-    fn parse_visibility(&mut self) -> PResult<'a, Visibility> {\n-        if self.eat_keyword(keywords::Pub) { Ok(Visibility::Public) }\n-        else { Ok(Visibility::Inherited) }\n+    fn parse_visibility(&mut self, allow_restricted: bool) -> PResult<'a, Visibility> {\n+        if !self.eat_keyword(keywords::Pub) {\n+            Ok(Visibility::Inherited)\n+        } else if !allow_restricted || !self.eat(&token::OpenDelim(token::Paren)) {\n+            Ok(Visibility::Public)\n+        } else if self.eat_keyword(keywords::Crate) {\n+            let span = self.last_span;\n+            self.expect(&token::CloseDelim(token::Paren))?;\n+            Ok(Visibility::Crate(span))\n+        } else {\n+            let path = self.with_res(Restrictions::ALLOW_MODULE_PATHS,\n+                                     |this| this.parse_path(NoTypesAllowed))?;\n+            self.expect(&token::CloseDelim(token::Paren))?;\n+            Ok(Visibility::Restricted { path: P(path), id: ast::DUMMY_NODE_ID })\n+        }\n     }\n \n     /// Parse defaultness: DEFAULT or nothing\n@@ -5764,7 +5773,7 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n \n-        let visibility = self.parse_visibility()?;\n+        let visibility = self.parse_visibility(true)?;\n \n         if self.eat_keyword(keywords::Use) {\n             // USE ITEM\n@@ -6014,7 +6023,7 @@ impl<'a> Parser<'a> {\n     fn parse_foreign_item(&mut self) -> PResult<'a, Option<ForeignItem>> {\n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.span.lo;\n-        let visibility = self.parse_visibility()?;\n+        let visibility = self.parse_visibility(true)?;\n \n         if self.check_keyword(keywords::Static) {\n             // FOREIGN STATIC ITEM"}, {"sha": "95f1b63168b479f7db4b4249def9158810e7e04d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -435,7 +435,7 @@ pub fn mac_to_string(arg: &ast::Mac) -> String {\n pub fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n     match *vis {\n         ast::Visibility::Public => format!(\"pub {}\", s),\n-        ast::Visibility::Crate => format!(\"pub(crate) {}\", s),\n+        ast::Visibility::Crate(_) => format!(\"pub(crate) {}\", s),\n         ast::Visibility::Restricted { ref path, .. } => format!(\"pub({}) {}\", path, s),\n         ast::Visibility::Inherited => s.to_string()\n     }\n@@ -1386,7 +1386,7 @@ impl<'a> State<'a> {\n     pub fn print_visibility(&mut self, vis: &ast::Visibility) -> io::Result<()> {\n         match *vis {\n             ast::Visibility::Public => self.word_nbsp(\"pub\"),\n-            ast::Visibility::Crate => self.word_nbsp(\"pub(crate)\"),\n+            ast::Visibility::Crate(_) => self.word_nbsp(\"pub(crate)\"),\n             ast::Visibility::Restricted { ref path, .. } =>\n                 self.word_nbsp(&format!(\"pub({})\", path)),\n             ast::Visibility::Inherited => Ok(())"}, {"sha": "413017c727177351559122a67881fa161695c2ee", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -231,6 +231,7 @@ pub fn walk_trait_ref<'v,V>(visitor: &mut V,\n }\n \n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n+    visitor.visit_vis(&item.vis);\n     visitor.visit_ident(item.span, item.ident);\n     match item.node {\n         ItemKind::ExternCrate(opt_name) => {\n@@ -470,6 +471,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n \n pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              foreign_item: &'v ForeignItem) {\n+    visitor.visit_vis(&foreign_item.vis);\n     visitor.visit_ident(foreign_item.span, foreign_item.ident);\n \n     match foreign_item.node {\n@@ -592,6 +594,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n }\n \n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n+    visitor.visit_vis(&impl_item.vis);\n     visitor.visit_ident(impl_item.span, impl_item.ident);\n     walk_list!(visitor, visit_attribute, &impl_item.attrs);\n     match impl_item.node {\n@@ -619,6 +622,7 @@ pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              struct_field: &'v StructField) {\n+    visitor.visit_vis(&struct_field.vis);\n     walk_opt_ident(visitor, struct_field.span, struct_field.ident);\n     visitor.visit_ty(&struct_field.ty);\n     walk_list!(visitor, visit_attribute, &struct_field.attrs);\n@@ -812,8 +816,7 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n }\n \n pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility) {\n-    match *vis {\n-        Visibility::Restricted { ref path, id } => visitor.visit_path(path, id),\n-        _ => {}\n+    if let Visibility::Restricted { ref path, id } = *vis {\n+        visitor.visit_path(path, id);\n     }\n }"}, {"sha": "b1c88ce6ce55c796d731e41b910353d7b3bbf2fa", "filename": "src/test/auxiliary/pub_restricted.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Ftest%2Fauxiliary%2Fpub_restricted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Ftest%2Fauxiliary%2Fpub_restricted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fpub_restricted.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(pub_restricted)]\n+\n+pub(crate) struct Crate;\n+#[derive(Default)]\n+pub struct Universe {\n+    pub x: i32,\n+    pub(crate) y: i32\n+}\n+\n+impl Universe {\n+    pub fn f(&self) {}\n+    pub(crate) fn g(&self) {}\n+}"}, {"sha": "53ae439867f9883726f8b68e8482affadcd1d139", "filename": "src/test/compile-fail/privacy/restricted/feature-gate.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ffeature-gate.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub(crate) //~ ERROR experimental\n+mod foo {}\n+\n+pub(self) //~ ERROR experimental\n+mod bar {}\n+\n+struct S {\n+    pub(self) x: i32, //~ ERROR experimental\n+}\n+impl S {\n+    pub(self) fn f() {} //~ ERROR experimental\n+}\n+extern {\n+    pub(self) fn f(); //~ ERROR experimental\n+}"}, {"sha": "4e2a69cb79e1945aa9e9a6fe076aace0c8140866", "filename": "src/test/compile-fail/privacy/restricted/lookup-ignores-private.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Flookup-ignores-private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Flookup-ignores-private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Flookup-ignores-private.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs, pub_restricted)]\n+#![allow(warnings)]\n+\n+mod foo {\n+    pub use foo::bar::S;\n+    mod bar {\n+        #[derive(Default)]\n+        pub struct S {\n+            pub(foo) x: i32,\n+        }\n+        impl S {\n+            pub(foo) fn f(&self) -> i32 { 0 }\n+        }\n+\n+        pub struct S2 {\n+            pub(crate) x: bool,\n+        }\n+        impl S2 {\n+            pub(crate) fn f(&self) -> bool { false }\n+        }\n+\n+        impl ::std::ops::Deref for S {\n+            type Target = S2;\n+            fn deref(&self) -> &S2 { unimplemented!() }\n+        }\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { //~ ERROR compilation successful\n+    let s = foo::S::default();\n+    let _: bool = s.x;\n+    let _: bool = s.f();\n+}"}, {"sha": "f8e7e6283a0afe26a7c19cd52fdaffe1c0272c02", "filename": "src/test/compile-fail/privacy/restricted/private-in-public.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Fprivate-in-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Fprivate-in-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Fprivate-in-public.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(pub_restricted)]\n+\n+mod foo {\n+    struct Priv;\n+    mod bar {\n+        use foo::Priv;\n+        pub(super) fn f(_: Priv) {}\n+        pub(crate) fn f(_: Priv) {} //~ ERROR private\n+    }\n+}"}, {"sha": "e254e005656c10267149a8cadc2be0bed39a69af", "filename": "src/test/compile-fail/privacy/restricted/struct-literal-field.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Fstruct-literal-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Fstruct-literal-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Fstruct-literal-field.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(pub_restricted)]\n+#![deny(private_in_public)]\n+#![allow(warnings)]\n+\n+mod foo {\n+    pub mod bar {\n+        pub struct S {\n+            pub(foo) x: i32,\n+        }\n+    }\n+\n+    fn f() {\n+        use foo::bar::S;\n+        S { x: 0 }; // ok\n+    }\n+}\n+\n+fn main() {\n+    use foo::bar::S;\n+    S { x: 0 }; //~ ERROR private\n+}"}, {"sha": "3e1bb7666229c60fbedea94abd1b0b7f5f2eb04c", "filename": "src/test/compile-fail/privacy/restricted/test.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftest.rs?ref=ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:pub_restricted.rs\n+\n+#![feature(pub_restricted)]\n+#![deny(private_in_public)]\n+#![allow(warnings)]\n+extern crate pub_restricted;\n+\n+mod foo {\n+    pub mod bar {\n+        pub(super) fn f() {}\n+        #[derive(Default)]\n+        pub struct S {\n+            pub(super) x: i32,\n+        }\n+        impl S {\n+            pub(super) fn f(&self) {}\n+            pub(super) fn g() {}\n+        }\n+    }\n+    fn f() {\n+        use foo::bar::S;\n+        pub(self) use foo::bar::f; // ok\n+        pub(super) use foo::bar::f as g; //~ ERROR cannot be reexported\n+        S::default().x; // ok\n+        S::default().f(); // ok\n+        S::g(); // ok\n+    }\n+}\n+\n+fn f() {\n+    use foo::bar::S;\n+    use foo::bar::f; //~ ERROR private\n+    S::default().x; //~ ERROR private\n+    S::default().f(); //~ ERROR private\n+    S::g(); //~ ERROR private\n+}\n+\n+fn main() {\n+    use pub_restricted::Universe;\n+    use pub_restricted::Crate; //~ ERROR private\n+\n+    let u = Universe::default();\n+    let _ = u.x;\n+    let _ = u.y; //~ ERROR private\n+    u.f();\n+    u.g(); //~ ERROR private\n+}\n+\n+mod pathological {\n+    pub(bad::path) mod m1 {} //~ ERROR failed to resolve module path\n+    pub(foo) mod m2 {} //~ ERROR visibilities can only be restricted to ancestor modules\n+}"}]}