{"sha": "3854a76aced92072455a9a189ab9d2a20ae00099", "node_id": "C_kwDOAAsO6NoAKDM4NTRhNzZhY2VkOTIwNzI0NTVhOWExODlhYjlkMmEyMGFlMDAwOTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-05T22:47:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-05T22:47:51Z"}, "message": "Auto merge of #1970 - asquared31415:open_unix_varargs, r=RalfJung\n\nAllow varargs for libc::open when it is allowed by the second argument\n\nThis PR allows `libc::open` to be called using two or three arguments as defined in https://man7.org/linux/man-pages/man2/open.2.html\n\nThe presence of the third argument depends on the value of the second argument.  If the second argument dictates that the third argument is *required* miri will emit an error if the argument is missing.  If the second argument does *not* require a third argument, then the argument is ignored and passed as 0 internally (it would be ignored by libc anyway)", "tree": {"sha": "702f069197aa40d333122c800aef0c621185b945", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/702f069197aa40d333122c800aef0c621185b945"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3854a76aced92072455a9a189ab9d2a20ae00099", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3854a76aced92072455a9a189ab9d2a20ae00099", "html_url": "https://github.com/rust-lang/rust/commit/3854a76aced92072455a9a189ab9d2a20ae00099", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3854a76aced92072455a9a189ab9d2a20ae00099/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c1b9ce3480b007696716f356a8fe87d3575055c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c1b9ce3480b007696716f356a8fe87d3575055c", "html_url": "https://github.com/rust-lang/rust/commit/2c1b9ce3480b007696716f356a8fe87d3575055c"}, {"sha": "8e97599af47ba3a1e4ed2185b8d0dddd9c69f0dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e97599af47ba3a1e4ed2185b8d0dddd9c69f0dd", "html_url": "https://github.com/rust-lang/rust/commit/8e97599af47ba3a1e4ed2185b8d0dddd9c69f0dd"}], "stats": {"total": 147, "additions": 117, "deletions": 30}, "files": [{"sha": "02fb7089c34db5d1750c4765037fe6a9770eff63", "filename": "src/shims/posix/foreign_items.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3854a76aced92072455a9a189ab9d2a20ae00099/src%2Fshims%2Fposix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3854a76aced92072455a9a189ab9d2a20ae00099/src%2Fshims%2Fposix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fforeign_items.rs?ref=3854a76aced92072455a9a189ab9d2a20ae00099", "patch": "@@ -55,8 +55,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // File related shims\n             \"open\" | \"open64\" => {\n-                let &[ref path, ref flag, ref mode] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let result = this.open(path, flag, mode)?;\n+                // `open` is variadic, the third argument is only present when the second argument has O_CREAT (or on linux O_TMPFILE, but miri doesn't support that) set\n+                this.check_abi_and_shim_symbol_clash(abi, Abi::C { unwind: false }, link_name)?;\n+                let result = this.open(args)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fcntl\" => {"}, {"sha": "7956cfe4dcef3b5b58e7b89a67dfa688b6666cb9", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3854a76aced92072455a9a189ab9d2a20ae00099/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3854a76aced92072455a9a189ab9d2a20ae00099/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=3854a76aced92072455a9a189ab9d2a20ae00099", "patch": "@@ -474,23 +474,18 @@ fn maybe_sync_file(\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    fn open(\n-        &mut self,\n-        path_op: &OpTy<'tcx, Tag>,\n-        flag_op: &OpTy<'tcx, Tag>,\n-        mode_op: &OpTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, i32> {\n-        let this = self.eval_context_mut();\n+    fn open(&mut self, args: &[OpTy<'tcx, Tag>]) -> InterpResult<'tcx, i32> {\n+        if args.len() < 2 || args.len() > 3 {\n+            throw_ub_format!(\n+                \"incorrect number of arguments for `open`: got {}, expected 2 or 3\",\n+                args.len()\n+            );\n+        }\n \n-        let flag = this.read_scalar(flag_op)?.to_i32()?;\n+        let this = self.eval_context_mut();\n \n-        // Get the mode.  On macOS, the argument type `mode_t` is actually `u16`, but\n-        // C integer promotion rules mean that on the ABI level, it gets passed as `u32`\n-        // (see https://github.com/rust-lang/rust/issues/71915).\n-        let mode = this.read_scalar(mode_op)?.to_u32()?;\n-        if mode != 0o666 {\n-            throw_unsup_format!(\"non-default mode 0o{:o} is not supported\", mode);\n-        }\n+        let path_op = &args[0];\n+        let flag = this.read_scalar(&args[1])?.to_i32()?;\n \n         let mut options = OpenOptions::new();\n \n@@ -535,6 +530,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         let o_creat = this.eval_libc_i32(\"O_CREAT\")?;\n         if flag & o_creat != 0 {\n+            // Get the mode.  On macOS, the argument type `mode_t` is actually `u16`, but\n+            // C integer promotion rules mean that on the ABI level, it gets passed as `u32`\n+            // (see https://github.com/rust-lang/rust/issues/71915).\n+            let mode = if let Some(arg) = args.get(2) {\n+                this.read_scalar(arg)?.to_u32()?\n+            } else {\n+                throw_ub_format!(\n+                    \"incorrect number of arguments for `open` with `O_CREAT`: got {}, expected 3\",\n+                    args.len()\n+                );\n+            };\n+\n+            if mode != 0o666 {\n+                throw_unsup_format!(\"non-default mode 0o{:o} is not supported\", mode);\n+            }\n+\n             mirror |= o_creat;\n \n             let o_excl = this.eval_libc_i32(\"O_EXCL\")?;"}, {"sha": "2bac72912544a6ac4d51353dad01ba13e2ce2a95", "filename": "tests/compile-fail/fs/unix_open_missing_required_mode.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3854a76aced92072455a9a189ab9d2a20ae00099/tests%2Fcompile-fail%2Ffs%2Funix_open_missing_required_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3854a76aced92072455a9a189ab9d2a20ae00099/tests%2Fcompile-fail%2Ffs%2Funix_open_missing_required_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffs%2Funix_open_missing_required_mode.rs?ref=3854a76aced92072455a9a189ab9d2a20ae00099", "patch": "@@ -0,0 +1,16 @@\n+// ignore-windows: No libc on Windows\n+// compile-flags: -Zmiri-disable-isolation\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() {\n+    test_file_open_missing_needed_mode();\n+}\n+\n+fn test_file_open_missing_needed_mode() {\n+    let name = b\"missing_arg.txt\\0\";\n+    let name_ptr = name.as_ptr().cast::<libc::c_char>();\n+    let _fd = unsafe { libc::open(name_ptr, libc::O_CREAT) }; //~ ERROR Undefined Behavior: incorrect number of arguments for `open` with `O_CREAT`: got 2, expected 3\n+}"}, {"sha": "9df7415d3133a9fe94e3efbe96d86017ca308bb0", "filename": "tests/compile-fail/fs/unix_open_too_many_args.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3854a76aced92072455a9a189ab9d2a20ae00099/tests%2Fcompile-fail%2Ffs%2Funix_open_too_many_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3854a76aced92072455a9a189ab9d2a20ae00099/tests%2Fcompile-fail%2Ffs%2Funix_open_too_many_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffs%2Funix_open_too_many_args.rs?ref=3854a76aced92072455a9a189ab9d2a20ae00099", "patch": "@@ -0,0 +1,16 @@\n+// ignore-windows: No libc on Windows\n+// compile-flags: -Zmiri-disable-isolation\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() {\n+    test_open_too_many_args();\n+}\n+\n+fn test_open_too_many_args() {\n+    let name = b\"too_many_args.txt\\0\";\n+    let name_ptr = name.as_ptr().cast::<libc::c_char>();\n+    let _fd = unsafe { libc::open(name_ptr, libc::O_RDONLY, 0, 0) }; //~ ERROR Undefined Behavior: incorrect number of arguments for `open`: got 4, expected 2 or 3\n+}"}, {"sha": "9ab1d4c033839a068331738bb11055716f3372c8", "filename": "tests/run-pass/fs.rs", "status": "modified", "additions": 56, "deletions": 13, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3854a76aced92072455a9a189ab9d2a20ae00099/tests%2Frun-pass%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3854a76aced92072455a9a189ab9d2a20ae00099/tests%2Frun-pass%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffs.rs?ref=3854a76aced92072455a9a189ab9d2a20ae00099", "patch": "@@ -5,13 +5,10 @@\n \n extern crate libc;\n \n-use std::fs::{\n-    File, create_dir, OpenOptions, remove_dir, remove_dir_all, remove_file, rename,\n-};\n use std::ffi::CString;\n-use std::io::{Read, Write, Error, ErrorKind, Result, Seek, SeekFrom};\n-use std::path::{PathBuf, Path};\n-\n+use std::fs::{create_dir, remove_dir, remove_dir_all, remove_file, rename, File, OpenOptions};\n+use std::io::{Error, ErrorKind, Read, Result, Seek, SeekFrom, Write};\n+use std::path::{Path, PathBuf};\n \n fn main() {\n     test_file();\n@@ -26,6 +23,11 @@ fn main() {\n     test_rename();\n     test_directory();\n     test_dup_stdout_stderr();\n+\n+    // These all require unix, if the test is changed to no longer `ignore-windows`, move these to a unix test\n+    test_file_open_unix_allow_two_args();\n+    test_file_open_unix_needs_three_args();\n+    test_file_open_unix_extra_third_arg();\n }\n \n fn tmp() -> PathBuf {\n@@ -41,7 +43,8 @@ fn tmp() -> PathBuf {\n \n             #[cfg(not(windows))]\n             return PathBuf::from(tmp.replace(\"\\\\\", \"/\"));\n-        }).unwrap_or_else(|_| std::env::temp_dir())\n+        })\n+        .unwrap_or_else(|_| std::env::temp_dir())\n }\n \n /// Prepare: compute filename and make sure the file does not exist.\n@@ -93,6 +96,39 @@ fn test_file() {\n     remove_file(&path).unwrap();\n }\n \n+fn test_file_open_unix_allow_two_args() {\n+    use std::os::unix::ffi::OsStrExt;\n+\n+    let path = prepare_with_content(\"test_file_open_unix_allow_two_args.txt\", &[]);\n+\n+    let mut name = path.into_os_string();\n+    name.push(\"\\0\");\n+    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n+    let _fd = unsafe { libc::open(name_ptr, libc::O_RDONLY) };\n+}\n+\n+fn test_file_open_unix_needs_three_args() {\n+    use std::os::unix::ffi::OsStrExt;\n+\n+    let path = prepare_with_content(\"test_file_open_unix_needs_three_args.txt\", &[]);\n+\n+    let mut name = path.into_os_string();\n+    name.push(\"\\0\");\n+    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n+    let _fd = unsafe { libc::open(name_ptr, libc::O_CREAT, 0o666) };\n+}\n+\n+fn test_file_open_unix_extra_third_arg() {\n+    use std::os::unix::ffi::OsStrExt;\n+\n+    let path = prepare_with_content(\"test_file_open_unix_extra_third_arg.txt\", &[]);\n+\n+    let mut name = path.into_os_string();\n+    name.push(\"\\0\");\n+    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n+    let _fd = unsafe { libc::open(name_ptr, libc::O_RDONLY, 42) };\n+}\n+\n fn test_file_clone() {\n     let bytes = b\"Hello, World!\\n\";\n     let path = prepare_with_content(\"miri_test_fs_file_clone.txt\", bytes);\n@@ -115,7 +151,10 @@ fn test_file_create_new() {\n     // Creating a new file that doesn't yet exist should succeed.\n     OpenOptions::new().write(true).create_new(true).open(&path).unwrap();\n     // Creating a new file that already exists should fail.\n-    assert_eq!(ErrorKind::AlreadyExists, OpenOptions::new().write(true).create_new(true).open(&path).unwrap_err().kind());\n+    assert_eq!(\n+        ErrorKind::AlreadyExists,\n+        OpenOptions::new().write(true).create_new(true).open(&path).unwrap_err().kind()\n+    );\n     // Optionally creating a new file that already exists should succeed.\n     OpenOptions::new().write(true).create(true).open(&path).unwrap();\n \n@@ -235,7 +274,6 @@ fn test_symlink() {\n     symlink_file.read_to_end(&mut contents).unwrap();\n     assert_eq!(bytes, contents.as_slice());\n \n-\n     #[cfg(unix)]\n     {\n         use std::os::unix::ffi::OsStrExt;\n@@ -250,7 +288,9 @@ fn test_symlink() {\n         // Make the buf one byte larger than it needs to be,\n         // and check that the last byte is not overwritten.\n         let mut large_buf = vec![0xFF; expected_path.len() + 1];\n-        let res = unsafe { libc::readlink(symlink_c_ptr, large_buf.as_mut_ptr().cast(), large_buf.len()) };\n+        let res = unsafe {\n+            libc::readlink(symlink_c_ptr, large_buf.as_mut_ptr().cast(), large_buf.len())\n+        };\n         // Check that the resovled path was properly written into the buf.\n         assert_eq!(&large_buf[..(large_buf.len() - 1)], expected_path);\n         assert_eq!(large_buf.last(), Some(&0xFF));\n@@ -259,18 +299,21 @@ fn test_symlink() {\n         // Test that the resolved path is truncated if the provided buffer\n         // is too small.\n         let mut small_buf = [0u8; 2];\n-        let res = unsafe { libc::readlink(symlink_c_ptr, small_buf.as_mut_ptr().cast(), small_buf.len()) };\n+        let res = unsafe {\n+            libc::readlink(symlink_c_ptr, small_buf.as_mut_ptr().cast(), small_buf.len())\n+        };\n         assert_eq!(small_buf, &expected_path[..small_buf.len()]);\n         assert_eq!(res, small_buf.len() as isize);\n \n         // Test that we report a proper error for a missing path.\n         let bad_path = CString::new(\"MIRI_MISSING_FILE_NAME\").unwrap();\n-        let res = unsafe { libc::readlink(bad_path.as_ptr(), small_buf.as_mut_ptr().cast(), small_buf.len()) };\n+        let res = unsafe {\n+            libc::readlink(bad_path.as_ptr(), small_buf.as_mut_ptr().cast(), small_buf.len())\n+        };\n         assert_eq!(res, -1);\n         assert_eq!(Error::last_os_error().kind(), ErrorKind::NotFound);\n     }\n \n-\n     // Test that metadata of a symbolic link is correct.\n     check_metadata(bytes, &symlink_path).unwrap();\n     // Test that the metadata of a symbolic link is correct when not following it."}]}