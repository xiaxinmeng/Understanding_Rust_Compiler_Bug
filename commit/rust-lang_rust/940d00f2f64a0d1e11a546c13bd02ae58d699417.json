{"sha": "940d00f2f64a0d1e11a546c13bd02ae58d699417", "node_id": "C_kwDOAAsO6NoAKDk0MGQwMGYyZjY0YTBkMWUxMWE1NDZjMTNiZDAyYWU1OGQ2OTk0MTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-22T06:53:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-22T06:53:36Z"}, "message": "Auto merge of #107185 - compiler-errors:rollup-wkomjma, r=compiler-errors\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #103418 (Add `SEMICOLON_IN_EXPRESSIONS_FROM_MACROS` to future-incompat report)\n - #106113 (llvm-wrapper: adapt for LLVM API change)\n - #106144 (Improve the documentation of `black_box`)\n - #106578 (Label closure captures/generator locals that make opaque types recursive)\n - #106749 (Update cc to 1.0.77)\n - #106935 (Fix `SingleUseLifetime` ICE)\n - #107015 (Re-enable building rust-analyzer on riscv64)\n - #107029 (Add new bootstrap members to triagebot.toml)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "7a25a6ec3b9a787d7394f1e7e7b2f0b2584351f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a25a6ec3b9a787d7394f1e7e7b2f0b2584351f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/940d00f2f64a0d1e11a546c13bd02ae58d699417", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/940d00f2f64a0d1e11a546c13bd02ae58d699417", "html_url": "https://github.com/rust-lang/rust/commit/940d00f2f64a0d1e11a546c13bd02ae58d699417", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/940d00f2f64a0d1e11a546c13bd02ae58d699417/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85da15c016f74d7382f243cd92bb12515a8a518f", "url": "https://api.github.com/repos/rust-lang/rust/commits/85da15c016f74d7382f243cd92bb12515a8a518f", "html_url": "https://github.com/rust-lang/rust/commit/85da15c016f74d7382f243cd92bb12515a8a518f"}, {"sha": "31f9f21412958d19de26a2079990ce7707fb7bd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/31f9f21412958d19de26a2079990ce7707fb7bd1", "html_url": "https://github.com/rust-lang/rust/commit/31f9f21412958d19de26a2079990ce7707fb7bd1"}], "stats": {"total": 628, "additions": 577, "deletions": 51}, "files": [{"sha": "cc1b5dcf6a76e5571d869c6363c1732d3233b1f9", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -551,9 +551,9 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.76\"\n+version = \"1.0.77\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"76a284da2e6fe2092f2353e51713435363112dfd60030e22add80be333fb928f\"\n+checksum = \"e9f73505338f7d905b19d18738976aae232eb46b8efc15554ffc56deb5d9ebe4\"\n dependencies = [\n  \"jobserver\",\n ]"}, {"sha": "abc1c2d7b8d1754ade0e1b977b8032a7c331c787", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 53, "deletions": 6, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -1391,11 +1391,15 @@ fn async_opaque_type_cycle_error(tcx: TyCtxt<'_>, span: Span) -> ErrorGuaranteed\n ///\n /// If all the return expressions evaluate to `!`, then we explain that the error will go away\n /// after changing it. This can happen when a user uses `panic!()` or similar as a placeholder.\n-fn opaque_type_cycle_error(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) -> ErrorGuaranteed {\n+fn opaque_type_cycle_error(\n+    tcx: TyCtxt<'_>,\n+    opaque_def_id: LocalDefId,\n+    span: Span,\n+) -> ErrorGuaranteed {\n     let mut err = struct_span_err!(tcx.sess, span, E0720, \"cannot resolve opaque type\");\n \n     let mut label = false;\n-    if let Some((def_id, visitor)) = get_owner_return_paths(tcx, def_id) {\n+    if let Some((def_id, visitor)) = get_owner_return_paths(tcx, opaque_def_id) {\n         let typeck_results = tcx.typeck(def_id);\n         if visitor\n             .returns\n@@ -1431,28 +1435,71 @@ fn opaque_type_cycle_error(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) -> E\n                 .filter_map(|e| typeck_results.node_type_opt(e.hir_id).map(|t| (e.span, t)))\n                 .filter(|(_, ty)| !matches!(ty.kind(), ty::Never))\n             {\n-                struct OpaqueTypeCollector(Vec<DefId>);\n+                #[derive(Default)]\n+                struct OpaqueTypeCollector {\n+                    opaques: Vec<DefId>,\n+                    closures: Vec<DefId>,\n+                }\n                 impl<'tcx> ty::visit::TypeVisitor<'tcx> for OpaqueTypeCollector {\n                     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                         match *t.kind() {\n                             ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, .. }) => {\n-                                self.0.push(def);\n+                                self.opaques.push(def);\n                                 ControlFlow::Continue(())\n                             }\n+                            ty::Closure(def_id, ..) | ty::Generator(def_id, ..) => {\n+                                self.closures.push(def_id);\n+                                t.super_visit_with(self)\n+                            }\n                             _ => t.super_visit_with(self),\n                         }\n                     }\n                 }\n-                let mut visitor = OpaqueTypeCollector(vec![]);\n+\n+                let mut visitor = OpaqueTypeCollector::default();\n                 ty.visit_with(&mut visitor);\n-                for def_id in visitor.0 {\n+                for def_id in visitor.opaques {\n                     let ty_span = tcx.def_span(def_id);\n                     if !seen.contains(&ty_span) {\n                         err.span_label(ty_span, &format!(\"returning this opaque type `{ty}`\"));\n                         seen.insert(ty_span);\n                     }\n                     err.span_label(sp, &format!(\"returning here with type `{ty}`\"));\n                 }\n+\n+                for closure_def_id in visitor.closures {\n+                    let Some(closure_local_did) = closure_def_id.as_local() else { continue; };\n+                    let typeck_results = tcx.typeck(closure_local_did);\n+\n+                    let mut label_match = |ty: Ty<'_>, span| {\n+                        for arg in ty.walk() {\n+                            if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+                                && let ty::Alias(ty::Opaque, ty::AliasTy { def_id: captured_def_id, .. }) = *ty.kind()\n+                                && captured_def_id == opaque_def_id.to_def_id()\n+                            {\n+                                err.span_label(\n+                                    span,\n+                                    format!(\n+                                        \"{} captures itself here\",\n+                                        tcx.def_kind(closure_def_id).descr(closure_def_id)\n+                                    ),\n+                                );\n+                            }\n+                        }\n+                    };\n+\n+                    // Label any closure upvars that capture the opaque\n+                    for capture in typeck_results.closure_min_captures_flattened(closure_local_did)\n+                    {\n+                        label_match(capture.place.ty(), capture.get_path_span(tcx));\n+                    }\n+                    // Label any generator locals that capture the opaque\n+                    for interior_ty in\n+                        typeck_results.generator_interior_types.as_ref().skip_binder()\n+                    {\n+                        label_match(interior_ty.ty, interior_ty.span);\n+                    }\n+                }\n             }\n         }\n     }"}, {"sha": "8046cc21cea583eb73f15cb45228593a05139af6", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -825,34 +825,39 @@ pub trait LintContext: Sized {\n                     debug!(?param_span, ?use_span, ?deletion_span);\n                     db.span_label(param_span, \"this lifetime...\");\n                     db.span_label(use_span, \"...is used only here\");\n-                    let msg = \"elide the single-use lifetime\";\n-                    let (use_span, replace_lt) = if elide {\n-                        let use_span = sess.source_map().span_extend_while(\n-                            use_span,\n-                            char::is_whitespace,\n-                        ).unwrap_or(use_span);\n-                        (use_span, String::new())\n-                    } else {\n-                        (use_span, \"'_\".to_owned())\n-                    };\n-                    db.multipart_suggestion(\n-                        msg,\n-                        vec![(deletion_span, String::new()), (use_span, replace_lt)],\n-                        Applicability::MachineApplicable,\n-                    );\n+                    if let Some(deletion_span) = deletion_span {\n+                        let msg = \"elide the single-use lifetime\";\n+                        let (use_span, replace_lt) = if elide {\n+                            let use_span = sess.source_map().span_extend_while(\n+                                use_span,\n+                                char::is_whitespace,\n+                            ).unwrap_or(use_span);\n+                            (use_span, String::new())\n+                        } else {\n+                            (use_span, \"'_\".to_owned())\n+                        };\n+                        debug!(?deletion_span, ?use_span);\n+                        db.multipart_suggestion(\n+                            msg,\n+                            vec![(deletion_span, String::new()), (use_span, replace_lt)],\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n                 },\n                 BuiltinLintDiagnostics::SingleUseLifetime {\n                     param_span: _,\n                     use_span: None,\n                     deletion_span,\n                 } => {\n                     debug!(?deletion_span);\n-                    db.span_suggestion(\n-                        deletion_span,\n-                        \"elide the unused lifetime\",\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    );\n+                    if let Some(deletion_span) = deletion_span {\n+                        db.span_suggestion(\n+                            deletion_span,\n+                            \"elide the unused lifetime\",\n+                            \"\",\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n                 },\n                 BuiltinLintDiagnostics::NamedArgumentUsedPositionally{ position_sp_to_replace, position_sp_for_msg, named_arg_sp, named_arg_name, is_formatting_arg} => {\n                     db.span_label(named_arg_sp, \"this named argument is referred to by position in formatting string\");"}, {"sha": "b6481d70bc8898fe2de912d9f382e90233fa28bd", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -3015,6 +3015,7 @@ declare_lint! {\n     \"trailing semicolon in macro body used as expression\",\n     @future_incompatible = FutureIncompatibleInfo {\n         reference: \"issue #79813 <https://github.com/rust-lang/rust/issues/79813>\",\n+        reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n     };\n }\n "}, {"sha": "7054d1e9f105e4392e513f197f3dc91d0632fe2c", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -503,7 +503,7 @@ pub enum BuiltinLintDiagnostics {\n         param_span: Span,\n         /// Span of the code that should be removed when eliding this lifetime.\n         /// This span should include leading or trailing comma.\n-        deletion_span: Span,\n+        deletion_span: Option<Span>,\n         /// Span of the single use, or None if the lifetime is never used.\n         /// If true, the lifetime will be fully elided.\n         use_span: Option<(Span, bool)>,"}, {"sha": "87b0e1273eb7761ed06ab0390704af2ae8c2b645", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -1349,18 +1349,16 @@ extern \"C\" LLVMTypeKind LLVMRustGetTypeKind(LLVMTypeRef Ty) {\n     return LLVMBFloatTypeKind;\n   case Type::X86_AMXTyID:\n     return LLVMX86_AMXTypeKind;\n-#if LLVM_VERSION_GE(15, 0) && LLVM_VERSION_LT(16, 0)\n-  case Type::DXILPointerTyID:\n-    report_fatal_error(\"Rust does not support DirectX typed pointers.\");\n-    break;\n-#endif\n-#if LLVM_VERSION_GE(16, 0)\n-  case Type::TypedPointerTyID:\n-    report_fatal_error(\"Rust does not support typed pointers.\");\n-    break;\n-#endif\n+  default:\n+    {\n+      std::string error;\n+      llvm::raw_string_ostream stream(error);\n+      stream << \"Rust does not support the TypeID: \" << unwrap(Ty)->getTypeID()\n+             << \" for the type: \" << *unwrap(Ty);\n+      stream.flush();\n+      report_fatal_error(error.c_str());\n+    }\n   }\n-  report_fatal_error(\"Unhandled TypeID.\");\n }\n \n DEFINE_SIMPLE_CONVERSION_FUNCTIONS(SMDiagnostic, LLVMSMDiagnosticRef)"}, {"sha": "6d448433ee6dbc940bdcde726b3a9f25efbe8997", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -2188,15 +2188,31 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             let deletion_span = || {\n                 if params.len() == 1 {\n                     // if sole lifetime, remove the entire `<>` brackets\n-                    generics_span\n+                    Some(generics_span)\n                 } else if param_index == 0 {\n                     // if removing within `<>` brackets, we also want to\n                     // delete a leading or trailing comma as appropriate\n-                    param.span().to(params[param_index + 1].span().shrink_to_lo())\n+                    match (\n+                        param.span().find_ancestor_inside(generics_span),\n+                        params[param_index + 1].span().find_ancestor_inside(generics_span),\n+                    ) {\n+                        (Some(param_span), Some(next_param_span)) => {\n+                            Some(param_span.to(next_param_span.shrink_to_lo()))\n+                        }\n+                        _ => None,\n+                    }\n                 } else {\n                     // if removing within `<>` brackets, we also want to\n                     // delete a leading or trailing comma as appropriate\n-                    params[param_index - 1].span().shrink_to_hi().to(param.span())\n+                    match (\n+                        param.span().find_ancestor_inside(generics_span),\n+                        params[param_index - 1].span().find_ancestor_inside(generics_span),\n+                    ) {\n+                        (Some(param_span), Some(prev_param_span)) => {\n+                            Some(prev_param_span.shrink_to_hi().to(param_span))\n+                        }\n+                        _ => None,\n+                    }\n                 }\n             };\n             match use_set {"}, {"sha": "5a76e866923366e8716afeb1ddeb3ecc1e470ac7", "filename": "library/core/src/hint.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/library%2Fcore%2Fsrc%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/library%2Fcore%2Fsrc%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhint.rs?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -219,6 +219,75 @@ pub fn spin_loop() {\n /// backend used. Programs cannot rely on `black_box` for *correctness* in any way.\n ///\n /// [`std::convert::identity`]: crate::convert::identity\n+///\n+/// # When is this useful?\n+///\n+/// First and foremost: `black_box` does _not_ guarantee any exact behavior and, in some cases, may\n+/// do nothing at all. As such, it **must not be relied upon to control critical program behavior.**\n+/// This _immediately_ precludes any direct use of this function for cryptographic or security\n+/// purposes.\n+///\n+/// While not suitable in those mission-critical cases, `back_box`'s functionality can generally be\n+/// relied upon for benchmarking, and should be used there. It will try to ensure that the\n+/// compiler doesn't optimize away part of the intended test code based on context. For\n+/// example:\n+///\n+/// ```\n+/// fn contains(haystack: &[&str], needle: &str) -> bool {\n+///     haystack.iter().any(|x| x == &needle)\n+/// }\n+///\n+/// pub fn benchmark() {\n+///     let haystack = vec![\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\"];\n+///     let needle = \"ghi\";\n+///     for _ in 0..10 {\n+///         contains(&haystack, needle);\n+///     }\n+/// }\n+/// ```\n+///\n+/// The compiler could theoretically make optimizations like the following:\n+///\n+/// - `needle` and `haystack` are always the same, move the call to `contains` outside the loop and\n+///   delete the loop\n+/// - Inline `contains`\n+/// - `needle` and `haystack` have values known at compile time, `contains` is always true. Remove\n+///   the call and replace with `true`\n+/// - Nothing is done with the result of `contains`: delete this function call entirely\n+/// - `benchmark` now has no purpose: delete this function\n+///\n+/// It is not likely that all of the above happens, but the compiler is definitely able to make some\n+/// optimizations that could result in a very inaccurate benchmark. This is where `black_box` comes\n+/// in:\n+///\n+/// ```\n+/// use std::hint::black_box;\n+///\n+/// // Same `contains` function\n+/// fn contains(haystack: &[&str], needle: &str) -> bool {\n+///     haystack.iter().any(|x| x == &needle)\n+/// }\n+///\n+/// pub fn benchmark() {\n+///     let haystack = vec![\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\"];\n+///     let needle = \"ghi\";\n+///     for _ in 0..10 {\n+///         // Adjust our benchmark loop contents\n+///         black_box(contains(black_box(&haystack), black_box(needle)));\n+///     }\n+/// }\n+/// ```\n+///\n+/// This essentially tells the compiler to block optimizations across any calls to `black_box`. So,\n+/// it now:\n+///\n+/// - Treats both arguments to `contains` as unpredictable: the body of `contains` can no longer be\n+///   optimized based on argument values\n+/// - Treats the call to `contains` and its result as volatile: the body of `benchmark` cannot\n+///   optimize this away\n+///\n+/// This makes our benchmark much more realistic to how the function would be used in situ, where\n+/// arguments are usually not known at compile time and the result is used in some way.\n #[inline]\n #[stable(feature = \"bench_black_box\", since = \"1.66.0\")]\n #[rustc_const_unstable(feature = \"const_black_box\", issue = \"none\")]"}, {"sha": "2e4f753965deda9938c65f8ee353fdcb9c5331c2", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -1130,12 +1130,6 @@ impl Step for RustAnalyzer {\n         let compiler = self.compiler;\n         let target = self.target;\n \n-        if target.contains(\"riscv64\") {\n-            // riscv64 currently has an LLVM bug that makes rust-analyzer unable\n-            // to build. See #74813 for details.\n-            return None;\n-        }\n-\n         let rust_analyzer = builder\n             .ensure(tool::RustAnalyzer { compiler, target })\n             .expect(\"rust-analyzer always builds\");"}, {"sha": "e876f0fb43f65086be101f0aff1f1e98d67c012c", "filename": "tests/ui/impl-trait/recursive-generator.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Fimpl-trait%2Frecursive-generator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Fimpl-trait%2Frecursive-generator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Frecursive-generator.rs?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -0,0 +1,23 @@\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{Generator, GeneratorState};\n+\n+fn foo() -> impl Generator<Yield = (), Return = ()> {\n+    //~^ ERROR cannot resolve opaque type\n+    //~| NOTE recursive opaque type\n+    //~| NOTE in this expansion of desugaring of\n+    || {\n+    //~^ NOTE returning here\n+        let mut gen = Box::pin(foo());\n+        //~^ NOTE generator captures itself here\n+        let mut r = gen.as_mut().resume(());\n+        while let GeneratorState::Yielded(v) = r {\n+            yield v;\n+            r = gen.as_mut().resume(());\n+        }\n+    }\n+}\n+\n+fn main() {\n+    foo();\n+}"}, {"sha": "e23fd4b4a85e51526cd82ac0ddb64238d126e429", "filename": "tests/ui/impl-trait/recursive-generator.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Fimpl-trait%2Frecursive-generator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Fimpl-trait%2Frecursive-generator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Frecursive-generator.stderr?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -0,0 +1,19 @@\n+error[E0720]: cannot resolve opaque type\n+  --> $DIR/recursive-generator.rs:5:13\n+   |\n+LL |   fn foo() -> impl Generator<Yield = (), Return = ()> {\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ recursive opaque type\n+...\n+LL | /     || {\n+LL | |\n+LL | |         let mut gen = Box::pin(foo());\n+   | |             ------- generator captures itself here\n+LL | |\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____- returning here with type `[generator@$DIR/recursive-generator.rs:9:5: 9:7]`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0720`."}, {"sha": "ebb231ae14f0d77b564567461740e41a377d97dd", "filename": "tests/ui/impl-trait/recursive-impl-trait-type-indirect.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -53,6 +53,7 @@ LL |   fn closure_capture() -> impl Sized {\n ...\n LL | /     move || {\n LL | |         x;\n+   | |         - closure captures itself here\n LL | |     }\n    | |_____- returning here with type `[closure@$DIR/recursive-impl-trait-type-indirect.rs:35:5: 35:12]`\n \n@@ -64,6 +65,7 @@ LL |   fn closure_ref_capture() -> impl Sized {\n ...\n LL | /     move || {\n LL | |         &x;\n+   | |          - closure captures itself here\n LL | |     }\n    | |_____- returning here with type `[closure@$DIR/recursive-impl-trait-type-indirect.rs:43:5: 43:12]`\n \n@@ -94,6 +96,7 @@ LL |   fn generator_capture() -> impl Sized {\n LL | /     move || {\n LL | |         yield;\n LL | |         x;\n+   | |         - generator captures itself here\n LL | |     }\n    | |_____- returning here with type `[generator@$DIR/recursive-impl-trait-type-indirect.rs:61:5: 61:12]`\n \n@@ -114,6 +117,7 @@ LL |   fn generator_hold() -> impl Sized {\n LL |\n LL | /     move || {\n LL | |         let x = generator_hold();\n+   | |             - generator captures itself here\n LL | |         yield;\n LL | |         x;\n LL | |     }"}, {"sha": "c60120061643da4f595aef35afbc4279bb0d0693", "filename": "tests/ui/lint/semicolon-in-expressions-from-macros/semicolon-in-expressions-from-macros.stderr", "status": "modified", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fsemicolon-in-expressions-from-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fsemicolon-in-expressions-from-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fsemicolon-in-expressions-from-macros.stderr?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -46,3 +46,140 @@ LL |     let _ = #[allow(semicolon_in_expressions_from_macros)] foo!(allow_does_\n \n warning: 3 warnings emitted\n \n+Future incompatibility report: Future breakage diagnostic:\n+warning: trailing semicolon in macro used in expression position\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:9:13\n+   |\n+LL |         true;\n+   |             ^\n+...\n+LL |         foo!(first)\n+   |         ----------- in this macro invocation\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79813 <https://github.com/rust-lang/rust/issues/79813>\n+   = note: macro invocations at the end of a block are treated as expressions\n+   = note: to ignore the value produced by the macro, add a semicolon after the invocation of `foo`\n+note: the lint level is defined here\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:24:13\n+   |\n+LL |     #[allow(semicolon_in_expressions_from_macros)]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this warning originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+Future breakage diagnostic:\n+warning: trailing semicolon in macro used in expression position\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:9:13\n+   |\n+LL |         true;\n+   |             ^\n+...\n+LL |     let _ = foo!(second);\n+   |             ------------ in this macro invocation\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79813 <https://github.com/rust-lang/rust/issues/79813>\n+note: the lint level is defined here\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:29:13\n+   |\n+LL |     #[allow(semicolon_in_expressions_from_macros)]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this warning originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+Future breakage diagnostic:\n+warning: trailing semicolon in macro used in expression position\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:9:13\n+   |\n+LL |         true;\n+   |             ^\n+...\n+LL |         let _ = foo!(third);\n+   |                 ----------- in this macro invocation\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79813 <https://github.com/rust-lang/rust/issues/79813>\n+note: the lint level is defined here\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:32:13\n+   |\n+LL |     #[allow(semicolon_in_expressions_from_macros)]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this warning originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+Future breakage diagnostic:\n+warning: trailing semicolon in macro used in expression position\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:9:13\n+   |\n+LL |         true;\n+   |             ^\n+...\n+LL |         let _ = foo!(fourth);\n+   |                 ------------ in this macro invocation\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79813 <https://github.com/rust-lang/rust/issues/79813>\n+note: the lint level is defined here\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:37:13\n+   |\n+LL |     #[allow(semicolon_in_expressions_from_macros)]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this warning originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+Future breakage diagnostic:\n+warning: trailing semicolon in macro used in expression position\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:9:13\n+   |\n+LL |         true;\n+   |             ^\n+...\n+LL |         foo!(warn_in_block)\n+   |         ------------------- in this macro invocation\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79813 <https://github.com/rust-lang/rust/issues/79813>\n+   = note: macro invocations at the end of a block are treated as expressions\n+   = note: to ignore the value produced by the macro, add a semicolon after the invocation of `foo`\n+note: the lint level is defined here\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:4:9\n+   |\n+LL | #![warn(semicolon_in_expressions_from_macros)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this warning originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+Future breakage diagnostic:\n+warning: trailing semicolon in macro used in expression position\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:9:13\n+   |\n+LL |         true;\n+   |             ^\n+...\n+LL |     let _ = foo!(warn_in_expr);\n+   |             ------------------ in this macro invocation\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79813 <https://github.com/rust-lang/rust/issues/79813>\n+note: the lint level is defined here\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:4:9\n+   |\n+LL | #![warn(semicolon_in_expressions_from_macros)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this warning originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+Future breakage diagnostic:\n+warning: trailing semicolon in macro used in expression position\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:9:13\n+   |\n+LL |         true;\n+   |             ^\n+...\n+LL |     let _ = #[allow(semicolon_in_expressions_from_macros)] foo!(allow_does_not_work);\n+   |                                                            ------------------------- in this macro invocation\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79813 <https://github.com/rust-lang/rust/issues/79813>\n+note: the lint level is defined here\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:4:9\n+   |\n+LL | #![warn(semicolon_in_expressions_from_macros)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this warning originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n+"}, {"sha": "0fec4996f1a0ae16dbce4848a7f7ec446730170f", "filename": "tests/ui/lint/semicolon-in-expressions-from-macros/warn-semicolon-in-expressions-from-macros.stderr", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fwarn-semicolon-in-expressions-from-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fwarn-semicolon-in-expressions-from-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fwarn-semicolon-in-expressions-from-macros.stderr?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -14,3 +14,18 @@ LL |         _ => foo!()\n \n warning: 1 warning emitted\n \n+Future incompatibility report: Future breakage diagnostic:\n+warning: trailing semicolon in macro used in expression position\n+  --> $DIR/warn-semicolon-in-expressions-from-macros.rs:6:13\n+   |\n+LL |         true;\n+   |             ^\n+...\n+LL |         _ => foo!()\n+   |              ------ in this macro invocation\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79813 <https://github.com/rust-lang/rust/issues/79813>\n+   = note: `#[warn(semicolon_in_expressions_from_macros)]` on by default\n+   = note: this warning originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n+"}, {"sha": "29ccd17e06999abf8a20e0c01dd8eb5775d75e1d", "filename": "tests/ui/macros/issue-84195-lint-anon-const.stderr", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Fmacros%2Fissue-84195-lint-anon-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Fmacros%2Fissue-84195-lint-anon-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fissue-84195-lint-anon-const.stderr?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -18,3 +18,22 @@ LL | #![deny(semicolon_in_expressions_from_macros)]\n \n error: aborting due to previous error\n \n+Future incompatibility report: Future breakage diagnostic:\n+error: trailing semicolon in macro used in expression position\n+  --> $DIR/issue-84195-lint-anon-const.rs:8:14\n+   |\n+LL |     () => { 0; };\n+   |              ^\n+...\n+LL |     let val: [u8; len!()] = [];\n+   |                   ------ in this macro invocation\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79813 <https://github.com/rust-lang/rust/issues/79813>\n+note: the lint level is defined here\n+  --> $DIR/issue-84195-lint-anon-const.rs:5:9\n+   |\n+LL | #![deny(semicolon_in_expressions_from_macros)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in the macro `len` (in Nightly builds, run with -Z macro-backtrace for more info)\n+"}, {"sha": "13cecc3a31d233cb662a6f6a1b62596452fd8a5b", "filename": "tests/ui/macros/lint-trailing-macro-call.stderr", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Fmacros%2Flint-trailing-macro-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Fmacros%2Flint-trailing-macro-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Flint-trailing-macro-call.stderr?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -16,3 +16,20 @@ LL |     expand_it!()\n \n warning: 1 warning emitted\n \n+Future incompatibility report: Future breakage diagnostic:\n+warning: trailing semicolon in macro used in expression position\n+  --> $DIR/lint-trailing-macro-call.rs:9:25\n+   |\n+LL |         #[cfg(FALSE)] 25;\n+   |                         ^\n+...\n+LL |     expand_it!()\n+   |     ------------ in this macro invocation\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79813 <https://github.com/rust-lang/rust/issues/79813>\n+   = note: macro invocations at the end of a block are treated as expressions\n+   = note: to ignore the value produced by the macro, add a semicolon after the invocation of `expand_it`\n+   = note: `#[warn(semicolon_in_expressions_from_macros)]` on by default\n+   = note: this warning originates in the macro `expand_it` (in Nightly builds, run with -Z macro-backtrace for more info)\n+"}, {"sha": "7785f415946277401d7cc61e4d8b0b11af93d987", "filename": "tests/ui/macros/macro-context.stderr", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Fmacros%2Fmacro-context.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Fmacros%2Fmacro-context.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fmacro-context.stderr?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -82,3 +82,18 @@ error: aborting due to 6 previous errors; 1 warning emitted\n \n Some errors have detailed explanations: E0412, E0425.\n For more information about an error, try `rustc --explain E0412`.\n+Future incompatibility report: Future breakage diagnostic:\n+warning: trailing semicolon in macro used in expression position\n+  --> $DIR/macro-context.rs:3:15\n+   |\n+LL |     () => ( i ; typeof );\n+   |               ^\n+...\n+LL |     let i = m!();\n+   |             ---- in this macro invocation\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79813 <https://github.com/rust-lang/rust/issues/79813>\n+   = note: `#[warn(semicolon_in_expressions_from_macros)]` on by default\n+   = note: this warning originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+"}, {"sha": "3f492b141a5f5949875f5c9f33d728ab2c83ddca", "filename": "tests/ui/macros/macro-in-expression-context.stderr", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Fmacros%2Fmacro-in-expression-context.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Fmacros%2Fmacro-in-expression-context.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fmacro-in-expression-context.stderr?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -31,3 +31,20 @@ LL |     foo!()\n \n error: aborting due to previous error; 1 warning emitted\n \n+Future incompatibility report: Future breakage diagnostic:\n+warning: trailing semicolon in macro used in expression position\n+  --> $DIR/macro-in-expression-context.rs:5:29\n+   |\n+LL |         assert_eq!(\"A\", \"A\");\n+   |                             ^\n+...\n+LL |     foo!()\n+   |     ------ in this macro invocation\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79813 <https://github.com/rust-lang/rust/issues/79813>\n+   = note: macro invocations at the end of a block are treated as expressions\n+   = note: to ignore the value produced by the macro, add a semicolon after the invocation of `foo`\n+   = note: `#[warn(semicolon_in_expressions_from_macros)]` on by default\n+   = note: this warning originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n+"}, {"sha": "0795e95303a1e05023e8878c06531d513c5e2d1c", "filename": "tests/ui/single-use-lifetime/issue-104440.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Fsingle-use-lifetime%2Fissue-104440.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Fsingle-use-lifetime%2Fissue-104440.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle-use-lifetime%2Fissue-104440.rs?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -0,0 +1,100 @@\n+#![feature(decl_macro, rustc_attrs)]\n+#![deny(single_use_lifetimes)]\n+\n+mod type_params {\n+    macro m($T:ident) {\n+        fn f<$T: Clone, T: PartialEq>(t1: $T, t2: T) -> ($T, bool) {\n+            (t1.clone(), t2 == t2)\n+        }\n+    }\n+\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    macro n($T:ident) {\n+        fn g<$T: Clone>(t1: $T, t2: T) -> (T, $T) {\n+            (t1.clone(), t2.clone())\n+        }\n+        fn h<T: Clone>(t1: $T, t2: T) -> (T, $T) {\n+            (t1.clone(), t2.clone())\n+        }\n+    }\n+\n+    #[rustc_macro_transparency = \"transparent\"]\n+    macro p($T:ident) {\n+        fn j<$T: Clone>(t1: $T, t2: T) -> (T, $T) {\n+            (t1.clone(), t2.clone())\n+        }\n+        fn k<T: Clone>(t1: $T, t2: T) -> (T, $T) {\n+            (t1.clone(), t2.clone())\n+        }\n+    }\n+\n+    m!(T);\n+    n!(T);\n+    p!(T);\n+}\n+\n+mod lifetime_params {\n+    macro m($a:lifetime) {\n+        fn f<'b, 'c, $a: 'b, 'a: 'c>(t1: &$a(), t2: &'a ()) -> (&'b (), &'c ()) { //~ ERROR lifetime parameter `'a` only used once\n+            (t1, t2)\n+        }\n+    }\n+\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    macro n($a:lifetime) {\n+        fn g<$a>(t1: &$a(), t2: &'a ()) -> (&'a (), &$a ()) {\n+            (t1, t2)\n+        }\n+        fn h<'a>(t1: &$a(), t2: &'a ()) -> (&'a (), &$a ()) {\n+            (t1, t2)\n+        }\n+    }\n+\n+    #[rustc_macro_transparency = \"transparent\"]\n+    macro p($a:lifetime) {\n+        fn j<$a>(t1: &$a(), t2: &'a ()) -> (&'a (), &$a ()) {\n+            (t1, t2)\n+        }\n+        fn k<'a>(t1: &$a(), t2: &'a ()) -> (&'a (), &$a ()) {\n+            (t1, t2)\n+        }\n+    }\n+\n+    m!('a); //~ ERROR lifetime parameter `'a` only used once\n+    n!('a);\n+    p!('a);\n+}\n+\n+mod const_params {\n+    macro m($C:ident) {\n+        fn f<const $C: usize, const C: usize>(t1: [(); $C], t2: [(); C]) -> ([(); $C], [(); C]) {\n+            (t1, t2)\n+        }\n+    }\n+\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    macro n($C:ident) {\n+        fn g<const $C: usize>(t1: [(); $C], t2: [(); C]) -> ([(); C], [(); $C]) {\n+            (t1, t2)\n+        }\n+        fn h<const C: usize>(t1: [(); $C], t2: [(); C]) -> ([(); C], [(); $C]) {\n+            (t1, t2)\n+        }\n+    }\n+\n+    #[rustc_macro_transparency = \"transparent\"]\n+    macro p($C:ident) {\n+        fn j<const $C: usize>(t1: [(); $C], t2: [(); C]) -> ([(); C], [(); $C]) {\n+            (t1, t2)\n+        }\n+        fn k<const C: usize>(t1: [(); $C], t2: [(); C]) -> ([(); C], [(); $C]) {\n+            (t1, t2)\n+        }\n+    }\n+\n+    m!(C);\n+    n!(C);\n+    p!(C);\n+}\n+\n+fn main() {}"}, {"sha": "54ded31dcbe8936a998721c7d1ced3ec23889fb5", "filename": "tests/ui/single-use-lifetime/issue-104440.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Fsingle-use-lifetime%2Fissue-104440.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/tests%2Fui%2Fsingle-use-lifetime%2Fissue-104440.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle-use-lifetime%2Fissue-104440.stderr?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -0,0 +1,28 @@\n+error: lifetime parameter `'a` only used once\n+  --> $DIR/issue-104440.rs:63:8\n+   |\n+LL |     m!('a);\n+   |        ^^\n+   |        |\n+   |        this lifetime...\n+   |        ...is used only here\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-104440.rs:2:9\n+   |\n+LL | #![deny(single_use_lifetimes)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: lifetime parameter `'a` only used once\n+  --> $DIR/issue-104440.rs:38:30\n+   |\n+LL |         fn f<'b, 'c, $a: 'b, 'a: 'c>(t1: &$a(), t2: &'a ()) -> (&'b (), &'c ()) {\n+   |                              ^^ this lifetime...     -- ...is used only here\n+...\n+LL |     m!('a);\n+   |     ------ in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "16a3132151374d31dda0f22a0e822163a41e477b", "filename": "triagebot.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/940d00f2f64a0d1e11a546c13bd02ae58d699417/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/940d00f2f64a0d1e11a546c13bd02ae58d699417/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=940d00f2f64a0d1e11a546c13bd02ae58d699417", "patch": "@@ -175,7 +175,7 @@ exclude_labels = [\n     \"T-*\",\n ]\n \n-[autolabel.\"A-bootstrap\"]\n+[autolabel.\"T-bootstrap\"]\n trigger_files = [\n     \"x.py\",\n     \"x\",\n@@ -493,6 +493,8 @@ libs = [\n ]\n bootstrap = [\n     \"@Mark-Simulacrum\",\n+    \"@albertlarsan68\",\n+    \"@ozkanonur\",\n ]\n infra-ci = [\n     \"@Mark-Simulacrum\","}]}