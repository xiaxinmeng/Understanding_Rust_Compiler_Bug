{"sha": "45b88aff100463534c036e3880c5f53ac75b83ae", "node_id": "C_kwDOAAsO6NoAKDQ1Yjg4YWZmMTAwNDYzNTM0YzAzNmUzODgwYzVmNTNhYzc1YjgzYWU", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-07-15T05:29:15Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-07-15T05:29:15Z"}, "message": "simplify `suggest_deref_ref_or_into`", "tree": {"sha": "f74ac6c7c3c4cad444280ac7b7b7549936996d21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f74ac6c7c3c4cad444280ac7b7b7549936996d21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45b88aff100463534c036e3880c5f53ac75b83ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45b88aff100463534c036e3880c5f53ac75b83ae", "html_url": "https://github.com/rust-lang/rust/commit/45b88aff100463534c036e3880c5f53ac75b83ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45b88aff100463534c036e3880c5f53ac75b83ae/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1599c5a82175485bdebbb231fba1cedcac742868", "url": "https://api.github.com/repos/rust-lang/rust/commits/1599c5a82175485bdebbb231fba1cedcac742868", "html_url": "https://github.com/rust-lang/rust/commit/1599c5a82175485bdebbb231fba1cedcac742868"}], "stats": {"total": 92, "additions": 47, "deletions": 45}, "files": [{"sha": "b1f2b52bb2eb6b3cff8a4e3b7d60b03df7aba88a", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45b88aff100463534c036e3880c5f53ac75b83ae/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45b88aff100463534c036e3880c5f53ac75b83ae/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=45b88aff100463534c036e3880c5f53ac75b83ae", "patch": "@@ -1811,6 +1811,14 @@ impl Expr<'_> {\n             _ => false,\n         }\n     }\n+\n+    pub fn method_ident(&self) -> Option<Ident> {\n+        match self.kind {\n+            ExprKind::MethodCall(receiver_method, ..) => Some(receiver_method.ident),\n+            ExprKind::Unary(_, expr) | ExprKind::AddrOf(.., expr) => expr.method_ident(),\n+            _ => None,\n+        }\n+    }\n }\n \n /// Checks if the specified expression is a built-in range literal."}, {"sha": "37d675d6b4ddfce3f954fcd45fef0adf56ef599d", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45b88aff100463534c036e3880c5f53ac75b83ae/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45b88aff100463534c036e3880c5f53ac75b83ae/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=45b88aff100463534c036e3880c5f53ac75b83ae", "patch": "@@ -1434,6 +1434,8 @@ symbols! {\n         thumb2,\n         thumb_mode: \"thumb-mode\",\n         tmm_reg,\n+        to_string,\n+        to_vec,\n         todo_macro,\n         tool_attributes,\n         tool_lints,"}, {"sha": "ac3bd29ea0027d09c80a0ed8bdbce24c60bc3c74", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 37, "deletions": 45, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/45b88aff100463534c036e3880c5f53ac75b83ae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45b88aff100463534c036e3880c5f53ac75b83ae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=45b88aff100463534c036e3880c5f53ac75b83ae", "patch": "@@ -14,12 +14,10 @@ use rustc_infer::infer::{self, TyCtxtInferExt};\n use rustc_infer::traits;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Binder, IsSuggestable, Subst, ToPredicate, Ty};\n-use rustc_span::symbol::{sym, Ident};\n+use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n \n-use std::iter;\n-\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn suggest_semicolon_at_end(&self, span: Span, err: &mut Diagnostic) {\n         err.span_suggestion_short(\n@@ -187,54 +185,48 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err.span_label(self.tcx.def_span(def_id), &format!(\"{} defined here\", found));\n             }\n         } else if !self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n-            let struct_pat_shorthand_field = self.maybe_get_struct_pattern_shorthand_field(expr);\n             let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n             if !methods.is_empty() {\n-                let mut suggestions = iter::zip(iter::repeat(&expr), &methods)\n-                    .filter_map(|(receiver_expr, method)| {\n-                        let method_call = format!(\".{}()\", method.name);\n-                        fn method_ident(expr: &hir::Expr<'_>) -> Option<Ident> {\n-                            match expr.kind {\n-                                ExprKind::MethodCall(receiver_method, ..) => Some(receiver_method.ident),\n-                                ExprKind::Unary(_, expr) | ExprKind::AddrOf(.., expr) => method_ident(expr),\n-                                _ => None\n-                            }\n+                let mut suggestions = methods.iter()\n+                    .filter_map(|conversion_method| {\n+                        let receiver_method_ident = expr.method_ident();\n+                        if let Some(method_ident) = receiver_method_ident\n+                            && method_ident.name == conversion_method.name\n+                        {\n+                            return None // do not suggest code that is already there (#53348)\n                         }\n-                        let method_ident = method_ident(&receiver_expr);\n-                        if let Some(method_ident) = method_ident\n-                            && method_ident.name == method.name\n+\n+                        let method_call_list = [sym::to_vec, sym::to_string];\n+                        let mut sugg = if let ExprKind::MethodCall(receiver_method, ..) = expr.kind\n+                            && receiver_method.ident.name == sym::clone\n+                            && method_call_list.contains(&conversion_method.name)\n+                            // If receiver is `.clone()` and found type has one of those methods,\n+                            // we guess that the user wants to convert from a slice type (`&[]` or `&str`)\n+                            // to an owned type (`Vec` or `String`).  These conversions clone internally,\n+                            // so we remove the user's `clone` call.\n                         {\n-                            None // do not suggest code that is already there (#53348)\n+                            vec![(\n+                                receiver_method.ident.span,\n+                                conversion_method.name.to_string()\n+                            )]\n+                        } else if expr.precedence().order()\n+                            < ExprPrecedence::MethodCall.order()\n+                        {\n+                            vec![\n+                                (expr.span.shrink_to_lo(), \"(\".to_string()),\n+                                (expr.span.shrink_to_hi(), format!(\").{}()\", conversion_method.name)),\n+                            ]\n                         } else {\n-                            let method_call_list = [\".to_vec()\", \".to_string()\"];\n-                            let mut sugg = if let ExprKind::MethodCall(receiver_method, ..) = receiver_expr.kind\n-                                && receiver_method.ident.name == sym::clone\n-                                && method_call_list.contains(&method_call.as_str())\n-                            {\n-                                vec![(\n-                                    receiver_method.ident.span,\n-                                    method.name.to_string()\n-                                )]\n-                            } else {\n-                                if expr.precedence().order()\n-                                    < ExprPrecedence::MethodCall.order()\n-                                {\n-                                    vec![\n-                                        (expr.span.shrink_to_lo(), \"(\".to_string()),\n-                                        (expr.span.shrink_to_hi(), format!(\"){}\", method_call)),\n-                                    ]\n-                                } else {\n-                                    vec![(expr.span.shrink_to_hi(), method_call)]\n-                                }\n-                            };\n-                            if let Some(name) = struct_pat_shorthand_field {\n-                                sugg.insert(\n-                                    0,\n-                                    (expr.span.shrink_to_lo(), format!(\"{}: \", name)),\n-                                );\n-                            }\n-                            Some(sugg)\n+                            vec![(expr.span.shrink_to_hi(), format!(\".{}()\", conversion_method.name))]\n+                        };\n+                        let struct_pat_shorthand_field = self.maybe_get_struct_pattern_shorthand_field(expr);\n+                        if let Some(name) = struct_pat_shorthand_field {\n+                            sugg.insert(\n+                                0,\n+                                (expr.span.shrink_to_lo(), format!(\"{}: \", name)),\n+                            );\n                         }\n+                        Some(sugg)\n                     })\n                     .peekable();\n                 if suggestions.peek().is_some() {"}]}