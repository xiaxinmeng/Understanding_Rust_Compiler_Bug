{"sha": "bb72150f0214c9395c48fdd3ee93650f0a507112", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNzIxNTBmMDIxNGM5Mzk1YzQ4ZmRkM2VlOTM2NTBmMGE1MDcxMTI=", "commit": {"author": {"name": "unexge", "email": "unexge@gmail.com", "date": "2020-08-14T19:10:49Z"}, "committer": {"name": "unexge", "email": "unexge@gmail.com", "date": "2020-08-20T18:34:53Z"}, "message": "Handle more cases in AST replacing in expand glob import", "tree": {"sha": "e908449d3b1faf038e963611877e09e480ffb538", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e908449d3b1faf038e963611877e09e480ffb538"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb72150f0214c9395c48fdd3ee93650f0a507112", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb72150f0214c9395c48fdd3ee93650f0a507112", "html_url": "https://github.com/rust-lang/rust/commit/bb72150f0214c9395c48fdd3ee93650f0a507112", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb72150f0214c9395c48fdd3ee93650f0a507112/comments", "author": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "128eef779f572a8120cb475d86a373ac4c9e5559", "url": "https://api.github.com/repos/rust-lang/rust/commits/128eef779f572a8120cb475d86a373ac4c9e5559", "html_url": "https://github.com/rust-lang/rust/commit/128eef779f572a8120cb475d86a373ac4c9e5559"}], "stats": {"total": 255, "additions": 220, "deletions": 35}, "files": [{"sha": "ff9c80d49924c1a77f3004bc95bf075ed3a58975", "filename": "crates/assists/src/handlers/expand_glob_import.rs", "status": "modified", "additions": 219, "deletions": 34, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/bb72150f0214c9395c48fdd3ee93650f0a507112/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb72150f0214c9395c48fdd3ee93650f0a507112/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=bb72150f0214c9395c48fdd3ee93650f0a507112", "patch": "@@ -1,10 +1,12 @@\n use either::Either;\n+use std::iter::successors;\n+\n use hir::{AssocItem, MacroDef, ModuleDef, Name, PathResolution, ScopeDef, SemanticsScope};\n use ide_db::{\n     defs::{classify_name_ref, Definition, NameRefClass},\n     RootDatabase,\n };\n-use syntax::{ast, AstNode, SyntaxToken, T};\n+use syntax::{algo, ast, AstNode, SourceFile, SyntaxNode, SyntaxToken, T};\n \n use crate::{\n     assist_context::{AssistBuilder, AssistContext, Assists},\n@@ -48,27 +50,39 @@ pub(crate) fn expand_glob_import(acc: &mut Assists, ctx: &AssistContext) -> Opti\n     let scope = ctx.sema.scope_at_offset(source_file.syntax(), ctx.offset());\n \n     let defs_in_mod = find_defs_in_mod(ctx, scope, module)?;\n-    let name_refs_in_source_file =\n-        source_file.syntax().descendants().filter_map(ast::NameRef::cast).collect();\n-    let used_names = find_used_names(ctx, defs_in_mod, name_refs_in_source_file);\n+    let names_to_import = find_names_to_import(ctx, source_file, defs_in_mod);\n \n-    let target = parent.syntax();\n+    let target = parent.clone().either(|n| n.syntax().clone(), |n| n.syntax().clone());\n     acc.add(\n         AssistId(\"expand_glob_import\", AssistKind::RefactorRewrite),\n         \"Expand glob import\",\n         target.text_range(),\n         |builder| {\n-            replace_ast(builder, parent, mod_path, used_names);\n+            replace_ast(builder, parent, mod_path, names_to_import);\n         },\n     )\n }\n \n-fn find_parent_and_path(star: &SyntaxToken) -> Option<(ast::UseTree, ast::Path)> {\n-    star.ancestors().find_map(|n| {\n+fn find_parent_and_path(\n+    star: &SyntaxToken,\n+) -> Option<(Either<ast::UseTree, ast::UseTreeList>, ast::Path)> {\n+    return star.ancestors().find_map(|n| {\n+        find_use_tree_list(n.clone())\n+            .and_then(|(u, p)| Some((Either::Right(u), p)))\n+            .or_else(|| find_use_tree(n).and_then(|(u, p)| Some((Either::Left(u), p))))\n+    });\n+\n+    fn find_use_tree_list(n: SyntaxNode) -> Option<(ast::UseTreeList, ast::Path)> {\n+        let use_tree_list = ast::UseTreeList::cast(n)?;\n+        let path = use_tree_list.parent_use_tree().path()?;\n+        Some((use_tree_list, path))\n+    }\n+\n+    fn find_use_tree(n: SyntaxNode) -> Option<(ast::UseTree, ast::Path)> {\n         let use_tree = ast::UseTree::cast(n)?;\n         let path = use_tree.path()?;\n         Some((use_tree, path))\n-    })\n+    }\n }\n \n #[derive(PartialEq)]\n@@ -105,14 +119,36 @@ fn find_defs_in_mod(\n     Some(defs)\n }\n \n-fn find_used_names(\n+fn find_names_to_import(\n     ctx: &AssistContext,\n+    source_file: &SourceFile,\n     defs_in_mod: Vec<Def>,\n-    name_refs_in_source_file: Vec<ast::NameRef>,\n ) -> Vec<Name> {\n-    let defs_in_source_file = name_refs_in_source_file\n-        .iter()\n-        .filter_map(|r| classify_name_ref(&ctx.sema, r))\n+    let (name_refs_in_use_item, name_refs_in_source) = source_file\n+        .syntax()\n+        .descendants()\n+        .filter_map(|n| {\n+            let name_ref = ast::NameRef::cast(n.clone())?;\n+            let name_ref_class = classify_name_ref(&ctx.sema, &name_ref)?;\n+            let is_in_use_item =\n+                successors(n.parent(), |n| n.parent()).find_map(ast::Use::cast).is_some();\n+            Some((name_ref_class, is_in_use_item))\n+        })\n+        .partition::<Vec<_>, _>(|&(_, is_in_use_item)| is_in_use_item);\n+\n+    let name_refs_to_import: Vec<NameRefClass> = name_refs_in_source\n+        .into_iter()\n+        .filter_map(|(r, _)| {\n+            if name_refs_in_use_item.contains(&(r.clone(), true)) {\n+                // already imported\n+                return None;\n+            }\n+            Some(r)\n+        })\n+        .collect();\n+\n+    let defs_in_source_file = name_refs_to_import\n+        .into_iter()\n         .filter_map(|rc| match rc {\n             NameRefClass::Definition(Definition::ModuleDef(def)) => Some(Def::ModuleDef(def)),\n             NameRefClass::Definition(Definition::Macro(def)) => Some(Def::MacroDef(def)),\n@@ -141,28 +177,62 @@ fn find_used_names(\n \n fn replace_ast(\n     builder: &mut AssistBuilder,\n-    parent: ast::UseTree,\n+    parent: Either<ast::UseTree, ast::UseTreeList>,\n     path: ast::Path,\n-    used_names: Vec<Name>,\n+    names_to_import: Vec<Name>,\n ) {\n-    let replacement = match used_names.as_slice() {\n-        [name] => ast::make::use_tree(\n-            ast::make::path_from_text(&format!(\"{}::{}\", path, name)),\n-            None,\n-            None,\n-            false,\n-        ),\n-        names => ast::make::use_tree(\n-            path,\n-            Some(ast::make::use_tree_list(names.iter().map(|n| {\n-                ast::make::use_tree(ast::make::path_from_text(&n.to_string()), None, None, false)\n-            }))),\n-            None,\n-            false,\n-        ),\n+    let existing_use_trees = match parent.clone() {\n+        Either::Left(_) => vec![],\n+        Either::Right(u) => u.use_trees().filter(|n| \n+            // filter out star\n+            n.star_token().is_none()\n+        ).collect(),\n     };\n \n-    builder.replace_ast(parent, replacement);\n+    let new_use_trees: Vec<ast::UseTree> = names_to_import\n+        .iter()\n+        .map(|n| ast::make::use_tree(ast::make::path_from_text(&n.to_string()), None, None, false))\n+        .collect();\n+\n+    let use_trees = [&existing_use_trees[..], &new_use_trees[..]].concat();\n+\n+    match use_trees.as_slice() {\n+        [name] => {\n+            if let Some(end_path) = name.path() {\n+                let replacement = ast::make::use_tree(\n+                    ast::make::path_from_text(&format!(\"{}::{}\", path, end_path)),\n+                    None,\n+                    None,\n+                    false,\n+                );\n+\n+                algo::diff(\n+                    &parent.either(|n| n.syntax().clone(), |n| n.syntax().clone()),\n+                    replacement.syntax(),\n+                )\n+                .into_text_edit(builder.text_edit_builder());\n+            }\n+        }\n+        names => {\n+            let replacement = match parent {\n+                Either::Left(_) => ast::make::use_tree(\n+                    path,\n+                    Some(ast::make::use_tree_list(names.to_owned())),\n+                    None,\n+                    false,\n+                )\n+                .syntax()\n+                .clone(),\n+                Either::Right(_) => ast::make::use_tree_list(names.to_owned()).syntax().clone(),\n+            };\n+\n+            algo::diff(\n+                &parent.either(|n| n.syntax().clone(), |n| n.syntax().clone()),\n+                &replacement,\n+            )\n+            .into_text_edit(builder.text_edit_builder());\n+        }\n+    };\n }\n \n #[cfg(test)]\n@@ -236,7 +306,46 @@ mod foo {\n     pub fn f() {}\n }\n \n-use foo::{Baz, Bar, f};\n+use foo::{f, Baz, Bar};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn expanding_glob_import_with_existing_uses_in_same_module() {\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+    pub struct Qux;\n+\n+    pub fn f() {}\n+}\n+\n+use foo::Bar;\n+use foo::{*<|>, f};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+}\n+\",\n+            r\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+    pub struct Qux;\n+\n+    pub fn f() {}\n+}\n+\n+use foo::Bar;\n+use foo::{f, Baz};\n \n fn qux(bar: Bar, baz: Baz) {\n     f();\n@@ -286,7 +395,7 @@ mod foo {\n     }\n }\n \n-use foo::{bar::{Baz, Bar, f}, baz::*};\n+use foo::{bar::{f, Baz, Bar}, baz::*};\n \n fn qux(bar: Bar, baz: Baz) {\n     f();\n@@ -486,6 +595,82 @@ use foo::{\n     baz::{g, qux::{h, q::j}}\n };\n \n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+    g();\n+    h();\n+    j();\n+}\n+\",\n+        );\n+\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+\n+        pub fn f() {}\n+    }\n+\n+    pub mod baz {\n+        pub fn g() {}\n+\n+        pub mod qux {\n+            pub fn h() {}\n+            pub fn m() {}\n+\n+            pub mod q {\n+                pub fn j() {}\n+            }\n+        }\n+    }\n+}\n+\n+use foo::{\n+    bar::{*, f},\n+    baz::{g, qux::{q::j, *<|>}}\n+};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+    g();\n+    h();\n+    j();\n+}\n+\",\n+            r\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+\n+        pub fn f() {}\n+    }\n+\n+    pub mod baz {\n+        pub fn g() {}\n+\n+        pub mod qux {\n+            pub fn h() {}\n+            pub fn m() {}\n+\n+            pub mod q {\n+                pub fn j() {}\n+            }\n+        }\n+    }\n+}\n+\n+use foo::{\n+    bar::{*, f},\n+    baz::{g, qux::{q::j, h}}\n+};\n+\n fn qux(bar: Bar, baz: Baz) {\n     f();\n     g();"}, {"sha": "1e7a1f1591213375039cd3ef8a2a57396e9f67dc", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb72150f0214c9395c48fdd3ee93650f0a507112/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb72150f0214c9395c48fdd3ee93650f0a507112/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=bb72150f0214c9395c48fdd3ee93650f0a507112", "patch": "@@ -225,7 +225,7 @@ pub fn classify_name(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option\n     }\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n pub enum NameRefClass {\n     ExternCrate(Crate),\n     Definition(Definition),"}]}