{"sha": "2891f5abe3c7f455d16930a35bfc8d8d623de0ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4OTFmNWFiZTNjN2Y0NTVkMTY5MzBhMzViZmM4ZDhkNjIzZGUwZmY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-26T23:41:14Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-26T23:41:35Z"}, "message": "tutorial: Remove all references to 'records'. Misc", "tree": {"sha": "bde4007d0f812582505e9a6e6e51017fc41c9ab8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bde4007d0f812582505e9a6e6e51017fc41c9ab8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2891f5abe3c7f455d16930a35bfc8d8d623de0ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2891f5abe3c7f455d16930a35bfc8d8d623de0ff", "html_url": "https://github.com/rust-lang/rust/commit/2891f5abe3c7f455d16930a35bfc8d8d623de0ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2891f5abe3c7f455d16930a35bfc8d8d623de0ff/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4148932fcab17f6f8bb362df34d7b83e4c57580", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4148932fcab17f6f8bb362df34d7b83e4c57580", "html_url": "https://github.com/rust-lang/rust/commit/e4148932fcab17f6f8bb362df34d7b83e4c57580"}], "stats": {"total": 73, "additions": 41, "deletions": 32}, "files": [{"sha": "8023f9365a572925708a21a8ecc514ae88cdb297", "filename": "doc/tutorial-borrowed-ptr.md", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2891f5abe3c7f455d16930a35bfc8d8d623de0ff/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/2891f5abe3c7f455d16930a35bfc8d8d623de0ff/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=2891f5abe3c7f455d16930a35bfc8d8d623de0ff", "patch": "@@ -29,10 +29,10 @@ a limit duration. Borrowed pointers never claim any kind of ownership\n over the data that they point at: instead, they are used for cases\n where you like to make use of data for a short time.\n \n-As an example, consider a simple record type `point`:\n+As an example, consider a simple struct type `point`:\n \n ~~~\n-type point = {x: float, y: float};\n+struct point {x: float, y: float}\n ~~~\n \n We can use this simple definition to allocate points in many ways. For\n@@ -82,7 +82,7 @@ compute_distance(shared_box, unique_box);\n \n Here the `&` operator is used to take the address of the variable\n `on_the_stack`; this is because `on_the_stack` has the type `point`\n-(that is, a record value) and we have to take its address to get a\n+(that is, a struct value) and we have to take its address to get a\n value. We also call this _borrowing_ the local variable\n `on_the_stack`, because we are created an alias: that is, another\n route to the same data.\n@@ -325,15 +325,18 @@ which has been freed.\n In fact, the compiler can apply this same kind of reasoning can be\n applied to any memory which is _(uniquely) owned by the stack\n frame_. So we could modify the previous example to introduce\n-additional unique pointers and records, and the compiler will still be\n+additional unique pointers and structs, and the compiler will still be\n able to detect possible mutations:\n \n ~~~ {.xfail-test}\n fn example3() -> int {\n-    let mut x = ~{mut f: ~{g: 3}};\n+    struct R { g: int }\n+    struct S { mut f: ~R }\n+\n+    let mut x = ~S {mut f: ~R {g: 3}};\n     let y = &x.f.g;\n-    x = ~{mut f: ~{g: 4}}; // Error reported here.\n-    x.f = ~{g: 5};         // Error reported here.\n+    x = ~S {mut f: ~R {g: 4}}; // Error reported here.\n+    x.f = ~R {g: 5};           // Error reported here.\n     *y\n }\n ~~~\n@@ -504,7 +507,7 @@ Stack             Memory\n ~~~\n \n As you can see, the `size` pointer would not be pointing at a `float` and\n-not a record. This is not good.\n+not a struct. This is not good.\n \n So, in fact, for every `ref` binding, the compiler will impose the\n same rules as the ones we saw for borrowing the interior of a unique\n@@ -559,14 +562,14 @@ defined by the caller.\n \n In any case, whatever the lifetime L is, the pointer produced by\n `&p.x` always has the same lifetime as `p` itself, as a pointer to a\n-field of a record is valid as long as the record is valid. Therefore,\n+field of a struct is valid as long as the struct is valid. Therefore,\n the compiler is satisfied with the function `get_x()`.\n \n To drill in this point, let\u2019s look at a variation on the example, this\n time one which does not compile:\n \n ~~~ {.xfail-test}\n-type point = {x: float, y: float};\n+struct point {x: float, y: float}\n fn get_x_sh(p: @point) -> &float {\n     &p.x // Error reported here\n }"}, {"sha": "b7e39390168c8dedf4b5d42acb3bf986f33cb940", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2891f5abe3c7f455d16930a35bfc8d8d623de0ff/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/2891f5abe3c7f455d16930a35bfc8d8d623de0ff/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=2891f5abe3c7f455d16930a35bfc8d8d623de0ff", "patch": "@@ -205,7 +205,7 @@ vector.\n ## Passing structures\n \n C functions often take pointers to structs as arguments. Since Rust\n-records are binary-compatible with C structs, Rust programs can call\n+structs are binary-compatible with C structs, Rust programs can call\n such functions directly.\n \n This program uses the POSIX function `gettimeofday` to get a\n@@ -215,14 +215,20 @@ microsecond-resolution timer.\n extern mod std;\n use libc::c_ulonglong;\n \n-type timeval = {mut tv_sec: c_ulonglong,\n-                mut tv_usec: c_ulonglong};\n+struct timeval {\n+    mut tv_sec: c_ulonglong,\n+    mut tv_usec: c_ulonglong\n+}\n+\n #[nolink]\n extern mod lib_c {\n     fn gettimeofday(tv: *timeval, tz: *()) -> i32;\n }\n fn unix_time_in_microseconds() -> u64 unsafe {\n-    let x = {mut tv_sec: 0 as c_ulonglong, mut tv_usec: 0 as c_ulonglong};\n+    let x = timeval {\n+        mut tv_sec: 0 as c_ulonglong,\n+        mut tv_usec: 0 as c_ulonglong\n+    };\n     lib_c::gettimeofday(ptr::addr_of(x), ptr::null());\n     return (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\n }\n@@ -234,8 +240,8 @@ The `#[nolink]` attribute indicates that there's no foreign library to\n link in. The standard C library is already linked with Rust programs.\n \n A `timeval`, in C, is a struct with two 32-bit integers. Thus, we\n-define a record type with the same contents, and declare\n-`gettimeofday` to take a pointer to such a record.\n+define a struct type with the same contents, and declare\n+`gettimeofday` to take a pointer to such a struct.\n \n The second argument to `gettimeofday` (the time zone) is not used by\n this program, so it simply declares it to be a pointer to the nil"}, {"sha": "7244206b2eb414ba7e8810fa9f84d1d87ca68896", "filename": "doc/tutorial.md", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2891f5abe3c7f455d16930a35bfc8d8d623de0ff/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/2891f5abe3c7f455d16930a35bfc8d8d623de0ff/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=2891f5abe3c7f455d16930a35bfc8d8d623de0ff", "patch": "@@ -713,16 +713,16 @@ enum Shape {\n }\n ~~~~\n \n-A value of this type is either a Circle, in which case it contains a\n-point struct and a float, or a Rectangle, in which case it contains\n-two point records. The run-time representation of such a value\n+A value of this type is either a `Circle`, in which case it contains a\n+`Point` struct and a float, or a `Rectangle`, in which case it contains\n+two `Point` structs. The run-time representation of such a value\n includes an identifier of the actual form that it holds, much like the\n 'tagged union' pattern in C, but with better ergonomics.\n \n-The above declaration will define a type `shape` that can be used to\n-refer to such shapes, and two functions, `circle` and `rectangle`,\n+The above declaration will define a type `Shape` that can be used to\n+refer to such shapes, and two functions, `Circle` and `Rectangle`,\n which can be used to construct values of the type (taking arguments of\n-the specified types). So `circle({x: 0f, y: 0f}, 10f)` is the way to\n+the specified types). So `Circle(Point {x: 0f, y: 0f}, 10f)` is the way to\n create a new circle.\n \n Enum variants need not have type parameters. This, for example, is\n@@ -820,7 +820,7 @@ fn point_from_direction(dir: Direction) -> Point {\n \n ## Tuples\n \n-Tuples in Rust behave exactly like records, except that their fields\n+Tuples in Rust behave exactly like structs, except that their fields\n do not have names (and can thus not be accessed with dot notation).\n Tuples can have any arity except for 0 or 1 (though you may consider\n nil, `()`, as the empty tuple if you like).\n@@ -1006,16 +1006,16 @@ of each is key to using Rust effectively.\n \n # Boxes and pointers\n \n-In contrast to a lot of modern languages, aggregate types like records\n+In contrast to a lot of modern languages, aggregate types like structs\n and enums are _not_ represented as pointers to allocated memory in\n Rust. They are, as in C and C++, represented directly. This means that\n-if you `let x = {x: 1f, y: 1f};`, you are creating a record on the\n-stack. If you then copy it into a data structure, the whole record is\n+if you `let x = Point {x: 1f, y: 1f};`, you are creating a struct on the\n+stack. If you then copy it into a data structure, the whole struct is\n copied, not just a pointer.\n \n-For small records like `point`, this is usually more efficient than\n-allocating memory and going through a pointer. But for big records, or\n-records with mutable fields, it can be useful to have a single copy on\n+For small structs like `Point`, this is usually more efficient than\n+allocating memory and going through a pointer. But for big structs, or\n+those with mutable fields, it can be useful to have a single copy on\n the heap, and refer to that through a pointer.\n \n Rust supports several types of pointers. The safe pointer types are\n@@ -1191,8 +1191,8 @@ compute_distance(shared_box, unique_box);\n ~~~\n \n Here the `&` operator is used to take the address of the variable\n-`on_the_stack`; this is because `on_the_stack` has the type `point`\n-(that is, a record value) and we have to take its address to get a\n+`on_the_stack`; this is because `on_the_stack` has the type `Point`\n+(that is, a struct value) and we have to take its address to get a\n value. We also call this _borrowing_ the local variable\n `on_the_stack`, because we are created an alias: that is, another\n route to the same data.\n@@ -1517,7 +1517,7 @@ fn each(v: &[int], op: fn(v: &int)) {\n The reason we pass in a *pointer* to an integer rather than the\n integer itself is that this is how the actual `each()` function for\n vectors works.  Using a pointer means that the function can be used\n-for vectors of any type, even large records that would be impractical\n+for vectors of any type, even large structs that would be impractical\n to copy out of the vector on each iteration.  As a caller, if we use a\n closure to provide the final operator argument, we can write it in a\n way that has a pleasant, block-like structure."}]}