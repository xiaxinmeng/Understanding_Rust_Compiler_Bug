{"sha": "3abaf43f770a8bae23da474690e3841041219029", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYmFmNDNmNzcwYThiYWUyM2RhNDc0NjkwZTM4NDEwNDEyMTkwMjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-30T07:46:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-30T07:46:00Z"}, "message": "Auto merge of #37954 - eddyb:rustdoc-2, r=alexcrichton\n\nrustdoc: link to cross-crate sources directly.\n\nFixes #37684 by implementing proper support for getting the `Span` of definitions across crates.\nIn rustdoc this is used to generate direct links to the original source instead of fragile redirects.\n\nThis functionality could be expanded further for making error reporting code more uniform and seamless across crates, although at the moment there is no actual source to print, only file/line/column information.\n\nCloses #37870 which is also \"fixes\" #37684 by throwing away the builtin macro docs from libcore.\nAfter this lands, #37727 could be reverted, although it doesn't matter much either way.", "tree": {"sha": "806a8618b7b42a3ee113ee4a8734544840514f99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/806a8618b7b42a3ee113ee4a8734544840514f99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3abaf43f770a8bae23da474690e3841041219029", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3abaf43f770a8bae23da474690e3841041219029", "html_url": "https://github.com/rust-lang/rust/commit/3abaf43f770a8bae23da474690e3841041219029", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3abaf43f770a8bae23da474690e3841041219029/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e373b47872872a2ce61c5b02f4dd96d90d046ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e373b47872872a2ce61c5b02f4dd96d90d046ee", "html_url": "https://github.com/rust-lang/rust/commit/8e373b47872872a2ce61c5b02f4dd96d90d046ee"}, {"sha": "900191891fc5462d4ef33756a7d4d40e78e1c1cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/900191891fc5462d4ef33756a7d4d40e78e1c1cc", "html_url": "https://github.com/rust-lang/rust/commit/900191891fc5462d4ef33756a7d4d40e78e1c1cc"}], "stats": {"total": 621, "additions": 296, "deletions": 325}, "files": [{"sha": "6ce6f6896df29cca0134a636ec79d8f2b01c03dd", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -760,47 +760,40 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn opt_span(&self, id: NodeId) -> Option<Span> {\n-        let sp = match self.find(id) {\n-            Some(NodeItem(item)) => item.span,\n-            Some(NodeForeignItem(foreign_item)) => foreign_item.span,\n-            Some(NodeTraitItem(trait_method)) => trait_method.span,\n-            Some(NodeImplItem(ref impl_item)) => impl_item.span,\n-            Some(NodeVariant(variant)) => variant.span,\n-            Some(NodeField(field)) => field.span,\n-            Some(NodeExpr(expr)) => expr.span,\n-            Some(NodeStmt(stmt)) => stmt.span,\n-            Some(NodeTy(ty)) => ty.span,\n-            Some(NodeTraitRef(tr)) => tr.path.span,\n-            Some(NodeLocal(pat)) => pat.span,\n-            Some(NodePat(pat)) => pat.span,\n-            Some(NodeBlock(block)) => block.span,\n-            Some(NodeStructCtor(_)) => self.expect_item(self.get_parent(id)).span,\n-            Some(NodeTyParam(ty_param)) => ty_param.span,\n-            Some(NodeVisibility(&Visibility::Restricted { ref path, .. })) => path.span,\n-            _ => return None,\n-        };\n-        Some(sp)\n-    }\n-\n     pub fn span(&self, id: NodeId) -> Span {\n         self.read(id); // reveals span from node\n-        self.opt_span(id)\n-            .unwrap_or_else(|| bug!(\"AstMap.span: could not find span for id {:?}\", id))\n+        match self.find_entry(id) {\n+            Some(EntryItem(_, item)) => item.span,\n+            Some(EntryForeignItem(_, foreign_item)) => foreign_item.span,\n+            Some(EntryTraitItem(_, trait_method)) => trait_method.span,\n+            Some(EntryImplItem(_, impl_item)) => impl_item.span,\n+            Some(EntryVariant(_, variant)) => variant.span,\n+            Some(EntryField(_, field)) => field.span,\n+            Some(EntryExpr(_, expr)) => expr.span,\n+            Some(EntryStmt(_, stmt)) => stmt.span,\n+            Some(EntryTy(_, ty)) => ty.span,\n+            Some(EntryTraitRef(_, tr)) => tr.path.span,\n+            Some(EntryLocal(_, pat)) => pat.span,\n+            Some(EntryPat(_, pat)) => pat.span,\n+            Some(EntryBlock(_, block)) => block.span,\n+            Some(EntryStructCtor(_, _)) => self.expect_item(self.get_parent(id)).span,\n+            Some(EntryLifetime(_, lifetime)) => lifetime.span,\n+            Some(EntryTyParam(_, ty_param)) => ty_param.span,\n+            Some(EntryVisibility(_, &Visibility::Restricted { ref path, .. })) => path.span,\n+            Some(EntryVisibility(_, v)) => bug!(\"unexpected Visibility {:?}\", v),\n+\n+            Some(RootCrate) => self.krate().span,\n+            Some(RootInlinedParent(parent)) => parent.body.span,\n+            Some(NotPresent) | None => {\n+                bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n+            }\n+        }\n     }\n \n     pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n         self.as_local_node_id(id).map(|id| self.span(id))\n     }\n \n-    pub fn def_id_span(&self, def_id: DefId, fallback: Span) -> Span {\n-        if let Some(node_id) = self.as_local_node_id(def_id) {\n-            self.opt_span(node_id).unwrap_or(fallback)\n-        } else {\n-            fallback\n-        }\n-    }\n-\n     pub fn node_to_string(&self, id: NodeId) -> String {\n         node_id_to_string(self, id, true)\n     }"}, {"sha": "484e2f1535e7aaaacdb63d01afe454d61976ce13", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -260,6 +260,7 @@ pub struct ExternCrate {\n pub trait CrateStore<'tcx> {\n     // item info\n     fn describe_def(&self, def: DefId) -> Option<Def>;\n+    fn def_span(&self, sess: &Session, def: DefId) -> Span;\n     fn stability(&self, def: DefId) -> Option<attr::Stability>;\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>;\n     fn visibility(&self, def: DefId) -> ty::Visibility;\n@@ -404,6 +405,7 @@ pub struct DummyCrateStore;\n impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // item info\n     fn describe_def(&self, def: DefId) -> Option<Def> { bug!(\"describe_def\") }\n+    fn def_span(&self, sess: &Session, def: DefId) -> Span { bug!(\"def_span\") }\n     fn stability(&self, def: DefId) -> Option<attr::Stability> { bug!(\"stability\") }\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { bug!(\"deprecation\") }\n     fn visibility(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }"}, {"sha": "e95ce97e13577f19d36573988b739e2e0aa6ae85", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -283,10 +283,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                           expected.ty,\n                                           found.ty));\n \n-                match\n-                    self.map.as_local_node_id(expected.def_id)\n-                            .and_then(|node_id| self.map.opt_span(node_id))\n-                {\n+                match self.map.span_if_local(expected.def_id) {\n                     Some(span) => {\n                         db.span_note(span, \"a default was defined here...\");\n                     }\n@@ -300,10 +297,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     expected.origin_span,\n                     \"...that was applied to an unconstrained type variable here\");\n \n-                match\n-                    self.map.as_local_node_id(found.def_id)\n-                            .and_then(|node_id| self.map.opt_span(node_id))\n-                {\n+                match self.map.span_if_local(found.def_id) {\n                     Some(span) => {\n                         db.span_note(span, \"a second default was defined here...\");\n                     }"}, {"sha": "3ce092db482c4c765143ae548f3c9c0693f7d951", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -2360,6 +2360,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn def_span(self, def_id: DefId) -> Span {\n+        if let Some(id) = self.map.as_local_node_id(def_id) {\n+            self.map.span(id)\n+        } else {\n+            self.sess.cstore.def_span(&self.sess, def_id)\n+        }\n+    }\n+\n     pub fn item_name(self, id: DefId) -> ast::Name {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.name(id)"}, {"sha": "b0a1b3498545fad7ba47b133cab54bdde9862c67", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -496,8 +496,8 @@ fn add_fragment_siblings_for_extension<'a, 'tcx>(this: &MoveData<'tcx>,\n         },\n \n         ref ty => {\n-            let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n-            span_bug!(opt_span.unwrap_or(DUMMY_SP),\n+            let span = origin_id.map_or(DUMMY_SP, |id| tcx.map.span(id));\n+            span_bug!(span,\n                       \"type {:?} ({:?}) is not fragmentable\",\n                       parent_ty, ty);\n         }"}, {"sha": "b055b043723e4ab769304d1a249fa2feff74cd38", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -1006,11 +1006,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                got {:?}\",\n                                               node);\n \n-                        // Point to what was found, if there's an accessible span.\n-                        match tcx.map.opt_span(nodeid) {\n-                            Some(sp) => tcx.sess.span_fatal(sp, &message),\n-                            None => tcx.sess.fatal(&message),\n-                        }\n+                        tcx.sess.span_fatal(tcx.map.span(nodeid), &message)\n                     }\n                 }\n             }"}, {"sha": "c41c3afb83ed5682aab1fd7cdaeac2ddda70ad49", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -32,7 +32,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::parse::new_parser_from_source_str;\n use syntax::symbol::Symbol;\n-use syntax_pos::mk_sp;\n+use syntax_pos::{mk_sp, Span};\n use rustc::hir::svh::Svh;\n use rustc_back::target::Target;\n use rustc::hir;\n@@ -43,6 +43,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def.krate).get_def(def.index)\n     }\n \n+    fn def_span(&self, sess: &Session, def: DefId) -> Span {\n+        self.dep_graph.read(DepNode::MetaData(def));\n+        self.get_crate_data(def.krate).get_span(def.index, sess)\n+    }\n+\n     fn stability(&self, def: DefId) -> Option<attr::Stability> {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_stability(def.index)\n@@ -383,20 +388,23 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         let local_span = mk_sp(lo, parser.prev_span.hi);\n \n         // Mark the attrs as used\n-        for attr in &def.attrs {\n+        let attrs = data.get_item_attrs(id.index);\n+        for attr in &attrs {\n             attr::mark_used(attr);\n         }\n \n+        let name = data.def_key(id.index).disambiguated_data.data\n+            .get_opt_name().expect(\"no name in load_macro\");\n         sess.imported_macro_spans.borrow_mut()\n-            .insert(local_span, (def.name.as_str().to_string(), def.span));\n+            .insert(local_span, (name.to_string(), data.get_span(id.index, sess)));\n \n         LoadedMacro::MacroRules(ast::MacroDef {\n-            ident: ast::Ident::with_empty_ctxt(def.name),\n+            ident: ast::Ident::with_empty_ctxt(name),\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n             imported_from: None, // FIXME\n-            allow_internal_unstable: attr::contains_name(&def.attrs, \"allow_internal_unstable\"),\n-            attrs: def.attrs,\n+            allow_internal_unstable: attr::contains_name(&attrs, \"allow_internal_unstable\"),\n+            attrs: attrs,\n             body: body,\n         })\n     }"}, {"sha": "308cd6a83db7e386d4066e349ae5e19b946bdd74", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -25,6 +25,7 @@ use rustc::middle::cstore::{InlinedItem, LinkagePreference};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::middle::lang_items;\n+use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n \n@@ -47,8 +48,9 @@ use syntax_pos::{self, Span, BytePos, Pos};\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Decoder<'a>,\n-    tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n     cdata: Option<&'a CrateMetadata>,\n+    sess: Option<&'a Session>,\n+    tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n     from_id_range: IdRange,\n     to_id_range: IdRange,\n \n@@ -61,22 +63,21 @@ pub struct DecodeContext<'a, 'tcx: 'a> {\n /// Abstract over the various ways one can create metadata decoders.\n pub trait Metadata<'a, 'tcx>: Copy {\n     fn raw_bytes(self) -> &'a [u8];\n-    fn cdata(self) -> Option<&'a CrateMetadata> {\n-        None\n-    }\n-    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> {\n-        None\n-    }\n+    fn cdata(self) -> Option<&'a CrateMetadata> { None }\n+    fn sess(self) -> Option<&'a Session> { None }\n+    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { None }\n \n     fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n         let id_range = IdRange {\n             min: NodeId::from_u32(u32::MIN),\n             max: NodeId::from_u32(u32::MAX),\n         };\n+        let tcx = self.tcx();\n         DecodeContext {\n             opaque: opaque::Decoder::new(self.raw_bytes(), pos),\n             cdata: self.cdata(),\n-            tcx: self.tcx(),\n+            sess: self.sess().or(tcx.map(|tcx| tcx.sess)),\n+            tcx: tcx,\n             from_id_range: id_range,\n             to_id_range: id_range,\n             last_filemap_index: 0,\n@@ -104,6 +105,18 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a CrateMetadata {\n     }\n }\n \n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, &'a Session) {\n+    fn raw_bytes(self) -> &'a [u8] {\n+        self.0.raw_bytes()\n+    }\n+    fn cdata(self) -> Option<&'a CrateMetadata> {\n+        Some(self.0)\n+    }\n+    fn sess(self) -> Option<&'a Session> {\n+        Some(&self.1)\n+    }\n+}\n+\n impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>) {\n     fn raw_bytes(self) -> &'a [u8] {\n         self.0.raw_bytes()\n@@ -280,8 +293,8 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         let lo = BytePos::decode(self)?;\n         let hi = BytePos::decode(self)?;\n \n-        let tcx = if let Some(tcx) = self.tcx {\n-            tcx\n+        let sess = if let Some(sess) = self.sess {\n+            sess\n         } else {\n             return Ok(syntax_pos::mk_sp(lo, hi));\n         };\n@@ -299,7 +312,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             (lo, hi)\n         };\n \n-        let imported_filemaps = self.cdata().imported_filemaps(&tcx.sess.codemap());\n+        let imported_filemaps = self.cdata().imported_filemaps(&sess.codemap());\n         let filemap = {\n             // Optimize for the case that most spans within a translated item\n             // originate from the same filemap.\n@@ -537,6 +550,10 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n+    pub fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n+        self.entry(index).span.decode((self, sess))\n+    }\n+\n     pub fn get_trait_def(&self,\n                          item_id: DefIndex,\n                          tcx: TyCtxt<'a, 'tcx, 'tcx>)"}, {"sha": "6abc81d74dc0ad041699328bbe440dd4242dbd80", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -275,6 +275,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Entry {\n             kind: EntryKind::Variant(self.lazy(&data)),\n             visibility: enum_vis.simplify(),\n+            span: self.lazy(&tcx.def_span(def_id)),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n             children: self.lazy_seq(variant.fields.iter().map(|f| {\n@@ -313,6 +314,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Entry {\n             kind: EntryKind::Mod(self.lazy(&data)),\n             visibility: vis.simplify(),\n+            span: self.lazy(&md.inner),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(attrs),\n             children: self.lazy_seq(md.item_ids.iter().map(|item_id| {\n@@ -393,6 +395,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Entry {\n             kind: EntryKind::Field,\n             visibility: field.vis.simplify(),\n+            span: self.lazy(&tcx.def_span(def_id)),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&variant_data.fields()[field_index].attrs),\n             children: LazySeq::empty(),\n@@ -426,6 +429,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Entry {\n             kind: EntryKind::Struct(self.lazy(&data)),\n             visibility: struct_vis.simplify(),\n+            span: self.lazy(&tcx.def_span(def_id)),\n             def_key: self.encode_def_key(def_id),\n             attributes: LazySeq::empty(),\n             children: LazySeq::empty(),\n@@ -492,6 +496,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Entry {\n             kind: kind,\n             visibility: trait_item.vis.simplify(),\n+            span: self.lazy(&ast_item.span),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&ast_item.attrs),\n             children: LazySeq::empty(),\n@@ -580,6 +585,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Entry {\n             kind: kind,\n             visibility: impl_item.vis.simplify(),\n+            span: self.lazy(&ast_item.span),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&ast_item.attrs),\n             children: LazySeq::empty(),\n@@ -743,6 +749,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Entry {\n             kind: kind,\n             visibility: item.vis.simplify(),\n+            span: self.lazy(&item.span),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&item.attrs),\n             children: match item.node {\n@@ -850,18 +857,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     /// Serialize the text of exported macros\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) -> Entry<'tcx> {\n         let def_id = self.tcx.map.local_def_id(macro_def.id);\n-        let macro_def = MacroDef {\n-            name: macro_def.name,\n-            attrs: macro_def.attrs.to_vec(),\n-            span: macro_def.span,\n-            body: ::syntax::print::pprust::tts_to_string(&macro_def.body)\n-        };\n         Entry {\n-            kind: EntryKind::MacroDef(self.lazy(&macro_def)),\n+            kind: EntryKind::MacroDef(self.lazy(&MacroDef {\n+                body: ::syntax::print::pprust::tts_to_string(&macro_def.body)\n+            })),\n             visibility: ty::Visibility::Public,\n+            span: self.lazy(&macro_def.span),\n             def_key: self.encode_def_key(def_id),\n \n-            attributes: LazySeq::empty(),\n+            attributes: self.encode_attributes(&macro_def.attrs),\n             children: LazySeq::empty(),\n             stability: None,\n             deprecation: None,\n@@ -960,6 +964,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Entry {\n             kind: kind,\n             visibility: nitem.vis.simplify(),\n+            span: self.lazy(&nitem.span),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&nitem.attrs),\n             children: LazySeq::empty(),\n@@ -1038,9 +1043,11 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_anon_ty(&mut self, def_id: DefId) -> Entry<'tcx> {\n+        let tcx = self.tcx;\n         Entry {\n             kind: EntryKind::Type,\n             visibility: ty::Visibility::Public,\n+            span: self.lazy(&tcx.def_span(def_id)),\n             def_key: self.encode_def_key(def_id),\n             attributes: LazySeq::empty(),\n             children: LazySeq::empty(),\n@@ -1069,6 +1076,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Entry {\n             kind: EntryKind::Closure(self.lazy(&data)),\n             visibility: ty::Visibility::Public,\n+            span: self.lazy(&tcx.def_span(def_id)),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n             children: LazySeq::empty(),\n@@ -1163,11 +1171,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let all_filemaps = codemap.files.borrow();\n         self.lazy_seq_ref(all_filemaps.iter()\n             .filter(|filemap| {\n-                // No need to export empty filemaps, as they can't contain spans\n-                // that need translation.\n-                // Also no need to re-export imported filemaps, as any downstream\n+                // No need to re-export imported filemaps, as any downstream\n                 // crate will import them from their original source.\n-                !filemap.lines.borrow().is_empty() && !filemap.is_imported()\n+                !filemap.is_imported()\n             })\n             .map(|filemap| &**filemap))\n     }"}, {"sha": "c2acb2e0d7002694911b5906d8d5e384402addd4", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -197,18 +197,11 @@ pub struct TraitImpls {\n     pub impls: LazySeq<DefIndex>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct MacroDef {\n-    pub name: ast::Name,\n-    pub attrs: Vec<ast::Attribute>,\n-    pub span: Span,\n-    pub body: String,\n-}\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Entry<'tcx> {\n     pub kind: EntryKind<'tcx>,\n     pub visibility: ty::Visibility,\n+    pub span: Lazy<Span>,\n     pub def_key: Lazy<hir::map::DefKey>,\n     pub attributes: LazySeq<ast::Attribute>,\n     pub children: LazySeq<DefIndex>,\n@@ -257,6 +250,11 @@ pub struct ModData {\n     pub reexports: LazySeq<def::Export>,\n }\n \n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct MacroDef {\n+    pub body: String,\n+}\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct FnData {\n     pub constness: hir::Constness,"}, {"sha": "521dd7530beeabcbf79d1a663091a777235c966b", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -69,7 +69,7 @@ pub fn item_namespace(ccx: &CrateContext, def_id: DefId) -> DIScope {\n     };\n \n     let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n-    let span = ccx.tcx().map.def_id_span(def_id, DUMMY_SP);\n+    let span = ccx.tcx().def_span(def_id);\n     let (file, line) = if span != DUMMY_SP {\n         let loc = span_start(ccx, span);\n         (file_metadata(ccx, &loc.file.name, &loc.file.abs_path), loc.line as c_uint)"}, {"sha": "7cac9172a9c8b18975ef6ad3233b77e1bf048d8f", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -79,7 +79,7 @@ pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: DefId)\n     });\n \n     // Try to get some span information, if we have an inlined item.\n-    let definition_span = cx.tcx().map.def_id_span(def_id, syntax_pos::DUMMY_SP);\n+    let definition_span = cx.tcx().def_span(def_id);\n \n     (containing_scope, definition_span)\n }"}, {"sha": "032ad6efe1f0fdb3f55d744f53c772710b88f423", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -1227,8 +1227,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 self.tcx().associated_items(b.def_id()).find(|item| {\n                     item.kind == ty::AssociatedKind::Type && item.name == assoc_name\n                 })\n-                .and_then(|item| self.tcx().map.as_local_node_id(item.def_id))\n-                .and_then(|node_id| self.tcx().map.opt_span(node_id))\n+                .and_then(|item| self.tcx().map.span_if_local(item.def_id))\n             });\n \n             let mut err = struct_span_err!("}, {"sha": "1a5dfc8797ed0df7568662a30dc2a3eb2ae6db9c", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -21,7 +21,7 @@ use rustc::traits::{self, ObligationCause, Reveal};\n use util::nodemap::FxHashSet;\n \n use syntax::ast;\n-use syntax_pos::{self, Span};\n+use syntax_pos::Span;\n \n /// check_drop_impl confirms that the Drop implementation identfied by\n /// `drop_impl_did` is not any more specialized than the type it is\n@@ -59,7 +59,7 @@ pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()>\n         _ => {\n             // Destructors only work on nominal types.  This was\n             // already checked by coherence, so we can panic here.\n-            let span = ccx.tcx.map.def_id_span(drop_impl_did, syntax_pos::DUMMY_SP);\n+            let span = ccx.tcx.def_span(drop_impl_did);\n             span_bug!(span,\n                       \"should have been rejected by coherence check: {}\",\n                       dtor_self_type);\n@@ -88,7 +88,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         let named_type = tcx.item_type(self_type_did);\n         let named_type = named_type.subst(tcx, &infcx.parameter_environment.free_substs);\n \n-        let drop_impl_span = tcx.map.def_id_span(drop_impl_did, syntax_pos::DUMMY_SP);\n+        let drop_impl_span = tcx.def_span(drop_impl_did);\n         let fresh_impl_substs =\n             infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n@@ -173,7 +173,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n \n     let self_type_node_id = tcx.map.as_local_node_id(self_type_did).unwrap();\n \n-    let drop_impl_span = tcx.map.def_id_span(drop_impl_did, syntax_pos::DUMMY_SP);\n+    let drop_impl_span = tcx.def_span(drop_impl_did);\n \n     // We can assume the predicates attached to struct/enum definition\n     // hold."}, {"sha": "7cfefefc0d964fdbe0d8edc240dae215c26670d0", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -124,7 +124,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     CandidateSource::TraitSource(trait_did) => {\n                         let item = self.associated_item(trait_did, item_name).unwrap();\n-                        let item_span = self.tcx.map.def_id_span(item.def_id, span);\n+                        let item_span = self.tcx.def_span(item.def_id);\n                         span_note!(err,\n                                    item_span,\n                                    \"candidate #{} is defined in the trait `{}`\","}, {"sha": "8d51f52e9986e2234d6e53c39424a73de783d073", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -1755,7 +1755,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let item_predicates = self.tcx.item_predicates(def_id);\n                 let bounds = item_predicates.instantiate(self.tcx, substs);\n \n-                let span = self.tcx.map.def_id_span(def_id, codemap::DUMMY_SP);\n+                let span = self.tcx.def_span(def_id);\n                 for predicate in bounds.predicates {\n                     // Change the predicate to refer to the type variable,\n                     // which will be the concrete type, instead of the TyAnon."}, {"sha": "b041fb41abf95f529655c4fc1c4931ade831fe02", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -183,7 +183,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                     fcx.register_wf_obligation(ty, span, code.clone());\n                 }\n                 ty::AssociatedKind::Method => {\n-                    reject_shadowing_type_parameters(fcx.tcx, span, item.def_id);\n+                    reject_shadowing_type_parameters(fcx.tcx, item.def_id);\n                     let method_ty = fcx.tcx.item_type(item.def_id);\n                     let method_ty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n                     let predicates = fcx.instantiate_bounds(span, item.def_id, free_substs);\n@@ -576,7 +576,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n     }\n }\n \n-fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, def_id: DefId) {\n+fn reject_shadowing_type_parameters(tcx: TyCtxt, def_id: DefId) {\n     let generics = tcx.item_generics(def_id);\n     let parent = tcx.item_generics(generics.parent.unwrap());\n     let impl_params: FxHashMap<_, _> = parent.types\n@@ -587,17 +587,12 @@ fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, def_id: DefId) {\n     for method_param in &generics.types {\n         if impl_params.contains_key(&method_param.name) {\n             // Tighten up the span to focus on only the shadowing type\n-            let shadow_node_id = tcx.map.as_local_node_id(method_param.def_id).unwrap();\n-            let type_span = match tcx.map.opt_span(shadow_node_id) {\n-                Some(osp) => osp,\n-                None => span\n-            };\n+            let type_span = tcx.def_span(method_param.def_id);\n \n             // The expectation here is that the original trait declaration is\n             // local so it should be okay to just unwrap everything.\n-            let trait_def_id = impl_params.get(&method_param.name).unwrap();\n-            let trait_node_id = tcx.map.as_local_node_id(*trait_def_id).unwrap();\n-            let trait_decl_span = tcx.map.opt_span(trait_node_id).unwrap();\n+            let trait_def_id = impl_params[&method_param.name];\n+            let trait_decl_span = tcx.def_span(trait_def_id);\n             error_194(tcx, type_span, trait_decl_span, method_param.name);\n         }\n     }"}, {"sha": "56de75995fd2e820bc4929c1a74eeb51ebbaa82f", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -24,7 +24,7 @@ use rustc::util::nodemap::DefIdMap;\n use std::cell::Cell;\n \n use syntax::ast;\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::Span;\n \n use rustc::hir::print::pat_to_string;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -542,7 +542,7 @@ impl<'a, 'gcx, 'tcx> ResolveReason {\n             }\n             ResolvingClosure(did) |\n             ResolvingAnonTy(did) => {\n-                tcx.map.def_id_span(did, DUMMY_SP)\n+                tcx.def_span(did)\n             }\n             ResolvingDeferredObligation(span) => span\n         }"}, {"sha": "bf739abe3da0dc65134672eb5d6b3ad1b324e0db", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -115,7 +115,7 @@ fn try_inline_def(cx: &DocContext, def: Def) -> Option<Vec<clean::Item>> {\n     let did = def.def_id();\n     cx.renderinfo.borrow_mut().inlined.insert(did);\n     ret.push(clean::Item {\n-        source: clean::Span::empty(),\n+        source: tcx.def_span(did).clean(cx),\n         name: Some(tcx.item_name(did).to_string()),\n         attrs: load_attrs(cx, did),\n         inner: inner,\n@@ -321,7 +321,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n                     clean::RegionBound(..) => unreachable!(),\n                 },\n             }),\n-            source: clean::Span::empty(),\n+            source: tcx.def_span(did).clean(cx),\n             name: None,\n             attrs: attrs,\n             visibility: Some(clean::Inherited),\n@@ -357,7 +357,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n                         tcx.item_type(item.def_id).clean(cx),\n                         default,\n                     ),\n-                    source: clean::Span::empty(),\n+                    source: tcx.def_span(item.def_id).clean(cx),\n                     attrs: clean::Attributes::default(),\n                     visibility: None,\n                     stability: tcx.lookup_stability(item.def_id).clean(cx),\n@@ -404,7 +404,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n                 Some(clean::Item {\n                     name: Some(item.name.clean(cx)),\n                     inner: clean::TypedefItem(typedef, true),\n-                    source: clean::Span::empty(),\n+                    source: tcx.def_span(item.def_id).clean(cx),\n                     attrs: clean::Attributes::default(),\n                     visibility: None,\n                     stability: tcx.lookup_stability(item.def_id).clean(cx),\n@@ -442,7 +442,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n             items: trait_items,\n             polarity: Some(polarity.clean(cx)),\n         }),\n-        source: clean::Span::empty(),\n+        source: tcx.def_span(did).clean(cx),\n         name: None,\n         attrs: attrs,\n         visibility: Some(clean::Inherited),"}, {"sha": "7f8be4d633144336fef95b8e3e8e52f830333e9e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 82, "deletions": 93, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -27,12 +27,11 @@ use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::{self, DUMMY_SP, Pos};\n \n-use rustc_trans::back::link;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::resolve_lifetime::DefRegion::*;\n use rustc::middle::lang_items;\n use rustc::hir::def::{Def, CtorKind};\n-use rustc::hir::def_id::{self, DefId, DefIndex, CRATE_DEF_INDEX};\n+use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::print as pprust;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind};\n@@ -46,7 +45,6 @@ use std::rc::Rc;\n use std::slice;\n use std::sync::Arc;\n use std::u32;\n-use std::env::current_dir;\n use std::mem;\n \n use core::DocContext;\n@@ -111,19 +109,16 @@ pub struct Crate {\n     pub name: String,\n     pub src: PathBuf,\n     pub module: Option<Item>,\n-    pub externs: Vec<(def_id::CrateNum, ExternalCrate)>,\n-    pub primitives: Vec<PrimitiveType>,\n+    pub externs: Vec<(CrateNum, ExternalCrate)>,\n+    pub primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n     pub access_levels: Arc<AccessLevels<DefId>>,\n     // These are later on moved into `CACHEKEY`, leaving the map empty.\n     // Only here so that they can be filtered through the rustdoc passes.\n     pub external_traits: FxHashMap<DefId, Trait>,\n }\n \n-struct CrateNum(def_id::CrateNum);\n-\n impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n     fn clean(&self, cx: &DocContext) -> Crate {\n-        use rustc::session::config::Input;\n         use ::visit_lib::LibEmbargoVisitor;\n \n         {\n@@ -134,83 +129,41 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n \n         let mut externs = Vec::new();\n         for cnum in cx.sess().cstore.crates() {\n-            externs.push((cnum, CrateNum(cnum).clean(cx)));\n+            externs.push((cnum, cnum.clean(cx)));\n             // Analyze doc-reachability for extern items\n             LibEmbargoVisitor::new(cx).visit_lib(cnum);\n         }\n         externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n-        // Figure out the name of this crate\n-        let input = &cx.input;\n-        let name = link::find_crate_name(None, &self.attrs, input);\n-\n         // Clean the crate, translating the entire libsyntax AST to one that is\n         // understood by rustdoc.\n         let mut module = self.module.clean(cx);\n \n-        // Collect all inner modules which are tagged as implementations of\n-        // primitives.\n-        //\n-        // Note that this loop only searches the top-level items of the crate,\n-        // and this is intentional. If we were to search the entire crate for an\n-        // item tagged with `#[doc(primitive)]` then we would also have to\n-        // search the entirety of external modules for items tagged\n-        // `#[doc(primitive)]`, which is a pretty inefficient process (decoding\n-        // all that metadata unconditionally).\n-        //\n-        // In order to keep the metadata load under control, the\n-        // `#[doc(primitive)]` feature is explicitly designed to only allow the\n-        // primitive tags to show up as the top level items in a crate.\n-        //\n-        // Also note that this does not attempt to deal with modules tagged\n-        // duplicately for the same primitive. This is handled later on when\n-        // rendering by delegating everything to a hash map.\n-        let mut primitives = Vec::new();\n+        let ExternalCrate { name, src, primitives, .. } = LOCAL_CRATE.clean(cx);\n         {\n             let m = match module.inner {\n                 ModuleItem(ref mut m) => m,\n                 _ => unreachable!(),\n             };\n-            let mut tmp = Vec::new();\n-            for child in &mut m.items {\n-                if !child.is_mod() {\n-                    continue;\n-                }\n-                let prim = match PrimitiveType::find(&child.attrs) {\n-                    Some(prim) => prim,\n-                    None => continue,\n-                };\n-                primitives.push(prim);\n-                tmp.push(Item {\n+            m.items.extend(primitives.iter().map(|&(def_id, prim, ref attrs)| {\n+                Item {\n                     source: Span::empty(),\n                     name: Some(prim.to_url_str().to_string()),\n-                    attrs: child.attrs.clone(),\n+                    attrs: attrs.clone(),\n                     visibility: Some(Public),\n                     stability: None,\n                     deprecation: None,\n-                    def_id: DefId::local(prim.to_def_index()),\n+                    def_id: def_id,\n                     inner: PrimitiveItem(prim),\n-                });\n-            }\n-            m.items.extend(tmp);\n-        }\n-\n-        let src = match cx.input {\n-            Input::File(ref path) => {\n-                if path.is_absolute() {\n-                    path.clone()\n-                } else {\n-                    current_dir().unwrap().join(path)\n                 }\n-            },\n-            Input::Str { ref name, .. } => PathBuf::from(name.clone()),\n-        };\n+            }));\n+        }\n \n         let mut access_levels = cx.access_levels.borrow_mut();\n         let mut external_traits = cx.external_traits.borrow_mut();\n \n         Crate {\n-            name: name.to_string(),\n+            name: name,\n             src: src,\n             module: Some(module),\n             externs: externs,\n@@ -224,21 +177,78 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ExternalCrate {\n     pub name: String,\n+    pub src: PathBuf,\n     pub attrs: Attributes,\n-    pub primitives: Vec<PrimitiveType>,\n+    pub primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n }\n \n impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &DocContext) -> ExternalCrate {\n-        let mut primitives = Vec::new();\n-        let root = DefId { krate: self.0, index: CRATE_DEF_INDEX };\n-        for item in cx.tcx.sess.cstore.item_children(root) {\n-            let attrs = inline::load_attrs(cx, item.def.def_id());\n-            PrimitiveType::find(&attrs).map(|prim| primitives.push(prim));\n-        }\n+        let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n+        let krate_span = cx.tcx.def_span(root);\n+        let krate_src = cx.sess().codemap().span_to_filename(krate_span);\n+\n+        // Collect all inner modules which are tagged as implementations of\n+        // primitives.\n+        //\n+        // Note that this loop only searches the top-level items of the crate,\n+        // and this is intentional. If we were to search the entire crate for an\n+        // item tagged with `#[doc(primitive)]` then we would also have to\n+        // search the entirety of external modules for items tagged\n+        // `#[doc(primitive)]`, which is a pretty inefficient process (decoding\n+        // all that metadata unconditionally).\n+        //\n+        // In order to keep the metadata load under control, the\n+        // `#[doc(primitive)]` feature is explicitly designed to only allow the\n+        // primitive tags to show up as the top level items in a crate.\n+        //\n+        // Also note that this does not attempt to deal with modules tagged\n+        // duplicately for the same primitive. This is handled later on when\n+        // rendering by delegating everything to a hash map.\n+        let as_primitive = |def: Def| {\n+            if let Def::Mod(def_id) = def {\n+                let attrs = cx.tcx.get_attrs(def_id).clean(cx);\n+                let mut prim = None;\n+                for attr in attrs.lists(\"doc\") {\n+                    if let Some(v) = attr.value_str() {\n+                        if attr.check_name(\"primitive\") {\n+                            prim = PrimitiveType::from_str(&v.as_str());\n+                            if prim.is_some() {\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+                return prim.map(|p| (def_id, p, attrs));\n+            }\n+            None\n+        };\n+        let primitives = if root.is_local() {\n+            cx.tcx.map.krate().module.item_ids.iter().filter_map(|&id| {\n+                let item = cx.tcx.map.expect_item(id.id);\n+                match item.node {\n+                    hir::ItemMod(_) => {\n+                        as_primitive(Def::Mod(cx.tcx.map.local_def_id(id.id)))\n+                    }\n+                    hir::ItemUse(ref path, hir::UseKind::Single)\n+                    if item.vis == hir::Visibility::Public => {\n+                        as_primitive(path.def).map(|(_, prim, attrs)| {\n+                            // Pretend the primitive is local.\n+                            (cx.tcx.map.local_def_id(id.id), prim, attrs)\n+                        })\n+                    }\n+                    _ => None\n+                }\n+            }).collect()\n+        } else {\n+            cx.tcx.sess.cstore.item_children(root).iter().map(|item| item.def)\n+              .filter_map(as_primitive).collect()\n+        };\n+\n         ExternalCrate {\n-            name: cx.sess().cstore.crate_name(self.0).to_string(),\n-            attrs: cx.sess().cstore.item_attrs(root).clean(cx),\n+            name: cx.tcx.crate_name(*self).to_string(),\n+            src: PathBuf::from(krate_src),\n+            attrs: cx.tcx.get_attrs(root).clean(cx),\n             primitives: primitives,\n         }\n     }\n@@ -1438,7 +1448,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n             deprecation: get_deprecation(cx, self.def_id),\n             def_id: self.def_id,\n             attrs: inline::load_attrs(cx, self.def_id),\n-            source: Span::empty(),\n+            source: cx.tcx.def_span(self.def_id).clean(cx),\n             inner: inner,\n         }\n     }\n@@ -1596,19 +1606,6 @@ impl PrimitiveType {\n         }\n     }\n \n-    fn find(attrs: &Attributes) -> Option<PrimitiveType> {\n-        for attr in attrs.lists(\"doc\") {\n-            if let Some(v) = attr.value_str() {\n-                if attr.check_name(\"primitive\") {\n-                    if let ret@Some(..) = PrimitiveType::from_str(&v.as_str()) {\n-                        return ret;\n-                    }\n-                }\n-            }\n-        }\n-        None\n-    }\n-\n     pub fn as_str(&self) -> &'static str {\n         match *self {\n             PrimitiveType::Isize => \"isize\",\n@@ -1636,14 +1633,6 @@ impl PrimitiveType {\n     pub fn to_url_str(&self) -> &'static str {\n         self.as_str()\n     }\n-\n-    /// Creates a rustdoc-specific node id for primitive types.\n-    ///\n-    /// These node ids are generally never used by the AST itself.\n-    pub fn to_def_index(&self) -> DefIndex {\n-        let x = u32::MAX - 1 - (*self as u32);\n-        DefIndex::new(x as usize)\n-    }\n }\n \n impl From<ast::IntTy> for PrimitiveType {\n@@ -1943,7 +1932,7 @@ impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n         Item {\n             name: Some(self.name).clean(cx),\n             attrs: cx.tcx.get_attrs(self.did).clean(cx),\n-            source: Span::empty(),\n+            source: cx.tcx.def_span(self.did).clean(cx),\n             visibility: self.vis.clean(cx),\n             stability: get_stability(cx, self.did),\n             deprecation: get_deprecation(cx, self.did),\n@@ -2110,7 +2099,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n                     fields_stripped: false,\n                     fields: self.fields.iter().map(|field| {\n                         Item {\n-                            source: Span::empty(),\n+                            source: cx.tcx.def_span(field.did).clean(cx),\n                             name: Some(field.name.clean(cx)),\n                             attrs: cx.tcx.get_attrs(field.did).clean(cx),\n                             visibility: field.vis.clean(cx),\n@@ -2126,7 +2115,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: inline::load_attrs(cx, self.did),\n-            source: Span::empty(),\n+            source: cx.tcx.def_span(self.did).clean(cx),\n             visibility: Some(Inherited),\n             def_id: self.did,\n             inner: VariantItem(Variant { kind: kind }),"}, {"sha": "df25473ddd91666640bcaabc9e22a14181b1c48f", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -45,7 +45,6 @@ pub type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n \n pub struct DocContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pub input: Input,\n     pub populated_all_crate_impls: Cell<bool>,\n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n@@ -187,7 +186,6 @@ pub fn run_core(search_paths: SearchPaths,\n \n         let ctxt = DocContext {\n             tcx: tcx,\n-            input: input,\n             populated_all_crate_impls: Cell::new(false),\n             access_levels: RefCell::new(access_levels),\n             external_traits: Default::default(),"}, {"sha": "6dc6e80dae0b81fb926e5238e145fedcb07704ce", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -18,7 +18,7 @@\n use std::fmt;\n use std::iter::repeat;\n \n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::DefId;\n use syntax::abi::Abi;\n use rustc::hir;\n \n@@ -403,9 +403,9 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n         None => match cache.external_paths.get(&did) {\n             Some(&(ref fqp, shortty)) => {\n                 (fqp, shortty, match cache.extern_locations[&did.krate] {\n-                    (_, render::Remote(ref s)) => s.to_string(),\n-                    (_, render::Local) => repeat(\"../\").take(loc.len()).collect(),\n-                    (_, render::Unknown) => return None,\n+                    (.., render::Remote(ref s)) => s.to_string(),\n+                    (.., render::Local) => repeat(\"../\").take(loc.len()).collect(),\n+                    (.., render::Unknown) => return None,\n                 })\n             }\n             None => return None,\n@@ -479,22 +479,24 @@ fn primitive_link(f: &mut fmt::Formatter,\n     let mut needs_termination = false;\n     if !f.alternate() {\n         match m.primitive_locations.get(&prim) {\n-            Some(&LOCAL_CRATE) => {\n+            Some(&def_id) if def_id.is_local() => {\n                 let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n                 let len = if len == 0 {0} else {len - 1};\n                 write!(f, \"<a class='primitive' href='{}primitive.{}.html'>\",\n                        repeat(\"../\").take(len).collect::<String>(),\n                        prim.to_url_str())?;\n                 needs_termination = true;\n             }\n-            Some(&cnum) => {\n-                let loc = match m.extern_locations[&cnum] {\n-                    (ref cname, render::Remote(ref s)) => Some((cname, s.to_string())),\n-                    (ref cname, render::Local) => {\n+            Some(&def_id) => {\n+                let loc = match m.extern_locations[&def_id.krate] {\n+                    (ref cname, _, render::Remote(ref s)) => {\n+                        Some((cname, s.to_string()))\n+                    }\n+                    (ref cname, _, render::Local) => {\n                         let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n                         Some((cname, repeat(\"../\").take(len).collect::<String>()))\n                     }\n-                    (_, render::Unknown) => None,\n+                    (.., render::Unknown) => None,\n                 };\n                 if let Some((cname, root)) = loc {\n                     write!(f, \"<a class='primitive' href='{}{}/primitive.{}.html'>\","}, {"sha": "cbf93662811da6ee046cf69269cb93e0dbbc36fe", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 70, "deletions": 96, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -55,7 +55,7 @@ use externalfiles::ExternalHtml;\n use serialize::json::{ToJson, Json, as_json};\n use syntax::{abi, ast};\n use syntax::feature_gate::UnstableFeatures;\n-use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n use rustc::hir;\n@@ -241,10 +241,10 @@ pub struct Cache {\n     pub implementors: FxHashMap<DefId, Vec<Implementor>>,\n \n     /// Cache of where external crate documentation can be found.\n-    pub extern_locations: FxHashMap<CrateNum, (String, ExternalLocation)>,\n+    pub extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n \n     /// Cache of where documentation for primitives can be found.\n-    pub primitive_locations: FxHashMap<clean::PrimitiveType, CrateNum>,\n+    pub primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n \n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n@@ -523,8 +523,13 @@ pub fn run(mut krate: clean::Crate,\n \n     // Cache where all our extern crates are located\n     for &(n, ref e) in &krate.externs {\n-        cache.extern_locations.insert(n, (e.name.clone(),\n+        let src_root = match Path::new(&e.src).parent() {\n+            Some(p) => p.to_path_buf(),\n+            None => PathBuf::new(),\n+        };\n+        cache.extern_locations.insert(n, (e.name.clone(), src_root,\n                                           extern_location(e, &cx.dst)));\n+\n         let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n         cache.external_paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n     }\n@@ -533,13 +538,13 @@ pub fn run(mut krate: clean::Crate,\n     //\n     // Favor linking to as local extern as possible, so iterate all crates in\n     // reverse topological order.\n-    for &(n, ref e) in krate.externs.iter().rev() {\n-        for &prim in &e.primitives {\n-            cache.primitive_locations.insert(prim, n);\n+    for &(_, ref e) in krate.externs.iter().rev() {\n+        for &(def_id, prim, _) in &e.primitives {\n+            cache.primitive_locations.insert(prim, def_id);\n         }\n     }\n-    for &prim in &krate.primitives {\n-        cache.primitive_locations.insert(prim, LOCAL_CRATE);\n+    for &(def_id, prim, _) in &krate.primitives {\n+        cache.primitive_locations.insert(prim, def_id);\n     }\n \n     cache.stack.push(krate.name.clone());\n@@ -875,6 +880,8 @@ impl<'a> DocFolder for SourceCollector<'a> {\n         if self.scx.include_sources\n             // skip all invalid spans\n             && item.source.filename != \"\"\n+            // skip non-local items\n+            && item.def_id.is_local()\n             // Macros from other libraries get special filenames which we can\n             // safely ignore.\n             && !(item.source.filename.starts_with(\"<\")\n@@ -1127,13 +1134,15 @@ impl DocFolder for Cache {\n                         true\n                     }\n                     ref t => {\n-                        match t.primitive_type() {\n-                            Some(prim) => {\n-                                let did = DefId::local(prim.to_def_index());\n+                        let prim_did = t.primitive_type().and_then(|t| {\n+                            self.primitive_locations.get(&t).cloned()\n+                        });\n+                        match prim_did {\n+                            Some(did) => {\n                                 self.parent_stack.push(did);\n                                 true\n                             }\n-                            _ => false,\n+                            None => false,\n                         }\n                     }\n                 }\n@@ -1158,10 +1167,7 @@ impl DocFolder for Cache {\n                         }\n                         ref t => {\n                             t.primitive_type().and_then(|t| {\n-                                self.primitive_locations.get(&t).map(|n| {\n-                                    let id = t.to_def_index();\n-                                    DefId { krate: *n, index: id }\n-                                })\n+                                self.primitive_locations.get(&t).cloned()\n                             })\n                         }\n                     }\n@@ -1439,79 +1445,50 @@ impl<'a> Item<'a> {\n     /// If `None` is returned, then a source link couldn't be generated. This\n     /// may happen, for example, with externally inlined items where the source\n     /// of their crate documentation isn't known.\n-    fn href(&self) -> Option<String> {\n-        let href = if self.item.source.loline == self.item.source.hiline {\n-            format!(\"{}\", self.item.source.loline)\n-        } else {\n-            format!(\"{}-{}\", self.item.source.loline, self.item.source.hiline)\n-        };\n+    fn src_href(&self) -> Option<String> {\n+        let mut root = self.cx.root_path();\n \n-        // First check to see if this is an imported macro source. In this case\n-        // we need to handle it specially as cross-crate inlined macros have...\n-        // odd locations!\n-        let imported_macro_from = match self.item.inner {\n-            clean::MacroItem(ref m) => m.imported_from.as_ref(),\n-            _ => None,\n-        };\n-        if let Some(krate) = imported_macro_from {\n-            let cache = cache();\n-            let root = cache.extern_locations.values().find(|&&(ref n, _)| {\n-                *krate == *n\n-            }).map(|l| &l.1);\n-            let root = match root {\n-                Some(&Remote(ref s)) => s.to_string(),\n-                Some(&Local) => self.cx.root_path(),\n-                None | Some(&Unknown) => return None,\n-            };\n-            Some(format!(\"{root}/{krate}/macro.{name}.html?gotomacrosrc=1\",\n-                         root = root,\n-                         krate = krate,\n-                         name = self.item.name.as_ref().unwrap()))\n-\n-        // If this item is part of the local crate, then we're guaranteed to\n-        // know the span, so we plow forward and generate a proper url. The url\n-        // has anchors for the line numbers that we're linking to.\n-        } else if self.item.def_id.is_local() {\n+        let cache = cache();\n+        let mut path = String::new();\n+        let (krate, path) = if self.item.def_id.is_local() {\n             let path = PathBuf::from(&self.item.source.filename);\n-            self.cx.shared.local_sources.get(&path).map(|path| {\n-                format!(\"{root}src/{krate}/{path}#{href}\",\n-                        root = self.cx.root_path(),\n-                        krate = self.cx.shared.layout.krate,\n-                        path = path,\n-                        href = href)\n-            })\n-        // If this item is not part of the local crate, then things get a little\n-        // trickier. We don't actually know the span of the external item, but\n-        // we know that the documentation on the other end knows the span!\n-        //\n-        // In this case, we generate a link to the *documentation* for this type\n-        // in the original crate. There's an extra URL parameter which says that\n-        // we want to go somewhere else, and the JS on the destination page will\n-        // pick it up and instantly redirect the browser to the source code.\n-        //\n-        // If we don't know where the external documentation for this crate is\n-        // located, then we return `None`.\n+            if let Some(path) = self.cx.shared.local_sources.get(&path) {\n+                (&self.cx.shared.layout.krate, path)\n+            } else {\n+                return None;\n+            }\n         } else {\n-            let cache = cache();\n-            let external_path = match cache.external_paths.get(&self.item.def_id) {\n-                Some(&(ref path, _)) => path,\n-                None => return None,\n-            };\n-            let mut path = match cache.extern_locations.get(&self.item.def_id.krate) {\n-                Some(&(_, Remote(ref s))) => s.to_string(),\n-                Some(&(_, Local)) => self.cx.root_path(),\n-                Some(&(_, Unknown)) => return None,\n-                None => return None,\n+            let (krate, src_root) = match cache.extern_locations.get(&self.item.def_id.krate) {\n+                Some(&(ref name, ref src, Local)) => (name, src),\n+                Some(&(ref name, ref src, Remote(ref s))) => {\n+                    root = s.to_string();\n+                    (name, src)\n+                }\n+                Some(&(_, _, Unknown)) | None => return None,\n             };\n-            for item in &external_path[..external_path.len() - 1] {\n-                path.push_str(item);\n-                path.push_str(\"/\");\n-            }\n-            Some(format!(\"{path}{file}?gotosrc={goto}\",\n-                         path = path,\n-                         file = item_path(self.item.type_(), external_path.last().unwrap()),\n-                         goto = self.item.def_id.index.as_usize()))\n-        }\n+\n+            let file = Path::new(&self.item.source.filename);\n+            clean_srcpath(&src_root, file, false, |component| {\n+                path.push_str(component);\n+                path.push('/');\n+            });\n+            let mut fname = file.file_name().expect(\"source has no filename\")\n+                                .to_os_string();\n+            fname.push(\".html\");\n+            path.push_str(&fname.to_string_lossy());\n+            (krate, &path)\n+        };\n+\n+        let lines = if self.item.source.loline == self.item.source.hiline {\n+            format!(\"{}\", self.item.source.loline)\n+        } else {\n+            format!(\"{}-{}\", self.item.source.loline, self.item.source.hiline)\n+        };\n+        Some(format!(\"{root}src/{krate}/{path}#{lines}\",\n+                     root = root,\n+                     krate = krate,\n+                     path = path,\n+                     lines = lines))\n     }\n }\n \n@@ -1576,10 +1553,9 @@ impl<'a> fmt::Display for Item<'a> {\n         // this page, and this link will be auto-clicked. The `id` attribute is\n         // used to find the link to auto-click.\n         if self.cx.shared.include_sources && !self.item.is_primitive() {\n-            if let Some(l) = self.href() {\n-                write!(fmt, \"<a id='src-{}' class='srclink' \\\n-                              href='{}' title='{}'>[src]</a>\",\n-                       self.item.def_id.index.as_usize(), l, \"goto source code\")?;\n+            if let Some(l) = self.src_href() {\n+                write!(fmt, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n+                       l, \"goto source code\")?;\n             }\n         }\n \n@@ -2781,8 +2757,7 @@ fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl,\n         render_assoc_items(w, cx, container_item, did, what)\n     } else {\n         if let Some(prim) = target.primitive_type() {\n-            if let Some(c) = cache().primitive_locations.get(&prim) {\n-                let did = DefId { krate: *c, index: prim.to_def_index() };\n+            if let Some(&did) = cache().primitive_locations.get(&prim) {\n                 render_assoc_items(w, cx, container_item, did, what)?;\n             }\n         }\n@@ -2796,12 +2771,11 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         write!(w, \"<h3 class='impl'><span class='in-band'><code>{}</code>\", i.inner_impl())?;\n         write!(w, \"</span><span class='out-of-band'>\")?;\n         let since = i.impl_item.stability.as_ref().map(|s| &s.since[..]);\n-        if let Some(l) = (Item { item: &i.impl_item, cx: cx }).href() {\n+        if let Some(l) = (Item { item: &i.impl_item, cx: cx }).src_href() {\n             write!(w, \"<div class='ghost'></div>\")?;\n             render_stability_since_raw(w, since, outer_version)?;\n-            write!(w, \"<a id='src-{}' class='srclink' \\\n-                       href='{}' title='{}'>[src]</a>\",\n-                   i.impl_item.def_id.index.as_usize(), l, \"goto source code\")?;\n+            write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n+                   l, \"goto source code\")?;\n         } else {\n             render_stability_since_raw(w, since, outer_version)?;\n         }"}, {"sha": "6ea25fa1241f8c447c9e845f87dab6a1de786672", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -923,15 +923,6 @@\n         window.register_implementors(window.pending_implementors);\n     }\n \n-    // See documentation in html/render.rs for what this is doing.\n-    var query = getQueryStringParams();\n-    if (query['gotosrc']) {\n-        window.location = $('#src-' + query['gotosrc']).attr('href');\n-    }\n-    if (query['gotomacrosrc']) {\n-        window.location = $('.srclink').attr('href');\n-    }\n-\n     function labelForToggleButton(sectionIsCollapsed) {\n         if (sectionIsCollapsed) {\n             // button will expand the section"}, {"sha": "12f880421616f513810adc561fffd23cc84fe310", "filename": "src/test/rustdoc/issue-34274.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Ftest%2Frustdoc%2Fissue-34274.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Ftest%2Frustdoc%2Fissue-34274.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-34274.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -16,5 +16,5 @@\n \n extern crate issue_34274;\n \n-// @has foo/fn.extern_c_fn.html '//a/@href' '../issue_34274/fn.extern_c_fn.html?gotosrc='\n+// @has foo/fn.extern_c_fn.html '//a/@href' '../src/issue_34274/issue-34274.rs.html#12'\n pub use issue_34274::extern_c_fn;"}, {"sha": "d3307bb4d42c1076f23e1df42d9f9c4392bafb38", "filename": "src/test/rustdoc/src-links-external.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3abaf43f770a8bae23da474690e3841041219029/src%2Ftest%2Frustdoc%2Fsrc-links-external.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abaf43f770a8bae23da474690e3841041219029/src%2Ftest%2Frustdoc%2Fsrc-links-external.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsrc-links-external.rs?ref=3abaf43f770a8bae23da474690e3841041219029", "patch": "@@ -11,12 +11,13 @@\n // aux-build:src-links-external.rs\n // build-aux-docs\n // ignore-cross-compile\n+// ignore-tidy-linelength\n \n #![crate_name = \"foo\"]\n \n extern crate src_links_external;\n \n-// @has foo/bar/index.html '//a/@href' '../src_links_external/index.html?gotosrc='\n+// @has foo/bar/index.html '//a/@href' '../../src/src_links_external/src-links-external.rs.html#11'\n pub use src_links_external as bar;\n \n-// @has foo/bar/struct.Foo.html '//a/@href' '../src_links_external/struct.Foo.html?gotosrc='\n+// @has foo/bar/struct.Foo.html '//a/@href' '../../src/src_links_external/src-links-external.rs.html#11'"}]}