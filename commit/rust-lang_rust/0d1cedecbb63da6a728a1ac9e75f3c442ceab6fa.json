{"sha": "0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMWNlZGVjYmI2M2RhNmE3MjhhMWFjOWU3NWYzYzQ0MmNlYWI2ZmE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-06-25T16:33:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-25T16:33:00Z"}, "message": "Merge pull request #1166 from eggyal/lazy-jit-multithreaded\n\nMultithreading support for lazy-jit", "tree": {"sha": "f4ebe3c40d38824f87a8fc8444ff3106e9d36a71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4ebe3c40d38824f87a8fc8444ff3106e9d36a71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg1gU8CRBK7hj4Ov3rIwAAAKUIADcdiyYYhzoe4ZmylYQyB82+\n2FSVea1xcXhMH9UCSRw80eN9xPK9cafHzBGtWJ4YTDIUcGlLCMXDxoerlUzkxscl\nBBudiljZI5bRbUZdpI6HXnNX2Hlz0h6ePUu1k0OWDubD8/jxhX4JeKw8RJKX7+Eq\nqdgVEjfru5R9GTbvCY7rBCvNWnvOS6OhmDY4G5OHT6Bm0SPR3WlepOCluHa3+pH6\nH6CHrSjCL2uQznnA4OHXg+WR1cfTF2SoxduzMvf3s689mp+WUtJL+BY7pMo5ttk3\nvzOc60JVFt5O++re0Msb8UnL4xvUKmSQ1La4EQZIps6YtQ0eJB83uMBtY+s+8jw=\n=w4uu\n-----END PGP SIGNATURE-----\n", "payload": "tree f4ebe3c40d38824f87a8fc8444ff3106e9d36a71\nparent 089d986c5c9ce6237013a4842f3093e721d4f589\nparent 57c6eb7b2ba4375039d289e84e51e9e784b08f31\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1624638780 +0200\ncommitter GitHub <noreply@github.com> 1624638780 +0200\n\nMerge pull request #1166 from eggyal/lazy-jit-multithreaded\n\nMultithreading support for lazy-jit"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa", "html_url": "https://github.com/rust-lang/rust/commit/0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "089d986c5c9ce6237013a4842f3093e721d4f589", "url": "https://api.github.com/repos/rust-lang/rust/commits/089d986c5c9ce6237013a4842f3093e721d4f589", "html_url": "https://github.com/rust-lang/rust/commit/089d986c5c9ce6237013a4842f3093e721d4f589"}, {"sha": "57c6eb7b2ba4375039d289e84e51e9e784b08f31", "url": "https://api.github.com/repos/rust-lang/rust/commits/57c6eb7b2ba4375039d289e84e51e9e784b08f31", "html_url": "https://github.com/rust-lang/rust/commit/57c6eb7b2ba4375039d289e84e51e9e784b08f31"}], "stats": {"total": 117, "additions": 101, "deletions": 16}, "files": [{"sha": "956d5905a97adfbf460676559a73b32728b06b00", "filename": "docs/usage.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa/docs%2Fusage.md", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa/docs%2Fusage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fusage.md?ref=0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa", "patch": "@@ -40,8 +40,7 @@ $ $cg_clif_dir/build/bin/cg_clif -Cllvm-args=mode=jit -Cprefer-dynamic my_crate.\n ```\n \n There is also an experimental lazy jit mode. In this mode functions are only compiled once they are\n-first called. It currently does not work with multi-threaded programs. When a not yet compiled\n-function is called from another thread than the main thread, you will get an ICE.\n+first called.\n \n ```bash\n $ $cg_clif_dir/build/cargo lazy-jit"}, {"sha": "5bc51a541b58c7d63b0939976ab2d8869983d24b", "filename": "example/std_example.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa", "patch": "@@ -15,8 +15,6 @@ fn main() {\n     let stderr = ::std::io::stderr();\n     let mut stderr = stderr.lock();\n \n-    // FIXME support lazy jit when multi threading\n-    #[cfg(not(lazy_jit))]\n     std::thread::spawn(move || {\n         println!(\"Hello from another thread!\");\n     });"}, {"sha": "5df04c533a70e38fb009dec4ec62f337e0a87a38", "filename": "scripts/tests.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa/scripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa/scripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Ftests.sh?ref=0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa", "patch": "@@ -47,7 +47,7 @@ function base_sysroot_tests() {\n         $MY_RUSTC -Cllvm-args=mode=jit -Cprefer-dynamic example/std_example.rs --target \"$HOST_TRIPLE\"\n \n         echo \"[JIT-lazy] std_example\"\n-        $MY_RUSTC -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/std_example.rs --cfg lazy_jit --target \"$HOST_TRIPLE\"\n+        $MY_RUSTC -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/std_example.rs --target \"$HOST_TRIPLE\"\n     else\n         echo \"[JIT] std_example (skipped)\"\n     fi"}, {"sha": "39a39e764cb6dfe8966f6fa1d3b81cb7ee5441f1", "filename": "src/driver/jit.rs", "status": "modified", "additions": 91, "deletions": 10, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa/src%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa/src%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fjit.rs?ref=0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa", "patch": "@@ -3,7 +3,9 @@\n \n use std::cell::RefCell;\n use std::ffi::CString;\n+use std::lazy::{Lazy, SyncOnceCell};\n use std::os::raw::{c_char, c_int};\n+use std::sync::{mpsc, Mutex};\n \n use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_codegen_ssa::CrateInfo;\n@@ -23,6 +25,40 @@ thread_local! {\n     static LAZY_JIT_STATE: RefCell<Option<JitState>> = RefCell::new(None);\n }\n \n+/// The Sender owned by the rustc thread\n+static GLOBAL_MESSAGE_SENDER: SyncOnceCell<Mutex<mpsc::Sender<UnsafeMessage>>> = SyncOnceCell::new();\n+\n+/// A message that is sent from the jitted runtime to the rustc thread.\n+/// Senders are responsible for upholding `Send` semantics.\n+enum UnsafeMessage {\n+    /// Request that the specified `Instance` be lazily jitted.\n+    ///\n+    /// Nothing accessible through `instance_ptr` may be moved or mutated by the sender after\n+    /// this message is sent.\n+    JitFn {\n+        instance_ptr: *const Instance<'static>,\n+        trampoline_ptr: *const u8,\n+        tx: mpsc::Sender<*const u8>,\n+    },\n+}\n+unsafe impl Send for UnsafeMessage {}\n+\n+impl UnsafeMessage {\n+    /// Send the message.\n+    fn send(self) -> Result<(), mpsc::SendError<UnsafeMessage>> {\n+        thread_local! {\n+            /// The Sender owned by the local thread\n+            static LOCAL_MESSAGE_SENDER: Lazy<mpsc::Sender<UnsafeMessage>> = Lazy::new(||\n+                GLOBAL_MESSAGE_SENDER\n+                    .get().unwrap()\n+                    .lock().unwrap()\n+                    .clone()\n+            );\n+        }\n+        LOCAL_MESSAGE_SENDER.with(|sender| sender.send(self))\n+    }\n+}\n+\n fn create_jit_module<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     backend_config: &BackendConfig,\n@@ -116,11 +152,6 @@ pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n         .chain(backend_config.jit_args.iter().map(|arg| &**arg))\n         .map(|arg| CString::new(arg).unwrap())\n         .collect::<Vec<_>>();\n-    let mut argv = args.iter().map(|arg| arg.as_ptr()).collect::<Vec<_>>();\n-\n-    // Push a null pointer as a terminating argument. This is required by POSIX and\n-    // useful as some dynamic linkers use it as a marker to jump over.\n-    argv.push(std::ptr::null());\n \n     let start_sig = Signature {\n         params: vec![\n@@ -141,12 +172,49 @@ pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n \n     let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n         unsafe { ::std::mem::transmute(finalized_start) };\n-    let ret = f(args.len() as c_int, argv.as_ptr());\n-    std::process::exit(ret);\n+\n+    let (tx, rx) = mpsc::channel();\n+    GLOBAL_MESSAGE_SENDER.set(Mutex::new(tx)).unwrap();\n+\n+    // Spawn the jitted runtime in a new thread so that this rustc thread can handle messages\n+    // (eg to lazily JIT further functions as required)\n+    std::thread::spawn(move || {\n+        let mut argv = args.iter().map(|arg| arg.as_ptr()).collect::<Vec<_>>();\n+\n+        // Push a null pointer as a terminating argument. This is required by POSIX and\n+        // useful as some dynamic linkers use it as a marker to jump over.\n+        argv.push(std::ptr::null());\n+\n+        let ret = f(args.len() as c_int, argv.as_ptr());\n+        std::process::exit(ret);\n+    });\n+\n+    // Handle messages\n+    loop {\n+        match rx.recv().unwrap() {\n+            // lazy JIT compilation request - compile requested instance and return pointer to result\n+            UnsafeMessage::JitFn { instance_ptr, trampoline_ptr, tx } => {\n+                tx.send(jit_fn(instance_ptr, trampoline_ptr))\n+                  .expect(\"jitted runtime hung up before response to lazy JIT request was sent\");\n+            }\n+        }\n+    }\n }\n \n #[no_mangle]\n-extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8 {\n+extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>, trampoline_ptr: *const u8) -> *const u8 {\n+    // send the JIT request to the rustc thread, with a channel for the response\n+    let (tx, rx) = mpsc::channel();\n+    UnsafeMessage::JitFn { instance_ptr, trampoline_ptr, tx }\n+        .send()\n+        .expect(\"rustc thread hung up before lazy JIT request was sent\");\n+\n+    // block on JIT compilation result\n+    rx.recv()\n+      .expect(\"rustc thread hung up before responding to sent lazy JIT request\")\n+}\n+\n+fn jit_fn(instance_ptr: *const Instance<'static>, trampoline_ptr: *const u8) -> *const u8 {\n     rustc_middle::ty::tls::with(|tcx| {\n         // lift is used to ensure the correct lifetime for instance.\n         let instance = tcx.lift(unsafe { *instance_ptr }).unwrap();\n@@ -160,6 +228,17 @@ extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8\n             let name = tcx.symbol_name(instance).name;\n             let sig = crate::abi::get_function_sig(tcx, jit_module.isa().triple(), instance);\n             let func_id = jit_module.declare_function(name, Linkage::Export, &sig).unwrap();\n+\n+            let current_ptr = jit_module.read_got_entry(func_id);\n+\n+            // If the function's GOT entry has already been updated to point at something other\n+            // than the shim trampoline, don't re-jit but just return the new pointer instead.\n+            // This does not need synchronization as this code is executed only by a sole rustc\n+            // thread.\n+            if current_ptr != trampoline_ptr {\n+                return current_ptr;\n+            }\n+\n             jit_module.prepare_for_function_redefine(func_id).unwrap();\n \n             let mut cx = crate::CodegenCx::new(tcx, backend_config, jit_module.isa(), false);\n@@ -254,7 +333,7 @@ fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: In\n             Linkage::Import,\n             &Signature {\n                 call_conv: module.target_config().default_call_conv,\n-                params: vec![AbiParam::new(pointer_type)],\n+                params: vec![AbiParam::new(pointer_type), AbiParam::new(pointer_type)],\n                 returns: vec![AbiParam::new(pointer_type)],\n             },\n         )\n@@ -267,6 +346,7 @@ fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: In\n     let mut builder_ctx = FunctionBuilderContext::new();\n     let mut trampoline_builder = FunctionBuilder::new(trampoline, &mut builder_ctx);\n \n+    let trampoline_fn = module.declare_func_in_func(func_id, trampoline_builder.func);\n     let jit_fn = module.declare_func_in_func(jit_fn, trampoline_builder.func);\n     let sig_ref = trampoline_builder.func.import_signature(sig);\n \n@@ -276,7 +356,8 @@ fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: In\n \n     trampoline_builder.switch_to_block(entry_block);\n     let instance_ptr = trampoline_builder.ins().iconst(pointer_type, instance_ptr as u64 as i64);\n-    let jitted_fn = trampoline_builder.ins().call(jit_fn, &[instance_ptr]);\n+    let trampoline_ptr = trampoline_builder.ins().func_addr(pointer_type, trampoline_fn);\n+    let jitted_fn = trampoline_builder.ins().call(jit_fn, &[instance_ptr, trampoline_ptr]);\n     let jitted_fn = trampoline_builder.func.dfg.inst_results(jitted_fn)[0];\n     let call_inst = trampoline_builder.ins().call_indirect(sig_ref, jitted_fn, &fn_args);\n     let ret_vals = trampoline_builder.func.dfg.inst_results(call_inst).to_vec();"}, {"sha": "c6203fd926d18adf9fdabf3927b34312cc9e6120", "filename": "src/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=0d1cedecbb63da6a728a1ac9e75f3c442ceab6fa", "patch": "@@ -1,4 +1,11 @@\n-#![feature(rustc_private, decl_macro, never_type, hash_drain_filter, vec_into_raw_parts)]\n+#![feature(\n+    rustc_private,\n+    decl_macro,\n+    never_type,\n+    hash_drain_filter,\n+    vec_into_raw_parts,\n+    once_cell,\n+)]\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n #![warn(unreachable_pub)]"}]}