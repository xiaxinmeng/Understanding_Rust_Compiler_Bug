{"sha": "e59af6c7196ee0118c524e9d33df10419452698d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1OWFmNmM3MTk2ZWUwMTE4YzUyNGU5ZDMzZGYxMDQxOTQ1MjY5OGQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-17T12:20:33Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-17T12:20:33Z"}, "message": "Rollup merge of #31441 - gereeter:btree-docs, r=bluss\n\nStart documenting BTreeMap's node interface\n\ncc @Gankro @apasel422", "tree": {"sha": "48c8bb9f440992aeb4ee70566316db4be4dac72e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48c8bb9f440992aeb4ee70566316db4be4dac72e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e59af6c7196ee0118c524e9d33df10419452698d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e59af6c7196ee0118c524e9d33df10419452698d", "html_url": "https://github.com/rust-lang/rust/commit/e59af6c7196ee0118c524e9d33df10419452698d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e59af6c7196ee0118c524e9d33df10419452698d/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8d71747fea8ade214cd2da9703d1823b6b314a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8d71747fea8ade214cd2da9703d1823b6b314a8", "html_url": "https://github.com/rust-lang/rust/commit/d8d71747fea8ade214cd2da9703d1823b6b314a8"}, {"sha": "fa8556eea22565ecbccc532ecb6a1302978ef903", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa8556eea22565ecbccc532ecb6a1302978ef903", "html_url": "https://github.com/rust-lang/rust/commit/fa8556eea22565ecbccc532ecb6a1302978ef903"}], "stats": {"total": 181, "additions": 176, "deletions": 5}, "files": [{"sha": "ad34de9e3df97b2b9a954785010ee797dab87eb3", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 176, "deletions": 5, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/e59af6c7196ee0118c524e9d33df10419452698d/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59af6c7196ee0118c524e9d33df10419452698d/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=e59af6c7196ee0118c524e9d33df10419452698d", "patch": "@@ -31,6 +31,16 @@\n // Since Rust doesn't actually have dependent types and polymorphic recursion,\n // we make do with lots of unsafety.\n \n+// A major goal of this module is to avoid complexity by treating the tree as a generic (if\n+// weirdly shaped) container and avoiding dealing with most of the B-Tree invariants. As such,\n+// this module doesn't care whether the entries are sorted, which nodes can be underfull, or\n+// even what underfull means. However, we do rely on a few invariants:\n+//\n+// - Trees must have uniform depth/height. This means that every path down to a leaf from a\n+//   given node has exactly the same length.\n+// - A node of length `n` has `n` keys, `n` values, and (in an internal node) `n + 1` edges.\n+//   This implies that even an empty internal node has at least one edge.\n+\n use alloc::heap;\n use core::marker::PhantomData;\n use core::mem;\n@@ -43,17 +53,43 @@ use boxed::Box;\n const B: usize = 6;\n pub const CAPACITY: usize = 2 * B - 1;\n \n+/// The underlying representation of leaf nodes. Note that it is often unsafe to actually store\n+/// these, since only the first `len` keys and values are assumed to be initialized. As such,\n+/// these should always be put behind pointers, and specifically behind `BoxedNode` in the owned\n+/// case.\n+///\n+/// See also rust-lang/rfcs#197, which would make this structure significantly more safe by\n+/// avoiding accidentally dropping unused and uninitialized keys and values.\n struct LeafNode<K, V> {\n+    /// The arrays storing the actual data of the node. Only the first `len` elements of each\n+    /// array are initialized and valid.\n     keys: [K; CAPACITY],\n     vals: [V; CAPACITY],\n+\n+    /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n+    /// This either points to an actual node or is null.\n     parent: *const InternalNode<K, V>,\n+\n+    /// This node's index into the parent node's `edges` array.\n+    /// `*node.parent.edges[node.parent_idx]` should be the same thing as `node`.\n+    /// This is only guaranteed to be initialized when `parent` is nonnull.\n     parent_idx: u16,\n+\n+    /// The number of keys and values this node stores.\n+    ///\n+    /// This is at the end of the node's representation and next to `parent_idx` to encourage\n+    /// the compiler to join `len` and `parent_idx` into the same 32-bit word, reducing space\n+    /// overhead.\n     len: u16,\n }\n \n impl<K, V> LeafNode<K, V> {\n+    /// Creates a new `LeafNode`. Unsafe because all nodes should really be hidden behind\n+    /// `BoxedNode`, preventing accidental dropping of uninitialized keys and values.\n     unsafe fn new() -> Self {\n         LeafNode {\n+            // As a general policy, we leave fields uninitialized if they can be, as this should\n+            // be both slightly faster and easier to track in Valgrind.\n             keys: mem::uninitialized(),\n             vals: mem::uninitialized(),\n             parent: ptr::null(),\n@@ -63,15 +99,28 @@ impl<K, V> LeafNode<K, V> {\n     }\n }\n \n-// We use repr(C) so that a pointer to an internal node can be\n-// directly used as a pointer to a leaf node\n+/// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n+/// behind `BoxedNode`s to prevent dropping uninitialized keys and values. Any pointer to an\n+/// `InternalNode` can be directly casted to a pointer to the underlying `LeafNode` portion of the\n+/// node, allowing code to act on leaf and internal nodes generically without having to even check\n+/// which of the two a pointer is pointing at. This property is enabled by the use of `repr(C)`.\n #[repr(C)]\n struct InternalNode<K, V> {\n     data: LeafNode<K, V>,\n+\n+    /// The pointers to the children of this node. `len + 1` of these are considered\n+    /// initialized and valid.\n     edges: [BoxedNode<K, V>; 2 * B],\n }\n \n impl<K, V> InternalNode<K, V> {\n+    /// Creates a new `InternalNode`.\n+    ///\n+    /// This is unsafe for two reasons. First, it returns an `InternalNode` by value, risking\n+    /// dropping of uninitialized fields. Second, an invariant of internal nodes is that `len + 1`\n+    /// edges are initialized and valid, meaning that even when the node is empty (having a\n+    /// `len` of 0), there must be one initialized and valid edge. This function does not set up\n+    /// such an edge.\n     unsafe fn new() -> Self {\n         InternalNode {\n             data: LeafNode::new(),\n@@ -80,8 +129,12 @@ impl<K, V> InternalNode<K, V> {\n     }\n }\n \n+/// An owned pointer to a node. This basically is either `Box<LeafNode<K, V>>` or\n+/// `Box<InternalNode<K, V>>`. However, it contains no information as to which of the two types\n+/// of nodes is acutally behind the box, and, partially due to this lack of information, has no\n+/// destructor.\n struct BoxedNode<K, V> {\n-    ptr: Unique<LeafNode<K, V>> // we don't know if this points to a leaf node or an internal node\n+    ptr: Unique<LeafNode<K, V>>\n }\n \n impl<K, V> BoxedNode<K, V> {\n@@ -156,7 +209,7 @@ impl<K, V> Root<K, V> {\n         }\n     }\n \n-    /// Add a new internal node with a single edge, pointing to the previous root, and make that\n+    /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n     /// new node the root. This increases the height by 1 and is the opposite of `pop_level`.\n     pub fn push_level(&mut self)\n             -> NodeRef<marker::Mut, K, V, marker::Internal> {\n@@ -180,7 +233,7 @@ impl<K, V> Root<K, V> {\n         ret\n     }\n \n-    ///\u00a0Remove the root node, using its first child as the new root. This cannot be called when\n+    /// Removes the root node, using its first child as the new root. This cannot be called when\n     /// the tree consists only of a leaf node. As it is intended only to be called when the root\n     /// has only one edge, no cleanup is done on any of the other children are elements of the root.\n     /// This decreases the height by 1 and is the opposite of `push_level`.\n@@ -229,6 +282,7 @@ impl<K, V> Root<K, V> {\n pub struct NodeRef<BorrowType, K, V, Type> {\n     height: usize,\n     node: NonZero<*const LeafNode<K, V>>,\n+    // This is null unless the borrow type is `Mut`\n     root: *const Root<K, V>,\n     _marker: PhantomData<(BorrowType, Type)>\n }\n@@ -268,10 +322,14 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n \n \n impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n+    /// Finds the length of the node. This is the number of keys or values. In an\n+    /// internal node, the number of edges is `len() + 1`.\n     pub fn len(&self) -> usize {\n         self.as_leaf().len as usize\n     }\n \n+    /// Removes any static information about whether this node is a `Leaf` or an\n+    /// `Internal` node.\n     pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n         NodeRef {\n             height: self.height,\n@@ -281,6 +339,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         }\n     }\n \n+    /// Temporarily takes out another, immutable reference to the same node.\n     fn reborrow<'a>(&'a self) -> NodeRef<marker::Immut<'a>, K, V, Type> {\n         NodeRef {\n             height: self.height,\n@@ -304,6 +363,13 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         self.reborrow().into_slices().1\n     }\n \n+    /// Finds the parent of the current node. Returns `Ok(handle)` if the current\n+    /// node actually has a parent, where `handle` points to the edge of the parent\n+    /// that points to the current node. Returns `Err(self)` if the current node has\n+    /// no parent, giving back the original `NodeRef`.\n+    ///\n+    /// `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n+    /// both, upon success, do nothing.\n     pub fn ascend(self) -> Result<\n         Handle<\n             NodeRef<\n@@ -344,6 +410,9 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n }\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n+    /// Similar to `ascend`, gets a reference to a node's parent node, but also\n+    /// deallocate the current node in the process. This is unsafe because the\n+    /// current node will still be accessible despite being deallocated.\n     pub unsafe fn deallocate_and_ascend(self) -> Option<\n         Handle<\n             NodeRef<\n@@ -362,6 +431,9 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n }\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n+    /// Similar to `ascend`, gets a reference to a node's parent node, but also\n+    /// deallocate the current node in the process. This is unsafe because the\n+    /// current node will still be accessible despite being deallocated.\n     pub unsafe fn deallocate_and_ascend(self) -> Option<\n         Handle<\n             NodeRef<\n@@ -384,6 +456,8 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n }\n \n impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n+    /// Unsafely asserts to the compiler some static information about whether this\n+    /// node is a `Leaf`.\n     unsafe fn cast_unchecked<NewType>(&mut self)\n             -> NodeRef<marker::Mut, K, V, NewType> {\n \n@@ -395,6 +469,16 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n+    /// Temporarily takes out another, mutable reference to the same node. Beware, as\n+    /// this method is very dangerous, doubly so since it may not immediately appear\n+    /// dangerous.\n+    ///\n+    /// Because mutable pointers can roam anywhere around the tree and can even (through\n+    /// `into_root_mut`) mess with the root of the tree, the result of `reborrow_mut`\n+    /// can easily be used to make the original mutable pointer dangling, or, in the case\n+    /// of a reborrowed handle, out of bounds.\n+    // FIXME(@gereeter) consider adding yet another type parameter to `NodeRef` that restricts\n+    // the use of `ascend` and `into_root_mut` on reborrowed pointers, preventing this unsafety.\n     unsafe fn reborrow_mut(&mut self) -> NodeRef<marker::Mut, K, V, Type> {\n         NodeRef {\n             height: self.height,\n@@ -437,6 +521,8 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n+    /// Gets a mutable reference to the root itself. This is useful primarily when the\n+    /// height of the tree needs to be adjusted. Never call this on a reborrowed pointer.\n     pub fn into_root_mut(self) -> &'a mut Root<K, V> {\n         unsafe {\n             &mut *(self.root as *mut Root<K, V>)\n@@ -460,6 +546,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n+    /// Adds a key/value pair the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() < CAPACITY);\n@@ -474,6 +561,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         self.as_leaf_mut().len += 1;\n     }\n \n+    /// Adds a key/value pair to the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() < CAPACITY);\n@@ -488,6 +576,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+    /// Adds a key/value pair and an edge to go to the right of that pair to\n+    /// the end of the node.\n     pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(edge.height == self.height - 1);\n@@ -506,6 +596,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         }\n     }\n \n+    /// Adds a key/value pair and an edge to go to the left of that pair to\n+    /// the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(edge.height == self.height - 1);\n@@ -534,6 +626,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n+    /// Removes a key/value pair from the end of this node. If this is an internal node,\n+    /// also removes the edge that was to the right of that pair.\n     pub fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() > 0);\n@@ -558,6 +652,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         }\n     }\n \n+    /// Removes a key/value pair from the beginning of this node. If this is an internal node,\n+    /// also removes the edge that was to the left of that pair.\n     pub fn pop_front(&mut self) -> (K, V, Option<Root<K, V>>) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() > 0);\n@@ -597,6 +693,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n }\n \n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+    /// Checks whether a node is an `Internal` node or a `Leaf` node.\n     pub fn force(self) -> ForceResult<\n         NodeRef<BorrowType, K, V, marker::Leaf>,\n         NodeRef<BorrowType, K, V, marker::Internal>\n@@ -619,26 +716,38 @@ impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n     }\n }\n \n+/// A reference to a specific key/value pair or edge within a node. The `Node` parameter\n+/// must be a `NodeRef`, while the `Type` can either be `KV` (signifying a handle on a key/value\n+/// pair) or `Edge` (signifying a handle on an edge).\n+///\n+/// Note that even `Leaf` nodes can have `Edge` handles. Instead of representing a pointer to\n+/// a child node, these represent the spaces where child pointers would go between the key/value\n+/// pairs. For example, in a node with length 2, there would be 3 possible edge locations - one\n+/// to the left of the node, one between the two pairs, and one at the right of the node.\n pub struct Handle<Node, Type> {\n     node: Node,\n     idx: usize,\n     _marker: PhantomData<Type>\n }\n \n impl<Node: Copy, Type> Copy for Handle<Node, Type> { }\n+// We don't need the full generality of `#[derive(Clone)]`, as the only time `Node` will be\n+// `Clone`able is when it is an immutable reference and therefore `Copy`.\n impl<Node: Copy, Type> Clone for Handle<Node, Type> {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n impl<Node, Type> Handle<Node, Type> {\n+    /// Retrieves the node that contains the edge of key/value pair this handle pointes to.\n     pub fn into_node(self) -> Node {\n         self.node\n     }\n }\n \n impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV> {\n+    /// Creates a new handle to a key/value pair in `node`. `idx` must be less than `node.len()`.\n     pub fn new_kv(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n         // Necessary for correctness, but in a private module\n         debug_assert!(idx < node.len());\n@@ -670,6 +779,7 @@ impl<BorrowType, K, V, NodeType, HandleType> PartialEq\n impl<BorrowType, K, V, NodeType, HandleType>\n         Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType> {\n \n+    /// Temporarily takes out another, immutable handle on the same location.\n     pub fn reborrow(&self)\n             -> Handle<NodeRef<marker::Immut, K, V, NodeType>, HandleType> {\n \n@@ -685,6 +795,16 @@ impl<BorrowType, K, V, NodeType, HandleType>\n impl<'a, K, V, NodeType, HandleType>\n         Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, HandleType> {\n \n+    /// Temporarily takes out another, mutable handle on the same location. Beware, as\n+    /// this method is very dangerous, doubly so since it may not immediately appear\n+    /// dangerous.\n+    ///\n+    /// Because mutable pointers can roam anywhere around the tree and can even (through\n+    /// `into_root_mut`) mess with the root of the tree, the result of `reborrow_mut`\n+    /// can easily be used to make the original mutable pointer dangling, or, in the case\n+    /// of a reborrowed handle, out of bounds.\n+    // FIXME(@gereeter) consider adding yet another type parameter to `NodeRef` that restricts\n+    // the use of `ascend` and `into_root_mut` on reborrowed pointers, preventing this unsafety.\n     pub unsafe fn reborrow_mut(&mut self)\n             -> Handle<NodeRef<marker::Mut, K, V, NodeType>, HandleType> {\n \n@@ -700,6 +820,8 @@ impl<'a, K, V, NodeType, HandleType>\n impl<BorrowType, K, V, NodeType>\n         Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n \n+    /// Creates a new handle to an edge in `node`. `idx` must be less than or equal to\n+    /// `node.len()`.\n     pub fn new_edge(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n         // Necessary for correctness, but in a private module\n         debug_assert!(idx <= node.len());\n@@ -733,6 +855,11 @@ impl<BorrowType, K, V, NodeType>\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+    /// Inserts a new key/value pair between the key/value pairs to the right and left of\n+    /// this edge. This method assumes that there is enough space in the node for the new\n+    /// pair to fit.\n+    ///\n+    /// The returned pointer points to the inserted value.\n     fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n         // Necessary for correctness, but in a private module\n         debug_assert!(self.node.len() < CAPACITY);\n@@ -747,6 +874,10 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n         }\n     }\n \n+    /// Inserts a new key/value pair between the key/value pairs to the right and left of\n+    /// this edge. This method splits the node if there isn't enough room.\n+    ///\n+    /// The returned pointer points to the inserted value.\n     pub fn insert(mut self, key: K, val: V)\n             -> (InsertResult<'a, K, V, marker::Leaf>, *mut V) {\n \n@@ -774,6 +905,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n+    /// Fixes the parent pointer and index in the child node below this edge. This is useful\n+    /// when the ordering of edges has been changed, such as in the various `insert` methods.\n     fn correct_parent_link(mut self) {\n         let idx = self.idx as u16;\n         let ptr = self.node.as_internal_mut() as *mut _;\n@@ -782,18 +915,24 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         child.as_leaf_mut().parent_idx = idx;\n     }\n \n+    /// Unsafely asserts to the compiler some static information about whether the underlying\n+    /// node of this handle is a `Leaf`.\n     unsafe fn cast_unchecked<NewType>(&mut self)\n             -> Handle<NodeRef<marker::Mut, K, V, NewType>, marker::Edge> {\n \n         Handle::new_edge(self.node.cast_unchecked(), self.idx)\n     }\n \n+    /// Inserts a new key/value pair and an edge that will go to the right of that new pair\n+    /// between this edge and the key/value pair to the right of this edge. This method assumes\n+    /// that there is enough space in the node for the new pair to fit.\n     fn insert_fit(&mut self, key: K, val: V, edge: Root<K, V>) {\n         // Necessary for correctness, but in an internal module\n         debug_assert!(self.node.len() < CAPACITY);\n         debug_assert!(edge.height == self.node.height - 1);\n \n         unsafe {\n+            // This cast is a lie, but it allows us to reuse the key/value insertion logic.\n             self.cast_unchecked::<marker::Leaf>().insert_fit(key, val);\n \n             slice_insert(\n@@ -811,6 +950,9 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n+    /// Inserts a new key/value pair and an edge that will go to the right of that new pair\n+    /// between this edge and the key/value pair to the right of this edge. This method splits\n+    /// the node if there isn't enough room.\n     pub fn insert(mut self, key: K, val: V, edge: Root<K, V>)\n             -> InsertResult<'a, K, V, marker::Internal> {\n \n@@ -843,6 +985,10 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n impl<BorrowType, K, V>\n         Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge> {\n \n+    /// Finds the node pointed to by this edge.\n+    ///\n+    /// `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n+    /// both, upon success, do nothing.\n     pub fn descend(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n         NodeRef {\n             height: self.node.height - 1,\n@@ -885,6 +1031,13 @@ impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n+    /// Splits the underlying node into three parts:\n+    ///\n+    /// - The node is truncated to only contain the key/value pairs to the right of\n+    ///   this handle.\n+    /// - The key and value pointed to by this handle and extracted.\n+    /// - All the key/value pairs to the right of this handle are put into a newly\n+    ///   allocated node.\n     pub fn split(mut self)\n             -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n         unsafe {\n@@ -920,6 +1073,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n         }\n     }\n \n+    /// Removes the key/value pair pointed to by this handle, returning the edge between the\n+    /// now adjacent key/value pairs to the left and right of this handle.\n     pub fn remove(mut self)\n             -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n         unsafe {\n@@ -932,6 +1087,13 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV> {\n+    /// Splits the underlying node into three parts:\n+    ///\n+    /// - The node is truncated to only contain the edges and key/value pairs to the\n+    ///   right of this handle.\n+    /// - The key and value pointed to by this handle and extracted.\n+    /// - All the edges and key/value pairs to the right of this handle are put into\n+    ///   a newly allocated node.\n     pub fn split(mut self)\n             -> (NodeRef<marker::Mut<'a>, K, V, marker::Internal>, K, V, Root<K, V>) {\n         unsafe {\n@@ -979,6 +1141,9 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n+    /// Returns whether it is valid to call `.merge()`, i.e., whether there is enough room in\n+    /// a node to hold the combination of the nodes to the left and right of this handle along\n+    /// with the key/value pair at this handle.\n     pub fn can_merge(&self) -> bool {\n         (\n             self.reborrow()\n@@ -993,6 +1158,11 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         ) <= CAPACITY\n     }\n \n+    /// Combines the node immediately to the left of this handle, the key/value pair pointed\n+    /// to by this handle, and the node immediately to the right of this handle into one new\n+    /// child of the underlying node, returning an edge referencing that new child.\n+    ///\n+    /// Assumes that this edge `.can_merge()`.\n     pub fn merge(mut self)\n             -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n         let self1 = unsafe { ptr::read(&self) };\n@@ -1068,6 +1238,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n impl<BorrowType, K, V, HandleType>\n         Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, HandleType> {\n \n+    /// Check whether the underlying node is an `Internal` node or a `Leaf` node.\n     pub fn force(self) -> ForceResult<\n         Handle<NodeRef<BorrowType, K, V, marker::Leaf>, HandleType>,\n         Handle<NodeRef<BorrowType, K, V, marker::Internal>, HandleType>"}]}