{"sha": "76a2891febd8b54fb8bea07cdb60184d24c324d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YTI4OTFmZWJkOGI1NGZiOGJlYTA3Y2RiNjAxODRkMjRjMzI0ZDk=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-12-20T20:52:53Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-12-20T20:52:53Z"}, "message": "Remove the cfg(stageN)-specific serialize code.", "tree": {"sha": "278a5932f92dc8f065b256cefc5cec276e074383", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/278a5932f92dc8f065b256cefc5cec276e074383"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76a2891febd8b54fb8bea07cdb60184d24c324d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76a2891febd8b54fb8bea07cdb60184d24c324d9", "html_url": "https://github.com/rust-lang/rust/commit/76a2891febd8b54fb8bea07cdb60184d24c324d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76a2891febd8b54fb8bea07cdb60184d24c324d9/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faef32995c0fb5fa40a7a68341ac8b15c4e073c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/faef32995c0fb5fa40a7a68341ac8b15c4e073c8", "html_url": "https://github.com/rust-lang/rust/commit/faef32995c0fb5fa40a7a68341ac8b15c4e073c8"}], "stats": {"total": 615, "additions": 0, "deletions": 615}, "files": [{"sha": "726bc5f95902fced3baaa4e1c2542ba76c553642", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76a2891febd8b54fb8bea07cdb60184d24c324d9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a2891febd8b54fb8bea07cdb60184d24c324d9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=76a2891febd8b54fb8bea07cdb60184d24c324d9", "patch": "@@ -25,10 +25,6 @@ use reader = std::ebml::reader;\n use std::ebml;\n use std::map::HashMap;\n use std::map;\n-#[cfg(stage0)]\n-use std::serialize::traits::Decodable;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n use std::serialize::Decodable;\n use syntax::ast_map;\n use syntax::attr;"}, {"sha": "40d4bd61668b05947db692b0cdc89e3f785e67e3", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76a2891febd8b54fb8bea07cdb60184d24c324d9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a2891febd8b54fb8bea07cdb60184d24c324d9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=76a2891febd8b54fb8bea07cdb60184d24c324d9", "patch": "@@ -29,10 +29,6 @@ use std::ebml;\n use std::map::HashMap;\n use std::serialize;\n use std::serialize::{Encodable, EncoderHelpers, DecoderHelpers};\n-#[cfg(stage0)]\n-use std::serialize::traits::Decodable;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n use std::serialize::Decodable;\n use syntax::ast;\n use syntax::ast_map;"}, {"sha": "9b1949256931c0aa1cfd9cc292525385ef63faac", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 0, "deletions": 607, "changes": 607, "blob_url": "https://github.com/rust-lang/rust/blob/76a2891febd8b54fb8bea07cdb60184d24c324d9/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a2891febd8b54fb8bea07cdb60184d24c324d9/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=76a2891febd8b54fb8bea07cdb60184d24c324d9", "patch": "@@ -102,8 +102,6 @@ pub trait Decoder {\n     fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n }\n \n-#[cfg(stage0)]\n-pub mod traits {\n pub trait Encodable<S: Encoder> {\n     fn encode(&self, s: &S);\n }\n@@ -582,608 +580,3 @@ pub impl<D: Decoder> D: DecoderHelpers {\n         }\n     }\n }\n-}\n-\n-#[cfg(stage0)]\n-pub use serialize::traits::*;\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub trait Encodable<S: Encoder> {\n-    fn encode(&self, s: &S);\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub trait Decodable<D: Decoder> {\n-    static fn decode(&self, d: &D) -> self;\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> uint: Encodable<S> {\n-    fn encode(&self, s: &S) { s.emit_uint(*self) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder> uint: Decodable<D> {\n-    static fn decode(&self, d: &D) -> uint {\n-        d.read_uint()\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> u8: Encodable<S> {\n-    fn encode(&self, s: &S) { s.emit_u8(*self) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder> u8: Decodable<D> {\n-    static fn decode(&self, d: &D) -> u8 {\n-        d.read_u8()\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> u16: Encodable<S> {\n-    fn encode(&self, s: &S) { s.emit_u16(*self) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder> u16: Decodable<D> {\n-    static fn decode(&self, d: &D) -> u16 {\n-        d.read_u16()\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> u32: Encodable<S> {\n-    fn encode(&self, s: &S) { s.emit_u32(*self) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder> u32: Decodable<D> {\n-    static fn decode(&self, d: &D) -> u32 {\n-        d.read_u32()\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> u64: Encodable<S> {\n-    fn encode(&self, s: &S) { s.emit_u64(*self) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder> u64: Decodable<D> {\n-    static fn decode(&self, d: &D) -> u64 {\n-        d.read_u64()\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> int: Encodable<S> {\n-    fn encode(&self, s: &S) { s.emit_int(*self) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder> int: Decodable<D> {\n-    static fn decode(&self, d: &D) -> int {\n-        d.read_int()\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> i8: Encodable<S> {\n-    fn encode(&self, s: &S) { s.emit_i8(*self) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder> i8: Decodable<D> {\n-    static fn decode(&self, d: &D) -> i8 {\n-        d.read_i8()\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> i16: Encodable<S> {\n-    fn encode(&self, s: &S) { s.emit_i16(*self) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder> i16: Decodable<D> {\n-    static fn decode(&self, d: &D) -> i16 {\n-        d.read_i16()\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> i32: Encodable<S> {\n-    fn encode(&self, s: &S) { s.emit_i32(*self) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder> i32: Decodable<D> {\n-    static fn decode(&self, d: &D) -> i32 {\n-        d.read_i32()\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> i64: Encodable<S> {\n-    fn encode(&self, s: &S) { s.emit_i64(*self) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder> i64: Decodable<D> {\n-    static fn decode(&self, d: &D) -> i64 {\n-        d.read_i64()\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> &str: Encodable<S> {\n-    fn encode(&self, s: &S) { s.emit_borrowed_str(*self) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> ~str: Encodable<S> {\n-    fn encode(&self, s: &S) { s.emit_owned_str(*self) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder> ~str: Decodable<D> {\n-    static fn decode(&self, d: &D) -> ~str {\n-        d.read_owned_str()\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> @str: Encodable<S> {\n-    fn encode(&self, s: &S) { s.emit_managed_str(*self) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder> @str: Decodable<D> {\n-    static fn decode(&self, d: &D) -> @str {\n-        d.read_managed_str()\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> float: Encodable<S> {\n-    fn encode(&self, s: &S) { s.emit_float(*self) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder> float: Decodable<D> {\n-    static fn decode(&self, d: &D) -> float {\n-        d.read_float()\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> f32: Encodable<S> {\n-    fn encode(&self, s: &S) { s.emit_f32(*self) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder> f32: Decodable<D> {\n-    static fn decode(&self, d: &D) -> f32 {\n-        d.read_f32() }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> f64: Encodable<S> {\n-    fn encode(&self, s: &S) { s.emit_f64(*self) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder> f64: Decodable<D> {\n-    static fn decode(&self, d: &D) -> f64 {\n-        d.read_f64()\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> bool: Encodable<S> {\n-    fn encode(&self, s: &S) { s.emit_bool(*self) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder> bool: Decodable<D> {\n-    static fn decode(&self, d: &D) -> bool {\n-        d.read_bool()\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> (): Encodable<S> {\n-    fn encode(&self, s: &S) { s.emit_nil() }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder> (): Decodable<D> {\n-    static fn decode(&self, d: &D) -> () {\n-        d.read_nil()\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder, T: Encodable<S>> &T: Encodable<S> {\n-    fn encode(&self, s: &S) {\n-        s.emit_borrowed(|| (**self).encode(s))\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder, T: Encodable<S>> ~T: Encodable<S> {\n-    fn encode(&self, s: &S) {\n-        s.emit_owned(|| (**self).encode(s))\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder, T: Decodable<D>> ~T: Decodable<D> {\n-    static fn decode(&self, d: &D) -> ~T {\n-        d.read_owned(|| ~Decodable::decode(d))\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder, T: Encodable<S>> @T: Encodable<S> {\n-    fn encode(&self, s: &S) {\n-        s.emit_managed(|| (**self).encode(s))\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder, T: Decodable<D>> @T: Decodable<D> {\n-    static fn decode(&self, d: &D) -> @T {\n-        d.read_managed(|| @Decodable::decode(d))\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder, T: Encodable<S>> &[T]: Encodable<S> {\n-    fn encode(&self, s: &S) {\n-        do s.emit_borrowed_vec(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_vec_elt(i, || e.encode(s))\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder, T: Encodable<S>> ~[T]: Encodable<S> {\n-    fn encode(&self, s: &S) {\n-        do s.emit_owned_vec(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_vec_elt(i, || e.encode(s))\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder, T: Decodable<D>> ~[T]: Decodable<D> {\n-    static fn decode(&self, d: &D) -> ~[T] {\n-        do d.read_owned_vec |len| {\n-            do vec::from_fn(len) |i| {\n-                d.read_vec_elt(i, || Decodable::decode(d))\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder, T: Encodable<S>> @[T]: Encodable<S> {\n-    fn encode(&self, s: &S) {\n-        do s.emit_managed_vec(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_vec_elt(i, || e.encode(s))\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder, T: Decodable<D>> @[T]: Decodable<D> {\n-    static fn decode(&self, d: &D) -> @[T] {\n-        do d.read_managed_vec |len| {\n-            do at_vec::from_fn(len) |i| {\n-                d.read_vec_elt(i, || Decodable::decode(d))\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder, T: Encodable<S>> Option<T>: Encodable<S> {\n-    fn encode(&self, s: &S) {\n-        do s.emit_enum(~\"option\") {\n-            match *self {\n-              None => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n-              },\n-\n-              Some(ref v) => do s.emit_enum_variant(~\"some\", 1u, 1u) {\n-                s.emit_enum_variant_arg(0u, || v.encode(s))\n-              }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder, T: Decodable<D>> Option<T>: Decodable<D> {\n-    static fn decode(&self, d: &D) -> Option<T> {\n-        do d.read_enum(~\"option\") {\n-            do d.read_enum_variant |i| {\n-                match i {\n-                  0 => None,\n-                  1 => Some(d.read_enum_variant_arg(\n-                      0u, || Decodable::decode(d))),\n-                  _ => fail(fmt!(\"Bad variant for option: %u\", i))\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<\n-    S: Encoder,\n-    T0: Encodable<S>,\n-    T1: Encodable<S>\n-> (T0, T1): Encodable<S> {\n-    fn encode(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1) => {\n-                do s.emit_tup(2) {\n-                    s.emit_tup_elt(0, || t0.encode(s));\n-                    s.emit_tup_elt(1, || t1.encode(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<\n-    D: Decoder,\n-    T0: Decodable<D>,\n-    T1: Decodable<D>\n-> (T0, T1): Decodable<D> {\n-    static fn decode(&self, d: &D) -> (T0, T1) {\n-        do d.read_tup(2) {\n-            (\n-                d.read_tup_elt(0, || Decodable::decode(d)),\n-                d.read_tup_elt(1, || Decodable::decode(d))\n-            )\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<\n-    S: Encoder,\n-    T0: Encodable<S>,\n-    T1: Encodable<S>,\n-    T2: Encodable<S>\n-> (T0, T1, T2): Encodable<S> {\n-    fn encode(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2) => {\n-                do s.emit_tup(3) {\n-                    s.emit_tup_elt(0, || t0.encode(s));\n-                    s.emit_tup_elt(1, || t1.encode(s));\n-                    s.emit_tup_elt(2, || t2.encode(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<\n-    D: Decoder,\n-    T0: Decodable<D>,\n-    T1: Decodable<D>,\n-    T2: Decodable<D>\n-> (T0, T1, T2): Decodable<D> {\n-    static fn decode(&self, d: &D) -> (T0, T1, T2) {\n-        do d.read_tup(3) {\n-            (\n-                d.read_tup_elt(0, || Decodable::decode(d)),\n-                d.read_tup_elt(1, || Decodable::decode(d)),\n-                d.read_tup_elt(2, || Decodable::decode(d))\n-            )\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<\n-    S: Encoder,\n-    T0: Encodable<S>,\n-    T1: Encodable<S>,\n-    T2: Encodable<S>,\n-    T3: Encodable<S>\n-> (T0, T1, T2, T3): Encodable<S> {\n-    fn encode(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2, ref t3) => {\n-                do s.emit_tup(4) {\n-                    s.emit_tup_elt(0, || t0.encode(s));\n-                    s.emit_tup_elt(1, || t1.encode(s));\n-                    s.emit_tup_elt(2, || t2.encode(s));\n-                    s.emit_tup_elt(3, || t3.encode(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<\n-    D: Decoder,\n-    T0: Decodable<D>,\n-    T1: Decodable<D>,\n-    T2: Decodable<D>,\n-    T3: Decodable<D>\n-> (T0, T1, T2, T3): Decodable<D> {\n-    static fn decode(&self, d: &D) -> (T0, T1, T2, T3) {\n-        do d.read_tup(4) {\n-            (\n-                d.read_tup_elt(0, || Decodable::decode(d)),\n-                d.read_tup_elt(1, || Decodable::decode(d)),\n-                d.read_tup_elt(2, || Decodable::decode(d)),\n-                d.read_tup_elt(3, || Decodable::decode(d))\n-            )\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<\n-    S: Encoder,\n-    T0: Encodable<S>,\n-    T1: Encodable<S>,\n-    T2: Encodable<S>,\n-    T3: Encodable<S>,\n-    T4: Encodable<S>\n-> (T0, T1, T2, T3, T4): Encodable<S> {\n-    fn encode(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n-                do s.emit_tup(5) {\n-                    s.emit_tup_elt(0, || t0.encode(s));\n-                    s.emit_tup_elt(1, || t1.encode(s));\n-                    s.emit_tup_elt(2, || t2.encode(s));\n-                    s.emit_tup_elt(3, || t3.encode(s));\n-                    s.emit_tup_elt(4, || t4.encode(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<\n-    D: Decoder,\n-    T0: Decodable<D>,\n-    T1: Decodable<D>,\n-    T2: Decodable<D>,\n-    T3: Decodable<D>,\n-    T4: Decodable<D>\n-> (T0, T1, T2, T3, T4): Decodable<D> {\n-    static fn decode(&self, d: &D)\n-      -> (T0, T1, T2, T3, T4) {\n-        do d.read_tup(5) {\n-            (\n-                d.read_tup_elt(0, || Decodable::decode(d)),\n-                d.read_tup_elt(1, || Decodable::decode(d)),\n-                d.read_tup_elt(2, || Decodable::decode(d)),\n-                d.read_tup_elt(3, || Decodable::decode(d)),\n-                d.read_tup_elt(4, || Decodable::decode(d))\n-            )\n-        }\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-// Helper routines\n-//\n-// In some cases, these should eventually be coded as traits.\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub trait EncoderHelpers {\n-    fn emit_from_vec<T>(&self, v: ~[T], f: fn(v: &T));\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<S: Encoder> S: EncoderHelpers {\n-    fn emit_from_vec<T>(&self, v: ~[T], f: fn(v: &T)) {\n-        do self.emit_owned_vec(v.len()) {\n-            for v.eachi |i, e| {\n-                do self.emit_vec_elt(i) {\n-                    f(e)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub trait DecoderHelpers {\n-    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T];\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-pub impl<D: Decoder> D: DecoderHelpers {\n-    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T] {\n-        do self.read_owned_vec |len| {\n-            do vec::from_fn(len) |i| {\n-                self.read_vec_elt(i, || f())\n-            }\n-        }\n-    }\n-}"}]}