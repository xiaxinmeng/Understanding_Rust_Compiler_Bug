{"sha": "f94339cc1c98a1ae3ee3beb94c848009167a58d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5NDMzOWNjMWM5OGExYWUzZWUzYmViOTRjODQ4MDA5MTY3YTU4ZDk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-03T20:47:01Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-04T07:48:12Z"}, "message": "rt: Rename rust_scheduler to rust_task_thread", "tree": {"sha": "557b51759b825ea48071cbddbd023b687a8c4098", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/557b51759b825ea48071cbddbd023b687a8c4098"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f94339cc1c98a1ae3ee3beb94c848009167a58d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f94339cc1c98a1ae3ee3beb94c848009167a58d9", "html_url": "https://github.com/rust-lang/rust/commit/f94339cc1c98a1ae3ee3beb94c848009167a58d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f94339cc1c98a1ae3ee3beb94c848009167a58d9/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3343b35717edbfb88c7d1fae790e43d5d7cb732", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3343b35717edbfb88c7d1fae790e43d5d7cb732", "html_url": "https://github.com/rust-lang/rust/commit/f3343b35717edbfb88c7d1fae790e43d5d7cb732"}], "stats": {"total": 547, "additions": 273, "deletions": 274}, "files": [{"sha": "a0f3991c42610550017dcdb9b107837aa8b29747", "filename": "mk/rt.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -42,7 +42,7 @@ RUNTIME_CS_$(1) := \\\n               rt/rust_run_program.cpp \\\n               rt/rust_crate_cache.cpp \\\n               rt/rust_env.cpp \\\n-              rt/rust_scheduler.cpp \\\n+              rt/rust_task_thread.cpp \\\n               rt/rust_task.cpp \\\n               rt/rust_task_list.cpp \\\n               rt/rust_port.cpp \\\n@@ -79,7 +79,7 @@ RUNTIME_HDR_$(1) := rt/globals.h \\\n                rt/rust_unwind.h \\\n                rt/rust_upcall.h \\\n                rt/rust_port.h \\\n-               rt/rust_scheduler.h \\\n+               rt/rust_task_thread.h \\\n                rt/rust_shape.h \\\n                rt/rust_task.h \\\n                rt/rust_task_list.h \\"}, {"sha": "090279d83e3ae3ca0fe291b0bf3be4b54185ba04", "filename": "src/rt/intrinsics/intrinsics.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.cpp?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -5,7 +5,6 @@\n \n #include \"../rust_internal.h\"\n #include \"../rust_util.h\"\n-#include \"../rust_scheduler.h\"\n #include <cstdlib>\n #include <cstring>\n "}, {"sha": "3bb9e8aae1262db4de2945376ef0bf571c8755e5", "filename": "src/rt/intrinsics/intrinsics.i386.ll.in", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -10,15 +10,15 @@ target triple = \"@CFG_TARGET_TRIPLE@\"\n %struct.rust_vec = type { i32, i32, [0 x i8] }\n %struct.rust_fn = type { i32*, %struct.rust_box* }\n %struct.rust_box = type opaque\n-%struct.rust_task = type { %struct.rust_task_user, i32, [8 x i8], %class.context, %struct.stk_seg*, i32, %struct.rust_scheduler*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i32, i32*, i32, i32, %class.memory_region, %class.boxed_region, i8, i8, i8, %class.lock_and_signal, %class.hash_map.4, %class.rust_obstack, i32, %\"class.debug::task_debug_info\", i32, [12 x i8] }\n+%struct.rust_task = type { %struct.rust_task_user, i32, [8 x i8], %class.context, %struct.stk_seg*, i32, %struct.rust_task_thread*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i32, i32*, %class.memory_region, %class.boxed_region, i8, i8, i8, %class.lock_and_signal, %class.hash_map.4, %class.rust_obstack, i32, %\"class.debug::task_debug_info\", i32, [4 x i8] }\n %struct.rust_task_user = type { i32, i32, %struct.chan_handle, i32 }\n %struct.chan_handle = type { i32, i32 }\n %class.context = type { %struct.registers_t, %class.context*, [12 x i8] }\n %struct.registers_t = type { i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i16, i16, i16, i32, i32, [12 x i8] }\n %struct.stk_seg = type { %struct.stk_seg*, %struct.stk_seg*, i32, i32, i32, [0 x i8] }\n-%struct.rust_scheduler = type { %class.rust_thread, i32, i32, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, i32, i32, %class.lock_and_signal, i32, %union.pthread_attr_t, %struct.rust_env*, [8 x i8], %class.context }\n+%struct.rust_task_thread = type { %class.rust_thread, i32, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, i32, i32, %class.lock_and_signal, i32, %union.pthread_attr_t, %struct.rust_env*, [12 x i8], %class.context, i8, [15 x i8] }\n %class.rust_thread = type { i32 (...)**, i8, i32 }\n-%class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_scheduler*, i8 }\n+%class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_task_thread*, i8 }\n %class.rust_srv = type { i32 (...)**, %struct.rust_env*, %class.memory_region }\n %struct.rust_env = type { i32, i32, i32, i8*, i8, i8, i8* }\n %class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %class.array_list, i8, i8, %class.lock_and_signal }\n@@ -30,14 +30,14 @@ target triple = \"@CFG_TARGET_TRIPLE@\"\n %union.pthread_mutex_t = type { %\"struct.<anonymous union>::__pthread_mutex_s\" }\n %\"struct.<anonymous union>::__pthread_mutex_s\" = type { i32, i32, i32, i32, i32, %union.anon }\n %union.anon = type { i32 }\n-%class.rust_task_list = type { %class.indexed_list, %struct.rust_scheduler*, i8* }\n+%class.rust_task_list = type { %class.indexed_list, %struct.rust_task_thread*, i8* }\n %class.indexed_list = type { i32 (...)**, %class.array_list.1 }\n %class.array_list.1 = type { i32, %struct.rust_task**, i32 }\n-%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_hashable_dict*, %struct.rust_scheduler*, i32 }\n+%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_hashable_dict*, %struct.rust_task_thread*, i32 }\n %struct.rust_hashable_dict = type { %struct.UT_hash_handle, [0 x i8*] }\n %struct.randctx = type { i32, [256 x i32], [256 x i32], i32, i32, i32 }\n %class.rust_kernel = type { i32 (...)**, %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, %class.array_list.3, %struct.randctx, i32, %class.hash_map, i32, i32, i32, %struct.rust_env* }\n-%class.array_list.3 = type { i32, %struct.rust_scheduler**, i32 }\n+%class.array_list.3 = type { i32, %struct.rust_task_thread**, i32 }\n %class.hash_map = type { %\"struct.hash_map<int, rust_task *>::map_entry\"* }\n %\"struct.hash_map<int, rust_task *>::map_entry\" = type opaque\n %union.pthread_attr_t = type { i32, [32 x i8] }"}, {"sha": "5f0e1709f6afe68c1f12173e3d02ca61bdfcf4fd", "filename": "src/rt/intrinsics/intrinsics.x86_64.ll.in", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -10,15 +10,15 @@ target triple = \"@CFG_TARGET_TRIPLE@\"\n %struct.rust_vec = type { i64, i64, [0 x i8] }\n %struct.rust_fn = type { i64*, %struct.rust_box* }\n %struct.rust_box = type opaque\n-%struct.rust_task = type { %struct.rust_task_user, i64, %class.context, %struct.stk_seg*, i64, %struct.rust_scheduler*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i64, i64*, i32, i32, %class.memory_region, %class.boxed_region, i8, i8, i8, %class.lock_and_signal, %class.hash_map.4, %class.rust_obstack, i32, %\"class.debug::task_debug_info\", i64 }\n+%struct.rust_task = type { %struct.rust_task_user, i64, %class.context, %struct.stk_seg*, i64, %struct.rust_task_thread*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i64, i64*, %class.memory_region, %class.boxed_region, i8, i8, i8, %class.lock_and_signal, %class.hash_map.4, %class.rust_obstack, i32, %\"class.debug::task_debug_info\", i64, [8 x i8] }\n %struct.rust_task_user = type { i64, i64, %struct.chan_handle, i64 }\n %struct.chan_handle = type { i64, i64 }\n %class.context = type { %struct.registers_t, %class.context*, [8 x i8] }\n %struct.registers_t = type { [22 x i64] }\n %struct.stk_seg = type { %struct.stk_seg*, %struct.stk_seg*, i64, i32, [0 x i8] }\n-%struct.rust_scheduler = type { %class.rust_thread, i64, i64, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, i32, i32, %class.lock_and_signal, i64, %union.pthread_attr_t, %struct.rust_env*, %class.context }\n+%struct.rust_task_thread = type { %class.rust_thread, i64, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, i32, i32, %class.lock_and_signal, i64, %union.pthread_attr_t, %struct.rust_env*, [8 x i8], %class.context, i8, [15 x i8] }\n %class.rust_thread = type { i32 (...)**, i8, i64 }\n-%class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_scheduler*, i8 }\n+%class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_task_thread*, i8 }\n %class.rust_srv = type { i32 (...)**, %struct.rust_env*, %class.memory_region }\n %struct.rust_env = type { i64, i64, i64, i8*, i8, i8, i8* }\n %class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %class.array_list, i8, i8, %class.lock_and_signal }\n@@ -30,14 +30,14 @@ target triple = \"@CFG_TARGET_TRIPLE@\"\n %union.pthread_mutex_t = type { %\"struct.<anonymous union>::__pthread_mutex_s\" }\n %\"struct.<anonymous union>::__pthread_mutex_s\" = type { i32, i32, i32, i32, i32, i32, %struct.__pthread_internal_list }\n %struct.__pthread_internal_list = type { %struct.__pthread_internal_list*, %struct.__pthread_internal_list* }\n-%class.rust_task_list = type { %class.indexed_list, %struct.rust_scheduler*, i8* }\n+%class.rust_task_list = type { %class.indexed_list, %struct.rust_task_thread*, i8* }\n %class.indexed_list = type { i32 (...)**, %class.array_list.1 }\n %class.array_list.1 = type { i64, %struct.rust_task**, i64 }\n-%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_hashable_dict*, %struct.rust_scheduler*, i64 }\n+%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_hashable_dict*, %struct.rust_task_thread*, i64 }\n %struct.rust_hashable_dict = type { %struct.UT_hash_handle, [0 x i8*] }\n %struct.randctx = type { i64, [256 x i64], [256 x i64], i64, i64, i64 }\n %class.rust_kernel = type { i32 (...)**, %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, %class.array_list.3, %struct.randctx, i64, %class.hash_map, i32, i64, i32, %struct.rust_env* }\n-%class.array_list.3 = type { i64, %struct.rust_scheduler**, i64 }\n+%class.array_list.3 = type { i64, %struct.rust_task_thread**, i64 }\n %class.hash_map = type { %\"struct.hash_map<long, rust_task *>::map_entry\"* }\n %\"struct.hash_map<long, rust_task *>::map_entry\" = type opaque\n %union.pthread_attr_t = type { i64, [48 x i8] }"}, {"sha": "aa1e05c0400428dee385965e1c6b14f7900363c5", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -90,15 +90,15 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n     rust_task_id root_id = kernel->create_task(NULL, \"main\", MAIN_STACK_SIZE);\n     rust_task *root_task = kernel->get_task_by_id(root_id);\n     I(kernel, root_task != NULL);\n-    rust_scheduler *sched = root_task->sched;\n+    rust_task_thread *thread = root_task->thread;\n     command_line_args *args\n         = new (kernel, \"main command line args\")\n         command_line_args(root_task, argc, argv);\n \n-    DLOG(sched, dom, \"startup: %d args in 0x%\" PRIxPTR,\n+    DLOG(thread, dom, \"startup: %d args in 0x%\" PRIxPTR,\n              args->argc, (uintptr_t)args->args);\n     for (int i = 0; i < args->argc; i++) {\n-        DLOG(sched, dom, \"startup: arg[%d] = '%s'\", i, args->argv[i]);\n+        DLOG(thread, dom, \"startup: arg[%d] = '%s'\", i, args->argv[i]);\n     }\n \n     root_task->start((spawn_fn)main_fn, NULL, args->args);"}, {"sha": "bccd55f4288c37ea31a41434a1f3b104aa9ea7b3", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -1,7 +1,7 @@\n /* Native builtins. */\n \n #include \"rust_internal.h\"\n-#include \"rust_scheduler.h\"\n+#include \"rust_task_thread.h\"\n #include \"rust_task.h\"\n #include \"rust_util.h\"\n #include \"sync/timer.h\"\n@@ -12,7 +12,7 @@\n \n extern \"C\" CDECL rust_str*\n last_os_error() {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n \n     LOG(task, task, \"last_os_error()\");\n \n@@ -55,7 +55,7 @@ last_os_error() {\n \n extern \"C\" CDECL rust_str *\n rust_getcwd() {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG(task, task, \"rust_getcwd()\");\n \n     char cbuf[BUF_BYTES];\n@@ -93,14 +93,14 @@ refcount(intptr_t *v) {\n \n extern \"C\" CDECL void\n unsupervise() {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     task->unsupervise();\n }\n \n extern \"C\" CDECL void\n vec_reserve_shared(type_desc* ty, rust_vec** vp,\n                    size_t n_elts) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     reserve_vec(task, vp, n_elts * ty->size);\n }\n \n@@ -110,7 +110,7 @@ vec_reserve_shared(type_desc* ty, rust_vec** vp,\n  */\n extern \"C\" CDECL rust_vec*\n vec_from_buf_shared(type_desc *ty, void *ptr, size_t count) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     size_t fill = ty->size * count;\n     rust_vec* v = (rust_vec*)task->kernel->malloc(fill + sizeof(rust_vec),\n                                                     \"vec_from_buf\");\n@@ -121,7 +121,7 @@ vec_from_buf_shared(type_desc *ty, void *ptr, size_t count) {\n \n extern \"C\" CDECL void\n rust_str_push(rust_vec** sp, uint8_t byte) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     size_t fill = (*sp)->fill;\n     reserve_vec(task, sp, fill + 1);\n     (*sp)->data[fill-1] = byte;\n@@ -131,14 +131,14 @@ rust_str_push(rust_vec** sp, uint8_t byte) {\n \n extern \"C\" CDECL void *\n rand_new() {\n-    rust_task *task = rust_scheduler::get_task();\n-    rust_scheduler *sched = task->sched;\n+    rust_task *task = rust_task_thread::get_task();\n+    rust_task_thread *thread = task->thread;\n     randctx *rctx = (randctx *) task->malloc(sizeof(randctx), \"randctx\");\n     if (!rctx) {\n         task->fail();\n         return NULL;\n     }\n-    isaac_init(sched, rctx);\n+    isaac_init(thread, rctx);\n     return rctx;\n }\n \n@@ -149,7 +149,7 @@ rand_next(randctx *rctx) {\n \n extern \"C\" CDECL void\n rand_free(randctx *rctx) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     task->free(rctx);\n }\n \n@@ -158,22 +158,22 @@ rand_free(randctx *rctx) {\n static void\n debug_tydesc_helper(type_desc *t)\n {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG(task, stdlib, \"  size %\" PRIdPTR \", align %\" PRIdPTR\n         \", first_param 0x%\" PRIxPTR,\n         t->size, t->align, t->first_param);\n }\n \n extern \"C\" CDECL void\n debug_tydesc(type_desc *t) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG(task, stdlib, \"debug_tydesc\");\n     debug_tydesc_helper(t);\n }\n \n extern \"C\" CDECL void\n debug_opaque(type_desc *t, uint8_t *front) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG(task, stdlib, \"debug_opaque\");\n     debug_tydesc_helper(t);\n     // FIXME may want to actually account for alignment.  `front` may not\n@@ -192,7 +192,7 @@ struct rust_box {\n \n extern \"C\" CDECL void\n debug_box(type_desc *t, rust_box *box) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG(task, stdlib, \"debug_box(0x%\" PRIxPTR \")\", box);\n     debug_tydesc_helper(t);\n     LOG(task, stdlib, \"  refcount %\" PRIdPTR,\n@@ -209,7 +209,7 @@ struct rust_tag {\n \n extern \"C\" CDECL void\n debug_tag(type_desc *t, rust_tag *tag) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n \n     LOG(task, stdlib, \"debug_tag\");\n     debug_tydesc_helper(t);\n@@ -227,7 +227,7 @@ struct rust_obj {\n \n extern \"C\" CDECL void\n debug_obj(type_desc *t, rust_obj *obj, size_t nmethods, size_t nbytes) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n \n     LOG(task, stdlib, \"debug_obj with %\" PRIdPTR \" methods\", nmethods);\n     debug_tydesc_helper(t);\n@@ -249,7 +249,7 @@ struct rust_fn {\n \n extern \"C\" CDECL void\n debug_fn(type_desc *t, rust_fn *fn) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG(task, stdlib, \"debug_fn\");\n     debug_tydesc_helper(t);\n     LOG(task, stdlib, \"  thunk at 0x%\" PRIxPTR, fn->thunk);\n@@ -263,7 +263,7 @@ extern \"C\" CDECL void *\n debug_ptrcast(type_desc *from_ty,\n               type_desc *to_ty,\n               void *ptr) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG(task, stdlib, \"debug_ptrcast from\");\n     debug_tydesc_helper(from_ty);\n     LOG(task, stdlib, \"to\");\n@@ -273,13 +273,13 @@ debug_ptrcast(type_desc *from_ty,\n \n extern \"C\" CDECL void *\n debug_get_stk_seg() {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     return task->stk;\n }\n \n extern \"C\" CDECL rust_vec*\n rust_list_files(rust_str *path) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     array_list<rust_str*> strings;\n #if defined(__WIN32__)\n     WIN32_FIND_DATA FindFileData;\n@@ -346,7 +346,7 @@ rust_ptr_eq(type_desc *t, rust_box *a, rust_box *b) {\n #if defined(__WIN32__)\n extern \"C\" CDECL void\n get_time(uint32_t *sec, uint32_t *usec) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     SYSTEMTIME systemTime;\n     FILETIME fileTime;\n     GetSystemTime(&systemTime);\n@@ -377,13 +377,13 @@ nano_time(uint64_t *ns) {\n \n extern \"C\" CDECL rust_task_id\n get_task_id() {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     return task->user.id;\n }\n \n extern \"C\" CDECL rust_task_id\n new_task() {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     return task->kernel->create_task(task, NULL);\n }\n \n@@ -396,32 +396,32 @@ drop_task(rust_task *target) {\n \n extern \"C\" CDECL rust_task *\n get_task_pointer(rust_task_id id) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     return task->kernel->get_task_by_id(id);\n }\n \n extern \"C\" rust_task *\n rust_get_task() {\n-    return rust_scheduler::get_task();\n+    return rust_task_thread::get_task();\n }\n \n extern \"C\" CDECL void\n start_task(rust_task_id id, fn_env_pair *f) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     rust_task *target = task->kernel->get_task_by_id(id);\n     target->start(f->f, f->env, NULL);\n     target->deref();\n }\n \n extern \"C\" CDECL int\n sched_threads() {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     return task->kernel->num_threads;\n }\n \n extern \"C\" CDECL rust_port*\n new_port(size_t unit_sz) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG(task, comm, \"new_port(task=0x%\" PRIxPTR \" (%s), unit_sz=%d)\",\n         (uintptr_t) task, task->name, unit_sz);\n     // port starts with refcount == 1\n@@ -430,7 +430,7 @@ new_port(size_t unit_sz) {\n \n extern \"C\" CDECL void\n rust_port_detach(rust_port *port) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG(task, comm, \"rust_port_detach(0x%\" PRIxPTR \")\", (uintptr_t) port);\n     port->detach();\n     // FIXME: Busy waiting until we're the only ref\n@@ -443,9 +443,9 @@ rust_port_detach(rust_port *port) {\n \n extern \"C\" CDECL void\n del_port(rust_port *port) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG(task, comm, \"del_port(0x%\" PRIxPTR \")\", (uintptr_t) port);\n-    A(task->sched, port->ref_count == 1, \"Expected port ref_count == 1\");\n+    A(task->thread, port->ref_count == 1, \"Expected port ref_count == 1\");\n     port->deref();\n }\n \n@@ -464,7 +464,7 @@ chan_id_send(type_desc *t, rust_task_id target_task_id,\n              rust_port_id target_port_id, void *sptr) {\n     // FIXME: make sure this is thread-safe\n     bool sent = false;\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     rust_task *target_task = task->kernel->get_task_by_id(target_task_id);\n     if(target_task) {\n         rust_port *port = target_task->get_port_by_id(target_port_id);\n@@ -491,7 +491,7 @@ port_recv(uintptr_t *dptr, rust_port *port,\n           uintptr_t *yield, uintptr_t *killed) {\n     *yield = false;\n     *killed = false;\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     {\n         scoped_lock with(port->lock);\n \n@@ -524,7 +524,7 @@ port_recv(uintptr_t *dptr, rust_port *port,\n \n extern \"C\" CDECL void\n rust_set_exit_status(intptr_t code) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     task->kernel->set_exit_status((int)code);\n }\n \n@@ -539,7 +539,7 @@ extern void log_console_off(rust_env *env);\n \n extern \"C\" CDECL void\n rust_log_console_off() {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     log_console_off(task->kernel->env);\n }\n "}, {"sha": "0294069051bddcd99150393a9d73e2af43634677", "filename": "src/rt/rust_crate_cache.cpp", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_crate_cache.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_crate_cache.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate_cache.cpp?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -9,20 +9,20 @@ rust_crate_cache::get_type_desc(size_t size,\n                                 type_desc const **descs,\n                                 uintptr_t n_obj_params)\n {\n-    I(sched, n_descs > 1);\n+    I(thread, n_descs > 1);\n     type_desc *td = NULL;\n     size_t keysz = n_descs * sizeof(type_desc*);\n     HASH_FIND(hh, this->type_descs, descs, keysz, td);\n     if (td) {\n-        DLOG(sched, cache, \"rust_crate_cache::get_type_desc hit\");\n+        DLOG(thread, cache, \"rust_crate_cache::get_type_desc hit\");\n \n         // FIXME: This is a gross hack.\n         td->n_obj_params = std::max(td->n_obj_params, n_obj_params);\n \n         return td;\n     }\n-    DLOG(sched, cache, \"rust_crate_cache::get_type_desc miss\");\n-    td = (type_desc*) sched->kernel->malloc(sizeof(type_desc) + keysz,\n+    DLOG(thread, cache, \"rust_crate_cache::get_type_desc miss\");\n+    td = (type_desc*) thread->kernel->malloc(sizeof(type_desc) + keysz,\n                                             \"crate cache typedesc\");\n     if (!td)\n         return NULL;\n@@ -34,7 +34,7 @@ rust_crate_cache::get_type_desc(size_t size,\n     td->size = size;\n     td->align = align;\n     for (size_t i = 0; i < n_descs; ++i) {\n-        DLOG(sched, cache,\n+        DLOG(thread, cache,\n                  \"rust_crate_cache::descs[%\" PRIdPTR \"] = 0x%\" PRIxPTR,\n                  i, descs[i]);\n         td->descs[i] = descs[i];\n@@ -52,7 +52,7 @@ rust_crate_cache::get_dict(size_t n_fields, void** dict) {\n     HASH_FIND(hh, this->dicts, dict, dictsz, found);\n     if (found) return &(found->fields[0]);\n     found = (rust_hashable_dict*)\n-        sched->kernel->malloc(sizeof(UT_hash_handle) + dictsz,\n+        thread->kernel->malloc(sizeof(UT_hash_handle) + dictsz,\n                               \"crate cache dict\");\n     if (!found) return NULL;\n     void** retptr = &(found->fields[0]);\n@@ -61,28 +61,28 @@ rust_crate_cache::get_dict(size_t n_fields, void** dict) {\n     return retptr;\n }\n \n-rust_crate_cache::rust_crate_cache(rust_scheduler *sched)\n+rust_crate_cache::rust_crate_cache(rust_task_thread *thread)\n     : type_descs(NULL),\n       dicts(NULL),\n-      sched(sched),\n+      thread(thread),\n       idx(0)\n {\n }\n \n void\n rust_crate_cache::flush() {\n-    DLOG(sched, cache, \"rust_crate_cache::flush()\");\n+    DLOG(thread, cache, \"rust_crate_cache::flush()\");\n \n     while (type_descs) {\n         type_desc *d = type_descs;\n         HASH_DEL(type_descs, d);\n-        DLOG(sched, mem, \"rust_crate_cache::flush() tydesc %\" PRIxPTR, d);\n-        sched->kernel->free(d);\n+        DLOG(thread, mem, \"rust_crate_cache::flush() tydesc %\" PRIxPTR, d);\n+        thread->kernel->free(d);\n     }\n     while (dicts) {\n         rust_hashable_dict *d = dicts;\n         HASH_DEL(dicts, d);\n-        sched->kernel->free(d);\n+        thread->kernel->free(d);\n     }\n }\n "}, {"sha": "8536681ecad095d1c16d0ac73242da87f76c3f0a", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -50,7 +50,7 @@ extern \"C\" {\n #include \"sync/lock_and_signal.h\"\n #include \"sync/lock_free_queue.h\"\n \n-struct rust_scheduler;\n+struct rust_task_thread;\n struct rust_task;\n class rust_log;\n class rust_port;\n@@ -217,7 +217,7 @@ template <typename T> class ptr_vec : public task_owned<ptr_vec<T> > {\n #include \"rust_srv.h\"\n #include \"rust_log.h\"\n #include \"rust_kernel.h\"\n-#include \"rust_scheduler.h\"\n+#include \"rust_task_thread.h\"\n \n typedef void CDECL (glue_fn)(void *, void *,\n                              const type_desc **, void *);"}, {"sha": "f1ce434cd34731bd85edab7a32ff9f82563210fc", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -20,25 +20,25 @@ rust_kernel::rust_kernel(rust_srv *srv, size_t num_threads) :\n     create_schedulers();\n }\n \n-rust_scheduler *\n+rust_task_thread *\n rust_kernel::create_scheduler(int id) {\n     _kernel_lock.lock();\n     rust_srv *srv = this->srv->clone();\n-    rust_scheduler *sched =\n-        new (this, \"rust_scheduler\") rust_scheduler(this, srv, id);\n+    rust_task_thread *thread =\n+        new (this, \"rust_task_thread\") rust_task_thread(this, srv, id);\n     KLOG_(\"created scheduler: \" PTR \", id: %d, index: %d\",\n-          sched, id, sched->list_index);\n+          thread, id, thread->list_index);\n     _kernel_lock.unlock();\n-    return sched;\n+    return thread;\n }\n \n void\n-rust_kernel::destroy_scheduler(rust_scheduler *sched) {\n+rust_kernel::destroy_scheduler(rust_task_thread *thread) {\n     _kernel_lock.lock();\n     KLOG_(\"deleting scheduler: \" PTR \", name: %s, index: %d\",\n-        sched, sched->name, sched->list_index);\n-    rust_srv *srv = sched->srv;\n-    delete sched;\n+        thread, thread->name, thread->list_index);\n+    rust_srv *srv = thread->srv;\n+    delete thread;\n     delete srv;\n     _kernel_lock.unlock();\n }\n@@ -120,12 +120,12 @@ rust_kernel::signal_kernel_lock() {\n int rust_kernel::start_task_threads()\n {\n     for(size_t i = 0; i < num_threads; ++i) {\n-        rust_scheduler *thread = threads[i];\n+        rust_task_thread *thread = threads[i];\n         thread->start();\n     }\n \n     for(size_t i = 0; i < num_threads; ++i) {\n-        rust_scheduler *thread = threads[i];\n+        rust_task_thread *thread = threads[i];\n         thread->join();\n     }\n \n@@ -142,7 +142,7 @@ rust_kernel::fail() {\n     exit(rval);\n #endif\n     for(size_t i = 0; i < num_threads; ++i) {\n-        rust_scheduler *thread = threads[i];\n+        rust_task_thread *thread = threads[i];\n         thread->kill_all_tasks();\n     }\n }\n@@ -151,7 +151,7 @@ rust_task_id\n rust_kernel::create_task(rust_task *spawner, const char *name,\n                          size_t init_stack_sz) {\n     scoped_lock with(_kernel_lock);\n-    rust_scheduler *thread = threads[isaac_rand(&rctx) % num_threads];\n+    rust_task_thread *thread = threads[isaac_rand(&rctx) % num_threads];\n     rust_task *t = thread->create_task(spawner, name, init_stack_sz);\n     t->user.id = max_id++;\n     task_table.put(t->user.id, t);"}, {"sha": "963c503bee516868587d3289d9e7e86e8d96b02f", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -5,7 +5,7 @@\n #include \"memory_region.h\"\n #include \"rust_log.h\"\n \n-struct rust_scheduler;\n+struct rust_task_thread;\n \n /**\n  * A global object shared by all thread domains. Most of the data structures\n@@ -21,12 +21,12 @@ class rust_kernel {\n private:\n     lock_and_signal _kernel_lock;\n \n-    array_list<rust_scheduler *> threads;\n+    array_list<rust_task_thread *> threads;\n \n     randctx rctx;\n \n-    rust_scheduler *create_scheduler(int id);\n-    void destroy_scheduler(rust_scheduler *sched);\n+    rust_task_thread *create_scheduler(int id);\n+    void destroy_scheduler(rust_task_thread *thread);\n \n     void create_schedulers();\n     void destroy_schedulers();"}, {"sha": "729ca2462e885ab095b85d40f884c74e9dae847d", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -40,9 +40,9 @@ log_console_off(rust_env *env) {\n     }\n }\n \n-rust_log::rust_log(rust_srv *srv, rust_scheduler *sched) :\n+rust_log::rust_log(rust_srv *srv, rust_task_thread *thread) :\n     _srv(srv),\n-    _sched(sched) {\n+    _thread(thread) {\n }\n \n rust_log::~rust_log() {\n@@ -118,12 +118,12 @@ rust_log::trace_ln(rust_task *task, uint32_t level, char *message) {\n #endif\n \n     char prefix[BUF_BYTES] = \"\";\n-    if (_sched && _sched->name) {\n+    if (_thread && _thread->name) {\n         append_string(prefix, \"%04\" PRIxPTR \":%.10s:\",\n-                      thread_id, _sched->name);\n+                      thread_id, _thread->name);\n     } else {\n         append_string(prefix, \"%04\" PRIxPTR \":0x%08\" PRIxPTR \":\",\n-                      thread_id, (uintptr_t) _sched);\n+                      thread_id, (uintptr_t) _thread);\n     }\n     if (task) {\n         if (task->name) {"}, {"sha": "8c5e87cf4927dd63b80beb7db4cf389755333fda", "filename": "src/rt/rust_log.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_log.h", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_log.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.h?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -8,18 +8,18 @@ const uint32_t log_info = 2;\n const uint32_t log_debug = 3;\n \n #define LOG(task, field, ...)                                   \\\n-    DLOG_LVL(log_debug, task, task->sched, field, __VA_ARGS__)\n+    DLOG_LVL(log_debug, task, task->thread, field, __VA_ARGS__)\n #define LOG_ERR(task, field, ...)                               \\\n-    DLOG_LVL(log_err, task, task->sched, field, __VA_ARGS__)\n-#define DLOG(sched, field, ...)                                   \\\n-    DLOG_LVL(log_debug, NULL, sched, field, __VA_ARGS__)\n-#define DLOG_ERR(sched, field, ...)                               \\\n-    DLOG_LVL(log_err, NULL, sched, field, __VA_ARGS__)\n-#define LOGPTR(sched, msg, ptrval)                                \\\n-    DLOG_LVL(log_debug, NULL, sched, mem, \"%s 0x%\" PRIxPTR, msg, ptrval)\n-#define DLOG_LVL(lvl, task, sched, field, ...)                    \\\n+    DLOG_LVL(log_err, task, task->thread, field, __VA_ARGS__)\n+#define DLOG(thread, field, ...)                                   \\\n+    DLOG_LVL(log_debug, NULL, thread, field, __VA_ARGS__)\n+#define DLOG_ERR(thread, field, ...)                               \\\n+    DLOG_LVL(log_err, NULL, thread, field, __VA_ARGS__)\n+#define LOGPTR(thread, msg, ptrval)                                \\\n+    DLOG_LVL(log_debug, NULL, thread, mem, \"%s 0x%\" PRIxPTR, msg, ptrval)\n+#define DLOG_LVL(lvl, task, thread, field, ...)                    \\\n     do {                                                        \\\n-        rust_scheduler* _d_ = sched;                            \\\n+        rust_task_thread* _d_ = thread;                            \\\n         if (log_rt_##field >= lvl && _d_->log_lvl >= lvl) {     \\\n             _d_->log(task, lvl, __VA_ARGS__);                   \\\n         }                                                       \\\n@@ -34,13 +34,13 @@ const uint32_t log_debug = 3;\n         }                                                     \\\n     } while (0)\n \n-struct rust_scheduler;\n+struct rust_task_thread;\n struct rust_task;\n \n class rust_log {\n \n public:\n-    rust_log(rust_srv *srv, rust_scheduler *sched);\n+    rust_log(rust_srv *srv, rust_task_thread *thread);\n     virtual ~rust_log();\n \n     void trace_ln(rust_task *task, uint32_t level, char *message);\n@@ -49,7 +49,7 @@ class rust_log {\n \n private:\n     rust_srv *_srv;\n-    rust_scheduler *_sched;\n+    rust_task_thread *_thread;\n     bool _use_labels;\n     void trace_ln(rust_task *task, char *message);\n };"}, {"sha": "a917c12e151a32ff400ca66dcf6cfbaeabbbaade", "filename": "src/rt/rust_port.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_port.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_port.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.cpp?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -21,15 +21,15 @@ rust_port::~rust_port() {\n }\n \n void rust_port::detach() {\n-    I(task->sched, !task->lock.lock_held_by_current_thread());\n+    I(task->thread, !task->lock.lock_held_by_current_thread());\n     scoped_lock with(task->lock);\n     {\n         task->release_port(id);\n     }\n }\n \n void rust_port::send(void *sptr) {\n-    I(task->sched, !lock.lock_held_by_current_thread());\n+    I(task->thread, !lock.lock_held_by_current_thread());\n     scoped_lock with(lock);\n \n     buffer.enqueue(sptr);\n@@ -46,7 +46,7 @@ void rust_port::send(void *sptr) {\n }\n \n bool rust_port::receive(void *dptr) {\n-    I(task->sched, lock.lock_held_by_current_thread());\n+    I(task->thread, lock.lock_held_by_current_thread());\n     if (buffer.is_empty() == false) {\n         buffer.dequeue(dptr);\n         LOG(task, comm, \"<=== read data ===\");\n@@ -56,7 +56,7 @@ bool rust_port::receive(void *dptr) {\n }\n \n size_t rust_port::size() {\n-    I(task->sched, !lock.lock_held_by_current_thread());\n+    I(task->thread, !lock.lock_held_by_current_thread());\n     scoped_lock with(lock);\n     return buffer.size();\n }"}, {"sha": "20f8bef89aad915672165ee8b19f1134884cf267", "filename": "src/rt/rust_shape.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -532,7 +532,7 @@ extern \"C\" void\n shape_cmp_type(int8_t *result, const type_desc *tydesc,\n \t       const type_desc **subtydescs, uint8_t *data_0,\n \t       uint8_t *data_1, uint8_t cmp_type) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     shape::arena arena;\n \n     // FIXME: This may well be broken when comparing two closures or objects\n@@ -553,7 +553,7 @@ shape_cmp_type(int8_t *result, const type_desc *tydesc,\n \n extern \"C\" rust_str *\n shape_log_str(const type_desc *tydesc, uint8_t *data) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n \n     shape::arena arena;\n     shape::type_param *params =\n@@ -571,7 +571,7 @@ shape_log_str(const type_desc *tydesc, uint8_t *data) {\n \n extern \"C\" void\n shape_log_type(const type_desc *tydesc, uint8_t *data, uint32_t level) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n \n     shape::arena arena;\n     shape::type_param *params =\n@@ -583,6 +583,6 @@ shape_log_type(const type_desc *tydesc, uint8_t *data, uint32_t level) {\n \n     log.walk();\n \n-    task->sched->log(task, level, \"%s\", ss.str().c_str());\n+    task->thread->log(task, level, \"%s\", ss.str().c_str());\n }\n "}, {"sha": "4612a4858d8ef2c6fe7021ce81cd5d8208026332", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -67,7 +67,7 @@ const uint8_t stack_canary[] = {0xAB, 0xCD, 0xAB, 0xCD,\n                                 0xAB, 0xCD, 0xAB, 0xCD};\n \n static size_t\n-get_next_stk_size(rust_scheduler *sched, rust_task *task,\n+get_next_stk_size(rust_task_thread *thread, rust_task *task,\n                   size_t min, size_t current, size_t requested) {\n     LOG(task, mem, \"calculating new stack size for 0x%\" PRIxPTR, task);\n     LOG(task, mem,\n@@ -84,7 +84,7 @@ get_next_stk_size(rust_scheduler *sched, rust_task *task,\n     sz = std::max(sz, next);\n \n     LOG(task, mem, \"next stack size: %\" PRIdPTR, sz);\n-    I(sched, requested <= sz);\n+    I(thread, requested <= sz);\n     return sz;\n }\n \n@@ -132,29 +132,29 @@ user_stack_size(stk_seg *stk) {\n \n static void\n free_stk(rust_task *task, stk_seg *stk) {\n-    LOGPTR(task->sched, \"freeing stk segment\", (uintptr_t)stk);\n+    LOGPTR(task->thread, \"freeing stk segment\", (uintptr_t)stk);\n     task->total_stack_sz -= user_stack_size(stk);\n     task->free(stk);\n }\n \n static stk_seg*\n-new_stk(rust_scheduler *sched, rust_task *task, size_t requested_sz)\n+new_stk(rust_task_thread *thread, rust_task *task, size_t requested_sz)\n {\n     LOG(task, mem, \"creating new stack for task %\" PRIxPTR, task);\n     if (task->stk) {\n         check_stack_canary(task->stk);\n     }\n \n     // The minimum stack size, in bytes, of a Rust stack, excluding red zone\n-    size_t min_sz = sched->min_stack_size;\n+    size_t min_sz = thread->min_stack_size;\n \n     // Try to reuse an existing stack segment\n     if (task->stk != NULL && task->stk->prev != NULL) {\n         size_t prev_sz = user_stack_size(task->stk->prev);\n         if (min_sz <= prev_sz && requested_sz <= prev_sz) {\n             LOG(task, mem, \"reusing existing stack\");\n             task->stk = task->stk->prev;\n-            A(sched, task->stk->prev == NULL, \"Bogus stack ptr\");\n+            A(thread, task->stk->prev == NULL, \"Bogus stack ptr\");\n             config_valgrind_stack(task->stk);\n             return task->stk;\n         } else {\n@@ -170,23 +170,23 @@ new_stk(rust_scheduler *sched, rust_task *task, size_t requested_sz)\n         current_sz = user_stack_size(task->stk);\n     }\n     // The calculated size of the new stack, excluding red zone\n-    size_t rust_stk_sz = get_next_stk_size(sched, task, min_sz,\n+    size_t rust_stk_sz = get_next_stk_size(thread, task, min_sz,\n                                            current_sz, requested_sz);\n \n-    if (task->total_stack_sz + rust_stk_sz > sched->env->max_stack_size) {\n+    if (task->total_stack_sz + rust_stk_sz > thread->env->max_stack_size) {\n         LOG_ERR(task, task, \"task %\" PRIxPTR \" ran out of stack\", task);\n         task->fail();\n     }\n \n     size_t sz = sizeof(stk_seg) + rust_stk_sz + RED_ZONE_SIZE;\n     stk_seg *stk = (stk_seg *)task->malloc(sz, \"stack\");\n-    LOGPTR(task->sched, \"new stk\", (uintptr_t)stk);\n+    LOGPTR(task->thread, \"new stk\", (uintptr_t)stk);\n     memset(stk, 0, sizeof(stk_seg));\n     add_stack_canary(stk);\n     stk->prev = NULL;\n     stk->next = task->stk;\n     stk->end = (uintptr_t) &stk->data[rust_stk_sz + RED_ZONE_SIZE];\n-    LOGPTR(task->sched, \"stk end\", stk->end);\n+    LOGPTR(task->thread, \"stk end\", stk->end);\n \n     task->stk = stk;\n     config_valgrind_stack(task->stk);\n@@ -222,20 +222,20 @@ del_stk(rust_task *task, stk_seg *stk)\n     unconfig_valgrind_stack(stk);\n     if (delete_stack) {\n         free_stk(task, stk);\n-        A(task->sched, task->total_stack_sz == 0, \"Stack size should be 0\");\n+        A(task->thread, task->total_stack_sz == 0, \"Stack size should be 0\");\n     }\n }\n \n // Tasks\n-rust_task::rust_task(rust_scheduler *sched, rust_task_list *state,\n+rust_task::rust_task(rust_task_thread *thread, rust_task_list *state,\n                      rust_task *spawner, const char *name,\n                      size_t init_stack_sz) :\n     ref_count(1),\n     stk(NULL),\n     runtime_sp(0),\n-    sched(sched),\n+    thread(thread),\n     cache(NULL),\n-    kernel(sched->kernel),\n+    kernel(thread->kernel),\n     name(name),\n     state(state),\n     cond(NULL),\n@@ -244,7 +244,7 @@ rust_task::rust_task(rust_scheduler *sched, rust_task_list *state,\n     list_index(-1),\n     next_port_id(0),\n     rendezvous_ptr(0),\n-    local_region(&sched->srv->local_region),\n+    local_region(&thread->srv->local_region),\n     boxed(&local_region),\n     unwinding(false),\n     killed(false),\n@@ -253,14 +253,14 @@ rust_task::rust_task(rust_scheduler *sched, rust_task_list *state,\n     cc_counter(0),\n     total_stack_sz(0)\n {\n-    LOGPTR(sched, \"new task\", (uintptr_t)this);\n-    DLOG(sched, task, \"sizeof(task) = %d (0x%x)\", sizeof *this, sizeof *this);\n+    LOGPTR(thread, \"new task\", (uintptr_t)this);\n+    DLOG(thread, task, \"sizeof(task) = %d (0x%x)\", sizeof *this, sizeof *this);\n \n     assert((void*)this == (void*)&user);\n \n     user.notify_enabled = 0;\n \n-    stk = new_stk(sched, this, init_stack_sz);\n+    stk = new_stk(thread, this, init_stack_sz);\n     user.rust_sp = stk->end;\n     if (supervisor) {\n         supervisor->ref();\n@@ -269,9 +269,9 @@ rust_task::rust_task(rust_scheduler *sched, rust_task_list *state,\n \n rust_task::~rust_task()\n {\n-    I(sched, !sched->lock.lock_held_by_current_thread());\n-    I(sched, port_table.is_empty());\n-    DLOG(sched, task, \"~rust_task %s @0x%\" PRIxPTR \", refcnt=%d\",\n+    I(thread, !thread->lock.lock_held_by_current_thread());\n+    I(thread, port_table.is_empty());\n+    DLOG(thread, task, \"~rust_task %s @0x%\" PRIxPTR \", refcnt=%d\",\n          name, (uintptr_t)this, ref_count);\n \n     if (supervisor) {\n@@ -282,7 +282,7 @@ rust_task::~rust_task()\n \n     /* FIXME: tighten this up, there are some more\n        assertions that hold at task-lifecycle events. */\n-    I(sched, ref_count == 0); // ||\n+    I(thread, ref_count == 0); // ||\n     //   (ref_count == 1 && this == sched->root_task));\n \n     // Delete all the stacks. There may be more than one if the task failed\n@@ -325,7 +325,7 @@ cleanup_task(cleanup_args *args) {\n #ifndef __WIN32__\n         task->conclude_failure();\n #else\n-        A(task->sched, false, \"Shouldn't happen\");\n+        A(task->thread, false, \"Shouldn't happen\");\n #endif\n     }\n }\n@@ -342,7 +342,7 @@ void task_start_wrapper(spawn_args *a)\n         // must have void return type, we can safely pass 0.\n         a->f(0, a->envptr, a->argptr);\n     } catch (rust_task *ex) {\n-        A(task->sched, ex == task,\n+        A(task->thread, ex == task,\n           \"Expected this task to be thrown for unwinding\");\n         threw_exception = true;\n     }\n@@ -359,7 +359,7 @@ void task_start_wrapper(spawn_args *a)\n \n     // The cleanup work needs lots of stack\n     cleanup_args ca = {a, threw_exception};\n-    task->sched->c_context.call_shim_on_c_stack(&ca, (void*)cleanup_task);\n+    task->thread->c_context.call_shim_on_c_stack(&ca, (void*)cleanup_task);\n \n     task->ctx.next->swap(task->ctx);\n }\n@@ -373,7 +373,7 @@ rust_task::start(spawn_fn spawnee_fn,\n         \" with env 0x%\" PRIxPTR \" and arg 0x%\" PRIxPTR,\n         spawnee_fn, envptr, argptr);\n \n-    I(sched, stk->data != NULL);\n+    I(thread, stk->data != NULL);\n \n     char *sp = (char *)user.rust_sp;\n \n@@ -393,7 +393,7 @@ rust_task::start(spawn_fn spawnee_fn,\n \n void rust_task::start()\n {\n-    transition(&sched->newborn_tasks, &sched->running_tasks);\n+    transition(&thread->newborn_tasks, &thread->running_tasks);\n }\n \n // Only run this on the rust stack\n@@ -440,7 +440,7 @@ bool rust_task_is_unwinding(rust_task *rt) {\n void\n rust_task::fail() {\n     // See note in ::kill() regarding who should call this.\n-    DLOG(sched, task, \"task %s @0x%\" PRIxPTR \" failing\", name, this);\n+    DLOG(thread, task, \"task %s @0x%\" PRIxPTR \" failing\", name, this);\n     backtrace();\n     unwinding = true;\n #ifndef __WIN32__\n@@ -449,7 +449,7 @@ rust_task::fail() {\n     die();\n     conclude_failure();\n     // FIXME: Need unwinding on windows. This will end up aborting\n-    sched->fail();\n+    thread->fail();\n #endif\n }\n \n@@ -461,22 +461,22 @@ rust_task::conclude_failure() {\n void\n rust_task::fail_parent() {\n     if (supervisor) {\n-        DLOG(sched, task,\n+        DLOG(thread, task,\n              \"task %s @0x%\" PRIxPTR\n              \" propagating failure to supervisor %s @0x%\" PRIxPTR,\n              name, this, supervisor->name, supervisor);\n         supervisor->kill();\n     }\n     // FIXME: implement unwinding again.\n     if (NULL == supervisor && propagate_failure)\n-        sched->fail();\n+        thread->fail();\n }\n \n void\n rust_task::unsupervise()\n {\n     if (supervisor) {\n-        DLOG(sched, task,\n+        DLOG(thread, task,\n              \"task %s @0x%\" PRIxPTR\n              \" disconnecting from supervisor %s @0x%\" PRIxPTR,\n              name, this, supervisor->name, supervisor);\n@@ -495,13 +495,13 @@ rust_task::get_frame_glue_fns(uintptr_t fp) {\n bool\n rust_task::running()\n {\n-    return state == &sched->running_tasks;\n+    return state == &thread->running_tasks;\n }\n \n bool\n rust_task::blocked()\n {\n-    return state == &sched->blocked_tasks;\n+    return state == &thread->blocked_tasks;\n }\n \n bool\n@@ -513,7 +513,7 @@ rust_task::blocked_on(rust_cond *on)\n bool\n rust_task::dead()\n {\n-    return state == &sched->dead_tasks;\n+    return state == &thread->dead_tasks;\n }\n \n void *\n@@ -537,55 +537,55 @@ rust_task::free(void *p)\n void\n rust_task::transition(rust_task_list *src, rust_task_list *dst) {\n     bool unlock = false;\n-    if(!sched->lock.lock_held_by_current_thread()) {\n+    if(!thread->lock.lock_held_by_current_thread()) {\n         unlock = true;\n-        sched->lock.lock();\n+        thread->lock.lock();\n     }\n-    DLOG(sched, task,\n+    DLOG(thread, task,\n          \"task %s \" PTR \" state change '%s' -> '%s' while in '%s'\",\n          name, (uintptr_t)this, src->name, dst->name, state->name);\n-    I(sched, state == src);\n+    I(thread, state == src);\n     src->remove(this);\n     dst->append(this);\n     state = dst;\n-    sched->lock.signal();\n+    thread->lock.signal();\n     if(unlock)\n-        sched->lock.unlock();\n+        thread->lock.unlock();\n }\n \n void\n rust_task::block(rust_cond *on, const char* name) {\n-    I(sched, !lock.lock_held_by_current_thread());\n+    I(thread, !lock.lock_held_by_current_thread());\n     scoped_lock with(lock);\n     LOG(this, task, \"Blocking on 0x%\" PRIxPTR \", cond: 0x%\" PRIxPTR,\n                          (uintptr_t) on, (uintptr_t) cond);\n-    A(sched, cond == NULL, \"Cannot block an already blocked task.\");\n-    A(sched, on != NULL, \"Cannot block on a NULL object.\");\n+    A(thread, cond == NULL, \"Cannot block an already blocked task.\");\n+    A(thread, on != NULL, \"Cannot block on a NULL object.\");\n \n-    transition(&sched->running_tasks, &sched->blocked_tasks);\n+    transition(&thread->running_tasks, &thread->blocked_tasks);\n     cond = on;\n     cond_name = name;\n }\n \n void\n rust_task::wakeup(rust_cond *from) {\n-    I(sched, !lock.lock_held_by_current_thread());\n+    I(thread, !lock.lock_held_by_current_thread());\n     scoped_lock with(lock);\n-    A(sched, cond != NULL, \"Cannot wake up unblocked task.\");\n+    A(thread, cond != NULL, \"Cannot wake up unblocked task.\");\n     LOG(this, task, \"Blocked on 0x%\" PRIxPTR \" woken up on 0x%\" PRIxPTR,\n                         (uintptr_t) cond, (uintptr_t) from);\n-    A(sched, cond == from, \"Cannot wake up blocked task on wrong condition.\");\n+    A(thread, cond == from, \"Cannot wake up blocked task on wrong condition.\");\n \n     cond = NULL;\n     cond_name = \"none\";\n-    transition(&sched->blocked_tasks, &sched->running_tasks);\n+    transition(&thread->blocked_tasks, &thread->running_tasks);\n }\n \n void\n rust_task::die() {\n-    I(sched, !lock.lock_held_by_current_thread());\n+    I(thread, !lock.lock_held_by_current_thread());\n     scoped_lock with(lock);\n-    transition(&sched->running_tasks, &sched->dead_tasks);\n+    transition(&thread->running_tasks, &thread->dead_tasks);\n }\n \n void\n@@ -601,8 +601,8 @@ rust_crate_cache *\n rust_task::get_crate_cache()\n {\n     if (!cache) {\n-        DLOG(sched, task, \"fetching cache for current crate\");\n-        cache = sched->get_cache();\n+        DLOG(thread, task, \"fetching cache for current crate\");\n+        cache = thread->get_cache();\n     }\n     return cache;\n }\n@@ -623,7 +623,7 @@ rust_task::calloc(size_t size, const char *tag) {\n }\n \n rust_port_id rust_task::register_port(rust_port *port) {\n-    I(sched, !lock.lock_held_by_current_thread());\n+    I(thread, !lock.lock_held_by_current_thread());\n     scoped_lock with(lock);\n \n     rust_port_id id = next_port_id++;\n@@ -632,12 +632,12 @@ rust_port_id rust_task::register_port(rust_port *port) {\n }\n \n void rust_task::release_port(rust_port_id id) {\n-    I(sched, lock.lock_held_by_current_thread());\n+    I(thread, lock.lock_held_by_current_thread());\n     port_table.remove(id);\n }\n \n rust_port *rust_task::get_port_by_id(rust_port_id id) {\n-    I(sched, !lock.lock_held_by_current_thread());\n+    I(thread, !lock.lock_held_by_current_thread());\n     scoped_lock with(lock);\n     rust_port *port = NULL;\n     port_table.get(id, &port);\n@@ -675,8 +675,8 @@ record_sp(void *limit);\n void *\n rust_task::new_stack(size_t stk_sz, void *args_addr, size_t args_sz) {\n \n-    stk_seg *stk_seg = new_stk(sched, this, stk_sz + args_sz);\n-    A(sched, stk_seg->end - (uintptr_t)stk_seg->data >= stk_sz + args_sz,\n+    stk_seg *stk_seg = new_stk(thread, this, stk_sz + args_sz);\n+    A(thread, stk_seg->end - (uintptr_t)stk_seg->data >= stk_sz + args_sz,\n       \"Did not receive enough stack\");\n     uint8_t *new_sp = (uint8_t*)stk_seg->end;\n     // Push the function arguments to the new stack\n@@ -700,7 +700,7 @@ rust_task::record_stack_limit() {\n     // subtracting the frame size. As a result we need our stack limit to\n     // account for those 256 bytes.\n     const unsigned LIMIT_OFFSET = 256;\n-    A(sched,\n+    A(thread,\n       (uintptr_t)stk->end - RED_ZONE_SIZE\n       - (uintptr_t)stk->data >= LIMIT_OFFSET,\n       \"Stack size must be greater than LIMIT_OFFSET\");\n@@ -731,7 +731,7 @@ rust_task::reset_stack_limit() {\n     uintptr_t sp = get_sp();\n     while (!sp_in_stk_seg(sp, stk)) {\n         del_stk(this, stk);\n-        A(sched, stk != NULL, \"Failed to find the current stack\");\n+        A(thread, stk != NULL, \"Failed to find the current stack\");\n     }\n     record_stack_limit();\n }"}, {"sha": "54b2a66d3615b2a9ba62d3fdf6423a58c2d1912a", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -76,7 +76,7 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     context ctx;\n     stk_seg *stk;\n     uintptr_t runtime_sp;      // Runtime sp while task running.\n-    rust_scheduler *sched;\n+    rust_task_thread *thread;\n     rust_crate_cache *cache;\n \n     // Fields known only to the runtime.\n@@ -123,7 +123,7 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     size_t total_stack_sz;\n \n     // Only a pointer to 'name' is kept, so it must live as long as this task.\n-    rust_task(rust_scheduler *sched,\n+    rust_task(rust_task_thread *thread,\n               rust_task_list *state,\n               rust_task *spawner,\n               const char *name,"}, {"sha": "e7cc479f98f2d1523c38f179d34a9a663221e023", "filename": "src/rt/rust_task_list.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_task_list.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_task_list.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task_list.cpp?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -1,15 +1,15 @@\n #include \"rust_internal.h\"\n \n-rust_task_list::rust_task_list (rust_scheduler *sched, const char* name) :\n-    sched(sched), name(name) {\n+rust_task_list::rust_task_list (rust_task_thread *thread, const char* name) :\n+    thread(thread), name(name) {\n }\n \n void\n rust_task_list::delete_all() {\n-    DLOG(sched, task, \"deleting all %s tasks\", name);\n+    DLOG(thread, task, \"deleting all %s tasks\", name);\n     while (is_empty() == false) {\n         rust_task *task = pop_value();\n-        DLOG(sched, task, \"deleting task \" PTR, task);\n+        DLOG(thread, task, \"deleting task \" PTR, task);\n         delete task;\n     }\n }"}, {"sha": "864cd3cdd57c0f0e8503203fc34f1a723e6d1c6f", "filename": "src/rt/rust_task_list.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_task_list.h", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_task_list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task_list.h?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -8,9 +8,9 @@\n class rust_task_list : public indexed_list<rust_task>,\n                        public kernel_owned<rust_task_list> {\n public:\n-    rust_scheduler *sched;\n+    rust_task_thread *thread;\n     const char* name;\n-    rust_task_list (rust_scheduler *sched, const char* name);\n+    rust_task_list (rust_task_thread *thread, const char* name);\n     void delete_all();\n };\n "}, {"sha": "774e71f24aaf095f195be7a249b63c4daca8e021", "filename": "src/rt/rust_task_thread.cpp", "status": "renamed", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_task_thread.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_task_thread.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task_thread.cpp?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -7,14 +7,14 @@\n #include \"globals.h\"\n \n #ifndef _WIN32\n-pthread_key_t rust_scheduler::task_key;\n+pthread_key_t rust_task_thread::task_key;\n #else\n-DWORD rust_scheduler::task_key;\n+DWORD rust_task_thread::task_key;\n #endif\n \n-bool rust_scheduler::tls_initialized = false;\n+bool rust_task_thread::tls_initialized = false;\n \n-rust_scheduler::rust_scheduler(rust_kernel *kernel,\n+rust_task_thread::rust_task_thread(rust_kernel *kernel,\n                                rust_srv *srv,\n                                int id) :\n     ref_count(1),\n@@ -46,8 +46,8 @@ rust_scheduler::rust_scheduler(rust_kernel *kernel,\n         init_tls();\n }\n \n-rust_scheduler::~rust_scheduler() {\n-    DLOG(this, dom, \"~rust_scheduler %s @0x%\" PRIxPTR, name, (uintptr_t)this);\n+rust_task_thread::~rust_task_thread() {\n+    DLOG(this, dom, \"~rust_task_thread %s @0x%\" PRIxPTR, name, (uintptr_t)this);\n \n     newborn_tasks.delete_all();\n     running_tasks.delete_all();\n@@ -59,7 +59,7 @@ rust_scheduler::~rust_scheduler() {\n }\n \n void\n-rust_scheduler::activate(rust_task *task) {\n+rust_task_thread::activate(rust_task *task) {\n     task->ctx.next = &c_context;\n     DLOG(this, task, \"descheduling...\");\n     lock.unlock();\n@@ -69,7 +69,7 @@ rust_scheduler::activate(rust_task *task) {\n }\n \n void\n-rust_scheduler::log(rust_task* task, uint32_t level, char const *fmt, ...) {\n+rust_task_thread::log(rust_task* task, uint32_t level, char const *fmt, ...) {\n     char buf[BUF_BYTES];\n     va_list args;\n     va_start(args, fmt);\n@@ -79,14 +79,14 @@ rust_scheduler::log(rust_task* task, uint32_t level, char const *fmt, ...) {\n }\n \n void\n-rust_scheduler::fail() {\n+rust_task_thread::fail() {\n     log(NULL, log_err, \"domain %s @0x%\" PRIxPTR \" root task failed\",\n         name, this);\n     kernel->fail();\n }\n \n void\n-rust_scheduler::kill_all_tasks() {\n+rust_task_thread::kill_all_tasks() {\n     I(this, !lock.lock_held_by_current_thread());\n     scoped_lock with(lock);\n \n@@ -104,15 +104,15 @@ rust_scheduler::kill_all_tasks() {\n }\n \n size_t\n-rust_scheduler::number_of_live_tasks() {\n+rust_task_thread::number_of_live_tasks() {\n     return running_tasks.length() + blocked_tasks.length();\n }\n \n /**\n  * Delete any dead tasks.\n  */\n void\n-rust_scheduler::reap_dead_tasks() {\n+rust_task_thread::reap_dead_tasks() {\n     I(this, lock.lock_held_by_current_thread());\n     if (dead_tasks.length() == 0) {\n         return;\n@@ -157,7 +157,7 @@ rust_scheduler::reap_dead_tasks() {\n  * Returns NULL if no tasks can be scheduled.\n  */\n rust_task *\n-rust_scheduler::schedule_task() {\n+rust_task_thread::schedule_task() {\n     I(this, this);\n     // FIXME: in the face of failing tasks, this is not always right.\n     // I(this, n_live_tasks() > 0);\n@@ -173,7 +173,7 @@ rust_scheduler::schedule_task() {\n }\n \n void\n-rust_scheduler::log_state() {\n+rust_task_thread::log_state() {\n     if (log_rt_task < log_debug) return;\n \n     if (!running_tasks.is_empty()) {\n@@ -211,7 +211,7 @@ rust_scheduler::log_state() {\n  * drop to zero.\n  */\n void\n-rust_scheduler::start_main_loop() {\n+rust_task_thread::start_main_loop() {\n     lock.lock();\n \n     DLOG(this, dom, \"started domain loop %d\", id);\n@@ -277,12 +277,12 @@ rust_scheduler::start_main_loop() {\n }\n \n rust_crate_cache *\n-rust_scheduler::get_cache() {\n+rust_task_thread::get_cache() {\n     return &cache;\n }\n \n rust_task *\n-rust_scheduler::create_task(rust_task *spawner, const char *name,\n+rust_task_thread::create_task(rust_task *spawner, const char *name,\n                             size_t init_stack_sz) {\n     rust_task *task =\n         new (this->kernel, \"rust_task\")\n@@ -300,27 +300,27 @@ rust_scheduler::create_task(rust_task *spawner, const char *name,\n     return task;\n }\n \n-void rust_scheduler::run() {\n+void rust_task_thread::run() {\n     this->start_main_loop();\n }\n \n #ifndef _WIN32\n void\n-rust_scheduler::init_tls() {\n+rust_task_thread::init_tls() {\n     int result = pthread_key_create(&task_key, NULL);\n     assert(!result && \"Couldn't create the TLS key!\");\n     tls_initialized = true;\n }\n \n void\n-rust_scheduler::place_task_in_tls(rust_task *task) {\n+rust_task_thread::place_task_in_tls(rust_task *task) {\n     int result = pthread_setspecific(task_key, task);\n     assert(!result && \"Couldn't place the task in TLS!\");\n     task->record_stack_limit();\n }\n \n rust_task *\n-rust_scheduler::get_task() {\n+rust_task_thread::get_task() {\n     if (!tls_initialized)\n         return NULL;\n     rust_task *task = reinterpret_cast<rust_task *>\n@@ -330,21 +330,21 @@ rust_scheduler::get_task() {\n }\n #else\n void\n-rust_scheduler::init_tls() {\n+rust_task_thread::init_tls() {\n     task_key = TlsAlloc();\n     assert(task_key != TLS_OUT_OF_INDEXES && \"Couldn't create the TLS key!\");\n     tls_initialized = true;\n }\n \n void\n-rust_scheduler::place_task_in_tls(rust_task *task) {\n+rust_task_thread::place_task_in_tls(rust_task *task) {\n     BOOL result = TlsSetValue(task_key, task);\n     assert(result && \"Couldn't place the task in TLS!\");\n     task->record_stack_limit();\n }\n \n rust_task *\n-rust_scheduler::get_task() {\n+rust_task_thread::get_task() {\n     if (!tls_initialized)\n         return NULL;\n     rust_task *task = reinterpret_cast<rust_task *>(TlsGetValue(task_key));\n@@ -354,7 +354,7 @@ rust_scheduler::get_task() {\n #endif\n \n void\n-rust_scheduler::exit() {\n+rust_task_thread::exit() {\n     A(this, !lock.lock_held_by_current_thread(), \"Shouldn't have lock\");\n     scoped_lock with(lock);\n     should_exit = true;", "previous_filename": "src/rt/rust_scheduler.cpp"}, {"sha": "194866337134619f959ef88cdf4bba485a5411fe", "filename": "src/rt/rust_task_thread.h", "status": "renamed", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_task_thread.h", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_task_thread.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task_thread.h?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -1,5 +1,5 @@\n-#ifndef RUST_SCHEDULER_H\n-#define RUST_SCHEDULER_H\n+#ifndef RUST_TASK_THREAD_H\n+#define RUST_TASK_THREAD_H\n \n #include \"context.h\"\n \n@@ -9,7 +9,7 @@\n #include <windows.h>\n #endif\n \n-struct rust_scheduler;\n+struct rust_task_thread;\n \n struct rust_hashable_dict {\n     UT_hash_handle hh;\n@@ -32,18 +32,18 @@ class rust_crate_cache {\n \n public:\n \n-    rust_scheduler *sched;\n+    rust_task_thread *thread;\n     size_t idx;\n \n-    rust_crate_cache(rust_scheduler *sched);\n+    rust_crate_cache(rust_task_thread *thread);\n     ~rust_crate_cache();\n     void flush();\n };\n \n-struct rust_scheduler : public kernel_owned<rust_scheduler>,\n+struct rust_task_thread : public kernel_owned<rust_task_thread>,\n                         rust_thread\n {\n-    RUST_REFCOUNTED(rust_scheduler)\n+    RUST_REFCOUNTED(rust_task_thread)\n \n     // Fields known only by the runtime:\n     rust_log _log;\n@@ -92,8 +92,8 @@ struct rust_scheduler : public kernel_owned<rust_scheduler>,\n \n     // Only a pointer to 'name' is kept, so it must live as long as this\n     // domain.\n-    rust_scheduler(rust_kernel *kernel, rust_srv *srv, int id);\n-    ~rust_scheduler();\n+    rust_task_thread(rust_kernel *kernel, rust_srv *srv, int id);\n+    ~rust_task_thread();\n     void activate(rust_task *task);\n     void log(rust_task *task, uint32_t level, char const *fmt, ...);\n     rust_log & get_log();\n@@ -132,7 +132,7 @@ struct rust_scheduler : public kernel_owned<rust_scheduler>,\n };\n \n inline rust_log &\n-rust_scheduler::get_log() {\n+rust_task_thread::get_log() {\n     return _log;\n }\n \n@@ -147,4 +147,4 @@ rust_scheduler::get_log() {\n // End:\n //\n \n-#endif /* RUST_SCHEDULER_H */\n+#endif /* RUST_TASK_THREAD_H */", "previous_filename": "src/rt/rust_scheduler.h"}, {"sha": "6c666fb8189bbc20cbcc3522cb72a303c9f8b29c", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -8,7 +8,7 @@\n \n #include \"rust_cc.h\"\n #include \"rust_internal.h\"\n-#include \"rust_scheduler.h\"\n+#include \"rust_task_thread.h\"\n #include \"rust_unwind.h\"\n #include \"rust_upcall.h\"\n #include \"rust_util.h\"\n@@ -46,9 +46,9 @@ static void check_stack_alignment() { }\n inline void\n call_upcall_on_c_stack(void *args, void *fn_ptr) {\n     check_stack_alignment();\n-    rust_task *task = rust_scheduler::get_task();\n-    rust_scheduler *sched = task->sched;\n-    sched->c_context.call_shim_on_c_stack(args, fn_ptr);\n+    rust_task *task = rust_task_thread::get_task();\n+    rust_task_thread *thread = task->thread;\n+    thread->c_context.call_shim_on_c_stack(args, fn_ptr);\n }\n \n extern \"C\" void record_sp(void *limit);\n@@ -62,21 +62,21 @@ extern \"C\" void record_sp(void *limit);\n  */\n extern \"C\" CDECL void\n upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n \n     // FIXME (1226) - The shim functions generated by rustc contain the\n     // morestack prologue, so we need to let them know they have enough\n     // stack.\n     record_sp(0);\n \n-    rust_scheduler *sched = task->sched;\n+    rust_task_thread *thread = task->thread;\n     try {\n-        sched->c_context.call_shim_on_c_stack(args, fn_ptr);\n+        thread->c_context.call_shim_on_c_stack(args, fn_ptr);\n     } catch (...) {\n-        A(sched, false, \"Native code threw an exception\");\n+        A(thread, false, \"Native code threw an exception\");\n     }\n \n-    task = rust_scheduler::get_task();\n+    task = rust_task_thread::get_task();\n     task->record_stack_limit();\n }\n \n@@ -90,7 +90,7 @@ struct s_fail_args {\n \n extern \"C\" CDECL void\n upcall_s_fail(s_fail_args *args) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG_UPCALL_ENTRY(task);\n     LOG_ERR(task, upcall, \"upcall fail '%s', %s:%\" PRIdPTR, \n             args->expr, args->file, args->line);\n@@ -116,7 +116,7 @@ struct s_malloc_args {\n \n extern \"C\" CDECL void\n upcall_s_malloc(s_malloc_args *args) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     LOG(task, mem, \"upcall malloc(0x%\" PRIxPTR \")\", args->td);\n@@ -153,11 +153,11 @@ struct s_free_args {\n \n extern \"C\" CDECL void\n upcall_s_free(s_free_args *args) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n-    rust_scheduler *sched = task->sched;\n-    DLOG(sched, mem,\n+    rust_task_thread *thread = task->thread;\n+    DLOG(thread, mem,\n              \"upcall free(0x%\" PRIxPTR \", is_gc=%\" PRIdPTR \")\",\n              (uintptr_t)args->ptr);\n \n@@ -200,7 +200,7 @@ struct s_shared_malloc_args {\n \n extern \"C\" CDECL void\n upcall_s_shared_malloc(s_shared_malloc_args *args) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     LOG(task, mem,\n@@ -232,11 +232,11 @@ struct s_shared_free_args {\n \n extern \"C\" CDECL void\n upcall_s_shared_free(s_shared_free_args *args) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n-    rust_scheduler *sched = task->sched;\n-    DLOG(sched, mem,\n+    rust_task_thread *thread = task->thread;\n+    DLOG(thread, mem,\n              \"upcall shared_free(0x%\" PRIxPTR\")\",\n              (uintptr_t)args->ptr);\n     task->kernel->free(args->ptr);\n@@ -262,7 +262,7 @@ struct s_create_shared_type_desc_args {\n \n void upcall_s_create_shared_type_desc(s_create_shared_type_desc_args *args)\n {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     // Copy the main part of the type descriptor:\n@@ -301,7 +301,7 @@ upcall_create_shared_type_desc(type_desc *td) {\n \n void upcall_s_free_shared_type_desc(type_desc *td)\n { // n.b.: invoked from rust_cc.cpp as well as generated code\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     if (td) {\n@@ -337,7 +337,7 @@ struct s_get_type_desc_args {\n \n extern \"C\" CDECL void\n upcall_s_get_type_desc(s_get_type_desc_args *args) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     LOG(task, cache, \"upcall get_type_desc with size=%\" PRIdPTR\n@@ -375,7 +375,7 @@ struct s_intern_dict_args {\n \n extern \"C\" CDECL void\n upcall_s_intern_dict(s_intern_dict_args *args) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG_UPCALL_ENTRY(task);\n     rust_crate_cache *cache = task->get_crate_cache();\n     args->res = cache->get_dict(args->n_fields, args->dict);\n@@ -397,7 +397,7 @@ struct s_vec_grow_args {\n \n extern \"C\" CDECL void\n upcall_s_vec_grow(s_vec_grow_args *args) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG_UPCALL_ENTRY(task);\n     reserve_vec(task, args->vp, args->new_sz);\n     (*args->vp)->fill = args->new_sz;\n@@ -438,7 +438,7 @@ struct s_vec_push_args {\n \n extern \"C\" CDECL void\n upcall_s_vec_push(s_vec_push_args *args) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     LOG_UPCALL_ENTRY(task);\n     size_t new_sz = (*args->vp)->fill + args->elt_ty->size;\n     reserve_vec(task, args->vp, new_sz);\n@@ -456,7 +456,7 @@ upcall_vec_push(rust_vec** vp, type_desc* elt_ty, void* elt) {\n     upcall_s_vec_push(&args);\n \n     // Do the stack check to make sure this op, on the Rust stack, is behaving\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     task->check_stack_canary();\n }\n \n@@ -471,7 +471,7 @@ struct s_dynastack_mark_args {\n \n extern \"C\" CDECL void\n upcall_s_dynastack_mark(s_dynastack_mark_args *args) {\n-    args->retval = rust_scheduler::get_task()->dynastack.mark();\n+    args->retval = rust_task_thread::get_task()->dynastack.mark();\n }\n \n extern \"C\" CDECL void *\n@@ -496,7 +496,7 @@ extern \"C\" CDECL void\n upcall_s_dynastack_alloc(s_dynastack_alloc_args *args) {\n     size_t sz = args->sz;\n     args->retval = sz ?\n-        rust_scheduler::get_task()->dynastack.alloc(sz, NULL) : NULL;\n+        rust_task_thread::get_task()->dynastack.alloc(sz, NULL) : NULL;\n }\n \n extern \"C\" CDECL void *\n@@ -522,7 +522,7 @@ upcall_s_dynastack_alloc_2(s_dynastack_alloc_2_args *args) {\n     size_t sz = args->sz;\n     type_desc *ty = args->ty;\n     args->retval = sz ?\n-        rust_scheduler::get_task()->dynastack.alloc(sz, ty) : NULL;\n+        rust_task_thread::get_task()->dynastack.alloc(sz, ty) : NULL;\n }\n \n extern \"C\" CDECL void *\n@@ -538,7 +538,7 @@ struct s_dynastack_free_args {\n \n extern \"C\" CDECL void\n upcall_s_dynastack_free(s_dynastack_free_args *args) {\n-    return rust_scheduler::get_task()->dynastack.free(args->ptr);\n+    return rust_task_thread::get_task()->dynastack.free(args->ptr);\n }\n \n /** Frees space in the dynamic stack. */\n@@ -587,7 +587,7 @@ upcall_rust_personality(int version,\n     s_rust_personality_args args = {(_Unwind_Reason_Code)0,\n                                     version, actions, exception_class,\n                                     ue_header, context};\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n \n     // The personality function is run on the stack of the\n     // last function that threw or landed, which is going\n@@ -659,7 +659,7 @@ struct s_new_stack_args {\n \n extern \"C\" CDECL void\n upcall_s_new_stack(struct s_new_stack_args *args) {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     args->result = task->new_stack(args->stk_sz,\n                                    args->args_addr,\n                                    args->args_sz);\n@@ -674,7 +674,7 @@ upcall_new_stack(size_t stk_sz, void *args_addr, size_t args_sz) {\n \n extern \"C\" CDECL void\n upcall_s_del_stack() {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     task->del_stack();\n }\n \n@@ -689,7 +689,7 @@ upcall_del_stack() {\n // needs to acquire the value of the stack pointer\n extern \"C\" CDECL void\n upcall_reset_stack_limit() {\n-    rust_task *task = rust_scheduler::get_task();\n+    rust_task *task = rust_task_thread::get_task();\n     task->reset_stack_limit();\n }\n "}, {"sha": "87b3da930d5c22489d81966e9d716e38ba4386a0", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -13,39 +13,39 @@ ptr_vec<T>::ptr_vec(rust_task *task) :\n     fill(0),\n     data(new (task, \"ptr_vec<T>\") T*[alloc])\n {\n-    I(task->sched, data);\n-    DLOG(task->sched, mem, \"new ptr_vec(data=0x%\" PRIxPTR \") -> 0x%\" PRIxPTR,\n+    I(task->thread, data);\n+    DLOG(task->thread, mem, \"new ptr_vec(data=0x%\" PRIxPTR \") -> 0x%\" PRIxPTR,\n          (uintptr_t)data, (uintptr_t)this);\n }\n \n template <typename T>\n ptr_vec<T>::~ptr_vec()\n {\n-    I(task->sched, data);\n-    DLOG(task->sched, mem, \"~ptr_vec 0x%\" PRIxPTR \", data=0x%\" PRIxPTR,\n+    I(task->thread, data);\n+    DLOG(task->thread, mem, \"~ptr_vec 0x%\" PRIxPTR \", data=0x%\" PRIxPTR,\n          (uintptr_t)this, (uintptr_t)data);\n-    I(task->sched, fill == 0);\n+    I(task->thread, fill == 0);\n     task->free(data);\n }\n \n template <typename T> T *&\n ptr_vec<T>::operator[](size_t offset) {\n-    I(task->sched, data[offset]->idx == offset);\n+    I(task->thread, data[offset]->idx == offset);\n     return data[offset];\n }\n \n template <typename T>\n void\n ptr_vec<T>::push(T *p)\n {\n-    I(task->sched, data);\n-    I(task->sched, fill <= alloc);\n+    I(task->thread, data);\n+    I(task->thread, fill <= alloc);\n     if (fill == alloc) {\n         alloc *= 2;\n         data = (T **)task->realloc(data, alloc * sizeof(T*));\n-        I(task->sched, data);\n+        I(task->thread, data);\n     }\n-    I(task->sched, fill < alloc);\n+    I(task->thread, fill < alloc);\n     p->idx = fill;\n     data[fill++] = p;\n }\n@@ -68,13 +68,13 @@ template <typename T>\n void\n ptr_vec<T>::trim(size_t sz)\n {\n-    I(task->sched, data);\n+    I(task->thread, data);\n     if (sz <= (alloc / 4) &&\n         (alloc / 2) >= INIT_SIZE) {\n         alloc /= 2;\n-        I(task->sched, alloc >= fill);\n+        I(task->thread, alloc >= fill);\n         data = (T **)task->realloc(data, alloc * sizeof(T*));\n-        I(task->sched, data);\n+        I(task->thread, data);\n     }\n }\n \n@@ -83,9 +83,9 @@ void\n ptr_vec<T>::swap_delete(T *item)\n {\n     /* Swap the endpoint into i and decr fill. */\n-    I(task->sched, data);\n-    I(task->sched, fill > 0);\n-    I(task->sched, item->idx < fill);\n+    I(task->thread, data);\n+    I(task->thread, fill > 0);\n+    I(task->thread, item->idx < fill);\n     fill--;\n     if (fill > 0) {\n         T *subst = data[fill];\n@@ -124,13 +124,13 @@ align_to(T size, size_t alignment) {\n \n // Initialization helper for ISAAC RNG\n \n-template <typename sched_or_kernel>\n+template <typename thread_or_kernel>\n static inline void\n-isaac_init(sched_or_kernel *sched, randctx *rctx)\n+isaac_init(thread_or_kernel *thread, randctx *rctx)\n {\n         memset(rctx, 0, sizeof(randctx));\n \n-        char *rust_seed = sched->env->rust_seed;\n+        char *rust_seed = thread->env->rust_seed;\n         if (rust_seed != NULL) {\n             ub4 seed = (ub4) atoi(rust_seed);\n             for (size_t i = 0; i < RANDSIZ; i ++) {\n@@ -140,24 +140,24 @@ isaac_init(sched_or_kernel *sched, randctx *rctx)\n         } else {\n #ifdef __WIN32__\n             HCRYPTPROV hProv;\n-            sched->win32_require\n+            thread->win32_require\n                 (_T(\"CryptAcquireContext\"),\n                  CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL,\n                                      CRYPT_VERIFYCONTEXT|CRYPT_SILENT));\n-            sched->win32_require\n+            thread->win32_require\n                 (_T(\"CryptGenRandom\"),\n                  CryptGenRandom(hProv, sizeof(rctx->randrsl),\n                                 (BYTE*)(&rctx->randrsl)));\n-            sched->win32_require\n+            thread->win32_require\n                 (_T(\"CryptReleaseContext\"),\n                  CryptReleaseContext(hProv, 0));\n #else\n             int fd = open(\"/dev/urandom\", O_RDONLY);\n-            I(sched, fd > 0);\n-            I(sched,\n+            I(thread, fd > 0);\n+            I(thread,\n               read(fd, (void*) &rctx->randrsl, sizeof(rctx->randrsl))\n               == sizeof(rctx->randrsl));\n-            I(sched, close(fd) == 0);\n+            I(thread, close(fd) == 0);\n #endif\n         }\n "}, {"sha": "7bd0b4fe55bd99c1d6aad741e7ed8641cb412762", "filename": "src/rt/rust_uvtmp.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_uvtmp.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f94339cc1c98a1ae3ee3beb94c848009167a58d9/src%2Frt%2Frust_uvtmp.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uvtmp.cpp?ref=f94339cc1c98a1ae3ee3beb94c848009167a58d9", "patch": "@@ -87,7 +87,7 @@ class rust_uvtmp_thread : public rust_thread {\n public:\n \n     rust_uvtmp_thread() {\n-\ttask = rust_scheduler::get_task();\n+\ttask = rust_task_thread::get_task();\n \tstop_flag = false;\n \tloop = uv_loop_new();\n \tuv_idle_init(loop, &idle);"}]}