{"sha": "524e23ae2e842a6f52d5fc4d5819473b73a335ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyNGUyM2FlMmU4NDJhNmY1MmQ1ZmM0ZDU4MTk0NzNiNzNhMzM1ZWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-05T19:06:46Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-16T10:57:44Z"}, "message": "make `RegionVid` implement `Idx` and use `IndexVec`", "tree": {"sha": "b6bc8a23bb4589efb3d6176049fd2b909e000108", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6bc8a23bb4589efb3d6176049fd2b909e000108"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/524e23ae2e842a6f52d5fc4d5819473b73a335ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/524e23ae2e842a6f52d5fc4d5819473b73a335ef", "html_url": "https://github.com/rust-lang/rust/commit/524e23ae2e842a6f52d5fc4d5819473b73a335ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/524e23ae2e842a6f52d5fc4d5819473b73a335ef/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bea6b94273bc616f806b111c8f1f6b3d2e3e5380", "url": "https://api.github.com/repos/rust-lang/rust/commits/bea6b94273bc616f806b111c8f1f6b3d2e3e5380", "html_url": "https://github.com/rust-lang/rust/commit/bea6b94273bc616f806b111c8f1f6b3d2e3e5380"}], "stats": {"total": 74, "additions": 49, "deletions": 25}, "files": [{"sha": "3aeecaf166ac6d66815048b3178343579bfe48bb", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/524e23ae2e842a6f52d5fc4d5819473b73a335ef/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/524e23ae2e842a6f52d5fc4d5819473b73a335ef/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=524e23ae2e842a6f52d5fc4d5819473b73a335ef", "patch": "@@ -17,6 +17,7 @@ use infer::region_constraints::GenericKind;\n use infer::region_constraints::RegionConstraintData;\n use infer::region_constraints::VerifyBound;\n use middle::free_region::RegionRelations;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n use std::fmt;\n@@ -29,7 +30,7 @@ use ty::{ReLateBound, ReScope, ReSkolemized, ReVar};\n mod graphviz;\n \n pub struct LexicalRegionResolutions<'tcx> {\n-    values: Vec<VarValue<'tcx>>,\n+    values: IndexVec<RegionVid, VarValue<'tcx>>,\n     error_region: ty::Region<'tcx>,\n }\n \n@@ -114,7 +115,7 @@ impl<'tcx> RegionConstraintData<'tcx> {\n \n             (&ReVar(v_id), _) | (_, &ReVar(v_id)) => {\n                 span_bug!(\n-                    self.var_origins[v_id.index as usize].span(),\n+                    self.var_origins[v_id].span(),\n                     \"lub_concrete_regions invoked with non-concrete \\\n                      regions: {:?}, {:?}\",\n                     a,\n@@ -211,7 +212,7 @@ impl<'tcx> RegionConstraintData<'tcx> {\n     fn construct_var_data(&self, tcx: TyCtxt<'_, '_, 'tcx>) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n             error_region: tcx.types.re_static,\n-            values: (0..self.num_vars() as usize)\n+            values: (0..self.num_vars())\n                 .map(|_| VarValue::Value(tcx.types.re_empty))\n                 .collect(),\n         }\n@@ -240,11 +241,20 @@ impl<'tcx> RegionConstraintData<'tcx> {\n \n         let seeds: Vec<_> = self.givens.iter().cloned().collect();\n         for (r, vid) in seeds {\n+\n+            // While all things transitively reachable in the graph\n+            // from the variable (`'0` in the example above).\n             let seed_index = NodeIndex(vid.index as usize);\n             for succ_index in graph.depth_traverse(seed_index, OUTGOING) {\n-                let succ_index = succ_index.0 as u32;\n+                let succ_index = succ_index.0;\n+\n+                // The first N nodes correspond to the region\n+                // variables. Other nodes correspond to constant\n+                // regions.\n                 if succ_index < self.num_vars() {\n-                    let succ_vid = RegionVid { index: succ_index };\n+                    let succ_vid = RegionVid::new(succ_index);\n+\n+                    // Add `'c <= '1`.\n                     self.givens.insert((r, succ_vid));\n                 }\n             }\n@@ -442,11 +452,10 @@ impl<'tcx> RegionConstraintData<'tcx> {\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations.\n-        let mut dup_vec = vec![u32::MAX; self.num_vars() as usize];\n+        let mut dup_vec = vec![u32::MAX; self.num_vars()];\n \n-        for index in 0..self.num_vars() {\n-            let node_vid = RegionVid { index };\n-            match var_data.value(node_vid) {\n+        for (node_vid, value) in var_data.values.iter_enumerated() {\n+            match *value {\n                 VarValue::Value(_) => { /* Inference successful */ }\n                 VarValue::ErrorValue => {\n                     /* Inference impossible, this value contains\n@@ -560,7 +569,7 @@ impl<'tcx> RegionConstraintData<'tcx> {\n         for lower_bound in &lower_bounds {\n             for upper_bound in &upper_bounds {\n                 if !region_rels.is_subregion_of(lower_bound.region, upper_bound.region) {\n-                    let origin = self.var_origins[node_idx.index as usize].clone();\n+                    let origin = self.var_origins[node_idx].clone();\n                     debug!(\n                         \"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n                          sup: {:?}\",\n@@ -582,7 +591,7 @@ impl<'tcx> RegionConstraintData<'tcx> {\n         }\n \n         span_bug!(\n-            self.var_origins[node_idx.index as usize].span(),\n+            self.var_origins[node_idx].span(),\n             \"collect_error_for_expanding_node() could not find \\\n              error for var {:?}, lower_bounds={:?}, \\\n              upper_bounds={:?}\",\n@@ -741,15 +750,15 @@ impl<'tcx> LexicalRegionResolutions<'tcx> {\n     }\n \n     fn value(&self, rid: RegionVid) -> &VarValue<'tcx> {\n-        &self.values[rid.index as usize]\n+        &self.values[rid]\n     }\n \n     fn value_mut(&mut self, rid: RegionVid) -> &mut VarValue<'tcx> {\n-        &mut self.values[rid.index as usize]\n+        &mut self.values[rid]\n     }\n \n     pub fn resolve_var(&self, rid: RegionVid) -> ty::Region<'tcx> {\n-        let result = match self.values[rid.index as usize] {\n+        let result = match self.values[rid] {\n             VarValue::Value(r) => r,\n             VarValue::ErrorValue => self.error_region,\n         };"}, {"sha": "634e4642600681bedf7a396653c2801c8fc6551d", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/524e23ae2e842a6f52d5fc4d5819473b73a335ef/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/524e23ae2e842a6f52d5fc4d5819473b73a335ef/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=524e23ae2e842a6f52d5fc4d5819473b73a335ef", "patch": "@@ -16,6 +16,7 @@ use self::CombineMapType::*;\n use super::{MiscVariable, RegionVariableOrigin, SubregionOrigin};\n use super::unify_key;\n \n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::unify::{self, UnificationTable};\n use ty::{self, Ty, TyCtxt};\n@@ -51,14 +52,16 @@ pub struct RegionConstraintCollector<'tcx> {\n     unification_table: UnificationTable<ty::RegionVid>,\n }\n \n+pub type VarOrigins = IndexVec<RegionVid, RegionVariableOrigin>;\n+\n /// The full set of region constraints gathered up by the collector.\n /// Describes a set of region variables ranging from 0..N (where N is\n /// the length of the `var_origins` vector), and various constraints\n /// between them.\n #[derive(Default)]\n pub struct RegionConstraintData<'tcx> {\n     /// For each `RegionVid`, the corresponding `RegionVariableOrigin`.\n-    pub var_origins: Vec<RegionVariableOrigin>,\n+    pub var_origins: IndexVec<RegionVid, RegionVariableOrigin>,\n \n     /// Constraints of the form `A <= B`, where either `A` or `B` can\n     /// be a region variable (or neither, as it happens).\n@@ -344,10 +347,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     }\n \n     pub fn new_region_var(&mut self, origin: RegionVariableOrigin) -> RegionVid {\n-        let vid = RegionVid {\n-            index: self.data.num_vars(),\n-        };\n-        self.data.var_origins.push(origin.clone());\n+        let vid = self.data.var_origins.push(origin.clone());\n \n         let u_vid = self.unification_table\n             .new_key(unify_key::RegionVidKey { min_vid: vid });\n@@ -364,7 +364,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     }\n \n     pub fn var_origin(&self, vid: RegionVid) -> RegionVariableOrigin {\n-        self.data.var_origins[vid.index as usize].clone()\n+        self.data.var_origins[vid].clone()\n     }\n \n     /// Creates a new skolemized region. Skolemized regions are fresh\n@@ -862,10 +862,7 @@ impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n }\n \n impl<'tcx> RegionConstraintData<'tcx> {\n-    pub fn num_vars(&self) -> u32 {\n-        let len = self.var_origins.len();\n-        // enforce no overflow\n-        assert!(len as u32 as usize == len);\n-        len as u32\n+    pub fn num_vars(&self) -> usize {\n+        self.var_origins.len()\n     }\n }"}, {"sha": "a73b234ffbea4ab12d25d3006579f2d6e9c2cca6", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/524e23ae2e842a6f52d5fc4d5819473b73a335ef/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/524e23ae2e842a6f52d5fc4d5819473b73a335ef/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=524e23ae2e842a6f52d5fc4d5819473b73a335ef", "patch": "@@ -14,6 +14,7 @@ use hir::def_id::DefId;\n \n use middle::const_val::ConstVal;\n use middle::region;\n+use rustc_data_structures::indexed_vec::Idx;\n use ty::subst::{Substs, Subst};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use ty::{Slice, TyS};\n@@ -898,6 +899,18 @@ pub struct RegionVid {\n     pub index: u32,\n }\n \n+// TODO after rebasing, should be able to use `newtype_index!`\n+impl Idx for RegionVid {\n+    fn new(value: usize) -> Self {\n+        assert!(value < ::std::u32::MAX as usize);\n+        RegionVid { index: value as u32 }\n+    }\n+\n+    fn index(self) -> usize {\n+        self.index as usize\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, PartialOrd, Ord)]\n pub struct SkolemizedRegionVid {\n     pub index: u32,"}, {"sha": "622e8c51bee9d2fb13d1debe0903a806307a05ec", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/524e23ae2e842a6f52d5fc4d5819473b73a335ef/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/524e23ae2e842a6f52d5fc4d5819473b73a335ef/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=524e23ae2e842a6f52d5fc4d5819473b73a335ef", "patch": "@@ -384,6 +384,11 @@ impl<I: Idx, T> IndexVec<I, T> {\n         idx\n     }\n \n+    #[inline]\n+    pub fn pop(&mut self) -> Option<T> {\n+        self.raw.pop()\n+    }\n+\n     #[inline]\n     pub fn len(&self) -> usize {\n         self.raw.len()"}]}