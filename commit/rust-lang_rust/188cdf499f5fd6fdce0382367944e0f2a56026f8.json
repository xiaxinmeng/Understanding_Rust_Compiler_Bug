{"sha": "188cdf499f5fd6fdce0382367944e0f2a56026f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4OGNkZjQ5OWY1ZmQ2ZmRjZTAzODIzNjc5NDRlMGYyYTU2MDI2Zjg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-07-15T09:18:19Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2017-07-28T13:46:27Z"}, "message": "combine `bckerr_to_diag` and `note_and_explain_bckerr`", "tree": {"sha": "70a37439e6db9889d7f7f8fcf8b10fdb72228ee3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70a37439e6db9889d7f7f8fcf8b10fdb72228ee3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/188cdf499f5fd6fdce0382367944e0f2a56026f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/188cdf499f5fd6fdce0382367944e0f2a56026f8", "html_url": "https://github.com/rust-lang/rust/commit/188cdf499f5fd6fdce0382367944e0f2a56026f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/188cdf499f5fd6fdce0382367944e0f2a56026f8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a6e0694da97dad246f8112c757988163697a3a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a6e0694da97dad246f8112c757988163697a3a6", "html_url": "https://github.com/rust-lang/rust/commit/5a6e0694da97dad246f8112c757988163697a3a6"}], "stats": {"total": 281, "additions": 137, "deletions": 144}, "files": [{"sha": "0d321b095521cce42734b413fd06c9cacd89e86d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 137, "deletions": 144, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/188cdf499f5fd6fdce0382367944e0f2a56026f8/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188cdf499f5fd6fdce0382367944e0f2a56026f8/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=188cdf499f5fd6fdce0382367944e0f2a56026f8", "patch": "@@ -506,9 +506,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             _ => { }\n         }\n \n-        let mut db = self.bckerr_to_diag(&err);\n-        self.note_and_explain_bckerr(&mut db, err);\n-        db.emit();\n+        self.report_bckerr(&err);\n     }\n \n     pub fn report_use_of_moved_value(&self,\n@@ -693,8 +691,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err_with_code(s, msg, code);\n     }\n \n-    fn bckerr_to_diag(&self, err: &BckError<'tcx>) -> DiagnosticBuilder<'a> {\n-        let span = err.span.clone();\n+    fn report_bckerr(&self, err: &BckError<'tcx>) {\n+        let error_span = err.span.clone();\n \n         match err.code {\n             err_mutbl => {\n@@ -718,12 +716,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                 };\n \n-                match err.cause {\n+                let mut db = match err.cause {\n                     MutabilityViolation => {\n-                        struct_span_err!(self.tcx.sess, span, E0594, \"cannot assign to {}\", descr)\n+                        struct_span_err!(self.tcx.sess, error_span, E0594, \"cannot assign to {}\", descr)\n                     }\n                     BorrowViolation(euv::ClosureCapture(_)) => {\n-                        struct_span_err!(self.tcx.sess, span, E0595,\n+                        struct_span_err!(self.tcx.sess, error_span, E0595,\n                                          \"closure cannot assign to {}\", descr)\n                     }\n                     BorrowViolation(euv::OverloadedOperator) |\n@@ -733,30 +731,152 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     BorrowViolation(euv::AutoUnsafe) |\n                     BorrowViolation(euv::ForLoop) |\n                     BorrowViolation(euv::MatchDiscriminant) => {\n-                        struct_span_err!(self.tcx.sess, span, E0596,\n+                        struct_span_err!(self.tcx.sess, error_span, E0596,\n                                          \"cannot borrow {} as mutable\", descr)\n                     }\n                     BorrowViolation(euv::ClosureInvocation) => {\n                         span_bug!(err.span,\n                             \"err_mutbl with a closure invocation\");\n                     }\n-                }\n+                };\n+\n+                self.note_and_explain_mutbl_error(&mut db, &err, &error_span);\n+                self.note_immutability_blame(&mut db, err.cmt.immutability_blame());\n+                db.emit();\n             }\n-            err_out_of_scope(..) => {\n+            err_out_of_scope(super_scope, sub_scope, cause) => {\n                 let msg = match opt_loan_path(&err.cmt) {\n                     None => \"borrowed value\".to_string(),\n                     Some(lp) => {\n                         format!(\"`{}`\", self.loan_path_to_string(&lp))\n                     }\n                 };\n-                struct_span_err!(self.tcx.sess, span, E0597, \"{} does not live long enough\", msg)\n+                let mut db = struct_span_err!(self.tcx.sess, error_span, E0597, \"{} does not live long enough\", msg);\n+\n+                                let (value_kind, value_msg) = match err.cmt.cat {\n+                    mc::Categorization::Rvalue(..) =>\n+                        (\"temporary value\", \"temporary value created here\"),\n+                    _ =>\n+                        (\"borrowed value\", \"borrow occurs here\")\n+                };\n+\n+                let is_closure = match cause {\n+                    euv::ClosureCapture(s) => {\n+                        // The primary span starts out as the closure creation point.\n+                        // Change the primary span here to highlight the use of the variable\n+                        // in the closure, because it seems more natural. Highlight\n+                        // closure creation point as a secondary span.\n+                        match db.span.primary_span() {\n+                            Some(primary) => {\n+                                db.span = MultiSpan::from_span(s);\n+                                db.span_label(primary, \"capture occurs here\");\n+                                db.span_label(s, \"does not live long enough\");\n+                                true\n+                            }\n+                            None => false\n+                        }\n+                    }\n+                    _ => {\n+                        db.span_label(error_span, \"does not live long enough\");\n+                        false\n+                    }\n+                };\n+\n+                let sub_span = self.region_end_span(sub_scope);\n+                let super_span = self.region_end_span(super_scope);\n+\n+                match (sub_span, super_span) {\n+                    (Some(s1), Some(s2)) if s1 == s2 => {\n+                        if !is_closure {\n+                            db.span = MultiSpan::from_span(s1);\n+                            db.span_label(error_span, value_msg);\n+                            let msg = match opt_loan_path(&err.cmt) {\n+                                None => value_kind.to_string(),\n+                                Some(lp) => {\n+                                    format!(\"`{}`\", self.loan_path_to_string(&lp))\n+                                }\n+                            };\n+                            db.span_label(s1,\n+                                          format!(\"{} dropped here while still borrowed\", msg));\n+                        } else {\n+                            db.span_label(s1, format!(\"{} dropped before borrower\", value_kind));\n+                        }\n+                        db.note(\"values in a scope are dropped in the opposite order \\\n+                                they are created\");\n+                    }\n+                    (Some(s1), Some(s2)) if !is_closure => {\n+                        db.span = MultiSpan::from_span(s2);\n+                        db.span_label(error_span, value_msg);\n+                        let msg = match opt_loan_path(&err.cmt) {\n+                            None => value_kind.to_string(),\n+                            Some(lp) => {\n+                                format!(\"`{}`\", self.loan_path_to_string(&lp))\n+                            }\n+                        };\n+                        db.span_label(s2, format!(\"{} dropped here while still borrowed\", msg));\n+                        db.span_label(s1, format!(\"{} needs to live until here\", value_kind));\n+                    }\n+                    _ => {\n+                        match sub_span {\n+                            Some(s) => {\n+                                db.span_label(s, format!(\"{} needs to live until here\",\n+                                                          value_kind));\n+                            }\n+                            None => {\n+                                self.tcx.note_and_explain_region(\n+                                    &mut db,\n+                                    \"borrowed value must be valid for \",\n+                                    sub_scope,\n+                                    \"...\");\n+                            }\n+                        }\n+                        match super_span {\n+                            Some(s) => {\n+                                db.span_label(s, format!(\"{} only lives until here\", value_kind));\n+                            }\n+                            None => {\n+                                self.tcx.note_and_explain_region(\n+                                    &mut db,\n+                                    \"...but borrowed value is only valid for \",\n+                                    super_scope,\n+                                    \"\");\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                if let Some(_) = statement_scope_span(self.tcx, super_scope) {\n+                    db.note(\"consider using a `let` binding to increase its lifetime\");\n+                }\n+\n+                db.emit();\n             }\n-            err_borrowed_pointer_too_short(..) => {\n+            err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {\n                 let descr = self.cmt_to_path_or_string(&err.cmt);\n-                struct_span_err!(self.tcx.sess, span, E0598,\n-                                 \"lifetime of {} is too short to guarantee \\\n-                                  its contents can be safely reborrowed\",\n-                                 descr)\n+                let mut db = struct_span_err!(self.tcx.sess, error_span, E0598,\n+                                              \"lifetime of {} is too short to guarantee \\\n+                                               its contents can be safely reborrowed\",\n+                                              descr);\n+\n+                let descr = match opt_loan_path(&err.cmt) {\n+                    Some(lp) => {\n+                        format!(\"`{}`\", self.loan_path_to_string(&lp))\n+                    }\n+                    None => self.cmt_to_string(&err.cmt),\n+                };\n+                self.tcx.note_and_explain_region(\n+                    &mut db,\n+                    &format!(\"{} would have to be valid for \",\n+                            descr),\n+                    loan_scope,\n+                    \"...\");\n+                self.tcx.note_and_explain_region(\n+                    &mut db,\n+                    &format!(\"...but {} is only valid for \", descr),\n+                    ptr_scope,\n+                    \"\");\n+\n+                db.emit();\n             }\n         }\n     }\n@@ -1013,133 +1133,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn note_and_explain_bckerr(&self, db: &mut DiagnosticBuilder, err: BckError<'tcx>) {\n-        let error_span = err.span.clone();\n-        match err.code {\n-            err_mutbl => {\n-                self.note_and_explain_mutbl_error(db, &err, &error_span);\n-                self.note_immutability_blame(db, err.cmt.immutability_blame());\n-            }\n-            err_out_of_scope(super_scope, sub_scope, cause) => {\n-                let (value_kind, value_msg) = match err.cmt.cat {\n-                    mc::Categorization::Rvalue(..) =>\n-                        (\"temporary value\", \"temporary value created here\"),\n-                    _ =>\n-                        (\"borrowed value\", \"borrow occurs here\")\n-                };\n-\n-                let is_closure = match cause {\n-                    euv::ClosureCapture(s) => {\n-                        // The primary span starts out as the closure creation point.\n-                        // Change the primary span here to highlight the use of the variable\n-                        // in the closure, because it seems more natural. Highlight\n-                        // closure creation point as a secondary span.\n-                        match db.span.primary_span() {\n-                            Some(primary) => {\n-                                db.span = MultiSpan::from_span(s);\n-                                db.span_label(primary, \"capture occurs here\");\n-                                db.span_label(s, \"does not live long enough\");\n-                                true\n-                            }\n-                            None => false\n-                        }\n-                    }\n-                    _ => {\n-                        db.span_label(error_span, \"does not live long enough\");\n-                        false\n-                    }\n-                };\n-\n-                let sub_span = self.region_end_span(sub_scope);\n-                let super_span = self.region_end_span(super_scope);\n-\n-                match (sub_span, super_span) {\n-                    (Some(s1), Some(s2)) if s1 == s2 => {\n-                        if !is_closure {\n-                            db.span = MultiSpan::from_span(s1);\n-                            db.span_label(error_span, value_msg);\n-                            let msg = match opt_loan_path(&err.cmt) {\n-                                None => value_kind.to_string(),\n-                                Some(lp) => {\n-                                    format!(\"`{}`\", self.loan_path_to_string(&lp))\n-                                }\n-                            };\n-                            db.span_label(s1,\n-                                          format!(\"{} dropped here while still borrowed\", msg));\n-                        } else {\n-                            db.span_label(s1, format!(\"{} dropped before borrower\", value_kind));\n-                        }\n-                        db.note(\"values in a scope are dropped in the opposite order \\\n-                                they are created\");\n-                    }\n-                    (Some(s1), Some(s2)) if !is_closure => {\n-                        db.span = MultiSpan::from_span(s2);\n-                        db.span_label(error_span, value_msg);\n-                        let msg = match opt_loan_path(&err.cmt) {\n-                            None => value_kind.to_string(),\n-                            Some(lp) => {\n-                                format!(\"`{}`\", self.loan_path_to_string(&lp))\n-                            }\n-                        };\n-                        db.span_label(s2, format!(\"{} dropped here while still borrowed\", msg));\n-                        db.span_label(s1, format!(\"{} needs to live until here\", value_kind));\n-                    }\n-                    _ => {\n-                        match sub_span {\n-                            Some(s) => {\n-                                db.span_label(s, format!(\"{} needs to live until here\",\n-                                                          value_kind));\n-                            }\n-                            None => {\n-                                self.tcx.note_and_explain_region(\n-                                    db,\n-                                    \"borrowed value must be valid for \",\n-                                    sub_scope,\n-                                    \"...\");\n-                            }\n-                        }\n-                        match super_span {\n-                            Some(s) => {\n-                                db.span_label(s, format!(\"{} only lives until here\", value_kind));\n-                            }\n-                            None => {\n-                                self.tcx.note_and_explain_region(\n-                                    db,\n-                                    \"...but borrowed value is only valid for \",\n-                                    super_scope,\n-                                    \"\");\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                if let Some(_) = statement_scope_span(self.tcx, super_scope) {\n-                    db.note(\"consider using a `let` binding to increase its lifetime\");\n-                }\n-            }\n-\n-            err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {\n-                let descr = match opt_loan_path(&err.cmt) {\n-                    Some(lp) => {\n-                        format!(\"`{}`\", self.loan_path_to_string(&lp))\n-                    }\n-                    None => self.cmt_to_string(&err.cmt),\n-                };\n-                self.tcx.note_and_explain_region(\n-                    db,\n-                    &format!(\"{} would have to be valid for \",\n-                            descr),\n-                    loan_scope,\n-                    \"...\");\n-                self.tcx.note_and_explain_region(\n-                    db,\n-                    &format!(\"...but {} is only valid for \", descr),\n-                    ptr_scope,\n-                    \"\");\n-            }\n-        }\n-    }\n-\n     fn note_and_explain_mutbl_error(&self, db: &mut DiagnosticBuilder, err: &BckError<'tcx>,\n                                     error_span: &Span) {\n         match err.cmt.note {"}]}