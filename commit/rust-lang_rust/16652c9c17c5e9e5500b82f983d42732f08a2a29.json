{"sha": "16652c9c17c5e9e5500b82f983d42732f08a2a29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NjUyYzljMTdjNWU5ZTU1MDBiODJmOTgzZDQyNzMyZjA4YTJhMjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-18T03:42:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-18T03:42:58Z"}, "message": "auto merge of #5909 : brson/rust/rt4, r=graydon\n\nThis is just a bunch of minor changes and simplifications to the structure of core::rt. It makes ownership of the ~Scheduler more strict (though it is still mutably aliased sometimes), turns the scheduler cleanup_jobs vector into just a single job, shunts the thread-local scheduler code off to its own file.", "tree": {"sha": "170c04f7c00158e3ada1095aab092b0fddb5def6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/170c04f7c00158e3ada1095aab092b0fddb5def6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16652c9c17c5e9e5500b82f983d42732f08a2a29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16652c9c17c5e9e5500b82f983d42732f08a2a29", "html_url": "https://github.com/rust-lang/rust/commit/16652c9c17c5e9e5500b82f983d42732f08a2a29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16652c9c17c5e9e5500b82f983d42732f08a2a29/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a089c6f8fc93c9a914bd5cfd2445f4e184d4e670", "url": "https://api.github.com/repos/rust-lang/rust/commits/a089c6f8fc93c9a914bd5cfd2445f4e184d4e670", "html_url": "https://github.com/rust-lang/rust/commit/a089c6f8fc93c9a914bd5cfd2445f4e184d4e670"}, {"sha": "7bfd0e5035418bc162304ef87a5c5630abfe3830", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bfd0e5035418bc162304ef87a5c5630abfe3830", "html_url": "https://github.com/rust-lang/rust/commit/7bfd0e5035418bc162304ef87a5c5630abfe3830"}], "stats": {"total": 906, "additions": 457, "deletions": 449}, "files": [{"sha": "b1227af5f4c331cf86a33a9c8362da8ebb49f00a", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16652c9c17c5e9e5500b82f983d42732f08a2a29/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16652c9c17c5e9e5500b82f983d42732f08a2a29/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=16652c9c17c5e9e5500b82f983d42732f08a2a29", "patch": "@@ -32,6 +32,7 @@ macro_rules! rtdebug (\n     ($( $arg:expr),+) => ( $(let _ = $arg)*; )\n )\n \n+#[path = \"sched/mod.rs\"]\n mod sched;\n mod rtio;\n pub mod uvll;"}, {"sha": "d800101111464782067a6b56200d94ad100ea297", "filename": "src/libcore/rt/sched/local.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/16652c9c17c5e9e5500b82f983d42732f08a2a29/src%2Flibcore%2Frt%2Fsched%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16652c9c17c5e9e5500b82f983d42732f08a2a29/src%2Flibcore%2Frt%2Fsched%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Flocal.rs?ref=16652c9c17c5e9e5500b82f983d42732f08a2a29", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Access to the thread-local Scheduler\n+\n+use ptr::mut_null;\n+use libc::c_void;\n+use cast::transmute;\n+\n+use super::Scheduler;\n+use tls = super::super::thread_local_storage;\n+#[cfg(test)] use super::super::uvio::UvEventLoop;\n+\n+/// Give the Scheduler to thread-local storage\n+pub fn put(sched: ~Scheduler) {\n+    unsafe {\n+        let key = tls_key();\n+        let void_sched: *mut c_void = transmute::<~Scheduler, *mut c_void>(sched);\n+        tls::set(key, void_sched);\n+    }\n+}\n+\n+/// Take ownership of the Scheduler from thread-local storage\n+pub fn take() -> ~Scheduler {\n+    unsafe {\n+        let key = tls_key();\n+        let void_sched: *mut c_void = tls::get(key);\n+        assert!(void_sched.is_not_null());\n+        let sched = transmute::<*mut c_void, ~Scheduler>(void_sched);\n+        tls::set(key, mut_null());\n+        return sched;\n+    }\n+}\n+\n+/// Borrow a mutable reference to the thread-local Scheduler\n+/// # Safety Note\n+/// Because this leaves the Scheduler in thread-local storage it is possible\n+/// For the Scheduler pointer to be aliased\n+pub unsafe fn borrow() -> &mut Scheduler {\n+    unsafe {\n+        let key = tls_key();\n+        let mut void_sched: *mut c_void = tls::get(key);\n+        assert!(void_sched.is_not_null());\n+        {\n+            let void_sched_ptr = &mut void_sched;\n+            let sched: &mut ~Scheduler = {\n+                transmute::<&mut *mut c_void, &mut ~Scheduler>(void_sched_ptr)\n+            };\n+            let sched: &mut Scheduler = &mut **sched;\n+            return sched;\n+        }\n+    }\n+}\n+\n+fn tls_key() -> tls::Key {\n+    unsafe {\n+        let key: *mut c_void = rust_get_sched_tls_key();\n+        let key: &mut tls::Key = transmute(key);\n+        return *key;\n+    }\n+}\n+\n+extern {\n+    fn rust_get_sched_tls_key() -> *mut c_void;\n+}\n+\n+#[test]\n+fn thread_local_scheduler_smoke_test() {\n+    let scheduler = ~UvEventLoop::new_scheduler();\n+    put(scheduler);\n+    let _scheduler = take();\n+}\n+\n+#[test]\n+fn thread_local_scheduler_two_instances() {\n+    let scheduler = ~UvEventLoop::new_scheduler();\n+    put(scheduler);\n+    let _scheduler = take();\n+    let scheduler = ~UvEventLoop::new_scheduler();\n+    put(scheduler);\n+    let _scheduler = take();\n+}\n+\n+#[test]\n+fn borrow_smoke_test() {\n+    let scheduler = ~UvEventLoop::new_scheduler();\n+    put(scheduler);\n+    unsafe {\n+        let _scheduler = borrow();\n+    }\n+    let _scheduler = take();\n+}\n+"}, {"sha": "f157e6a80e0c4fe6e63e705a1a92242ee0f1c89a", "filename": "src/libcore/rt/sched/mod.rs", "status": "renamed", "additions": 182, "deletions": 261, "changes": 443, "blob_url": "https://github.com/rust-lang/rust/blob/16652c9c17c5e9e5500b82f983d42732f08a2a29/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16652c9c17c5e9e5500b82f983d42732f08a2a29/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Fmod.rs?ref=16652c9c17c5e9e5500b82f983d42732f08a2a29", "patch": "@@ -11,18 +11,18 @@\n use option::*;\n use sys;\n use cast::transmute;\n-use libc::c_void;\n-use ptr::mut_null;\n \n use super::work_queue::WorkQueue;\n use super::stack::{StackPool, StackSegment};\n-use super::rtio::{EventLoop, EventLoopObject};\n+use super::rtio::{EventLoop, EventLoopObject, IoFactoryObject};\n use super::context::Context;\n-use tls = super::thread_local_storage;\n \n #[cfg(test)] use super::uvio::UvEventLoop;\n #[cfg(test)] use unstable::run_in_bare_thread;\n #[cfg(test)] use int;\n+#[cfg(test)] use cell::Cell;\n+\n+mod local;\n \n /// The Scheduler is responsible for coordinating execution of Tasks\n /// on a single thread. When the scheduler is running it is owned by\n@@ -38,31 +38,25 @@ pub struct Scheduler {\n     priv saved_context: Context,\n     /// The currently executing task\n     priv current_task: Option<~Task>,\n-    /// A queue of jobs to perform immediately upon return from task\n-    /// context to scheduler context.\n-    /// XXX: This probably should be a single cleanup action and it\n-    /// should run after a context switch, not on return from the\n-    /// scheduler\n-    priv cleanup_jobs: ~[CleanupJob]\n+    /// An action performed after a context switch on behalf of the\n+    /// code running before the context switch\n+    priv cleanup_job: Option<CleanupJob>\n }\n \n // XXX: Some hacks to put a &fn in Scheduler without borrowck\n // complaining\n type UnsafeTaskReceiver = sys::Closure;\n-trait HackAroundBorrowCk {\n-    fn from_fn(&fn(&mut Scheduler, ~Task)) -> Self;\n-    fn to_fn(self) -> &fn(&mut Scheduler, ~Task);\n+trait ClosureConverter {\n+    fn from_fn(&fn(~Task)) -> Self;\n+    fn to_fn(self) -> &fn(~Task);\n }\n-impl HackAroundBorrowCk for UnsafeTaskReceiver {\n-    fn from_fn(f: &fn(&mut Scheduler, ~Task)) -> UnsafeTaskReceiver {\n-        unsafe { transmute(f) }\n-    }\n-    fn to_fn(self) -> &fn(&mut Scheduler, ~Task) {\n-        unsafe { transmute(self) }\n-    }\n+impl ClosureConverter for UnsafeTaskReceiver {\n+    fn from_fn(f: &fn(~Task)) -> UnsafeTaskReceiver { unsafe { transmute(f) } }\n+    fn to_fn(self) -> &fn(~Task) { unsafe { transmute(self) } }\n }\n \n enum CleanupJob {\n+    DoNothing,\n     RescheduleTask(~Task),\n     RecycleTask(~Task),\n     GiveTask(~Task, UnsafeTaskReceiver)\n@@ -84,7 +78,7 @@ pub impl Scheduler {\n             stack_pool: StackPool::new(),\n             saved_context: Context::empty(),\n             current_task: None,\n-            cleanup_jobs: ~[]\n+            cleanup_job: None\n         }\n     }\n \n@@ -96,39 +90,52 @@ pub impl Scheduler {\n         assert!(!self.in_task_context());\n \n         // Give ownership of the scheduler (self) to the thread\n-        do self.install |scheduler| {\n-            fn run_scheduler_once() {\n-                do Scheduler::local |scheduler| {\n-                    if scheduler.resume_task_from_queue() {\n-                        // Ok, a task ran. Nice! We'll do it again later\n-                        scheduler.event_loop.callback(run_scheduler_once);\n-                    }\n+        local::put(self);\n+\n+        let scheduler = unsafe { local::borrow() };\n+        fn run_scheduler_once() {\n+            let scheduler = Scheduler::take_local();\n+            if scheduler.resume_task_from_queue() {\n+                // Ok, a task ran. Nice! We'll do it again later\n+                do Scheduler::borrow_local |scheduler| {\n+                    scheduler.event_loop.callback(run_scheduler_once);\n                 }\n             }\n-\n-            scheduler.event_loop.callback(run_scheduler_once);\n-            scheduler.event_loop.run();\n         }\n+\n+        scheduler.event_loop.callback(run_scheduler_once);\n+        scheduler.event_loop.run();\n+\n+        return local::take();\n     }\n \n-    fn install(~self, f: &fn(&mut Scheduler)) -> ~Scheduler {\n-        let mut tlsched = ThreadLocalScheduler::new();\n-        tlsched.put_scheduler(self);\n-        {\n-            let sched = tlsched.get_scheduler();\n-            f(sched);\n+    /// Get a mutable pointer to the thread-local I/O\n+    /// # Safety Note\n+    /// This allows other mutable aliases to the scheduler, both in the current\n+    /// execution context and other execution contexts.\n+    unsafe fn borrow_local_io() -> &mut IoFactoryObject {\n+        unsafe {\n+            let io = local::borrow().event_loop.io().unwrap();\n+            transmute::<&mut IoFactoryObject, &mut IoFactoryObject>(io)\n         }\n-        return tlsched.take_scheduler();\n     }\n \n-    fn local(f: &fn(&mut Scheduler)) {\n-        let mut tlsched = ThreadLocalScheduler::new();\n-        f(tlsched.get_scheduler());\n+    /// Borrow the thread-local scheduler from thread-local storage.\n+    /// While the scheduler is borrowed it is not available in TLS.\n+    fn borrow_local(f: &fn(&mut Scheduler)) {\n+        let mut sched = local::take();\n+        f(sched);\n+        local::put(sched);\n+    }\n+\n+    /// Take ownership of the scheduler from thread local storage\n+    fn take_local() -> ~Scheduler {\n+        local::take()\n     }\n \n     // * Scheduler-context operations\n \n-    fn resume_task_from_queue(&mut self) -> bool {\n+    fn resume_task_from_queue(~self) -> bool {\n         assert!(!self.in_task_context());\n \n         let mut self = self;\n@@ -139,40 +146,62 @@ pub impl Scheduler {\n             }\n             None => {\n                 rtdebug!(\"no tasks in queue\");\n+                local::put(self);\n                 return false;\n             }\n         }\n     }\n \n-    fn resume_task_immediately(&mut self, task: ~Task) {\n+    fn resume_task_immediately(~self, task: ~Task) {\n+        let mut self = self;\n         assert!(!self.in_task_context());\n \n         rtdebug!(\"scheduling a task\");\n \n         // Store the task in the scheduler so it can be grabbed later\n         self.current_task = Some(task);\n-        self.swap_in_task();\n+        self.enqueue_cleanup_job(DoNothing);\n+\n+        local::put(self);\n+\n+        // Take pointers to both the task and scheduler's saved registers.\n+        let sched = unsafe { local::borrow() };\n+        let (sched_context, _, next_task_context) = sched.get_contexts();\n+        let next_task_context = next_task_context.unwrap();\n+        // Context switch to the task, restoring it's registers\n+        // and saving the scheduler's\n+        Context::swap(sched_context, next_task_context);\n+\n+        let sched = unsafe { local::borrow() };\n         // The running task should have passed ownership elsewhere\n-        assert!(self.current_task.is_none());\n+        assert!(sched.current_task.is_none());\n \n         // Running tasks may have asked us to do some cleanup\n-        self.run_cleanup_jobs();\n+        sched.run_cleanup_job();\n     }\n \n \n     // * Task-context operations\n \n     /// Called by a running task to end execution, after which it will\n     /// be recycled by the scheduler for reuse in a new task.\n-    fn terminate_current_task(&mut self) {\n+    fn terminate_current_task(~self) {\n+        let mut self = self;\n         assert!(self.in_task_context());\n \n         rtdebug!(\"ending running task\");\n \n         let dead_task = self.current_task.swap_unwrap();\n         self.enqueue_cleanup_job(RecycleTask(dead_task));\n-        let dead_task = self.task_from_last_cleanup_job();\n-        self.swap_out_task(dead_task);\n+\n+        local::put(self);\n+\n+        let sched = unsafe { local::borrow() };\n+        let (sched_context, last_task_context, _) = sched.get_contexts();\n+        let last_task_context = last_task_context.unwrap();\n+        Context::swap(last_task_context, sched_context);\n+\n+        // Control never reaches here\n     }\n \n     /// Block a running task, context switch to the scheduler, then pass the\n@@ -183,127 +212,120 @@ pub impl Scheduler {\n     /// The closure here is a *stack* closure that lives in the\n     /// running task.  It gets transmuted to the scheduler's lifetime\n     /// and called while the task is blocked.\n-    fn block_running_task_and_then(&mut self, f: &fn(&mut Scheduler, ~Task)) {\n+    fn deschedule_running_task_and_then(~self, f: &fn(~Task)) {\n+        let mut self = self;\n         assert!(self.in_task_context());\n \n         rtdebug!(\"blocking task\");\n \n         let blocked_task = self.current_task.swap_unwrap();\n-        let f_fake_region = unsafe {\n-            transmute::<&fn(&mut Scheduler, ~Task), &fn(&mut Scheduler, ~Task)>(f)\n-        };\n-        let f_opaque = HackAroundBorrowCk::from_fn(f_fake_region);\n+        let f_fake_region = unsafe { transmute::<&fn(~Task), &fn(~Task)>(f) };\n+        let f_opaque = ClosureConverter::from_fn(f_fake_region);\n         self.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n-        let blocked_task = self.task_from_last_cleanup_job();\n \n-        self.swap_out_task(blocked_task);\n+        local::put(self);\n+\n+        let sched = unsafe { local::borrow() };\n+        let (sched_context, last_task_context, _) = sched.get_contexts();\n+        let last_task_context = last_task_context.unwrap();\n+        Context::swap(last_task_context, sched_context);\n+\n+        // We could be executing in a different thread now\n+        let sched = unsafe { local::borrow() };\n+        sched.run_cleanup_job();\n     }\n \n     /// Switch directly to another task, without going through the scheduler.\n     /// You would want to think hard about doing this, e.g. if there are\n     /// pending I/O events it would be a bad idea.\n-    fn resume_task_from_running_task_direct(&mut self, next_task: ~Task) {\n+    fn resume_task_from_running_task_direct(~self, next_task: ~Task) {\n+        let mut self = self;\n         assert!(self.in_task_context());\n \n         rtdebug!(\"switching tasks\");\n \n         let old_running_task = self.current_task.swap_unwrap();\n         self.enqueue_cleanup_job(RescheduleTask(old_running_task));\n-        let old_running_task = self.task_from_last_cleanup_job();\n-\n         self.current_task = Some(next_task);\n-        self.swap_in_task_from_running_task(old_running_task);\n-    }\n \n+        local::put(self);\n \n-    // * Context switching\n+        let sched = unsafe { local::borrow() };\n+        let (_, last_task_context, next_task_context) = sched.get_contexts();\n+        let last_task_context = last_task_context.unwrap();\n+        let next_task_context = next_task_context.unwrap();\n+        Context::swap(last_task_context, next_task_context);\n \n-    // NB: When switching to a task callers are expected to first set\n-    // self.running_task. When switching away from a task likewise move\n-    // out of the self.running_task\n-\n-    priv fn swap_in_task(&mut self) {\n-        // Take pointers to both the task and scheduler's saved registers.\n-        let running_task: &~Task = self.current_task.get_ref();\n-        let task_context = &running_task.saved_context;\n-        let scheduler_context = &mut self.saved_context;\n-\n-        // Context switch to the task, restoring it's registers\n-        // and saving the scheduler's\n-        Context::swap(scheduler_context, task_context);\n-    }\n-\n-    priv fn swap_out_task(&mut self, running_task: &mut Task) {\n-        let task_context = &mut running_task.saved_context;\n-        let scheduler_context = &self.saved_context;\n-        Context::swap(task_context, scheduler_context);\n+        // We could be executing in a different thread now\n+        let sched = unsafe { local::borrow() };\n+        sched.run_cleanup_job();\n     }\n \n-    priv fn swap_in_task_from_running_task(&mut self, running_task: &mut Task) {\n-        let running_task_context = &mut running_task.saved_context;\n-        let next_context = &self.current_task.get_ref().saved_context;\n-        Context::swap(running_task_context, next_context);\n-    }\n-\n-\n     // * Other stuff\n \n     fn in_task_context(&self) -> bool { self.current_task.is_some() }\n \n     fn enqueue_cleanup_job(&mut self, job: CleanupJob) {\n-        self.cleanup_jobs.unshift(job);\n+        assert!(self.cleanup_job.is_none());\n+        self.cleanup_job = Some(job);\n     }\n \n-    fn run_cleanup_jobs(&mut self) {\n-        assert!(!self.in_task_context());\n-        rtdebug!(\"running cleanup jobs\");\n+    fn run_cleanup_job(&mut self) {\n+        rtdebug!(\"running cleanup job\");\n \n-        while !self.cleanup_jobs.is_empty() {\n-            match self.cleanup_jobs.pop() {\n-                RescheduleTask(task) => {\n-                    // NB: Pushing to the *front* of the queue\n-                    self.task_queue.push_front(task);\n-                }\n-                RecycleTask(task) => task.recycle(&mut self.stack_pool),\n-                GiveTask(task, f) => (f.to_fn())(self, task)\n+        assert!(self.cleanup_job.is_some());\n+\n+        let cleanup_job = self.cleanup_job.swap_unwrap();\n+        match cleanup_job {\n+            DoNothing => { }\n+            RescheduleTask(task) => {\n+                // NB: Pushing to the *front* of the queue\n+                self.task_queue.push_front(task);\n             }\n+            RecycleTask(task) => task.recycle(&mut self.stack_pool),\n+            GiveTask(task, f) => (f.to_fn())(task)\n         }\n     }\n \n-    // XXX: Hack. This should return &'self mut but I don't know how to\n-    // make the borrowcheck happy\n-    #[cfg(stage0)]\n-    fn task_from_last_cleanup_job(&mut self) -> &mut Task {\n-        assert!(!self.cleanup_jobs.is_empty());\n-        let last_job: &'self mut CleanupJob = &mut self.cleanup_jobs[0];\n-        let last_task: &'self Task = match last_job {\n-            &RescheduleTask(~ref task) => task,\n-            &RecycleTask(~ref task) => task,\n-            &GiveTask(~ref task, _) => task,\n-        };\n-        // XXX: Pattern matching mutable pointers above doesn't work\n-        // because borrowck thinks the three patterns are conflicting\n-        // borrows\n-        return unsafe { transmute::<&Task, &mut Task>(last_task) };\n-    }\n-\n-    // XXX: Hack. This should return &'self mut but I don't know how to\n-    // make the borrowcheck happy\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n-    fn task_from_last_cleanup_job<'a>(&'a mut self) -> &mut Task {\n-        assert!(!self.cleanup_jobs.is_empty());\n-        let last_job: &'a mut CleanupJob = &mut self.cleanup_jobs[0];\n-        let last_task: &'a Task = match last_job {\n-            &RescheduleTask(~ref task) => task,\n-            &RecycleTask(~ref task) => task,\n-            &GiveTask(~ref task, _) => task,\n+    /// Get mutable references to all the contexts that may be involved in a\n+    /// context switch.\n+    ///\n+    /// Returns (the scheduler context, the optional context of the\n+    /// task in the cleanup list, the optional context of the task in\n+    /// the current task slot).  When context switching to a task,\n+    /// callers should first arrange for that task to be located in the\n+    /// Scheduler's current_task slot and set up the\n+    /// post-context-switch cleanup job.\n+    fn get_contexts<'a>(&'a mut self) -> (&'a mut Context,\n+                                          Option<&'a mut Context>,\n+                                          Option<&'a mut Context>) {\n+        let last_task = match self.cleanup_job {\n+            Some(RescheduleTask(~ref task)) |\n+            Some(RecycleTask(~ref task)) |\n+            Some(GiveTask(~ref task, _)) => {\n+                Some(task)\n+            }\n+            Some(DoNothing) => {\n+                None\n+            }\n+            None => fail!(fmt!(\"all context switches should have a cleanup job\"))\n         };\n         // XXX: Pattern matching mutable pointers above doesn't work\n         // because borrowck thinks the three patterns are conflicting\n         // borrows\n-        return unsafe { transmute::<&Task, &mut Task>(last_task) };\n+        unsafe {\n+            let last_task = transmute::<Option<&Task>, Option<&mut Task>>(last_task);\n+            let last_task_context = match last_task {\n+                Some(ref t) => Some(&mut t.saved_context), None => None\n+            };\n+            let next_task_context = match self.current_task {\n+                Some(ref mut t) => Some(&mut t.saved_context), None => None\n+            };\n+            // XXX: These transmutes can be removed after snapshot\n+            return (transmute(&mut self.saved_context),\n+                    last_task_context,\n+                    transmute(next_task_context));\n+        }\n     }\n }\n \n@@ -333,10 +355,15 @@ pub impl Task {\n     priv fn build_start_wrapper(start: ~fn()) -> ~fn() {\n         // XXX: The old code didn't have this extra allocation\n         let wrapper: ~fn() = || {\n+            // This is the first code to execute after the initial\n+            // context switch to the task. The previous context may\n+            // have asked us to do some cleanup.\n+            let sched = unsafe { local::borrow() };\n+            sched.run_cleanup_job();\n+\n             start();\n \n-            let mut sched = ThreadLocalScheduler::new();\n-            let sched = sched.get_scheduler();\n+            let sched = Scheduler::take_local();\n             sched.terminate_current_task();\n         };\n         return wrapper;\n@@ -352,112 +379,6 @@ pub impl Task {\n     }\n }\n \n-// NB: This is a type so we can use make use of the &self region.\n-struct ThreadLocalScheduler(tls::Key);\n-\n-impl ThreadLocalScheduler {\n-    fn new() -> ThreadLocalScheduler {\n-        unsafe {\n-            // NB: This assumes that the TLS key has been created prior.\n-            // Currently done in rust_start.\n-            let key: *mut c_void = rust_get_sched_tls_key();\n-            let key: &mut tls::Key = transmute(key);\n-            ThreadLocalScheduler(*key)\n-        }\n-    }\n-\n-    fn put_scheduler(&mut self, scheduler: ~Scheduler) {\n-        unsafe {\n-            let key = match self { &ThreadLocalScheduler(key) => key };\n-            let value: *mut c_void = transmute::<~Scheduler, *mut c_void>(scheduler);\n-            tls::set(key, value);\n-        }\n-    }\n-\n-    #[cfg(stage0)]\n-    fn get_scheduler(&mut self) -> &'self mut Scheduler {\n-        unsafe {\n-            let key = match self { &ThreadLocalScheduler(key) => key };\n-            let mut value: *mut c_void = tls::get(key);\n-            assert!(value.is_not_null());\n-            {\n-                let value_ptr = &mut value;\n-                let sched: &mut ~Scheduler = {\n-                    transmute::<&mut *mut c_void, &mut ~Scheduler>(value_ptr)\n-                };\n-                let sched: &mut Scheduler = &mut **sched;\n-                return sched;\n-            }\n-        }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n-    fn get_scheduler<'a>(&'a mut self) -> &'a mut Scheduler {\n-        unsafe {\n-            let key = match self { &ThreadLocalScheduler(key) => key };\n-            let mut value: *mut c_void = tls::get(key);\n-            assert!(value.is_not_null());\n-            {\n-                let value_ptr = &mut value;\n-                let sched: &mut ~Scheduler = {\n-                    transmute::<&mut *mut c_void, &mut ~Scheduler>(value_ptr)\n-                };\n-                let sched: &mut Scheduler = &mut **sched;\n-                return sched;\n-            }\n-        }\n-    }\n-\n-    fn take_scheduler(&mut self) -> ~Scheduler {\n-        unsafe {\n-            let key = match self { &ThreadLocalScheduler(key) => key };\n-            let value: *mut c_void = tls::get(key);\n-            assert!(value.is_not_null());\n-            let sched = transmute(value);\n-            tls::set(key, mut_null());\n-            return sched;\n-        }\n-    }\n-}\n-\n-extern {\n-    fn rust_get_sched_tls_key() -> *mut c_void;\n-}\n-\n-#[test]\n-fn thread_local_scheduler_smoke_test() {\n-    let scheduler = ~UvEventLoop::new_scheduler();\n-    let mut tls_scheduler = ThreadLocalScheduler::new();\n-    tls_scheduler.put_scheduler(scheduler);\n-    {\n-        let _scheduler = tls_scheduler.get_scheduler();\n-    }\n-    let _scheduler = tls_scheduler.take_scheduler();\n-}\n-\n-#[test]\n-fn thread_local_scheduler_two_instances() {\n-    let scheduler = ~UvEventLoop::new_scheduler();\n-    let mut tls_scheduler = ThreadLocalScheduler::new();\n-    tls_scheduler.put_scheduler(scheduler);\n-    {\n-\n-        let _scheduler = tls_scheduler.get_scheduler();\n-    }\n-    {\n-        let scheduler = tls_scheduler.take_scheduler();\n-        tls_scheduler.put_scheduler(scheduler);\n-    }\n-\n-    let mut tls_scheduler = ThreadLocalScheduler::new();\n-    {\n-        let _scheduler = tls_scheduler.get_scheduler();\n-    }\n-    let _scheduler = tls_scheduler.take_scheduler();\n-}\n-\n #[test]\n fn test_simple_scheduling() {\n     do run_in_bare_thread {\n@@ -502,13 +423,12 @@ fn test_swap_tasks() {\n         let mut sched = ~UvEventLoop::new_scheduler();\n         let task1 = ~do Task::new(&mut sched.stack_pool) {\n             unsafe { *count_ptr = *count_ptr + 1; }\n-            do Scheduler::local |sched| {\n-                let task2 = ~do Task::new(&mut sched.stack_pool) {\n-                    unsafe { *count_ptr = *count_ptr + 1; }\n-                };\n-                // Context switch directly to the new task\n-                sched.resume_task_from_running_task_direct(task2);\n-            }\n+            let mut sched = Scheduler::take_local();\n+            let task2 = ~do Task::new(&mut sched.stack_pool) {\n+                unsafe { *count_ptr = *count_ptr + 1; }\n+            };\n+            // Context switch directly to the new task\n+            sched.resume_task_from_running_task_direct(task2);\n             unsafe { *count_ptr = *count_ptr + 1; }\n         };\n         sched.task_queue.push_back(task1);\n@@ -535,7 +455,7 @@ fn test_run_a_lot_of_tasks_queued() {\n         assert!(count == MAX);\n \n         fn run_task(count_ptr: *mut int) {\n-            do Scheduler::local |sched| {\n+            do Scheduler::borrow_local |sched| {\n                 let task = ~do Task::new(&mut sched.stack_pool) {\n                     unsafe {\n                         *count_ptr = *count_ptr + 1;\n@@ -568,18 +488,17 @@ fn test_run_a_lot_of_tasks_direct() {\n         assert!(count == MAX);\n \n         fn run_task(count_ptr: *mut int) {\n-            do Scheduler::local |sched| {\n-                let task = ~do Task::new(&mut sched.stack_pool) {\n-                    unsafe {\n-                        *count_ptr = *count_ptr + 1;\n-                        if *count_ptr != MAX {\n-                            run_task(count_ptr);\n-                        }\n+            let mut sched = Scheduler::take_local();\n+            let task = ~do Task::new(&mut sched.stack_pool) {\n+                unsafe {\n+                    *count_ptr = *count_ptr + 1;\n+                    if *count_ptr != MAX {\n+                        run_task(count_ptr);\n                     }\n-                };\n-                // Context switch directly to the new task\n-                sched.resume_task_from_running_task_direct(task);\n-            }\n+                }\n+            };\n+            // Context switch directly to the new task\n+            sched.resume_task_from_running_task_direct(task);\n         };\n     }\n }\n@@ -589,11 +508,13 @@ fn test_block_task() {\n     do run_in_bare_thread {\n         let mut sched = ~UvEventLoop::new_scheduler();\n         let task = ~do Task::new(&mut sched.stack_pool) {\n-            do Scheduler::local |sched| {\n-                assert!(sched.in_task_context());\n-                do sched.block_running_task_and_then() |sched, task| {\n+            let sched = Scheduler::take_local();\n+            assert!(sched.in_task_context());\n+            do sched.deschedule_running_task_and_then() |task| {\n+                let task = Cell(task);\n+                do Scheduler::borrow_local |sched| {\n                     assert!(!sched.in_task_context());\n-                    sched.task_queue.push_back(task);\n+                    sched.task_queue.push_back(task.take());\n                 }\n             }\n         };", "previous_filename": "src/libcore/rt/sched.rs"}, {"sha": "fe7b0a71dbfe660ed1f9c9d60389ad6ac2f10e1a", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 174, "deletions": 188, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/16652c9c17c5e9e5500b82f983d42732f08a2a29/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16652c9c17c5e9e5500b82f983d42732f08a2a29/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=16652c9c17c5e9e5500b82f983d42732f08a2a29", "patch": "@@ -120,37 +120,37 @@ impl IoFactory for UvIoFactory {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n \n-        do Scheduler::local |scheduler| {\n-            assert!(scheduler.in_task_context());\n+        let scheduler = Scheduler::take_local();\n+        assert!(scheduler.in_task_context());\n \n-            // Block this task and take ownership, switch to scheduler context\n-            do scheduler.block_running_task_and_then |scheduler, task| {\n+        // Block this task and take ownership, switch to scheduler context\n+        do scheduler.deschedule_running_task_and_then |task| {\n \n-                rtdebug!(\"connect: entered scheduler context\");\n+            rtdebug!(\"connect: entered scheduler context\");\n+            do Scheduler::borrow_local |scheduler| {\n                 assert!(!scheduler.in_task_context());\n-                let mut tcp_watcher = TcpWatcher::new(self.uv_loop());\n-                let task_cell = Cell(task);\n-\n-                // Wait for a connection\n-                do tcp_watcher.connect(addr) |stream_watcher, status| {\n-                    rtdebug!(\"connect: in connect callback\");\n-                    let maybe_stream = if status.is_none() {\n-                        rtdebug!(\"status is none\");\n-                        Some(~UvStream(stream_watcher))\n-                    } else {\n-                        rtdebug!(\"status is some\");\n-                        stream_watcher.close(||());\n-                        None\n-                    };\n-\n-                    // Store the stream in the task's stack\n-                    unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n-\n-                    // Context switch\n-                    do Scheduler::local |scheduler| {\n-                        scheduler.resume_task_immediately(task_cell.take());\n-                    }\n-                }\n+            }\n+            let mut tcp_watcher = TcpWatcher::new(self.uv_loop());\n+            let task_cell = Cell(task);\n+\n+            // Wait for a connection\n+            do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                rtdebug!(\"connect: in connect callback\");\n+                let maybe_stream = if status.is_none() {\n+                    rtdebug!(\"status is none\");\n+                    Some(~UvStream(stream_watcher))\n+                } else {\n+                    rtdebug!(\"status is some\");\n+                    stream_watcher.close(||());\n+                    None\n+                };\n+\n+                // Store the stream in the task's stack\n+                unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n+\n+                // Context switch\n+                let scheduler = Scheduler::take_local();\n+                scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n \n@@ -194,33 +194,31 @@ impl TcpListener for UvTcpListener {\n \n         let server_tcp_watcher = self.watcher();\n \n-        do Scheduler::local |scheduler| {\n-            assert!(scheduler.in_task_context());\n-\n-            do scheduler.block_running_task_and_then |_, task| {\n-                let task_cell = Cell(task);\n-                let mut server_tcp_watcher = server_tcp_watcher;\n-                do server_tcp_watcher.listen |server_stream_watcher, status| {\n-                    let maybe_stream = if status.is_none() {\n-                        let mut server_stream_watcher = server_stream_watcher;\n-                        let mut loop_ = loop_from_watcher(&server_stream_watcher);\n-                        let mut client_tcp_watcher = TcpWatcher::new(&mut loop_);\n-                        let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n-                        // XXX: Need's to be surfaced in interface\n-                        server_stream_watcher.accept(client_tcp_watcher);\n-                        Some(~UvStream::new(client_tcp_watcher))\n-                    } else {\n-                        None\n-                    };\n-\n-                    unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n-\n-                    rtdebug!(\"resuming task from listen\");\n-                    // Context switch\n-                    do Scheduler::local |scheduler| {\n-                        scheduler.resume_task_immediately(task_cell.take());\n-                    }\n-                }\n+        let scheduler = Scheduler::take_local();\n+        assert!(scheduler.in_task_context());\n+\n+        do scheduler.deschedule_running_task_and_then |task| {\n+            let task_cell = Cell(task);\n+            let mut server_tcp_watcher = server_tcp_watcher;\n+            do server_tcp_watcher.listen |server_stream_watcher, status| {\n+                let maybe_stream = if status.is_none() {\n+                    let mut server_stream_watcher = server_stream_watcher;\n+                    let mut loop_ = loop_from_watcher(&server_stream_watcher);\n+                    let mut client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+                    let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n+                    // XXX: Need's to be surfaced in interface\n+                    server_stream_watcher.accept(client_tcp_watcher);\n+                    Some(~UvStream::new(client_tcp_watcher))\n+                } else {\n+                    None\n+                };\n+\n+                unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n+\n+                rtdebug!(\"resuming task from listen\");\n+                // Context switch\n+                let scheduler = Scheduler::take_local();\n+                scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n \n@@ -259,42 +257,42 @@ impl Stream for UvStream {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Result<uint, ()>> = &result_cell;\n \n-        do Scheduler::local |scheduler| {\n-            assert!(scheduler.in_task_context());\n-            let watcher = self.watcher();\n-            let buf_ptr: *&mut [u8] = &buf;\n-            do scheduler.block_running_task_and_then |scheduler, task| {\n-                rtdebug!(\"read: entered scheduler context\");\n+        let scheduler = Scheduler::take_local();\n+        assert!(scheduler.in_task_context());\n+        let watcher = self.watcher();\n+        let buf_ptr: *&mut [u8] = &buf;\n+        do scheduler.deschedule_running_task_and_then |task| {\n+            rtdebug!(\"read: entered scheduler context\");\n+            do Scheduler::borrow_local |scheduler| {\n                 assert!(!scheduler.in_task_context());\n+            }\n+            let mut watcher = watcher;\n+            let task_cell = Cell(task);\n+            // XXX: We shouldn't reallocate these callbacks every\n+            // call to read\n+            let alloc: AllocCallback = |_| unsafe {\n+                slice_to_uv_buf(*buf_ptr)\n+            };\n+            do watcher.read_start(alloc) |watcher, nread, _buf, status| {\n+\n+                // Stop reading so that no read callbacks are\n+                // triggered before the user calls `read` again.\n+                // XXX: Is there a performance impact to calling\n+                // stop here?\n                 let mut watcher = watcher;\n-                let task_cell = Cell(task);\n-                // XXX: We shouldn't reallocate these callbacks every\n-                // call to read\n-                let alloc: AllocCallback = |_| unsafe {\n-                    slice_to_uv_buf(*buf_ptr)\n+                watcher.read_stop();\n+\n+                let result = if status.is_none() {\n+                    assert!(nread >= 0);\n+                    Ok(nread as uint)\n+                } else {\n+                    Err(())\n                 };\n-                do watcher.read_start(alloc) |watcher, nread, _buf, status| {\n-\n-                    // Stop reading so that no read callbacks are\n-                    // triggered before the user calls `read` again.\n-                    // XXX: Is there a performance impact to calling\n-                    // stop here?\n-                    let mut watcher = watcher;\n-                    watcher.read_stop();\n-\n-                    let result = if status.is_none() {\n-                        assert!(nread >= 0);\n-                        Ok(nread as uint)\n-                    } else {\n-                        Err(())\n-                    };\n-\n-                    unsafe { (*result_cell_ptr).put_back(result); }\n-\n-                    do Scheduler::local |scheduler| {\n-                        scheduler.resume_task_immediately(task_cell.take());\n-                    }\n-                }\n+\n+                unsafe { (*result_cell_ptr).put_back(result); }\n+\n+                let scheduler = Scheduler::take_local();\n+                scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n \n@@ -305,29 +303,27 @@ impl Stream for UvStream {\n     fn write(&mut self, buf: &[u8]) -> Result<(), ()> {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Result<(), ()>> = &result_cell;\n-        do Scheduler::local |scheduler| {\n-            assert!(scheduler.in_task_context());\n-            let watcher = self.watcher();\n-            let buf_ptr: *&[u8] = &buf;\n-            do scheduler.block_running_task_and_then |_, task| {\n-                let mut watcher = watcher;\n-                let task_cell = Cell(task);\n-                let buf = unsafe { &*buf_ptr };\n-                // XXX: OMGCOPIES\n-                let buf = buf.to_vec();\n-                do watcher.write(buf) |_watcher, status| {\n-                    let result = if status.is_none() {\n-                        Ok(())\n-                    } else {\n-                        Err(())\n-                    };\n-\n-                    unsafe { (*result_cell_ptr).put_back(result); }\n-\n-                    do Scheduler::local |scheduler| {\n-                        scheduler.resume_task_immediately(task_cell.take());\n-                    }\n-                }\n+        let scheduler = Scheduler::take_local();\n+        assert!(scheduler.in_task_context());\n+        let watcher = self.watcher();\n+        let buf_ptr: *&[u8] = &buf;\n+        do scheduler.deschedule_running_task_and_then |task| {\n+            let mut watcher = watcher;\n+            let task_cell = Cell(task);\n+            let buf = unsafe { &*buf_ptr };\n+            // XXX: OMGCOPIES\n+            let buf = buf.to_vec();\n+            do watcher.write(buf) |_watcher, status| {\n+                let result = if status.is_none() {\n+                    Ok(())\n+                } else {\n+                    Err(())\n+                };\n+\n+                unsafe { (*result_cell_ptr).put_back(result); }\n+\n+                let scheduler = Scheduler::take_local();\n+                scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n \n@@ -342,12 +338,10 @@ fn test_simple_io_no_connect() {\n     do run_in_bare_thread {\n         let mut sched = ~UvEventLoop::new_scheduler();\n         let task = ~do Task::new(&mut sched.stack_pool) {\n-            do Scheduler::local |sched| {\n-                let io = sched.event_loop.io().unwrap();\n-                let addr = Ipv4(127, 0, 0, 1, 2926);\n-                let maybe_chan = io.connect(addr);\n-                assert!(maybe_chan.is_none());\n-            }\n+            let io = unsafe { Scheduler::borrow_local_io() };\n+            let addr = Ipv4(127, 0, 0, 1, 2926);\n+            let maybe_chan = io.connect(addr);\n+            assert!(maybe_chan.is_none());\n         };\n         sched.task_queue.push_back(task);\n         sched.run();\n@@ -362,29 +356,25 @@ fn test_simple_tcp_server_and_client() {\n         let addr = Ipv4(127, 0, 0, 1, 2929);\n \n         let client_task = ~do Task::new(&mut sched.stack_pool) {\n-            do Scheduler::local |sched| {\n-                let io = sched.event_loop.io().unwrap();\n-                let mut stream = io.connect(addr).unwrap();\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.close();\n-            }\n+            let io = unsafe { Scheduler::borrow_local_io() };\n+            let mut stream = io.connect(addr).unwrap();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.close();\n         };\n \n         let server_task = ~do Task::new(&mut sched.stack_pool) {\n-            do Scheduler::local |sched| {\n-                let io = sched.event_loop.io().unwrap();\n-                let mut listener = io.bind(addr).unwrap();\n-                let mut stream = listener.listen().unwrap();\n-                let mut buf = [0, .. 2048];\n-                let nread = stream.read(buf).unwrap();\n-                assert!(nread == 8);\n-                for uint::range(0, nread) |i| {\n-                    rtdebug!(\"%u\", buf[i] as uint);\n-                    assert!(buf[i] == i as u8);\n-                }\n-                stream.close();\n-                listener.close();\n+            let io = unsafe { Scheduler::borrow_local_io() };\n+            let mut listener = io.bind(addr).unwrap();\n+            let mut stream = listener.listen().unwrap();\n+            let mut buf = [0, .. 2048];\n+            let nread = stream.read(buf).unwrap();\n+            assert!(nread == 8);\n+            for uint::range(0, nread) |i| {\n+                rtdebug!(\"%u\", buf[i] as uint);\n+                assert!(buf[i] == i as u8);\n             }\n+            stream.close();\n+            listener.close();\n         };\n \n         // Start the server first so it listens before the client connects\n@@ -401,53 +391,51 @@ fn test_read_and_block() {\n         let addr = Ipv4(127, 0, 0, 1, 2930);\n \n         let client_task = ~do Task::new(&mut sched.stack_pool) {\n-            do Scheduler::local |sched| {\n-                let io = sched.event_loop.io().unwrap();\n-                let mut stream = io.connect(addr).unwrap();\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.close();\n-            }\n+            let io = unsafe { Scheduler::borrow_local_io() };\n+            let mut stream = io.connect(addr).unwrap();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.close();\n         };\n \n         let server_task = ~do Task::new(&mut sched.stack_pool) {\n-            do Scheduler::local |sched| {\n-                let io = sched.event_loop.io().unwrap();\n-                let mut listener = io.bind(addr).unwrap();\n-                let mut stream = listener.listen().unwrap();\n-                let mut buf = [0, .. 2048];\n-\n-                let expected = 32;\n-                let mut current = 0;\n-                let mut reads = 0;\n-\n-                while current < expected {\n-                    let nread = stream.read(buf).unwrap();\n-                    for uint::range(0, nread) |i| {\n-                        let val = buf[i] as uint;\n-                        assert!(val == current % 8);\n-                        current += 1;\n-                    }\n-                    reads += 1;\n-\n-                    do Scheduler::local |scheduler| {\n-                        // Yield to the other task in hopes that it\n-                        // will trigger a read callback while we are\n-                        // not ready for it\n-                        do scheduler.block_running_task_and_then |scheduler, task| {\n-                            scheduler.task_queue.push_back(task);\n-                        }\n+            let io = unsafe { Scheduler::borrow_local_io() };\n+            let mut listener = io.bind(addr).unwrap();\n+            let mut stream = listener.listen().unwrap();\n+            let mut buf = [0, .. 2048];\n+\n+            let expected = 32;\n+            let mut current = 0;\n+            let mut reads = 0;\n+\n+            while current < expected {\n+                let nread = stream.read(buf).unwrap();\n+                for uint::range(0, nread) |i| {\n+                    let val = buf[i] as uint;\n+                    assert!(val == current % 8);\n+                    current += 1;\n+                }\n+                reads += 1;\n+\n+                let scheduler = Scheduler::take_local();\n+                // Yield to the other task in hopes that it\n+                // will trigger a read callback while we are\n+                // not ready for it\n+                do scheduler.deschedule_running_task_and_then |task| {\n+                    let task = Cell(task);\n+                    do Scheduler::borrow_local |scheduler| {\n+                        scheduler.task_queue.push_back(task.take());\n                     }\n                 }\n+            }\n \n-                // Make sure we had multiple reads\n-                assert!(reads > 1);\n+            // Make sure we had multiple reads\n+            assert!(reads > 1);\n \n-                stream.close();\n-                listener.close();\n-            }\n+            stream.close();\n+            listener.close();\n         };\n \n         // Start the server first so it listens before the client connects\n@@ -464,19 +452,17 @@ fn test_read_read_read() {\n         let addr = Ipv4(127, 0, 0, 1, 2931);\n \n         let client_task = ~do Task::new(&mut sched.stack_pool) {\n-            do Scheduler::local |sched| {\n-                let io = sched.event_loop.io().unwrap();\n-                let mut stream = io.connect(addr).unwrap();\n-                let mut buf = [0, .. 2048];\n-                let mut total_bytes_read = 0;\n-                while total_bytes_read < 500000000 {\n-                    let nread = stream.read(buf).unwrap();\n-                    rtdebug!(\"read %u bytes\", nread as uint);\n-                    total_bytes_read += nread;\n-                }\n-                rtdebug_!(\"read %u bytes total\", total_bytes_read as uint);\n-                stream.close();\n+            let io = unsafe { Scheduler::borrow_local_io() };\n+            let mut stream = io.connect(addr).unwrap();\n+            let mut buf = [0, .. 2048];\n+            let mut total_bytes_read = 0;\n+            while total_bytes_read < 500000000 {\n+                let nread = stream.read(buf).unwrap();\n+                rtdebug!(\"read %u bytes\", nread as uint);\n+                total_bytes_read += nread;\n             }\n+            rtdebug_!(\"read %u bytes total\", total_bytes_read as uint);\n+            stream.close();\n         };\n \n         sched.task_queue.push_back(client_task);"}]}