{"sha": "11f6096a9ef6ad52de2956f4d2df200de7617077", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExZjYwOTZhOWVmNmFkNTJkZTI5NTZmNGQyZGYyMDBkZTc2MTcwNzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-09T03:28:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-09T03:28:16Z"}, "message": "Auto merge of #70860 - lcnr:has_local_value, r=nikomatsakis\n\nremove `KEEP_IN_LOCAL_TCX` flag\n\ncloses #70285\n\nI did not rename `needs_infer` here as this complex enough as is.\nWill probably open a followup for that.\n\nr? @eddyb", "tree": {"sha": "bcee8572be11708a6d1bac29e53f9c9aa9fe85c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcee8572be11708a6d1bac29e53f9c9aa9fe85c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11f6096a9ef6ad52de2956f4d2df200de7617077", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11f6096a9ef6ad52de2956f4d2df200de7617077", "html_url": "https://github.com/rust-lang/rust/commit/11f6096a9ef6ad52de2956f4d2df200de7617077", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11f6096a9ef6ad52de2956f4d2df200de7617077/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d249d756374737eb014079901ac132f1e1ed905e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d249d756374737eb014079901ac132f1e1ed905e", "html_url": "https://github.com/rust-lang/rust/commit/d249d756374737eb014079901ac132f1e1ed905e"}, {"sha": "fca7d165be9df4e6febaa849482a696a5d2e12af", "url": "https://api.github.com/repos/rust-lang/rust/commits/fca7d165be9df4e6febaa849482a696a5d2e12af", "html_url": "https://github.com/rust-lang/rust/commit/fca7d165be9df4e6febaa849482a696a5d2e12af"}], "stats": {"total": 102, "additions": 44, "deletions": 58}, "files": [{"sha": "c3df5bd3d61abf33564621c5d8947b97dbeec4c6", "filename": "src/librustc_infer/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=11f6096a9ef6ad52de2956f4d2df200de7617077", "patch": "@@ -488,12 +488,12 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         V: TypeFoldable<'tcx>,\n     {\n         let needs_canonical_flags = if canonicalize_region_mode.any() {\n-            TypeFlags::KEEP_IN_LOCAL_TCX |\n+            TypeFlags::NEEDS_INFER |\n             TypeFlags::HAS_FREE_REGIONS | // `HAS_RE_PLACEHOLDER` implies `HAS_FREE_REGIONS`\n             TypeFlags::HAS_TY_PLACEHOLDER |\n             TypeFlags::HAS_CT_PLACEHOLDER\n         } else {\n-            TypeFlags::KEEP_IN_LOCAL_TCX\n+            TypeFlags::NEEDS_INFER\n                 | TypeFlags::HAS_RE_PLACEHOLDER\n                 | TypeFlags::HAS_TY_PLACEHOLDER\n                 | TypeFlags::HAS_CT_PLACEHOLDER\n@@ -524,7 +524,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         // Once we have canonicalized `out_value`, it should not\n         // contain anything that ties it to this inference context\n         // anymore, so it should live in the global arena.\n-        debug_assert!(!out_value.has_type_flags(TypeFlags::KEEP_IN_LOCAL_TCX));\n+        debug_assert!(!out_value.needs_infer());\n \n         let canonical_variables = tcx.intern_canonical_var_infos(&canonicalizer.variables);\n "}, {"sha": "b908b75a257e3a619485585b31849157b8989d92", "filename": "src/librustc_infer/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_infer%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_infer%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fresolve.rs?ref=11f6096a9ef6ad52de2956f4d2df200de7617077", "patch": "@@ -181,10 +181,8 @@ impl<'a, 'tcx> TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.needs_infer() && !ty::keep_local(&t) {\n+        if !t.needs_infer() {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n-        // ^ we need to have the `keep_local` check to un-default\n-        // defaulted tuples.\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n             match t.kind {\n@@ -222,10 +220,8 @@ impl<'a, 'tcx> TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n     }\n \n     fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if !c.needs_infer() && !ty::keep_local(&c) {\n+        if !c.needs_infer() {\n             c // micro-optimize -- if there is nothing in this const that this fold affects...\n-        // ^ we need to have the `keep_local` check to un-default\n-        // defaulted tuples.\n         } else {\n             let c = self.infcx.shallow_resolve(c);\n             match c.val {"}, {"sha": "903a62a9d91d15d7895d9e9253bdbc3af1a4bd5b", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=11f6096a9ef6ad52de2956f4d2df200de7617077", "patch": "@@ -2065,10 +2065,6 @@ macro_rules! direct_interners {\n     }\n }\n \n-pub fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n-    x.has_type_flags(ty::TypeFlags::KEEP_IN_LOCAL_TCX)\n-}\n-\n direct_interners!(\n     region: mk_region(RegionKind),\n     goal: mk_goal(GoalKind<'tcx>),"}, {"sha": "ba165925b64747b2b3e15a027e8902199b149c3c", "filename": "src/librustc_middle/ty/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_middle%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_middle%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ferase_regions.rs?ref=11f6096a9ef6ad52de2956f4d2df200de7617077", "patch": "@@ -40,7 +40,7 @@ impl TypeFolder<'tcx> for RegionEraserVisitor<'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if ty.has_local_value() { ty.super_fold_with(self) } else { self.tcx.erase_regions_ty(ty) }\n+        if ty.needs_infer() { ty.super_fold_with(self) } else { self.tcx.erase_regions_ty(ty) }\n     }\n \n     fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>"}, {"sha": "172f6d4608b1f428b632d30d174aab85cb8418e2", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=11f6096a9ef6ad52de2956f4d2df200de7617077", "patch": "@@ -109,13 +109,12 @@ impl FlagComputation {\n             }\n \n             &ty::Infer(infer) => {\n-                self.add_flags(TypeFlags::HAS_TY_INFER);\n                 self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n                 match infer {\n                     ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_) => {}\n \n                     ty::TyVar(_) | ty::IntVar(_) | ty::FloatVar(_) => {\n-                        self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX)\n+                        self.add_flags(TypeFlags::HAS_TY_INFER)\n                     }\n                 }\n             }\n@@ -221,11 +220,10 @@ impl FlagComputation {\n                 self.add_flags(TypeFlags::HAS_CT_PROJECTION);\n             }\n             ty::ConstKind::Infer(infer) => {\n-                self.add_flags(TypeFlags::HAS_CT_INFER);\n                 self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n                 match infer {\n                     InferConst::Fresh(_) => {}\n-                    InferConst::Var(_) => self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX),\n+                    InferConst::Var(_) => self.add_flags(TypeFlags::HAS_CT_INFER),\n                 }\n             }\n             ty::ConstKind::Bound(debruijn, _) => {"}, {"sha": "d144e507691ce1695c87f7366fa58eb5cee0c7ce", "filename": "src/librustc_middle/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_middle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_middle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ffold.rs?ref=11f6096a9ef6ad52de2956f4d2df200de7617077", "patch": "@@ -96,9 +96,6 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_infer_consts(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_CT_INFER)\n     }\n-    fn has_local_value(&self) -> bool {\n-        self.has_type_flags(TypeFlags::KEEP_IN_LOCAL_TCX)\n-    }\n     fn needs_infer(&self) -> bool {\n         self.has_type_flags(TypeFlags::NEEDS_INFER)\n     }"}, {"sha": "18518e78e3556558f6bea58a8263f17ad2e53a4c", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=11f6096a9ef6ad52de2956f4d2df200de7617077", "patch": "@@ -71,7 +71,7 @@ pub use crate::ty::diagnostics::*;\n pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n \n-pub use self::context::{keep_local, tls, FreeRegionInfo, TyCtxt};\n+pub use self::context::{tls, FreeRegionInfo, TyCtxt};\n pub use self::context::{\n     CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, ResolvedOpaqueTy,\n     UserType, UserTypeAnnotationIndex,\n@@ -577,27 +577,23 @@ bitflags! {\n                                           | TypeFlags::HAS_TY_OPAQUE.bits\n                                           | TypeFlags::HAS_CT_PROJECTION.bits;\n \n-        /// Present if the type belongs in a local type context.\n-        /// Set for placeholders and inference variables that are not \"Fresh\".\n-        const KEEP_IN_LOCAL_TCX           = 1 << 13;\n-\n         /// Is an error type reachable?\n-        const HAS_TY_ERR                  = 1 << 14;\n+        const HAS_TY_ERR                  = 1 << 13;\n \n         /// Does this have any region that \"appears free\" in the type?\n         /// Basically anything but [ReLateBound] and [ReErased].\n-        const HAS_FREE_REGIONS            = 1 << 15;\n+        const HAS_FREE_REGIONS            = 1 << 14;\n \n         /// Does this have any [ReLateBound] regions? Used to check\n         /// if a global bound is safe to evaluate.\n-        const HAS_RE_LATE_BOUND           = 1 << 16;\n+        const HAS_RE_LATE_BOUND           = 1 << 15;\n \n         /// Does this have any [ReErased] regions?\n-        const HAS_RE_ERASED               = 1 << 17;\n+        const HAS_RE_ERASED               = 1 << 16;\n \n         /// Does this value have parameters/placeholders/inference variables which could be\n         /// replaced later, in a way that would change the results of `impl` specialization?\n-        const STILL_FURTHER_SPECIALIZABLE = 1 << 18;\n+        const STILL_FURTHER_SPECIALIZABLE = 1 << 17;\n     }\n }\n "}, {"sha": "4d668e6ee59777810c1e1aa7154d595bed6baa4c", "filename": "src/librustc_middle/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_middle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_middle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Frelate.rs?ref=11f6096a9ef6ad52de2956f4d2df200de7617077", "patch": "@@ -510,7 +510,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n     let tcx = relation.tcx();\n \n     let eagerly_eval = |x: &'tcx ty::Const<'tcx>| {\n-        if !x.val.has_local_value() {\n+        if !x.val.needs_infer() {\n             return x.eval(tcx, relation.param_env()).val;\n         }\n         x.val"}, {"sha": "392abf37ba598fa5f70d6b1978fbeb6cd4abba11", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=11f6096a9ef6ad52de2956f4d2df200de7617077", "patch": "@@ -1605,7 +1605,6 @@ impl RegionKind {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n                 flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_INFER;\n-                flags = flags | TypeFlags::KEEP_IN_LOCAL_TCX;\n                 flags = flags | TypeFlags::STILL_FURTHER_SPECIALIZABLE;\n             }\n             ty::RePlaceholder(..) => {\n@@ -2361,8 +2360,8 @@ impl<'tcx> Const<'tcx> {\n         let try_const_eval = |did, param_env: ParamEnv<'tcx>, substs, promoted| {\n             let param_env_and_substs = param_env.with_reveal_all().and(substs);\n \n-            // Avoid querying `tcx.const_eval(...)` with any e.g. inference vars.\n-            if param_env_and_substs.has_local_value() {\n+            // Avoid querying `tcx.const_eval(...)` with any inference vars.\n+            if param_env_and_substs.needs_infer() {\n                 return None;\n             }\n \n@@ -2377,12 +2376,12 @@ impl<'tcx> Const<'tcx> {\n \n         match self.val {\n             ConstKind::Unevaluated(did, substs, promoted) => {\n-                // HACK(eddyb) when substs contain e.g. inference variables,\n+                // HACK(eddyb) when substs contain inference variables,\n                 // attempt using identity substs instead, that will succeed\n                 // when the expression doesn't depend on any parameters.\n                 // FIXME(eddyb, skinny121) pass `InferCtxt` into here when it's available, so that\n                 // we can call `infcx.const_eval_resolve` which handles inference variables.\n-                if substs.has_local_value() {\n+                if substs.needs_infer() {\n                     let identity_substs = InternalSubsts::identity_for_item(tcx, did);\n                     // The `ParamEnv` needs to match the `identity_substs`.\n                     let identity_param_env = tcx.param_env(did);"}, {"sha": "400121166335f6f8122b3190e1315d691684fccc", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=11f6096a9ef6ad52de2956f4d2df200de7617077", "patch": "@@ -995,15 +995,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 self.definitions[upper_bound].external_name.unwrap_or(r)\n             } else {\n                 // In the case of a failure, use a `ReVar` result. This will\n-                // cause the `has_local_value` later on to return `None`.\n+                // cause the `needs_infer` later on to return `None`.\n                 r\n             }\n         });\n \n         debug!(\"try_promote_type_test_subject: folded ty = {:?}\", ty);\n \n-        // `has_local_value` will only be true if we failed to promote some region.\n-        if ty.has_local_value() {\n+        // `needs_infer` will only be true if we failed to promote some region.\n+        if ty.needs_infer() {\n             return None;\n         }\n "}, {"sha": "66df4fe9511622f57787fa5f71a21ea1fc3f8e8b", "filename": "src/librustc_trait_selection/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_trait_selection%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_trait_selection%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Finfer.rs?ref=11f6096a9ef6ad52de2956f4d2df200de7617077", "patch": "@@ -43,7 +43,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     ) -> bool {\n         let ty = self.resolve_vars_if_possible(&ty);\n \n-        if !(param_env, ty).has_local_value() {\n+        if !(param_env, ty).needs_infer() {\n             return ty.is_copy_modulo_regions(self.tcx, param_env, span);\n         }\n "}, {"sha": "193ca36e0fd0e53c60531b057a02647ea4a84864", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=11f6096a9ef6ad52de2956f4d2df200de7617077", "patch": "@@ -259,8 +259,8 @@ fn do_normalize_predicates<'tcx>(\n                 return Err(ErrorReported);\n             }\n         };\n-        if predicates.has_local_value() {\n-            // FIXME: shouldn't we, you know, actually report an error here? or an ICE?\n+        if predicates.needs_infer() {\n+            tcx.sess.delay_span_bug(span, \"encountered inference variables after `fully_resolve`\");\n             Err(ErrorReported)\n         } else {\n             Ok(predicates)"}, {"sha": "0a85999c60da75fd77c27ff0900bd38fb7626078", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=11f6096a9ef6ad52de2956f4d2df200de7617077", "patch": "@@ -820,7 +820,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         if self.can_use_global_caches(param_env) {\n-            if !trait_ref.has_local_value() {\n+            if !trait_ref.needs_infer() {\n                 debug!(\n                     \"insert_evaluation_cache(trait_ref={:?}, candidate={:?}) global\",\n                     trait_ref, result,\n@@ -1178,10 +1178,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Do note that if the type itself is not in the\n     /// global tcx, the local caches will be used.\n     fn can_use_global_caches(&self, param_env: ty::ParamEnv<'tcx>) -> bool {\n-        // If there are any e.g. inference variables in the `ParamEnv`, then we\n+        // If there are any inference variables in the `ParamEnv`, then we\n         // always use a cache local to this particular scope. Otherwise, we\n         // switch to a global cache.\n-        if param_env.has_local_value() {\n+        if param_env.needs_infer() {\n             return false;\n         }\n \n@@ -1242,7 +1242,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         result: &SelectionResult<'tcx, SelectionCandidate<'tcx>>,\n     ) -> bool {\n         match result {\n-            Ok(Some(SelectionCandidate::ParamCandidate(trait_ref))) => !trait_ref.has_local_value(),\n+            Ok(Some(SelectionCandidate::ParamCandidate(trait_ref))) => !trait_ref.needs_infer(),\n             _ => true,\n         }\n     }\n@@ -1269,8 +1269,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         if self.can_use_global_caches(param_env) {\n             if let Err(Overflow) = candidate {\n                 // Don't cache overflow globally; we only produce this in certain modes.\n-            } else if !trait_ref.has_local_value() {\n-                if !candidate.has_local_value() {\n+            } else if !trait_ref.needs_infer() {\n+                if !candidate.needs_infer() {\n                     debug!(\n                         \"insert_candidate_cache(trait_ref={:?}, candidate={:?}) global\",\n                         trait_ref, candidate,"}, {"sha": "cb794bfd7e1e93fa1f5d7f9723913a846b91b8ca", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=11f6096a9ef6ad52de2956f4d2df200de7617077", "patch": "@@ -369,7 +369,7 @@ fn check_type_defn<'tcx, F>(\n                 packed && {\n                     let ty = variant.fields.last().unwrap().ty;\n                     let ty = fcx.tcx.erase_regions(&ty);\n-                    if ty.has_local_value() {\n+                    if ty.needs_infer() {\n                         fcx_tcx\n                             .sess\n                             .delay_span_bug(item.span, &format!(\"inference variables in {:?}\", ty));"}, {"sha": "28574c68e941a9eaf4c93fc256ea1fea2a288d71", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f6096a9ef6ad52de2956f4d2df200de7617077/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=11f6096a9ef6ad52de2956f4d2df200de7617077", "patch": "@@ -365,8 +365,12 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         for (&local_id, c_ty) in fcx_tables.user_provided_types().iter() {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n \n-            if cfg!(debug_assertions) && c_ty.has_local_value() {\n-                span_bug!(hir_id.to_span(self.fcx.tcx), \"writeback: `{:?}` is a local value\", c_ty);\n+            if cfg!(debug_assertions) && c_ty.needs_infer() {\n+                span_bug!(\n+                    hir_id.to_span(self.fcx.tcx),\n+                    \"writeback: `{:?}` has inference variables\",\n+                    c_ty\n+                );\n             };\n \n             self.tables.user_provided_types_mut().insert(hir_id, c_ty.clone());\n@@ -399,10 +403,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n \n         for (&def_id, c_sig) in fcx_tables.user_provided_sigs.iter() {\n-            if cfg!(debug_assertions) && c_sig.has_local_value() {\n+            if cfg!(debug_assertions) && c_sig.needs_infer() {\n                 span_bug!(\n                     self.fcx.tcx.hir().span_if_local(def_id).unwrap(),\n-                    \"writeback: `{:?}` is a local value\",\n+                    \"writeback: `{:?}` has inference variables\",\n                     c_sig\n                 );\n             };\n@@ -457,7 +461,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 }\n             }\n \n-            if !opaque_defn.substs.has_local_value() {\n+            if !opaque_defn.substs.needs_infer() {\n                 // We only want to add an entry into `concrete_opaque_types`\n                 // if we actually found a defining usage of this opaque type.\n                 // Otherwise, we do nothing - we'll either find a defining usage\n@@ -485,7 +489,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     }\n                 }\n             } else {\n-                self.tcx().sess.delay_span_bug(span, \"`opaque_defn` is a local value\");\n+                self.tcx().sess.delay_span_bug(span, \"`opaque_defn` has inference variables\");\n             }\n         }\n     }\n@@ -579,8 +583,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         let x = x.fold_with(&mut Resolver::new(self.fcx, span, self.body));\n-        if cfg!(debug_assertions) && x.has_local_value() {\n-            span_bug!(span.to_span(self.fcx.tcx), \"writeback: `{:?}` is a local value\", x);\n+        if cfg!(debug_assertions) && x.needs_infer() {\n+            span_bug!(span.to_span(self.fcx.tcx), \"writeback: `{:?}` has inference variables\", x);\n         }\n         x\n     }"}]}