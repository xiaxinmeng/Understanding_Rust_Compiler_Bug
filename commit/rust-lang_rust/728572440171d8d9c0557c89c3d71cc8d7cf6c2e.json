{"sha": "728572440171d8d9c0557c89c3d71cc8d7cf6c2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyODU3MjQ0MDE3MWQ4ZDljMDU1N2M4OWMzZDcxY2M4ZDdjZjZjMmU=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-01-10T23:36:54Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-01-14T00:05:56Z"}, "message": "Make `TokenStream` use `Option`.\n\nBecause that's the more typical way of representing an all-or-nothing\ntype.", "tree": {"sha": "01c48878b169bbc139f3c468d259d0565f80181e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01c48878b169bbc139f3c468d259d0565f80181e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/728572440171d8d9c0557c89c3d71cc8d7cf6c2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/728572440171d8d9c0557c89c3d71cc8d7cf6c2e", "html_url": "https://github.com/rust-lang/rust/commit/728572440171d8d9c0557c89c3d71cc8d7cf6c2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/728572440171d8d9c0557c89c3d71cc8d7cf6c2e/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba31d83adc839768ed8fab7dea79d9f6bd6c58ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba31d83adc839768ed8fab7dea79d9f6bd6c58ac", "html_url": "https://github.com/rust-lang/rust/commit/ba31d83adc839768ed8fab7dea79d9f6bd6c58ac"}], "stats": {"total": 95, "additions": 45, "deletions": 50}, "files": [{"sha": "f5d2d6f18ee87916f4a63d976fc3ebd2e533164c", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/728572440171d8d9c0557c89c3d71cc8d7cf6c2e/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/728572440171d8d9c0557c89c3d71cc8d7cf6c2e/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=728572440171d8d9c0557c89c3d71cc8d7cf6c2e", "patch": "@@ -141,11 +141,13 @@ impl TokenTree {\n /// The goal is for procedural macros to work with `TokenStream`s and `TokenTree`s\n /// instead of a representation of the abstract syntax tree.\n /// Today's `TokenTree`s can still contain AST via `Token::Interpolated` for back-compat.\n+///\n+/// The use of `Option` is an optimization that avoids the need for an\n+/// allocation when the stream is empty. However, it is not guaranteed that an\n+/// empty stream is represented with `None`; it may be represented as a `Some`\n+/// around an empty `Vec`.\n #[derive(Clone, Debug)]\n-pub enum TokenStream {\n-    Empty,\n-    Stream(Lrc<Vec<TreeAndJoint>>),\n-}\n+pub struct TokenStream(Option<Lrc<Vec<TreeAndJoint>>>);\n \n pub type TreeAndJoint = (TokenTree, IsJoint);\n \n@@ -166,7 +168,7 @@ impl TokenStream {\n     /// separating the two arguments with a comma for diagnostic suggestions.\n     pub(crate) fn add_comma(&self) -> Option<(TokenStream, Span)> {\n         // Used to suggest if a user writes `foo!(a b);`\n-        if let TokenStream::Stream(ref stream) = self {\n+        if let Some(ref stream) = self.0 {\n             let mut suggestion = None;\n             let mut iter = stream.iter().enumerate().peekable();\n             while let Some((pos, ts)) = iter.next() {\n@@ -230,21 +232,21 @@ impl PartialEq<TokenStream> for TokenStream {\n \n impl TokenStream {\n     pub fn len(&self) -> usize {\n-        if let TokenStream::Stream(ref slice) = self {\n+        if let Some(ref slice) = self.0 {\n             slice.len()\n         } else {\n             0\n         }\n     }\n \n     pub fn empty() -> TokenStream {\n-        TokenStream::Empty\n+        TokenStream(None)\n     }\n \n     pub fn is_empty(&self) -> bool {\n-        match self {\n-            TokenStream::Empty => true,\n-            _ => false,\n+        match self.0 {\n+            None => true,\n+            Some(ref stream) => stream.is_empty(),\n         }\n     }\n \n@@ -255,9 +257,9 @@ impl TokenStream {\n             _ => {\n                 let mut vec = vec![];\n                 for stream in streams {\n-                    match stream {\n-                        TokenStream::Empty => {},\n-                        TokenStream::Stream(stream2) => vec.extend(stream2.iter().cloned()),\n+                    match stream.0 {\n+                        None => {},\n+                        Some(stream2) => vec.extend(stream2.iter().cloned()),\n                     }\n                 }\n                 TokenStream::new(vec)\n@@ -267,15 +269,14 @@ impl TokenStream {\n \n     pub fn new(streams: Vec<TreeAndJoint>) -> TokenStream {\n         match streams.len() {\n-            0 => TokenStream::empty(),\n-            _ => TokenStream::Stream(Lrc::new(streams)),\n+            0 => TokenStream(None),\n+            _ => TokenStream(Some(Lrc::new(streams))),\n         }\n     }\n \n     pub fn append_to_tree_and_joint_vec(self, vec: &mut Vec<TreeAndJoint>) {\n-        match self {\n-            TokenStream::Empty => {}\n-            TokenStream::Stream(stream) => vec.extend(stream.iter().cloned()),\n+        if let Some(stream) = self.0 {\n+            vec.extend(stream.iter().cloned());\n         }\n     }\n \n@@ -340,41 +341,36 @@ impl TokenStream {\n     }\n \n     pub fn map_enumerated<F: FnMut(usize, TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n-        match self {\n-            TokenStream::Empty => TokenStream::Empty,\n-            TokenStream::Stream(stream) => TokenStream::Stream(Lrc::new(\n+        TokenStream(self.0.map(|stream| {\n+            Lrc::new(\n                 stream\n                     .iter()\n                     .enumerate()\n                     .map(|(i, (tree, is_joint))| (f(i, tree.clone()), *is_joint))\n-                    .collect()\n-            )),\n-        }\n+                    .collect())\n+        }))\n     }\n \n     pub fn map<F: FnMut(TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n-        match self {\n-            TokenStream::Empty => TokenStream::Empty,\n-            TokenStream::Stream(stream) => TokenStream::Stream(Lrc::new(\n+        TokenStream(self.0.map(|stream| {\n+            Lrc::new(\n                 stream\n                     .iter()\n                     .map(|(tree, is_joint)| (f(tree.clone()), *is_joint))\n-                    .collect()\n-            )),\n-        }\n+                    .collect())\n+        }))\n     }\n \n-    fn first_tree_and_joint(&self) -> Option<(TokenTree, IsJoint)> {\n-        match self {\n-            TokenStream::Empty => None,\n-            TokenStream::Stream(ref stream) => Some(stream.first().unwrap().clone())\n-        }\n+    fn first_tree_and_joint(&self) -> Option<TreeAndJoint> {\n+        self.0.as_ref().map(|stream| {\n+            stream.first().unwrap().clone()\n+        })\n     }\n \n     fn last_tree_if_joint(&self) -> Option<TokenTree> {\n-        match self {\n-            TokenStream::Empty => None,\n-            TokenStream::Stream(ref stream) => {\n+        match self.0 {\n+            None => None,\n+            Some(ref stream) => {\n                 if let (tree, Joint) = stream.last().unwrap() {\n                     Some(tree.clone())\n                 } else {\n@@ -418,21 +414,21 @@ impl TokenStreamBuilder {\n     }\n \n     fn push_all_but_last_tree(&mut self, stream: &TokenStream) {\n-        if let TokenStream::Stream(ref streams) = stream {\n+        if let Some(ref streams) = stream.0 {\n             let len = streams.len();\n             match len {\n                 1 => {}\n-                _ => self.0.push(TokenStream::Stream(Lrc::new(streams[0 .. len - 1].to_vec()))),\n+                _ => self.0.push(TokenStream(Some(Lrc::new(streams[0 .. len - 1].to_vec())))),\n             }\n         }\n     }\n \n     fn push_all_but_first_tree(&mut self, stream: &TokenStream) {\n-        if let TokenStream::Stream(ref streams) = stream {\n+        if let Some(ref streams) = stream.0 {\n             let len = streams.len();\n             match len {\n                 1 => {}\n-                _ => self.0.push(TokenStream::Stream(Lrc::new(streams[1 .. len].to_vec()))),\n+                _ => self.0.push(TokenStream(Some(Lrc::new(streams[1 .. len].to_vec())))),\n             }\n         }\n     }\n@@ -458,9 +454,9 @@ impl Cursor {\n     }\n \n     pub fn next_with_joint(&mut self) -> Option<TreeAndJoint> {\n-        match self.stream {\n-            TokenStream::Empty => None,\n-            TokenStream::Stream(ref stream) => {\n+        match self.stream.0 {\n+            None => None,\n+            Some(ref stream) => {\n                 if self.index < stream.len() {\n                     self.index += 1;\n                     Some(stream[self.index - 1].clone())\n@@ -476,16 +472,15 @@ impl Cursor {\n             return;\n         }\n         let index = self.index;\n-        let stream = mem::replace(&mut self.stream, TokenStream::Empty);\n+        let stream = mem::replace(&mut self.stream, TokenStream(None));\n         *self = TokenStream::from_streams(vec![stream, new_stream]).into_trees();\n         self.index = index;\n     }\n \n     pub fn look_ahead(&self, n: usize) -> Option<TokenTree> {\n-        match self.stream {\n-            TokenStream::Empty => None,\n-            TokenStream::Stream(ref stream) =>\n-                stream[self.index ..].get(n).map(|(tree, _)| tree.clone()),\n+        match self.stream.0 {\n+            None => None,\n+            Some(ref stream) => stream[self.index ..].get(n).map(|(tree, _)| tree.clone()),\n         }\n     }\n }"}]}