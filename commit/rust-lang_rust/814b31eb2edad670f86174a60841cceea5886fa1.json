{"sha": "814b31eb2edad670f86174a60841cceea5886fa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNGIzMWViMmVkYWQ2NzBmODYxNzRhNjA4NDFjY2VlYTU4ODZmYTE=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-08-02T16:05:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-02T16:05:13Z"}, "message": "Rollup merge of #74762 - ssomers:btree_no_root_in_remove_kv_tracking, r=Mark-Simulacrum\n\nBTreeMap::drain_filter should not touch the root during iteration\n\nAlthough Miri doesn't point it out, I believe there is undefined behaviour using `drain_filter` when draining the 11th-last element from a tree that was larger. When this happens, the last remaining child nodes are merged, the root becomes empty and is popped from the tree. That last step establishes a mutable reference to the node elected root and writes a pointer in `node::Root`, while iteration continues to visit the same node.\n\nThis is mostly code from #74437, slightly adapted.", "tree": {"sha": "d9f219b006cce573dd400d2de3128977144a0fdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9f219b006cce573dd400d2de3128977144a0fdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/814b31eb2edad670f86174a60841cceea5886fa1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfJuQ6CRBK7hj4Ov3rIwAAdHIIAGocxni4ic5DryJViZq3BzYa\nFcc5QvyXCBpa2U0+sOCGU6deBFlU0gaErHXTg7H25Rmh1A9BAFDzehkcEa70/dl4\nQxt5VL7pFPewFy3gS5Kl0atriCEuYGbGaxT33R1wDhjNXv4g9xVJ+HVuZu0JKBm9\njySUXNlFwI4WCTtX2D/wr+flg+TYbg1xpnj0RRuvwAV2PKoWM31WMd+4q/ODqZky\nLB3uQq4JFR+vntG6ADVKV0jzJ9lioJWtfuSfJc4xUAF0VWauJ3Cdp+VUVoiI04wo\nU/riI4ZeE34gou7ZDBa5rJdfSiX31XFnnwtXM3O0WrCBfAoqI9deChUACu0Zn+M=\n=iEcN\n-----END PGP SIGNATURE-----\n", "payload": "tree d9f219b006cce573dd400d2de3128977144a0fdf\nparent 8c331ee4709c73b23f0f4c7525661ea7d47c8467\nparent 99398dd2fd46c24857707ee5db8c7a90f0811850\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1596384313 +0900\ncommitter GitHub <noreply@github.com> 1596384313 +0900\n\nRollup merge of #74762 - ssomers:btree_no_root_in_remove_kv_tracking, r=Mark-Simulacrum\n\nBTreeMap::drain_filter should not touch the root during iteration\n\nAlthough Miri doesn't point it out, I believe there is undefined behaviour using `drain_filter` when draining the 11th-last element from a tree that was larger. When this happens, the last remaining child nodes are merged, the root becomes empty and is popped from the tree. That last step establishes a mutable reference to the node elected root and writes a pointer in `node::Root`, while iteration continues to visit the same node.\n\nThis is mostly code from #74437, slightly adapted.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/814b31eb2edad670f86174a60841cceea5886fa1", "html_url": "https://github.com/rust-lang/rust/commit/814b31eb2edad670f86174a60841cceea5886fa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/814b31eb2edad670f86174a60841cceea5886fa1/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c331ee4709c73b23f0f4c7525661ea7d47c8467", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c331ee4709c73b23f0f4c7525661ea7d47c8467", "html_url": "https://github.com/rust-lang/rust/commit/8c331ee4709c73b23f0f4c7525661ea7d47c8467"}, {"sha": "99398dd2fd46c24857707ee5db8c7a90f0811850", "url": "https://api.github.com/repos/rust-lang/rust/commits/99398dd2fd46c24857707ee5db8c7a90f0811850", "html_url": "https://github.com/rust-lang/rust/commit/99398dd2fd46c24857707ee5db8c7a90f0811850"}], "stats": {"total": 457, "additions": 405, "deletions": 52}, "files": [{"sha": "7c2e5694a62fc4249859748c47d16499752ad066", "filename": "library/alloc/benches/btree/map.rs", "status": "modified", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/814b31eb2edad670f86174a60841cceea5886fa1/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814b31eb2edad670f86174a60841cceea5886fa1/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs?ref=814b31eb2edad670f86174a60841cceea5886fa1", "patch": "@@ -282,3 +282,305 @@ pub fn iter_10k(b: &mut Bencher) {\n pub fn iter_1m(b: &mut Bencher) {\n     bench_iter(b, 1_000, 1_000_000);\n }\n+\n+const FAT: usize = 256;\n+\n+// The returned map has small keys and values.\n+// Benchmarks on it have a counterpart in set.rs with the same keys and no values at all.\n+fn slim_map(n: usize) -> BTreeMap<usize, usize> {\n+    (0..n).map(|i| (i, i)).collect::<BTreeMap<_, _>>()\n+}\n+\n+// The returned map has small keys and large values.\n+fn fat_val_map(n: usize) -> BTreeMap<usize, [usize; FAT]> {\n+    (0..n).map(|i| (i, [i; FAT])).collect::<BTreeMap<_, _>>()\n+}\n+\n+// The returned map has large keys and values.\n+fn fat_map(n: usize) -> BTreeMap<[usize; FAT], [usize; FAT]> {\n+    (0..n).map(|i| ([i; FAT], [i; FAT])).collect::<BTreeMap<_, _>>()\n+}\n+\n+#[bench]\n+pub fn clone_slim_100(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_clear(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_drain_all(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_drain_half(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i % 2 == 0).count(), 100 / 2);\n+        assert_eq!(map.len(), 100 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_into_iter(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_pop_all(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_remove_all(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_remove_half(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..100).step_by(2) {\n+            let v = map.remove(&i);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 100 / 2);\n+        map\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_clear(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_drain_all(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_drain_half(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i % 2 == 0).count(), 10_000 / 2);\n+        assert_eq!(map.len(), 10_000 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_into_iter(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_pop_all(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_remove_all(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_remove_half(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..10_000).step_by(2) {\n+            let v = map.remove(&i);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 10_000 / 2);\n+        map\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_clear(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_drain_all(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_drain_half(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i % 2 == 0).count(), 100 / 2);\n+        assert_eq!(map.len(), 100 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_into_iter(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_pop_all(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_remove_all(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_remove_half(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..100).step_by(2) {\n+            let v = map.remove(&i);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 100 / 2);\n+        map\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_100(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_clear(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_drain_all(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_drain_half(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i[0] % 2 == 0).count(), 100 / 2);\n+        assert_eq!(map.len(), 100 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_into_iter(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_pop_all(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_remove_all(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_remove_half(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..100).step_by(2) {\n+            let v = map.remove(&[i; FAT]);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 100 / 2);\n+        map\n+    })\n+}"}, {"sha": "07bf5093727c04b4589f7260416a1e275f0ce717", "filename": "library/alloc/benches/btree/set.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/814b31eb2edad670f86174a60841cceea5886fa1/library%2Falloc%2Fbenches%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814b31eb2edad670f86174a60841cceea5886fa1/library%2Falloc%2Fbenches%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fbtree%2Fset.rs?ref=814b31eb2edad670f86174a60841cceea5886fa1", "patch": "@@ -50,27 +50,31 @@ macro_rules! set_bench {\n     };\n }\n \n+fn slim_set(n: usize) -> BTreeSet<usize> {\n+    (0..n).collect::<BTreeSet<_>>()\n+}\n+\n #[bench]\n pub fn clone_100(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone())\n }\n \n #[bench]\n pub fn clone_100_and_clear(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone().clear())\n }\n \n #[bench]\n pub fn clone_100_and_drain_all(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone().drain_filter(|_| true).count())\n }\n \n #[bench]\n pub fn clone_100_and_drain_half(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n         assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 100 / 2);\n@@ -80,13 +84,13 @@ pub fn clone_100_and_drain_half(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_100_and_into_iter(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone().into_iter().count())\n }\n \n #[bench]\n pub fn clone_100_and_pop_all(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n         while set.pop_first().is_some() {}\n@@ -96,23 +100,25 @@ pub fn clone_100_and_pop_all(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_100_and_remove_all(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n         while let Some(elt) = set.iter().copied().next() {\n-            set.remove(&elt);\n+            let ok = set.remove(&elt);\n+            debug_assert!(ok);\n         }\n         set\n     });\n }\n \n #[bench]\n pub fn clone_100_and_remove_half(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n-        for i in (2..=100 as i32).step_by(2) {\n-            set.remove(&i);\n+        for i in (0..100).step_by(2) {\n+            let ok = set.remove(&i);\n+            debug_assert!(ok);\n         }\n         assert_eq!(set.len(), 100 / 2);\n         set\n@@ -121,25 +127,25 @@ pub fn clone_100_and_remove_half(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_10k(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone())\n }\n \n #[bench]\n pub fn clone_10k_and_clear(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone().clear())\n }\n \n #[bench]\n pub fn clone_10k_and_drain_all(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone().drain_filter(|_| true).count())\n }\n \n #[bench]\n pub fn clone_10k_and_drain_half(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n         assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 10_000 / 2);\n@@ -149,13 +155,13 @@ pub fn clone_10k_and_drain_half(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_10k_and_into_iter(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone().into_iter().count())\n }\n \n #[bench]\n pub fn clone_10k_and_pop_all(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n         while set.pop_first().is_some() {}\n@@ -165,23 +171,25 @@ pub fn clone_10k_and_pop_all(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_10k_and_remove_all(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n         while let Some(elt) = set.iter().copied().next() {\n-            set.remove(&elt);\n+            let ok = set.remove(&elt);\n+            debug_assert!(ok);\n         }\n         set\n     });\n }\n \n #[bench]\n pub fn clone_10k_and_remove_half(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n-        for i in (2..=10_000 as i32).step_by(2) {\n-            set.remove(&i);\n+        for i in (0..10_000).step_by(2) {\n+            let ok = set.remove(&i);\n+            debug_assert!(ok);\n         }\n         assert_eq!(set.len(), 10_000 / 2);\n         set"}, {"sha": "6184051316ef801584398bd5083d8d2b02229967", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 64, "deletions": 23, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/814b31eb2edad670f86174a60841cceea5886fa1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814b31eb2edad670f86174a60841cceea5886fa1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=814b31eb2edad670f86174a60841cceea5886fa1", "patch": "@@ -174,7 +174,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n \n                     {\n                         let out_root = BTreeMap::ensure_is_owned(&mut out_tree.root);\n-                        let mut out_node = out_root.push_level();\n+                        let mut out_node = out_root.push_internal_level();\n                         let mut in_edge = internal.first_edge();\n                         while let Ok(kv) = in_edge.right_kv() {\n                             let (k, v) = kv.into_kv();\n@@ -1080,9 +1080,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                                 test_node = parent.forget_type();\n                             }\n                         }\n-                        Err(node) => {\n+                        Err(_) => {\n                             // We are at the top, create a new root node and push there.\n-                            open_node = node.into_root_mut().push_level();\n+                            open_node = root.push_internal_level();\n                             break;\n                         }\n                     }\n@@ -1092,7 +1092,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                 let tree_height = open_node.height() - 1;\n                 let mut right_tree = node::Root::new_leaf();\n                 for _ in 0..tree_height {\n-                    right_tree.push_level();\n+                    right_tree.push_internal_level();\n                 }\n                 open_node.push(key, value, right_tree);\n \n@@ -1171,7 +1171,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let mut right = Self::new();\n         let right_root = Self::ensure_is_owned(&mut right.root);\n         for _ in 0..left_root.height() {\n-            right_root.push_level();\n+            right_root.push_internal_level();\n         }\n \n         {\n@@ -1255,7 +1255,11 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n     pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n         let front = self.root.as_mut().map(|r| r.as_mut().first_leaf_edge());\n-        DrainFilterInner { length: &mut self.length, cur_leaf_edge: front }\n+        DrainFilterInner {\n+            length: &mut self.length,\n+            cur_leaf_edge: front,\n+            emptied_internal_root: false,\n+        }\n     }\n \n     /// Calculates the number of elements if it is incorrect.\n@@ -1625,6 +1629,7 @@ where\n pub(super) struct DrainFilterInner<'a, K: 'a, V: 'a> {\n     length: &'a mut usize,\n     cur_leaf_edge: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+    emptied_internal_root: bool,\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n@@ -1665,6 +1670,17 @@ where\n     }\n }\n \n+impl<K, V> Drop for DrainFilterInner<'_, K, V> {\n+    fn drop(&mut self) {\n+        if self.emptied_internal_root {\n+            if let Some(handle) = self.cur_leaf_edge.take() {\n+                let root = handle.into_node().into_root_mut();\n+                root.pop_internal_level();\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n     /// Allow Debug implementations to predict the next element.\n     pub(super) fn peek(&self) -> Option<(&K, &V)> {\n@@ -1681,9 +1697,10 @@ impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n             let (k, v) = kv.kv_mut();\n             if pred(k, v) {\n                 *self.length -= 1;\n-                let (k, v, leaf_edge_location) = kv.remove_kv_tracking();\n-                self.cur_leaf_edge = Some(leaf_edge_location);\n-                return Some((k, v));\n+                let RemoveResult { old_kv, pos, emptied_internal_root } = kv.remove_kv_tracking();\n+                self.cur_leaf_edge = Some(pos);\n+                self.emptied_internal_root |= emptied_internal_root;\n+                return Some(old_kv);\n             }\n             self.cur_leaf_edge = Some(kv.next_leaf_edge());\n         }\n@@ -2477,7 +2494,7 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n                     }\n                 },\n                 Err(root) => {\n-                    root.push_level().push(ins_k, ins_v, ins_edge);\n+                    root.push_internal_level().push(ins_k, ins_v, ins_edge);\n                     return unsafe { &mut *out_ptr };\n                 }\n             }\n@@ -2647,20 +2664,35 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n         self.remove_kv().1\n     }\n \n+    // Body of `remove_entry`, separate to keep the above implementations short.\n     fn remove_kv(self) -> (K, V) {\n         *self.length -= 1;\n \n-        let (old_key, old_val, _) = self.handle.remove_kv_tracking();\n-        (old_key, old_val)\n+        let RemoveResult { old_kv, pos, emptied_internal_root } = self.handle.remove_kv_tracking();\n+        let root = pos.into_node().into_root_mut();\n+        if emptied_internal_root {\n+            root.pop_internal_level();\n+        }\n+        old_kv\n     }\n }\n \n+struct RemoveResult<'a, K, V> {\n+    // Key and value removed.\n+    old_kv: (K, V),\n+    // Unique location at the leaf level that the removed KV lopgically collapsed into.\n+    pos: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    // Whether the remove left behind and empty internal root node, that should be removed\n+    // using `pop_internal_level`.\n+    emptied_internal_root: bool,\n+}\n+\n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n-    /// Removes a key/value-pair from the map, and returns that pair, as well as\n-    /// the leaf edge corresponding to that former pair.\n-    fn remove_kv_tracking(\n-        self,\n-    ) -> (K, V, Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n+    /// Removes a key/value-pair from the tree, and returns that pair, as well as\n+    /// the leaf edge corresponding to that former pair. It's possible this leaves\n+    /// an empty internal root node, which the caller should subsequently pop from\n+    /// the map holding the tree. The caller should also decrement the map's length.\n+    fn remove_kv_tracking(self) -> RemoveResult<'a, K, V> {\n         let (mut pos, old_key, old_val, was_internal) = match self.force() {\n             Leaf(leaf) => {\n                 let (hole, old_key, old_val) = leaf.remove();\n@@ -2689,6 +2721,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n         };\n \n         // Handle underflow\n+        let mut emptied_internal_root = false;\n         let mut cur_node = unsafe { ptr::read(&pos).into_node().forget_type() };\n         let mut at_leaf = true;\n         while cur_node.len() < node::MIN_LEN {\n@@ -2709,8 +2742,8 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n \n                     let parent = edge.into_node();\n                     if parent.len() == 0 {\n-                        // We must be at the root\n-                        parent.into_root_mut().pop_level();\n+                        // This empty parent must be the root, and should be popped off the tree.\n+                        emptied_internal_root = true;\n                         break;\n                     } else {\n                         cur_node = parent.forget_type();\n@@ -2737,15 +2770,15 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n             pos = unsafe { unwrap_unchecked(pos.next_kv().ok()).next_leaf_edge() };\n         }\n \n-        (old_key, old_val, pos)\n+        RemoveResult { old_kv: (old_key, old_val), pos, emptied_internal_root }\n     }\n }\n \n impl<K, V> node::Root<K, V> {\n     /// Removes empty levels on the top, but keep an empty leaf if the entire tree is empty.\n     fn fix_top(&mut self) {\n         while self.height() > 0 && self.as_ref().len() == 0 {\n-            self.pop_level();\n+            self.pop_internal_level();\n         }\n     }\n \n@@ -2817,8 +2850,16 @@ fn handle_underfull_node<K, V>(\n     let (is_left, mut handle) = match parent.left_kv() {\n         Ok(left) => (true, left),\n         Err(parent) => {\n-            let right = unsafe { unwrap_unchecked(parent.right_kv().ok()) };\n-            (false, right)\n+            match parent.right_kv() {\n+                Ok(right) => (false, right),\n+                Err(_) => {\n+                    // The underfull node has an empty parent, so it is the only child\n+                    // of an empty root. It is destined to become the new root, thus\n+                    // allowed to be underfull. The empty parent should be removed later\n+                    // by `pop_internal_level`.\n+                    return AtRoot;\n+                }\n+            }\n         }\n     };\n "}, {"sha": "85e864db056de1301495e04fc1387c3924d578e9", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/814b31eb2edad670f86174a60841cceea5886fa1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814b31eb2edad670f86174a60841cceea5886fa1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=814b31eb2edad670f86174a60841cceea5886fa1", "patch": "@@ -191,8 +191,9 @@ impl<K, V> Root<K, V> {\n     }\n \n     /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n-    /// new node the root. This increases the height by 1 and is the opposite of `pop_level`.\n-    pub fn push_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n+    /// new node the root. This increases the height by 1 and is the opposite of\n+    /// `pop_internal_level`.\n+    pub fn push_internal_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n         new_node.edges[0].write(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n \n@@ -213,11 +214,12 @@ impl<K, V> Root<K, V> {\n         ret\n     }\n \n-    /// Removes the root node, using its first child as the new root. This cannot be called when\n-    /// the tree consists only of a leaf node. As it is intended only to be called when the root\n-    /// has only one edge, no cleanup is done on any of the other children of the root.\n-    /// This decreases the height by 1 and is the opposite of `push_level`.\n-    pub fn pop_level(&mut self) {\n+    /// Removes the internal root node, using its first child as the new root.\n+    /// As it is intended only to be called when the root has only one child,\n+    /// no cleanup is done on any of the other children of the root.\n+    /// This decreases the height by 1 and is the opposite of `push_internal_level`.\n+    /// Panics if there is no internal level, i.e. if the root is a leaf.\n+    pub fn pop_internal_level(&mut self) {\n         assert!(self.height > 0);\n \n         let top = self.node.ptr;"}]}