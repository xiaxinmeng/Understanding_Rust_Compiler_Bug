{"sha": "fb5ae9906ba7961c8b3c39512181c966b82d180c", "node_id": "C_kwDOAAsO6NoAKGZiNWFlOTkwNmJhNzk2MWM4YjNjMzk1MTIxODFjOTY2YjgyZDE4MGM", "commit": {"author": {"name": "Kartavya Vashishtha", "email": "sendtokartavya@gmail.com", "date": "2022-09-11T05:09:25Z"}, "committer": {"name": "Kartavya Vashishtha", "email": "sendtokartavya@gmail.com", "date": "2022-09-11T05:09:25Z"}, "message": "suggest ExtractRefactor if no expressions found\n\nAdded `Ident` variant to arg enum.", "tree": {"sha": "2ce46f1897cd8264c839a1925cc7b5d53c5909f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ce46f1897cd8264c839a1925cc7b5d53c5909f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb5ae9906ba7961c8b3c39512181c966b82d180c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE+fRQYdEX7Emd36W/pQASwjJOXfAFAmMdbYUACgkQpQASwjJO\nXfDiCg/9E7lAHuRCPOgU0cf1w79BQ+NuEYxQOYgNNHr/c2cv0d4uxASjRoNlAZ96\nmtW6FeR69DWZpm6kk6rOn/P9Rd/eg5Xtd2KBfpnrtL+fK8fVyIUN5r62DTrfGeNf\nBImA58gtRknAVGI2KSENQBdDg7BvLP0HVb6jzePipGeEBPiCZbiXub9+Ps6g0qJ6\n093g3C034ph6Rv1tphfj8cNttnvo8DVeD2IsCzvL299hHHx60TR3vdmyv7MJv9Z+\naU1MvQu9wTkzfOlNtRji31mPvGlvywBf6yUJnYu5RMZyR48sX9chtpRJvH6xcwCH\nuMHqyC8GDAKDPeRCxAfp7QhubXuHVWtGvvL2EkEg4oEaB4EL1xIMXE9HmgmHHZWL\n80GGeeVko3ZlEfDdTcxT9P4ogxYAC0Wnv9Qf3boxXA9lthRjRj4RRuLbwdUc8yhx\nPdcFb6dZGMxNKvvgdDrRhs0DLQUlmwyI+V2w1OsjXKruQXRwb9vjKqTBYhgMV09X\nj8pcSrTS5LfzXlXp6FZ+v9C7lNXEpp030BENwe5IT9dlOgflVLmeNpoOIO/WKBPg\nWhNMnLGeGxcNcjo6KztBlt4+VegR/+6azueDxENjZzAjo7zUREKqrNU6LlZwjuUX\nXx6Rsnf1IMK/KX0PK69Oz6+q5b++16TO8hpLP+Itn9jBnP7LKqM=\n=uQxi\n-----END PGP SIGNATURE-----", "payload": "tree 2ce46f1897cd8264c839a1925cc7b5d53c5909f3\nparent a5cbee4d11ff0c4fca00493d4015d9b8e7f82d6d\nauthor Kartavya Vashishtha <sendtokartavya@gmail.com> 1662872965 +0530\ncommitter Kartavya Vashishtha <sendtokartavya@gmail.com> 1662872965 +0530\n\nsuggest ExtractRefactor if no expressions found\n\nAdded `Ident` variant to arg enum.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb5ae9906ba7961c8b3c39512181c966b82d180c", "html_url": "https://github.com/rust-lang/rust/commit/fb5ae9906ba7961c8b3c39512181c966b82d180c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb5ae9906ba7961c8b3c39512181c966b82d180c/comments", "author": {"login": "DesmondWillowbrook", "id": 51814158, "node_id": "MDQ6VXNlcjUxODE0MTU4", "avatar_url": "https://avatars.githubusercontent.com/u/51814158?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DesmondWillowbrook", "html_url": "https://github.com/DesmondWillowbrook", "followers_url": "https://api.github.com/users/DesmondWillowbrook/followers", "following_url": "https://api.github.com/users/DesmondWillowbrook/following{/other_user}", "gists_url": "https://api.github.com/users/DesmondWillowbrook/gists{/gist_id}", "starred_url": "https://api.github.com/users/DesmondWillowbrook/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DesmondWillowbrook/subscriptions", "organizations_url": "https://api.github.com/users/DesmondWillowbrook/orgs", "repos_url": "https://api.github.com/users/DesmondWillowbrook/repos", "events_url": "https://api.github.com/users/DesmondWillowbrook/events{/privacy}", "received_events_url": "https://api.github.com/users/DesmondWillowbrook/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DesmondWillowbrook", "id": 51814158, "node_id": "MDQ6VXNlcjUxODE0MTU4", "avatar_url": "https://avatars.githubusercontent.com/u/51814158?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DesmondWillowbrook", "html_url": "https://github.com/DesmondWillowbrook", "followers_url": "https://api.github.com/users/DesmondWillowbrook/followers", "following_url": "https://api.github.com/users/DesmondWillowbrook/following{/other_user}", "gists_url": "https://api.github.com/users/DesmondWillowbrook/gists{/gist_id}", "starred_url": "https://api.github.com/users/DesmondWillowbrook/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DesmondWillowbrook/subscriptions", "organizations_url": "https://api.github.com/users/DesmondWillowbrook/orgs", "repos_url": "https://api.github.com/users/DesmondWillowbrook/repos", "events_url": "https://api.github.com/users/DesmondWillowbrook/events{/privacy}", "received_events_url": "https://api.github.com/users/DesmondWillowbrook/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5cbee4d11ff0c4fca00493d4015d9b8e7f82d6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5cbee4d11ff0c4fca00493d4015d9b8e7f82d6d", "html_url": "https://github.com/rust-lang/rust/commit/a5cbee4d11ff0c4fca00493d4015d9b8e7f82d6d"}], "stats": {"total": 118, "additions": 86, "deletions": 32}, "files": [{"sha": "cb7c30b37d6b9fcd0e6d687ddcdfe6dfaf090cef", "filename": "crates/ide-assists/src/handlers/move_format_string_arg.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb5ae9906ba7961c8b3c39512181c966b82d180c/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5ae9906ba7961c8b3c39512181c966b82d180c/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs?ref=fb5ae9906ba7961c8b3c39512181c966b82d180c", "patch": "@@ -56,7 +56,15 @@ pub(crate) fn move_format_string_arg(acc: &mut Assists, ctx: &AssistContext<'_>)\n     }\n \n     acc.add(\n-        AssistId(\"move_format_string_arg\", AssistKind::QuickFix),\n+        AssistId(\n+            \"move_format_string_arg\",\n+            // if there aren't any expressions, then make the assist a RefactorExtract\n+            if extracted_args.iter().filter(|f| matches!(f, Arg::Expr(_))).count() == 0 {\n+                AssistKind::RefactorExtract\n+            } else {\n+                AssistKind::QuickFix\n+            },\n+        ),\n         \"Extract format args\",\n         tt.syntax().text_range(),\n         |edit| {\n@@ -107,7 +115,7 @@ pub(crate) fn move_format_string_arg(acc: &mut Assists, ctx: &AssistContext<'_>)\n                 args.push_str(\", \");\n \n                 match extracted_args {\n-                    Arg::Expr(s) => {\n+                    Arg::Ident(s) | Arg::Expr(s) => {\n                         // insert arg\n                         args.push_str(&s);\n                     }"}, {"sha": "ac6c6e8feeea01e1b2ef90cc2c664fd0b1bb76fe", "filename": "crates/ide-db/src/syntax_helpers/format_string_exprs.rs", "status": "modified", "additions": 76, "deletions": 30, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/fb5ae9906ba7961c8b3c39512181c966b82d180c/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5ae9906ba7961c8b3c39512181c966b82d180c/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs?ref=fb5ae9906ba7961c8b3c39512181c966b82d180c", "patch": "@@ -4,24 +4,27 @@\n /// Enum for represenging extraced format string args.\n /// Can either be extracted expressions (which includes identifiers),\n /// or placeholders `{}`.\n-#[derive(Debug)]\n+#[derive(Debug, PartialEq, Eq)]\n pub enum Arg {\n     Placeholder,\n+    Ident(String),\n     Expr(String),\n }\n \n /**\n- Add placeholders like `$1` and `$2` in place of [`Arg::Placeholder`].\n+ Add placeholders like `$1` and `$2` in place of [`Arg::Placeholder`],\n+ and unwraps the [`Arg::Ident`] and [`Arg::Expr`] enums.\n  ```rust\n- assert_eq!(vec![Arg::Expr(\"expr\"), Arg::Placeholder, Arg::Expr(\"expr\")], vec![\"expr\", \"$1\", \"expr\"])\n+ # use ide_db::syntax_helpers::format_string_exprs::*;\n+ assert_eq!(with_placeholders(vec![Arg::Ident(\"ident\".to_owned()), Arg::Placeholder, Arg::Expr(\"expr + 2\".to_owned())]), vec![\"ident\".to_owned(), \"$1\".to_owned(), \"expr + 2\".to_owned()])\n  ```\n */\n \n pub fn with_placeholders(args: Vec<Arg>) -> Vec<String> {\n     let mut placeholder_id = 1;\n     args.into_iter()\n         .map(move |a| match a {\n-            Arg::Expr(s) => s,\n+            Arg::Expr(s) | Arg::Ident(s) => s,\n             Arg::Placeholder => {\n                 let s = format!(\"${placeholder_id}\");\n                 placeholder_id += 1;\n@@ -40,21 +43,22 @@ pub fn with_placeholders(args: Vec<Arg>) -> Vec<String> {\n  Splits a format string that may contain expressions\n  like\n  ```rust\n- assert_eq!(parse(\"{expr} {} {expr} \").unwrap(), (\"{} {} {}\", vec![Arg::Expr(\"expr\"), Arg::Placeholder, Arg::Expr(\"expr\")]));\n+ assert_eq!(parse(\"{ident} {} {expr + 42} \").unwrap(), (\"{} {} {}\", vec![Arg::Ident(\"ident\"), Arg::Placeholder, Arg::Expr(\"expr + 42\")]));\n  ```\n */\n pub fn parse_format_exprs(input: &str) -> Result<(String, Vec<Arg>), ()> {\n     #[derive(Debug, Clone, Copy, PartialEq)]\n     enum State {\n-        NotExpr,\n-        MaybeExpr,\n+        NotArg,\n+        MaybeArg,\n         Expr,\n+        Ident,\n         MaybeIncorrect,\n         FormatOpts,\n     }\n \n+    let mut state = State::NotArg;\n     let mut current_expr = String::new();\n-    let mut state = State::NotExpr;\n     let mut extracted_expressions = Vec::new();\n     let mut output = String::new();\n \n@@ -66,15 +70,15 @@ pub fn parse_format_exprs(input: &str) -> Result<(String, Vec<Arg>), ()> {\n     let mut chars = input.chars().peekable();\n     while let Some(chr) = chars.next() {\n         match (state, chr) {\n-            (State::NotExpr, '{') => {\n+            (State::NotArg, '{') => {\n                 output.push(chr);\n-                state = State::MaybeExpr;\n+                state = State::MaybeArg;\n             }\n-            (State::NotExpr, '}') => {\n+            (State::NotArg, '}') => {\n                 output.push(chr);\n                 state = State::MaybeIncorrect;\n             }\n-            (State::NotExpr, _) => {\n+            (State::NotArg, _) => {\n                 if matches!(chr, '\\\\' | '$') {\n                     output.push('\\\\');\n                 }\n@@ -83,71 +87,97 @@ pub fn parse_format_exprs(input: &str) -> Result<(String, Vec<Arg>), ()> {\n             (State::MaybeIncorrect, '}') => {\n                 // It's okay, we met \"}}\".\n                 output.push(chr);\n-                state = State::NotExpr;\n+                state = State::NotArg;\n             }\n             (State::MaybeIncorrect, _) => {\n                 // Error in the string.\n                 return Err(());\n             }\n-            (State::MaybeExpr, '{') => {\n+            // Escaped braces `{{`\n+            (State::MaybeArg, '{') => {\n                 output.push(chr);\n-                state = State::NotExpr;\n+                state = State::NotArg;\n             }\n-            (State::MaybeExpr, '}') => {\n-                // This is an empty sequence '{}'. Replace it with placeholder.\n+            (State::MaybeArg, '}') => {\n+                // This is an empty sequence '{}'.\n                 output.push(chr);\n                 extracted_expressions.push(Arg::Placeholder);\n-                state = State::NotExpr;\n+                state = State::NotArg;\n             }\n-            (State::MaybeExpr, _) => {\n+            (State::MaybeArg, _) => {\n                 if matches!(chr, '\\\\' | '$') {\n                     current_expr.push('\\\\');\n                 }\n                 current_expr.push(chr);\n-                state = State::Expr;\n+\n+                // While Rust uses the unicode sets of XID_start and XID_continue for Identifiers\n+                // this is probably the best we can do to avoid a false positive\n+                if chr.is_alphabetic() || chr == '_' {\n+                    state = State::Ident;\n+                } else {\n+                    state = State::Expr;\n+                }\n             }\n-            (State::Expr, '}') => {\n+            (State::Ident | State::Expr, '}') => {\n                 if inexpr_open_count == 0 {\n                     output.push(chr);\n-                    extracted_expressions.push(Arg::Expr(current_expr.trim().into()));\n+\n+                    if matches!(state, State::Expr) {\n+                        extracted_expressions.push(Arg::Expr(current_expr.trim().into()));\n+                    } else {\n+                        extracted_expressions.push(Arg::Ident(current_expr.trim().into()));\n+                    }\n+\n                     current_expr = String::new();\n-                    state = State::NotExpr;\n+                    state = State::NotArg;\n                 } else {\n                     // We're closing one brace met before inside of the expression.\n                     current_expr.push(chr);\n                     inexpr_open_count -= 1;\n                 }\n             }\n-            (State::Expr, ':') if matches!(chars.peek(), Some(':')) => {\n+            (State::Ident | State::Expr, ':') if matches!(chars.peek(), Some(':')) => {\n                 // path separator\n+                state = State::Expr;\n                 current_expr.push_str(\"::\");\n                 chars.next();\n             }\n-            (State::Expr, ':') => {\n+            (State::Ident | State::Expr, ':') => {\n                 if inexpr_open_count == 0 {\n                     // We're outside of braces, thus assume that it's a specifier, like \"{Some(value):?}\"\n                     output.push(chr);\n-                    extracted_expressions.push(Arg::Expr(current_expr.trim().into()));\n+\n+                    if matches!(state, State::Expr) {\n+                        extracted_expressions.push(Arg::Expr(current_expr.trim().into()));\n+                    } else {\n+                        extracted_expressions.push(Arg::Ident(current_expr.trim().into()));\n+                    }\n+\n                     current_expr = String::new();\n                     state = State::FormatOpts;\n                 } else {\n                     // We're inside of braced expression, assume that it's a struct field name/value delimiter.\n                     current_expr.push(chr);\n                 }\n             }\n-            (State::Expr, '{') => {\n+            (State::Ident | State::Expr, '{') => {\n+                state = State::Expr;\n                 current_expr.push(chr);\n                 inexpr_open_count += 1;\n             }\n-            (State::Expr, _) => {\n+            (State::Ident | State::Expr, _) => {\n+                if !(chr.is_alphanumeric() || chr == '_' || chr == '#') {\n+                    state = State::Expr;\n+                }\n+\n                 if matches!(chr, '\\\\' | '$') {\n                     current_expr.push('\\\\');\n                 }\n                 current_expr.push(chr);\n             }\n             (State::FormatOpts, '}') => {\n                 output.push(chr);\n-                state = State::NotExpr;\n+                state = State::NotArg;\n             }\n             (State::FormatOpts, _) => {\n                 if matches!(chr, '\\\\' | '$') {\n@@ -158,7 +188,7 @@ pub fn parse_format_exprs(input: &str) -> Result<(String, Vec<Arg>), ()> {\n         }\n     }\n \n-    if state != State::NotExpr {\n+    if state != State::NotArg {\n         return Err(());\n     }\n \n@@ -218,4 +248,20 @@ mod tests {\n             check(input, output)\n         }\n     }\n+\n+    #[test]\n+    fn arg_type() {\n+        assert_eq!(\n+            parse_format_exprs(\"{_ident} {r#raw_ident} {expr.obj} {name {thing: 42} } {}\")\n+                .unwrap()\n+                .1,\n+            vec![\n+                Arg::Ident(\"_ident\".to_owned()),\n+                Arg::Ident(\"r#raw_ident\".to_owned()),\n+                Arg::Expr(\"expr.obj\".to_owned()),\n+                Arg::Expr(\"name {thing: 42}\".to_owned()),\n+                Arg::Placeholder\n+            ]\n+        );\n+    }\n }"}]}