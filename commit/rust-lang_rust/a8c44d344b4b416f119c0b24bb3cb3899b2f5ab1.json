{"sha": "a8c44d344b4b416f119c0b24bb3cb3899b2f5ab1", "node_id": "C_kwDOAAsO6NoAKGE4YzQ0ZDM0NGI0YjQxNmYxMTljMGIyNGJiM2NiMzg5OWIyZjVhYjE", "commit": {"author": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-10-08T16:09:34Z"}, "committer": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-10-16T23:04:39Z"}, "message": "Some cleanup", "tree": {"sha": "fc73b1c5a23c8895eca84d21e5cc8cc43def49e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc73b1c5a23c8895eca84d21e5cc8cc43def49e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8c44d344b4b416f119c0b24bb3cb3899b2f5ab1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8c44d344b4b416f119c0b24bb3cb3899b2f5ab1", "html_url": "https://github.com/rust-lang/rust/commit/a8c44d344b4b416f119c0b24bb3cb3899b2f5ab1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8c44d344b4b416f119c0b24bb3cb3899b2f5ab1/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bc340f7564a7a046b3acaa69d6aa1653ed27d66", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bc340f7564a7a046b3acaa69d6aa1653ed27d66", "html_url": "https://github.com/rust-lang/rust/commit/0bc340f7564a7a046b3acaa69d6aa1653ed27d66"}], "stats": {"total": 275, "additions": 216, "deletions": 59}, "files": [{"sha": "f9a309c775dae73a789a63240496384d648e1d01", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 105, "deletions": 59, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/a8c44d344b4b416f119c0b24bb3cb3899b2f5ab1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c44d344b4b416f119c0b24bb3cb3899b2f5ab1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=a8c44d344b4b416f119c0b24bb3cb3899b2f5ab1", "patch": "@@ -1,6 +1,7 @@\n use crate::check::{FnCtxt, Inherited};\n use crate::constrained_generic_params::{identify_constrained_generic_params, Parameter};\n \n+use crate::traits::query::type_op::{self, TypeOp, TypeOpOutput};\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n@@ -15,13 +16,14 @@ use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n-use rustc_middle::ty::{self, AdtKind, GenericParamDefKind, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeVisitor, WithConstness};\n-use rustc_session::lint;\n+use rustc_middle::ty::{\n+    self, AdtKind, GenericParamDefKind, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeVisitor,\n+    WithConstness,\n+};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{sym, Ident, Symbol};\n-use rustc_span::{DUMMY_SP, Span};\n-use rustc_trait_selection::traits::query::evaluate_obligation::{InferCtxtExt as _};\n-use rustc_trait_selection::traits::query::outlives_bounds::{InferCtxtExt as _};\n+use rustc_span::Span;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, WellFormedLoc};\n \n use std::convert::TryInto;\n@@ -255,75 +257,119 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         }\n     }\n \n-    // Require that the user writes as where clauses on GATs the implicit\n-    // outlives bounds involving trait parameters in trait functions and\n-    // lifetimes passed as GAT substs. See `self-outlives-lint` test.\n+    check_gat_where_clauses(tcx, trait_item, encl_trait_def_id);\n+}\n+\n+/// Require that the user writes as where clauses on GATs the implicit\n+/// outlives bounds involving trait parameters in trait functions and\n+/// lifetimes passed as GAT substs. See `self-outlives-lint` test.\n+fn check_gat_where_clauses(\n+    tcx: TyCtxt<'_>,\n+    trait_item: &hir::TraitItem<'_>,\n+    encl_trait_def_id: DefId,\n+) {\n     let item = tcx.associated_item(trait_item.def_id);\n+    // If the current trait item isn't a type, it isn't a GAT\n+    if !matches!(item.kind, ty::AssocKind::Type) {\n+        return;\n+    }\n     let generics: &ty::Generics = tcx.generics_of(trait_item.def_id);\n-    if matches!(item.kind, ty::AssocKind::Type) && generics.params.len() > 0 {\n-        let associated_items: &ty::AssocItems<'_> = tcx.associated_items(encl_trait_def_id);\n-        associated_items\n-            .in_definition_order()\n-            .filter(|item| matches!(item.kind, ty::AssocKind::Fn))\n-            .for_each(|item| {\n-                tcx.infer_ctxt().enter(|infcx| {\n-                    let sig: ty::Binder<'_, ty::FnSig<'_>> = tcx.fn_sig(item.def_id);\n-                    let sig = infcx.replace_bound_vars_with_placeholders(sig);\n-                    let output = sig.output();\n-                    let mut visitor = RegionsInGATs {\n-                        tcx,\n-                        gat: trait_item.def_id.to_def_id(),\n-                        regions: FxHashSet::default(),\n-                    };\n-                    output.visit_with(&mut visitor);\n-                    for input in sig.inputs() {\n-                        let bounds = infcx.implied_outlives_bounds(ty::ParamEnv::empty(), hir_id, input, DUMMY_SP);\n-                        debug!(?bounds);\n-                        let mut clauses = FxHashSet::default();\n-                        for bound in bounds {\n-                            match bound {\n-                                traits::query::OutlivesBound::RegionSubParam(r, p) => {\n-                                    for idx in visitor.regions.iter().filter(|(proj_r, _)| proj_r == &r).map(|r| r.1) {\n-                                        let param_r = tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n-                                            def_id: generics.params[idx].def_id,\n-                                            index: idx as u32,\n-                                            name: generics.params[idx].name,\n-                                        }));\n-                                        let clause = ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(tcx.mk_ty(ty::Param(p)), param_r));\n-                                        let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n-                                        clauses.insert(clause);\n-                                    }\n-                                }\n-                                _ => {}\n-                            }\n-                        }\n-                        debug!(?clauses);\n-                        if !clauses.is_empty() {\n-                            let written_predicates: ty::GenericPredicates<'_> = tcx.predicates_of(trait_item.def_id);\n-                            for clause in clauses {\n-                                let found = written_predicates.predicates.iter().find(|p| p.0 == clause).is_some();\n-                                debug!(?clause, ?found);\n-                                let mut error = tcx.sess.struct_span_err(\n-                                    trait_item.generics.span,\n-                                    &format!(\"Missing bound: {}\", clause),\n+    // If the current associated type doesn't have any (own) params, it's not a GAT\n+    if generics.params.len() == 0 {\n+        return;\n+    }\n+    let associated_items: &ty::AssocItems<'_> = tcx.associated_items(encl_trait_def_id);\n+    // For every function in this trait...\n+    for item in\n+        associated_items.in_definition_order().filter(|item| matches!(item.kind, ty::AssocKind::Fn))\n+    {\n+        tcx.infer_ctxt().enter(|infcx| {\n+            let sig: ty::Binder<'_, ty::FnSig<'_>> = tcx.fn_sig(item.def_id);\n+            let sig = infcx.replace_bound_vars_with_placeholders(sig);\n+            // Find out what regions are passed as GAT substs\n+            let mut visitor = GATSubstCollector {\n+                tcx,\n+                gat: trait_item.def_id.to_def_id(),\n+                regions: FxHashSet::default(),\n+                _types: FxHashSet::default(),\n+            };\n+            sig.output().visit_with(&mut visitor);\n+            // If there are none, then it nothing to do\n+            if visitor.regions.is_empty() {\n+                return;\n+            }\n+            let mut clauses = FxHashSet::default();\n+            // Otherwise, find the clauses required from implied bounds\n+            for input in sig.inputs() {\n+                // For a given input type, find the implied bounds\n+                let TypeOpOutput { output: bounds, .. } = match ty::ParamEnv::empty()\n+                    .and(type_op::implied_outlives_bounds::ImpliedOutlivesBounds { ty: input })\n+                    .fully_perform(&infcx)\n+                {\n+                    Ok(o) => o,\n+                    Err(_) => continue,\n+                };\n+                debug!(?bounds);\n+                for bound in bounds {\n+                    match bound {\n+                        traits::query::OutlivesBound::RegionSubParam(r, p) => {\n+                            // If the implied bound is a `RegionSubParam` and\n+                            // the region is used a GAT subst...\n+                            for idx in visitor\n+                                .regions\n+                                .iter()\n+                                .filter(|(proj_r, _)| proj_r == &r)\n+                                .map(|r| r.1)\n+                            {\n+                                // Then create a clause that is required on the GAT\n+                                let param_r = tcx.mk_region(ty::RegionKind::ReEarlyBound(\n+                                    ty::EarlyBoundRegion {\n+                                        def_id: generics.params[idx].def_id,\n+                                        index: idx as u32,\n+                                        name: generics.params[idx].name,\n+                                    },\n+                                ));\n+                                let clause = ty::PredicateKind::TypeOutlives(\n+                                    ty::OutlivesPredicate(tcx.mk_ty(ty::Param(p)), param_r),\n                                 );\n-                                error.emit();\n+                                let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n+                                clauses.insert(clause);\n                             }\n                         }\n+                        _ => {}\n                     }\n-                })\n-            });\n+                }\n+            }\n+            // If there are any missing clauses, emit an error\n+            debug!(?clauses);\n+            if !clauses.is_empty() {\n+                let written_predicates: ty::GenericPredicates<'_> =\n+                    tcx.predicates_of(trait_item.def_id);\n+                for clause in clauses {\n+                    let found =\n+                        written_predicates.predicates.iter().find(|p| p.0 == clause).is_some();\n+                    debug!(?clause, ?found);\n+                    let mut error = tcx.sess.struct_span_err(\n+                        trait_item.generics.span,\n+                        &format!(\"Missing bound: {}\", clause),\n+                    );\n+                    error.emit();\n+                }\n+            }\n+        })\n     }\n }\n \n-struct RegionsInGATs<'tcx> {\n+struct GATSubstCollector<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     gat: DefId,\n     // Which region appears and which parameter index its subsituted for\n     regions: FxHashSet<(ty::Region<'tcx>, usize)>,\n+    // Which params appears and which parameter index its subsituted for\n+    _types: FxHashSet<(Ty<'tcx>, usize)>,\n }\n \n-impl<'tcx> TypeVisitor<'tcx> for RegionsInGATs<'tcx> {\n+impl<'tcx> TypeVisitor<'tcx> for GATSubstCollector<'tcx> {\n     type BreakTy = !;\n \n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {"}, {"sha": "92ac1a4249e4bd5da8184deea400e4781178d32b", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a8c44d344b4b416f119c0b24bb3cb3899b2f5ab1/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c44d344b4b416f119c0b24bb3cb3899b2f5ab1/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs?ref=a8c44d344b4b416f119c0b24bb3cb3899b2f5ab1", "patch": "@@ -4,6 +4,7 @@\n \n trait Iterable {\n     type Item<'x>;\n+    //~^ Missing bound\n     fn iter<'a>(&'a self) -> Self::Item<'a>;\n }\n \n@@ -18,6 +19,7 @@ impl<T> Iterable for T {\n \n trait Deserializer<T> {\n     type Out<'x>;\n+    //~^ Missing bound\n     fn deserialize<'a>(&self, input: &'a T) -> Self::Out<'a>;\n }\n \n@@ -30,12 +32,65 @@ impl<T> Deserializer<T> for () {\n \n trait Deserializer2<T> {\n     type Out<'x>;\n+    //~^ Missing bound\n     fn deserialize2<'a, 'b: 'a>(&self, input: &'a T, input2: &'b T) -> Self::Out<'a>;\n }\n \n trait Deserializer3<T, U> {\n     type Out<'x, 'y>;\n+    //~^ Missing bound\n+    //~^^ Missing bound\n     fn deserialize2<'a, 'b>(&self, input: &'a T, input2: &'b U) -> Self::Out<'a, 'b>;\n }\n \n+trait Deserializer4 {\n+    type Out<'x>;\n+    //~^ Missing bound\n+    fn deserialize<'a, T>(&self, input: &'a T) -> Self::Out<'a>;\n+}\n+\n+struct Wrap<T>(T);\n+\n+trait Des {\n+    type Out<'x, D>;\n+    //~^ Missing bound\n+    fn des<'z, T>(&self, data: &'z Wrap<T>) -> Self::Out<'z, Wrap<T>>;\n+}\n+/*\n+impl Des for () {\n+    type Out<'x, D> = &'x D;\n+    fn des<'a, T>(&self, data: &'a Wrap<T>) -> Self::Out<'a, Wrap<T>> {\n+        data\n+    }\n+}\n+*/\n+\n+trait Des2 {\n+    type Out<'x, D>;\n+    //~^ Missing bound\n+    fn des<'z, T>(&self, data: &'z Wrap<T>) -> Self::Out<'z, T>;\n+}\n+/*\n+impl Des2 for () {\n+    type Out<'x, D> = &'x D;\n+    fn des<'a, T>(&self, data: &'a Wrap<T>) -> Self::Out<'a, T> {\n+        data\n+    }\n+}\n+*/\n+\n+trait Des3 {\n+    type Out<'x, D>;\n+    //~^ Missing bound\n+    fn des<'z, T>(&self, data: &'z T) -> Self::Out<'z, T>;\n+}\n+/*\n+impl Des3 for () {\n+    type Out<'x, D> = &'x D;\n+    fn des<'a, T>(&self, data: &'a T) -> Self::Out<'a, T> {\n+          data\n+    }\n+}\n+*/\n+  \n fn main() {}"}, {"sha": "3fb41335495299f99839578c97879697a8854968", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a8c44d344b4b416f119c0b24bb3cb3899b2f5ab1/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8c44d344b4b416f119c0b24bb3cb3899b2f5ab1/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr?ref=a8c44d344b4b416f119c0b24bb3cb3899b2f5ab1", "patch": "@@ -0,0 +1,56 @@\n+error: Missing bound: Self: 'x\n+  --> $DIR/self-outlives-lint.rs:6:14\n+   |\n+LL |     type Item<'x>;\n+   |              ^^^^\n+\n+error: Missing bound: T: 'x\n+  --> $DIR/self-outlives-lint.rs:21:13\n+   |\n+LL |     type Out<'x>;\n+   |             ^^^^\n+\n+error: Missing bound: T: 'x\n+  --> $DIR/self-outlives-lint.rs:34:13\n+   |\n+LL |     type Out<'x>;\n+   |             ^^^^\n+\n+error: Missing bound: T: 'x\n+  --> $DIR/self-outlives-lint.rs:40:13\n+   |\n+LL |     type Out<'x, 'y>;\n+   |             ^^^^^^^^\n+\n+error: Missing bound: U: 'y\n+  --> $DIR/self-outlives-lint.rs:40:13\n+   |\n+LL |     type Out<'x, 'y>;\n+   |             ^^^^^^^^\n+\n+error: Missing bound: T: 'x\n+  --> $DIR/self-outlives-lint.rs:47:13\n+   |\n+LL |     type Out<'x>;\n+   |             ^^^^\n+\n+error: Missing bound: T: 'x\n+  --> $DIR/self-outlives-lint.rs:55:13\n+   |\n+LL |     type Out<'x, D>;\n+   |             ^^^^^^^\n+\n+error: Missing bound: T: 'x\n+  --> $DIR/self-outlives-lint.rs:69:13\n+   |\n+LL |     type Out<'x, D>;\n+   |             ^^^^^^^\n+\n+error: Missing bound: T: 'x\n+  --> $DIR/self-outlives-lint.rs:83:13\n+   |\n+LL |     type Out<'x, D>;\n+   |             ^^^^^^^\n+\n+error: aborting due to 9 previous errors\n+"}]}