{"sha": "7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmM2NiN2ZkYjhlM2I3OWNiMGMyYjQxMzk4ZTI0Zjk0YzgwNmFhYWE=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-10-21T10:08:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-21T10:08:20Z"}, "message": "Merge pull request #68 from oli-obk/master\n\npriroda requirements + static impl", "tree": {"sha": "bea8f5390058d7d470d2d0fcee1652f4f0b1dcec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bea8f5390058d7d470d2d0fcee1652f4f0b1dcec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa", "html_url": "https://github.com/rust-lang/rust/commit/7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7bcf35f8ac9ac0797d0117166e0158d71acc03b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7bcf35f8ac9ac0797d0117166e0158d71acc03b", "html_url": "https://github.com/rust-lang/rust/commit/e7bcf35f8ac9ac0797d0117166e0158d71acc03b"}, {"sha": "edc6b93b855ef342e0f3f5935eef60b3218a9b97", "url": "https://api.github.com/repos/rust-lang/rust/commits/edc6b93b855ef342e0f3f5935eef60b3218a9b97", "html_url": "https://github.com/rust-lang/rust/commit/edc6b93b855ef342e0f3f5935eef60b3218a9b97"}], "stats": {"total": 315, "additions": 201, "deletions": 114}, "files": [{"sha": "5459ad2f03d71defd93b34ab2dceb83c434110ed", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 174, "deletions": 91, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa", "patch": "@@ -15,9 +15,9 @@ use std::rc::Rc;\n use syntax::codemap::{self, DUMMY_SP};\n \n use error::{EvalError, EvalResult};\n-use memory::{Memory, Pointer, AllocId};\n+use memory::{Memory, Pointer};\n use primval::{self, PrimVal, PrimValKind};\n-use self::value::Value;\n+pub use self::value::Value;\n \n use std::collections::HashMap;\n \n@@ -41,8 +41,7 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n     memory: Memory<'a, 'tcx>,\n \n     /// Precomputed statics, constants and promoteds.\n-    // FIXME(solson): Change from Pointer to Value.\n-    statics: HashMap<ConstantId<'tcx>, Pointer>,\n+    globals: HashMap<GlobalId<'tcx>, Global<'tcx>>,\n \n     /// The virtual call stack.\n     stack: Vec<Frame<'a, 'tcx>>,\n@@ -77,7 +76,7 @@ pub struct Frame<'a, 'tcx: 'a> {\n     pub return_to_block: StackPopCleanup,\n \n     /// The location where the result of the current stack frame should be written to.\n-    pub return_lvalue: Lvalue,\n+    pub return_lvalue: Lvalue<'tcx>,\n \n     /// The list of locals for this stack frame, stored in order as\n     /// `[arguments..., variables..., temporaries...]`. The locals are stored as `Value`s, which\n@@ -99,7 +98,7 @@ pub struct Frame<'a, 'tcx: 'a> {\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-pub enum Lvalue {\n+pub enum Lvalue<'tcx> {\n     /// An lvalue referring to a value allocated in the `Memory` system.\n     Ptr {\n         ptr: Pointer,\n@@ -111,9 +110,11 @@ pub enum Lvalue {\n     Local {\n         frame: usize,\n         local: mir::Local,\n-    }\n+    },\n+\n+    Global(GlobalId<'tcx>),\n \n-    // TODO(solson): Static/Const? None/Never?\n+    // TODO(solson): None/Never?\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -130,31 +131,43 @@ pub enum CachedMir<'mir, 'tcx: 'mir> {\n     Owned(Rc<mir::Mir<'tcx>>)\n }\n \n-#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n /// Uniquely identifies a specific constant or static\n-struct ConstantId<'tcx> {\n+pub struct GlobalId<'tcx> {\n     /// the def id of the constant/static or in case of promoteds, the def id of the function they belong to\n     def_id: DefId,\n     /// In case of statics and constants this is `Substs::empty()`, so only promoteds and associated\n     /// constants actually have something useful here. We could special case statics and constants,\n     /// but that would only require more branching when working with constants, and not bring any\n     /// real benefits.\n     substs: &'tcx Substs<'tcx>,\n-    kind: ConstantKind,\n+    /// this `Option` is `Some` for promoted constants\n+    promoted: Option<mir::Promoted>,\n }\n \n-#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n-enum ConstantKind {\n-    Promoted(mir::Promoted),\n-    /// Statics, constants and associated constants\n-    Global,\n+#[derive(Copy, Clone, Debug)]\n+pub struct Global<'tcx> {\n+    data: Option<Value>,\n+    mutable: bool,\n+    ty: Ty<'tcx>,\n+}\n+\n+impl<'tcx> Global<'tcx> {\n+    fn uninitialized(ty: Ty<'tcx>) -> Self {\n+        Global {\n+            data: None,\n+            mutable: true,\n+            ty: ty,\n+        }\n+    }\n }\n \n #[derive(Clone, Debug, Eq, PartialEq, Hash)]\n pub enum StackPopCleanup {\n-    /// The stackframe existed to compute the initial value of a static/constant, make sure the\n-    /// static isn't modifyable afterwards\n-    Freeze(AllocId),\n+    /// The stackframe existed to compute the initial value of a static/constant, make sure it\n+    /// isn't modifyable afterwards. The allocation of the result is frozen iff it's an\n+    /// actual allocation. `PrimVal`s are unmodifyable anyway.\n+    Freeze,\n     /// A regular stackframe added due to a function call will need to get forwarded to the next\n     /// block\n     Goto(mir::BasicBlock),\n@@ -169,7 +182,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             mir_map: mir_map,\n             mir_cache: RefCell::new(DefIdMap()),\n             memory: Memory::new(&tcx.data_layout, memory_size),\n-            statics: HashMap::new(),\n+            globals: HashMap::new(),\n             stack: Vec::new(),\n             stack_limit: stack_limit,\n         }\n@@ -347,7 +360,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         span: codemap::Span,\n         mir: CachedMir<'a, 'tcx>,\n         substs: &'tcx Substs<'tcx>,\n-        return_lvalue: Lvalue,\n+        return_lvalue: Lvalue<'tcx>,\n         return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx, ()> {\n         ::log_settings::settings().indentation += 1;\n@@ -380,7 +393,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ::log_settings::settings().indentation -= 1;\n         let frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n         match frame.return_to_block {\n-            StackPopCleanup::Freeze(alloc_id) => self.memory.freeze(alloc_id)?,\n+            StackPopCleanup::Freeze => if let Lvalue::Global(id) = frame.return_lvalue {\n+                let global_value = self.globals\n+                                       .get_mut(&id)\n+                                       .expect(\"global should have been cached (freeze)\");\n+                if let Value::ByRef(ptr) = global_value.data.expect(\"global should have been initialized\") {\n+                    self.memory.freeze(ptr.alloc_id)?;\n+                }\n+                assert!(global_value.mutable);\n+                global_value.mutable = false;\n+            } else {\n+                bug!(\"StackPopCleanup::Freeze on: {:?}\", frame.return_lvalue);\n+            },\n             StackPopCleanup::Goto(target) => self.goto_block(target),\n             StackPopCleanup::None => {},\n         }\n@@ -406,7 +430,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         op: mir::BinOp,\n         left: &mir::Operand<'tcx>,\n         right: &mir::Operand<'tcx>,\n-        dest: Lvalue,\n+        dest: Lvalue<'tcx>,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, ()> {\n         let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n@@ -421,7 +445,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         op: mir::BinOp,\n         left: &mir::Operand<'tcx>,\n         right: &mir::Operand<'tcx>,\n-        dest: Lvalue,\n+        dest: Lvalue<'tcx>,\n     ) -> EvalResult<'tcx, bool> {\n         let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n         self.write_primval(dest, val)?;\n@@ -430,7 +454,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn assign_fields<I: IntoIterator<Item = u64>>(\n         &mut self,\n-        dest: Lvalue,\n+        dest: Lvalue<'tcx>,\n         offsets: I,\n         operands: &[mir::Operand<'tcx>],\n     ) -> EvalResult<'tcx, ()> {\n@@ -812,26 +836,22 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             // function items are zero sized\n                             Value::ByRef(self.memory.allocate(0, 0)?)\n                         } else {\n-                            let cid = ConstantId {\n+                            let cid = GlobalId {\n                                 def_id: def_id,\n                                 substs: substs,\n-                                kind: ConstantKind::Global,\n+                                promoted: None,\n                             };\n-                            let static_ptr = *self.statics.get(&cid)\n-                                .expect(\"static should have been cached (rvalue)\");\n-                            Value::ByRef(static_ptr)\n+                            self.read_lvalue(Lvalue::Global(cid))?\n                         }\n                     }\n \n                     Literal::Promoted { index } => {\n-                        let cid = ConstantId {\n+                        let cid = GlobalId {\n                             def_id: self.frame().def_id,\n                             substs: self.substs(),\n-                            kind: ConstantKind::Promoted(index),\n+                            promoted: Some(index),\n                         };\n-                        let static_ptr = *self.statics.get(&cid)\n-                            .expect(\"a promoted constant hasn't been precomputed\");\n-                        Value::ByRef(static_ptr)\n+                        self.read_lvalue(Lvalue::Global(cid))?\n                     }\n                 };\n \n@@ -851,19 +871,28 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n             }\n         }\n+        let lvalue = self.eval_lvalue(lvalue)?;\n+        self.read_lvalue(lvalue)\n+    }\n \n-        match self.eval_lvalue(lvalue)? {\n+    pub fn read_lvalue(&self, lvalue: Lvalue<'tcx>) -> EvalResult<'tcx, Value> {\n+        match lvalue {\n             Lvalue::Ptr { ptr, extra } => {\n                 assert_eq!(extra, LvalueExtra::None);\n                 Ok(Value::ByRef(ptr))\n             }\n             Lvalue::Local { frame, local } => {\n                 self.stack[frame].get_local(local).ok_or(EvalError::ReadUndefBytes)\n             }\n+            Lvalue::Global(cid) => self.globals\n+                                       .get(&cid)\n+                                       .expect(\"global not cached\")\n+                                       .data\n+                                       .ok_or(EvalError::ReadUndefBytes),\n         }\n     }\n \n-    fn eval_lvalue(&mut self, mir_lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue> {\n+    fn eval_lvalue(&mut self, mir_lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         use rustc::mir::repr::Lvalue::*;\n         let lvalue = match *mir_lvalue {\n             Local(mir::RETURN_POINTER) => self.frame().return_lvalue,\n@@ -877,14 +906,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Static(def_id) => {\n                 let substs = subst::Substs::empty(self.tcx);\n-                let cid = ConstantId {\n+                let cid = GlobalId {\n                     def_id: def_id,\n                     substs: substs,\n-                    kind: ConstantKind::Global,\n+                    promoted: None,\n                 };\n-                let ptr = *self.statics.get(&cid)\n-                    .expect(\"static should have been cached (lvalue)\");\n-                Lvalue::Ptr { ptr: ptr, extra: LvalueExtra::None }\n+                Lvalue::Global(cid)\n             }\n \n             Projection(ref proj) => return self.eval_lvalue_projection(proj),\n@@ -900,7 +927,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn eval_lvalue_projection(\n         &mut self,\n         proj: &mir::LvalueProjection<'tcx>,\n-    ) -> EvalResult<'tcx, Lvalue> {\n+    ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         let base = self.eval_lvalue(&proj.base)?;\n         let base_ty = self.lvalue_ty(&proj.base);\n         let base_layout = self.type_layout(base_ty);\n@@ -1069,11 +1096,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn force_allocation(&mut self, lvalue: Lvalue) -> EvalResult<'tcx, Lvalue> {\n+    fn force_allocation(&mut self, lvalue: Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         let new_lvalue = match lvalue {\n             Lvalue::Local { frame, local } => {\n-                let ptr = match self.stack[frame].get_local(local) {\n-                    Some(Value::ByRef(ptr)) => ptr,\n+                match self.stack[frame].get_local(local) {\n+                    Some(Value::ByRef(ptr)) => Lvalue::from_ptr(ptr),\n                     opt_val => {\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n                         let substs = self.stack[frame].substs;\n@@ -1082,12 +1109,32 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         if let Some(val) = opt_val {\n                             self.write_value_to_ptr(val, ptr, ty)?;\n                         }\n-                        ptr\n+                        Lvalue::from_ptr(ptr)\n                     }\n-                };\n-                Lvalue::Ptr { ptr: ptr, extra: LvalueExtra::None }\n+                }\n             }\n             Lvalue::Ptr { .. } => lvalue,\n+            Lvalue::Global(cid) => {\n+                let global_val = *self.globals.get(&cid).expect(\"global not cached\");\n+                match global_val.data {\n+                    Some(Value::ByRef(ptr)) => Lvalue::from_ptr(ptr),\n+                    _ => {\n+                        let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.substs)?;\n+                        if let Some(val) = global_val.data {\n+                            self.write_value_to_ptr(val, ptr, global_val.ty)?;\n+                        }\n+                        if !global_val.mutable {\n+                            self.memory.freeze(ptr.alloc_id)?;\n+                        }\n+                        let lval = self.globals.get_mut(&cid).expect(\"already checked\");\n+                        *lval = Global {\n+                            data: Some(Value::ByRef(ptr)),\n+                            .. global_val\n+                        };\n+                        Lvalue::from_ptr(ptr)\n+                    },\n+                }\n+            }\n         };\n         Ok(new_lvalue)\n     }\n@@ -1136,7 +1183,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn write_primval(\n         &mut self,\n-        dest: Lvalue,\n+        dest: Lvalue<'tcx>,\n         val: PrimVal,\n     ) -> EvalResult<'tcx, ()> {\n         match dest {\n@@ -1148,58 +1195,94 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.stack[frame].set_local(local, Value::ByVal(val));\n                 Ok(())\n             }\n+            Lvalue::Global(cid) => {\n+                let global_val = self.globals.get_mut(&cid).expect(\"global not cached\");\n+                if global_val.mutable {\n+                    global_val.data = Some(Value::ByVal(val));\n+                    Ok(())\n+                } else {\n+                    Err(EvalError::ModifiedConstantMemory)\n+                }\n+            }\n         }\n     }\n \n     fn write_value(\n         &mut self,\n         src_val: Value,\n-        dest: Lvalue,\n+        dest: Lvalue<'tcx>,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, ()> {\n         match dest {\n+            Lvalue::Global(cid) => {\n+                let dest = *self.globals.get_mut(&cid).expect(\"global should be cached\");\n+                if !dest.mutable {\n+                    return Err(EvalError::ModifiedConstantMemory);\n+                }\n+                self.write_value_possibly_by_val(\n+                    src_val,\n+                    |this, val| *this.globals.get_mut(&cid).expect(\"already checked\") = Global { data: Some(val), ..dest },\n+                    dest.data,\n+                    dest_ty,\n+                )\n+            },\n+\n             Lvalue::Ptr { ptr, extra } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                self.write_value_to_ptr(src_val, ptr, dest_ty)?;\n+                self.write_value_to_ptr(src_val, ptr, dest_ty)\n             }\n \n-            // The cases here can be a bit subtle. Read carefully!\n             Lvalue::Local { frame, local } => {\n-                let dest_val = self.stack[frame].get_local(local);\n-\n-                if let Some(Value::ByRef(dest_ptr)) = dest_val {\n-                    // If the local value is already `ByRef` (that is, backed by an `Allocation`),\n-                    // then we must write the new value into this allocation, because there may be\n-                    // other pointers into the allocation. These other pointers are logically\n-                    // pointers into the local variable, and must be able to observe the change.\n-                    //\n-                    // Thus, it would be an error to replace the `ByRef` with a `ByVal`, unless we\n-                    // knew for certain that there were no outstanding pointers to this local.\n-                    self.write_value_to_ptr(src_val, dest_ptr, dest_ty)?;\n-\n-                } else if let Value::ByRef(src_ptr) = src_val {\n-                    // If the local value is not `ByRef`, then we know there are no pointers to it\n-                    // and we can simply overwrite the `Value` in the locals array directly.\n-                    //\n-                    // In this specific case, where the source value is `ByRef`, we must duplicate\n-                    // the allocation, because this is a by-value operation. It would be incorrect\n-                    // if they referred to the same allocation, since then a change to one would\n-                    // implicitly change the other.\n-                    //\n-                    // TODO(solson): It would be valid to attempt reading a primitive value out of\n-                    // the source and writing that into the destination without making an\n-                    // allocation. This would be a pure optimization.\n-                    let dest_ptr = self.alloc_ptr(dest_ty)?;\n-                    self.copy(src_ptr, dest_ptr, dest_ty)?;\n-                    self.stack[frame].set_local(local, Value::ByRef(dest_ptr));\n-\n-                } else {\n-                    // Finally, we have the simple case where neither source nor destination are\n-                    // `ByRef`. We may simply copy the source value over the the destintion local.\n-                    self.stack[frame].set_local(local, src_val);\n-                }\n+                let dest = self.stack[frame].get_local(local);\n+                self.write_value_possibly_by_val(\n+                    src_val,\n+                    |this, val| this.stack[frame].set_local(local, val),\n+                    dest,\n+                    dest_ty,\n+                )\n             }\n         }\n+    }\n+\n+    // The cases here can be a bit subtle. Read carefully!\n+    fn write_value_possibly_by_val<F: FnOnce(&mut Self, Value)>(\n+        &mut self,\n+        src_val: Value,\n+        write_dest: F,\n+        old_dest_val: Option<Value>,\n+        dest_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, ()> {\n+        if let Some(Value::ByRef(dest_ptr)) = old_dest_val {\n+            // If the value is already `ByRef` (that is, backed by an `Allocation`),\n+            // then we must write the new value into this allocation, because there may be\n+            // other pointers into the allocation. These other pointers are logically\n+            // pointers into the local variable, and must be able to observe the change.\n+            //\n+            // Thus, it would be an error to replace the `ByRef` with a `ByVal`, unless we\n+            // knew for certain that there were no outstanding pointers to this allocation.\n+            self.write_value_to_ptr(src_val, dest_ptr, dest_ty)?;\n+\n+        } else if let Value::ByRef(src_ptr) = src_val {\n+            // If the value is not `ByRef`, then we know there are no pointers to it\n+            // and we can simply overwrite the `Value` in the locals array directly.\n+            //\n+            // In this specific case, where the source value is `ByRef`, we must duplicate\n+            // the allocation, because this is a by-value operation. It would be incorrect\n+            // if they referred to the same allocation, since then a change to one would\n+            // implicitly change the other.\n+            //\n+            // TODO(solson): It would be valid to attempt reading a primitive value out of\n+            // the source and writing that into the destination without making an\n+            // allocation. This would be a pure optimization.\n+            let dest_ptr = self.alloc_ptr(dest_ty)?;\n+            self.copy(src_ptr, dest_ptr, dest_ty)?;\n+            write_dest(self, Value::ByRef(dest_ptr));\n+\n+        } else {\n+            // Finally, we have the simple case where neither source nor destination are\n+            // `ByRef`. We may simply copy the source value over the the destintion.\n+            write_dest(self, src_val);\n+        }\n         Ok(())\n     }\n \n@@ -1491,7 +1574,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn dump_local(&self, lvalue: Lvalue) {\n+    fn dump_local(&self, lvalue: Lvalue<'tcx>) {\n         if let Lvalue::Local { frame, local } = lvalue {\n             if let Some(val) = self.stack[frame].get_local(local) {\n                 match val {\n@@ -1512,7 +1595,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx: 'a> Frame<'a, 'tcx> {\n-    fn get_local(&self, local: mir::Local) -> Option<Value> {\n+    pub fn get_local(&self, local: mir::Local) -> Option<Value> {\n         // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n         self.locals[local.index() - 1]\n     }\n@@ -1523,8 +1606,8 @@ impl<'a, 'tcx: 'a> Frame<'a, 'tcx> {\n     }\n }\n \n-impl Lvalue {\n-    fn from_ptr(ptr: Pointer) -> Self {\n+impl<'tcx> Lvalue<'tcx> {\n+    pub fn from_ptr(ptr: Pointer) -> Self {\n         Lvalue::Ptr { ptr: ptr, extra: LvalueExtra::None }\n     }\n \n@@ -1542,7 +1625,7 @@ impl Lvalue {\n         ptr\n     }\n \n-    fn elem_ty_and_len<'tcx>(self, ty: Ty<'tcx>) -> (Ty<'tcx>, u64) {\n+    fn elem_ty_and_len(self, ty: Ty<'tcx>) -> (Ty<'tcx>, u64) {\n         match ty.sty {\n             ty::TyArray(elem, n) => (elem, n as u64),\n "}, {"sha": "eac5494f43103b3553225973d56d471fb667a87f", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa", "patch": "@@ -4,11 +4,11 @@\n \n use super::{\n     CachedMir,\n-    ConstantId,\n+    GlobalId,\n     EvalContext,\n     Lvalue,\n-    ConstantKind,\n     StackPopCleanup,\n+    Global,\n };\n use error::EvalResult;\n use rustc::mir::repr as mir;\n@@ -118,25 +118,23 @@ struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b> {\n \n impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n     fn global_item(&mut self, def_id: DefId, substs: &'tcx subst::Substs<'tcx>, span: Span, immutable: bool) {\n-        let cid = ConstantId {\n+        let cid = GlobalId {\n             def_id: def_id,\n             substs: substs,\n-            kind: ConstantKind::Global,\n+            promoted: None,\n         };\n-        if self.ecx.statics.contains_key(&cid) {\n+        if self.ecx.globals.contains_key(&cid) {\n             return;\n         }\n         self.try(|this| {\n             let mir = this.ecx.load_mir(def_id)?;\n-            // FIXME(solson): Don't allocate a pointer unconditionally.\n-            let ptr = this.ecx.alloc_ptr_with_substs(mir.return_ty, substs)?;\n-            this.ecx.statics.insert(cid.clone(), ptr);\n+            this.ecx.globals.insert(cid, Global::uninitialized(mir.return_ty));\n             let cleanup = if immutable && !mir.return_ty.type_contents(this.ecx.tcx).interior_unsafe() {\n-                StackPopCleanup::Freeze(ptr.alloc_id)\n+                StackPopCleanup::Freeze\n             } else {\n                 StackPopCleanup::None\n             };\n-            this.ecx.push_stack_frame(def_id, span, mir, substs, Lvalue::from_ptr(ptr), cleanup)\n+            this.ecx.push_stack_frame(def_id, span, mir, substs, Lvalue::Global(cid), cleanup)\n         });\n     }\n     fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx, ()>>(&mut self, f: F) {\n@@ -167,27 +165,25 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                 }\n             },\n             mir::Literal::Promoted { index } => {\n-                let cid = ConstantId {\n+                let mir = self.mir.promoted[index].clone();\n+                let cid = GlobalId {\n                     def_id: self.def_id,\n                     substs: self.substs,\n-                    kind: ConstantKind::Promoted(index),\n+                    promoted: Some(index),\n                 };\n-                if self.ecx.statics.contains_key(&cid) {\n+                if self.ecx.globals.contains_key(&cid) {\n                     return;\n                 }\n-                let mir = self.mir.promoted[index].clone();\n-                let return_ty = mir.return_ty;\n                 self.try(|this| {\n-                    // FIXME(solson): Don't allocate a pointer unconditionally.\n-                    let return_ptr = this.ecx.alloc_ptr_with_substs(return_ty, cid.substs)?;\n                     let mir = CachedMir::Owned(Rc::new(mir));\n-                    this.ecx.statics.insert(cid.clone(), return_ptr);\n+                    let ty = this.ecx.monomorphize(mir.return_ty, this.substs);\n+                    this.ecx.globals.insert(cid, Global::uninitialized(ty));\n                     this.ecx.push_stack_frame(this.def_id,\n                                               constant.span,\n                                               mir,\n                                               this.substs,\n-                                              Lvalue::from_ptr(return_ptr),\n-                                              StackPopCleanup::Freeze(return_ptr.alloc_id))\n+                                              Lvalue::Global(cid),\n+                                              StackPopCleanup::Freeze)\n                 });\n             }\n         }"}, {"sha": "5f8886c5c1f03313ca7e2d5af8cb27d8af70e372", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa", "patch": "@@ -15,7 +15,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n         args: &[mir::Operand<'tcx>],\n-        dest: Lvalue,\n+        dest: Lvalue<'tcx>,\n         dest_ty: Ty<'tcx>,\n         dest_layout: &'tcx Layout,\n     ) -> EvalResult<'tcx, ()> {"}, {"sha": "f3edc5182500c501add7e3ff5b6e3b5cc0da4ebc", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa", "patch": "@@ -148,7 +148,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n         fn_ty: &'tcx BareFnTy,\n-        destination: Option<(Lvalue, mir::BasicBlock)>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n     ) -> EvalResult<'tcx, ()> {\n@@ -262,7 +262,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &mut self,\n         def_id: DefId,\n         args: &[mir::Operand<'tcx>],\n-        dest: Lvalue,\n+        dest: Lvalue<'tcx>,\n         dest_size: usize,\n     ) -> EvalResult<'tcx, ()> {\n         let name = self.tcx.item_name(def_id);"}, {"sha": "3ed75a54c2a51e236c6ec971301646989295083c", "filename": "src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa", "patch": "@@ -36,10 +36,18 @@ pub use interpreter::{\n     eval_main,\n     run_mir_passes,\n     StackPopCleanup,\n+    Value,\n+    Lvalue,\n+    LvalueExtra,\n };\n \n pub use memory::{\n     Memory,\n     Pointer,\n     AllocId,\n };\n+\n+pub use primval::{\n+    PrimVal,\n+    PrimValKind,\n+};"}]}