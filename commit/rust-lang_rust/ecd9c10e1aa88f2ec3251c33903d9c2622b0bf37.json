{"sha": "ecd9c10e1aa88f2ec3251c33903d9c2622b0bf37", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjZDljMTBlMWFhODhmMmVjMzI1MWMzMzkwM2Q5YzI2MjJiMGJmMzc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-02T09:12:25Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-03T12:01:21Z"}, "message": "Move upvar checking into its own pre-pass that occurs before regionck\nand which uses EUV. For now, upvar inference is not any smarter than\nit ever was, but regionck is simpler because it doesn't have to do as\nmany things at once.", "tree": {"sha": "c22df7c57db5381e47fe0070ae204387539a7fea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c22df7c57db5381e47fe0070ae204387539a7fea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecd9c10e1aa88f2ec3251c33903d9c2622b0bf37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecd9c10e1aa88f2ec3251c33903d9c2622b0bf37", "html_url": "https://github.com/rust-lang/rust/commit/ecd9c10e1aa88f2ec3251c33903d9c2622b0bf37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecd9c10e1aa88f2ec3251c33903d9c2622b0bf37/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7474be066022d2cd0b0695a466651570c00f3700", "url": "https://api.github.com/repos/rust-lang/rust/commits/7474be066022d2cd0b0695a466651570c00f3700", "html_url": "https://github.com/rust-lang/rust/commit/7474be066022d2cd0b0695a466651570c00f3700"}], "stats": {"total": 724, "additions": 385, "deletions": 339}, "files": [{"sha": "acbb7d567dceac8b253230a17d00fb9163e0e08c", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecd9c10e1aa88f2ec3251c33903d9c2622b0bf37/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd9c10e1aa88f2ec3251c33903d9c2622b0bf37/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=ecd9c10e1aa88f2ec3251c33903d9c2622b0bf37", "patch": "@@ -126,6 +126,12 @@ impl TraitItemKind {\n }\n \n impl Def {\n+    pub fn local_node_id(&self) -> ast::NodeId {\n+        let def_id = self.def_id();\n+        assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n+        def_id.node\n+    }\n+\n     pub fn def_id(&self) -> ast::DefId {\n         match *self {\n             DefFn(id, _) | DefStaticMethod(id, _) | DefMod(id) |"}, {"sha": "82525b71052d2be0a625baee3bb2d9ed24d50f37", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd9c10e1aa88f2ec3251c33903d9c2622b0bf37/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd9c10e1aa88f2ec3251c33903d9c2622b0bf37/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ecd9c10e1aa88f2ec3251c33903d9c2622b0bf37", "patch": "@@ -130,6 +130,7 @@ pub mod regionmanip;\n pub mod regionck;\n pub mod demand;\n pub mod method;\n+mod upvar;\n pub mod wf;\n mod closure;\n mod callee;\n@@ -482,6 +483,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                decl, id, body, &inh);\n \n             vtable::select_all_fcx_obligations_or_error(&fcx);\n+            upvar::closure_analyze_fn(&fcx, id, decl, body);\n             regionck::regionck_fn(&fcx, id, decl, body);\n             writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n         }"}, {"sha": "e97a29ec458c7f9d6ea3f55833ba15a62d75a396", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 339, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/ecd9c10e1aa88f2ec3251c33903d9c2622b0bf37/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd9c10e1aa88f2ec3251c33903d9c2622b0bf37/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=ecd9c10e1aa88f2ec3251c33903d9c2622b0bf37", "patch": "@@ -81,38 +81,6 @@\n //! traversed.  This is essentially the same as the ownership\n //! relation, except that a borrowed pointer never owns its\n //! contents.\n-//!\n-//! ### Inferring borrow kinds for upvars\n-//!\n-//! Whenever there is a closure expression, we need to determine how each\n-//! upvar is used. We do this by initially assigning each upvar an\n-//! immutable \"borrow kind\" (see `ty::BorrowKind` for details) and then\n-//! \"escalating\" the kind as needed. The borrow kind proceeds according to\n-//! the following lattice:\n-//!\n-//!     ty::ImmBorrow -> ty::UniqueImmBorrow -> ty::MutBorrow\n-//!\n-//! So, for example, if we see an assignment `x = 5` to an upvar `x`, we\n-//! will promote its borrow kind to mutable borrow. If we see an `&mut x`\n-//! we'll do the same. Naturally, this applies not just to the upvar, but\n-//! to everything owned by `x`, so the result is the same for something\n-//! like `x.f = 5` and so on (presuming `x` is not a borrowed pointer to a\n-//! struct). These adjustments are performed in\n-//! `adjust_upvar_borrow_kind()` (you can trace backwards through the code\n-//! from there).\n-//!\n-//! The fact that we are inferring borrow kinds as we go results in a\n-//! semi-hacky interaction with mem-categorization. In particular,\n-//! mem-categorization will query the current borrow kind as it\n-//! categorizes, and we'll return the *current* value, but this may get\n-//! adjusted later. Therefore, in this module, we generally ignore the\n-//! borrow kind (and derived mutabilities) that are returned from\n-//! mem-categorization, since they may be inaccurate. (Another option\n-//! would be to use a unification scheme, where instead of returning a\n-//! concrete borrow kind like `ty::ImmBorrow`, we return a\n-//! `ty::InferBorrow(upvar_id)` or something like that, but this would\n-//! then mean that all later passes would have to check for these figments\n-//! and report an error, and it just seems like more mess in the end.)\n \n use astconv::AstConv;\n use check::FnCtxt;\n@@ -126,17 +94,13 @@ use middle::ty::{ReScope};\n use middle::ty::{mod, Ty, MethodCall};\n use middle::infer;\n use middle::pat_util;\n-use util::nodemap::{FnvHashMap};\n use util::ppaux::{ty_to_string, Repr};\n \n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-use std::cell::{RefCell};\n-use std::collections::hash_map::Entry::{Vacant, Occupied};\n-\n use self::RepeatingScope::Repeating;\n use self::SubjectNode::Subject;\n \n@@ -197,19 +161,6 @@ pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n ///////////////////////////////////////////////////////////////////////////\n // INTERNALS\n \n-// Stores parameters for a potential call to link_region()\n-// to perform if an upvar reference is marked unique/mutable after\n-// it has already been processed before.\n-struct MaybeLink<'tcx> {\n-    span: Span,\n-    borrow_region: ty::Region,\n-    borrow_kind: ty::BorrowKind,\n-    borrow_cmt: mc::cmt<'tcx>\n-}\n-\n-// A map associating an upvar ID to a vector of the above\n-type MaybeLinkMap<'tcx> = RefCell<FnvHashMap<ty::UpvarId, Vec<MaybeLink<'tcx>>>>;\n-\n pub struct Rcx<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n \n@@ -220,10 +171,6 @@ pub struct Rcx<'a, 'tcx: 'a> {\n \n     // id of AST node being analyzed (the subject of the analysis).\n     subject: SubjectNode,\n-\n-    // Possible region links we will establish if an upvar\n-    // turns out to be unique/mutable\n-    maybe_links: MaybeLinkMap<'tcx>\n }\n \n /// Returns the validity region of `def` -- that is, how long is `def` valid?\n@@ -258,8 +205,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         Rcx { fcx: fcx,\n               repeating_scope: initial_repeating_scope,\n               subject: subject,\n-              region_param_pairs: Vec::new(),\n-              maybe_links: RefCell::new(FnvHashMap::new()) }\n+              region_param_pairs: Vec::new() }\n     }\n \n     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n@@ -590,19 +536,12 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr);\n         }\n \n-        ast::ExprAssign(ref lhs, _) => {\n-            adjust_borrow_kind_for_assignment_lhs(rcx, &**lhs);\n-            visit::walk_expr(rcx, expr);\n-        }\n-\n         ast::ExprAssignOp(_, ref lhs, ref rhs) => {\n             if has_method_map {\n                 constrain_call(rcx, expr, Some(&**lhs),\n                                Some(&**rhs).into_iter(), true);\n             }\n \n-            adjust_borrow_kind_for_assignment_lhs(rcx, &**lhs);\n-\n             visit::walk_expr(rcx, expr);\n         }\n \n@@ -838,22 +777,6 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     visit::walk_expr(rcx, expr);\n     rcx.set_repeating_scope(repeating_scope);\n \n-    match function_type.sty {\n-        ty::ty_closure(box ty::ClosureTy { store: ty::RegionTraitStore(..), .. }) => {\n-            ty::with_freevars(tcx, expr.id, |freevars| {\n-                propagate_upupvar_borrow_kind(rcx, expr, freevars);\n-            })\n-        }\n-        ty::ty_unboxed_closure(..) => {\n-            if tcx.capture_modes.borrow()[expr.id].clone() == ast::CaptureByRef {\n-                ty::with_freevars(tcx, expr.id, |freevars| {\n-                    propagate_upupvar_borrow_kind(rcx, expr, freevars);\n-                });\n-            }\n-        }\n-        _ => {}\n-    }\n-\n     match function_type.sty {\n         ty::ty_closure(box ty::ClosureTy {ref bounds, ..}) => {\n             ty::with_freevars(tcx, expr.id, |freevars| {\n@@ -930,7 +853,6 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         freevars: &[ty::Freevar])\n     {\n         let tcx = rcx.fcx.ccx.tcx;\n-        let infcx = rcx.fcx.infcx();\n         debug!(\"constrain_free_variables({}, {})\",\n                region_bound.repr(tcx), expr.repr(tcx));\n         for freevar in freevars.iter() {\n@@ -946,20 +868,10 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             let upvar_id = ty::UpvarId { var_id: var_node_id,\n                                          closure_expr_id: expr.id };\n \n-            // Create a region variable to represent this borrow. This borrow\n-            // must outlive the region on the closure.\n-            let origin = infer::UpvarRegion(upvar_id, expr.span);\n-            let freevar_region = infcx.next_region_var(origin);\n-            rcx.fcx.mk_subr(infer::FreeVariable(freevar.span, var_node_id),\n-                            region_bound, freevar_region);\n+            let upvar_borrow = rcx.fcx.inh.upvar_borrow_map.borrow()[upvar_id];\n \n-            // Create a UpvarBorrow entry. Note that we begin with a\n-            // const borrow_kind, but change it to either mut or\n-            // immutable as dictated by the uses.\n-            let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow,\n-                                                 region: freevar_region };\n-            rcx.fcx.inh.upvar_borrow_map.borrow_mut().insert(upvar_id,\n-                                                             upvar_borrow);\n+            rcx.fcx.mk_subr(infer::FreeVariable(freevar.span, var_node_id),\n+                            region_bound, upvar_borrow.region);\n \n             // Guarantee that the closure does not outlive the variable itself.\n             let enclosing_region = region_of_def(rcx.fcx, def);\n@@ -968,52 +880,6 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                             region_bound, enclosing_region);\n         }\n     }\n-\n-    fn propagate_upupvar_borrow_kind(rcx: &mut Rcx,\n-                                     expr: &ast::Expr,\n-                                     freevars: &[ty::Freevar]) {\n-        let tcx = rcx.fcx.ccx.tcx;\n-        debug!(\"propagate_upupvar_borrow_kind({})\", expr.repr(tcx));\n-        for freevar in freevars.iter() {\n-            // Because of the semi-hokey way that we are doing\n-            // borrow_kind inference, we need to check for\n-            // indirect dependencies, like so:\n-            //\n-            //     let mut x = 0;\n-            //     outer_call(|| {\n-            //         inner_call(|| {\n-            //             x = 1;\n-            //         });\n-            //     });\n-            //\n-            // Here, the `inner_call` is basically \"reborrowing\" the\n-            // outer pointer. With no other changes, `inner_call`\n-            // would infer that it requires a mutable borrow, but\n-            // `outer_call` would infer that a const borrow is\n-            // sufficient. This is because we haven't linked the\n-            // borrow_kind of the borrow that occurs in the inner\n-            // closure to the borrow_kind of the borrow in the outer\n-            // closure. Note that regions *are* naturally linked\n-            // because we have a proper inference scheme there.\n-            //\n-            // Anyway, for borrow_kind, we basically go back over now\n-            // after checking the inner closure (and hence\n-            // determining the final borrow_kind) and propagate that as\n-            // a constraint on the outer closure.\n-            if let def::DefUpvar(var_id, outer_closure_id, _) = freevar.def {\n-                // thing being captured is itself an upvar:\n-                let outer_upvar_id = ty::UpvarId {\n-                    var_id: var_id,\n-                    closure_expr_id: outer_closure_id };\n-                let inner_upvar_id = ty::UpvarId {\n-                    var_id: var_id,\n-                    closure_expr_id: expr.id };\n-                link_upvar_borrow_kind_for_nested_closures(rcx,\n-                                                           inner_upvar_id,\n-                                                           outer_upvar_id);\n-            }\n-        }\n-    }\n }\n \n fn constrain_callee(rcx: &mut Rcx,\n@@ -1491,14 +1357,6 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                 rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n             match upvar_borrow_map.get_mut(upvar_id) {\n                 Some(upvar_borrow) => {\n-                    // Adjust mutability that we infer for the upvar\n-                    // so it can accommodate being borrowed with\n-                    // mutability `kind`:\n-                    adjust_upvar_borrow_kind_for_loan(rcx,\n-                                                      *upvar_id,\n-                                                      upvar_borrow,\n-                                                      borrow_kind);\n-\n                     // The mutability of the upvar may have been modified\n                     // by the above adjustment, so update our local variable.\n                     ref_kind = upvar_borrow.kind;\n@@ -1583,27 +1441,6 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n             // else the user is borrowed imm memory as mut memory,\n             // which means they'll get an error downstream in borrowck\n             // anyhow.)\n-            //\n-            // If mutability was inferred from an upvar, we may be\n-            // forced to revisit this decision later if processing\n-            // another borrow or nested closure ends up converting the\n-            // upvar borrow kind to mutable/unique.  Record the\n-            // information needed to perform the recursive link in the\n-            // maybe link map.\n-            if let mc::NoteUpvarRef(upvar_id) = note {\n-                let link = MaybeLink {\n-                    span: span,\n-                    borrow_region: borrow_region,\n-                    borrow_kind: new_borrow_kind,\n-                    borrow_cmt: ref_cmt\n-                };\n-\n-                match rcx.maybe_links.borrow_mut().entry(upvar_id) {\n-                    Vacant(entry) => { entry.set(vec![link]); }\n-                    Occupied(entry) => { entry.into_mut().push(link); }\n-                }\n-            }\n-\n             return None;\n         }\n \n@@ -1615,178 +1452,6 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     }\n }\n \n-/// Adjusts the inferred borrow_kind as needed to account for upvars that are assigned to in an\n-/// assignment expression.\n-fn adjust_borrow_kind_for_assignment_lhs(rcx: &Rcx,\n-                                         lhs: &ast::Expr) {\n-    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-    let cmt = mc.cat_expr(lhs);\n-    adjust_upvar_borrow_kind_for_mut(rcx, cmt);\n-}\n-\n-/// Indicates that `cmt` is being directly mutated (e.g., assigned to). If cmt contains any by-ref\n-/// upvars, this implies that those upvars must be borrowed using an `&mut` borow.\n-fn adjust_upvar_borrow_kind_for_mut<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                                              cmt: mc::cmt<'tcx>) {\n-    let mut cmt = cmt;\n-    loop {\n-        debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={})\",\n-               cmt.repr(rcx.tcx()));\n-\n-        match cmt.cat.clone() {\n-            mc::cat_deref(base, _, mc::Unique) |\n-            mc::cat_interior(base, _) |\n-            mc::cat_downcast(base, _) => {\n-                // Interior or owned data is mutable if base is\n-                // mutable, so iterate to the base.\n-                cmt = base;\n-                continue;\n-            }\n-\n-            mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n-            mc::cat_deref(base, _, mc::Implicit(..)) => {\n-                if let mc::NoteUpvarRef(ref upvar_id) = cmt.note {\n-                    // if this is an implicit deref of an\n-                    // upvar, then we need to modify the\n-                    // borrow_kind of the upvar to make sure it\n-                    // is inferred to mutable if necessary\n-                    let mut upvar_borrow_map =\n-                        rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-                    let ub = &mut (*upvar_borrow_map)[*upvar_id];\n-                    return adjust_upvar_borrow_kind(rcx, *upvar_id, ub, ty::MutBorrow);\n-                }\n-\n-                // assignment to deref of an `&mut`\n-                // borrowed pointer implies that the\n-                // pointer itself must be unique, but not\n-                // necessarily *mutable*\n-                return adjust_upvar_borrow_kind_for_unique(rcx, base);\n-            }\n-\n-            mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n-            mc::cat_static_item |\n-            mc::cat_rvalue(_) |\n-            mc::cat_local(_) |\n-            mc::cat_upvar(..) => {\n-                return;\n-            }\n-        }\n-    }\n-}\n-\n-fn adjust_upvar_borrow_kind_for_unique<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>, cmt: mc::cmt<'tcx>) {\n-    let mut cmt = cmt;\n-    loop {\n-        debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={})\",\n-               cmt.repr(rcx.tcx()));\n-\n-        match cmt.cat.clone() {\n-            mc::cat_deref(base, _, mc::Unique) |\n-            mc::cat_interior(base, _) |\n-            mc::cat_downcast(base, _) => {\n-                // Interior or owned data is unique if base is\n-                // unique.\n-                cmt = base;\n-                continue;\n-            }\n-\n-            mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n-            mc::cat_deref(base, _, mc::Implicit(..)) => {\n-                if let mc::NoteUpvarRef(ref upvar_id) = cmt.note {\n-                    // if this is an implicit deref of an\n-                    // upvar, then we need to modify the\n-                    // borrow_kind of the upvar to make sure it\n-                    // is inferred to unique if necessary\n-                    let mut ub = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-                    let ub = &mut (*ub)[*upvar_id];\n-                    return adjust_upvar_borrow_kind(rcx, *upvar_id, ub, ty::UniqueImmBorrow);\n-                }\n-\n-                // for a borrowed pointer to be unique, its\n-                // base must be unique\n-                return adjust_upvar_borrow_kind_for_unique(rcx, base);\n-            }\n-\n-            mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n-            mc::cat_static_item |\n-            mc::cat_rvalue(_) |\n-            mc::cat_local(_) |\n-            mc::cat_upvar(..) => {\n-                return;\n-            }\n-        }\n-    }\n-}\n-\n-/// Indicates that the borrow_kind of `outer_upvar_id` must permit a reborrowing with the\n-/// borrow_kind of `inner_upvar_id`. This occurs in nested closures, see comment above at the call\n-/// to this function.\n-fn link_upvar_borrow_kind_for_nested_closures(rcx: &mut Rcx,\n-                                              inner_upvar_id: ty::UpvarId,\n-                                              outer_upvar_id: ty::UpvarId) {\n-    debug!(\"link_upvar_borrow_kind: inner_upvar_id={} outer_upvar_id={}\",\n-           inner_upvar_id, outer_upvar_id);\n-\n-    let mut upvar_borrow_map = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-    let inner_borrow = upvar_borrow_map[inner_upvar_id].clone();\n-    match upvar_borrow_map.get_mut(&outer_upvar_id) {\n-        Some(outer_borrow) => {\n-            adjust_upvar_borrow_kind(rcx, outer_upvar_id, outer_borrow, inner_borrow.kind);\n-        }\n-        None => { /* outer closure is not a stack closure */ }\n-    }\n-}\n-\n-fn adjust_upvar_borrow_kind_for_loan(rcx: &Rcx,\n-                                     upvar_id: ty::UpvarId,\n-                                     upvar_borrow: &mut ty::UpvarBorrow,\n-                                     kind: ty::BorrowKind) {\n-    debug!(\"adjust_upvar_borrow_kind_for_loan: upvar_id={} kind={} -> {}\",\n-           upvar_id, upvar_borrow.kind, kind);\n-\n-    adjust_upvar_borrow_kind(rcx, upvar_id, upvar_borrow, kind)\n-}\n-\n-/// We infer the borrow_kind with which to borrow upvars in a stack closure. The borrow_kind\n-/// basically follows a lattice of `imm < unique-imm < mut`, moving from left to right as needed\n-/// (but never right to left). Here the argument `mutbl` is the borrow_kind that is required by\n-/// some particular use.\n-fn adjust_upvar_borrow_kind(rcx: &Rcx,\n-                            upvar_id: ty::UpvarId,\n-                            upvar_borrow: &mut ty::UpvarBorrow,\n-                            kind: ty::BorrowKind) {\n-    debug!(\"adjust_upvar_borrow_kind: id={} kind=({} -> {})\",\n-           upvar_id, upvar_borrow.kind, kind);\n-\n-    match (upvar_borrow.kind, kind) {\n-        // Take RHS:\n-        (ty::ImmBorrow, ty::UniqueImmBorrow) |\n-        (ty::ImmBorrow, ty::MutBorrow) |\n-        (ty::UniqueImmBorrow, ty::MutBorrow) => {\n-            upvar_borrow.kind = kind;\n-\n-            // Check if there are any region links we now need to\n-            // establish due to adjusting the borrow kind of the upvar\n-            match rcx.maybe_links.borrow_mut().entry(upvar_id) {\n-                Occupied(entry) => {\n-                    for MaybeLink { span, borrow_region,\n-                                    borrow_kind, borrow_cmt } in entry.take().into_iter()\n-                    {\n-                        link_region(rcx, span, borrow_region, borrow_kind, borrow_cmt);\n-                    }\n-                }\n-                Vacant(_) => {}\n-            }\n-        }\n-        // Take LHS:\n-        (ty::ImmBorrow, ty::ImmBorrow) |\n-        (ty::UniqueImmBorrow, ty::ImmBorrow) |\n-        (ty::UniqueImmBorrow, ty::UniqueImmBorrow) |\n-        (ty::MutBorrow, _) => {\n-        }\n-    }\n-}\n-\n /// Ensures that all borrowed data reachable via `ty` outlives `region`.\n fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                origin: infer::SubregionOrigin<'tcx>,"}, {"sha": "a4c3550fcd676d4c6c9cc2efe0eef8847a9b8376", "filename": "src/librustc_typeck/check/upvar.rs", "status": "added", "additions": 373, "deletions": 0, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/ecd9c10e1aa88f2ec3251c33903d9c2622b0bf37/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd9c10e1aa88f2ec3251c33903d9c2622b0bf37/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=ecd9c10e1aa88f2ec3251c33903d9c2622b0bf37", "patch": "@@ -0,0 +1,373 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! ### Inferring borrow kinds for upvars\n+//!\n+//! Whenever there is a closure expression, we need to determine how each\n+//! upvar is used. We do this by initially assigning each upvar an\n+//! immutable \"borrow kind\" (see `ty::BorrowKind` for details) and then\n+//! \"escalating\" the kind as needed. The borrow kind proceeds according to\n+//! the following lattice:\n+//!\n+//!     ty::ImmBorrow -> ty::UniqueImmBorrow -> ty::MutBorrow\n+//!\n+//! So, for example, if we see an assignment `x = 5` to an upvar `x`, we\n+//! will promote its borrow kind to mutable borrow. If we see an `&mut x`\n+//! we'll do the same. Naturally, this applies not just to the upvar, but\n+//! to everything owned by `x`, so the result is the same for something\n+//! like `x.f = 5` and so on (presuming `x` is not a borrowed pointer to a\n+//! struct). These adjustments are performed in\n+//! `adjust_upvar_borrow_kind()` (you can trace backwards through the code\n+//! from there).\n+//!\n+//! The fact that we are inferring borrow kinds as we go results in a\n+//! semi-hacky interaction with mem-categorization. In particular,\n+//! mem-categorization will query the current borrow kind as it\n+//! categorizes, and we'll return the *current* value, but this may get\n+//! adjusted later. Therefore, in this module, we generally ignore the\n+//! borrow kind (and derived mutabilities) that are returned from\n+//! mem-categorization, since they may be inaccurate. (Another option\n+//! would be to use a unification scheme, where instead of returning a\n+//! concrete borrow kind like `ty::ImmBorrow`, we return a\n+//! `ty::InferBorrow(upvar_id)` or something like that, but this would\n+//! then mean that all later passes would have to check for these figments\n+//! and report an error, and it just seems like more mess in the end.)\n+\n+use super::FnCtxt;\n+\n+use middle::expr_use_visitor as euv;\n+use middle::mem_categorization as mc;\n+use middle::ty::{mod};\n+use middle::infer::{InferCtxt, UpvarRegion};\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use syntax::visit::{mod, Visitor};\n+use util::ppaux::Repr;\n+\n+///////////////////////////////////////////////////////////////////////////\n+// PUBLIC ENTRY POINTS\n+\n+pub fn closure_analyze_fn(fcx: &FnCtxt,\n+                          _id: ast::NodeId,\n+                          decl: &ast::FnDecl,\n+                          body: &ast::Block) {\n+    let mut seed = SeedBorrowKind::new(fcx);\n+    seed.visit_block(body);\n+\n+    let mut adjust = AdjustBorrowKind::new(fcx);\n+    adjust.analyze_fn(decl, body);\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// SEED BORROW KIND\n+\n+struct SeedBorrowKind<'a,'tcx:'a> {\n+    fcx: &'a FnCtxt<'a,'tcx>,\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &ast::Expr) {\n+        match expr.node {\n+            ast::ExprClosure(cc, _, _, ref body) => {\n+                self.check_closure(expr, cc, &**body);\n+            }\n+\n+            _ => { }\n+        }\n+\n+        visit::walk_expr(self, expr);\n+    }\n+\n+    fn visit_fn(&mut self,\n+                fn_kind: visit::FnKind<'v>,\n+                decl: &'v ast::FnDecl,\n+                block: &'v ast::Block,\n+                span: Span,\n+                _id: ast::NodeId)\n+    {\n+        match fn_kind {\n+            visit::FkItemFn(..) | visit::FkMethod(..) => {\n+                // ignore nested fn items\n+            }\n+            visit::FkFnBlock => {\n+                visit::walk_fn(self, fn_kind, decl, block, span);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n+    fn new(fcx: &'a FnCtxt<'a,'tcx>) -> SeedBorrowKind<'a,'tcx> {\n+        SeedBorrowKind { fcx: fcx }\n+    }\n+\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.fcx.tcx()\n+    }\n+\n+    fn infcx(&self) -> &'a InferCtxt<'a,'tcx> {\n+        self.fcx.infcx()\n+    }\n+\n+    fn check_closure(&mut self,\n+                     expr: &ast::Expr,\n+                     capture_clause: ast::CaptureClause,\n+                     _body: &ast::Block)\n+    {\n+        let is_old_skool_closure = match self.fcx.expr_ty(expr).sty {\n+            ty::ty_closure(..) => true,\n+            _ => false,\n+        };\n+\n+        match capture_clause {\n+            ast::CaptureByValue if !is_old_skool_closure => {\n+            }\n+            _ => {\n+                ty::with_freevars(self.tcx(), expr.id, |freevars| {\n+                    for freevar in freevars.iter() {\n+                        let var_node_id = freevar.def.local_node_id();\n+                        let upvar_id = ty::UpvarId { var_id: var_node_id,\n+                                                     closure_expr_id: expr.id };\n+                        debug!(\"seed upvar_id {}\", upvar_id);\n+                        let origin = UpvarRegion(upvar_id, expr.span);\n+                        let freevar_region = self.infcx().next_region_var(origin);\n+                        let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow,\n+                                                             region: freevar_region };\n+                        self.fcx.inh.upvar_borrow_map.borrow_mut().insert(upvar_id,\n+                                                                          upvar_borrow);\n+                    }\n+                });\n+            }\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// ADJUST BORROW KIND\n+\n+struct AdjustBorrowKind<'a,'tcx:'a> {\n+    fcx: &'a FnCtxt<'a,'tcx>\n+}\n+\n+impl<'a,'tcx> AdjustBorrowKind<'a,'tcx>{\n+    fn new(fcx: &'a FnCtxt<'a,'tcx>) -> AdjustBorrowKind<'a,'tcx> {\n+        AdjustBorrowKind { fcx: fcx }\n+    }\n+\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.fcx.tcx()\n+    }\n+\n+    fn analyze_fn(&mut self, decl: &ast::FnDecl, body: &ast::Block) {\n+        /*!\n+         * Analysis starting point.\n+         */\n+\n+        self.visit_block(body);\n+\n+        debug!(\"analyzing fn body with id {}\", body.id);\n+\n+        let mut euv = euv::ExprUseVisitor::new(self, self.fcx);\n+        euv.walk_fn(decl, body);\n+    }\n+\n+    /// Indicates that `cmt` is being directly mutated (e.g., assigned\n+    /// to). If cmt contains any by-ref upvars, this implies that\n+    /// those upvars must be borrowed using an `&mut` borow.\n+    fn adjust_upvar_borrow_kind_for_mut(&mut self, cmt: mc::cmt<'tcx>) {\n+        debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={})\",\n+               cmt.repr(self.tcx()));\n+\n+        match cmt.cat.clone() {\n+            mc::cat_deref(base, _, mc::Unique) |\n+            mc::cat_interior(base, _) |\n+            mc::cat_downcast(base, _) => {\n+                // Interior or owned data is mutable if base is\n+                // mutable, so iterate to the base.\n+                self.adjust_upvar_borrow_kind_for_mut(base);\n+            }\n+\n+            mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n+            mc::cat_deref(base, _, mc::Implicit(..)) => {\n+                if let mc::NoteUpvarRef(upvar_id) = cmt.note {\n+                    // if this is an implicit deref of an\n+                    // upvar, then we need to modify the\n+                    // borrow_kind of the upvar to make sure it\n+                    // is inferred to mutable if necessary\n+                    let mut upvar_borrow_map = self.fcx.inh.upvar_borrow_map.borrow_mut();\n+                    let ub = &mut upvar_borrow_map[upvar_id];\n+                    self.adjust_upvar_borrow_kind(upvar_id, ub, ty::MutBorrow);\n+                } else {\n+                    // assignment to deref of an `&mut`\n+                    // borrowed pointer implies that the\n+                    // pointer itself must be unique, but not\n+                    // necessarily *mutable*\n+                    self.adjust_upvar_borrow_kind_for_unique(base);\n+                }\n+            }\n+\n+            mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n+            mc::cat_static_item |\n+            mc::cat_rvalue(_) |\n+            mc::cat_local(_) |\n+            mc::cat_upvar(..) => {\n+                return;\n+            }\n+        }\n+    }\n+\n+    fn adjust_upvar_borrow_kind_for_unique(&self, cmt: mc::cmt<'tcx>) {\n+        debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={})\",\n+               cmt.repr(self.tcx()));\n+\n+        match cmt.cat.clone() {\n+            mc::cat_deref(base, _, mc::Unique) |\n+            mc::cat_interior(base, _) |\n+            mc::cat_downcast(base, _) => {\n+                // Interior or owned data is unique if base is\n+                // unique.\n+                self.adjust_upvar_borrow_kind_for_unique(base);\n+            }\n+\n+            mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n+            mc::cat_deref(base, _, mc::Implicit(..)) => {\n+                if let mc::NoteUpvarRef(upvar_id) = cmt.note {\n+                    // if this is an implicit deref of an\n+                    // upvar, then we need to modify the\n+                    // borrow_kind of the upvar to make sure it\n+                    // is inferred to unique if necessary\n+                    let mut ub = self.fcx.inh.upvar_borrow_map.borrow_mut();\n+                    let ub = &mut ub[upvar_id];\n+                    self.adjust_upvar_borrow_kind(upvar_id, ub, ty::UniqueImmBorrow);\n+                } else {\n+                    // for a borrowed pointer to be unique, its\n+                    // base must be unique\n+                    self.adjust_upvar_borrow_kind_for_unique(base);\n+                }\n+            }\n+\n+            mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n+            mc::cat_static_item |\n+            mc::cat_rvalue(_) |\n+            mc::cat_local(_) |\n+            mc::cat_upvar(..) => {\n+            }\n+        }\n+    }\n+\n+    /// We infer the borrow_kind with which to borrow upvars in a stack closure. The borrow_kind\n+    /// basically follows a lattice of `imm < unique-imm < mut`, moving from left to right as needed\n+    /// (but never right to left). Here the argument `mutbl` is the borrow_kind that is required by\n+    /// some particular use.\n+    fn adjust_upvar_borrow_kind(&self,\n+                                upvar_id: ty::UpvarId,\n+                                upvar_borrow: &mut ty::UpvarBorrow,\n+                                kind: ty::BorrowKind) {\n+        debug!(\"adjust_upvar_borrow_kind: id={} kind=({} -> {})\",\n+               upvar_id, upvar_borrow.kind, kind);\n+\n+        match (upvar_borrow.kind, kind) {\n+            // Take RHS:\n+            (ty::ImmBorrow, ty::UniqueImmBorrow) |\n+            (ty::ImmBorrow, ty::MutBorrow) |\n+            (ty::UniqueImmBorrow, ty::MutBorrow) => {\n+                upvar_borrow.kind = kind;\n+            }\n+            // Take LHS:\n+            (ty::ImmBorrow, ty::ImmBorrow) |\n+            (ty::UniqueImmBorrow, ty::ImmBorrow) |\n+            (ty::UniqueImmBorrow, ty::UniqueImmBorrow) |\n+            (ty::MutBorrow, _) => {\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for AdjustBorrowKind<'a, 'tcx> {\n+    fn visit_fn(&mut self,\n+                fn_kind: visit::FnKind<'v>,\n+                decl: &'v ast::FnDecl,\n+                body: &'v ast::Block,\n+                span: Span,\n+                _id: ast::NodeId)\n+    {\n+        match fn_kind {\n+            visit::FkItemFn(..) | visit::FkMethod(..) => {\n+                // ignore nested fn items\n+            }\n+            visit::FkFnBlock => {\n+                self.analyze_fn(decl, body);\n+                visit::walk_fn(self, fn_kind, decl, body, span);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n+    fn consume(&mut self,\n+               _consume_id: ast::NodeId,\n+               _consume_span: Span,\n+               _cmt: mc::cmt<'tcx>,\n+               _mode: euv::ConsumeMode)\n+    {}\n+\n+    fn matched_pat(&mut self,\n+                   _matched_pat: &ast::Pat,\n+                   _cmt: mc::cmt<'tcx>,\n+                   _mode: euv::MatchMode)\n+    {}\n+\n+    fn consume_pat(&mut self,\n+                   _consume_pat: &ast::Pat,\n+                   _cmt: mc::cmt<'tcx>,\n+                   _mode: euv::ConsumeMode)\n+    {}\n+\n+    fn borrow(&mut self,\n+              borrow_id: ast::NodeId,\n+              _borrow_span: Span,\n+              cmt: mc::cmt<'tcx>,\n+              _loan_region: ty::Region,\n+              bk: ty::BorrowKind,\n+              _loan_cause: euv::LoanCause)\n+    {\n+        debug!(\"borrow(borrow_id={}, cmt={}, bk={})\",\n+               borrow_id, cmt.repr(self.tcx()), bk);\n+\n+        match bk {\n+            ty::ImmBorrow => { }\n+            ty::UniqueImmBorrow => {\n+                self.adjust_upvar_borrow_kind_for_unique(cmt);\n+            }\n+            ty::MutBorrow => {\n+                self.adjust_upvar_borrow_kind_for_mut(cmt);\n+            }\n+        }\n+    }\n+\n+    fn decl_without_init(&mut self,\n+                         _id: ast::NodeId,\n+                         _span: Span)\n+    {}\n+\n+    fn mutate(&mut self,\n+              _assignment_id: ast::NodeId,\n+              _assignment_span: Span,\n+              assignee_cmt: mc::cmt<'tcx>,\n+              _mode: euv::MutateMode)\n+    {\n+        debug!(\"mutate(assignee_cmt={})\",\n+               assignee_cmt.repr(self.tcx()));\n+\n+        self.adjust_upvar_borrow_kind_for_mut(assignee_cmt);\n+    }\n+}\n+\n+"}]}