{"sha": "0f20c9d8b7bd63b8e62db5fde172651d71580ec9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMjBjOWQ4YjdiZDYzYjhlNjJkYjVmZGUxNzI2NTFkNzE1ODBlYzk=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-20T17:33:13Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-20T17:33:57Z"}, "message": "Remove feature gated examples from the reference.\n\nThe slice patterns example was nice, so let's put it with the other\nslice pattern feature gate documentation.\n\nFixes #24573", "tree": {"sha": "d52f0ecd8b8a49c9369d6737952bd022bfc85d47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d52f0ecd8b8a49c9369d6737952bd022bfc85d47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f20c9d8b7bd63b8e62db5fde172651d71580ec9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f20c9d8b7bd63b8e62db5fde172651d71580ec9", "html_url": "https://github.com/rust-lang/rust/commit/0f20c9d8b7bd63b8e62db5fde172651d71580ec9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f20c9d8b7bd63b8e62db5fde172651d71580ec9/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5910dc0e8e396a4af7b948b83bab03f27b414a0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5910dc0e8e396a4af7b948b83bab03f27b414a0e", "html_url": "https://github.com/rust-lang/rust/commit/5910dc0e8e396a4af7b948b83bab03f27b414a0e"}], "stats": {"total": 161, "additions": 46, "deletions": 115}, "files": [{"sha": "d918a320e63a909c3298c213cb2188ddab0492b0", "filename": "src/doc/reference.md", "status": "modified", "additions": 22, "deletions": 115, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/0f20c9d8b7bd63b8e62db5fde172651d71580ec9/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f20c9d8b7bd63b8e62db5fde172651d71580ec9/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=0f20c9d8b7bd63b8e62db5fde172651d71580ec9", "patch": "@@ -973,8 +973,7 @@ Use declarations support a number of convenient shortcuts:\n \n An example of `use` declarations:\n \n-```\n-# #![feature(core)]\n+```rust\n use std::option::Option::{Some, None};\n use std::collections::hash_map::{self, HashMap};\n \n@@ -1031,16 +1030,17 @@ declarations.\n An example of what will and will not work for `use` items:\n \n ```\n-# #![feature(core)]\n # #![allow(unused_imports)]\n-use foo::core::iter;  // good: foo is at the root of the crate\n use foo::baz::foobaz;    // good: foo is at the root of the crate\n \n mod foo {\n-    extern crate core;\n \n-    use foo::core::iter; // good: foo is at crate root\n-//  use core::iter;      // bad:  core is not at the crate root\n+    mod example {\n+        pub mod iter {}\n+    }\n+\n+    use foo::example::iter; // good: foo is at crate root\n+//  use example::iter;      // bad:  core is not at the crate root\n     use self::baz::foobaz;  // good: self refers to module 'foo'\n     use foo::bar::foobar;   // good: foo is at crate root\n \n@@ -1368,17 +1368,14 @@ a = Animal::Cat;\n \n Enumeration constructors can have either named or unnamed fields:\n \n-```\n-# #![feature(struct_variant)]\n-# fn main() {\n+```rust\n enum Animal {\n     Dog (String, f64),\n     Cat { name: String, weight: f64 }\n }\n \n let mut a: Animal = Animal::Dog(\"Cocoa\".to_string(), 37.2);\n a = Animal::Cat { name: \"Spotty\".to_string(), weight: 2.7 };\n-# }\n ```\n \n In this example, `Cat` is a _struct-like enum variant_,\n@@ -1718,17 +1715,6 @@ Functions within external blocks are declared in the same way as other Rust\n functions, with the exception that they may not have a body and are instead\n terminated by a semicolon.\n \n-```\n-# #![feature(libc)]\n-extern crate libc;\n-use libc::{c_char, FILE};\n-\n-extern {\n-    fn fopen(filename: *const c_char, mode: *const c_char) -> *mut FILE;\n-}\n-# fn main() {}\n-```\n-\n Functions within external blocks may be called by Rust code, just like\n functions defined in Rust. The Rust compiler automatically translates between\n the Rust ABI and the foreign ABI.\n@@ -1739,7 +1725,7 @@ By default external blocks assume that the library they are calling uses the\n standard C \"cdecl\" ABI. Other ABIs may be specified using an `abi` string, as\n shown here:\n \n-```{.ignore}\n+```ignore\n // Interface to the Windows API\n extern \"stdcall\" { }\n ```\n@@ -3231,55 +3217,7 @@ expression.\n \n In a pattern whose head expression has an `enum` type, a placeholder (`_`)\n stands for a *single* data field, whereas a wildcard `..` stands for *all* the\n-fields of a particular variant. For example:\n-\n-```\n-#![feature(box_patterns)]\n-#![feature(box_syntax)]\n-enum List<X> { Nil, Cons(X, Box<List<X>>) }\n-\n-fn main() {\n-    let x: List<i32> = List::Cons(10, box List::Cons(11, box List::Nil));\n-\n-    match x {\n-        List::Cons(_, box List::Nil) => panic!(\"singleton list\"),\n-        List::Cons(..)               => return,\n-        List::Nil                    => panic!(\"empty list\")\n-    }\n-}\n-```\n-\n-The first pattern matches lists constructed by applying `Cons` to any head\n-value, and a tail value of `box Nil`. The second pattern matches _any_ list\n-constructed with `Cons`, ignoring the values of its arguments. The difference\n-between `_` and `..` is that the pattern `C(_)` is only type-correct if `C` has\n-exactly one argument, while the pattern `C(..)` is type-correct for any enum\n-variant `C`, regardless of how many arguments `C` has.\n-\n-Used inside an array pattern, `..` stands for any number of elements, when the\n-`advanced_slice_patterns` feature gate is turned on. This wildcard can be used\n-at most once for a given array, which implies that it cannot be used to\n-specifically match elements that are at an unknown distance from both ends of a\n-array, like `[.., 42, ..]`. If preceded by a variable name, it will bind the\n-corresponding slice to the variable. Example:\n-\n-```\n-# #![feature(advanced_slice_patterns, slice_patterns)]\n-fn is_symmetric(list: &[u32]) -> bool {\n-    match list {\n-        [] | [_]                   => true,\n-        [x, inside.., y] if x == y => is_symmetric(inside),\n-        _                          => false\n-    }\n-}\n-\n-fn main() {\n-    let sym     = &[0, 1, 4, 2, 4, 1, 0];\n-    let not_sym = &[0, 1, 7, 2, 4, 1, 0];\n-    assert!(is_symmetric(sym));\n-    assert!(!is_symmetric(not_sym));\n-}\n-```\n+fields of a particular variant.\n \n A `match` behaves differently depending on whether or not the head expression\n is an [lvalue or an rvalue](#lvalues,-rvalues-and-temporaries). If the head\n@@ -3298,30 +3236,15 @@ the inside of the match.\n An example of a `match` expression:\n \n ```\n-#![feature(box_patterns)]\n-#![feature(box_syntax)]\n-# fn process_pair(a: i32, b: i32) { }\n-# fn process_ten() { }\n-\n-enum List<X> { Nil, Cons(X, Box<List<X>>) }\n-\n-fn main() {\n-    let x: List<i32> = List::Cons(10, box List::Cons(11, box List::Nil));\n+let x = 1;\n \n-    match x {\n-        List::Cons(a, box List::Cons(b, _)) => {\n-            process_pair(a, b);\n-        }\n-        List::Cons(10, _) => {\n-            process_ten();\n-        }\n-        List::Nil => {\n-            return;\n-        }\n-        _ => {\n-            panic!();\n-        }\n-    }\n+match x {\n+    1 => println!(\"one\"),\n+    2 => println!(\"two\"),\n+    3 => println!(\"three\"),\n+    4 => println!(\"four\"),\n+    5 => println!(\"five\"),\n+    _ => println!(\"something else\"),\n }\n ```\n \n@@ -3334,28 +3257,12 @@ Subpatterns can also be bound to variables by the use of the syntax `variable @\n subpattern`. For example:\n \n ```\n-#![feature(box_patterns)]\n-#![feature(box_syntax)]\n-\n-enum List { Nil, Cons(u32, Box<List>) }\n+let x = 1;\n \n-fn is_sorted(list: &List) -> bool {\n-    match *list {\n-        List::Nil | List::Cons(_, box List::Nil) => true,\n-        List::Cons(x, ref r @ box List::Cons(_, _)) => {\n-            match *r {\n-                box List::Cons(y, _) => (x <= y) && is_sorted(&**r),\n-                _ => panic!()\n-            }\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let a = List::Cons(6, box List::Cons(7, box List::Cons(42, box List::Nil)));\n-    assert!(is_sorted(&a));\n+match x {\n+    e @ 1 ... 5 => println!(\"got a range element {}\", e),\n+    _ => println!(\"anything\"),\n }\n-\n ```\n \n Patterns can also dereference pointers by using the `&`, `&mut` and `box`"}, {"sha": "de165b70fc4028d5846fa4bc8384bc21dea0d966", "filename": "src/doc/trpl/slice-patterns.md", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f20c9d8b7bd63b8e62db5fde172651d71580ec9/src%2Fdoc%2Ftrpl%2Fslice-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f20c9d8b7bd63b8e62db5fde172651d71580ec9/src%2Fdoc%2Ftrpl%2Fslice-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fslice-patterns.md?ref=0f20c9d8b7bd63b8e62db5fde172651d71580ec9", "patch": "@@ -16,3 +16,27 @@ fn main() {\n }\n ```\n \n+The `advanced_slice_patterns` gate lets you use `..` to indicate any number of\n+elements inside a pattern matching a slice. This wildcard can only be used once\n+for a given array. If there's an identifier before the `..`, the result of the\n+slice will be bound to that name. For example:\n+\n+```rust\n+#![feature(advanced_slice_patterns, slice_patterns)]\n+\n+fn is_symmetric(list: &[u32]) -> bool {\n+    match list {\n+        [] | [_] => true,\n+        [x, inside.., y] if x == y => is_symmetric(inside),\n+        _ => false\n+    }\n+}\n+\n+fn main() {\n+    let sym = &[0, 1, 4, 2, 4, 1, 0];\n+    assert!(is_symmetric(sym));\n+\n+    let not_sym = &[0, 1, 7, 2, 4, 1, 0];\n+    assert!(!is_symmetric(not_sym));\n+}\n+```"}]}