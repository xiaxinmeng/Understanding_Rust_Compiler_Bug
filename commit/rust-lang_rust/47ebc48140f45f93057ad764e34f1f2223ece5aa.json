{"sha": "47ebc48140f45f93057ad764e34f1f2223ece5aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZWJjNDgxNDBmNDVmOTMwNTdhZDc2NGUzNGYxZjIyMjNlY2U1YWE=", "commit": {"author": {"name": "Raphael Speyer", "email": "rspeyer@gmail.com", "date": "2015-04-20T16:01:06Z"}, "committer": {"name": "Raphael Speyer", "email": "rspeyer@gmail.com", "date": "2015-04-23T16:43:23Z"}, "message": "Implement IntoIterator for Receiver", "tree": {"sha": "4969eb4946b431b410e80b53bfea7a5d46d74e96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4969eb4946b431b410e80b53bfea7a5d46d74e96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47ebc48140f45f93057ad764e34f1f2223ece5aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47ebc48140f45f93057ad764e34f1f2223ece5aa", "html_url": "https://github.com/rust-lang/rust/commit/47ebc48140f45f93057ad764e34f1f2223ece5aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47ebc48140f45f93057ad764e34f1f2223ece5aa/comments", "author": {"login": "rapha", "id": 29763, "node_id": "MDQ6VXNlcjI5NzYz", "avatar_url": "https://avatars.githubusercontent.com/u/29763?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rapha", "html_url": "https://github.com/rapha", "followers_url": "https://api.github.com/users/rapha/followers", "following_url": "https://api.github.com/users/rapha/following{/other_user}", "gists_url": "https://api.github.com/users/rapha/gists{/gist_id}", "starred_url": "https://api.github.com/users/rapha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rapha/subscriptions", "organizations_url": "https://api.github.com/users/rapha/orgs", "repos_url": "https://api.github.com/users/rapha/repos", "events_url": "https://api.github.com/users/rapha/events{/privacy}", "received_events_url": "https://api.github.com/users/rapha/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rapha", "id": 29763, "node_id": "MDQ6VXNlcjI5NzYz", "avatar_url": "https://avatars.githubusercontent.com/u/29763?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rapha", "html_url": "https://github.com/rapha", "followers_url": "https://api.github.com/users/rapha/followers", "following_url": "https://api.github.com/users/rapha/following{/other_user}", "gists_url": "https://api.github.com/users/rapha/gists{/gist_id}", "starred_url": "https://api.github.com/users/rapha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rapha/subscriptions", "organizations_url": "https://api.github.com/users/rapha/orgs", "repos_url": "https://api.github.com/users/rapha/repos", "events_url": "https://api.github.com/users/rapha/events{/privacy}", "received_events_url": "https://api.github.com/users/rapha/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c9636975cdc289e98ef8f33400969371c4ce1bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c9636975cdc289e98ef8f33400969371c4ce1bf", "html_url": "https://github.com/rust-lang/rust/commit/5c9636975cdc289e98ef8f33400969371c4ce1bf"}], "stats": {"total": 57, "additions": 57, "deletions": 0}, "files": [{"sha": "b3cc133d229465bf1a3a1b0bdfe988c800c1f02c", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/47ebc48140f45f93057ad764e34f1f2223ece5aa/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47ebc48140f45f93057ad764e34f1f2223ece5aa/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=47ebc48140f45f93057ad764e34f1f2223ece5aa", "patch": "@@ -306,6 +306,14 @@ pub struct Iter<'a, T: 'a> {\n     rx: &'a Receiver<T>\n }\n \n+/// An owning iterator over messages on a receiver, this iterator will block\n+/// whenever `next` is called, waiting for a new message, and `None` will be\n+/// returned when the corresponding channel has hung up.\n+#[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\n+pub struct IntoIter<T> {\n+    rx: Receiver<T>\n+}\n+\n /// The sending-half of Rust's asynchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -899,6 +907,29 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn next(&mut self) -> Option<T> { self.rx.recv().ok() }\n }\n \n+#[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\n+impl<'a, T> IntoIterator for &'a Receiver<T> {\n+    type Item = T;\n+    type IntoIter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> { self.iter() }\n+}\n+\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n+    fn next(&mut self) -> Option<T> { self.rx.recv().ok() }\n+}\n+\n+#[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\n+impl <T> IntoIterator for Receiver<T> {\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        IntoIter { rx: self }\n+    }\n+}\n+\n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Receiver<T> {\n@@ -1507,6 +1538,32 @@ mod test {\n         assert_eq!(count_rx.recv().unwrap(), 4);\n     }\n \n+    #[test]\n+    fn test_recv_into_iter_owned() {\n+        let mut iter = {\n+          let (tx, rx) = channel::<i32>();\n+          tx.send(1).unwrap();\n+          tx.send(2).unwrap();\n+\n+          rx.into_iter()\n+        };\n+        assert_eq!(iter.next().unwrap(), 1);\n+        assert_eq!(iter.next().unwrap(), 2);\n+        assert_eq!(iter.next().is_none(), true);\n+    }\n+\n+    #[test]\n+    fn test_recv_into_iter_borrowed() {\n+        let (tx, rx) = channel::<i32>();\n+        tx.send(1).unwrap();\n+        tx.send(2).unwrap();\n+        drop(tx);\n+        let mut iter = (&rx).into_iter();\n+        assert_eq!(iter.next().unwrap(), 1);\n+        assert_eq!(iter.next().unwrap(), 2);\n+        assert_eq!(iter.next().is_none(), true);\n+    }\n+\n     #[test]\n     fn try_recv_states() {\n         let (tx1, rx1) = channel::<i32>();"}]}