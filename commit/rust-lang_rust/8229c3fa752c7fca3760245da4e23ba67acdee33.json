{"sha": "8229c3fa752c7fca3760245da4e23ba67acdee33", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyMjljM2ZhNzUyYzdmY2EzNzYwMjQ1ZGE0ZTIzYmE2N2FjZGVlMzM=", "commit": {"author": {"name": "Rob Arnold", "email": "robarnold@cs.cmu.edu", "date": "2011-07-09T00:22:48Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-05T18:57:06Z"}, "message": "Update libuv to revision ee599ec1141cc48f895de1f9d148033babdf9c2a", "tree": {"sha": "ed2e83518503b901cadcb3dbac01f4a0dad67023", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed2e83518503b901cadcb3dbac01f4a0dad67023"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8229c3fa752c7fca3760245da4e23ba67acdee33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8229c3fa752c7fca3760245da4e23ba67acdee33", "html_url": "https://github.com/rust-lang/rust/commit/8229c3fa752c7fca3760245da4e23ba67acdee33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8229c3fa752c7fca3760245da4e23ba67acdee33/comments", "author": {"login": "robarnold", "id": 326113, "node_id": "MDQ6VXNlcjMyNjExMw==", "avatar_url": "https://avatars.githubusercontent.com/u/326113?v=4", "gravatar_id": "", "url": "https://api.github.com/users/robarnold", "html_url": "https://github.com/robarnold", "followers_url": "https://api.github.com/users/robarnold/followers", "following_url": "https://api.github.com/users/robarnold/following{/other_user}", "gists_url": "https://api.github.com/users/robarnold/gists{/gist_id}", "starred_url": "https://api.github.com/users/robarnold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/robarnold/subscriptions", "organizations_url": "https://api.github.com/users/robarnold/orgs", "repos_url": "https://api.github.com/users/robarnold/repos", "events_url": "https://api.github.com/users/robarnold/events{/privacy}", "received_events_url": "https://api.github.com/users/robarnold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "html_url": "https://github.com/rust-lang/rust/commit/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa"}], "stats": {"total": 38610, "additions": 37885, "deletions": 725}, "files": [{"sha": "a2f8e6c04c3fb3423ae56ed45ccd53d0e17a2ec8", "filename": "mk/rt.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -66,7 +66,7 @@ RUNTIME_HDR := rt/globals.h \\\n \n RUNTIME_DEF := rt/rustrt$(CFG_DEF_SUFFIX)\n RUNTIME_INCS := -I $(S)src/rt/isaac -I $(S)src/rt/uthash \\\n-                -I $(S)src/rt/arch/i386 -I $(S)src/rt/libuv\n+                -I $(S)src/rt/arch/i386 -I $(S)src/rt/libuv/include\n RUNTIME_OBJS := $(RUNTIME_CS:.cpp=.o) $(RUNTIME_LL:.ll=.o) $(RUNTIME_S:.s=.o)\n RUNTIME_LIBS := $(S)src/rt/libuv/uv.a\n \n@@ -97,7 +97,7 @@ rt/$(CFG_RUNTIME): $(RUNTIME_OBJS) $(MKFILES) $(RUNTIME_HDR) $(RUNTIME_DEF) $(RU\n \t@$(call E, link: $@)\n \t$(Q)$(call CFG_LINK_C,$@,$(CFG_GCCISH_POST_LIB_FLAGS) $(RUNTIME_LIBS) $(RUNTIME_OBJS),$(RUNTIME_DEF))\n \n-$(S)src/rt/libuv/uv.a: rt/libuv/LIBUV_REVISION\n+$(S)src/rt/libuv/uv.a: $(S)src/rt/libuv/LIBUV_REVISION\n \t$(Q)$(MAKE) -C $(S)src/rt/libuv CFLAGS=\\\"-m32\\\" LDFLAGS=\\\"-m32\\\"\n \t$(Q)mkdir -p rt/libuv\n \t$(Q)cp $(S)src/rt/libuv/uv.a rt/libuv/uv.a"}, {"sha": "9d142354bf381129ed8f1c86480624f84963f0c2", "filename": "src/rt/libuv/.gitignore", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2F.gitignore?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -26,3 +26,18 @@ test/run-tests.exe\n test/run-benchmarks.exe\n test/run-benchmarks.dSYM/\n test/run-tests.dSYM/\n+\n+\n+c-ares/.deps/\n+c-ares/.libs/\n+c-ares/Makefile\n+c-ares/acountry\n+c-ares/adig\n+c-ares/ahost\n+c-ares/ares_config.h\n+c-ares/config.log\n+c-ares/config.status\n+c-ares/libcares.pc\n+c-ares/libtool\n+c-ares/stamp-h1\n+c-ares/stamp-h2"}, {"sha": "4b4cab70f130cf12bee89c6def16c75efca5d966", "filename": "src/rt/libuv/AUTHORS", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2FAUTHORS", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2FAUTHORS", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2FAUTHORS?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -3,4 +3,9 @@ Ryan Dahl <ryan@joyent.com>\n Bert Belder <bertbelder@gmail.com>\n Josh Roesslein <jroesslein@gmail.com>\n Alan Gutierrez <alan@prettyrobots.com>\n+Igor Zinkovsky <igorzi@microsoft.com>\n Vanilla Hsu <vanilla@fatpipi.com>\n+Ben Noordhuis <info@bnoordhuis.nl>\n+Henry Rawas <henryr@schakra.com>\n+Robert Mustacchi <rm@joyent.com>\n+Matt Stevens <matt@alloysoft.com>"}, {"sha": "f079f65776527a1a85745d34350e0bafeb8e81f4", "filename": "src/rt/libuv/LIBUV_REVISION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2FLIBUV_REVISION", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2FLIBUV_REVISION", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2FLIBUV_REVISION?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -1,5 +1,5 @@\n This subtree is pulled from:\n-2b5707d834a6b85b8e589ac04cb61a6db2dab94b\n+ee599ec1141cc48f895de1f9d148033babdf9c2a\n \n When pulling in a new version of libuv, please update this file to ensure that\n everyone correctly rebuilds libuv."}, {"sha": "f7df47f71c9c57f9600cf1ac8aeb6e059d303949", "filename": "src/rt/libuv/LICENSE", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2FLICENSE", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2FLICENSE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2FLICENSE?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -35,3 +35,6 @@ The externally maintained libraries used by libuv are:\n \n   - libev, located at ev/ is copyright Marc Alexander Lehmann, and\n     dual-licensed under the MIT license and GPL2.\n+\n+  - libeio, located at eio/ is copyright Marc Alexander Lehmann, and\n+    dual-licensed under the MIT license and GPL2."}, {"sha": "be8abca1cbe14bc2a6068c495f836b8d4e513fdf", "filename": "src/rt/libuv/config-mingw.mk", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fconfig-mingw.mk", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fconfig-mingw.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fconfig-mingw.mk?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -20,26 +20,44 @@\n \n # Use make -f Makefile.gcc PREFIX=i686-w64-mingw32-\n # for cross compilation\n-CC = $(PREFIX)gcc\n-AR = $(PREFIX)ar\n+CC ?= $(PREFIX)gcc\n+AR ?= $(PREFIX)ar\n E=.exe\n \n-CFLAGS=-g --std=gnu89 -Wno-variadic-macros\n+CFLAGS=$(CPPFLAGS) -g --std=gnu89 -D_WIN32_WINNT=0x0501 -Isrc/ares/config_win32\n LINKFLAGS=-lm\n \n+CARES_OBJS += src/ares/windows_port.o\n+\n RUNNER_CFLAGS=$(CFLAGS) -D_GNU_SOURCE # Need _GNU_SOURCE for strdup?\n RUNNER_LINKFLAGS=$(LINKFLAGS)\n RUNNER_LIBS=-lws2_32\n RUNNER_SRC=test/runner-win.c\n \n-uv.a: uv-win.o uv-common.o\n-\t$(AR) rcs uv.a uv-win.o uv-common.o\n+uv.a: src/uv-win.o src/uv-common.o src/uv-eio.o src/eio/eio.o $(CARES_OBJS)\n+\t$(AR) rcs uv.a src/uv-win.o src/uv-common.o src/uv-eio.o src/eio/eio.o $(CARES_OBJS)\n \n-uv-win.o: uv-win.c uv.h uv-win.h\n-\t$(CC) $(CFLAGS) -c uv-win.c -o uv-win.o\n+src/uv-win.o: src/uv-win.c include/uv.h include/uv-win.h\n+\t$(CC) $(CFLAGS) -c src/uv-win.c -o src/uv-win.o\n \n-uv-common.o: uv-common.c uv.h uv-win.h\n-\t$(CC) $(CFLAGS) -c uv-common.c -o uv-common.o\n+src/uv-common.o: src/uv-common.c include/uv.h include/uv-win.h\n+\t$(CC) $(CFLAGS) -c src/uv-common.c -o src/uv-common.o\n+\n+EIO_CPPFLAGS += $(CPPFLAGS)\n+EIO_CPPFLAGS += -DEIO_CONFIG_H=\\\"$(EIO_CONFIG)\\\"\n+EIO_CPPFLAGS += -DEIO_STACKSIZE=65536\n+EIO_CPPFLAGS += -D_GNU_SOURCE\n+\n+src/eio/eio.o: src/eio/eio.c\n+\t$(CC) $(EIO_CPPFLAGS) $(CFLAGS) -c src/eio/eio.c -o src/eio/eio.o\n+\n+src/uv-eio.o: src/uv-eio.c\n+\t$(CC) $(CPPFLAGS) -Isrc/eio/ $(CFLAGS) -c src/uv-eio.c -o src/uv-eio.o\n \n-distclean-platform:\n clean-platform:\n+\t-rm -f src/ares/*.o\n+\t-rm -f src/eio/*.o\n+\n+distclean-platform:\n+\t-rm -f src/ares/*.o\n+\t-rm -f src/eio/*.o"}, {"sha": "b132cb5b5be6b723181ca324d90c8fbe920f3866", "filename": "src/rt/libuv/config-unix.mk", "status": "modified", "additions": 77, "deletions": 15, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fconfig-unix.mk", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fconfig-unix.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fconfig-unix.mk?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -18,14 +18,56 @@\n # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n # IN THE SOFTWARE.\n \n-CC = $(PREFIX)gcc\n-AR = $(PREFIX)ar\n+CC ?= $(PREFIX)gcc\n+AR ?= $(PREFIX)ar\n E=\n-CFLAGS=--std=gnu89 -Wno-variadic-macros -g\n+CSTDFLAG=--std=c89 -pedantic\n+CFLAGS=-g\n+CPPFLAGS += -Isrc/ev\n LINKFLAGS=-lm\n \n+CPPFLAGS += -D_LARGEFILE_SOURCE\n+CPPFLAGS += -D_FILE_OFFSET_BITS=64\n+\n ifeq (SunOS,$(uname_S))\n+EV_CONFIG=config_sunos.h\n+EIO_CONFIG=config_sunos.h\n+CPPFLAGS += -Isrc/ares/config_sunos\n LINKFLAGS+=-lsocket -lnsl\n+UV_OS_FILE=uv-sunos.c\n+endif\n+\n+ifeq (Darwin,$(uname_S))\n+EV_CONFIG=config_darwin.h\n+EIO_CONFIG=config_darwin.h\n+CPPFLAGS += -Isrc/ares/config_darwin\n+LINKFLAGS+=-framework CoreServices\n+UV_OS_FILE=uv-darwin.c\n+endif\n+\n+ifeq (Linux,$(uname_S))\n+EV_CONFIG=config_linux.h\n+EIO_CONFIG=config_linux.h\n+CSTDFLAG += -D_XOPEN_SOURCE=600\n+CPPFLAGS += -Isrc/ares/config_linux\n+LINKFLAGS+=-lrt\n+UV_OS_FILE=uv-linux.c\n+endif\n+\n+ifeq (FreeBSD,$(uname_S))\n+EV_CONFIG=config_freebsd.h\n+EIO_CONFIG=config_freebsd.h\n+CPPFLAGS += -Isrc/ares/config_freebsd\n+LINKFLAGS+=\n+UV_OS_FILE=uv-freebsd.c\n+endif\n+\n+ifneq (,$(findstring CYGWIN,$(uname_S)))\n+EV_CONFIG=config_cygwin.h\n+EIO_CONFIG=config_cygwin.h\n+CPPFLAGS += -Isrc/ares/config_cygwin\n+LINKFLAGS+=\n+UV_OS_FILE=uv-cygwin.c\n endif\n \n # Need _GNU_SOURCE for strdup?\n@@ -35,23 +77,43 @@ RUNNER_LINKFLAGS=$(LINKFLAGS) -pthread\n RUNNER_LIBS=\n RUNNER_SRC=test/runner-unix.c\n \n-uv.a: uv-unix.o uv-common.o ev/ev.o\n-\t$(AR) rcs uv.a uv-unix.o uv-common.o ev/ev.o\n+uv.a: src/uv-unix.o src/uv-common.o src/uv-platform.o src/ev/ev.o src/uv-eio.o src/eio/eio.o $(CARES_OBJS)\n+\t$(AR) rcs uv.a src/uv-unix.o src/uv-platform.o src/uv-common.o src/uv-eio.o src/ev/ev.o \\\n+\t\tsrc/eio/eio.o $(CARES_OBJS)\n+\n+src/uv-platform.o: src/$(UV_OS_FILE) include/uv.h include/uv-unix.h\n+\t$(CC) $(CSTDFLAG) $(CPPFLAGS) $(CFLAGS) -c src/$(UV_OS_FILE) -o src/uv-platform.o\n+\n+src/uv-unix.o: src/uv-unix.c include/uv.h include/uv-unix.h\n+\t$(CC) $(CSTDFLAG) $(CPPFLAGS) -Ieio $(CFLAGS) -c src/uv-unix.c -o src/uv-unix.o\n+\n+src/uv-common.o: src/uv-common.c include/uv.h include/uv-unix.h\n+\t$(CC) $(CSTDFLAG) $(CPPFLAGS) $(CFLAGS) -c src/uv-common.c -o src/uv-common.o\n+\n+src/ev/ev.o: src/ev/ev.c\n+\t$(CC) $(CPPFLAGS) $(CFLAGS) -c src/ev/ev.c -o src/ev/ev.o -DEV_CONFIG_H=\\\"$(EV_CONFIG)\\\"\n+\n \n-uv-unix.o: uv-unix.c uv.h uv-unix.h\n-\t$(CC) $(CFLAGS) -c uv-unix.c -o uv-unix.o\n+EIO_CPPFLAGS += $(CPPFLAGS)\n+EIO_CPPFLAGS += -DEIO_CONFIG_H=\\\"$(EIO_CONFIG)\\\"\n+EIO_CPPFLAGS += -DEIO_STACKSIZE=65536\n+EIO_CPPFLAGS += -D_GNU_SOURCE\n \n-uv-common.o: uv-common.c uv.h uv-unix.h\n-\t$(CC) $(CFLAGS) -c uv-common.c -o uv-common.o\n+src/eio/eio.o: src/eio/eio.c\n+\t$(CC) $(EIO_CPPFLAGS) $(CFLAGS) -c src/eio/eio.c -o src/eio/eio.o\n \n-ev/ev.o: ev/config.h ev/ev.c\n-\t$(MAKE) -C ev\n+src/uv-eio.o: src/uv-eio.c\n+\t$(CC) $(CPPFLAGS) -Isrc/eio/ $(CSTDFLAG) $(CFLAGS) -c src/uv-eio.c -o src/uv-eio.o\n \n-ev/config.h:\n-\tcd ev && ./configure\n \n clean-platform:\n-\t$(MAKE) -C ev clean\n+\t-rm -f src/ares/*.o\n+\t-rm -f src/ev/*.o\n+\t-rm -f src/eio/*.o\n+\t-rm -rf test/run-tests.dSYM run-benchmarks.dSYM\n \n distclean-platform:\n-\t$(MAKE) -C ev distclean\n+\t-rm -f src/ares/*.o\n+\t-rm -f src/ev/*.o\n+\t-rm -f src/eio/*.o\n+\t-rm -rf test/run-tests.dSYM run-benchmarks.dSYM"}, {"sha": "9faa57591e943b2b9e58371f6147af5a0986a0f9", "filename": "src/rt/libuv/doc/desired-api.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fdoc%2Fdesired-api.md", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fdoc%2Fdesired-api.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fdoc%2Fdesired-api.md?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/desired-api.md"}, {"sha": "905a29eea6f8637620f631b144eaf26c277a34a5", "filename": "src/rt/libuv/include/ares.h", "status": "added", "additions": 582, "deletions": 0, "changes": 582, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Finclude%2Fares.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Finclude%2Fares.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fares.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,582 @@\n+\n+/* Copyright 1998, 2009 by the Massachusetts Institute of Technology.\n+ * Copyright (C) 2007-2010 by Daniel Stenberg\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#ifndef ARES__H\n+#define ARES__H\n+\n+#include \"ares_version.h\"  /* c-ares version defines   */\n+\n+/*\n+ * Define WIN32 when build target is Win32 API\n+ */\n+\n+#if (defined(_WIN32) || defined(__WIN32__)) && \\\n+   !defined(WIN32) && !defined(__SYMBIAN32__)\n+#  define WIN32\n+#endif\n+\n+/*************************** libuv patch ***************/\n+\n+/*\n+ * We want to avoid autoconf altogether since there are a finite number of\n+ * operating systems and simply build c-ares. Therefore we do not want the\n+ * configurations provided by ares_build.h since we are always statically\n+ * linking c-ares into libuv. Having a system dependent ares_build.h forces\n+ * all users of ares.h to include the correct ares_build.h.  We do not care\n+ * about the linking checks provided by ares_rules.h. This would complicate\n+ * the libuv build process.\n+ */\n+\n+\n+#if defined(WIN32)\n+/* Configure process defines this to 1 when it finds out that system  */\n+/* header file ws2tcpip.h must be included by the external interface. */\n+/* #undef CARES_PULL_WS2TCPIP_H */\n+# include <winsock2.h>\n+# include <ws2tcpip.h>\n+# include <windows.h>\n+\n+#else /* Not Windows */\n+\n+# include <sys/time.h>\n+# include <sys/types.h>\n+# include <sys/socket.h>\n+#endif\n+\n+#if 0\n+/* The size of `long', as computed by sizeof. */\n+#define CARES_SIZEOF_LONG 4\n+#endif\n+\n+/* Integral data type used for ares_socklen_t. */\n+#define CARES_TYPEOF_ARES_SOCKLEN_T socklen_t\n+\n+#if 0\n+/* The size of `ares_socklen_t', as computed by sizeof. */\n+#define CARES_SIZEOF_ARES_SOCKLEN_T 4\n+#endif\n+\n+/* Data type definition of ares_socklen_t. */\n+typedef int ares_socklen_t;\n+\n+#if 0 /* libuv disabled */\n+#include \"ares_rules.h\"    /* c-ares rules enforcement */\n+#endif\n+\n+/*********************** end libuv patch ***************/\n+\n+#include <sys/types.h>\n+\n+/* HP-UX systems version 9, 10 and 11 lack sys/select.h and so does oldish\n+   libc5-based Linux systems. Only include it on system that are known to\n+   require it! */\n+#if defined(_AIX) || defined(__NOVELL_LIBC__) || defined(__NetBSD__) || \\\n+    defined(__minix) || defined(__SYMBIAN32__) || defined(__INTEGRITY)\n+#include <sys/select.h>\n+#endif\n+#if (defined(NETWARE) && !defined(__NOVELL_LIBC__))\n+#include <sys/bsdskt.h>\n+#endif\n+\n+#if defined(WATT32)\n+#  include <netinet/in.h>\n+#  include <sys/socket.h>\n+#  include <tcp.h>\n+#elif defined(WIN32)\n+#  include <winsock2.h>\n+#  include <ws2tcpip.h>\n+#  include <windows.h>\n+#else\n+#  include <sys/socket.h>\n+#  include <netinet/in.h>\n+#endif\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/*\n+** c-ares external API function linkage decorations.\n+*/\n+\n+#if !defined(CARES_STATICLIB) && \\\n+   (defined(WIN32) || defined(_WIN32) || defined(__SYMBIAN32__))\n+   /* __declspec function decoration for Win32 and Symbian DLL's */\n+#  if defined(CARES_BUILDING_LIBRARY)\n+#    define CARES_EXTERN  __declspec(dllexport)\n+#  else\n+#    define CARES_EXTERN  __declspec(dllimport)\n+#  endif\n+#else\n+   /* visibility function decoration for other cases */\n+#  if !defined(CARES_SYMBOL_HIDING) || \\\n+     defined(WIN32) || defined(_WIN32) || defined(__SYMBIAN32__)\n+#    define CARES_EXTERN\n+#  else\n+#    define CARES_EXTERN CARES_SYMBOL_SCOPE_EXTERN\n+#  endif\n+#endif\n+\n+\n+#define ARES_SUCCESS            0\n+\n+/* Server error codes (ARES_ENODATA indicates no relevant answer) */\n+#define ARES_ENODATA            1\n+#define ARES_EFORMERR           2\n+#define ARES_ESERVFAIL          3\n+#define ARES_ENOTFOUND          4\n+#define ARES_ENOTIMP            5\n+#define ARES_EREFUSED           6\n+\n+/* Locally generated error codes */\n+#define ARES_EBADQUERY          7\n+#define ARES_EBADNAME           8\n+#define ARES_EBADFAMILY         9\n+#define ARES_EBADRESP           10\n+#define ARES_ECONNREFUSED       11\n+#define ARES_ETIMEOUT           12\n+#define ARES_EOF                13\n+#define ARES_EFILE              14\n+#define ARES_ENOMEM             15\n+#define ARES_EDESTRUCTION       16\n+#define ARES_EBADSTR            17\n+\n+/* ares_getnameinfo error codes */\n+#define ARES_EBADFLAGS          18\n+\n+/* ares_getaddrinfo error codes */\n+#define ARES_ENONAME            19\n+#define ARES_EBADHINTS          20\n+\n+/* Uninitialized library error code */\n+#define ARES_ENOTINITIALIZED    21          /* introduced in 1.7.0 */\n+\n+/* ares_library_init error codes */\n+#define ARES_ELOADIPHLPAPI           22     /* introduced in 1.7.0 */\n+#define ARES_EADDRGETNETWORKPARAMS   23     /* introduced in 1.7.0 */\n+\n+/* More error codes */\n+#define ARES_ECANCELLED         24          /* introduced in 1.7.0 */\n+\n+/* Flag values */\n+#define ARES_FLAG_USEVC         (1 << 0)\n+#define ARES_FLAG_PRIMARY       (1 << 1)\n+#define ARES_FLAG_IGNTC         (1 << 2)\n+#define ARES_FLAG_NORECURSE     (1 << 3)\n+#define ARES_FLAG_STAYOPEN      (1 << 4)\n+#define ARES_FLAG_NOSEARCH      (1 << 5)\n+#define ARES_FLAG_NOALIASES     (1 << 6)\n+#define ARES_FLAG_NOCHECKRESP   (1 << 7)\n+\n+/* Option mask values */\n+#define ARES_OPT_FLAGS          (1 << 0)\n+#define ARES_OPT_TIMEOUT        (1 << 1)\n+#define ARES_OPT_TRIES          (1 << 2)\n+#define ARES_OPT_NDOTS          (1 << 3)\n+#define ARES_OPT_UDP_PORT       (1 << 4)\n+#define ARES_OPT_TCP_PORT       (1 << 5)\n+#define ARES_OPT_SERVERS        (1 << 6)\n+#define ARES_OPT_DOMAINS        (1 << 7)\n+#define ARES_OPT_LOOKUPS        (1 << 8)\n+#define ARES_OPT_SOCK_STATE_CB  (1 << 9)\n+#define ARES_OPT_SORTLIST       (1 << 10)\n+#define ARES_OPT_SOCK_SNDBUF    (1 << 11)\n+#define ARES_OPT_SOCK_RCVBUF    (1 << 12)\n+#define ARES_OPT_TIMEOUTMS      (1 << 13)\n+#define ARES_OPT_ROTATE         (1 << 14)\n+\n+/* Nameinfo flag values */\n+#define ARES_NI_NOFQDN                  (1 << 0)\n+#define ARES_NI_NUMERICHOST             (1 << 1)\n+#define ARES_NI_NAMEREQD                (1 << 2)\n+#define ARES_NI_NUMERICSERV             (1 << 3)\n+#define ARES_NI_DGRAM                   (1 << 4)\n+#define ARES_NI_TCP                     0\n+#define ARES_NI_UDP                     ARES_NI_DGRAM\n+#define ARES_NI_SCTP                    (1 << 5)\n+#define ARES_NI_DCCP                    (1 << 6)\n+#define ARES_NI_NUMERICSCOPE            (1 << 7)\n+#define ARES_NI_LOOKUPHOST              (1 << 8)\n+#define ARES_NI_LOOKUPSERVICE           (1 << 9)\n+/* Reserved for future use */\n+#define ARES_NI_IDN                     (1 << 10)\n+#define ARES_NI_IDN_ALLOW_UNASSIGNED    (1 << 11)\n+#define ARES_NI_IDN_USE_STD3_ASCII_RULES (1 << 12)\n+\n+/* Addrinfo flag values */\n+#define ARES_AI_CANONNAME               (1 << 0)\n+#define ARES_AI_NUMERICHOST             (1 << 1)\n+#define ARES_AI_PASSIVE                 (1 << 2)\n+#define ARES_AI_NUMERICSERV             (1 << 3)\n+#define ARES_AI_V4MAPPED                (1 << 4)\n+#define ARES_AI_ALL                     (1 << 5)\n+#define ARES_AI_ADDRCONFIG              (1 << 6)\n+/* Reserved for future use */\n+#define ARES_AI_IDN                     (1 << 10)\n+#define ARES_AI_IDN_ALLOW_UNASSIGNED    (1 << 11)\n+#define ARES_AI_IDN_USE_STD3_ASCII_RULES (1 << 12)\n+#define ARES_AI_CANONIDN                (1 << 13)\n+\n+#define ARES_AI_MASK (ARES_AI_CANONNAME|ARES_AI_NUMERICHOST|ARES_AI_PASSIVE| \\\n+                      ARES_AI_NUMERICSERV|ARES_AI_V4MAPPED|ARES_AI_ALL| \\\n+                      ARES_AI_ADDRCONFIG)\n+#define ARES_GETSOCK_MAXNUM 16 /* ares_getsock() can return info about this\n+                                  many sockets */\n+#define ARES_GETSOCK_READABLE(bits,num) (bits & (1<< (num)))\n+#define ARES_GETSOCK_WRITABLE(bits,num) (bits & (1 << ((num) + \\\n+                                         ARES_GETSOCK_MAXNUM)))\n+\n+/* c-ares library initialization flag values */\n+#define ARES_LIB_INIT_NONE   (0)\n+#define ARES_LIB_INIT_WIN32  (1 << 0)\n+#define ARES_LIB_INIT_ALL    (ARES_LIB_INIT_WIN32)\n+\n+\n+/*\n+ * Typedef our socket type\n+ */\n+\n+#ifndef ares_socket_typedef\n+#ifdef WIN32\n+typedef SOCKET ares_socket_t;\n+#define ARES_SOCKET_BAD INVALID_SOCKET\n+#else\n+typedef int ares_socket_t;\n+#define ARES_SOCKET_BAD -1\n+#endif\n+#define ares_socket_typedef\n+#endif /* ares_socket_typedef */\n+\n+typedef void (*ares_sock_state_cb)(void *data,\n+                                   ares_socket_t socket_fd,\n+                                   int readable,\n+                                   int writable);\n+\n+struct apattern;\n+\n+/* NOTE about the ares_options struct to users and developers.\n+\n+   This struct will remain looking like this. It will not be extended nor\n+   shrunk in future releases, but all new options will be set by ares_set_*()\n+   options instead of with the ares_init_options() function.\n+\n+   Eventually (in a galaxy far far away), all options will be settable by\n+   ares_set_*() options and the ares_init_options() function will become\n+   deprecated.\n+\n+   When new options are added to c-ares, they are not added to this\n+   struct. And they are not \"saved\" with the ares_save_options() function but\n+   instead we encourage the use of the ares_dup() function. Needless to say,\n+   if you add config options to c-ares you need to make sure ares_dup()\n+   duplicates this new option.\n+\n+ */\n+struct ares_options {\n+  int flags;\n+  int timeout; /* in seconds or milliseconds, depending on options */\n+  int tries;\n+  int ndots;\n+  unsigned short udp_port;\n+  unsigned short tcp_port;\n+  int socket_send_buffer_size;\n+  int socket_receive_buffer_size;\n+  struct in_addr *servers;\n+  int nservers;\n+  char **domains;\n+  int ndomains;\n+  char *lookups;\n+  ares_sock_state_cb sock_state_cb;\n+  void *sock_state_cb_data;\n+  struct apattern *sortlist;\n+  int nsort;\n+};\n+\n+struct hostent;\n+struct timeval;\n+struct sockaddr;\n+struct ares_channeldata;\n+\n+typedef struct ares_channeldata *ares_channel;\n+\n+typedef void (*ares_callback)(void *arg,\n+                              int status,\n+                              int timeouts,\n+                              unsigned char *abuf,\n+                              int alen);\n+\n+typedef void (*ares_host_callback)(void *arg,\n+                                   int status,\n+                                   int timeouts,\n+                                   struct hostent *hostent);\n+\n+typedef void (*ares_nameinfo_callback)(void *arg,\n+                                       int status,\n+                                       int timeouts,\n+                                       char *node,\n+                                       char *service);\n+\n+typedef int  (*ares_sock_create_callback)(ares_socket_t socket_fd,\n+                                          int type,\n+                                          void *data);\n+\n+CARES_EXTERN int ares_library_init(int flags);\n+\n+CARES_EXTERN void ares_library_cleanup(void);\n+\n+CARES_EXTERN const char *ares_version(int *version);\n+\n+CARES_EXTERN int ares_init(ares_channel *channelptr);\n+\n+CARES_EXTERN int ares_init_options(ares_channel *channelptr,\n+                                   struct ares_options *options,\n+                                   int optmask);\n+\n+CARES_EXTERN int ares_save_options(ares_channel channel,\n+                                   struct ares_options *options,\n+                                   int *optmask);\n+\n+CARES_EXTERN void ares_destroy_options(struct ares_options *options);\n+\n+CARES_EXTERN int ares_dup(ares_channel *dest,\n+                          ares_channel src);\n+\n+CARES_EXTERN void ares_destroy(ares_channel channel);\n+\n+CARES_EXTERN void ares_cancel(ares_channel channel);\n+\n+/* These next 3 configure local binding for the out-going socket\n+ * connection.  Use these to specify source IP and/or network device\n+ * on multi-homed systems.\n+ */\n+CARES_EXTERN void ares_set_local_ip4(ares_channel channel, unsigned int local_ip);\n+\n+/* local_ip6 should be 16 bytes in length */\n+CARES_EXTERN void ares_set_local_ip6(ares_channel channel,\n+                                     const unsigned char* local_ip6);\n+\n+/* local_dev_name should be null terminated. */\n+CARES_EXTERN void ares_set_local_dev(ares_channel channel,\n+                                     const char* local_dev_name);\n+\n+CARES_EXTERN void ares_set_socket_callback(ares_channel channel,\n+                                           ares_sock_create_callback callback,\n+                                           void *user_data);\n+\n+CARES_EXTERN void ares_send(ares_channel channel,\n+                            const unsigned char *qbuf,\n+                            int qlen,\n+                            ares_callback callback,\n+                            void *arg);\n+\n+CARES_EXTERN void ares_query(ares_channel channel,\n+                             const char *name,\n+                             int dnsclass,\n+                             int type,\n+                             ares_callback callback,\n+                             void *arg);\n+\n+CARES_EXTERN void ares_search(ares_channel channel,\n+                              const char *name,\n+                              int dnsclass,\n+                              int type,\n+                              ares_callback callback,\n+                              void *arg);\n+\n+CARES_EXTERN void ares_gethostbyname(ares_channel channel,\n+                                     const char *name,\n+                                     int family,\n+                                     ares_host_callback callback,\n+                                     void *arg);\n+\n+CARES_EXTERN int ares_gethostbyname_file(ares_channel channel,\n+                                         const char *name,\n+                                         int family,\n+                                         struct hostent **host);\n+\n+CARES_EXTERN void ares_gethostbyaddr(ares_channel channel,\n+                                     const void *addr,\n+                                     int addrlen,\n+                                     int family,\n+                                     ares_host_callback callback,\n+                                     void *arg);\n+\n+CARES_EXTERN void ares_getnameinfo(ares_channel channel,\n+                                   const struct sockaddr *sa,\n+                                   ares_socklen_t salen,\n+                                   int flags,\n+                                   ares_nameinfo_callback callback,\n+                                   void *arg);\n+\n+CARES_EXTERN int ares_fds(ares_channel channel,\n+                          fd_set *read_fds,\n+                          fd_set *write_fds);\n+\n+CARES_EXTERN int ares_getsock(ares_channel channel,\n+                              ares_socket_t *socks,\n+                              int numsocks);\n+\n+CARES_EXTERN struct timeval *ares_timeout(ares_channel channel,\n+                                          struct timeval *maxtv,\n+                                          struct timeval *tv);\n+\n+CARES_EXTERN void ares_process(ares_channel channel,\n+                               fd_set *read_fds,\n+                               fd_set *write_fds);\n+\n+CARES_EXTERN void ares_process_fd(ares_channel channel,\n+                                  ares_socket_t read_fd,\n+                                  ares_socket_t write_fd);\n+\n+CARES_EXTERN int ares_mkquery(const char *name,\n+                              int dnsclass,\n+                              int type,\n+                              unsigned short id,\n+                              int rd,\n+                              unsigned char **buf,\n+                              int *buflen);\n+\n+CARES_EXTERN int ares_expand_name(const unsigned char *encoded,\n+                                  const unsigned char *abuf,\n+                                  int alen,\n+                                  char **s,\n+                                  long *enclen);\n+\n+CARES_EXTERN int ares_expand_string(const unsigned char *encoded,\n+                                    const unsigned char *abuf,\n+                                    int alen,\n+                                    unsigned char **s,\n+                                    long *enclen);\n+\n+/*\n+ * NOTE: before c-ares 1.7.0 we would most often use the system in6_addr\n+ * struct below when ares itself was built, but many apps would use this\n+ * private version since the header checked a HAVE_* define for it. Starting\n+ * with 1.7.0 we always declare and use our own to stop relying on the\n+ * system's one.\n+ */\n+struct ares_in6_addr {\n+  union {\n+    unsigned char _S6_u8[16];\n+  } _S6_un;\n+};\n+\n+struct ares_addrttl {\n+  struct in_addr ipaddr;\n+  int            ttl;\n+};\n+\n+struct ares_addr6ttl {\n+  struct ares_in6_addr ip6addr;\n+  int             ttl;\n+};\n+\n+struct ares_srv_reply {\n+  struct ares_srv_reply  *next;\n+  char                   *host;\n+  unsigned short          priority;\n+  unsigned short          weight;\n+  unsigned short          port;\n+};\n+\n+struct ares_mx_reply {\n+  struct ares_mx_reply   *next;\n+  char                   *host;\n+  unsigned short          priority;\n+};\n+\n+struct ares_txt_reply {\n+  struct ares_txt_reply  *next;\n+  unsigned char          *txt;\n+  size_t                  length;  /* length excludes null termination */\n+};\n+\n+/*\n+** Parse the buffer, starting at *abuf and of length alen bytes, previously\n+** obtained from an ares_search call.  Put the results in *host, if nonnull.\n+** Also, if addrttls is nonnull, put up to *naddrttls IPv4 addresses along with\n+** their TTLs in that array, and set *naddrttls to the number of addresses\n+** so written.\n+*/\n+\n+CARES_EXTERN int ares_parse_a_reply(const unsigned char *abuf,\n+                                    int alen,\n+                                    struct hostent **host,\n+                                    struct ares_addrttl *addrttls,\n+                                    int *naddrttls);\n+\n+CARES_EXTERN int ares_parse_aaaa_reply(const unsigned char *abuf,\n+                                       int alen,\n+                                       struct hostent **host,\n+                                       struct ares_addr6ttl *addrttls,\n+                                       int *naddrttls);\n+\n+CARES_EXTERN int ares_parse_ptr_reply(const unsigned char *abuf,\n+                                      int alen,\n+                                      const void *addr,\n+                                      int addrlen,\n+                                      int family,\n+                                      struct hostent **host);\n+\n+CARES_EXTERN int ares_parse_ns_reply(const unsigned char *abuf,\n+                                     int alen,\n+                                     struct hostent **host);\n+\n+CARES_EXTERN int ares_parse_srv_reply(const unsigned char* abuf,\n+                                      int alen,\n+                                      struct ares_srv_reply** srv_out);\n+\n+CARES_EXTERN int ares_parse_mx_reply(const unsigned char* abuf,\n+                                      int alen,\n+                                      struct ares_mx_reply** mx_out);\n+\n+CARES_EXTERN int ares_parse_txt_reply(const unsigned char* abuf,\n+                                      int alen,\n+                                      struct ares_txt_reply** txt_out);\n+\n+CARES_EXTERN void ares_free_string(void *str);\n+\n+CARES_EXTERN void ares_free_hostent(struct hostent *host);\n+\n+CARES_EXTERN void ares_free_data(void *dataptr);\n+\n+CARES_EXTERN const char *ares_strerror(int code);\n+\n+/* TODO:  Hold port here as well. */\n+struct ares_addr_node {\n+  struct ares_addr_node *next;\n+  int family;\n+  union {\n+    struct in_addr       addr4;\n+    struct ares_in6_addr addr6;\n+  } addr;\n+};\n+\n+CARES_EXTERN int ares_set_servers(ares_channel channel,\n+                                  struct ares_addr_node *servers);\n+\n+/* Incomming string format: host[:port][,host[:port]]... */\n+CARES_EXTERN int ares_set_servers_csv(ares_channel channel,\n+                                      const char* servers);\n+\n+CARES_EXTERN int ares_get_servers(ares_channel channel,\n+                                  struct ares_addr_node **servers);\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+\n+#endif /* ARES__H */"}, {"sha": "8baa897cda2c0982f8f7a494d066eaae4a6cb296", "filename": "src/rt/libuv/include/ares_version.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Finclude%2Fares_version.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Finclude%2Fares_version.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fares_version.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,24 @@\n+\n+#ifndef ARES__VERSION_H\n+#define ARES__VERSION_H\n+\n+/* This is the global package copyright */\n+#define ARES_COPYRIGHT \"2004 - 2010 Daniel Stenberg, <daniel@haxx.se>.\"\n+\n+#define ARES_VERSION_MAJOR 1\n+#define ARES_VERSION_MINOR 7\n+#define ARES_VERSION_PATCH 4\n+#define ARES_VERSION ((ARES_VERSION_MAJOR<<16)|\\\n+                       (ARES_VERSION_MINOR<<8)|\\\n+                       (ARES_VERSION_PATCH))\n+#define ARES_VERSION_STR \"1.7.4\"\n+\n+#if (ARES_VERSION >= 0x010700)\n+#  define CARES_HAVE_ARES_LIBRARY_INIT 1\n+#  define CARES_HAVE_ARES_LIBRARY_CLEANUP 1\n+#else\n+#  undef CARES_HAVE_ARES_LIBRARY_INIT\n+#  undef CARES_HAVE_ARES_LIBRARY_CLEANUP\n+#endif\n+\n+#endif"}, {"sha": "3dd3267678a10d81ed6f1c2aa9e91e37b874c2b3", "filename": "src/rt/libuv/include/eio.h", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Finclude%2Feio.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Finclude%2Feio.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Feio.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,356 @@\n+/*\n+ * libeio API header\n+ *\n+ * Copyright (c) 2007,2008,2009,2010 Marc Alexander Lehmann <libeio@schmorp.de>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modifica-\n+ * tion, are permitted provided that the following conditions are met:\n+ * \n+ *   1.  Redistributions of source code must retain the above copyright notice,\n+ *       this list of conditions and the following disclaimer.\n+ * \n+ *   2.  Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License (\"GPL\") version 2 or any later version,\n+ * in which case the provisions of the GPL are applicable instead of\n+ * the above. If you wish to allow the use of your version of this file\n+ * only under the terms of the GPL and not to allow others to use your\n+ * version of this file under the BSD license, indicate your decision\n+ * by deleting the provisions above and replace them with the notice\n+ * and other provisions required by the GPL. If you do not delete the\n+ * provisions above, a recipient may use your version of this file under\n+ * either the BSD or the GPL.\n+ */\n+\n+#ifndef EIO_H_\n+#define EIO_H_\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+#include <sys/types.h>\n+\n+#ifdef __OpenBSD__\n+# include <inttypes.h>\n+#endif\n+\n+#ifdef _WIN32\n+# define uid_t int\n+# define gid_t int\n+#endif\n+\n+typedef struct eio_req    eio_req;\n+typedef struct eio_dirent eio_dirent;\n+\n+typedef int (*eio_cb)(eio_req *req);\n+\n+#ifndef EIO_REQ_MEMBERS\n+# define EIO_REQ_MEMBERS\n+#endif\n+\n+#ifndef EIO_STRUCT_STAT\n+# ifdef _WIN32\n+#   define EIO_STRUCT_STAT struct _stati64\n+# else\n+#   define EIO_STRUCT_STAT struct stat\n+# endif\n+#endif\n+\n+#ifndef EIO_STRUCT_STATVFS\n+# define EIO_STRUCT_STATVFS struct statvfs\n+#endif\n+\n+/* for readdir */\n+\n+/* eio_readdir flags */\n+enum\n+{\n+  EIO_READDIR_DENTS         = 0x01, /* ptr2 contains eio_dirents, not just the (unsorted) names */\n+  EIO_READDIR_DIRS_FIRST    = 0x02, /* dirents gets sorted into a good stat() ing order to find directories first */\n+  EIO_READDIR_STAT_ORDER    = 0x04, /* dirents gets sorted into a good stat() ing order to quickly stat all files */\n+  EIO_READDIR_FOUND_UNKNOWN = 0x80, /* set by eio_readdir when *_ARRAY was set and any TYPE=UNKNOWN's were found */\n+\n+  EIO_READDIR_CUSTOM1       = 0x100, /* for use by apps */\n+  EIO_READDIR_CUSTOM2       = 0x200  /* for use by apps */\n+};\n+\n+/* using \"typical\" values in the hope that the compiler will do something sensible */\n+enum eio_dtype\n+{\n+  EIO_DT_UNKNOWN =  0,\n+  EIO_DT_FIFO    =  1,\n+  EIO_DT_CHR     =  2,\n+  EIO_DT_MPC     =  3, /* multiplexed char device (v7+coherent) */\n+  EIO_DT_DIR     =  4,\n+  EIO_DT_NAM     =  5, /* xenix special named file */\n+  EIO_DT_BLK     =  6,\n+  EIO_DT_MPB     =  7, /* multiplexed block device (v7+coherent) */\n+  EIO_DT_REG     =  8,\n+  EIO_DT_NWK     =  9, /* HP-UX network special */\n+  EIO_DT_CMP     =  9, /* VxFS compressed */\n+  EIO_DT_LNK     = 10,\n+  /*  DT_SHAD    = 11,*/\n+  EIO_DT_SOCK    = 12,\n+  EIO_DT_DOOR    = 13, /* solaris door */\n+  EIO_DT_WHT     = 14,\n+  EIO_DT_MAX     = 15  /* highest DT_VALUE ever, hopefully */\n+};\n+\n+struct eio_dirent\n+{\n+  int nameofs; /* offset of null-terminated name string in (char *)req->ptr2 */\n+  unsigned short namelen; /* size of filename without trailing 0 */\n+  unsigned char type; /* one of EIO_DT_* */\n+  signed char score; /* internal use */\n+  ino_t inode; /* the inode number, if available, otherwise unspecified */\n+};\n+\n+/* eio_msync flags */\n+enum\n+{\n+  EIO_MS_ASYNC      = 1,\n+  EIO_MS_INVALIDATE = 2,\n+  EIO_MS_SYNC       = 4\n+};\n+\n+/* eio_mtouch flags */\n+\n+enum\n+{\n+  EIO_MT_MODIFY     = 1\n+};\n+\n+/* eio_sync_file_range flags */\n+\n+enum\n+{\n+  EIO_SYNC_FILE_RANGE_WAIT_BEFORE = 1,\n+  EIO_SYNC_FILE_RANGE_WRITE       = 2,\n+  EIO_SYNC_FILE_RANGE_WAIT_AFTER  = 4\n+};\n+\n+typedef double eio_tstamp; /* feel free to use double in your code directly */\n+\n+/* the eio request structure */\n+\n+enum\n+{\n+  EIO_CUSTOM,\n+  EIO_OPEN, EIO_CLOSE, EIO_DUP2,\n+  EIO_READ, EIO_WRITE,\n+  EIO_READAHEAD, EIO_SENDFILE,\n+  EIO_STAT, EIO_LSTAT, EIO_FSTAT,\n+  EIO_STATVFS, EIO_FSTATVFS,\n+  EIO_TRUNCATE, EIO_FTRUNCATE,\n+  EIO_UTIME, EIO_FUTIME,\n+  EIO_CHMOD, EIO_FCHMOD,\n+  EIO_CHOWN, EIO_FCHOWN,\n+  EIO_SYNC, EIO_FSYNC, EIO_FDATASYNC,\n+  EIO_MSYNC, EIO_MTOUCH, EIO_SYNC_FILE_RANGE,\n+  EIO_MLOCK, EIO_MLOCKALL,\n+  EIO_UNLINK, EIO_RMDIR, EIO_MKDIR, EIO_RENAME,\n+  EIO_MKNOD, EIO_READDIR,\n+  EIO_LINK, EIO_SYMLINK, EIO_READLINK,\n+  EIO_GROUP, EIO_NOP,\n+  EIO_BUSY\n+};\n+\n+/* mlockall constants */\n+enum\n+{\n+  EIO_MCL_CURRENT = 1,\n+  EIO_MCL_FUTURE  = 2\n+};\n+\n+/* request priorities */\n+\n+enum {\n+  EIO_PRI_MIN     = -4,\n+  EIO_PRI_MAX     =  4,\n+  EIO_PRI_DEFAULT =  0\n+};\n+\n+/* eio request structure */\n+/* this structure is mostly read-only */\n+/* when initialising it, all members must be zero-initialised */\n+struct eio_req\n+{\n+  eio_req volatile *next; /* private ETP */\n+\n+  ssize_t result;  /* result of syscall, e.g. result = read (... */\n+  off_t offs;      /* read, write, truncate, readahead, sync_file_range: file offset */\n+  size_t size;     /* read, write, readahead, sendfile, msync, mlock, sync_file_range: length */\n+  void *ptr1;      /* all applicable requests: pathname, old name; readdir: optional eio_dirents */\n+  void *ptr2;      /* all applicable requests: new name or memory buffer; readdir: name strings */\n+  eio_tstamp nv1;  /* utime, futime: atime; busy: sleep time */\n+  eio_tstamp nv2;  /* utime, futime: mtime */\n+\n+  int type;        /* EIO_xxx constant ETP */\n+  int int1;        /* all applicable requests: file descriptor; sendfile: output fd; open, msync, mlockall, readdir: flags */\n+  long int2;       /* chown, fchown: uid; sendfile: input fd; open, chmod, mkdir, mknod: file mode, sync_file_range: flags */\n+  long int3;       /* chown, fchown: gid; mknod: dev_t */\n+  int errorno;     /* errno value on syscall return */\n+\n+  unsigned char flags; /* private */\n+  signed char pri;     /* the priority */\n+\n+  void *data;\n+  eio_cb finish;\n+  void (*destroy)(eio_req *req); /* called when requets no longer needed */\n+  void (*feed)(eio_req *req);    /* only used for group requests */\n+\n+  EIO_REQ_MEMBERS\n+\n+  eio_req *grp, *grp_prev, *grp_next, *grp_first; /* private */\n+};\n+\n+/* _private_ request flags */\n+enum {\n+  EIO_FLAG_CANCELLED = 0x01, /* request was cancelled */\n+  EIO_FLAG_PTR1_FREE = 0x02, /* need to free(ptr1) */\n+  EIO_FLAG_PTR2_FREE = 0x04, /* need to free(ptr2) */\n+  EIO_FLAG_GROUPADD  = 0x08  /* some request was added to the group */\n+};\n+\n+/* undocumented/unsupported/private helper */\n+/*void eio_page_align (void **addr, size_t *length);*/\n+\n+/* returns < 0 on error, errno set\n+ * need_poll, if non-zero, will be called when results are available\n+ * and eio_poll_cb needs to be invoked (it MUST NOT call eio_poll_cb itself).\n+ * done_poll is called when the need to poll is gone.\n+ */\n+int eio_init (void (*want_poll)(void), void (*done_poll)(void));\n+\n+/* must be called regularly to handle pending requests */\n+/* returns 0 if all requests were handled, -1 if not, or the value of EIO_FINISH if != 0 */\n+int eio_poll (void);\n+\n+/* stop polling if poll took longer than duration seconds */\n+void eio_set_max_poll_time (eio_tstamp nseconds);\n+/* do not handle more then count requests in one call to eio_poll_cb */\n+void eio_set_max_poll_reqs (unsigned int nreqs);\n+\n+/* set minimum required number\n+ * maximum wanted number\n+ * or maximum idle number of threads */\n+void eio_set_min_parallel (unsigned int nthreads);\n+void eio_set_max_parallel (unsigned int nthreads);\n+void eio_set_max_idle     (unsigned int nthreads);\n+\n+unsigned int eio_nreqs    (void); /* number of requests in-flight */\n+unsigned int eio_nready   (void); /* number of not-yet handled requests */\n+unsigned int eio_npending (void); /* numbe rof finished but unhandled requests */\n+unsigned int eio_nthreads (void); /* number of worker threads in use currently */\n+\n+/*****************************************************************************/\n+/* convinience wrappers */\n+\n+#ifndef EIO_NO_WRAPPERS\n+eio_req *eio_nop       (int pri, eio_cb cb, void *data); /* does nothing except go through the whole process */\n+eio_req *eio_busy      (eio_tstamp delay, int pri, eio_cb cb, void *data); /* ties a thread for this long, simulating busyness */\n+eio_req *eio_sync      (int pri, eio_cb cb, void *data);\n+eio_req *eio_fsync     (int fd, int pri, eio_cb cb, void *data);\n+eio_req *eio_fdatasync (int fd, int pri, eio_cb cb, void *data);\n+eio_req *eio_msync     (void *addr, size_t length, int flags, int pri, eio_cb cb, void *data);\n+eio_req *eio_mtouch    (void *addr, size_t length, int flags, int pri, eio_cb cb, void *data);\n+eio_req *eio_mlock     (void *addr, size_t length, int pri, eio_cb cb, void *data);\n+eio_req *eio_mlockall  (int flags, int pri, eio_cb cb, void *data);\n+eio_req *eio_sync_file_range (int fd, off_t offset, size_t nbytes, unsigned int flags, int pri, eio_cb cb, void *data);\n+eio_req *eio_close     (int fd, int pri, eio_cb cb, void *data);\n+eio_req *eio_readahead (int fd, off_t offset, size_t length, int pri, eio_cb cb, void *data);\n+eio_req *eio_read      (int fd, void *buf, size_t length, off_t offset, int pri, eio_cb cb, void *data);\n+eio_req *eio_write     (int fd, void *buf, size_t length, off_t offset, int pri, eio_cb cb, void *data);\n+eio_req *eio_fstat     (int fd, int pri, eio_cb cb, void *data); /* stat buffer=ptr2 allocated dynamically */\n+eio_req *eio_fstatvfs  (int fd, int pri, eio_cb cb, void *data); /* stat buffer=ptr2 allocated dynamically */\n+eio_req *eio_futime    (int fd, eio_tstamp atime, eio_tstamp mtime, int pri, eio_cb cb, void *data);\n+eio_req *eio_ftruncate (int fd, off_t offset, int pri, eio_cb cb, void *data);\n+eio_req *eio_fchmod    (int fd, mode_t mode, int pri, eio_cb cb, void *data);\n+eio_req *eio_fchown    (int fd, uid_t uid, gid_t gid, int pri, eio_cb cb, void *data);\n+eio_req *eio_dup2      (int fd, int fd2, int pri, eio_cb cb, void *data);\n+eio_req *eio_sendfile  (int out_fd, int in_fd, off_t in_offset, size_t length, int pri, eio_cb cb, void *data);\n+eio_req *eio_open      (const char *path, int flags, mode_t mode, int pri, eio_cb cb, void *data);\n+eio_req *eio_utime     (const char *path, eio_tstamp atime, eio_tstamp mtime, int pri, eio_cb cb, void *data);\n+eio_req *eio_truncate  (const char *path, off_t offset, int pri, eio_cb cb, void *data);\n+eio_req *eio_chown     (const char *path, uid_t uid, gid_t gid, int pri, eio_cb cb, void *data);\n+eio_req *eio_chmod     (const char *path, mode_t mode, int pri, eio_cb cb, void *data);\n+eio_req *eio_mkdir     (const char *path, mode_t mode, int pri, eio_cb cb, void *data);\n+eio_req *eio_readdir   (const char *path, int flags, int pri, eio_cb cb, void *data); /* result=ptr2 allocated dynamically */\n+eio_req *eio_rmdir     (const char *path, int pri, eio_cb cb, void *data);\n+eio_req *eio_unlink    (const char *path, int pri, eio_cb cb, void *data);\n+eio_req *eio_readlink  (const char *path, int pri, eio_cb cb, void *data); /* result=ptr2 allocated dynamically */\n+eio_req *eio_stat      (const char *path, int pri, eio_cb cb, void *data); /* stat buffer=ptr2 allocated dynamically */\n+eio_req *eio_lstat     (const char *path, int pri, eio_cb cb, void *data); /* stat buffer=ptr2 allocated dynamically */\n+eio_req *eio_statvfs   (const char *path, int pri, eio_cb cb, void *data); /* stat buffer=ptr2 allocated dynamically */\n+eio_req *eio_mknod     (const char *path, mode_t mode, dev_t dev, int pri, eio_cb cb, void *data);\n+eio_req *eio_link      (const char *path, const char *new_path, int pri, eio_cb cb, void *data);\n+eio_req *eio_symlink   (const char *path, const char *new_path, int pri, eio_cb cb, void *data);\n+eio_req *eio_rename    (const char *path, const char *new_path, int pri, eio_cb cb, void *data);\n+eio_req *eio_custom    (eio_cb execute, int pri, eio_cb cb, void *data);\n+#endif\n+\n+/*****************************************************************************/\n+/* groups */\n+\n+eio_req *eio_grp       (eio_cb cb, void *data);\n+void eio_grp_feed      (eio_req *grp, void (*feed)(eio_req *req), int limit);\n+void eio_grp_limit     (eio_req *grp, int limit);\n+void eio_grp_add       (eio_req *grp, eio_req *req);\n+void eio_grp_cancel    (eio_req *grp); /* cancels all sub requests but not the group */\n+\n+/*****************************************************************************/\n+/* request api */\n+\n+/* true if the request was cancelled, useful in the invoke callback */\n+#define EIO_CANCELLED(req)   ((req)->flags & EIO_FLAG_CANCELLED)\n+\n+#define EIO_RESULT(req)      ((req)->result)\n+/* returns a pointer to the result buffer allocated by eio */\n+#define EIO_BUF(req)         ((req)->ptr2)\n+#define EIO_STAT_BUF(req)    ((EIO_STRUCT_STAT    *)EIO_BUF(req))\n+#define EIO_STATVFS_BUF(req) ((EIO_STRUCT_STATVFS *)EIO_BUF(req))\n+#define EIO_PATH(req)        ((char *)(req)->ptr1)\n+\n+/* submit a request for execution */\n+void eio_submit (eio_req *req);\n+/* cancel a request as soon fast as possible, if possible */\n+void eio_cancel (eio_req *req);\n+/* destroy a request that has never been submitted */\n+void eio_destroy (eio_req *req);\n+\n+/*****************************************************************************/\n+/* convinience functions */\n+\n+ssize_t eio_sendfile_sync (int ofd, int ifd, off_t offset, size_t count);\n+\n+/*****************************************************************************/\n+/* export these so node_file can use these function instead of pread/write */\n+\n+#if !HAVE_PREADWRITE\n+ssize_t eio__pread (int fd, void *buf, size_t count, off_t offset);\n+ssize_t eio__pwrite (int fd, void *buf, size_t count, off_t offset);\n+#endif\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n+"}, {"sha": "526b9f1bcb9c917cb482e30892b4827608ca408f", "filename": "src/rt/libuv/include/ev.h", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Finclude%2Fev.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Finclude%2Fev.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fev.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -197,7 +197,7 @@ struct ev_loop;\n \n /* eventmask, revents, events... */\n enum {\n-  EV_UNDEF    = 0xFFFFFFFF, /* guaranteed to be invalid */\n+  EV_UNDEF    =         -1, /* guaranteed to be invalid */\n   EV_NONE     =       0x00, /* no events */\n   EV_READ     =       0x01, /* ev_io detected read will not block */\n   EV_WRITE    =       0x02, /* ev_io detected write will not block */\n@@ -219,7 +219,7 @@ enum {\n   EV_CLEANUP  = 0x00040000, /* event loop resumed in child */\n   EV_ASYNC    = 0x00080000, /* async intra-loop signal */\n   EV_CUSTOM   = 0x01000000, /* for use by user code */\n-  EV_ERROR    = 0x80000000  /* sent when an error occurs */\n+  EV_ERROR    = (-2147483647 - 1) /* sent when an error occurs */\n };\n \n /* can be used to add custom fields to all watchers, while losing binary compatibility */", "previous_filename": "src/rt/libuv/ev/ev.h"}, {"sha": "f8576d67dc24f44fa6d1cf5c112ad15160457d7e", "filename": "src/rt/libuv/include/ngx-queue.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Finclude%2Fngx-queue.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Finclude%2Fngx-queue.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fngx-queue.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ngx-queue.h"}, {"sha": "37966d353c3de68aefa5dba3e773dc8513d0c9d7", "filename": "src/rt/libuv/include/tree.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Finclude%2Ftree.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Finclude%2Ftree.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Ftree.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/tree.h"}, {"sha": "f68a7fd6fd977980289ba920f5934f324f44e975", "filename": "src/rt/libuv/include/uv-unix.h", "status": "renamed", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Finclude%2Fuv-unix.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Finclude%2Fuv-unix.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-unix.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -24,9 +24,11 @@\n \n #include \"ngx-queue.h\"\n \n-#include \"ev/ev.h\"\n+#include \"ev.h\"\n \n+#include <sys/types.h>\n #include <sys/socket.h>\n+#include <netdb.h>\n #include <netinet/in.h>\n #include <netinet/tcp.h>\n \n@@ -37,13 +39,15 @@ typedef struct {\n   size_t len;\n } uv_buf_t;\n \n+#define UV_REQ_BUFSML_SIZE (4)\n \n #define UV_REQ_PRIVATE_FIELDS \\\n   int write_index; \\\n   ev_timer timer; \\\n   ngx_queue_t queue; \\\n   uv_buf_t* bufs; \\\n-  int bufcnt;\n+  int bufcnt; \\\n+  uv_buf_t bufsml[UV_REQ_BUFSML_SIZE];\n \n \n /* TODO: union or classes please! */\n@@ -53,48 +57,64 @@ typedef struct {\n   ev_idle next_watcher;\n \n \n+#define UV_STREAM_PRIVATE_FIELDS \\\n+  uv_read_cb read_cb; \\\n+  uv_alloc_cb alloc_cb;\n+\n+\n /* UV_TCP */\n #define UV_TCP_PRIVATE_FIELDS \\\n   int delayed_error; \\\n-  uv_read_cb read_cb; \\\n-  uv_alloc_cb alloc_cb; \\\n   uv_connection_cb connection_cb; \\\n   int accepted_fd; \\\n   uv_req_t *connect_req; \\\n   uv_req_t *shutdown_req; \\\n   ev_io read_watcher; \\\n   ev_io write_watcher; \\\n-  ngx_queue_t write_queue;\n+  ngx_queue_t write_queue; \\\n+  ngx_queue_t write_completed_queue;\n \n \n /* UV_PREPARE */ \\\n #define UV_PREPARE_PRIVATE_FIELDS \\\n   ev_prepare prepare_watcher; \\\n-  uv_loop_cb prepare_cb;\n+  uv_prepare_cb prepare_cb;\n \n \n /* UV_CHECK */\n #define UV_CHECK_PRIVATE_FIELDS \\\n   ev_check check_watcher; \\\n-  uv_loop_cb check_cb;\n+  uv_check_cb check_cb;\n \n \n /* UV_IDLE */\n #define UV_IDLE_PRIVATE_FIELDS \\\n   ev_idle idle_watcher; \\\n-  uv_loop_cb idle_cb;\n+  uv_idle_cb idle_cb;\n \n \n /* UV_ASYNC */\n #define UV_ASYNC_PRIVATE_FIELDS \\\n   ev_async async_watcher; \\\n-  uv_loop_cb async_cb;\n+  uv_async_cb async_cb;\n \n \n /* UV_TIMER */\n #define UV_TIMER_PRIVATE_FIELDS \\\n   ev_timer timer_watcher; \\\n-  uv_loop_cb timer_cb;\n+  uv_timer_cb timer_cb;\n \n+#define UV_ARES_TASK_PRIVATE_FIELDS \\\n+  int sock; \\\n+  ev_io read_watcher; \\\n+  ev_io write_watcher;\n+\n+#define UV_GETADDRINFO_PRIVATE_FIELDS \\\n+  uv_getaddrinfo_cb cb; \\\n+  struct addrinfo* hints; \\\n+  char* hostname; \\\n+  char* service; \\\n+  struct addrinfo* res; \\\n+  int retcode;\n \n #endif /* UV_UNIX_H */", "previous_filename": "src/rt/libuv/uv-unix.h"}, {"sha": "e6254fee09ae6d477077c5c1aab865e77b6a6e58", "filename": "src/rt/libuv/include/uv-win.h", "status": "renamed", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Finclude%2Fuv-win.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Finclude%2Fuv-win.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-win.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -31,7 +31,6 @@\n \n #include \"tree.h\"\n \n-\n /**\n  * It should be possible to cast uv_buf_t[] to WSABUF[]\n  * see http://msdn.microsoft.com/en-us/library/ms741542(v=vs.85).aspx\n@@ -53,10 +52,12 @@ typedef struct uv_buf_t {\n   uv_err_t error;                         \\\n   struct uv_req_s* next_req;\n \n-#define uv_tcp_connection_fields          \\\n+#define UV_STREAM_PRIVATE_FIELDS          \\\n   uv_alloc_cb alloc_cb;                   \\\n   uv_read_cb read_cb;                     \\\n   struct uv_req_s read_req;               \\\n+  \n+#define uv_tcp_connection_fields          \\\n   unsigned int write_reqs_pending;        \\\n   uv_req_t* shutdown_req;\n \n@@ -81,32 +82,49 @@ typedef struct uv_buf_t {\n   RB_ENTRY(uv_timer_s) tree_entry;        \\\n   int64_t due;                            \\\n   int64_t repeat;                         \\\n-  uv_loop_cb timer_cb;\n-\n-#define UV_LOOP_PRIVATE_FIELDS            \\\n-  uv_handle_t* loop_prev;                 \\\n-  uv_handle_t* loop_next;                 \\\n-  uv_loop_cb loop_cb;\n+  uv_timer_cb timer_cb;\n \n #define UV_ASYNC_PRIVATE_FIELDS           \\\n   struct uv_req_s async_req;              \\\n   /* char to avoid alignment issues */    \\\n   char volatile async_sent;\n \n-#define UV_PREPARE_PRIVATE_FIELDS /* empty */\n-#define UV_CHECK_PRIVATE_FIELDS   /* empty */\n-#define UV_IDLE_PRIVATE_FIELDS    /* empty */\n+#define UV_PREPARE_PRIVATE_FIELDS         \\\n+  uv_prepare_t* prepare_prev;             \\\n+  uv_prepare_t* prepare_next;             \\\n+  uv_prepare_cb prepare_cb;\n \n-/*\n- * TODO: remove UV_LOOP_PRIVATE_FIELDS from UV_HANDLE_PRIVATE_FIELDS and\n- * use it in UV_(PREPARE|CHECK|IDLE)_PRIVATE_FIELDS instead.\n- */\n+#define UV_CHECK_PRIVATE_FIELDS           \\\n+  uv_check_t* check_prev;                 \\\n+  uv_check_t* check_next;                 \\\n+  uv_check_cb check_cb;\n+\n+#define UV_IDLE_PRIVATE_FIELDS            \\\n+  uv_idle_t* idle_prev;                   \\\n+  uv_idle_t* idle_next;                   \\\n+  uv_idle_cb idle_cb;\n \n #define UV_HANDLE_PRIVATE_FIELDS          \\\n   uv_handle_t* endgame_next;              \\\n   unsigned int flags;                     \\\n-  uv_err_t error;                         \\\n-  UV_LOOP_PRIVATE_FIELDS\n-\n+  uv_err_t error;\n+\n+#define UV_ARES_TASK_PRIVATE_FIELDS       \\\n+  struct uv_req_s ares_req;               \\\n+  SOCKET sock;                            \\\n+  HANDLE h_wait;                          \\\n+  WSAEVENT h_event;                       \\\n+  HANDLE h_close_event;\n+\n+#define UV_GETADDRINFO_PRIVATE_FIELDS     \\\n+  struct uv_req_s getadddrinfo_req;       \\\n+  uv_getaddrinfo_cb getaddrinfo_cb;       \\\n+  void* alloc;                            \\\n+  wchar_t* node;                          \\\n+  wchar_t* service;                       \\\n+  struct addrinfoW* hints;                \\\n+  struct addrinfoW* res;                  \\\n+  int retcode;\n \n int uv_utf16_to_utf8(wchar_t* utf16Buffer, size_t utf16Size, char* utf8Buffer, size_t utf8Size);\n+int uv_utf8_to_utf16(const char* utf8Buffer, wchar_t* utf16Buffer, size_t utf16Size);", "previous_filename": "src/rt/libuv/uv-win.h"}, {"sha": "6aecb282008768f5d2776d843d0f9127e49e24b1", "filename": "src/rt/libuv/include/uv.h", "status": "renamed", "additions": 156, "deletions": 44, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Finclude%2Fuv.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Finclude%2Fuv.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -28,21 +28,28 @@ extern \"C\" {\n #define UV_VERSION_MAJOR 0\n #define UV_VERSION_MINOR 1\n \n+#define CARES_STATICLIB 1\n+\n #include <stdint.h> /* int64_t */\n #include <sys/types.h> /* size_t */\n \n-#ifndef ssize_t\n+#include \"ares.h\"\n+\n+#ifndef _SSIZE_T_\n typedef intptr_t ssize_t;\n #endif\n \n typedef struct uv_err_s uv_err_t;\n typedef struct uv_handle_s uv_handle_t;\n+typedef struct uv_stream_s uv_stream_t;\n typedef struct uv_tcp_s uv_tcp_t;\n typedef struct uv_timer_s uv_timer_t;\n typedef struct uv_prepare_s uv_prepare_t;\n typedef struct uv_check_s uv_check_t;\n typedef struct uv_idle_s uv_idle_t;\n typedef struct uv_req_s uv_req_t;\n+typedef struct uv_async_s uv_async_t;\n+typedef struct uv_getaddrinfo_s uv_getaddrinfo_t;\n \n \n #if defined(__unix__) || defined(__POSIX__) || defined(__APPLE__)\n@@ -60,16 +67,20 @@ typedef struct uv_req_s uv_req_t;\n  * In the case of uv_read_cb the uv_buf_t returned should be freed by the\n  * user.\n  */\n-typedef uv_buf_t (*uv_alloc_cb)(uv_tcp_t* tcp, size_t suggested_size);\n-typedef void (*uv_read_cb)(uv_tcp_t* tcp, ssize_t nread, uv_buf_t buf);\n+typedef uv_buf_t (*uv_alloc_cb)(uv_stream_t* tcp, size_t suggested_size);\n+typedef void (*uv_read_cb)(uv_stream_t* tcp, ssize_t nread, uv_buf_t buf);\n typedef void (*uv_write_cb)(uv_req_t* req, int status);\n typedef void (*uv_connect_cb)(uv_req_t* req, int status);\n typedef void (*uv_shutdown_cb)(uv_req_t* req, int status);\n-typedef void (*uv_connection_cb)(uv_tcp_t* server, int status);\n+typedef void (*uv_connection_cb)(uv_handle_t* server, int status);\n typedef void (*uv_close_cb)(uv_handle_t* handle);\n-/* TODO: do loop_cb and async_cb really need a status argument? */\n-typedef void (*uv_loop_cb)(uv_handle_t* handle, int status);\n-typedef void (*uv_async_cb)(uv_handle_t* handle, int status);\n+typedef void (*uv_timer_cb)(uv_timer_t* handle, int status);\n+/* TODO: do these really need a status argument? */\n+typedef void (*uv_async_cb)(uv_async_t* handle, int status);\n+typedef void (*uv_prepare_cb)(uv_prepare_t* handle, int status);\n+typedef void (*uv_check_cb)(uv_check_t* handle, int status);\n+typedef void (*uv_idle_cb)(uv_idle_t* handle, int status);\n+typedef void (*uv_getaddrinfo_cb)(uv_getaddrinfo_t* handle, int status, struct addrinfo* res);\n \n \n /* Expand this list if necessary. */\n@@ -108,7 +119,12 @@ typedef enum {\n   UV_EPROTO,\n   UV_EPROTONOSUPPORT,\n   UV_EPROTOTYPE,\n-  UV_ETIMEDOUT\n+  UV_ETIMEDOUT,\n+  UV_ECHARSET,\n+  UV_EAIFAMNOSUPPORT,\n+  UV_EAINONAME,\n+  UV_EAISERVICE,\n+  UV_EAISOCKTYPE\n } uv_err_code;\n \n typedef enum {\n@@ -121,7 +137,10 @@ typedef enum {\n   UV_PREPARE,\n   UV_CHECK,\n   UV_IDLE,\n-  UV_ASYNC\n+  UV_ASYNC,\n+  UV_ARES,\n+  UV_ARES_TASK,\n+  UV_GETADDRINFO\n } uv_handle_type;\n \n typedef enum {\n@@ -148,7 +167,7 @@ struct uv_req_s {\n   uv_req_type type;\n   /* public */\n   uv_handle_t* handle;\n-  void* cb;\n+  void *(*cb)(void *);\n   void* data;\n   /* private */\n   UV_REQ_PRIVATE_FIELDS\n@@ -157,7 +176,9 @@ struct uv_req_s {\n /*\n  * Initialize a request for use with uv_write, uv_shutdown, or uv_connect.\n  */\n-void uv_req_init(uv_req_t* req, uv_handle_t* handle, void* cb);\n+void uv_req_init(uv_req_t* req, uv_handle_t* handle, void *(*cb)(void *));\n+\n+int uv_shutdown(uv_req_t* req);\n \n \n #define UV_HANDLE_FIELDS \\\n@@ -167,7 +188,7 @@ void uv_req_init(uv_req_t* req, uv_handle_t* handle, void* cb);\n   uv_close_cb close_cb; \\\n   void* data; \\\n   /* private */ \\\n-  UV_HANDLE_PRIVATE_FIELDS \\\n+  UV_HANDLE_PRIVATE_FIELDS\n \n /* The abstract base class of all handles.  */\n struct uv_handle_s {\n@@ -187,33 +208,29 @@ int uv_is_active(uv_handle_t* handle);\n int uv_close(uv_handle_t* handle, uv_close_cb close_cb);\n \n \n-/*\n- * A subclass of uv_handle_t representing a TCP stream or TCP server. In the\n- * future this will probably be split into two classes - one a stream and\n- * the other a server.\n- */\n-struct uv_tcp_s {\n+#define UV_STREAM_FIELDS \\\n+  /* number of bytes queued for writing */ \\\n+  size_t write_queue_size; \\\n+  /* private */ \\\n+  UV_STREAM_PRIVATE_FIELDS\n+\n+/* The abstract base class for all streams. */\n+struct uv_stream_s {\n   UV_HANDLE_FIELDS\n-  size_t write_queue_size; /* number of bytes queued for writing */\n-  UV_TCP_PRIVATE_FIELDS\n+  UV_STREAM_FIELDS\n };\n \n-int uv_tcp_init(uv_tcp_t* handle);\n-\n-int uv_bind(uv_tcp_t* handle, struct sockaddr_in);\n-\n-int uv_connect(uv_req_t* req, struct sockaddr_in);\n-\n-int uv_shutdown(uv_req_t* req);\n-\n-int uv_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb);\n-\n-/* This call is used in conjunction with uv_listen() to accept incoming TCP\n+/* This call is used in conjunction with uv_listen() to accept incoming\n  * connections. Call uv_accept after receiving a uv_connection_cb to accept\n- * the connection. Before calling uv_accept use uv_tcp_init() must be\n+ * the connection. Before calling uv_accept use uv_*_init() must be\n  * called on the client. Non-zero return value indicates an error.\n+ *\n+ * When the uv_connection_cb is called it is guaranteed that uv_accept will\n+ * complete successfully the first time. If you attempt to use it more than\n+ * once, it may fail. It is suggested to only call uv_accept once per\n+ * uv_connection_cb call.\n  */\n-int uv_accept(uv_tcp_t* server, uv_tcp_t* client);\n+int uv_accept(uv_handle_t* server, uv_stream_t* client);\n \n /* Read data from an incoming stream. The callback will be made several\n  * several times until there is no more data to read or uv_read_stop is\n@@ -224,13 +241,52 @@ int uv_accept(uv_tcp_t* server, uv_tcp_t* client);\n  * eof; it happens when libuv requested a buffer through the alloc callback\n  * but then decided that it didn't need that buffer.\n  */\n-int uv_read_start(uv_tcp_t*, uv_alloc_cb alloc_cb, uv_read_cb read_cb);\n+int uv_read_start(uv_stream_t*, uv_alloc_cb alloc_cb, uv_read_cb read_cb);\n \n-int uv_read_stop(uv_tcp_t*);\n+int uv_read_stop(uv_stream_t*);\n \n+/* Write data to stream. Buffers are written in order. Example:\n+ *\n+ *   uv_buf_t a[] = {\n+ *     { .base = \"1\", .len = 1 },\n+ *     { .base = \"2\", .len = 1 }\n+ *   };\n+ *\n+ *   uv_buf_t b[] = {\n+ *     { .base = \"3\", .len = 1 },\n+ *     { .base = \"4\", .len = 1 }\n+ *   };\n+ *\n+ *   // writes \"1234\"\n+ *   uv_write(req, a, 2);\n+ *   uv_write(req, b, 2);\n+ *\n+ */\n int uv_write(uv_req_t* req, uv_buf_t bufs[], int bufcnt);\n \n \n+/*\n+ * A subclass of uv_stream_t representing a TCP stream or TCP server. In the\n+ * future this will probably be split into two classes - one a stream and\n+ * the other a server.\n+ */\n+struct uv_tcp_s {\n+  UV_HANDLE_FIELDS\n+  UV_STREAM_FIELDS\n+  UV_TCP_PRIVATE_FIELDS\n+};\n+\n+int uv_tcp_init(uv_tcp_t* handle);\n+\n+int uv_tcp_bind(uv_tcp_t* handle, struct sockaddr_in);\n+int uv_tcp_bind6(uv_tcp_t* handle, struct sockaddr_in6);\n+\n+int uv_tcp_connect(uv_req_t* req, struct sockaddr_in);\n+int uv_tcp_connect6(uv_req_t* req, struct sockaddr_in6);\n+\n+int uv_tcp_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb);\n+\n+\n /*\n  * Subclass of uv_handle_t. libev wrapper. Every active prepare handle gets\n  * its callback called exactly once per loop iteration, just before the\n@@ -243,7 +299,7 @@ struct uv_prepare_s {\n \n int uv_prepare_init(uv_prepare_t* prepare);\n \n-int uv_prepare_start(uv_prepare_t* prepare, uv_loop_cb cb);\n+int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb);\n \n int uv_prepare_stop(uv_prepare_t* prepare);\n \n@@ -260,7 +316,7 @@ struct uv_check_s {\n \n int uv_check_init(uv_check_t* check);\n \n-int uv_check_start(uv_check_t* check, uv_loop_cb cb);\n+int uv_check_start(uv_check_t* check, uv_check_cb cb);\n \n int uv_check_stop(uv_check_t* check);\n \n@@ -278,7 +334,7 @@ struct uv_idle_s {\n \n int uv_idle_init(uv_idle_t* idle);\n \n-int uv_idle_start(uv_idle_t* idle, uv_loop_cb cb);\n+int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb);\n \n int uv_idle_stop(uv_idle_t* idle);\n \n@@ -291,10 +347,10 @@ int uv_idle_stop(uv_idle_t* idle);\n  * after the call to async_send. Unlike all other libuv functions,\n  * uv_async_send can be called from another thread.\n  */\n-typedef struct {\n+struct uv_async_s {\n   UV_HANDLE_FIELDS\n   UV_ASYNC_PRIVATE_FIELDS\n-} uv_async_t;\n+};\n \n int uv_async_init(uv_async_t* async, uv_async_cb async_cb);\n \n@@ -312,7 +368,7 @@ struct uv_timer_s {\n \n int uv_timer_init(uv_timer_t* timer);\n \n-int uv_timer_start(uv_timer_t* timer, uv_loop_cb cb, int64_t timeout, int64_t repeat);\n+int uv_timer_start(uv_timer_t* timer, uv_timer_cb cb, int64_t timeout, int64_t repeat);\n \n int uv_timer_stop(uv_timer_t* timer);\n \n@@ -334,6 +390,37 @@ void uv_timer_set_repeat(uv_timer_t* timer, int64_t repeat);\n int64_t uv_timer_get_repeat(uv_timer_t* timer);\n \n \n+/* c-ares integration initialize and terminate */\n+int uv_ares_init_options(ares_channel *channelptr,\n+                        struct ares_options *options,\n+                        int optmask);\n+\n+void uv_ares_destroy(ares_channel channel);\n+\n+\n+/*\n+ * Subclass of uv_handle_t. Used for integration of getaddrinfo.\n+ */\n+struct uv_getaddrinfo_s {\n+  UV_HANDLE_FIELDS\n+  UV_GETADDRINFO_PRIVATE_FIELDS\n+};\n+\n+\n+/* uv_getaddrinfo\n+ * return code of UV_OK means that request is accepted,\n+ * and callback will be called with result.\n+ * Other return codes mean that there will not be a callback.\n+ * Input arguments may be released after return from this call.\n+ * Callback must not call freeaddrinfo\n+ */\n+ int uv_getaddrinfo(uv_getaddrinfo_t* handle,\n+                    uv_getaddrinfo_cb getaddrinfo_cb,\n+                    const char* node,\n+                    const char* service,\n+                    const struct addrinfo* hints);\n+\n+\n /*\n  * Most functions return boolean: 0 for success and -1 for failure.\n  * On error the user should then call uv_last_error() to determine\n@@ -358,10 +445,22 @@ int64_t uv_now();\n \n \n /* Utility */\n-struct sockaddr_in uv_ip4_addr(char* ip, int port);\n+struct sockaddr_in uv_ip4_addr(const char* ip, int port);\n+struct sockaddr_in6 uv_ip6_addr(const char* ip, int port);\n \n /* Gets the executable path */\n-int uv_get_exepath(char* buffer, size_t* size);\n+int uv_exepath(char* buffer, size_t* size);\n+\n+/*\n+ * Returns the current high-resolution real time. This is expressed in\n+ * nanoseconds. It is relative to an arbitrary time in the past. It is not\n+ * related to the time of day and therefore not subject to clock drift. The\n+ * primary use is for measuring performance between intervals.\n+ *\n+ * Note not every platform can support nanosecond resolution; however, this\n+ * value will always be in nanoseconds.\n+ */\n+extern uint64_t uv_hrtime(void);\n \n \n /* the presence of this union forces similar struct layout */\n@@ -372,6 +471,7 @@ union uv_any_handle {\n   uv_idle_t idle;\n   uv_async_t async;\n   uv_timer_t timer;\n+  uv_getaddrinfo_t getaddrinfo;\n };\n \n /* Diagnostic counters */\n@@ -386,7 +486,19 @@ typedef struct {\n   uint64_t timer_init;\n } uv_counters_t;\n \n-uv_counters_t* const uv_counters();\n+uv_counters_t* uv_counters();\n+\n+\n+/* Don't export the private CPP symbols. */\n+#undef UV_REQ_PRIVATE_FIELDS\n+#undef UV_STREAM_PRIVATE_FIELDS\n+#undef UV_TCP_PRIVATE_FIELDS\n+#undef UV_PREPARE_PRIVATE_FIELDS\n+#undef UV_CHECK_PRIVATE_FIELDS\n+#undef UV_IDLE_PRIVATE_FIELDS\n+#undef UV_ASYNC_PRIVATE_FIELDS\n+#undef UV_TIMER_PRIVATE_FIELDS\n+#undef UV_GETADDRINFO_PRIVATE_FIELDS\n \n #ifdef __cplusplus\n }", "previous_filename": "src/rt/libuv/uv.h"}, {"sha": "4ada6ccb3df0ddb10331ea66b9e102598cd242a4", "filename": "src/rt/libuv/msvs/c-ares.vcxproj", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fmsvs%2Fc-ares.vcxproj", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fmsvs%2Fc-ares.vcxproj", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fmsvs%2Fc-ares.vcxproj?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,179 @@\n+\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<Project DefaultTargets=\"Build\" ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n+  <ItemGroup Label=\"ProjectConfigurations\">\n+    <ProjectConfiguration Include=\"Debug|Win32\">\n+      <Configuration>Debug</Configuration>\n+      <Platform>Win32</Platform>\n+    </ProjectConfiguration>\n+    <ProjectConfiguration Include=\"Debug|x64\">\n+      <Configuration>Debug</Configuration>\n+      <Platform>x64</Platform>\n+    </ProjectConfiguration>\n+    <ProjectConfiguration Include=\"Release|Win32\">\n+      <Configuration>Release</Configuration>\n+      <Platform>Win32</Platform>\n+    </ProjectConfiguration>\n+    <ProjectConfiguration Include=\"Release|x64\">\n+      <Configuration>Release</Configuration>\n+      <Platform>x64</Platform>\n+    </ProjectConfiguration>\n+  </ItemGroup>\n+  <PropertyGroup Label=\"Globals\">\n+    <Keyword>Win32Proj</Keyword>\n+  </PropertyGroup>\n+  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"Configuration\">\n+    <ConfigurationType>StaticLibrary</ConfigurationType>\n+    <UseDebugLibraries>true</UseDebugLibraries>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\n+    <ConfigurationType>StaticLibrary</ConfigurationType>\n+    <UseDebugLibraries>true</UseDebugLibraries>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"Configuration\">\n+    <ConfigurationType>StaticLibrary</ConfigurationType>\n+    <UseDebugLibraries>false</UseDebugLibraries>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n+    <ConfigurationType>StaticLibrary</ConfigurationType>\n+    <UseDebugLibraries>false</UseDebugLibraries>\n+  </PropertyGroup>\n+  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n+  <ImportGroup Label=\"ExtensionSettings\">\n+  </ImportGroup>\n+  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n+    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n+  </ImportGroup>\n+  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"PropertySheets\">\n+    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n+  </ImportGroup>\n+  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n+    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n+  </ImportGroup>\n+  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"PropertySheets\">\n+    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n+  </ImportGroup>\n+  <PropertyGroup Label=\"UserMacros\" />\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n+    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n+    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n+    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n+    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n+    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n+    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n+    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n+    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n+  </PropertyGroup>\n+  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n+    <ClCompile>\n+      <PreprocessorDefinitions>WIN32;HAVE_CONFIG_H;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n+      <WarningLevel>Level3</WarningLevel>\n+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n+      <Optimization>Disabled</Optimization>\n+      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n+    </ClCompile>\n+  </ItemDefinitionGroup>\n+  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n+    <ClCompile>\n+      <PreprocessorDefinitions>WIN32;HAVE_CONFIG_H;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n+      <WarningLevel>Level3</WarningLevel>\n+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n+      <Optimization>Disabled</Optimization>\n+      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n+    </ClCompile>\n+  </ItemDefinitionGroup>\n+  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n+    <ClCompile>\n+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n+      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n+      <PreprocessorDefinitions>WIN32;HAVE_CONFIG_H;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n+    </ClCompile>\n+  </ItemDefinitionGroup>\n+  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n+    <ClCompile>\n+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n+      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n+      <PreprocessorDefinitions>WIN32;HAVE_CONFIG_H;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n+    </ClCompile>\n+  </ItemDefinitionGroup>\n+  <ItemGroup>\n+    <ClCompile Include=\"..\\src\\ares\\ares__close_sockets.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares__get_hostent.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares__read_line.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares__timeval.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_cancel.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_data.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_destroy.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_expand_name.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_expand_string.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_fds.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_free_hostent.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_free_string.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_gethostbyaddr.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_gethostbyname.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_getnameinfo.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_getsock.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_init.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_library_init.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_llist.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_mkquery.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_nowarn.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_options.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_parse_a_reply.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_parse_aaaa_reply.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_parse_mx_reply.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_parse_ns_reply.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_parse_ptr_reply.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_parse_srv_reply.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_parse_txt_reply.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_process.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_query.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_search.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_send.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_strcasecmp.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_strdup.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_strerror.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_timeout.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_version.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\ares_writev.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\bitncmp.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\inet_net_pton.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\inet_ntop.c\" />\n+    <ClCompile Include=\"..\\src\\ares\\windows_port.c\" />\n+  </ItemGroup>\n+  <ItemGroup>\n+    <ClInclude Include=\"..\\include\\ares.h\" />\n+    <ClInclude Include=\"..\\include\\ares_version.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\ares_data.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\ares_dns.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\ares_iphlpapi.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\ares_ipv6.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\ares_library_init.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\ares_llist.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\ares_nowarn.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\ares_private.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\ares_rules.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\ares_setup.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\ares_strcasecmp.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\ares_strdup.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\ares_version.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\ares_writev.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\bitncmp.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\config_win32\\ares_config.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\inet_net_pton.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\inet_ntop.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\nameser.h\" />\n+    <ClInclude Include=\"..\\src\\ares\\setup_once.h\" />\n+  </ItemGroup>\n+  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n+  <ImportGroup Label=\"ExtensionTargets\">\n+  </ImportGroup>\n+</Project>"}, {"sha": "5727a1aa3c8959ab29edefdd5f97130013455522", "filename": "src/rt/libuv/msvs/libuv-benchmark.vcxproj", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fmsvs%2Flibuv-benchmark.vcxproj", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fmsvs%2Flibuv-benchmark.vcxproj", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fmsvs%2Flibuv-benchmark.vcxproj?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -81,6 +81,7 @@\n       <WarningLevel>Level3</WarningLevel>\n       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n       <Optimization>Disabled</Optimization>\n+      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n     </ClCompile>\n     <Link>\n       <TargetMachine>MachineX86</TargetMachine>\n@@ -96,6 +97,7 @@\n       <WarningLevel>Level3</WarningLevel>\n       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n       <Optimization>Disabled</Optimization>\n+      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n     </ClCompile>\n     <Link>\n       <GenerateDebugInformation>true</GenerateDebugInformation>\n@@ -109,6 +111,7 @@\n       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n       <WarningLevel>Level3</WarningLevel>\n       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n+      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n     </ClCompile>\n     <Link>\n       <TargetMachine>MachineX86</TargetMachine>\n@@ -125,6 +128,7 @@\n       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n       <WarningLevel>Level3</WarningLevel>\n       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n+      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n     </ClCompile>\n     <Link>\n       <GenerateDebugInformation>true</GenerateDebugInformation>\n@@ -135,28 +139,19 @@\n     </Link>\n   </ItemDefinitionGroup>\n   <ItemGroup>\n+    <ClCompile Include=\"..\\test\\benchmark-ares.c\" />\n+    <ClCompile Include=\"..\\test\\benchmark-getaddrinfo.c\" />\n     <ClCompile Include=\"..\\test\\benchmark-ping-pongs.c\" />\n     <ClCompile Include=\"..\\test\\benchmark-pump.c\" />\n     <ClCompile Include=\"..\\test\\benchmark-sizes.c\" />\n+    <ClCompile Include=\"..\\test\\dns-server.c\" />\n     <ClCompile Include=\"..\\test\\echo-server.c\" />\n     <ClCompile Include=\"..\\test\\run-benchmarks.c\" />\n-    <ClCompile Include=\"..\\test\\runner-unix.c\">\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">true</ExcludedFromBuild>\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">true</ExcludedFromBuild>\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</ExcludedFromBuild>\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">true</ExcludedFromBuild>\n-    </ClCompile>\n     <ClCompile Include=\"..\\test\\runner-win.c\" />\n     <ClCompile Include=\"..\\test\\runner.c\" />\n   </ItemGroup>\n   <ItemGroup>\n     <ClInclude Include=\"..\\test\\benchmark-list.h\" />\n-    <ClInclude Include=\"..\\test\\runner-unix.h\">\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">true</ExcludedFromBuild>\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">true</ExcludedFromBuild>\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</ExcludedFromBuild>\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">true</ExcludedFromBuild>\n-    </ClInclude>\n     <ClInclude Include=\"..\\test\\runner-win.h\" />\n     <ClInclude Include=\"..\\test\\runner.h\" />\n     <ClInclude Include=\"..\\test\\task.h\" />"}, {"sha": "5b47daeb2018c751eee5140293b2d415674d2627", "filename": "src/rt/libuv/msvs/libuv-test.vcxproj", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fmsvs%2Flibuv-test.vcxproj", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fmsvs%2Flibuv-test.vcxproj", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fmsvs%2Flibuv-test.vcxproj?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -82,6 +82,7 @@\n       <WarningLevel>Level3</WarningLevel>\n       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n       <Optimization>Disabled</Optimization>\n+      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n     </ClCompile>\n     <Link>\n       <TargetMachine>MachineX86</TargetMachine>\n@@ -97,6 +98,7 @@\n       <WarningLevel>Level3</WarningLevel>\n       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n       <Optimization>Disabled</Optimization>\n+      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n     </ClCompile>\n     <Link>\n       <GenerateDebugInformation>true</GenerateDebugInformation>\n@@ -110,6 +112,7 @@\n       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n       <WarningLevel>Level3</WarningLevel>\n       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n+      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n     </ClCompile>\n     <Link>\n       <TargetMachine>MachineX86</TargetMachine>\n@@ -126,6 +129,7 @@\n       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n       <WarningLevel>Level3</WarningLevel>\n       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n+      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n     </ClCompile>\n     <Link>\n       <GenerateDebugInformation>true</GenerateDebugInformation>\n@@ -137,18 +141,16 @@\n   </ItemDefinitionGroup>\n   <ItemGroup>\n     <ClCompile Include=\"..\\test\\echo-server.c\" />\n-    <ClCompile Include=\"..\\test\\runner-unix.c\">\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">true</ExcludedFromBuild>\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">true</ExcludedFromBuild>\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</ExcludedFromBuild>\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">true</ExcludedFromBuild>\n-    </ClCompile>\n     <ClCompile Include=\"..\\test\\test-async.c\" />\n+    <ClCompile Include=\"..\\test\\test-bind6-error.c\" />\n     <ClCompile Include=\"..\\test\\test-delayed-accept.c\" />\n     <ClCompile Include=\"..\\test\\test-callback-stack.c\" />\n     <ClCompile Include=\"..\\test\\test-connection-fail.c\" />\n     <ClCompile Include=\"..\\test\\test-get-currentexe.c\" />\n     <ClCompile Include=\"..\\test\\test-fail-always.c\" />\n+    <ClCompile Include=\"..\\test\\test-gethostbyname.c\" />\n+    <ClCompile Include=\"..\\test\\test-getaddrinfo.c\" />\n+    <ClCompile Include=\"..\\test\\test-hrtime.c\" />\n     <ClCompile Include=\"..\\test\\test-loop-handles.c\" />\n     <ClCompile Include=\"..\\test\\test-pass-always.c\" />\n     <ClCompile Include=\"..\\test\\test-ping-pong.c\" />\n@@ -162,12 +164,6 @@\n     <ClCompile Include=\"..\\test\\run-tests.c\" />\n   </ItemGroup>\n   <ItemGroup>\n-    <ClInclude Include=\"..\\test\\runner-unix.h\">\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">true</ExcludedFromBuild>\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">true</ExcludedFromBuild>\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</ExcludedFromBuild>\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">true</ExcludedFromBuild>\n-    </ClInclude>\n     <ClInclude Include=\"..\\test\\test-list.h\" />\n     <ClInclude Include=\"..\\test\\runner-win.h\" />\n     <ClInclude Include=\"..\\test\\runner.h\" />"}, {"sha": "a4eca0a6d4b38b7e2352cb43bc03c3c3a9da71c7", "filename": "src/rt/libuv/msvs/libuv.sln", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fmsvs%2Flibuv.sln", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fmsvs%2Flibuv.sln", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fmsvs%2Flibuv.sln?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -7,6 +7,8 @@ Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"libuv-test\", \"libuv-test.vc\n EndProject\r\n Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"libuv-benchmark\", \"libuv-benchmark.vcxproj\", \"{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}\"\r\n EndProject\r\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"c-ares\", \"c-ares.vcxproj\", \"{2B6A4644-EBA9-DFB5-AF35-6C56EDF05C7F}\"\r\n+EndProject\r\n Global\r\n \tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n \t\tDebug|Win32 = Debug|Win32\r\n@@ -39,6 +41,14 @@ Global\n \t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Release|Win32.Build.0 = Release|Win32\r\n \t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Release|x64.ActiveCfg = Release|x64\r\n \t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Release|x64.Build.0 = Release|x64\r\n+\t\t{2B6A4644-EBA9-DFB5-AF35-6C56EDF05C7F}.Debug|Win32.ActiveCfg = Debug|Win32\r\n+\t\t{2B6A4644-EBA9-DFB5-AF35-6C56EDF05C7F}.Debug|Win32.Build.0 = Debug|Win32\r\n+\t\t{2B6A4644-EBA9-DFB5-AF35-6C56EDF05C7F}.Debug|x64.ActiveCfg = Debug|x64\r\n+\t\t{2B6A4644-EBA9-DFB5-AF35-6C56EDF05C7F}.Debug|x64.Build.0 = Debug|x64\r\n+\t\t{2B6A4644-EBA9-DFB5-AF35-6C56EDF05C7F}.Release|Win32.ActiveCfg = Release|Win32\r\n+\t\t{2B6A4644-EBA9-DFB5-AF35-6C56EDF05C7F}.Release|Win32.Build.0 = Release|Win32\r\n+\t\t{2B6A4644-EBA9-DFB5-AF35-6C56EDF05C7F}.Release|x64.ActiveCfg = Release|x64\r\n+\t\t{2B6A4644-EBA9-DFB5-AF35-6C56EDF05C7F}.Release|x64.Build.0 = Release|x64\r\n \tEndGlobalSection\r\n \tGlobalSection(SolutionProperties) = preSolution\r\n \t\tHideSolutionNode = FALSE\r"}, {"sha": "c896c6970f03b787a4e313bfabdbdc7efb724f5f", "filename": "src/rt/libuv/msvs/libuv.vcxproj", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fmsvs%2Flibuv.vcxproj", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fmsvs%2Flibuv.vcxproj", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fmsvs%2Flibuv.vcxproj?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -78,6 +78,7 @@\n       <WarningLevel>Level3</WarningLevel>\n       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n       <Optimization>Disabled</Optimization>\n+      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n     </ClCompile>\n   </ItemDefinitionGroup>\n   <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n@@ -87,48 +88,42 @@\n       <WarningLevel>Level3</WarningLevel>\n       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n       <Optimization>Disabled</Optimization>\n+      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n     </ClCompile>\n   </ItemDefinitionGroup>\n   <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n     <ClCompile>\n       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n+      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n     </ClCompile>\n   </ItemDefinitionGroup>\n   <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n     <ClCompile>\n       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n+      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n     </ClCompile>\n   </ItemDefinitionGroup>\n   <ItemGroup>\n-    <ClInclude Include=\"..\\ngx-queue.h\" />\n-    <ClInclude Include=\"..\\uv-unix.h\">\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">true</ExcludedFromBuild>\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">true</ExcludedFromBuild>\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</ExcludedFromBuild>\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">true</ExcludedFromBuild>\n-    </ClInclude>\n-    <ClInclude Include=\"..\\uv-win.h\" />\n-    <ClInclude Include=\"..\\uv.h\" />\n-    <ClInclude Include=\"..\\tree.h\" />\n+    <ProjectReference Include=\"c-ares.vcxproj\">\n+      <Project>{2b6a4644-eba9-dfb5-af35-6c56edf05c7f}</Project>\n+      <Private>true</Private>\n+      <ReferenceOutputAssembly>true</ReferenceOutputAssembly>\n+      <CopyLocalSatelliteAssemblies>false</CopyLocalSatelliteAssemblies>\n+      <LinkLibraryDependencies>true</LinkLibraryDependencies>\n+      <UseLibraryDependencyInputs>false</UseLibraryDependencyInputs>\n+    </ProjectReference>\n   </ItemGroup>\n   <ItemGroup>\n-    <ClCompile Include=\"..\\uv-unix.c\">\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">true</ExcludedFromBuild>\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">true</ExcludedFromBuild>\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</ExcludedFromBuild>\n-      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">true</ExcludedFromBuild>\n-    </ClCompile>\n-    <ClCompile Include=\"..\\uv-win.c\" />\n-    <ClCompile Include=\"..\\uv-common.c\" />\n+    <ClCompile Include=\"..\\src\\uv-common.c\" />\n+    <ClCompile Include=\"..\\src\\uv-win.c\" />\n   </ItemGroup>\n   <ItemGroup>\n-    <None Include=\"..\\AUTHORS\" />\n-    <None Include=\"..\\config-mingw.mk\" />\n-    <None Include=\"..\\config-unix.mk\" />\n-    <None Include=\"..\\iocp-links.html\" />\n-    <None Include=\"..\\LICENSE\" />\n-    <None Include=\"..\\Makefile\" />\n-    <None Include=\"..\\README\" />\n+    <ClInclude Include=\"..\\include\\ares.h\" />\n+    <ClInclude Include=\"..\\include\\ares_version.h\" />\n+    <ClInclude Include=\"..\\include\\tree.h\" />\n+    <ClInclude Include=\"..\\include\\uv-win.h\" />\n+    <ClInclude Include=\"..\\include\\uv.h\" />\n+    <ClInclude Include=\"..\\src\\uv-common.h\" />\n   </ItemGroup>\n   <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n   <ImportGroup Label=\"ExtensionTargets\">"}, {"sha": "e197a7419d0065f0865f7bf6aeb1c775396522f6", "filename": "src/rt/libuv/src/ares/AUTHORS", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FAUTHORS", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FAUTHORS", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FAUTHORS?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,37 @@\n+c-ares is based on ares, and these are the people that have worked on it since\n+the fork was made:\n+\n+Alexander Lazic\n+Alexey Simak\n+Andreas Rieke\n+Ashish Sharma\n+Brad House\n+Brad Spencer\n+Bram Matthys\n+Dan Fandrich\n+Daniel Stenberg\n+Dirk Manske\n+Dominick Meglio\n+Doug Goldstein\n+Duncan Wilcox\n+Eino Tuominen\n+Erik Kline\n+George Neill\n+Gisle Vanem\n+Guilherme Balena Versiani\n+Gunter Knauf\n+Henrik Stoerner\n+James Bursa\n+Michael Wallner\n+Nick Mathewson\n+Phil Blundell\n+Ravi Pratap\n+Robin Cornelius\n+Sebastian at basti79.de\n+Shmulik Regev\n+Steinar H. Gunderson\n+Tofu Linden\n+Vlad Dinulescu\n+William Ahern\n+Yang Tse\n+liren at vivisimo.com"}, {"sha": "f739b4687908e3c1b4ee347ff38ccffbed096046", "filename": "src/rt/libuv/src/ares/CHANGES", "status": "added", "additions": 1198, "deletions": 0, "changes": 1198, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FCHANGES", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FCHANGES", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FCHANGES?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,1198 @@\n+  Changelog for the c-ares project\n+\n+Version 1.7.4 (December 9, 2010)\n+\n+Changed:\n+\n+ o local-bind: Support binding to local interface/IPs, see\n+   ares_set_local_ip4, ares_set_local_ip6, ares_set_local_dev\n+\n+Fixed:\n+\n+ o memory leak in ares_getnameinfo\n+ o add missing break that caused get_ares_servers to fail\n+ o ares_parse_a_reply: fix CNAME response parsing\n+ o init_by_options: don't copy an empty sortlist\n+ o Replaced uint32_t with unsigned int to fix broken builds\n+   on a couple of platforms\n+ o Fix lookup with HOSTALIASES set\n+ o adig: fix NAPTR parsing\n+ o compiler warning cleanups\n+\n+Version 1.7.3 (June 11, 2010)\n+\n+Fixed:\n+\n+ o builds on Android\n+ o now includes all files necessary to build it (1.7.2 lacked a file)\n+\n+Version 1.7.2 (June 10, 2010)\n+\n+Changed:\n+\n+ o Added ares_parse_mx_reply()\n+\n+Fixed:\n+\n+ o ares_init: Last, not first instance of domain or search should win\n+ o improve alternative definition of bool\n+ o fix VS2010 compiler warnings\n+\n+\n+Version 1.7.1 (Mar 23, 2010)\n+\n+* May 31, 2010 (Jakub Hrozek)\n+- Use the last instance of domain/search, not the first one\n+\n+* March 23, 2010 (Daniel Stenberg)\n+- We switched from CVS to git. See http://github.com/bagder/c-ares\n+\n+* March 5, 2010 (Daniel Stenberg)\n+- Daniel Johnson provided fixes for building with the clang compiler.\n+\n+* March 5, 2010 (Yang Tse)\n+- Added IPv6 name servers support. Implementation has been based on code,\n+  comments and feedback provided November and December of 2008 by Daniel\n+  Stenberg, Gregor Jasny, Phil Blundell and myself, December 2009 by Cedric\n+  Bail, and February 2010 by Jakub Hrozek on the c-ares mailing list. On\n+  March I reviewed all that, selected the best of each, and adjusted or\n+  extended parts of it to make the best fit.\n+\n+  The external and visible result of all this is that two new functions are\n+  added to the external API, ares_get_servers() and ares_set_servers(), which\n+  becomes now the preferred way of getting and setting name servers for any\n+  ares channel as these support both IPv4 and IPv6 name servers.\n+\n+  In order to not break ABI compatibility, ares_init_options() with option\n+  mask ARES_OPT_SERVERS and ares_save_options() may still be used in code\n+  which is intended to run on IPv4-only stacks. But remember that these\n+  functions do not support IPv6 name servers. This implies that if the user\n+  is capable of defining or providing an IPv6 name server, and the app is\n+  using ares_init_options() or ares_save_options() at some point to handle\n+  the name servers, the app will likely lose IPv6 name servers.\n+\n+* January 28, 2010 (Daniel Stenberg)\n+- Tommie Gannert pointed out a silly bug in ares_process_fd() since it didn't\n+  check for broken connections like ares_process() did. Based on that, I\n+  merged the two functions into a single generic one with two front-ends.\n+\n+* December 29, 2009 (Yang Tse)\n+- Laszlo Tamas Szabo adjusted Makefile.msvc compiler options so that where\n+  run-time error checks enabling compiler option /GZ was used it is replaced\n+  with equivalent /RTCsu for Visual Studio 2003 and newer versions. Option\n+  /GX is replaced with equivalent /EHsc for all versions. Also fixed socket\n+  data type for internal configure_socket function.\n+\n+* December 21, 2009 (Yang Tse)\n+- Ingmar Runge noticed that Windows config-win32.h configuration file\n+  did not include a definition for HAVE_CLOSESOCKET which resulted in\n+  function close() being inappropriately used to close sockets.\n+\n+Version 1.7.0 (Nov 30, 2009)\n+\n+* November 26, 2009 (Yang Tse)\n+- Larry Lansing fixed ares_parse_srv_reply to properly parse replies\n+  which might contain non-SRV answers, skipping over potential non-SRV\n+  ones such as CNAMEs.\n+\n+* November 23, 2009 (Yang Tse)\n+- Changed naming convention for c-ares libraries built with MSVC, details\n+  and build instructions provided in README.msvc file.\n+\n+* November 22, 2009 (Yang Tse)\n+- Jakub Hrozek fixed more function prototypes in man pages to sync them\n+  with the ones declared in ares.h\n+\n+- Jakub Hrozek renamed addrttl and addr6ttl structs to ares_addrttl and\n+  ares_addr6ttl in order to prevent name space pollution, along with\n+  necessary changes to code base and man pages.This change does not break\n+  ABI, there is no need to recompile existing applications. But existing\n+  applications using these structs with the old name will need source code\n+  adjustments when recompiled using c-ares 1.7.0.\n+\n+* November 21, 2009 (Yang Tse)\n+- Added manifest stuff to Makefile.msvc.\n+\n+* November 20, 2009 (Yang Tse)\n+- Fixed several function prototypes in man pages that were out of sync\n+  with the ones declared in ares.h.  Added ares_free_data() along with\n+  man page.  Updated ares_parse_srv_reply() and ares_parse_txt_reply()\n+  with changes from Jakub Hrozek making these now return linked lists\n+  instead of arrays, and merging the ares_free_data() adjustments.\n+\n+* November 10, 2009 (Yang Tse)\n+- Updated MSVC 6.0 project files to match settings from Makefile.msvc.\n+\n+* November 9, 2009 (Yang Tse)\n+- Makefile.msvc is now the reference method to build c-ares and sample\n+  programs with any MSVC compiler or MS Visual Studio version.  If no\n+  option or target are specified it builds dynamic and static c-ares\n+  libraries in debug and release flavours and also builds all sample\n+  programs using each of the different c-ares libraries.\n+\n+* November 2, 2009 (Yang Tse)\n+- Renamed c-ares setup.h to ares_setup.h\n+\n+* October 31, 2009 (Yang Tse)\n+- Symbol hiding configure options are named now --enable-symbol-hiding\n+  and --disable-symbol-hiding in an attempt to make them less ambiguous.\n+\n+* October 30, 2009 (Yang Tse)\n+- Many fixes for ares_parse_txt_reply()\n+\n+* October 29, 2009 (Daniel Stenberg)\n+- Jakub Hrozek added ares_parse_txt_reply() for TXT parsing\n+\n+* October 29, 2009 (Yang Tse)\n+- Updated MSVC 6.0 workspace and project files that allows building\n+  dynamic and static c-ares libraries in debug and release flavours.\n+  Additionally each of the three sample programs is built against\n+  each of the four possible c-ares libraries, generating all this\n+  a total number of 12 executables and 4 libraries.\n+\n+* October 28, 2009 (Yang Tse)\n+- Initial step towards the ability to reduce c-ares exported symbols\n+  when built as a shared library based on the 'visibility' attribute\n+  for GNUC and Intel compilers and based on __global for Sun compilers,\n+  taking also in account __declspec function decoration for Win32 and\n+  Symbian DLL's.\n+\n+* October 27, 2009 (Yang Tse)\n+- Fixed Pelles C Win32 target compilation issues.\n+\n+* October 23, 2009 (Yang Tse)\n+- John Engelhart noticed an unreleased problem relative to a duplicate\n+  ARES_ECANCELLED error code value and missing error code description.\n+\n+* October 7, 2009 (Yang Tse)\n+- Overhauled ares__get_hostent() Fixing out of bounds memory overwrite\n+  triggered with malformed /etc/hosts file. Improving parsing of /etc/hosts\n+  file. Validating requested address family. Ensuring that failures always\n+  return a NULL pointer. Adjusting header inclusions.\n+\n+* October 6, 2009 (Yang Tse)\n+- Fix ssize_t redefinition errors on WIN64 reported by Alexey Simak.\n+\n+* September 29, 2009 (Yang Tse)\n+- Make configure script also check if _REENTRANT definition is required to\n+  make errno available as a preprocessor macro.\n+\n+* September 7, 2009 (Yang Tse)\n+- Add T_SRV portability check to ares_parse_srv_reply.c\n+\n+* 4 Sep 2009 (Daniel Stenberg)\n+- Jakub Hrozek added ares_parse_srv_reply() for SRV parsing\n+\n+* 3 Aug 2009 (Daniel Stenberg)\n+- Joshua Kwan fixed the init routine to fill in the defaults for stuff that\n+  fails to get inited by other means. This fixes a case of when the c-ares\n+  init fails when internet access is fone.\n+\n+- Timo Teras changed the reason code used in the resolve callback done when\n+  ares_cancel() is used, to be ARES_ECANCELLED instead of ARES_ETIMEOUT to\n+  better allow the callback to know what's happening.\n+\n+* 14 Jul 2009 (Guenter Knauf)\n+- renamed generated config.h to ares_config.h to avoid any future clashes\n+  with config.h from other projects.\n+\n+* June 20 2009 (Yang Tse)\n+- Refactor how libraries are checked for connect() function in configure\n+  script and check for connect() as it is done for other functions.\n+\n+* June 19 2009 (Yang Tse)\n+- Make sclose() function-like macro definition used to close a socket,\n+  now solely based on HAVE_CLOSESOCKET and HAVE_CLOSESOCKET_CAMEL\n+  config file preprocessor definitions\n+\n+* June 18 2009 (Yang Tse)\n+- Add CloseSocket camel case function check for configure script.\n+\n+* June 17 2009 (Yang Tse)\n+- Check for socket() and closesocket() as it is done for other functions\n+  in configure script.\n+\n+* June 11 2009 (Yang Tse)\n+- Modified buildconf so that when automake runs it copies missing files\n+  instead of symlinking them.\n+\n+* June 8 2009 (Yang Tse)\n+- Removed buildconf.bat from release and daily snapshot archives. This\n+  file is only for CVS tree checkout builds.\n+\n+* May 26 2009 (Yang Tse)\n+- Added --enable-curldebug configure option to enable and disable building\n+  with the low-level curl debug memory tracking 'feature' to allow decoupled\n+  setting from --enable-debug, allowing again to build c-ares independently\n+  out of the CVS tree.\n+\n+  For the c-ares library option --enable-debug enables debug build features\n+  which are _not_ related with memory tracking. For the c-ares library when\n+  --enable-debug is given it does not enable the memory tracking feature. If\n+  you wish to enable the curl debug memory tracking you must use configure\n+  option --enable-curldebug explicitily to do so.\n+\n+  Internally, definition of preprocessor symbol DEBUGBUILD restricts code\n+  which is only compiled for debug enabled builds. And symbol CURLDEBUG is\n+  used to differentiate code which is _only_ used for memory tracking.\n+\n+  Make ares_init(), ares_dup() and ares_init_options() fail returning\n+  ARES_ENOTINITIALIZED if library initialization has not been performed\n+  calling ares_library_init().\n+\n+* May 20 2009 (Yang Tse)\n+- Added ares_library_init() and ares_library_cleanup() man pages.\n+\n+* May 19 2009 (Yang Tse)\n+- Introduced ares_library_init() and ares_library_cleanup() functions.\n+\n+  This is an API and ABI break for Win32/64 systems. Non-Win32/64 build targets\n+  using c-ares 1.7.0 can still survive without calling these functions. Read all\n+  the details on ares_library_init(3) and ares_library_cleanup(3) man pages that\n+  are included.\n+\n+  curl/libcurl 7.19.5 is fully compatible with c-ares 1.7.0 on all systems.\n+\n+  In order to use c-ares 1.7.0 with curl/libcurl on Win32/64 systems it is\n+  required that curl/libcurl is 7.19.5 or newer. In other words, it is not\n+  possible on Win32/64 to use c-ares 1.7.0 with a curl/libcurl version less\n+  than 7.19.5\n+\n+* May 11 2009 (Daniel Stenberg)\n+- Gregor Jasny made c-ares link with libtool 's -export-symbols-regex option to\n+  only expose functions starting with ares_.\n+\n+* May 7 2009 (Yang Tse)\n+- Fix an m4 overquoting triggering a spurious 'AS_TR_CPP' symbol definition\n+  attempt in generated config.h\n+\n+* May 2 2009 (Yang Tse)\n+- Use a build-time configured ares_socklen_t data type instead of socklen_t.\n+\n+* April 21 2009 (Yang Tse)\n+- Moved potential inclusion of system's malloc.h and memory.h header files to\n+  setup_once.h.  Inclusion of each header file is based on the definition of\n+  NEED_MALLOC_H and NEED_MEMORY_H respectively.\n+\n+* March 11 2009 (Yang Tse)\n+- Japheth Cleaver fixed acountry.c replacing u_long with unsigned long.\n+\n+* February 20 2009 (Yang Tse)\n+- Do not halt compilation when using VS2008 to build a Windows 2000 target.\n+\n+* February 3 2009 (Phil Blundell)\n+- If the server returns garbage or nothing at all in response to an AAAA query,\n+  go on and ask for A records anyway.\n+\n+* January 31 2009 (Daniel Stenberg)\n+- ares_gethostbyname() now accepts 'AF_UNSPEC' as a family for resolving\n+  either AF_INET6 or AF_INET. It works by accepting any of the looksups in the\n+  hosts file, and it resolves the AAAA field with a fallback to A.\n+\n+* January 14 2009 (Daniel Stenberg)\n+- ares.h no longer uses the HAVE_STRUCT_IN6_ADDR define check, but instead it\n+  now declares the private struct ares_in6_addr for all systems instead of\n+  relying on one possibly not present in the system.\n+\n+* January 13 2009 (Phil Blundell)\n+- ares__send_query() now varies the retry timeout pseudo-randomly to avoid\n+  packet storms when several queries were started at the same time.\n+\n+* January 11 2009 (Daniel Stenberg)\n+- Phil Blundell added the internal function ares__expand_name_for_response()\n+  that is now used by the ares_parse_*_reply() functions instead of the\n+  ares_expand_name() simply to easier return ARES_EBADRESP for the cases where\n+  the name expansion fails as in responses that really isn't expected.\n+\n+Version 1.6.0 (Dec 9, 2008)\n+\n+* December 9 2008 (Gisle Vanem)\n+\n+  Fixes for Win32 targets using the Watt-32 tcp/ip stack.\n+\n+* Dec 4 2008 (Daniel Stenberg)\n+\n+  Gregor Jasny provided the patch that introduces ares_set_socket_callback(),\n+  and I edited it to also get duped by ares_dup().\n+\n+* Dec 3 2008 (Daniel Stenberg)\n+\n+  API changes:\n+\n+  I made sure the public ares_config struct looks like before and yet it\n+  supports the ROTATE option thanks to c-ares now storing the \"optmask\"\n+  internally. Thus we should be ABI compatible with the past release(s)\n+  now. My efforts mentioned below should not break backwards ABI compliance.\n+\n+  Here's how I suggest we proceed with the API:\n+\n+  ares_init() will be primary \"channel creator\" function.\n+\n+  ares_init_options() will continue to work exactly like now and before. For\n+  starters, it will be the (only) way to set the existing options.\n+\n+  ares_save_options() will continue to work like today, but will ONLY save\n+  options that you can set today (including ARES_OPT_ROTATE actually) but new\n+  options that we add may not be saved with this.\n+\n+  Instead we introduce:\n+\n+  ares_dup() that instead can make a new channel and clone the config used\n+  from an existing channel. It will then clone all config options, including\n+  future new things we add.\n+\n+  ares_set_*() style functions that set (new) config options. As a start we\n+  simply add these for new functionality, but over time we can also introduce\n+  them for existing \"struct ares_options\" so that we can eventually deprecate\n+  the two ares_*_options() functions.\n+\n+  ares_get_*() style functions for extracting info from a channel handle that\n+  should be used instead of ares_save_options().\n+\n+* Nov 26 2008 (Yang Tse)\n+- Brad Spencer provided changes to allow buildconf to work on OS X.\n+\n+- Gerald Combs fixed a bug in ares_parse_ptr_reply() which would cause a\n+  buffer to shrink instead of expand if a reply contained 8 or more records.\n+\n+* Nov 25 2008 (Yang Tse)\n+- In preparation for the upcomming IPv6 nameservers patch, the internal\n+  ares_addr union is now changed into an internal struct which also holds\n+  the address family.\n+\n+* Nov 19 2008 (Daniel Stenberg)\n+- Brad Spencer brought the new function ares_gethostbyname_file() which simply\n+  resolves a host name from the given file, using the regular hosts syntax.\n+\n+* Nov 1 2008 (Daniel Stenberg)\n+- Carlo Contavalli added support for the glibc \"rotate\" option, as documented\n+  in man resolv.conf:\n+\n+  causes round robin selection of nameservers from among those listed.  This\n+  has the effect of spreading the query load among all listed servers, rather\n+  than having all clients try the first listed server first every time.\n+\n+  You can enable it with ARES_OPT_ROTATE\n+\n+* Oct 21 2008 (Yang Tse)\n+  Charles Hardin added handling of EINPROGRESS for UDP connects.\n+\n+* Oct 18 2008 (Daniel Stenberg)\n+  Charles Hardin made adig support a regular numerical dotted IP address for the\n+  -s option as well.\n+\n+* Oct 7 2008 (Yang Tse)\n+- Added --enable-optimize configure option to enable and disable compiler\n+  optimizations to allow decoupled setting from --enable-debug.\n+\n+* Oct 2 2008 (Yang Tse)\n+- Added --enable-warnings configure option to enable and disable strict\n+  compiler warnings to allow decoupled setting from --enable-debug.\n+\n+* Sep 17 2008 (Yang Tse)\n+- Code reorganization to allow internal/private use of \"nameser.h\" to any\n+  system that lacks arpa/nameser.h or arpa/nameser_compat.h header files.\n+\n+* Sep 16 2008 (Yang Tse)\n+- Code reorganization to allow internal/private use of ares_writev to any\n+  system that lacks the writev function.\n+\n+* Sep 15 2008 (Yang Tse)\n+- Code reorganization to allow internal/private use of ares_strcasecmp to any\n+  system that lacks the strcasecmp function.\n+\n+- Improve configure detection of some string functions.\n+\n+* Sep 11 2008 (Yang Tse)\n+- Code reorganization to allow internal/private use of ares_strdup to any\n+  system that lacks the strdup function.\n+\n+Version 1.5.3 (Aug 29, 2008)\n+\n+* Aug 25 2008 (Yang Tse)\n+- Improvement by Brad House:\n+\n+  This patch addresses an issue in which a response could be sent back to the\n+  source port of a client from a different address than the request was made to.\n+  This is one form of a DNS cache poisoning attack.\n+\n+  The patch simply uses recvfrom() rather than recv() and validates that the\n+  address returned from recvfrom() matches the address of the server we have\n+  connected to. Only necessary on UDP sockets as they are connection-less, TCP\n+  is unaffected.\n+\n+- Fix by George Neill:\n+  Fixed compilation of acountry sample application failure on some systems.\n+\n+* Aug 4 2008 (Daniel Stenberg)\n+- Fix by Tofu Linden:\n+\n+  The symptom:\n+  * Users (usually, but not always) on 2-Wire routers and the Comcast service\n+  and a wired connection to their router would find that the second and\n+  subsequent DNS lookups from fresh processes using c-ares to resolve the same\n+  address would cause the process to never see a reply (it keeps polling for\n+  around 1m15s before giving up).\n+\n+  The repro:\n+  * On such a machine (and yeah, it took us a lot of QA to find the systems\n+  that reproduce such a specific problem!), do 'ahost www.secondlife.com',\n+  then do it again.  The first process's lookup will work, subsequent lookups\n+  will time-out and fail.\n+\n+  The cause:\n+  * init_id_key() was calling randomize_key() *before* it initialized\n+  key->state, meaning that the randomness generated by randomize_key() is\n+  immediately overwritten with deterministic values. (/dev/urandom was also\n+  being read incorrectly in the c-ares version we were using, but this was\n+  fixed in a later version.)\n+  * This makes the stream of generated query-IDs from any new c-ares process\n+  be an identical and predictable sequence of IDs.\n+  * This makes the 2-Wire's default built-in DNS server detect these queries\n+  as probable-duplicates and (erroneously) not respond at all.\n+\n+\n+* Aug 4 2008 (Yang Tse)\n+- Autoconf 2.62 has changed the behaviour of the AC_AIX macro which we use.\n+  Prior versions of autoconf defined _ALL_SOURCE if _AIX was defined. 2.62\n+  version of AC_AIX defines _ALL_SOURCE and other four preprocessor symbols\n+  no matter if the system is AIX or not. To keep the traditional behaviour,\n+  and an uniform one across autoconf versions AC_AIX is replaced with our\n+  own internal macro CARES_CHECK_AIX_ALL_SOURCE.\n+\n+* Aug 1 2008 (Yang Tse)\n+- Configure process now checks if the preprocessor _REENTRANT symbol is already\n+  defined. If it isn't currently defined a set of checks are performed to test\n+  if its definition is required to make visible to the compiler a set of *_r\n+  functions. Finally, if _REENTRANT is already defined or needed it takes care\n+  of making adjustments necessary to ensure that it is defined equally for the\n+  configure process tests and generated config file.\n+\n+* Jul 20 2008 (Yang Tse)\n+- When recvfrom prototype uses a void pointer for arguments 2, 5 or 6 this will\n+  now cause the definition, as appropriate, of RECVFROM_TYPE_ARG2_IS_VOID,\n+  RECVFROM_TYPE_ARG5_IS_VOID or RECVFROM_TYPE_ARG6_IS_VOID.\n+\n+* Jul 17 2008 (Yang Tse)\n+- RECVFROM_TYPE_ARG2, RECVFROM_TYPE_ARG5 and RECVFROM_TYPE_ARG6 are now defined\n+  to the data type pointed by its respective argument and not the pointer type.\n+\n+* Jul 16 2008 (Yang Tse)\n+- Improved configure detection of number of arguments for getservbyport_r.\n+  Detection is now based on compilation checks instead of linker ones.\n+\n+- Configure process now checks availability of recvfrom() socket function and\n+  finds out its return type and the types of its arguments. Added definitions\n+  for non-configure systems config files, and introduced macro sreadfrom which\n+  will be used on udp sockets as a recvfrom() wrapper in the future.\n+\n+* Jul 15 2008 (Yang Tse)\n+- Introduce definition of _REENTRANT symbol in setup.h to improve library\n+  usability.  Previously the configure process only used the AC_SYS_LARGEFILE\n+  macro for debug builds, now it is also used for non-debug ones enabling the\n+  use of configure options --enable-largefile and --disable-largefile which\n+  might be needed for library compatibility.  Remove checking the size of\n+  curl_off_t, it is no longer needed.\n+\n+* Jul 3 2008 (Daniel Stenberg)\n+- Phil Blundell: If you ask ares_gethostbyname() to do an AF_INET6 lookup and\n+  the target host has only A records, it automatically falls back to an\n+  AF_INET lookup and gives you the A results.  However, if the target host has\n+  a CNAME record, this behaviour is defeated since the original query does\n+  return some data even though ares_parse_aaa_reply() doesn't consider it\n+  relevant. Here's a small patch to make it behave the same with and without\n+  the CNAME.\n+\n+* Jul 2 2008 (Yang Tse)\n+- Fallback to gettimeofday when monotonic clock is unavailable at run-time.\n+\n+* Jun 30 2008 (Daniel Stenberg)\n+\n+- As was pointed out to me by Andreas Schuldei, the MAXHOSTNAMELEN define is\n+  not posix or anything and thus c-ares failed to build on hurd (and possibly\n+  elsewhere). The define was also somewhat artificially used in the windows\n+  port. Now, I instead rewrote the use of gethostbyname to enlarge the host\n+  name buffer in case of need and totally avoid the use of the MAXHOSTNAMELEN\n+  define. I thus also removed the defien from the namser.h file where it was\n+  once added for the windows build.\n+\n+  I also fixed init_by_defaults() function to not leak memory in case if\n+  error.\n+\n+* Jun 9 2008 (Yang Tse)\n+\n+- Make libcares.pc generated file for pkg-config include information relative\n+  to the libraries needed for the static linking of c-ares.\n+\n+* May 30 2008 (Yang Tse)\n+\n+- Brad House fixed a missing header file inclusion in adig sample program.\n+\n+Version 1.5.2 (May 29, 2008)\n+\n+* May 13 2008 (Daniel Stenberg)\n+\n+- Introducing millisecond resolution support for the timeout option. See\n+  ares_init_options()'s ARES_OPT_TIMEOUTMS.\n+\n+* May 9 2008 (Yang Tse)\n+\n+- Use monotonic time source if available, for private function ares__tvnow()\n+\n+* May 7 2008 (Daniel Stenberg)\n+\n+- Sebastian made c-ares able to return all PTR-records when doing reverse\n+  lookups. It is not common practice to have multiple PTR-Records for a single\n+  IP, but its perfectly legal and some sites have those.\n+\n+- Doug Goldstein provided a configure patch: updates autoconf 2.13 usage to\n+  autoconf 2.57 usage (which is the version you have specified as the minimum\n+  version). It's a minor change but it does clean up some warnings with newer\n+  autoconf (specifically 2.62).\n+\n+* May 5 2008 (Yang Tse)\n+\n+- Improved parsing of resolver configuration files.\n+\n+* April 4 2008 (Daniel Stenberg)\n+\n+- Eino Tuominen improved the code when a file is used to seed the randomizer.\n+\n+- Alexey Simak made adig support NAPTR records\n+\n+- Alexey Simak fixed the VC dsp file by adding the missing source file\n+  ares_expand_string.c\n+\n+* December 11 2007 (Gisle Vanem)\n+\n+- Added another sample application; acountry.c which converts an\n+  IPv4-address(es) and/or host-name(s) to country-name and country-code.\n+  This uses the service of the DNSBL at countries.nerd.dk.\n+\n+* December 3 2007 (Daniel Stenberg)\n+\n+- Brad Spencer fixed the configure script to assume that there's no\n+  /dev/urandom when built cross-compiled as then the script cannot check for\n+  it.\n+\n+- Erik Kline cleaned up ares_gethostbyaddr.c:next_lookup() somewhat\n+\n+Version 1.5.1 (Nov 21, 2007)\n+\n+* November 21 2007 (Daniel Stenberg)\n+\n+- Robin Cornelius pointed out that ares_llist.h was missing in the release\n+  archive for 1.5.0\n+\n+Version 1.5.0 (Nov 21, 2007)\n+\n+* October 2 2007 (Daniel Stenberg)\n+\n+- ares_strerror() segfaulted if the input error number was out of the currently\n+  supported range.\n+\n+- Yang Tse: Avoid a segfault when generating a DNS \"Transaction ID\" in\n+  internal function init_id_key() under low memory conditions.\n+\n+* September 28 2007 (Daniel Stenberg)\n+\n+- Bumped version to 1.5.0 for next release and soname bumped to 2 due to ABI\n+  and API changes in the progress callback (and possibly more coming up from\n+  Steinar)\n+\n+* September 28 2007 (Steinar H. Gunderson)\n+\n+- Don't skip a server if it's the only one. (Bugfix from the Google tree.)\n+\n+- Made the query callbacks receive the number of timeouts that happened during\n+  the execution of a query, and updated documentation accordingly. (Patch from\n+  the Google tree.)\n+\n+- Support a few more socket options: ARES_OPT_SOCK_SNDBUF and\n+  ARES_OPT_SOCK_RCVBUF\n+\n+- Always register for TCP events even if there are no outstanding queries, as\n+  the other side could always close the connection, which is a valid event\n+  which should be responded to.\n+\n+* September 22 2007 (Daniel Stenberg)\n+\n+- Steinar H. Gunderson fixed: Correctly clear sockets from the fd_set on in\n+  several functions (write_tcp_data, read_tcp_data, read_udp_packets) so that\n+  if it fails and the socket is closed the following code doesn't try to use\n+  the file descriptor.\n+\n+- Steinar H. Gunderson modified c-ares to now also do to DNS retries even when\n+  TCP is used since there are several edge cases where it still makes sense.\n+\n+- Brad House provided a fix for ares_save_options():\n+\n+  Apparently I overlooked something with the ares_save_options() where it\n+  would try to do a malloc(0) when no options of that type needed to be saved.\n+  On most platforms, this was fine because malloc(0) doesn't actually return\n+  NULL, but on AIX it does, so ares_save_options would return ARES_ENOMEM.\n+\n+* July 14 2007 (Daniel Stenberg)\n+\n+- Vlad Dinulescu fixed two outstanding valgrind reports:\n+\n+  1. In ares_query.c , in find_query_by_id we compare q->qid (which is a short\n+  int variable) with qid, which is declared as an int variable.  Moreover,\n+  DNS_HEADER_SET_QID is used to set the value of qid, but DNS_HEADER_SET_QID\n+  sets only the first two bytes of qid. I think that qid should be declared as\n+  \"unsigned short\" in this function.\n+\n+  2. The same problem occurs in ares_process.c, process_answer() .  query->qid\n+  (an unsigned short integer variable) is compared with id, which is an\n+  integer variable. Moreover, id is initialized from DNS_HEADER_QID which sets\n+  only the first two bytes of id. I think that the id variable should be\n+  declared as \"unsigned short\" in this function.\n+\n+  Even after declaring these variables as \"unsigned short\", the valgrind\n+  errors are still there. Which brings us to the third problem.\n+\n+  3. The third problem is that Valgrind assumes that query->qid is not\n+  initialised correctly. And it does that because query->qid is set from\n+  DNS_HEADER_QID(qbuf); Valgrind says that qbuf has unitialised bytes. And\n+  qbuf has uninitialised bytes because of channel->next_id . And next_id is\n+  set by ares_init.c:ares__generate_new_id() . I found that putting short r=0\n+  in this function (instead of short r) makes all Valgrind warnings go away.\n+  I have studied ares__rc4() too, and this is the offending line:\n+\n+        buffer_ptr[counter] ^= state[xorIndex];   (ares_query.c:62)\n+\n+  This is what triggers Valgrind.. buffer_ptr is unitialised in this function,\n+  and by applying ^= on it, it remains unitialised.\n+\n+Version 1.4.0 (June 8, 2007)\n+\n+* June 4 2007 (Daniel Stenberg)\n+\n+- James Bursa reported a major memory problem when resolving multi-IP names\n+  and I found and fixed the problem. It was added by Ashish Sharma's patch\n+  two days ago.\n+\n+  When I then tried to verify multiple entries in /etc/hosts after my fix, I\n+  got another segfault and decided this code was not ripe for inclusion and I\n+  reverted the patch.\n+\n+* June 2 2007\n+\n+- Brad Spencer found and fixed three flaws in the code, found with the new\n+  gcc 4.2.0 warning: -Waddress\n+\n+- Brad House fixed VS2005 compiler warnings due to time_t being 64bit.\n+  He also made recent Microsoft compilers use _strdup() instead of strdup().\n+\n+- Brad House's man pages for ares_save_options() and ares_destroy_options()\n+  were added.\n+\n+- Ashish Sharma provided a patch for supporting multiple entries in the\n+  /etc/hosts file. Patch edited for coding style and functionality by me\n+  (Daniel).\n+\n+* May 30 2007\n+\n+- Shmulik Regev brought cryptographically secure transaction IDs:\n+\n+  The c-ares library implementation uses a DNS \"Transaction ID\" field that is\n+  seeded with a pseudo random number (based on gettimeofday) which is\n+  incremented (++) between consecutive calls and is therefore rather\n+  predictable. In general, predictability of DNS Transaction ID is a well\n+  known security problem (e.g.\n+  http://bak.spc.org/dms/archive/dns_id_attack.txt) and makes a c-ares based\n+  implementation vulnerable to DNS poisoning. Credit goes to Amit Klein\n+  (Trusteer) for identifying this problem.\n+\n+  The patch I wrote changes the implementation to use a more secure way of\n+  generating unique IDs. It starts by obtaining a key with reasonable entropy\n+  which is used with an RC4 stream to generate the cryptographically secure\n+  transaction IDs.\n+\n+  Note that the key generation code (in ares_init:randomize_key) has two\n+  versions, the Windows specific one uses a cryptographically safe function\n+  provided (but undocumented :) by the operating system (described at\n+  http://blogs.msdn.com/michael_howard/archive/2005/01/14/353379.aspx).  The\n+  default implementation is a bit naive and uses the standard 'rand'\n+  function. Surely a better way to generate random keys exists for other\n+  platforms.\n+\n+  The patch can be tested by using the adig utility and using the '-s' option.\n+\n+- Brad House added ares_save_options() and ares_destroy_options() that can be\n+  used to keep options for later re-usal when ares_init_options() is used.\n+\n+  Problem: Calling ares_init() for each lookup can be unnecessarily resource\n+         intensive.  On windows, it must LoadLibrary() or search the registry\n+         on each call to ares_init().  On unix, it must read and parse\n+         multiple files to obtain the necessary configuration information.  In\n+         a single-threaded environment, it would make sense to only\n+         ares_init() once, but in a heavily multi-threaded environment, it is\n+         undesirable to ares_init() and ares_destroy() for each thread created\n+         and track that.\n+\n+  Solution: Create ares_save_options() and ares_destroy_options() functions to\n+         retrieve and free options obtained from an initialized channel.  The\n+         options populated can be used to pass back into ares_init_options(),\n+         it should populate all needed fields and not retrieve any information\n+         from the system.  Probably wise to destroy the cache every minute or\n+         so to prevent the data from becoming stale.\n+\n+- Daniel S added ares_process_fd() to allow applications to ask for processing\n+  on specific sockets and thus avoiding select() and associated\n+  functions/macros.  This function will be used by upcoming libcurl releases\n+  for this very reason. It also made me export the ares_socket_t type in the\n+  public ares.h header file, since ares_process_fd() uses that type for two of\n+  the arguments.\n+\n+* May 25 2007\n+\n+- Ravi Pratap fixed a flaw in the init_by_resolv_conf() function for windows\n+  that could cause it to return a bad return code.\n+\n+* April 16 2007\n+\n+- Yang Tse: Provide ares_getopt() command-line parser function as a source\n+  code helper function, not belonging to the actual c-ares library.\n+\n+* February 19 2007\n+\n+- Vlad Dinulescu added ares_parse_ns_reply().\n+\n+* February 13 2007\n+\n+- Yang Tse: Fix failure to get the search sequence of /etc/hosts and\n+  DNS from /etc/nsswitch.conf, /etc/host.conf or /etc/svc.conf when\n+  /etc/resolv.conf did not exist or was unable to read it.\n+\n+* November 22 2006\n+\n+- Install ares_dns.h too\n+\n+- Michael Wallner fixed this problem: When I set domains in the options\n+  struct, and there are domain/search entries in /etc/resolv.conf, the domains\n+  of the options struct will be overridden.\n+\n+* November 6 2006\n+\n+- Yang Tse removed a couple of potential zero size memory allocations.\n+\n+- Andreas Rieke fixed the line endings in the areslib.dsp file that I (Daniel)\n+  broke in the 1.3.2 release. We should switch to a system where that file is\n+  auto-generated. We could rip some code for that from curl...\n+\n+Version 1.3.2 (November 3, 2006)\n+\n+* October 12 2006\n+\n+- Prevent ares_getsock() to overflow if more than 16 sockets are used.\n+\n+* September 11 2006\n+\n+- Guilherme Balena Versiani: I noted a strange BUG in Win32 port\n+  (ares_init.c/get_iphlpapi_dns_info() function): when I disable the network\n+  by hand or disconnect the network cable in Windows 2000 or Windows XP, my\n+  application gets 127.0.0.1 as the only name server. The problem comes from\n+  'GetNetworkParams' function, that returns the empty string \"\" as the only\n+  name server in that case. Moreover, the Windows implementation of\n+  inet_addr() returns INADDR_LOOPBACK instead of INADDR_NONE.\n+\n+* August 29 2006\n+\n+- Brad Spencer did\n+\n+  o made ares_version.h use extern \"C\" for c++ compilers\n+  o fixed compiler warnings in ares_getnameinfo.c\n+  o fixed a buffer position init for TCP reads\n+\n+* August 3 2006\n+\n+- Ravi Pratap fixed ares_getsock() to actually return the proper bitmap and\n+  not always zero!\n+\n+Version 1.3.1 (June 24, 2006)\n+\n+* July 23, 2006\n+\n+- Gisle Vanem added getopt() to the ahost program. Currently accepts\n+  only [-t {a|aaaa}] to specify address family in ares_gethostbyname().\n+\n+* June 19, 2006\n+\n+- (wahern) Removed \"big endian\" DNS section and RR data integer parser\n+  macros from ares_dns.h, which break c-ares on my Sparc64. Bit-wise\n+  operations in C operate on logical values. And in any event the octets are\n+  already in big-endian (aka network) byte order so they're being reversed\n+  (thus the source of the breakage).\n+\n+* June 18, 2006\n+\n+- William Ahern handles EAGAIN/EWOULDBLOCK errors in most of the I/O calls\n+  from area_process.c.\n+\n+  TODO: Handle one last EAGAIN for a UDP socket send(2) in\n+  ares__send_query().\n+\n+* May 10, 2006\n+\n+- Bram Matthys brought my attention to a libtool peculiarity where detecting\n+  things such as C++ compiler actually is a bad thing and since we don't need\n+  that detection I added a work-around, much inspired by a previous patch by\n+  Paolo Bonzini. This also shortens the configure script quite a lot.\n+\n+* May 3, 2006\n+\n+- Nick Mathewson added the ARES_OPT_SOCK_STATE_CB option that when set makes\n+  c-ares call a callback on socket state changes. A better way than the\n+  ares_getsock() to get full control over the socket state.\n+\n+* January 9, 2006\n+\n+- Alexander Lazic improved the getservbyport_r() configure check.\n+\n+* January 6, 2006\n+\n+- Alexander Lazic pointed out that the buildconf should use the ACLOCAL_FLAGS\n+  variable for easier controlling what it does and how it runs.\n+\n+* January 5, 2006\n+\n+- James Bursa fixed c-ares to find the hosts file on RISC OS, and made it\n+  build with newer gcc versions that no longer defines \"riscos\".\n+\n+* December 22\n+\n+- Daniel Stenberg added ares_getsock() that extracts the set of sockets to\n+  wait for action on. Similar to ares_fds() but not restricted to using\n+  select() for the waiting.\n+\n+* November 25\n+\n+- Yang Tse fixed some send() / recv() compiler warnings\n+\n+* September 18\n+\n+- Added constants that will be used by ares_getaddrinfo\n+\n+- Made ares_getnameinfo use the reentrant getservbyport (getservbyport_r) if it\n+  is available to ensure it works properly in a threaded environment.\n+\n+* September 10\n+\n+- configure fix for detecting a member in the sockaddr_in6 struct which failed\n+  on ipv6-enabled HP-UX 11.00\n+\n+Version 1.3.0 (August 29, 2005)\n+\n+* August 21\n+\n+- Alfredo Tupone provided a fix for the Windows code in get_iphlpapi_dns_info()\n+  when getting the DNS server etc.\n+\n+* June 19\n+\n+- Added some checks for the addrinfo structure.\n+\n+* June 2\n+\n+- William Ahern:\n+\n+  Make UDP sockets non-blocking. I've confirmed that at least on Linux 2.4 a\n+  read event can come back from poll() on a valid SOCK_DGRAM socket but\n+  recv(2) will still block. This patch doesn't ignore EAGAIN in\n+  read_udp_packets(), though maybe it should. (This patch was edited by Daniel\n+  Stenberg and a new configure test was added (imported from curl's configure)\n+  to properly detect what non-blocking socket approach to use.)\n+\n+  I'm not quite sure how this was happening, but I've been seeing PTR queries\n+  which seem to return empty responses. At least, they were empty when calling\n+  ares_expand_name() on the record. Here's a patch which guarantees to\n+  NUL-terminate the expanded name. The old behavior failed to NUL-terminate if\n+  len was 0, and this was causing strlen() to run past the end of the buffer\n+  after calling ares_expand_name() and getting ARES_SUCCESS as the return\n+  value. If q is not greater than *s then it's equal and *s is always\n+  allocated with at least one byte.\n+\n+* May 16\n+\n+- Added ares_getnameinfo which mimics the getnameinfo API (another feature\n+  that could use testing).\n+\n+* May 14\n+\n+- Added an inet_ntop function from BIND for systems that do not have it.\n+\n+* April 9\n+\n+- Made sortlist support IPv6 (this can probably use some testing).\n+\n+- Made sortlist support CIDR matching for IPv4.\n+\n+* April 8\n+\n+- Added preliminary IPv6 support to ares_gethostbyname. Currently, sortlist\n+  does not work with IPv6. Also provided an implementation of bitncmp from\n+  BIND for systems that do not supply this function. This will be used to add\n+  IPv6 support to sortlist.\n+\n+- Made ares_gethostbyaddr support IPv6 by specifying AF_INET6 as the family.\n+  The function can lookup IPv6 addresses both from files (/etc/hosts) and\n+  DNS lookups.\n+\n+* April 7\n+\n+- Tupone Alfredo fixed includes of arpa/nameser_compat.h to build fine on Mac\n+  OS X.\n+\n+* April 5\n+\n+- Dominick Meglio: Provided implementations of inet_net_pton and inet_pton\n+  from BIND for systems that do not include these functions.\n+\n+* March 11, 2005\n+\n+- Dominick Meglio added ares_parse_aaaa_reply.c and did various\n+  adjustments. The first little steps towards IPv6 support!\n+\n+* November 7\n+\n+- Fixed the VC project and makefile to use ares_cancel and ares_version\n+\n+* October 24\n+\n+- The released ares_version.h from 1.2.1 says 1.2.0 due to a maketgz flaw.\n+  This is now fixed.\n+\n+Version 1.2.1 (October 20, 2004)\n+\n+* September 29\n+\n+- Henrik Stoerner fix: got a report that Tru64 Unix (the unix from Digital\n+  when they made Alpha's) uses /etc/svc.conf for the purpose fixed below for\n+  other OSes. He made c-ares check for and understand it if present.\n+\n+- Now c-ares will use local host name lookup _before_ DNS resolving by default\n+  if nothing else is told.\n+\n+* September 26\n+\n+- Henrik Stoerner: found out that c-ares does not look at the /etc/host.conf\n+  file to determine the sequence in which to search /etc/hosts and DNS.  So on\n+  systems where this order is defined by /etc/host.conf instead of a \"lookup\"\n+  entry in /etc/resolv.conf, c-ares will always default to looking in DNS\n+  first, and /etc/hosts second.\n+\n+  c-ares now looks at\n+\n+  1) resolv.conf (for the \"lookup\" line);\n+  2) nsswitch.fon (for the \"hosts:\" line);\n+  3) host.conf (for the \"order\" line).\n+\n+  First match wins.\n+\n+- Dominick Meglio patched: C-ares on Windows assumed that the HOSTS file is\n+  located in a static location. It assumed\n+  C:\\Windows\\System32\\Drivers\\Etc. This is a poor assumption to make. In fact,\n+  the location of the HOSTS file can be changed via a registry setting.\n+\n+  There is a key called DatabasePath which specifies the path to the HOSTS\n+  file:\n+  http://www.microsoft.com/technet/itsolutions/network/deploy/depovg/tcpip2k.mspx\n+\n+  The patch will make c-ares correctly consult the registry for the location\n+  of this file.\n+\n+* August 29\n+\n+- Gisle Vanem fixed the MSVC build files.\n+\n+* August 20\n+\n+- Gisle Vanem made c-ares build and work with his Watt-32 TCP/IP stack.\n+\n+* August 13\n+\n+- Harshal Pradhan made a minor syntax change in ares_init.c to make it build\n+  fine with MSVC 7.1\n+\n+* July 24\n+\n+- Made the lib get built static only if --enable-debug is used.\n+\n+- Gisle Vanem fixed:\n+\n+  Basically in loops like handle_errors(), 'query->next' was assigned a local\n+  variable and then query was referenced after the memory was freed by\n+  next_server(). I've changed that so next_server() and end_query() returns\n+  the next query. So callers should use this ret-value.\n+\n+  The next problem was that 'server->tcp_buffer_pos' had a random value at\n+  entry to 1st recv() (luckily causing Winsock to return ENOBUFS).\n+\n+  I've also added a ares_writev() for Windows to streamline the code a bit\n+  more.\n+\n+* July 20\n+- Fixed a few variable return types for some system calls. Made configure\n+  check for ssize_t to make it possible to use that when receiving the send()\n+  error code. This is necessary to prevent compiler warnings on some systems.\n+\n+- Made configure create config.h, and all source files now include setup.h that\n+  might include the proper config.h (or a handicrafted alternative).\n+\n+- Switched to 'ares_socket_t' type for sockets in ares, since Windows don't\n+  use 'int' for that.\n+\n+- automake-ified and libool-ified c-ares. Now it builds libcares as a shared\n+  lib on most platforms if wanted. (This bloated the size of the release\n+  archive with another 200K!)\n+\n+- Makefile.am now uses Makefile.inc for the c sources, h headers and man\n+  pages, to make it easier for other makefiles to use the exact same set of\n+  files.\n+\n+- Adjusted 'maketgz' to use the new automake magic when building distribution\n+  archives.\n+\n+- Anyone desires HTML and/or PDF versions of the man pages in the release\n+  archives?\n+\n+* July 3\n+- G\ufffdnter Knauf made c-ares build and run on Novell Netware.\n+\n+* July 1\n+- Gisle Vanem provided Makefile.dj to build with djgpp, added a few more djgpp\n+  fixes and made ares not use 'errno' to provide further info on Windows.\n+\n+* June 30\n+- Gisle Vanem made it build with djgpp and run fine with the Watt-32 stack.\n+\n+* June 10\n+- Gisle Vanem's init patch for Windows:\n+\n+  The init_by_resolv_conf() function fetches the DNS-server(s)\n+  from a series of registry branches.\n+\n+  This can be wrong in the case where DHCP has assigned nameservers, but the\n+  user has overridden these servers with other prefered settings. Then it's\n+  wrong to use the DHCPNAMESERVER setting in registry.\n+\n+  In the case of no global DHCP-assigned or fixed servers, but DNS server(s)\n+  per adapter, one has to query the adapter branches.  But how can c-ares know\n+  which adapter is valid for use? AFAICS it can't. There could be one adapter\n+  that is down (e.g. a VPN adapter).\n+\n+  So it's better to leave this to the IP Helper API (iphlapi) available in\n+  Win-98/2000 and later. My patch falls-back to the old way if not available.\n+\n+* June 8\n+- James Bursa fixed an init issue for RISC OS.\n+\n+* May 11\n+- Nico Stappenbelt reported that when processing domain and search lines in\n+  the resolv.conf file, the first entry encountered is processed and used as\n+  the search list. According to the manual pages for both Linux, Solaris and\n+  Tru64, the last entry of either a domain or a search field is used.\n+\n+  This is now adjusted in the code\n+\n+Version 1.2.0 (April 13, 2004)\n+\n+* April 2, 2004\n+- Updated various man pages to look nicer when converted to HTML on the web\n+  site.\n+\n+* April 1, 2004\n+- Dirk Manske provided a new function that is now named ares_cancel(). It is\n+  used to cancel/cleanup a resolve/request made using ares functions on the\n+  given ares channel. It does not destroy/kill the ares channel itself.\n+\n+- Dominick Meglio cleaned up the formatting in several man pages.\n+\n+* March 30, 2004\n+- Dominick Meglio's new ares_expand_string. A helper function when decoding\n+  incoming DNS packages.\n+\n+- Daniel Stenberg modified the Makefile.in to use a for loop for the man page\n+  installation to improve overview and make it easier to add man pages.\n+\n+Version 1.1.0 (March 11, 2004)\n+\n+* March 9, 2004\n+- Gisle Vanem improved build on Windows.\n+\n+* February 25, 2004\n+- Dan Fandrich found a flaw in the Feb 22 fix.\n+\n+- Added better configure --enable-debug logic (taken from the curl configure\n+  script). Added acinclude.m4 to the tarball.\n+\n+* February 23, 2004\n+- Removed ares_free_errmem(), the function, the file and the man page. It was\n+  not used and it did nothing.\n+\n+- Fixed a lot of code that wasn't \"64bit clean\" and thus caused a lot of\n+  compiler warnings on picky compilers.\n+\n+* February 22, 2004\n+- Dominick Meglio made ares init support multiple name servers in the\n+  NameServer key on Windows.\n+\n+* February 16, 2004\n+- Modified ares_private.h to include libcurl's memory debug header if\n+  CURLDEBUG is set. This makes all the ares-functions supervised properly by\n+  the curl test suite. This also forced me to add inclusion of the\n+  ares_private.h header in a few more files that are using some kind of\n+  memory-related resources.\n+\n+- Made the makefile only build ahost and adig if 'make demos' is used.\n+\n+* February 10, 2004\n+- Dirk Manske made ares_version.h installed with 'make install'\n+\n+* February 4, 2004\n+- ares_free_errmem() is subject for removal, it is simply present for future\n+  purposes, and since we removed the extra parameter in strerror() it won't\n+  be used by c-ares!\n+- configure --enable-debug now enables picky compiler options if gcc is used\n+- fixed several compiler warnings --enable-debug showed and Joerg Mueller-Tolk\n+  reported\n+\n+Version 1.0.0 (February 3, 2004)\n+\n+* February 3, 2004\n+- now we produce the libcares.a library instead of the previous libares.a\n+  since we are no longer compatible\n+\n+* February 2, 2004\n+\n+- ares_strerror() has one argument less. This is the first official\n+  modification of the existing provided ares API.\n+\n+* January 29, 2004\n+\n+- Dirk Manske fixed how the socket is set non-blocking.\n+\n+* January 4, 2004\n+\n+- Dominick Meglio made the private gettimeofday() become ares_gettimeofday()\n+  instead in order to not pollute the name space and risk colliding with\n+  other libraries' versions of this function.\n+\n+* October 24, 2003. Daniel Stenberg\n+\n+  Added ares_version().\n+\n+Version 1.0-pre1 (8 October 2003)\n+\n+- James Bursa made it run on RISC OS\n+\n+- Dominick Meglio made it run fine on NT4\n+\n+- Duncan Wilcox made it work fine on Mac OS X\n+\n+- Daniel Stenberg adjusted the windows port\n+\n+- liren at vivisimo.com made the initial windows port\n+\n+* Imported the sources from ares 1.1.1"}, {"sha": "7bbb95b879cea72095854c0bd50291587a3e121c", "filename": "src/rt/libuv/src/ares/CMakeLists.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FCMakeLists.txt", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FCMakeLists.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FCMakeLists.txt?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,22 @@\n+include_directories(${CMAKE_CURRENT_SOURCE_DIR})\n+include_directories(${node_platform}-${cares_arch})\n+add_definitions(-DHAVE_CONFIG_H=1)\n+\n+include(CheckLibraryExists)\n+check_library_exists(socket socket \"\" HAVE_SOCKET_LIB)\n+check_library_exists(nsl gethostbyname \"\" HAVE_NSL_LIB)\n+\n+file(GLOB lib_sources *.c)\n+add_library(cares ${lib_sources})\n+\n+if(${HAVE_SOCKET_LIB})\n+  set(cares_libs ${cares_libs} socket)\n+endif()\n+\n+if(${HAVE_NSL_LIB})\n+  set(cares_libs ${cares_libs} nsl)\n+endif()\n+\n+if(cares_libs)\n+  target_link_libraries(cares ${cares_libs})\n+endif()"}, {"sha": "95a2eeea2742b06a2e8645634509c27326b4ee07", "filename": "src/rt/libuv/src/ares/NEWS", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FNEWS", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FNEWS", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FNEWS?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,21 @@\n+Major changes since:\n+* see the CHANGES file\n+\n+Major changes in release 1.1.1:\n+* ares should now compile as C++ code (no longer uses reserved word\n+  \"class\").\n+* Added SRV support to adig test program.\n+* Fixed a few error handling bugs in query processing.\n+\n+Major changes in release 1.1.0:\n+* Added ares_free_string() function so that memory can be freed in the\n+  same layer as it is allocated, a desirable feature in some\n+  environments.\n+* A few of the ares_dns.h macros are fixed to use the proper bitwise\n+  operator.\n+* Fixed a couple of fenceposts fixed in ares_expand_name()'s\n+  bounds-checking.\n+* In process_timeouts(), extract query->next before calling\n+  next_server() and possibly freeing the query structure.\n+* Casted arguments to ctype macros casted to unsigned char, since not\n+  all char values are valid inputs to those macros according to ANSI."}, {"sha": "56a43c53a74b4b826ef807634ddaa3e21eee3bb6", "filename": "src/rt/libuv/src/ares/README", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,60 @@\n+c-ares\n+======\n+\n+This is c-ares, an asynchronous resolver library.  It is intended for\n+applications which need to perform DNS queries without blocking, or need to\n+perform multiple DNS queries in parallel.  The primary examples of such\n+applications are servers which communicate with multiple clients and programs\n+with graphical user interfaces.\n+\n+The full source code is available in the 'c-ares' release archives, and in a\n+git repository: http://github.com/bagder/c-ares\n+\n+If you find bugs, correct flaws, have questions or have comments in general in\n+regard to c-ares (or by all means the original ares too), get in touch with us\n+on the c-ares mailing list: http://cool.haxx.se/mailman/listinfo/c-ares\n+\n+c-ares is of course distributed under the same MIT-style license as the\n+original ares.\n+\n+You'll find all c-ares details and news here:\n+\n+        http://c-ares.haxx.se/\n+\n+\n+NOTES FOR C-ARES HACKERS\n+\n+The following notes apply to c-ares version 1.7.0 and later.\n+\n+* The distributed ares_build.h file is only intended to be used on systems\n+  which can not run the also distributed configure script.\n+\n+* The distributed ares_build.h file is generated as a copy of ares_build.h.dist\n+  when the c-ares source code distribution archive file is originally created.\n+\n+* If you check out from git on a non-configure platform, you must run the\n+  appropriate buildconf* script to set up ares_build.h and other local files\n+  before being able of compiling the library.\n+\n+* On systems capable of running the configure script, the configure process\n+  will overwrite the distributed ares_build.h file with one that is suitable\n+  and specific to the library being configured and built, this new file is\n+  generated from the ares_build.h.in template file.\n+\n+* If you intend to distribute an already compiled c-ares library you _MUST_\n+  also distribute along with it the generated ares_build.h which has been\n+  used to compile it. Otherwise the library will be of no use for the users of\n+  the library that you have built. It is _your_ responsibility to provide this\n+  file. No one at the c-ares project can know how you have built the library.\n+\n+* File ares_build.h includes platform and configuration dependent info,\n+  and must not be modified by anyone. Configure script generates it for you.\n+\n+* We cannot assume anything else but very basic compiler features being\n+  present. While c-ares requires an ANSI C compiler to build, some of the\n+  earlier ANSI compilers clearly can't deal with some preprocessor operators.\n+\n+* Newlines must remain unix-style for older compilers' sake.\n+\n+* Comments must be written in the old-style /* unnested C-fashion */\n+"}, {"sha": "aca54c8cd1fc77e7259609bb0a2c75ed8414c75b", "filename": "src/rt/libuv/src/ares/README.cares", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.cares", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.cares", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.cares?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,13 @@\n+c-ares\n+======\n+\n+This package is based on ares 1.1.1 (written by Greg Hudson). I decided to\n+fork and release a separate project since the ares author didn't want the\n+improvements that were vital for our use of it.\n+\n+This package is dubbed 'c-ares' since I (Daniel Stenberg) wanted this for use\n+within the curl project (hence the letter C) and it makes a nice pun. Also,\n+c-ares is not API compatible with ares: a new name makes that more obvious to\n+the public.\n+\n+The original libares was distributed at athena-dist.mit.edu:pub/ATHENA/ares."}, {"sha": "9c1163ac5f1060f8d4701a6ebfef9007df9e082a", "filename": "src/rt/libuv/src/ares/README.msvc", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.msvc", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.msvc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.msvc?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,118 @@\n+\n+\n+                          ___       __ _ _ __ ___  ___ \n+                         / __| ___ / _` | '__/ _ \\/ __|\n+                        | (_  |___| (_| | | |  __/\\__ \\\n+                         \\___|     \\__,_|_|  \\___||___/\n+\n+\n+                How to build c-ares using MSVC or Visual Studio\n+               =================================================\n+\n+\n+\n+  How to build using MSVC from the command line\n+  ---------------------------------------------\n+\n+  Open a command prompt window and ensure that the environment is properly\n+  set up in order to use MSVC or Visual Studio compiler tools.\n+\n+  Change to c-ares source folder where Makefile.msvc file is located and run:\n+\n+  > nmake -f Makefile.msvc\n+\n+  This will build all c-ares libraries as well as three sample programs.\n+\n+  Once the above command has finished a new folder named MSVCXX will exist\n+  below the folder where makefile.msvc is found. The name of the folder\n+  depends on the MSVC compiler version being used to build c-ares.\n+\n+  Below the MSVCXX folder there will exist four folders named 'cares',\n+  'ahost', 'acountry', and 'adig'. The 'cares' folder is the one that\n+  holds the c-ares libraries you have just generated, the other three\n+  hold sample programs that use the libraries.\n+\n+  The above command builds four versions of the c-ares library, dynamic\n+  and static versions and each one in release and debug flavours. Each\n+  of these is found in folders named dll-release, dll-debug, lib-release,\n+  and lib-debug, which hang from the 'cares' folder mentioned above. Each\n+  sample program also has folders with the same names to reflect which\n+  library version it is using.\n+\n+\n+  How to build using Visual Studio 6 IDE\n+  --------------------------------------\n+\n+  A VC++ 6.0 reference workspace (vc6aws.dsw) is available within the 'vc'\n+  folder to allow proper building of the library and sample programs.\n+\n+  1) Open the vc6aws.dsw workspace with MSVC6's IDE.\n+  2) Select 'Build' from top menu.\n+  3) Select 'Batch Build' from dropdown menu.\n+  4) Make sure that the sixteen project configurations are 'checked'.\n+  5) Click on the 'Build' button.\n+  6) Once the sixteen project configurations are built you are done.\n+\n+  Dynamic and static c-ares libraries are built in debug and release flavours,\n+  and can be located each one in its own subdirectory, dll-debug, dll-release,\n+  lib-debug and lib-release, all of them below the 'vc\\cares' subdirectory.\n+\n+  In the same way four executable versions of each sample program are built,\n+  each using its respective library. The resulting sample executables are\n+  located in its own subdirectory, dll-debug, dll-release, lib-debug and\n+  lib-release, below the 'vc\\acountry', 'vc\\adig' and 'vc\\ahost'folders.\n+\n+  These reference VC++ 6.0 configurations are generated using the dynamic CRT.\n+\n+\n+  How to build using Visual Studio 2003 or newer IDE\n+  --------------------------------------------------\n+\n+  First you have to convert the VC++ 6.0 reference workspace and project files\n+  to the Visual Studio IDE version you are using, following next steps:\n+\n+  1) Open vc\\vc6aws.dsw with VS20XX.\n+  2) Allow VS20XX to update all projects and workspaces.\n+  3) Save ALL and close VS20XX.\n+  4) Open vc\\vc6aws.sln with VS20XX.\n+  5) Select batch build, check 'all' projects and click 'build' button.\n+\n+  Same comments relative to generated files and folders as done above for\n+  Visual Studio 6 IDE apply here.\n+\n+\n+  Relationship between c-ares library file names and versions\n+  -----------------------------------------------------------\n+\n+  c-ares static release library version files:\n+\n+      libcares.lib -> static release library\n+\n+  c-ares static debug library version files:\n+\n+      libcaresd.lib -> static debug library\n+\n+  c-ares dynamic release library version files:\n+\n+      cares.dll -> dynamic release library\n+      cares.lib -> import library for the dynamic release library\n+      cares.exp -> export file for the dynamic release library\n+\n+  c-ares dynamic debug library version files:\n+\n+      caresd.dll -> dynamic debug library\n+      caresd.lib -> import library for the dynamic debug library\n+      caresd.exp -> export file for the dynamic debug library\n+      caresd.pdb -> debug symbol file for the dynamic debug library\n+\n+\n+  How to use c-ares static libraries\n+  ----------------------------------\n+\n+  When using the c-ares static library in your program, you will have to\n+  define preprocessor symbol CARES_STATICLIB while building your program,\n+  otherwise you will get errors at linkage stage.\n+\n+\n+Have Fun!\n+ "}, {"sha": "17503096fdd636b6c01b9a8d364812bf0c697bff", "filename": "src/rt/libuv/src/ares/README.node", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.node", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.node", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.node?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,21 @@\n+Library: c-ares, DNS resolver\n+\n+Version: 1.7.3 (11 June, 2010)\n+\n+Authors: Greg Hudson, Daniel Stenberg\n+\n+License: MIT\n+\n+Notes:\n+\n+Just use waf instead of the autoconf based configure script. Delete most of\n+the documentation and other files distributed with it. To upgrade, run\n+./configure on linux, macintosh, solaris (and other supported platforms) and\n+copy\n+- ares_config.h\n+- ares_setup.h\n+- ares_build.h\n+into the appropriate directory.\n+\n+\n+"}, {"sha": "639a314e19671c01b582209f7ac505aeb839c841", "filename": "src/rt/libuv/src/ares/RELEASE-NOTES", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FRELEASE-NOTES", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FRELEASE-NOTES", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FRELEASE-NOTES?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,25 @@\n+c-ares version 1.7.4\n+\n+Changed:\n+\n+ o local-bind: Support binding to local interface/IPs, see\n+   ares_set_local_ip4, ares_set_local_ip6, ares_set_local_dev\n+\n+Fixed:\n+\n+ o memory leak in ares_getnameinfo\n+ o add missing break that caused get_ares_servers to fail\n+ o ares_parse_a_reply: fix CNAME response parsing\n+ o init_by_options: don't copy an empty sortlist\n+ o Replaced uint32_t with unsigned int to fix broken builds\n+   on a couple of platforms\n+ o Fix lookup with HOSTALIASES set\n+ o adig: fix NAPTR parsing\n+ o compiler warning cleanups\n+\n+Thanks go to these friendly people for their efforts and contributions:\n+\n+ Andrew C. Morrow, Ben Greear, Ben Noordhuis, Daniel Stenberg,\n+ Guenter Knauf, Mike Crowe, Patrik Thunstrom, Yang Tse\n+\n+Have fun!"}, {"sha": "fa31cea6fb79b42edda1a4dd4ab9745fb783c237", "filename": "src/rt/libuv/src/ares/TODO", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FTODO", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2FTODO", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FTODO?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,23 @@\n+TODO\n+====\n+\n+ares_reinit()\n+\n+- To allow an app to force a re-read of /etc/resolv.conf etc, pretty much\n+  like the res_init() resolver function offers\n+\n+ares_gethostbyname\n+\n+- When built to support IPv6, it needs to also support PF_UNSPEC or similar,\n+  so that an application can ask for any protocol and then c-ares would return\n+  all known resolves and not just explicitly IPv4 _or_ IPv6 resolves.\n+\n+ares_process\n+\n+- Upon next ABI breakage ares_process() should be changed to return 'int'\n+  and return ARES_ENOTINITIALIZED if ares_library_init() has not been called.\n+\n+ares_process_fd\n+\n+- Upon next ABI breakage ares_process_fd() should be changed to return\n+  'int' and return ARES_ENOTINITIALIZED if library has not been initialized."}, {"sha": "5d391a9ef2ec7fb4c6eb6ec11aa459d56393eebb", "filename": "src/rt/libuv/src/ares/ares__close_sockets.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__close_sockets.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__close_sockets.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__close_sockets.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,66 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#include <stdlib.h>\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#include \"ares.h\"\n+#include \"ares_private.h\"\n+\n+void ares__close_sockets(ares_channel channel, struct server_state *server)\n+{\n+  struct send_request *sendreq;\n+\n+  /* Free all pending output buffers. */\n+  while (server->qhead)\n+    {\n+      /* Advance server->qhead; pull out query as we go. */\n+      sendreq = server->qhead;\n+      server->qhead = sendreq->next;\n+      if (sendreq->data_storage != NULL)\n+        free(sendreq->data_storage);\n+      free(sendreq);\n+    }\n+  server->qtail = NULL;\n+\n+  /* Reset any existing input buffer. */\n+  if (server->tcp_buffer)\n+    free(server->tcp_buffer);\n+  server->tcp_buffer = NULL;\n+  server->tcp_lenbuf_pos = 0;\n+\n+  /* Reset brokenness */\n+  server->is_broken = 0;\n+\n+  /* Close the TCP and UDP sockets. */\n+  if (server->tcp_socket != ARES_SOCKET_BAD)\n+    {\n+      SOCK_STATE_CALLBACK(channel, server->tcp_socket, 0, 0);\n+      sclose(server->tcp_socket);\n+      server->tcp_socket = ARES_SOCKET_BAD;\n+      server->tcp_connection_generation = ++channel->tcp_connection_generation;\n+    }\n+  if (server->udp_socket != ARES_SOCKET_BAD)\n+    {\n+      SOCK_STATE_CALLBACK(channel, server->udp_socket, 0, 0);\n+      sclose(server->udp_socket);\n+      server->udp_socket = ARES_SOCKET_BAD;\n+    }\n+}"}, {"sha": "298df09182a63c7b4ae9ed5fc78e5cebf6cb996f", "filename": "src/rt/libuv/src/ares/ares__get_hostent.c", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__get_hostent.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__get_hostent.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__get_hostent.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,263 @@\n+\n+/* Copyright 1998, 2010 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_NETDB_H\n+#  include <netdb.h>\n+#endif\n+#ifdef HAVE_ARPA_INET_H\n+#  include <arpa/inet.h>\n+#endif\n+\n+#include \"ares.h\"\n+#include \"inet_net_pton.h\"\n+#include \"ares_private.h\"\n+\n+int ares__get_hostent(FILE *fp, int family, struct hostent **host)\n+{\n+  char *line = NULL, *p, *q, **alias;\n+  char *txtaddr, *txthost, *txtalias;\n+  int status;\n+  size_t addrlen, linesize, naliases;\n+  struct ares_addr addr;\n+  struct hostent *hostent = NULL;\n+\n+  *host = NULL; /* Assume failure */\n+\n+  /* Validate family */\n+  switch (family) {\n+    case AF_INET:\n+    case AF_INET6:\n+    case AF_UNSPEC:\n+      break;\n+    default:\n+      return ARES_EBADFAMILY;\n+  }\n+\n+  while ((status = ares__read_line(fp, &line, &linesize)) == ARES_SUCCESS)\n+    {\n+\n+      /* Trim line comment. */\n+      p = line;\n+      while (*p && (*p != '#'))\n+        p++;\n+      *p = '\\0';\n+\n+      /* Trim trailing whitespace. */\n+      q = p - 1;\n+      while ((q >= line) && ISSPACE(*q))\n+        q--;\n+      *++q = '\\0';\n+\n+      /* Skip leading whitespace. */\n+      p = line;\n+      while (*p && ISSPACE(*p))\n+        p++;\n+      if (!*p)\n+        /* Ignore line if empty. */\n+        continue;\n+\n+      /* Pointer to start of IPv4 or IPv6 address part. */\n+      txtaddr = p;\n+\n+      /* Advance past address part. */\n+      while (*p && !ISSPACE(*p))\n+        p++;\n+      if (!*p)\n+        /* Ignore line if reached end of line. */\n+        continue;\n+\n+      /* Null terminate address part. */\n+      *p = '\\0';\n+\n+      /* Advance to host name */\n+      p++;\n+      while (*p && ISSPACE(*p))\n+        p++;\n+      if (!*p)\n+        /* Ignore line if reached end of line. */\n+        continue;\n+\n+      /* Pointer to start of host name. */\n+      txthost = p;\n+\n+      /* Advance past host name. */\n+      while (*p && !ISSPACE(*p))\n+        p++;\n+\n+      /* Pointer to start of first alias. */\n+      txtalias = NULL;\n+      if (*p)\n+        {\n+          q = p + 1;\n+          while (*q && ISSPACE(*q))\n+            q++;\n+          if (*q)\n+            txtalias = q;\n+        }\n+\n+      /* Null terminate host name. */\n+      *p = '\\0';\n+\n+      /* find out number of aliases. */\n+      naliases = 0;\n+      if (txtalias)\n+        {\n+          p = txtalias;\n+          while (*p)\n+            {\n+              while (*p && !ISSPACE(*p))\n+                p++;\n+              while (*p && ISSPACE(*p))\n+                p++;\n+              naliases++;\n+            }\n+        }\n+\n+      /* Convert address string to network address for the requested family. */\n+      addrlen = 0;\n+      addr.family = AF_UNSPEC;\n+      addr.addrV4.s_addr = INADDR_NONE;\n+      if ((family == AF_INET) || (family == AF_UNSPEC))\n+        {\n+          addr.addrV4.s_addr = inet_addr(txtaddr);\n+          if (addr.addrV4.s_addr != INADDR_NONE)\n+            {\n+              /* Actual network address family and length. */\n+              addr.family = AF_INET;\n+              addrlen = sizeof(addr.addrV4);\n+            }\n+        }\n+      if ((family == AF_INET6) || ((family == AF_UNSPEC) && (!addrlen)))\n+        {\n+          if (ares_inet_pton(AF_INET6, txtaddr, &addr.addrV6) > 0)\n+            {\n+              /* Actual network address family and length. */\n+              addr.family = AF_INET6;\n+              addrlen = sizeof(addr.addrV6);\n+            }\n+        }\n+      if (!addrlen)\n+        /* Ignore line if invalid address string for the requested family. */\n+        continue;\n+\n+      /*\n+      ** Actual address family possible values are AF_INET and AF_INET6 only.\n+      */\n+\n+      /* Allocate memory for the hostent structure. */\n+      hostent = malloc(sizeof(struct hostent));\n+      if (!hostent)\n+        break;\n+\n+      /* Initialize fields for out of memory condition. */\n+      hostent->h_aliases = NULL;\n+      hostent->h_addr_list = NULL;\n+\n+      /* Copy official host name. */\n+      hostent->h_name = strdup(txthost);\n+      if (!hostent->h_name)\n+        break;\n+\n+      /* Copy network address. */\n+      hostent->h_addr_list = malloc(2 * sizeof(char *));\n+      if (!hostent->h_addr_list)\n+        break;\n+      hostent->h_addr_list[1] = NULL;\n+      hostent->h_addr_list[0] = malloc(addrlen);\n+      if (!hostent->h_addr_list[0])\n+        break;\n+      if (addr.family == AF_INET)\n+        memcpy(hostent->h_addr_list[0], &addr.addrV4, sizeof(addr.addrV4));\n+      else\n+        memcpy(hostent->h_addr_list[0], &addr.addrV6, sizeof(addr.addrV6));\n+\n+      /* Copy aliases. */\n+      hostent->h_aliases = malloc((naliases + 1) * sizeof(char *));\n+      if (!hostent->h_aliases)\n+        break;\n+      alias = hostent->h_aliases;\n+      while (naliases)\n+        *(alias + naliases--) = NULL;\n+      *alias = NULL;\n+      while (txtalias)\n+        {\n+          p = txtalias;\n+          while (*p && !ISSPACE(*p))\n+            p++;\n+          q = p;\n+          while (*q && ISSPACE(*q))\n+            q++;\n+          *p = '\\0';\n+          if ((*alias = strdup(txtalias)) == NULL)\n+            break;\n+          alias++;\n+          txtalias = *q ? q : NULL;\n+        }\n+      if (txtalias)\n+        /* Alias memory allocation failure. */\n+        break;\n+\n+      /* Copy actual network address family and length. */\n+      hostent->h_addrtype = addr.family;\n+      hostent->h_length = (int)addrlen;\n+\n+      /* Free line buffer. */\n+      free(line);\n+\n+      /* Return hostent successfully */\n+      *host = hostent;\n+      return ARES_SUCCESS;\n+\n+    }\n+\n+  /* If allocated, free line buffer. */\n+  if (line)\n+    free(line);\n+\n+  if (status == ARES_SUCCESS)\n+    {\n+      /* Memory allocation failure; clean up. */\n+      if (hostent)\n+        {\n+          if (hostent->h_name)\n+            free((char *) hostent->h_name);\n+          if (hostent->h_aliases)\n+            {\n+              for (alias = hostent->h_aliases; *alias; alias++)\n+                free(*alias);\n+              free(hostent->h_aliases);\n+            }\n+          if (hostent->h_addr_list)\n+            {\n+              if (hostent->h_addr_list[0])\n+                free(hostent->h_addr_list[0]);\n+              free(hostent->h_addr_list);\n+            }\n+          free(hostent);\n+        }\n+      return ARES_ENOMEM;\n+    }\n+\n+  return status;\n+}"}, {"sha": "ca018035ec369820362929584143fb0713ed9673", "filename": "src/rt/libuv/src/ares/ares__read_line.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__read_line.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__read_line.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__read_line.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,71 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include \"ares.h\"\n+#include \"ares_nowarn.h\"\n+#include \"ares_private.h\"\n+\n+/* This is an internal function.  Its contract is to read a line from\n+ * a file into a dynamically allocated buffer, zeroing the trailing\n+ * newline if there is one.  The calling routine may call\n+ * ares__read_line multiple times with the same buf and bufsize\n+ * pointers; *buf will be reallocated and *bufsize adjusted as\n+ * appropriate.  The initial value of *buf should be NULL.  After the\n+ * calling routine is done reading lines, it should free *buf.\n+ */\n+int ares__read_line(FILE *fp, char **buf, size_t *bufsize)\n+{\n+  char *newbuf;\n+  size_t offset = 0;\n+  size_t len;\n+\n+  if (*buf == NULL)\n+    {\n+      *buf = malloc(128);\n+      if (!*buf)\n+        return ARES_ENOMEM;\n+      *bufsize = 128;\n+    }\n+\n+  for (;;)\n+    {\n+      int bytestoread = aresx_uztosi(*bufsize - offset);\n+\n+      if (!fgets(*buf + offset, bytestoread, fp))\n+        return (offset != 0) ? 0 : (ferror(fp)) ? ARES_EFILE : ARES_EOF;\n+      len = offset + strlen(*buf + offset);\n+      if ((*buf)[len - 1] == '\\n')\n+        {\n+          (*buf)[len - 1] = 0;\n+          break;\n+        }\n+      offset = len;\n+      if(len < *bufsize - 1)\n+        continue;\n+\n+      /* Allocate more space. */\n+      newbuf = realloc(*buf, *bufsize * 2);\n+      if (!newbuf)\n+        return ARES_ENOMEM;\n+      *buf = newbuf;\n+      *bufsize *= 2;\n+    }\n+  return ARES_SUCCESS;\n+}"}, {"sha": "f7aa7883f93572e8e23945305c59a8a1877135b2", "filename": "src/rt/libuv/src/ares/ares__timeval.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__timeval.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__timeval.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__timeval.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,111 @@\n+\n+/* Copyright (C) 2008 by Daniel Stenberg et al\n+ *\n+ * Permission to use, copy, modify, and distribute this software and its\n+ * documentation for any purpose and without fee is hereby granted, provided\n+ * that the above copyright notice appear in all copies and that both that\n+ * copyright notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in advertising or\n+ * publicity pertaining to distribution of the software without specific,\n+ * written prior permission.  M.I.T. makes no representations about the\n+ * suitability of this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+#include \"ares.h\"\n+#include \"ares_private.h\"\n+\n+#if defined(WIN32) && !defined(MSDOS)\n+\n+struct timeval ares__tvnow(void)\n+{\n+  /*\n+  ** GetTickCount() is available on _all_ Windows versions from W95 up\n+  ** to nowadays. Returns milliseconds elapsed since last system boot,\n+  ** increases monotonically and wraps once 49.7 days have elapsed.\n+  */\n+  struct timeval now;\n+  DWORD milliseconds = GetTickCount();\n+  now.tv_sec = milliseconds / 1000;\n+  now.tv_usec = (milliseconds % 1000) * 1000;\n+  return now;\n+}\n+\n+#elif defined(HAVE_CLOCK_GETTIME_MONOTONIC)\n+\n+struct timeval ares__tvnow(void)\n+{\n+  /*\n+  ** clock_gettime() is granted to be increased monotonically when the\n+  ** monotonic clock is queried. Time starting point is unspecified, it\n+  ** could be the system start-up time, the Epoch, or something else,\n+  ** in any case the time starting point does not change once that the\n+  ** system has started up.\n+  */\n+  struct timeval now;\n+  struct timespec tsnow;\n+  if(0 == clock_gettime(CLOCK_MONOTONIC, &tsnow)) {\n+    now.tv_sec = tsnow.tv_sec;\n+    now.tv_usec = tsnow.tv_nsec / 1000;\n+  }\n+  /*\n+  ** Even when the configure process has truly detected monotonic clock\n+  ** availability, it might happen that it is not actually available at\n+  ** run-time. When this occurs simply fallback to other time source.\n+  */\n+#ifdef HAVE_GETTIMEOFDAY\n+  else\n+    (void)gettimeofday(&now, NULL);\n+#else\n+  else {\n+    now.tv_sec = (long)time(NULL);\n+    now.tv_usec = 0;\n+  }\n+#endif\n+  return now;\n+}\n+\n+#elif defined(HAVE_GETTIMEOFDAY)\n+\n+struct timeval ares__tvnow(void)\n+{\n+  /*\n+  ** gettimeofday() is not granted to be increased monotonically, due to\n+  ** clock drifting and external source time synchronization it can jump\n+  ** forward or backward in time.\n+  */\n+  struct timeval now;\n+  (void)gettimeofday(&now, NULL);\n+  return now;\n+}\n+\n+#else\n+\n+struct timeval ares__tvnow(void)\n+{\n+  /*\n+  ** time() returns the value of time in seconds since the Epoch.\n+  */\n+  struct timeval now;\n+  now.tv_sec = (long)time(NULL);\n+  now.tv_usec = 0;\n+  return now;\n+}\n+\n+#endif\n+\n+#if 0 /* Not used */\n+/*\n+ * Make sure that the first argument is the more recent time, as otherwise\n+ * we'll get a weird negative time-diff back...\n+ *\n+ * Returns: the time difference in number of milliseconds.\n+ */\n+long ares__tvdiff(struct timeval newer, struct timeval older)\n+{\n+  return (newer.tv_sec-older.tv_sec)*1000+\n+    (newer.tv_usec-older.tv_usec)/1000;\n+}\n+#endif\n+"}, {"sha": "eb790ae00d06f82f0d9d350ccd54d75a364dfae0", "filename": "src/rt/libuv/src/ares/ares_cancel.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_cancel.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_cancel.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_cancel.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,63 @@\n+\n+/* Copyright (C) 2004 by Daniel Stenberg et al\n+ *\n+ * Permission to use, copy, modify, and distribute this software and its\n+ * documentation for any purpose and without fee is hereby granted, provided\n+ * that the above copyright notice appear in all copies and that both that\n+ * copyright notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in advertising or\n+ * publicity pertaining to distribution of the software without specific,\n+ * written prior permission.  M.I.T. makes no representations about the\n+ * suitability of this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+#include <assert.h>\n+#include <stdlib.h>\n+#include \"ares.h\"\n+#include \"ares_private.h\"\n+\n+/*\n+ * ares_cancel() cancels all ongoing requests/resolves that might be going on\n+ * on the given channel. It does NOT kill the channel, use ares_destroy() for\n+ * that.\n+ */\n+void ares_cancel(ares_channel channel)\n+{\n+  struct query *query;\n+  struct list_node* list_head;\n+  struct list_node* list_node;\n+  int i;\n+\n+  list_head = &(channel->all_queries);\n+  for (list_node = list_head->next; list_node != list_head; )\n+  {\n+    query = list_node->data;\n+    list_node = list_node->next;  /* since we're deleting the query */\n+    query->callback(query->arg, ARES_ECANCELLED, 0, NULL, 0);\n+    ares__free_query(query);\n+  }\n+#ifndef NDEBUG\n+  /* Freeing the query should remove it from all the lists in which it sits,\n+   * so all query lists should be empty now.\n+   */\n+  assert(ares__is_list_empty(&(channel->all_queries)));\n+  for (i = 0; i < ARES_QID_TABLE_SIZE; i++)\n+    {\n+      assert(ares__is_list_empty(&(channel->queries_by_qid[i])));\n+    }\n+  for (i = 0; i < ARES_TIMEOUT_TABLE_SIZE; i++)\n+    {\n+      assert(ares__is_list_empty(&(channel->queries_by_timeout[i])));\n+    }\n+#endif\n+  if (!(channel->flags & ARES_FLAG_STAYOPEN))\n+  {\n+    if (channel->servers)\n+    {\n+      for (i = 0; i < channel->nservers; i++)\n+        ares__close_sockets(channel, &channel->servers[i]);\n+    }\n+  }\n+}"}, {"sha": "a2477be192c562389cb7d23b5dbec58e08db40f9", "filename": "src/rt/libuv/src/ares/ares_data.c", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_data.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_data.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_data.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,190 @@\n+\n+/* Copyright (C) 2009-2010 by Daniel Stenberg\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+\n+#include \"ares_setup.h\"\n+\n+#include <stddef.h>\n+\n+#include \"ares.h\"\n+#include \"ares_data.h\"\n+#include \"ares_private.h\"\n+\n+\n+/*\n+** ares_free_data() - c-ares external API function.\n+**\n+** This function must be used by the application to free data memory that\n+** has been internally allocated by some c-ares function and for which a\n+** pointer has already been returned to the calling application. The list\n+** of c-ares functions returning pointers that must be free'ed using this\n+** function is:\n+**\n+**   ares_get_servers()\n+**   ares_parse_srv_reply()\n+**   ares_parse_txt_reply()\n+*/\n+\n+void ares_free_data(void *dataptr)\n+{\n+  struct ares_data *ptr;\n+\n+  if (!dataptr)\n+    return;\n+\n+#ifdef __INTEL_COMPILER\n+#  pragma warning(push)\n+#  pragma warning(disable:1684)\n+   /* 1684: conversion from pointer to same-sized integral type */\n+#endif\n+\n+  ptr = (void *)((char *)dataptr - offsetof(struct ares_data, data));\n+\n+#ifdef __INTEL_COMPILER\n+#  pragma warning(pop)\n+#endif\n+\n+  if (ptr->mark != ARES_DATATYPE_MARK)\n+    return;\n+\n+  switch (ptr->type)\n+    {\n+      case ARES_DATATYPE_MX_REPLY:\n+\n+        if (ptr->data.mx_reply.next)\n+          ares_free_data(ptr->data.mx_reply.next);\n+        if (ptr->data.mx_reply.host)\n+          free(ptr->data.mx_reply.host);\n+        break;\n+\n+      case ARES_DATATYPE_SRV_REPLY:\n+\n+        if (ptr->data.srv_reply.next)\n+          ares_free_data(ptr->data.srv_reply.next);\n+        if (ptr->data.srv_reply.host)\n+          free(ptr->data.srv_reply.host);\n+        break;\n+\n+      case ARES_DATATYPE_TXT_REPLY:\n+\n+        if (ptr->data.txt_reply.next)\n+          ares_free_data(ptr->data.txt_reply.next);\n+        if (ptr->data.txt_reply.txt)\n+          free(ptr->data.txt_reply.txt);\n+        break;\n+\n+      case ARES_DATATYPE_ADDR_NODE:\n+\n+        if (ptr->data.addr_node.next)\n+          ares_free_data(ptr->data.addr_node.next);\n+        break;\n+\n+      default:\n+        return;\n+    }\n+\n+  free(ptr);\n+}\n+\n+\n+/*\n+** ares_malloc_data() - c-ares internal helper function.\n+**\n+** This function allocates memory for a c-ares private ares_data struct\n+** for the specified ares_datatype, initializes c-ares private fields\n+** and zero initializes those which later might be used from the public\n+** API. It returns an interior pointer which can be passed by c-ares\n+** functions to the calling application, and that must be free'ed using\n+** c-ares external API function ares_free_data().\n+*/\n+\n+void *ares_malloc_data(ares_datatype type)\n+{\n+  struct ares_data *ptr;\n+\n+  ptr = malloc(sizeof(struct ares_data));\n+  if (!ptr)\n+    return NULL;\n+\n+  switch (type)\n+    {\n+      case ARES_DATATYPE_MX_REPLY:\n+        ptr->data.mx_reply.next = NULL;\n+        ptr->data.mx_reply.host = NULL;\n+        ptr->data.mx_reply.priority = 0;\n+        break;\n+\n+      case ARES_DATATYPE_SRV_REPLY:\n+        ptr->data.srv_reply.next = NULL;\n+        ptr->data.srv_reply.host = NULL;\n+        ptr->data.srv_reply.priority = 0;\n+        ptr->data.srv_reply.weight = 0;\n+        ptr->data.srv_reply.port = 0;\n+        break;\n+\n+      case ARES_DATATYPE_TXT_REPLY:\n+        ptr->data.txt_reply.next = NULL;\n+        ptr->data.txt_reply.txt = NULL;\n+        ptr->data.txt_reply.length  = 0;\n+        break;\n+\n+      case ARES_DATATYPE_ADDR_NODE:\n+        ptr->data.addr_node.next = NULL;\n+        ptr->data.addr_node.family = 0;\n+        memset(&ptr->data.addr_node.addrV6, 0,\n+               sizeof(ptr->data.addr_node.addrV6));\n+        break;\n+\n+      default:\n+        free(ptr);\n+        return NULL;\n+    }\n+\n+  ptr->mark = ARES_DATATYPE_MARK;\n+  ptr->type = type;\n+\n+  return &ptr->data;\n+}\n+\n+\n+/*\n+** ares_get_datatype() - c-ares internal helper function.\n+**\n+** This function returns the ares_datatype of the data stored in a\n+** private ares_data struct when given the public API pointer.\n+*/\n+\n+ares_datatype ares_get_datatype(void * dataptr)\n+{\n+  struct ares_data *ptr;\n+\n+#ifdef __INTEL_COMPILER\n+#  pragma warning(push)\n+#  pragma warning(disable:1684)\n+   /* 1684: conversion from pointer to same-sized integral type */\n+#endif\n+\n+  ptr = (void *)((char *)dataptr - offsetof(struct ares_data, data));\n+\n+#ifdef __INTEL_COMPILER\n+#  pragma warning(pop)\n+#endif\n+\n+  if (ptr->mark == ARES_DATATYPE_MARK)\n+    return ptr->type;\n+\n+  return ARES_DATATYPE_UNKNOWN;\n+}"}, {"sha": "de1608be5b85519b9e64ab8232f4984646ed10f4", "filename": "src/rt/libuv/src/ares/ares_data.h", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_data.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_data.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_data.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,65 @@\n+\n+/* Copyright (C) 2009-2010 by Daniel Stenberg\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+typedef enum {\n+  ARES_DATATYPE_UNKNOWN = 1,  /* unknown data type     - introduced in 1.7.0 */\n+  ARES_DATATYPE_SRV_REPLY,    /* struct ares_srv_reply - introduced in 1.7.0 */\n+  ARES_DATATYPE_TXT_REPLY,    /* struct ares_txt_reply - introduced in 1.7.0 */\n+  ARES_DATATYPE_ADDR_NODE,    /* struct ares_addr_node - introduced in 1.7.1 */\n+  ARES_DATATYPE_MX_REPLY,    /* struct ares_mx_reply   - introduced in 1.7.2 */\n+#if 0\n+  ARES_DATATYPE_ADDR6TTL,     /* struct ares_addrttl   */\n+  ARES_DATATYPE_ADDRTTL,      /* struct ares_addr6ttl  */\n+  ARES_DATATYPE_HOSTENT,      /* struct hostent        */\n+  ARES_DATATYPE_OPTIONS,      /* struct ares_options   */\n+#endif\n+  ARES_DATATYPE_LAST          /* not used              - introduced in 1.7.0 */\n+} ares_datatype;\n+\n+#define ARES_DATATYPE_MARK 0xbead\n+\n+/*\n+ * ares_data struct definition is internal to c-ares and shall not\n+ * be exposed by the public API in order to allow future changes\n+ * and extensions to it without breaking ABI.  This will be used\n+ * internally by c-ares as the container of multiple types of data\n+ * dynamically allocated for which a reference will be returned\n+ * to the calling application.\n+ *\n+ * c-ares API functions returning a pointer to c-ares internally\n+ * allocated data will actually be returning an interior pointer\n+ * into this ares_data struct.\n+ *\n+ * All this is 'invisible' to the calling application, the only\n+ * requirement is that this kind of data must be free'ed by the\n+ * calling application using ares_free_data() with the pointer\n+ * it has received from a previous c-ares function call.\n+ */\n+\n+struct ares_data {\n+  ares_datatype type;  /* Actual data type identifier. */\n+  unsigned int  mark;  /* Private ares_data signature. */\n+  union {\n+    struct ares_txt_reply txt_reply;\n+    struct ares_srv_reply srv_reply;\n+    struct ares_addr_node addr_node;\n+    struct ares_mx_reply mx_reply;\n+  } data;\n+};\n+\n+void *ares_malloc_data(ares_datatype type);\n+\n+ares_datatype ares_get_datatype(void * dataptr);"}, {"sha": "5e274daeef5d67526856f6282ab505e59901cf2d", "filename": "src/rt/libuv/src/ares/ares_destroy.c", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_destroy.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_destroy.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_destroy.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,105 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ * Copyright (C) 2004-2010 by Daniel Stenberg\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+#include <assert.h>\n+#include <stdlib.h>\n+#include \"ares.h\"\n+#include \"ares_private.h\"\n+\n+void ares_destroy_options(struct ares_options *options)\n+{\n+  int i;\n+\n+  if(options->servers)\n+    free(options->servers);\n+  for (i = 0; i < options->ndomains; i++)\n+    free(options->domains[i]);\n+  free(options->domains);\n+  if(options->sortlist)\n+    free(options->sortlist);\n+  free(options->lookups);\n+}\n+\n+void ares_destroy(ares_channel channel)\n+{\n+  int i;\n+  struct query *query;\n+  struct list_node* list_head;\n+  struct list_node* list_node;\n+  \n+  if (!channel)\n+    return;\n+\n+  list_head = &(channel->all_queries);\n+  for (list_node = list_head->next; list_node != list_head; )\n+    {\n+      query = list_node->data;\n+      list_node = list_node->next;  /* since we're deleting the query */\n+      query->callback(query->arg, ARES_EDESTRUCTION, 0, NULL, 0);\n+      ares__free_query(query);\n+    }\n+#ifndef NDEBUG\n+  /* Freeing the query should remove it from all the lists in which it sits,\n+   * so all query lists should be empty now.\n+   */\n+  assert(ares__is_list_empty(&(channel->all_queries)));\n+  for (i = 0; i < ARES_QID_TABLE_SIZE; i++)\n+    {\n+      assert(ares__is_list_empty(&(channel->queries_by_qid[i])));\n+    }\n+  for (i = 0; i < ARES_TIMEOUT_TABLE_SIZE; i++)\n+    {\n+      assert(ares__is_list_empty(&(channel->queries_by_timeout[i])));\n+    }\n+#endif\n+\n+  ares__destroy_servers_state(channel);\n+\n+  if (channel->domains) {\n+    for (i = 0; i < channel->ndomains; i++)\n+      free(channel->domains[i]);\n+    free(channel->domains);\n+  }\n+\n+  if(channel->sortlist)\n+    free(channel->sortlist);\n+\n+  if (channel->lookups)\n+    free(channel->lookups);\n+\n+  free(channel);\n+}\n+\n+void ares__destroy_servers_state(ares_channel channel)\n+{\n+  struct server_state *server;\n+  int i;\n+\n+  if (channel->servers)\n+    {\n+      for (i = 0; i < channel->nservers; i++)\n+        {\n+          server = &channel->servers[i];\n+          ares__close_sockets(channel, server);\n+          assert(ares__is_list_empty(&server->queries_to_server));\n+        }\n+      free(channel->servers);\n+      channel->servers = NULL;\n+    }\n+  channel->nservers = -1;\n+}"}, {"sha": "6893c024c89f5e1b3ead0526cb82ce16ad9d7091", "filename": "src/rt/libuv/src/ares/ares_dns.h", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_dns.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_dns.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_dns.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,90 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#ifndef ARES__DNS_H\n+#define ARES__DNS_H\n+\n+#define DNS__16BIT(p)                   (((p)[0] << 8) | (p)[1])\n+#define DNS__32BIT(p)                   (((p)[0] << 24) | ((p)[1] << 16) | \\\n+                                         ((p)[2] << 8) | (p)[3])\n+\n+#define DNS__SET16BIT(p, v)  (((p)[0] = (unsigned char)(((v) >> 8) & 0xff)), \\\n+                              ((p)[1] = (unsigned char)((v) & 0xff)))\n+#define DNS__SET32BIT(p, v)  (((p)[0] = (unsigned char)(((v) >> 24) & 0xff)), \\\n+                              ((p)[1] = (unsigned char)(((v) >> 16) & 0xff)), \\\n+                              ((p)[2] = (unsigned char)(((v) >> 8) & 0xff)), \\\n+                              ((p)[3] = (unsigned char)((v) & 0xff)))\n+\n+#if 0\n+/* we cannot use this approach on systems where we can't access 16/32 bit\n+   data on un-aligned addresses */\n+#define DNS__16BIT(p)                   ntohs(*(unsigned short*)(p))\n+#define DNS__32BIT(p)                   ntohl(*(unsigned long*)(p))\n+#define DNS__SET16BIT(p, v)             *(unsigned short*)(p) = htons(v)\n+#define DNS__SET32BIT(p, v)             *(unsigned long*)(p) = htonl(v)\n+#endif\n+\n+/* Macros for parsing a DNS header */\n+#define DNS_HEADER_QID(h)               DNS__16BIT(h)\n+#define DNS_HEADER_QR(h)                (((h)[2] >> 7) & 0x1)\n+#define DNS_HEADER_OPCODE(h)            (((h)[2] >> 3) & 0xf)\n+#define DNS_HEADER_AA(h)                (((h)[2] >> 2) & 0x1)\n+#define DNS_HEADER_TC(h)                (((h)[2] >> 1) & 0x1)\n+#define DNS_HEADER_RD(h)                ((h)[2] & 0x1)\n+#define DNS_HEADER_RA(h)                (((h)[3] >> 7) & 0x1)\n+#define DNS_HEADER_Z(h)                 (((h)[3] >> 4) & 0x7)\n+#define DNS_HEADER_RCODE(h)             ((h)[3] & 0xf)\n+#define DNS_HEADER_QDCOUNT(h)           DNS__16BIT((h) + 4)\n+#define DNS_HEADER_ANCOUNT(h)           DNS__16BIT((h) + 6)\n+#define DNS_HEADER_NSCOUNT(h)           DNS__16BIT((h) + 8)\n+#define DNS_HEADER_ARCOUNT(h)           DNS__16BIT((h) + 10)\n+\n+/* Macros for constructing a DNS header */\n+#define DNS_HEADER_SET_QID(h, v)      DNS__SET16BIT(h, v)\n+#define DNS_HEADER_SET_QR(h, v)       ((h)[2] |= (unsigned char)(((v) & 0x1) << 7))\n+#define DNS_HEADER_SET_OPCODE(h, v)   ((h)[2] |= (unsigned char)(((v) & 0xf) << 3))\n+#define DNS_HEADER_SET_AA(h, v)       ((h)[2] |= (unsigned char)(((v) & 0x1) << 2))\n+#define DNS_HEADER_SET_TC(h, v)       ((h)[2] |= (unsigned char)(((v) & 0x1) << 1))\n+#define DNS_HEADER_SET_RD(h, v)       ((h)[2] |= (unsigned char)((v) & 0x1))\n+#define DNS_HEADER_SET_RA(h, v)       ((h)[3] |= (unsigned char)(((v) & 0x1) << 7))\n+#define DNS_HEADER_SET_Z(h, v)        ((h)[3] |= (unsigned char)(((v) & 0x7) << 4))\n+#define DNS_HEADER_SET_RCODE(h, v)    ((h)[3] |= (unsigned char)((v) & 0xf))\n+#define DNS_HEADER_SET_QDCOUNT(h, v)  DNS__SET16BIT((h) + 4, v)\n+#define DNS_HEADER_SET_ANCOUNT(h, v)  DNS__SET16BIT((h) + 6, v)\n+#define DNS_HEADER_SET_NSCOUNT(h, v)  DNS__SET16BIT((h) + 8, v)\n+#define DNS_HEADER_SET_ARCOUNT(h, v)  DNS__SET16BIT((h) + 10, v)\n+\n+/* Macros for parsing the fixed part of a DNS question */\n+#define DNS_QUESTION_TYPE(q)            DNS__16BIT(q)\n+#define DNS_QUESTION_CLASS(q)           DNS__16BIT((q) + 2)\n+\n+/* Macros for constructing the fixed part of a DNS question */\n+#define DNS_QUESTION_SET_TYPE(q, v)     DNS__SET16BIT(q, v)\n+#define DNS_QUESTION_SET_CLASS(q, v)    DNS__SET16BIT((q) + 2, v)\n+\n+/* Macros for parsing the fixed part of a DNS resource record */\n+#define DNS_RR_TYPE(r)                  DNS__16BIT(r)\n+#define DNS_RR_CLASS(r)                 DNS__16BIT((r) + 2)\n+#define DNS_RR_TTL(r)                   DNS__32BIT((r) + 4)\n+#define DNS_RR_LEN(r)                   DNS__16BIT((r) + 8)\n+\n+/* Macros for constructing the fixed part of a DNS resource record */\n+#define DNS_RR_SET_TYPE(r)              DNS__SET16BIT(r, v)\n+#define DNS_RR_SET_CLASS(r)             DNS__SET16BIT((r) + 2, v)\n+#define DNS_RR_SET_TTL(r)               DNS__SET32BIT((r) + 4, v)\n+#define DNS_RR_SET_LEN(r)               DNS__SET16BIT((r) + 8, v)\n+\n+#endif /* ARES__DNS_H */"}, {"sha": "2af6b2ac40b2fae976dcfb8249d06c47be13d028", "filename": "src/rt/libuv/src/ares/ares_expand_name.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_expand_name.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_expand_name.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_expand_name.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,193 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n+#  include <arpa/nameser_compat.h>\n+#endif\n+\n+#include <stdlib.h>\n+#include \"ares.h\"\n+#include \"ares_private.h\" /* for the memdebug */\n+\n+static int name_length(const unsigned char *encoded, const unsigned char *abuf,\n+                       int alen);\n+\n+/* Expand an RFC1035-encoded domain name given by encoded.  The\n+ * containing message is given by abuf and alen.  The result given by\n+ * *s, which is set to a NUL-terminated allocated buffer.  *enclen is\n+ * set to the length of the encoded name (not the length of the\n+ * expanded name; the goal is to tell the caller how many bytes to\n+ * move forward to get past the encoded name).\n+ *\n+ * In the simple case, an encoded name is a series of labels, each\n+ * composed of a one-byte length (limited to values between 0 and 63\n+ * inclusive) followed by the label contents.  The name is terminated\n+ * by a zero-length label.\n+ *\n+ * In the more complicated case, a label may be terminated by an\n+ * indirection pointer, specified by two bytes with the high bits of\n+ * the first byte (corresponding to INDIR_MASK) set to 11.  With the\n+ * two high bits of the first byte stripped off, the indirection\n+ * pointer gives an offset from the beginning of the containing\n+ * message with more labels to decode.  Indirection can happen an\n+ * arbitrary number of times, so we have to detect loops.\n+ *\n+ * Since the expanded name uses '.' as a label separator, we use\n+ * backslashes to escape periods or backslashes in the expanded name.\n+ */\n+\n+int ares_expand_name(const unsigned char *encoded, const unsigned char *abuf,\n+                     int alen, char **s, long *enclen)\n+{\n+  int len, indir = 0;\n+  char *q;\n+  const unsigned char *p;\n+  union {\n+    ssize_t sig;\n+     size_t uns;\n+  } nlen;\n+\n+  nlen.sig = name_length(encoded, abuf, alen);\n+  if (nlen.sig < 0)\n+    return ARES_EBADNAME;\n+\n+  *s = malloc(nlen.uns + 1);\n+  if (!*s)\n+    return ARES_ENOMEM;\n+  q = *s;\n+\n+  if (nlen.uns == 0) {\n+    /* RFC2181 says this should be \".\": the root of the DNS tree.\n+     * Since this function strips trailing dots though, it becomes \"\"\n+     */\n+    q[0] = '\\0';\n+    *enclen = 1;  /* the caller should move one byte to get past this */\n+    return ARES_SUCCESS;\n+  }\n+\n+  /* No error-checking necessary; it was all done by name_length(). */\n+  p = encoded;\n+  while (*p)\n+    {\n+      if ((*p & INDIR_MASK) == INDIR_MASK)\n+        {\n+          if (!indir)\n+            {\n+              *enclen = p + 2 - encoded;\n+              indir = 1;\n+            }\n+          p = abuf + ((*p & ~INDIR_MASK) << 8 | *(p + 1));\n+        }\n+      else\n+        {\n+          len = *p;\n+          p++;\n+          while (len--)\n+            {\n+              if (*p == '.' || *p == '\\\\')\n+                *q++ = '\\\\';\n+              *q++ = *p;\n+              p++;\n+            }\n+          *q++ = '.';\n+        }\n+    }\n+  if (!indir)\n+    *enclen = p + 1 - encoded;\n+\n+  /* Nuke the trailing period if we wrote one. */\n+  if (q > *s)\n+    *(q - 1) = 0;\n+  else\n+    *q = 0; /* zero terminate */\n+\n+  return ARES_SUCCESS;\n+}\n+\n+/* Return the length of the expansion of an encoded domain name, or\n+ * -1 if the encoding is invalid.\n+ */\n+static int name_length(const unsigned char *encoded, const unsigned char *abuf,\n+                       int alen)\n+{\n+  int n = 0, offset, indir = 0;\n+\n+  /* Allow the caller to pass us abuf + alen and have us check for it. */\n+  if (encoded == abuf + alen)\n+    return -1;\n+\n+  while (*encoded)\n+    {\n+      if ((*encoded & INDIR_MASK) == INDIR_MASK)\n+        {\n+          /* Check the offset and go there. */\n+          if (encoded + 1 >= abuf + alen)\n+            return -1;\n+          offset = (*encoded & ~INDIR_MASK) << 8 | *(encoded + 1);\n+          if (offset >= alen)\n+            return -1;\n+          encoded = abuf + offset;\n+\n+          /* If we've seen more indirects than the message length,\n+           * then there's a loop.\n+           */\n+          if (++indir > alen)\n+            return -1;\n+        }\n+      else\n+        {\n+          offset = *encoded;\n+          if (encoded + offset + 1 >= abuf + alen)\n+            return -1;\n+          encoded++;\n+          while (offset--)\n+            {\n+              n += (*encoded == '.' || *encoded == '\\\\') ? 2 : 1;\n+              encoded++;\n+            }\n+          n++;\n+        }\n+    }\n+\n+  /* If there were any labels at all, then the number of dots is one\n+   * less than the number of labels, so subtract one.\n+   */\n+  return (n) ? n - 1 : n;\n+}\n+\n+/* Like ares_expand_name but returns EBADRESP in case of invalid input. */\n+int ares__expand_name_for_response(const unsigned char *encoded,\n+                                   const unsigned char *abuf, int alen,\n+                                   char **s, long *enclen)\n+{\n+  int status = ares_expand_name(encoded, abuf, alen, s, enclen);\n+  if (status == ARES_EBADNAME)\n+    status = ARES_EBADRESP;\n+  return status;\n+}"}, {"sha": "f24cccf6470d17391c07e31635dc78588fdee1f7", "filename": "src/rt/libuv/src/ares/ares_expand_string.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_expand_string.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_expand_string.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_expand_string.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,75 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+\n+#include <string.h>\n+#include <stdlib.h>\n+#include \"ares.h\"\n+#include \"ares_private.h\" /* for the memdebug */\n+\n+/* Simply decodes a length-encoded character string. The first byte of the\n+ * input is the length of the string to be returned and the bytes thereafter\n+ * are the characters of the string. The returned result will be NULL\n+ * terminated.\n+ */\n+int ares_expand_string(const unsigned char *encoded,\n+                       const unsigned char *abuf,\n+                       int alen,\n+                       unsigned char **s,\n+                       long *enclen)\n+{\n+  unsigned char *q;\n+  union {\n+    ssize_t sig;\n+     size_t uns;\n+  } elen;\n+\n+  if (encoded == abuf+alen)\n+    return ARES_EBADSTR;\n+\n+  elen.uns = *encoded;\n+  if (encoded+elen.sig+1 > abuf+alen)\n+    return ARES_EBADSTR;\n+\n+  encoded++;\n+\n+  *s = malloc(elen.uns+1);\n+  if (*s == NULL)\n+    return ARES_ENOMEM;\n+  q = *s;\n+  strncpy((char *)q, (char *)encoded, elen.uns);\n+  q[elen.uns] = '\\0';\n+\n+  *s = q;\n+\n+  *enclen = (long)(elen.sig+1);\n+\n+  return ARES_SUCCESS;\n+}\n+"}, {"sha": "b57be9287bb53fe78774e6b0f9a956892823c358", "filename": "src/rt/libuv/src/ares/ares_fds.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_fds.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_fds.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_fds.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,62 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+\n+#include \"ares.h\"\n+#include \"ares_private.h\"\n+\n+int ares_fds(ares_channel channel, fd_set *read_fds, fd_set *write_fds)\n+{\n+  struct server_state *server;\n+  ares_socket_t nfds;\n+  int i;\n+\n+  /* Are there any active queries? */\n+  int active_queries = !ares__is_list_empty(&(channel->all_queries));\n+\n+  nfds = 0;\n+  for (i = 0; i < channel->nservers; i++)\n+    {\n+      server = &channel->servers[i];\n+      /* We only need to register interest in UDP sockets if we have\n+       * outstanding queries.\n+       */\n+      if (active_queries && server->udp_socket != ARES_SOCKET_BAD)\n+        {\n+          FD_SET(server->udp_socket, read_fds);\n+          if (server->udp_socket >= nfds)\n+            nfds = server->udp_socket + 1;\n+        }\n+      /* We always register for TCP events, because we want to know\n+       * when the other side closes the connection, so we don't waste\n+       * time trying to use a broken connection.\n+       */\n+      if (server->tcp_socket != ARES_SOCKET_BAD)\n+       {\n+         FD_SET(server->tcp_socket, read_fds);\n+         if (server->qhead)\n+           FD_SET(server->tcp_socket, write_fds);\n+         if (server->tcp_socket >= nfds)\n+           nfds = server->tcp_socket + 1;\n+\t}\n+    }\n+  return (int)nfds;\n+}"}, {"sha": "b124560d86a1b7522e0de2c7cb59964f1ce16982", "filename": "src/rt/libuv/src/ares/ares_free_hostent.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_free_hostent.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_free_hostent.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_free_hostent.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,39 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+#include <stdlib.h>\n+\n+#ifdef HAVE_NETDB_H\n+#include <netdb.h>\n+#endif\n+\n+#include \"ares.h\"\n+#include \"ares_private.h\" /* for memdebug */\n+\n+void ares_free_hostent(struct hostent *host)\n+{\n+  char **p;\n+\n+  free((char *)(host->h_name));\n+  for (p = host->h_aliases; *p; p++)\n+    free(*p);\n+  free(host->h_aliases);\n+  free(host->h_addr_list[0]); /* no matter if there is one or many entries,\n+                                 there is only one malloc for all of them */\n+  free(host->h_addr_list);\n+  free(host);\n+}"}, {"sha": "e0545c1d1af076b7321f659111d6cbe3dc7355a9", "filename": "src/rt/libuv/src/ares/ares_free_string.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_free_string.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_free_string.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_free_string.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,25 @@\n+\n+/* Copyright 2000 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+#include <stdlib.h>\n+#include \"ares.h\"\n+#include \"ares_private.h\"\n+\n+void ares_free_string(void *str)\n+{\n+  free(str);\n+}"}, {"sha": "0de2cf249f05f9f7ee6a38cb0ef9f5a73a0f9bea", "filename": "src/rt/libuv/src/ares/ares_gethostbyaddr.c", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_gethostbyaddr.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_gethostbyaddr.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_gethostbyaddr.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,292 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_NETDB_H\n+#  include <netdb.h>\n+#endif\n+#ifdef HAVE_ARPA_INET_H\n+#  include <arpa/inet.h>\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n+#  include <arpa/nameser_compat.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"ares.h\"\n+#include \"inet_net_pton.h\"\n+#include \"ares_private.h\"\n+\n+#ifdef WATT32\n+#undef WIN32\n+#endif\n+\n+struct addr_query {\n+  /* Arguments passed to ares_gethostbyaddr() */\n+  ares_channel channel;\n+  struct ares_addr addr;\n+  ares_host_callback callback;\n+  void *arg;\n+\n+  const char *remaining_lookups;\n+  int timeouts;\n+};\n+\n+static void next_lookup(struct addr_query *aquery);\n+static void addr_callback(void *arg, int status, int timeouts,\n+                          unsigned char *abuf, int alen);\n+static void end_aquery(struct addr_query *aquery, int status,\n+                       struct hostent *host);\n+static int file_lookup(struct ares_addr *addr, struct hostent **host);\n+static void ptr_rr_name(char *name, const struct ares_addr *addr);\n+\n+void ares_gethostbyaddr(ares_channel channel, const void *addr, int addrlen,\n+                        int family, ares_host_callback callback, void *arg)\n+{\n+  struct addr_query *aquery;\n+\n+  if (family != AF_INET && family != AF_INET6)\n+    {\n+      callback(arg, ARES_ENOTIMP, 0, NULL);\n+      return;\n+    }\n+\n+  if ((family == AF_INET && addrlen != sizeof(aquery->addr.addrV4)) ||\n+      (family == AF_INET6 && addrlen != sizeof(aquery->addr.addrV6)))\n+    {\n+      callback(arg, ARES_ENOTIMP, 0, NULL);\n+      return;\n+    }\n+\n+  aquery = malloc(sizeof(struct addr_query));\n+  if (!aquery)\n+    {\n+      callback(arg, ARES_ENOMEM, 0, NULL);\n+      return;\n+    }\n+  aquery->channel = channel;\n+  if (family == AF_INET)\n+    memcpy(&aquery->addr.addrV4, addr, sizeof(aquery->addr.addrV4));\n+  else\n+    memcpy(&aquery->addr.addrV6, addr, sizeof(aquery->addr.addrV6));\n+  aquery->addr.family = family;\n+  aquery->callback = callback;\n+  aquery->arg = arg;\n+  aquery->remaining_lookups = channel->lookups;\n+  aquery->timeouts = 0;\n+\n+  next_lookup(aquery);\n+}\n+\n+static void next_lookup(struct addr_query *aquery)\n+{\n+  const char *p;\n+  char name[128];\n+  int status;\n+  struct hostent *host;\n+\n+  for (p = aquery->remaining_lookups; *p; p++)\n+    {\n+      switch (*p)\n+        {\n+        case 'b':\n+          ptr_rr_name(name, &aquery->addr);\n+          aquery->remaining_lookups = p + 1;\n+          ares_query(aquery->channel, name, C_IN, T_PTR, addr_callback,\n+                     aquery);\n+          return;\n+        case 'f':\n+          status = file_lookup(&aquery->addr, &host);\n+\n+          /* this status check below previously checked for !ARES_ENOTFOUND,\n+             but we should not assume that this single error code is the one\n+             that can occur, as that is in fact no longer the case */\n+          if (status == ARES_SUCCESS)\n+            {\n+              end_aquery(aquery, status, host);\n+              return;\n+            }\n+          break;\n+        }\n+    }\n+  end_aquery(aquery, ARES_ENOTFOUND, NULL);\n+}\n+\n+static void addr_callback(void *arg, int status, int timeouts,\n+                          unsigned char *abuf, int alen)\n+{\n+  struct addr_query *aquery = (struct addr_query *) arg;\n+  struct hostent *host;\n+  size_t addrlen;\n+\n+  aquery->timeouts += timeouts;\n+  if (status == ARES_SUCCESS)\n+    {\n+      if (aquery->addr.family == AF_INET)\n+        {\n+          addrlen = sizeof(aquery->addr.addrV4);\n+          status = ares_parse_ptr_reply(abuf, alen, &aquery->addr.addrV4,\n+                                        (int)addrlen, AF_INET, &host);\n+        }\n+      else\n+        {\n+          addrlen = sizeof(aquery->addr.addrV6);\n+          status = ares_parse_ptr_reply(abuf, alen, &aquery->addr.addrV6,\n+                                        (int)addrlen, AF_INET6, &host);\n+        }\n+      end_aquery(aquery, status, host);\n+    }\n+  else if (status == ARES_EDESTRUCTION)\n+    end_aquery(aquery, status, NULL);\n+  else\n+    next_lookup(aquery);\n+}\n+\n+static void end_aquery(struct addr_query *aquery, int status,\n+                       struct hostent *host)\n+{\n+  aquery->callback(aquery->arg, status, aquery->timeouts, host);\n+  if (host)\n+    ares_free_hostent(host);\n+  free(aquery);\n+}\n+\n+static int file_lookup(struct ares_addr *addr, struct hostent **host)\n+{\n+  FILE *fp;\n+  int status;\n+  int error;\n+\n+#ifdef WIN32\n+  char PATH_HOSTS[MAX_PATH];\n+  if (IS_NT()) {\n+    char tmp[MAX_PATH];\n+    HKEY hkeyHosts;\n+\n+    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY, 0, KEY_READ,\n+                     &hkeyHosts) == ERROR_SUCCESS)\n+    {\n+      DWORD dwLength = MAX_PATH;\n+      RegQueryValueEx(hkeyHosts, DATABASEPATH, NULL, NULL, (LPBYTE)tmp,\n+                      &dwLength);\n+      ExpandEnvironmentStrings(tmp, PATH_HOSTS, MAX_PATH);\n+      RegCloseKey(hkeyHosts);\n+    }\n+  }\n+  else\n+    GetWindowsDirectory(PATH_HOSTS, MAX_PATH);\n+\n+  strcat(PATH_HOSTS, WIN_PATH_HOSTS);\n+\n+#elif defined(WATT32)\n+  extern const char *_w32_GetHostsFile (void);\n+  const char *PATH_HOSTS = _w32_GetHostsFile();\n+\n+  if (!PATH_HOSTS)\n+    return ARES_ENOTFOUND;\n+#endif\n+\n+  fp = fopen(PATH_HOSTS, \"r\");\n+  if (!fp)\n+    {\n+      error = ERRNO;\n+      switch(error)\n+        {\n+        case ENOENT:\n+        case ESRCH:\n+          return ARES_ENOTFOUND;\n+        default:\n+          DEBUGF(fprintf(stderr, \"fopen() failed with error: %d %s\\n\",\n+                         error, strerror(error)));\n+          DEBUGF(fprintf(stderr, \"Error opening file: %s\\n\",\n+                         PATH_HOSTS));\n+          *host = NULL;\n+          return ARES_EFILE;\n+        }\n+    }\n+  while ((status = ares__get_hostent(fp, addr->family, host)) == ARES_SUCCESS)\n+    {\n+      if (addr->family != (*host)->h_addrtype)\n+        {\n+          ares_free_hostent(*host);\n+          continue;\n+        }\n+      if (addr->family == AF_INET)\n+        {\n+          if (memcmp((*host)->h_addr, &addr->addrV4,\n+                     sizeof(addr->addrV4)) == 0)\n+            break;\n+        }\n+      else if (addr->family == AF_INET6)\n+        {\n+          if (memcmp((*host)->h_addr, &addr->addrV6,\n+                     sizeof(addr->addrV6)) == 0)\n+            break;\n+        }\n+      ares_free_hostent(*host);\n+    }\n+  fclose(fp);\n+  if (status == ARES_EOF)\n+    status = ARES_ENOTFOUND;\n+  if (status != ARES_SUCCESS)\n+    *host = NULL;\n+  return status;\n+}\n+\n+static void ptr_rr_name(char *name, const struct ares_addr *addr)\n+{\n+  if (addr->family == AF_INET)\n+    {\n+       unsigned long laddr = ntohl(addr->addrV4.s_addr);\n+       unsigned long a1 = (laddr >> 24UL) & 0xFFUL;\n+       unsigned long a2 = (laddr >> 16UL) & 0xFFUL;\n+       unsigned long a3 = (laddr >>  8UL) & 0xFFUL;\n+       unsigned long a4 = laddr & 0xFFUL;\n+       sprintf(name, \"%lu.%lu.%lu.%lu.in-addr.arpa\", a4, a3, a2, a1);\n+    }\n+  else\n+    {\n+       unsigned char *bytes = (unsigned char *)&addr->addrV6;\n+       /* There are too many arguments to do this in one line using\n+        * minimally C89-compliant compilers */\n+       sprintf(name,\n+                \"%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.\",\n+                bytes[15]&0xf, bytes[15] >> 4, bytes[14]&0xf, bytes[14] >> 4,\n+                bytes[13]&0xf, bytes[13] >> 4, bytes[12]&0xf, bytes[12] >> 4,\n+                bytes[11]&0xf, bytes[11] >> 4, bytes[10]&0xf, bytes[10] >> 4,\n+                bytes[9]&0xf, bytes[9] >> 4, bytes[8]&0xf, bytes[8] >> 4);\n+       sprintf(name+strlen(name),\n+                \"%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.ip6.arpa\",\n+                bytes[7]&0xf, bytes[7] >> 4, bytes[6]&0xf, bytes[6] >> 4,\n+                bytes[5]&0xf, bytes[5] >> 4, bytes[4]&0xf, bytes[4] >> 4,\n+                bytes[3]&0xf, bytes[3] >> 4, bytes[2]&0xf, bytes[2] >> 4,\n+                bytes[1]&0xf, bytes[1] >> 4, bytes[0]&0xf, bytes[0] >> 4);\n+    }\n+}"}, {"sha": "4469ffee23331f8e11b56d4ad93e88592e551279", "filename": "src/rt/libuv/src/ares/ares_gethostbyname.c", "status": "added", "additions": 515, "deletions": 0, "changes": 515, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_gethostbyname.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_gethostbyname.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_gethostbyname.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,515 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_NETDB_H\n+#  include <netdb.h>\n+#endif\n+#ifdef HAVE_ARPA_INET_H\n+#  include <arpa/inet.h>\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n+#  include <arpa/nameser_compat.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <ctype.h>\n+#ifdef HAVE_STRINGS_H\n+#include <strings.h>\n+#endif\n+\n+#include \"ares.h\"\n+#include \"inet_net_pton.h\"\n+#include \"bitncmp.h\"\n+#include \"ares_private.h\"\n+\n+#ifdef WATT32\n+#undef WIN32\n+#endif\n+\n+struct host_query {\n+  /* Arguments passed to ares_gethostbyname() */\n+  ares_channel channel;\n+  char *name;\n+  ares_host_callback callback;\n+  void *arg;\n+  int sent_family; /* this family is what was is being used */\n+  int want_family; /* this family is what is asked for in the API */\n+  const char *remaining_lookups;\n+  int timeouts;\n+};\n+\n+static void next_lookup(struct host_query *hquery, int status_code);\n+static void host_callback(void *arg, int status, int timeouts,\n+                          unsigned char *abuf, int alen);\n+static void end_hquery(struct host_query *hquery, int status,\n+                       struct hostent *host);\n+static int fake_hostent(const char *name, int family,\n+                        ares_host_callback callback, void *arg);\n+static int file_lookup(const char *name, int family, struct hostent **host);\n+static void sort_addresses(struct hostent *host,\n+                           const struct apattern *sortlist, int nsort);\n+static void sort6_addresses(struct hostent *host,\n+                            const struct apattern *sortlist, int nsort);\n+static int get_address_index(const struct in_addr *addr,\n+                             const struct apattern *sortlist, int nsort);\n+static int get6_address_index(const struct ares_in6_addr *addr,\n+                              const struct apattern *sortlist, int nsort);\n+\n+void ares_gethostbyname(ares_channel channel, const char *name, int family,\n+                        ares_host_callback callback, void *arg)\n+{\n+  struct host_query *hquery;\n+\n+  /* Right now we only know how to look up Internet addresses - and unspec\n+     means try both basically. */\n+  switch (family) {\n+  case AF_INET:\n+  case AF_INET6:\n+  case AF_UNSPEC:\n+    break;\n+  default:\n+    callback(arg, ARES_ENOTIMP, 0, NULL);\n+    return;\n+  }\n+\n+  if (fake_hostent(name, family, callback, arg))\n+    return;\n+\n+  /* Allocate and fill in the host query structure. */\n+  hquery = malloc(sizeof(struct host_query));\n+  if (!hquery)\n+    {\n+      callback(arg, ARES_ENOMEM, 0, NULL);\n+      return;\n+    }\n+  hquery->channel = channel;\n+  hquery->name = strdup(name);\n+  hquery->want_family = family;\n+  hquery->sent_family = -1; /* nothing is sent yet */\n+  if (!hquery->name) {\n+    free(hquery);\n+    callback(arg, ARES_ENOMEM, 0, NULL);\n+    return;\n+  }\n+  hquery->callback = callback;\n+  hquery->arg = arg;\n+  hquery->remaining_lookups = channel->lookups;\n+  hquery->timeouts = 0;\n+\n+  /* Start performing lookups according to channel->lookups. */\n+  next_lookup(hquery, ARES_ECONNREFUSED /* initial error code */);\n+}\n+\n+static void next_lookup(struct host_query *hquery, int status_code)\n+{\n+  const char *p;\n+  struct hostent *host;\n+  int status = status_code;\n+\n+  for (p = hquery->remaining_lookups; *p; p++)\n+    {\n+      switch (*p)\n+        {\n+        case 'b':\n+          /* DNS lookup */\n+          hquery->remaining_lookups = p + 1;\n+          if ((hquery->want_family == AF_INET6) ||\n+              (hquery->want_family == AF_UNSPEC)) {\n+            /* if inet6 or unspec, start out with AAAA */\n+            hquery->sent_family = AF_INET6;\n+            ares_search(hquery->channel, hquery->name, C_IN, T_AAAA,\n+                        host_callback, hquery);\n+          }\n+          else {\n+            hquery->sent_family = AF_INET;\n+            ares_search(hquery->channel, hquery->name, C_IN, T_A,\n+                        host_callback, hquery);\n+          }\n+          return;\n+\n+        case 'f':\n+          /* Host file lookup */\n+          status = file_lookup(hquery->name, hquery->want_family, &host);\n+\n+          /* this status check below previously checked for !ARES_ENOTFOUND,\n+             but we should not assume that this single error code is the one\n+             that can occur, as that is in fact no longer the case */\n+          if (status == ARES_SUCCESS)\n+            {\n+              end_hquery(hquery, status, host);\n+              return;\n+            }\n+          status = status_code;   /* Use original status code */\n+          break;\n+        }\n+    }\n+  end_hquery(hquery, status, NULL);\n+}\n+\n+static void host_callback(void *arg, int status, int timeouts,\n+                          unsigned char *abuf, int alen)\n+{\n+  struct host_query *hquery = (struct host_query *) arg;\n+  ares_channel channel = hquery->channel;\n+  struct hostent *host = NULL;\n+\n+  hquery->timeouts += timeouts;\n+  if (status == ARES_SUCCESS)\n+    {\n+      if (hquery->sent_family == AF_INET)\n+        {\n+          status = ares_parse_a_reply(abuf, alen, &host, NULL, NULL);\n+          if (host && channel->nsort)\n+            sort_addresses(host, channel->sortlist, channel->nsort);\n+        }\n+      else if (hquery->sent_family == AF_INET6)\n+        {\n+          status = ares_parse_aaaa_reply(abuf, alen, &host, NULL, NULL);\n+          if (status == ARES_ENODATA || status == ARES_EBADRESP) {\n+            /* The query returned something but either there were no AAAA\n+               records (e.g. just CNAME) or the response was malformed.  Try\n+               looking up A instead.  We should possibly limit this\n+               attempt-next logic to AF_UNSPEC lookups only. */\n+            hquery->sent_family = AF_INET;\n+            ares_search(hquery->channel, hquery->name, C_IN, T_A,\n+                        host_callback, hquery);\n+            return;\n+          }\n+          if (host && channel->nsort)\n+            sort6_addresses(host, channel->sortlist, channel->nsort);\n+        }\n+      end_hquery(hquery, status, host);\n+    }\n+  else if ((status == ARES_ENODATA || status == ARES_EBADRESP ||\n+            status == ARES_ETIMEOUT) && hquery->sent_family == AF_INET6)\n+    {\n+      /* The AAAA query yielded no useful result.  Now look up an A instead.\n+         We should possibly limit this attempt-next logic to AF_UNSPEC lookups\n+         only. */\n+      hquery->sent_family = AF_INET;\n+      ares_search(hquery->channel, hquery->name, C_IN, T_A, host_callback,\n+                  hquery);\n+    }\n+  else if (status == ARES_EDESTRUCTION)\n+    end_hquery(hquery, status, NULL);\n+  else\n+    next_lookup(hquery, status);\n+}\n+\n+static void end_hquery(struct host_query *hquery, int status,\n+                       struct hostent *host)\n+{\n+  hquery->callback(hquery->arg, status, hquery->timeouts, host);\n+  if (host)\n+    ares_free_hostent(host);\n+  free(hquery->name);\n+  free(hquery);\n+}\n+\n+/* If the name looks like an IP address, fake up a host entry, end the\n+ * query immediately, and return true.  Otherwise return false.\n+ */\n+static int fake_hostent(const char *name, int family,\n+                        ares_host_callback callback, void *arg)\n+{\n+  struct hostent hostent;\n+  char *aliases[1] = { NULL };\n+  char *addrs[2];\n+  int result = 0;\n+  struct in_addr in;\n+  struct ares_in6_addr in6;\n+\n+  if (family == AF_INET || family == AF_INET6)\n+    {\n+      /* It only looks like an IP address if it's all numbers and dots. */\n+      int numdots = 0, valid = 1;\n+      const char *p;\n+      for (p = name; *p; p++)\n+        {\n+          if (!ISDIGIT(*p) && *p != '.') {\n+            valid = 0;\n+            break;\n+          } else if (*p == '.') {\n+            numdots++;\n+          }\n+        }\n+\n+      /* if we don't have 3 dots, it is illegal\n+       * (although inet_addr doesn't think so).\n+       */\n+      if (numdots != 3 || !valid)\n+        result = 0;\n+      else\n+        result = ((in.s_addr = inet_addr(name)) == INADDR_NONE ? 0 : 1);\n+\n+      if (result)\n+        family = AF_INET;\n+    }\n+  if (family == AF_INET6)\n+    result = (ares_inet_pton(AF_INET6, name, &in6) < 1 ? 0 : 1);\n+\n+  if (!result)\n+    return 0;\n+\n+  if (family == AF_INET)\n+    {\n+      hostent.h_length = (int)sizeof(struct in_addr);\n+      addrs[0] = (char *)&in;\n+    }\n+  else if (family == AF_INET6)\n+    {\n+      hostent.h_length = (int)sizeof(struct ares_in6_addr);\n+      addrs[0] = (char *)&in6;\n+    }\n+  /* Duplicate the name, to avoid a constness violation. */\n+  hostent.h_name = strdup(name);\n+  if (!hostent.h_name)\n+    {\n+      callback(arg, ARES_ENOMEM, 0, NULL);\n+      return 1;\n+    }\n+\n+  /* Fill in the rest of the host structure and terminate the query. */\n+  addrs[1] = NULL;\n+  hostent.h_aliases = aliases;\n+  hostent.h_addrtype = family;\n+  hostent.h_addr_list = addrs;\n+  callback(arg, ARES_SUCCESS, 0, &hostent);\n+\n+  free((char *)(hostent.h_name));\n+  return 1;\n+}\n+\n+/* This is an API method */\n+int ares_gethostbyname_file(ares_channel channel, const char *name,\n+                            int family, struct hostent **host)\n+{\n+  int result;\n+\n+  /* We only take the channel to ensure that ares_init() been called. */\n+  if(channel == NULL)\n+    {\n+      /* Anything will do, really.  This seems fine, and is consistent with\n+         other error cases. */\n+      *host = NULL;\n+      return ARES_ENOTFOUND;\n+    }\n+\n+  /* Just chain to the internal implementation we use here; it's exactly\n+   * what we want.\n+   */\n+  result = file_lookup(name, family, host);\n+  if(result != ARES_SUCCESS)\n+    {\n+      /* We guarantee a NULL hostent on failure. */\n+      *host = NULL;\n+    }\n+  return result;\n+}\n+\n+static int file_lookup(const char *name, int family, struct hostent **host)\n+{\n+  FILE *fp;\n+  char **alias;\n+  int status;\n+  int error;\n+\n+#ifdef WIN32\n+  char PATH_HOSTS[MAX_PATH];\n+  if (IS_NT()) {\n+    char tmp[MAX_PATH];\n+    HKEY hkeyHosts;\n+\n+    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY, 0, KEY_READ,\n+                     &hkeyHosts) == ERROR_SUCCESS)\n+    {\n+      DWORD dwLength = MAX_PATH;\n+      RegQueryValueEx(hkeyHosts, DATABASEPATH, NULL, NULL, (LPBYTE)tmp,\n+                      &dwLength);\n+      ExpandEnvironmentStrings(tmp, PATH_HOSTS, MAX_PATH);\n+      RegCloseKey(hkeyHosts);\n+    }\n+  }\n+  else\n+    GetWindowsDirectory(PATH_HOSTS, MAX_PATH);\n+\n+  strcat(PATH_HOSTS, WIN_PATH_HOSTS);\n+\n+#elif defined(WATT32)\n+  extern const char *_w32_GetHostsFile (void);\n+  const char *PATH_HOSTS = _w32_GetHostsFile();\n+\n+  if (!PATH_HOSTS)\n+    return ARES_ENOTFOUND;\n+#endif\n+\n+  fp = fopen(PATH_HOSTS, \"r\");\n+  if (!fp)\n+    {\n+      error = ERRNO;\n+      switch(error)\n+        {\n+        case ENOENT:\n+        case ESRCH:\n+          return ARES_ENOTFOUND;\n+        default:\n+          DEBUGF(fprintf(stderr, \"fopen() failed with error: %d %s\\n\",\n+                         error, strerror(error)));\n+          DEBUGF(fprintf(stderr, \"Error opening file: %s\\n\",\n+                         PATH_HOSTS));\n+          *host = NULL;\n+          return ARES_EFILE;\n+        }\n+    }\n+  while ((status = ares__get_hostent(fp, family, host)) == ARES_SUCCESS)\n+    {\n+      if (strcasecmp((*host)->h_name, name) == 0)\n+        break;\n+      for (alias = (*host)->h_aliases; *alias; alias++)\n+        {\n+          if (strcasecmp(*alias, name) == 0)\n+            break;\n+        }\n+      if (*alias)\n+        break;\n+      ares_free_hostent(*host);\n+    }\n+  fclose(fp);\n+  if (status == ARES_EOF)\n+    status = ARES_ENOTFOUND;\n+  if (status != ARES_SUCCESS)\n+    *host = NULL;\n+  return status;\n+}\n+\n+static void sort_addresses(struct hostent *host,\n+                           const struct apattern *sortlist, int nsort)\n+{\n+  struct in_addr a1, a2;\n+  int i1, i2, ind1, ind2;\n+\n+  /* This is a simple insertion sort, not optimized at all.  i1 walks\n+   * through the address list, with the loop invariant that everything\n+   * to the left of i1 is sorted.  In the loop body, the value at i1 is moved\n+   * back through the list (via i2) until it is in sorted order.\n+   */\n+  for (i1 = 0; host->h_addr_list[i1]; i1++)\n+    {\n+      memcpy(&a1, host->h_addr_list[i1], sizeof(struct in_addr));\n+      ind1 = get_address_index(&a1, sortlist, nsort);\n+      for (i2 = i1 - 1; i2 >= 0; i2--)\n+        {\n+          memcpy(&a2, host->h_addr_list[i2], sizeof(struct in_addr));\n+          ind2 = get_address_index(&a2, sortlist, nsort);\n+          if (ind2 <= ind1)\n+            break;\n+          memcpy(host->h_addr_list[i2 + 1], &a2, sizeof(struct in_addr));\n+        }\n+      memcpy(host->h_addr_list[i2 + 1], &a1, sizeof(struct in_addr));\n+    }\n+}\n+\n+/* Find the first entry in sortlist which matches addr.  Return nsort\n+ * if none of them match.\n+ */\n+static int get_address_index(const struct in_addr *addr,\n+                             const struct apattern *sortlist,\n+                             int nsort)\n+{\n+  int i;\n+\n+  for (i = 0; i < nsort; i++)\n+    {\n+      if (sortlist[i].family != AF_INET)\n+        continue;\n+      if (sortlist[i].type == PATTERN_MASK)\n+        {\n+          if ((addr->s_addr & sortlist[i].mask.addr4.s_addr)\n+              == sortlist[i].addrV4.s_addr)\n+            break;\n+        }\n+      else\n+        {\n+          if (!ares_bitncmp(&addr->s_addr, &sortlist[i].addrV4.s_addr,\n+                            sortlist[i].mask.bits))\n+            break;\n+        }\n+    }\n+  return i;\n+}\n+\n+static void sort6_addresses(struct hostent *host,\n+                            const struct apattern *sortlist, int nsort)\n+{\n+  struct ares_in6_addr a1, a2;\n+  int i1, i2, ind1, ind2;\n+\n+  /* This is a simple insertion sort, not optimized at all.  i1 walks\n+   * through the address list, with the loop invariant that everything\n+   * to the left of i1 is sorted.  In the loop body, the value at i1 is moved\n+   * back through the list (via i2) until it is in sorted order.\n+   */\n+  for (i1 = 0; host->h_addr_list[i1]; i1++)\n+    {\n+      memcpy(&a1, host->h_addr_list[i1], sizeof(struct ares_in6_addr));\n+      ind1 = get6_address_index(&a1, sortlist, nsort);\n+      for (i2 = i1 - 1; i2 >= 0; i2--)\n+        {\n+          memcpy(&a2, host->h_addr_list[i2], sizeof(struct ares_in6_addr));\n+          ind2 = get6_address_index(&a2, sortlist, nsort);\n+          if (ind2 <= ind1)\n+            break;\n+          memcpy(host->h_addr_list[i2 + 1], &a2, sizeof(struct ares_in6_addr));\n+        }\n+      memcpy(host->h_addr_list[i2 + 1], &a1, sizeof(struct ares_in6_addr));\n+    }\n+}\n+\n+/* Find the first entry in sortlist which matches addr.  Return nsort\n+ * if none of them match.\n+ */\n+static int get6_address_index(const struct ares_in6_addr *addr,\n+                              const struct apattern *sortlist,\n+                              int nsort)\n+{\n+  int i;\n+\n+  for (i = 0; i < nsort; i++)\n+    {\n+      if (sortlist[i].family != AF_INET6)\n+        continue;\n+        if (!ares_bitncmp(addr,\n+                          &sortlist[i].addrV6,\n+                          sortlist[i].mask.bits))\n+          break;\n+    }\n+  return i;\n+}"}, {"sha": "b6236862ed0c20a61bf92567ee5da1d45a39432e", "filename": "src/rt/libuv/src/ares/ares_getnameinfo.c", "status": "added", "additions": 426, "deletions": 0, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getnameinfo.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getnameinfo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getnameinfo.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,426 @@\n+\n+/* Copyright 2005 by Dominick Meglio\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_GETSERVBYPORT_R\n+#  if !defined(GETSERVBYPORT_R_ARGS) || \\\n+     (GETSERVBYPORT_R_ARGS < 4) || (GETSERVBYPORT_R_ARGS > 6)\n+#    error \"you MUST specifiy a valid number of arguments for getservbyport_r\"\n+#  endif\n+#endif\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_NETDB_H\n+#  include <netdb.h>\n+#endif\n+#ifdef HAVE_ARPA_INET_H\n+#  include <arpa/inet.h>\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n+#  include <arpa/nameser_compat.h>\n+#endif\n+\n+#ifdef HAVE_NET_IF_H\n+#include <net/if.h>\n+#endif\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"ares.h\"\n+#include \"ares_ipv6.h\"\n+#include \"inet_ntop.h\"\n+#include \"ares_private.h\"\n+\n+struct nameinfo_query {\n+  ares_nameinfo_callback callback;\n+  void *arg;\n+  union {\n+    struct sockaddr_in addr4;\n+    struct sockaddr_in6 addr6;\n+  } addr;\n+  int family;\n+  int flags;\n+  int timeouts;\n+};\n+\n+#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID\n+#define IPBUFSIZ \\\n+        (sizeof(\"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\") + IF_NAMESIZE)\n+#else\n+#define IPBUFSIZ \\\n+        (sizeof(\"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\"))\n+#endif\n+\n+static void nameinfo_callback(void *arg, int status, int timeouts,\n+                              struct hostent *host);\n+static char *lookup_service(unsigned short port, int flags,\n+                            char *buf, size_t buflen);\n+#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID\n+static void append_scopeid(struct sockaddr_in6 *addr6, unsigned int scopeid,\n+                           char *buf, size_t buflen);\n+#endif\n+static char *ares_striendstr(const char *s1, const char *s2);\n+\n+void ares_getnameinfo(ares_channel channel, const struct sockaddr *sa,\n+                      ares_socklen_t salen,\n+                      int flags, ares_nameinfo_callback callback, void *arg)\n+{\n+  struct sockaddr_in *addr = NULL;\n+  struct sockaddr_in6 *addr6 = NULL;\n+  struct nameinfo_query *niquery;\n+  unsigned int port = 0;\n+\n+  /* Validate socket address family and length */\n+  if ((sa->sa_family == AF_INET) &&\n+      (salen == sizeof(struct sockaddr_in)))\n+    {\n+      addr = (struct sockaddr_in *)sa;\n+      port = addr->sin_port;\n+    }\n+  else if ((sa->sa_family == AF_INET6) &&\n+           (salen == sizeof(struct sockaddr_in6)))\n+    {\n+      addr6 = (struct sockaddr_in6 *)sa;\n+      port = addr6->sin6_port;\n+    }\n+  else\n+    {\n+      callback(arg, ARES_ENOTIMP, 0, NULL, NULL);\n+      return;\n+    }\n+\n+  /* If neither, assume they want a host */\n+  if (!(flags & ARES_NI_LOOKUPSERVICE) && !(flags & ARES_NI_LOOKUPHOST))\n+    flags |= ARES_NI_LOOKUPHOST;\n+\n+  /* All they want is a service, no need for DNS */\n+  if ((flags & ARES_NI_LOOKUPSERVICE) && !(flags & ARES_NI_LOOKUPHOST))\n+    {\n+      char buf[33], *service;\n+\n+      service = lookup_service((unsigned short)(port & 0xffff),\n+                               flags, buf, sizeof(buf));\n+      callback(arg, ARES_SUCCESS, 0, NULL, service);\n+      return;\n+    }\n+\n+  /* They want a host lookup */\n+  if ((flags & ARES_NI_LOOKUPHOST))\n+    {\n+     /* A numeric host can be handled without DNS */\n+     if ((flags & ARES_NI_NUMERICHOST))\n+      {\n+        char ipbuf[IPBUFSIZ];\n+        char srvbuf[33];\n+        char *service = NULL;\n+        ipbuf[0] = 0;\n+\n+        /* Specifying not to lookup a host, but then saying a host\n+         * is required has to be illegal.\n+         */\n+        if (flags & ARES_NI_NAMEREQD)\n+          {\n+            callback(arg, ARES_EBADFLAGS, 0, NULL, NULL);\n+            return;\n+          }\n+        if (salen == sizeof(struct sockaddr_in6))\n+          {\n+            ares_inet_ntop(AF_INET6, &addr6->sin6_addr, ipbuf, IPBUFSIZ);\n+            /* If the system supports scope IDs, use it */\n+#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID\n+            append_scopeid(addr6, flags, ipbuf, sizeof(ipbuf));\n+#endif\n+          }\n+        else\n+          {\n+            ares_inet_ntop(AF_INET, &addr->sin_addr, ipbuf, IPBUFSIZ);\n+          }\n+        /* They also want a service */\n+        if (flags & ARES_NI_LOOKUPSERVICE)\n+          service = lookup_service((unsigned short)(port & 0xffff),\n+                                   flags, srvbuf, sizeof(srvbuf));\n+        callback(arg, ARES_SUCCESS, 0, ipbuf, service);\n+        return;\n+      }\n+    /* This is where a DNS lookup becomes necessary */\n+    else\n+      {\n+        niquery = malloc(sizeof(struct nameinfo_query));\n+        if (!niquery)\n+          {\n+            callback(arg, ARES_ENOMEM, 0, NULL, NULL);\n+            return;\n+          }\n+        niquery->callback = callback;\n+        niquery->arg = arg;\n+        niquery->flags = flags;\n+        niquery->timeouts = 0;\n+        if (sa->sa_family == AF_INET)\n+          {\n+            niquery->family = AF_INET;\n+            memcpy(&niquery->addr.addr4, addr, sizeof(addr));\n+            ares_gethostbyaddr(channel, &addr->sin_addr,\n+                               sizeof(struct in_addr), AF_INET,\n+                               nameinfo_callback, niquery);\n+          }\n+        else\n+          {\n+            niquery->family = AF_INET6;\n+            memcpy(&niquery->addr.addr6, addr6, sizeof(addr6));\n+            ares_gethostbyaddr(channel, &addr6->sin6_addr,\n+                               sizeof(struct ares_in6_addr), AF_INET6,\n+                               nameinfo_callback, niquery);\n+          }\n+      }\n+    }\n+}\n+\n+static void nameinfo_callback(void *arg, int status, int timeouts,\n+                              struct hostent *host)\n+{\n+  struct nameinfo_query *niquery = (struct nameinfo_query *) arg;\n+  char srvbuf[33];\n+  char *service = NULL;\n+\n+  niquery->timeouts += timeouts;\n+  if (status == ARES_SUCCESS)\n+    {\n+      /* They want a service too */\n+      if (niquery->flags & ARES_NI_LOOKUPSERVICE)\n+        {\n+          if (niquery->family == AF_INET)\n+            service = lookup_service(niquery->addr.addr4.sin_port,\n+                                     niquery->flags, srvbuf, sizeof(srvbuf));\n+          else\n+            service = lookup_service(niquery->addr.addr6.sin6_port,\n+                                     niquery->flags, srvbuf, sizeof(srvbuf));\n+        }\n+      /* NOFQDN means we have to strip off the domain name portion.  We do\n+         this by determining our own domain name, then searching the string\n+         for this domain name and removing it.\n+       */\n+#ifdef HAVE_GETHOSTNAME\n+      if (niquery->flags & ARES_NI_NOFQDN)\n+        {\n+           char buf[255];\n+           char *domain;\n+           gethostname(buf, 255);\n+           if ((domain = strchr(buf, '.')) != NULL)\n+             {\n+               char *end = ares_striendstr(host->h_name, domain);\n+               if (end)\n+                 *end = 0;\n+             }\n+        }\n+#endif\n+      niquery->callback(niquery->arg, ARES_SUCCESS, niquery->timeouts,\n+                        (char *)(host->h_name),\n+                        service);\n+      free(niquery);\n+      return;\n+    }\n+  /* We couldn't find the host, but it's OK, we can use the IP */\n+  else if (status == ARES_ENOTFOUND && !(niquery->flags & ARES_NI_NAMEREQD))\n+    {\n+      char ipbuf[IPBUFSIZ];\n+      if (niquery->family == AF_INET)\n+        ares_inet_ntop(AF_INET, &niquery->addr.addr4.sin_addr, ipbuf,\n+                       IPBUFSIZ);\n+      else\n+        {\n+          ares_inet_ntop(AF_INET6, &niquery->addr.addr6.sin6_addr, ipbuf,\n+                         IPBUFSIZ);\n+#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID\n+          append_scopeid(&niquery->addr.addr6, niquery->flags, ipbuf,\n+                         sizeof(ipbuf));\n+#endif\n+        }\n+      /* They want a service too */\n+      if (niquery->flags & ARES_NI_LOOKUPSERVICE)\n+        {\n+          if (niquery->family == AF_INET)\n+            service = lookup_service(niquery->addr.addr4.sin_port,\n+                                     niquery->flags, srvbuf, sizeof(srvbuf));\n+          else\n+            service = lookup_service(niquery->addr.addr6.sin6_port,\n+                                     niquery->flags, srvbuf, sizeof(srvbuf));\n+        }\n+      niquery->callback(niquery->arg, ARES_SUCCESS, niquery->timeouts, ipbuf,\n+                        service);\n+      free(niquery);\n+      return;\n+    }\n+  niquery->callback(niquery->arg, status, niquery->timeouts, NULL, NULL);\n+  free(niquery);\n+}\n+\n+static char *lookup_service(unsigned short port, int flags,\n+                            char *buf, size_t buflen)\n+{\n+  const char *proto;\n+  struct servent *sep;\n+#ifdef HAVE_GETSERVBYPORT_R\n+  struct servent se;\n+#endif\n+  char tmpbuf[4096];\n+\n+  if (port)\n+    {\n+      if (flags & ARES_NI_NUMERICSERV)\n+        sep = NULL;\n+      else\n+        {\n+          if (flags & ARES_NI_UDP)\n+            proto = \"udp\";\n+          else if (flags & ARES_NI_SCTP)\n+            proto = \"sctp\";\n+          else if (flags & ARES_NI_DCCP)\n+            proto = \"dccp\";\n+          else\n+            proto = \"tcp\";\n+#ifdef HAVE_GETSERVBYPORT_R\n+          sep = &se;\n+          memset(tmpbuf, 0, sizeof(tmpbuf));\n+#if GETSERVBYPORT_R_ARGS == 6\n+          if (getservbyport_r(port, proto, &se, (void *)tmpbuf,\n+                              sizeof(tmpbuf), &sep) != 0)\n+            sep = NULL;\n+#elif GETSERVBYPORT_R_ARGS == 5\n+          sep = getservbyport_r(port, proto, &se, (void *)tmpbuf,\n+                                sizeof(tmpbuf));\n+#elif GETSERVBYPORT_R_ARGS == 4\n+          if (getservbyport_r(port, proto, &se, (void *)tmpbuf) != 0)\n+            sep = NULL;\n+#else\n+          /* Lets just hope the OS uses TLS! */\n+          sep = getservbyport(port, proto);\n+#endif\n+#else\n+          /* Lets just hope the OS uses TLS! */\n+#if (defined(NETWARE) && !defined(__NOVELL_LIBC__))\n+          sep = getservbyport(port, (char*)proto);\n+#else\n+          sep = getservbyport(port, proto);\n+#endif\n+#endif\n+        }\n+      if (sep && sep->s_name)\n+        /* get service name */\n+        strcpy(tmpbuf, sep->s_name);\n+      else\n+        /* get port as a string */\n+        sprintf(tmpbuf, \"%u\", (unsigned int)ntohs(port));\n+      if (strlen(tmpbuf) < buflen)\n+        /* return it if buffer big enough */\n+        strcpy(buf, tmpbuf);\n+      else\n+        /* avoid reusing previous one */\n+        buf[0] = '\\0';\n+      return buf;\n+    }\n+  buf[0] = '\\0';\n+  return NULL;\n+}\n+\n+#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID\n+static void append_scopeid(struct sockaddr_in6 *addr6, unsigned int flags,\n+                           char *buf, size_t buflen)\n+{\n+#ifdef HAVE_IF_INDEXTONAME\n+  int is_ll, is_mcll;\n+#endif\n+  static const char fmt_u[] = \"%u\";\n+  static const char fmt_lu[] = \"%lu\";\n+  char tmpbuf[IF_NAMESIZE + 2];\n+  size_t bufl;\n+  const char *fmt = (sizeof(addr6->sin6_scope_id) > sizeof(unsigned int))?\n+    fmt_lu:fmt_u;\n+\n+  tmpbuf[0] = '%';\n+\n+#ifdef HAVE_IF_INDEXTONAME\n+  is_ll = IN6_IS_ADDR_LINKLOCAL(&addr6->sin6_addr);\n+  is_mcll = IN6_IS_ADDR_MC_LINKLOCAL(&addr6->sin6_addr);\n+  if ((flags & ARES_NI_NUMERICSCOPE) ||\n+      (!is_ll && !is_mcll))\n+    {\n+       sprintf(&tmpbuf[1], fmt, addr6->sin6_scope_id);\n+    }\n+  else\n+    {\n+      if (if_indextoname(addr6->sin6_scope_id, &tmpbuf[1]) == NULL)\n+        sprintf(&tmpbuf[1], fmt, addr6->sin6_scope_id);\n+    }\n+#else\n+  sprintf(&tmpbuf[1], fmt, addr6->sin6_scope_id);\n+  (void) flags;\n+#endif\n+  tmpbuf[IF_NAMESIZE + 1] = '\\0';\n+  bufl = strlen(buf);\n+\n+  if(bufl + strlen(tmpbuf) < buflen)\n+    /* only append the scopeid string if it fits in the target buffer */\n+    strcpy(&buf[bufl], tmpbuf);\n+}\n+#endif\n+\n+/* Determines if s1 ends with the string in s2 (case-insensitive) */\n+static char *ares_striendstr(const char *s1, const char *s2)\n+{\n+  const char *c1, *c2, *c1_begin;\n+  int lo1, lo2;\n+  size_t s1_len = strlen(s1), s2_len = strlen(s2);\n+\n+  /* If the substr is longer than the full str, it can't match */\n+  if (s2_len > s1_len)\n+    return NULL;\n+\n+  /* Jump to the end of s1 minus the length of s2 */\n+  c1_begin = s1+s1_len-s2_len;\n+  c1 = (const char *)c1_begin;\n+  c2 = s2;\n+  while (c2 < s2+s2_len)\n+    {\n+      lo1 = TOLOWER(*c1);\n+      lo2 = TOLOWER(*c2);\n+      if (lo1 != lo2)\n+        return NULL;\n+      else\n+        {\n+          c1++;\n+          c2++;\n+        }\n+    }\n+  if (c2 == c1 && c2 == NULL)\n+    return (char *)c1_begin;\n+  return NULL;\n+}"}, {"sha": "1e02d086866ed8440bc2e6143f1e4e7f8e8f5afc", "filename": "src/rt/libuv/src/ares/ares_getopt.c", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getopt.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getopt.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getopt.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,122 @@\n+/*\n+ * Original file name getopt.c  Initial import into the c-ares source tree\n+ * on 2007-04-11.  Lifted from version 5.2 of the 'Open Mash' project with\n+ * the modified BSD license, BSD license without the advertising clause.\n+ *\n+ */\n+\n+/*\n+ * getopt.c --\n+ *\n+ *      Standard UNIX getopt function.  Code is from BSD.\n+ *\n+ * Copyright (c) 1987-2001 The Regents of the University of California.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * A. Redistributions of source code must retain the above copyright notice,\n+ *    this list of conditions and the following disclaimer.\n+ * B. Redistributions in binary form must reproduce the above copyright notice,\n+ *    this list of conditions and the following disclaimer in the documentation\n+ *    and/or other materials provided with the distribution.\n+ * C. Neither the names of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from this\n+ *    software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS\n+ * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+/* #if !defined(lint)\n+ * static char sccsid[] = \"@(#)getopt.c 8.2 (Berkeley) 4/2/94\";\n+ * #endif\n+ */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include \"ares_getopt.h\"\n+\n+int   opterr = 1,     /* if error message should be printed */\n+      optind = 1;     /* index into parent argv vector */\n+int   optopt = 0;     /* character checked for validity */\n+static int optreset;  /* reset getopt */\n+char  *optarg;        /* argument associated with option */\n+\n+#define  BADCH   (int)'?'\n+#define  BADARG  (int)':'\n+#define  EMSG    (char *)\"\"\n+\n+/*\n+ * ares_getopt --\n+ *    Parse argc/argv argument vector.\n+ */\n+int\n+ares_getopt(int nargc, char * const nargv[], const char *ostr)\n+{\n+    static char *place = EMSG;                /* option letter processing */\n+    char *oli;                                /* option letter list index */\n+\n+    if (optreset || !*place) {                /* update scanning pointer */\n+        optreset = 0;\n+        if (optind >= nargc || *(place = nargv[optind]) != '-') {\n+            place = EMSG;\n+            return (EOF);\n+        }\n+        if (place[1] && *++place == '-') {    /* found \"--\" */\n+            ++optind;\n+            place = EMSG;\n+            return (EOF);\n+        }\n+    }                                         /* option letter okay? */\n+    if ((optopt = (int)*place++) == (int)':' ||\n+        (oli = strchr(ostr, optopt)) == NULL) {\n+        /*\n+         * if the user didn't specify '-' as an option,\n+         * assume it means EOF.\n+         */\n+        if (optopt == (int)'-')\n+            return (EOF);\n+        if (!*place)\n+            ++optind;\n+        if (opterr && *ostr != ':')\n+            (void)fprintf(stderr,\n+                \"%s: illegal option -- %c\\n\", __FILE__, optopt);\n+        return (BADCH);\n+    }\n+    if (*++oli != ':') {                      /* don't need argument */\n+        optarg = NULL;\n+        if (!*place)\n+            ++optind;\n+    }\n+    else {                                    /* need an argument */\n+        if (*place)                           /* no white space */\n+            optarg = place;\n+        else if (nargc <= ++optind) {         /* no arg */\n+            place = EMSG;\n+            if (*ostr == ':')\n+                return (BADARG);\n+            if (opterr)\n+                (void)fprintf(stderr,\n+                    \"%s: option requires an argument -- %c\\n\",\n+                    __FILE__, optopt);\n+            return (BADCH);\n+        }\n+         else                                 /* white space */\n+            optarg = nargv[optind];\n+        place = EMSG;\n+        ++optind;\n+    }\n+    return (optopt);                          /* dump back option letter */\n+}"}, {"sha": "63acb3b42323d70984caa1dd5762c50d677d5174", "filename": "src/rt/libuv/src/ares/ares_getopt.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getopt.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getopt.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getopt.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,53 @@\n+#ifndef ARES_GETOPT_H\n+#define ARES_GETOPT_H\n+\n+/*\n+ * Copyright (c) 1987-2001 The Regents of the University of California.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * A. Redistributions of source code must retain the above copyright notice,\n+ *    this list of conditions and the following disclaimer.\n+ * B. Redistributions in binary form must reproduce the above copyright notice,\n+ *    this list of conditions and the following disclaimer in the documentation\n+ *    and/or other materials provided with the distribution.\n+ * C. Neither the names of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from this\n+ *    software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS\n+ * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+\n+int ares_getopt(int nargc, char * const nargv[], const char *ostr);\n+\n+#undef optarg\n+#undef optind\n+#undef opterr\n+#undef optopt\n+#undef optreset\n+\n+#define optarg   ares_optarg\n+#define optind   ares_optind\n+#define opterr   ares_opterr\n+#define optopt   ares_optopt\n+#define optreset ares_optreset\n+\n+extern char *optarg;\n+extern int optind;\n+extern int opterr;\n+extern int optopt;\n+\n+#endif /* ARES_GETOPT_H */"}, {"sha": "72e467f2e63758a3bdb4e787c991e03cdf5d714d", "filename": "src/rt/libuv/src/ares/ares_getsock.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getsock.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getsock.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getsock.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,72 @@\n+\n+/* Copyright (C) 2005 - 2010, Daniel Stenberg\n+ *\n+ * Permission to use, copy, modify, and distribute this software and its\n+ * documentation for any purpose and without fee is hereby granted, provided\n+ * that the above copyright notice appear in all copies and that both that\n+ * copyright notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in advertising or\n+ * publicity pertaining to distribution of the software without specific,\n+ * written prior permission.  M.I.T. makes no representations about the\n+ * suitability of this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+\n+#include \"ares.h\"\n+#include \"ares_private.h\"\n+\n+int ares_getsock(ares_channel channel,\n+                 ares_socket_t *socks,\n+                 int numsocks) /* size of the 'socks' array */\n+{\n+  struct server_state *server;\n+  int i;\n+  int sockindex=0;\n+  int bitmap = 0;\n+  unsigned int setbits = 0xffffffff;\n+\n+  /* Are there any active queries? */\n+  int active_queries = !ares__is_list_empty(&(channel->all_queries));\n+\n+  for (i = 0;\n+       (i < channel->nservers) && (sockindex < ARES_GETSOCK_MAXNUM);\n+       i++)\n+    {\n+      server = &channel->servers[i];\n+      /* We only need to register interest in UDP sockets if we have\n+       * outstanding queries.\n+       */\n+      if (active_queries && server->udp_socket != ARES_SOCKET_BAD)\n+        {\n+          if(sockindex >= numsocks)\n+            break;\n+          socks[sockindex] = server->udp_socket;\n+          bitmap |= ARES_GETSOCK_READABLE(setbits, sockindex);\n+          sockindex++;\n+        }\n+      /* We always register for TCP events, because we want to know\n+       * when the other side closes the connection, so we don't waste\n+       * time trying to use a broken connection.\n+       */\n+      if (server->tcp_socket != ARES_SOCKET_BAD)\n+       {\n+         if(sockindex >= numsocks)\n+           break;\n+         socks[sockindex] = server->tcp_socket;\n+         bitmap |= ARES_GETSOCK_READABLE(setbits, sockindex);\n+\n+         if (server->qhead && active_queries)\n+           /* then the tcp socket is also writable! */\n+           bitmap |= ARES_GETSOCK_WRITABLE(setbits, sockindex);\n+\n+         sockindex++;\n+       }\n+    }\n+  return bitmap;\n+}"}, {"sha": "d7954a06b2855c1f702b417bd2bb9208cd4d5ddf", "filename": "src/rt/libuv/src/ares/ares_init.c", "status": "added", "additions": 1665, "deletions": 0, "changes": 1665, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_init.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_init.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_init.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,1665 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ * Copyright (C) 2007-2010 by Daniel Stenberg\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef USE_WINSOCK\n+#include <iphlpapi.h>\n+#endif\n+\n+#ifdef HAVE_SYS_PARAM_H\n+#include <sys/param.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#include <sys/socket.h>\n+#endif\n+\n+#ifdef HAVE_NETINET_IN_H\n+#include <netinet/in.h>\n+#endif\n+\n+#ifdef HAVE_NETDB_H\n+#include <netdb.h>\n+#endif\n+\n+#ifdef HAVE_ARPA_INET_H\n+#include <arpa/inet.h>\n+#endif\n+\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n+#  include <arpa/nameser_compat.h>\n+#endif\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <ctype.h>\n+#include <time.h>\n+#include <errno.h>\n+#include \"ares.h\"\n+#include \"inet_net_pton.h\"\n+#include \"ares_library_init.h\"\n+#include \"ares_nowarn.h\"\n+#include \"ares_private.h\"\n+\n+#ifdef ANDROID\n+#include <sys/system_properties.h>\n+#endif\n+\n+#ifdef WATT32\n+#undef WIN32  /* Redefined in MingW/MSVC headers */\n+#endif\n+\n+static int init_by_options(ares_channel channel, const struct ares_options *options,\n+                           int optmask);\n+static int init_by_environment(ares_channel channel);\n+static int init_by_resolv_conf(ares_channel channel);\n+static int init_by_defaults(ares_channel channel);\n+\n+#ifndef WATT32\n+static int config_nameserver(struct server_state **servers, int *nservers,\n+                             char *str);\n+#endif\n+static int set_search(ares_channel channel, const char *str);\n+static int set_options(ares_channel channel, const char *str);\n+static const char *try_option(const char *p, const char *q, const char *opt);\n+static int init_id_key(rc4_key* key,int key_data_len);\n+\n+#if !defined(WIN32) && !defined(WATT32)\n+static int sortlist_alloc(struct apattern **sortlist, int *nsort, struct apattern *pat);\n+static int ip_addr(const char *s, ssize_t len, struct in_addr *addr);\n+static void natural_mask(struct apattern *pat);\n+static int config_domain(ares_channel channel, char *str);\n+static int config_lookup(ares_channel channel, const char *str,\n+                         const char *bindch, const char *filech);\n+static int config_sortlist(struct apattern **sortlist, int *nsort,\n+                           const char *str);\n+static char *try_config(char *s, const char *opt);\n+#endif\n+\n+#define ARES_CONFIG_CHECK(x) (x->lookups && x->nsort > -1 && \\\n+                             x->nservers > -1 && \\\n+                             x->ndomains > -1 && \\\n+                             x->ndots > -1 && x->timeout > -1 && \\\n+                             x->tries > -1)\n+\n+int ares_init(ares_channel *channelptr)\n+{\n+  return ares_init_options(channelptr, NULL, 0);\n+}\n+\n+int ares_init_options(ares_channel *channelptr, struct ares_options *options,\n+                      int optmask)\n+{\n+  ares_channel channel;\n+  int i;\n+  int status = ARES_SUCCESS;\n+  struct timeval now;\n+\n+#ifdef CURLDEBUG\n+  const char *env = getenv(\"CARES_MEMDEBUG\");\n+\n+  if (env)\n+    curl_memdebug(env);\n+  env = getenv(\"CARES_MEMLIMIT\");\n+  if (env) {\n+    char *endptr;\n+    long num = strtol(env, &endptr, 10);\n+    if((endptr != env) && (endptr == env + strlen(env)) && (num > 0))\n+      curl_memlimit(num);\n+  }\n+#endif\n+\n+  if (ares_library_initialized() != ARES_SUCCESS)\n+    return ARES_ENOTINITIALIZED;\n+\n+  channel = malloc(sizeof(struct ares_channeldata));\n+  if (!channel) {\n+    *channelptr = NULL;\n+    return ARES_ENOMEM;\n+  }\n+\n+  now = ares__tvnow();\n+\n+  /* Set everything to distinguished values so we know they haven't\n+   * been set yet.\n+   */\n+  channel->flags = -1;\n+  channel->timeout = -1;\n+  channel->tries = -1;\n+  channel->ndots = -1;\n+  channel->rotate = -1;\n+  channel->udp_port = -1;\n+  channel->tcp_port = -1;\n+  channel->socket_send_buffer_size = -1;\n+  channel->socket_receive_buffer_size = -1;\n+  channel->nservers = -1;\n+  channel->ndomains = -1;\n+  channel->nsort = -1;\n+  channel->tcp_connection_generation = 0;\n+  channel->lookups = NULL;\n+  channel->domains = NULL;\n+  channel->sortlist = NULL;\n+  channel->servers = NULL;\n+  channel->sock_state_cb = NULL;\n+  channel->sock_state_cb_data = NULL;\n+  channel->sock_create_cb = NULL;\n+  channel->sock_create_cb_data = NULL;\n+\n+  channel->last_server = 0;\n+  channel->last_timeout_processed = (time_t)now.tv_sec;\n+\n+  memset(&channel->local_dev_name, 0, sizeof(channel->local_dev_name));\n+  channel->local_ip4 = 0;\n+  memset(&channel->local_ip6, 0, sizeof(channel->local_ip6));\n+\n+  /* Initialize our lists of queries */\n+  ares__init_list_head(&(channel->all_queries));\n+  for (i = 0; i < ARES_QID_TABLE_SIZE; i++)\n+    {\n+      ares__init_list_head(&(channel->queries_by_qid[i]));\n+    }\n+  for (i = 0; i < ARES_TIMEOUT_TABLE_SIZE; i++)\n+    {\n+      ares__init_list_head(&(channel->queries_by_timeout[i]));\n+    }\n+\n+  /* Initialize configuration by each of the four sources, from highest\n+   * precedence to lowest.\n+   */\n+\n+  if (status == ARES_SUCCESS) {\n+    status = init_by_options(channel, options, optmask);\n+    if (status != ARES_SUCCESS)\n+      DEBUGF(fprintf(stderr, \"Error: init_by_options failed: %s\\n\",\n+                     ares_strerror(status)));\n+  }\n+  if (status == ARES_SUCCESS) {\n+    status = init_by_environment(channel);\n+    if (status != ARES_SUCCESS)\n+      DEBUGF(fprintf(stderr, \"Error: init_by_environment failed: %s\\n\",\n+                     ares_strerror(status)));\n+  }\n+  if (status == ARES_SUCCESS) {\n+    status = init_by_resolv_conf(channel);\n+    if (status != ARES_SUCCESS)\n+      DEBUGF(fprintf(stderr, \"Error: init_by_resolv_conf failed: %s\\n\",\n+                     ares_strerror(status)));\n+  }\n+\n+  /*\n+   * No matter what failed or succeeded, seed defaults to provide\n+   * useful behavior for things that we missed.\n+   */\n+  status = init_by_defaults(channel);\n+  if (status != ARES_SUCCESS)\n+    DEBUGF(fprintf(stderr, \"Error: init_by_defaults failed: %s\\n\",\n+                   ares_strerror(status)));\n+\n+  /* Generate random key */\n+\n+  if (status == ARES_SUCCESS) {\n+    status = init_id_key(&channel->id_key, ARES_ID_KEY_LEN);\n+    if (status == ARES_SUCCESS)\n+      channel->next_id = ares__generate_new_id(&channel->id_key);\n+    else\n+      DEBUGF(fprintf(stderr, \"Error: init_id_key failed: %s\\n\",\n+                     ares_strerror(status)));\n+  }\n+\n+  if (status != ARES_SUCCESS)\n+    {\n+      /* Something failed; clean up memory we may have allocated. */\n+      if (channel->servers)\n+        free(channel->servers);\n+      if (channel->domains)\n+        {\n+          for (i = 0; i < channel->ndomains; i++)\n+            free(channel->domains[i]);\n+          free(channel->domains);\n+        }\n+      if (channel->sortlist)\n+        free(channel->sortlist);\n+      if(channel->lookups)\n+        free(channel->lookups);\n+      free(channel);\n+      return status;\n+    }\n+\n+  /* Trim to one server if ARES_FLAG_PRIMARY is set. */\n+  if ((channel->flags & ARES_FLAG_PRIMARY) && channel->nservers > 1)\n+    channel->nservers = 1;\n+\n+  ares__init_servers_state(channel);\n+\n+  *channelptr = channel;\n+  return ARES_SUCCESS;\n+}\n+\n+/* ares_dup() duplicates a channel handle with all its options and returns a\n+   new channel handle */\n+int ares_dup(ares_channel *dest, ares_channel src)\n+{\n+  struct ares_options opts;\n+  struct ares_addr_node *servers;\n+  int ipv6_nservers = 0;\n+  int i, rc;\n+  int optmask;\n+\n+  *dest = NULL; /* in case of failure return NULL explicitly */\n+\n+  /* First get the options supported by the old ares_save_options() function,\n+     which is most of them */\n+  rc = ares_save_options(src, &opts, &optmask);\n+  if(rc)\n+    return rc;\n+\n+  /* Then create the new channel with those options */\n+  rc = ares_init_options(dest, &opts, optmask);\n+\n+  /* destroy the options copy to not leak any memory */\n+  ares_destroy_options(&opts);\n+\n+  if(rc)\n+    return rc;\n+\n+  /* Now clone the options that ares_save_options() doesn't support. */\n+  (*dest)->sock_create_cb      = src->sock_create_cb;\n+  (*dest)->sock_create_cb_data = src->sock_create_cb_data;\n+\n+  strncpy((*dest)->local_dev_name, src->local_dev_name, sizeof(src->local_dev_name));\n+  (*dest)->local_ip4 = src->local_ip4;\n+  memcpy((*dest)->local_ip6, src->local_ip6, sizeof(src->local_ip6));\n+\n+  /* Full name server cloning required when not all are IPv4 */\n+  for (i = 0; i < src->nservers; i++)\n+    {\n+      if (src->servers[i].addr.family != AF_INET) {\n+        ipv6_nservers++;\n+        break;\n+      }\n+    }\n+  if (ipv6_nservers) {\n+    rc = ares_get_servers(src, &servers);\n+    if (rc != ARES_SUCCESS)\n+      return rc;\n+    rc = ares_set_servers(*dest, servers);\n+    ares_free_data(servers);\n+    if (rc != ARES_SUCCESS)\n+      return rc;\n+  }\n+\n+  return ARES_SUCCESS; /* everything went fine */\n+}\n+\n+/* Save options from initialized channel */\n+int ares_save_options(ares_channel channel, struct ares_options *options,\n+                      int *optmask)\n+{\n+  int i, j;\n+  int ipv4_nservers = 0;\n+\n+  /* Zero everything out */\n+  memset(options, 0, sizeof(struct ares_options));\n+\n+  if (!ARES_CONFIG_CHECK(channel))\n+    return ARES_ENODATA;\n+\n+  /* Traditionally the optmask wasn't saved in the channel struct so it was\n+     recreated here. ROTATE is the first option that has no struct field of\n+     its own in the public config struct */\n+  (*optmask) = (ARES_OPT_FLAGS|ARES_OPT_TRIES|ARES_OPT_NDOTS|\n+                ARES_OPT_UDP_PORT|ARES_OPT_TCP_PORT|ARES_OPT_SOCK_STATE_CB|\n+                ARES_OPT_SERVERS|ARES_OPT_DOMAINS|ARES_OPT_LOOKUPS|\n+                ARES_OPT_SORTLIST|ARES_OPT_TIMEOUTMS) |\n+    (channel->optmask & ARES_OPT_ROTATE);\n+\n+  /* Copy easy stuff */\n+  options->flags   = channel->flags;\n+\n+  /* We return full millisecond resolution but that's only because we don't\n+     set the ARES_OPT_TIMEOUT anymore, only the new ARES_OPT_TIMEOUTMS */\n+  options->timeout = channel->timeout;\n+  options->tries   = channel->tries;\n+  options->ndots   = channel->ndots;\n+  options->udp_port = (unsigned short)channel->udp_port;\n+  options->tcp_port = (unsigned short)channel->tcp_port;\n+  options->sock_state_cb     = channel->sock_state_cb;\n+  options->sock_state_cb_data = channel->sock_state_cb_data;\n+\n+  /* Copy IPv4 servers */\n+  if (channel->nservers) {\n+    for (i = 0; i < channel->nservers; i++)\n+    {\n+      if (channel->servers[i].addr.family == AF_INET)\n+        ipv4_nservers++;\n+    }\n+    if (ipv4_nservers) {\n+      options->servers = malloc(ipv4_nservers * sizeof(struct server_state));\n+      if (!options->servers)\n+        return ARES_ENOMEM;\n+      for (i = j = 0; i < channel->nservers; i++)\n+      {\n+        if (channel->servers[i].addr.family == AF_INET)\n+          memcpy(&options->servers[j++],\n+                 &channel->servers[i].addr.addrV4,\n+                 sizeof(channel->servers[i].addr.addrV4));\n+      }\n+    }\n+  }\n+  options->nservers = ipv4_nservers;\n+\n+  /* copy domains */\n+  if (channel->ndomains) {\n+    options->domains = malloc(channel->ndomains * sizeof(char *));\n+    if (!options->domains)\n+      return ARES_ENOMEM;\n+\n+    for (i = 0; i < channel->ndomains; i++)\n+    {\n+      options->ndomains = i;\n+      options->domains[i] = strdup(channel->domains[i]);\n+      if (!options->domains[i])\n+        return ARES_ENOMEM;\n+    }\n+  }\n+  options->ndomains = channel->ndomains;\n+\n+  /* copy lookups */\n+  if (channel->lookups) {\n+    options->lookups = strdup(channel->lookups);\n+    if (!options->lookups && channel->lookups)\n+      return ARES_ENOMEM;\n+  }\n+\n+  /* copy sortlist */\n+  if (channel->nsort) {\n+    options->sortlist = malloc(channel->nsort * sizeof(struct apattern));\n+    if (!options->sortlist)\n+      return ARES_ENOMEM;\n+    for (i = 0; i < channel->nsort; i++)\n+      options->sortlist[i] = channel->sortlist[i];\n+  }\n+  options->nsort = channel->nsort;\n+\n+  return ARES_SUCCESS;\n+}\n+\n+static int init_by_options(ares_channel channel,\n+                           const struct ares_options *options,\n+                           int optmask)\n+{\n+  int i;\n+\n+  /* Easy stuff. */\n+  if ((optmask & ARES_OPT_FLAGS) && channel->flags == -1)\n+    channel->flags = options->flags;\n+  if ((optmask & ARES_OPT_TIMEOUTMS) && channel->timeout == -1)\n+    channel->timeout = options->timeout;\n+  else if ((optmask & ARES_OPT_TIMEOUT) && channel->timeout == -1)\n+    channel->timeout = options->timeout * 1000;\n+  if ((optmask & ARES_OPT_TRIES) && channel->tries == -1)\n+    channel->tries = options->tries;\n+  if ((optmask & ARES_OPT_NDOTS) && channel->ndots == -1)\n+    channel->ndots = options->ndots;\n+  if ((optmask & ARES_OPT_ROTATE) && channel->rotate == -1)\n+    channel->rotate = 1;\n+  if ((optmask & ARES_OPT_UDP_PORT) && channel->udp_port == -1)\n+    channel->udp_port = options->udp_port;\n+  if ((optmask & ARES_OPT_TCP_PORT) && channel->tcp_port == -1)\n+    channel->tcp_port = options->tcp_port;\n+  if ((optmask & ARES_OPT_SOCK_STATE_CB) && channel->sock_state_cb == NULL)\n+    {\n+      channel->sock_state_cb = options->sock_state_cb;\n+      channel->sock_state_cb_data = options->sock_state_cb_data;\n+    }\n+  if ((optmask & ARES_OPT_SOCK_SNDBUF)\n+      && channel->socket_send_buffer_size == -1)\n+    channel->socket_send_buffer_size = options->socket_send_buffer_size;\n+  if ((optmask & ARES_OPT_SOCK_RCVBUF)\n+      && channel->socket_receive_buffer_size == -1)\n+    channel->socket_receive_buffer_size = options->socket_receive_buffer_size;\n+\n+  /* Copy the IPv4 servers, if given. */\n+  if ((optmask & ARES_OPT_SERVERS) && channel->nservers == -1)\n+    {\n+      /* Avoid zero size allocations at any cost */\n+      if (options->nservers > 0)\n+        {\n+          channel->servers =\n+            malloc(options->nservers * sizeof(struct server_state));\n+          if (!channel->servers)\n+            return ARES_ENOMEM;\n+          for (i = 0; i < options->nservers; i++)\n+            {\n+              channel->servers[i].addr.family = AF_INET;\n+              memcpy(&channel->servers[i].addr.addrV4,\n+                     &options->servers[i],\n+                     sizeof(channel->servers[i].addr.addrV4));\n+            }\n+        }\n+      channel->nservers = options->nservers;\n+    }\n+\n+  /* Copy the domains, if given.  Keep channel->ndomains consistent so\n+   * we can clean up in case of error.\n+   */\n+  if ((optmask & ARES_OPT_DOMAINS) && channel->ndomains == -1)\n+    {\n+      /* Avoid zero size allocations at any cost */\n+      if (options->ndomains > 0)\n+      {\n+        channel->domains = malloc(options->ndomains * sizeof(char *));\n+        if (!channel->domains)\n+          return ARES_ENOMEM;\n+        for (i = 0; i < options->ndomains; i++)\n+          {\n+            channel->ndomains = i;\n+            channel->domains[i] = strdup(options->domains[i]);\n+            if (!channel->domains[i])\n+              return ARES_ENOMEM;\n+          }\n+      }\n+      channel->ndomains = options->ndomains;\n+    }\n+\n+  /* Set lookups, if given. */\n+  if ((optmask & ARES_OPT_LOOKUPS) && !channel->lookups)\n+    {\n+      channel->lookups = strdup(options->lookups);\n+      if (!channel->lookups)\n+        return ARES_ENOMEM;\n+    }\n+\n+  /* copy sortlist */\n+  if ((optmask & ARES_OPT_SORTLIST) && (channel->nsort == -1) &&\n+      (options->nsort>0)) {\n+    channel->sortlist = malloc(options->nsort * sizeof(struct apattern));\n+    if (!channel->sortlist)\n+      return ARES_ENOMEM;\n+    for (i = 0; i < options->nsort; i++)\n+      channel->sortlist[i] = options->sortlist[i];\n+    channel->nsort = options->nsort;\n+  }\n+\n+  channel->optmask = optmask;\n+\n+  return ARES_SUCCESS;\n+}\n+\n+static int init_by_environment(ares_channel channel)\n+{\n+  const char *localdomain, *res_options;\n+  int status;\n+\n+  localdomain = getenv(\"LOCALDOMAIN\");\n+  if (localdomain && channel->ndomains == -1)\n+    {\n+      status = set_search(channel, localdomain);\n+      if (status != ARES_SUCCESS)\n+        return status;\n+    }\n+\n+  res_options = getenv(\"RES_OPTIONS\");\n+  if (res_options)\n+    {\n+      status = set_options(channel, res_options);\n+      if (status != ARES_SUCCESS)\n+        return status;\n+    }\n+\n+  return ARES_SUCCESS;\n+}\n+\n+#ifdef WIN32\n+/*\n+ * Warning: returns a dynamically allocated buffer, the user MUST\n+ * use free() if the function returns 1\n+ */\n+static int get_res_nt(HKEY hKey, const char *subkey, char **obuf)\n+{\n+  /* Test for the size we need */\n+  DWORD size = 0;\n+  int result;\n+\n+  result = RegQueryValueEx(hKey, subkey, 0, NULL, NULL, &size);\n+  if ((result != ERROR_SUCCESS && result != ERROR_MORE_DATA) || !size)\n+    return 0;\n+  *obuf = malloc(size+1);\n+  if (!*obuf)\n+    return 0;\n+\n+  if (RegQueryValueEx(hKey, subkey, 0, NULL,\n+                      (LPBYTE)*obuf, &size) != ERROR_SUCCESS)\n+  {\n+    free(*obuf);\n+    return 0;\n+  }\n+  if (size == 1)\n+  {\n+    free(*obuf);\n+    return 0;\n+  }\n+  return 1;\n+}\n+\n+static int get_res_interfaces_nt(HKEY hKey, const char *subkey, char **obuf)\n+{\n+  char enumbuf[39]; /* GUIDs are 38 chars + 1 for NULL */\n+  DWORD enum_size = 39;\n+  int idx = 0;\n+  HKEY hVal;\n+\n+  while (RegEnumKeyEx(hKey, idx++, enumbuf, &enum_size, 0,\n+                      NULL, NULL, NULL) != ERROR_NO_MORE_ITEMS)\n+  {\n+    int rc;\n+\n+    enum_size = 39;\n+    if (RegOpenKeyEx(hKey, enumbuf, 0, KEY_QUERY_VALUE, &hVal) !=\n+        ERROR_SUCCESS)\n+      continue;\n+    rc = get_res_nt(hVal, subkey, obuf);\n+      RegCloseKey(hVal);\n+    if (rc)\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+static int get_iphlpapi_dns_info (char *ret_buf, size_t ret_size)\n+{\n+  FIXED_INFO    *fi, *newfi;\n+  DWORD          size = sizeof (*fi);\n+  IP_ADDR_STRING *ipAddr;\n+  int            i, count = 0;\n+  int            debug  = 0;\n+  size_t         ip_size = sizeof(\"255.255.255.255,\")-1;\n+  size_t         left = ret_size;\n+  char          *ret = ret_buf;\n+  HRESULT        res;\n+\n+  fi = malloc(size);\n+  if (!fi)\n+     return 0;\n+\n+  res = (*ares_fpGetNetworkParams) (fi, &size);\n+  if ((res != ERROR_BUFFER_OVERFLOW) && (res != ERROR_SUCCESS))\n+     goto quit;\n+\n+  newfi = realloc(fi, size);\n+  if (!newfi)\n+     goto quit;\n+\n+  fi = newfi;\n+  res = (*ares_fpGetNetworkParams) (fi, &size);\n+  if (res != ERROR_SUCCESS)\n+     goto quit;\n+\n+  if (debug)\n+  {\n+    printf (\"Host Name: %s\\n\", fi->HostName);\n+    printf (\"Domain Name: %s\\n\", fi->DomainName);\n+    printf (\"DNS Servers:\\n\"\n+            \"    %s (primary)\\n\", fi->DnsServerList.IpAddress.String);\n+  }\n+  if (strlen(fi->DnsServerList.IpAddress.String) > 0 &&\n+      inet_addr(fi->DnsServerList.IpAddress.String) != INADDR_NONE &&\n+      left > ip_size)\n+  {\n+    ret += sprintf (ret, \"%s,\", fi->DnsServerList.IpAddress.String);\n+    left -= ret - ret_buf;\n+    count++;\n+  }\n+\n+  for (i = 0, ipAddr = fi->DnsServerList.Next; ipAddr && left > ip_size;\n+       ipAddr = ipAddr->Next, i++)\n+  {\n+    if (inet_addr(ipAddr->IpAddress.String) != INADDR_NONE)\n+    {\n+       ret += sprintf (ret, \"%s,\", ipAddr->IpAddress.String);\n+       left -= ret - ret_buf;\n+       count++;\n+    }\n+    if (debug)\n+       printf (\"    %s (secondary %d)\\n\", ipAddr->IpAddress.String, i+1);\n+  }\n+\n+quit:\n+  if (fi)\n+     free(fi);\n+\n+  if (debug && left <= ip_size)\n+     printf (\"Too many nameservers. Truncating to %d addressess\", count);\n+  if (ret > ret_buf)\n+     ret[-1] = '\\0';\n+  return count;\n+}\n+#endif\n+\n+static int init_by_resolv_conf(ares_channel channel)\n+{\n+#ifndef WATT32\n+  char *line = NULL;\n+#endif\n+  int status = -1, nservers = 0, nsort = 0;\n+  struct server_state *servers = NULL;\n+  struct apattern *sortlist = NULL;\n+\n+#ifdef WIN32\n+\n+    /*\n+  NameServer info via IPHLPAPI (IP helper API):\n+    GetNetworkParams() should be the trusted source for this.\n+    Available in Win-98/2000 and later. If that fail, fall-back to\n+    registry information.\n+\n+  NameServer Registry:\n+\n+   On Windows 9X, the DNS server can be found in:\n+HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\VxD\\MSTCP\\NameServer\n+\n+        On Windows NT/2000/XP/2003:\n+HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\NameServer\n+        or\n+HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\DhcpNameServer\n+        or\n+HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\{AdapterID}\\\n+NameServer\n+        or\n+HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\{AdapterID}\\\n+DhcpNameServer\n+   */\n+\n+  HKEY mykey;\n+  HKEY subkey;\n+  DWORD data_type;\n+  DWORD bytes;\n+  DWORD result;\n+  char  buf[256];\n+\n+  if (channel->nservers > -1)  /* don't override ARES_OPT_SERVER */\n+     return ARES_SUCCESS;\n+\n+  if (get_iphlpapi_dns_info(buf,sizeof(buf)) > 0)\n+  {\n+    status = config_nameserver(&servers, &nservers, buf);\n+    if (status == ARES_SUCCESS)\n+      goto okay;\n+  }\n+\n+  if (IS_NT())\n+  {\n+    if (RegOpenKeyEx(\n+          HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY, 0,\n+          KEY_READ, &mykey\n+          ) == ERROR_SUCCESS)\n+    {\n+      RegOpenKeyEx(mykey, \"Interfaces\", 0,\n+                   KEY_QUERY_VALUE|KEY_ENUMERATE_SUB_KEYS, &subkey);\n+      if (get_res_nt(mykey, NAMESERVER, &line))\n+      {\n+        status = config_nameserver(&servers, &nservers, line);\n+        free(line);\n+      }\n+      else if (get_res_nt(mykey, DHCPNAMESERVER, &line))\n+      {\n+        status = config_nameserver(&servers, &nservers, line);\n+        free(line);\n+      }\n+      /* Try the interfaces */\n+      else if (get_res_interfaces_nt(subkey, NAMESERVER, &line))\n+      {\n+        status = config_nameserver(&servers, &nservers, line);\n+        free(line);\n+      }\n+      else if (get_res_interfaces_nt(subkey, DHCPNAMESERVER, &line))\n+      {\n+        status = config_nameserver(&servers, &nservers, line);\n+        free(line);\n+      }\n+      RegCloseKey(subkey);\n+      RegCloseKey(mykey);\n+    }\n+  }\n+  else\n+  {\n+    if (RegOpenKeyEx(\n+          HKEY_LOCAL_MACHINE, WIN_NS_9X, 0,\n+          KEY_READ, &mykey\n+          ) == ERROR_SUCCESS)\n+    {\n+      if ((result = RegQueryValueEx(\n+             mykey, NAMESERVER, NULL, &data_type,\n+             NULL, &bytes\n+             )\n+            ) == ERROR_SUCCESS ||\n+          result == ERROR_MORE_DATA)\n+      {\n+        if (bytes)\n+        {\n+          line = malloc(bytes+1);\n+          if (RegQueryValueEx(mykey, NAMESERVER, NULL, &data_type,\n+                              (unsigned char *)line, &bytes) ==\n+              ERROR_SUCCESS)\n+          {\n+            status = config_nameserver(&servers, &nservers, line);\n+          }\n+          free(line);\n+        }\n+      }\n+    }\n+    RegCloseKey(mykey);\n+  }\n+\n+  if (status == ARES_SUCCESS)\n+    status = ARES_EOF;\n+  else\n+    /* Catch the case when all the above checks fail (which happens when there\n+       is no network card or the cable is unplugged) */\n+    status = ARES_EFILE;\n+\n+#elif defined(__riscos__)\n+\n+  /* Under RISC OS, name servers are listed in the\n+     system variable Inet$Resolvers, space separated. */\n+\n+  line = getenv(\"Inet$Resolvers\");\n+  status = ARES_EOF;\n+  if (line) {\n+    char *resolvers = strdup(line), *pos, *space;\n+\n+    if (!resolvers)\n+      return ARES_ENOMEM;\n+\n+    pos = resolvers;\n+    do {\n+      space = strchr(pos, ' ');\n+      if (space)\n+        *space = '\\0';\n+      status = config_nameserver(&servers, &nservers, pos);\n+      if (status != ARES_SUCCESS)\n+        break;\n+      pos = space + 1;\n+    } while (space);\n+\n+    if (status == ARES_SUCCESS)\n+      status = ARES_EOF;\n+\n+    free(resolvers);\n+  }\n+\n+#elif defined(WATT32)\n+  int i;\n+\n+  sock_init();\n+  for (i = 0; def_nameservers[i]; i++)\n+      ;\n+  if (i == 0)\n+    return ARES_SUCCESS; /* use localhost DNS server */\n+\n+  nservers = i;\n+  servers = calloc(i, sizeof(struct server_state));\n+  if (!servers)\n+     return ARES_ENOMEM;\n+\n+  for (i = 0; def_nameservers[i]; i++)\n+      servers[i].addr.addrV4.s_addr = htonl(def_nameservers[i]);\n+  status = ARES_EOF;\n+\n+#elif defined(ANDROID)\n+  char value[PROP_VALUE_MAX]=\"\";\n+  __system_property_get(\"net.dns1\", value);\n+  status = config_nameserver(&servers, &nservers, value);\n+  if (status == ARES_SUCCESS)\n+    status = ARES_EOF;\n+#else\n+  {\n+    char *p;\n+    FILE *fp;\n+    size_t linesize;\n+    int error;\n+\n+    /* Don't read resolv.conf and friends if we don't have to */\n+    if (ARES_CONFIG_CHECK(channel))\n+        return ARES_SUCCESS;\n+\n+    fp = fopen(PATH_RESOLV_CONF, \"r\");\n+    if (fp) {\n+      while ((status = ares__read_line(fp, &line, &linesize)) == ARES_SUCCESS)\n+      {\n+        if ((p = try_config(line, \"domain\")))\n+          status = config_domain(channel, p);\n+        else if ((p = try_config(line, \"lookup\")) && !channel->lookups)\n+          status = config_lookup(channel, p, \"bind\", \"file\");\n+        else if ((p = try_config(line, \"search\")))\n+          status = set_search(channel, p);\n+        else if ((p = try_config(line, \"nameserver\")) && channel->nservers == -1)\n+          status = config_nameserver(&servers, &nservers, p);\n+        else if ((p = try_config(line, \"sortlist\")) && channel->nsort == -1)\n+          status = config_sortlist(&sortlist, &nsort, p);\n+        else if ((p = try_config(line, \"options\")))\n+          status = set_options(channel, p);\n+        else\n+          status = ARES_SUCCESS;\n+        if (status != ARES_SUCCESS)\n+          break;\n+      }\n+      fclose(fp);\n+    }\n+    else {\n+      error = ERRNO;\n+      switch(error) {\n+      case ENOENT:\n+      case ESRCH:\n+        status = ARES_EOF;\n+        break;\n+      default:\n+        DEBUGF(fprintf(stderr, \"fopen() failed with error: %d %s\\n\",\n+                       error, strerror(error)));\n+        DEBUGF(fprintf(stderr, \"Error opening file: %s\\n\", PATH_RESOLV_CONF));\n+        status = ARES_EFILE;\n+      }\n+    }\n+\n+    if ((status == ARES_EOF) && (!channel->lookups)) {\n+      /* Many systems (Solaris, Linux, BSD's) use nsswitch.conf */\n+      fp = fopen(\"/etc/nsswitch.conf\", \"r\");\n+      if (fp) {\n+        while ((status = ares__read_line(fp, &line, &linesize)) == ARES_SUCCESS)\n+        {\n+          if ((p = try_config(line, \"hosts:\")) && !channel->lookups)\n+            status = config_lookup(channel, p, \"dns\", \"files\");\n+        }\n+        fclose(fp);\n+      }\n+      else {\n+        error = ERRNO;\n+        switch(error) {\n+        case ENOENT:\n+        case ESRCH:\n+          status = ARES_EOF;\n+          break;\n+        default:\n+          DEBUGF(fprintf(stderr, \"fopen() failed with error: %d %s\\n\",\n+                         error, strerror(error)));\n+          DEBUGF(fprintf(stderr, \"Error opening file: %s\\n\", \"/etc/nsswitch.conf\"));\n+          status = ARES_EFILE;\n+        }\n+      }\n+    }\n+\n+    if ((status == ARES_EOF) && (!channel->lookups)) {\n+      /* Linux / GNU libc 2.x and possibly others have host.conf */\n+      fp = fopen(\"/etc/host.conf\", \"r\");\n+      if (fp) {\n+        while ((status = ares__read_line(fp, &line, &linesize)) == ARES_SUCCESS)\n+        {\n+          if ((p = try_config(line, \"order\")) && !channel->lookups)\n+            status = config_lookup(channel, p, \"bind\", \"hosts\");\n+        }\n+        fclose(fp);\n+      }\n+      else {\n+        error = ERRNO;\n+        switch(error) {\n+        case ENOENT:\n+        case ESRCH:\n+          status = ARES_EOF;\n+          break;\n+        default:\n+          DEBUGF(fprintf(stderr, \"fopen() failed with error: %d %s\\n\",\n+                         error, strerror(error)));\n+          DEBUGF(fprintf(stderr, \"Error opening file: %s\\n\", \"/etc/host.conf\"));\n+          status = ARES_EFILE;\n+        }\n+      }\n+    }\n+\n+    if ((status == ARES_EOF) && (!channel->lookups)) {\n+      /* Tru64 uses /etc/svc.conf */\n+      fp = fopen(\"/etc/svc.conf\", \"r\");\n+      if (fp) {\n+        while ((status = ares__read_line(fp, &line, &linesize)) == ARES_SUCCESS)\n+        {\n+          if ((p = try_config(line, \"hosts=\")) && !channel->lookups)\n+            status = config_lookup(channel, p, \"bind\", \"local\");\n+        }\n+        fclose(fp);\n+      }\n+      else {\n+        error = ERRNO;\n+        switch(error) {\n+        case ENOENT:\n+        case ESRCH:\n+          status = ARES_EOF;\n+          break;\n+        default:\n+          DEBUGF(fprintf(stderr, \"fopen() failed with error: %d %s\\n\",\n+                         error, strerror(error)));\n+          DEBUGF(fprintf(stderr, \"Error opening file: %s\\n\", \"/etc/svc.conf\"));\n+          status = ARES_EFILE;\n+        }\n+      }\n+    }\n+\n+    if(line)\n+      free(line);\n+  }\n+\n+#endif\n+\n+  /* Handle errors. */\n+  if (status != ARES_EOF)\n+    {\n+      if (servers != NULL)\n+        free(servers);\n+      if (sortlist != NULL)\n+        free(sortlist);\n+      return status;\n+    }\n+\n+  /* If we got any name server entries, fill them in. */\n+#ifdef WIN32\n+okay:\n+#endif\n+  if (servers)\n+    {\n+      channel->servers = servers;\n+      channel->nservers = nservers;\n+    }\n+\n+  /* If we got any sortlist entries, fill them in. */\n+  if (sortlist)\n+    {\n+      channel->sortlist = sortlist;\n+      channel->nsort = nsort;\n+    }\n+\n+  return ARES_SUCCESS;\n+}\n+\n+static int init_by_defaults(ares_channel channel)\n+{\n+  char *hostname = NULL;\n+  int rc = ARES_SUCCESS;\n+#ifdef HAVE_GETHOSTNAME\n+  char *dot;\n+#endif\n+\n+  if (channel->flags == -1)\n+    channel->flags = 0;\n+  if (channel->timeout == -1)\n+    channel->timeout = DEFAULT_TIMEOUT;\n+  if (channel->tries == -1)\n+    channel->tries = DEFAULT_TRIES;\n+  if (channel->ndots == -1)\n+    channel->ndots = 1;\n+  if (channel->rotate == -1)\n+    channel->rotate = 0;\n+  if (channel->udp_port == -1)\n+    channel->udp_port = htons(NAMESERVER_PORT);\n+  if (channel->tcp_port == -1)\n+    channel->tcp_port = htons(NAMESERVER_PORT);\n+\n+  if (channel->nservers == -1) {\n+    /* If nobody specified servers, try a local named. */\n+    channel->servers = malloc(sizeof(struct server_state));\n+    if (!channel->servers) {\n+      rc = ARES_ENOMEM;\n+      goto error;\n+    }\n+    channel->servers[0].addr.family = AF_INET;\n+    channel->servers[0].addr.addrV4.s_addr = htonl(INADDR_LOOPBACK);\n+    channel->nservers = 1;\n+  }\n+\n+#ifdef ENAMETOOLONG\n+#define toolong(x) (x == -1) && ((ENAMETOOLONG == errno) || (EINVAL == errno))\n+#else\n+#define toolong(x) (x == -1) && (EINVAL == errno)\n+#endif\n+\n+  if (channel->ndomains == -1) {\n+    /* Derive a default domain search list from the kernel hostname,\n+     * or set it to empty if the hostname isn't helpful.\n+     */\n+    size_t len = 64;\n+    int res;\n+    channel->ndomains = 0; /* default to none */\n+\n+#ifdef HAVE_GETHOSTNAME\n+    hostname = malloc(len);\n+    if(!hostname) {\n+      rc = ARES_ENOMEM;\n+      goto error;\n+    }\n+\n+    do {\n+      res = gethostname(hostname, len);\n+\n+      if(toolong(res)) {\n+        char *p;\n+        len *= 2;\n+        p = realloc(hostname, len);\n+        if(!p) {\n+          rc = ARES_ENOMEM;\n+          goto error;\n+        }\n+        hostname = p;\n+        continue;\n+      }\n+      else if(res) {\n+        rc = ARES_EBADNAME;\n+        goto error;\n+      }\n+\n+    } while(0);\n+\n+    dot = strchr(hostname, '.');\n+    if (dot) {\n+      /* a dot was found */\n+      channel->domains = malloc(sizeof(char *));\n+      if (!channel->domains) {\n+        rc = ARES_ENOMEM;\n+        goto error;\n+      }\n+      channel->domains[0] = strdup(dot + 1);\n+      if (!channel->domains[0]) {\n+        rc = ARES_ENOMEM;\n+        goto error;\n+      }\n+      channel->ndomains = 1;\n+    }\n+#endif\n+  }\n+\n+  if (channel->nsort == -1) {\n+    channel->sortlist = NULL;\n+    channel->nsort = 0;\n+  }\n+\n+  if (!channel->lookups) {\n+    channel->lookups = strdup(\"fb\");\n+    if (!channel->lookups)\n+      rc = ARES_ENOMEM;\n+  }\n+\n+  error:\n+  if(rc) {\n+    if(channel->servers)\n+      free(channel->servers);\n+\n+    if(channel->domains && channel->domains[0])\n+      free(channel->domains[0]);\n+    if(channel->domains)\n+      free(channel->domains);\n+    if(channel->lookups)\n+      free(channel->lookups);\n+  }\n+\n+  if(hostname)\n+    free(hostname);\n+\n+  return rc;\n+}\n+\n+#if !defined(WIN32) && !defined(WATT32)\n+static int config_domain(ares_channel channel, char *str)\n+{\n+  char *q;\n+\n+  /* Set a single search domain. */\n+  q = str;\n+  while (*q && !ISSPACE(*q))\n+    q++;\n+  *q = '\\0';\n+  return set_search(channel, str);\n+}\n+\n+#if defined(__INTEL_COMPILER) && (__INTEL_COMPILER == 910) && \\\n+    defined(__OPTIMIZE__) && defined(__unix__) &&  defined(__i386__)\n+  /* workaround icc 9.1 optimizer issue */\n+# define vqualifier volatile\n+#else\n+# define vqualifier\n+#endif\n+\n+static int config_lookup(ares_channel channel, const char *str,\n+                         const char *bindch, const char *filech)\n+{\n+  char lookups[3], *l;\n+  const char *vqualifier p;\n+\n+  /* Set the lookup order.  Only the first letter of each work\n+   * is relevant, and it has to be \"b\" for DNS or \"f\" for the\n+   * host file.  Ignore everything else.\n+   */\n+  l = lookups;\n+  p = str;\n+  while (*p)\n+    {\n+      if ((*p == *bindch || *p == *filech) && l < lookups + 2) {\n+        if (*p == *bindch) *l++ = 'b';\n+        else *l++ = 'f';\n+      }\n+      while (*p && !ISSPACE(*p) && (*p != ','))\n+        p++;\n+      while (*p && (ISSPACE(*p) || (*p == ',')))\n+        p++;\n+    }\n+  *l = '\\0';\n+  channel->lookups = strdup(lookups);\n+  return (channel->lookups) ? ARES_SUCCESS : ARES_ENOMEM;\n+}\n+#endif  /* !WIN32 & !WATT32 */\n+\n+#ifndef WATT32\n+static int config_nameserver(struct server_state **servers, int *nservers,\n+                             char *str)\n+{\n+  struct ares_addr host;\n+  struct server_state *newserv;\n+  char *p, *txtaddr;\n+  /* On Windows, there may be more than one nameserver specified in the same\n+   * registry key, so we parse input as a space or comma seperated list.\n+   */\n+  for (p = str; p;)\n+    {\n+      /* Skip whitespace and commas. */\n+      while (*p && (ISSPACE(*p) || (*p == ',')))\n+        p++;\n+      if (!*p)\n+        /* No more input, done. */\n+        break;\n+\n+      /* Pointer to start of IPv4 or IPv6 address part. */\n+      txtaddr = p;\n+\n+      /* Advance past this address. */\n+      while (*p && !ISSPACE(*p) && (*p != ','))\n+        p++;\n+      if (*p)\n+        /* Null terminate this address. */\n+        *p++ = '\\0';\n+      else\n+        /* Reached end of input, done when this address is processed. */\n+        p = NULL;\n+\n+      /* Convert textual address to binary format. */\n+      if (ares_inet_pton(AF_INET, txtaddr, &host.addrV4) == 1)\n+        host.family = AF_INET;\n+      else if (ares_inet_pton(AF_INET6, txtaddr, &host.addrV6) == 1)\n+        host.family = AF_INET6;\n+      else\n+        continue;\n+\n+      /* Resize servers state array. */\n+      newserv = realloc(*servers, (*nservers + 1) *\n+                        sizeof(struct server_state));\n+      if (!newserv)\n+        return ARES_ENOMEM;\n+\n+      /* Store address data. */\n+      newserv[*nservers].addr.family = host.family;\n+      if (host.family == AF_INET)\n+        memcpy(&newserv[*nservers].addr.addrV4, &host.addrV4,\n+               sizeof(host.addrV4));\n+      else\n+        memcpy(&newserv[*nservers].addr.addrV6, &host.addrV6,\n+               sizeof(host.addrV6));\n+\n+      /* Update arguments. */\n+      *servers = newserv;\n+      *nservers += 1;\n+    }\n+\n+  return ARES_SUCCESS;\n+}\n+\n+#ifndef WIN32\n+static int config_sortlist(struct apattern **sortlist, int *nsort,\n+                           const char *str)\n+{\n+  struct apattern pat;\n+  const char *q;\n+\n+  /* Add sortlist entries. */\n+  while (*str && *str != ';')\n+    {\n+      int bits;\n+      char ipbuf[16], ipbufpfx[32];\n+      /* Find just the IP */\n+      q = str;\n+      while (*q && *q != '/' && *q != ';' && !ISSPACE(*q))\n+        q++;\n+      memcpy(ipbuf, str, q-str);\n+      ipbuf[q-str] = '\\0';\n+      /* Find the prefix */\n+      if (*q == '/')\n+        {\n+          const char *str2 = q+1;\n+          while (*q && *q != ';' && !ISSPACE(*q))\n+            q++;\n+          memcpy(ipbufpfx, str, q-str);\n+          ipbufpfx[q-str] = '\\0';\n+          str = str2;\n+        }\n+      else\n+        ipbufpfx[0] = '\\0';\n+      /* Lets see if it is CIDR */\n+      /* First we'll try IPv6 */\n+      if ((bits = ares_inet_net_pton(AF_INET6, ipbufpfx[0] ? ipbufpfx : ipbuf,\n+                                     &pat.addrV6,\n+                                     sizeof(pat.addrV6))) > 0)\n+        {\n+          pat.type = PATTERN_CIDR;\n+          pat.mask.bits = (unsigned short)bits;\n+          pat.family = AF_INET6;\n+          if (!sortlist_alloc(sortlist, nsort, &pat))\n+            return ARES_ENOMEM;\n+        }\n+      if (ipbufpfx[0] &&\n+          (bits = ares_inet_net_pton(AF_INET, ipbufpfx, &pat.addrV4,\n+                                     sizeof(pat.addrV4))) > 0)\n+        {\n+          pat.type = PATTERN_CIDR;\n+          pat.mask.bits = (unsigned short)bits;\n+          pat.family = AF_INET;\n+          if (!sortlist_alloc(sortlist, nsort, &pat))\n+            return ARES_ENOMEM;\n+        }\n+      /* See if it is just a regular IP */\n+      else if (ip_addr(ipbuf, q-str, &pat.addrV4) == 0)\n+        {\n+          if (ipbufpfx[0])\n+            {\n+              memcpy(ipbuf, str, q-str);\n+              ipbuf[q-str] = '\\0';\n+              if (ip_addr(ipbuf, q-str, &pat.mask.addr4) != 0)\n+                natural_mask(&pat);\n+            }\n+          else\n+            natural_mask(&pat);\n+          pat.family = AF_INET;\n+          pat.type = PATTERN_MASK;\n+          if (!sortlist_alloc(sortlist, nsort, &pat))\n+            return ARES_ENOMEM;\n+        }\n+      else\n+        {\n+          while (*q && *q != ';' && !ISSPACE(*q))\n+            q++;\n+        }\n+      str = q;\n+      while (ISSPACE(*str))\n+        str++;\n+    }\n+\n+  return ARES_SUCCESS;\n+}\n+#endif  /* !WIN32 */\n+#endif  /* !WATT32 */\n+\n+static int set_search(ares_channel channel, const char *str)\n+{\n+  int n;\n+  const char *p, *q;\n+\n+  if(channel->ndomains != -1) {\n+    /* if we already have some domains present, free them first */\n+    for(n=0; n < channel->ndomains; n++)\n+      free(channel->domains[n]);\n+    free(channel->domains);\n+    channel->domains = NULL;\n+    channel->ndomains = -1;\n+  }\n+\n+  /* Count the domains given. */\n+  n = 0;\n+  p = str;\n+  while (*p)\n+    {\n+      while (*p && !ISSPACE(*p))\n+        p++;\n+      while (ISSPACE(*p))\n+        p++;\n+      n++;\n+    }\n+\n+  if (!n)\n+    {\n+      channel->ndomains = 0;\n+      return ARES_SUCCESS;\n+    }\n+\n+  channel->domains = malloc(n * sizeof(char *));\n+  if (!channel->domains)\n+    return ARES_ENOMEM;\n+\n+  /* Now copy the domains. */\n+  n = 0;\n+  p = str;\n+  while (*p)\n+    {\n+      channel->ndomains = n;\n+      q = p;\n+      while (*q && !ISSPACE(*q))\n+        q++;\n+      channel->domains[n] = malloc(q - p + 1);\n+      if (!channel->domains[n])\n+        return ARES_ENOMEM;\n+      memcpy(channel->domains[n], p, q - p);\n+      channel->domains[n][q - p] = 0;\n+      p = q;\n+      while (ISSPACE(*p))\n+        p++;\n+      n++;\n+    }\n+  channel->ndomains = n;\n+\n+  return ARES_SUCCESS;\n+}\n+\n+static int set_options(ares_channel channel, const char *str)\n+{\n+  const char *p, *q, *val;\n+\n+  p = str;\n+  while (*p)\n+    {\n+      q = p;\n+      while (*q && !ISSPACE(*q))\n+        q++;\n+      val = try_option(p, q, \"ndots:\");\n+      if (val && channel->ndots == -1)\n+        channel->ndots = aresx_sltosi(strtol(val, NULL, 10));\n+      val = try_option(p, q, \"retrans:\");\n+      if (val && channel->timeout == -1)\n+        channel->timeout = aresx_sltosi(strtol(val, NULL, 10));\n+      val = try_option(p, q, \"retry:\");\n+      if (val && channel->tries == -1)\n+        channel->tries = aresx_sltosi(strtol(val, NULL, 10));\n+      val = try_option(p, q, \"rotate\");\n+      if (val && channel->rotate == -1)\n+        channel->rotate = 1;\n+      p = q;\n+      while (ISSPACE(*p))\n+        p++;\n+    }\n+\n+  return ARES_SUCCESS;\n+}\n+\n+static const char *try_option(const char *p, const char *q, const char *opt)\n+{\n+  size_t len = strlen(opt);\n+  return ((size_t)(q - p) >= len && !strncmp(p, opt, len)) ? &p[len] : NULL;\n+}\n+\n+#if !defined(WIN32) && !defined(WATT32)\n+static char *try_config(char *s, const char *opt)\n+{\n+  size_t len;\n+  char *p;\n+  char *q;\n+\n+  if (!s || !opt)\n+    /* no line or no option */\n+    return NULL;\n+\n+  /* trim line comment */\n+  p = s;\n+  while (*p && (*p != '#'))\n+    p++;\n+  *p = '\\0';\n+\n+  /* trim trailing whitespace */\n+  q = p - 1;\n+  while ((q >= s) && ISSPACE(*q))\n+    q--;\n+  *++q = '\\0';\n+\n+  /* skip leading whitespace */\n+  p = s;\n+  while (*p && ISSPACE(*p))\n+    p++;\n+\n+  if (!*p)\n+    /* empty line */\n+    return NULL;\n+\n+  if ((len = strlen(opt)) == 0)\n+    /* empty option */\n+    return NULL;\n+\n+  if (strncmp(p, opt, len) != 0)\n+    /* line and option do not match */\n+    return NULL;\n+\n+  /* skip over given option name */\n+  p += len;\n+\n+  if (!*p)\n+    /* no option value */\n+    return NULL;\n+\n+  if ((opt[len-1] != ':') && (opt[len-1] != '=') && !ISSPACE(*p))\n+    /* whitespace between option name and value is mandatory\n+       for given option names which do not end with ':' or '=' */\n+    return NULL;\n+\n+  /* skip over whitespace */\n+  while (*p && ISSPACE(*p))\n+    p++;\n+\n+  if (!*p)\n+    /* no option value */\n+    return NULL;\n+\n+  /* return pointer to option value */\n+  return p;\n+}\n+\n+static int sortlist_alloc(struct apattern **sortlist, int *nsort,\n+                          struct apattern *pat)\n+{\n+  struct apattern *newsort;\n+  newsort = realloc(*sortlist, (*nsort + 1) * sizeof(struct apattern));\n+  if (!newsort)\n+    return 0;\n+  newsort[*nsort] = *pat;\n+  *sortlist = newsort;\n+  (*nsort)++;\n+  return 1;\n+}\n+\n+static int ip_addr(const char *ipbuf, ssize_t len, struct in_addr *addr)\n+{\n+\n+  /* Four octets and three periods yields at most 15 characters. */\n+  if (len > 15)\n+    return -1;\n+\n+  addr->s_addr = inet_addr(ipbuf);\n+  if (addr->s_addr == INADDR_NONE && strcmp(ipbuf, \"255.255.255.255\") != 0)\n+    return -1;\n+  return 0;\n+}\n+\n+static void natural_mask(struct apattern *pat)\n+{\n+  struct in_addr addr;\n+\n+  /* Store a host-byte-order copy of pat in a struct in_addr.  Icky,\n+   * but portable.\n+   */\n+  addr.s_addr = ntohl(pat->addrV4.s_addr);\n+\n+  /* This is out of date in the CIDR world, but some people might\n+   * still rely on it.\n+   */\n+  if (IN_CLASSA(addr.s_addr))\n+    pat->mask.addr4.s_addr = htonl(IN_CLASSA_NET);\n+  else if (IN_CLASSB(addr.s_addr))\n+    pat->mask.addr4.s_addr = htonl(IN_CLASSB_NET);\n+  else\n+    pat->mask.addr4.s_addr = htonl(IN_CLASSC_NET);\n+}\n+#endif /* !WIN32 && !WATT32 */\n+\n+/* initialize an rc4 key. If possible a cryptographically secure random key\n+   is generated using a suitable function (for example win32's RtlGenRandom as\n+   described in\n+   http://blogs.msdn.com/michael_howard/archive/2005/01/14/353379.aspx\n+   otherwise the code defaults to cross-platform albeit less secure mechanism\n+   using rand\n+*/\n+static void randomize_key(unsigned char* key,int key_data_len)\n+{\n+  int randomized = 0;\n+  int counter=0;\n+#ifdef WIN32\n+  BOOLEAN res;\n+  if (ares_fpSystemFunction036)\n+    {\n+      res = (*ares_fpSystemFunction036) (key, key_data_len);\n+      if (res)\n+        randomized = 1;\n+    }\n+#else /* !WIN32 */\n+#ifdef RANDOM_FILE\n+  FILE *f = fopen(RANDOM_FILE, \"rb\");\n+  if(f) {\n+    counter = aresx_uztosi(fread(key, 1, key_data_len, f));\n+    fclose(f);\n+  }\n+#endif\n+#endif /* WIN32 */\n+\n+  if ( !randomized ) {\n+    for (;counter<key_data_len;counter++)\n+      key[counter]=(unsigned char)(rand() % 256);\n+  }\n+}\n+\n+static int init_id_key(rc4_key* key,int key_data_len)\n+{\n+  unsigned char index1;\n+  unsigned char index2;\n+  unsigned char* state;\n+  short counter;\n+  unsigned char *key_data_ptr = 0;\n+\n+  key_data_ptr = calloc(1,key_data_len);\n+  if (!key_data_ptr)\n+    return ARES_ENOMEM;\n+\n+  state = &key->state[0];\n+  for(counter = 0; counter < 256; counter++)\n+    /* unnecessary AND but it keeps some compilers happier */\n+    state[counter] = (unsigned char)(counter & 0xff);\n+  randomize_key(key->state,key_data_len);\n+  key->x = 0;\n+  key->y = 0;\n+  index1 = 0;\n+  index2 = 0;\n+  for(counter = 0; counter < 256; counter++)\n+  {\n+    index2 = (unsigned char)((key_data_ptr[index1] + state[counter] +\n+                              index2) % 256);\n+    ARES_SWAP_BYTE(&state[counter], &state[index2]);\n+\n+    index1 = (unsigned char)((index1 + 1) % key_data_len);\n+  }\n+  free(key_data_ptr);\n+  return ARES_SUCCESS;\n+}\n+\n+unsigned short ares__generate_new_id(rc4_key* key)\n+{\n+  unsigned short r=0;\n+  ares__rc4(key, (unsigned char *)&r, sizeof(r));\n+  return r;\n+}\n+\n+void ares_set_local_ip4(ares_channel channel, unsigned int local_ip)\n+{\n+  channel->local_ip4 = local_ip;\n+}\n+\n+/* local_ip6 should be 16 bytes in length */\n+void ares_set_local_ip6(ares_channel channel,\n+                        const unsigned char* local_ip6)\n+{\n+  memcpy(&channel->local_ip6, local_ip6, sizeof(channel->local_ip6));\n+}\n+\n+/* local_dev_name should be null terminated. */\n+void ares_set_local_dev(ares_channel channel,\n+                        const char* local_dev_name)\n+{\n+  strncpy(channel->local_dev_name, local_dev_name,\n+          sizeof(channel->local_dev_name));\n+  channel->local_dev_name[sizeof(channel->local_dev_name) - 1] = 0;\n+}\n+\n+\n+void ares_set_socket_callback(ares_channel channel,\n+                              ares_sock_create_callback cb,\n+                              void *data)\n+{\n+  channel->sock_create_cb = cb;\n+  channel->sock_create_cb_data = data;\n+}\n+\n+void ares__init_servers_state(ares_channel channel)\n+{\n+  struct server_state *server;\n+  int i;\n+\n+  for (i = 0; i < channel->nservers; i++)\n+    {\n+      server = &channel->servers[i];\n+      server->udp_socket = ARES_SOCKET_BAD;\n+      server->tcp_socket = ARES_SOCKET_BAD;\n+      server->tcp_connection_generation = ++channel->tcp_connection_generation;\n+      server->tcp_lenbuf_pos = 0;\n+      server->tcp_buffer_pos = 0;\n+      server->tcp_buffer = NULL;\n+      server->tcp_length = 0;\n+      server->qhead = NULL;\n+      server->qtail = NULL;\n+      ares__init_list_head(&server->queries_to_server);\n+      server->channel = channel;\n+      server->is_broken = 0;\n+    }\n+}"}, {"sha": "6f1022a76f533847fac76852af1b350185c2da96", "filename": "src/rt/libuv/src/ares/ares_ipv6.h", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_ipv6.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_ipv6.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_ipv6.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,78 @@\n+\n+/* Copyright (C) 2005 by Dominick Meglio\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#ifndef ARES_IPV6_H\n+#define ARES_IPV6_H\n+\n+#ifndef HAVE_PF_INET6\n+#define PF_INET6 AF_INET6\n+#endif\n+\n+#ifndef HAVE_STRUCT_SOCKADDR_IN6\n+struct sockaddr_in6\n+{\n+  unsigned short       sin6_family;\n+  unsigned short       sin6_port;\n+  unsigned long        sin6_flowinfo;\n+  struct ares_in6_addr sin6_addr;\n+  unsigned int         sin6_scope_id;\n+};\n+#endif\n+\n+#ifndef HAVE_STRUCT_ADDRINFO\n+struct addrinfo\n+{\n+  int              ai_flags;\n+  int              ai_family;\n+  int              ai_socktype;\n+  int              ai_protocol;\n+  ares_socklen_t   ai_addrlen;   /* Follow rfc3493 struct addrinfo */\n+  char            *ai_canonname;\n+  struct sockaddr *ai_addr;\n+  struct addrinfo *ai_next;\n+};\n+#endif\n+\n+#ifndef NS_IN6ADDRSZ\n+#if SIZEOF_STRUCT_IN6_ADDR == 0\n+/* We cannot have it set to zero, so we pick a fixed value here */\n+#define NS_IN6ADDRSZ 16\n+#else\n+#define NS_IN6ADDRSZ SIZEOF_STRUCT_IN6_ADDR\n+#endif\n+#endif\n+\n+#ifndef NS_INADDRSZ\n+#define NS_INADDRSZ SIZEOF_STRUCT_IN_ADDR\n+#endif\n+\n+#ifndef NS_INT16SZ\n+#define NS_INT16SZ 2\n+#endif\n+\n+#ifndef IF_NAMESIZE\n+#ifdef IFNAMSIZ\n+#define IF_NAMESIZE IFNAMSIZ\n+#else\n+#define IF_NAMESIZE 256\n+#endif\n+#endif\n+\n+/* Defined in ares_net_pton.c for no particular reason. */\n+extern const struct ares_in6_addr ares_in6addr_any; /* :: */\n+\n+\n+#endif /* ARES_IPV6_H */"}, {"sha": "1a875da1504ba91e4303dd1d1758a4a2daa45b80", "filename": "src/rt/libuv/src/ares/ares_library_init.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_library_init.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_library_init.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_library_init.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,132 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ * Copyright (C) 2004-2009 by Daniel Stenberg\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#include \"ares.h\"\n+#include \"ares_library_init.h\"\n+#include \"ares_private.h\"\n+\n+/* library-private global and unique instance vars */\n+\n+#ifdef USE_WINSOCK\n+fpGetNetworkParams_t ares_fpGetNetworkParams = ZERO_NULL;\n+fpSystemFunction036_t ares_fpSystemFunction036 = ZERO_NULL;\n+#endif\n+\n+/* library-private global vars with source visibility restricted to this file */\n+\n+static unsigned int ares_initialized;\n+static int          ares_init_flags;\n+\n+#ifdef USE_WINSOCK\n+static HMODULE hnd_iphlpapi;\n+static HMODULE hnd_advapi32;\n+#endif\n+\n+\n+static int ares_win32_init(void)\n+{\n+#ifdef USE_WINSOCK\n+\n+  hnd_iphlpapi = 0;\n+  hnd_iphlpapi = LoadLibrary(\"iphlpapi.dll\");\n+  if (!hnd_iphlpapi)\n+    return ARES_ELOADIPHLPAPI;\n+\n+  ares_fpGetNetworkParams = (fpGetNetworkParams_t)\n+    GetProcAddress(hnd_iphlpapi, \"GetNetworkParams\");\n+  if (!ares_fpGetNetworkParams)\n+    {\n+      FreeLibrary(hnd_iphlpapi);\n+      return ARES_EADDRGETNETWORKPARAMS;\n+    }\n+\n+  /*\n+   * When advapi32.dll is unavailable or advapi32.dll has no SystemFunction036,\n+   * also known as RtlGenRandom, which is the case for Windows versions prior\n+   * to WinXP then c-ares uses portable rand() function. Then don't error here.\n+   */\n+\n+  hnd_advapi32 = 0;\n+  hnd_advapi32 = LoadLibrary(\"advapi32.dll\");\n+  if (hnd_advapi32)\n+    {\n+      ares_fpSystemFunction036 = (fpSystemFunction036_t)\n+        GetProcAddress(hnd_advapi32, \"SystemFunction036\");\n+    }\n+\n+#endif\n+  return ARES_SUCCESS;\n+}\n+\n+\n+static void ares_win32_cleanup(void)\n+{\n+#ifdef USE_WINSOCK\n+  if (hnd_advapi32)\n+    FreeLibrary(hnd_advapi32);\n+  if (hnd_iphlpapi)\n+    FreeLibrary(hnd_iphlpapi);\n+#endif\n+}\n+\n+\n+int ares_library_init(int flags)\n+{\n+  int res;\n+\n+  if (ares_initialized)\n+    return ARES_SUCCESS;\n+  ares_initialized++;\n+\n+  if (flags & ARES_LIB_INIT_WIN32)\n+    {\n+      res = ares_win32_init();\n+      if (res != ARES_SUCCESS)\n+        return res;\n+    }\n+\n+  ares_init_flags = flags;\n+\n+  return ARES_SUCCESS;\n+}\n+\n+\n+void ares_library_cleanup(void)\n+{\n+  if (!ares_initialized)\n+    return;\n+  ares_initialized--;\n+\n+  if (ares_init_flags & ARES_LIB_INIT_WIN32)\n+    ares_win32_cleanup();\n+\n+  ares_init_flags = ARES_LIB_INIT_NONE;\n+}\n+\n+\n+int ares_library_initialized(void)\n+{\n+#ifdef USE_WINSOCK\n+  if (!ares_initialized)\n+    return ARES_ENOTINITIALIZED;\n+#endif\n+  return ARES_SUCCESS;\n+}\n+\n+"}, {"sha": "29d5c9e73ff73c253274884cb26af1c0f3a3decc", "filename": "src/rt/libuv/src/ares/ares_library_init.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_library_init.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_library_init.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_library_init.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,39 @@\n+#ifndef HEADER_CARES_LIBRARY_INIT_H\n+#define HEADER_CARES_LIBRARY_INIT_H\n+\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ * Copyright (C) 2004-2009 by Daniel Stenberg\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef USE_WINSOCK\n+\n+#include <iphlpapi.h>\n+\n+typedef DWORD (WINAPI *fpGetNetworkParams_t) (FIXED_INFO*, DWORD*);\n+typedef BOOLEAN (APIENTRY *fpSystemFunction036_t) (void*, ULONG);\n+\n+/* Forward-declaration of variables defined in ares_library_init.c */\n+/* that are global and unique instances for whole c-ares library.  */\n+\n+extern fpGetNetworkParams_t ares_fpGetNetworkParams;\n+extern fpSystemFunction036_t ares_fpSystemFunction036;\n+\n+#endif /* USE_WINSOCK */\n+\n+#endif /* HEADER_CARES_LIBRARY_INIT_H */\n+"}, {"sha": "c0acd90a8e8af9fc4b27f95f33d06414fef4103f", "filename": "src/rt/libuv/src/ares/ares_llist.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_llist.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_llist.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_llist.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,86 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#include \"ares.h\"\n+#include \"ares_private.h\"\n+\n+/* Routines for managing doubly-linked circular linked lists with a\n+ * dummy head.\n+ */\n+\n+/* Initialize a new head node */\n+void ares__init_list_head(struct list_node* head) {\n+  head->prev = head;\n+  head->next = head;\n+  head->data = NULL;\n+}\n+\n+/* Initialize a list node */\n+void ares__init_list_node(struct list_node* node, void* d) {\n+  node->prev = NULL;\n+  node->next = NULL;\n+  node->data = d;\n+}\n+\n+/* Returns true iff the given list is empty */\n+int ares__is_list_empty(struct list_node* head) {\n+  return ((head->next == head) && (head->prev == head));\n+}\n+\n+/* Inserts new_node before old_node */\n+void ares__insert_in_list(struct list_node* new_node,\n+                          struct list_node* old_node) {\n+  new_node->next = old_node;\n+  new_node->prev = old_node->prev;\n+  old_node->prev->next = new_node;\n+  old_node->prev = new_node;\n+}\n+\n+/* Removes the node from the list it's in, if any */\n+void ares__remove_from_list(struct list_node* node) {\n+  if (node->next != NULL) {\n+    node->prev->next = node->next;\n+    node->next->prev = node->prev;\n+    node->prev = NULL;\n+    node->next = NULL;\n+  }\n+}\n+\n+/* Swap the contents of two lists */\n+void ares__swap_lists(struct list_node* head_a,\n+                      struct list_node* head_b) {\n+  int is_a_empty = ares__is_list_empty(head_a);\n+  int is_b_empty = ares__is_list_empty(head_b);\n+  struct list_node old_a = *head_a;\n+  struct list_node old_b = *head_b;\n+\n+  if (is_a_empty) {\n+    ares__init_list_head(head_b);\n+  } else {\n+    *head_b = old_a;\n+    old_a.next->prev = head_b;\n+    old_a.prev->next = head_b;\n+  }\n+  if (is_b_empty) {\n+    ares__init_list_head(head_a);\n+  } else {\n+    *head_a = old_b;\n+    old_b.next->prev = head_a;\n+    old_b.prev->next = head_a;\n+  }\n+}"}, {"sha": "b09f0de6d71b48bc69ca48639883cd8e8c0d3b65", "filename": "src/rt/libuv/src/ares/ares_llist.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_llist.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_llist.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_llist.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,42 @@\n+#ifndef __ARES_LLIST_H\n+#define __ARES_LLIST_H\n+\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+\n+/* Node definition for circular, doubly-linked list */\n+struct list_node {\n+  struct list_node *prev;\n+  struct list_node *next;\n+  void* data;\n+};\n+\n+void ares__init_list_head(struct list_node* head);\n+\n+void ares__init_list_node(struct list_node* node, void* d);\n+\n+int ares__is_list_empty(struct list_node* head);\n+\n+void ares__insert_in_list(struct list_node* new_node,\n+                          struct list_node* old_node);\n+\n+void ares__remove_from_list(struct list_node* node);\n+\n+void ares__swap_lists(struct list_node* head_a,\n+                      struct list_node* head_b);\n+\n+#endif /* __ARES_LLIST_H */"}, {"sha": "e33f13ff223216f263dd8e84434e629862d685bc", "filename": "src/rt/libuv/src/ares/ares_mkquery.c", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_mkquery.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_mkquery.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_mkquery.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,195 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n+#  include <arpa/nameser_compat.h>\n+#endif\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include \"ares.h\"\n+#include \"ares_dns.h\"\n+#include \"ares_private.h\"\n+\n+/* Header format, from RFC 1035:\n+ *                                  1  1  1  1  1  1\n+ *    0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n+ *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n+ *  |                      ID                       |\n+ *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n+ *  |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\n+ *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n+ *  |                    QDCOUNT                    |\n+ *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n+ *  |                    ANCOUNT                    |\n+ *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n+ *  |                    NSCOUNT                    |\n+ *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n+ *  |                    ARCOUNT                    |\n+ *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n+ *\n+ * AA, TC, RA, and RCODE are only set in responses.  Brief description\n+ * of the remaining fields:\n+ *      ID      Identifier to match responses with queries\n+ *      QR      Query (0) or response (1)\n+ *      Opcode  For our purposes, always QUERY\n+ *      RD      Recursion desired\n+ *      Z       Reserved (zero)\n+ *      QDCOUNT Number of queries\n+ *      ANCOUNT Number of answers\n+ *      NSCOUNT Number of name server records\n+ *      ARCOUNT Number of additional records\n+ *\n+ * Question format, from RFC 1035:\n+ *                                  1  1  1  1  1  1\n+ *    0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n+ *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n+ *  |                                               |\n+ *  /                     QNAME                     /\n+ *  /                                               /\n+ *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n+ *  |                     QTYPE                     |\n+ *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n+ *  |                     QCLASS                    |\n+ *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n+ *\n+ * The query name is encoded as a series of labels, each represented\n+ * as a one-byte length (maximum 63) followed by the text of the\n+ * label.  The list is terminated by a label of length zero (which can\n+ * be thought of as the root domain).\n+ */\n+\n+int ares_mkquery(const char *name, int dnsclass, int type, unsigned short id,\n+                 int rd, unsigned char **buf, int *buflen)\n+{\n+  int len;\n+  unsigned char *q;\n+  const char *p;\n+\n+  /* Set our results early, in case we bail out early with an error. */\n+  *buflen = 0;\n+  *buf = NULL;\n+\n+  /* Compute the length of the encoded name so we can check buflen.\n+   * Start counting at 1 for the zero-length label at the end. */\n+  len = 1;\n+  for (p = name; *p; p++)\n+    {\n+      if (*p == '\\\\' && *(p + 1) != 0)\n+        p++;\n+      len++;\n+    }\n+  /* If there are n periods in the name, there are n + 1 labels, and\n+   * thus n + 1 length fields, unless the name is empty or ends with a\n+   * period.  So add 1 unless name is empty or ends with a period.\n+   */\n+  if (*name && *(p - 1) != '.')\n+    len++;\n+\n+  /* Immediately reject names that are longer than the maximum of 255\n+   * bytes that's specified in RFC 1035 (\"To simplify implementations,\n+   * the total length of a domain name (i.e., label octets and label\n+   * length octets) is restricted to 255 octets or less.\"). We aren't\n+   * doing this just to be a stickler about RFCs. For names that are\n+   * too long, 'dnscache' closes its TCP connection to us immediately\n+   * (when using TCP) and ignores the request when using UDP, and\n+   * BIND's named returns ServFail (TCP or UDP). Sending a request\n+   * that we know will cause 'dnscache' to close the TCP connection is\n+   * painful, since that makes any other outstanding requests on that\n+   * connection fail. And sending a UDP request that we know\n+   * 'dnscache' will ignore is bad because resources will be tied up\n+   * until we time-out the request.\n+   */\n+  if (len > MAXCDNAME)\n+    return ARES_EBADNAME;\n+\n+  *buflen = len + HFIXEDSZ + QFIXEDSZ;\n+  *buf = malloc(*buflen);\n+  if (!*buf)\n+      return ARES_ENOMEM;\n+\n+  /* Set up the header. */\n+  q = *buf;\n+  memset(q, 0, HFIXEDSZ);\n+  DNS_HEADER_SET_QID(q, id);\n+  DNS_HEADER_SET_OPCODE(q, QUERY);\n+  if (rd) {\n+    DNS_HEADER_SET_RD(q, 1);\n+  }\n+  else {\n+    DNS_HEADER_SET_RD(q, 0);\n+  }\n+  DNS_HEADER_SET_QDCOUNT(q, 1);\n+\n+  /* A name of \".\" is a screw case for the loop below, so adjust it. */\n+  if (strcmp(name, \".\") == 0)\n+    name++;\n+\n+  /* Start writing out the name after the header. */\n+  q += HFIXEDSZ;\n+  while (*name)\n+    {\n+      if (*name == '.')\n+        return ARES_EBADNAME;\n+\n+      /* Count the number of bytes in this label. */\n+      len = 0;\n+      for (p = name; *p && *p != '.'; p++)\n+        {\n+          if (*p == '\\\\' && *(p + 1) != 0)\n+            p++;\n+          len++;\n+        }\n+      if (len > MAXLABEL)\n+        return ARES_EBADNAME;\n+\n+      /* Encode the length and copy the data. */\n+      *q++ = (unsigned char)len;\n+      for (p = name; *p && *p != '.'; p++)\n+        {\n+          if (*p == '\\\\' && *(p + 1) != 0)\n+            p++;\n+          *q++ = *p;\n+        }\n+\n+      /* Go to the next label and repeat, unless we hit the end. */\n+      if (!*p)\n+        break;\n+      name = p + 1;\n+    }\n+\n+  /* Add the zero-length label at the end. */\n+  *q++ = 0;\n+\n+  /* Finish off the question with the type and class. */\n+  DNS_QUESTION_SET_TYPE(q, type);\n+  DNS_QUESTION_SET_CLASS(q, dnsclass);\n+\n+  return ARES_SUCCESS;\n+}"}, {"sha": "52d079e6409ea51a16f5af9e622d0cd9303b4ce8", "filename": "src/rt/libuv/src/ares/ares_nowarn.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_nowarn.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_nowarn.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_nowarn.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,59 @@\n+\n+/* Copyright (C) 2010 by Daniel Stenberg\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+\n+#include \"ares_setup.h\"\n+\n+#include \"ares_nowarn.h\"\n+\n+#define CARES_MASK_UINT (~(unsigned int) 0)\n+#define CARES_MASK_SINT (CARES_MASK_UINT >> 1)\n+\n+/*\n+** size_t to signed int\n+*/\n+\n+int aresx_uztosi(size_t uznum)\n+{\n+#ifdef __INTEL_COMPILER\n+#  pragma warning(push)\n+#  pragma warning(disable:810) /* conversion may lose significant bits */\n+#endif\n+\n+  return (int)(uznum & (size_t) CARES_MASK_SINT);\n+\n+#ifdef __INTEL_COMPILER\n+#  pragma warning(pop)\n+#endif\n+}\n+\n+/*\n+** signed long to signed int\n+*/\n+\n+int aresx_sltosi(long slnum)\n+{\n+#ifdef __INTEL_COMPILER\n+#  pragma warning(push)\n+#  pragma warning(disable:810) /* conversion may lose significant bits */\n+#endif\n+\n+  return (int)(slnum & (long) CARES_MASK_SINT);\n+\n+#ifdef __INTEL_COMPILER\n+#  pragma warning(pop)\n+#endif\n+}"}, {"sha": "fb804951065ccdae13b831ec27564f00d41390df", "filename": "src/rt/libuv/src/ares/ares_nowarn.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_nowarn.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_nowarn.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_nowarn.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,24 @@\n+#ifndef HEADER_CARES_NOWARN_H\n+#define HEADER_CARES_NOWARN_H\n+\n+\n+/* Copyright (C) 2010 by Daniel Stenberg\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+int aresx_uztosi(size_t uznum);\n+\n+int aresx_sltosi(long slnum);\n+\n+#endif /* HEADER_CARES_NOWARN_H */"}, {"sha": "70280526869500a55b55bf4e211d5d36fba4d7e9", "filename": "src/rt/libuv/src/ares/ares_options.c", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_options.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_options.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_options.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,253 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ * Copyright (C) 2008-2010 by Daniel Stenberg\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_ARPA_INET_H\n+#  include <arpa/inet.h>\n+#endif\n+\n+#include \"ares.h\"\n+#include \"ares_data.h\"\n+#include \"inet_net_pton.h\"\n+#include \"ares_private.h\"\n+\n+\n+int ares_get_servers(ares_channel channel,\n+                     struct ares_addr_node **servers)\n+{\n+  struct ares_addr_node *srvr_head = NULL;\n+  struct ares_addr_node *srvr_last = NULL;\n+  struct ares_addr_node *srvr_curr;\n+  int status = ARES_SUCCESS;\n+  int i;\n+\n+  if (!channel)\n+    return ARES_ENODATA;\n+\n+  for (i = 0; i < channel->nservers; i++)\n+    {\n+      /* Allocate storage for this server node appending it to the list */\n+      srvr_curr = ares_malloc_data(ARES_DATATYPE_ADDR_NODE);\n+      if (!srvr_curr)\n+        {\n+          status = ARES_ENOMEM;\n+          break;\n+        }\n+      if (srvr_last)\n+        {\n+          srvr_last->next = srvr_curr;\n+        }\n+      else\n+        {\n+          srvr_head = srvr_curr;\n+        }\n+      srvr_last = srvr_curr;\n+\n+      /* Fill this server node data */\n+      srvr_curr->family = channel->servers[i].addr.family;\n+      if (srvr_curr->family == AF_INET)\n+        memcpy(&srvr_curr->addrV4, &channel->servers[i].addr.addrV4,\n+               sizeof(srvr_curr->addrV4));\n+      else\n+        memcpy(&srvr_curr->addrV6, &channel->servers[i].addr.addrV6,\n+               sizeof(srvr_curr->addrV6));\n+    }\n+\n+  if (status != ARES_SUCCESS)\n+    {\n+      if (srvr_head)\n+        {\n+          ares_free_data(srvr_head);\n+          srvr_head = NULL;\n+        }\n+    }\n+\n+  *servers = srvr_head;\n+\n+  return status;\n+}\n+\n+\n+int ares_set_servers(ares_channel channel,\n+                     struct ares_addr_node *servers)\n+{\n+  struct ares_addr_node *srvr;\n+  int num_srvrs = 0;\n+  int i;\n+\n+  if (ares_library_initialized() != ARES_SUCCESS)\n+    return ARES_ENOTINITIALIZED;\n+\n+  if (!channel)\n+    return ARES_ENODATA;\n+\n+  ares__destroy_servers_state(channel);\n+\n+  for (srvr = servers; srvr; srvr = srvr->next)\n+    {\n+      num_srvrs++;\n+    }\n+\n+  if (num_srvrs > 0)\n+    {\n+      /* Allocate storage for servers state */\n+      channel->servers = malloc(num_srvrs * sizeof(struct server_state));\n+      if (!channel->servers)\n+        {\n+          return ARES_ENOMEM;\n+        }\n+      channel->nservers = num_srvrs;\n+      /* Fill servers state address data */\n+      for (i = 0, srvr = servers; srvr; i++, srvr = srvr->next)\n+        {\n+          channel->servers[i].addr.family = srvr->family;\n+          if (srvr->family == AF_INET)\n+            memcpy(&channel->servers[i].addr.addrV4, &srvr->addrV4,\n+                   sizeof(srvr->addrV4));\n+          else\n+            memcpy(&channel->servers[i].addr.addrV6, &srvr->addrV6,\n+                   sizeof(srvr->addrV6));\n+        }\n+      /* Initialize servers state remaining data */\n+      ares__init_servers_state(channel);\n+    }\n+\n+  return ARES_SUCCESS;\n+}\n+\n+/* Incomming string format: host[:port][,host[:port]]... */\n+int ares_set_servers_csv(ares_channel channel,\n+                         const char* _csv)\n+{\n+  int i;\n+  char* csv = NULL;\n+  char* ptr;\n+  char* start_host;\n+  long port;\n+  bool found_port;\n+  int rv = ARES_SUCCESS;\n+  struct ares_addr_node *servers = NULL;\n+  struct ares_addr_node *last = NULL;\n+\n+  if (ares_library_initialized() != ARES_SUCCESS)\n+    return ARES_ENOTINITIALIZED;\n+\n+  if (!channel)\n+    return ARES_ENODATA;\n+\n+  ares__destroy_servers_state(channel);\n+\n+  i = strlen(_csv);\n+  if (i == 0)\n+     return ARES_SUCCESS; /* blank all servers */\n+\n+  csv = malloc(i + 2);\n+  strcpy(csv, _csv);\n+  if (csv[i-1] != ',') { /* make parsing easier by ensuring ending ',' */\n+    csv[i] = ',';\n+    csv[i+1] = 0;\n+  }\n+\n+  start_host = csv;\n+  found_port = false;\n+  for (ptr = csv; *ptr; ptr++) {\n+    if (*ptr == ',') {\n+      char* pp = ptr - 1;\n+      struct in_addr in4;\n+      struct ares_in6_addr in6;\n+      struct ares_addr_node *s = NULL;\n+\n+      *ptr = 0; /* null terminate host:port string */\n+      /* Got an entry..see if port was specified. */\n+      while (pp > start_host) {\n+        if (*pp == ':')\n+          break; /* yes */\n+        if (!ISDIGIT(*pp)) {\n+          /* Found end of digits before we found :, so wasn't a port */\n+          pp = ptr;\n+          break;\n+        }\n+        pp--;\n+      }\n+      if ((pp != start_host) && ((pp + 1) < ptr)) {\n+        /* Found it. */\n+        found_port = true;\n+        port = strtol(pp + 1, NULL, 10);\n+        *pp = 0; /* null terminate host */\n+      }\n+      /* resolve host, try ipv4 first, rslt is in network byte order */\n+      rv = ares_inet_pton(AF_INET, start_host, &in4);\n+      if (!rv) {\n+        /* Ok, try IPv6 then */\n+        rv = ares_inet_pton(AF_INET6, start_host, &in6);\n+        if (!rv) {\n+          rv = ARES_EBADSTR;\n+          goto out;\n+        }\n+        /* was ipv6, add new server */\n+        s = malloc(sizeof(*s));\n+        if (!s) {\n+          rv = ARES_ENOMEM;\n+          goto out;\n+        }\n+        s->family = AF_INET6;\n+        memcpy(&s->addr, &in6, sizeof(struct ares_in6_addr));\n+      }\n+      else {\n+        /* was ipv4, add new server */\n+        s = malloc(sizeof(*s));\n+        if (!s) {\n+          rv = ARES_ENOMEM;\n+          goto out;\n+        }\n+        s->family = AF_INET;\n+        memcpy(&s->addr, &in4, sizeof(struct in_addr));\n+      }\n+      if (s) {\n+        /* TODO:  Add port to ares_addr_node and assign it here. */\n+\n+        s->next = NULL;\n+        if (last) {\n+          last->next = s;\n+        }\n+        else {\n+          servers = s;\n+          last = s;\n+        }\n+      }\n+\n+      /* Set up for next one */\n+      found_port = false;\n+      start_host = ptr + 1;\n+    }\n+  }\n+\n+  rv = ares_set_servers(channel, servers);\n+\n+  out:\n+  if (csv)\n+    free(csv);\n+  while (servers) {\n+    struct ares_addr_node *s = servers;\n+    servers = servers->next;\n+    free(s);\n+  }\n+\n+  return rv;\n+}"}, {"sha": "93012549c90f471fb4caa35478fd98067ea142e0", "filename": "src/rt/libuv/src/ares/ares_parse_a_reply.c", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_a_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_a_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_a_reply.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,258 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_NETDB_H\n+#  include <netdb.h>\n+#endif\n+#ifdef HAVE_ARPA_INET_H\n+#  include <arpa/inet.h>\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n+#  include <arpa/nameser_compat.h>\n+#endif\n+\n+#ifdef HAVE_STRINGS_H\n+#  include <strings.h>\n+#endif\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#ifdef HAVE_LIMITS_H\n+#  include <limits.h>\n+#endif\n+\n+#include \"ares.h\"\n+#include \"ares_dns.h\"\n+#include \"ares_private.h\"\n+\n+int ares_parse_a_reply(const unsigned char *abuf, int alen,\n+                       struct hostent **host,\n+                       struct ares_addrttl *addrttls, int *naddrttls)\n+{\n+  unsigned int qdcount, ancount;\n+  int status, i, rr_type, rr_class, rr_len, rr_ttl, naddrs;\n+  int cname_ttl = INT_MAX;  /* the TTL imposed by the CNAME chain */\n+  int naliases;\n+  long len;\n+  const unsigned char *aptr;\n+  char *hostname, *rr_name, *rr_data, **aliases;\n+  struct in_addr *addrs;\n+  struct hostent *hostent;\n+  const int max_addr_ttls = (addrttls && naddrttls) ? *naddrttls : 0;\n+\n+  /* Set *host to NULL for all failure cases. */\n+  if (host)\n+    *host = NULL;\n+  /* Same with *naddrttls. */\n+  if (naddrttls)\n+    *naddrttls = 0;\n+\n+  /* Give up if abuf doesn't have room for a header. */\n+  if (alen < HFIXEDSZ)\n+    return ARES_EBADRESP;\n+\n+  /* Fetch the question and answer count from the header. */\n+  qdcount = DNS_HEADER_QDCOUNT(abuf);\n+  ancount = DNS_HEADER_ANCOUNT(abuf);\n+  if (qdcount != 1)\n+    return ARES_EBADRESP;\n+\n+  /* Expand the name from the question, and skip past the question. */\n+  aptr = abuf + HFIXEDSZ;\n+  status = ares__expand_name_for_response(aptr, abuf, alen, &hostname, &len);\n+  if (status != ARES_SUCCESS)\n+    return status;\n+  if (aptr + len + QFIXEDSZ > abuf + alen)\n+    {\n+      free(hostname);\n+      return ARES_EBADRESP;\n+    }\n+  aptr += len + QFIXEDSZ;\n+\n+  if (host)\n+    {\n+      /* Allocate addresses and aliases; ancount gives an upper bound for\n+         both. */\n+      addrs = malloc(ancount * sizeof(struct in_addr));\n+      if (!addrs)\n+        {\n+          free(hostname);\n+          return ARES_ENOMEM;\n+        }\n+      aliases = malloc((ancount + 1) * sizeof(char *));\n+      if (!aliases)\n+        {\n+          free(hostname);\n+          free(addrs);\n+          return ARES_ENOMEM;\n+        }\n+    }\n+  else\n+    {\n+      addrs = NULL;\n+      aliases = NULL;\n+    }\n+\n+  naddrs = 0;\n+  naliases = 0;\n+\n+  /* Examine each answer resource record (RR) in turn. */\n+  for (i = 0; i < (int)ancount; i++)\n+    {\n+      /* Decode the RR up to the data field. */\n+      status = ares__expand_name_for_response(aptr, abuf, alen, &rr_name, &len);\n+      if (status != ARES_SUCCESS)\n+        break;\n+      aptr += len;\n+      if (aptr + RRFIXEDSZ > abuf + alen)\n+        {\n+          status = ARES_EBADRESP;\n+          break;\n+        }\n+      rr_type = DNS_RR_TYPE(aptr);\n+      rr_class = DNS_RR_CLASS(aptr);\n+      rr_len = DNS_RR_LEN(aptr);\n+      rr_ttl = DNS_RR_TTL(aptr);\n+      aptr += RRFIXEDSZ;\n+\n+      if (rr_class == C_IN && rr_type == T_A\n+          && rr_len == sizeof(struct in_addr)\n+          && strcasecmp(rr_name, hostname) == 0)\n+        {\n+          if (addrs)\n+            {\n+              if (aptr + sizeof(struct in_addr) > abuf + alen)\n+              {\n+                status = ARES_EBADRESP;\n+                break;\n+              }\n+              memcpy(&addrs[naddrs], aptr, sizeof(struct in_addr));\n+            }\n+          if (naddrs < max_addr_ttls)\n+            {\n+              struct ares_addrttl * const at = &addrttls[naddrs];\n+              if (aptr + sizeof(struct in_addr) > abuf + alen)\n+              {\n+                status = ARES_EBADRESP;\n+                break;\n+              }\n+              memcpy(&at->ipaddr, aptr,  sizeof(struct in_addr));\n+              at->ttl = rr_ttl;\n+            }\n+          naddrs++;\n+          status = ARES_SUCCESS;\n+        }\n+\n+      if (rr_class == C_IN && rr_type == T_CNAME)\n+        {\n+          /* Record the RR name as an alias. */\n+          if (aliases)\n+            aliases[naliases] = rr_name;\n+          else\n+            free(rr_name);\n+          naliases++;\n+\n+          /* Decode the RR data and replace the hostname with it. */\n+          status = ares__expand_name_for_response(aptr, abuf, alen, &rr_data,\n+                                                  &len);\n+          if (status != ARES_SUCCESS)\n+            break;\n+          free(hostname);\n+          hostname = rr_data;\n+\n+          /* Take the min of the TTLs we see in the CNAME chain. */\n+          if (cname_ttl > rr_ttl)\n+            cname_ttl = rr_ttl;\n+        }\n+      else\n+        free(rr_name);\n+\n+      aptr += rr_len;\n+      if (aptr > abuf + alen)\n+        {\n+          status = ARES_EBADRESP;\n+          break;\n+        }\n+    }\n+\n+  if (status == ARES_SUCCESS && naddrs == 0 && naliases == 0)\n+    /* the check for naliases to be zero is to make sure CNAME responses\n+       don't get caught here */\n+    status = ARES_ENODATA;\n+  if (status == ARES_SUCCESS)\n+    {\n+      /* We got our answer. */\n+      if (naddrttls)\n+        {\n+          const int n = naddrs < max_addr_ttls ? naddrs : max_addr_ttls;\n+          for (i = 0; i < n; i++)\n+            {\n+              /* Ensure that each A TTL is no larger than the CNAME TTL. */\n+              if (addrttls[i].ttl > cname_ttl)\n+                addrttls[i].ttl = cname_ttl;\n+            }\n+          *naddrttls = n;\n+        }\n+      if (aliases)\n+        aliases[naliases] = NULL;\n+      if (host)\n+        {\n+          /* Allocate memory to build the host entry. */\n+          hostent = malloc(sizeof(struct hostent));\n+          if (hostent)\n+            {\n+              hostent->h_addr_list = malloc((naddrs + 1) * sizeof(char *));\n+              if (hostent->h_addr_list)\n+                {\n+                  /* Fill in the hostent and return successfully. */\n+                  hostent->h_name = hostname;\n+                  hostent->h_aliases = aliases;\n+                  hostent->h_addrtype = AF_INET;\n+                  hostent->h_length = sizeof(struct in_addr);\n+                  for (i = 0; i < naddrs; i++)\n+                    hostent->h_addr_list[i] = (char *) &addrs[i];\n+                  hostent->h_addr_list[naddrs] = NULL;\n+                  *host = hostent;\n+                  return ARES_SUCCESS;\n+                }\n+              free(hostent);\n+            }\n+          status = ARES_ENOMEM;\n+        }\n+     }\n+  if (aliases)\n+    {\n+      for (i = 0; i < naliases; i++)\n+        free(aliases[i]);\n+      free(aliases);\n+    }\n+  free(addrs);\n+  free(hostname);\n+  return status;\n+}"}, {"sha": "a0f524daa5f523e2ad4b17bc1aaa027c5990e52d", "filename": "src/rt/libuv/src/ares/ares_parse_aaaa_reply.c", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_aaaa_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_aaaa_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_aaaa_reply.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,256 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ * Copyright 2005 Dominick Meglio\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_NETDB_H\n+#  include <netdb.h>\n+#endif\n+#ifdef HAVE_ARPA_INET_H\n+#  include <arpa/inet.h>\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n+#  include <arpa/nameser_compat.h>\n+#endif\n+\n+#ifdef HAVE_STRINGS_H\n+#  include <strings.h>\n+#endif\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#ifdef HAVE_LIMITS_H\n+#  include <limits.h>\n+#endif\n+\n+#include \"ares.h\"\n+#include \"ares_dns.h\"\n+#include \"inet_net_pton.h\"\n+#include \"ares_private.h\"\n+\n+int ares_parse_aaaa_reply(const unsigned char *abuf, int alen,\n+                          struct hostent **host, struct ares_addr6ttl *addrttls,\n+                          int *naddrttls)\n+{\n+  unsigned int qdcount, ancount;\n+  int status, i, rr_type, rr_class, rr_len, rr_ttl, naddrs;\n+  int cname_ttl = INT_MAX;  /* the TTL imposed by the CNAME chain */\n+  int naliases;\n+  long len;\n+  const unsigned char *aptr;\n+  char *hostname, *rr_name, *rr_data, **aliases;\n+  struct ares_in6_addr *addrs;\n+  struct hostent *hostent;\n+  const int max_addr_ttls = (addrttls && naddrttls) ? *naddrttls : 0;\n+\n+  /* Set *host to NULL for all failure cases. */\n+  if (host)\n+    *host = NULL;\n+  /* Same with *naddrttls. */\n+  if (naddrttls)\n+    *naddrttls = 0;\n+\n+  /* Give up if abuf doesn't have room for a header. */\n+  if (alen < HFIXEDSZ)\n+    return ARES_EBADRESP;\n+\n+  /* Fetch the question and answer count from the header. */\n+  qdcount = DNS_HEADER_QDCOUNT(abuf);\n+  ancount = DNS_HEADER_ANCOUNT(abuf);\n+  if (qdcount != 1)\n+    return ARES_EBADRESP;\n+\n+  /* Expand the name from the question, and skip past the question. */\n+  aptr = abuf + HFIXEDSZ;\n+  status = ares__expand_name_for_response(aptr, abuf, alen, &hostname, &len);\n+  if (status != ARES_SUCCESS)\n+    return status;\n+  if (aptr + len + QFIXEDSZ > abuf + alen)\n+    {\n+      free(hostname);\n+      return ARES_EBADRESP;\n+    }\n+  aptr += len + QFIXEDSZ;\n+\n+  /* Allocate addresses and aliases; ancount gives an upper bound for both. */\n+  if (host)\n+    {\n+      addrs = malloc(ancount * sizeof(struct ares_in6_addr));\n+      if (!addrs)\n+        {\n+          free(hostname);\n+          return ARES_ENOMEM;\n+        }\n+      aliases = malloc((ancount + 1) * sizeof(char *));\n+      if (!aliases)\n+        {\n+          free(hostname);\n+          free(addrs);\n+          return ARES_ENOMEM;\n+        }\n+    }\n+  else\n+    {\n+      addrs = NULL;\n+      aliases = NULL;\n+    }\n+  naddrs = 0;\n+  naliases = 0;\n+\n+  /* Examine each answer resource record (RR) in turn. */\n+  for (i = 0; i < (int)ancount; i++)\n+    {\n+      /* Decode the RR up to the data field. */\n+      status = ares__expand_name_for_response(aptr, abuf, alen, &rr_name, &len);\n+      if (status != ARES_SUCCESS)\n+        break;\n+      aptr += len;\n+      if (aptr + RRFIXEDSZ > abuf + alen)\n+        {\n+          status = ARES_EBADRESP;\n+          break;\n+        }\n+      rr_type = DNS_RR_TYPE(aptr);\n+      rr_class = DNS_RR_CLASS(aptr);\n+      rr_len = DNS_RR_LEN(aptr);\n+      rr_ttl = DNS_RR_TTL(aptr);\n+      aptr += RRFIXEDSZ;\n+\n+      if (rr_class == C_IN && rr_type == T_AAAA\n+          && rr_len == sizeof(struct ares_in6_addr)\n+          && strcasecmp(rr_name, hostname) == 0)\n+        {\n+          if (addrs)\n+            {\n+              if (aptr + sizeof(struct ares_in6_addr) > abuf + alen)\n+              {\n+                status = ARES_EBADRESP;\n+                break;\n+              }\n+              memcpy(&addrs[naddrs], aptr, sizeof(struct ares_in6_addr));\n+            }\n+          if (naddrs < max_addr_ttls)\n+            {\n+              struct ares_addr6ttl * const at = &addrttls[naddrs];\n+              if (aptr + sizeof(struct ares_in6_addr) > abuf + alen)\n+              {\n+                status = ARES_EBADRESP;\n+                break;\n+              }\n+              memcpy(&at->ip6addr, aptr,  sizeof(struct ares_in6_addr));\n+              at->ttl = rr_ttl;\n+            }\n+          naddrs++;\n+          status = ARES_SUCCESS;\n+        }\n+\n+      if (rr_class == C_IN && rr_type == T_CNAME)\n+        {\n+          /* Record the RR name as an alias. */\n+          if (aliases)\n+            aliases[naliases] = rr_name;\n+          else\n+            free(rr_name);\n+          naliases++;\n+\n+          /* Decode the RR data and replace the hostname with it. */\n+          status = ares__expand_name_for_response(aptr, abuf, alen, &rr_data,\n+                                                  &len);\n+          if (status != ARES_SUCCESS)\n+            break;\n+          free(hostname);\n+          hostname = rr_data;\n+\n+          /* Take the min of the TTLs we see in the CNAME chain. */\n+          if (cname_ttl > rr_ttl)\n+            cname_ttl = rr_ttl;\n+        }\n+      else\n+        free(rr_name);\n+\n+      aptr += rr_len;\n+      if (aptr > abuf + alen)\n+        {\n+          status = ARES_EBADRESP;\n+          break;\n+        }\n+    }\n+\n+  if (status == ARES_SUCCESS && naddrs == 0)\n+    status = ARES_ENODATA;\n+  if (status == ARES_SUCCESS)\n+    {\n+      /* We got our answer. */\n+      if (naddrttls)\n+        {\n+          const int n = naddrs < max_addr_ttls ? naddrs : max_addr_ttls;\n+          for (i = 0; i < n; i++)\n+            {\n+              /* Ensure that each A TTL is no larger than the CNAME TTL. */\n+              if (addrttls[i].ttl > cname_ttl)\n+                addrttls[i].ttl = cname_ttl;\n+            }\n+          *naddrttls = n;\n+        }\n+      if (aliases)\n+        aliases[naliases] = NULL;\n+      if (host)\n+        {\n+          /* Allocate memory to build the host entry. */\n+          hostent = malloc(sizeof(struct hostent));\n+          if (hostent)\n+            {\n+              hostent->h_addr_list = malloc((naddrs + 1) * sizeof(char *));\n+              if (hostent->h_addr_list)\n+                {\n+                  /* Fill in the hostent and return successfully. */\n+                  hostent->h_name = hostname;\n+                  hostent->h_aliases = aliases;\n+                  hostent->h_addrtype = AF_INET6;\n+                  hostent->h_length = sizeof(struct ares_in6_addr);\n+                  for (i = 0; i < naddrs; i++)\n+                    hostent->h_addr_list[i] = (char *) &addrs[i];\n+                  hostent->h_addr_list[naddrs] = NULL;\n+                  *host = hostent;\n+                  return ARES_SUCCESS;\n+                }\n+              free(hostent);\n+            }\n+          status = ARES_ENOMEM;\n+        }\n+    }\n+  if (aliases)\n+    {\n+      for (i = 0; i < naliases; i++)\n+        free(aliases[i]);\n+      free(aliases);\n+    }\n+  free(addrs);\n+  free(hostname);\n+  return status;\n+}"}, {"sha": "186ddd348d75a271796a9527569a465cace3c706", "filename": "src/rt/libuv/src/ares/ares_parse_mx_reply.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_mx_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_mx_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_mx_reply.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,170 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ * Copyright (C) 2010 Jeremy Lal <kapouer@melix.org>\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_NETDB_H\n+#  include <netdb.h>\n+#endif\n+#ifdef HAVE_ARPA_INET_H\n+#  include <arpa/inet.h>\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n+#  include <arpa/nameser_compat.h>\n+#endif\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include \"ares.h\"\n+#include \"ares_dns.h\"\n+#include \"ares_data.h\"\n+#include \"ares_private.h\"\n+\n+int\n+ares_parse_mx_reply (const unsigned char *abuf, int alen,\n+                      struct ares_mx_reply **mx_out)\n+{\n+  unsigned int qdcount, ancount, i;\n+  const unsigned char *aptr, *vptr;\n+  int status, rr_type, rr_class, rr_len;\n+  long len;\n+  char *hostname = NULL, *rr_name = NULL;\n+  struct ares_mx_reply *mx_head = NULL;\n+  struct ares_mx_reply *mx_last = NULL;\n+  struct ares_mx_reply *mx_curr;\n+\n+  /* Set *mx_out to NULL for all failure cases. */\n+  *mx_out = NULL;\n+\n+  /* Give up if abuf doesn't have room for a header. */\n+  if (alen < HFIXEDSZ)\n+    return ARES_EBADRESP;\n+\n+  /* Fetch the question and answer count from the header. */\n+  qdcount = DNS_HEADER_QDCOUNT (abuf);\n+  ancount = DNS_HEADER_ANCOUNT (abuf);\n+  if (qdcount != 1)\n+    return ARES_EBADRESP;\n+  if (ancount == 0)\n+    return ARES_ENODATA;\n+\n+  /* Expand the name from the question, and skip past the question. */\n+  aptr = abuf + HFIXEDSZ;\n+  status = ares_expand_name (aptr, abuf, alen, &hostname, &len);\n+  if (status != ARES_SUCCESS)\n+    return status;\n+\n+  if (aptr + len + QFIXEDSZ > abuf + alen)\n+    {\n+      free (hostname);\n+      return ARES_EBADRESP;\n+    }\n+  aptr += len + QFIXEDSZ;\n+\n+  /* Examine each answer resource record (RR) in turn. */\n+  for (i = 0; i < ancount; i++)\n+    {\n+      /* Decode the RR up to the data field. */\n+      status = ares_expand_name (aptr, abuf, alen, &rr_name, &len);\n+      if (status != ARES_SUCCESS)\n+        {\n+          break;\n+        }\n+      aptr += len;\n+      if (aptr + RRFIXEDSZ > abuf + alen)\n+        {\n+          status = ARES_EBADRESP;\n+          break;\n+        }\n+      rr_type = DNS_RR_TYPE (aptr);\n+      rr_class = DNS_RR_CLASS (aptr);\n+      rr_len = DNS_RR_LEN (aptr);\n+      aptr += RRFIXEDSZ;\n+\n+      /* Check if we are really looking at a MX record */\n+      if (rr_class == C_IN && rr_type == T_MX)\n+        {\n+          /* parse the MX record itself */\n+          if (rr_len < 2)\n+            {\n+              status = ARES_EBADRESP;\n+              break;\n+            }\n+\n+          /* Allocate storage for this MX answer appending it to the list */\n+          mx_curr = ares_malloc_data(ARES_DATATYPE_MX_REPLY);\n+          if (!mx_curr)\n+            {\n+              status = ARES_ENOMEM;\n+              break;\n+            }\n+          if (mx_last)\n+            {\n+              mx_last->next = mx_curr;\n+            }\n+          else\n+            {\n+              mx_head = mx_curr;\n+            }\n+          mx_last = mx_curr;\n+\n+          vptr = aptr;\n+          mx_curr->priority = ntohs (*((unsigned short *)vptr));\n+          vptr += sizeof(unsigned short);\n+\n+          status = ares_expand_name (vptr, abuf, alen, &mx_curr->host, &len);\n+          if (status != ARES_SUCCESS)\n+            break;\n+        }\n+\n+      /* Don't lose memory in the next iteration */\n+      free (rr_name);\n+      rr_name = NULL;\n+\n+      /* Move on to the next record */\n+      aptr += rr_len;\n+    }\n+\n+  if (hostname)\n+    free (hostname);\n+  if (rr_name)\n+    free (rr_name);\n+\n+  /* clean up on error */\n+  if (status != ARES_SUCCESS)\n+    {\n+      if (mx_head)\n+        ares_free_data (mx_head);\n+      return status;\n+    }\n+\n+  /* everything looks fine, return the data */\n+  *mx_out = mx_head;\n+\n+  return ARES_SUCCESS;\n+}"}, {"sha": "25c632994a5233c74e1ca94c2e2b617065d0fd72", "filename": "src/rt/libuv/src/ares/ares_parse_ns_reply.c", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_ns_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_ns_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_ns_reply.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,182 @@\n+/* $Id */\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+/*\n+ * ares_parse_ns_reply created by Vlad Dinulescu <vlad.dinulescu@avira.com>\n+ *      on behalf of AVIRA Gmbh - http://www.avira.com\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_NETDB_H\n+#  include <netdb.h>\n+#endif\n+#ifdef HAVE_ARPA_INET_H\n+#  include <arpa/inet.h>\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n+#  include <arpa/nameser_compat.h>\n+#endif\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include \"ares.h\"\n+#include \"ares_dns.h\"\n+#include \"ares_private.h\"\n+\n+int ares_parse_ns_reply( const unsigned char* abuf, int alen,\n+                         struct hostent** host )\n+{\n+  unsigned int qdcount, ancount;\n+  int status, i, rr_type, rr_class, rr_len;\n+  int nameservers_num;\n+  long len;\n+  const unsigned char *aptr;\n+  char* hostname, *rr_name, *rr_data, **nameservers;\n+  struct hostent *hostent;\n+\n+  /* Set *host to NULL for all failure cases. */\n+  *host = NULL;\n+\n+  /* Give up if abuf doesn't have room for a header. */\n+  if ( alen < HFIXEDSZ )\n+    return ARES_EBADRESP;\n+\n+  /* Fetch the question and answer count from the header. */\n+  qdcount = DNS_HEADER_QDCOUNT( abuf );\n+  ancount = DNS_HEADER_ANCOUNT( abuf );\n+  if ( qdcount != 1 )\n+    return ARES_EBADRESP;\n+\n+  /* Expand the name from the question, and skip past the question. */\n+  aptr = abuf + HFIXEDSZ;\n+  status = ares__expand_name_for_response( aptr, abuf, alen, &hostname, &len);\n+  if ( status != ARES_SUCCESS )\n+    return status;\n+  if ( aptr + len + QFIXEDSZ > abuf + alen )\n+  {\n+    free( hostname );\n+    return ARES_EBADRESP;\n+  }\n+  aptr += len + QFIXEDSZ;\n+\n+  /* Allocate nameservers array; ancount gives an upper bound */\n+  nameservers = malloc( ( ancount + 1 ) * sizeof( char * ) );\n+  if ( !nameservers )\n+  {\n+    free( hostname );\n+    return ARES_ENOMEM;\n+  }\n+  nameservers_num = 0;\n+\n+  /* Examine each answer resource record (RR) in turn. */\n+  for ( i = 0; i < ( int ) ancount; i++ )\n+  {\n+    /* Decode the RR up to the data field. */\n+    status = ares__expand_name_for_response( aptr, abuf, alen, &rr_name, &len );\n+    if ( status != ARES_SUCCESS )\n+      break;\n+    aptr += len;\n+    if ( aptr + RRFIXEDSZ > abuf + alen )\n+    {\n+      status = ARES_EBADRESP;\n+      break;\n+    }\n+    rr_type = DNS_RR_TYPE( aptr );\n+    rr_class = DNS_RR_CLASS( aptr );\n+    rr_len = DNS_RR_LEN( aptr );\n+    aptr += RRFIXEDSZ;\n+\n+    if ( rr_class == C_IN && rr_type == T_NS )\n+    {\n+      /* Decode the RR data and add it to the nameservers list */\n+      status = ares__expand_name_for_response( aptr, abuf, alen, &rr_data,\n+                                               &len);\n+      if ( status != ARES_SUCCESS )\n+      {\n+        break;\n+      }\n+\n+      nameservers[nameservers_num] = malloc(strlen(rr_data)+1);\n+\n+      if (nameservers[nameservers_num]==NULL)\n+      {\n+        free(rr_name);\n+        free(rr_data);\n+        status=ARES_ENOMEM;\n+        break;\n+      }\n+      strcpy(nameservers[nameservers_num],rr_data);\n+      free(rr_data);\n+\n+      nameservers_num++;\n+    }\n+\n+    free( rr_name );\n+\n+    aptr += rr_len;\n+    if ( aptr > abuf + alen )\n+    {\n+      status = ARES_EBADRESP;\n+      break;\n+    }\n+  }\n+\n+  if ( status == ARES_SUCCESS && nameservers_num == 0 )\n+  {\n+    status = ARES_ENODATA;\n+  }\n+  if ( status == ARES_SUCCESS )\n+  {\n+    /* We got our answer.  Allocate memory to build the host entry. */\n+    nameservers[nameservers_num] = NULL;\n+    hostent = malloc( sizeof( struct hostent ) );\n+    if ( hostent )\n+    {\n+      hostent->h_addr_list = malloc( 1 * sizeof( char * ) );\n+      if ( hostent->h_addr_list )\n+      {\n+        /* Fill in the hostent and return successfully. */\n+        hostent->h_name = hostname;\n+        hostent->h_aliases = nameservers;\n+        hostent->h_addrtype = AF_INET;\n+        hostent->h_length = sizeof( struct in_addr );\n+        hostent->h_addr_list[0] = NULL;\n+        *host = hostent;\n+        return ARES_SUCCESS;\n+      }\n+      free( hostent );\n+    }\n+    status = ARES_ENOMEM;\n+  }\n+  for ( i = 0; i < nameservers_num; i++ )\n+    free( nameservers[i] );\n+  free( nameservers );\n+  free( hostname );\n+  return status;\n+}"}, {"sha": "ccd68a26da11a67a58027d08962c3a890ee1612e", "filename": "src/rt/libuv/src/ares/ares_parse_ptr_reply.c", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_ptr_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_ptr_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_ptr_reply.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,208 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_NETDB_H\n+#  include <netdb.h>\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n+#  include <arpa/nameser_compat.h>\n+#endif\n+\n+#ifdef HAVE_STRINGS_H\n+#  include <strings.h>\n+#endif\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include \"ares.h\"\n+#include \"ares_dns.h\"\n+#include \"ares_private.h\"\n+\n+int ares_parse_ptr_reply(const unsigned char *abuf, int alen, const void *addr,\n+                         int addrlen, int family, struct hostent **host)\n+{\n+  unsigned int qdcount, ancount;\n+  int status, i, rr_type, rr_class, rr_len;\n+  long len;\n+  const unsigned char *aptr;\n+  char *ptrname, *hostname, *rr_name, *rr_data;\n+  struct hostent *hostent;\n+  int aliascnt = 0;\n+  int alias_alloc = 8;\n+  char ** aliases;\n+\n+  /* Set *host to NULL for all failure cases. */\n+  *host = NULL;\n+\n+  /* Give up if abuf doesn't have room for a header. */\n+  if (alen < HFIXEDSZ)\n+    return ARES_EBADRESP;\n+\n+  /* Fetch the question and answer count from the header. */\n+  qdcount = DNS_HEADER_QDCOUNT(abuf);\n+  ancount = DNS_HEADER_ANCOUNT(abuf);\n+  if (qdcount != 1)\n+    return ARES_EBADRESP;\n+\n+  /* Expand the name from the question, and skip past the question. */\n+  aptr = abuf + HFIXEDSZ;\n+  status = ares__expand_name_for_response(aptr, abuf, alen, &ptrname, &len);\n+  if (status != ARES_SUCCESS)\n+    return status;\n+  if (aptr + len + QFIXEDSZ > abuf + alen)\n+    {\n+      free(ptrname);\n+      return ARES_EBADRESP;\n+    }\n+  aptr += len + QFIXEDSZ;\n+\n+  /* Examine each answer resource record (RR) in turn. */\n+  hostname = NULL;\n+  aliases = malloc(alias_alloc * sizeof(char *));\n+  if (!aliases)\n+    {\n+      free(ptrname);\n+      return ARES_ENOMEM;\n+    }\n+  for (i = 0; i < (int)ancount; i++)\n+    {\n+      /* Decode the RR up to the data field. */\n+      status = ares__expand_name_for_response(aptr, abuf, alen, &rr_name, &len);\n+      if (status != ARES_SUCCESS)\n+        break;\n+      aptr += len;\n+      if (aptr + RRFIXEDSZ > abuf + alen)\n+        {\n+          status = ARES_EBADRESP;\n+          break;\n+        }\n+      rr_type = DNS_RR_TYPE(aptr);\n+      rr_class = DNS_RR_CLASS(aptr);\n+      rr_len = DNS_RR_LEN(aptr);\n+      aptr += RRFIXEDSZ;\n+\n+      if (rr_class == C_IN && rr_type == T_PTR\n+          && strcasecmp(rr_name, ptrname) == 0)\n+        {\n+          /* Decode the RR data and set hostname to it. */\n+          status = ares__expand_name_for_response(aptr, abuf, alen, &rr_data,\n+                                                  &len);\n+          if (status != ARES_SUCCESS)\n+            break;\n+          if (hostname)\n+            free(hostname);\n+          hostname = rr_data;\n+          aliases[aliascnt] = malloc((strlen(rr_data)+1) * sizeof(char *));\n+          if (!aliases[aliascnt])\n+            {\n+              status = ARES_ENOMEM;\n+              break;\n+            }\n+          strncpy(aliases[aliascnt], rr_data, strlen(rr_data)+1);\n+          aliascnt++;\n+          if (aliascnt >= alias_alloc) {\n+            char **ptr;\n+            alias_alloc *= 2;\n+            ptr = realloc(aliases, alias_alloc * sizeof(char *));\n+            if(!ptr) {\n+              status = ARES_ENOMEM;\n+              break;\n+            }\n+            aliases = ptr;\n+          }\n+        }\n+\n+      if (rr_class == C_IN && rr_type == T_CNAME)\n+        {\n+          /* Decode the RR data and replace ptrname with it. */\n+          status = ares__expand_name_for_response(aptr, abuf, alen, &rr_data,\n+                                                  &len);\n+          if (status != ARES_SUCCESS)\n+            break;\n+          free(ptrname);\n+          ptrname = rr_data;\n+        }\n+\n+      free(rr_name);\n+      aptr += rr_len;\n+      if (aptr > abuf + alen)\n+        {\n+          status = ARES_EBADRESP;\n+          break;\n+        }\n+    }\n+\n+  if (status == ARES_SUCCESS && !hostname)\n+    status = ARES_ENODATA;\n+  if (status == ARES_SUCCESS)\n+    {\n+      /* We got our answer.  Allocate memory to build the host entry. */\n+      hostent = malloc(sizeof(struct hostent));\n+      if (hostent)\n+        {\n+          hostent->h_addr_list = malloc(2 * sizeof(char *));\n+          if (hostent->h_addr_list)\n+            {\n+              hostent->h_addr_list[0] = malloc(addrlen);\n+              if (hostent->h_addr_list[0])\n+                {\n+                  hostent->h_aliases = malloc((aliascnt+1) * sizeof (char *));\n+                  if (hostent->h_aliases)\n+                    {\n+                      /* Fill in the hostent and return successfully. */\n+                      hostent->h_name = hostname;\n+                      for (i=0 ; i<aliascnt ; i++)\n+                        hostent->h_aliases[i] = aliases[i];\n+                      hostent->h_aliases[aliascnt] = NULL;\n+                      hostent->h_addrtype = family;\n+                      hostent->h_length = addrlen;\n+                      memcpy(hostent->h_addr_list[0], addr, addrlen);\n+                      hostent->h_addr_list[1] = NULL;\n+                      *host = hostent;\n+                      free(aliases);\n+                      free(ptrname);\n+                      return ARES_SUCCESS;\n+                    }\n+                  free(hostent->h_addr_list[0]);\n+                }\n+              free(hostent->h_addr_list);\n+            }\n+          free(hostent);\n+        }\n+      status = ARES_ENOMEM;\n+    }\n+  for (i=0 ; i<aliascnt ; i++)\n+    if (aliases[i]) \n+      free(aliases[i]);\n+  free(aliases);\n+  if (hostname)\n+    free(hostname);\n+  free(ptrname);\n+  return status;\n+}"}, {"sha": "7d443b38ed38e18bc30b15c9ed8da5de876af50e", "filename": "src/rt/libuv/src/ares/ares_parse_srv_reply.c", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_srv_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_srv_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_srv_reply.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,179 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ * Copyright (C) 2009 by Jakub Hrozek <jhrozek@redhat.com>\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_NETDB_H\n+#  include <netdb.h>\n+#endif\n+#ifdef HAVE_ARPA_INET_H\n+#  include <arpa/inet.h>\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n+#  include <arpa/nameser_compat.h>\n+#endif\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include \"ares.h\"\n+#include \"ares_dns.h\"\n+#include \"ares_data.h\"\n+#include \"ares_private.h\"\n+\n+/* AIX portability check */\n+#ifndef T_SRV\n+#  define T_SRV 33 /* server selection */\n+#endif\n+\n+int\n+ares_parse_srv_reply (const unsigned char *abuf, int alen,\n+                      struct ares_srv_reply **srv_out)\n+{\n+  unsigned int qdcount, ancount, i;\n+  const unsigned char *aptr, *vptr;\n+  int status, rr_type, rr_class, rr_len;\n+  long len;\n+  char *hostname = NULL, *rr_name = NULL;\n+  struct ares_srv_reply *srv_head = NULL;\n+  struct ares_srv_reply *srv_last = NULL;\n+  struct ares_srv_reply *srv_curr;\n+\n+  /* Set *srv_out to NULL for all failure cases. */\n+  *srv_out = NULL;\n+\n+  /* Give up if abuf doesn't have room for a header. */\n+  if (alen < HFIXEDSZ)\n+    return ARES_EBADRESP;\n+\n+  /* Fetch the question and answer count from the header. */\n+  qdcount = DNS_HEADER_QDCOUNT (abuf);\n+  ancount = DNS_HEADER_ANCOUNT (abuf);\n+  if (qdcount != 1)\n+    return ARES_EBADRESP;\n+  if (ancount == 0)\n+    return ARES_ENODATA;\n+\n+  /* Expand the name from the question, and skip past the question. */\n+  aptr = abuf + HFIXEDSZ;\n+  status = ares_expand_name (aptr, abuf, alen, &hostname, &len);\n+  if (status != ARES_SUCCESS)\n+    return status;\n+\n+  if (aptr + len + QFIXEDSZ > abuf + alen)\n+    {\n+      free (hostname);\n+      return ARES_EBADRESP;\n+    }\n+  aptr += len + QFIXEDSZ;\n+\n+  /* Examine each answer resource record (RR) in turn. */\n+  for (i = 0; i < ancount; i++)\n+    {\n+      /* Decode the RR up to the data field. */\n+      status = ares_expand_name (aptr, abuf, alen, &rr_name, &len);\n+      if (status != ARES_SUCCESS)\n+        {\n+          break;\n+        }\n+      aptr += len;\n+      if (aptr + RRFIXEDSZ > abuf + alen)\n+        {\n+          status = ARES_EBADRESP;\n+          break;\n+        }\n+      rr_type = DNS_RR_TYPE (aptr);\n+      rr_class = DNS_RR_CLASS (aptr);\n+      rr_len = DNS_RR_LEN (aptr);\n+      aptr += RRFIXEDSZ;\n+\n+      /* Check if we are really looking at a SRV record */\n+      if (rr_class == C_IN && rr_type == T_SRV)\n+        {\n+          /* parse the SRV record itself */\n+          if (rr_len < 6)\n+            {\n+              status = ARES_EBADRESP;\n+              break;\n+            }\n+\n+          /* Allocate storage for this SRV answer appending it to the list */\n+          srv_curr = ares_malloc_data(ARES_DATATYPE_SRV_REPLY);\n+          if (!srv_curr)\n+            {\n+              status = ARES_ENOMEM;\n+              break;\n+            }\n+          if (srv_last)\n+            {\n+              srv_last->next = srv_curr;\n+            }\n+          else\n+            {\n+              srv_head = srv_curr;\n+            }\n+          srv_last = srv_curr;\n+\n+          vptr = aptr;\n+          srv_curr->priority = ntohs (*((unsigned short *)vptr));\n+          vptr += sizeof(unsigned short);\n+          srv_curr->weight = ntohs (*((unsigned short *)vptr));\n+          vptr += sizeof(unsigned short);\n+          srv_curr->port = ntohs (*((unsigned short *)vptr));\n+          vptr += sizeof(unsigned short);\n+\n+          status = ares_expand_name (vptr, abuf, alen, &srv_curr->host, &len);\n+          if (status != ARES_SUCCESS)\n+            break;\n+        }\n+\n+      /* Don't lose memory in the next iteration */\n+      free (rr_name);\n+      rr_name = NULL;\n+\n+      /* Move on to the next record */\n+      aptr += rr_len;\n+    }\n+\n+  if (hostname)\n+    free (hostname);\n+  if (rr_name)\n+    free (rr_name);\n+\n+  /* clean up on error */\n+  if (status != ARES_SUCCESS)\n+    {\n+      if (srv_head)\n+        ares_free_data (srv_head);\n+      return status;\n+    }\n+\n+  /* everything looks fine, return the data */\n+  *srv_out = srv_head;\n+\n+  return ARES_SUCCESS;\n+}"}, {"sha": "51653328eb0203b24ee1f1a657191bb68ddb6adf", "filename": "src/rt/libuv/src/ares/ares_parse_txt_reply.c", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_txt_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_txt_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_txt_reply.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,201 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ * Copyright (C) 2009 by Jakub Hrozek <jhrozek@redhat.com>\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_NETDB_H\n+#  include <netdb.h>\n+#endif\n+#ifdef HAVE_ARPA_INET_H\n+#  include <arpa/inet.h>\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n+#  include <arpa/nameser_compat.h>\n+#endif\n+\n+#ifdef HAVE_STRINGS_H\n+#  include <strings.h>\n+#endif\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"ares.h\"\n+#include \"ares_dns.h\"\n+#include \"ares_data.h\"\n+#include \"ares_private.h\"\n+\n+int\n+ares_parse_txt_reply (const unsigned char *abuf, int alen,\n+                      struct ares_txt_reply **txt_out)\n+{\n+  size_t substr_len, str_len;\n+  unsigned int qdcount, ancount, i;\n+  const unsigned char *aptr;\n+  const unsigned char *strptr;\n+  int status, rr_type, rr_class, rr_len;\n+  long len;\n+  char *hostname = NULL, *rr_name = NULL;\n+  struct ares_txt_reply *txt_head = NULL;\n+  struct ares_txt_reply *txt_last = NULL;\n+  struct ares_txt_reply *txt_curr;\n+\n+  /* Set *txt_out to NULL for all failure cases. */\n+  *txt_out = NULL;\n+\n+  /* Give up if abuf doesn't have room for a header. */\n+  if (alen < HFIXEDSZ)\n+    return ARES_EBADRESP;\n+\n+  /* Fetch the question and answer count from the header. */\n+  qdcount = DNS_HEADER_QDCOUNT (abuf);\n+  ancount = DNS_HEADER_ANCOUNT (abuf);\n+  if (qdcount != 1)\n+    return ARES_EBADRESP;\n+  if (ancount == 0)\n+    return ARES_ENODATA;\n+\n+  /* Expand the name from the question, and skip past the question. */\n+  aptr = abuf + HFIXEDSZ;\n+  status = ares_expand_name (aptr, abuf, alen, &hostname, &len);\n+  if (status != ARES_SUCCESS)\n+    return status;\n+\n+  if (aptr + len + QFIXEDSZ > abuf + alen)\n+    {\n+      free (hostname);\n+      return ARES_EBADRESP;\n+    }\n+  aptr += len + QFIXEDSZ;\n+\n+  /* Examine each answer resource record (RR) in turn. */\n+  for (i = 0; i < ancount; i++)\n+    {\n+      /* Decode the RR up to the data field. */\n+      status = ares_expand_name (aptr, abuf, alen, &rr_name, &len);\n+      if (status != ARES_SUCCESS)\n+        {\n+          break;\n+        }\n+      aptr += len;\n+      if (aptr + RRFIXEDSZ > abuf + alen)\n+        {\n+          status = ARES_EBADRESP;\n+          break;\n+        }\n+      rr_type = DNS_RR_TYPE (aptr);\n+      rr_class = DNS_RR_CLASS (aptr);\n+      rr_len = DNS_RR_LEN (aptr);\n+      aptr += RRFIXEDSZ;\n+\n+      /* Check if we are really looking at a TXT record */\n+      if (rr_class == C_IN && rr_type == T_TXT)\n+        {\n+          /* Allocate storage for this TXT answer appending it to the list */\n+          txt_curr = ares_malloc_data(ARES_DATATYPE_TXT_REPLY);\n+          if (!txt_curr)\n+            {\n+              status = ARES_ENOMEM;\n+              break;\n+            }\n+          if (txt_last)\n+            {\n+              txt_last->next = txt_curr;\n+            }\n+          else\n+            {\n+              txt_head = txt_curr;\n+            }\n+          txt_last = txt_curr;\n+\n+          /*\n+           * There may be multiple substrings in a single TXT record. Each\n+           * substring may be up to 255 characters in length, with a\n+           * \"length byte\" indicating the size of the substring payload.\n+           * RDATA contains both the length-bytes and payloads of all\n+           * substrings contained therein.\n+           */\n+\n+          /* Compute total length to allow a single memory allocation */\n+          strptr = aptr;\n+          while (strptr < (aptr + rr_len))\n+            {\n+              substr_len = (unsigned char)*strptr;\n+              txt_curr->length += substr_len;\n+              strptr += substr_len + 1;\n+            }\n+\n+          /* Including null byte */\n+          txt_curr->txt = malloc (txt_curr->length + 1);\n+          if (txt_curr->txt == NULL)\n+            {\n+              status = ARES_ENOMEM;\n+              break;\n+            }\n+\n+          /* Step through the list of substrings, concatenating them */\n+          str_len = 0;\n+          strptr = aptr;\n+          while (strptr < (aptr + rr_len))\n+            {\n+              substr_len = (unsigned char)*strptr;\n+              strptr++;\n+              memcpy ((char *) txt_curr->txt + str_len, strptr, substr_len);\n+              str_len += substr_len;\n+              strptr += substr_len;\n+            }\n+          /* Make sure we NULL-terminate */\n+          *((char *) txt_curr->txt + txt_curr->length) = '\\0';\n+        }\n+\n+      /* Don't lose memory in the next iteration */\n+      free (rr_name);\n+      rr_name = NULL;\n+\n+      /* Move on to the next record */\n+      aptr += rr_len;\n+    }\n+\n+  if (hostname)\n+    free (hostname);\n+  if (rr_name)\n+    free (rr_name);\n+\n+  /* clean up on error */\n+  if (status != ARES_SUCCESS)\n+    {\n+      if (txt_head)\n+        ares_free_data (txt_head);\n+      return status;\n+    }\n+\n+  /* everything looks fine, return the data */\n+  *txt_out = txt_head;\n+\n+  return ARES_SUCCESS;\n+}"}, {"sha": "bf21abd82590cff3988cfb90ff2557f5b209dba5", "filename": "src/rt/libuv/src/ares/ares_private.h", "status": "added", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_private.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_private.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_private.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,351 @@\n+#ifndef __ARES_PRIVATE_H\n+#define __ARES_PRIVATE_H\n+\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ * Copyright (C) 2004-2010 by Daniel Stenberg\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+/*\n+ * Define WIN32 when build target is Win32 API\n+ */\n+\n+#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)\n+#define WIN32\n+#endif\n+\n+#include <stdio.h>\n+#include <sys/types.h>\n+\n+#ifdef HAVE_NETINET_IN_H\n+#include <netinet/in.h>\n+#endif\n+\n+#ifdef WATT32\n+#include <tcp.h>\n+#include <sys/ioctl.h>\n+#define writev(s,v,c)     writev_s(s,v,c)\n+#define HAVE_WRITEV 1\n+#endif\n+\n+#ifdef NETWARE\n+#include <time.h>\n+#endif\n+\n+#define DEFAULT_TIMEOUT         5000 /* milliseconds */\n+#define DEFAULT_TRIES           4\n+#ifndef INADDR_NONE\n+#define INADDR_NONE 0xffffffff\n+#endif\n+\n+#if defined(WIN32) && !defined(WATT32)\n+\n+#define IS_NT()        ((int)GetVersion() > 0)\n+#define WIN_NS_9X      \"System\\\\CurrentControlSet\\\\Services\\\\VxD\\\\MSTCP\"\n+#define WIN_NS_NT_KEY  \"System\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters\"\n+#define NAMESERVER     \"NameServer\"\n+#define DHCPNAMESERVER \"DhcpNameServer\"\n+#define DATABASEPATH   \"DatabasePath\"\n+#define WIN_PATH_HOSTS  \"\\\\hosts\"\n+\n+#elif defined(WATT32)\n+\n+#define PATH_RESOLV_CONF \"/dev/ENV/etc/resolv.conf\"\n+\n+#elif defined(NETWARE)\n+\n+#define PATH_RESOLV_CONF \"sys:/etc/resolv.cfg\"\n+#define PATH_HOSTS              \"sys:/etc/hosts\"\n+\n+#elif defined(__riscos__)\n+\n+#define PATH_HOSTS             \"InetDBase:Hosts\"\n+\n+#else\n+\n+#define PATH_RESOLV_CONF        \"/etc/resolv.conf\"\n+#ifdef ETC_INET\n+#define PATH_HOSTS              \"/etc/inet/hosts\"\n+#else\n+#define PATH_HOSTS              \"/etc/hosts\"\n+#endif\n+\n+#endif\n+\n+#define ARES_ID_KEY_LEN 31\n+\n+#include \"ares_ipv6.h\"\n+#include \"ares_llist.h\"\n+\n+#ifndef HAVE_STRDUP\n+#  include \"ares_strdup.h\"\n+#  define strdup(ptr) ares_strdup(ptr)\n+#endif\n+\n+#ifndef HAVE_STRCASECMP\n+#  include \"ares_strcasecmp.h\"\n+#  define strcasecmp(p1,p2) ares_strcasecmp(p1,p2)\n+#endif\n+\n+#ifndef HAVE_STRNCASECMP\n+#  include \"ares_strcasecmp.h\"\n+#  define strncasecmp(p1,p2,n) ares_strncasecmp(p1,p2,n)\n+#endif\n+\n+#ifndef HAVE_WRITEV\n+#  include \"ares_writev.h\"\n+#  define writev(s,ptr,cnt) ares_writev(s,ptr,cnt)\n+#endif\n+\n+struct ares_addr {\n+  int family;\n+  union {\n+    struct in_addr       addr4;\n+    struct ares_in6_addr addr6;\n+  } addr;\n+};\n+#define addrV4 addr.addr4\n+#define addrV6 addr.addr6\n+\n+struct query;\n+\n+struct send_request {\n+  /* Remaining data to send */\n+  const unsigned char *data;\n+  size_t len;\n+\n+  /* The query for which we're sending this data */\n+  struct query* owner_query;\n+  /* The buffer we're using, if we have our own copy of the packet */\n+  unsigned char *data_storage;\n+\n+  /* Next request in queue */\n+  struct send_request *next;\n+};\n+\n+struct server_state {\n+  struct ares_addr addr;\n+  ares_socket_t udp_socket;\n+  ares_socket_t tcp_socket;\n+\n+  /* Mini-buffer for reading the length word */\n+  unsigned char tcp_lenbuf[2];\n+  int tcp_lenbuf_pos;\n+  int tcp_length;\n+\n+  /* Buffer for reading actual TCP data */\n+  unsigned char *tcp_buffer;\n+  int tcp_buffer_pos;\n+\n+  /* TCP output queue */\n+  struct send_request *qhead;\n+  struct send_request *qtail;\n+\n+  /* Which incarnation of this connection is this? We don't want to\n+   * retransmit requests into the very same socket, but if the server\n+   * closes on us and we re-open the connection, then we do want to\n+   * re-send. */\n+  int tcp_connection_generation;\n+\n+  /* Circular, doubly-linked list of outstanding queries to this server */\n+  struct list_node queries_to_server;\n+\n+  /* Link back to owning channel */\n+  ares_channel channel;\n+\n+  /* Is this server broken? We mark connections as broken when a\n+   * request that is queued for sending times out.\n+   */\n+  int is_broken;\n+};\n+\n+/* State to represent a DNS query */\n+struct query {\n+  /* Query ID from qbuf, for faster lookup, and current timeout */\n+  unsigned short qid;\n+  struct timeval timeout;\n+\n+  /*\n+   * Links for the doubly-linked lists in which we insert a query.\n+   * These circular, doubly-linked lists that are hash-bucketed based\n+   * the attributes we care about, help making most important\n+   * operations O(1).\n+   */\n+  struct list_node queries_by_qid;    /* hopefully in same cache line as qid */\n+  struct list_node queries_by_timeout;\n+  struct list_node queries_to_server;\n+  struct list_node all_queries;\n+\n+  /* Query buf with length at beginning, for TCP transmission */\n+  unsigned char *tcpbuf;\n+  int tcplen;\n+\n+  /* Arguments passed to ares_send() (qbuf points into tcpbuf) */\n+  const unsigned char *qbuf;\n+  int qlen;\n+  ares_callback callback;\n+  void *arg;\n+\n+  /* Query status */\n+  int try; /* Number of times we tried this query already. */\n+  int server; /* Server this query has last been sent to. */\n+  struct query_server_info *server_info;   /* per-server state */\n+  int using_tcp;\n+  int error_status;\n+  int timeouts; /* number of timeouts we saw for this request */\n+};\n+\n+/* Per-server state for a query */\n+struct query_server_info {\n+  int skip_server;  /* should we skip server, due to errors, etc? */\n+  int tcp_connection_generation;  /* into which TCP connection did we send? */\n+};\n+\n+/* An IP address pattern; matches an IP address X if X & mask == addr */\n+#define PATTERN_MASK 0x1\n+#define PATTERN_CIDR 0x2\n+\n+struct apattern {\n+  union\n+  {\n+    struct in_addr       addr4;\n+    struct ares_in6_addr addr6;\n+  } addr;\n+  union\n+  {\n+    struct in_addr       addr4;\n+    struct ares_in6_addr addr6;\n+    unsigned short       bits;\n+  } mask;\n+  int family;\n+  unsigned short type;\n+};\n+\n+typedef struct rc4_key\n+{\n+  unsigned char state[256];\n+  unsigned char x;\n+  unsigned char y;\n+} rc4_key;\n+\n+struct ares_channeldata {\n+  /* Configuration data */\n+  int flags;\n+  int timeout; /* in milliseconds */\n+  int tries;\n+  int ndots;\n+  int rotate; /* if true, all servers specified are used */\n+  int udp_port;\n+  int tcp_port;\n+  int socket_send_buffer_size;\n+  int socket_receive_buffer_size;\n+  char **domains;\n+  int ndomains;\n+  struct apattern *sortlist;\n+  int nsort;\n+  char *lookups;\n+\n+  /* For binding to local devices and/or IP addresses.  Leave\n+   * them null/zero for no binding.\n+   */\n+  char local_dev_name[32];\n+  unsigned int local_ip4;\n+  unsigned char local_ip6[16];\n+\n+  int optmask; /* the option bitfield passed in at init time */\n+\n+  /* Server addresses and communications state */\n+  struct server_state *servers;\n+  int nservers;\n+\n+  /* ID to use for next query */\n+  unsigned short next_id;\n+  /* key to use when generating new ids */\n+  rc4_key id_key;\n+\n+  /* Generation number to use for the next TCP socket open/close */\n+  int tcp_connection_generation;\n+\n+  /* The time at which we last called process_timeouts(). Uses integer seconds\n+     just to draw the line somewhere. */\n+  time_t last_timeout_processed;\n+\n+  /* Last server we sent a query to. */\n+  int last_server;\n+\n+  /* Circular, doubly-linked list of queries, bucketed various ways.... */\n+  /* All active queries in a single list: */\n+  struct list_node all_queries;\n+  /* Queries bucketed by qid, for quickly dispatching DNS responses: */\n+#define ARES_QID_TABLE_SIZE 2048\n+  struct list_node queries_by_qid[ARES_QID_TABLE_SIZE];\n+  /* Queries bucketed by timeout, for quickly handling timeouts: */\n+#define ARES_TIMEOUT_TABLE_SIZE 1024\n+  struct list_node queries_by_timeout[ARES_TIMEOUT_TABLE_SIZE];\n+\n+  ares_sock_state_cb sock_state_cb;\n+  void *sock_state_cb_data;\n+\n+  ares_sock_create_callback sock_create_cb;\n+  void *sock_create_cb_data;\n+};\n+\n+/* return true if now is exactly check time or later */\n+int ares__timedout(struct timeval *now,\n+                   struct timeval *check);\n+/* add the specific number of milliseconds to the time in the first argument */\n+int ares__timeadd(struct timeval *now,\n+                  int millisecs);\n+/* return time offset between now and (future) check, in milliseconds */\n+long ares__timeoffset(struct timeval *now,\n+                      struct timeval *check);\n+/* returns ARES_SUCCESS if library has been initialized */\n+int ares_library_initialized(void);\n+void ares__rc4(rc4_key* key,unsigned char *buffer_ptr, int buffer_len);\n+void ares__send_query(ares_channel channel, struct query *query,\n+                      struct timeval *now);\n+void ares__close_sockets(ares_channel channel, struct server_state *server);\n+int ares__get_hostent(FILE *fp, int family, struct hostent **host);\n+int ares__read_line(FILE *fp, char **buf, size_t *bufsize);\n+void ares__free_query(struct query *query);\n+unsigned short ares__generate_new_id(rc4_key* key);\n+struct timeval ares__tvnow(void);\n+int ares__expand_name_for_response(const unsigned char *encoded,\n+                                   const unsigned char *abuf, int alen,\n+                                   char **s, long *enclen);\n+void ares__init_servers_state(ares_channel channel);\n+void ares__destroy_servers_state(ares_channel channel);\n+#if 0 /* Not used */\n+long ares__tvdiff(struct timeval t1, struct timeval t2);\n+#endif\n+\n+#define ARES_SWAP_BYTE(a,b) \\\n+  { unsigned char swapByte = *(a);  *(a) = *(b);  *(b) = swapByte; }\n+\n+#define SOCK_STATE_CALLBACK(c, s, r, w)                                 \\\n+  do {                                                                  \\\n+    if ((c)->sock_state_cb)                                             \\\n+      (c)->sock_state_cb((c)->sock_state_cb_data, (s), (r), (w));       \\\n+  } while (0)\n+\n+#ifdef CURLDEBUG\n+/* This is low-level hard-hacking memory leak tracking and similar. Using the\n+   libcurl lowlevel code from within library is ugly and only works when\n+   c-ares is built and linked with a similarly curldebug-enabled libcurl,\n+   but we do this anyway for convenience. */\n+#include \"../lib/memdebug.h\"\n+#endif\n+\n+#endif /* __ARES_PRIVATE_H */"}, {"sha": "7d04effa8a3e6c62ccd67331e5d540b0cea9ded6", "filename": "src/rt/libuv/src/ares/ares_process.c", "status": "added", "additions": 1296, "deletions": 0, "changes": 1296, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_process.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_process.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_process.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,1296 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ * Copyright (C) 2004-2010 by Daniel Stenberg\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_SYS_UIO_H\n+#  include <sys/uio.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_NETINET_TCP_H\n+#  include <netinet/tcp.h>\n+#endif\n+#ifdef HAVE_NETDB_H\n+#  include <netdb.h>\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n+#  include <arpa/nameser_compat.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TIME_H\n+#  include <sys/time.h>\n+#endif\n+\n+#ifdef HAVE_STRINGS_H\n+#  include <strings.h>\n+#endif\n+#ifdef HAVE_UNISTD_H\n+#  include <unistd.h>\n+#endif\n+#ifdef HAVE_SYS_IOCTL_H\n+#  include <sys/ioctl.h>\n+#endif\n+#ifdef NETWARE\n+#  include <sys/filio.h>\n+#endif\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <fcntl.h>\n+#include <time.h>\n+#include <errno.h>\n+\n+#include \"ares.h\"\n+#include \"ares_dns.h\"\n+#include \"ares_private.h\"\n+\n+\n+static int try_again(int errnum);\n+static void write_tcp_data(ares_channel channel, fd_set *write_fds,\n+                           ares_socket_t write_fd, struct timeval *now);\n+static void read_tcp_data(ares_channel channel, fd_set *read_fds,\n+                          ares_socket_t read_fd, struct timeval *now);\n+static void read_udp_packets(ares_channel channel, fd_set *read_fds,\n+                             ares_socket_t read_fd, struct timeval *now);\n+static void advance_tcp_send_queue(ares_channel channel, int whichserver,\n+                                   ssize_t num_bytes);\n+static void process_timeouts(ares_channel channel, struct timeval *now);\n+static void process_broken_connections(ares_channel channel,\n+                                       struct timeval *now);\n+static void process_answer(ares_channel channel, unsigned char *abuf,\n+                           int alen, int whichserver, int tcp,\n+                           struct timeval *now);\n+static void handle_error(ares_channel channel, int whichserver,\n+                         struct timeval *now);\n+static void skip_server(ares_channel channel, struct query *query,\n+                        int whichserver);\n+static void next_server(ares_channel channel, struct query *query,\n+                        struct timeval *now);\n+static int open_tcp_socket(ares_channel channel, struct server_state *server);\n+static int open_udp_socket(ares_channel channel, struct server_state *server);\n+static int same_questions(const unsigned char *qbuf, int qlen,\n+                          const unsigned char *abuf, int alen);\n+static int same_address(struct sockaddr *sa, struct ares_addr *aa);\n+static void end_query(ares_channel channel, struct query *query, int status,\n+                      unsigned char *abuf, int alen);\n+\n+/* return true if now is exactly check time or later */\n+int ares__timedout(struct timeval *now,\n+                   struct timeval *check)\n+{\n+  long secs = (now->tv_sec - check->tv_sec);\n+\n+  if(secs > 0)\n+    return 1; /* yes, timed out */\n+  if(secs < 0)\n+    return 0; /* nope, not timed out */\n+\n+  /* if the full seconds were identical, check the sub second parts */\n+  return (now->tv_usec - check->tv_usec >= 0);\n+}\n+\n+/* add the specific number of milliseconds to the time in the first argument */\n+int ares__timeadd(struct timeval *now,\n+                  int millisecs)\n+{\n+  now->tv_sec += millisecs/1000;\n+  now->tv_usec += (millisecs%1000)*1000;\n+\n+  if(now->tv_usec >= 1000000) {\n+    ++(now->tv_sec);\n+    now->tv_usec -= 1000000;\n+  }\n+\n+  return 0;\n+}\n+\n+/* return time offset between now and (future) check, in milliseconds */\n+long ares__timeoffset(struct timeval *now,\n+                      struct timeval *check)\n+{\n+  return (check->tv_sec - now->tv_sec)*1000 +\n+         (check->tv_usec - now->tv_usec)/1000;\n+}\n+\n+\n+/*\n+ * generic process function\n+ */\n+static void processfds(ares_channel channel,\n+                       fd_set *read_fds, ares_socket_t read_fd,\n+                       fd_set *write_fds, ares_socket_t write_fd)\n+{\n+  struct timeval now = ares__tvnow();\n+\n+  write_tcp_data(channel, write_fds, write_fd, &now);\n+  read_tcp_data(channel, read_fds, read_fd, &now);\n+  read_udp_packets(channel, read_fds, read_fd, &now);\n+  process_timeouts(channel, &now);\n+  process_broken_connections(channel, &now);\n+}\n+\n+/* Something interesting happened on the wire, or there was a timeout.\n+ * See what's up and respond accordingly.\n+ */\n+void ares_process(ares_channel channel, fd_set *read_fds, fd_set *write_fds)\n+{\n+  processfds(channel, read_fds, ARES_SOCKET_BAD, write_fds, ARES_SOCKET_BAD);\n+}\n+\n+/* Something interesting happened on the wire, or there was a timeout.\n+ * See what's up and respond accordingly.\n+ */\n+void ares_process_fd(ares_channel channel,\n+                     ares_socket_t read_fd, /* use ARES_SOCKET_BAD or valid\n+                                               file descriptors */\n+                     ares_socket_t write_fd)\n+{\n+  processfds(channel, NULL, read_fd, NULL, write_fd);\n+}\n+\n+\n+/* Return 1 if the specified error number describes a readiness error, or 0\n+ * otherwise. This is mostly for HP-UX, which could return EAGAIN or\n+ * EWOULDBLOCK. See this man page\n+ *\n+ * http://devrsrc1.external.hp.com/STKS/cgi-bin/man2html?\n+ *     manpage=/usr/share/man/man2.Z/send.2\n+ */\n+static int try_again(int errnum)\n+{\n+#if !defined EWOULDBLOCK && !defined EAGAIN\n+#error \"Neither EWOULDBLOCK nor EAGAIN defined\"\n+#endif\n+  switch (errnum)\n+    {\n+#ifdef EWOULDBLOCK\n+    case EWOULDBLOCK:\n+      return 1;\n+#endif\n+#if defined EAGAIN && EAGAIN != EWOULDBLOCK\n+    case EAGAIN:\n+      return 1;\n+#endif\n+    }\n+  return 0;\n+}\n+\n+/* If any TCP sockets select true for writing, write out queued data\n+ * we have for them.\n+ */\n+static void write_tcp_data(ares_channel channel,\n+                           fd_set *write_fds,\n+                           ares_socket_t write_fd,\n+                           struct timeval *now)\n+{\n+  struct server_state *server;\n+  struct send_request *sendreq;\n+  struct iovec *vec;\n+  int i;\n+  ssize_t scount;\n+  ssize_t wcount;\n+  size_t n;\n+\n+  if(!write_fds && (write_fd == ARES_SOCKET_BAD))\n+    /* no possible action */\n+    return;\n+\n+  for (i = 0; i < channel->nservers; i++)\n+    {\n+      /* Make sure server has data to send and is selected in write_fds or\n+         write_fd. */\n+      server = &channel->servers[i];\n+      if (!server->qhead || server->tcp_socket == ARES_SOCKET_BAD ||\n+          server->is_broken)\n+        continue;\n+\n+      if(write_fds) {\n+        if(!FD_ISSET(server->tcp_socket, write_fds))\n+          continue;\n+      }\n+      else {\n+        if(server->tcp_socket != write_fd)\n+          continue;\n+      }\n+\n+      if(write_fds)\n+        /* If there's an error and we close this socket, then open\n+         * another with the same fd to talk to another server, then we\n+         * don't want to think that it was the new socket that was\n+         * ready. This is not disastrous, but is likely to result in\n+         * extra system calls and confusion. */\n+        FD_CLR(server->tcp_socket, write_fds);\n+\n+      /* Count the number of send queue items. */\n+      n = 0;\n+      for (sendreq = server->qhead; sendreq; sendreq = sendreq->next)\n+        n++;\n+\n+      /* Allocate iovecs so we can send all our data at once. */\n+      vec = malloc(n * sizeof(struct iovec));\n+      if (vec)\n+        {\n+          /* Fill in the iovecs and send. */\n+          n = 0;\n+          for (sendreq = server->qhead; sendreq; sendreq = sendreq->next)\n+            {\n+              vec[n].iov_base = (char *) sendreq->data;\n+              vec[n].iov_len = sendreq->len;\n+              n++;\n+            }\n+          wcount = (ssize_t)writev(server->tcp_socket, vec, (int)n);\n+          free(vec);\n+          if (wcount < 0)\n+            {\n+              if (!try_again(SOCKERRNO))\n+                  handle_error(channel, i, now);\n+              continue;\n+            }\n+\n+          /* Advance the send queue by as many bytes as we sent. */\n+          advance_tcp_send_queue(channel, i, wcount);\n+        }\n+      else\n+        {\n+          /* Can't allocate iovecs; just send the first request. */\n+          sendreq = server->qhead;\n+\n+          scount = swrite(server->tcp_socket, sendreq->data, sendreq->len);\n+          if (scount < 0)\n+            {\n+              if (!try_again(SOCKERRNO))\n+                  handle_error(channel, i, now);\n+              continue;\n+            }\n+\n+          /* Advance the send queue by as many bytes as we sent. */\n+          advance_tcp_send_queue(channel, i, scount);\n+        }\n+    }\n+}\n+\n+/* Consume the given number of bytes from the head of the TCP send queue. */\n+static void advance_tcp_send_queue(ares_channel channel, int whichserver,\n+                                   ssize_t num_bytes)\n+{\n+  struct send_request *sendreq;\n+  struct server_state *server = &channel->servers[whichserver];\n+  while (num_bytes > 0)\n+    {\n+      sendreq = server->qhead;\n+      if ((size_t)num_bytes >= sendreq->len)\n+       {\n+         num_bytes -= sendreq->len;\n+         server->qhead = sendreq->next;\n+         if (server->qhead == NULL)\n+           {\n+             SOCK_STATE_CALLBACK(channel, server->tcp_socket, 1, 0);\n+             server->qtail = NULL;\n+           }\n+         if (sendreq->data_storage != NULL)\n+           free(sendreq->data_storage);\n+         free(sendreq);\n+       }\n+      else\n+       {\n+         sendreq->data += num_bytes;\n+         sendreq->len -= num_bytes;\n+         num_bytes = 0;\n+       }\n+    }\n+}\n+\n+/* If any TCP socket selects true for reading, read some data,\n+ * allocate a buffer if we finish reading the length word, and process\n+ * a packet if we finish reading one.\n+ */\n+static void read_tcp_data(ares_channel channel, fd_set *read_fds,\n+                          ares_socket_t read_fd, struct timeval *now)\n+{\n+  struct server_state *server;\n+  int i;\n+  ssize_t count;\n+\n+  if(!read_fds && (read_fd == ARES_SOCKET_BAD))\n+    /* no possible action */\n+    return;\n+\n+  for (i = 0; i < channel->nservers; i++)\n+    {\n+      /* Make sure the server has a socket and is selected in read_fds. */\n+      server = &channel->servers[i];\n+      if (server->tcp_socket == ARES_SOCKET_BAD || server->is_broken)\n+        continue;\n+\n+      if(read_fds) {\n+        if(!FD_ISSET(server->tcp_socket, read_fds))\n+          continue;\n+      }\n+      else {\n+        if(server->tcp_socket != read_fd)\n+          continue;\n+      }\n+\n+      if(read_fds)\n+        /* If there's an error and we close this socket, then open\n+         * another with the same fd to talk to another server, then we\n+         * don't want to think that it was the new socket that was\n+         * ready. This is not disastrous, but is likely to result in\n+         * extra system calls and confusion. */\n+        FD_CLR(server->tcp_socket, read_fds);\n+\n+      if (server->tcp_lenbuf_pos != 2)\n+        {\n+          /* We haven't yet read a length word, so read that (or\n+           * what's left to read of it).\n+           */\n+          count = sread(server->tcp_socket,\n+                        server->tcp_lenbuf + server->tcp_lenbuf_pos,\n+                        2 - server->tcp_lenbuf_pos);\n+          if (count <= 0)\n+            {\n+              if (!(count == -1 && try_again(SOCKERRNO)))\n+                  handle_error(channel, i, now);\n+              continue;\n+            }\n+\n+          server->tcp_lenbuf_pos += (int)count;\n+          if (server->tcp_lenbuf_pos == 2)\n+            {\n+              /* We finished reading the length word.  Decode the\n+               * length and allocate a buffer for the data.\n+               */\n+              server->tcp_length = server->tcp_lenbuf[0] << 8\n+                | server->tcp_lenbuf[1];\n+              server->tcp_buffer = malloc(server->tcp_length);\n+              if (!server->tcp_buffer)\n+                handle_error(channel, i, now);\n+              server->tcp_buffer_pos = 0;\n+            }\n+        }\n+      else\n+        {\n+          /* Read data into the allocated buffer. */\n+          count = sread(server->tcp_socket,\n+                        server->tcp_buffer + server->tcp_buffer_pos,\n+                        server->tcp_length - server->tcp_buffer_pos);\n+          if (count <= 0)\n+            {\n+              if (!(count == -1 && try_again(SOCKERRNO)))\n+                  handle_error(channel, i, now);\n+              continue;\n+            }\n+\n+          server->tcp_buffer_pos += (int)count;\n+          if (server->tcp_buffer_pos == server->tcp_length)\n+            {\n+              /* We finished reading this answer; process it and\n+               * prepare to read another length word.\n+               */\n+              process_answer(channel, server->tcp_buffer, server->tcp_length,\n+                             i, 1, now);\n+          if (server->tcp_buffer)\n+                        free(server->tcp_buffer);\n+              server->tcp_buffer = NULL;\n+              server->tcp_lenbuf_pos = 0;\n+              server->tcp_buffer_pos = 0;\n+            }\n+        }\n+    }\n+}\n+\n+/* If any UDP sockets select true for reading, process them. */\n+static void read_udp_packets(ares_channel channel, fd_set *read_fds,\n+                             ares_socket_t read_fd, struct timeval *now)\n+{\n+  struct server_state *server;\n+  int i;\n+  ssize_t count;\n+  unsigned char buf[PACKETSZ + 1];\n+#ifdef HAVE_RECVFROM\n+  ares_socklen_t fromlen;\n+  union {\n+    struct sockaddr     sa;\n+    struct sockaddr_in  sa4;\n+    struct sockaddr_in6 sa6;\n+  } from;\n+#endif\n+\n+  if(!read_fds && (read_fd == ARES_SOCKET_BAD))\n+    /* no possible action */\n+    return;\n+\n+  for (i = 0; i < channel->nservers; i++)\n+    {\n+      /* Make sure the server has a socket and is selected in read_fds. */\n+      server = &channel->servers[i];\n+\n+      if (server->udp_socket == ARES_SOCKET_BAD || server->is_broken)\n+        continue;\n+\n+      if(read_fds) {\n+        if(!FD_ISSET(server->udp_socket, read_fds))\n+          continue;\n+      }\n+      else {\n+        if(server->udp_socket != read_fd)\n+          continue;\n+      }\n+\n+      if(read_fds)\n+        /* If there's an error and we close this socket, then open\n+         * another with the same fd to talk to another server, then we\n+         * don't want to think that it was the new socket that was\n+         * ready. This is not disastrous, but is likely to result in\n+         * extra system calls and confusion. */\n+        FD_CLR(server->udp_socket, read_fds);\n+\n+      /* To reduce event loop overhead, read and process as many\n+       * packets as we can. */\n+      do {\n+#ifdef HAVE_RECVFROM\n+        if (server->addr.family == AF_INET)\n+          fromlen = sizeof(from.sa4);\n+        else\n+          fromlen = sizeof(from.sa6);\n+        count = (ssize_t)recvfrom(server->udp_socket, (void *)buf, sizeof(buf),\n+                                  0, &from.sa, &fromlen);\n+#else\n+        count = sread(server->udp_socket, buf, sizeof(buf));\n+#endif\n+        if (count == -1 && try_again(SOCKERRNO))\n+          continue;\n+        else if (count <= 0)\n+          handle_error(channel, i, now);\n+#ifdef HAVE_RECVFROM\n+        else if (!same_address(&from.sa, &server->addr))\n+          /* The address the response comes from does not match\n+           * the address we sent the request to. Someone may be\n+           * attempting to perform a cache poisoning attack. */\n+          break;\n+#endif\n+        else\n+          process_answer(channel, buf, (int)count, i, 0, now);\n+       } while (count > 0);\n+    }\n+}\n+\n+/* If any queries have timed out, note the timeout and move them on. */\n+static void process_timeouts(ares_channel channel, struct timeval *now)\n+{\n+  time_t t;  /* the time of the timeouts we're processing */\n+  struct query *query;\n+  struct list_node* list_head;\n+  struct list_node* list_node;\n+\n+  /* Process all the timeouts that have fired since the last time we\n+   * processed timeouts. If things are going well, then we'll have\n+   * hundreds/thousands of queries that fall into future buckets, and\n+   * only a handful of requests that fall into the \"now\" bucket, so\n+   * this should be quite quick.\n+   */\n+  for (t = channel->last_timeout_processed; t <= now->tv_sec; t++)\n+    {\n+      list_head = &(channel->queries_by_timeout[t % ARES_TIMEOUT_TABLE_SIZE]);\n+      for (list_node = list_head->next; list_node != list_head; )\n+        {\n+          query = list_node->data;\n+          list_node = list_node->next;  /* in case the query gets deleted */\n+          if (query->timeout.tv_sec && ares__timedout(now, &query->timeout))\n+            {\n+              query->error_status = ARES_ETIMEOUT;\n+              ++query->timeouts;\n+              next_server(channel, query, now);\n+            }\n+        }\n+     }\n+  channel->last_timeout_processed = now->tv_sec;\n+}\n+\n+/* Handle an answer from a server. */\n+static void process_answer(ares_channel channel, unsigned char *abuf,\n+                           int alen, int whichserver, int tcp,\n+                           struct timeval *now)\n+{\n+  int tc, rcode;\n+  unsigned short id;\n+  struct query *query;\n+  struct list_node* list_head;\n+  struct list_node* list_node;\n+\n+  /* If there's no room in the answer for a header, we can't do much\n+   * with it. */\n+  if (alen < HFIXEDSZ)\n+    return;\n+\n+  /* Grab the query ID, truncate bit, and response code from the packet. */\n+  id = DNS_HEADER_QID(abuf);\n+  tc = DNS_HEADER_TC(abuf);\n+  rcode = DNS_HEADER_RCODE(abuf);\n+\n+  /* Find the query corresponding to this packet. The queries are\n+   * hashed/bucketed by query id, so this lookup should be quick.\n+   * Note that both the query id and the questions must be the same;\n+   * when the query id wraps around we can have multiple outstanding\n+   * queries with the same query id, so we need to check both the id and\n+   * question.\n+   */\n+  query = NULL;\n+  list_head = &(channel->queries_by_qid[id % ARES_QID_TABLE_SIZE]);\n+  for (list_node = list_head->next; list_node != list_head;\n+       list_node = list_node->next)\n+    {\n+      struct query *q = list_node->data;\n+      if ((q->qid == id) && same_questions(q->qbuf, q->qlen, abuf, alen))\n+        {\n+          query = q;\n+          break;\n+        }\n+    }\n+  if (!query)\n+    return;\n+\n+  /* If we got a truncated UDP packet and are not ignoring truncation,\n+   * don't accept the packet, and switch the query to TCP if we hadn't\n+   * done so already.\n+   */\n+  if ((tc || alen > PACKETSZ) && !tcp && !(channel->flags & ARES_FLAG_IGNTC))\n+    {\n+      if (!query->using_tcp)\n+        {\n+          query->using_tcp = 1;\n+          ares__send_query(channel, query, now);\n+        }\n+      return;\n+    }\n+\n+  /* Limit alen to PACKETSZ if we aren't using TCP (only relevant if we\n+   * are ignoring truncation.\n+   */\n+  if (alen > PACKETSZ && !tcp)\n+    alen = PACKETSZ;\n+\n+  /* If we aren't passing through all error packets, discard packets\n+   * with SERVFAIL, NOTIMP, or REFUSED response codes.\n+   */\n+  if (!(channel->flags & ARES_FLAG_NOCHECKRESP))\n+    {\n+      if (rcode == SERVFAIL || rcode == NOTIMP || rcode == REFUSED)\n+        {\n+          skip_server(channel, query, whichserver);\n+          if (query->server == whichserver)\n+            next_server(channel, query, now);\n+          return;\n+        }\n+    }\n+\n+  end_query(channel, query, ARES_SUCCESS, abuf, alen);\n+}\n+\n+/* Close all the connections that are no longer usable. */\n+static void process_broken_connections(ares_channel channel,\n+                                       struct timeval *now)\n+{\n+  int i;\n+  for (i = 0; i < channel->nservers; i++)\n+    {\n+      struct server_state *server = &channel->servers[i];\n+      if (server->is_broken)\n+        {\n+          handle_error(channel, i, now);\n+        }\n+    }\n+}\n+\n+static void handle_error(ares_channel channel, int whichserver,\n+                         struct timeval *now)\n+{\n+  struct server_state *server;\n+  struct query *query;\n+  struct list_node list_head;\n+  struct list_node* list_node;\n+\n+  server = &channel->servers[whichserver];\n+\n+  /* Reset communications with this server. */\n+  ares__close_sockets(channel, server);\n+\n+  /* Tell all queries talking to this server to move on and not try\n+   * this server again. We steal the current list of queries that were\n+   * in-flight to this server, since when we call next_server this can\n+   * cause the queries to be re-sent to this server, which will\n+   * re-insert these queries in that same server->queries_to_server\n+   * list.\n+   */\n+  ares__init_list_head(&list_head);\n+  ares__swap_lists(&list_head, &(server->queries_to_server));\n+  for (list_node = list_head.next; list_node != &list_head; )\n+    {\n+      query = list_node->data;\n+      list_node = list_node->next;  /* in case the query gets deleted */\n+      assert(query->server == whichserver);\n+      skip_server(channel, query, whichserver);\n+      next_server(channel, query, now);\n+    }\n+  /* Each query should have removed itself from our temporary list as\n+   * it re-sent itself or finished up...\n+   */\n+  assert(ares__is_list_empty(&list_head));\n+}\n+\n+static void skip_server(ares_channel channel, struct query *query,\n+                        int whichserver) {\n+  /* The given server gave us problems with this query, so if we have\n+   * the luxury of using other servers, then let's skip the\n+   * potentially broken server and just use the others. If we only\n+   * have one server and we need to retry then we should just go ahead\n+   * and re-use that server, since it's our only hope; perhaps we\n+   * just got unlucky, and retrying will work (eg, the server timed\n+   * out our TCP connection just as we were sending another request).\n+   */\n+  if (channel->nservers > 1)\n+    {\n+      query->server_info[whichserver].skip_server = 1;\n+    }\n+}\n+\n+static void next_server(ares_channel channel, struct query *query,\n+                        struct timeval *now)\n+{\n+  /* We need to try each server channel->tries times. We have channel->nservers\n+   * servers to try. In total, we need to do channel->nservers * channel->tries\n+   * attempts. Use query->try to remember how many times we already attempted\n+   * this query. Use modular arithmetic to find the next server to try. */\n+  while (++(query->try) < (channel->nservers * channel->tries))\n+    {\n+      struct server_state *server;\n+\n+      /* Move on to the next server. */\n+      query->server = (query->server + 1) % channel->nservers;\n+      server = &channel->servers[query->server];\n+\n+      /* We don't want to use this server if (1) we decided this\n+       * connection is broken, and thus about to be closed, (2)\n+       * we've decided to skip this server because of earlier\n+       * errors we encountered, or (3) we already sent this query\n+       * over this exact connection.\n+       */\n+      if (!server->is_broken &&\n+           !query->server_info[query->server].skip_server &&\n+           !(query->using_tcp &&\n+             (query->server_info[query->server].tcp_connection_generation ==\n+              server->tcp_connection_generation)))\n+        {\n+           ares__send_query(channel, query, now);\n+           return;\n+        }\n+\n+      /* You might think that with TCP we only need one try. However,\n+       * even when using TCP, servers can time-out our connection just\n+       * as we're sending a request, or close our connection because\n+       * they die, or never send us a reply because they get wedged or\n+       * tickle a bug that drops our request.\n+       */\n+    }\n+\n+  /* If we are here, all attempts to perform query failed. */\n+  end_query(channel, query, query->error_status, NULL, 0);\n+}\n+\n+void ares__send_query(ares_channel channel, struct query *query,\n+                      struct timeval *now)\n+{\n+  struct send_request *sendreq;\n+  struct server_state *server;\n+  int timeplus;\n+\n+  server = &channel->servers[query->server];\n+  if (query->using_tcp)\n+    {\n+      /* Make sure the TCP socket for this server is set up and queue\n+       * a send request.\n+       */\n+      if (server->tcp_socket == ARES_SOCKET_BAD)\n+        {\n+          if (open_tcp_socket(channel, server) == -1)\n+            {\n+              skip_server(channel, query, query->server);\n+              next_server(channel, query, now);\n+              return;\n+            }\n+        }\n+      sendreq = calloc(1, sizeof(struct send_request));\n+      if (!sendreq)\n+        {\n+        end_query(channel, query, ARES_ENOMEM, NULL, 0);\n+          return;\n+        }\n+      /* To make the common case fast, we avoid copies by using the\n+       * query's tcpbuf for as long as the query is alive. In the rare\n+       * case where the query ends while it's queued for transmission,\n+       * then we give the sendreq its own copy of the request packet\n+       * and put it in sendreq->data_storage.\n+       */\n+      sendreq->data_storage = NULL;\n+      sendreq->data = query->tcpbuf;\n+      sendreq->len = query->tcplen;\n+      sendreq->owner_query = query;\n+      sendreq->next = NULL;\n+      if (server->qtail)\n+        server->qtail->next = sendreq;\n+      else\n+        {\n+          SOCK_STATE_CALLBACK(channel, server->tcp_socket, 1, 1);\n+          server->qhead = sendreq;\n+        }\n+      server->qtail = sendreq;\n+      query->server_info[query->server].tcp_connection_generation =\n+        server->tcp_connection_generation;\n+    }\n+  else\n+    {\n+      if (server->udp_socket == ARES_SOCKET_BAD)\n+        {\n+          if (open_udp_socket(channel, server) == -1)\n+            {\n+              skip_server(channel, query, query->server);\n+              next_server(channel, query, now);\n+              return;\n+            }\n+        }\n+      if (swrite(server->udp_socket, query->qbuf, query->qlen) == -1)\n+        {\n+          /* FIXME: Handle EAGAIN here since it likely can happen. */\n+          skip_server(channel, query, query->server);\n+          next_server(channel, query, now);\n+          return;\n+        }\n+    }\n+    timeplus = channel->timeout << (query->try / channel->nservers);\n+    timeplus = (timeplus * (9 + (rand () & 7))) / 16;\n+    query->timeout = *now;\n+    ares__timeadd(&query->timeout,\n+                  timeplus);\n+    /* Keep track of queries bucketed by timeout, so we can process\n+     * timeout events quickly.\n+     */\n+    ares__remove_from_list(&(query->queries_by_timeout));\n+    ares__insert_in_list(\n+        &(query->queries_by_timeout),\n+        &(channel->queries_by_timeout[query->timeout.tv_sec %\n+                                      ARES_TIMEOUT_TABLE_SIZE]));\n+\n+    /* Keep track of queries bucketed by server, so we can process server\n+     * errors quickly.\n+     */\n+    ares__remove_from_list(&(query->queries_to_server));\n+    ares__insert_in_list(&(query->queries_to_server),\n+                         &(server->queries_to_server));\n+}\n+\n+/*\n+ * setsocknonblock sets the given socket to either blocking or non-blocking\n+ * mode based on the 'nonblock' boolean argument. This function is highly\n+ * portable.\n+ */\n+static int setsocknonblock(ares_socket_t sockfd,    /* operate on this */\n+                    int nonblock   /* TRUE or FALSE */)\n+{\n+#if defined(USE_BLOCKING_SOCKETS)\n+\n+  return 0; /* returns success */\n+\n+#elif defined(HAVE_FCNTL_O_NONBLOCK)\n+\n+  /* most recent unix versions */\n+  int flags;\n+  flags = fcntl(sockfd, F_GETFL, 0);\n+  if (FALSE != nonblock)\n+    return fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);\n+  else\n+    return fcntl(sockfd, F_SETFL, flags & (~O_NONBLOCK));\n+\n+#elif defined(HAVE_IOCTL_FIONBIO)\n+\n+  /* older unix versions */\n+  int flags;\n+  flags = nonblock;\n+  return ioctl(sockfd, FIONBIO, &flags);\n+\n+#elif defined(HAVE_IOCTLSOCKET_FIONBIO)\n+\n+#ifdef WATT32\n+  char flags;\n+#else\n+  /* Windows */\n+  unsigned long flags;\n+#endif\n+  flags = nonblock;\n+  return ioctlsocket(sockfd, FIONBIO, &flags);\n+\n+#elif defined(HAVE_IOCTLSOCKET_CAMEL_FIONBIO)\n+\n+  /* Amiga */\n+  return IoctlSocket(sockfd, FIONBIO, (long)nonblock);\n+\n+#elif defined(HAVE_SETSOCKOPT_SO_NONBLOCK)\n+\n+  /* BeOS */\n+  long b = nonblock ? 1 : 0;\n+  return setsockopt(sockfd, SOL_SOCKET, SO_NONBLOCK, &b, sizeof(b));\n+\n+#else\n+#  error \"no non-blocking method was found/used/set\"\n+#endif\n+}\n+\n+static int configure_socket(ares_socket_t s, int family, ares_channel channel)\n+{\n+  union {\n+    struct sockaddr     sa;\n+    struct sockaddr_in  sa4;\n+    struct sockaddr_in6 sa6;\n+  } local;\n+\n+  setsocknonblock(s, TRUE);\n+\n+#if defined(FD_CLOEXEC) && !defined(MSDOS)\n+  /* Configure the socket fd as close-on-exec. */\n+  if (fcntl(s, F_SETFD, FD_CLOEXEC) == -1)\n+    return -1;\n+#endif\n+\n+  /* Set the socket's send and receive buffer sizes. */\n+  if ((channel->socket_send_buffer_size > 0) &&\n+      setsockopt(s, SOL_SOCKET, SO_SNDBUF,\n+                 (void *)&channel->socket_send_buffer_size,\n+                 sizeof(channel->socket_send_buffer_size)) == -1)\n+    return -1;\n+\n+  if ((channel->socket_receive_buffer_size > 0) &&\n+      setsockopt(s, SOL_SOCKET, SO_RCVBUF,\n+                 (void *)&channel->socket_receive_buffer_size,\n+                 sizeof(channel->socket_receive_buffer_size)) == -1)\n+    return -1;\n+\n+#ifdef SO_BINDTODEVICE\n+  if (channel->local_dev_name[0]) {\n+    if (setsockopt(s, SOL_SOCKET, SO_BINDTODEVICE,\n+                   channel->local_dev_name, sizeof(channel->local_dev_name))) {\n+      /* Only root can do this, and usually not fatal if it doesn't work, so */\n+      /* just continue on. */\n+    }\n+  }\n+#endif\n+\n+  if (family == AF_INET) {\n+    if (channel->local_ip4) {\n+      memset(&local.sa4, 0, sizeof(local.sa4));\n+      local.sa4.sin_family = AF_INET;\n+      local.sa4.sin_addr.s_addr = htonl(channel->local_ip4);\n+      if (bind(s, &local.sa, sizeof(local.sa4)) < 0)\n+        return -1;\n+    }\n+  }\n+  else if (family == AF_INET6) {\n+    if (memcmp(channel->local_ip6, &ares_in6addr_any, sizeof(channel->local_ip6)) != 0) {\n+      memset(&local.sa6, 0, sizeof(local.sa6));\n+      local.sa6.sin6_family = AF_INET6;\n+      memcpy(&local.sa6.sin6_addr, channel->local_ip6, sizeof(channel->local_ip6));\n+      if (bind(s, &local.sa, sizeof(local.sa6)) < 0)\n+        return -1;\n+    }\n+  }\n+\n+  return 0;\n+}\n+\n+static int open_tcp_socket(ares_channel channel, struct server_state *server)\n+{\n+  ares_socket_t s;\n+  int opt;\n+  ares_socklen_t salen;\n+  union {\n+    struct sockaddr_in  sa4;\n+    struct sockaddr_in6 sa6;\n+  } saddr;\n+  struct sockaddr *sa;\n+\n+  switch (server->addr.family)\n+    {\n+      case AF_INET:\n+        sa = (void *)&saddr.sa4;\n+        salen = sizeof(saddr.sa4);\n+        memset(sa, 0, salen);\n+        saddr.sa4.sin_family = AF_INET;\n+        saddr.sa4.sin_port = (unsigned short)(channel->tcp_port & 0xffff);\n+        memcpy(&saddr.sa4.sin_addr, &server->addr.addrV4,\n+               sizeof(server->addr.addrV4));\n+        break;\n+      case AF_INET6:\n+        sa = (void *)&saddr.sa6;\n+        salen = sizeof(saddr.sa6);\n+        memset(sa, 0, salen);\n+        saddr.sa6.sin6_family = AF_INET6;\n+        saddr.sa6.sin6_port = (unsigned short)(channel->tcp_port & 0xffff);\n+        memcpy(&saddr.sa6.sin6_addr, &server->addr.addrV6,\n+               sizeof(server->addr.addrV6));\n+        break;\n+      default:\n+        return -1;\n+    }\n+\n+  /* Acquire a socket. */\n+  s = socket(server->addr.family, SOCK_STREAM, 0);\n+  if (s == ARES_SOCKET_BAD)\n+    return -1;\n+\n+  /* Configure it. */\n+  if (configure_socket(s, server->addr.family, channel) < 0)\n+    {\n+       sclose(s);\n+       return -1;\n+    }\n+\n+#ifdef TCP_NODELAY\n+  /*\n+   * Disable the Nagle algorithm (only relevant for TCP sockets, and thus not\n+   * in configure_socket). In general, in DNS lookups we're pretty much\n+   * interested in firing off a single request and then waiting for a reply,\n+   * so batching isn't very interesting.\n+   */\n+  opt = 1;\n+  if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY,\n+                 (void *)&opt, sizeof(opt)) == -1)\n+    {\n+       sclose(s);\n+       return -1;\n+    }\n+#endif\n+\n+  /* Connect to the server. */\n+  if (connect(s, sa, salen) == -1)\n+    {\n+      int err = SOCKERRNO;\n+\n+      if (err != EINPROGRESS && err != EWOULDBLOCK)\n+        {\n+          sclose(s);\n+          return -1;\n+        }\n+    }\n+\n+  if (channel->sock_create_cb)\n+    {\n+      int err = channel->sock_create_cb(s, SOCK_STREAM,\n+                                        channel->sock_create_cb_data);\n+      if (err < 0)\n+        {\n+          sclose(s);\n+          return err;\n+        }\n+    }\n+\n+  SOCK_STATE_CALLBACK(channel, s, 1, 0);\n+  server->tcp_buffer_pos = 0;\n+  server->tcp_socket = s;\n+  server->tcp_connection_generation = ++channel->tcp_connection_generation;\n+  return 0;\n+}\n+\n+static int open_udp_socket(ares_channel channel, struct server_state *server)\n+{\n+  ares_socket_t s;\n+  ares_socklen_t salen;\n+  union {\n+    struct sockaddr_in  sa4;\n+    struct sockaddr_in6 sa6;\n+  } saddr;\n+  struct sockaddr *sa;\n+\n+  switch (server->addr.family)\n+    {\n+      case AF_INET:\n+        sa = (void *)&saddr.sa4;\n+        salen = sizeof(saddr.sa4);\n+        memset(sa, 0, salen);\n+        saddr.sa4.sin_family = AF_INET;\n+        saddr.sa4.sin_port = (unsigned short)(channel->udp_port & 0xffff);\n+        memcpy(&saddr.sa4.sin_addr, &server->addr.addrV4,\n+               sizeof(server->addr.addrV4));\n+        break;\n+      case AF_INET6:\n+        sa = (void *)&saddr.sa6;\n+        salen = sizeof(saddr.sa6);\n+        memset(sa, 0, salen);\n+        saddr.sa6.sin6_family = AF_INET6;\n+        saddr.sa6.sin6_port = (unsigned short)(channel->udp_port & 0xffff);\n+        memcpy(&saddr.sa6.sin6_addr, &server->addr.addrV6,\n+               sizeof(server->addr.addrV6));\n+        break;\n+      default:\n+        return -1;\n+    }\n+\n+  /* Acquire a socket. */\n+  s = socket(server->addr.family, SOCK_DGRAM, 0);\n+  if (s == ARES_SOCKET_BAD)\n+    return -1;\n+\n+  /* Set the socket non-blocking. */\n+  if (configure_socket(s, server->addr.family, channel) < 0)\n+    {\n+       sclose(s);\n+       return -1;\n+    }\n+\n+  /* Connect to the server. */\n+  if (connect(s, sa, salen) == -1)\n+    {\n+      int err = SOCKERRNO;\n+\n+      if (err != EINPROGRESS && err != EWOULDBLOCK)\n+        {\n+          sclose(s);\n+          return -1;\n+        }\n+    }\n+\n+  if (channel->sock_create_cb)\n+    {\n+      int err = channel->sock_create_cb(s, SOCK_DGRAM,\n+                                        channel->sock_create_cb_data);\n+      if (err < 0)\n+        {\n+          sclose(s);\n+          return err;\n+        }\n+    }\n+\n+  SOCK_STATE_CALLBACK(channel, s, 1, 0);\n+\n+  server->udp_socket = s;\n+  return 0;\n+}\n+\n+static int same_questions(const unsigned char *qbuf, int qlen,\n+                          const unsigned char *abuf, int alen)\n+{\n+  struct {\n+    const unsigned char *p;\n+    int qdcount;\n+    char *name;\n+    long namelen;\n+    int type;\n+    int dnsclass;\n+  } q, a;\n+  int i, j;\n+\n+  if (qlen < HFIXEDSZ || alen < HFIXEDSZ)\n+    return 0;\n+\n+  /* Extract qdcount from the request and reply buffers and compare them. */\n+  q.qdcount = DNS_HEADER_QDCOUNT(qbuf);\n+  a.qdcount = DNS_HEADER_QDCOUNT(abuf);\n+  if (q.qdcount != a.qdcount)\n+    return 0;\n+\n+  /* For each question in qbuf, find it in abuf. */\n+  q.p = qbuf + HFIXEDSZ;\n+  for (i = 0; i < q.qdcount; i++)\n+    {\n+      /* Decode the question in the query. */\n+      if (ares_expand_name(q.p, qbuf, qlen, &q.name, &q.namelen)\n+          != ARES_SUCCESS)\n+        return 0;\n+      q.p += q.namelen;\n+      if (q.p + QFIXEDSZ > qbuf + qlen)\n+        {\n+          free(q.name);\n+          return 0;\n+        }\n+      q.type = DNS_QUESTION_TYPE(q.p);\n+      q.dnsclass = DNS_QUESTION_CLASS(q.p);\n+      q.p += QFIXEDSZ;\n+\n+      /* Search for this question in the answer. */\n+      a.p = abuf + HFIXEDSZ;\n+      for (j = 0; j < a.qdcount; j++)\n+        {\n+          /* Decode the question in the answer. */\n+          if (ares_expand_name(a.p, abuf, alen, &a.name, &a.namelen)\n+              != ARES_SUCCESS)\n+            {\n+              free(q.name);\n+              return 0;\n+            }\n+          a.p += a.namelen;\n+          if (a.p + QFIXEDSZ > abuf + alen)\n+            {\n+              free(q.name);\n+              free(a.name);\n+              return 0;\n+            }\n+          a.type = DNS_QUESTION_TYPE(a.p);\n+          a.dnsclass = DNS_QUESTION_CLASS(a.p);\n+          a.p += QFIXEDSZ;\n+\n+          /* Compare the decoded questions. */\n+          if (strcasecmp(q.name, a.name) == 0 && q.type == a.type\n+              && q.dnsclass == a.dnsclass)\n+            {\n+              free(a.name);\n+              break;\n+            }\n+          free(a.name);\n+        }\n+\n+      free(q.name);\n+      if (j == a.qdcount)\n+        return 0;\n+    }\n+  return 1;\n+}\n+\n+static int same_address(struct sockaddr *sa, struct ares_addr *aa)\n+{\n+  void *addr1;\n+  void *addr2;\n+\n+  if (sa->sa_family == aa->family)\n+    {\n+      switch (aa->family)\n+        {\n+          case AF_INET:\n+            addr1 = &aa->addrV4;\n+            addr2 = &((struct sockaddr_in *)sa)->sin_addr;\n+            if (memcmp(addr1, addr2, sizeof(aa->addrV4)) == 0)\n+              return 1; /* match */\n+            break;\n+          case AF_INET6:\n+            addr1 = &aa->addrV6;\n+            addr2 = &((struct sockaddr_in6 *)sa)->sin6_addr;\n+            if (memcmp(addr1, addr2, sizeof(aa->addrV6)) == 0)\n+              return 1; /* match */\n+            break;\n+          default:\n+            break;\n+        }\n+    }\n+  return 0; /* different */\n+}\n+\n+static void end_query (ares_channel channel, struct query *query, int status,\n+                       unsigned char *abuf, int alen)\n+{\n+  int i;\n+\n+  /* First we check to see if this query ended while one of our send\n+   * queues still has pointers to it.\n+   */\n+  for (i = 0; i < channel->nservers; i++)\n+    {\n+      struct server_state *server = &channel->servers[i];\n+      struct send_request *sendreq;\n+      for (sendreq = server->qhead; sendreq; sendreq = sendreq->next)\n+        if (sendreq->owner_query == query)\n+          {\n+            sendreq->owner_query = NULL;\n+            assert(sendreq->data_storage == NULL);\n+            if (status == ARES_SUCCESS)\n+              {\n+                /* We got a reply for this query, but this queued\n+                 * sendreq points into this soon-to-be-gone query's\n+                 * tcpbuf. Probably this means we timed out and queued\n+                 * the query for retransmission, then received a\n+                 * response before actually retransmitting. This is\n+                 * perfectly fine, so we want to keep the connection\n+                 * running smoothly if we can. But in the worst case\n+                 * we may have sent only some prefix of the query,\n+                 * with some suffix of the query left to send. Also,\n+                 * the buffer may be queued on multiple queues. To\n+                 * prevent dangling pointers to the query's tcpbuf and\n+                 * handle these cases, we just give such sendreqs\n+                 * their own copy of the query packet.\n+                 */\n+               sendreq->data_storage = malloc(sendreq->len);\n+               if (sendreq->data_storage != NULL)\n+                 {\n+                   memcpy(sendreq->data_storage, sendreq->data, sendreq->len);\n+                   sendreq->data = sendreq->data_storage;\n+                 }\n+              }\n+            if ((status != ARES_SUCCESS) || (sendreq->data_storage == NULL))\n+              {\n+                /* We encountered an error (probably a timeout,\n+                 * suggesting the DNS server we're talking to is\n+                 * probably unreachable, wedged, or severely\n+                 * overloaded) or we couldn't copy the request, so\n+                 * mark the connection as broken. When we get to\n+                 * process_broken_connections() we'll close the\n+                 * connection and try to re-send requests to another\n+                 * server.\n+                 */\n+               server->is_broken = 1;\n+               /* Just to be paranoid, zero out this sendreq... */\n+               sendreq->data = NULL;\n+               sendreq->len = 0;\n+             }\n+          }\n+    }\n+\n+  /* Invoke the callback */\n+  query->callback(query->arg, status, query->timeouts, abuf, alen);\n+  ares__free_query(query);\n+\n+  /* Simple cleanup policy: if no queries are remaining, close all\n+   * network sockets unless STAYOPEN is set.\n+   */\n+  if (!(channel->flags & ARES_FLAG_STAYOPEN) &&\n+      ares__is_list_empty(&(channel->all_queries)))\n+    {\n+      for (i = 0; i < channel->nservers; i++)\n+        ares__close_sockets(channel, &channel->servers[i]);\n+    }\n+}\n+\n+void ares__free_query(struct query *query)\n+{\n+  /* Remove the query from all the lists in which it is linked */\n+  ares__remove_from_list(&(query->queries_by_qid));\n+  ares__remove_from_list(&(query->queries_by_timeout));\n+  ares__remove_from_list(&(query->queries_to_server));\n+  ares__remove_from_list(&(query->all_queries));\n+  /* Zero out some important stuff, to help catch bugs */\n+  query->callback = NULL;\n+  query->arg = NULL;\n+  /* Deallocate the memory associated with the query */\n+  free(query->tcpbuf);\n+  free(query->server_info);\n+  free(query);\n+}"}, {"sha": "63652e229d274b6eba21ad076399c979318f5ac2", "filename": "src/rt/libuv/src/ares/ares_query.c", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_query.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_query.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_query.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,183 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n+#  include <arpa/nameser_compat.h>\n+#endif\n+\n+#include <stdlib.h>\n+#include \"ares.h\"\n+#include \"ares_dns.h\"\n+#include \"ares_private.h\"\n+\n+struct qquery {\n+  ares_callback callback;\n+  void *arg;\n+};\n+\n+static void qcallback(void *arg, int status, int timeouts, unsigned char *abuf, int alen);\n+\n+void ares__rc4(rc4_key* key, unsigned char *buffer_ptr, int buffer_len)\n+{\n+  unsigned char x;\n+  unsigned char y;\n+  unsigned char* state;\n+  unsigned char xorIndex;\n+  short counter;\n+\n+  x = key->x;\n+  y = key->y;\n+\n+  state = &key->state[0];\n+  for(counter = 0; counter < buffer_len; counter ++)\n+  {\n+    x = (unsigned char)((x + 1) % 256);\n+    y = (unsigned char)((state[x] + y) % 256);\n+    ARES_SWAP_BYTE(&state[x], &state[y]);\n+\n+    xorIndex = (unsigned char)((state[x] + state[y]) % 256);\n+\n+    buffer_ptr[counter] = (unsigned char)(buffer_ptr[counter]^state[xorIndex]);\n+  }\n+  key->x = x;\n+  key->y = y;\n+}\n+\n+static struct query* find_query_by_id(ares_channel channel, unsigned short id)\n+{\n+  unsigned short qid;\n+  struct list_node* list_head;\n+  struct list_node* list_node;\n+  DNS_HEADER_SET_QID(((unsigned char*)&qid), id);\n+\n+  /* Find the query corresponding to this packet. */\n+  list_head = &(channel->queries_by_qid[qid % ARES_QID_TABLE_SIZE]);\n+  for (list_node = list_head->next; list_node != list_head;\n+       list_node = list_node->next)\n+    {\n+       struct query *q = list_node->data;\n+       if (q->qid == qid)\n+\t  return q;\n+    }\n+  return NULL;\n+}\n+\n+\n+/* a unique query id is generated using an rc4 key. Since the id may already\n+   be used by a running query (as infrequent as it may be), a lookup is\n+   performed per id generation. In practice this search should happen only\n+   once per newly generated id\n+*/\n+static unsigned short generate_unique_id(ares_channel channel)\n+{\n+  unsigned short id;\n+\n+  do {\n+    id = ares__generate_new_id(&channel->id_key);\n+  } while (find_query_by_id(channel, id));\n+\n+  return (unsigned short)id;\n+}\n+\n+void ares_query(ares_channel channel, const char *name, int dnsclass,\n+                int type, ares_callback callback, void *arg)\n+{\n+  struct qquery *qquery;\n+  unsigned char *qbuf;\n+  int qlen, rd, status;\n+\n+  /* Compose the query. */\n+  rd = !(channel->flags & ARES_FLAG_NORECURSE);\n+  status = ares_mkquery(name, dnsclass, type, channel->next_id, rd, &qbuf,\n+                        &qlen);\n+  if (status != ARES_SUCCESS)\n+    {\n+      if (qbuf != NULL) free(qbuf);\n+      callback(arg, status, 0, NULL, 0);\n+      return;\n+    }\n+\n+  channel->next_id = generate_unique_id(channel);\n+\n+  /* Allocate and fill in the query structure. */\n+  qquery = malloc(sizeof(struct qquery));\n+  if (!qquery)\n+    {\n+      ares_free_string(qbuf);\n+      callback(arg, ARES_ENOMEM, 0, NULL, 0);\n+      return;\n+    }\n+  qquery->callback = callback;\n+  qquery->arg = arg;\n+\n+  /* Send it off.  qcallback will be called when we get an answer. */\n+  ares_send(channel, qbuf, qlen, qcallback, qquery);\n+  ares_free_string(qbuf);\n+}\n+\n+static void qcallback(void *arg, int status, int timeouts, unsigned char *abuf, int alen)\n+{\n+  struct qquery *qquery = (struct qquery *) arg;\n+  unsigned int ancount;\n+  int rcode;\n+\n+  if (status != ARES_SUCCESS)\n+    qquery->callback(qquery->arg, status, timeouts, abuf, alen);\n+  else\n+    {\n+      /* Pull the response code and answer count from the packet. */\n+      rcode = DNS_HEADER_RCODE(abuf);\n+      ancount = DNS_HEADER_ANCOUNT(abuf);\n+\n+      /* Convert errors. */\n+      switch (rcode)\n+        {\n+        case NOERROR:\n+          status = (ancount > 0) ? ARES_SUCCESS : ARES_ENODATA;\n+          break;\n+        case FORMERR:\n+          status = ARES_EFORMERR;\n+          break;\n+        case SERVFAIL:\n+          status = ARES_ESERVFAIL;\n+          break;\n+        case NXDOMAIN:\n+          status = ARES_ENOTFOUND;\n+          break;\n+        case NOTIMP:\n+          status = ARES_ENOTIMP;\n+          break;\n+        case REFUSED:\n+          status = ARES_EREFUSED;\n+          break;\n+        }\n+      qquery->callback(qquery->arg, status, timeouts, abuf, alen);\n+    }\n+  free(qquery);\n+}"}, {"sha": "f94c5b59165e7adb20c67a29103b95c5136298b5", "filename": "src/rt/libuv/src/ares/ares_rules.h", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_rules.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_rules.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_rules.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,144 @@\n+#ifndef __CARES_RULES_H\n+#define __CARES_RULES_H\n+\n+\n+/* Copyright (C) 2009 by Daniel Stenberg et al\n+ *\n+ * Permission to use, copy, modify, and distribute this software and its\n+ * documentation for any purpose and without fee is hereby granted, provided\n+ * that the above copyright notice appear in all copies and that both that\n+ * copyright notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in advertising or\n+ * publicity pertaining to distribution of the software without specific,\n+ * written prior permission.  M.I.T. makes no representations about the\n+ * suitability of this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+/* ================================================================ */\n+/*                    COMPILE TIME SANITY CHECKS                    */\n+/* ================================================================ */\n+\n+/*\n+ * NOTE 1:\n+ * -------\n+ *\n+ * All checks done in this file are intentionally placed in a public\n+ * header file which is pulled by ares.h when an application is\n+ * being built using an already built c-ares library. Additionally\n+ * this file is also included and used when building the library.\n+ *\n+ * If compilation fails on this file it is certainly sure that the\n+ * problem is elsewhere. It could be a problem in the ares_build.h\n+ * header file, or simply that you are using different compilation\n+ * settings than those used to build the library.\n+ *\n+ * Nothing in this file is intended to be modified or adjusted by the\n+ * c-ares library user nor by the c-ares library builder.\n+ *\n+ * Do not deactivate any check, these are done to make sure that the\n+ * library is properly built and used.\n+ *\n+ * You can find further help on the c-ares development mailing list:\n+ * http://cool.haxx.se/mailman/listinfo/c-ares/\n+ *\n+ * NOTE 2\n+ * ------\n+ *\n+ * Some of the following compile time checks are based on the fact\n+ * that the dimension of a constant array can not be a negative one.\n+ * In this way if the compile time verification fails, the compilation\n+ * will fail issuing an error. The error description wording is compiler\n+ * dependent but it will be quite similar to one of the following:\n+ *\n+ *   \"negative subscript or subscript is too large\"\n+ *   \"array must have at least one element\"\n+ *   \"-1 is an illegal array size\"\n+ *   \"size of array is negative\"\n+ *\n+ * If you are building an application which tries to use an already\n+ * built c-ares library and you are getting this kind of errors on\n+ * this file, it is a clear indication that there is a mismatch between\n+ * how the library was built and how you are trying to use it for your\n+ * application. Your already compiled or binary library provider is the\n+ * only one who can give you the details you need to properly use it.\n+ */\n+\n+/*\n+ * Verify that some macros are actually defined.\n+ */\n+\n+#ifndef CARES_SIZEOF_LONG\n+#  error \"CARES_SIZEOF_LONG definition is missing!\"\n+   Error Compilation_aborted_CARES_SIZEOF_LONG_is_missing\n+#endif\n+\n+#ifndef CARES_TYPEOF_ARES_SOCKLEN_T\n+#  error \"CARES_TYPEOF_ARES_SOCKLEN_T definition is missing!\"\n+   Error Compilation_aborted_CARES_TYPEOF_ARES_SOCKLEN_T_is_missing\n+#endif\n+\n+#ifndef CARES_SIZEOF_ARES_SOCKLEN_T\n+#  error \"CARES_SIZEOF_ARES_SOCKLEN_T definition is missing!\"\n+   Error Compilation_aborted_CARES_SIZEOF_ARES_SOCKLEN_T_is_missing\n+#endif\n+\n+/*\n+ * Macros private to this header file.\n+ */\n+\n+#define CareschkszEQ(t, s) sizeof(t) == s ? 1 : -1\n+\n+#define CareschkszGE(t1, t2) sizeof(t1) >= sizeof(t2) ? 1 : -1\n+\n+/*\n+ * Verify that the size previously defined and expected for long\n+ * is the same as the one reported by sizeof() at compile time.\n+ */\n+\n+typedef char\n+  __cares_rule_01__\n+    [CareschkszEQ(long, CARES_SIZEOF_LONG)];\n+\n+/*\n+ * Verify that the size previously defined and expected for\n+ * ares_socklen_t is actually the the same as the one reported\n+ * by sizeof() at compile time.\n+ */\n+\n+typedef char\n+  __cares_rule_02__\n+    [CareschkszEQ(ares_socklen_t, CARES_SIZEOF_ARES_SOCKLEN_T)];\n+\n+/*\n+ * Verify at compile time that the size of ares_socklen_t as reported\n+ * by sizeof() is greater or equal than the one reported for int for\n+ * the current compilation.\n+ */\n+\n+typedef char\n+  __cares_rule_03__\n+    [CareschkszGE(ares_socklen_t, int)];\n+\n+/* ================================================================ */\n+/*          EXTERNALLY AND INTERNALLY VISIBLE DEFINITIONS           */\n+/* ================================================================ */\n+\n+/*\n+ * Get rid of macros private to this header file.\n+ */\n+\n+#undef CareschkszEQ\n+#undef CareschkszGE\n+\n+/*\n+ * Get rid of macros not intended to exist beyond this point.\n+ */\n+\n+#undef CARES_PULL_WS2TCPIP_H\n+#undef CARES_PULL_SYS_TYPES_H\n+#undef CARES_PULL_SYS_SOCKET_H\n+\n+#undef CARES_TYPEOF_ARES_SOCKLEN_T\n+\n+#endif /* __CARES_RULES_H */"}, {"sha": "608cb153d329b617c28ef2a618c22056b6932b9b", "filename": "src/rt/libuv/src/ares/ares_search.c", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_search.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_search.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_search.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,322 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <ctype.h>\n+#include <errno.h>\n+\n+#ifdef HAVE_STRINGS_H\n+#  include <strings.h>\n+#endif\n+\n+#include \"ares.h\"\n+#include \"ares_private.h\"\n+\n+struct search_query {\n+  /* Arguments passed to ares_search */\n+  ares_channel channel;\n+  char *name;                   /* copied into an allocated buffer */\n+  int dnsclass;\n+  int type;\n+  ares_callback callback;\n+  void *arg;\n+\n+  int status_as_is;             /* error status from trying as-is */\n+  int next_domain;              /* next search domain to try */\n+  int trying_as_is;             /* current query is for name as-is */\n+  int timeouts;                 /* number of timeouts we saw for this request */\n+  int ever_got_nodata;          /* did we ever get ARES_ENODATA along the way? */\n+};\n+\n+static void search_callback(void *arg, int status, int timeouts,\n+                            unsigned char *abuf, int alen);\n+static void end_squery(struct search_query *squery, int status,\n+                       unsigned char *abuf, int alen);\n+static int cat_domain(const char *name, const char *domain, char **s);\n+static int single_domain(ares_channel channel, const char *name, char **s);\n+\n+void ares_search(ares_channel channel, const char *name, int dnsclass,\n+                 int type, ares_callback callback, void *arg)\n+{\n+  struct search_query *squery;\n+  char *s;\n+  const char *p;\n+  int status, ndots;\n+\n+  /* If name only yields one domain to search, then we don't have\n+   * to keep extra state, so just do an ares_query().\n+   */\n+  status = single_domain(channel, name, &s);\n+  if (status != ARES_SUCCESS)\n+    {\n+      callback(arg, status, 0, NULL, 0);\n+      return;\n+    }\n+  if (s)\n+    {\n+      ares_query(channel, s, dnsclass, type, callback, arg);\n+      free(s);\n+      return;\n+    }\n+\n+  /* Allocate a search_query structure to hold the state necessary for\n+   * doing multiple lookups.\n+   */\n+  squery = malloc(sizeof(struct search_query));\n+  if (!squery)\n+    {\n+      callback(arg, ARES_ENOMEM, 0, NULL, 0);\n+      return;\n+    }\n+  squery->channel = channel;\n+  squery->name = strdup(name);\n+  if (!squery->name)\n+    {\n+      free(squery);\n+      callback(arg, ARES_ENOMEM, 0, NULL, 0);\n+      return;\n+    }\n+  squery->dnsclass = dnsclass;\n+  squery->type = type;\n+  squery->status_as_is = -1;\n+  squery->callback = callback;\n+  squery->arg = arg;\n+  squery->timeouts = 0;\n+  squery->ever_got_nodata = 0;\n+\n+  /* Count the number of dots in name. */\n+  ndots = 0;\n+  for (p = name; *p; p++)\n+    {\n+      if (*p == '.')\n+        ndots++;\n+    }\n+\n+  /* If ndots is at least the channel ndots threshold (usually 1),\n+   * then we try the name as-is first.  Otherwise, we try the name\n+   * as-is last.\n+   */\n+  if (ndots >= channel->ndots)\n+    {\n+      /* Try the name as-is first. */\n+      squery->next_domain = 0;\n+      squery->trying_as_is = 1;\n+      ares_query(channel, name, dnsclass, type, search_callback, squery);\n+    }\n+  else\n+    {\n+      /* Try the name as-is last; start with the first search domain. */\n+      squery->next_domain = 1;\n+      squery->trying_as_is = 0;\n+      status = cat_domain(name, channel->domains[0], &s);\n+      if (status == ARES_SUCCESS)\n+        {\n+          ares_query(channel, s, dnsclass, type, search_callback, squery);\n+          free(s);\n+        }\n+      else\n+      {\n+        /* failed, free the malloc()ed memory */\n+        free(squery->name);\n+        free(squery);\n+        callback(arg, status, 0, NULL, 0);\n+      }\n+    }\n+}\n+\n+static void search_callback(void *arg, int status, int timeouts,\n+                            unsigned char *abuf, int alen)\n+{\n+  struct search_query *squery = (struct search_query *) arg;\n+  ares_channel channel = squery->channel;\n+  char *s;\n+\n+  squery->timeouts += timeouts;\n+\n+  /* Stop searching unless we got a non-fatal error. */\n+  if (status != ARES_ENODATA && status != ARES_ESERVFAIL\n+      && status != ARES_ENOTFOUND)\n+    end_squery(squery, status, abuf, alen);\n+  else\n+    {\n+      /* Save the status if we were trying as-is. */\n+      if (squery->trying_as_is)\n+        squery->status_as_is = status;\n+\n+      /*\n+       * If we ever get ARES_ENODATA along the way, record that; if the search\n+       * should run to the very end and we got at least one ARES_ENODATA,\n+       * then callers like ares_gethostbyname() may want to try a T_A search\n+       * even if the last domain we queried for T_AAAA resource records\n+       * returned ARES_ENOTFOUND.\n+       */\n+      if (status == ARES_ENODATA)\n+        squery->ever_got_nodata = 1;\n+\n+      if (squery->next_domain < channel->ndomains)\n+        {\n+          /* Try the next domain. */\n+          status = cat_domain(squery->name,\n+                              channel->domains[squery->next_domain], &s);\n+          if (status != ARES_SUCCESS)\n+            end_squery(squery, status, NULL, 0);\n+          else\n+            {\n+              squery->trying_as_is = 0;\n+              squery->next_domain++;\n+              ares_query(channel, s, squery->dnsclass, squery->type,\n+                         search_callback, squery);\n+              free(s);\n+            }\n+        }\n+      else if (squery->status_as_is == -1)\n+        {\n+          /* Try the name as-is at the end. */\n+          squery->trying_as_is = 1;\n+          ares_query(channel, squery->name, squery->dnsclass, squery->type,\n+                     search_callback, squery);\n+        }\n+      else {\n+        if (squery->status_as_is == ARES_ENOTFOUND && squery->ever_got_nodata) {\n+          end_squery(squery, ARES_ENODATA, NULL, 0);\n+        }\n+        else\n+          end_squery(squery, squery->status_as_is, NULL, 0);\n+      }\n+    }\n+}\n+\n+static void end_squery(struct search_query *squery, int status,\n+                       unsigned char *abuf, int alen)\n+{\n+  squery->callback(squery->arg, status, squery->timeouts, abuf, alen);\n+  free(squery->name);\n+  free(squery);\n+}\n+\n+/* Concatenate two domains. */\n+static int cat_domain(const char *name, const char *domain, char **s)\n+{\n+  size_t nlen = strlen(name);\n+  size_t dlen = strlen(domain);\n+\n+  *s = malloc(nlen + 1 + dlen + 1);\n+  if (!*s)\n+    return ARES_ENOMEM;\n+  memcpy(*s, name, nlen);\n+  (*s)[nlen] = '.';\n+  memcpy(*s + nlen + 1, domain, dlen);\n+  (*s)[nlen + 1 + dlen] = 0;\n+  return ARES_SUCCESS;\n+}\n+\n+/* Determine if this name only yields one query.  If it does, set *s to\n+ * the string we should query, in an allocated buffer.  If not, set *s\n+ * to NULL.\n+ */\n+static int single_domain(ares_channel channel, const char *name, char **s)\n+{\n+  size_t len = strlen(name);\n+  const char *hostaliases;\n+  FILE *fp;\n+  char *line = NULL;\n+  int status;\n+  size_t linesize;\n+  const char *p, *q;\n+  int error;\n+\n+  /* If the name contains a trailing dot, then the single query is the name\n+   * sans the trailing dot.\n+   */\n+  if (name[len - 1] == '.')\n+    {\n+      *s = strdup(name);\n+      return (*s) ? ARES_SUCCESS : ARES_ENOMEM;\n+    }\n+\n+  if (!(channel->flags & ARES_FLAG_NOALIASES) && !strchr(name, '.'))\n+    {\n+      /* The name might be a host alias. */\n+      hostaliases = getenv(\"HOSTALIASES\");\n+      if (hostaliases)\n+        {\n+          fp = fopen(hostaliases, \"r\");\n+          if (fp)\n+            {\n+              while ((status = ares__read_line(fp, &line, &linesize))\n+                     == ARES_SUCCESS)\n+                {\n+                  if (strncasecmp(line, name, len) != 0 ||\n+                      !ISSPACE(line[len]))\n+                    continue;\n+                  p = line + len;\n+                  while (ISSPACE(*p))\n+                    p++;\n+                  if (*p)\n+                    {\n+                      q = p + 1;\n+                      while (*q && !ISSPACE(*q))\n+                        q++;\n+                      *s = malloc(q - p + 1);\n+                      if (*s)\n+                        {\n+                          memcpy(*s, p, q - p);\n+                          (*s)[q - p] = 0;\n+                        }\n+                      free(line);\n+                      fclose(fp);\n+                      return (*s) ? ARES_SUCCESS : ARES_ENOMEM;\n+                    }\n+                }\n+              free(line);\n+              fclose(fp);\n+              if (status != ARES_SUCCESS && status != ARES_EOF)\n+                return status;\n+            }\n+          else\n+            {\n+              error = errno;\n+              switch(error)\n+                {\n+                case ENOENT:\n+                case ESRCH:\n+                  break;\n+                default:\n+                  DEBUGF(fprintf(stderr, \"fopen() failed with error: %d %s\\n\",\n+                                 error, strerror(error)));\n+                  DEBUGF(fprintf(stderr, \"Error opening file: %s\\n\",\n+                                 hostaliases));\n+                  *s = NULL;\n+                  return ARES_EFILE;\n+                }\n+            }\n+        }\n+    }\n+\n+  if (channel->flags & ARES_FLAG_NOSEARCH || channel->ndomains == 0)\n+    {\n+      /* No domain search to do; just try the name as-is. */\n+      *s = strdup(name);\n+      return (*s) ? ARES_SUCCESS : ARES_ENOMEM;\n+    }\n+\n+  *s = NULL;\n+  return ARES_SUCCESS;\n+}"}, {"sha": "9f24d339a8a0044b1f96631361699e1b75077960", "filename": "src/rt/libuv/src/ares/ares_send.c", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_send.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_send.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_send.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,134 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n+#  include <arpa/nameser_compat.h>\n+#endif\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <time.h>\n+#include \"ares.h\"\n+#include \"ares_dns.h\"\n+#include \"ares_private.h\"\n+\n+void ares_send(ares_channel channel, const unsigned char *qbuf, int qlen,\n+               ares_callback callback, void *arg)\n+{\n+  struct query *query;\n+  int i;\n+  struct timeval now;\n+\n+  /* Verify that the query is at least long enough to hold the header. */\n+  if (qlen < HFIXEDSZ || qlen >= (1 << 16))\n+    {\n+      callback(arg, ARES_EBADQUERY, 0, NULL, 0);\n+      return;\n+    }\n+\n+  /* Allocate space for query and allocated fields. */\n+  query = malloc(sizeof(struct query));\n+  if (!query)\n+    {\n+      callback(arg, ARES_ENOMEM, 0, NULL, 0);\n+      return;\n+    }\n+  query->tcpbuf = malloc(qlen + 2);\n+  if (!query->tcpbuf)\n+    {\n+      free(query);\n+      callback(arg, ARES_ENOMEM, 0, NULL, 0);\n+      return;\n+    }\n+  query->server_info = malloc(channel->nservers *\n+                              sizeof(query->server_info[0]));\n+  if (!query->server_info)\n+    {\n+      free(query->tcpbuf);\n+      free(query);\n+      callback(arg, ARES_ENOMEM, 0, NULL, 0);\n+      return;\n+    }\n+\n+  /* Compute the query ID.  Start with no timeout. */\n+  query->qid = (unsigned short)DNS_HEADER_QID(qbuf);\n+  query->timeout.tv_sec = 0;\n+  query->timeout.tv_usec = 0;\n+\n+  /* Form the TCP query buffer by prepending qlen (as two\n+   * network-order bytes) to qbuf.\n+   */\n+  query->tcpbuf[0] = (unsigned char)((qlen >> 8) & 0xff);\n+  query->tcpbuf[1] = (unsigned char)(qlen & 0xff);\n+  memcpy(query->tcpbuf + 2, qbuf, qlen);\n+  query->tcplen = qlen + 2;\n+\n+  /* Fill in query arguments. */\n+  query->qbuf = query->tcpbuf + 2;\n+  query->qlen = qlen;\n+  query->callback = callback;\n+  query->arg = arg;\n+\n+  /* Initialize query status. */\n+  query->try = 0;\n+\n+  /* Choose the server to send the query to. If rotation is enabled, keep track\n+   * of the next server we want to use. */\n+  query->server = channel->last_server;\n+  if (channel->rotate == 1)\n+    channel->last_server = (channel->last_server + 1) % channel->nservers;\n+\n+  for (i = 0; i < channel->nservers; i++)\n+    {\n+      query->server_info[i].skip_server = 0;\n+      query->server_info[i].tcp_connection_generation = 0;\n+    }\n+  query->using_tcp = (channel->flags & ARES_FLAG_USEVC) || qlen > PACKETSZ;\n+  query->error_status = ARES_ECONNREFUSED;\n+  query->timeouts = 0;\n+\n+  /* Initialize our list nodes. */\n+  ares__init_list_node(&(query->queries_by_qid),     query);\n+  ares__init_list_node(&(query->queries_by_timeout), query);\n+  ares__init_list_node(&(query->queries_to_server),  query);\n+  ares__init_list_node(&(query->all_queries),        query);\n+\n+  /* Chain the query into the list of all queries. */\n+  ares__insert_in_list(&(query->all_queries), &(channel->all_queries));\n+  /* Keep track of queries bucketed by qid, so we can process DNS\n+   * responses quickly.\n+   */\n+  ares__insert_in_list(\n+    &(query->queries_by_qid),\n+    &(channel->queries_by_qid[query->qid % ARES_QID_TABLE_SIZE]));\n+\n+  /* Perform the first query action. */\n+  now = ares__tvnow();\n+  ares__send_query(channel, query, &now);\n+}"}, {"sha": "9cec52af76ef0edb86e2953cf6723caaa63bc7cf", "filename": "src/rt/libuv/src/ares/ares_setup.h", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_setup.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_setup.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_setup.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,191 @@\n+#ifndef HEADER_CARES_SETUP_H\n+#define HEADER_CARES_SETUP_H\n+\n+/* $Id$ */\n+\n+/* Copyright (C) 2004 - 2009 by Daniel Stenberg et al\n+ *\n+ * Permission to use, copy, modify, and distribute this software and its\n+ * documentation for any purpose and without fee is hereby granted, provided\n+ * that the above copyright notice appear in all copies and that both that\n+ * copyright notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in advertising or\n+ * publicity pertaining to distribution of the software without specific,\n+ * written prior permission.  M.I.T. makes no representations about the\n+ * suitability of this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+/*\n+ * Define WIN32 when build target is Win32 API\n+ */\n+\n+#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)\n+#define WIN32\n+#endif\n+\n+/*\n+ * Include configuration script results or hand-crafted\n+ * configuration file for platforms which lack config tool.\n+ */\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"ares_config.h\"\n+#endif /* HAVE_CONFIG_H */\n+\n+/* ================================================================ */\n+/* Definition of preprocessor macros/symbols which modify compiler  */\n+/* behaviour or generated code characteristics must be done here,   */\n+/* as appropriate, before any system header file is included. It is */\n+/* also possible to have them defined in the config file included   */\n+/* before this point. As a result of all this we frown inclusion of */\n+/* system header files in our config files, avoid this at any cost. */\n+/* ================================================================ */\n+\n+/*\n+ * AIX 4.3 and newer needs _THREAD_SAFE defined to build\n+ * proper reentrant code. Others may also need it.\n+ */\n+\n+#ifdef NEED_THREAD_SAFE\n+#  ifndef _THREAD_SAFE\n+#    define _THREAD_SAFE\n+#  endif\n+#endif\n+\n+/*\n+ * Tru64 needs _REENTRANT set for a few function prototypes and\n+ * things to appear in the system header files. Unixware needs it\n+ * to build proper reentrant code. Others may also need it.\n+ */\n+\n+#ifdef NEED_REENTRANT\n+#  ifndef _REENTRANT\n+#    define _REENTRANT\n+#  endif\n+#endif\n+\n+/* ================================================================ */\n+/*  If you need to include a system header file for your platform,  */\n+/*  please, do it beyond the point further indicated in this file.  */\n+/* ================================================================ */\n+\n+#if 0 /* libuv disabled */\n+/*\n+ * c-ares external interface definitions are also used internally,\n+ * and might also include required system header files to define them.\n+ */\n+\n+#include <ares_build.h>\n+\n+/*\n+ * Compile time sanity checks must also be done when building the library.\n+ */\n+\n+#include <ares_rules.h>\n+#endif\n+\n+/* ================================================================= */\n+/* No system header file shall be included in this file before this  */\n+/* point. The only allowed ones are those included from ares_build.h */\n+/* ================================================================= */\n+\n+/*\n+ * Include header files for windows builds before redefining anything.\n+ * Use this preproessor block only to include or exclude windows.h,\n+ * winsock2.h, ws2tcpip.h or winsock.h. Any other windows thing belongs\n+ * to any other further and independent block.  Under Cygwin things work\n+ * just as under linux (e.g. <sys/socket.h>) and the winsock headers should\n+ * never be included when __CYGWIN__ is defined.  configure script takes\n+ * care of this, not defining HAVE_WINDOWS_H, HAVE_WINSOCK_H, HAVE_WINSOCK2_H,\n+ * neither HAVE_WS2TCPIP_H when __CYGWIN__ is defined.\n+ */\n+\n+#ifdef HAVE_WINDOWS_H\n+#  ifdef HAVE_WINSOCK2_H\n+#    include <winsock2.h>\n+#    ifdef HAVE_WS2TCPIP_H\n+#       include <ws2tcpip.h>\n+#    endif\n+#  else\n+#    ifdef HAVE_WINSOCK_H\n+#      include <winsock.h>\n+#    endif\n+#  endif\n+#  include <windows.h>\n+#endif\n+\n+/*\n+ * Define USE_WINSOCK to 2 if we have and use WINSOCK2 API, else\n+ * define USE_WINSOCK to 1 if we have and use WINSOCK  API, else\n+ * undefine USE_WINSOCK.\n+ */\n+\n+#undef USE_WINSOCK\n+\n+#ifdef HAVE_WINSOCK2_H\n+#  define USE_WINSOCK 2\n+#else\n+#  ifdef HAVE_WINSOCK_H\n+#    define USE_WINSOCK 1\n+#  endif\n+#endif\n+\n+/*\n+ * Work-arounds for systems without configure support\n+ */\n+\n+#ifndef HAVE_CONFIG_H\n+\n+#if !defined(HAVE_SYS_TIME_H) && !defined(_MSC_VER) && !defined(__WATCOMC__)\n+#define HAVE_SYS_TIME_H\n+#endif\n+\n+#if !defined(HAVE_UNISTD_H) && !defined(_MSC_VER)\n+#define HAVE_UNISTD_H 1\n+#endif\n+\n+#if !defined(HAVE_SYS_UIO_H) && !defined(WIN32) && !defined(MSDOS)\n+#define HAVE_SYS_UIO_H\n+#endif\n+\n+#endif /* HAVE_CONFIG_H */\n+\n+#ifdef __POCC__\n+#  include <sys/types.h>\n+#  include <unistd.h>\n+#  define ESRCH 3\n+#endif\n+\n+/*\n+ * Recent autoconf versions define these symbols in ares_config.h. We don't\n+ * want them (since they collide with the libcurl ones when we build\n+ *  --enable-debug) so we undef them again here.\n+ */\n+\n+#undef PACKAGE_STRING\n+#undef PACKAGE_TARNAME\n+#undef PACKAGE_VERSION\n+#undef PACKAGE_BUGREPORT\n+#undef PACKAGE_NAME\n+#undef VERSION\n+#undef PACKAGE\n+\n+/* IPv6 compatibility */\n+#if !defined(HAVE_AF_INET6)\n+#if defined(HAVE_PF_INET6)\n+#define AF_INET6 PF_INET6\n+#else\n+#define AF_INET6 AF_MAX+1\n+#endif\n+#endif\n+\n+/*\n+ * Include macros and defines that should only be processed once.\n+ */\n+\n+#ifndef __SETUP_ONCE_H\n+#include \"setup_once.h\"\n+#endif\n+\n+#endif /* HEADER_CARES_SETUP_H */"}, {"sha": "f9c85e209666c57a3a8b981a0461b65af82a3c37", "filename": "src/rt/libuv/src/ares/ares_strcasecmp.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strcasecmp.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strcasecmp.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strcasecmp.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,66 @@\n+\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+#include \"ares_strcasecmp.h\"\n+\n+#ifndef HAVE_STRCASECMP\n+int ares_strcasecmp(const char *a, const char *b)\n+{\n+#if defined(HAVE_STRCMPI)\n+  return strcmpi(a, b);\n+#elif defined(HAVE_STRICMP)\n+  return stricmp(a, b);\n+#else\n+  size_t i;\n+\n+  for (i = 0; i < (size_t)-1; i++) {\n+    int c1 = ISUPPER(a[i]) ? tolower(a[i]) : a[i];\n+    int c2 = ISUPPER(b[i]) ? tolower(b[i]) : b[i];\n+    if (c1 != c2)\n+      return c1-c2;\n+    if (!c1)\n+      break;\n+  }\n+  return 0;\n+#endif\n+}\n+#endif\n+\n+#ifndef HAVE_STRNCASECMP\n+int ares_strncasecmp(const char *a, const char *b, size_t n)\n+{\n+#if defined(HAVE_STRNCMPI)\n+  return strncmpi(a, b, n);\n+#elif defined(HAVE_STRNICMP)\n+  return strnicmp(a, b, n);\n+#else\n+  size_t i;\n+\n+  for (i = 0; i < n; i++) {\n+    int c1 = ISUPPER(a[i]) ? tolower(a[i]) : a[i];\n+    int c2 = ISUPPER(b[i]) ? tolower(b[i]) : b[i];\n+    if (c1 != c2)\n+      return c1-c2;\n+    if (!c1)\n+      break;\n+  }\n+  return 0;\n+#endif\n+}\n+#endif\n+"}, {"sha": "57d86f963429ce434a166db3144afa069f8043f4", "filename": "src/rt/libuv/src/ares/ares_strcasecmp.h", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strcasecmp.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strcasecmp.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strcasecmp.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,30 @@\n+#ifndef HEADER_CARES_STRCASECMP_H\n+#define HEADER_CARES_STRCASECMP_H\n+\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifndef HAVE_STRCASECMP\n+extern int ares_strcasecmp(const char *a, const char *b);\n+#endif\n+\n+#ifndef HAVE_STRNCASECMP\n+extern int ares_strncasecmp(const char *a, const char *b, size_t n);\n+#endif\n+\n+#endif /* HEADER_CARES_STRCASECMP_H */"}, {"sha": "18043274e9925dceda4679a1404a05313585435f", "filename": "src/rt/libuv/src/ares/ares_strdup.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strdup.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strdup.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strdup.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,42 @@\n+\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+#include \"ares_strdup.h\"\n+\n+#ifndef HAVE_STRDUP\n+char *ares_strdup(const char *s1)\n+{\n+  size_t sz;\n+  char * s2;\n+\n+  if(s1) {\n+    sz = strlen(s1);\n+    if(sz < (size_t)-1) {\n+      sz++;\n+      if(sz < ((size_t)-1) / sizeof(char)) {\n+        s2 = malloc(sz * sizeof(char));\n+        if(s2) {\n+          memcpy(s2, s1, sz * sizeof(char));\n+          return s2;\n+        }\n+      }\n+    }\n+  }\n+  return (char *)NULL;\n+}\n+#endif"}, {"sha": "c413a941c5179561ca8241c17f4e1f67f796a30c", "filename": "src/rt/libuv/src/ares/ares_strdup.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strdup.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strdup.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strdup.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,26 @@\n+#ifndef HEADER_CARES_STRDUP_H\n+#define HEADER_CARES_STRDUP_H\n+\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifndef HAVE_STRDUP\n+extern char *ares_strdup(const char *s1);\n+#endif\n+\n+#endif /* HEADER_CARES_STRDUP_H */"}, {"sha": "c3ecbd7b43c0e75b50e245c08e2f51263bb96a6d", "filename": "src/rt/libuv/src/ares/ares_strerror.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strerror.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strerror.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strerror.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,56 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+#include <assert.h>\n+#include \"ares.h\"\n+\n+const char *ares_strerror(int code)\n+{\n+  /* Return a string literal from a table. */\n+  const char *errtext[] = {\n+    \"Successful completion\",\n+    \"DNS server returned answer with no data\",\n+    \"DNS server claims query was misformatted\",\n+    \"DNS server returned general failure\",\n+    \"Domain name not found\",\n+    \"DNS server does not implement requested operation\",\n+    \"DNS server refused query\",\n+    \"Misformatted DNS query\",\n+    \"Misformatted domain name\",\n+    \"Unsupported address family\",\n+    \"Misformatted DNS reply\",\n+    \"Could not contact DNS servers\",\n+    \"Timeout while contacting DNS servers\",\n+    \"End of file\",\n+    \"Error reading file\",\n+    \"Out of memory\",\n+    \"Channel is being destroyed\",\n+    \"Misformatted string\",\n+    \"Illegal flags specified\",\n+    \"Given hostname is not numeric\",\n+    \"Illegal hints flags specified\",\n+    \"c-ares library initialization not yet performed\",\n+    \"Error loading iphlpapi.dll\",\n+    \"Could not find GetNetworkParams function\",\n+    \"DNS query cancelled\"\n+  };\n+\n+  if(code >= 0 && code < (int)(sizeof(errtext) / sizeof(*errtext)))\n+    return errtext[code];\n+  else\n+    return \"unknown\";\n+}"}, {"sha": "2da4f5f4a18976a8b50af14f311a8f62614a1b7a", "filename": "src/rt/libuv/src/ares/ares_timeout.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_timeout.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_timeout.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_timeout.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,80 @@\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+\n+#include <time.h>\n+\n+#include \"ares.h\"\n+#include \"ares_private.h\"\n+\n+/* WARNING: Beware that this is linear in the number of outstanding\n+ * requests! You are probably far better off just calling ares_process()\n+ * once per second, rather than calling ares_timeout() to figure out\n+ * when to next call ares_process().\n+ */\n+struct timeval *ares_timeout(ares_channel channel, struct timeval *maxtv,\n+                             struct timeval *tvbuf)\n+{\n+  struct query *query;\n+  struct list_node* list_head;\n+  struct list_node* list_node;\n+  struct timeval now;\n+  struct timeval nextstop;\n+  long offset, min_offset;\n+\n+  /* No queries, no timeout (and no fetch of the current time). */\n+  if (ares__is_list_empty(&(channel->all_queries)))\n+    return maxtv;\n+\n+  /* Find the minimum timeout for the current set of queries. */\n+  now = ares__tvnow();\n+  min_offset = -1;\n+\n+  list_head = &(channel->all_queries);\n+  for (list_node = list_head->next; list_node != list_head;\n+       list_node = list_node->next)\n+    {\n+      query = list_node->data;\n+      if (query->timeout.tv_sec == 0)\n+        continue;\n+      offset = ares__timeoffset(&now, &query->timeout);\n+      if (offset < 0)\n+        offset = 0;\n+      if (min_offset == -1 || offset < min_offset)\n+        min_offset = offset;\n+    }\n+\n+  if(min_offset != -1) {\n+    nextstop.tv_sec = min_offset/1000;\n+    nextstop.tv_usec = (min_offset%1000)*1000;\n+  }\n+\n+  /* If we found a minimum timeout and it's sooner than the one specified in\n+   * maxtv (if any), return it.  Otherwise go with maxtv.\n+   */\n+  if (min_offset != -1 && (!maxtv || ares__timedout(maxtv, &nextstop)))\n+    {\n+      *tvbuf = nextstop;\n+      return tvbuf;\n+    }\n+  else\n+    return maxtv;\n+}"}, {"sha": "4f8c42f2c9a34d5d11562de85b2256638c31cfda", "filename": "src/rt/libuv/src/ares/ares_version.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_version.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_version.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_version.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,11 @@\n+\n+#include \"ares_setup.h\"\n+#include \"ares.h\"\n+\n+const char *ares_version(int *version)\n+{\n+  if(version)\n+    *version = ARES_VERSION;\n+\n+  return ARES_VERSION_STR;\n+}"}, {"sha": "9e8e2d65741e2ee3621096db8b55d55277bf1249", "filename": "src/rt/libuv/src/ares/ares_writev.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_writev.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_writev.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_writev.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,79 @@\n+\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_LIMITS_H\n+#  include <limits.h>\n+#endif\n+\n+#include \"ares.h\"\n+#include \"ares_private.h\"\n+\n+#ifndef HAVE_WRITEV\n+ssize_t ares_writev(ares_socket_t s, const struct iovec *iov, int iovcnt)\n+{\n+  char *buffer, *bp;\n+  int i;\n+  size_t bytes = 0;\n+  ssize_t result;\n+\n+  /* Validate iovcnt */\n+  if (iovcnt <= 0)\n+  {\n+    SET_ERRNO(EINVAL);\n+    return (-1);\n+  }\n+\n+  /* Validate and find the sum of the iov_len values in the iov array */\n+  for (i = 0; i < iovcnt; i++)\n+  {\n+    if (iov[i].iov_len > INT_MAX - bytes)\n+    {\n+      SET_ERRNO(EINVAL);\n+      return (-1);\n+    }\n+    bytes += iov[i].iov_len;\n+  }\n+\n+  if (bytes == 0)\n+    return (0);\n+\n+  /* Allocate a temporary buffer to hold the data */\n+  buffer = malloc(bytes);\n+  if (!buffer)\n+  {\n+    SET_ERRNO(ENOMEM);\n+    return (-1);\n+  }\n+\n+  /* Copy the data into buffer */\n+  for (bp = buffer, i = 0; i < iovcnt; ++i)\n+  {\n+    memcpy (bp, iov[i].iov_base, iov[i].iov_len);\n+    bp += iov[i].iov_len;\n+  }\n+\n+  /* Send buffer contents */\n+  result = swrite(s, buffer, bytes);\n+\n+  free(buffer);\n+\n+  return (result);\n+}\n+#endif\n+"}, {"sha": "1a23a0f3d10929de21f6aaf8d8400c4d5e501565", "filename": "src/rt/libuv/src/ares/ares_writev.h", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_writev.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_writev.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_writev.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,36 @@\n+#ifndef HEADER_CARES_WRITEV_H\n+#define HEADER_CARES_WRITEV_H\n+\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+#include \"ares.h\"\n+\n+#ifndef HAVE_WRITEV\n+\n+/* Structure for scatter/gather I/O. */\n+struct iovec\n+{\n+  void *iov_base;  /* Pointer to data. */\n+  size_t iov_len;  /* Length of data.  */\n+};\n+\n+extern ssize_t ares_writev(ares_socket_t s, const struct iovec *iov, int iovcnt);\n+\n+#endif\n+\n+#endif /* HEADER_CARES_WRITEV_H */"}, {"sha": "5c89506b33f904d10f4fba69e882674c27b0d09b", "filename": "src/rt/libuv/src/ares/bitncmp.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fbitncmp.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fbitncmp.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fbitncmp.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,59 @@\n+\n+/*\n+ * Copyright (c) 2004 by Internet Systems Consortium, Inc. (\"ISC\")\n+ * Copyright (c) 1996,1999 by Internet Software Consortium.\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND ISC DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT\n+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#ifndef HAVE_BITNCMP\n+\n+#include \"ares_setup.h\"\n+#include \"bitncmp.h\"\n+\n+/*\n+ * int\n+ * bitncmp(l, r, n)\n+ *\tcompare bit masks l and r, for n bits.\n+ * return:\n+ *\t-1, 1, or 0 in the libc tradition.\n+ * note:\n+ *\tnetwork byte order assumed.  this means 192.5.5.240/28 has\n+ *\t0x11110000 in its fourth octet.\n+ * author:\n+ *\tPaul Vixie (ISC), June 1996\n+ */\n+int\n+ares_bitncmp(const void *l, const void *r, int n) {\n+\tunsigned int lb, rb;\n+\tint x, b;\n+\n+\tb = n / 8;\n+\tx = memcmp(l, r, b);\n+\tif (x || (n % 8) == 0)\n+\t\treturn (x);\n+\n+\tlb = ((const unsigned char *)l)[b];\n+\trb = ((const unsigned char *)r)[b];\n+\tfor (b = n % 8; b > 0; b--) {\n+\t\tif ((lb & 0x80) != (rb & 0x80)) {\n+\t\t\tif (lb & 0x80)\n+\t\t\t\treturn (1);\n+\t\t\treturn (-1);\n+\t\t}\n+\t\tlb <<= 1;\n+\t\trb <<= 1;\n+\t}\n+\treturn (0);\n+}\n+#endif"}, {"sha": "b0a5c812b428740d43e469356f0980789857ebae", "filename": "src/rt/libuv/src/ares/bitncmp.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fbitncmp.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fbitncmp.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fbitncmp.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,26 @@\n+#ifndef __ARES_BITNCMP_H\n+#define __ARES_BITNCMP_H\n+\n+\n+/* Copyright (C) 2005 by Dominick Meglio\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#ifndef HAVE_BITNCMP\n+int ares_bitncmp(const void *l, const void *r, int n);\n+#else\n+#define ares_bitncmp(x,y,z) bitncmp(x,y,z)\n+#endif\n+\n+#endif /* __ARES_BITNCMP_H */"}, {"sha": "70595d36175b8eda12a9a73bfdee42a53206e1d7", "filename": "src/rt/libuv/src/ares/config_cygwin/ares_config.h", "status": "added", "additions": 510, "deletions": 0, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_cygwin%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_cygwin%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_cygwin%2Fares_config.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,510 @@\n+/* ares_config.h.  Generated from ares_config.h.in by configure.  */\n+/* ares_config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define if building universal (internal helper macro) */\n+/* #undef AC_APPLE_UNIVERSAL_BUILD */\n+\n+/* define this if ares is built for a big endian system */\n+/* #undef ARES_BIG_ENDIAN */\n+\n+/* when building as static part of libcurl */\n+/* #undef BUILDING_LIBCURL */\n+\n+/* when building c-ares library */\n+/* #undef CARES_BUILDING_LIBRARY */\n+\n+/* when not building a shared library */\n+/* #undef CARES_STATICLIB */\n+\n+/* Define to 1 to enable hiding of library internal symbols. */\n+#define CARES_SYMBOL_HIDING 1\n+\n+/* Definition to make a library symbol externally visible. */\n+#define CARES_SYMBOL_SCOPE_EXTERN __attribute__ ((visibility (\"default\")))\n+\n+/* if a /etc/inet dir is being used */\n+/* #undef ETC_INET */\n+\n+/* Define to the type qualifier of arg 1 for getnameinfo. */\n+#define GETNAMEINFO_QUAL_ARG1 const\n+\n+/* Define to the type of arg 1 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG1 struct sockaddr *\n+\n+/* Define to the type of arg 2 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG2 socklen_t\n+\n+/* Define to the type of args 4 and 6 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG46 int\n+\n+/* Define to the type of arg 7 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG7 int\n+\n+/* Specifies the number of arguments to getservbyport_r */\n+/* #undef GETSERVBYPORT_R_ARGS */\n+\n+/* Specifies the size of the buffer to pass to getservbyport_r */\n+/* #undef GETSERVBYPORT_R_BUFSIZE */\n+\n+/* Define to 1 if you have AF_INET6. */\n+#define HAVE_AF_INET6 1\n+\n+/* Define to 1 if you have the <arpa/inet.h> header file. */\n+#define HAVE_ARPA_INET_H 1\n+\n+/* Define to 1 if you have the <arpa/nameser_compat.h> header file. */\n+#define HAVE_ARPA_NAMESER_COMPAT_H 1\n+\n+/* Define to 1 if you have the <arpa/nameser.h> header file. */\n+#define HAVE_ARPA_NAMESER_H 1\n+\n+/* Define to 1 if you have the <assert.h> header file. */\n+#define HAVE_ASSERT_H 1\n+\n+/* Define to 1 if you have the `bitncmp' function. */\n+/* #undef HAVE_BITNCMP */\n+\n+/* Define to 1 if bool is an available type. */\n+#define HAVE_BOOL_T 1\n+\n+/* Define to 1 if you have the clock_gettime function and monotonic timer. */\n+/* #undef HAVE_CLOCK_GETTIME_MONOTONIC */\n+\n+/* Define to 1 if you have the closesocket function. */\n+/* #undef HAVE_CLOSESOCKET */\n+\n+/* Define to 1 if you have the CloseSocket camel case function. */\n+/* #undef HAVE_CLOSESOCKET_CAMEL */\n+\n+/* Define to 1 if you have the connect function. */\n+#define HAVE_CONNECT 1\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#define HAVE_DLFCN_H 1\n+\n+/* Define to 1 if you have the <errno.h> header file. */\n+#define HAVE_ERRNO_H 1\n+\n+/* Define to 1 if you have the fcntl function. */\n+#define HAVE_FCNTL 1\n+\n+/* Define to 1 if you have the <fcntl.h> header file. */\n+#define HAVE_FCNTL_H 1\n+\n+/* Define to 1 if you have a working fcntl O_NONBLOCK function. */\n+#define HAVE_FCNTL_O_NONBLOCK 1\n+\n+/* Define to 1 if you have the freeaddrinfo function. */\n+#define HAVE_FREEADDRINFO 1\n+\n+/* Define to 1 if you have a working getaddrinfo function. */\n+#define HAVE_GETADDRINFO 1\n+\n+/* Define to 1 if the getaddrinfo function is threadsafe. */\n+/* #undef HAVE_GETADDRINFO_THREADSAFE */\n+\n+/* Define to 1 if you have the gethostbyaddr function. */\n+#define HAVE_GETHOSTBYADDR 1\n+\n+/* Define to 1 if you have the gethostbyname function. */\n+#define HAVE_GETHOSTBYNAME 1\n+\n+/* Define to 1 if you have the gethostname function. */\n+#define HAVE_GETHOSTNAME 1\n+\n+/* Define to 1 if you have the getnameinfo function. */\n+#define HAVE_GETNAMEINFO 1\n+\n+/* Define to 1 if you have the getservbyport_r function. */\n+/* #undef HAVE_GETSERVBYPORT_R */\n+\n+/* Define to 1 if you have the `gettimeofday' function. */\n+#define HAVE_GETTIMEOFDAY 1\n+\n+/* Define to 1 if you have the `if_indextoname' function. */\n+#define HAVE_IF_INDEXTONAME 1\n+\n+/* Define to 1 if you have the `inet_net_pton' function. */\n+/* #undef HAVE_INET_NET_PTON */\n+\n+/* Define to 1 if inet_net_pton supports IPv6. */\n+/* #undef HAVE_INET_NET_PTON_IPV6 */\n+\n+/* Define to 1 if you have a IPv6 capable working inet_ntop function. */\n+#define HAVE_INET_NTOP 1\n+\n+/* Define to 1 if you have a IPv6 capable working inet_pton function. */\n+#define HAVE_INET_PTON 1\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#define HAVE_INTTYPES_H 1\n+\n+/* Define to 1 if you have the ioctl function. */\n+#define HAVE_IOCTL 1\n+\n+/* Define to 1 if you have the ioctlsocket function. */\n+/* #undef HAVE_IOCTLSOCKET */\n+\n+/* Define to 1 if you have the IoctlSocket camel case function. */\n+/* #undef HAVE_IOCTLSOCKET_CAMEL */\n+\n+/* Define to 1 if you have a working IoctlSocket camel case FIONBIO function.\n+   */\n+/* #undef HAVE_IOCTLSOCKET_CAMEL_FIONBIO */\n+\n+/* Define to 1 if you have a working ioctlsocket FIONBIO function. */\n+/* #undef HAVE_IOCTLSOCKET_FIONBIO */\n+\n+/* Define to 1 if you have a working ioctl FIONBIO function. */\n+#define HAVE_IOCTL_FIONBIO 1\n+\n+/* Define to 1 if you have a working ioctl SIOCGIFADDR function. */\n+#define HAVE_IOCTL_SIOCGIFADDR 1\n+\n+/* Define to 1 if you have the `resolve' library (-lresolve). */\n+/* #undef HAVE_LIBRESOLVE */\n+\n+/* Define to 1 if you have the <limits.h> header file. */\n+#define HAVE_LIMITS_H 1\n+\n+/* if your compiler supports LL */\n+#define HAVE_LL 1\n+\n+/* Define to 1 if the compiler supports the 'long long' data type. */\n+#define HAVE_LONGLONG 1\n+\n+/* Define to 1 if you have the malloc.h header file. */\n+#define HAVE_MALLOC_H 1\n+\n+/* Define to 1 if you have the memory.h header file. */\n+#define HAVE_MEMORY_H 1\n+\n+/* Define to 1 if you have the MSG_NOSIGNAL flag. */\n+#define HAVE_MSG_NOSIGNAL 1\n+\n+/* Define to 1 if you have the <netdb.h> header file. */\n+#define HAVE_NETDB_H 1\n+\n+/* Define to 1 if you have the <netinet/in.h> header file. */\n+#define HAVE_NETINET_IN_H 1\n+\n+/* Define to 1 if you have the <netinet/tcp.h> header file. */\n+#define HAVE_NETINET_TCP_H 1\n+\n+/* Define to 1 if you have the <net/if.h> header file. */\n+#define HAVE_NET_IF_H 1\n+\n+/* Define to 1 if you have PF_INET6. */\n+#define HAVE_PF_INET6 1\n+\n+/* Define to 1 if you have the recv function. */\n+#define HAVE_RECV 1\n+\n+/* Define to 1 if you have the recvfrom function. */\n+#define HAVE_RECVFROM 1\n+\n+/* Define to 1 if you have the send function. */\n+#define HAVE_SEND 1\n+\n+/* Define to 1 if you have the setsockopt function. */\n+#define HAVE_SETSOCKOPT 1\n+\n+/* Define to 1 if you have a working setsockopt SO_NONBLOCK function. */\n+/* #undef HAVE_SETSOCKOPT_SO_NONBLOCK */\n+\n+/* Define to 1 if you have the <signal.h> header file. */\n+#define HAVE_SIGNAL_H 1\n+\n+/* Define to 1 if sig_atomic_t is an available typedef. */\n+#define HAVE_SIG_ATOMIC_T 1\n+\n+/* Define to 1 if sig_atomic_t is already defined as volatile. */\n+/* #undef HAVE_SIG_ATOMIC_T_VOLATILE */\n+\n+/* Define to 1 if your struct sockaddr_in6 has sin6_scope_id. */\n+#define HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID 1\n+\n+/* Define to 1 if you have the socket function. */\n+#define HAVE_SOCKET 1\n+\n+/* Define to 1 if you have the <socket.h> header file. */\n+/* #undef HAVE_SOCKET_H */\n+\n+/* Define to 1 if you have the <stdbool.h> header file. */\n+#define HAVE_STDBOOL_H 1\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#define HAVE_STDINT_H 1\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#define HAVE_STDLIB_H 1\n+\n+/* Define to 1 if you have the strcasecmp function. */\n+#define HAVE_STRCASECMP 1\n+\n+/* Define to 1 if you have the strcmpi function. */\n+/* #undef HAVE_STRCMPI */\n+\n+/* Define to 1 if you have the strdup function. */\n+#define HAVE_STRDUP 1\n+\n+/* Define to 1 if you have the stricmp function. */\n+/* #undef HAVE_STRICMP */\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#define HAVE_STRINGS_H 1\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#define HAVE_STRING_H 1\n+\n+/* Define to 1 if you have the strncasecmp function. */\n+#define HAVE_STRNCASECMP 1\n+\n+/* Define to 1 if you have the strncmpi function. */\n+/* #undef HAVE_STRNCMPI */\n+\n+/* Define to 1 if you have the strnicmp function. */\n+/* #undef HAVE_STRNICMP */\n+\n+/* Define to 1 if you have the <stropts.h> header file. */\n+/* #undef HAVE_STROPTS_H */\n+\n+/* Define to 1 if you have struct addrinfo. */\n+#define HAVE_STRUCT_ADDRINFO 1\n+\n+/* Define to 1 if you have struct in6_addr. */\n+#define HAVE_STRUCT_IN6_ADDR 1\n+\n+/* Define to 1 if you have struct sockaddr_in6. */\n+#define HAVE_STRUCT_SOCKADDR_IN6 1\n+\n+/* if struct sockaddr_storage is defined */\n+#define HAVE_STRUCT_SOCKADDR_STORAGE 1\n+\n+/* Define to 1 if you have the timeval struct. */\n+#define HAVE_STRUCT_TIMEVAL 1\n+\n+/* Define to 1 if you have the <sys/ioctl.h> header file. */\n+#define HAVE_SYS_IOCTL_H 1\n+\n+/* Define to 1 if you have the <sys/param.h> header file. */\n+#define HAVE_SYS_PARAM_H 1\n+\n+/* Define to 1 if you have the <sys/select.h> header file. */\n+#define HAVE_SYS_SELECT_H 1\n+\n+/* Define to 1 if you have the <sys/socket.h> header file. */\n+#define HAVE_SYS_SOCKET_H 1\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#define HAVE_SYS_STAT_H 1\n+\n+/* Define to 1 if you have the <sys/time.h> header file. */\n+#define HAVE_SYS_TIME_H 1\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#define HAVE_SYS_TYPES_H 1\n+\n+/* Define to 1 if you have the <sys/uio.h> header file. */\n+#define HAVE_SYS_UIO_H 1\n+\n+/* Define to 1 if you have the <time.h> header file. */\n+#define HAVE_TIME_H 1\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#define HAVE_UNISTD_H 1\n+\n+/* Define to 1 if you have the windows.h header file. */\n+/* #undef HAVE_WINDOWS_H */\n+\n+/* Define to 1 if you have the winsock2.h header file. */\n+/* #undef HAVE_WINSOCK2_H */\n+\n+/* Define to 1 if you have the winsock.h header file. */\n+/* #undef HAVE_WINSOCK_H */\n+\n+/* Define to 1 if you have the writev function. */\n+#define HAVE_WRITEV 1\n+\n+/* Define to 1 if you have the ws2tcpip.h header file. */\n+/* #undef HAVE_WS2TCPIP_H */\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#define LT_OBJDIR \".libs/\"\n+\n+/* Define to 1 if you are building a native Windows target. */\n+/* #undef NATIVE_WINDOWS */\n+\n+/* Define to 1 if you need the malloc.h header file even with stdlib.h */\n+/* #undef NEED_MALLOC_H */\n+\n+/* Define to 1 if you need the memory.h header file even with stdlib.h */\n+/* #undef NEED_MEMORY_H */\n+\n+/* Define to 1 if _REENTRANT preprocessor symbol must be defined. */\n+/* #undef NEED_REENTRANT */\n+\n+/* Define to 1 if _THREAD_SAFE preprocessor symbol must be defined. */\n+/* #undef NEED_THREAD_SAFE */\n+\n+/* Define to 1 if your C compiler doesn't accept -c and -o together. */\n+/* #undef NO_MINUS_C_MINUS_O */\n+\n+/* cpu-machine-OS */\n+#define OS \"i686-pc-cygwin\"\n+\n+/* Name of package */\n+#define PACKAGE \"c-ares\"\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#define PACKAGE_BUGREPORT \"c-ares mailing list => http://cool.haxx.se/mailman/listinfo/c-ares\"\n+\n+/* Define to the full name of this package. */\n+#define PACKAGE_NAME \"c-ares\"\n+\n+/* Define to the full name and version of this package. */\n+#define PACKAGE_STRING \"c-ares 1.7.1\"\n+\n+/* Define to the one symbol short name of this package. */\n+#define PACKAGE_TARNAME \"c-ares\"\n+\n+/* Define to the home page for this package. */\n+#define PACKAGE_URL \"\"\n+\n+/* Define to the version of this package. */\n+#define PACKAGE_VERSION \"1.7.1\"\n+\n+/* a suitable file/device to read random data from */\n+#define RANDOM_FILE \"/dev/urandom\"\n+\n+/* Define to the type of arg 1 for recvfrom. */\n+#define RECVFROM_TYPE_ARG1 int\n+\n+/* Define to the type pointed by arg 2 for recvfrom. */\n+#define RECVFROM_TYPE_ARG2 void\n+\n+/* Define to 1 if the type pointed by arg 2 for recvfrom is void. */\n+#define RECVFROM_TYPE_ARG2_IS_VOID 1\n+\n+/* Define to the type of arg 3 for recvfrom. */\n+#define RECVFROM_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for recvfrom. */\n+#define RECVFROM_TYPE_ARG4 int\n+\n+/* Define to the type pointed by arg 5 for recvfrom. */\n+#define RECVFROM_TYPE_ARG5 struct sockaddr\n+\n+/* Define to 1 if the type pointed by arg 5 for recvfrom is void. */\n+/* #undef RECVFROM_TYPE_ARG5_IS_VOID */\n+\n+/* Define to the type pointed by arg 6 for recvfrom. */\n+#define RECVFROM_TYPE_ARG6 socklen_t\n+\n+/* Define to 1 if the type pointed by arg 6 for recvfrom is void. */\n+/* #undef RECVFROM_TYPE_ARG6_IS_VOID */\n+\n+/* Define to the function return type for recvfrom. */\n+#define RECVFROM_TYPE_RETV int\n+\n+/* Define to the type of arg 1 for recv. */\n+#define RECV_TYPE_ARG1 int\n+\n+/* Define to the type of arg 2 for recv. */\n+#define RECV_TYPE_ARG2 void *\n+\n+/* Define to the type of arg 3 for recv. */\n+#define RECV_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for recv. */\n+#define RECV_TYPE_ARG4 int\n+\n+/* Define to the function return type for recv. */\n+#define RECV_TYPE_RETV int\n+\n+/* Define as the return type of signal handlers (`int' or `void'). */\n+#define RETSIGTYPE void\n+\n+/* Define to the type qualifier of arg 2 for send. */\n+#define SEND_QUAL_ARG2 const\n+\n+/* Define to the type of arg 1 for send. */\n+#define SEND_TYPE_ARG1 int\n+\n+/* Define to the type of arg 2 for send. */\n+#define SEND_TYPE_ARG2 void *\n+\n+/* Define to the type of arg 3 for send. */\n+#define SEND_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for send. */\n+#define SEND_TYPE_ARG4 int\n+\n+/* Define to the function return type for send. */\n+#define SEND_TYPE_RETV int\n+\n+/* The size of `int', as computed by sizeof. */\n+#define SIZEOF_INT 4\n+\n+/* The size of `long', as computed by sizeof. */\n+#define SIZEOF_LONG 4\n+\n+/* The size of `size_t', as computed by sizeof. */\n+#define SIZEOF_SIZE_T 4\n+\n+/* The size of `struct in6_addr', as computed by sizeof. */\n+#define SIZEOF_STRUCT_IN6_ADDR 16\n+\n+/* The size of `struct in_addr', as computed by sizeof. */\n+#define SIZEOF_STRUCT_IN_ADDR 4\n+\n+/* The size of `time_t', as computed by sizeof. */\n+#define SIZEOF_TIME_T 4\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#define STDC_HEADERS 1\n+\n+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n+#define TIME_WITH_SYS_TIME 1\n+\n+/* Define to disable non-blocking sockets. */\n+/* #undef USE_BLOCKING_SOCKETS */\n+\n+/* Version number of package */\n+#define VERSION \"1.7.1\"\n+\n+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n+   significant byte first (like Motorola and SPARC, unlike Intel). */\n+#if defined AC_APPLE_UNIVERSAL_BUILD\n+# if defined __BIG_ENDIAN__\n+#  define WORDS_BIGENDIAN 1\n+# endif\n+#else\n+# ifndef WORDS_BIGENDIAN\n+/* #  undef WORDS_BIGENDIAN */\n+# endif\n+#endif\n+\n+/* Define to 1 if OS is AIX. */\n+#ifndef _ALL_SOURCE\n+/* #  undef _ALL_SOURCE */\n+#endif\n+\n+/* Number of bits in a file offset, on hosts where this is settable. */\n+/* #undef _FILE_OFFSET_BITS */\n+\n+/* Define for large files, on AIX-style hosts. */\n+/* #undef _LARGE_FILES */\n+\n+/* Define to empty if `const' does not conform to ANSI C. */\n+/* #undef const */\n+\n+/* Type to use in place of in_addr_t when system does not provide it. */\n+/* #undef in_addr_t */\n+\n+/* Define to `unsigned int' if <sys/types.h> does not define. */\n+/* #undef size_t */\n+\n+/* the signed version of size_t */\n+/* #undef ssize_t */"}, {"sha": "3722bba10b56d0648c6a67541d0765ac1ee584c6", "filename": "src/rt/libuv/src/ares/config_darwin/ares_config.h", "status": "added", "additions": 510, "deletions": 0, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_darwin%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_darwin%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_darwin%2Fares_config.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,510 @@\n+/* ares_config.h.  Generated from ares_config.h.in by configure.  */\n+/* ares_config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define if building universal (internal helper macro) */\n+/* #undef AC_APPLE_UNIVERSAL_BUILD */\n+\n+/* define this if ares is built for a big endian system */\n+/* #undef ARES_BIG_ENDIAN */\n+\n+/* when building as static part of libcurl */\n+/* #undef BUILDING_LIBCURL */\n+\n+/* when building c-ares library */\n+/* #undef CARES_BUILDING_LIBRARY */\n+\n+/* when not building a shared library */\n+/* #undef CARES_STATICLIB */\n+\n+/* Define to 1 to enable hiding of library internal symbols. */\n+#define CARES_SYMBOL_HIDING 1\n+\n+/* Definition to make a library symbol externally visible. */\n+#define CARES_SYMBOL_SCOPE_EXTERN __attribute__ ((visibility (\"default\")))\n+\n+/* if a /etc/inet dir is being used */\n+/* #undef ETC_INET */\n+\n+/* Define to the type qualifier of arg 1 for getnameinfo. */\n+#define GETNAMEINFO_QUAL_ARG1 const\n+\n+/* Define to the type of arg 1 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG1 struct sockaddr *\n+\n+/* Define to the type of arg 2 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG2 socklen_t\n+\n+/* Define to the type of args 4 and 6 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG46 socklen_t\n+\n+/* Define to the type of arg 7 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG7 int\n+\n+/* Specifies the number of arguments to getservbyport_r */\n+/* #undef GETSERVBYPORT_R_ARGS */\n+\n+/* Specifies the size of the buffer to pass to getservbyport_r */\n+/* #undef GETSERVBYPORT_R_BUFSIZE */\n+\n+/* Define to 1 if you have AF_INET6. */\n+#define HAVE_AF_INET6 1\n+\n+/* Define to 1 if you have the <arpa/inet.h> header file. */\n+#define HAVE_ARPA_INET_H 1\n+\n+/* Define to 1 if you have the <arpa/nameser_compat.h> header file. */\n+#define HAVE_ARPA_NAMESER_COMPAT_H 1\n+\n+/* Define to 1 if you have the <arpa/nameser.h> header file. */\n+#define HAVE_ARPA_NAMESER_H 1\n+\n+/* Define to 1 if you have the <assert.h> header file. */\n+#define HAVE_ASSERT_H 1\n+\n+/* Define to 1 if you have the `bitncmp' function. */\n+/* #undef HAVE_BITNCMP */\n+\n+/* Define to 1 if bool is an available type. */\n+#define HAVE_BOOL_T 1\n+\n+/* Define to 1 if you have the clock_gettime function and monotonic timer. */\n+/* #undef HAVE_CLOCK_GETTIME_MONOTONIC */\n+\n+/* Define to 1 if you have the closesocket function. */\n+/* #undef HAVE_CLOSESOCKET */\n+\n+/* Define to 1 if you have the CloseSocket camel case function. */\n+/* #undef HAVE_CLOSESOCKET_CAMEL */\n+\n+/* Define to 1 if you have the connect function. */\n+#define HAVE_CONNECT 1\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#define HAVE_DLFCN_H 1\n+\n+/* Define to 1 if you have the <errno.h> header file. */\n+#define HAVE_ERRNO_H 1\n+\n+/* Define to 1 if you have the fcntl function. */\n+#define HAVE_FCNTL 1\n+\n+/* Define to 1 if you have the <fcntl.h> header file. */\n+#define HAVE_FCNTL_H 1\n+\n+/* Define to 1 if you have a working fcntl O_NONBLOCK function. */\n+#define HAVE_FCNTL_O_NONBLOCK 1\n+\n+/* Define to 1 if you have the freeaddrinfo function. */\n+#define HAVE_FREEADDRINFO 1\n+\n+/* Define to 1 if you have a working getaddrinfo function. */\n+#define HAVE_GETADDRINFO 1\n+\n+/* Define to 1 if the getaddrinfo function is threadsafe. */\n+#define HAVE_GETADDRINFO_THREADSAFE 1\n+\n+/* Define to 1 if you have the gethostbyaddr function. */\n+#define HAVE_GETHOSTBYADDR 1\n+\n+/* Define to 1 if you have the gethostbyname function. */\n+#define HAVE_GETHOSTBYNAME 1\n+\n+/* Define to 1 if you have the gethostname function. */\n+#define HAVE_GETHOSTNAME 1\n+\n+/* Define to 1 if you have the getnameinfo function. */\n+#define HAVE_GETNAMEINFO 1\n+\n+/* Define to 1 if you have the getservbyport_r function. */\n+/* #undef HAVE_GETSERVBYPORT_R */\n+\n+/* Define to 1 if you have the `gettimeofday' function. */\n+#define HAVE_GETTIMEOFDAY 1\n+\n+/* Define to 1 if you have the `if_indextoname' function. */\n+#define HAVE_IF_INDEXTONAME 1\n+\n+/* Define to 1 if you have the `inet_net_pton' function. */\n+#define HAVE_INET_NET_PTON 1\n+\n+/* Define to 1 if inet_net_pton supports IPv6. */\n+#define HAVE_INET_NET_PTON_IPV6 1\n+\n+/* Define to 1 if you have a IPv6 capable working inet_ntop function. */\n+#define HAVE_INET_NTOP 1\n+\n+/* Define to 1 if you have a IPv6 capable working inet_pton function. */\n+#define HAVE_INET_PTON 1\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#define HAVE_INTTYPES_H 1\n+\n+/* Define to 1 if you have the ioctl function. */\n+#define HAVE_IOCTL 1\n+\n+/* Define to 1 if you have the ioctlsocket function. */\n+/* #undef HAVE_IOCTLSOCKET */\n+\n+/* Define to 1 if you have the IoctlSocket camel case function. */\n+/* #undef HAVE_IOCTLSOCKET_CAMEL */\n+\n+/* Define to 1 if you have a working IoctlSocket camel case FIONBIO function.\n+   */\n+/* #undef HAVE_IOCTLSOCKET_CAMEL_FIONBIO */\n+\n+/* Define to 1 if you have a working ioctlsocket FIONBIO function. */\n+/* #undef HAVE_IOCTLSOCKET_FIONBIO */\n+\n+/* Define to 1 if you have a working ioctl FIONBIO function. */\n+#define HAVE_IOCTL_FIONBIO 1\n+\n+/* Define to 1 if you have a working ioctl SIOCGIFADDR function. */\n+#define HAVE_IOCTL_SIOCGIFADDR 1\n+\n+/* Define to 1 if you have the `resolve' library (-lresolve). */\n+/* #undef HAVE_LIBRESOLVE */\n+\n+/* Define to 1 if you have the <limits.h> header file. */\n+#define HAVE_LIMITS_H 1\n+\n+/* if your compiler supports LL */\n+#define HAVE_LL 1\n+\n+/* Define to 1 if the compiler supports the 'long long' data type. */\n+#define HAVE_LONGLONG 1\n+\n+/* Define to 1 if you have the malloc.h header file. */\n+/* #undef HAVE_MALLOC_H */\n+\n+/* Define to 1 if you have the memory.h header file. */\n+#define HAVE_MEMORY_H 1\n+\n+/* Define to 1 if you have the MSG_NOSIGNAL flag. */\n+/* #undef HAVE_MSG_NOSIGNAL */\n+\n+/* Define to 1 if you have the <netdb.h> header file. */\n+#define HAVE_NETDB_H 1\n+\n+/* Define to 1 if you have the <netinet/in.h> header file. */\n+#define HAVE_NETINET_IN_H 1\n+\n+/* Define to 1 if you have the <netinet/tcp.h> header file. */\n+#define HAVE_NETINET_TCP_H 1\n+\n+/* Define to 1 if you have the <net/if.h> header file. */\n+#define HAVE_NET_IF_H 1\n+\n+/* Define to 1 if you have PF_INET6. */\n+#define HAVE_PF_INET6 1\n+\n+/* Define to 1 if you have the recv function. */\n+#define HAVE_RECV 1\n+\n+/* Define to 1 if you have the recvfrom function. */\n+#define HAVE_RECVFROM 1\n+\n+/* Define to 1 if you have the send function. */\n+#define HAVE_SEND 1\n+\n+/* Define to 1 if you have the setsockopt function. */\n+#define HAVE_SETSOCKOPT 1\n+\n+/* Define to 1 if you have a working setsockopt SO_NONBLOCK function. */\n+/* #undef HAVE_SETSOCKOPT_SO_NONBLOCK */\n+\n+/* Define to 1 if you have the <signal.h> header file. */\n+#define HAVE_SIGNAL_H 1\n+\n+/* Define to 1 if sig_atomic_t is an available typedef. */\n+#define HAVE_SIG_ATOMIC_T 1\n+\n+/* Define to 1 if sig_atomic_t is already defined as volatile. */\n+/* #undef HAVE_SIG_ATOMIC_T_VOLATILE */\n+\n+/* Define to 1 if your struct sockaddr_in6 has sin6_scope_id. */\n+#define HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID 1\n+\n+/* Define to 1 if you have the socket function. */\n+#define HAVE_SOCKET 1\n+\n+/* Define to 1 if you have the <socket.h> header file. */\n+/* #undef HAVE_SOCKET_H */\n+\n+/* Define to 1 if you have the <stdbool.h> header file. */\n+#define HAVE_STDBOOL_H 1\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#define HAVE_STDINT_H 1\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#define HAVE_STDLIB_H 1\n+\n+/* Define to 1 if you have the strcasecmp function. */\n+#define HAVE_STRCASECMP 1\n+\n+/* Define to 1 if you have the strcmpi function. */\n+/* #undef HAVE_STRCMPI */\n+\n+/* Define to 1 if you have the strdup function. */\n+#define HAVE_STRDUP 1\n+\n+/* Define to 1 if you have the stricmp function. */\n+/* #undef HAVE_STRICMP */\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#define HAVE_STRINGS_H 1\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#define HAVE_STRING_H 1\n+\n+/* Define to 1 if you have the strncasecmp function. */\n+#define HAVE_STRNCASECMP 1\n+\n+/* Define to 1 if you have the strncmpi function. */\n+/* #undef HAVE_STRNCMPI */\n+\n+/* Define to 1 if you have the strnicmp function. */\n+/* #undef HAVE_STRNICMP */\n+\n+/* Define to 1 if you have the <stropts.h> header file. */\n+/* #undef HAVE_STROPTS_H */\n+\n+/* Define to 1 if you have struct addrinfo. */\n+#define HAVE_STRUCT_ADDRINFO 1\n+\n+/* Define to 1 if you have struct in6_addr. */\n+#define HAVE_STRUCT_IN6_ADDR 1\n+\n+/* Define to 1 if you have struct sockaddr_in6. */\n+#define HAVE_STRUCT_SOCKADDR_IN6 1\n+\n+/* if struct sockaddr_storage is defined */\n+#define HAVE_STRUCT_SOCKADDR_STORAGE 1\n+\n+/* Define to 1 if you have the timeval struct. */\n+#define HAVE_STRUCT_TIMEVAL 1\n+\n+/* Define to 1 if you have the <sys/ioctl.h> header file. */\n+#define HAVE_SYS_IOCTL_H 1\n+\n+/* Define to 1 if you have the <sys/param.h> header file. */\n+#define HAVE_SYS_PARAM_H 1\n+\n+/* Define to 1 if you have the <sys/select.h> header file. */\n+#define HAVE_SYS_SELECT_H 1\n+\n+/* Define to 1 if you have the <sys/socket.h> header file. */\n+#define HAVE_SYS_SOCKET_H 1\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#define HAVE_SYS_STAT_H 1\n+\n+/* Define to 1 if you have the <sys/time.h> header file. */\n+#define HAVE_SYS_TIME_H 1\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#define HAVE_SYS_TYPES_H 1\n+\n+/* Define to 1 if you have the <sys/uio.h> header file. */\n+#define HAVE_SYS_UIO_H 1\n+\n+/* Define to 1 if you have the <time.h> header file. */\n+#define HAVE_TIME_H 1\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#define HAVE_UNISTD_H 1\n+\n+/* Define to 1 if you have the windows.h header file. */\n+/* #undef HAVE_WINDOWS_H */\n+\n+/* Define to 1 if you have the winsock2.h header file. */\n+/* #undef HAVE_WINSOCK2_H */\n+\n+/* Define to 1 if you have the winsock.h header file. */\n+/* #undef HAVE_WINSOCK_H */\n+\n+/* Define to 1 if you have the writev function. */\n+#define HAVE_WRITEV 1\n+\n+/* Define to 1 if you have the ws2tcpip.h header file. */\n+/* #undef HAVE_WS2TCPIP_H */\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#define LT_OBJDIR \".libs/\"\n+\n+/* Define to 1 if you are building a native Windows target. */\n+/* #undef NATIVE_WINDOWS */\n+\n+/* Define to 1 if you need the malloc.h header file even with stdlib.h */\n+/* #undef NEED_MALLOC_H */\n+\n+/* Define to 1 if you need the memory.h header file even with stdlib.h */\n+/* #undef NEED_MEMORY_H */\n+\n+/* Define to 1 if _REENTRANT preprocessor symbol must be defined. */\n+/* #undef NEED_REENTRANT */\n+\n+/* Define to 1 if _THREAD_SAFE preprocessor symbol must be defined. */\n+/* #undef NEED_THREAD_SAFE */\n+\n+/* Define to 1 if your C compiler doesn't accept -c and -o together. */\n+/* #undef NO_MINUS_C_MINUS_O */\n+\n+/* cpu-machine-OS */\n+#define OS \"i386-apple-darwin9.8.0\"\n+\n+/* Name of package */\n+#define PACKAGE \"c-ares\"\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#define PACKAGE_BUGREPORT \"c-ares mailing list => http://cool.haxx.se/mailman/listinfo/c-ares\"\n+\n+/* Define to the full name of this package. */\n+#define PACKAGE_NAME \"c-ares\"\n+\n+/* Define to the full name and version of this package. */\n+#define PACKAGE_STRING \"c-ares 1.7.1\"\n+\n+/* Define to the one symbol short name of this package. */\n+#define PACKAGE_TARNAME \"c-ares\"\n+\n+/* Define to the home page for this package. */\n+#define PACKAGE_URL \"\"\n+\n+/* Define to the version of this package. */\n+#define PACKAGE_VERSION \"1.7.1\"\n+\n+/* a suitable file/device to read random data from */\n+#define RANDOM_FILE \"/dev/urandom\"\n+\n+/* Define to the type of arg 1 for recvfrom. */\n+#define RECVFROM_TYPE_ARG1 int\n+\n+/* Define to the type pointed by arg 2 for recvfrom. */\n+#define RECVFROM_TYPE_ARG2 void\n+\n+/* Define to 1 if the type pointed by arg 2 for recvfrom is void. */\n+#define RECVFROM_TYPE_ARG2_IS_VOID 1\n+\n+/* Define to the type of arg 3 for recvfrom. */\n+#define RECVFROM_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for recvfrom. */\n+#define RECVFROM_TYPE_ARG4 int\n+\n+/* Define to the type pointed by arg 5 for recvfrom. */\n+#define RECVFROM_TYPE_ARG5 struct sockaddr\n+\n+/* Define to 1 if the type pointed by arg 5 for recvfrom is void. */\n+/* #undef RECVFROM_TYPE_ARG5_IS_VOID */\n+\n+/* Define to the type pointed by arg 6 for recvfrom. */\n+#define RECVFROM_TYPE_ARG6 socklen_t\n+\n+/* Define to 1 if the type pointed by arg 6 for recvfrom is void. */\n+/* #undef RECVFROM_TYPE_ARG6_IS_VOID */\n+\n+/* Define to the function return type for recvfrom. */\n+#define RECVFROM_TYPE_RETV ssize_t\n+\n+/* Define to the type of arg 1 for recv. */\n+#define RECV_TYPE_ARG1 int\n+\n+/* Define to the type of arg 2 for recv. */\n+#define RECV_TYPE_ARG2 void *\n+\n+/* Define to the type of arg 3 for recv. */\n+#define RECV_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for recv. */\n+#define RECV_TYPE_ARG4 int\n+\n+/* Define to the function return type for recv. */\n+#define RECV_TYPE_RETV ssize_t\n+\n+/* Define as the return type of signal handlers (`int' or `void'). */\n+#define RETSIGTYPE void\n+\n+/* Define to the type qualifier of arg 2 for send. */\n+#define SEND_QUAL_ARG2 const\n+\n+/* Define to the type of arg 1 for send. */\n+#define SEND_TYPE_ARG1 int\n+\n+/* Define to the type of arg 2 for send. */\n+#define SEND_TYPE_ARG2 void *\n+\n+/* Define to the type of arg 3 for send. */\n+#define SEND_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for send. */\n+#define SEND_TYPE_ARG4 int\n+\n+/* Define to the function return type for send. */\n+#define SEND_TYPE_RETV ssize_t\n+\n+/* The size of `int', as computed by sizeof. */\n+#define SIZEOF_INT 4\n+\n+/* The size of `long', as computed by sizeof. */\n+#define SIZEOF_LONG 4\n+\n+/* The size of `size_t', as computed by sizeof. */\n+#define SIZEOF_SIZE_T 4\n+\n+/* The size of `struct in6_addr', as computed by sizeof. */\n+#define SIZEOF_STRUCT_IN6_ADDR 16\n+\n+/* The size of `struct in_addr', as computed by sizeof. */\n+#define SIZEOF_STRUCT_IN_ADDR 4\n+\n+/* The size of `time_t', as computed by sizeof. */\n+#define SIZEOF_TIME_T 4\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#define STDC_HEADERS 1\n+\n+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n+#define TIME_WITH_SYS_TIME 1\n+\n+/* Define to disable non-blocking sockets. */\n+/* #undef USE_BLOCKING_SOCKETS */\n+\n+/* Version number of package */\n+#define VERSION \"1.7.1\"\n+\n+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n+   significant byte first (like Motorola and SPARC, unlike Intel). */\n+#if defined AC_APPLE_UNIVERSAL_BUILD\n+# if defined __BIG_ENDIAN__\n+#  define WORDS_BIGENDIAN 1\n+# endif\n+#else\n+# ifndef WORDS_BIGENDIAN\n+/* #  undef WORDS_BIGENDIAN */\n+# endif\n+#endif\n+\n+/* Define to 1 if OS is AIX. */\n+#ifndef _ALL_SOURCE\n+/* #  undef _ALL_SOURCE */\n+#endif\n+\n+/* Number of bits in a file offset, on hosts where this is settable. */\n+/* #undef _FILE_OFFSET_BITS */\n+\n+/* Define for large files, on AIX-style hosts. */\n+/* #undef _LARGE_FILES */\n+\n+/* Define to empty if `const' does not conform to ANSI C. */\n+/* #undef const */\n+\n+/* Type to use in place of in_addr_t when system does not provide it. */\n+/* #undef in_addr_t */\n+\n+/* Define to `unsigned int' if <sys/types.h> does not define. */\n+/* #undef size_t */\n+\n+/* the signed version of size_t */\n+/* #undef ssize_t */"}, {"sha": "4164edb3e25fe9b017babca83421e82e7545f8ed", "filename": "src/rt/libuv/src/ares/config_freebsd/ares_config.h", "status": "added", "additions": 510, "deletions": 0, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_freebsd%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_freebsd%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_freebsd%2Fares_config.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,510 @@\n+/* ares_config.h.  Generated from ares_config.h.in by configure.  */\n+/* ares_config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define if building universal (internal helper macro) */\n+/* #undef AC_APPLE_UNIVERSAL_BUILD */\n+\n+/* define this if ares is built for a big endian system */\n+/* #undef ARES_BIG_ENDIAN */\n+\n+/* when building as static part of libcurl */\n+/* #undef BUILDING_LIBCURL */\n+\n+/* when building c-ares library */\n+/* #undef CARES_BUILDING_LIBRARY */\n+\n+/* when not building a shared library */\n+/* #undef CARES_STATICLIB */\n+\n+/* Define to 1 to enable hiding of library internal symbols. */\n+#define CARES_SYMBOL_HIDING 1\n+\n+/* Definition to make a library symbol externally visible. */\n+#define CARES_SYMBOL_SCOPE_EXTERN __attribute__ ((visibility (\"default\")))\n+\n+/* if a /etc/inet dir is being used */\n+/* #undef ETC_INET */\n+\n+/* Define to the type qualifier of arg 1 for getnameinfo. */\n+#define GETNAMEINFO_QUAL_ARG1 const\n+\n+/* Define to the type of arg 1 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG1 struct sockaddr *\n+\n+/* Define to the type of arg 2 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG2 socklen_t\n+\n+/* Define to the type of args 4 and 6 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG46 size_t\n+\n+/* Define to the type of arg 7 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG7 int\n+\n+/* Specifies the number of arguments to getservbyport_r */\n+#define GETSERVBYPORT_R_ARGS 6\n+\n+/* Specifies the size of the buffer to pass to getservbyport_r */\n+#define GETSERVBYPORT_R_BUFSIZE 4096\n+\n+/* Define to 1 if you have AF_INET6. */\n+#define HAVE_AF_INET6 1\n+\n+/* Define to 1 if you have the <arpa/inet.h> header file. */\n+#define HAVE_ARPA_INET_H 1\n+\n+/* Define to 1 if you have the <arpa/nameser_compat.h> header file. */\n+#define HAVE_ARPA_NAMESER_COMPAT_H 1\n+\n+/* Define to 1 if you have the <arpa/nameser.h> header file. */\n+#define HAVE_ARPA_NAMESER_H 1\n+\n+/* Define to 1 if you have the <assert.h> header file. */\n+#define HAVE_ASSERT_H 1\n+\n+/* Define to 1 if you have the `bitncmp' function. */\n+/* #undef HAVE_BITNCMP */\n+\n+/* Define to 1 if bool is an available type. */\n+#define HAVE_BOOL_T 1\n+\n+/* Define to 1 if you have the clock_gettime function and monotonic timer. */\n+#define HAVE_CLOCK_GETTIME_MONOTONIC 1\n+\n+/* Define to 1 if you have the closesocket function. */\n+/* #undef HAVE_CLOSESOCKET */\n+\n+/* Define to 1 if you have the CloseSocket camel case function. */\n+/* #undef HAVE_CLOSESOCKET_CAMEL */\n+\n+/* Define to 1 if you have the connect function. */\n+#define HAVE_CONNECT 1\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#define HAVE_DLFCN_H 1\n+\n+/* Define to 1 if you have the <errno.h> header file. */\n+#define HAVE_ERRNO_H 1\n+\n+/* Define to 1 if you have the fcntl function. */\n+#define HAVE_FCNTL 1\n+\n+/* Define to 1 if you have the <fcntl.h> header file. */\n+#define HAVE_FCNTL_H 1\n+\n+/* Define to 1 if you have a working fcntl O_NONBLOCK function. */\n+#define HAVE_FCNTL_O_NONBLOCK 1\n+\n+/* Define to 1 if you have the freeaddrinfo function. */\n+#define HAVE_FREEADDRINFO 1\n+\n+/* Define to 1 if you have a working getaddrinfo function. */\n+#define HAVE_GETADDRINFO 1\n+\n+/* Define to 1 if the getaddrinfo function is threadsafe. */\n+#define HAVE_GETADDRINFO_THREADSAFE 1\n+\n+/* Define to 1 if you have the gethostbyaddr function. */\n+#define HAVE_GETHOSTBYADDR 1\n+\n+/* Define to 1 if you have the gethostbyname function. */\n+#define HAVE_GETHOSTBYNAME 1\n+\n+/* Define to 1 if you have the gethostname function. */\n+#define HAVE_GETHOSTNAME 1\n+\n+/* Define to 1 if you have the getnameinfo function. */\n+#define HAVE_GETNAMEINFO 1\n+\n+/* Define to 1 if you have the getservbyport_r function. */\n+#define HAVE_GETSERVBYPORT_R 1\n+\n+/* Define to 1 if you have the `gettimeofday' function. */\n+#define HAVE_GETTIMEOFDAY 1\n+\n+/* Define to 1 if you have the `if_indextoname' function. */\n+#define HAVE_IF_INDEXTONAME 1\n+\n+/* Define to 1 if you have the `inet_net_pton' function. */\n+#define HAVE_INET_NET_PTON 1\n+\n+/* Define to 1 if inet_net_pton supports IPv6. */\n+/* #undef HAVE_INET_NET_PTON_IPV6 */\n+\n+/* Define to 1 if you have a IPv6 capable working inet_ntop function. */\n+#define HAVE_INET_NTOP 1\n+\n+/* Define to 1 if you have a IPv6 capable working inet_pton function. */\n+#define HAVE_INET_PTON 1\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#define HAVE_INTTYPES_H 1\n+\n+/* Define to 1 if you have the ioctl function. */\n+#define HAVE_IOCTL 1\n+\n+/* Define to 1 if you have the ioctlsocket function. */\n+/* #undef HAVE_IOCTLSOCKET */\n+\n+/* Define to 1 if you have the IoctlSocket camel case function. */\n+/* #undef HAVE_IOCTLSOCKET_CAMEL */\n+\n+/* Define to 1 if you have a working IoctlSocket camel case FIONBIO function.\n+   */\n+/* #undef HAVE_IOCTLSOCKET_CAMEL_FIONBIO */\n+\n+/* Define to 1 if you have a working ioctlsocket FIONBIO function. */\n+/* #undef HAVE_IOCTLSOCKET_FIONBIO */\n+\n+/* Define to 1 if you have a working ioctl FIONBIO function. */\n+#define HAVE_IOCTL_FIONBIO 1\n+\n+/* Define to 1 if you have a working ioctl SIOCGIFADDR function. */\n+#define HAVE_IOCTL_SIOCGIFADDR 1\n+\n+/* Define to 1 if you have the `resolve' library (-lresolve). */\n+/* #undef HAVE_LIBRESOLVE */\n+\n+/* Define to 1 if you have the <limits.h> header file. */\n+#define HAVE_LIMITS_H 1\n+\n+/* if your compiler supports LL */\n+#define HAVE_LL 1\n+\n+/* Define to 1 if the compiler supports the 'long long' data type. */\n+#define HAVE_LONGLONG 1\n+\n+/* Define to 1 if you have the malloc.h header file. */\n+/* #undef HAVE_MALLOC_H */\n+\n+/* Define to 1 if you have the memory.h header file. */\n+#define HAVE_MEMORY_H 1\n+\n+/* Define to 1 if you have the MSG_NOSIGNAL flag. */\n+#define HAVE_MSG_NOSIGNAL 1\n+\n+/* Define to 1 if you have the <netdb.h> header file. */\n+#define HAVE_NETDB_H 1\n+\n+/* Define to 1 if you have the <netinet/in.h> header file. */\n+#define HAVE_NETINET_IN_H 1\n+\n+/* Define to 1 if you have the <netinet/tcp.h> header file. */\n+#define HAVE_NETINET_TCP_H 1\n+\n+/* Define to 1 if you have the <net/if.h> header file. */\n+#define HAVE_NET_IF_H 1\n+\n+/* Define to 1 if you have PF_INET6. */\n+#define HAVE_PF_INET6 1\n+\n+/* Define to 1 if you have the recv function. */\n+#define HAVE_RECV 1\n+\n+/* Define to 1 if you have the recvfrom function. */\n+#define HAVE_RECVFROM 1\n+\n+/* Define to 1 if you have the send function. */\n+#define HAVE_SEND 1\n+\n+/* Define to 1 if you have the setsockopt function. */\n+#define HAVE_SETSOCKOPT 1\n+\n+/* Define to 1 if you have a working setsockopt SO_NONBLOCK function. */\n+/* #undef HAVE_SETSOCKOPT_SO_NONBLOCK */\n+\n+/* Define to 1 if you have the <signal.h> header file. */\n+#define HAVE_SIGNAL_H 1\n+\n+/* Define to 1 if sig_atomic_t is an available typedef. */\n+#define HAVE_SIG_ATOMIC_T 1\n+\n+/* Define to 1 if sig_atomic_t is already defined as volatile. */\n+/* #undef HAVE_SIG_ATOMIC_T_VOLATILE */\n+\n+/* Define to 1 if your struct sockaddr_in6 has sin6_scope_id. */\n+#define HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID 1\n+\n+/* Define to 1 if you have the socket function. */\n+#define HAVE_SOCKET 1\n+\n+/* Define to 1 if you have the <socket.h> header file. */\n+/* #undef HAVE_SOCKET_H */\n+\n+/* Define to 1 if you have the <stdbool.h> header file. */\n+#define HAVE_STDBOOL_H 1\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#define HAVE_STDINT_H 1\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#define HAVE_STDLIB_H 1\n+\n+/* Define to 1 if you have the strcasecmp function. */\n+#define HAVE_STRCASECMP 1\n+\n+/* Define to 1 if you have the strcmpi function. */\n+/* #undef HAVE_STRCMPI */\n+\n+/* Define to 1 if you have the strdup function. */\n+#define HAVE_STRDUP 1\n+\n+/* Define to 1 if you have the stricmp function. */\n+/* #undef HAVE_STRICMP */\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#define HAVE_STRINGS_H 1\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#define HAVE_STRING_H 1\n+\n+/* Define to 1 if you have the strncasecmp function. */\n+#define HAVE_STRNCASECMP 1\n+\n+/* Define to 1 if you have the strncmpi function. */\n+/* #undef HAVE_STRNCMPI */\n+\n+/* Define to 1 if you have the strnicmp function. */\n+/* #undef HAVE_STRNICMP */\n+\n+/* Define to 1 if you have the <stropts.h> header file. */\n+/* #undef HAVE_STROPTS_H */\n+\n+/* Define to 1 if you have struct addrinfo. */\n+#define HAVE_STRUCT_ADDRINFO 1\n+\n+/* Define to 1 if you have struct in6_addr. */\n+#define HAVE_STRUCT_IN6_ADDR 1\n+\n+/* Define to 1 if you have struct sockaddr_in6. */\n+#define HAVE_STRUCT_SOCKADDR_IN6 1\n+\n+/* if struct sockaddr_storage is defined */\n+#define HAVE_STRUCT_SOCKADDR_STORAGE 1\n+\n+/* Define to 1 if you have the timeval struct. */\n+#define HAVE_STRUCT_TIMEVAL 1\n+\n+/* Define to 1 if you have the <sys/ioctl.h> header file. */\n+#define HAVE_SYS_IOCTL_H 1\n+\n+/* Define to 1 if you have the <sys/param.h> header file. */\n+#define HAVE_SYS_PARAM_H 1\n+\n+/* Define to 1 if you have the <sys/select.h> header file. */\n+#define HAVE_SYS_SELECT_H 1\n+\n+/* Define to 1 if you have the <sys/socket.h> header file. */\n+#define HAVE_SYS_SOCKET_H 1\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#define HAVE_SYS_STAT_H 1\n+\n+/* Define to 1 if you have the <sys/time.h> header file. */\n+#define HAVE_SYS_TIME_H 1\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#define HAVE_SYS_TYPES_H 1\n+\n+/* Define to 1 if you have the <sys/uio.h> header file. */\n+#define HAVE_SYS_UIO_H 1\n+\n+/* Define to 1 if you have the <time.h> header file. */\n+#define HAVE_TIME_H 1\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#define HAVE_UNISTD_H 1\n+\n+/* Define to 1 if you have the windows.h header file. */\n+/* #undef HAVE_WINDOWS_H */\n+\n+/* Define to 1 if you have the winsock2.h header file. */\n+/* #undef HAVE_WINSOCK2_H */\n+\n+/* Define to 1 if you have the winsock.h header file. */\n+/* #undef HAVE_WINSOCK_H */\n+\n+/* Define to 1 if you have the writev function. */\n+#define HAVE_WRITEV 1\n+\n+/* Define to 1 if you have the ws2tcpip.h header file. */\n+/* #undef HAVE_WS2TCPIP_H */\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#define LT_OBJDIR \".libs/\"\n+\n+/* Define to 1 if you are building a native Windows target. */\n+/* #undef NATIVE_WINDOWS */\n+\n+/* Define to 1 if you need the malloc.h header file even with stdlib.h */\n+/* #undef NEED_MALLOC_H */\n+\n+/* Define to 1 if you need the memory.h header file even with stdlib.h */\n+/* #undef NEED_MEMORY_H */\n+\n+/* Define to 1 if _REENTRANT preprocessor symbol must be defined. */\n+/* #undef NEED_REENTRANT */\n+\n+/* Define to 1 if _THREAD_SAFE preprocessor symbol must be defined. */\n+/* #undef NEED_THREAD_SAFE */\n+\n+/* Define to 1 if your C compiler doesn't accept -c and -o together. */\n+/* #undef NO_MINUS_C_MINUS_O */\n+\n+/* cpu-machine-OS */\n+#define OS \"i386-portbld-freebsd8.0\"\n+\n+/* Name of package */\n+#define PACKAGE \"c-ares\"\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#define PACKAGE_BUGREPORT \"c-ares mailing list => http://cool.haxx.se/mailman/listinfo/c-ares\"\n+\n+/* Define to the full name of this package. */\n+#define PACKAGE_NAME \"c-ares\"\n+\n+/* Define to the full name and version of this package. */\n+#define PACKAGE_STRING \"c-ares 1.7.1\"\n+\n+/* Define to the one symbol short name of this package. */\n+#define PACKAGE_TARNAME \"c-ares\"\n+\n+/* Define to the home page for this package. */\n+#define PACKAGE_URL \"\"\n+\n+/* Define to the version of this package. */\n+#define PACKAGE_VERSION \"1.7.1\"\n+\n+/* a suitable file/device to read random data from */\n+#define RANDOM_FILE \"/dev/urandom\"\n+\n+/* Define to the type of arg 1 for recvfrom. */\n+#define RECVFROM_TYPE_ARG1 int\n+\n+/* Define to the type pointed by arg 2 for recvfrom. */\n+#define RECVFROM_TYPE_ARG2 void\n+\n+/* Define to 1 if the type pointed by arg 2 for recvfrom is void. */\n+#define RECVFROM_TYPE_ARG2_IS_VOID 1\n+\n+/* Define to the type of arg 3 for recvfrom. */\n+#define RECVFROM_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for recvfrom. */\n+#define RECVFROM_TYPE_ARG4 int\n+\n+/* Define to the type pointed by arg 5 for recvfrom. */\n+#define RECVFROM_TYPE_ARG5 struct sockaddr\n+\n+/* Define to 1 if the type pointed by arg 5 for recvfrom is void. */\n+/* #undef RECVFROM_TYPE_ARG5_IS_VOID */\n+\n+/* Define to the type pointed by arg 6 for recvfrom. */\n+#define RECVFROM_TYPE_ARG6 socklen_t\n+\n+/* Define to 1 if the type pointed by arg 6 for recvfrom is void. */\n+/* #undef RECVFROM_TYPE_ARG6_IS_VOID */\n+\n+/* Define to the function return type for recvfrom. */\n+#define RECVFROM_TYPE_RETV int\n+\n+/* Define to the type of arg 1 for recv. */\n+#define RECV_TYPE_ARG1 int\n+\n+/* Define to the type of arg 2 for recv. */\n+#define RECV_TYPE_ARG2 void *\n+\n+/* Define to the type of arg 3 for recv. */\n+#define RECV_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for recv. */\n+#define RECV_TYPE_ARG4 int\n+\n+/* Define to the function return type for recv. */\n+#define RECV_TYPE_RETV int\n+\n+/* Define as the return type of signal handlers (`int' or `void'). */\n+#define RETSIGTYPE void\n+\n+/* Define to the type qualifier of arg 2 for send. */\n+#define SEND_QUAL_ARG2 const\n+\n+/* Define to the type of arg 1 for send. */\n+#define SEND_TYPE_ARG1 int\n+\n+/* Define to the type of arg 2 for send. */\n+#define SEND_TYPE_ARG2 void *\n+\n+/* Define to the type of arg 3 for send. */\n+#define SEND_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for send. */\n+#define SEND_TYPE_ARG4 int\n+\n+/* Define to the function return type for send. */\n+#define SEND_TYPE_RETV int\n+\n+/* The size of `int', as computed by sizeof. */\n+#define SIZEOF_INT 4\n+\n+/* The size of `long', as computed by sizeof. */\n+#define SIZEOF_LONG 4\n+\n+/* The size of `size_t', as computed by sizeof. */\n+#define SIZEOF_SIZE_T 4\n+\n+/* The size of `struct in6_addr', as computed by sizeof. */\n+#define SIZEOF_STRUCT_IN6_ADDR 16\n+\n+/* The size of `struct in_addr', as computed by sizeof. */\n+#define SIZEOF_STRUCT_IN_ADDR 4\n+\n+/* The size of `time_t', as computed by sizeof. */\n+#define SIZEOF_TIME_T 4\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#define STDC_HEADERS 1\n+\n+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n+#define TIME_WITH_SYS_TIME 1\n+\n+/* Define to disable non-blocking sockets. */\n+/* #undef USE_BLOCKING_SOCKETS */\n+\n+/* Version number of package */\n+#define VERSION \"1.7.1\"\n+\n+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n+   significant byte first (like Motorola and SPARC, unlike Intel). */\n+#if defined AC_APPLE_UNIVERSAL_BUILD\n+# if defined __BIG_ENDIAN__\n+#  define WORDS_BIGENDIAN 1\n+# endif\n+#else\n+# ifndef WORDS_BIGENDIAN\n+/* #  undef WORDS_BIGENDIAN */\n+# endif\n+#endif\n+\n+/* Define to 1 if OS is AIX. */\n+#ifndef _ALL_SOURCE\n+/* #  undef _ALL_SOURCE */\n+#endif\n+\n+/* Number of bits in a file offset, on hosts where this is settable. */\n+/* #undef _FILE_OFFSET_BITS */\n+\n+/* Define for large files, on AIX-style hosts. */\n+/* #undef _LARGE_FILES */\n+\n+/* Define to empty if `const' does not conform to ANSI C. */\n+/* #undef const */\n+\n+/* Type to use in place of in_addr_t when system does not provide it. */\n+/* #undef in_addr_t */\n+\n+/* Define to `unsigned int' if <sys/types.h> does not define. */\n+/* #undef size_t */\n+\n+/* the signed version of size_t */\n+/* #undef ssize_t */"}, {"sha": "dca6476eb538a7f48fc7ae5e086799dd20f60353", "filename": "src/rt/libuv/src/ares/config_linux/ares_config.h", "status": "added", "additions": 510, "deletions": 0, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_linux%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_linux%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_linux%2Fares_config.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,510 @@\n+/* ares_config.h.  Generated from ares_config.h.in by configure.  */\n+/* ares_config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define if building universal (internal helper macro) */\n+/* #undef AC_APPLE_UNIVERSAL_BUILD */\n+\n+/* define this if ares is built for a big endian system */\n+/* #undef ARES_BIG_ENDIAN */\n+\n+/* when building as static part of libcurl */\n+/* #undef BUILDING_LIBCURL */\n+\n+/* when building c-ares library */\n+/* #undef CARES_BUILDING_LIBRARY */\n+\n+/* when not building a shared library */\n+/* #undef CARES_STATICLIB */\n+\n+/* Define to 1 to enable hiding of library internal symbols. */\n+#define CARES_SYMBOL_HIDING 1\n+\n+/* Definition to make a library symbol externally visible. */\n+#define CARES_SYMBOL_SCOPE_EXTERN __attribute__ ((visibility (\"default\")))\n+\n+/* if a /etc/inet dir is being used */\n+/* #undef ETC_INET */\n+\n+/* Define to the type qualifier of arg 1 for getnameinfo. */\n+#define GETNAMEINFO_QUAL_ARG1 const\n+\n+/* Define to the type of arg 1 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG1 struct sockaddr *\n+\n+/* Define to the type of arg 2 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG2 socklen_t\n+\n+/* Define to the type of args 4 and 6 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG46 size_t\n+\n+/* Define to the type of arg 7 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG7 unsigned int\n+\n+/* Specifies the number of arguments to getservbyport_r */\n+#define GETSERVBYPORT_R_ARGS 6\n+\n+/* Specifies the size of the buffer to pass to getservbyport_r */\n+#define GETSERVBYPORT_R_BUFSIZE 4096\n+\n+/* Define to 1 if you have AF_INET6. */\n+#define HAVE_AF_INET6 1\n+\n+/* Define to 1 if you have the <arpa/inet.h> header file. */\n+#define HAVE_ARPA_INET_H 1\n+\n+/* Define to 1 if you have the <arpa/nameser_compat.h> header file. */\n+#define HAVE_ARPA_NAMESER_COMPAT_H 1\n+\n+/* Define to 1 if you have the <arpa/nameser.h> header file. */\n+#define HAVE_ARPA_NAMESER_H 1\n+\n+/* Define to 1 if you have the <assert.h> header file. */\n+#define HAVE_ASSERT_H 1\n+\n+/* Define to 1 if you have the `bitncmp' function. */\n+/* #undef HAVE_BITNCMP */\n+\n+/* Define to 1 if bool is an available type. */\n+#define HAVE_BOOL_T 1\n+\n+/* Define to 1 if you have the clock_gettime function and monotonic timer. */\n+#define HAVE_CLOCK_GETTIME_MONOTONIC 1\n+\n+/* Define to 1 if you have the closesocket function. */\n+/* #undef HAVE_CLOSESOCKET */\n+\n+/* Define to 1 if you have the CloseSocket camel case function. */\n+/* #undef HAVE_CLOSESOCKET_CAMEL */\n+\n+/* Define to 1 if you have the connect function. */\n+#define HAVE_CONNECT 1\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#define HAVE_DLFCN_H 1\n+\n+/* Define to 1 if you have the <errno.h> header file. */\n+#define HAVE_ERRNO_H 1\n+\n+/* Define to 1 if you have the fcntl function. */\n+#define HAVE_FCNTL 1\n+\n+/* Define to 1 if you have the <fcntl.h> header file. */\n+#define HAVE_FCNTL_H 1\n+\n+/* Define to 1 if you have a working fcntl O_NONBLOCK function. */\n+#define HAVE_FCNTL_O_NONBLOCK 1\n+\n+/* Define to 1 if you have the freeaddrinfo function. */\n+#define HAVE_FREEADDRINFO 1\n+\n+/* Define to 1 if you have a working getaddrinfo function. */\n+#define HAVE_GETADDRINFO 1\n+\n+/* Define to 1 if the getaddrinfo function is threadsafe. */\n+#define HAVE_GETADDRINFO_THREADSAFE 1\n+\n+/* Define to 1 if you have the gethostbyaddr function. */\n+#define HAVE_GETHOSTBYADDR 1\n+\n+/* Define to 1 if you have the gethostbyname function. */\n+#define HAVE_GETHOSTBYNAME 1\n+\n+/* Define to 1 if you have the gethostname function. */\n+#define HAVE_GETHOSTNAME 1\n+\n+/* Define to 1 if you have the getnameinfo function. */\n+#define HAVE_GETNAMEINFO 1\n+\n+/* Define to 1 if you have the getservbyport_r function. */\n+#define HAVE_GETSERVBYPORT_R 1\n+\n+/* Define to 1 if you have the `gettimeofday' function. */\n+#define HAVE_GETTIMEOFDAY 1\n+\n+/* Define to 1 if you have the `if_indextoname' function. */\n+#define HAVE_IF_INDEXTONAME 1\n+\n+/* Define to 1 if you have the `inet_net_pton' function. */\n+/* #undef HAVE_INET_NET_PTON */\n+\n+/* Define to 1 if inet_net_pton supports IPv6. */\n+/* #undef HAVE_INET_NET_PTON_IPV6 */\n+\n+/* Define to 1 if you have a IPv6 capable working inet_ntop function. */\n+#define HAVE_INET_NTOP 1\n+\n+/* Define to 1 if you have a IPv6 capable working inet_pton function. */\n+#define HAVE_INET_PTON 1\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#define HAVE_INTTYPES_H 1\n+\n+/* Define to 1 if you have the ioctl function. */\n+#define HAVE_IOCTL 1\n+\n+/* Define to 1 if you have the ioctlsocket function. */\n+/* #undef HAVE_IOCTLSOCKET */\n+\n+/* Define to 1 if you have the IoctlSocket camel case function. */\n+/* #undef HAVE_IOCTLSOCKET_CAMEL */\n+\n+/* Define to 1 if you have a working IoctlSocket camel case FIONBIO function.\n+   */\n+/* #undef HAVE_IOCTLSOCKET_CAMEL_FIONBIO */\n+\n+/* Define to 1 if you have a working ioctlsocket FIONBIO function. */\n+/* #undef HAVE_IOCTLSOCKET_FIONBIO */\n+\n+/* Define to 1 if you have a working ioctl FIONBIO function. */\n+#define HAVE_IOCTL_FIONBIO 1\n+\n+/* Define to 1 if you have a working ioctl SIOCGIFADDR function. */\n+#define HAVE_IOCTL_SIOCGIFADDR 1\n+\n+/* Define to 1 if you have the `resolve' library (-lresolve). */\n+/* #undef HAVE_LIBRESOLVE */\n+\n+/* Define to 1 if you have the <limits.h> header file. */\n+#define HAVE_LIMITS_H 1\n+\n+/* if your compiler supports LL */\n+#define HAVE_LL 1\n+\n+/* Define to 1 if the compiler supports the 'long long' data type. */\n+#define HAVE_LONGLONG 1\n+\n+/* Define to 1 if you have the malloc.h header file. */\n+#define HAVE_MALLOC_H 1\n+\n+/* Define to 1 if you have the memory.h header file. */\n+#define HAVE_MEMORY_H 1\n+\n+/* Define to 1 if you have the MSG_NOSIGNAL flag. */\n+#define HAVE_MSG_NOSIGNAL 1\n+\n+/* Define to 1 if you have the <netdb.h> header file. */\n+#define HAVE_NETDB_H 1\n+\n+/* Define to 1 if you have the <netinet/in.h> header file. */\n+#define HAVE_NETINET_IN_H 1\n+\n+/* Define to 1 if you have the <netinet/tcp.h> header file. */\n+#define HAVE_NETINET_TCP_H 1\n+\n+/* Define to 1 if you have the <net/if.h> header file. */\n+#define HAVE_NET_IF_H 1\n+\n+/* Define to 1 if you have PF_INET6. */\n+#define HAVE_PF_INET6 1\n+\n+/* Define to 1 if you have the recv function. */\n+#define HAVE_RECV 1\n+\n+/* Define to 1 if you have the recvfrom function. */\n+#define HAVE_RECVFROM 1\n+\n+/* Define to 1 if you have the send function. */\n+#define HAVE_SEND 1\n+\n+/* Define to 1 if you have the setsockopt function. */\n+#define HAVE_SETSOCKOPT 1\n+\n+/* Define to 1 if you have a working setsockopt SO_NONBLOCK function. */\n+/* #undef HAVE_SETSOCKOPT_SO_NONBLOCK */\n+\n+/* Define to 1 if you have the <signal.h> header file. */\n+#define HAVE_SIGNAL_H 1\n+\n+/* Define to 1 if sig_atomic_t is an available typedef. */\n+#define HAVE_SIG_ATOMIC_T 1\n+\n+/* Define to 1 if sig_atomic_t is already defined as volatile. */\n+/* #undef HAVE_SIG_ATOMIC_T_VOLATILE */\n+\n+/* Define to 1 if your struct sockaddr_in6 has sin6_scope_id. */\n+#define HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID 1\n+\n+/* Define to 1 if you have the socket function. */\n+#define HAVE_SOCKET 1\n+\n+/* Define to 1 if you have the <socket.h> header file. */\n+/* #undef HAVE_SOCKET_H */\n+\n+/* Define to 1 if you have the <stdbool.h> header file. */\n+#define HAVE_STDBOOL_H 1\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#define HAVE_STDINT_H 1\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#define HAVE_STDLIB_H 1\n+\n+/* Define to 1 if you have the strcasecmp function. */\n+#define HAVE_STRCASECMP 1\n+\n+/* Define to 1 if you have the strcmpi function. */\n+/* #undef HAVE_STRCMPI */\n+\n+/* Define to 1 if you have the strdup function. */\n+#define HAVE_STRDUP 1\n+\n+/* Define to 1 if you have the stricmp function. */\n+/* #undef HAVE_STRICMP */\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#define HAVE_STRINGS_H 1\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#define HAVE_STRING_H 1\n+\n+/* Define to 1 if you have the strncasecmp function. */\n+#define HAVE_STRNCASECMP 1\n+\n+/* Define to 1 if you have the strncmpi function. */\n+/* #undef HAVE_STRNCMPI */\n+\n+/* Define to 1 if you have the strnicmp function. */\n+/* #undef HAVE_STRNICMP */\n+\n+/* Define to 1 if you have the <stropts.h> header file. */\n+#define HAVE_STROPTS_H 1\n+\n+/* Define to 1 if you have struct addrinfo. */\n+#define HAVE_STRUCT_ADDRINFO 1\n+\n+/* Define to 1 if you have struct in6_addr. */\n+#define HAVE_STRUCT_IN6_ADDR 1\n+\n+/* Define to 1 if you have struct sockaddr_in6. */\n+#define HAVE_STRUCT_SOCKADDR_IN6 1\n+\n+/* if struct sockaddr_storage is defined */\n+#define HAVE_STRUCT_SOCKADDR_STORAGE 1\n+\n+/* Define to 1 if you have the timeval struct. */\n+#define HAVE_STRUCT_TIMEVAL 1\n+\n+/* Define to 1 if you have the <sys/ioctl.h> header file. */\n+#define HAVE_SYS_IOCTL_H 1\n+\n+/* Define to 1 if you have the <sys/param.h> header file. */\n+#define HAVE_SYS_PARAM_H 1\n+\n+/* Define to 1 if you have the <sys/select.h> header file. */\n+#define HAVE_SYS_SELECT_H 1\n+\n+/* Define to 1 if you have the <sys/socket.h> header file. */\n+#define HAVE_SYS_SOCKET_H 1\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#define HAVE_SYS_STAT_H 1\n+\n+/* Define to 1 if you have the <sys/time.h> header file. */\n+#define HAVE_SYS_TIME_H 1\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#define HAVE_SYS_TYPES_H 1\n+\n+/* Define to 1 if you have the <sys/uio.h> header file. */\n+#define HAVE_SYS_UIO_H 1\n+\n+/* Define to 1 if you have the <time.h> header file. */\n+#define HAVE_TIME_H 1\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#define HAVE_UNISTD_H 1\n+\n+/* Define to 1 if you have the windows.h header file. */\n+/* #undef HAVE_WINDOWS_H */\n+\n+/* Define to 1 if you have the winsock2.h header file. */\n+/* #undef HAVE_WINSOCK2_H */\n+\n+/* Define to 1 if you have the winsock.h header file. */\n+/* #undef HAVE_WINSOCK_H */\n+\n+/* Define to 1 if you have the writev function. */\n+#define HAVE_WRITEV 1\n+\n+/* Define to 1 if you have the ws2tcpip.h header file. */\n+/* #undef HAVE_WS2TCPIP_H */\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#define LT_OBJDIR \".libs/\"\n+\n+/* Define to 1 if you are building a native Windows target. */\n+/* #undef NATIVE_WINDOWS */\n+\n+/* Define to 1 if you need the malloc.h header file even with stdlib.h */\n+/* #undef NEED_MALLOC_H */\n+\n+/* Define to 1 if you need the memory.h header file even with stdlib.h */\n+/* #undef NEED_MEMORY_H */\n+\n+/* Define to 1 if _REENTRANT preprocessor symbol must be defined. */\n+/* #undef NEED_REENTRANT */\n+\n+/* Define to 1 if _THREAD_SAFE preprocessor symbol must be defined. */\n+/* #undef NEED_THREAD_SAFE */\n+\n+/* Define to 1 if your C compiler doesn't accept -c and -o together. */\n+/* #undef NO_MINUS_C_MINUS_O */\n+\n+/* cpu-machine-OS */\n+#define OS \"i686-pc-linux-gnu\"\n+\n+/* Name of package */\n+#define PACKAGE \"c-ares\"\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#define PACKAGE_BUGREPORT \"c-ares mailing list => http://cool.haxx.se/mailman/listinfo/c-ares\"\n+\n+/* Define to the full name of this package. */\n+#define PACKAGE_NAME \"c-ares\"\n+\n+/* Define to the full name and version of this package. */\n+#define PACKAGE_STRING \"c-ares 1.7.1\"\n+\n+/* Define to the one symbol short name of this package. */\n+#define PACKAGE_TARNAME \"c-ares\"\n+\n+/* Define to the home page for this package. */\n+#define PACKAGE_URL \"\"\n+\n+/* Define to the version of this package. */\n+#define PACKAGE_VERSION \"1.7.1\"\n+\n+/* a suitable file/device to read random data from */\n+#define RANDOM_FILE \"/dev/urandom\"\n+\n+/* Define to the type of arg 1 for recvfrom. */\n+#define RECVFROM_TYPE_ARG1 int\n+\n+/* Define to the type pointed by arg 2 for recvfrom. */\n+#define RECVFROM_TYPE_ARG2 void\n+\n+/* Define to 1 if the type pointed by arg 2 for recvfrom is void. */\n+#define RECVFROM_TYPE_ARG2_IS_VOID 1\n+\n+/* Define to the type of arg 3 for recvfrom. */\n+#define RECVFROM_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for recvfrom. */\n+#define RECVFROM_TYPE_ARG4 int\n+\n+/* Define to the type pointed by arg 5 for recvfrom. */\n+#define RECVFROM_TYPE_ARG5 struct sockaddr\n+\n+/* Define to 1 if the type pointed by arg 5 for recvfrom is void. */\n+/* #undef RECVFROM_TYPE_ARG5_IS_VOID */\n+\n+/* Define to the type pointed by arg 6 for recvfrom. */\n+#define RECVFROM_TYPE_ARG6 socklen_t\n+\n+/* Define to 1 if the type pointed by arg 6 for recvfrom is void. */\n+/* #undef RECVFROM_TYPE_ARG6_IS_VOID */\n+\n+/* Define to the function return type for recvfrom. */\n+#define RECVFROM_TYPE_RETV int\n+\n+/* Define to the type of arg 1 for recv. */\n+#define RECV_TYPE_ARG1 int\n+\n+/* Define to the type of arg 2 for recv. */\n+#define RECV_TYPE_ARG2 void *\n+\n+/* Define to the type of arg 3 for recv. */\n+#define RECV_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for recv. */\n+#define RECV_TYPE_ARG4 int\n+\n+/* Define to the function return type for recv. */\n+#define RECV_TYPE_RETV int\n+\n+/* Define as the return type of signal handlers (`int' or `void'). */\n+#define RETSIGTYPE void\n+\n+/* Define to the type qualifier of arg 2 for send. */\n+#define SEND_QUAL_ARG2 const\n+\n+/* Define to the type of arg 1 for send. */\n+#define SEND_TYPE_ARG1 int\n+\n+/* Define to the type of arg 2 for send. */\n+#define SEND_TYPE_ARG2 void *\n+\n+/* Define to the type of arg 3 for send. */\n+#define SEND_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for send. */\n+#define SEND_TYPE_ARG4 int\n+\n+/* Define to the function return type for send. */\n+#define SEND_TYPE_RETV int\n+\n+/* The size of `int', as computed by sizeof. */\n+#define SIZEOF_INT 4\n+\n+/* The size of `long', as computed by sizeof. */\n+#define SIZEOF_LONG 4\n+\n+/* The size of `size_t', as computed by sizeof. */\n+#define SIZEOF_SIZE_T 4\n+\n+/* The size of `struct in6_addr', as computed by sizeof. */\n+#define SIZEOF_STRUCT_IN6_ADDR 16\n+\n+/* The size of `struct in_addr', as computed by sizeof. */\n+#define SIZEOF_STRUCT_IN_ADDR 4\n+\n+/* The size of `time_t', as computed by sizeof. */\n+#define SIZEOF_TIME_T 4\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#define STDC_HEADERS 1\n+\n+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n+#define TIME_WITH_SYS_TIME 1\n+\n+/* Define to disable non-blocking sockets. */\n+/* #undef USE_BLOCKING_SOCKETS */\n+\n+/* Version number of package */\n+#define VERSION \"1.7.1\"\n+\n+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n+   significant byte first (like Motorola and SPARC, unlike Intel). */\n+#if defined AC_APPLE_UNIVERSAL_BUILD\n+# if defined __BIG_ENDIAN__\n+#  define WORDS_BIGENDIAN 1\n+# endif\n+#else\n+# ifndef WORDS_BIGENDIAN\n+/* #  undef WORDS_BIGENDIAN */\n+# endif\n+#endif\n+\n+/* Define to 1 if OS is AIX. */\n+#ifndef _ALL_SOURCE\n+/* #  undef _ALL_SOURCE */\n+#endif\n+\n+/* Number of bits in a file offset, on hosts where this is settable. */\n+#define _FILE_OFFSET_BITS 64\n+\n+/* Define for large files, on AIX-style hosts. */\n+/* #undef _LARGE_FILES */\n+\n+/* Define to empty if `const' does not conform to ANSI C. */\n+/* #undef const */\n+\n+/* Type to use in place of in_addr_t when system does not provide it. */\n+/* #undef in_addr_t */\n+\n+/* Define to `unsigned int' if <sys/types.h> does not define. */\n+/* #undef size_t */\n+\n+/* the signed version of size_t */\n+/* #undef ssize_t */"}, {"sha": "5e3ae6886452517297fa3399930d29776707e3b8", "filename": "src/rt/libuv/src/ares/config_openbsd/ares_config.h", "status": "added", "additions": 510, "deletions": 0, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_openbsd%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_openbsd%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_openbsd%2Fares_config.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,510 @@\n+/* ares_config.h.  Generated from ares_config.h.in by configure.  */\n+/* ares_config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define if building universal (internal helper macro) */\n+/* #undef AC_APPLE_UNIVERSAL_BUILD */\n+\n+/* define this if ares is built for a big endian system */\n+/* #undef ARES_BIG_ENDIAN */\n+\n+/* when building as static part of libcurl */\n+/* #undef BUILDING_LIBCURL */\n+\n+/* when building c-ares library */\n+/* #undef CARES_BUILDING_LIBRARY */\n+\n+/* when not building a shared library */\n+/* #undef CARES_STATICLIB */\n+\n+/* Define to 1 to enable hiding of library internal symbols. */\n+/* #undef CARES_SYMBOL_HIDING */\n+\n+/* Definition to make a library symbol externally visible. */\n+/* #undef CARES_SYMBOL_SCOPE_EXTERN */\n+\n+/* if a /etc/inet dir is being used */\n+/* #undef ETC_INET */\n+\n+/* Define to the type qualifier of arg 1 for getnameinfo. */\n+#define GETNAMEINFO_QUAL_ARG1 const\n+\n+/* Define to the type of arg 1 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG1 struct sockaddr *\n+\n+/* Define to the type of arg 2 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG2 socklen_t\n+\n+/* Define to the type of args 4 and 6 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG46 size_t\n+\n+/* Define to the type of arg 7 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG7 int\n+\n+/* Specifies the number of arguments to getservbyport_r */\n+#define GETSERVBYPORT_R_ARGS 4\n+\n+/* Specifies the size of the buffer to pass to getservbyport_r */\n+#define GETSERVBYPORT_R_BUFSIZE sizeof(struct servent_data)\n+\n+/* Define to 1 if you have AF_INET6. */\n+#define HAVE_AF_INET6 1\n+\n+/* Define to 1 if you have the <arpa/inet.h> header file. */\n+#define HAVE_ARPA_INET_H 1\n+\n+/* Define to 1 if you have the <arpa/nameser_compat.h> header file. */\n+/* #undef HAVE_ARPA_NAMESER_COMPAT_H */\n+\n+/* Define to 1 if you have the <arpa/nameser.h> header file. */\n+#define HAVE_ARPA_NAMESER_H 1\n+\n+/* Define to 1 if you have the <assert.h> header file. */\n+#define HAVE_ASSERT_H 1\n+\n+/* Define to 1 if you have the `bitncmp' function. */\n+/* #undef HAVE_BITNCMP */\n+\n+/* Define to 1 if bool is an available type. */\n+#define HAVE_BOOL_T 1\n+\n+/* Define to 1 if you have the clock_gettime function and monotonic timer. */\n+#define HAVE_CLOCK_GETTIME_MONOTONIC 1\n+\n+/* Define to 1 if you have the closesocket function. */\n+/* #undef HAVE_CLOSESOCKET */\n+\n+/* Define to 1 if you have the CloseSocket camel case function. */\n+/* #undef HAVE_CLOSESOCKET_CAMEL */\n+\n+/* Define to 1 if you have the connect function. */\n+#define HAVE_CONNECT 1\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#define HAVE_DLFCN_H 1\n+\n+/* Define to 1 if you have the <errno.h> header file. */\n+#define HAVE_ERRNO_H 1\n+\n+/* Define to 1 if you have the fcntl function. */\n+#define HAVE_FCNTL 1\n+\n+/* Define to 1 if you have the <fcntl.h> header file. */\n+#define HAVE_FCNTL_H 1\n+\n+/* Define to 1 if you have a working fcntl O_NONBLOCK function. */\n+#define HAVE_FCNTL_O_NONBLOCK 1\n+\n+/* Define to 1 if you have the freeaddrinfo function. */\n+#define HAVE_FREEADDRINFO 1\n+\n+/* Define to 1 if you have a working getaddrinfo function. */\n+#define HAVE_GETADDRINFO 1\n+\n+/* Define to 1 if the getaddrinfo function is threadsafe. */\n+/* #undef HAVE_GETADDRINFO_THREADSAFE */\n+\n+/* Define to 1 if you have the gethostbyaddr function. */\n+#define HAVE_GETHOSTBYADDR 1\n+\n+/* Define to 1 if you have the gethostbyname function. */\n+#define HAVE_GETHOSTBYNAME 1\n+\n+/* Define to 1 if you have the gethostname function. */\n+#define HAVE_GETHOSTNAME 1\n+\n+/* Define to 1 if you have the getnameinfo function. */\n+#define HAVE_GETNAMEINFO 1\n+\n+/* Define to 1 if you have the getservbyport_r function. */\n+#define HAVE_GETSERVBYPORT_R 1\n+\n+/* Define to 1 if you have the `gettimeofday' function. */\n+#define HAVE_GETTIMEOFDAY 1\n+\n+/* Define to 1 if you have the `if_indextoname' function. */\n+#define HAVE_IF_INDEXTONAME 1\n+\n+/* Define to 1 if you have the `inet_net_pton' function. */\n+#define HAVE_INET_NET_PTON 1\n+\n+/* Define to 1 if inet_net_pton supports IPv6. */\n+/* #undef HAVE_INET_NET_PTON_IPV6 */\n+\n+/* Define to 1 if you have a IPv6 capable working inet_ntop function. */\n+#define HAVE_INET_NTOP 1\n+\n+/* Define to 1 if you have a IPv6 capable working inet_pton function. */\n+#define HAVE_INET_PTON 1\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#define HAVE_INTTYPES_H 1\n+\n+/* Define to 1 if you have the ioctl function. */\n+#define HAVE_IOCTL 1\n+\n+/* Define to 1 if you have the ioctlsocket function. */\n+/* #undef HAVE_IOCTLSOCKET */\n+\n+/* Define to 1 if you have the IoctlSocket camel case function. */\n+/* #undef HAVE_IOCTLSOCKET_CAMEL */\n+\n+/* Define to 1 if you have a working IoctlSocket camel case FIONBIO function.\n+   */\n+/* #undef HAVE_IOCTLSOCKET_CAMEL_FIONBIO */\n+\n+/* Define to 1 if you have a working ioctlsocket FIONBIO function. */\n+/* #undef HAVE_IOCTLSOCKET_FIONBIO */\n+\n+/* Define to 1 if you have a working ioctl FIONBIO function. */\n+#define HAVE_IOCTL_FIONBIO 1\n+\n+/* Define to 1 if you have a working ioctl SIOCGIFADDR function. */\n+#define HAVE_IOCTL_SIOCGIFADDR 1\n+\n+/* Define to 1 if you have the `resolve' library (-lresolve). */\n+/* #undef HAVE_LIBRESOLVE */\n+\n+/* Define to 1 if you have the <limits.h> header file. */\n+#define HAVE_LIMITS_H 1\n+\n+/* if your compiler supports LL */\n+#define HAVE_LL 1\n+\n+/* Define to 1 if the compiler supports the 'long long' data type. */\n+#define HAVE_LONGLONG 1\n+\n+/* Define to 1 if you have the malloc.h header file. */\n+#define HAVE_MALLOC_H 1\n+\n+/* Define to 1 if you have the memory.h header file. */\n+#define HAVE_MEMORY_H 1\n+\n+/* Define to 1 if you have the MSG_NOSIGNAL flag. */\n+/* #undef HAVE_MSG_NOSIGNAL */\n+\n+/* Define to 1 if you have the <netdb.h> header file. */\n+#define HAVE_NETDB_H 1\n+\n+/* Define to 1 if you have the <netinet/in.h> header file. */\n+#define HAVE_NETINET_IN_H 1\n+\n+/* Define to 1 if you have the <netinet/tcp.h> header file. */\n+#define HAVE_NETINET_TCP_H 1\n+\n+/* Define to 1 if you have the <net/if.h> header file. */\n+#define HAVE_NET_IF_H 1\n+\n+/* Define to 1 if you have PF_INET6. */\n+#define HAVE_PF_INET6 1\n+\n+/* Define to 1 if you have the recv function. */\n+#define HAVE_RECV 1\n+\n+/* Define to 1 if you have the recvfrom function. */\n+#define HAVE_RECVFROM 1\n+\n+/* Define to 1 if you have the send function. */\n+#define HAVE_SEND 1\n+\n+/* Define to 1 if you have the setsockopt function. */\n+#define HAVE_SETSOCKOPT 1\n+\n+/* Define to 1 if you have a working setsockopt SO_NONBLOCK function. */\n+/* #undef HAVE_SETSOCKOPT_SO_NONBLOCK */\n+\n+/* Define to 1 if you have the <signal.h> header file. */\n+#define HAVE_SIGNAL_H 1\n+\n+/* Define to 1 if sig_atomic_t is an available typedef. */\n+#define HAVE_SIG_ATOMIC_T 1\n+\n+/* Define to 1 if sig_atomic_t is already defined as volatile. */\n+/* #undef HAVE_SIG_ATOMIC_T_VOLATILE */\n+\n+/* Define to 1 if your struct sockaddr_in6 has sin6_scope_id. */\n+#define HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID 1\n+\n+/* Define to 1 if you have the socket function. */\n+#define HAVE_SOCKET 1\n+\n+/* Define to 1 if you have the <socket.h> header file. */\n+/* #undef HAVE_SOCKET_H */\n+\n+/* Define to 1 if you have the <stdbool.h> header file. */\n+#define HAVE_STDBOOL_H 1\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#define HAVE_STDINT_H 1\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#define HAVE_STDLIB_H 1\n+\n+/* Define to 1 if you have the strcasecmp function. */\n+#define HAVE_STRCASECMP 1\n+\n+/* Define to 1 if you have the strcmpi function. */\n+/* #undef HAVE_STRCMPI */\n+\n+/* Define to 1 if you have the strdup function. */\n+#define HAVE_STRDUP 1\n+\n+/* Define to 1 if you have the stricmp function. */\n+/* #undef HAVE_STRICMP */\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#define HAVE_STRINGS_H 1\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#define HAVE_STRING_H 1\n+\n+/* Define to 1 if you have the strncasecmp function. */\n+#define HAVE_STRNCASECMP 1\n+\n+/* Define to 1 if you have the strncmpi function. */\n+/* #undef HAVE_STRNCMPI */\n+\n+/* Define to 1 if you have the strnicmp function. */\n+/* #undef HAVE_STRNICMP */\n+\n+/* Define to 1 if you have the <stropts.h> header file. */\n+/* #undef HAVE_STROPTS_H */\n+\n+/* Define to 1 if you have struct addrinfo. */\n+#define HAVE_STRUCT_ADDRINFO 1\n+\n+/* Define to 1 if you have struct in6_addr. */\n+#define HAVE_STRUCT_IN6_ADDR 1\n+\n+/* Define to 1 if you have struct sockaddr_in6. */\n+#define HAVE_STRUCT_SOCKADDR_IN6 1\n+\n+/* if struct sockaddr_storage is defined */\n+#define HAVE_STRUCT_SOCKADDR_STORAGE 1\n+\n+/* Define to 1 if you have the timeval struct. */\n+#define HAVE_STRUCT_TIMEVAL 1\n+\n+/* Define to 1 if you have the <sys/ioctl.h> header file. */\n+#define HAVE_SYS_IOCTL_H 1\n+\n+/* Define to 1 if you have the <sys/param.h> header file. */\n+#define HAVE_SYS_PARAM_H 1\n+\n+/* Define to 1 if you have the <sys/select.h> header file. */\n+#define HAVE_SYS_SELECT_H 1\n+\n+/* Define to 1 if you have the <sys/socket.h> header file. */\n+#define HAVE_SYS_SOCKET_H 1\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#define HAVE_SYS_STAT_H 1\n+\n+/* Define to 1 if you have the <sys/time.h> header file. */\n+#define HAVE_SYS_TIME_H 1\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#define HAVE_SYS_TYPES_H 1\n+\n+/* Define to 1 if you have the <sys/uio.h> header file. */\n+#define HAVE_SYS_UIO_H 1\n+\n+/* Define to 1 if you have the <time.h> header file. */\n+#define HAVE_TIME_H 1\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#define HAVE_UNISTD_H 1\n+\n+/* Define to 1 if you have the windows.h header file. */\n+/* #undef HAVE_WINDOWS_H */\n+\n+/* Define to 1 if you have the winsock2.h header file. */\n+/* #undef HAVE_WINSOCK2_H */\n+\n+/* Define to 1 if you have the winsock.h header file. */\n+/* #undef HAVE_WINSOCK_H */\n+\n+/* Define to 1 if you have the writev function. */\n+#define HAVE_WRITEV 1\n+\n+/* Define to 1 if you have the ws2tcpip.h header file. */\n+/* #undef HAVE_WS2TCPIP_H */\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#define LT_OBJDIR \".libs/\"\n+\n+/* Define to 1 if you are building a native Windows target. */\n+/* #undef NATIVE_WINDOWS */\n+\n+/* Define to 1 if you need the malloc.h header file even with stdlib.h */\n+/* #undef NEED_MALLOC_H */\n+\n+/* Define to 1 if you need the memory.h header file even with stdlib.h */\n+/* #undef NEED_MEMORY_H */\n+\n+/* Define to 1 if _REENTRANT preprocessor symbol must be defined. */\n+/* #undef NEED_REENTRANT */\n+\n+/* Define to 1 if _THREAD_SAFE preprocessor symbol must be defined. */\n+/* #undef NEED_THREAD_SAFE */\n+\n+/* Define to 1 if your C compiler doesn't accept -c and -o together. */\n+/* #undef NO_MINUS_C_MINUS_O */\n+\n+/* cpu-machine-OS */\n+#define OS \"i386-unknown-openbsd4.7\"\n+\n+/* Name of package */\n+#define PACKAGE \"c-ares\"\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#define PACKAGE_BUGREPORT \"c-ares mailing list => http://cool.haxx.se/mailman/listinfo/c-ares\"\n+\n+/* Define to the full name of this package. */\n+#define PACKAGE_NAME \"c-ares\"\n+\n+/* Define to the full name and version of this package. */\n+#define PACKAGE_STRING \"c-ares 1.7.1\"\n+\n+/* Define to the one symbol short name of this package. */\n+#define PACKAGE_TARNAME \"c-ares\"\n+\n+/* Define to the home page for this package. */\n+#define PACKAGE_URL \"\"\n+\n+/* Define to the version of this package. */\n+#define PACKAGE_VERSION \"1.7.1\"\n+\n+/* a suitable file/device to read random data from */\n+#define RANDOM_FILE \"/dev/urandom\"\n+\n+/* Define to the type of arg 1 for recvfrom. */\n+#define RECVFROM_TYPE_ARG1 int\n+\n+/* Define to the type pointed by arg 2 for recvfrom. */\n+#define RECVFROM_TYPE_ARG2 void\n+\n+/* Define to 1 if the type pointed by arg 2 for recvfrom is void. */\n+#define RECVFROM_TYPE_ARG2_IS_VOID 1\n+\n+/* Define to the type of arg 3 for recvfrom. */\n+#define RECVFROM_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for recvfrom. */\n+#define RECVFROM_TYPE_ARG4 int\n+\n+/* Define to the type pointed by arg 5 for recvfrom. */\n+#define RECVFROM_TYPE_ARG5 struct sockaddr\n+\n+/* Define to 1 if the type pointed by arg 5 for recvfrom is void. */\n+/* #undef RECVFROM_TYPE_ARG5_IS_VOID */\n+\n+/* Define to the type pointed by arg 6 for recvfrom. */\n+#define RECVFROM_TYPE_ARG6 socklen_t\n+\n+/* Define to 1 if the type pointed by arg 6 for recvfrom is void. */\n+/* #undef RECVFROM_TYPE_ARG6_IS_VOID */\n+\n+/* Define to the function return type for recvfrom. */\n+#define RECVFROM_TYPE_RETV int\n+\n+/* Define to the type of arg 1 for recv. */\n+#define RECV_TYPE_ARG1 int\n+\n+/* Define to the type of arg 2 for recv. */\n+#define RECV_TYPE_ARG2 void *\n+\n+/* Define to the type of arg 3 for recv. */\n+#define RECV_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for recv. */\n+#define RECV_TYPE_ARG4 int\n+\n+/* Define to the function return type for recv. */\n+#define RECV_TYPE_RETV int\n+\n+/* Define as the return type of signal handlers (`int' or `void'). */\n+#define RETSIGTYPE void\n+\n+/* Define to the type qualifier of arg 2 for send. */\n+#define SEND_QUAL_ARG2 const\n+\n+/* Define to the type of arg 1 for send. */\n+#define SEND_TYPE_ARG1 int\n+\n+/* Define to the type of arg 2 for send. */\n+#define SEND_TYPE_ARG2 void *\n+\n+/* Define to the type of arg 3 for send. */\n+#define SEND_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for send. */\n+#define SEND_TYPE_ARG4 int\n+\n+/* Define to the function return type for send. */\n+#define SEND_TYPE_RETV int\n+\n+/* The size of `int', as computed by sizeof. */\n+#define SIZEOF_INT 4\n+\n+/* The size of `long', as computed by sizeof. */\n+#define SIZEOF_LONG 4\n+\n+/* The size of `size_t', as computed by sizeof. */\n+#define SIZEOF_SIZE_T 4\n+\n+/* The size of `struct in6_addr', as computed by sizeof. */\n+#define SIZEOF_STRUCT_IN6_ADDR 16\n+\n+/* The size of `struct in_addr', as computed by sizeof. */\n+#define SIZEOF_STRUCT_IN_ADDR 4\n+\n+/* The size of `time_t', as computed by sizeof. */\n+#define SIZEOF_TIME_T 4\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#define STDC_HEADERS 1\n+\n+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n+#define TIME_WITH_SYS_TIME 1\n+\n+/* Define to disable non-blocking sockets. */\n+/* #undef USE_BLOCKING_SOCKETS */\n+\n+/* Version number of package */\n+#define VERSION \"1.7.1\"\n+\n+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n+   significant byte first (like Motorola and SPARC, unlike Intel). */\n+#if defined AC_APPLE_UNIVERSAL_BUILD\n+# if defined __BIG_ENDIAN__\n+#  define WORDS_BIGENDIAN 1\n+# endif\n+#else\n+# ifndef WORDS_BIGENDIAN\n+/* #  undef WORDS_BIGENDIAN */\n+# endif\n+#endif\n+\n+/* Define to 1 if OS is AIX. */\n+#ifndef _ALL_SOURCE\n+/* #  undef _ALL_SOURCE */\n+#endif\n+\n+/* Number of bits in a file offset, on hosts where this is settable. */\n+/* #undef _FILE_OFFSET_BITS */\n+\n+/* Define for large files, on AIX-style hosts. */\n+/* #undef _LARGE_FILES */\n+\n+/* Define to empty if `const' does not conform to ANSI C. */\n+/* #undef const */\n+\n+/* Type to use in place of in_addr_t when system does not provide it. */\n+/* #undef in_addr_t */\n+\n+/* Define to `unsigned int' if <sys/types.h> does not define. */\n+/* #undef size_t */\n+\n+/* the signed version of size_t */\n+/* #undef ssize_t */"}, {"sha": "836de9f5dde29589a44d996cb7c79db616a3435f", "filename": "src/rt/libuv/src/ares/config_sunos/ares_config.h", "status": "added", "additions": 510, "deletions": 0, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_sunos%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_sunos%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_sunos%2Fares_config.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,510 @@\n+/* ares_config.h.  Generated from ares_config.h.in by configure.  */\n+/* ares_config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define if building universal (internal helper macro) */\n+/* #undef AC_APPLE_UNIVERSAL_BUILD */\n+\n+/* define this if ares is built for a big endian system */\n+/* #undef ARES_BIG_ENDIAN */\n+\n+/* when building as static part of libcurl */\n+/* #undef BUILDING_LIBCURL */\n+\n+/* when building c-ares library */\n+/* #undef CARES_BUILDING_LIBRARY */\n+\n+/* when not building a shared library */\n+/* #undef CARES_STATICLIB */\n+\n+/* Define to 1 to enable hiding of library internal symbols. */\n+/* #undef CARES_SYMBOL_HIDING */\n+\n+/* Definition to make a library symbol externally visible. */\n+/* #undef CARES_SYMBOL_SCOPE_EXTERN */\n+\n+/* if a /etc/inet dir is being used */\n+#define ETC_INET 1\n+\n+/* Define to the type qualifier of arg 1 for getnameinfo. */\n+#define GETNAMEINFO_QUAL_ARG1 const\n+\n+/* Define to the type of arg 1 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG1 struct sockaddr *\n+\n+/* Define to the type of arg 2 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG2 socklen_t\n+\n+/* Define to the type of args 4 and 6 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG46 size_t\n+\n+/* Define to the type of arg 7 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG7 int\n+\n+/* Specifies the number of arguments to getservbyport_r */\n+#define GETSERVBYPORT_R_ARGS 5\n+\n+/* Specifies the size of the buffer to pass to getservbyport_r */\n+#define GETSERVBYPORT_R_BUFSIZE 4096\n+\n+/* Define to 1 if you have AF_INET6. */\n+#define HAVE_AF_INET6 1\n+\n+/* Define to 1 if you have the <arpa/inet.h> header file. */\n+#define HAVE_ARPA_INET_H 1\n+\n+/* Define to 1 if you have the <arpa/nameser_compat.h> header file. */\n+#define HAVE_ARPA_NAMESER_COMPAT_H 1\n+\n+/* Define to 1 if you have the <arpa/nameser.h> header file. */\n+#define HAVE_ARPA_NAMESER_H 1\n+\n+/* Define to 1 if you have the <assert.h> header file. */\n+#define HAVE_ASSERT_H 1\n+\n+/* Define to 1 if you have the `bitncmp' function. */\n+/* #undef HAVE_BITNCMP */\n+\n+/* Define to 1 if bool is an available type. */\n+#define HAVE_BOOL_T 1\n+\n+/* Define to 1 if you have the clock_gettime function and monotonic timer. */\n+#define HAVE_CLOCK_GETTIME_MONOTONIC 1\n+\n+/* Define to 1 if you have the closesocket function. */\n+/* #undef HAVE_CLOSESOCKET */\n+\n+/* Define to 1 if you have the CloseSocket camel case function. */\n+/* #undef HAVE_CLOSESOCKET_CAMEL */\n+\n+/* Define to 1 if you have the connect function. */\n+#define HAVE_CONNECT 1\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#define HAVE_DLFCN_H 1\n+\n+/* Define to 1 if you have the <errno.h> header file. */\n+#define HAVE_ERRNO_H 1\n+\n+/* Define to 1 if you have the fcntl function. */\n+#define HAVE_FCNTL 1\n+\n+/* Define to 1 if you have the <fcntl.h> header file. */\n+#define HAVE_FCNTL_H 1\n+\n+/* Define to 1 if you have a working fcntl O_NONBLOCK function. */\n+#define HAVE_FCNTL_O_NONBLOCK 1\n+\n+/* Define to 1 if you have the freeaddrinfo function. */\n+#define HAVE_FREEADDRINFO 1\n+\n+/* Define to 1 if you have a working getaddrinfo function. */\n+#define HAVE_GETADDRINFO 1\n+\n+/* Define to 1 if the getaddrinfo function is threadsafe. */\n+#define HAVE_GETADDRINFO_THREADSAFE 1\n+\n+/* Define to 1 if you have the gethostbyaddr function. */\n+#define HAVE_GETHOSTBYADDR 1\n+\n+/* Define to 1 if you have the gethostbyname function. */\n+#define HAVE_GETHOSTBYNAME 1\n+\n+/* Define to 1 if you have the gethostname function. */\n+#define HAVE_GETHOSTNAME 1\n+\n+/* Define to 1 if you have the getnameinfo function. */\n+#define HAVE_GETNAMEINFO 1\n+\n+/* Define to 1 if you have the getservbyport_r function. */\n+#define HAVE_GETSERVBYPORT_R 1\n+\n+/* Define to 1 if you have the `gettimeofday' function. */\n+#define HAVE_GETTIMEOFDAY 1\n+\n+/* Define to 1 if you have the `if_indextoname' function. */\n+#define HAVE_IF_INDEXTONAME 1\n+\n+/* Define to 1 if you have the `inet_net_pton' function. */\n+/* #undef HAVE_INET_NET_PTON */\n+\n+/* Define to 1 if inet_net_pton supports IPv6. */\n+/* #undef HAVE_INET_NET_PTON_IPV6 */\n+\n+/* Define to 1 if you have a IPv6 capable working inet_ntop function. */\n+#define HAVE_INET_NTOP 1\n+\n+/* Define to 1 if you have a IPv6 capable working inet_pton function. */\n+#define HAVE_INET_PTON 1\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#define HAVE_INTTYPES_H 1\n+\n+/* Define to 1 if you have the ioctl function. */\n+#define HAVE_IOCTL 1\n+\n+/* Define to 1 if you have the ioctlsocket function. */\n+/* #undef HAVE_IOCTLSOCKET */\n+\n+/* Define to 1 if you have the IoctlSocket camel case function. */\n+/* #undef HAVE_IOCTLSOCKET_CAMEL */\n+\n+/* Define to 1 if you have a working IoctlSocket camel case FIONBIO function.\n+   */\n+/* #undef HAVE_IOCTLSOCKET_CAMEL_FIONBIO */\n+\n+/* Define to 1 if you have a working ioctlsocket FIONBIO function. */\n+/* #undef HAVE_IOCTLSOCKET_FIONBIO */\n+\n+/* Define to 1 if you have a working ioctl FIONBIO function. */\n+/* #undef HAVE_IOCTL_FIONBIO */\n+\n+/* Define to 1 if you have a working ioctl SIOCGIFADDR function. */\n+/* #undef HAVE_IOCTL_SIOCGIFADDR */\n+\n+/* Define to 1 if you have the `resolve' library (-lresolve). */\n+/* #undef HAVE_LIBRESOLVE */\n+\n+/* Define to 1 if you have the <limits.h> header file. */\n+#define HAVE_LIMITS_H 1\n+\n+/* if your compiler supports LL */\n+#define HAVE_LL 1\n+\n+/* Define to 1 if the compiler supports the 'long long' data type. */\n+#define HAVE_LONGLONG 1\n+\n+/* Define to 1 if you have the malloc.h header file. */\n+#define HAVE_MALLOC_H 1\n+\n+/* Define to 1 if you have the memory.h header file. */\n+#define HAVE_MEMORY_H 1\n+\n+/* Define to 1 if you have the MSG_NOSIGNAL flag. */\n+/* #undef HAVE_MSG_NOSIGNAL */\n+\n+/* Define to 1 if you have the <netdb.h> header file. */\n+#define HAVE_NETDB_H 1\n+\n+/* Define to 1 if you have the <netinet/in.h> header file. */\n+#define HAVE_NETINET_IN_H 1\n+\n+/* Define to 1 if you have the <netinet/tcp.h> header file. */\n+#define HAVE_NETINET_TCP_H 1\n+\n+/* Define to 1 if you have the <net/if.h> header file. */\n+#define HAVE_NET_IF_H 1\n+\n+/* Define to 1 if you have PF_INET6. */\n+#define HAVE_PF_INET6 1\n+\n+/* Define to 1 if you have the recv function. */\n+#define HAVE_RECV 1\n+\n+/* Define to 1 if you have the recvfrom function. */\n+#define HAVE_RECVFROM 1\n+\n+/* Define to 1 if you have the send function. */\n+#define HAVE_SEND 1\n+\n+/* Define to 1 if you have the setsockopt function. */\n+#define HAVE_SETSOCKOPT 1\n+\n+/* Define to 1 if you have a working setsockopt SO_NONBLOCK function. */\n+/* #undef HAVE_SETSOCKOPT_SO_NONBLOCK */\n+\n+/* Define to 1 if you have the <signal.h> header file. */\n+#define HAVE_SIGNAL_H 1\n+\n+/* Define to 1 if sig_atomic_t is an available typedef. */\n+#define HAVE_SIG_ATOMIC_T 1\n+\n+/* Define to 1 if sig_atomic_t is already defined as volatile. */\n+/* #undef HAVE_SIG_ATOMIC_T_VOLATILE */\n+\n+/* Define to 1 if your struct sockaddr_in6 has sin6_scope_id. */\n+#define HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID 1\n+\n+/* Define to 1 if you have the socket function. */\n+#define HAVE_SOCKET 1\n+\n+/* Define to 1 if you have the <socket.h> header file. */\n+/* #undef HAVE_SOCKET_H */\n+\n+/* Define to 1 if you have the <stdbool.h> header file. */\n+#define HAVE_STDBOOL_H 1\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#define HAVE_STDINT_H 1\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#define HAVE_STDLIB_H 1\n+\n+/* Define to 1 if you have the strcasecmp function. */\n+#define HAVE_STRCASECMP 1\n+\n+/* Define to 1 if you have the strcmpi function. */\n+/* #undef HAVE_STRCMPI */\n+\n+/* Define to 1 if you have the strdup function. */\n+#define HAVE_STRDUP 1\n+\n+/* Define to 1 if you have the stricmp function. */\n+/* #undef HAVE_STRICMP */\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#define HAVE_STRINGS_H 1\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#define HAVE_STRING_H 1\n+\n+/* Define to 1 if you have the strncasecmp function. */\n+#define HAVE_STRNCASECMP 1\n+\n+/* Define to 1 if you have the strncmpi function. */\n+/* #undef HAVE_STRNCMPI */\n+\n+/* Define to 1 if you have the strnicmp function. */\n+/* #undef HAVE_STRNICMP */\n+\n+/* Define to 1 if you have the <stropts.h> header file. */\n+#define HAVE_STROPTS_H 1\n+\n+/* Define to 1 if you have struct addrinfo. */\n+#define HAVE_STRUCT_ADDRINFO 1\n+\n+/* Define to 1 if you have struct in6_addr. */\n+#define HAVE_STRUCT_IN6_ADDR 1\n+\n+/* Define to 1 if you have struct sockaddr_in6. */\n+#define HAVE_STRUCT_SOCKADDR_IN6 1\n+\n+/* if struct sockaddr_storage is defined */\n+#define HAVE_STRUCT_SOCKADDR_STORAGE 1\n+\n+/* Define to 1 if you have the timeval struct. */\n+#define HAVE_STRUCT_TIMEVAL 1\n+\n+/* Define to 1 if you have the <sys/ioctl.h> header file. */\n+#define HAVE_SYS_IOCTL_H 1\n+\n+/* Define to 1 if you have the <sys/param.h> header file. */\n+#define HAVE_SYS_PARAM_H 1\n+\n+/* Define to 1 if you have the <sys/select.h> header file. */\n+#define HAVE_SYS_SELECT_H 1\n+\n+/* Define to 1 if you have the <sys/socket.h> header file. */\n+#define HAVE_SYS_SOCKET_H 1\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#define HAVE_SYS_STAT_H 1\n+\n+/* Define to 1 if you have the <sys/time.h> header file. */\n+#define HAVE_SYS_TIME_H 1\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#define HAVE_SYS_TYPES_H 1\n+\n+/* Define to 1 if you have the <sys/uio.h> header file. */\n+#define HAVE_SYS_UIO_H 1\n+\n+/* Define to 1 if you have the <time.h> header file. */\n+#define HAVE_TIME_H 1\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#define HAVE_UNISTD_H 1\n+\n+/* Define to 1 if you have the windows.h header file. */\n+/* #undef HAVE_WINDOWS_H */\n+\n+/* Define to 1 if you have the winsock2.h header file. */\n+/* #undef HAVE_WINSOCK2_H */\n+\n+/* Define to 1 if you have the winsock.h header file. */\n+/* #undef HAVE_WINSOCK_H */\n+\n+/* Define to 1 if you have the writev function. */\n+#define HAVE_WRITEV 1\n+\n+/* Define to 1 if you have the ws2tcpip.h header file. */\n+/* #undef HAVE_WS2TCPIP_H */\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#define LT_OBJDIR \".libs/\"\n+\n+/* Define to 1 if you are building a native Windows target. */\n+/* #undef NATIVE_WINDOWS */\n+\n+/* Define to 1 if you need the malloc.h header file even with stdlib.h */\n+/* #undef NEED_MALLOC_H */\n+\n+/* Define to 1 if you need the memory.h header file even with stdlib.h */\n+/* #undef NEED_MEMORY_H */\n+\n+/* Define to 1 if _REENTRANT preprocessor symbol must be defined. */\n+#define NEED_REENTRANT 1\n+\n+/* Define to 1 if _THREAD_SAFE preprocessor symbol must be defined. */\n+/* #undef NEED_THREAD_SAFE */\n+\n+/* Define to 1 if your C compiler doesn't accept -c and -o together. */\n+/* #undef NO_MINUS_C_MINUS_O */\n+\n+/* cpu-machine-OS */\n+#define OS \"i386-pc-solaris2.11\"\n+\n+/* Name of package */\n+#define PACKAGE \"c-ares\"\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#define PACKAGE_BUGREPORT \"c-ares mailing list => http://cool.haxx.se/mailman/listinfo/c-ares\"\n+\n+/* Define to the full name of this package. */\n+#define PACKAGE_NAME \"c-ares\"\n+\n+/* Define to the full name and version of this package. */\n+#define PACKAGE_STRING \"c-ares 1.7.1\"\n+\n+/* Define to the one symbol short name of this package. */\n+#define PACKAGE_TARNAME \"c-ares\"\n+\n+/* Define to the home page for this package. */\n+#define PACKAGE_URL \"\"\n+\n+/* Define to the version of this package. */\n+#define PACKAGE_VERSION \"1.7.1\"\n+\n+/* a suitable file/device to read random data from */\n+#define RANDOM_FILE \"/dev/urandom\"\n+\n+/* Define to the type of arg 1 for recvfrom. */\n+#define RECVFROM_TYPE_ARG1 int\n+\n+/* Define to the type pointed by arg 2 for recvfrom. */\n+#define RECVFROM_TYPE_ARG2 void\n+\n+/* Define to 1 if the type pointed by arg 2 for recvfrom is void. */\n+#define RECVFROM_TYPE_ARG2_IS_VOID 1\n+\n+/* Define to the type of arg 3 for recvfrom. */\n+#define RECVFROM_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for recvfrom. */\n+#define RECVFROM_TYPE_ARG4 int\n+\n+/* Define to the type pointed by arg 5 for recvfrom. */\n+#define RECVFROM_TYPE_ARG5 struct sockaddr\n+\n+/* Define to 1 if the type pointed by arg 5 for recvfrom is void. */\n+/* #undef RECVFROM_TYPE_ARG5_IS_VOID */\n+\n+/* Define to the type pointed by arg 6 for recvfrom. */\n+#define RECVFROM_TYPE_ARG6 void\n+\n+/* Define to 1 if the type pointed by arg 6 for recvfrom is void. */\n+#define RECVFROM_TYPE_ARG6_IS_VOID 1\n+\n+/* Define to the function return type for recvfrom. */\n+#define RECVFROM_TYPE_RETV int\n+\n+/* Define to the type of arg 1 for recv. */\n+#define RECV_TYPE_ARG1 int\n+\n+/* Define to the type of arg 2 for recv. */\n+#define RECV_TYPE_ARG2 void *\n+\n+/* Define to the type of arg 3 for recv. */\n+#define RECV_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for recv. */\n+#define RECV_TYPE_ARG4 int\n+\n+/* Define to the function return type for recv. */\n+#define RECV_TYPE_RETV int\n+\n+/* Define as the return type of signal handlers (`int' or `void'). */\n+#define RETSIGTYPE void\n+\n+/* Define to the type qualifier of arg 2 for send. */\n+#define SEND_QUAL_ARG2 const\n+\n+/* Define to the type of arg 1 for send. */\n+#define SEND_TYPE_ARG1 int\n+\n+/* Define to the type of arg 2 for send. */\n+#define SEND_TYPE_ARG2 void *\n+\n+/* Define to the type of arg 3 for send. */\n+#define SEND_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for send. */\n+#define SEND_TYPE_ARG4 int\n+\n+/* Define to the function return type for send. */\n+#define SEND_TYPE_RETV int\n+\n+/* The size of `int', as computed by sizeof. */\n+#define SIZEOF_INT 4\n+\n+/* The size of `long', as computed by sizeof. */\n+#define SIZEOF_LONG 4\n+\n+/* The size of `size_t', as computed by sizeof. */\n+#define SIZEOF_SIZE_T 4\n+\n+/* The size of `struct in6_addr', as computed by sizeof. */\n+#define SIZEOF_STRUCT_IN6_ADDR 16\n+\n+/* The size of `struct in_addr', as computed by sizeof. */\n+#define SIZEOF_STRUCT_IN_ADDR 4\n+\n+/* The size of `time_t', as computed by sizeof. */\n+#define SIZEOF_TIME_T 4\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#define STDC_HEADERS 1\n+\n+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n+#define TIME_WITH_SYS_TIME 1\n+\n+/* Define to disable non-blocking sockets. */\n+/* #undef USE_BLOCKING_SOCKETS */\n+\n+/* Version number of package */\n+#define VERSION \"1.7.1\"\n+\n+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n+   significant byte first (like Motorola and SPARC, unlike Intel). */\n+#if defined AC_APPLE_UNIVERSAL_BUILD\n+# if defined __BIG_ENDIAN__\n+#  define WORDS_BIGENDIAN 1\n+# endif\n+#else\n+# ifndef WORDS_BIGENDIAN\n+/* #  undef WORDS_BIGENDIAN */\n+# endif\n+#endif\n+\n+/* Define to 1 if OS is AIX. */\n+#ifndef _ALL_SOURCE\n+/* #  undef _ALL_SOURCE */\n+#endif\n+\n+/* Number of bits in a file offset, on hosts where this is settable. */\n+#define _FILE_OFFSET_BITS 64\n+\n+/* Define for large files, on AIX-style hosts. */\n+/* #undef _LARGE_FILES */\n+\n+/* Define to empty if `const' does not conform to ANSI C. */\n+/* #undef const */\n+\n+/* Type to use in place of in_addr_t when system does not provide it. */\n+/* #undef in_addr_t */\n+\n+/* Define to `unsigned int' if <sys/types.h> does not define. */\n+/* #undef size_t */\n+\n+/* the signed version of size_t */\n+/* #undef ssize_t */"}, {"sha": "a269da2b81463dc65a668b869a58aa67224bfd21", "filename": "src/rt/libuv/src/ares/config_win32/ares_config.h", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_win32%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_win32%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_win32%2Fares_config.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,369 @@\n+#ifndef __ARES_CONFIG_WIN32_H\n+#define __ARES_CONFIG_WIN32_H\n+\n+/* when building c-ares library */\n+#define CARES_BUILDING_LIBRARY 1\n+\n+/* when not building a shared library */\n+#define CARES_STATICLIB 1\n+\n+/* Copyright (C) 2004 - 2008 by Daniel Stenberg et al\n+ *\n+ * Permission to use, copy, modify, and distribute this software and its\n+ * documentation for any purpose and without fee is hereby granted, provided\n+ * that the above copyright notice appear in all copies and that both that\n+ * copyright notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in advertising or\n+ * publicity pertaining to distribution of the software without specific,\n+ * written prior permission.  M.I.T. makes no representations about the\n+ * suitability of this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#define ARES_\n+\n+/* ================================================================ */\n+/*    ares/config-win32.h - Hand crafted config file for Windows    */\n+/* ================================================================ */\n+\n+/* ---------------------------------------------------------------- */\n+/*                          HEADER FILES                            */\n+/* ---------------------------------------------------------------- */\n+\n+/* Define if you have the <getopt.h> header file.  */\n+#if defined(__MINGW32__) || defined(__POCC__)\n+#define HAVE_GETOPT_H 1\n+#endif\n+\n+/* Define if you have the <limits.h> header file.  */\n+#define HAVE_LIMITS_H 1\n+\n+/* Define if you have the <process.h> header file.  */\n+#ifndef __SALFORDC__\n+#define HAVE_PROCESS_H 1\n+#endif\n+\n+/* Define if you have the <signal.h> header file. */\n+#define HAVE_SIGNAL_H 1\n+\n+/* Define if you have the <sys/time.h> header file */\n+#if defined(__MINGW32__)\n+#define HAVE_SYS_TIME_H 1\n+#endif\n+\n+/* Define if you have the <time.h> header file.  */\n+#define HAVE_TIME_H 1\n+\n+/* Define if you have the <unistd.h> header file.  */\n+#if defined(__MINGW32__) || defined(__WATCOMC__) || defined(__LCC__) || \\\n+    defined(__POCC__)\n+#define HAVE_UNISTD_H 1\n+#endif\n+\n+/* Define if you have the windows.h header file. */\n+#define HAVE_WINDOWS_H 1\n+\n+/* Define if you have the <winsock.h> header file.  */\n+#define HAVE_WINSOCK_H 1\n+\n+/* Define if you have the <winsock2.h> header file.  */\n+#ifndef __SALFORDC__\n+#define HAVE_WINSOCK2_H 1\n+#endif\n+\n+/* Define if you have the <ws2tcpip.h> header file.  */\n+#ifndef __SALFORDC__\n+#define HAVE_WS2TCPIP_H 1\n+#endif\n+\n+/* ---------------------------------------------------------------- */\n+/*                        OTHER HEADER INFO                         */\n+/* ---------------------------------------------------------------- */\n+\n+/* Define if sig_atomic_t is an available typedef. */\n+#define HAVE_SIG_ATOMIC_T 1\n+\n+/* Define if you have the ANSI C header files.  */\n+#define STDC_HEADERS 1\n+\n+/* Define if you can safely include both <sys/time.h> and <time.h>.  */\n+/* #define TIME_WITH_SYS_TIME 1 */\n+\n+/* ---------------------------------------------------------------- */\n+/*                             FUNCTIONS                            */\n+/* ---------------------------------------------------------------- */\n+\n+/* Define if you have the closesocket function.  */\n+#define HAVE_CLOSESOCKET 1\n+\n+/* Define if you have the gethostname function.  */\n+#define HAVE_GETHOSTNAME 1\n+\n+/* Define if you have the ioctlsocket function. */\n+#define HAVE_IOCTLSOCKET 1\n+\n+/* Define if you have a working ioctlsocket FIONBIO function. */\n+#define HAVE_IOCTLSOCKET_FIONBIO 1\n+\n+/* Define if you have the strcasecmp function. */\n+/* #define HAVE_STRCASECMP 1 */\n+\n+/* Define if you have the strdup function. */\n+#define HAVE_STRDUP 1\n+\n+/* Define if you have the stricmp function. */\n+#define HAVE_STRICMP 1\n+\n+/* Define if you have the strncasecmp function. */\n+/* #define HAVE_STRNCASECMP 1 */\n+\n+/* Define if you have the strnicmp function. */\n+#define HAVE_STRNICMP 1\n+\n+/* Define if you have the recv function. */\n+#define HAVE_RECV 1\n+\n+/* Define to the type of arg 1 for recv. */\n+#define RECV_TYPE_ARG1 SOCKET\n+\n+/* Define to the type of arg 2 for recv. */\n+#define RECV_TYPE_ARG2 char *\n+\n+/* Define to the type of arg 3 for recv. */\n+#define RECV_TYPE_ARG3 int\n+\n+/* Define to the type of arg 4 for recv. */\n+#define RECV_TYPE_ARG4 int\n+\n+/* Define to the function return type for recv. */\n+#define RECV_TYPE_RETV int\n+\n+/* Define if you have the recvfrom function. */\n+#define HAVE_RECVFROM 1\n+\n+/* Define to the type of arg 1 for recvfrom. */\n+#define RECVFROM_TYPE_ARG1 SOCKET\n+\n+/* Define to the type pointed by arg 2 for recvfrom. */\n+#define RECVFROM_TYPE_ARG2 char\n+\n+/* Define to the type of arg 3 for recvfrom. */\n+#define RECVFROM_TYPE_ARG3 int\n+\n+/* Define to the type of arg 4 for recvfrom. */\n+#define RECVFROM_TYPE_ARG4 int\n+\n+/* Define to the type pointed by arg 5 for recvfrom. */\n+#define RECVFROM_TYPE_ARG5 struct sockaddr\n+\n+/* Define to the type pointed by arg 6 for recvfrom. */\n+#define RECVFROM_TYPE_ARG6 int\n+\n+/* Define to the function return type for recvfrom. */\n+#define RECVFROM_TYPE_RETV int\n+\n+/* Define if you have the send function. */\n+#define HAVE_SEND 1\n+\n+/* Define to the type of arg 1 for send. */\n+#define SEND_TYPE_ARG1 SOCKET\n+\n+/* Define to the type qualifier of arg 2 for send. */\n+#define SEND_QUAL_ARG2 const\n+\n+/* Define to the type of arg 2 for send. */\n+#define SEND_TYPE_ARG2 char *\n+\n+/* Define to the type of arg 3 for send. */\n+#define SEND_TYPE_ARG3 int\n+\n+/* Define to the type of arg 4 for send. */\n+#define SEND_TYPE_ARG4 int\n+\n+/* Define to the function return type for send. */\n+#define SEND_TYPE_RETV int\n+\n+/* Specifics for the Watt-32 tcp/ip stack */\n+#ifdef WATT32\n+  #define SOCKET              int\n+  #define NS_INADDRSZ         4\n+  #define HAVE_ARPA_NAMESER_H 1\n+  #define HAVE_ARPA_INET_H    1\n+  #define HAVE_NETDB_H        1\n+  #define HAVE_NETINET_IN_H   1\n+  #define HAVE_SYS_SOCKET_H   1\n+  #define HAVE_NETINET_TCP_H  1\n+  #define HAVE_AF_INET6       1\n+  #define HAVE_PF_INET6       1\n+  #define HAVE_STRUCT_IN6_ADDR     1\n+  #define HAVE_STRUCT_SOCKADDR_IN6 1\n+  #undef HAVE_WINSOCK_H\n+  #undef HAVE_WINSOCK2_H\n+  #undef HAVE_WS2TCPIP_H\n+#endif\n+\n+/* ---------------------------------------------------------------- */\n+/*                       TYPEDEF REPLACEMENTS                       */\n+/* ---------------------------------------------------------------- */\n+\n+/* Define this if in_addr_t is not an available 'typedefed' type */\n+#define in_addr_t unsigned long\n+\n+/* Define as the return type of signal handlers (int or void).  */\n+#define RETSIGTYPE void\n+\n+/* Define ssize_t if it is not an available 'typedefed' type */\n+#ifndef _SSIZE_T_DEFINED\n+#  if (defined(__WATCOMC__) && (__WATCOMC__ >= 1240)) || \\\n+      defined(__POCC__) || \\\n+      defined(__MINGW32__)\n+#  elif defined(_WIN64)\n+#    define _SSIZE_T_DEFINED\n+#    define ssize_t __int64\n+#  else\n+#    define _SSIZE_T_DEFINED\n+#    define ssize_t int\n+#  endif\n+#endif\n+\n+/* ---------------------------------------------------------------- */\n+/*                            TYPE SIZES                            */\n+/* ---------------------------------------------------------------- */\n+\n+/* The size of `int', as computed by sizeof. */\n+#define SIZEOF_INT 4\n+\n+/* The size of `short', as computed by sizeof. */\n+#define SIZEOF_SHORT 2\n+\n+/* The size of `size_t', as computed by sizeof. */\n+#if defined(_WIN64)\n+#  define SIZEOF_SIZE_T 8\n+#else\n+#  define SIZEOF_SIZE_T 4\n+#endif\n+\n+/* ---------------------------------------------------------------- */\n+/*                          STRUCT RELATED                          */\n+/* ---------------------------------------------------------------- */\n+\n+/* Define this if you have struct addrinfo */\n+#define HAVE_STRUCT_ADDRINFO 1\n+\n+/* Define this if you have struct sockaddr_storage */\n+#ifndef __SALFORDC__\n+#define HAVE_STRUCT_SOCKADDR_STORAGE 1\n+#endif\n+\n+/* Define this if you have struct timeval */\n+#define HAVE_STRUCT_TIMEVAL 1\n+\n+/* ---------------------------------------------------------------- */\n+/*                        COMPILER SPECIFIC                         */\n+/* ---------------------------------------------------------------- */\n+\n+/* Define to avoid VS2005 complaining about portable C functions */\n+#if defined(_MSC_VER) && (_MSC_VER >= 1400)\n+#define _CRT_SECURE_NO_DEPRECATE 1\n+#define _CRT_NONSTDC_NO_DEPRECATE 1\n+#endif\n+\n+/* Officially, Microsoft's Windows SDK versions 6.X do not support Windows\n+   2000 as a supported build target. VS2008 default installations provide an\n+   embedded Windows SDK v6.0A along with the claim that Windows 2000 is a\n+   valid build target for VS2008. Popular belief is that binaries built using\n+   Windows SDK versions 6.X and Windows 2000 as a build target are functional */\n+#if defined(_MSC_VER) && (_MSC_VER >= 1500)\n+#  define VS2008_MINIMUM_TARGET 0x0500\n+#endif\n+\n+/* When no build target is specified VS2008 default build target is Windows\n+   Vista, which leaves out even Winsows XP. If no build target has been given\n+   for VS2008 we will target the minimum Officially supported build target,\n+   which happens to be Windows XP. */\n+#if defined(_MSC_VER) && (_MSC_VER >= 1500)\n+#  define VS2008_DEFAULT_TARGET  0x0501\n+#endif\n+\n+/* VS2008 default target settings and minimum build target check */\n+#if defined(_MSC_VER) && (_MSC_VER >= 1500)\n+#  ifndef _WIN32_WINNT\n+#    define _WIN32_WINNT VS2008_DEFAULT_TARGET\n+#  endif\n+#  ifndef WINVER\n+#    define WINVER VS2008_DEFAULT_TARGET\n+#  endif\n+#  if (_WIN32_WINNT < VS2008_MINIMUM_TARGET) || (WINVER < VS2008_MINIMUM_TARGET)\n+#    error VS2008 does not support Windows build targets prior to Windows 2000\n+#  endif\n+#endif\n+\n+/* When no build target is specified Pelles C 5.00 and later default build\n+   target is Windows Vista. We override default target to be Windows 2000. */\n+#if defined(__POCC__) && (__POCC__ >= 500)\n+#  ifndef _WIN32_WINNT\n+#    define _WIN32_WINNT 0x0500\n+#  endif\n+#  ifndef WINVER\n+#    define WINVER 0x0500\n+#  endif\n+#endif\n+\n+/* Availability of freeaddrinfo, getaddrinfo and getnameinfo functions is\n+   quite convoluted, compiler dependent and even build target dependent. */\n+#if defined(HAVE_WS2TCPIP_H)\n+#  if defined(__POCC__)\n+#    define HAVE_FREEADDRINFO 1\n+#    define HAVE_GETADDRINFO  1\n+#    define HAVE_GETNAMEINFO  1\n+#  elif defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0501)\n+#    define HAVE_FREEADDRINFO 1\n+#    define HAVE_GETADDRINFO  1\n+#    define HAVE_GETNAMEINFO  1\n+#  elif defined(_MSC_VER) && (_MSC_VER >= 1200)\n+#    define HAVE_FREEADDRINFO 1\n+#    define HAVE_GETADDRINFO  1\n+#    define HAVE_GETNAMEINFO  1\n+#  endif\n+#endif\n+\n+#if defined(__POCC__)\n+#  ifndef _MSC_VER\n+#    error Microsoft extensions /Ze compiler option is required\n+#  endif\n+#  ifndef __POCC__OLDNAMES\n+#    error Compatibility names /Go compiler option is required\n+#  endif\n+#endif\n+\n+/* ---------------------------------------------------------------- */\n+/*                         IPV6 COMPATIBILITY                       */\n+/* ---------------------------------------------------------------- */\n+\n+/* Define this if you have address family AF_INET6 */\n+#ifdef HAVE_WINSOCK2_H\n+#define HAVE_AF_INET6 1\n+#endif\n+\n+/* Define this if you have protocol family PF_INET6 */\n+#ifdef HAVE_WINSOCK2_H\n+#define HAVE_PF_INET6 1\n+#endif\n+\n+/* Define this if you have struct in6_addr */\n+#ifdef HAVE_WS2TCPIP_H\n+#define HAVE_STRUCT_IN6_ADDR 1\n+#endif\n+\n+/* Define this if you have struct sockaddr_in6 */\n+#ifdef HAVE_WS2TCPIP_H\n+#define HAVE_STRUCT_SOCKADDR_IN6 1\n+#endif\n+\n+/* Define this if you have sockaddr_in6 with scopeid */\n+#ifdef HAVE_WS2TCPIP_H\n+#define HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID 1\n+#endif\n+\n+\n+#endif  /* __ARES_CONFIG_WIN32_H */"}, {"sha": "a63c729a9dc5c920f129fc61b3f81e30356e6d14", "filename": "src/rt/libuv/src/ares/get_ver.awk", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fget_ver.awk", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fget_ver.awk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fget_ver.awk?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,35 @@\n+# ***************************************************************************\n+# *  Project: c-ares\n+# *\n+# ***************************************************************************\n+# awk script which fetches c-ares version number and string from input\n+# file and writes them to STDOUT. Here you can get an awk version for Win32:\n+# http://www.gknw.net/development/prgtools/awk-20070501.zip\n+#\n+BEGIN {\n+  if (match (ARGV[1], /ares_version.h/)) {\n+    while ((getline < ARGV[1]) > 0) {\n+      if (match ($0, /^#define ARES_COPYRIGHT \"[^\"]+\"$/)) {\n+        libcares_copyright_str = substr($0, 25, length($0)-25);\n+      }\n+      else if (match ($0, /^#define ARES_VERSION_STR \"[^\"]+\"$/)) {\n+        libcares_ver_str = substr($3, 2, length($3)-2);\n+      }\n+      else if (match ($0, /^#define ARES_VERSION_MAJOR [0-9]+$/)) {\n+        libcares_ver_major = substr($3, 1, length($3));\n+      }\n+      else if (match ($0, /^#define ARES_VERSION_MINOR [0-9]+$/)) {\n+        libcares_ver_minor = substr($3, 1, length($3));\n+      }\n+      else if (match ($0, /^#define ARES_VERSION_PATCH [0-9]+$/)) {\n+        libcares_ver_patch = substr($3, 1, length($3));\n+      }\n+    }\n+    libcares_ver = libcares_ver_major \",\" libcares_ver_minor \",\" libcares_ver_patch;\n+    print \"LIBCARES_VERSION = \" libcares_ver \"\";\n+    print \"LIBCARES_VERSION_STR = \" libcares_ver_str \"\";\n+    print \"LIBCARES_COPYRIGHT_STR = \" libcares_copyright_str \"\";\n+  }\n+}\n+\n+"}, {"sha": "0b2accf19777217dbcda96ad75d3fd43d2cca74d", "filename": "src/rt/libuv/src/ares/inet_net_pton.c", "status": "added", "additions": 450, "deletions": 0, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_net_pton.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_net_pton.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_net_pton.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,450 @@\n+\n+/*\n+ * Copyright (c) 2004 by Internet Systems Consortium, Inc. (\"ISC\")\n+ * Copyright (c) 1996,1999 by Internet Software Consortium.\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND ISC DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT\n+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_ARPA_INET_H\n+#  include <arpa/inet.h>\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n+#  include <arpa/nameser_compat.h>\n+#endif\n+\n+#include <ctype.h>\n+#include <errno.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#include \"ares.h\"\n+#include \"ares_ipv6.h\"\n+#include \"inet_net_pton.h\"\n+\n+\n+const struct ares_in6_addr ares_in6addr_any = { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } };\n+\n+\n+#if !defined(HAVE_INET_NET_PTON) || !defined(HAVE_INET_NET_PTON_IPV6)\n+\n+/*\n+ * static int\n+ * inet_net_pton_ipv4(src, dst, size)\n+ *      convert IPv4 network number from presentation to network format.\n+ *      accepts hex octets, hex strings, decimal octets, and /CIDR.\n+ *      \"size\" is in bytes and describes \"dst\".\n+ * return:\n+ *      number of bits, either imputed classfully or specified with /CIDR,\n+ *      or -1 if some failure occurred (check errno).  ENOENT means it was\n+ *      not an IPv4 network specification.\n+ * note:\n+ *      network byte order assumed.  this means 192.5.5.240/28 has\n+ *      0b11110000 in its fourth octet.\n+ * note:\n+ *      On Windows we store the error in the thread errno, not\n+ *      in the winsock error code. This is to avoid loosing the\n+ *      actual last winsock error. So use macro ERRNO to fetch the\n+ *      errno this funtion sets when returning (-1), not SOCKERRNO.\n+ * author:\n+ *      Paul Vixie (ISC), June 1996\n+ */\n+static int\n+inet_net_pton_ipv4(const char *src, unsigned char *dst, size_t size)\n+{\n+  static const char xdigits[] = \"0123456789abcdef\";\n+  static const char digits[] = \"0123456789\";\n+  int n, ch, tmp = 0, dirty, bits;\n+  const unsigned char *odst = dst;\n+\n+  ch = *src++;\n+  if (ch == '0' && (src[0] == 'x' || src[0] == 'X')\n+      && ISXDIGIT(src[1])) {\n+    /* Hexadecimal: Eat nybble string. */\n+    if (!size)\n+      goto emsgsize;\n+    dirty = 0;\n+    src++;  /* skip x or X. */\n+    while ((ch = *src++) != '\\0' && ISXDIGIT(ch)) {\n+      if (ISUPPER(ch))\n+        ch = tolower(ch);\n+      n = (int)(strchr(xdigits, ch) - xdigits);\n+      if (dirty == 0)\n+        tmp = n;\n+      else\n+        tmp = (tmp << 4) | n;\n+      if (++dirty == 2) {\n+        if (!size--)\n+          goto emsgsize;\n+        *dst++ = (unsigned char) tmp;\n+        dirty = 0;\n+      }\n+    }\n+    if (dirty) {  /* Odd trailing nybble? */\n+      if (!size--)\n+        goto emsgsize;\n+      *dst++ = (unsigned char) (tmp << 4);\n+    }\n+  } else if (ISDIGIT(ch)) {\n+    /* Decimal: eat dotted digit string. */\n+    for (;;) {\n+      tmp = 0;\n+      do {\n+        n = (int)(strchr(digits, ch) - digits);\n+        tmp *= 10;\n+        tmp += n;\n+        if (tmp > 255)\n+          goto enoent;\n+      } while ((ch = *src++) != '\\0' &&\n+               ISDIGIT(ch));\n+      if (!size--)\n+        goto emsgsize;\n+      *dst++ = (unsigned char) tmp;\n+      if (ch == '\\0' || ch == '/')\n+        break;\n+      if (ch != '.')\n+        goto enoent;\n+      ch = *src++;\n+      if (!ISDIGIT(ch))\n+        goto enoent;\n+    }\n+  } else\n+    goto enoent;\n+\n+  bits = -1;\n+  if (ch == '/' &&\n+      ISDIGIT(src[0]) && dst > odst) {\n+    /* CIDR width specifier.  Nothing can follow it. */\n+    ch = *src++;    /* Skip over the /. */\n+    bits = 0;\n+    do {\n+      n = (int)(strchr(digits, ch) - digits);\n+      bits *= 10;\n+      bits += n;\n+    } while ((ch = *src++) != '\\0' && ISDIGIT(ch));\n+    if (ch != '\\0')\n+      goto enoent;\n+    if (bits > 32)\n+      goto emsgsize;\n+  }\n+\n+  /* Firey death and destruction unless we prefetched EOS. */\n+  if (ch != '\\0')\n+    goto enoent;\n+\n+  /* If nothing was written to the destination, we found no address. */\n+  if (dst == odst)\n+    goto enoent;\n+  /* If no CIDR spec was given, infer width from net class. */\n+  if (bits == -1) {\n+    if (*odst >= 240)       /* Class E */\n+      bits = 32;\n+    else if (*odst >= 224)  /* Class D */\n+      bits = 8;\n+    else if (*odst >= 192)  /* Class C */\n+      bits = 24;\n+    else if (*odst >= 128)  /* Class B */\n+      bits = 16;\n+    else                    /* Class A */\n+      bits = 8;\n+    /* If imputed mask is narrower than specified octets, widen. */\n+    if (bits < ((dst - odst) * 8))\n+      bits = (int)(dst - odst) * 8;\n+    /*\n+     * If there are no additional bits specified for a class D\n+     * address adjust bits to 4.\n+     */\n+    if (bits == 8 && *odst == 224)\n+      bits = 4;\n+  }\n+  /* Extend network to cover the actual mask. */\n+  while (bits > ((dst - odst) * 8)) {\n+    if (!size--)\n+      goto emsgsize;\n+    *dst++ = '\\0';\n+  }\n+  return (bits);\n+\n+  enoent:\n+  SET_ERRNO(ENOENT);\n+  return (-1);\n+\n+  emsgsize:\n+  SET_ERRNO(EMSGSIZE);\n+  return (-1);\n+}\n+\n+static int\n+getbits(const char *src, int *bitsp)\n+{\n+  static const char digits[] = \"0123456789\";\n+  int n;\n+  int val;\n+  char ch;\n+\n+  val = 0;\n+  n = 0;\n+  while ((ch = *src++) != '\\0') {\n+    const char *pch;\n+\n+    pch = strchr(digits, ch);\n+    if (pch != NULL) {\n+      if (n++ != 0 && val == 0)       /* no leading zeros */\n+        return (0);\n+      val *= 10;\n+      val += (pch - digits);\n+      if (val > 128)                  /* range */\n+        return (0);\n+      continue;\n+    }\n+    return (0);\n+  }\n+  if (n == 0)\n+    return (0);\n+  *bitsp = val;\n+  return (1);\n+}\n+\n+static int\n+getv4(const char *src, unsigned char *dst, int *bitsp)\n+{\n+  static const char digits[] = \"0123456789\";\n+  unsigned char *odst = dst;\n+  int n;\n+  unsigned int val;\n+  char ch;\n+\n+  val = 0;\n+  n = 0;\n+  while ((ch = *src++) != '\\0') {\n+    const char *pch;\n+\n+    pch = strchr(digits, ch);\n+    if (pch != NULL) {\n+      if (n++ != 0 && val == 0)       /* no leading zeros */\n+        return (0);\n+      val *= 10;\n+      val += (pch - digits);\n+      if (val > 255)                  /* range */\n+        return (0);\n+      continue;\n+    }\n+    if (ch == '.' || ch == '/') {\n+      if (dst - odst > 3)             /* too many octets? */\n+        return (0);\n+      *dst++ = (unsigned char)val;\n+      if (ch == '/')\n+        return (getbits(src, bitsp));\n+      val = 0;\n+      n = 0;\n+      continue;\n+    }\n+    return (0);\n+  }\n+  if (n == 0)\n+    return (0);\n+  if (dst - odst > 3)             /* too many octets? */\n+    return (0);\n+  *dst++ = (unsigned char)val;\n+  return (1);\n+}\n+\n+static int\n+inet_net_pton_ipv6(const char *src, unsigned char *dst, size_t size)\n+{\n+  static const char xdigits_l[] = \"0123456789abcdef\",\n+    xdigits_u[] = \"0123456789ABCDEF\";\n+  unsigned char tmp[NS_IN6ADDRSZ], *tp, *endp, *colonp;\n+  const char *xdigits, *curtok;\n+  int ch, saw_xdigit;\n+  unsigned int val;\n+  int digits;\n+  int bits;\n+  size_t bytes;\n+  int words;\n+  int ipv4;\n+\n+  memset((tp = tmp), '\\0', NS_IN6ADDRSZ);\n+  endp = tp + NS_IN6ADDRSZ;\n+  colonp = NULL;\n+  /* Leading :: requires some special handling. */\n+  if (*src == ':')\n+    if (*++src != ':')\n+      goto enoent;\n+  curtok = src;\n+  saw_xdigit = 0;\n+  val = 0;\n+  digits = 0;\n+  bits = -1;\n+  ipv4 = 0;\n+  while ((ch = *src++) != '\\0') {\n+    const char *pch;\n+\n+    if ((pch = strchr((xdigits = xdigits_l), ch)) == NULL)\n+      pch = strchr((xdigits = xdigits_u), ch);\n+    if (pch != NULL) {\n+      val <<= 4;\n+      val |= (pch - xdigits);\n+      if (++digits > 4)\n+        goto enoent;\n+      saw_xdigit = 1;\n+      continue;\n+    }\n+    if (ch == ':') {\n+      curtok = src;\n+      if (!saw_xdigit) {\n+        if (colonp)\n+          goto enoent;\n+        colonp = tp;\n+        continue;\n+      } else if (*src == '\\0')\n+        goto enoent;\n+      if (tp + NS_INT16SZ > endp)\n+        return (0);\n+      *tp++ = (unsigned char)((val >> 8) & 0xff);\n+      *tp++ = (unsigned char)(val & 0xff);\n+      saw_xdigit = 0;\n+      digits = 0;\n+      val = 0;\n+      continue;\n+    }\n+    if (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&\n+        getv4(curtok, tp, &bits) > 0) {\n+      tp += NS_INADDRSZ;\n+      saw_xdigit = 0;\n+      ipv4 = 1;\n+      break;  /* '\\0' was seen by inet_pton4(). */\n+    }\n+    if (ch == '/' && getbits(src, &bits) > 0)\n+      break;\n+    goto enoent;\n+  }\n+  if (saw_xdigit) {\n+    if (tp + NS_INT16SZ > endp)\n+      goto enoent;\n+    *tp++ = (unsigned char)((val >> 8) & 0xff);\n+    *tp++ = (unsigned char)(val & 0xff);\n+  }\n+  if (bits == -1)\n+    bits = 128;\n+\n+  words = (bits + 15) / 16;\n+  if (words < 2)\n+    words = 2;\n+  if (ipv4)\n+    words = 8;\n+  endp =  tmp + 2 * words;\n+\n+  if (colonp != NULL) {\n+    /*\n+     * Since some memmove()'s erroneously fail to handle\n+     * overlapping regions, we'll do the shift by hand.\n+     */\n+    const ssize_t n = tp - colonp;\n+    ssize_t i;\n+\n+    if (tp == endp)\n+      goto enoent;\n+    for (i = 1; i <= n; i++) {\n+      *(endp - i) = *(colonp + n - i);\n+      *(colonp + n - i) = 0;\n+    }\n+    tp = endp;\n+  }\n+  if (tp != endp)\n+    goto enoent;\n+\n+  bytes = (bits + 7) / 8;\n+  if (bytes > size)\n+    goto emsgsize;\n+  memcpy(dst, tmp, bytes);\n+  return (bits);\n+\n+  enoent:\n+  SET_ERRNO(ENOENT);\n+  return (-1);\n+\n+  emsgsize:\n+  SET_ERRNO(EMSGSIZE);\n+  return (-1);\n+}\n+\n+/*\n+ * int\n+ * inet_net_pton(af, src, dst, size)\n+ *      convert network number from presentation to network format.\n+ *      accepts hex octets, hex strings, decimal octets, and /CIDR.\n+ *      \"size\" is in bytes and describes \"dst\".\n+ * return:\n+ *      number of bits, either imputed classfully or specified with /CIDR,\n+ *      or -1 if some failure occurred (check errno).  ENOENT means it was\n+ *      not a valid network specification.\n+ * note:\n+ *      On Windows we store the error in the thread errno, not\n+ *      in the winsock error code. This is to avoid loosing the\n+ *      actual last winsock error. So use macro ERRNO to fetch the\n+ *      errno this funtion sets when returning (-1), not SOCKERRNO.\n+ * author:\n+ *      Paul Vixie (ISC), June 1996\n+ */\n+int\n+ares_inet_net_pton(int af, const char *src, void *dst, size_t size)\n+{\n+  switch (af) {\n+  case AF_INET:\n+    return (inet_net_pton_ipv4(src, dst, size));\n+  case AF_INET6:\n+    return (inet_net_pton_ipv6(src, dst, size));\n+  default:\n+    SET_ERRNO(EAFNOSUPPORT);\n+    return (-1);\n+  }\n+}\n+\n+#endif\n+\n+#ifndef HAVE_INET_PTON\n+int ares_inet_pton(int af, const char *src, void *dst)\n+{\n+  int result;\n+  size_t size;\n+\n+  if (af == AF_INET)\n+    size = sizeof(struct in_addr);\n+  else if (af == AF_INET6)\n+    size = sizeof(struct ares_in6_addr);\n+  else\n+  {\n+    SET_ERRNO(EAFNOSUPPORT);\n+    return -1;\n+  }\n+  result = ares_inet_net_pton(af, src, dst, size);\n+  if (result == -1 && ERRNO == ENOENT)\n+    return 0;\n+  return (result > -1 ? 1 : -1);\n+}\n+#endif"}, {"sha": "e04bc11b1658b82a5e92b644f5792f3d6654e6e9", "filename": "src/rt/libuv/src/ares/inet_net_pton.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_net_pton.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_net_pton.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_net_pton.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,31 @@\n+#ifndef __ARES_INET_NET_PTON_H\n+#define __ARES_INET_NET_PTON_H\n+\n+\n+/* Copyright (C) 2005 by Daniel Stenberg\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#ifdef HAVE_INET_PTON\n+#define ares_inet_pton(x,y,z) inet_pton(x,y,z)\n+#else\n+int ares_inet_pton(int af, const char *src, void *dst);\n+#endif\n+#if defined(HAVE_INET_NET_PTON) && defined(HAVE_INET_NET_PTON_IPV6)\n+#define ares_inet_net_pton(w,x,y,z) inet_net_pton(w,x,y,z)\n+#else\n+int ares_inet_net_pton(int af, const char *src, void *dst, size_t size);\n+#endif\n+\n+#endif /* __ARES_INET_NET_PTON_H */"}, {"sha": "71385cc8c9af36e4c74f8e3a52440bfd0549fa41", "filename": "src/rt/libuv/src/ares/inet_ntop.c", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,232 @@\n+\n+/* Copyright (c) 1996 by Internet Software Consortium.\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS\n+ * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE\n+ * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL\n+ * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR\n+ * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS\n+ * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\n+ * SOFTWARE.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_ARPA_INET_H\n+#  include <arpa/inet.h>\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_H\n+#  include <arpa/nameser.h>\n+#else\n+#  include \"nameser.h\"\n+#endif\n+#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n+#  include <arpa/nameser_compat.h>\n+#endif\n+\n+#include <ctype.h>\n+#include <errno.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#include \"ares.h\"\n+#include \"ares_ipv6.h\"\n+#include \"inet_ntop.h\"\n+\n+\n+#ifndef HAVE_INET_NTOP\n+\n+#ifdef SPRINTF_CHAR\n+# define SPRINTF(x) strlen(sprintf/**/x)\n+#else\n+# define SPRINTF(x) ((size_t)sprintf x)\n+#endif\n+\n+/*\n+ * WARNING: Don't even consider trying to compile this on a system where\n+ * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.\n+ */\n+\n+static const char *inet_ntop4(const unsigned char *src, char *dst, size_t size);\n+static const char *inet_ntop6(const unsigned char *src, char *dst, size_t size);\n+\n+/* char *\n+ * inet_ntop(af, src, dst, size)\n+ *     convert a network format address to presentation format.\n+ * return:\n+ *     pointer to presentation format address (`dst'), or NULL (see errno).\n+ * note:\n+ *      On Windows we store the error in the thread errno, not\n+ *      in the winsock error code. This is to avoid loosing the\n+ *      actual last winsock error. So use macro ERRNO to fetch the\n+ *      errno this funtion sets when returning NULL, not SOCKERRNO.\n+ * author:\n+ *     Paul Vixie, 1996.\n+ */\n+const char *\n+ares_inet_ntop(int af, const void *src, char *dst, size_t size)\n+{\n+  switch (af)\n+    {\n+    case AF_INET:\n+      return (inet_ntop4(src, dst, size));\n+    case AF_INET6:\n+      return (inet_ntop6(src, dst, size));\n+    default:\n+      SET_ERRNO(EAFNOSUPPORT);\n+      return (NULL);\n+    }\n+  /* NOTREACHED */\n+}\n+\n+/* const char *\n+ * inet_ntop4(src, dst, size)\n+ *     format an IPv4 address, more or less like inet_ntoa()\n+ * return:\n+ *     `dst' (as a const)\n+ * notes:\n+ *     (1) uses no statics\n+ *     (2) takes a unsigned char* not an in_addr as input\n+ * author:\n+ *     Paul Vixie, 1996.\n+ */\n+static const char *\n+inet_ntop4(const unsigned char *src, char *dst, size_t size)\n+{\n+  static const char fmt[] = \"%u.%u.%u.%u\";\n+  char tmp[sizeof \"255.255.255.255\"];\n+\n+  if (SPRINTF((tmp, fmt, src[0], src[1], src[2], src[3])) > size)\n+    {\n+      SET_ERRNO(ENOSPC);\n+      return (NULL);\n+    }\n+    strcpy(dst, tmp);\n+    return (dst);\n+}\n+\n+/* const char *\n+ * inet_ntop6(src, dst, size)\n+ *    convert IPv6 binary address into presentation (printable) format\n+ * author:\n+ *    Paul Vixie, 1996.\n+ */\n+static const char *\n+inet_ntop6(const unsigned char *src, char *dst, size_t size)\n+{\n+  /*\n+   * Note that int32_t and int16_t need only be \"at least\" large enough\n+   * to contain a value of the specified size.  On some systems, like\n+   * Crays, there is no such thing as an integer variable with 16 bits.\n+   * Keep this in mind if you think this function should have been coded\n+   * to use pointer overlays.  All the world's not a VAX.\n+   */\n+  char tmp[sizeof(\"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\")];\n+  char *tp;\n+  struct {\n+    long base;\n+    long len;\n+  } best, cur;\n+  unsigned long words[NS_IN6ADDRSZ / NS_INT16SZ];\n+  int i;\n+\n+  /*\n+   * Preprocess:\n+   *  Copy the input (bytewise) array into a wordwise array.\n+   *  Find the longest run of 0x00's in src[] for :: shorthanding.\n+   */\n+  memset(words, '\\0', sizeof(words));\n+  for (i = 0; i < NS_IN6ADDRSZ; i++)\n+      words[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));\n+\n+  best.base = -1;\n+  cur.base = -1;\n+  best.len = 0;\n+  cur.len = 0;\n+\n+  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++)\n+    {\n+      if (words[i] == 0)\n+        {\n+          if (cur.base == -1)\n+            cur.base = i, cur.len = 1;\n+          else\n+            cur.len++;\n+        }\n+      else\n+        {\n+          if (cur.base != -1)\n+            {\n+              if (best.base == -1 || cur.len > best.len)\n+                best = cur;\n+              cur.base = -1;\n+            }\n+        }\n+    }\n+  if (cur.base != -1)\n+    {\n+      if (best.base == -1 || cur.len > best.len)\n+        best = cur;\n+    }\n+  if (best.base != -1 && best.len < 2)\n+    best.base = -1;\n+\n+  /*\n+   * Format the result.\n+   */\n+  tp = tmp;\n+  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++)\n+    {\n+      /* Are we inside the best run of 0x00's? */\n+      if (best.base != -1 && i >= best.base &&\n+          i < (best.base + best.len))\n+        {\n+          if (i == best.base)\n+             *tp++ = ':';\n+          continue;\n+        }\n+      /* Are we following an initial run of 0x00s or any real hex? */\n+      if (i != 0)\n+        *tp++ = ':';\n+      /* Is this address an encapsulated IPv4? */\n+      if (i == 6 && best.base == 0 &&\n+          (best.len == 6 || (best.len == 5 && words[5] == 0xffff)))\n+        {\n+          if (!inet_ntop4(src+12, tp, sizeof(tmp) - (tp - tmp)))\n+            return (NULL);\n+          tp += strlen(tp);\n+          break;\n+        }\n+        tp += SPRINTF((tp, \"%lx\", words[i]));\n+    }\n+\n+  /* Was it a trailing run of 0x00's? */\n+  if (best.base != -1 && (best.base + best.len) == (NS_IN6ADDRSZ / NS_INT16SZ))\n+    *tp++ = ':';\n+  *tp++ = '\\0';\n+\n+  /*\n+   * Check for overflow, copy, and we're done.\n+   */\n+  if ((size_t)(tp - tmp) > size)\n+    {\n+      SET_ERRNO(ENOSPC);\n+      return (NULL);\n+    }\n+  strcpy(dst, tmp);\n+  return (dst);\n+}\n+#endif\n+"}, {"sha": "c583488f75e736f78cca93c8e13539de2a60e4a0", "filename": "src/rt/libuv/src/ares/inet_ntop.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,26 @@\n+#ifndef __ARES_INET_NTOP_H\n+#define __ARES_INET_NTOP_H\n+\n+\n+/* Copyright (C) 2005 by Dominick Meglio\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#ifdef HAVE_INET_NTOP\n+#define ares_inet_ntop(w,x,y,z) inet_ntop(w,x,y,z)\n+#else\n+const char *ares_inet_ntop(int af, const void *src, char *dst, size_t size);\n+#endif\n+\n+#endif /* __ARES_INET_NTOP_H */"}, {"sha": "b5be424cf7481b2317f9b4113fc80b1456a9bec5", "filename": "src/rt/libuv/src/ares/nameser.h", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fnameser.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fnameser.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fnameser.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,193 @@\n+\n+#ifndef ARES_NAMESER_H\n+#define ARES_NAMESER_H\n+\n+/* header file provided by liren@vivisimo.com */\n+\n+#ifndef HAVE_ARPA_NAMESER_H\n+\n+#define NS_PACKETSZ     512   /* maximum packet size */\n+#define NS_MAXDNAME     256   /* maximum domain name */\n+#define NS_MAXCDNAME    255   /* maximum compressed domain name */\n+#define NS_MAXLABEL     63\n+#define NS_HFIXEDSZ     12    /* #/bytes of fixed data in header */\n+#define NS_QFIXEDSZ     4     /* #/bytes of fixed data in query */\n+#define NS_RRFIXEDSZ    10    /* #/bytes of fixed data in r record */\n+#define NS_INT16SZ      2\n+#define NS_INADDRSZ     4\n+#define NS_IN6ADDRSZ    16\n+#define NS_CMPRSFLGS    0xc0  /* Flag bits indicating name compression. */\n+#define NS_DEFAULTPORT  53    /* For both TCP and UDP. */\n+\n+typedef enum __ns_class {\n+    ns_c_invalid = 0,       /* Cookie. */\n+    ns_c_in = 1,            /* Internet. */\n+    ns_c_2 = 2,             /* unallocated/unsupported. */\n+    ns_c_chaos = 3,         /* MIT Chaos-net. */\n+    ns_c_hs = 4,            /* MIT Hesiod. */\n+    /* Query class values which do not appear in resource records */\n+    ns_c_none = 254,        /* for prereq. sections in update requests */\n+    ns_c_any = 255,         /* Wildcard match. */\n+    ns_c_max = 65536\n+} ns_class;\n+\n+typedef enum __ns_type {\n+    ns_t_invalid = 0,       /* Cookie. */\n+    ns_t_a = 1,             /* Host address. */\n+    ns_t_ns = 2,            /* Authoritative server. */\n+    ns_t_md = 3,            /* Mail destination. */\n+    ns_t_mf = 4,            /* Mail forwarder. */\n+    ns_t_cname = 5,         /* Canonical name. */\n+    ns_t_soa = 6,           /* Start of authority zone. */\n+    ns_t_mb = 7,            /* Mailbox domain name. */\n+    ns_t_mg = 8,            /* Mail group member. */\n+    ns_t_mr = 9,            /* Mail rename name. */\n+    ns_t_null = 10,         /* Null resource record. */\n+    ns_t_wks = 11,          /* Well known service. */\n+    ns_t_ptr = 12,          /* Domain name pointer. */\n+    ns_t_hinfo = 13,        /* Host information. */\n+    ns_t_minfo = 14,        /* Mailbox information. */\n+    ns_t_mx = 15,           /* Mail routing information. */\n+    ns_t_txt = 16,          /* Text strings. */\n+    ns_t_rp = 17,           /* Responsible person. */\n+    ns_t_afsdb = 18,        /* AFS cell database. */\n+    ns_t_x25 = 19,          /* X_25 calling address. */\n+    ns_t_isdn = 20,         /* ISDN calling address. */\n+    ns_t_rt = 21,           /* Router. */\n+    ns_t_nsap = 22,         /* NSAP address. */\n+    ns_t_nsap_ptr = 23,     /* Reverse NSAP lookup (deprecated). */\n+    ns_t_sig = 24,          /* Security signature. */\n+    ns_t_key = 25,          /* Security key. */\n+    ns_t_px = 26,           /* X.400 mail mapping. */\n+    ns_t_gpos = 27,         /* Geographical position (withdrawn). */\n+    ns_t_aaaa = 28,         /* Ip6 Address. */\n+    ns_t_loc = 29,          /* Location Information. */\n+    ns_t_nxt = 30,          /* Next domain (security). */\n+    ns_t_eid = 31,          /* Endpoint identifier. */\n+    ns_t_nimloc = 32,       /* Nimrod Locator. */\n+    ns_t_srv = 33,          /* Server Selection. */\n+    ns_t_atma = 34,         /* ATM Address */\n+    ns_t_naptr = 35,        /* Naming Authority PoinTeR */\n+    ns_t_kx = 36,           /* Key Exchange */\n+    ns_t_cert = 37,         /* Certification record */\n+    ns_t_a6 = 38,           /* IPv6 address (deprecates AAAA) */\n+    ns_t_dname = 39,        /* Non-terminal DNAME (for IPv6) */\n+    ns_t_sink = 40,         /* Kitchen sink (experimentatl) */\n+    ns_t_opt = 41,          /* EDNS0 option (meta-RR) */\n+    ns_t_apl = 42,          /* Address prefix list (RFC3123) */\n+    ns_t_tkey = 249,        /* Transaction key */\n+    ns_t_tsig = 250,        /* Transaction signature. */\n+    ns_t_ixfr = 251,        /* Incremental zone transfer. */\n+    ns_t_axfr = 252,        /* Transfer zone of authority. */\n+    ns_t_mailb = 253,       /* Transfer mailbox records. */\n+    ns_t_maila = 254,       /* Transfer mail agent records. */\n+    ns_t_any = 255,         /* Wildcard match. */\n+    ns_t_zxfr = 256,        /* BIND-specific, nonstandard. */\n+    ns_t_max = 65536\n+} ns_type;\n+\n+typedef enum __ns_opcode {\n+    ns_o_query = 0,         /* Standard query. */\n+    ns_o_iquery = 1,        /* Inverse query (deprecated/unsupported). */\n+    ns_o_status = 2,        /* Name server status query (unsupported). */\n+                                /* Opcode 3 is undefined/reserved. */\n+    ns_o_notify = 4,        /* Zone change notification. */\n+    ns_o_update = 5,        /* Zone update message. */\n+    ns_o_max = 6\n+} ns_opcode;\n+\n+typedef enum __ns_rcode {\n+    ns_r_noerror = 0,       /* No error occurred. */\n+    ns_r_formerr = 1,       /* Format error. */\n+    ns_r_servfail = 2,      /* Server failure. */\n+    ns_r_nxdomain = 3,      /* Name error. */\n+    ns_r_notimpl = 4,       /* Unimplemented. */\n+    ns_r_refused = 5,       /* Operation refused. */\n+    /* these are for BIND_UPDATE */\n+    ns_r_yxdomain = 6,      /* Name exists */\n+    ns_r_yxrrset = 7,       /* RRset exists */\n+    ns_r_nxrrset = 8,       /* RRset does not exist */\n+    ns_r_notauth = 9,       /* Not authoritative for zone */\n+    ns_r_notzone = 10,      /* Zone of record different from zone section */\n+    ns_r_max = 11,\n+    /* The following are TSIG extended errors */\n+    ns_r_badsig = 16,\n+    ns_r_badkey = 17,\n+    ns_r_badtime = 18\n+} ns_rcode;\n+\n+#endif /* HAVE_ARPA_NAMESER_H */\n+\n+#ifndef HAVE_ARPA_NAMESER_COMPAT_H\n+\n+#define PACKETSZ         NS_PACKETSZ\n+#define MAXDNAME         NS_MAXDNAME\n+#define MAXCDNAME        NS_MAXCDNAME\n+#define MAXLABEL         NS_MAXLABEL\n+#define HFIXEDSZ         NS_HFIXEDSZ\n+#define QFIXEDSZ         NS_QFIXEDSZ\n+#define RRFIXEDSZ        NS_RRFIXEDSZ\n+#define INDIR_MASK       NS_CMPRSFLGS\n+#define NAMESERVER_PORT  NS_DEFAULTPORT\n+\n+#define QUERY           ns_o_query\n+\n+#define SERVFAIL        ns_r_servfail\n+#define NOTIMP          ns_r_notimpl\n+#define REFUSED         ns_r_refused\n+#undef NOERROR /* it seems this is already defined in winerror.h */\n+#define NOERROR         ns_r_noerror\n+#define FORMERR         ns_r_formerr\n+#define NXDOMAIN        ns_r_nxdomain\n+\n+#define C_IN            ns_c_in\n+#define C_CHAOS         ns_c_chaos\n+#define C_HS            ns_c_hs\n+#define C_NONE          ns_c_none\n+#define C_ANY           ns_c_any\n+\n+#define T_A             ns_t_a\n+#define T_NS            ns_t_ns\n+#define T_MD            ns_t_md\n+#define T_MF            ns_t_mf\n+#define T_CNAME         ns_t_cname\n+#define T_SOA           ns_t_soa\n+#define T_MB            ns_t_mb\n+#define T_MG            ns_t_mg\n+#define T_MR            ns_t_mr\n+#define T_NULL          ns_t_null\n+#define T_WKS           ns_t_wks\n+#define T_PTR           ns_t_ptr\n+#define T_HINFO         ns_t_hinfo\n+#define T_MINFO         ns_t_minfo\n+#define T_MX            ns_t_mx\n+#define T_TXT           ns_t_txt\n+#define T_RP            ns_t_rp\n+#define T_AFSDB         ns_t_afsdb\n+#define T_X25           ns_t_x25\n+#define T_ISDN          ns_t_isdn\n+#define T_RT            ns_t_rt\n+#define T_NSAP          ns_t_nsap\n+#define T_NSAP_PTR      ns_t_nsap_ptr\n+#define T_SIG           ns_t_sig\n+#define T_KEY           ns_t_key\n+#define T_PX            ns_t_px\n+#define T_GPOS          ns_t_gpos\n+#define T_AAAA          ns_t_aaaa\n+#define T_LOC           ns_t_loc\n+#define T_NXT           ns_t_nxt\n+#define T_EID           ns_t_eid\n+#define T_NIMLOC        ns_t_nimloc\n+#define T_SRV           ns_t_srv\n+#define T_ATMA          ns_t_atma\n+#define T_NAPTR         ns_t_naptr\n+#define T_TSIG          ns_t_tsig\n+#define T_IXFR          ns_t_ixfr\n+#define T_AXFR          ns_t_axfr\n+#define T_MAILB         ns_t_mailb\n+#define T_MAILA         ns_t_maila\n+#define T_ANY           ns_t_any\n+\n+#endif /* HAVE_ARPA_NAMESER_COMPAT_H */\n+\n+#endif /* ARES_NAMESER_H */"}, {"sha": "0c7c811194c72817b3cf6119ae5552d3cf369e2b", "filename": "src/rt/libuv/src/ares/setup_once.h", "status": "added", "additions": 488, "deletions": 0, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fsetup_once.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fsetup_once.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fsetup_once.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,488 @@\n+#ifndef __SETUP_ONCE_H\n+#define __SETUP_ONCE_H\n+\n+\n+/* Copyright (C) 2004 - 2010 by Daniel Stenberg et al\n+ *\n+ * Permission to use, copy, modify, and distribute this software and its\n+ * documentation for any purpose and without fee is hereby granted, provided\n+ * that the above copyright notice appear in all copies and that both that\n+ * copyright notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in advertising or\n+ * publicity pertaining to distribution of the software without specific,\n+ * written prior permission.  M.I.T. makes no representations about the\n+ * suitability of this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+\n+/********************************************************************\n+ *                              NOTICE                              *\n+ *                             ========                             *\n+ *                                                                  *\n+ *  Content of header files lib/setup_once.h and ares/setup_once.h  *\n+ *  must be kept in sync. Modify the other one if you change this.  *\n+ *                                                                  *\n+ ********************************************************************/\n+\n+\n+/*\n+ * Inclusion of common header files.\n+ */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <stdarg.h>\n+#include <ctype.h>\n+#include <errno.h>\n+\n+#ifdef HAVE_SYS_TYPES_H\n+#include <sys/types.h>\n+#endif\n+\n+#ifdef NEED_MALLOC_H\n+#include <malloc.h>\n+#endif\n+\n+#ifdef NEED_MEMORY_H\n+#include <memory.h>\n+#endif\n+\n+#ifdef HAVE_SYS_STAT_H\n+#include <sys/stat.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#ifdef TIME_WITH_SYS_TIME\n+#include <time.h>\n+#endif\n+#else\n+#ifdef HAVE_TIME_H\n+#include <time.h>\n+#endif\n+#endif\n+\n+#ifdef WIN32\n+#include <io.h>\n+#include <fcntl.h>\n+#endif\n+\n+#ifdef HAVE_STDBOOL_H\n+#include <stdbool.h>\n+#endif\n+\n+\n+/*\n+ * Definition of timeval struct for platforms that don't have it.\n+ */\n+\n+#ifndef HAVE_STRUCT_TIMEVAL\n+struct timeval {\n+ long tv_sec;\n+ long tv_usec;\n+};\n+#endif\n+\n+\n+/*\n+ * If we have the MSG_NOSIGNAL define, make sure we use\n+ * it as the fourth argument of function send()\n+ */\n+\n+#ifdef HAVE_MSG_NOSIGNAL\n+#define SEND_4TH_ARG MSG_NOSIGNAL\n+#else\n+#define SEND_4TH_ARG 0\n+#endif\n+\n+\n+#if defined(__minix)\n+/* Minix doesn't support recv on TCP sockets */\n+#define sread(x,y,z) (ssize_t)read((RECV_TYPE_ARG1)(x), \\\n+                                   (RECV_TYPE_ARG2)(y), \\\n+                                   (RECV_TYPE_ARG3)(z))\n+\n+#elif defined(HAVE_RECV)\n+/*\n+ * The definitions for the return type and arguments types\n+ * of functions recv() and send() belong and come from the\n+ * configuration file. Do not define them in any other place.\n+ *\n+ * HAVE_RECV is defined if you have a function named recv()\n+ * which is used to read incoming data from sockets. If your\n+ * function has another name then don't define HAVE_RECV.\n+ *\n+ * If HAVE_RECV is defined then RECV_TYPE_ARG1, RECV_TYPE_ARG2,\n+ * RECV_TYPE_ARG3, RECV_TYPE_ARG4 and RECV_TYPE_RETV must also\n+ * be defined.\n+ *\n+ * HAVE_SEND is defined if you have a function named send()\n+ * which is used to write outgoing data on a connected socket.\n+ * If yours has another name then don't define HAVE_SEND.\n+ *\n+ * If HAVE_SEND is defined then SEND_TYPE_ARG1, SEND_QUAL_ARG2,\n+ * SEND_TYPE_ARG2, SEND_TYPE_ARG3, SEND_TYPE_ARG4 and\n+ * SEND_TYPE_RETV must also be defined.\n+ */\n+\n+#if !defined(RECV_TYPE_ARG1) || \\\n+    !defined(RECV_TYPE_ARG2) || \\\n+    !defined(RECV_TYPE_ARG3) || \\\n+    !defined(RECV_TYPE_ARG4) || \\\n+    !defined(RECV_TYPE_RETV)\n+  /* */\n+  Error Missing_definition_of_return_and_arguments_types_of_recv\n+  /* */\n+#else\n+#define sread(x,y,z) (ssize_t)recv((RECV_TYPE_ARG1)(x), \\\n+                                   (RECV_TYPE_ARG2)(y), \\\n+                                   (RECV_TYPE_ARG3)(z), \\\n+                                   (RECV_TYPE_ARG4)(0))\n+#endif\n+#else /* HAVE_RECV */\n+#ifndef sread\n+  /* */\n+  Error Missing_definition_of_macro_sread\n+  /* */\n+#endif\n+#endif /* HAVE_RECV */\n+\n+\n+#if defined(__minix)\n+/* Minix doesn't support send on TCP sockets */\n+#define swrite(x,y,z) (ssize_t)write((SEND_TYPE_ARG1)(x), \\\n+                                    (SEND_TYPE_ARG2)(y), \\\n+                                    (SEND_TYPE_ARG3)(z))\n+\n+#elif defined(HAVE_SEND)\n+#if !defined(SEND_TYPE_ARG1) || \\\n+    !defined(SEND_QUAL_ARG2) || \\\n+    !defined(SEND_TYPE_ARG2) || \\\n+    !defined(SEND_TYPE_ARG3) || \\\n+    !defined(SEND_TYPE_ARG4) || \\\n+    !defined(SEND_TYPE_RETV)\n+  /* */\n+  Error Missing_definition_of_return_and_arguments_types_of_send\n+  /* */\n+#else\n+#define swrite(x,y,z) (ssize_t)send((SEND_TYPE_ARG1)(x), \\\n+                                    (SEND_TYPE_ARG2)(y), \\\n+                                    (SEND_TYPE_ARG3)(z), \\\n+                                    (SEND_TYPE_ARG4)(SEND_4TH_ARG))\n+#endif\n+#else /* HAVE_SEND */\n+#ifndef swrite\n+  /* */\n+  Error Missing_definition_of_macro_swrite\n+  /* */\n+#endif\n+#endif /* HAVE_SEND */\n+\n+\n+#if 0\n+#if defined(HAVE_RECVFROM)\n+/*\n+ * Currently recvfrom is only used on udp sockets.\n+ */\n+#if !defined(RECVFROM_TYPE_ARG1) || \\\n+    !defined(RECVFROM_TYPE_ARG2) || \\\n+    !defined(RECVFROM_TYPE_ARG3) || \\\n+    !defined(RECVFROM_TYPE_ARG4) || \\\n+    !defined(RECVFROM_TYPE_ARG5) || \\\n+    !defined(RECVFROM_TYPE_ARG6) || \\\n+    !defined(RECVFROM_TYPE_RETV)\n+  /* */\n+  Error Missing_definition_of_return_and_arguments_types_of_recvfrom\n+  /* */\n+#else\n+#define sreadfrom(s,b,bl,f,fl) (ssize_t)recvfrom((RECVFROM_TYPE_ARG1)  (s),  \\\n+                                                 (RECVFROM_TYPE_ARG2 *)(b),  \\\n+                                                 (RECVFROM_TYPE_ARG3)  (bl), \\\n+                                                 (RECVFROM_TYPE_ARG4)  (0),  \\\n+                                                 (RECVFROM_TYPE_ARG5 *)(f),  \\\n+                                                 (RECVFROM_TYPE_ARG6 *)(fl))\n+#endif\n+#else /* HAVE_RECVFROM */\n+#ifndef sreadfrom\n+  /* */\n+  Error Missing_definition_of_macro_sreadfrom\n+  /* */\n+#endif\n+#endif /* HAVE_RECVFROM */\n+\n+\n+#ifdef RECVFROM_TYPE_ARG6_IS_VOID\n+#  define RECVFROM_ARG6_T int\n+#else\n+#  define RECVFROM_ARG6_T RECVFROM_TYPE_ARG6\n+#endif\n+#endif /* if 0 */\n+\n+\n+/*\n+ * Function-like macro definition used to close a socket.\n+ */\n+\n+#if defined(HAVE_CLOSESOCKET)\n+#  define sclose(x)  closesocket((x))\n+#elif defined(HAVE_CLOSESOCKET_CAMEL)\n+#  define sclose(x)  CloseSocket((x))\n+#else\n+#  define sclose(x)  close((x))\n+#endif\n+\n+\n+/*\n+ * Uppercase macro versions of ANSI/ISO is*() functions/macros which\n+ * avoid negative number inputs with argument byte codes > 127.\n+ */\n+\n+#define ISSPACE(x)  (isspace((int)  ((unsigned char)x)))\n+#define ISDIGIT(x)  (isdigit((int)  ((unsigned char)x)))\n+#define ISALNUM(x)  (isalnum((int)  ((unsigned char)x)))\n+#define ISXDIGIT(x) (isxdigit((int) ((unsigned char)x)))\n+#define ISGRAPH(x)  (isgraph((int)  ((unsigned char)x)))\n+#define ISALPHA(x)  (isalpha((int)  ((unsigned char)x)))\n+#define ISPRINT(x)  (isprint((int)  ((unsigned char)x)))\n+#define ISUPPER(x)  (isupper((int)  ((unsigned char)x)))\n+#define ISLOWER(x)  (islower((int)  ((unsigned char)x)))\n+\n+#define ISBLANK(x)  (int)((((unsigned char)x) == ' ') || \\\n+                          (((unsigned char)x) == '\\t'))\n+\n+#define TOLOWER(x)  (tolower((int)  ((unsigned char)x)))\n+\n+\n+/*\n+ * 'bool' exists on platforms with <stdbool.h>, i.e. C99 platforms.\n+ * On non-C99 platforms there's no bool, so define an enum for that.\n+ * On C99 platforms 'false' and 'true' also exist. Enum uses a\n+ * global namespace though, so use bool_false and bool_true.\n+ */\n+\n+#ifndef HAVE_BOOL_T\n+  typedef enum {\n+      bool_false = 0,\n+      bool_true  = 1\n+  } bool;\n+\n+/*\n+ * Use a define to let 'true' and 'false' use those enums.  There\n+ * are currently no use of true and false in libcurl proper, but\n+ * there are some in the examples. This will cater for any later\n+ * code happening to use true and false.\n+ */\n+#  define false bool_false\n+#  define true  bool_true\n+#  define HAVE_BOOL_T\n+#endif\n+\n+\n+/*\n+ * Redefine TRUE and FALSE too, to catch current use. With this\n+ * change, 'bool found = 1' will give a warning on MIPSPro, but\n+ * 'bool found = TRUE' will not. Change tested on IRIX/MIPSPro,\n+ * AIX 5.1/Xlc, Tru64 5.1/cc, w/make test too.\n+ */\n+\n+#ifndef TRUE\n+#define TRUE true\n+#endif\n+#ifndef FALSE\n+#define FALSE false\n+#endif\n+\n+\n+/*\n+ * Typedef to 'int' if sig_atomic_t is not an available 'typedefed' type.\n+ */\n+\n+#ifndef HAVE_SIG_ATOMIC_T\n+typedef int sig_atomic_t;\n+#define HAVE_SIG_ATOMIC_T\n+#endif\n+\n+\n+/*\n+ * Convenience SIG_ATOMIC_T definition\n+ */\n+\n+#ifdef HAVE_SIG_ATOMIC_T_VOLATILE\n+#define SIG_ATOMIC_T static sig_atomic_t\n+#else\n+#define SIG_ATOMIC_T static volatile sig_atomic_t\n+#endif\n+\n+\n+/*\n+ * Default return type for signal handlers.\n+ */\n+\n+#ifndef RETSIGTYPE\n+#define RETSIGTYPE void\n+#endif\n+\n+\n+/*\n+ * Macro used to include code only in debug builds.\n+ */\n+\n+#ifdef DEBUGBUILD\n+#define DEBUGF(x) x\n+#else\n+#define DEBUGF(x) do { } while (0)\n+#endif\n+\n+\n+/*\n+ * Macro used to include assertion code only in debug builds.\n+ */\n+\n+#if defined(DEBUGBUILD) && defined(HAVE_ASSERT_H)\n+#define DEBUGASSERT(x) assert(x)\n+#else\n+#define DEBUGASSERT(x) do { } while (0)\n+#endif\n+\n+\n+/*\n+ * Macro SOCKERRNO / SET_SOCKERRNO() returns / sets the *socket-related* errno\n+ * (or equivalent) on this platform to hide platform details to code using it.\n+ */\n+\n+#ifdef USE_WINSOCK\n+#define SOCKERRNO         ((int)WSAGetLastError())\n+#define SET_SOCKERRNO(x)  (WSASetLastError((int)(x)))\n+#else\n+#define SOCKERRNO         (errno)\n+#define SET_SOCKERRNO(x)  (errno = (x))\n+#endif\n+\n+\n+/*\n+ * Macro ERRNO / SET_ERRNO() returns / sets the NOT *socket-related* errno\n+ * (or equivalent) on this platform to hide platform details to code using it.\n+ */\n+\n+#ifdef WIN32\n+#define ERRNO         ((int)GetLastError())\n+#define SET_ERRNO(x)  (SetLastError((DWORD)(x)))\n+#else\n+#define ERRNO         (errno)\n+#define SET_ERRNO(x)  (errno = (x))\n+#endif\n+\n+\n+/*\n+ * Portable error number symbolic names defined to Winsock error codes.\n+ */\n+\n+#ifdef USE_WINSOCK\n+#undef  EBADF            /* override definition in errno.h */\n+#define EBADF            WSAEBADF\n+#undef  EINTR            /* override definition in errno.h */\n+#define EINTR            WSAEINTR\n+#undef  EINVAL           /* override definition in errno.h */\n+#define EINVAL           WSAEINVAL\n+#undef  EWOULDBLOCK      /* override definition in errno.h */\n+#define EWOULDBLOCK      WSAEWOULDBLOCK\n+#undef  EINPROGRESS      /* override definition in errno.h */\n+#define EINPROGRESS      WSAEINPROGRESS\n+#undef  EALREADY         /* override definition in errno.h */\n+#define EALREADY         WSAEALREADY\n+#undef  ENOTSOCK         /* override definition in errno.h */\n+#define ENOTSOCK         WSAENOTSOCK\n+#undef  EDESTADDRREQ     /* override definition in errno.h */\n+#define EDESTADDRREQ     WSAEDESTADDRREQ\n+#undef  EMSGSIZE         /* override definition in errno.h */\n+#define EMSGSIZE         WSAEMSGSIZE\n+#undef  EPROTOTYPE       /* override definition in errno.h */\n+#define EPROTOTYPE       WSAEPROTOTYPE\n+#undef  ENOPROTOOPT      /* override definition in errno.h */\n+#define ENOPROTOOPT      WSAENOPROTOOPT\n+#undef  EPROTONOSUPPORT  /* override definition in errno.h */\n+#define EPROTONOSUPPORT  WSAEPROTONOSUPPORT\n+#define ESOCKTNOSUPPORT  WSAESOCKTNOSUPPORT\n+#undef  EOPNOTSUPP       /* override definition in errno.h */\n+#define EOPNOTSUPP       WSAEOPNOTSUPP\n+#define EPFNOSUPPORT     WSAEPFNOSUPPORT\n+#undef  EAFNOSUPPORT     /* override definition in errno.h */\n+#define EAFNOSUPPORT     WSAEAFNOSUPPORT\n+#undef  EADDRINUSE       /* override definition in errno.h */\n+#define EADDRINUSE       WSAEADDRINUSE\n+#undef  EADDRNOTAVAIL    /* override definition in errno.h */\n+#define EADDRNOTAVAIL    WSAEADDRNOTAVAIL\n+#undef  ENETDOWN         /* override definition in errno.h */\n+#define ENETDOWN         WSAENETDOWN\n+#undef  ENETUNREACH      /* override definition in errno.h */\n+#define ENETUNREACH      WSAENETUNREACH\n+#undef  ENETRESET        /* override definition in errno.h */\n+#define ENETRESET        WSAENETRESET\n+#undef  ECONNABORTED     /* override definition in errno.h */\n+#define ECONNABORTED     WSAECONNABORTED\n+#undef  ECONNRESET       /* override definition in errno.h */\n+#define ECONNRESET       WSAECONNRESET\n+#undef  ENOBUFS          /* override definition in errno.h */\n+#define ENOBUFS          WSAENOBUFS\n+#undef  EISCONN          /* override definition in errno.h */\n+#define EISCONN          WSAEISCONN\n+#undef  ENOTCONN         /* override definition in errno.h */\n+#define ENOTCONN         WSAENOTCONN\n+#define ESHUTDOWN        WSAESHUTDOWN\n+#define ETOOMANYREFS     WSAETOOMANYREFS\n+#undef  ETIMEDOUT        /* override definition in errno.h */\n+#define ETIMEDOUT        WSAETIMEDOUT\n+#undef  ECONNREFUSED     /* override definition in errno.h */\n+#define ECONNREFUSED     WSAECONNREFUSED\n+#undef  ELOOP            /* override definition in errno.h */\n+#define ELOOP            WSAELOOP\n+#ifndef ENAMETOOLONG     /* possible previous definition in errno.h */\n+#define ENAMETOOLONG     WSAENAMETOOLONG\n+#endif\n+#define EHOSTDOWN        WSAEHOSTDOWN\n+#undef  EHOSTUNREACH     /* override definition in errno.h */\n+#define EHOSTUNREACH     WSAEHOSTUNREACH\n+#ifndef ENOTEMPTY        /* possible previous definition in errno.h */\n+#define ENOTEMPTY        WSAENOTEMPTY\n+#endif\n+#define EPROCLIM         WSAEPROCLIM\n+#define EUSERS           WSAEUSERS\n+#define EDQUOT           WSAEDQUOT\n+#define ESTALE           WSAESTALE\n+#define EREMOTE          WSAEREMOTE\n+#endif\n+\n+\n+/*\n+ *  Actually use __32_getpwuid() on 64-bit VMS builds for getpwuid()\n+ */\n+\n+#if defined(__VMS) && \\\n+    defined(__INITIAL_POINTER_SIZE) && (__INITIAL_POINTER_SIZE == 64)\n+#define getpwuid __32_getpwuid\n+#endif\n+\n+\n+/*\n+ * Macro argv_item_t hides platform details to code using it.\n+ */\n+\n+#ifdef __VMS\n+#define argv_item_t  __char_ptr32\n+#else\n+#define argv_item_t  char *\n+#endif\n+\n+\n+/*\n+ * We use this ZERO_NULL to avoid picky compiler warnings,\n+ * when assigning a NULL pointer to a function pointer var.\n+ */\n+\n+#define ZERO_NULL 0\n+\n+\n+#endif /* __SETUP_ONCE_H */\n+"}, {"sha": "03acd1c1e2b701af6bb0a118f7785a8a39fd7356", "filename": "src/rt/libuv/src/ares/windows_port.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fwindows_port.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fwindows_port.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fwindows_port.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,22 @@\n+#include \"ares_setup.h\"\n+\n+\n+/* only do the following on windows\n+ */\n+#if (defined(WIN32) || defined(WATT32)) && !defined(MSDOS)\n+\n+#ifdef __WATCOMC__\n+/*\n+ * Watcom needs a DllMain() in order to initialise the clib startup code.\n+ */\n+BOOL\n+WINAPI DllMain (HINSTANCE hnd, DWORD reason, LPVOID reserved)\n+{\n+  (void) hnd;\n+  (void) reason;\n+  (void) reserved;\n+  return (TRUE);\n+}\n+#endif\n+\n+#endif /* WIN32 builds only */"}, {"sha": "baa94eca9cab45e558c4837bbf1fb1c2ad95e1b7", "filename": "src/rt/libuv/src/eio/Changes", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2FChanges", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2FChanges", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2FChanges?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,35 @@\n+Revision history for libeio\n+\n+TODO: maybe add mincore support? available on at least darwin, solaris, linux, freebsd\n+TODO: openbsd requites stdint.h for intptr_t - why posix?\n+\n+1.0\n+        - readdir: correctly handle malloc failures.\n+        - readdir: new flags argument, can return inode\n+          and possibly filetype, can sort in various ways.\n+        - readdir: stop immediately when cancelled, do\n+          not continue reading the directory.\n+        - fix return value of eio_sendfile_sync.\n+        - include sys/mman.h for msync.\n+\t- added EIO_STACKSIZE.\n+\t- added msync, mtouch support (untested).\n+        - added sync_file_range (untested).\n+        - fixed custom support.\n+        - use a more robust feed-add detection method.\n+\t- \"outbundled\" from IO::AIO.\n+        - eio_set_max_polltime did not properly convert time to ticks.\n+        - tentatively support darwin in sendfile.\n+        - fix freebsd/darwin sendfile.\n+        - also use sendfile emulation for ENOTSUP and EOPNOTSUPP\n+          error codes.\n+        - add OS-independent EIO_MT_* and EIO_MS_* flag enums.\n+        - add eio_statvfs/eio_fstatvfs.\n+        - add eio_mlock/eio_mlockall and OS-independent MCL_* flag enums.\n+        - no longer set errno to 0 before making syscalls, this only lures\n+          people into the trap of believing errno shows success or failure.\n+        - \"fix\" demo.c so that it works as non-root.\n+        - suppoert utimes seperately from futimes, as some systems have\n+          utimes but not futimes.\n+        - use _POSIX_MEMLOCK_RANGE for mlock.\n+        - do not (errornously) overwrite CFLAGS in configure.ac.\n+"}, {"sha": "1ed1324d304ebd61920cd1f89df05486f3dd49e1", "filename": "src/rt/libuv/src/eio/LICENSE", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2FLICENSE", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2FLICENSE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2FLICENSE?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,36 @@\n+All files in libeio are Copyright (C)2007,2008 Marc Alexander Lehmann.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    * Redistributions of source code must retain the above copyright\n+      notice, this list of conditions and the following disclaimer.\n+\n+    * Redistributions in binary form must reproduce the above\n+      copyright notice, this list of conditions and the following\n+      disclaimer in the documentation and/or other materials provided\n+      with the distribution.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+Alternatively, the contents of this package may be used under the terms\n+of the GNU General Public License (\"GPL\") version 2 or any later version,\n+in which case the provisions of the GPL are applicable instead of the\n+above. If you wish to allow the use of your version of this package only\n+under the terms of the GPL and not to allow others to use your version of\n+this file under the BSD license, indicate your decision by deleting the\n+provisions above and replace them with the notice and other provisions\n+required by the GPL in this and the other files of this package. If you do\n+not delete the provisions above, a recipient may use your version of this\n+file under either the BSD or the GPL."}, {"sha": "857d26b6190a06e1e317b9886c402a75251bbe0a", "filename": "src/rt/libuv/src/eio/Makefile.am", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2FMakefile.am", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2FMakefile.am", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2FMakefile.am?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,15 @@\n+AUTOMAKE_OPTIONS = foreign no-dependencies\n+\n+VERSION_INFO = 1:0\n+\n+EXTRA_DIST = LICENSE Changes autogen.sh\n+\n+#man_MANS = ev.3\n+\n+include_HEADERS = eio.h\n+\n+lib_LTLIBRARIES = libeio.la\n+\n+libeio_la_SOURCES = eio.c xthread.h config.h\n+libeio_la_LDFLAGS = -version-info $(VERSION_INFO)\n+"}, {"sha": "18abb73686c0dfdbc293e38d58bb25852c698ee1", "filename": "src/rt/libuv/src/eio/aclocal.m4", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Faclocal.m4", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Faclocal.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2Faclocal.m4?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/aclocal.m4"}, {"sha": "bd3387c46c70f00112b261e0fa62f0aa6951afcb", "filename": "src/rt/libuv/src/eio/autogen.sh", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fautogen.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fautogen.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fautogen.sh?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,5 @@\n+libtoolize\n+aclocal\n+automake --add-missing\n+autoconf\n+autoheader"}, {"sha": "73e9dd07d280fe6d849e6e886690354b892d9b5e", "filename": "src/rt/libuv/src/eio/config.h.in", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfig.h.in", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfig.h.in?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,86 @@\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#undef HAVE_DLFCN_H\n+\n+/* fdatasync(2) is available */\n+#undef HAVE_FDATASYNC\n+\n+/* futimes(2) is available */\n+#undef HAVE_FUTIMES\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#undef HAVE_INTTYPES_H\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#undef HAVE_MEMORY_H\n+\n+/* posix_fadvise(2) is available */\n+#undef HAVE_POSIX_FADVISE\n+\n+/* posix_madvise(2) is available */\n+#undef HAVE_POSIX_MADVISE\n+\n+/* pread(2) and pwrite(2) are available */\n+#undef HAVE_PREADWRITE\n+\n+/* readahead(2) is available (linux) */\n+#undef HAVE_READAHEAD\n+\n+/* sendfile(2) is available and supported */\n+#undef HAVE_SENDFILE\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#undef HAVE_STDINT_H\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#undef HAVE_STDLIB_H\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#undef HAVE_STRINGS_H\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#undef HAVE_STRING_H\n+\n+/* sync_file_range(2) is available */\n+#undef HAVE_SYNC_FILE_RANGE\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#undef HAVE_SYS_STAT_H\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#undef HAVE_SYS_TYPES_H\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#undef HAVE_UNISTD_H\n+\n+/* utimes(2) is available */\n+#undef HAVE_UTIMES\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#undef LT_OBJDIR\n+\n+/* Name of package */\n+#undef PACKAGE\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#undef PACKAGE_BUGREPORT\n+\n+/* Define to the full name of this package. */\n+#undef PACKAGE_NAME\n+\n+/* Define to the full name and version of this package. */\n+#undef PACKAGE_STRING\n+\n+/* Define to the one symbol short name of this package. */\n+#undef PACKAGE_TARNAME\n+\n+/* Define to the home page for this package. */\n+#undef PACKAGE_URL\n+\n+/* Define to the version of this package. */\n+#undef PACKAGE_VERSION\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#undef STDC_HEADERS"}, {"sha": "f149a6b352a8a0f4da8aec0a32e6374fdc8ca9a7", "filename": "src/rt/libuv/src/eio/config_cygwin.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfig_cygwin.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfig_cygwin.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfig_cygwin.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,77 @@\n+/* config.h.  Generated from config.h.in by configure.  */\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#define HAVE_DLFCN_H 1\n+\n+/* fdatasync(2) is available */\n+#define HAVE_FDATASYNC 1\n+\n+/* futimes(2) is available */\n+#define HAVE_FUTIMES 1\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#define HAVE_INTTYPES_H 1\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#define HAVE_MEMORY_H 1\n+\n+/* pread(2) and pwrite(2) are available */\n+#define HAVE_PREADWRITE 1\n+\n+/* readahead(2) is available (linux) */\n+/* #undef HAVE_READAHEAD */\n+\n+/* sendfile(2) is available and supported */\n+/* #undef HAVE_SENDFILE */\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#define HAVE_STDINT_H 1\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#define HAVE_STDLIB_H 1\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#define HAVE_STRINGS_H 1\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#define HAVE_STRING_H 1\n+\n+/* sync_file_range(2) is available */\n+/* #undef HAVE_SYNC_FILE_RANGE */\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#define HAVE_SYS_STAT_H 1\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#define HAVE_SYS_TYPES_H 1\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#define HAVE_UNISTD_H 1\n+\n+/* Name of package */\n+#define PACKAGE \"libeio\"\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#define PACKAGE_BUGREPORT \"\"\n+\n+/* Define to the full name of this package. */\n+#define PACKAGE_NAME \"\"\n+\n+/* Define to the full name and version of this package. */\n+#define PACKAGE_STRING \"\"\n+\n+/* Define to the one symbol short name of this package. */\n+#define PACKAGE_TARNAME \"\"\n+\n+/* Define to the home page for this package. */\n+#define PACKAGE_URL \"\"\n+\n+/* Define to the version of this package. */\n+#define PACKAGE_VERSION \"\"\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#define STDC_HEADERS 1\n+\n+/* Version number of package */\n+#define VERSION \"1.0\""}, {"sha": "84a3440df0d4e6edc5f8ca9086628e8b3c3f5186", "filename": "src/rt/libuv/src/eio/config_darwin.h", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfig_darwin.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfig_darwin.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfig_darwin.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,82 @@\n+/* config.h.  Generated from config.h.in by configure.  */\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#define HAVE_DLFCN_H 1\n+\n+/* fdatasync(2) is not available on 10.5 but is on 10.6 \n+ * How should we deal with this? */\n+/* #define HAVE_FDATASYNC 0 */\n+\n+/* futimes(2) is available */\n+#define HAVE_FUTIMES 1\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#define HAVE_INTTYPES_H 1\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#define HAVE_MEMORY_H 1\n+\n+/* pread(2) and pwrite(2) are available */\n+#define HAVE_PREADWRITE 1\n+\n+/* readahead(2) is available (linux) */\n+/* #undef HAVE_READAHEAD */\n+\n+/* sendfile(2) is available and supported */\n+#define HAVE_SENDFILE 1\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#define HAVE_STDINT_H 1\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#define HAVE_STDLIB_H 1\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#define HAVE_STRINGS_H 1\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#define HAVE_STRING_H 1\n+\n+/* sync_file_range(2) is available */\n+/* #undef HAVE_SYNC_FILE_RANGE */\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#define HAVE_SYS_STAT_H 1\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#define HAVE_SYS_TYPES_H 1\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#define HAVE_UNISTD_H 1\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#define LT_OBJDIR \".libs/\"\n+\n+/* Name of package */\n+#define PACKAGE \"libeio\"\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#define PACKAGE_BUGREPORT \"\"\n+\n+/* Define to the full name of this package. */\n+#define PACKAGE_NAME \"\"\n+\n+/* Define to the full name and version of this package. */\n+#define PACKAGE_STRING \"\"\n+\n+/* Define to the one symbol short name of this package. */\n+#define PACKAGE_TARNAME \"\"\n+\n+/* Define to the home page for this package. */\n+#define PACKAGE_URL \"\"\n+\n+/* Define to the version of this package. */\n+#define PACKAGE_VERSION \"\"\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#define STDC_HEADERS 1\n+\n+/* Version number of package */\n+#define VERSION \"1.0\""}, {"sha": "b740cdd878770f011278a9ddaeef240928d7483e", "filename": "src/rt/libuv/src/eio/config_freebsd.h", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfig_freebsd.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfig_freebsd.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfig_freebsd.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,78 @@\n+/* config.h.  Generated from config.h.in by configure.  */\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#define HAVE_DLFCN_H 1\n+\n+/* fdatasync(2) is available */\n+/* #undef HAVE_FDATASYNC */\n+\n+/* futimes(2) is available */\n+#define HAVE_FUTIMES 1\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#define HAVE_INTTYPES_H 1\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#define HAVE_MEMORY_H 1\n+\n+/* pread(2) and pwrite(2) are available */\n+#define HAVE_PREADWRITE 1\n+\n+/* readahead(2) is available (linux) */\n+/* #undef HAVE_READAHEAD */\n+\n+/* sendfile(2) is available and supported */\n+#define HAVE_SENDFILE 1\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#define HAVE_STDINT_H 1\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#define HAVE_STDLIB_H 1\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#define HAVE_STRINGS_H 1\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#define HAVE_STRING_H 1\n+\n+/* sync_file_range(2) is available */\n+/* #undef HAVE_SYNC_FILE_RANGE */\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#define HAVE_SYS_STAT_H 1\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#define HAVE_SYS_TYPES_H 1\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#define HAVE_UNISTD_H 1\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#define LT_OBJDIR \".libs/\"\n+\n+/* Name of package */\n+#define PACKAGE \"libeio\"\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#define PACKAGE_BUGREPORT \"\"\n+\n+/* Define to the full name of this package. */\n+#define PACKAGE_NAME \"\"\n+\n+/* Define to the full name and version of this package. */\n+#define PACKAGE_STRING \"\"\n+\n+/* Define to the one symbol short name of this package. */\n+#define PACKAGE_TARNAME \"\"\n+\n+/* Define to the version of this package. */\n+#define PACKAGE_VERSION \"\"\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#define STDC_HEADERS 1\n+\n+/* Version number of package */\n+#define VERSION \"1.0\""}, {"sha": "9823f6240852638c5b4bd6950f0b74a06ca787e8", "filename": "src/rt/libuv/src/eio/config_linux.h", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfig_linux.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfig_linux.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfig_linux.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,89 @@\n+/* config.h.  Generated from config.h.in by configure.  */\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+#include <linux/version.h>\n+\n+#define LINUX_VERSION_CODE_FOR(major, minor, patch) \\\n+  (((major & 255) << 16) | ((minor & 255) << 8) | (patch & 255))\n+\n+#define LINUX_VERSION_AT_LEAST(major, minor, patch) \\\n+  (LINUX_VERSION_CODE >= LINUX_VERSION_CODE_FOR(major, minor, patch))\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#define HAVE_DLFCN_H 1\n+\n+/* fdatasync(2) is available */\n+#define HAVE_FDATASYNC 1\n+\n+/* futimes(2) is available */\n+#define HAVE_FUTIMES 1\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#define HAVE_INTTYPES_H 1\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#define HAVE_MEMORY_H 1\n+\n+/* pread(2) and pwrite(2) are available */\n+#define HAVE_PREADWRITE 1\n+\n+/* readahead(2) is available (linux) */\n+#define HAVE_READAHEAD 1\n+\n+/* sendfile(2) is available and supported */\n+#define HAVE_SENDFILE 1\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#define HAVE_STDINT_H 1\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#define HAVE_STDLIB_H 1\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#define HAVE_STRINGS_H 1\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#define HAVE_STRING_H 1\n+\n+/* sync_file_range(2) is available */\n+#define HAVE_SYNC_FILE_RANGE LINUX_VERSION_AT_LEAST(2, 6, 17)\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#define HAVE_SYS_STAT_H 1\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#define HAVE_SYS_TYPES_H 1\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#define HAVE_UNISTD_H 1\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#define LT_OBJDIR \".libs/\"\n+\n+/* Name of package */\n+#define PACKAGE \"libeio\"\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#define PACKAGE_BUGREPORT \"\"\n+\n+/* Define to the full name of this package. */\n+#define PACKAGE_NAME \"\"\n+\n+/* Define to the full name and version of this package. */\n+#define PACKAGE_STRING \"\"\n+\n+/* Define to the one symbol short name of this package. */\n+#define PACKAGE_TARNAME \"\"\n+\n+/* Define to the home page for this package. */\n+#define PACKAGE_URL \"\"\n+\n+/* Define to the version of this package. */\n+#define PACKAGE_VERSION \"\"\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#define STDC_HEADERS 1\n+\n+/* Version number of package */\n+#define VERSION \"1.0\""}, {"sha": "8f878efd95685dab7b8ce97f390da0dfaf2ce1b8", "filename": "src/rt/libuv/src/eio/config_sunos.h", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfig_sunos.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfig_sunos.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfig_sunos.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,81 @@\n+/* config.h.  Generated from config.h.in by configure.  */\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#define HAVE_DLFCN_H 1\n+\n+/* fdatasync(2) is available */\n+#define HAVE_FDATASYNC 1\n+\n+/* futimes(2) is available */\n+/* #undef HAVE_FUTIMES */\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#define HAVE_INTTYPES_H 1\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#define HAVE_MEMORY_H 1\n+\n+/* pread(2) and pwrite(2) are available */\n+#define HAVE_PREADWRITE 1\n+\n+/* readahead(2) is available (linux) */\n+/* #undef HAVE_READAHEAD */\n+\n+/* sendfile(2) is available and supported */\n+/* #undef HAVE_SENDFILE */\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#define HAVE_STDINT_H 1\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#define HAVE_STDLIB_H 1\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#define HAVE_STRINGS_H 1\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#define HAVE_STRING_H 1\n+\n+/* sync_file_range(2) is available */\n+/* #undef HAVE_SYNC_FILE_RANGE */\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#define HAVE_SYS_STAT_H 1\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#define HAVE_SYS_TYPES_H 1\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#define HAVE_UNISTD_H 1\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#define LT_OBJDIR \".libs/\"\n+\n+/* Name of package */\n+#define PACKAGE \"libeio\"\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#define PACKAGE_BUGREPORT \"\"\n+\n+/* Define to the full name of this package. */\n+#define PACKAGE_NAME \"\"\n+\n+/* Define to the full name and version of this package. */\n+#define PACKAGE_STRING \"\"\n+\n+/* Define to the one symbol short name of this package. */\n+#define PACKAGE_TARNAME \"\"\n+\n+/* Define to the home page for this package. */\n+#define PACKAGE_URL \"\"\n+\n+/* Define to the version of this package. */\n+#define PACKAGE_VERSION \"\"\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#define STDC_HEADERS 1\n+\n+/* Version number of package */\n+#define VERSION \"1.0\""}, {"sha": "9f4cea9d12d2ace8da7c9bcf49cf2a3f19c3e5e1", "filename": "src/rt/libuv/src/eio/configure.ac", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfigure.ac", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fconfigure.ac?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,22 @@\n+AC_PREREQ(2.59)\n+AC_INIT\n+AC_CONFIG_SRCDIR([eio.h])\n+AC_CONFIG_HEADERS([config.h])\n+\n+AM_INIT_AUTOMAKE(libeio,1.0)\n+AM_MAINTAINER_MODE\n+AC_PROG_LIBTOOL\n+\n+AC_PROG_CC\n+\n+if test \"x$GCC\" = xyes ; then\n+  CFLAGS=\"$CFLAGS -O3\"\n+fi\n+\n+dnl somebody will forgive me\n+CFLAGS=\"-D_GNU_SOURCE $CFLAGS\"\n+\n+m4_include([libeio.m4])\n+\n+AC_CONFIG_FILES([Makefile])\n+AC_OUTPUT"}, {"sha": "cbef59557fe0282dabc3df7bb42163f2ea8acac3", "filename": "src/rt/libuv/src/eio/demo.c", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fdemo.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fdemo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fdemo.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "patch": "@@ -0,0 +1,194 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <poll.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <fcntl.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#include \"eio.h\"\n+\n+int respipe [2];\n+\n+void\n+want_poll (void)\n+{\n+  char dummy;\n+  printf (\"want_poll ()\\n\");\n+  write (respipe [1], &dummy, 1);\n+}\n+\n+void\n+done_poll (void)\n+{\n+  char dummy;\n+  printf (\"done_poll ()\\n\");\n+  read (respipe [0], &dummy, 1);\n+}\n+\n+void\n+event_loop (void)\n+{\n+  // an event loop. yeah.\n+  struct pollfd pfd;\n+  pfd.fd     = respipe [0];\n+  pfd.events = POLLIN;\n+\n+  printf (\"\\nentering event loop\\n\");\n+  while (eio_nreqs ())\n+    {\n+      poll (&pfd, 1, -1);\n+      printf (\"eio_poll () = %d\\n\", eio_poll ());\n+    }\n+  printf (\"leaving event loop\\n\");\n+}\n+\n+int\n+res_cb (eio_req *req)\n+{\n+  printf (\"res_cb(%d|%s) = %d\\n\", req->type, req->data ? req->data : \"?\", EIO_RESULT (req));\n+\n+  if (req->result < 0)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+int\n+readdir_cb (eio_req *req)\n+{\n+  char *buf = (char *)EIO_BUF (req);\n+\n+  printf (\"readdir_cb = %d\\n\", EIO_RESULT (req));\n+\n+  if (EIO_RESULT (req) < 0)\n+    return 0;\n+\n+  while (EIO_RESULT (req)--)\n+    {\n+      printf (\"readdir = <%s>\\n\", buf);\n+      buf += strlen (buf) + 1;\n+    }\n+\n+  return 0;\n+}\n+\n+int\n+stat_cb (eio_req *req)\n+{\n+  struct stat *buf = EIO_STAT_BUF (req);\n+\n+  if (req->type == EIO_FSTAT)\n+    printf (\"fstat_cb = %d\\n\", EIO_RESULT (req));\n+  else\n+    printf (\"stat_cb(%s) = %d\\n\", EIO_PATH (req), EIO_RESULT (req));\n+\n+  if (!EIO_RESULT (req))\n+    printf (\"stat size %d perm 0%o\\n\", buf->st_size, buf->st_mode & 0777);\n+\n+  return 0;\n+}\n+\n+int\n+read_cb (eio_req *req)\n+{\n+  unsigned char *buf = (unsigned char *)EIO_BUF (req);\n+\n+  printf (\"read_cb = %d (%02x%02x%02x%02x %02x%02x%02x%02x)\\n\",\n+          EIO_RESULT (req),\n+          buf [0], buf [1], buf [2], buf [3],\n+          buf [4], buf [5], buf [6], buf [7]);\n+\n+  return 0;\n+}\n+\n+int last_fd;\n+\n+int\n+open_cb (eio_req *req)\n+{\n+  printf (\"open_cb = %d\\n\", EIO_RESULT (req));\n+\n+  last_fd = EIO_RESULT (req);\n+\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{\n+  printf (\"pipe ()\\n\");\n+  if (pipe (respipe)) abort ();\n+\n+  printf (\"eio_init ()\\n\");\n+  if (eio_init (want_poll, done_poll)) abort ();\n+\n+  do\n+    {\n+      /* avoid relative paths yourself(!) */\n+      eio_mkdir (\"eio-test-dir\", 0777, 0, res_cb, \"mkdir\");\n+      eio_nop (0, res_cb, \"nop\");\n+      event_loop ();\n+\n+      eio_stat (\"eio-test-dir\", 0, stat_cb, \"stat\");\n+      eio_lstat (\"eio-test-dir\", 0, stat_cb, \"stat\");\n+      eio_open (\"eio-test-dir/eio-test-file\", O_RDWR | O_CREAT, 0777, 0, open_cb, \"open\");\n+      eio_symlink (\"test\", \"eio-test-dir/eio-symlink\", 0, res_cb, \"symlink\");\n+      eio_mknod (\"eio-test-dir/eio-fifo\", S_IFIFO, 0, 0, res_cb, \"mknod\");\n+      event_loop ();\n+\n+      eio_utime (\"eio-test-dir\", 12345.678, 23456.789, 0, res_cb, \"utime\");\n+      eio_futime (last_fd, 92345.678, 93456.789, 0, res_cb, \"futime\");\n+      eio_chown (\"eio-test-dir\", getuid (), getgid (), 0, res_cb, \"chown\");\n+      eio_fchown (last_fd, getuid (), getgid (), 0, res_cb, \"fchown\");\n+      eio_fchmod (last_fd, 0723, 0, res_cb, \"fchmod\");\n+      eio_readdir (\"eio-test-dir\", 0, 0, readdir_cb, \"readdir\");\n+      eio_readdir (\"/nonexistant\", 0, 0, readdir_cb, \"readdir\");\n+      eio_fstat (last_fd, 0, stat_cb, \"stat\");\n+      eio_write (last_fd, \"test\\nfail\\n\", 10, 4, 0, res_cb, \"write\");\n+      event_loop ();\n+\n+      eio_read (last_fd, 0, 8, 0, EIO_PRI_DEFAULT, read_cb, \"read\");\n+      eio_readlink (\"eio-test-dir/eio-symlink\", 0, res_cb, \"readlink\");\n+      event_loop ();\n+\n+      eio_dup2 (1, 2, EIO_PRI_DEFAULT, res_cb, \"dup\"); // dup stdout to stderr\n+      eio_chmod (\"eio-test-dir\", 0765, 0, res_cb, \"chmod\");\n+      eio_ftruncate (last_fd, 9, 0, res_cb, \"ftruncate\");\n+      eio_fdatasync (last_fd, 0, res_cb, \"fdatasync\");\n+      eio_fsync (last_fd, 0, res_cb, \"fsync\");\n+      eio_sync (0, res_cb, \"sync\");\n+      eio_busy (0.5, 0, res_cb, \"busy\");\n+      event_loop ();\n+\n+      eio_sendfile (1, last_fd, 4, 5, 0, res_cb, \"sendfile\"); // write \"test\\n\" to stdout\n+      eio_fstat (last_fd, 0, stat_cb, \"stat\");\n+      event_loop ();\n+\n+      eio_truncate (\"eio-test-dir/eio-test-file\", 6, 0, res_cb, \"truncate\");\n+      eio_readahead (last_fd, 0, 64, 0, res_cb, \"readahead\");\n+      event_loop ();\n+\n+      eio_close (last_fd, 0, res_cb, \"close\");\n+      eio_link (\"eio-test-dir/eio-test-file\", \"eio-test-dir/eio-test-file-2\", 0, res_cb, \"link\");\n+      event_loop ();\n+\n+      eio_rename (\"eio-test-dir/eio-test-file\", \"eio-test-dir/eio-test-file-renamed\", 0, res_cb, \"rename\");\n+      event_loop ();\n+\n+      eio_unlink (\"eio-test-dir/eio-fifo\", 0, res_cb, \"unlink\");\n+      eio_unlink (\"eio-test-dir/eio-symlink\", 0, res_cb, \"unlink\");\n+      eio_unlink (\"eio-test-dir/eio-test-file-2\", 0, res_cb, \"unlink\");\n+      eio_unlink (\"eio-test-dir/eio-test-file-renamed\", 0, res_cb, \"unlink\");\n+      event_loop ();\n+\n+      eio_rmdir (\"eio-test-dir\", 0, res_cb, \"rmdir\");\n+      event_loop ();\n+    }\n+  while (0);\n+\n+  return 0;\n+}\n+"}, {"sha": "ec5bde33e1aec5e90582e23519fcc81a75517f8b", "filename": "src/rt/libuv/src/eio/eio.3", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Feio.3", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Feio.3", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2Feio.3?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "7f48add4019cbf28ed147d87e3eee4b36417c3bc", "filename": "src/rt/libuv/src/eio/eio.c", "status": "added", "additions": 2133, "deletions": 0, "changes": 2133, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Feio.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Feio.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2Feio.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "c83768ebf1910ce9d733b0a956dafac2cfbf8589", "filename": "src/rt/libuv/src/eio/eio.pod", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Feio.pod", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Feio.pod", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2Feio.pod?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "5302cfcc91ad6adbe63784807be356822574b99c", "filename": "src/rt/libuv/src/eio/libeio.m4", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Flibeio.m4", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Flibeio.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2Flibeio.m4?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "01e2933507da20f6ad93f851ae46ae443b7cf582", "filename": "src/rt/libuv/src/eio/xthread.h", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fxthread.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fxthread.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fxthread.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "d6fca2f67cde91d0c45c9d2e4fbf450d7fb95c6c", "filename": "src/rt/libuv/src/ev/Changes", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2FChanges", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2FChanges", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2FChanges?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/Changes"}, {"sha": "7fa0e9f844f0bcc1f34a48c63b2388b02ac5d9e6", "filename": "src/rt/libuv/src/ev/LICENSE", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2FLICENSE", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2FLICENSE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2FLICENSE?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/LICENSE"}, {"sha": "058c2cb0c1efc542c9539bcde4499524d6eaa102", "filename": "src/rt/libuv/src/ev/Makefile.am", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2FMakefile.am", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2FMakefile.am", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2FMakefile.am?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/Makefile.am"}, {"sha": "9817a7ebd7f4331b09a5fff5dc5b40dd35c1d778", "filename": "src/rt/libuv/src/ev/Makefile.in", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2FMakefile.in?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/Makefile.in"}, {"sha": "ca403c6f470494320d5de96f75f16f99946c68ac", "filename": "src/rt/libuv/src/ev/README", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2FREADME?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/README"}, {"sha": "18abb73686c0dfdbc293e38d58bb25852c698ee1", "filename": "src/rt/libuv/src/ev/aclocal.m4", "status": "added", "additions": 8957, "deletions": 0, "changes": 8957, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Faclocal.m4", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Faclocal.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Faclocal.m4?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "087d2aa4e963b767adc7a08d828852875e436686", "filename": "src/rt/libuv/src/ev/autogen.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fautogen.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fautogen.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fautogen.sh?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/autogen.sh"}, {"sha": "f32079abda668e5fc8f8de6f226e7b26384e8a03", "filename": "src/rt/libuv/src/ev/config.guess", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig.guess", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig.guess", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig.guess?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/config.guess"}, {"sha": "75da15cce7e7552e5770d1a1ca44f42762c9587b", "filename": "src/rt/libuv/src/ev/config.h.in", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig.h.in", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig.h.in?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/config.h.in"}, {"sha": "6759825a5b7fcf64476b4398dc0e30b3090b925c", "filename": "src/rt/libuv/src/ev/config.sub", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig.sub", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig.sub", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig.sub?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/config.sub"}, {"sha": "1f6f6d98c815e28d66bcbb23c8a3188ff7f3a2b3", "filename": "src/rt/libuv/src/ev/config_cygwin.h", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig_cygwin.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig_cygwin.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig_cygwin.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "03e3b219ec98ecf939dd47d8bdeb990cab564314", "filename": "src/rt/libuv/src/ev/config_darwin.h", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig_darwin.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig_darwin.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig_darwin.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "ebebd4156d2e036e1e101e7868b5caac1344f86b", "filename": "src/rt/libuv/src/ev/config_freebsd.h", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig_freebsd.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig_freebsd.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig_freebsd.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "b147b591c4334b0e02eb07ae45243ad95a30e9db", "filename": "src/rt/libuv/src/ev/config_linux.h", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig_linux.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig_linux.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig_linux.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "9f8861d8a369219be47c314e18d738005e2049f4", "filename": "src/rt/libuv/src/ev/config_sunos.h", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig_sunos.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig_sunos.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfig_sunos.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "98f102f1e42ed1f005a751278302ff5ea66e95d9", "filename": "src/rt/libuv/src/ev/configure", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfigure", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfigure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfigure?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/configure"}, {"sha": "03a784f2eba9bcc262637747cc3984b3d4eb2c8f", "filename": "src/rt/libuv/src/ev/configure.ac", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfigure.ac", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fconfigure.ac?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/configure.ac"}, {"sha": "df8eea7e4ce8862105fcd7929b20bdb45488048b", "filename": "src/rt/libuv/src/ev/depcomp", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fdepcomp", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fdepcomp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fdepcomp?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/depcomp"}, {"sha": "ce42b5f2de0ef0241d258db609f26eab72f4b2eb", "filename": "src/rt/libuv/src/ev/ev++.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev%2B%2B.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev%2B%2B.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev%2B%2B.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/ev++.h"}, {"sha": "f2a4514582eb89bd724adb6e3dae9e0d49006f44", "filename": "src/rt/libuv/src/ev/ev.3", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev.3", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev.3", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev.3?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/ev.3"}, {"sha": "4187b18af730dd72179d902f3cc6d0ac2637ce41", "filename": "src/rt/libuv/src/ev/ev.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/ev.c"}, {"sha": "4bbef1fcf25b3deb62c8a31bb4fddd2b844c598b", "filename": "src/rt/libuv/src/ev/ev.pod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev.pod", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev.pod", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev.pod?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/ev.pod"}, {"sha": "5deb65211181541bbac3f7082856ccdeef3beeba", "filename": "src/rt/libuv/src/ev/ev_epoll.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_epoll.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_epoll.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_epoll.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/ev_epoll.c"}, {"sha": "1b526d1c7bc0ded3fb3cc8e0124ec9f85b50ebc5", "filename": "src/rt/libuv/src/ev/ev_kqueue.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_kqueue.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_kqueue.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_kqueue.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/ev_kqueue.c"}, {"sha": "e53ae0de93c6055e2346e1a5d02afab295ea3e20", "filename": "src/rt/libuv/src/ev/ev_poll.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_poll.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_poll.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_poll.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/ev_poll.c"}, {"sha": "0ffebc372672866e3bfde9abe18cbf717b32a24f", "filename": "src/rt/libuv/src/ev/ev_port.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_port.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_port.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_port.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/ev_port.c"}, {"sha": "0ea9467e4015a5df7fcf1de9536f8f8d803cdaf6", "filename": "src/rt/libuv/src/ev/ev_select.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_select.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_select.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_select.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/ev_select.c"}, {"sha": "5ee3ed1b2a0eb2368cce927ba8af84bf37d8898f", "filename": "src/rt/libuv/src/ev/ev_vars.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_vars.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_vars.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_vars.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/ev_vars.h"}, {"sha": "338886efe407cfba00e33a1e425cc90d4d760a0c", "filename": "src/rt/libuv/src/ev/ev_win32.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_win32.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_win32.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_win32.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/ev_win32.c"}, {"sha": "2c195c5db4b2f8e65de6e55603b9752f3729b24b", "filename": "src/rt/libuv/src/ev/ev_wrap.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_wrap.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_wrap.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fev_wrap.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/ev_wrap.h"}, {"sha": "aaf6d534ca45f8c2c7041e3329bbda88a1d08ad6", "filename": "src/rt/libuv/src/ev/event.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fevent.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fevent.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fevent.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/event.c"}, {"sha": "10ff05a3cb4d64a397bb3aada943f2836858161a", "filename": "src/rt/libuv/src/ev/event.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fevent.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fevent.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fevent.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/event.h"}, {"sha": "6ce63b9f76bc6ab5ff08f967f52f8cf4c53a1353", "filename": "src/rt/libuv/src/ev/install-sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Finstall-sh", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Finstall-sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Finstall-sh?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/install-sh"}, {"sha": "e3f4c81b236d53a9f0ea2aa965a4264b2958bfcd", "filename": "src/rt/libuv/src/ev/libev.m4", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Flibev.m4", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Flibev.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Flibev.m4?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/libev.m4"}, {"sha": "d88da2c264c8c312b286a83ae06d688d5287361a", "filename": "src/rt/libuv/src/ev/ltmain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fltmain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fltmain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fltmain.sh?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/ltmain.sh"}, {"sha": "fc54c64ec969d9c1630335d8a88c5d72d3ca0856", "filename": "src/rt/libuv/src/ev/missing", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fmissing", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fmissing", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fmissing?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/missing"}, {"sha": "d2d5f21b611235316317197d3a32c2dff5897a6f", "filename": "src/rt/libuv/src/ev/mkinstalldirs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fmkinstalldirs", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fmkinstalldirs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fev%2Fmkinstalldirs?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/ev/mkinstalldirs"}, {"sha": "2c4e0cc765954888ae3d1d444fc005433db73237", "filename": "src/rt/libuv/src/uv-common.c", "status": "renamed", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/uv-common.c"}, {"sha": "74b4c4e38bb1081f1c4304c3e95c196b50ba144d", "filename": "src/rt/libuv/src/uv-common.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "d56a8e839ba913f492c8df7efd16e7f8b68ae184", "filename": "src/rt/libuv/src/uv-cygwin.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-cygwin.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-cygwin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-cygwin.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "fa2948cd2177dd0dd1cc2120ab697762a4ff2251", "filename": "src/rt/libuv/src/uv-darwin.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-darwin.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-darwin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-darwin.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "b07735cad8a5030f8e134124c57cd431bccd214e", "filename": "src/rt/libuv/src/uv-eio.c", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-eio.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-eio.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-eio.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "2f2d3486bf3037ab7f138f708f0e31855e1aae8f", "filename": "src/rt/libuv/src/uv-eio.h", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-eio.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-eio.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-eio.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "108455d8804d8ec0d5406b9fd7eb0635c89ca693", "filename": "src/rt/libuv/src/uv-freebsd.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-freebsd.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-freebsd.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-freebsd.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "dc718c6decda985fe6ca0e127deb5ec79a9378a4", "filename": "src/rt/libuv/src/uv-linux.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-linux.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-linux.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-linux.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "4a75461413ebd2244b4d7d6e5268e8a063a31a8a", "filename": "src/rt/libuv/src/uv-sunos.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-sunos.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-sunos.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-sunos.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "e29c842bfae05a94bd3cc462b2914df3dfa31750", "filename": "src/rt/libuv/src/uv-unix.c", "status": "renamed", "additions": 427, "deletions": 132, "changes": 559, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-unix.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-unix.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-unix.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/uv-unix.c"}, {"sha": "93bf64d193c3d79f3b92e4863eef0d4747529069", "filename": "src/rt/libuv/src/uv-win.c", "status": "renamed", "additions": 954, "deletions": 265, "changes": 1219, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-win.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Fsrc%2Fuv-win.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-win.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33", "previous_filename": "src/rt/libuv/uv-win.c"}, {"sha": "c3f538bff95fed1de7a809bb4a887a2e5d9228a6", "filename": "src/rt/libuv/test/benchmark-ares.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ares.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ares.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ares.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "ba859c3c82e22fb896a399b306fd4f02e714006d", "filename": "src/rt/libuv/test/benchmark-getaddrinfo.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-getaddrinfo.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-getaddrinfo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-getaddrinfo.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "6040e90a32607b0a24919edcd857f11c8eb10f38", "filename": "src/rt/libuv/test/benchmark-list.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-list.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-list.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "7124a3614a465638897b5a65f3cfdbbb06798e26", "filename": "src/rt/libuv/test/benchmark-ping-pongs.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ping-pongs.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ping-pongs.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ping-pongs.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "cd9c7d996791e8ca48104531dce9ec26ed6c6b8d", "filename": "src/rt/libuv/test/benchmark-pump.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pump.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pump.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pump.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "830de3a007c2f5e2d481316a1feaa989e36a81f8", "filename": "src/rt/libuv/test/benchmark-sizes.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-sizes.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-sizes.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-sizes.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "361c9d080bae8fc65a2b888e4101ae0e5e5befd6", "filename": "src/rt/libuv/test/dns-server.c", "status": "added", "additions": 325, "deletions": 0, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Fdns-server.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Fdns-server.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fdns-server.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "9addc546c1e66abc0cdef2a94825de6a07225f17", "filename": "src/rt/libuv/test/echo-server.c", "status": "modified", "additions": 47, "deletions": 13, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Fecho-server.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Fecho-server.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fecho-server.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "fa4c63bb2086b31e1a7e92a58e8f6fd0904d1586", "filename": "src/rt/libuv/test/runner-unix.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Frunner-unix.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Frunner-unix.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frunner-unix.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "a9933fdcb1498a1de790a333cffae1b79cbd245d", "filename": "src/rt/libuv/test/test-async.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-async.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-async.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-async.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "4ac60654f6d894f83044c5fc8f7ebe64a9cbe186", "filename": "src/rt/libuv/test/test-bind-error.c", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-bind-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-bind-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-bind-error.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "6072dcdc090cd9a8d0ea0fb70a3f3cbc6e518ea4", "filename": "src/rt/libuv/test/test-bind6-error.c", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-bind6-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-bind6-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-bind6-error.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "5b12c8b9b420852f83621b92f0e97bf684a3edc0", "filename": "src/rt/libuv/test/test-callback-stack.c", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-callback-stack.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-callback-stack.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-callback-stack.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "9fc3f0ba6eb07ee04e4c86d062e965cda5735096", "filename": "src/rt/libuv/test/test-connection-fail.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-connection-fail.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-connection-fail.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-connection-fail.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "eabf4818959bf72cc199c4bf25d73979f5fd278d", "filename": "src/rt/libuv/test/test-delayed-accept.c", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-delayed-accept.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-delayed-accept.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-delayed-accept.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "1dc85565590daee33e02c7d7415df8be487d3283", "filename": "src/rt/libuv/test/test-get-currentexe.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-get-currentexe.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-get-currentexe.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-get-currentexe.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "a33e3d075cc937563fc6481b33555dc378500b44", "filename": "src/rt/libuv/test/test-getaddrinfo.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-getaddrinfo.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-getaddrinfo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-getaddrinfo.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "cbd25343bbbe112e8169dbdf4167ca488dc7d49b", "filename": "src/rt/libuv/test/test-gethostbyname.c", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-gethostbyname.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-gethostbyname.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-gethostbyname.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "4d96e3331ec797f64c2f962f8a420c96193681e4", "filename": "src/rt/libuv/test/test-hrtime.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-hrtime.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-hrtime.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-hrtime.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "190574acaa86ec0df5e4500dfd38ae2987aaa88a", "filename": "src/rt/libuv/test/test-list.h", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-list.h", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-list.h?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "7979a74b4aed721bc76407d50c3215df2df6c04a", "filename": "src/rt/libuv/test/test-loop-handles.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-loop-handles.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-loop-handles.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-loop-handles.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "34de78b5b6c5d975926ad70ad4f0f578e6448f64", "filename": "src/rt/libuv/test/test-ping-pong.c", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-ping-pong.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-ping-pong.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-ping-pong.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "8a960c9ea6a93004deef3303a7a04fce9c132864", "filename": "src/rt/libuv/test/test-shutdown-eof.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-shutdown-eof.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-shutdown-eof.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-shutdown-eof.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "4e305a9f33de2eabafe8544daf6a3e6a3ab534c5", "filename": "src/rt/libuv/test/test-tcp-writealot.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-writealot.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-writealot.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-writealot.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "e083b01ced13f1b86c6fbaf416901300dad860a3", "filename": "src/rt/libuv/test/test-timer-again.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-timer-again.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-timer-again.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-timer-again.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "c62a8c68dbc9d7ff834fe9b798bf7e2405def882", "filename": "src/rt/libuv/test/test-timer.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-timer.c", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Flibuv%2Ftest%2Ftest-timer.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-timer.c?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}, {"sha": "d0d98aa5090e88f1a60c6c445edf0d8a4fd30c08", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8229c3fa752c7fca3760245da4e23ba67acdee33/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=8229c3fa752c7fca3760245da4e23ba67acdee33"}]}