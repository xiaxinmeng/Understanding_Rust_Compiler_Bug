{"sha": "b5995b4e93237fe0d1c0ea76e33eb2429f654487", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1OTk1YjRlOTMyMzdmZTBkMWMwZWE3NmUzM2ViMjQyOWY2NTQ0ODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-21T17:46:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-21T17:46:49Z"}, "message": "auto merge of #12326 : bjz/rust/integer, r=alexcrichton\n\nThis is part of the effort to simplify `std::num`, as tracked in issue #10387.", "tree": {"sha": "0a71ca876e0bdd52f90f6f0a0b24c766ea4ce82d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a71ca876e0bdd52f90f6f0a0b24c766ea4ce82d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5995b4e93237fe0d1c0ea76e33eb2429f654487", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5995b4e93237fe0d1c0ea76e33eb2429f654487", "html_url": "https://github.com/rust-lang/rust/commit/b5995b4e93237fe0d1c0ea76e33eb2429f654487", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5995b4e93237fe0d1c0ea76e33eb2429f654487/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8893ed5d97180dc51d82df1bdbab989c4bde46d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8893ed5d97180dc51d82df1bdbab989c4bde46d", "html_url": "https://github.com/rust-lang/rust/commit/f8893ed5d97180dc51d82df1bdbab989c4bde46d"}, {"sha": "3a9eca3a7be3ea156147fb8ed00a6447112e74d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a9eca3a7be3ea156147fb8ed00a6447112e74d7", "html_url": "https://github.com/rust-lang/rust/commit/3a9eca3a7be3ea156147fb8ed00a6447112e74d7"}], "stats": {"total": 860, "additions": 439, "deletions": 421}, "files": [{"sha": "d17f8fc2d877e6f149bb3bf026b5c8de9b309af9", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=b5995b4e93237fe0d1c0ea76e33eb2429f654487", "patch": "@@ -85,7 +85,7 @@ syn keyword rustTrait Iterator DoubleEndedIterator RandomAccessIterator Cloneabl\n syn keyword rustTrait OrdIterator MutableDoubleEndedIterator ExactSize\n \n syn keyword rustTrait Algebraic Trigonometric Exponential Hyperbolic\n-syn keyword rustTrait Bitwise Bounded Integer\n+syn keyword rustTrait Bitwise Bounded Fractional\n syn keyword rustTrait Num NumCast CheckedAdd CheckedSub CheckedMul CheckedDiv\n syn keyword rustTrait Orderable Signed Unsigned Round\n syn keyword rustTrait Primitive Int Float ToStrRadix ToPrimitive FromPrimitive"}, {"sha": "0418c61d361b4d7ff3c6f12d0d732f843405e0a5", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=b5995b4e93237fe0d1c0ea76e33eb2429f654487", "patch": "@@ -16,6 +16,8 @@ A `BigUint` is represented as an array of `BigDigit`s.\n A `BigInt` is a combination of `BigUint` and `Sign`.\n */\n \n+use Integer;\n+\n use std::cmp;\n use std::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use std::num::{Zero, One, ToStrRadix, FromStrRadix};\n@@ -461,7 +463,7 @@ impl Integer for BigUint {\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n     #[inline]\n-    fn is_multiple_of(&self, other: &BigUint) -> bool { (*self % *other).is_zero() }\n+    fn divides(&self, other: &BigUint) -> bool { (*self % *other).is_zero() }\n \n     /// Returns `true` if the number is divisible by `2`\n     #[inline]\n@@ -1118,7 +1120,7 @@ impl Integer for BigInt {\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n     #[inline]\n-    fn is_multiple_of(&self, other: &BigInt) -> bool { self.data.is_multiple_of(&other.data) }\n+    fn divides(&self, other: &BigInt) -> bool { self.data.divides(&other.data) }\n \n     /// Returns `true` if the number is divisible by `2`\n     #[inline]\n@@ -1388,6 +1390,7 @@ impl BigInt {\n \n #[cfg(test)]\n mod biguint_tests {\n+    use Integer;\n     use super::{BigDigit, BigUint, ToBigUint};\n     use super::{Plus, BigInt, RandBigInt, ToBigInt};\n \n@@ -2045,6 +2048,7 @@ mod biguint_tests {\n \n #[cfg(test)]\n mod bigint_tests {\n+    use Integer;\n     use super::{BigDigit, BigUint, ToBigUint};\n     use super::{Sign, Minus, Zero, Plus, BigInt, RandBigInt, ToBigInt};\n "}, {"sha": "e9e93cc29d6fe2906ea8b05b67ece030b12dceae", "filename": "src/libnum/lib.rs", "status": "modified", "additions": 400, "deletions": 0, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibnum%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibnum%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Flib.rs?ref=b5995b4e93237fe0d1c0ea76e33eb2429f654487", "patch": "@@ -20,3 +20,403 @@ extern crate extra;\n pub mod bigint;\n pub mod rational;\n pub mod complex;\n+\n+pub trait Integer: Num + Ord\n+                 + Div<Self, Self>\n+                 + Rem<Self, Self> {\n+    /// Simultaneous truncated integer division and modulus\n+    #[inline]\n+    fn div_rem(&self, other: &Self) -> (Self, Self) {\n+        (*self / *other, *self % *other)\n+    }\n+\n+    /// Floored integer division\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~\n+    /// # use num::Integer;\n+    /// assert!(( 8i).div_floor(& 3) ==  2);\n+    /// assert!(( 8i).div_floor(&-3) == -3);\n+    /// assert!((-8i).div_floor(& 3) == -3);\n+    /// assert!((-8i).div_floor(&-3) ==  2);\n+    ///\n+    /// assert!(( 1i).div_floor(& 2) ==  0);\n+    /// assert!(( 1i).div_floor(&-2) == -1);\n+    /// assert!((-1i).div_floor(& 2) == -1);\n+    /// assert!((-1i).div_floor(&-2) ==  0);\n+    /// ~~~\n+    fn div_floor(&self, other: &Self) -> Self;\n+\n+    /// Floored integer modulo, satisfying:\n+    ///\n+    /// ~~~\n+    /// # use num::Integer;\n+    /// # let n = 1i; let d = 1i;\n+    /// assert!(n.div_floor(&d) * d + n.mod_floor(&d) == n)\n+    /// ~~~\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~\n+    /// # use num::Integer;\n+    /// assert!(( 8i).mod_floor(& 3) ==  2);\n+    /// assert!(( 8i).mod_floor(&-3) == -1);\n+    /// assert!((-8i).mod_floor(& 3) ==  1);\n+    /// assert!((-8i).mod_floor(&-3) == -2);\n+    ///\n+    /// assert!(( 1i).mod_floor(& 2) ==  1);\n+    /// assert!(( 1i).mod_floor(&-2) == -1);\n+    /// assert!((-1i).mod_floor(& 2) ==  1);\n+    /// assert!((-1i).mod_floor(&-2) == -1);\n+    /// ~~~\n+    fn mod_floor(&self, other: &Self) -> Self;\n+\n+    /// Simultaneous floored integer division and modulus\n+    fn div_mod_floor(&self, other: &Self) -> (Self, Self) {\n+        (self.div_floor(other), self.mod_floor(other))\n+    }\n+\n+    /// Greatest Common Divisor (GCD)\n+    fn gcd(&self, other: &Self) -> Self;\n+\n+    /// Lowest Common Multiple (LCM)\n+    fn lcm(&self, other: &Self) -> Self;\n+\n+    /// Returns `true` if `other` divides evenly into `self`\n+    fn divides(&self, other: &Self) -> bool;\n+\n+    /// Returns `true` if the number is even\n+    fn is_even(&self) -> bool;\n+\n+    /// Returns `true` if the number is odd\n+    fn is_odd(&self) -> bool;\n+}\n+\n+/// Simultaneous integer division and modulus\n+#[inline] pub fn div_rem<T: Integer>(x: T, y: T) -> (T, T) { x.div_rem(&y) }\n+/// Floored integer division\n+#[inline] pub fn div_floor<T: Integer>(x: T, y: T) -> T { x.div_floor(&y) }\n+/// Floored integer modulus\n+#[inline] pub fn mod_floor<T: Integer>(x: T, y: T) -> T { x.mod_floor(&y) }\n+/// Simultaneous floored integer division and modulus\n+#[inline] pub fn div_mod_floor<T: Integer>(x: T, y: T) -> (T, T) { x.div_mod_floor(&y) }\n+\n+/// Calculates the Greatest Common Divisor (GCD) of the number and `other`. The\n+/// result is always positive.\n+#[inline(always)] pub fn gcd<T: Integer>(x: T, y: T) -> T { x.gcd(&y) }\n+/// Calculates the Lowest Common Multiple (LCM) of the number and `other`.\n+#[inline(always)] pub fn lcm<T: Integer>(x: T, y: T) -> T { x.lcm(&y) }\n+\n+macro_rules! impl_integer_for_int {\n+    ($T:ty, $test_mod:ident) => (\n+        impl Integer for $T {\n+            /// Floored integer division\n+            #[inline]\n+            fn div_floor(&self, other: &$T) -> $T {\n+                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n+                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n+                match self.div_rem(other) {\n+                    (d, r) if (r > 0 && *other < 0)\n+                           || (r < 0 && *other > 0) => d - 1,\n+                    (d, _)                          => d,\n+                }\n+            }\n+\n+            /// Floored integer modulo\n+            #[inline]\n+            fn mod_floor(&self, other: &$T) -> $T {\n+                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n+                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n+                match *self % *other {\n+                    r if (r > 0 && *other < 0)\n+                      || (r < 0 && *other > 0) => r + *other,\n+                    r                          => r,\n+                }\n+            }\n+\n+            /// Calculates `div_floor` and `mod_floor` simultaneously\n+            #[inline]\n+            fn div_mod_floor(&self, other: &$T) -> ($T,$T) {\n+                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n+                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n+                match self.div_rem(other) {\n+                    (d, r) if (r > 0 && *other < 0)\n+                           || (r < 0 && *other > 0) => (d - 1, r + *other),\n+                    (d, r)                          => (d, r),\n+                }\n+            }\n+\n+            /// Calculates the Greatest Common Divisor (GCD) of the number and\n+            /// `other`. The result is always positive.\n+            #[inline]\n+            fn gcd(&self, other: &$T) -> $T {\n+                // Use Euclid's algorithm\n+                let mut m = *self;\n+                let mut n = *other;\n+                while m != 0 {\n+                    let temp = m;\n+                    m = n % temp;\n+                    n = temp;\n+                }\n+                n.abs()\n+            }\n+\n+            /// Calculates the Lowest Common Multiple (LCM) of the number and\n+            /// `other`.\n+            #[inline]\n+            fn lcm(&self, other: &$T) -> $T {\n+                // should not have to recaluculate abs\n+                ((*self * *other) / self.gcd(other)).abs()\n+            }\n+\n+            /// Returns `true` if the number can be divided by `other` without\n+            /// leaving a remainder\n+            #[inline]\n+            fn divides(&self, other: &$T) -> bool { *self % *other == 0 }\n+\n+            /// Returns `true` if the number is divisible by `2`\n+            #[inline]\n+            fn is_even(&self) -> bool { self & 1 == 0 }\n+\n+            /// Returns `true` if the number is not divisible by `2`\n+            #[inline]\n+            fn is_odd(&self) -> bool { !self.is_even() }\n+        }\n+\n+        #[cfg(test)]\n+        mod $test_mod {\n+            use Integer;\n+\n+            /// Checks that the division rule holds for:\n+            ///\n+            /// - `n`: numerator (dividend)\n+            /// - `d`: denominator (divisor)\n+            /// - `qr`: quotient and remainder\n+            #[cfg(test)]\n+            fn test_division_rule((n,d): ($T,$T), (q,r): ($T,$T)) {\n+                assert_eq!(d * q + r, n);\n+            }\n+\n+            #[test]\n+            fn test_div_rem() {\n+                fn test_nd_dr(nd: ($T,$T), qr: ($T,$T)) {\n+                    let (n,d) = nd;\n+                    let separate_div_rem = (n / d, n % d);\n+                    let combined_div_rem = n.div_rem(&d);\n+\n+                    assert_eq!(separate_div_rem, qr);\n+                    assert_eq!(combined_div_rem, qr);\n+\n+                    test_division_rule(nd, separate_div_rem);\n+                    test_division_rule(nd, combined_div_rem);\n+                }\n+\n+                test_nd_dr(( 8,  3), ( 2,  2));\n+                test_nd_dr(( 8, -3), (-2,  2));\n+                test_nd_dr((-8,  3), (-2, -2));\n+                test_nd_dr((-8, -3), ( 2, -2));\n+\n+                test_nd_dr(( 1,  2), ( 0,  1));\n+                test_nd_dr(( 1, -2), ( 0,  1));\n+                test_nd_dr((-1,  2), ( 0, -1));\n+                test_nd_dr((-1, -2), ( 0, -1));\n+            }\n+\n+            #[test]\n+            fn test_div_mod_floor() {\n+                fn test_nd_dm(nd: ($T,$T), dm: ($T,$T)) {\n+                    let (n,d) = nd;\n+                    let separate_div_mod_floor = (n.div_floor(&d), n.mod_floor(&d));\n+                    let combined_div_mod_floor = n.div_mod_floor(&d);\n+\n+                    assert_eq!(separate_div_mod_floor, dm);\n+                    assert_eq!(combined_div_mod_floor, dm);\n+\n+                    test_division_rule(nd, separate_div_mod_floor);\n+                    test_division_rule(nd, combined_div_mod_floor);\n+                }\n+\n+                test_nd_dm(( 8,  3), ( 2,  2));\n+                test_nd_dm(( 8, -3), (-3, -1));\n+                test_nd_dm((-8,  3), (-3,  1));\n+                test_nd_dm((-8, -3), ( 2, -2));\n+\n+                test_nd_dm(( 1,  2), ( 0,  1));\n+                test_nd_dm(( 1, -2), (-1, -1));\n+                test_nd_dm((-1,  2), (-1,  1));\n+                test_nd_dm((-1, -2), ( 0, -1));\n+            }\n+\n+            #[test]\n+            fn test_gcd() {\n+                assert_eq!((10 as $T).gcd(&2), 2 as $T);\n+                assert_eq!((10 as $T).gcd(&3), 1 as $T);\n+                assert_eq!((0 as $T).gcd(&3), 3 as $T);\n+                assert_eq!((3 as $T).gcd(&3), 3 as $T);\n+                assert_eq!((56 as $T).gcd(&42), 14 as $T);\n+                assert_eq!((3 as $T).gcd(&-3), 3 as $T);\n+                assert_eq!((-6 as $T).gcd(&3), 3 as $T);\n+                assert_eq!((-4 as $T).gcd(&-2), 2 as $T);\n+            }\n+\n+            #[test]\n+            fn test_lcm() {\n+                assert_eq!((1 as $T).lcm(&0), 0 as $T);\n+                assert_eq!((0 as $T).lcm(&1), 0 as $T);\n+                assert_eq!((1 as $T).lcm(&1), 1 as $T);\n+                assert_eq!((-1 as $T).lcm(&1), 1 as $T);\n+                assert_eq!((1 as $T).lcm(&-1), 1 as $T);\n+                assert_eq!((-1 as $T).lcm(&-1), 1 as $T);\n+                assert_eq!((8 as $T).lcm(&9), 72 as $T);\n+                assert_eq!((11 as $T).lcm(&5), 55 as $T);\n+            }\n+\n+            #[test]\n+            fn test_even() {\n+                assert_eq!((-4 as $T).is_even(), true);\n+                assert_eq!((-3 as $T).is_even(), false);\n+                assert_eq!((-2 as $T).is_even(), true);\n+                assert_eq!((-1 as $T).is_even(), false);\n+                assert_eq!((0 as $T).is_even(), true);\n+                assert_eq!((1 as $T).is_even(), false);\n+                assert_eq!((2 as $T).is_even(), true);\n+                assert_eq!((3 as $T).is_even(), false);\n+                assert_eq!((4 as $T).is_even(), true);\n+            }\n+\n+            #[test]\n+            fn test_odd() {\n+                assert_eq!((-4 as $T).is_odd(), false);\n+                assert_eq!((-3 as $T).is_odd(), true);\n+                assert_eq!((-2 as $T).is_odd(), false);\n+                assert_eq!((-1 as $T).is_odd(), true);\n+                assert_eq!((0 as $T).is_odd(), false);\n+                assert_eq!((1 as $T).is_odd(), true);\n+                assert_eq!((2 as $T).is_odd(), false);\n+                assert_eq!((3 as $T).is_odd(), true);\n+                assert_eq!((4 as $T).is_odd(), false);\n+            }\n+        }\n+    )\n+}\n+\n+impl_integer_for_int!(i8,   test_integer_i8)\n+impl_integer_for_int!(i16,  test_integer_i16)\n+impl_integer_for_int!(i32,  test_integer_i32)\n+impl_integer_for_int!(i64,  test_integer_i64)\n+impl_integer_for_int!(int,  test_integer_int)\n+\n+macro_rules! impl_integer_for_uint {\n+    ($T:ty, $test_mod:ident) => (\n+        impl Integer for $T {\n+            /// Unsigned integer division. Returns the same result as `div` (`/`).\n+            #[inline]\n+            fn div_floor(&self, other: &$T) -> $T { *self / *other }\n+\n+            /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n+            #[inline]\n+            fn mod_floor(&self, other: &$T) -> $T { *self % *other }\n+\n+            /// Calculates the Greatest Common Divisor (GCD) of the number and `other`\n+            #[inline]\n+            fn gcd(&self, other: &$T) -> $T {\n+                // Use Euclid's algorithm\n+                let mut m = *self;\n+                let mut n = *other;\n+                while m != 0 {\n+                    let temp = m;\n+                    m = n % temp;\n+                    n = temp;\n+                }\n+                n\n+            }\n+\n+            /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n+            #[inline]\n+            fn lcm(&self, other: &$T) -> $T {\n+                (*self * *other) / self.gcd(other)\n+            }\n+\n+            /// Returns `true` if the number can be divided by `other` without leaving a remainder\n+            #[inline]\n+            fn divides(&self, other: &$T) -> bool { *self % *other == 0 }\n+\n+            /// Returns `true` if the number is divisible by `2`\n+            #[inline]\n+            fn is_even(&self) -> bool { self & 1 == 0 }\n+\n+            /// Returns `true` if the number is not divisible by `2`\n+            #[inline]\n+            fn is_odd(&self) -> bool { !self.is_even() }\n+        }\n+\n+        #[cfg(test)]\n+        mod $test_mod {\n+            use Integer;\n+\n+            #[test]\n+            fn test_div_mod_floor() {\n+                assert_eq!((10 as $T).div_floor(&(3 as $T)), 3 as $T);\n+                assert_eq!((10 as $T).mod_floor(&(3 as $T)), 1 as $T);\n+                assert_eq!((10 as $T).div_mod_floor(&(3 as $T)), (3 as $T, 1 as $T));\n+                assert_eq!((5 as $T).div_floor(&(5 as $T)), 1 as $T);\n+                assert_eq!((5 as $T).mod_floor(&(5 as $T)), 0 as $T);\n+                assert_eq!((5 as $T).div_mod_floor(&(5 as $T)), (1 as $T, 0 as $T));\n+                assert_eq!((3 as $T).div_floor(&(7 as $T)), 0 as $T);\n+                assert_eq!((3 as $T).mod_floor(&(7 as $T)), 3 as $T);\n+                assert_eq!((3 as $T).div_mod_floor(&(7 as $T)), (0 as $T, 3 as $T));\n+            }\n+\n+            #[test]\n+            fn test_gcd() {\n+                assert_eq!((10 as $T).gcd(&2), 2 as $T);\n+                assert_eq!((10 as $T).gcd(&3), 1 as $T);\n+                assert_eq!((0 as $T).gcd(&3), 3 as $T);\n+                assert_eq!((3 as $T).gcd(&3), 3 as $T);\n+                assert_eq!((56 as $T).gcd(&42), 14 as $T);\n+            }\n+\n+            #[test]\n+            fn test_lcm() {\n+                assert_eq!((1 as $T).lcm(&0), 0 as $T);\n+                assert_eq!((0 as $T).lcm(&1), 0 as $T);\n+                assert_eq!((1 as $T).lcm(&1), 1 as $T);\n+                assert_eq!((8 as $T).lcm(&9), 72 as $T);\n+                assert_eq!((11 as $T).lcm(&5), 55 as $T);\n+                assert_eq!((99 as $T).lcm(&17), 1683 as $T);\n+            }\n+\n+            #[test]\n+            fn test_divides() {\n+                assert!((6 as $T).divides(&(6 as $T)));\n+                assert!((6 as $T).divides(&(3 as $T)));\n+                assert!((6 as $T).divides(&(1 as $T)));\n+            }\n+\n+            #[test]\n+            fn test_even() {\n+                assert_eq!((0 as $T).is_even(), true);\n+                assert_eq!((1 as $T).is_even(), false);\n+                assert_eq!((2 as $T).is_even(), true);\n+                assert_eq!((3 as $T).is_even(), false);\n+                assert_eq!((4 as $T).is_even(), true);\n+            }\n+\n+            #[test]\n+            fn test_odd() {\n+                assert_eq!((0 as $T).is_odd(), false);\n+                assert_eq!((1 as $T).is_odd(), true);\n+                assert_eq!((2 as $T).is_odd(), false);\n+                assert_eq!((3 as $T).is_odd(), true);\n+                assert_eq!((4 as $T).is_odd(), false);\n+            }\n+        }\n+    )\n+}\n+\n+impl_integer_for_uint!(u8,   test_integer_u8)\n+impl_integer_for_uint!(u16,  test_integer_u16)\n+impl_integer_for_uint!(u32,  test_integer_u32)\n+impl_integer_for_uint!(u64,  test_integer_u64)\n+impl_integer_for_uint!(uint, test_integer_uint)"}, {"sha": "5f1868b48c5196e1d832794434b0c4d628972e50", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=b5995b4e93237fe0d1c0ea76e33eb2429f654487", "patch": "@@ -10,6 +10,8 @@\n \n //! Rational numbers\n \n+use Integer;\n+\n use std::cmp;\n use std::from_str::FromStr;\n use std::num::{Zero,One,ToStrRadix,FromStrRadix,Round};"}, {"sha": "5e919e4ac0a4d66ee931fe5d038ace4cd9b20fd6", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=b5995b4e93237fe0d1c0ea76e33eb2429f654487", "patch": "@@ -65,7 +65,7 @@ the rest of the rust manuals.\n */\n \n use cmp;\n-use num::{Zero, One, Integer, CheckedAdd, CheckedSub, Saturating, ToPrimitive};\n+use num::{Zero, One, CheckedAdd, CheckedSub, Saturating, ToPrimitive, Int};\n use option::{Option, Some, None};\n use ops::{Add, Mul, Sub};\n use cmp::{Eq, Ord};\n@@ -2005,9 +2005,9 @@ impl<A: Add<A, A> + Ord + Clone + ToPrimitive> Iterator<A> for Range<A> {\n     }\n }\n \n-/// `Integer` is required to ensure the range will be the same regardless of\n+/// `Int` is required to ensure the range will be the same regardless of\n /// the direction it is consumed.\n-impl<A: Integer + Ord + Clone + ToPrimitive> DoubleEndedIterator<A> for Range<A> {\n+impl<A: Int + Ord + Clone + ToPrimitive> DoubleEndedIterator<A> for Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.stop > self.state {\n@@ -2065,7 +2065,7 @@ impl<A: Add<A, A> + Eq + Ord + Clone + ToPrimitive> Iterator<A> for RangeInclusi\n     }\n }\n \n-impl<A: Sub<A, A> + Integer + Ord + Clone + ToPrimitive> DoubleEndedIterator<A>\n+impl<A: Sub<A, A> + Int + Ord + Clone + ToPrimitive> DoubleEndedIterator<A>\n     for RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -2381,7 +2381,7 @@ mod tests {\n     #[test]\n     fn test_filter_map() {\n         let mut it = count(0u, 1u).take(10)\n-            .filter_map(|x| if x.is_even() { Some(x*x) } else { None });\n+            .filter_map(|x| if x % 2 == 0 { Some(x*x) } else { None });\n         assert_eq!(it.collect::<~[uint]>(), ~[0*0, 2*2, 4*4, 6*6, 8*8]);\n     }\n \n@@ -2648,7 +2648,7 @@ mod tests {\n     fn test_all() {\n         let v: ~&[int] = ~&[1, 2, 3, 4, 5];\n         assert!(v.iter().all(|&x| x < 10));\n-        assert!(!v.iter().all(|&x| x.is_even()));\n+        assert!(!v.iter().all(|&x| x % 2 == 0));\n         assert!(!v.iter().all(|&x| x > 100));\n         assert!(v.slice(0, 0).iter().all(|_| fail!()));\n     }\n@@ -2657,7 +2657,7 @@ mod tests {\n     fn test_any() {\n         let v: ~&[int] = ~&[1, 2, 3, 4, 5];\n         assert!(v.iter().any(|&x| x < 10));\n-        assert!(v.iter().any(|&x| x.is_even()));\n+        assert!(v.iter().any(|&x| x % 2 == 0));\n         assert!(!v.iter().any(|&x| x > 100));\n         assert!(!v.slice(0, 0).iter().any(|_| fail!()));\n     }"}, {"sha": "7f45b5deb187c03e03f8fc48e4afcdf31a665b63", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 9, "deletions": 255, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=b5995b4e93237fe0d1c0ea76e33eb2429f654487", "patch": "@@ -91,53 +91,48 @@ impl Mul<$T,$T> for $T {\n \n #[cfg(not(test))]\n impl Div<$T,$T> for $T {\n-    ///\n-    /// Integer division, truncated towards 0. As this behaviour reflects the underlying\n-    /// machine implementation it is more efficient than `Integer::div_floor`.\n+    /// Integer division, truncated towards 0.\n     ///\n     /// # Examples\n     ///\n-    /// ```\n+    /// ~~~\n     /// assert!( 8 /  3 ==  2);\n     /// assert!( 8 / -3 == -2);\n     /// assert!(-8 /  3 == -2);\n     /// assert!(-8 / -3 ==  2);\n-\n+    ///\n     /// assert!( 1 /  2 ==  0);\n     /// assert!( 1 / -2 ==  0);\n     /// assert!(-1 /  2 ==  0);\n     /// assert!(-1 / -2 ==  0);\n-    /// ```\n-    ///\n+    /// ~~~\n     #[inline]\n     fn div(&self, other: &$T) -> $T { *self / *other }\n }\n \n #[cfg(not(test))]\n impl Rem<$T,$T> for $T {\n-    ///\n     /// Returns the integer remainder after division, satisfying:\n     ///\n-    /// ```\n+    /// ~~~\n     /// # let n = 1;\n     /// # let d = 2;\n     /// assert!((n / d) * d + (n % d) == n)\n-    /// ```\n+    /// ~~~\n     ///\n     /// # Examples\n     ///\n-    /// ```\n+    /// ~~~\n     /// assert!( 8 %  3 ==  2);\n     /// assert!( 8 % -3 ==  2);\n     /// assert!(-8 %  3 == -2);\n     /// assert!(-8 % -3 == -2);\n-\n+    ///\n     /// assert!( 1 %  2 ==  1);\n     /// assert!( 1 % -2 ==  1);\n     /// assert!(-1 %  2 == -1);\n     /// assert!(-1 % -2 == -1);\n-    /// ```\n-    ///\n+    /// ~~~\n     #[inline]\n     fn rem(&self, other: &$T) -> $T { *self % *other }\n }\n@@ -189,125 +184,6 @@ impl Signed for $T {\n     fn is_negative(&self) -> bool { *self < 0 }\n }\n \n-impl Integer for $T {\n-    ///\n-    /// Floored integer division\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert!(( 8i).div_floor(& 3) ==  2);\n-    /// assert!(( 8i).div_floor(&-3) == -3);\n-    /// assert!((-8i).div_floor(& 3) == -3);\n-    /// assert!((-8i).div_floor(&-3) ==  2);\n-    ///\n-    /// assert!(( 1i).div_floor(& 2) ==  0);\n-    /// assert!(( 1i).div_floor(&-2) == -1);\n-    /// assert!((-1i).div_floor(& 2) == -1);\n-    /// assert!((-1i).div_floor(&-2) ==  0);\n-    /// ```\n-    ///\n-    #[inline]\n-    fn div_floor(&self, other: &$T) -> $T {\n-        // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n-        // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-        match self.div_rem(other) {\n-            (d, r) if (r > 0 && *other < 0)\n-                   || (r < 0 && *other > 0) => d - 1,\n-            (d, _)                          => d,\n-        }\n-    }\n-\n-    ///\n-    /// Integer modulo, satisfying:\n-    ///\n-    /// ```\n-    /// # let n = 1i; let d = 1i;\n-    /// assert!(n.div_floor(&d) * d + n.mod_floor(&d) == n)\n-    /// ```\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert!(( 8i).mod_floor(& 3) ==  2);\n-    /// assert!(( 8i).mod_floor(&-3) == -1);\n-    /// assert!((-8i).mod_floor(& 3) ==  1);\n-    /// assert!((-8i).mod_floor(&-3) == -2);\n-    ///\n-    /// assert!(( 1i).mod_floor(& 2) ==  1);\n-    /// assert!(( 1i).mod_floor(&-2) == -1);\n-    /// assert!((-1i).mod_floor(& 2) ==  1);\n-    /// assert!((-1i).mod_floor(&-2) == -1);\n-    /// ```\n-    ///\n-    #[inline]\n-    fn mod_floor(&self, other: &$T) -> $T {\n-        // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n-        // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-        match *self % *other {\n-            r if (r > 0 && *other < 0)\n-              || (r < 0 && *other > 0) => r + *other,\n-            r                          => r,\n-        }\n-    }\n-\n-    /// Calculates `div_floor` and `mod_floor` simultaneously\n-    #[inline]\n-    fn div_mod_floor(&self, other: &$T) -> ($T,$T) {\n-        // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n-        // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-        match self.div_rem(other) {\n-            (d, r) if (r > 0 && *other < 0)\n-                   || (r < 0 && *other > 0) => (d - 1, r + *other),\n-            (d, r)                          => (d, r),\n-        }\n-    }\n-\n-    /// Calculates `div` (`/`) and `rem` (`%`) simultaneously\n-    #[inline]\n-    fn div_rem(&self, other: &$T) -> ($T,$T) {\n-        (*self / *other, *self % *other)\n-    }\n-\n-    ///\n-    /// Calculates the Greatest Common Divisor (GCD) of the number and `other`\n-    ///\n-    /// The result is always positive\n-    ///\n-    #[inline]\n-    fn gcd(&self, other: &$T) -> $T {\n-        // Use Euclid's algorithm\n-        let mut m = *self;\n-        let mut n = *other;\n-        while m != 0 {\n-            let temp = m;\n-            m = n % temp;\n-            n = temp;\n-        }\n-        n.abs()\n-    }\n-\n-    ///\n-    /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n-    ///\n-    #[inline]\n-    fn lcm(&self, other: &$T) -> $T {\n-        ((*self * *other) / self.gcd(other)).abs() // should not have to recaluculate abs\n-    }\n-\n-    /// Returns `true` if the number can be divided by `other` without leaving a remainder\n-    #[inline]\n-    fn is_multiple_of(&self, other: &$T) -> bool { *self % *other == 0 }\n-\n-    /// Returns `true` if the number is divisible by `2`\n-    #[inline]\n-    fn is_even(&self) -> bool { self & 1 == 0 }\n-\n-    /// Returns `true` if the number is not divisible by `2`\n-    #[inline]\n-    fn is_odd(&self) -> bool { !self.is_even() }\n-}\n-\n #[cfg(not(test))]\n impl BitOr<$T,$T> for $T {\n     #[inline]\n@@ -481,92 +357,6 @@ mod tests {\n         assert!((-1 as $T).is_negative());\n     }\n \n-    ///\n-    /// Checks that the division rule holds for:\n-    ///\n-    /// - `n`: numerator (dividend)\n-    /// - `d`: denominator (divisor)\n-    /// - `qr`: quotient and remainder\n-    ///\n-    #[cfg(test)]\n-    fn test_division_rule((n,d): ($T,$T), (q,r): ($T,$T)) {\n-        assert_eq!(d * q + r, n);\n-    }\n-\n-    #[test]\n-    fn test_div_rem() {\n-        fn test_nd_dr(nd: ($T,$T), qr: ($T,$T)) {\n-            let (n,d) = nd;\n-            let separate_div_rem = (n / d, n % d);\n-            let combined_div_rem = n.div_rem(&d);\n-\n-            assert_eq!(separate_div_rem, qr);\n-            assert_eq!(combined_div_rem, qr);\n-\n-            test_division_rule(nd, separate_div_rem);\n-            test_division_rule(nd, combined_div_rem);\n-        }\n-\n-        test_nd_dr(( 8,  3), ( 2,  2));\n-        test_nd_dr(( 8, -3), (-2,  2));\n-        test_nd_dr((-8,  3), (-2, -2));\n-        test_nd_dr((-8, -3), ( 2, -2));\n-\n-        test_nd_dr(( 1,  2), ( 0,  1));\n-        test_nd_dr(( 1, -2), ( 0,  1));\n-        test_nd_dr((-1,  2), ( 0, -1));\n-        test_nd_dr((-1, -2), ( 0, -1));\n-    }\n-\n-    #[test]\n-    fn test_div_mod_floor() {\n-        fn test_nd_dm(nd: ($T,$T), dm: ($T,$T)) {\n-            let (n,d) = nd;\n-            let separate_div_mod_floor = (n.div_floor(&d), n.mod_floor(&d));\n-            let combined_div_mod_floor = n.div_mod_floor(&d);\n-\n-            assert_eq!(separate_div_mod_floor, dm);\n-            assert_eq!(combined_div_mod_floor, dm);\n-\n-            test_division_rule(nd, separate_div_mod_floor);\n-            test_division_rule(nd, combined_div_mod_floor);\n-        }\n-\n-        test_nd_dm(( 8,  3), ( 2,  2));\n-        test_nd_dm(( 8, -3), (-3, -1));\n-        test_nd_dm((-8,  3), (-3,  1));\n-        test_nd_dm((-8, -3), ( 2, -2));\n-\n-        test_nd_dm(( 1,  2), ( 0,  1));\n-        test_nd_dm(( 1, -2), (-1, -1));\n-        test_nd_dm((-1,  2), (-1,  1));\n-        test_nd_dm((-1, -2), ( 0, -1));\n-    }\n-\n-    #[test]\n-    fn test_gcd() {\n-        assert_eq!((10 as $T).gcd(&2), 2 as $T);\n-        assert_eq!((10 as $T).gcd(&3), 1 as $T);\n-        assert_eq!((0 as $T).gcd(&3), 3 as $T);\n-        assert_eq!((3 as $T).gcd(&3), 3 as $T);\n-        assert_eq!((56 as $T).gcd(&42), 14 as $T);\n-        assert_eq!((3 as $T).gcd(&-3), 3 as $T);\n-        assert_eq!((-6 as $T).gcd(&3), 3 as $T);\n-        assert_eq!((-4 as $T).gcd(&-2), 2 as $T);\n-    }\n-\n-    #[test]\n-    fn test_lcm() {\n-        assert_eq!((1 as $T).lcm(&0), 0 as $T);\n-        assert_eq!((0 as $T).lcm(&1), 0 as $T);\n-        assert_eq!((1 as $T).lcm(&1), 1 as $T);\n-        assert_eq!((-1 as $T).lcm(&1), 1 as $T);\n-        assert_eq!((1 as $T).lcm(&-1), 1 as $T);\n-        assert_eq!((-1 as $T).lcm(&-1), 1 as $T);\n-        assert_eq!((8 as $T).lcm(&9), 72 as $T);\n-        assert_eq!((11 as $T).lcm(&5), 55 as $T);\n-    }\n-\n     #[test]\n     fn test_bitwise() {\n         assert_eq!(0b1110 as $T, (0b1100 as $T).bitor(&(0b1010 as $T)));\n@@ -577,42 +367,6 @@ mod tests {\n         assert_eq!(-(0b11 as $T) - (1 as $T), (0b11 as $T).not());\n     }\n \n-    #[test]\n-    fn test_multiple_of() {\n-        assert!((6 as $T).is_multiple_of(&(6 as $T)));\n-        assert!((6 as $T).is_multiple_of(&(3 as $T)));\n-        assert!((6 as $T).is_multiple_of(&(1 as $T)));\n-        assert!((-8 as $T).is_multiple_of(&(4 as $T)));\n-        assert!((8 as $T).is_multiple_of(&(-1 as $T)));\n-        assert!((-8 as $T).is_multiple_of(&(-2 as $T)));\n-    }\n-\n-    #[test]\n-    fn test_even() {\n-        assert_eq!((-4 as $T).is_even(), true);\n-        assert_eq!((-3 as $T).is_even(), false);\n-        assert_eq!((-2 as $T).is_even(), true);\n-        assert_eq!((-1 as $T).is_even(), false);\n-        assert_eq!((0 as $T).is_even(), true);\n-        assert_eq!((1 as $T).is_even(), false);\n-        assert_eq!((2 as $T).is_even(), true);\n-        assert_eq!((3 as $T).is_even(), false);\n-        assert_eq!((4 as $T).is_even(), true);\n-    }\n-\n-    #[test]\n-    fn test_odd() {\n-        assert_eq!((-4 as $T).is_odd(), false);\n-        assert_eq!((-3 as $T).is_odd(), true);\n-        assert_eq!((-2 as $T).is_odd(), false);\n-        assert_eq!((-1 as $T).is_odd(), true);\n-        assert_eq!((0 as $T).is_odd(), false);\n-        assert_eq!((1 as $T).is_odd(), true);\n-        assert_eq!((2 as $T).is_odd(), false);\n-        assert_eq!((3 as $T).is_odd(), true);\n-        assert_eq!((4 as $T).is_odd(), false);\n-    }\n-\n     #[test]\n     fn test_count_ones() {\n         assert_eq!((0b0101100 as $T).count_ones(), 3);"}, {"sha": "332eb62b0c63a09d411d3186066c3ac2c272bfdb", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=b5995b4e93237fe0d1c0ea76e33eb2429f654487", "patch": "@@ -33,6 +33,12 @@ pub trait Num: Eq + Zero + One\n              + Div<Self,Self>\n              + Rem<Self,Self> {}\n \n+/// Simultaneous division and remainder\n+#[inline]\n+pub fn div_rem<T: Div<T, T> + Rem<T, T>>(x: T, y: T) -> (T, T) {\n+    (x / y, x % y)\n+}\n+\n /// Defines an additive identity element for `Self`.\n ///\n /// # Deriving\n@@ -122,31 +128,6 @@ pub trait Signed: Num\n \n pub trait Unsigned: Num {}\n \n-pub trait Integer: Num\n-                 + Ord\n-                 + Div<Self,Self>\n-                 + Rem<Self,Self> {\n-    fn div_rem(&self, other: &Self) -> (Self,Self);\n-\n-    fn div_floor(&self, other: &Self) -> Self;\n-    fn mod_floor(&self, other: &Self) -> Self;\n-    fn div_mod_floor(&self, other: &Self) -> (Self,Self);\n-\n-    fn gcd(&self, other: &Self) -> Self;\n-    fn lcm(&self, other: &Self) -> Self;\n-\n-    fn is_multiple_of(&self, other: &Self) -> bool;\n-    fn is_even(&self) -> bool;\n-    fn is_odd(&self) -> bool;\n-}\n-\n-/// Calculates the Greatest Common Divisor (GCD) of the number and `other`.\n-///\n-/// The result is always positive.\n-#[inline(always)] pub fn gcd<T: Integer>(x: T, y: T) -> T { x.gcd(&y) }\n-/// Calculates the Lowest Common Multiple (LCM) of the number and `other`.\n-#[inline(always)] pub fn lcm<T: Integer>(x: T, y: T) -> T { x.lcm(&y) }\n-\n /// A collection of rounding operations.\n pub trait Round {\n     /// Return the largest integer less than or equal to a number.\n@@ -270,8 +251,7 @@ pub trait Primitive: Clone\n                    + Bounded {}\n \n /// A collection of traits relevant to primitive signed and unsigned integers\n-pub trait Int: Integer\n-             + Primitive\n+pub trait Int: Primitive\n              + Bitwise\n              + CheckedAdd\n              + CheckedSub"}, {"sha": "bc79ec9a4af38c6b60c30f6eed4f6191afcde44c", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=b5995b4e93237fe0d1c0ea76e33eb2429f654487", "patch": "@@ -21,7 +21,7 @@ use str;\n use vec::{CloneableVector, ImmutableVector, MutableVector};\n use vec::OwnedVector;\n use num;\n-use num::{NumCast, Zero, One, cast, Integer};\n+use num::{NumCast, Zero, One, cast, Int};\n use num::{Round, Float, FPNaN, FPInfinite, ToPrimitive};\n \n pub enum ExponentFormat {\n@@ -133,19 +133,7 @@ static NAN_BUF:          [u8, ..3] = ['N' as u8, 'a' as u8, 'N' as u8];\n  * # Failure\n  * - Fails if `radix` < 2 or `radix` > 36.\n  */\n-pub fn int_to_str_bytes_common<T:NumCast\n-                                +Zero\n-                                +Eq\n-                                +Ord\n-                                +Integer\n-                                +Div<T,T>\n-                                +Neg<T>\n-                                +Rem<T,T>\n-                                +Mul<T,T>>(\n-                                num: T,\n-                                radix: uint,\n-                                sign: SignFormat,\n-                                f: |u8|) {\n+pub fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8|) {\n     assert!(2 <= radix && radix <= 36);\n \n     let _0: T = Zero::zero();"}, {"sha": "33fcdcc426adfd7c1f526b3a15816ef52b0d9d1a", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=b5995b4e93237fe0d1c0ea76e33eb2429f654487", "patch": "@@ -100,60 +100,6 @@ impl Neg<$T> for $T {\n \n impl Unsigned for $T {}\n \n-impl Integer for $T {\n-    /// Calculates `div` (`/`) and `rem` (`%`) simultaneously\n-    #[inline]\n-    fn div_rem(&self, other: &$T) -> ($T,$T) {\n-        (*self / *other, *self % *other)\n-    }\n-\n-    /// Unsigned integer division. Returns the same result as `div` (`/`).\n-    #[inline]\n-    fn div_floor(&self, other: &$T) -> $T { *self / *other }\n-\n-    /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n-    #[inline]\n-    fn mod_floor(&self, other: &$T) -> $T { *self % *other }\n-\n-    /// Calculates `div_floor` and `mod_floor` simultaneously\n-    #[inline]\n-    fn div_mod_floor(&self, other: &$T) -> ($T,$T) {\n-        (*self / *other, *self % *other)\n-    }\n-\n-    /// Calculates the Greatest Common Divisor (GCD) of the number and `other`\n-    #[inline]\n-    fn gcd(&self, other: &$T) -> $T {\n-        // Use Euclid's algorithm\n-        let mut m = *self;\n-        let mut n = *other;\n-        while m != 0 {\n-            let temp = m;\n-            m = n % temp;\n-            n = temp;\n-        }\n-        n\n-    }\n-\n-    /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n-    #[inline]\n-    fn lcm(&self, other: &$T) -> $T {\n-        (*self * *other) / self.gcd(other)\n-    }\n-\n-    /// Returns `true` if the number can be divided by `other` without leaving a remainder\n-    #[inline]\n-    fn is_multiple_of(&self, other: &$T) -> bool { *self % *other == 0 }\n-\n-    /// Returns `true` if the number is divisible by `2`\n-    #[inline]\n-    fn is_even(&self) -> bool { self & 1 == 0 }\n-\n-    /// Returns `true` if the number is not divisible by `2`\n-    #[inline]\n-    fn is_odd(&self) -> bool { !self.is_even() }\n-}\n-\n #[cfg(not(test))]\n impl BitOr<$T,$T> for $T {\n     #[inline]\n@@ -309,63 +255,6 @@ mod tests {\n         num::test_num(10 as $T, 2 as $T);\n     }\n \n-    #[test]\n-    fn test_div_mod_floor() {\n-        assert_eq!((10 as $T).div_floor(&(3 as $T)), 3 as $T);\n-        assert_eq!((10 as $T).mod_floor(&(3 as $T)), 1 as $T);\n-        assert_eq!((10 as $T).div_mod_floor(&(3 as $T)), (3 as $T, 1 as $T));\n-        assert_eq!((5 as $T).div_floor(&(5 as $T)), 1 as $T);\n-        assert_eq!((5 as $T).mod_floor(&(5 as $T)), 0 as $T);\n-        assert_eq!((5 as $T).div_mod_floor(&(5 as $T)), (1 as $T, 0 as $T));\n-        assert_eq!((3 as $T).div_floor(&(7 as $T)), 0 as $T);\n-        assert_eq!((3 as $T).mod_floor(&(7 as $T)), 3 as $T);\n-        assert_eq!((3 as $T).div_mod_floor(&(7 as $T)), (0 as $T, 3 as $T));\n-    }\n-\n-    #[test]\n-    fn test_gcd() {\n-        assert_eq!((10 as $T).gcd(&2), 2 as $T);\n-        assert_eq!((10 as $T).gcd(&3), 1 as $T);\n-        assert_eq!((0 as $T).gcd(&3), 3 as $T);\n-        assert_eq!((3 as $T).gcd(&3), 3 as $T);\n-        assert_eq!((56 as $T).gcd(&42), 14 as $T);\n-    }\n-\n-    #[test]\n-    fn test_lcm() {\n-        assert_eq!((1 as $T).lcm(&0), 0 as $T);\n-        assert_eq!((0 as $T).lcm(&1), 0 as $T);\n-        assert_eq!((1 as $T).lcm(&1), 1 as $T);\n-        assert_eq!((8 as $T).lcm(&9), 72 as $T);\n-        assert_eq!((11 as $T).lcm(&5), 55 as $T);\n-        assert_eq!((99 as $T).lcm(&17), 1683 as $T);\n-    }\n-\n-    #[test]\n-    fn test_multiple_of() {\n-        assert!((6 as $T).is_multiple_of(&(6 as $T)));\n-        assert!((6 as $T).is_multiple_of(&(3 as $T)));\n-        assert!((6 as $T).is_multiple_of(&(1 as $T)));\n-    }\n-\n-    #[test]\n-    fn test_even() {\n-        assert_eq!((0 as $T).is_even(), true);\n-        assert_eq!((1 as $T).is_even(), false);\n-        assert_eq!((2 as $T).is_even(), true);\n-        assert_eq!((3 as $T).is_even(), false);\n-        assert_eq!((4 as $T).is_even(), true);\n-    }\n-\n-    #[test]\n-    fn test_odd() {\n-        assert_eq!((0 as $T).is_odd(), false);\n-        assert_eq!((1 as $T).is_odd(), true);\n-        assert_eq!((2 as $T).is_odd(), false);\n-        assert_eq!((3 as $T).is_odd(), true);\n-        assert_eq!((4 as $T).is_odd(), false);\n-    }\n-\n     #[test]\n     fn test_bitwise() {\n         assert_eq!(0b1110 as $T, (0b1100 as $T).bitor(&(0b1010 as $T)));"}, {"sha": "8fc4b985359e83f17439116157d657766897b307", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=b5995b4e93237fe0d1c0ea76e33eb2429f654487", "patch": "@@ -49,7 +49,7 @@ pub use hash::Hash;\n pub use iter::{FromIterator, Extendable};\n pub use iter::{Iterator, DoubleEndedIterator, RandomAccessIterator, CloneableIterator};\n pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};\n-pub use num::{Integer, Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n+pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n pub use num::{Signed, Unsigned, Round};\n pub use num::{Primitive, Int, Float, ToStrRadix, ToPrimitive, FromPrimitive};\n pub use path::{GenericPath, Path, PosixPath, WindowsPath};"}, {"sha": "0adc6083f6b817f6265b9404a56c99374d4a812f", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=b5995b4e93237fe0d1c0ea76e33eb2429f654487", "patch": "@@ -111,7 +111,7 @@ use cmp;\n use default::Default;\n use fmt;\n use iter::*;\n-use num::{Integer, CheckedAdd, Saturating, checked_next_power_of_two};\n+use num::{CheckedAdd, Saturating, checked_next_power_of_two, div_rem};\n use option::{None, Option, Some};\n use ptr;\n use ptr::RawPtr;\n@@ -575,7 +575,7 @@ impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n         if self.v.len() == 0 {\n             (0, Some(0))\n         } else {\n-            let (n, rem) = self.v.len().div_rem(&self.size);\n+            let (n, rem) = div_rem(self.v.len(), self.size);\n             let n = if rem > 0 { n+1 } else { n };\n             (n, Some(n))\n         }\n@@ -2859,7 +2859,7 @@ impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n         if self.v.len() == 0 {\n             (0, Some(0))\n         } else {\n-            let (n, rem) = self.v.len().div_rem(&self.chunk_size);\n+            let (n, rem) = div_rem(self.v.len(), self.chunk_size);\n             let n = if rem > 0 { n + 1 } else { n };\n             (n, Some(n))\n         }"}, {"sha": "71cd176a836ff86c0e9b941088f1afb43de3054b", "filename": "src/test/bench/shootout-pidigits.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Ftest%2Fbench%2Fshootout-pidigits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5995b4e93237fe0d1c0ea76e33eb2429f654487/src%2Ftest%2Fbench%2Fshootout-pidigits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pidigits.rs?ref=b5995b4e93237fe0d1c0ea76e33eb2429f654487", "patch": "@@ -14,6 +14,7 @@ use std::from_str::FromStr;\n use std::num::One;\n use std::num::Zero;\n use std::num::FromPrimitive;\n+use num::Integer;\n use num::bigint::BigInt;\n \n struct Context {"}]}