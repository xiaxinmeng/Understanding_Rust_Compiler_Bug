{"sha": "838191c40bc0411853d2b0d7e98326d08a5060e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzODE5MWM0MGJjMDQxMTg1M2QyYjBkN2U5ODMyNmQwOGE1MDYwZTA=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T15:03:16Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T15:03:24Z"}, "message": "std: replace str::{starts,ends}_with with the method.", "tree": {"sha": "f08ace09de7d2e1ece933e1c84d2dbe5915601f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f08ace09de7d2e1ece933e1c84d2dbe5915601f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/838191c40bc0411853d2b0d7e98326d08a5060e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/838191c40bc0411853d2b0d7e98326d08a5060e0", "html_url": "https://github.com/rust-lang/rust/commit/838191c40bc0411853d2b0d7e98326d08a5060e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/838191c40bc0411853d2b0d7e98326d08a5060e0/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "248b6e38b533d43b8b4adaf6d47efc62fe82ef2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/248b6e38b533d43b8b4adaf6d47efc62fe82ef2a", "html_url": "https://github.com/rust-lang/rust/commit/248b6e38b533d43b8b4adaf6d47efc62fe82ef2a"}], "stats": {"total": 106, "additions": 40, "deletions": 66}, "files": [{"sha": "e832534b227a9b6a294c2731bc4cadc9676a9fb2", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=838191c40bc0411853d2b0d7e98326d08a5060e0", "patch": "@@ -231,11 +231,11 @@ pub fn is_test(config: &config, testfile: &Path) -> bool {\n     let mut valid = false;\n \n     for valid_extensions.each |ext| {\n-        if str::ends_with(name, *ext) { valid = true; }\n+        if name.ends_with(*ext) { valid = true; }\n     }\n \n     for invalid_prefixes.each |pre| {\n-        if str::starts_with(name, *pre) { valid = false; }\n+        if name.starts_with(*pre) { valid = false; }\n     }\n \n     return valid;"}, {"sha": "87f5f4bd3fae11c2a1e546185b67cc3c5462a196", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=838191c40bc0411853d2b0d7e98326d08a5060e0", "patch": "@@ -112,7 +112,7 @@ fn iter_header(testfile: &Path, it: &fn(~str) -> bool) -> bool {\n         // Assume that any directives will be found before the first\n         // module or function. This doesn't seem to be an optimization\n         // with a warm page cache. Maybe with a cold one.\n-        if str::starts_with(ln, \"fn\") || str::starts_with(ln, \"mod\") {\n+        if ln.starts_with(\"fn\") || ln.starts_with(\"mod\") {\n             return false;\n         } else { if !(it(ln)) { return false; } }\n     }"}, {"sha": "87188100f4c52c39d57ab24708fcdb7d268cbffa", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=838191c40bc0411853d2b0d7e98326d08a5060e0", "patch": "@@ -28,7 +28,7 @@ fn target_env(lib_path: &str, prog: &str) -> ~[(~str,~str)] {\n         if k == ~\"PATH\" { (~\"PATH\", v + \";\" + lib_path + \";\" + aux_path) }\n         else { (k,v) }\n     };\n-    if str::ends_with(prog, \"rustc.exe\") {\n+    if prog.ends_with(\"rustc.exe\") {\n         env.push((~\"RUST_THREADS\", ~\"1\"));\n     }\n     return env;"}, {"sha": "7159e51e3b6f329d7dcd2e0e79634bee0a0c617e", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=838191c40bc0411853d2b0d7e98326d08a5060e0", "patch": "@@ -364,7 +364,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n             if !found_flags[i] {\n                 debug!(\"prefix=%s ee.kind=%s ee.msg=%s line=%s\",\n                        prefixes[i], ee.kind, ee.msg, line);\n-                if (str::starts_with(line, prefixes[i]) &&\n+                if (line.starts_with(prefixes[i]) &&\n                     line.contains(ee.kind) &&\n                     line.contains(ee.msg)) {\n                     found_flags[i] = true;"}, {"sha": "c85a866a04a66ed4c5fa058bc20235c623522927", "filename": "src/libextra/net_url.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Flibextra%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Flibextra%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_url.rs?ref=838191c40bc0411853d2b0d7e98326d08a5060e0", "patch": "@@ -394,7 +394,7 @@ enum Input {\n // returns userinfo, host, port, and unparsed part, or an error\n fn get_authority(rawurl: &str) ->\n     Result<(Option<UserInfo>, ~str, Option<~str>, ~str), ~str> {\n-    if !str::starts_with(rawurl, \"//\") {\n+    if !raw_url.starts_with(\"//\") {\n         // there is no authority.\n         return Ok((None, ~\"\", None, rawurl.to_str()));\n     }\n@@ -579,7 +579,7 @@ fn get_path(rawurl: &str, authority: bool) ->\n     }\n \n     if authority {\n-        if end != 0 && !str::starts_with(rawurl, \"/\") {\n+        if end != 0 && !rawurl.starts_with(\"/\") {\n             return Err(~\"Non-empty path must begin with\\\n                                '/' in presence of authority.\");\n         }\n@@ -592,8 +592,8 @@ fn get_path(rawurl: &str, authority: bool) ->\n // returns the parsed query and the fragment, if present\n fn get_query_fragment(rawurl: &str) ->\n     Result<(Query, Option<~str>), ~str> {\n-    if !str::starts_with(rawurl, \"?\") {\n-        if str::starts_with(rawurl, \"#\") {\n+    if !rawurl.starts_with(\"?\") {\n+        if rawurl.starts_with(\"#\") {\n             let f = decode_component(rawurl.slice(\n                                                 1,\n                                                 rawurl.len()));"}, {"sha": "c239e65e2d9a9a931a376b33f21526169ed98895", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=838191c40bc0411853d2b0d7e98326d08a5060e0", "patch": "@@ -42,7 +42,7 @@ mod tests {\n     fn test_mkdtemp() {\n         let p = mkdtemp(&Path(\".\"), \"foobar\").unwrap();\n         os::remove_dir(&p);\n-        assert!(str::ends_with(p.to_str(), \"foobar\"));\n+        assert!(p.to_str().ends_with(\"foobar\"));\n     }\n \n     // Ideally these would be in core::os but then core would need"}, {"sha": "5e5e0067afa418508062291bb2eb68a1a38b0b81", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=838191c40bc0411853d2b0d7e98326d08a5060e0", "patch": "@@ -240,7 +240,7 @@ mod test {\n         debug!(\"test_prefix_path: %s vs. %s\",\n                res.to_str(),\n                d.to_str());\n-        assert!(str::ends_with(res.to_str(), d.to_str()));\n+        assert!(res.to_str().ends_with(d.to_str()));\n     }\n \n     #[test]"}, {"sha": "ce93cad73b6f3cc88c4756d1cd00b322762413aa", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=838191c40bc0411853d2b0d7e98326d08a5060e0", "patch": "@@ -244,7 +244,7 @@ fn get_cache(cx: @CrateContext) -> metadata_cache {\n }\n \n fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n-    (if str::starts_with(full_path, work_dir) {\n+    (if full_path.starts_with(work_dir) {\n         full_path.slice(work_dir.len() + 1u,\n                    full_path.len()).to_owned()\n     } else {"}, {"sha": "13ad47e34b8aa8643189ec2367017705e34f5e37", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=838191c40bc0411853d2b0d7e98326d08a5060e0", "patch": "@@ -134,7 +134,7 @@ fn first_sentence_(s: &str) -> ~str {\n             str::to_owned(s.slice(0, idx - 1))\n         }\n         _ => {\n-            if str::ends_with(s, \".\") {\n+            if s.ends_with(\".\") {\n                 str::to_owned(s)\n             } else {\n                 str::to_owned(s)"}, {"sha": "8716f823848e27c91eb1ca7ee56e48dd93c316c1", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=838191c40bc0411853d2b0d7e98326d08a5060e0", "patch": "@@ -153,7 +153,7 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n }\n \n fn parse_header(line: ~str) -> Option<~str> {\n-    if str::starts_with(line, \"# \") {\n+    if line.starts_with(\"# \") {\n         Some(line.slice(2u, line.len()).to_owned())\n     } else {\n         None"}, {"sha": "409882c5cfe5addc8dab7bd4f5b47fc4cfedd681", "filename": "src/libstd/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=838191c40bc0411853d2b0d7e98326d08a5060e0", "patch": "@@ -1979,7 +1979,7 @@ mod tests {\n     fn file_writer_bad_name() {\n         match io::file_writer(&Path(\"?/?\"), []) {\n           result::Err(e) => {\n-            assert!(str::starts_with(e, \"error opening\"));\n+            assert!(e.starts_with(\"error opening\"));\n           }\n           result::Ok(_) => fail!()\n         }\n@@ -1989,7 +1989,7 @@ mod tests {\n     fn buffered_file_writer_bad_name() {\n         match io::buffered_file_writer(&Path(\"?/?\")) {\n           result::Err(e) => {\n-            assert!(str::starts_with(e, \"error opening\"));\n+            assert!(e.starts_with(\"error opening\"));\n           }\n           result::Ok(_) => fail!()\n         }"}, {"sha": "03169a167b31262028193a1c1074d9fdde59b1ca", "filename": "src/libstd/str.rs", "status": "modified", "additions": 24, "deletions": 50, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838191c40bc0411853d2b0d7e98326d08a5060e0/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=838191c40bc0411853d2b0d7e98326d08a5060e0", "patch": "@@ -977,36 +977,6 @@ fn match_at<'a,'b>(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n }\n \n \n-/**\n- * Returns true if one string starts with another\n- *\n- * # Arguments\n- *\n- * * haystack - The string to look in\n- * * needle - The string to look for\n- */\n-pub fn starts_with<'a,'b>(haystack: &'a str, needle: &'b str) -> bool {\n-    let (haystack_len, needle_len) = (haystack.len(), needle.len());\n-    if needle_len == 0u { true }\n-    else if needle_len > haystack_len { false }\n-    else { match_at(haystack, needle, 0u) }\n-}\n-\n-/**\n- * Returns true if one string ends with another\n- *\n- * # Arguments\n- *\n- * * haystack - The string to look in\n- * * needle - The string to look for\n- */\n-pub fn ends_with<'a,'b>(haystack: &'a str, needle: &'b str) -> bool {\n-    let (haystack_len, needle_len) = (haystack.len(), needle.len());\n-    if needle_len == 0u { true }\n-    else if needle_len > haystack_len { false }\n-    else { match_at(haystack, needle, haystack_len - needle_len) }\n-}\n-\n /*\n Section: String properties\n */\n@@ -1600,7 +1570,7 @@ pub trait StrSlice<'self> {\n     fn slice(&self, begin: uint, end: uint) -> &'self str;\n     fn slice_from(&self, begin: uint) -> &'self str;\n     fn slice_to(&self, end: uint) -> &'self str;\n-    fn starts_with<'a>(&self, needle: &'a str) -> bool;\n+    fn starts_with(&self, needle: &str) -> bool;\n     fn substr(&self, begin: uint, n: uint) -> &'self str;\n     fn escape_default(&self) -> ~str;\n     fn escape_unicode(&self) -> ~str;\n@@ -1770,12 +1740,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         self.split_iter(char::is_whitespace).filter(|s| !s.is_empty())\n     }\n \n-\n-    /// Returns true if one string ends with another\n-    #[inline]\n-    fn ends_with(&self, needle: &str) -> bool {\n-        ends_with(*self, needle)\n-    }\n     /// Returns true if the string has length 0\n     #[inline]\n     fn is_empty(&self) -> bool { self.len() == 0 }\n@@ -1831,11 +1795,21 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn slice_to(&self, end: uint) -> &'self str {\n         self.slice(0, end)\n     }\n-    /// Checks if `needle` is a prefix of the string.\n-    #[inline]\n+    /// Returns true if `needle` is a prefix of the string.\n     fn starts_with<'a>(&self, needle: &'a str) -> bool {\n-        starts_with(*self, needle)\n+        let (self_len, needle_len) = (self.len(), needle.len());\n+        if needle_len == 0u { true }\n+        else if needle_len > self_len { false }\n+        else { match_at(*self, needle, 0u) }\n     }\n+    /// Returns true if `needle` is a suffix of the string.\n+    pub fn ends_with(&self, needle: &str) -> bool {\n+        let (self_len, needle_len) = (self.len(), needle.len());\n+        if needle_len == 0u { true }\n+        else if needle_len > self_len { false }\n+        else { match_at(*self, needle, self_len - needle_len) }\n+    }\n+\n     /**\n      * Take a substring of another.\n      *\n@@ -2591,20 +2565,20 @@ mod tests {\n \n     #[test]\n     fn test_starts_with() {\n-        assert!((starts_with(\"\", \"\")));\n-        assert!((starts_with(\"abc\", \"\")));\n-        assert!((starts_with(\"abc\", \"a\")));\n-        assert!((!starts_with(\"a\", \"abc\")));\n-        assert!((!starts_with(\"\", \"abc\")));\n+        assert!((\"\".starts_with(\"\")));\n+        assert!((\"abc\".starts_with(\"\")));\n+        assert!((\"abc\".starts_with(\"a\")));\n+        assert!((!\"a\".starts_with(\"abc\")));\n+        assert!((!\"\".starts_with(\"abc\")));\n     }\n \n     #[test]\n     fn test_ends_with() {\n-        assert!((ends_with(\"\", \"\")));\n-        assert!((ends_with(\"abc\", \"\")));\n-        assert!((ends_with(\"abc\", \"c\")));\n-        assert!((!ends_with(\"a\", \"abc\")));\n-        assert!((!ends_with(\"\", \"abc\")));\n+        assert!((\"\".ends_with(\"\")));\n+        assert!((\"abc\".ends_with(\"\")));\n+        assert!((\"abc\".ends_with(\"c\")));\n+        assert!((!\"a\".ends_with(\"abc\")));\n+        assert!((!\"\".ends_with(\"abc\")));\n     }\n \n     #[test]"}]}