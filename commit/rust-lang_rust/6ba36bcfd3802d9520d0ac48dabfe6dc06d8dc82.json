{"sha": "6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiYTM2YmNmZDM4MDJkOTUyMGQwYWM0OGRhYmZlNmRjMDZkOGRjODI=", "commit": {"author": {"name": "Tim Nielens", "email": "tim.nielens@gmail.com", "date": "2020-08-21T22:43:04Z"}, "committer": {"name": "Tim Nielens", "email": "tim.nielens@gmail.com", "date": "2020-09-15T23:30:50Z"}, "message": "option_if_let_else - distinguish pure from impure else expressions", "tree": {"sha": "df0966badbe46bbe6b42b5e66ae4e6e9501d554d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df0966badbe46bbe6b42b5e66ae4e6e9501d554d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82", "html_url": "https://github.com/rust-lang/rust/commit/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/comments", "author": {"login": "tnielens", "id": 11885535, "node_id": "MDQ6VXNlcjExODg1NTM1", "avatar_url": "https://avatars.githubusercontent.com/u/11885535?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tnielens", "html_url": "https://github.com/tnielens", "followers_url": "https://api.github.com/users/tnielens/followers", "following_url": "https://api.github.com/users/tnielens/following{/other_user}", "gists_url": "https://api.github.com/users/tnielens/gists{/gist_id}", "starred_url": "https://api.github.com/users/tnielens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tnielens/subscriptions", "organizations_url": "https://api.github.com/users/tnielens/orgs", "repos_url": "https://api.github.com/users/tnielens/repos", "events_url": "https://api.github.com/users/tnielens/events{/privacy}", "received_events_url": "https://api.github.com/users/tnielens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tnielens", "id": 11885535, "node_id": "MDQ6VXNlcjExODg1NTM1", "avatar_url": "https://avatars.githubusercontent.com/u/11885535?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tnielens", "html_url": "https://github.com/tnielens", "followers_url": "https://api.github.com/users/tnielens/followers", "following_url": "https://api.github.com/users/tnielens/following{/other_user}", "gists_url": "https://api.github.com/users/tnielens/gists{/gist_id}", "starred_url": "https://api.github.com/users/tnielens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tnielens/subscriptions", "organizations_url": "https://api.github.com/users/tnielens/orgs", "repos_url": "https://api.github.com/users/tnielens/repos", "events_url": "https://api.github.com/users/tnielens/events{/privacy}", "received_events_url": "https://api.github.com/users/tnielens/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21c351867a4a81d12989e2166ba2418180e3e258", "url": "https://api.github.com/repos/rust-lang/rust/commits/21c351867a4a81d12989e2166ba2418180e3e258", "html_url": "https://github.com/rust-lang/rust/commit/21c351867a4a81d12989e2166ba2418180e3e258"}], "stats": {"total": 634, "additions": 420, "deletions": 214}, "files": [{"sha": "ae37942e55a1bbf65cf77a47d1925cb4b141dc5e", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82", "patch": "@@ -12,6 +12,7 @@ use rustc_middle::hir::map::Map;\n use rustc_span::Span;\n \n pub(crate) struct OptionAndThenSome;\n+\n impl BindInsteadOfMap for OptionAndThenSome {\n     const TYPE_NAME: &'static str = \"Option\";\n     const TYPE_QPATH: &'static [&'static str] = &paths::OPTION;\n@@ -24,6 +25,7 @@ impl BindInsteadOfMap for OptionAndThenSome {\n }\n \n pub(crate) struct ResultAndThenOk;\n+\n impl BindInsteadOfMap for ResultAndThenOk {\n     const TYPE_NAME: &'static str = \"Result\";\n     const TYPE_QPATH: &'static [&'static str] = &paths::RESULT;\n@@ -36,6 +38,7 @@ impl BindInsteadOfMap for ResultAndThenOk {\n }\n \n pub(crate) struct ResultOrElseErrInfo;\n+\n impl BindInsteadOfMap for ResultOrElseErrInfo {\n     const TYPE_NAME: &'static str = \"Result\";\n     const TYPE_QPATH: &'static [&'static str] = &paths::RESULT;\n@@ -120,9 +123,9 @@ pub(crate) trait BindInsteadOfMap {\n         }\n     }\n \n-    fn lint_closure(cx: &LateContext<'_>, expr: &hir::Expr<'_>, closure_expr: &hir::Expr<'_>) {\n+    fn lint_closure(cx: &LateContext<'_>, expr: &hir::Expr<'_>, closure_expr: &hir::Expr<'_>) -> bool {\n         let mut suggs = Vec::new();\n-        let can_sugg = find_all_ret_expressions(cx, closure_expr, |ret_expr| {\n+        let can_sugg: bool = find_all_ret_expressions(cx, closure_expr, |ret_expr| {\n             if_chain! {\n                 if !in_macro(ret_expr.span);\n                 if let hir::ExprKind::Call(ref func_path, ref args) = ret_expr.kind;\n@@ -153,21 +156,24 @@ pub(crate) trait BindInsteadOfMap {\n                 )\n             });\n         }\n+        can_sugg\n     }\n \n     /// Lint use of `_.and_then(|x| Some(y))` for `Option`s\n-    fn lint(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    fn lint(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) -> bool {\n         if !match_type(cx, cx.typeck_results().expr_ty(&args[0]), Self::TYPE_QPATH) {\n-            return;\n+            return false;\n         }\n \n         match args[1].kind {\n             hir::ExprKind::Closure(_, _, body_id, closure_args_span, _) => {\n                 let closure_body = cx.tcx.hir().body(body_id);\n                 let closure_expr = remove_blocks(&closure_body.value);\n \n-                if !Self::lint_closure_autofixable(cx, expr, args, closure_expr, closure_args_span) {\n-                    Self::lint_closure(cx, expr, closure_expr);\n+                if Self::lint_closure_autofixable(cx, expr, args, closure_expr, closure_args_span) {\n+                    true\n+                } else {\n+                    Self::lint_closure(cx, expr, closure_expr)\n                 }\n             },\n             // `_.and_then(Some)` case, which is no-op.\n@@ -181,8 +187,9 @@ pub(crate) trait BindInsteadOfMap {\n                     snippet(cx, args[0].span, \"..\").into(),\n                     Applicability::MachineApplicable,\n                 );\n+                true\n             },\n-            _ => {},\n+            _ => false,\n         }\n     }\n }"}, {"sha": "914f9f94e776a69b7244cfd34010d95bd8c1c5e5", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 19, "deletions": 47, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82", "patch": "@@ -25,14 +25,15 @@ use rustc_span::source_map::Span;\n use rustc_span::symbol::{sym, SymbolStr};\n \n use crate::consts::{constant, Constant};\n+use crate::utils::eager_or_lazy::is_lazyness_candidate;\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n     contains_ty, get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait, in_macro,\n-    is_copy, is_ctor_or_promotable_const_function, is_expn_of, is_type_diagnostic_item, iter_input_pats,\n-    last_path_segment, match_def_path, match_qpath, match_trait_method, match_type, match_var, method_calls,\n-    method_chain_args, paths, remove_blocks, return_ty, single_segment_path, snippet, snippet_with_applicability,\n-    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_note, span_lint_and_sugg,\n-    span_lint_and_then, sugg, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n+    is_copy, is_expn_of, is_type_diagnostic_item, iter_input_pats, last_path_segment, match_def_path, match_qpath,\n+    match_trait_method, match_type, match_var, method_calls, method_chain_args, paths, remove_blocks, return_ty,\n+    single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n+    span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then, sugg, walk_ptrs_ty,\n+    walk_ptrs_ty_depth, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -1454,18 +1455,21 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"unwrap_or\", \"map\"] => option_map_unwrap_or::lint(cx, expr, arg_lists[1], arg_lists[0], method_spans[1]),\n             [\"unwrap_or_else\", \"map\"] => {\n                 if !lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]) {\n-                    unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"unwrap_or\");\n+                    unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"unwrap_or\");\n                 }\n             },\n             [\"map_or\", ..] => lint_map_or_none(cx, expr, arg_lists[0]),\n             [\"and_then\", ..] => {\n-                unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], false, \"and\");\n-                bind_instead_of_map::OptionAndThenSome::lint(cx, expr, arg_lists[0]);\n-                bind_instead_of_map::ResultAndThenOk::lint(cx, expr, arg_lists[0]);\n+                let biom_option_linted = bind_instead_of_map::OptionAndThenSome::lint(cx, expr, arg_lists[0]);\n+                let biom_result_linted = bind_instead_of_map::ResultAndThenOk::lint(cx, expr, arg_lists[0]);\n+                if !biom_option_linted && !biom_result_linted {\n+                    unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"and\");\n+                }\n             },\n             [\"or_else\", ..] => {\n-                unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], false, \"or\");\n-                bind_instead_of_map::ResultOrElseErrInfo::lint(cx, expr, arg_lists[0]);\n+                if !bind_instead_of_map::ResultOrElseErrInfo::lint(cx, expr, arg_lists[0]) {\n+                    unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"or\");\n+                }\n             },\n             [\"next\", \"filter\"] => lint_filter_next(cx, expr, arg_lists[1]),\n             [\"next\", \"skip_while\"] => lint_skip_while_next(cx, expr, arg_lists[1]),\n@@ -1508,9 +1512,9 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"is_file\", ..] => lint_filetype_is_file(cx, expr, arg_lists[0]),\n             [\"map\", \"as_ref\"] => lint_option_as_ref_deref(cx, expr, arg_lists[1], arg_lists[0], false),\n             [\"map\", \"as_mut\"] => lint_option_as_ref_deref(cx, expr, arg_lists[1], arg_lists[0], true),\n-            [\"unwrap_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"unwrap_or\"),\n-            [\"get_or_insert_with\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"get_or_insert\"),\n-            [\"ok_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"ok_or\"),\n+            [\"unwrap_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"unwrap_or\"),\n+            [\"get_or_insert_with\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"get_or_insert\"),\n+            [\"ok_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"ok_or\"),\n             _ => {},\n         }\n \n@@ -1714,37 +1718,6 @@ fn lint_or_fun_call<'tcx>(\n     name: &str,\n     args: &'tcx [hir::Expr<'_>],\n ) {\n-    // Searches an expression for method calls or function calls that aren't ctors\n-    struct FunCallFinder<'a, 'tcx> {\n-        cx: &'a LateContext<'tcx>,\n-        found: bool,\n-    }\n-\n-    impl<'a, 'tcx> intravisit::Visitor<'tcx> for FunCallFinder<'a, 'tcx> {\n-        type Map = Map<'tcx>;\n-\n-        fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-            let call_found = match &expr.kind {\n-                // ignore enum and struct constructors\n-                hir::ExprKind::Call(..) => !is_ctor_or_promotable_const_function(self.cx, expr),\n-                hir::ExprKind::MethodCall(..) => true,\n-                _ => false,\n-            };\n-\n-            if call_found {\n-                self.found |= true;\n-            }\n-\n-            if !self.found {\n-                intravisit::walk_expr(self, expr);\n-            }\n-        }\n-\n-        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n-            intravisit::NestedVisitorMap::None\n-        }\n-    }\n-\n     /// Checks for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n     fn check_unwrap_or_default(\n         cx: &LateContext<'_>,\n@@ -1825,8 +1798,7 @@ fn lint_or_fun_call<'tcx>(\n         if_chain! {\n             if know_types.iter().any(|k| k.2.contains(&name));\n \n-            let mut finder = FunCallFinder { cx: &cx, found: false };\n-            if { finder.visit_expr(&arg); finder.found };\n+            if is_lazyness_candidate(cx, arg);\n             if !contains_return(&arg);\n \n             let self_ty = cx.typeck_results().expr_ty(self_expr);"}, {"sha": "08b3eab9b7cdfe3f631b2471c91968a4219184b6", "filename": "clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 9, "deletions": 67, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82", "patch": "@@ -1,78 +1,17 @@\n-use crate::utils::{is_type_diagnostic_item, match_qpath, snippet, span_lint_and_sugg};\n-use if_chain::if_chain;\n+use crate::utils::{eager_or_lazy, usage};\n+use crate::utils::{is_type_diagnostic_item, snippet, span_lint_and_sugg};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n \n use super::UNNECESSARY_LAZY_EVALUATIONS;\n \n-// Return true if the expression is an accessor of any of the arguments\n-fn expr_uses_argument(expr: &hir::Expr<'_>, params: &[hir::Param<'_>]) -> bool {\n-    params.iter().any(|arg| {\n-        if_chain! {\n-            if let hir::PatKind::Binding(_, _, ident, _) = arg.pat.kind;\n-            if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.kind;\n-            if let [p, ..] = path.segments;\n-            then {\n-                ident.name == p.ident.name\n-            } else {\n-                false\n-            }\n-        }\n-    })\n-}\n-\n-fn match_any_qpath(path: &hir::QPath<'_>, paths: &[&[&str]]) -> bool {\n-    paths.iter().any(|candidate| match_qpath(path, candidate))\n-}\n-\n-fn can_simplify(expr: &hir::Expr<'_>, params: &[hir::Param<'_>], variant_calls: bool) -> bool {\n-    match expr.kind {\n-        // Closures returning literals can be unconditionally simplified\n-        hir::ExprKind::Lit(_) => true,\n-\n-        hir::ExprKind::Index(ref object, ref index) => {\n-            // arguments are not being indexed into\n-            if expr_uses_argument(object, params) {\n-                false\n-            } else {\n-                // arguments are not used as index\n-                !expr_uses_argument(index, params)\n-            }\n-        },\n-\n-        // Reading fields can be simplified if the object is not an argument of the closure\n-        hir::ExprKind::Field(ref object, _) => !expr_uses_argument(object, params),\n-\n-        // Paths can be simplified if the root is not the argument, this also covers None\n-        hir::ExprKind::Path(_) => !expr_uses_argument(expr, params),\n-\n-        // Calls to Some, Ok, Err can be considered literals if they don't derive an argument\n-        hir::ExprKind::Call(ref func, ref args) => if_chain! {\n-            if variant_calls; // Disable lint when rules conflict with bind_instead_of_map\n-            if let hir::ExprKind::Path(ref path) = func.kind;\n-            if match_any_qpath(path, &[&[\"Some\"], &[\"Ok\"], &[\"Err\"]]);\n-            then {\n-                // Recursively check all arguments\n-                args.iter().all(|arg| can_simplify(arg, params, variant_calls))\n-            } else {\n-                false\n-            }\n-        },\n-\n-        // For anything more complex than the above, a closure is probably the right solution,\n-        // or the case is handled by an other lint\n-        _ => false,\n-    }\n-}\n-\n /// lint use of `<fn>_else(simple closure)` for `Option`s and `Result`s that can be\n /// replaced with `<fn>(return value of simple closure)`\n pub(super) fn lint<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     args: &'tcx [hir::Expr<'_>],\n-    allow_variant_calls: bool,\n     simplify_using: &str,\n ) {\n     let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym!(option_type));\n@@ -81,10 +20,13 @@ pub(super) fn lint<'tcx>(\n     if is_option || is_result {\n         if let hir::ExprKind::Closure(_, _, eid, _, _) = args[1].kind {\n             let body = cx.tcx.hir().body(eid);\n-            let ex = &body.value;\n-            let params = &body.params;\n+            let body_expr = &body.value;\n+\n+            if usage::BindingUsageFinder::are_params_used(cx, body) {\n+                return;\n+            }\n \n-            if can_simplify(ex, params, allow_variant_calls) {\n+            if eager_or_lazy::is_eagerness_candidate(cx, body_expr) {\n                 let msg = if is_option {\n                     \"unnecessary closure used to substitute value for `Option::None`\"\n                 } else {\n@@ -101,7 +43,7 @@ pub(super) fn lint<'tcx>(\n                         \"{0}.{1}({2})\",\n                         snippet(cx, args[0].span, \"..\"),\n                         simplify_using,\n-                        snippet(cx, ex.span, \"..\"),\n+                        snippet(cx, body_expr.span, \"..\"),\n                     ),\n                     Applicability::MachineApplicable,\n                 );"}, {"sha": "5e2652b48cb2aeaf6d876bd36852e625b17ac1ba", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82", "patch": "@@ -1,4 +1,5 @@\n use crate::utils;\n+use crate::utils::eager_or_lazy;\n use crate::utils::sugg::Sugg;\n use crate::utils::{match_type, paths, span_lint_and_sugg};\n use if_chain::if_chain;\n@@ -13,22 +14,16 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n declare_clippy_lint! {\n     /// **What it does:**\n     /// Lints usage of  `if let Some(v) = ... { y } else { x }` which is more\n-    /// idiomatically done with `Option::map_or` (if the else bit is a simple\n-    /// expression) or `Option::map_or_else` (if the else bit is a longer\n-    /// block).\n+    /// idiomatically done with `Option::map_or` (if the else bit is a pure\n+    /// expression) or `Option::map_or_else` (if the else bit is an impure\n+    /// expresion).\n     ///\n     /// **Why is this bad?**\n     /// Using the dedicated functions of the Option type is clearer and\n     /// more concise than an if let expression.\n     ///\n     /// **Known problems:**\n-    /// This lint uses whether the block is just an expression or if it has\n-    /// more statements to decide whether to use `Option::map_or` or\n-    /// `Option::map_or_else`. If you have a single expression which calls\n-    /// an expensive function, then it would be more efficient to use\n-    /// `Option::map_or_else`, but this lint would suggest `Option::map_or`.\n-    ///\n-    /// Also, this lint uses a deliberately conservative metric for checking\n+    /// This lint uses a deliberately conservative metric for checking\n     /// if the inside of either body contains breaks or continues which will\n     /// cause it to not suggest a fix if either block contains a loop with\n     /// continues or breaks contained within the loop.\n@@ -92,13 +87,15 @@ struct OptionIfLetElseOccurence {\n struct ReturnBreakContinueMacroVisitor {\n     seen_return_break_continue: bool,\n }\n+\n impl ReturnBreakContinueMacroVisitor {\n     fn new() -> ReturnBreakContinueMacroVisitor {\n         ReturnBreakContinueMacroVisitor {\n             seen_return_break_continue: false,\n         }\n     }\n }\n+\n impl<'tcx> Visitor<'tcx> for ReturnBreakContinueMacroVisitor {\n     type Map = Map<'tcx>;\n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n@@ -157,7 +154,7 @@ fn extract_body_from_arm<'a>(arm: &'a Arm<'a>) -> Option<&'a Expr<'a>> {\n }\n \n /// If this is the else body of an if/else expression, then we need to wrap\n-/// it in curcly braces. Otherwise, we don't.\n+/// it in curly braces. Otherwise, we don't.\n fn should_wrap_in_braces(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     utils::get_enclosing_block(cx, expr.hir_id).map_or(false, |parent| {\n         if let Some(Expr {\n@@ -199,7 +196,10 @@ fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: boo\n /// If this expression is the option if let/else construct we're detecting, then\n /// this function returns an `OptionIfLetElseOccurence` struct with details if\n /// this construct is found, or None if this construct is not found.\n-fn detect_option_if_let_else(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<OptionIfLetElseOccurence> {\n+fn detect_option_if_let_else<'tcx>(\n+    cx: &'_ LateContext<'tcx>,\n+    expr: &'_ Expr<'tcx>,\n+) -> Option<OptionIfLetElseOccurence> {\n     if_chain! {\n         if !utils::in_macro(expr.span); // Don't lint macros, because it behaves weirdly\n         if let ExprKind::Match(cond_expr, arms, MatchSource::IfLetDesugar{contains_else_clause: true}) = &expr.kind;\n@@ -214,10 +214,7 @@ fn detect_option_if_let_else(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Op\n             let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n             let some_body = extract_body_from_arm(&arms[0])?;\n             let none_body = extract_body_from_arm(&arms[1])?;\n-            let method_sugg = match &none_body.kind {\n-                ExprKind::Block(..) => \"map_or_else\",\n-                _ => \"map_or\",\n-            };\n+            let method_sugg = if eager_or_lazy::is_eagerness_candidate(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n             let capture_name = id.name.to_ident_string();\n             let wrap_braces = should_wrap_in_braces(cx, expr);\n             let (as_ref, as_mut) = match &cond_expr.kind {\n@@ -243,8 +240,8 @@ fn detect_option_if_let_else(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Op\n     }\n }\n \n-impl<'a> LateLintPass<'a> for OptionIfLetElse {\n-    fn check_expr(&mut self, cx: &LateContext<'a>, expr: &Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for OptionIfLetElse {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n         if let Some(detection) = detect_option_if_let_else(cx, expr) {\n             span_lint_and_sugg(\n                 cx,"}, {"sha": "6938d9971d96d0d8dc97bcac113d0e54a3a27c8d", "filename": "clippy_lints/src/utils/eager_or_lazy.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs?ref=6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82", "patch": "@@ -0,0 +1,128 @@\n+//! Utilities for evaluating whether eagerly evaluated expressions can be made lazy and vice versa.\n+//!\n+//! Things to consider:\n+//!  - has the expression side-effects?\n+//!  - is the expression computationally expensive?\n+//!\n+//! See lints:\n+//!  - unnecessary-lazy-evaluations\n+//!  - or-fun-call\n+//!  - option-if-let-else\n+\n+use crate::utils::is_ctor_or_promotable_const_function;\n+use rustc_hir::def::{DefKind, Res};\n+\n+use rustc_hir::intravisit;\n+use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n+\n+use rustc_hir::{Block, Expr, ExprKind, Path, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+\n+/// Is the expr pure (is it free from side-effects)?\n+/// This function is named so to stress that it isn't exhaustive and returns FNs.\n+fn identify_some_pure_patterns(expr: &Expr<'_>) -> bool {\n+    match expr.kind {\n+        ExprKind::Lit(..) | ExprKind::Path(..) | ExprKind::Field(..) => true,\n+        ExprKind::AddrOf(_, _, addr_of_expr) => identify_some_pure_patterns(addr_of_expr),\n+        ExprKind::Tup(tup_exprs) => tup_exprs.iter().all(|expr| identify_some_pure_patterns(expr)),\n+        ExprKind::Struct(_, fields, expr) => {\n+            fields.iter().all(|f| identify_some_pure_patterns(f.expr))\n+                && expr.map_or(true, |e| identify_some_pure_patterns(e))\n+        },\n+        ExprKind::Call(\n+            &Expr {\n+                kind:\n+                    ExprKind::Path(QPath::Resolved(\n+                        _,\n+                        Path {\n+                            res: Res::Def(DefKind::Ctor(..) | DefKind::Variant, ..),\n+                            ..\n+                        },\n+                    )),\n+                ..\n+            },\n+            args,\n+        ) => args.iter().all(|expr| identify_some_pure_patterns(expr)),\n+        ExprKind::Block(\n+            &Block {\n+                stmts,\n+                expr: Some(expr),\n+                ..\n+            },\n+            _,\n+        ) => stmts.is_empty() && identify_some_pure_patterns(expr),\n+        ExprKind::Box(..)\n+        | ExprKind::Array(..)\n+        | ExprKind::Call(..)\n+        | ExprKind::MethodCall(..)\n+        | ExprKind::Binary(..)\n+        | ExprKind::Unary(..)\n+        | ExprKind::Cast(..)\n+        | ExprKind::Type(..)\n+        | ExprKind::DropTemps(..)\n+        | ExprKind::Loop(..)\n+        | ExprKind::Match(..)\n+        | ExprKind::Closure(..)\n+        | ExprKind::Block(..)\n+        | ExprKind::Assign(..)\n+        | ExprKind::AssignOp(..)\n+        | ExprKind::Index(..)\n+        | ExprKind::Break(..)\n+        | ExprKind::Continue(..)\n+        | ExprKind::Ret(..)\n+        | ExprKind::InlineAsm(..)\n+        | ExprKind::LlvmInlineAsm(..)\n+        | ExprKind::Repeat(..)\n+        | ExprKind::Yield(..)\n+        | ExprKind::Err => false,\n+    }\n+}\n+\n+/// Identify some potentially computationally expensive patterns.\n+/// This function is named so to stress that its implementation is non-exhaustive.\n+/// It returns FNs and FPs.\n+fn identify_some_potentially_expensive_patterns<'a, 'tcx>(cx: &'a LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    // Searches an expression for method calls or function calls that aren't ctors\n+    struct FunCallFinder<'a, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        found: bool,\n+    }\n+\n+    impl<'a, 'tcx> intravisit::Visitor<'tcx> for FunCallFinder<'a, 'tcx> {\n+        type Map = Map<'tcx>;\n+\n+        fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+            let call_found = match &expr.kind {\n+                // ignore enum and struct constructors\n+                ExprKind::Call(..) => !is_ctor_or_promotable_const_function(self.cx, expr),\n+                ExprKind::MethodCall(..) => true,\n+                _ => false,\n+            };\n+\n+            if call_found {\n+                self.found |= true;\n+            }\n+\n+            if !self.found {\n+                intravisit::walk_expr(self, expr);\n+            }\n+        }\n+\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n+        }\n+    }\n+\n+    let mut finder = FunCallFinder { cx, found: false };\n+    finder.visit_expr(expr);\n+    finder.found\n+}\n+\n+pub fn is_eagerness_candidate<'a, 'tcx>(cx: &'a LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    !identify_some_potentially_expensive_patterns(cx, expr) && identify_some_pure_patterns(expr)\n+}\n+\n+pub fn is_lazyness_candidate<'a, 'tcx>(cx: &'a LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    identify_some_potentially_expensive_patterns(cx, expr)\n+}"}, {"sha": "7efeef62690411fbb89f2f40930c87367e645eaf", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82", "patch": "@@ -10,6 +10,7 @@ pub mod comparisons;\n pub mod conf;\n pub mod constants;\n mod diagnostics;\n+pub mod eager_or_lazy;\n pub mod higher;\n mod hir_utils;\n pub mod inspector;"}, {"sha": "ec8b7e59b597633cf3cb19a4c725e26a34e522f0", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82", "patch": "@@ -49,7 +49,7 @@ impl<'a> Sugg<'a> {\n     /// Convenience function around `hir_opt` for suggestions with a default\n     /// text.\n     pub fn hir(cx: &LateContext<'_>, expr: &hir::Expr<'_>, default: &'a str) -> Self {\n-        Self::hir_opt(cx, expr).unwrap_or_else(|| Sugg::NonParen(Cow::Borrowed(default)))\n+        Self::hir_opt(cx, expr).unwrap_or(Sugg::NonParen(Cow::Borrowed(default)))\n     }\n \n     /// Same as `hir`, but it adapts the applicability level by following rules:"}, {"sha": "ea1dc3be29ba027a95695f5d7c039901e252343e", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82", "patch": "@@ -1,6 +1,8 @@\n use crate::utils::match_var;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir as hir;\n use rustc_hir::def::Res;\n+use rustc_hir::intravisit;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{Expr, HirId, Path};\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -108,3 +110,67 @@ pub fn is_unused<'tcx>(ident: &'tcx Ident, body: &'tcx Expr<'_>) -> bool {\n     walk_expr(&mut visitor, body);\n     !visitor.used\n }\n+\n+pub struct ParamBindingIdCollector {\n+    binding_hir_ids: Vec<hir::HirId>,\n+}\n+impl<'tcx> ParamBindingIdCollector {\n+    fn collect_binding_hir_ids(body: &'tcx hir::Body<'tcx>) -> Vec<hir::HirId> {\n+        let mut finder = ParamBindingIdCollector {\n+            binding_hir_ids: Vec::new(),\n+        };\n+        finder.visit_body(body);\n+        finder.binding_hir_ids\n+    }\n+}\n+impl<'tcx> intravisit::Visitor<'tcx> for ParamBindingIdCollector {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n+        if let hir::PatKind::Binding(_, hir_id, ..) = param.pat.kind {\n+            self.binding_hir_ids.push(hir_id);\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::None\n+    }\n+}\n+\n+pub struct BindingUsageFinder<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    binding_ids: Vec<hir::HirId>,\n+    usage_found: bool,\n+}\n+impl<'a, 'tcx> BindingUsageFinder<'a, 'tcx> {\n+    pub fn are_params_used(cx: &'a LateContext<'tcx>, body: &'tcx hir::Body<'tcx>) -> bool {\n+        let mut finder = BindingUsageFinder {\n+            cx,\n+            binding_ids: ParamBindingIdCollector::collect_binding_hir_ids(body),\n+            usage_found: false,\n+        };\n+        finder.visit_body(body);\n+        finder.usage_found\n+    }\n+}\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for BindingUsageFinder<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n+        if !self.usage_found {\n+            intravisit::walk_expr(self, expr);\n+        }\n+    }\n+\n+    fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, _: hir::HirId) {\n+        if let hir::def::Res::Local(id) = path.res {\n+            if self.binding_ids.contains(&id) {\n+                self.usage_found = true;\n+            }\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+}"}, {"sha": "a7fb00a270577d64f9e3c9fa24cb2b96f6ffba38", "filename": "tests/ui/option_if_let_else.fixed", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/tests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/tests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.fixed?ref=6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n #![warn(clippy::option_if_let_else)]\n+#![allow(clippy::redundant_closure)]\n \n fn bad1(string: Option<&str>) -> (bool, &str) {\n     string.map_or((false, \"hello\"), |x| (true, x))\n@@ -36,6 +37,14 @@ fn longer_body(arg: Option<u32>) -> u32 {\n     })\n }\n \n+fn impure_else(arg: Option<i32>) {\n+    let side_effect = || {\n+        println!(\"return 1\");\n+        1\n+    };\n+    let _ = arg.map_or_else(|| side_effect(), |x| x);\n+}\n+\n fn test_map_or_else(arg: Option<u32>) {\n     let _ = arg.map_or_else(|| {\n         let mut y = 1;\n@@ -71,4 +80,5 @@ fn main() {\n     let _ = longer_body(None);\n     test_map_or_else(None);\n     let _ = negative_tests(None);\n+    let _ = impure_else(None);\n }"}, {"sha": "895fd86321faf01fe60fa80213d1c6a62df59bca", "filename": "tests/ui/option_if_let_else.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/tests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/tests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.rs?ref=6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n #![warn(clippy::option_if_let_else)]\n+#![allow(clippy::redundant_closure)]\n \n fn bad1(string: Option<&str>) -> (bool, &str) {\n     if let Some(x) = string {\n@@ -52,6 +53,19 @@ fn longer_body(arg: Option<u32>) -> u32 {\n     }\n }\n \n+fn impure_else(arg: Option<i32>) {\n+    let side_effect = || {\n+        println!(\"return 1\");\n+        1\n+    };\n+    let _ = if let Some(x) = arg {\n+        x\n+    } else {\n+        // map_or_else must be suggested\n+        side_effect()\n+    };\n+}\n+\n fn test_map_or_else(arg: Option<u32>) {\n     let _ = if let Some(x) = arg {\n         x * x * x * x\n@@ -89,4 +103,5 @@ fn main() {\n     let _ = longer_body(None);\n     test_map_or_else(None);\n     let _ = negative_tests(None);\n+    let _ = impure_else(None);\n }"}, {"sha": "b69fe7676827058f6cbda555238c035ca29e71a3", "filename": "tests/ui/option_if_let_else.stderr", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/tests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/tests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.stderr?ref=6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82", "patch": "@@ -1,5 +1,5 @@\n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:5:5\n+  --> $DIR/option_if_let_else.rs:6:5\n    |\n LL | /     if let Some(x) = string {\n LL | |         (true, x)\n@@ -11,7 +11,7 @@ LL | |     }\n    = note: `-D clippy::option-if-let-else` implied by `-D warnings`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:15:12\n+  --> $DIR/option_if_let_else.rs:16:12\n    |\n LL |       } else if let Some(x) = string {\n    |  ____________^\n@@ -22,19 +22,19 @@ LL | |     }\n    | |_____^ help: try: `{ string.map_or(Some((false, \"\")), |x| Some((true, x))) }`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:23:13\n+  --> $DIR/option_if_let_else.rs:24:13\n    |\n LL |     let _ = if let Some(s) = *string { s.len() } else { 0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `string.map_or(0, |s| s.len())`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:24:13\n+  --> $DIR/option_if_let_else.rs:25:13\n    |\n LL |     let _ = if let Some(s) = &num { s } else { &0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:25:13\n+  --> $DIR/option_if_let_else.rs:26:13\n    |\n LL |       let _ = if let Some(s) = &mut num {\n    |  _____________^\n@@ -54,13 +54,13 @@ LL |     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:31:13\n+  --> $DIR/option_if_let_else.rs:32:13\n    |\n LL |     let _ = if let Some(ref s) = num { s } else { &0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:32:13\n+  --> $DIR/option_if_let_else.rs:33:13\n    |\n LL |       let _ = if let Some(mut s) = num {\n    |  _____________^\n@@ -80,7 +80,7 @@ LL |     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:38:13\n+  --> $DIR/option_if_let_else.rs:39:13\n    |\n LL |       let _ = if let Some(ref mut s) = num {\n    |  _____________^\n@@ -100,7 +100,7 @@ LL |     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:47:5\n+  --> $DIR/option_if_let_else.rs:48:5\n    |\n LL | /     if let Some(x) = arg {\n LL | |         let y = x * x;\n@@ -119,7 +119,19 @@ LL |     })\n    |\n \n error: use Option::map_or_else instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:56:13\n+  --> $DIR/option_if_let_else.rs:61:13\n+   |\n+LL |       let _ = if let Some(x) = arg {\n+   |  _____________^\n+LL | |         x\n+LL | |     } else {\n+LL | |         // map_or_else must be suggested\n+LL | |         side_effect()\n+LL | |     };\n+   | |_____^ help: try: `arg.map_or_else(|| side_effect(), |x| x)`\n+\n+error: use Option::map_or_else instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:70:13\n    |\n LL |       let _ = if let Some(x) = arg {\n    |  _____________^\n@@ -142,10 +154,10 @@ LL |     }, |x| x * x * x * x);\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:85:13\n+  --> $DIR/option_if_let_else.rs:99:13\n    |\n LL |     let _ = if let Some(x) = optional { x + 2 } else { 5 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `optional.map_or(5, |x| x + 2)`\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 12 previous errors\n "}, {"sha": "4980c1114999c4e9a8906327203c1da1b2485d2c", "filename": "tests/ui/unnecessary_lazy_eval.fixed", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/tests%2Fui%2Funnecessary_lazy_eval.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/tests%2Fui%2Funnecessary_lazy_eval.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval.fixed?ref=6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82", "patch": "@@ -2,6 +2,7 @@\n #![warn(clippy::unnecessary_lazy_evaluations)]\n #![allow(clippy::redundant_closure)]\n #![allow(clippy::bind_instead_of_map)]\n+#![allow(clippy::map_identity)]\n \n struct Deep(Option<usize>);\n \n@@ -34,13 +35,13 @@ fn main() {\n     let _ = opt.unwrap_or(2);\n     let _ = opt.unwrap_or(astronomers_pi);\n     let _ = opt.unwrap_or(ext_str.some_field);\n-    let _ = opt.unwrap_or(ext_arr[0]);\n+    let _ = opt.unwrap_or_else(|| ext_arr[0]);\n     let _ = opt.and(ext_opt);\n     let _ = opt.or(ext_opt);\n     let _ = opt.or(None);\n     let _ = opt.get_or_insert(2);\n     let _ = opt.ok_or(2);\n-    let _ = opt.ok_or(ext_arr[0]);\n+    let _ = nested_tuple_opt.unwrap_or(Some((1, 2)));\n \n     // Cases when unwrap is not called on a simple variable\n     let _ = Some(10).unwrap_or(2);\n@@ -60,7 +61,6 @@ fn main() {\n     // Should not lint - Option\n     let _ = opt.unwrap_or_else(|| ext_str.return_some_field());\n     let _ = nested_opt.unwrap_or_else(|| Some(some_call()));\n-    let _ = nested_tuple_opt.unwrap_or_else(|| Some((1, 2)));\n     let _ = nested_tuple_opt.unwrap_or_else(|| Some((some_call(), some_call())));\n     let _ = opt.or_else(some_call);\n     let _ = opt.or_else(|| some_call());\n@@ -69,13 +69,16 @@ fn main() {\n     let _ = deep.0.get_or_insert_with(|| some_call());\n     let _ = deep.0.or_else(some_call);\n     let _ = deep.0.or_else(|| some_call());\n+    let _ = opt.ok_or_else(|| ext_arr[0]);\n \n-    // These are handled by bind_instead_of_map\n+    // should not lint, bind_instead_of_map takes priority\n     let _ = Some(10).and_then(|idx| Some(ext_arr[idx]));\n     let _ = Some(10).and_then(|idx| Some(idx));\n-    let _: Option<usize> = None.or_else(|| Some(3));\n-    let _ = deep.0.or_else(|| Some(3));\n-    let _ = opt.or_else(|| Some(3));\n+\n+    // should lint, bind_instead_of_map doesn't apply\n+    let _: Option<usize> = None.or(Some(3));\n+    let _ = deep.0.or(Some(3));\n+    let _ = opt.or(Some(3));\n \n     // Should lint - Result\n     let res: Result<usize, usize> = Err(5);\n@@ -92,26 +95,27 @@ fn main() {\n     let _ = res2.unwrap_or_else(|err| err.return_some_field());\n     let _ = res2.unwrap_or_else(|_| ext_str.return_some_field());\n \n+    // should not lint, bind_instead_of_map takes priority\n     let _: Result<usize, usize> = res.and_then(|x| Ok(x));\n-    let _: Result<usize, usize> = res.and_then(|x| Err(x));\n-\n-    let _: Result<usize, usize> = res.or_else(|err| Ok(err));\n     let _: Result<usize, usize> = res.or_else(|err| Err(err));\n \n-    // These are handled by bind_instead_of_map\n     let _: Result<usize, usize> = res.and_then(|_| Ok(2));\n     let _: Result<usize, usize> = res.and_then(|_| Ok(astronomers_pi));\n     let _: Result<usize, usize> = res.and_then(|_| Ok(ext_str.some_field));\n \n-    let _: Result<usize, usize> = res.and_then(|_| Err(2));\n-    let _: Result<usize, usize> = res.and_then(|_| Err(astronomers_pi));\n-    let _: Result<usize, usize> = res.and_then(|_| Err(ext_str.some_field));\n-\n-    let _: Result<usize, usize> = res.or_else(|_| Ok(2));\n-    let _: Result<usize, usize> = res.or_else(|_| Ok(astronomers_pi));\n-    let _: Result<usize, usize> = res.or_else(|_| Ok(ext_str.some_field));\n-\n     let _: Result<usize, usize> = res.or_else(|_| Err(2));\n     let _: Result<usize, usize> = res.or_else(|_| Err(astronomers_pi));\n     let _: Result<usize, usize> = res.or_else(|_| Err(ext_str.some_field));\n+\n+    // should lint, bind_instead_of_map doesn't apply\n+    let _: Result<usize, usize> = res.and_then(|x| Err(x));\n+    let _: Result<usize, usize> = res.or_else(|err| Ok(err));\n+\n+    let _: Result<usize, usize> = res.and(Err(2));\n+    let _: Result<usize, usize> = res.and(Err(astronomers_pi));\n+    let _: Result<usize, usize> = res.and(Err(ext_str.some_field));\n+\n+    let _: Result<usize, usize> = res.or(Ok(2));\n+    let _: Result<usize, usize> = res.or(Ok(astronomers_pi));\n+    let _: Result<usize, usize> = res.or(Ok(ext_str.some_field));\n }"}, {"sha": "0b270939ec20a2dc4fc8b9765601b21c2907feb5", "filename": "tests/ui/unnecessary_lazy_eval.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/tests%2Fui%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/tests%2Fui%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval.rs?ref=6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82", "patch": "@@ -2,6 +2,7 @@\n #![warn(clippy::unnecessary_lazy_evaluations)]\n #![allow(clippy::redundant_closure)]\n #![allow(clippy::bind_instead_of_map)]\n+#![allow(clippy::map_identity)]\n \n struct Deep(Option<usize>);\n \n@@ -40,7 +41,7 @@ fn main() {\n     let _ = opt.or_else(|| None);\n     let _ = opt.get_or_insert_with(|| 2);\n     let _ = opt.ok_or_else(|| 2);\n-    let _ = opt.ok_or_else(|| ext_arr[0]);\n+    let _ = nested_tuple_opt.unwrap_or_else(|| Some((1, 2)));\n \n     // Cases when unwrap is not called on a simple variable\n     let _ = Some(10).unwrap_or_else(|| 2);\n@@ -60,7 +61,6 @@ fn main() {\n     // Should not lint - Option\n     let _ = opt.unwrap_or_else(|| ext_str.return_some_field());\n     let _ = nested_opt.unwrap_or_else(|| Some(some_call()));\n-    let _ = nested_tuple_opt.unwrap_or_else(|| Some((1, 2)));\n     let _ = nested_tuple_opt.unwrap_or_else(|| Some((some_call(), some_call())));\n     let _ = opt.or_else(some_call);\n     let _ = opt.or_else(|| some_call());\n@@ -69,10 +69,13 @@ fn main() {\n     let _ = deep.0.get_or_insert_with(|| some_call());\n     let _ = deep.0.or_else(some_call);\n     let _ = deep.0.or_else(|| some_call());\n+    let _ = opt.ok_or_else(|| ext_arr[0]);\n \n-    // These are handled by bind_instead_of_map\n+    // should not lint, bind_instead_of_map takes priority\n     let _ = Some(10).and_then(|idx| Some(ext_arr[idx]));\n     let _ = Some(10).and_then(|idx| Some(idx));\n+\n+    // should lint, bind_instead_of_map doesn't apply\n     let _: Option<usize> = None.or_else(|| Some(3));\n     let _ = deep.0.or_else(|| Some(3));\n     let _ = opt.or_else(|| Some(3));\n@@ -92,26 +95,27 @@ fn main() {\n     let _ = res2.unwrap_or_else(|err| err.return_some_field());\n     let _ = res2.unwrap_or_else(|_| ext_str.return_some_field());\n \n+    // should not lint, bind_instead_of_map takes priority\n     let _: Result<usize, usize> = res.and_then(|x| Ok(x));\n-    let _: Result<usize, usize> = res.and_then(|x| Err(x));\n-\n-    let _: Result<usize, usize> = res.or_else(|err| Ok(err));\n     let _: Result<usize, usize> = res.or_else(|err| Err(err));\n \n-    // These are handled by bind_instead_of_map\n     let _: Result<usize, usize> = res.and_then(|_| Ok(2));\n     let _: Result<usize, usize> = res.and_then(|_| Ok(astronomers_pi));\n     let _: Result<usize, usize> = res.and_then(|_| Ok(ext_str.some_field));\n \n+    let _: Result<usize, usize> = res.or_else(|_| Err(2));\n+    let _: Result<usize, usize> = res.or_else(|_| Err(astronomers_pi));\n+    let _: Result<usize, usize> = res.or_else(|_| Err(ext_str.some_field));\n+\n+    // should lint, bind_instead_of_map doesn't apply\n+    let _: Result<usize, usize> = res.and_then(|x| Err(x));\n+    let _: Result<usize, usize> = res.or_else(|err| Ok(err));\n+\n     let _: Result<usize, usize> = res.and_then(|_| Err(2));\n     let _: Result<usize, usize> = res.and_then(|_| Err(astronomers_pi));\n     let _: Result<usize, usize> = res.and_then(|_| Err(ext_str.some_field));\n \n     let _: Result<usize, usize> = res.or_else(|_| Ok(2));\n     let _: Result<usize, usize> = res.or_else(|_| Ok(astronomers_pi));\n     let _: Result<usize, usize> = res.or_else(|_| Ok(ext_str.some_field));\n-\n-    let _: Result<usize, usize> = res.or_else(|_| Err(2));\n-    let _: Result<usize, usize> = res.or_else(|_| Err(astronomers_pi));\n-    let _: Result<usize, usize> = res.or_else(|_| Err(ext_str.some_field));\n }"}, {"sha": "1cf7ac46346db214afd11b68981018ebcd57203c", "filename": "tests/ui/unnecessary_lazy_eval.stderr", "status": "modified", "additions": 80, "deletions": 32, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/tests%2Fui%2Funnecessary_lazy_eval.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82/tests%2Fui%2Funnecessary_lazy_eval.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval.stderr?ref=6ba36bcfd3802d9520d0ac48dabfe6dc06d8dc82", "patch": "@@ -1,148 +1,196 @@\n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:34:13\n+  --> $DIR/unnecessary_lazy_eval.rs:35:13\n    |\n LL |     let _ = opt.unwrap_or_else(|| 2);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(2)`\n    |\n    = note: `-D clippy::unnecessary-lazy-evaluations` implied by `-D warnings`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:35:13\n+  --> $DIR/unnecessary_lazy_eval.rs:36:13\n    |\n LL |     let _ = opt.unwrap_or_else(|| astronomers_pi);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(astronomers_pi)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:36:13\n+  --> $DIR/unnecessary_lazy_eval.rs:37:13\n    |\n LL |     let _ = opt.unwrap_or_else(|| ext_str.some_field);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(ext_str.some_field)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:37:13\n-   |\n-LL |     let _ = opt.unwrap_or_else(|| ext_arr[0]);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(ext_arr[0])`\n-\n-error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:38:13\n+  --> $DIR/unnecessary_lazy_eval.rs:39:13\n    |\n LL |     let _ = opt.and_then(|_| ext_opt);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `opt.and(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:39:13\n+  --> $DIR/unnecessary_lazy_eval.rs:40:13\n    |\n LL |     let _ = opt.or_else(|| ext_opt);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `opt.or(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:40:13\n+  --> $DIR/unnecessary_lazy_eval.rs:41:13\n    |\n LL |     let _ = opt.or_else(|| None);\n    |             ^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `opt.or(None)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:41:13\n+  --> $DIR/unnecessary_lazy_eval.rs:42:13\n    |\n LL |     let _ = opt.get_or_insert_with(|| 2);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `opt.get_or_insert(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:42:13\n+  --> $DIR/unnecessary_lazy_eval.rs:43:13\n    |\n LL |     let _ = opt.ok_or_else(|| 2);\n    |             ^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `opt.ok_or(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:43:13\n+  --> $DIR/unnecessary_lazy_eval.rs:44:13\n    |\n-LL |     let _ = opt.ok_or_else(|| ext_arr[0]);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `opt.ok_or(ext_arr[0])`\n+LL |     let _ = nested_tuple_opt.unwrap_or_else(|| Some((1, 2)));\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `nested_tuple_opt.unwrap_or(Some((1, 2)))`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:46:13\n+  --> $DIR/unnecessary_lazy_eval.rs:47:13\n    |\n LL |     let _ = Some(10).unwrap_or_else(|| 2);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `Some(10).unwrap_or(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:47:13\n+  --> $DIR/unnecessary_lazy_eval.rs:48:13\n    |\n LL |     let _ = Some(10).and_then(|_| ext_opt);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `Some(10).and(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:48:28\n+  --> $DIR/unnecessary_lazy_eval.rs:49:28\n    |\n LL |     let _: Option<usize> = None.or_else(|| ext_opt);\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `None.or(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:49:13\n+  --> $DIR/unnecessary_lazy_eval.rs:50:13\n    |\n LL |     let _ = None.get_or_insert_with(|| 2);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `None.get_or_insert(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:50:35\n+  --> $DIR/unnecessary_lazy_eval.rs:51:35\n    |\n LL |     let _: Result<usize, usize> = None.ok_or_else(|| 2);\n    |                                   ^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `None.ok_or(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:51:28\n+  --> $DIR/unnecessary_lazy_eval.rs:52:28\n    |\n LL |     let _: Option<usize> = None.or_else(|| None);\n    |                            ^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `None.or(None)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:54:13\n+  --> $DIR/unnecessary_lazy_eval.rs:55:13\n    |\n LL |     let _ = deep.0.unwrap_or_else(|| 2);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `deep.0.unwrap_or(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:55:13\n+  --> $DIR/unnecessary_lazy_eval.rs:56:13\n    |\n LL |     let _ = deep.0.and_then(|_| ext_opt);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `deep.0.and(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:56:13\n+  --> $DIR/unnecessary_lazy_eval.rs:57:13\n    |\n LL |     let _ = deep.0.or_else(|| None);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `deep.0.or(None)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:57:13\n+  --> $DIR/unnecessary_lazy_eval.rs:58:13\n    |\n LL |     let _ = deep.0.get_or_insert_with(|| 2);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `deep.0.get_or_insert(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n-  --> $DIR/unnecessary_lazy_eval.rs:58:13\n+  --> $DIR/unnecessary_lazy_eval.rs:59:13\n    |\n LL |     let _ = deep.0.ok_or_else(|| 2);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `deep.0.ok_or(2)`\n \n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:79:28\n+   |\n+LL |     let _: Option<usize> = None.or_else(|| Some(3));\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `None.or(Some(3))`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:80:13\n+   |\n+LL |     let _ = deep.0.or_else(|| Some(3));\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `deep.0.or(Some(3))`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:81:13\n+   |\n+LL |     let _ = opt.or_else(|| Some(3));\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `opt.or(Some(3))`\n+\n error: unnecessary closure used to substitute value for `Result::Err`\n-  --> $DIR/unnecessary_lazy_eval.rs:84:13\n+  --> $DIR/unnecessary_lazy_eval.rs:87:13\n    |\n LL |     let _ = res2.unwrap_or_else(|_| 2);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(2)`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n-  --> $DIR/unnecessary_lazy_eval.rs:85:13\n+  --> $DIR/unnecessary_lazy_eval.rs:88:13\n    |\n LL |     let _ = res2.unwrap_or_else(|_| astronomers_pi);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(astronomers_pi)`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n-  --> $DIR/unnecessary_lazy_eval.rs:86:13\n+  --> $DIR/unnecessary_lazy_eval.rs:89:13\n    |\n LL |     let _ = res2.unwrap_or_else(|_| ext_str.some_field);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(ext_str.some_field)`\n \n-error: aborting due to 24 previous errors\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:114:35\n+   |\n+LL |     let _: Result<usize, usize> = res.and_then(|_| Err(2));\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `res.and(Err(2))`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:115:35\n+   |\n+LL |     let _: Result<usize, usize> = res.and_then(|_| Err(astronomers_pi));\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `res.and(Err(astronomers_pi))`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:116:35\n+   |\n+LL |     let _: Result<usize, usize> = res.and_then(|_| Err(ext_str.some_field));\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `res.and(Err(ext_str.some_field))`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:118:35\n+   |\n+LL |     let _: Result<usize, usize> = res.or_else(|_| Ok(2));\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `res.or(Ok(2))`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:119:35\n+   |\n+LL |     let _: Result<usize, usize> = res.or_else(|_| Ok(astronomers_pi));\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `res.or(Ok(astronomers_pi))`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:120:35\n+   |\n+LL |     let _: Result<usize, usize> = res.or_else(|_| Ok(ext_str.some_field));\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `res.or(Ok(ext_str.some_field))`\n+\n+error: aborting due to 32 previous errors\n "}]}