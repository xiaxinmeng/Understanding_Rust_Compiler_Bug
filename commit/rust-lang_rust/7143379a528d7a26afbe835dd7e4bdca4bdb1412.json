{"sha": "7143379a528d7a26afbe835dd7e4bdca4bdb1412", "node_id": "C_kwDOAAsO6NoAKDcxNDMzNzlhNTI4ZDdhMjZhZmJlODM1ZGQ3ZTRiZGNhNGJkYjE0MTI", "commit": {"author": {"name": "Stefan Lankes", "email": "slankes@eonerc.rwth-aachen.de", "date": "2022-12-06T19:31:43Z"}, "committer": {"name": "Stefan Lankes", "email": "slankes@eonerc.rwth-aachen.de", "date": "2023-02-24T14:30:14Z"}, "message": "add support of RustyHermit's BSD socket layer\n\nRustHermit publishs a new kernel interface and supports\na common BSD socket layer. By supporting this interface,\nthe implementation can be harmonized to other operating systems.\n\nTo realize this socket layer, the handling of file descriptors\nis also harmonized to other operating systems.", "tree": {"sha": "8c4dd43751cdaf603f3ec9cffa1034c942b170d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c4dd43751cdaf603f3ec9cffa1034c942b170d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7143379a528d7a26afbe835dd7e4bdca4bdb1412", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7143379a528d7a26afbe835dd7e4bdca4bdb1412", "html_url": "https://github.com/rust-lang/rust/commit/7143379a528d7a26afbe835dd7e4bdca4bdb1412", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7143379a528d7a26afbe835dd7e4bdca4bdb1412/comments", "author": {"login": "stlankes", "id": 5888473, "node_id": "MDQ6VXNlcjU4ODg0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/5888473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stlankes", "html_url": "https://github.com/stlankes", "followers_url": "https://api.github.com/users/stlankes/followers", "following_url": "https://api.github.com/users/stlankes/following{/other_user}", "gists_url": "https://api.github.com/users/stlankes/gists{/gist_id}", "starred_url": "https://api.github.com/users/stlankes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stlankes/subscriptions", "organizations_url": "https://api.github.com/users/stlankes/orgs", "repos_url": "https://api.github.com/users/stlankes/repos", "events_url": "https://api.github.com/users/stlankes/events{/privacy}", "received_events_url": "https://api.github.com/users/stlankes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "stlankes", "id": 5888473, "node_id": "MDQ6VXNlcjU4ODg0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/5888473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stlankes", "html_url": "https://github.com/stlankes", "followers_url": "https://api.github.com/users/stlankes/followers", "following_url": "https://api.github.com/users/stlankes/following{/other_user}", "gists_url": "https://api.github.com/users/stlankes/gists{/gist_id}", "starred_url": "https://api.github.com/users/stlankes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stlankes/subscriptions", "organizations_url": "https://api.github.com/users/stlankes/orgs", "repos_url": "https://api.github.com/users/stlankes/repos", "events_url": "https://api.github.com/users/stlankes/events{/privacy}", "received_events_url": "https://api.github.com/users/stlankes/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07c993eba8b76eae497e98433ae075b00f01be10", "url": "https://api.github.com/repos/rust-lang/rust/commits/07c993eba8b76eae497e98433ae075b00f01be10", "html_url": "https://github.com/rust-lang/rust/commit/07c993eba8b76eae497e98433ae075b00f01be10"}], "stats": {"total": 1271, "additions": 812, "deletions": 459}, "files": [{"sha": "d86b8018b7979d22ac6697f4313a956f1f40a0a7", "filename": "Cargo.lock", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7143379a528d7a26afbe835dd7e4bdca4bdb1412/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7143379a528d7a26afbe835dd7e4bdca4bdb1412/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7143379a528d7a26afbe835dd7e4bdca4bdb1412", "patch": "@@ -1927,8 +1927,16 @@ version = \"0.2.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ee512640fe35acbfb4bb779db6f0d80704c2cacfa2e39b601ef3e3f47d1ae4c7\"\n dependencies = [\n- \"compiler_builtins\",\n  \"libc\",\n+]\n+\n+[[package]]\n+name = \"hermit-abi\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"856b5cb0902c2b6d65d5fd97dfa30f9b70c7538e770b98eab5ed52d8db923e01\"\n+dependencies = [\n+ \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n@@ -5294,7 +5302,7 @@ dependencies = [\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n  \"hashbrown 0.12.3\",\n- \"hermit-abi 0.2.6\",\n+ \"hermit-abi 0.3.0\",\n  \"libc\",\n  \"miniz_oxide\",\n  \"object 0.29.0\","}, {"sha": "311b2e21c17a6ad6f561cff85fa8c0e1621799be", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=7143379a528d7a26afbe835dd7e4bdca4bdb1412", "patch": "@@ -43,7 +43,7 @@ dlmalloc = { version = \"0.2.3\", features = ['rustc-dep-of-std'] }\n fortanix-sgx-abi = { version = \"0.5.0\", features = ['rustc-dep-of-std'] }\n \n [target.'cfg(target_os = \"hermit\")'.dependencies]\n-hermit-abi = { version = \"0.2.6\", features = ['rustc-dep-of-std'] }\n+hermit-abi = { version = \"0.3.0\", features = ['rustc-dep-of-std'] }\n \n [target.wasm32-wasi.dependencies]\n wasi = { version = \"0.11.0\", features = ['rustc-dep-of-std'], default-features = false }"}, {"sha": "d8c741f7f4e118e7dcb75198c703aa3c8a020493", "filename": "library/std/src/os/hermit/io.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2Fsrc%2Fos%2Fhermit%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2Fsrc%2Fos%2Fhermit%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fhermit%2Fio.rs?ref=7143379a528d7a26afbe835dd7e4bdca4bdb1412", "patch": "@@ -0,0 +1,6 @@\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use hermit_abi as abi;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub type RawFd = abi::FileDescriptor;"}, {"sha": "7f3c7ea1030d9b503b7503ac1a5f5aa694d9fc21", "filename": "library/std/src/sys/hermit/fd/mod.rs", "status": "renamed", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd%2Fmod.rs?ref=7143379a528d7a26afbe835dd7e4bdca4bdb1412", "patch": "@@ -1,36 +1,26 @@\n #![unstable(reason = \"not public\", issue = \"none\", feature = \"fd\")]\n \n+mod owned;\n+mod raw;\n+\n use crate::io::{self, Read};\n-use crate::mem;\n use crate::sys::cvt;\n use crate::sys::hermit::abi;\n use crate::sys::unsupported;\n-use crate::sys_common::AsInner;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n+\n+pub use self::owned::*;\n+pub use self::raw::*;\n \n #[derive(Debug)]\n pub struct FileDesc {\n-    fd: i32,\n+    fd: OwnedFd,\n }\n \n impl FileDesc {\n-    pub fn new(fd: i32) -> FileDesc {\n-        FileDesc { fd }\n-    }\n-\n-    pub fn raw(&self) -> i32 {\n-        self.fd\n-    }\n-\n-    /// Extracts the actual file descriptor without closing it.\n-    pub fn into_raw(self) -> i32 {\n-        let fd = self.fd;\n-        mem::forget(self);\n-        fd\n-    }\n-\n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        let result = unsafe { abi::read(self.fd, buf.as_mut_ptr(), buf.len()) };\n-        cvt(result as i32)\n+        let result = cvt(unsafe { abi::read(self.fd.as_raw_fd(), buf.as_mut_ptr(), buf.len()) })?;\n+        Ok(result as usize)\n     }\n \n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n@@ -39,8 +29,8 @@ impl FileDesc {\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        let result = unsafe { abi::write(self.fd, buf.as_ptr(), buf.len()) };\n-        cvt(result as i32)\n+        let result = cvt(unsafe { abi::write(self.fd.as_raw_fd(), buf.as_ptr(), buf.len()) })?;\n+        Ok(result as usize)\n     }\n \n     pub fn duplicate(&self) -> io::Result<FileDesc> {\n@@ -69,19 +59,39 @@ impl<'a> Read for &'a FileDesc {\n     }\n }\n \n-impl AsInner<i32> for FileDesc {\n-    fn as_inner(&self) -> &i32 {\n+impl IntoInner<OwnedFd> for FileDesc {\n+    fn into_inner(self) -> OwnedFd {\n+        self.fd\n+    }\n+}\n+\n+impl FromInner<OwnedFd> for FileDesc {\n+    fn from_inner(owned_fd: OwnedFd) -> Self {\n+        Self { fd: owned_fd }\n+    }\n+}\n+\n+impl FromRawFd for FileDesc {\n+    unsafe fn from_raw_fd(raw_fd: RawFd) -> Self {\n+        Self { fd: FromRawFd::from_raw_fd(raw_fd) }\n+    }\n+}\n+\n+impl AsInner<OwnedFd> for FileDesc {\n+    fn as_inner(&self) -> &OwnedFd {\n         &self.fd\n     }\n }\n \n-impl Drop for FileDesc {\n-    fn drop(&mut self) {\n-        // Note that errors are ignored when closing a file descriptor. The\n-        // reason for this is that if an error occurs we don't actually know if\n-        // the file descriptor was closed or not, and if we retried (for\n-        // something like EINTR), we might close another valid file descriptor\n-        // (opened after we closed ours.\n-        let _ = unsafe { abi::close(self.fd) };\n+impl AsFd for FileDesc {\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.fd.as_fd()\n+    }\n+}\n+\n+impl AsRawFd for FileDesc {\n+    #[inline]\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.fd.as_raw_fd()\n     }\n }", "previous_filename": "library/std/src/sys/hermit/fd.rs"}, {"sha": "7746cb3b259b7613a81f1aa98335b581e0613d5f", "filename": "library/std/src/sys/hermit/fd/owned.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd%2Fowned.rs?ref=7143379a528d7a26afbe835dd7e4bdca4bdb1412", "patch": "@@ -0,0 +1,238 @@\n+use super::raw::RawFd;\n+\n+use crate::marker::PhantomData;\n+use crate::mem::forget;\n+use crate::sys::fd::{AsRawFd, FromRawFd, IntoRawFd};\n+use crate::sys::hermit::abi;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n+\n+/// A borrowed file descriptor.\n+///\n+/// This has a lifetime parameter to tie it to the lifetime of something that\n+/// owns the file descriptor.\n+///\n+/// This uses `repr(transparent)` and has the representation of a host file\n+/// descriptor, so it can be used in FFI in places where a file descriptor is\n+/// passed as an argument, it is not captured or consumed, and it never has the\n+/// value `-1`.\n+///\n+/// This type's `.to_owned()` implementation returns another `BorrowedFd`\n+/// rather than an `OwnedFd`. It just makes a trivial copy of the raw file\n+/// descriptor, which is then borrowed under the same lifetime.\n+#[derive(Copy, Clone)]\n+#[repr(transparent)]\n+#[rustc_layout_scalar_valid_range_start(0)]\n+// libstd/os/raw/mod.rs assures me that every libstd-supported platform has a\n+// 32-bit c_int. Below is -2, in two's complement, but that only works out\n+// because c_int is 32 bits.\n+#[rustc_layout_scalar_valid_range_end(0xFF_FF_FF_FE)]\n+#[rustc_nonnull_optimization_guaranteed]\n+#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+pub struct BorrowedFd<'fd> {\n+    fd: RawFd,\n+    _phantom: PhantomData<&'fd OwnedFd>,\n+}\n+\n+/// An owned file descriptor.\n+///\n+/// This closes the file descriptor on drop.\n+///\n+/// This uses `repr(transparent)` and has the representation of a host file\n+/// descriptor, so it can be used in FFI in places where a file descriptor is\n+/// passed as a consumed argument or returned as an owned value, and it never\n+/// has the value `-1`.\n+#[repr(transparent)]\n+#[rustc_layout_scalar_valid_range_start(0)]\n+// libstd/os/raw/mod.rs assures me that every libstd-supported platform has a\n+// 32-bit c_int. Below is -2, in two's complement, but that only works out\n+// because c_int is 32 bits.\n+#[rustc_layout_scalar_valid_range_end(0xFF_FF_FF_FE)]\n+#[rustc_nonnull_optimization_guaranteed]\n+#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+#[derive(Debug)]\n+pub struct OwnedFd {\n+    fd: RawFd,\n+}\n+\n+impl BorrowedFd<'_> {\n+    /// Return a `BorrowedFd` holding the given raw file descriptor.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The resource pointed to by `fd` must remain open for the duration of\n+    /// the returned `BorrowedFd`, and it must not have the value `-1`.\n+    #[inline]\n+    #[rustc_const_stable(feature = \"io_safety\", since = \"1.63.0\")]\n+    #[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+    pub const unsafe fn borrow_raw(fd: RawFd) -> Self {\n+        assert!(fd != u32::MAX as RawFd);\n+        // SAFETY: we just asserted that the value is in the valid range and isn't `-1` (the only value bigger than `0xFF_FF_FF_FE` unsigned)\n+        unsafe { Self { fd, _phantom: PhantomData } }\n+    }\n+}\n+\n+#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+impl AsRawFd for BorrowedFd<'_> {\n+    #[inline]\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.fd\n+    }\n+}\n+\n+#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+impl AsRawFd for OwnedFd {\n+    #[inline]\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.fd\n+    }\n+}\n+\n+#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+impl IntoRawFd for OwnedFd {\n+    #[inline]\n+    fn into_raw_fd(self) -> RawFd {\n+        let fd = self.fd;\n+        forget(self);\n+        fd\n+    }\n+}\n+\n+#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+impl FromRawFd for OwnedFd {\n+    /// Constructs a new instance of `Self` from the given raw file descriptor.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The resource pointed to by `fd` must be open and suitable for assuming\n+    /// ownership. The resource must not require any cleanup other than `close`.\n+    #[inline]\n+    unsafe fn from_raw_fd(fd: RawFd) -> Self {\n+        assert_ne!(fd, u32::MAX as RawFd);\n+        // SAFETY: we just asserted that the value is in the valid range and isn't `-1` (the only value bigger than `0xFF_FF_FF_FE` unsigned)\n+        unsafe { Self { fd } }\n+    }\n+}\n+\n+#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+impl AsFd for crate::net::TcpStream {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.as_inner().socket().as_fd()\n+    }\n+}\n+\n+#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+impl From<crate::net::TcpStream> for OwnedFd {\n+    #[inline]\n+    fn from(tcp_stream: crate::net::TcpStream) -> OwnedFd {\n+        tcp_stream.into_inner().into_socket().into_inner().into_inner().into()\n+    }\n+}\n+\n+#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+impl From<OwnedFd> for crate::net::TcpStream {\n+    #[inline]\n+    fn from(owned_fd: OwnedFd) -> Self {\n+        Self::from_inner(FromInner::from_inner(FromInner::from_inner(FromInner::from_inner(\n+            owned_fd,\n+        ))))\n+    }\n+}\n+\n+#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+impl AsFd for crate::net::TcpListener {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.as_inner().socket().as_fd()\n+    }\n+}\n+\n+#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+impl From<crate::net::TcpListener> for OwnedFd {\n+    #[inline]\n+    fn from(tcp_listener: crate::net::TcpListener) -> OwnedFd {\n+        tcp_listener.into_inner().into_socket().into_inner().into_inner().into()\n+    }\n+}\n+\n+#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+impl From<OwnedFd> for crate::net::TcpListener {\n+    #[inline]\n+    fn from(owned_fd: OwnedFd) -> Self {\n+        Self::from_inner(FromInner::from_inner(FromInner::from_inner(FromInner::from_inner(\n+            owned_fd,\n+        ))))\n+    }\n+}\n+\n+#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+impl AsFd for crate::net::UdpSocket {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.as_inner().socket().as_fd()\n+    }\n+}\n+\n+#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+impl From<crate::net::UdpSocket> for OwnedFd {\n+    #[inline]\n+    fn from(udp_socket: crate::net::UdpSocket) -> OwnedFd {\n+        udp_socket.into_inner().into_socket().into_inner().into_inner().into()\n+    }\n+}\n+\n+#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+impl From<OwnedFd> for crate::net::UdpSocket {\n+    #[inline]\n+    fn from(owned_fd: OwnedFd) -> Self {\n+        Self::from_inner(FromInner::from_inner(FromInner::from_inner(FromInner::from_inner(\n+            owned_fd,\n+        ))))\n+    }\n+}\n+\n+#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+impl Drop for OwnedFd {\n+    #[inline]\n+    fn drop(&mut self) {\n+        unsafe {\n+            // Note that errors are ignored when closing a file descriptor. The\n+            // reason for this is that if an error occurs we don't actually know if\n+            // the file descriptor was closed or not, and if we retried (for\n+            // something like EINTR), we might close another valid file descriptor\n+            // opened after we closed ours.\n+            let _ = abi::close(self.fd);\n+        }\n+    }\n+}\n+\n+pub trait AsFd {\n+    /// Borrows the file descriptor.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust,no_run\n+    /// use std::fs::File;\n+    /// # use std::io;\n+    /// # #[cfg(any(unix, target_os = \"wasi\"))]\n+    /// # use std::os::fd::{AsFd, BorrowedFd};\n+    ///\n+    /// let mut f = File::open(\"foo.txt\")?;\n+    /// # #[cfg(any(unix, target_os = \"wasi\"))]\n+    /// let borrowed_fd: BorrowedFd<'_> = f.as_fd();\n+    /// # Ok::<(), io::Error>(())\n+    /// ```\n+    #[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+    fn as_fd(&self) -> BorrowedFd<'_>;\n+}\n+\n+#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+impl AsFd for OwnedFd {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        // Safety: `OwnedFd` and `BorrowedFd` have the same validity\n+        // invariants, and the `BorrowdFd` is bounded by the lifetime\n+        // of `&self`.\n+        unsafe { BorrowedFd::borrow_raw(self.as_raw_fd()) }\n+    }\n+}"}, {"sha": "cdec90b4b87cd3a86c8e06d7257ecd7da745f5cf", "filename": "library/std/src/sys/hermit/fd/raw.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd%2Fraw.rs?ref=7143379a528d7a26afbe835dd7e4bdca4bdb1412", "patch": "@@ -0,0 +1,115 @@\n+/// Raw file descriptors.\n+#[rustc_allowed_through_unstable_modules]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub type RawFd = i32;\n+\n+/// A trait to extract the raw file descriptor from an underlying object.\n+///\n+/// This is only available on unix and WASI platforms and must be imported in\n+/// order to call the method. Windows platforms have a corresponding\n+/// `AsRawHandle` and `AsRawSocket` set of traits.\n+#[rustc_allowed_through_unstable_modules]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait AsRawFd {\n+    /// Extracts the raw file descriptor.\n+    ///\n+    /// This function is typically used to **borrow** an owned file descriptor.\n+    /// When used in this way, this method does **not** pass ownership of the\n+    /// raw file descriptor to the caller, and the file descriptor is only\n+    /// guaranteed to be valid while the original object has not yet been\n+    /// destroyed.\n+    ///\n+    /// However, borrowing is not strictly required. See [`AsFd::as_fd`]\n+    /// for an API which strictly borrows a file descriptor.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// # use std::io;\n+    /// #[cfg(any(unix, target_os = \"wasi\"))]\n+    /// use std::os::fd::{AsRawFd, RawFd};\n+    ///\n+    /// let mut f = File::open(\"foo.txt\")?;\n+    /// // Note that `raw_fd` is only valid as long as `f` exists.\n+    /// #[cfg(any(unix, target_os = \"wasi\"))]\n+    /// let raw_fd: RawFd = f.as_raw_fd();\n+    /// # Ok::<(), io::Error>(())\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn as_raw_fd(&self) -> RawFd;\n+}\n+\n+/// A trait to express the ability to consume an object and acquire ownership of\n+/// its raw file descriptor.\n+#[rustc_allowed_through_unstable_modules]\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+pub trait IntoRawFd {\n+    /// Consumes this object, returning the raw underlying file descriptor.\n+    ///\n+    /// This function is typically used to **transfer ownership** of the underlying\n+    /// file descriptor to the caller. When used in this way, callers are then the unique\n+    /// owners of the file descriptor and must close it once it's no longer needed.\n+    ///\n+    /// However, transferring ownership is not strictly required. Use a\n+    /// [`Into<OwnedFd>::into`] implementation for an API which strictly\n+    /// transfers ownership.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// # use std::io;\n+    /// #[cfg(any(unix, target_os = \"wasi\"))]\n+    /// use std::os::fd::{IntoRawFd, RawFd};\n+    ///\n+    /// let f = File::open(\"foo.txt\")?;\n+    /// #[cfg(any(unix, target_os = \"wasi\"))]\n+    /// let raw_fd: RawFd = f.into_raw_fd();\n+    /// # Ok::<(), io::Error>(())\n+    /// ```\n+    #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+    fn into_raw_fd(self) -> RawFd;\n+}\n+\n+/// A trait to express the ability to construct an object from a raw file\n+/// descriptor.\n+#[rustc_allowed_through_unstable_modules]\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+pub trait FromRawFd {\n+    /// Constructs a new instance of `Self` from the given raw file\n+    /// descriptor.\n+    ///\n+    /// This function is typically used to **consume ownership** of the\n+    /// specified file descriptor. When used in this way, the returned object\n+    /// will take responsibility for closing it when the object goes out of\n+    /// scope.\n+    ///\n+    /// However, consuming ownership is not strictly required. Use a\n+    /// [`From<OwnedFd>::from`] implementation for an API which strictly\n+    /// consumes ownership.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The `fd` passed in must be a valid and open file descriptor.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// # use std::io;\n+    /// #[cfg(any(unix, target_os = \"wasi\"))]\n+    /// use std::os::fd::{FromRawFd, IntoRawFd, RawFd};\n+    ///\n+    /// let f = File::open(\"foo.txt\")?;\n+    /// # #[cfg(any(unix, target_os = \"wasi\"))]\n+    /// let raw_fd: RawFd = f.into_raw_fd();\n+    /// // SAFETY: no other functions should call `from_raw_fd`, so there\n+    /// // is only one owner for the file descriptor.\n+    /// # #[cfg(any(unix, target_os = \"wasi\"))]\n+    /// let f = unsafe { File::from_raw_fd(raw_fd) };\n+    /// # Ok::<(), io::Error>(())\n+    /// ```\n+    #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+    unsafe fn from_raw_fd(fd: RawFd) -> Self;\n+}"}, {"sha": "6ae44484bce107eb7ae1288671d5e38ff2c840eb", "filename": "library/std/src/sys/hermit/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs?ref=7143379a528d7a26afbe835dd7e4bdca4bdb1412", "patch": "@@ -8,7 +8,7 @@ use crate::sys::common::small_c_string::run_path_with_cstr;\n use crate::sys::cvt;\n use crate::sys::hermit::abi;\n use crate::sys::hermit::abi::{O_APPEND, O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY};\n-use crate::sys::hermit::fd::FileDesc;\n+use crate::sys::hermit::fd::{FileDesc, FromRawFd};\n use crate::sys::time::SystemTime;\n use crate::sys::unsupported;\n \n@@ -283,7 +283,7 @@ impl File {\n         }\n \n         let fd = unsafe { cvt(abi::open(path.as_ptr(), flags, mode))? };\n-        Ok(File(FileDesc::new(fd as i32)))\n+        Ok(File(unsafe { FileDesc::from_raw_fd(fd as i32) }))\n     }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {"}, {"sha": "a5956194eeccfa4331c9ec33260bd168d135388c", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 65, "deletions": 18, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=7143379a528d7a26afbe835dd7e4bdca4bdb1412", "patch": "@@ -13,7 +13,7 @@\n //! compiling for wasm. That way it's a compile time error for something that's\n //! guaranteed to be a runtime error!\n \n-#![allow(unsafe_op_in_unsafe_fn)]\n+#![allow(missing_docs, nonstandard_style, unsafe_op_in_unsafe_fn)]\n \n use crate::intrinsics;\n use crate::os::raw::c_char;\n@@ -126,25 +126,72 @@ pub unsafe extern \"C\" fn runtime_entry(\n \n pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     match errno {\n-        x if x == 13 as i32 => ErrorKind::PermissionDenied,\n-        x if x == 98 as i32 => ErrorKind::AddrInUse,\n-        x if x == 99 as i32 => ErrorKind::AddrNotAvailable,\n-        x if x == 11 as i32 => ErrorKind::WouldBlock,\n-        x if x == 103 as i32 => ErrorKind::ConnectionAborted,\n-        x if x == 111 as i32 => ErrorKind::ConnectionRefused,\n-        x if x == 104 as i32 => ErrorKind::ConnectionReset,\n-        x if x == 17 as i32 => ErrorKind::AlreadyExists,\n-        x if x == 4 as i32 => ErrorKind::Interrupted,\n-        x if x == 22 as i32 => ErrorKind::InvalidInput,\n-        x if x == 2 as i32 => ErrorKind::NotFound,\n-        x if x == 107 as i32 => ErrorKind::NotConnected,\n-        x if x == 1 as i32 => ErrorKind::PermissionDenied,\n-        x if x == 32 as i32 => ErrorKind::BrokenPipe,\n-        x if x == 110 as i32 => ErrorKind::TimedOut,\n+        abi::errno::EACCES => ErrorKind::PermissionDenied,\n+        abi::errno::EADDRINUSE => ErrorKind::AddrInUse,\n+        abi::errno::EADDRNOTAVAIL => ErrorKind::AddrNotAvailable,\n+        abi::errno::EAGAIN => ErrorKind::WouldBlock,\n+        abi::errno::ECONNABORTED => ErrorKind::ConnectionAborted,\n+        abi::errno::ECONNREFUSED => ErrorKind::ConnectionRefused,\n+        abi::errno::ECONNRESET => ErrorKind::ConnectionReset,\n+        abi::errno::EEXIST => ErrorKind::AlreadyExists,\n+        abi::errno::EINTR => ErrorKind::Interrupted,\n+        abi::errno::EINVAL => ErrorKind::InvalidInput,\n+        abi::errno::ENOENT => ErrorKind::NotFound,\n+        abi::errno::ENOTCONN => ErrorKind::NotConnected,\n+        abi::errno::EPERM => ErrorKind::PermissionDenied,\n+        abi::errno::EPIPE => ErrorKind::BrokenPipe,\n+        abi::errno::ETIMEDOUT => ErrorKind::TimedOut,\n         _ => ErrorKind::Uncategorized,\n     }\n }\n \n-pub fn cvt(result: i32) -> crate::io::Result<usize> {\n-    if result < 0 { Err(crate::io::Error::from_raw_os_error(-result)) } else { Ok(result as usize) }\n+#[doc(hidden)]\n+pub trait IsNegative {\n+    fn is_negative(&self) -> bool;\n+    fn negate(&self) -> i32;\n+}\n+\n+macro_rules! impl_is_negative {\n+    ($($t:ident)*) => ($(impl IsNegative for $t {\n+        fn is_negative(&self) -> bool {\n+            *self < 0\n+        }\n+\n+        fn negate(&self) -> i32 {\n+            i32::try_from(-(*self)).unwrap()\n+        }\n+    })*)\n+}\n+\n+impl IsNegative for i32 {\n+    fn is_negative(&self) -> bool {\n+        *self < 0\n+    }\n+\n+    fn negate(&self) -> i32 {\n+        -(*self)\n+    }\n+}\n+impl_is_negative! { i8 i16 i64 isize }\n+\n+pub fn cvt<T: IsNegative>(t: T) -> crate::io::Result<T> {\n+    if t.is_negative() {\n+        let e = decode_error_kind(t.negate());\n+        Err(crate::io::Error::from(e))\n+    } else {\n+        Ok(t)\n+    }\n+}\n+\n+pub fn cvt_r<T, F>(mut f: F) -> crate::io::Result<T>\n+where\n+    T: IsNegative,\n+    F: FnMut() -> T,\n+{\n+    loop {\n+        match cvt(f()) {\n+            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+            other => return other,\n+        }\n+    }\n }"}, {"sha": "2d92068bca6e9ae24013fdb16c570408e229a63a", "filename": "library/std/src/sys/hermit/net.rs", "status": "modified", "additions": 250, "deletions": 388, "changes": 638, "blob_url": "https://github.com/rust-lang/rust/blob/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fnet.rs?ref=7143379a528d7a26afbe835dd7e4bdca4bdb1412", "patch": "@@ -1,490 +1,352 @@\n-use crate::fmt;\n-use crate::io::{self, ErrorKind, IoSlice, IoSliceMut};\n-use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n-use crate::str;\n-use crate::sync::Arc;\n-use crate::sys::hermit::abi;\n-use crate::sys::hermit::abi::IpAddress::{Ipv4, Ipv6};\n-use crate::sys::unsupported;\n-use crate::sys_common::AsInner;\n+#![allow(dead_code)]\n+\n+use crate::cmp;\n+use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::mem;\n+use crate::net::{Shutdown, SocketAddr};\n+use crate::sys::fd::{AsFd, AsRawFd, BorrowedFd, FileDesc, FromRawFd, RawFd};\n+use crate::sys::time::Instant;\n+use crate::sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::Duration;\n \n-/// Checks whether the HermitCore's socket interface has been started already, and\n-/// if not, starts it.\n-pub fn init() -> io::Result<()> {\n-    if abi::network_init() < 0 {\n-        return Err(io::const_io_error!(\n-            ErrorKind::Uncategorized,\n-            \"Unable to initialize network interface\",\n-        ));\n-    }\n-\n-    Ok(())\n-}\n-\n-#[derive(Debug, Clone)]\n-pub struct Socket(abi::Handle);\n-\n-impl AsInner<abi::Handle> for Socket {\n-    fn as_inner(&self) -> &abi::Handle {\n-        &self.0\n-    }\n-}\n+use core::ffi::c_int;\n \n-impl Drop for Socket {\n-    fn drop(&mut self) {\n-        let _ = abi::tcpstream::close(self.0);\n-    }\n-}\n+#[allow(unused_extern_crates)]\n+pub extern crate hermit_abi as netc;\n \n-// Arc is used to count the number of used sockets.\n-// Only if all sockets are released, the drop\n-// method will close the socket.\n-#[derive(Clone)]\n-pub struct TcpStream(Arc<Socket>);\n-\n-impl TcpStream {\n-    pub fn connect(addr: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n-        let addr = addr?;\n-\n-        match abi::tcpstream::connect(addr.ip().to_string().as_bytes(), addr.port(), None) {\n-            Ok(handle) => Ok(TcpStream(Arc::new(Socket(handle)))),\n-            _ => Err(io::const_io_error!(\n-                ErrorKind::Uncategorized,\n-                \"Unable to initiate a connection on a socket\",\n-            )),\n-        }\n-    }\n+pub use crate::sys::{cvt, cvt_r};\n \n-    pub fn connect_timeout(saddr: &SocketAddr, duration: Duration) -> io::Result<TcpStream> {\n-        match abi::tcpstream::connect(\n-            saddr.ip().to_string().as_bytes(),\n-            saddr.port(),\n-            Some(duration.as_millis() as u64),\n-        ) {\n-            Ok(handle) => Ok(TcpStream(Arc::new(Socket(handle)))),\n-            _ => Err(io::const_io_error!(\n-                ErrorKind::Uncategorized,\n-                \"Unable to initiate a connection on a socket\",\n-            )),\n-        }\n-    }\n+pub type wrlen_t = usize;\n \n-    pub fn set_read_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n-        abi::tcpstream::set_read_timeout(*self.0.as_inner(), duration.map(|d| d.as_millis() as u64))\n-            .map_err(|_| {\n-                io::const_io_error!(ErrorKind::Uncategorized, \"Unable to set timeout value\")\n-            })\n+pub fn cvt_gai(err: i32) -> io::Result<()> {\n+    if err == 0 {\n+        return Ok(());\n     }\n \n-    pub fn set_write_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n-        abi::tcpstream::set_write_timeout(\n-            *self.0.as_inner(),\n-            duration.map(|d| d.as_millis() as u64),\n-        )\n-        .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"Unable to set timeout value\"))\n-    }\n+    let detail = \"\";\n \n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        let duration = abi::tcpstream::get_read_timeout(*self.0.as_inner()).map_err(|_| {\n-            io::const_io_error!(ErrorKind::Uncategorized, \"Unable to determine timeout value\")\n-        })?;\n+    Err(io::Error::new(\n+        io::ErrorKind::Uncategorized,\n+        &format!(\"failed to lookup address information: {detail}\")[..],\n+    ))\n+}\n \n-        Ok(duration.map(|d| Duration::from_millis(d)))\n+/// Checks whether the HermitCore's socket interface has been started already, and\n+/// if not, starts it.\n+pub fn init() {\n+    if unsafe { netc::network_init() } < 0 {\n+        panic!(\"Unable to initialize network interface\");\n     }\n+}\n \n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        let duration = abi::tcpstream::get_write_timeout(*self.0.as_inner()).map_err(|_| {\n-            io::const_io_error!(ErrorKind::Uncategorized, \"Unable to determine timeout value\")\n-        })?;\n+#[derive(Debug)]\n+pub struct Socket(FileDesc);\n \n-        Ok(duration.map(|d| Duration::from_millis(d)))\n+impl Socket {\n+    pub fn new(addr: &SocketAddr, ty: i32) -> io::Result<Socket> {\n+        let fam = match *addr {\n+            SocketAddr::V4(..) => netc::AF_INET,\n+            SocketAddr::V6(..) => netc::AF_INET6,\n+        };\n+        Socket::new_raw(fam, ty)\n     }\n \n-    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        abi::tcpstream::peek(*self.0.as_inner(), buf)\n-            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"peek failed\"))\n+    pub fn new_raw(fam: i32, ty: i32) -> io::Result<Socket> {\n+        let fd = cvt(unsafe { netc::socket(fam, ty, 0) })?;\n+        Ok(Socket(unsafe { FileDesc::from_raw_fd(fd) }))\n     }\n \n-    pub fn read(&self, buffer: &mut [u8]) -> io::Result<usize> {\n-        self.read_vectored(&mut [IoSliceMut::new(buffer)])\n+    pub fn new_pair(_fam: i32, _ty: i32) -> io::Result<(Socket, Socket)> {\n+        unimplemented!()\n     }\n \n-    pub fn read_vectored(&self, ioslice: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        let mut size: usize = 0;\n-\n-        for i in ioslice.iter_mut() {\n-            let ret = abi::tcpstream::read(*self.0.as_inner(), &mut i[0..]).map_err(|_| {\n-                io::const_io_error!(ErrorKind::Uncategorized, \"Unable to read on socket\")\n-            })?;\n+    pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n+        self.set_nonblocking(true)?;\n+        let r = unsafe {\n+            let (addr, len) = addr.into_inner();\n+            cvt(netc::connect(self.as_raw_fd(), addr.as_ptr(), len))\n+        };\n+        self.set_nonblocking(false)?;\n \n-            if ret != 0 {\n-                size += ret;\n-            }\n+        match r {\n+            Ok(_) => return Ok(()),\n+            // there's no ErrorKind for EINPROGRESS :(\n+            Err(ref e) if e.raw_os_error() == Some(netc::errno::EINPROGRESS) => {}\n+            Err(e) => return Err(e),\n         }\n \n-        Ok(size)\n-    }\n-\n-    #[inline]\n-    pub fn is_read_vectored(&self) -> bool {\n-        true\n-    }\n-\n-    pub fn write(&self, buffer: &[u8]) -> io::Result<usize> {\n-        self.write_vectored(&[IoSlice::new(buffer)])\n-    }\n+        let mut pollfd = netc::pollfd { fd: self.as_raw_fd(), events: netc::POLLOUT, revents: 0 };\n \n-    pub fn write_vectored(&self, ioslice: &[IoSlice<'_>]) -> io::Result<usize> {\n-        let mut size: usize = 0;\n-\n-        for i in ioslice.iter() {\n-            size += abi::tcpstream::write(*self.0.as_inner(), i).map_err(|_| {\n-                io::const_io_error!(ErrorKind::Uncategorized, \"Unable to write on socket\")\n-            })?;\n+        if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n+            return Err(io::const_io_error!(\n+                io::ErrorKind::InvalidInput,\n+                \"cannot set a 0 duration timeout\",\n+            ));\n         }\n \n-        Ok(size)\n-    }\n-\n-    #[inline]\n-    pub fn is_write_vectored(&self) -> bool {\n-        true\n-    }\n-\n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        let (ipaddr, port) = abi::tcpstream::peer_addr(*self.0.as_inner())\n-            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"peer_addr failed\"))?;\n+        let start = Instant::now();\n \n-        let saddr = match ipaddr {\n-            Ipv4(ref addr) => SocketAddr::new(IpAddr::V4(Ipv4Addr::from(addr.0)), port),\n-            Ipv6(ref addr) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from(addr.0)), port),\n-            _ => {\n-                return Err(io::const_io_error!(ErrorKind::Uncategorized, \"peer_addr failed\"));\n+        loop {\n+            let elapsed = start.elapsed();\n+            if elapsed >= timeout {\n+                return Err(io::const_io_error!(io::ErrorKind::TimedOut, \"connection timed out\"));\n             }\n-        };\n-\n-        Ok(saddr)\n-    }\n-\n-    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        unsupported()\n-    }\n-\n-    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        abi::tcpstream::shutdown(*self.0.as_inner(), how as i32)\n-            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"unable to shutdown socket\"))\n-    }\n-\n-    pub fn duplicate(&self) -> io::Result<TcpStream> {\n-        Ok(self.clone())\n-    }\n-\n-    pub fn set_linger(&self, _linger: Option<Duration>) -> io::Result<()> {\n-        unsupported()\n-    }\n-\n-    pub fn linger(&self) -> io::Result<Option<Duration>> {\n-        unsupported()\n-    }\n-\n-    pub fn set_nodelay(&self, mode: bool) -> io::Result<()> {\n-        abi::tcpstream::set_nodelay(*self.0.as_inner(), mode)\n-            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"set_nodelay failed\"))\n-    }\n-\n-    pub fn nodelay(&self) -> io::Result<bool> {\n-        abi::tcpstream::nodelay(*self.0.as_inner())\n-            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"nodelay failed\"))\n-    }\n-\n-    pub fn set_ttl(&self, tll: u32) -> io::Result<()> {\n-        abi::tcpstream::set_tll(*self.0.as_inner(), tll)\n-            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"unable to set TTL\"))\n-    }\n-\n-    pub fn ttl(&self) -> io::Result<u32> {\n-        abi::tcpstream::get_tll(*self.0.as_inner())\n-            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"unable to get TTL\"))\n-    }\n \n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        unsupported()\n-    }\n-\n-    pub fn set_nonblocking(&self, mode: bool) -> io::Result<()> {\n-        abi::tcpstream::set_nonblocking(*self.0.as_inner(), mode).map_err(|_| {\n-            io::const_io_error!(ErrorKind::Uncategorized, \"unable to set blocking mode\")\n-        })\n-    }\n-}\n-\n-impl fmt::Debug for TcpStream {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        Ok(())\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct TcpListener(SocketAddr);\n-\n-impl TcpListener {\n-    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n-        let addr = addr?;\n-\n-        Ok(TcpListener(*addr))\n-    }\n-\n-    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        Ok(self.0)\n-    }\n-\n-    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n-        let (handle, ipaddr, port) = abi::tcplistener::accept(self.0.port())\n-            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"accept failed\"))?;\n-        let saddr = match ipaddr {\n-            Ipv4(ref addr) => SocketAddr::new(IpAddr::V4(Ipv4Addr::from(addr.0)), port),\n-            Ipv6(ref addr) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from(addr.0)), port),\n-            _ => {\n-                return Err(io::const_io_error!(ErrorKind::Uncategorized, \"accept failed\"));\n+            let timeout = timeout - elapsed;\n+            let mut timeout = timeout\n+                .as_secs()\n+                .saturating_mul(1_000)\n+                .saturating_add(timeout.subsec_nanos() as u64 / 1_000_000);\n+            if timeout == 0 {\n+                timeout = 1;\n             }\n-        };\n-\n-        Ok((TcpStream(Arc::new(Socket(handle))), saddr))\n-    }\n \n-    pub fn duplicate(&self) -> io::Result<TcpListener> {\n-        Ok(self.clone())\n-    }\n-\n-    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-        unsupported()\n-    }\n-\n-    pub fn ttl(&self) -> io::Result<u32> {\n-        unsupported()\n-    }\n-\n-    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n-        unsupported()\n+            let timeout = cmp::min(timeout, c_int::MAX as u64) as c_int;\n+\n+            match unsafe { netc::poll(&mut pollfd, 1, timeout) } {\n+                -1 => {\n+                    let err = io::Error::last_os_error();\n+                    if err.kind() != io::ErrorKind::Interrupted {\n+                        return Err(err);\n+                    }\n+                }\n+                0 => {}\n+                _ => {\n+                    // linux returns POLLOUT|POLLERR|POLLHUP for refused connections (!), so look\n+                    // for POLLHUP rather than read readiness\n+                    if pollfd.revents & netc::POLLHUP != 0 {\n+                        let e = self.take_error()?.unwrap_or_else(|| {\n+                            io::const_io_error!(\n+                                io::ErrorKind::Uncategorized,\n+                                \"no error set after POLLHUP\",\n+                            )\n+                        });\n+                        return Err(e);\n+                    }\n+\n+                    return Ok(());\n+                }\n+            }\n+        }\n     }\n \n-    pub fn only_v6(&self) -> io::Result<bool> {\n-        unsupported()\n+    pub fn accept(\n+        &self,\n+        storage: *mut netc::sockaddr,\n+        len: *mut netc::socklen_t,\n+    ) -> io::Result<Socket> {\n+        let fd = cvt(unsafe { netc::accept(self.0.as_raw_fd(), storage, len) })?;\n+        Ok(Socket(unsafe { FileDesc::from_raw_fd(fd) }))\n     }\n \n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        unsupported()\n+    pub fn duplicate(&self) -> io::Result<Socket> {\n+        let fd = cvt(unsafe { netc::dup(self.0.as_raw_fd()) })?;\n+        Ok(Socket(unsafe { FileDesc::from_raw_fd(fd) }))\n     }\n \n-    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-        unsupported()\n+    fn recv_with_flags(&self, buf: &mut [u8], flags: i32) -> io::Result<usize> {\n+        let ret =\n+            cvt(unsafe { netc::recv(self.0.as_raw_fd(), buf.as_mut_ptr(), buf.len(), flags) })?;\n+        Ok(ret as usize)\n     }\n-}\n \n-impl fmt::Debug for TcpListener {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        Ok(())\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.recv_with_flags(buf, 0)\n     }\n-}\n-\n-pub struct UdpSocket(abi::Handle);\n \n-impl UdpSocket {\n-    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n-        unsupported()\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.recv_with_flags(buf, netc::MSG_PEEK)\n     }\n \n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        unsupported()\n-    }\n+    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        let mut size: isize = 0;\n \n-    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        unsupported()\n-    }\n+        for i in bufs.iter_mut() {\n+            let ret: isize =\n+                cvt(unsafe { netc::read(self.0.as_raw_fd(), i.as_mut_ptr(), i.len()) })?;\n \n-    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        unsupported()\n-    }\n+            if ret != 0 {\n+                size += ret;\n+            }\n+        }\n \n-    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        unsupported()\n+        Ok(size.try_into().unwrap())\n     }\n \n-    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n-        unsupported()\n+    #[inline]\n+    pub fn is_read_vectored(&self) -> bool {\n+        true\n     }\n \n-    pub fn duplicate(&self) -> io::Result<UdpSocket> {\n-        unsupported()\n-    }\n+    fn recv_from_with_flags(&self, buf: &mut [u8], flags: i32) -> io::Result<(usize, SocketAddr)> {\n+        let mut storage: netc::sockaddr_storage = unsafe { mem::zeroed() };\n+        let mut addrlen = mem::size_of_val(&storage) as netc::socklen_t;\n \n-    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-        unsupported()\n+        let n = cvt(unsafe {\n+            netc::recvfrom(\n+                self.as_raw_fd(),\n+                buf.as_mut_ptr(),\n+                buf.len(),\n+                flags,\n+                &mut storage as *mut _ as *mut _,\n+                &mut addrlen,\n+            )\n+        })?;\n+        Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize)?))\n     }\n \n-    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-        unsupported()\n+    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_with_flags(buf, 0)\n     }\n \n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        unsupported()\n+    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_with_flags(buf, netc::MSG_PEEK)\n     }\n \n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        unsupported()\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        let sz = cvt(unsafe { netc::write(self.0.as_raw_fd(), buf.as_ptr(), buf.len()) })?;\n+        Ok(sz.try_into().unwrap())\n     }\n \n-    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n-        unsupported()\n-    }\n+    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        let mut size: isize = 0;\n \n-    pub fn broadcast(&self) -> io::Result<bool> {\n-        unsupported()\n-    }\n+        for i in bufs.iter() {\n+            size += cvt(unsafe { netc::write(self.0.as_raw_fd(), i.as_ptr(), i.len()) })?;\n+        }\n \n-    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n-        unsupported()\n+        Ok(size.try_into().unwrap())\n     }\n \n-    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n-        unsupported()\n+    pub fn is_write_vectored(&self) -> bool {\n+        true\n     }\n \n-    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n-        unsupported()\n-    }\n+    pub fn set_timeout(&self, dur: Option<Duration>, kind: i32) -> io::Result<()> {\n+        let timeout = match dur {\n+            Some(dur) => {\n+                if dur.as_secs() == 0 && dur.subsec_nanos() == 0 {\n+                    return Err(io::const_io_error!(\n+                        io::ErrorKind::InvalidInput,\n+                        \"cannot set a 0 duration timeout\",\n+                    ));\n+                }\n+\n+                let secs = if dur.as_secs() > netc::time_t::MAX as u64 {\n+                    netc::time_t::MAX\n+                } else {\n+                    dur.as_secs() as netc::time_t\n+                };\n+                let mut timeout = netc::timeval {\n+                    tv_sec: secs,\n+                    tv_usec: dur.subsec_micros() as netc::suseconds_t,\n+                };\n+                if timeout.tv_sec == 0 && timeout.tv_usec == 0 {\n+                    timeout.tv_usec = 1;\n+                }\n+                timeout\n+            }\n+            None => netc::timeval { tv_sec: 0, tv_usec: 0 },\n+        };\n \n-    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n-        unsupported()\n+        setsockopt(self, netc::SOL_SOCKET, kind, timeout)\n     }\n \n-    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n-        unsupported()\n+    pub fn timeout(&self, kind: i32) -> io::Result<Option<Duration>> {\n+        let raw: netc::timeval = getsockopt(self, netc::SOL_SOCKET, kind)?;\n+        if raw.tv_sec == 0 && raw.tv_usec == 0 {\n+            Ok(None)\n+        } else {\n+            let sec = raw.tv_sec as u64;\n+            let nsec = (raw.tv_usec as u32) * 1000;\n+            Ok(Some(Duration::new(sec, nsec)))\n+        }\n     }\n \n-    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n-        unsupported()\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        let how = match how {\n+            Shutdown::Write => netc::SHUT_WR,\n+            Shutdown::Read => netc::SHUT_RD,\n+            Shutdown::Both => netc::SHUT_RDWR,\n+        };\n+        cvt(unsafe { netc::shutdown_socket(self.as_raw_fd(), how) })?;\n+        Ok(())\n     }\n \n-    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n-        unsupported()\n-    }\n+    pub fn set_linger(&self, linger: Option<Duration>) -> io::Result<()> {\n+        let linger = netc::linger {\n+            l_onoff: linger.is_some() as i32,\n+            l_linger: linger.unwrap_or_default().as_secs() as libc::c_int,\n+        };\n \n-    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n-        unsupported()\n+        setsockopt(self, netc::SOL_SOCKET, netc::SO_LINGER, linger)\n     }\n \n-    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n-        unsupported()\n-    }\n+    pub fn linger(&self) -> io::Result<Option<Duration>> {\n+        let val: netc::linger = getsockopt(self, netc::SOL_SOCKET, netc::SO_LINGER)?;\n \n-    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n-        unsupported()\n+        Ok((val.l_onoff != 0).then(|| Duration::from_secs(val.l_linger as u64)))\n     }\n \n-    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-        unsupported()\n+    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n+        let value: i32 = if nodelay { 1 } else { 0 };\n+        setsockopt(self, netc::IPPROTO_TCP, netc::TCP_NODELAY, value)\n     }\n \n-    pub fn ttl(&self) -> io::Result<u32> {\n-        unsupported()\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        let raw: i32 = getsockopt(self, netc::IPPROTO_TCP, netc::TCP_NODELAY)?;\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        let mut nonblocking: i32 = if nonblocking { 1 } else { 0 };\n+        cvt(unsafe {\n+            netc::ioctl(\n+                self.as_raw_fd(),\n+                netc::FIONBIO,\n+                &mut nonblocking as *mut _ as *mut core::ffi::c_void,\n+            )\n+        })\n+        .map(drop)\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        unsupported()\n-    }\n-\n-    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-        unsupported()\n-    }\n-\n-    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n-        unsupported()\n-    }\n-\n-    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n-        unsupported()\n+        unimplemented!()\n     }\n \n-    pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n-        unsupported()\n-    }\n-\n-    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n-        unsupported()\n+    // This is used by sys_common code to abstract over Windows and Unix.\n+    pub fn as_raw(&self) -> RawFd {\n+        self.0.as_raw_fd()\n     }\n }\n \n-impl fmt::Debug for UdpSocket {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        Ok(())\n+impl AsInner<FileDesc> for Socket {\n+    fn as_inner(&self) -> &FileDesc {\n+        &self.0\n     }\n }\n \n-pub struct LookupHost(!);\n-\n-impl LookupHost {\n-    pub fn port(&self) -> u16 {\n+impl IntoInner<FileDesc> for Socket {\n+    fn into_inner(self) -> FileDesc {\n         self.0\n     }\n }\n \n-impl Iterator for LookupHost {\n-    type Item = SocketAddr;\n-    fn next(&mut self) -> Option<SocketAddr> {\n-        self.0\n+impl FromInner<FileDesc> for Socket {\n+    fn from_inner(file_desc: FileDesc) -> Self {\n+        Self(file_desc)\n     }\n }\n \n-impl TryFrom<&str> for LookupHost {\n-    type Error = io::Error;\n-\n-    fn try_from(_v: &str) -> io::Result<LookupHost> {\n-        unsupported()\n+impl AsFd for Socket {\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.0.as_fd()\n     }\n }\n \n-impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n-    type Error = io::Error;\n-\n-    fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n-        unsupported()\n+impl AsRawFd for Socket {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.0.as_raw_fd()\n     }\n }\n-\n-#[allow(nonstandard_style)]\n-pub mod netc {\n-    pub const AF_INET: u8 = 0;\n-    pub const AF_INET6: u8 = 1;\n-    pub type sa_family_t = u8;\n-\n-    #[derive(Copy, Clone)]\n-    pub struct in_addr {\n-        pub s_addr: u32,\n-    }\n-\n-    #[derive(Copy, Clone)]\n-    pub struct sockaddr_in {\n-        pub sin_family: sa_family_t,\n-        pub sin_port: u16,\n-        pub sin_addr: in_addr,\n-    }\n-\n-    #[derive(Copy, Clone)]\n-    pub struct in6_addr {\n-        pub s6_addr: [u8; 16],\n-    }\n-\n-    #[derive(Copy, Clone)]\n-    pub struct sockaddr_in6 {\n-        pub sin6_family: sa_family_t,\n-        pub sin6_port: u16,\n-        pub sin6_addr: in6_addr,\n-        pub sin6_flowinfo: u32,\n-        pub sin6_scope_id: u32,\n-    }\n-\n-    #[derive(Copy, Clone)]\n-    pub struct sockaddr {}\n-}"}, {"sha": "32ddc4346eefd5d0609fb701358fba9eb0020daa", "filename": "library/std/src/sys/hermit/time.rs", "status": "modified", "additions": 83, "deletions": 15, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ftime.rs?ref=7143379a528d7a26afbe835dd7e4bdca4bdb1412", "patch": "@@ -1,6 +1,7 @@\n #![allow(dead_code)]\n \n use crate::cmp::Ordering;\n+use crate::ops::{Add, AddAssign, Sub, SubAssign};\n use crate::sys::hermit::abi;\n use crate::sys::hermit::abi::timespec;\n use crate::sys::hermit::abi::{CLOCK_MONOTONIC, CLOCK_REALTIME, NSEC_PER_SEC};\n@@ -102,55 +103,122 @@ impl Hash for Timespec {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n-pub struct Instant {\n-    t: Timespec,\n-}\n+pub struct Instant(Timespec);\n \n impl Instant {\n     pub fn now() -> Instant {\n         let mut time: Timespec = Timespec::zero();\n         let _ = unsafe { abi::clock_gettime(CLOCK_MONOTONIC, &mut time.t as *mut timespec) };\n \n-        Instant { t: time }\n+        Instant(time)\n+    }\n+\n+    #[stable(feature = \"time2\", since = \"1.8.0\")]\n+    pub fn elapsed(&self) -> Duration {\n+        Instant::now() - *self\n+    }\n+\n+    pub fn duration_since(&self, earlier: Instant) -> Duration {\n+        self.checked_duration_since(earlier).unwrap_or_default()\n+    }\n+\n+    pub fn checked_duration_since(&self, earlier: Instant) -> Option<Duration> {\n+        self.checked_sub_instant(&earlier)\n     }\n \n     pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n-        self.t.sub_timespec(&other.t).ok()\n+        self.0.sub_timespec(&other.0).ok()\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n-        Some(Instant { t: self.t.checked_add_duration(other)? })\n+        Some(Instant(self.0.checked_add_duration(other)?))\n     }\n \n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n-        Some(Instant { t: self.t.checked_sub_duration(other)? })\n+        Some(Instant(self.0.checked_sub_duration(other)?))\n+    }\n+\n+    pub fn checked_add(&self, duration: Duration) -> Option<Instant> {\n+        self.0.checked_add_duration(&duration).map(Instant)\n+    }\n+\n+    pub fn checked_sub(&self, duration: Duration) -> Option<Instant> {\n+        self.0.checked_sub_duration(&duration).map(Instant)\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-pub struct SystemTime {\n-    t: Timespec,\n+impl Add<Duration> for Instant {\n+    type Output = Instant;\n+\n+    /// # Panics\n+    ///\n+    /// This function may panic if the resulting point in time cannot be represented by the\n+    /// underlying data structure. See [`Instant::checked_add`] for a version without panic.\n+    fn add(self, other: Duration) -> Instant {\n+        self.checked_add(other).expect(\"overflow when adding duration to instant\")\n+    }\n }\n \n-pub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n+impl AddAssign<Duration> for Instant {\n+    fn add_assign(&mut self, other: Duration) {\n+        *self = *self + other;\n+    }\n+}\n+\n+impl Sub<Duration> for Instant {\n+    type Output = Instant;\n+\n+    fn sub(self, other: Duration) -> Instant {\n+        self.checked_sub(other).expect(\"overflow when subtracting duration from instant\")\n+    }\n+}\n+\n+impl SubAssign<Duration> for Instant {\n+    fn sub_assign(&mut self, other: Duration) {\n+        *self = *self - other;\n+    }\n+}\n+\n+impl Sub<Instant> for Instant {\n+    type Output = Duration;\n+\n+    /// Returns the amount of time elapsed from another instant to this one,\n+    /// or zero duration if that instant is later than this one.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Previous rust versions panicked when `other` was later than `self`. Currently this\n+    /// method saturates. Future versions may reintroduce the panic in some circumstances.\n+    /// See [Monotonicity].\n+    ///\n+    /// [Monotonicity]: Instant#monotonicity\n+    fn sub(self, other: Instant) -> Duration {\n+        self.duration_since(other)\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub struct SystemTime(Timespec);\n+\n+pub const UNIX_EPOCH: SystemTime = SystemTime(Timespec::zero());\n \n impl SystemTime {\n     pub fn now() -> SystemTime {\n         let mut time: Timespec = Timespec::zero();\n         let _ = unsafe { abi::clock_gettime(CLOCK_REALTIME, &mut time.t as *mut timespec) };\n \n-        SystemTime { t: time }\n+        SystemTime(time)\n     }\n \n     pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n-        self.t.sub_timespec(&other.t)\n+        self.0.sub_timespec(&other.0)\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n-        Some(SystemTime { t: self.t.checked_add_duration(other)? })\n+        Some(SystemTime(self.0.checked_add_duration(other)?))\n     }\n \n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n-        Some(SystemTime { t: self.t.checked_sub_duration(other)? })\n+        Some(SystemTime(self.0.checked_sub_duration(other)?))\n     }\n }"}, {"sha": "e9c727cbbd1220aabf1230e06f7b2f4d47000170", "filename": "library/std/src/sys_common/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7143379a528d7a26afbe835dd7e4bdca4bdb1412/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs?ref=7143379a528d7a26afbe835dd7e4bdca4bdb1412", "patch": "@@ -44,7 +44,6 @@ cfg_if::cfg_if! {\n \n cfg_if::cfg_if! {\n     if #[cfg(any(target_os = \"l4re\",\n-                 target_os = \"hermit\",\n                  feature = \"restricted-std\",\n                  all(target_family = \"wasm\", not(target_os = \"emscripten\")),\n                  all(target_vendor = \"fortanix\", target_env = \"sgx\")))] {"}]}