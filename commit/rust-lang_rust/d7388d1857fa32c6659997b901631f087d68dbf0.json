{"sha": "d7388d1857fa32c6659997b901631f087d68dbf0", "node_id": "C_kwDOAAsO6NoAKGQ3Mzg4ZDE4NTdmYTMyYzY2NTk5OTdiOTAxNjMxZjA4N2Q2OGRiZjA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-06-25T13:14:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-25T13:14:06Z"}, "message": "Rollup merge of #96412 - ChrisDenton:remove-dir-all, r=thomcc\n\nWindows: Iterative `remove_dir_all`\n\nThis will allow better strategies for use of memory and File handles. However, fully taking advantage of that is left to future work.\n\nNote to reviewer: It's probably best to view the `remove_dir_all_recursive` as a new function. The diff is not very helpful (imho).", "tree": {"sha": "af8fdbf9e12fc6475457fd14a59f9990f45719ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af8fdbf9e12fc6475457fd14a59f9990f45719ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7388d1857fa32c6659997b901631f087d68dbf0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJitwofCRBK7hj4Ov3rIwAAQGwIAJTJDqvAiHX3MvDrg4dFheok\n2HYnKQgxLTZR55R6aqya6jdExsL4kMOMMUxE5YzH3DLONTIHeTt/Z14BGsWT1sN/\nBBbk+n3Z0XUdqbLrszssDRbaihXnON/zDIrNb5oBPtPXznusBmlNUihYtRdxuPJe\nFt43Ou/Lj12sEl4iHC330PZG9ZVR3Bmkj+kOAd7QEx4k4kVjShNxoh15kB/pKKcb\nx3HmUA171YOvsIkxDcPjLTovvPnqqfnBIw13/8yNEhgXf7rEDoXwwSuVkXKe4s5g\nHuqAMOOzGJKI8805s7SAWyHeBuX1DNFuR1BeweQc8a5pQF0zw8xe0m4du/rNrTQ=\n=DSqO\n-----END PGP SIGNATURE-----\n", "payload": "tree af8fdbf9e12fc6475457fd14a59f9990f45719ed\nparent 1aabd8a4a6e1871f14e804302bd60dfcbffd5761\nparent d579665bd1e1649c9597cdaf3da3c2ca7f54e793\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1656162846 +0200\ncommitter GitHub <noreply@github.com> 1656162846 +0200\n\nRollup merge of #96412 - ChrisDenton:remove-dir-all, r=thomcc\n\nWindows: Iterative `remove_dir_all`\n\nThis will allow better strategies for use of memory and File handles. However, fully taking advantage of that is left to future work.\n\nNote to reviewer: It's probably best to view the `remove_dir_all_recursive` as a new function. The diff is not very helpful (imho).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7388d1857fa32c6659997b901631f087d68dbf0", "html_url": "https://github.com/rust-lang/rust/commit/d7388d1857fa32c6659997b901631f087d68dbf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7388d1857fa32c6659997b901631f087d68dbf0/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1aabd8a4a6e1871f14e804302bd60dfcbffd5761", "url": "https://api.github.com/repos/rust-lang/rust/commits/1aabd8a4a6e1871f14e804302bd60dfcbffd5761", "html_url": "https://github.com/rust-lang/rust/commit/1aabd8a4a6e1871f14e804302bd60dfcbffd5761"}, {"sha": "d579665bd1e1649c9597cdaf3da3c2ca7f54e793", "url": "https://api.github.com/repos/rust-lang/rust/commits/d579665bd1e1649c9597cdaf3da3c2ca7f54e793", "html_url": "https://github.com/rust-lang/rust/commit/d579665bd1e1649c9597cdaf3da3c2ca7f54e793"}], "stats": {"total": 156, "additions": 81, "deletions": 75}, "files": [{"sha": "e9b1006907741a88ea82ae0aaeb4ae1284bd65d4", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 81, "deletions": 75, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/d7388d1857fa32c6659997b901631f087d68dbf0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7388d1857fa32c6659997b901631f087d68dbf0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=d7388d1857fa32c6659997b901631f087d68dbf0", "patch": "@@ -13,6 +13,7 @@ use crate::sys::handle::Handle;\n use crate::sys::time::SystemTime;\n use crate::sys::{c, cvt};\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n+use crate::thread;\n \n use super::path::maybe_verbatim;\n use super::to_u16s;\n@@ -679,7 +680,7 @@ impl<'a> DirBuffIter<'a> {\n     }\n }\n impl<'a> Iterator for DirBuffIter<'a> {\n-    type Item = &'a [u16];\n+    type Item = (&'a [u16], bool);\n     fn next(&mut self) -> Option<Self::Item> {\n         use crate::mem::size_of;\n         let buffer = &self.buffer?[self.cursor..];\n@@ -688,14 +689,16 @@ impl<'a> Iterator for DirBuffIter<'a> {\n         // SAFETY: The buffer contains a `FILE_ID_BOTH_DIR_INFO` struct but the\n         // last field (the file name) is unsized. So an offset has to be\n         // used to get the file name slice.\n-        let (name, next_entry) = unsafe {\n+        let (name, is_directory, next_entry) = unsafe {\n             let info = buffer.as_ptr().cast::<c::FILE_ID_BOTH_DIR_INFO>();\n             let next_entry = (*info).NextEntryOffset as usize;\n             let name = crate::slice::from_raw_parts(\n                 (*info).FileName.as_ptr().cast::<u16>(),\n                 (*info).FileNameLength as usize / size_of::<u16>(),\n             );\n-            (name, next_entry)\n+            let is_directory = ((*info).FileAttributes & c::FILE_ATTRIBUTE_DIRECTORY) != 0;\n+\n+            (name, is_directory, next_entry)\n         };\n \n         if next_entry == 0 {\n@@ -708,7 +711,7 @@ impl<'a> Iterator for DirBuffIter<'a> {\n         const DOT: u16 = b'.' as u16;\n         match name {\n             [DOT] | [DOT, DOT] => self.next(),\n-            _ => Some(name),\n+            _ => Some((name, is_directory)),\n         }\n     }\n }\n@@ -993,89 +996,92 @@ pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n     if (file.basic_info()?.FileAttributes & c::FILE_ATTRIBUTE_DIRECTORY) == 0 {\n         return Err(io::Error::from_raw_os_error(c::ERROR_DIRECTORY as _));\n     }\n-    let mut delete: fn(&File) -> io::Result<()> = File::posix_delete;\n-    let result = match delete(&file) {\n-        Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {\n-            match remove_dir_all_recursive(&file, delete) {\n-                // Return unexpected errors.\n-                Err(e) if e.kind() != io::ErrorKind::DirectoryNotEmpty => return Err(e),\n-                result => result,\n-            }\n-        }\n-        // If POSIX delete is not supported for this filesystem then fallback to win32 delete.\n-        Err(e)\n-            if e.raw_os_error() == Some(c::ERROR_NOT_SUPPORTED as i32)\n-                || e.raw_os_error() == Some(c::ERROR_INVALID_PARAMETER as i32) =>\n-        {\n-            delete = File::win32_delete;\n-            Err(e)\n-        }\n-        result => result,\n-    };\n-    if result.is_ok() {\n-        Ok(())\n-    } else {\n-        // This is a fallback to make sure the directory is actually deleted.\n-        // Otherwise this function is prone to failing with `DirectoryNotEmpty`\n-        // due to possible delays between marking a file for deletion and the\n-        // file actually being deleted from the filesystem.\n-        //\n-        // So we retry a few times before giving up.\n-        for _ in 0..5 {\n-            match remove_dir_all_recursive(&file, delete) {\n-                Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {}\n-                result => return result,\n+\n+    match remove_dir_all_iterative(&file, File::posix_delete) {\n+        Err(e) => {\n+            if let Some(code) = e.raw_os_error() {\n+                match code as u32 {\n+                    // If POSIX delete is not supported for this filesystem then fallback to win32 delete.\n+                    c::ERROR_NOT_SUPPORTED\n+                    | c::ERROR_INVALID_FUNCTION\n+                    | c::ERROR_INVALID_PARAMETER => {\n+                        remove_dir_all_iterative(&file, File::win32_delete)\n+                    }\n+                    _ => Err(e),\n+                }\n+            } else {\n+                Err(e)\n             }\n         }\n-        // Try one last time.\n-        delete(&file)\n+        ok => ok,\n     }\n }\n \n-fn remove_dir_all_recursive(f: &File, delete: fn(&File) -> io::Result<()>) -> io::Result<()> {\n+fn remove_dir_all_iterative(f: &File, delete: fn(&File) -> io::Result<()>) -> io::Result<()> {\n+    // When deleting files we may loop this many times when certain error conditions occur.\n+    // This allows remove_dir_all to succeed when the error is temporary.\n+    const MAX_RETRIES: u32 = 10;\n+\n     let mut buffer = DirBuff::new();\n-    let mut restart = true;\n-    // Fill the buffer and iterate the entries.\n-    while f.fill_dir_buff(&mut buffer, restart)? {\n-        for name in buffer.iter() {\n-            // Open the file without following symlinks and try deleting it.\n-            // We try opening will all needed permissions and if that is denied\n-            // fallback to opening without `FILE_LIST_DIRECTORY` permission.\n-            // Note `SYNCHRONIZE` permission is needed for synchronous access.\n-            let mut result =\n-                open_link_no_reparse(&f, name, c::SYNCHRONIZE | c::DELETE | c::FILE_LIST_DIRECTORY);\n-            if matches!(&result, Err(e) if e.kind() == io::ErrorKind::PermissionDenied) {\n-                result = open_link_no_reparse(&f, name, c::SYNCHRONIZE | c::DELETE);\n+    let mut dirlist = vec![f.duplicate()?];\n+\n+    // FIXME: This is a hack so we can push to the dirlist vec after borrowing from it.\n+    fn copy_handle(f: &File) -> mem::ManuallyDrop<File> {\n+        unsafe { mem::ManuallyDrop::new(File::from_raw_handle(f.as_raw_handle())) }\n+    }\n+\n+    while let Some(dir) = dirlist.last() {\n+        let dir = copy_handle(dir);\n+\n+        // Fill the buffer and iterate the entries.\n+        let more_data = dir.fill_dir_buff(&mut buffer, false)?;\n+        for (name, is_directory) in buffer.iter() {\n+            if is_directory {\n+                let child_dir = open_link_no_reparse(\n+                    &dir,\n+                    name,\n+                    c::SYNCHRONIZE | c::DELETE | c::FILE_LIST_DIRECTORY,\n+                )?;\n+                dirlist.push(child_dir);\n+            } else {\n+                for i in 1..=MAX_RETRIES {\n+                    let result = open_link_no_reparse(&dir, name, c::SYNCHRONIZE | c::DELETE);\n+                    match result {\n+                        Ok(f) => delete(&f)?,\n+                        // Already deleted, so skip.\n+                        Err(e) if e.kind() == io::ErrorKind::NotFound => break,\n+                        // Retry a few times if the file is locked or a delete is already in progress.\n+                        Err(e)\n+                            if i < MAX_RETRIES\n+                                && (e.raw_os_error() == Some(c::ERROR_DELETE_PENDING as _)\n+                                    || e.raw_os_error()\n+                                        == Some(c::ERROR_SHARING_VIOLATION as _)) => {}\n+                        // Otherwise return the error.\n+                        Err(e) => return Err(e),\n+                    }\n+                    thread::yield_now();\n+                }\n             }\n-            match result {\n-                Ok(file) => match delete(&file) {\n-                    Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {\n-                        // Iterate the directory's files.\n-                        // Ignore `DirectoryNotEmpty` errors here. They will be\n-                        // caught when `remove_dir_all` tries to delete the top\n-                        // level directory. It can then decide if to retry or not.\n-                        match remove_dir_all_recursive(&file, delete) {\n-                            Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {}\n-                            result => result?,\n+        }\n+        // If there were no more files then delete the directory.\n+        if !more_data {\n+            if let Some(dir) = dirlist.pop() {\n+                // Retry deleting a few times in case we need to wait for a file to be deleted.\n+                for i in 1..=MAX_RETRIES {\n+                    let result = delete(&dir);\n+                    if let Err(e) = result {\n+                        if i == MAX_RETRIES || e.kind() != io::ErrorKind::DirectoryNotEmpty {\n+                            return Err(e);\n                         }\n+                        thread::yield_now();\n+                    } else {\n+                        break;\n                     }\n-                    result => result?,\n-                },\n-                // Ignore error if a delete is already in progress or the file\n-                // has already been deleted. It also ignores sharing violations\n-                // (where a file is locked by another process) as these are\n-                // usually temporary.\n-                Err(e)\n-                    if e.raw_os_error() == Some(c::ERROR_DELETE_PENDING as _)\n-                        || e.kind() == io::ErrorKind::NotFound\n-                        || e.raw_os_error() == Some(c::ERROR_SHARING_VIOLATION as _) => {}\n-                Err(e) => return Err(e),\n+                }\n             }\n         }\n-        // Continue reading directory entries without restarting from the beginning,\n-        restart = false;\n     }\n-    delete(&f)\n+    Ok(())\n }\n \n pub fn readlink(path: &Path) -> io::Result<PathBuf> {"}]}