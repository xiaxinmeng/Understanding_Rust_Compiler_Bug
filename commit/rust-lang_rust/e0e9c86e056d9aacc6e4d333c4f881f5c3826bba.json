{"sha": "e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZTljODZlMDU2ZDlhYWNjNmU0ZDMzM2M0Zjg4MWY1YzM4MjZiYmE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-23T23:30:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-23T23:30:18Z"}, "message": "Rollup merge of #59545 - Zoxc:the-arena-3, r=eddyb,michaelwoerister\n\nUse arenas to avoid Lrc in queries #2\n\nThe `Remove subtle Default impl for Value` makes the compilation stop due earlier due to cycle errors, since there's no longer a default value to continue the compilation with.\n\nBased on https://github.com/rust-lang/rust/pull/59540.", "tree": {"sha": "c795e4b89cf9c3b37dc2edb6a5519981ad933eb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c795e4b89cf9c3b37dc2edb6a5519981ad933eb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc5y0LCRBK7hj4Ov3rIwAAdHIIAA9ACnhI1BKH+twOz3IFwOBC\nfTHChG4NdBm2vNWQQYML9Gwd5reNd1LExysNLvIPiGrQV27agwzRnoK1CmwsoZ0m\na2wdHHuDn3CW4o+ZFbp7aq2QOx3mJ8KKGRwXB8h6dgjWF2N7DoRXTnVEkDVhC120\ni8mlXb2PMrS5qatmVrIjh51Idi0N6y10zZkkdzZlRtMVi/pS+hE3Ftun5szJ56Ti\nqDpqkyzp8iS509YY0zfWlNIhP2SZPh1PIFoXPcVy7zKRh0c/8IS9WFfvkMM/Rw5f\nxbCbtRLhBctwYg37ABcSdjKJ7oE1x0M/CE9APAiVU20v/p9U/dnVNpKHoJg2zqs=\n=3w+V\n-----END PGP SIGNATURE-----\n", "payload": "tree c795e4b89cf9c3b37dc2edb6a5519981ad933eb5\nparent 27cc0db7a248308fc2634ac68d7608a20b4a1c09\nparent d46e732e393a01884115e4506968606bd4da0d17\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1558654218 +0200\ncommitter GitHub <noreply@github.com> 1558654218 +0200\n\nRollup merge of #59545 - Zoxc:the-arena-3, r=eddyb,michaelwoerister\n\nUse arenas to avoid Lrc in queries #2\n\nThe `Remove subtle Default impl for Value` makes the compilation stop due earlier due to cycle errors, since there's no longer a default value to continue the compilation with.\n\nBased on https://github.com/rust-lang/rust/pull/59540.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "html_url": "https://github.com/rust-lang/rust/commit/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27cc0db7a248308fc2634ac68d7608a20b4a1c09", "url": "https://api.github.com/repos/rust-lang/rust/commits/27cc0db7a248308fc2634ac68d7608a20b4a1c09", "html_url": "https://github.com/rust-lang/rust/commit/27cc0db7a248308fc2634ac68d7608a20b4a1c09"}, {"sha": "d46e732e393a01884115e4506968606bd4da0d17", "url": "https://api.github.com/repos/rust-lang/rust/commits/d46e732e393a01884115e4506968606bd4da0d17", "html_url": "https://github.com/rust-lang/rust/commit/d46e732e393a01884115e4506968606bd4da0d17"}], "stats": {"total": 707, "additions": 355, "deletions": 352}, "files": [{"sha": "392f3e8e4bdce56b25b47b89bb32dc0c857dc9c0", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -2877,6 +2877,7 @@ dependencies = [\n  \"rustc_errors 0.0.0\",\n  \"rustc_target 0.0.0\",\n  \"serialize 0.0.0\",\n+ \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"stable_deref_trait 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_ext 0.0.0\","}, {"sha": "d6bec816e4ee60fcea0fb79e277a4ccd27d99990", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -486,9 +486,31 @@ impl DroplessArena {\n         }\n     }\n \n+    #[inline]\n+    unsafe fn write_from_iter<T, I: Iterator<Item = T>>(\n+        &self,\n+        mut iter: I,\n+        len: usize,\n+        mem: *mut T,\n+    ) -> &mut [T] {\n+        let mut i = 0;\n+        // Use a manual loop since LLVM manages to optimize it better for\n+        // slice iterators\n+        loop {\n+            let value = iter.next();\n+            if i >= len || value.is_none() {\n+                // We only return as many items as the iterator gave us, even\n+                // though it was supposed to give us `len`\n+                return slice::from_raw_parts_mut(mem, i);\n+            }\n+            ptr::write(mem.offset(i as isize), value.unwrap());\n+            i += 1;\n+        }\n+    }\n+\n     #[inline]\n     pub fn alloc_from_iter<T, I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n-        let mut iter = iter.into_iter();\n+        let iter = iter.into_iter();\n         assert!(mem::size_of::<T>() != 0);\n         assert!(!mem::needs_drop::<T>());\n \n@@ -505,10 +527,7 @@ impl DroplessArena {\n                 let size = len.checked_mul(mem::size_of::<T>()).unwrap();\n                 let mem = self.alloc_raw(size, mem::align_of::<T>()) as *mut _ as *mut T;\n                 unsafe {\n-                    for i in 0..len {\n-                        ptr::write(mem.offset(i as isize), iter.next().unwrap())\n-                    }\n-                    slice::from_raw_parts_mut(mem, len)\n+                    self.write_from_iter(iter, len, mem)\n                 }\n             }\n             (_, _) => {"}, {"sha": "c179b05683d1c91258bf53b335f9cc94d8e305c5", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -6,6 +6,15 @@ use std::cell::RefCell;\n use std::marker::PhantomData;\n use smallvec::SmallVec;\n \n+/// This declares a list of types which can be allocated by `Arena`.\n+///\n+/// The `few` modifier will cause allocation to use the shared arena and recording the destructor.\n+/// This is faster and more memory efficient if there's only a few allocations of the type.\n+/// Leaving `few` out will cause the type to get its own dedicated `TypedArena` which is\n+/// faster and more memory efficient if there is lots of allocations.\n+///\n+/// Specifying the `decode` modifier will add decode impls for &T and &[T] where T is the type\n+/// listed. These impls will appear in the implement_ty_decoder! macro.\n #[macro_export]\n macro_rules! arena_types {\n     ($macro:path, $args:tt, $tcx:lifetime) => (\n@@ -14,7 +23,7 @@ macro_rules! arena_types {\n                 rustc::hir::def_id::DefId,\n                 rustc::ty::subst::SubstsRef<$tcx>\n             )>,\n-            [few] mir_keys: rustc::util::nodemap::DefIdSet,\n+            [few, decode] mir_keys: rustc::util::nodemap::DefIdSet,\n             [decode] specialization_graph: rustc::traits::specialization_graph::Graph,\n             [] region_scope_tree: rustc::middle::region::ScopeTree,\n             [] item_local_set: rustc::util::nodemap::ItemLocalSet,\n@@ -58,6 +67,40 @@ macro_rules! arena_types {\n                 rustc::infer::canonical::Canonical<'tcx,\n                     rustc::infer::canonical::QueryResponse<'tcx, rustc::ty::Ty<'tcx>>\n                 >,\n+            [few] crate_inherent_impls: rustc::ty::CrateInherentImpls,\n+            [decode] borrowck: rustc::middle::borrowck::BorrowCheckResult,\n+            [few] upstream_monomorphizations:\n+                rustc::util::nodemap::DefIdMap<\n+                    rustc_data_structures::fx::FxHashMap<\n+                        rustc::ty::subst::SubstsRef<'tcx>,\n+                        rustc::hir::def_id::CrateNum\n+                    >\n+                >,\n+            [few] resolve_lifetimes: rustc::middle::resolve_lifetime::ResolveLifetimes,\n+            [decode] generic_predicates: rustc::ty::GenericPredicates<'tcx>,\n+            [few] lint_levels: rustc::lint::LintLevelMap,\n+            [few] stability_index: rustc::middle::stability::Index<'tcx>,\n+            [few] features: syntax::feature_gate::Features,\n+            [few] all_traits: Vec<rustc::hir::def_id::DefId>,\n+            [few] privacy_access_levels: rustc::middle::privacy::AccessLevels,\n+            [few] target_features_whitelist: rustc_data_structures::fx::FxHashMap<\n+                String,\n+                Option<syntax::symbol::Symbol>\n+            >,\n+            [few] wasm_import_module_map: rustc_data_structures::fx::FxHashMap<\n+                rustc::hir::def_id::DefId,\n+                String\n+            >,\n+            [few] get_lib_features: rustc::middle::lib_features::LibFeatures,\n+            [few] defined_lib_features: rustc::middle::lang_items::LanguageItems,\n+            [few] visible_parent_map: rustc::util::nodemap::DefIdMap<rustc::hir::def_id::DefId>,\n+            [few] foreign_module: rustc::middle::cstore::ForeignModule,\n+            [few] foreign_modules: Vec<rustc::middle::cstore::ForeignModule>,\n+            [few] reachable_non_generics: rustc::util::nodemap::DefIdMap<\n+                rustc::middle::exported_symbols::SymbolExportLevel\n+            >,\n+            [few] crate_variances: rustc::ty::CrateVariancesMap<'tcx>,\n+            [few] inferred_outlives_crate: rustc::ty::CratePredicatesMap<'tcx>,\n         ], $tcx);\n     )\n }\n@@ -119,7 +162,7 @@ pub trait ArenaAllocatable {}\n \n impl<T: Copy> ArenaAllocatable for T {}\n \n-pub unsafe trait ArenaField<'tcx>: Sized {\n+unsafe trait ArenaField<'tcx>: Sized {\n     /// Returns a specific arena to allocate from.\n     /// If None is returned, the DropArena will be used.\n     fn arena<'a>(arena: &'a Arena<'tcx>) -> Option<&'a TypedArena<Self>>;"}, {"sha": "2a684f4b0bb458f868ce9d22ed0d102d5c052a2b", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -21,7 +21,7 @@\n pub use self::Level::*;\n pub use self::LintSource::*;\n \n-use rustc_data_structures::sync::{self, Lrc};\n+use rustc_data_structures::sync;\n \n use crate::hir::def_id::{CrateNum, LOCAL_CRATE};\n use crate::hir::intravisit;\n@@ -767,7 +767,7 @@ pub fn maybe_lint_level_root(tcx: TyCtxt<'_, '_, '_>, id: hir::HirId) -> bool {\n }\n \n fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n-    -> Lrc<LintLevelMap>\n+    -> &'tcx LintLevelMap\n {\n     assert_eq!(cnum, LOCAL_CRATE);\n     let mut builder = LintLevelMapBuilder {\n@@ -784,7 +784,7 @@ fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n     intravisit::walk_crate(&mut builder, krate);\n     builder.levels.pop(push);\n \n-    Lrc::new(builder.levels.build_map())\n+    tcx.arena.alloc(builder.levels.build_map())\n }\n \n struct LintLevelMapBuilder<'a, 'tcx: 'a> {"}, {"sha": "6f9abcd624f9921abca3606fa11e73172449c2f1", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -256,8 +256,8 @@ pub fn used_crates(tcx: TyCtxt<'_, '_, '_>, prefer: LinkagePreference)\n             Some((cnum, path))\n         })\n         .collect::<Vec<_>>();\n-    let mut ordering = tcx.postorder_cnums(LOCAL_CRATE);\n-    Lrc::make_mut(&mut ordering).reverse();\n+    let mut ordering = tcx.postorder_cnums(LOCAL_CRATE).to_owned();\n+    ordering.reverse();\n     libs.sort_by_cached_key(|&(a, _)| {\n         ordering.iter().position(|x| *x == a)\n     });"}, {"sha": "775da1de313fa0956286240569006e739022d4d9", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -15,7 +15,6 @@ use crate::rustc::lint;\n use crate::session::Session;\n use crate::util::nodemap::{DefIdMap, FxHashMap, FxHashSet, HirIdMap, HirIdSet};\n use errors::{Applicability, DiagnosticBuilder};\n-use rustc_data_structures::sync::Lrc;\n use rustc_macros::HashStable;\n use std::borrow::Cow;\n use std::cell::Cell;\n@@ -211,10 +210,10 @@ struct NamedRegionMap {\n /// See [`NamedRegionMap`].\n #[derive(Default)]\n pub struct ResolveLifetimes {\n-    defs: FxHashMap<LocalDefId, Lrc<FxHashMap<ItemLocalId, Region>>>,\n-    late_bound: FxHashMap<LocalDefId, Lrc<FxHashSet<ItemLocalId>>>,\n+    defs: FxHashMap<LocalDefId, FxHashMap<ItemLocalId, Region>>,\n+    late_bound: FxHashMap<LocalDefId, FxHashSet<ItemLocalId>>,\n     object_lifetime_defaults:\n-        FxHashMap<LocalDefId, Lrc<FxHashMap<ItemLocalId, Lrc<Vec<ObjectLifetimeDefault>>>>>,\n+        FxHashMap<LocalDefId, FxHashMap<ItemLocalId, Vec<ObjectLifetimeDefault>>>,\n }\n \n impl_stable_hash_for!(struct crate::middle::resolve_lifetime::ResolveLifetimes {\n@@ -347,23 +346,21 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n \n         named_region_map: |tcx, id| {\n             let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n-            tcx.resolve_lifetimes(LOCAL_CRATE).defs.get(&id).cloned()\n+            tcx.resolve_lifetimes(LOCAL_CRATE).defs.get(&id)\n         },\n \n         is_late_bound_map: |tcx, id| {\n             let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n             tcx.resolve_lifetimes(LOCAL_CRATE)\n                 .late_bound\n                 .get(&id)\n-                .cloned()\n         },\n \n         object_lifetime_defaults_map: |tcx, id| {\n             let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n             tcx.resolve_lifetimes(LOCAL_CRATE)\n                 .object_lifetime_defaults\n                 .get(&id)\n-                .cloned()\n         },\n \n         ..*providers\n@@ -379,7 +376,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n fn resolve_lifetimes<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     for_krate: CrateNum,\n-) -> Lrc<ResolveLifetimes> {\n+) -> &'tcx ResolveLifetimes {\n     assert_eq!(for_krate, LOCAL_CRATE);\n \n     let named_region_map = krate(tcx);\n@@ -388,24 +385,22 @@ fn resolve_lifetimes<'tcx>(\n \n     for (hir_id, v) in named_region_map.defs {\n         let map = rl.defs.entry(hir_id.owner_local_def_id()).or_default();\n-        Lrc::get_mut(map).unwrap().insert(hir_id.local_id, v);\n+        map.insert(hir_id.local_id, v);\n     }\n     for hir_id in named_region_map.late_bound {\n         let map = rl.late_bound\n             .entry(hir_id.owner_local_def_id())\n             .or_default();\n-        Lrc::get_mut(map).unwrap().insert(hir_id.local_id);\n+        map.insert(hir_id.local_id);\n     }\n     for (hir_id, v) in named_region_map.object_lifetime_defaults {\n         let map = rl.object_lifetime_defaults\n             .entry(hir_id.owner_local_def_id())\n             .or_default();\n-        Lrc::get_mut(map)\n-            .unwrap()\n-            .insert(hir_id.local_id, Lrc::new(v));\n+        map.insert(hir_id.local_id, v);\n     }\n \n-    Lrc::new(rl)\n+    tcx.arena.alloc(rl)\n }\n \n fn krate<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> NamedRegionMap {"}, {"sha": "ac0e99137cbc3ea68f76f7affc21f4d991347ffe", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -883,7 +883,7 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     remaining_lib_features.remove(&Symbol::intern(\"test\"));\n \n     let check_features =\n-        |remaining_lib_features: &mut FxHashMap<_, _>, defined_features: &Vec<_>| {\n+        |remaining_lib_features: &mut FxHashMap<_, _>, defined_features: &[_]| {\n             for &(feature, since) in defined_features {\n                 if let Some(since) = since {\n                     if let Some(span) = remaining_lib_features.get(&feature) {\n@@ -908,7 +908,7 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n             if remaining_lib_features.is_empty() {\n                 break;\n             }\n-            check_features(&mut remaining_lib_features, &tcx.defined_lib_features(cnum));\n+            check_features(&mut remaining_lib_features, tcx.defined_lib_features(cnum));\n         }\n     }\n "}, {"sha": "c03cd7e268ef5ceed3e20e678624516bf12ed3fc", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -61,13 +61,13 @@ rustc_queries! {\n         /// predicate gets in the way of some checks, which are intended\n         /// to operate over only the actual where-clauses written by the\n         /// user.)\n-        query predicates_of(_: DefId) -> Lrc<ty::GenericPredicates<'tcx>> {}\n+        query predicates_of(_: DefId) -> &'tcx ty::GenericPredicates<'tcx> {}\n \n         query native_libraries(_: CrateNum) -> Lrc<Vec<NativeLibrary>> {\n             desc { \"looking up the native libraries of a linked crate\" }\n         }\n \n-        query lint_levels(_: CrateNum) -> Lrc<lint::LintLevelMap> {\n+        query lint_levels(_: CrateNum) -> &'tcx lint::LintLevelMap {\n             eval_always\n             desc { \"computing the lint levels for items in this crate\" }\n         }\n@@ -155,7 +155,7 @@ rustc_queries! {\n     }\n \n     Linking {\n-        query wasm_import_module_map(_: CrateNum) -> Lrc<FxHashMap<DefId, String>> {\n+        query wasm_import_module_map(_: CrateNum) -> &'tcx FxHashMap<DefId, String> {\n             desc { \"wasm import module map\" }\n         }\n     }\n@@ -166,11 +166,11 @@ rustc_queries! {\n         /// equal to the `explicit_predicates_of` predicates plus the\n         /// `inferred_outlives_of` predicates.\n         query predicates_defined_on(_: DefId)\n-            -> Lrc<ty::GenericPredicates<'tcx>> {}\n+            -> &'tcx ty::GenericPredicates<'tcx> {}\n \n         /// Returns the predicates written explicitly by the user.\n         query explicit_predicates_of(_: DefId)\n-            -> Lrc<ty::GenericPredicates<'tcx>> {}\n+            -> &'tcx ty::GenericPredicates<'tcx> {}\n \n         /// Returns the inferred outlives predicates (e.g., for `struct\n         /// Foo<'a, T> { x: &'a T }`, this would return `T: 'a`).\n@@ -182,14 +182,14 @@ rustc_queries! {\n         /// evaluate them even during type conversion, often before the\n         /// full predicates are available (note that supertraits have\n         /// additional acyclicity requirements).\n-        query super_predicates_of(key: DefId) -> Lrc<ty::GenericPredicates<'tcx>> {\n+        query super_predicates_of(key: DefId) -> &'tcx ty::GenericPredicates<'tcx> {\n             desc { |tcx| \"computing the supertraits of `{}`\", tcx.def_path_str(key) }\n         }\n \n         /// To avoid cycles within the predicates of a single item we compute\n         /// per-type-parameter predicates for resolving `T::AssocTy`.\n         query type_param_predicates(key: (DefId, DefId))\n-            -> Lrc<ty::GenericPredicates<'tcx>> {\n+            -> &'tcx ty::GenericPredicates<'tcx> {\n             no_force\n             desc { |tcx| \"computing the bounds for type parameter `{}`\", {\n                 let id = tcx.hir().as_local_hir_id(key.1).unwrap();\n@@ -244,7 +244,7 @@ rustc_queries! {\n         query static_mutability(_: DefId) -> Option<hir::Mutability> {}\n \n         /// Gets a map with the variance of every item; use `item_variance` instead.\n-        query crate_variances(_: CrateNum) -> Lrc<ty::CrateVariancesMap<'tcx>> {\n+        query crate_variances(_: CrateNum) -> &'tcx ty::CrateVariancesMap<'tcx> {\n             desc { \"computing the variances for items in this crate\" }\n         }\n \n@@ -255,14 +255,14 @@ rustc_queries! {\n     TypeChecking {\n         /// Maps from thee `DefId` of a type to its (inferred) outlives.\n         query inferred_outlives_crate(_: CrateNum)\n-            -> Lrc<ty::CratePredicatesMap<'tcx>> {\n+            -> &'tcx ty::CratePredicatesMap<'tcx> {\n             desc { \"computing the inferred outlives predicates for items in this crate\" }\n         }\n     }\n \n     Other {\n         /// Maps from an impl/trait `DefId to a list of the `DefId`s of its items.\n-        query associated_item_def_ids(_: DefId) -> Lrc<Vec<DefId>> {}\n+        query associated_item_def_ids(_: DefId) -> &'tcx [DefId] {}\n \n         /// Maps from a trait item to the trait item \"descriptor\".\n         query associated_item(_: DefId) -> ty::AssociatedItem {}\n@@ -277,7 +277,7 @@ rustc_queries! {\n         /// Maps a `DefId` of a type to a list of its inherent impls.\n         /// Contains implementations of methods that are inherent to a type.\n         /// Methods in these implementations don't need to be exported.\n-        query inherent_impls(_: DefId) -> Lrc<Vec<DefId>> {\n+        query inherent_impls(_: DefId) -> &'tcx [DefId] {\n             eval_always\n         }\n     }\n@@ -359,7 +359,7 @@ rustc_queries! {\n     }\n \n     Other {\n-        query used_trait_imports(_: DefId) -> Lrc<DefIdSet> {}\n+        query used_trait_imports(_: DefId) -> &'tcx DefIdSet {}\n     }\n \n     TypeChecking {\n@@ -371,7 +371,7 @@ rustc_queries! {\n     }\n \n     BorrowChecking {\n-        query borrowck(_: DefId) -> Lrc<BorrowCheckResult> {}\n+        query borrowck(_: DefId) -> &'tcx BorrowCheckResult {}\n \n         /// Borrow-checks the function body. If this is a closure, returns\n         /// additional requirements that the closure's creator must verify.\n@@ -383,7 +383,7 @@ rustc_queries! {\n         /// Not meant to be used directly outside of coherence.\n         /// (Defined only for `LOCAL_CRATE`.)\n         query crate_inherent_impls(k: CrateNum)\n-            -> Lrc<CrateInherentImpls> {\n+            -> &'tcx CrateInherentImpls {\n             eval_always\n             desc { \"all inherent impls defined in crate `{:?}`\", k }\n         }\n@@ -437,7 +437,7 @@ rustc_queries! {\n         query check_match(_: DefId) -> () {}\n \n         /// Performs part of the privacy check and computes \"access levels\".\n-        query privacy_access_levels(_: CrateNum) -> Lrc<AccessLevels> {\n+        query privacy_access_levels(_: CrateNum) -> &'tcx AccessLevels {\n             eval_always\n             desc { \"privacy access levels\" }\n         }\n@@ -590,7 +590,7 @@ rustc_queries! {\n \n     Other {\n         query dylib_dependency_formats(_: CrateNum)\n-                                        -> Lrc<Vec<(CrateNum, LinkagePreference)>> {\n+                                        -> &'tcx [(CrateNum, LinkagePreference)] {\n             desc { \"dylib dependency formats of crate\" }\n         }\n     }\n@@ -625,7 +625,7 @@ rustc_queries! {\n             desc { \"test whether a crate has #![no_builtins]\" }\n         }\n \n-        query extern_crate(_: DefId) -> Lrc<Option<ExternCrate>> {\n+        query extern_crate(_: DefId) -> Option<&'tcx ExternCrate> {\n             eval_always\n             desc { \"getting crate's ExternCrateData\" }\n         }\n@@ -637,14 +637,14 @@ rustc_queries! {\n             desc { \"computing whether impls specialize one another\" }\n         }\n         query in_scope_traits_map(_: DefIndex)\n-            -> Option<Lrc<FxHashMap<ItemLocalId, Lrc<StableVec<TraitCandidate>>>>> {\n+            -> Option<&'tcx FxHashMap<ItemLocalId, StableVec<TraitCandidate>>> {\n             eval_always\n             desc { \"traits in scope at a block\" }\n         }\n     }\n \n     Other {\n-        query module_exports(_: DefId) -> Option<Lrc<Vec<Export<hir::HirId>>>> {\n+        query module_exports(_: DefId) -> Option<&'tcx [Export<hir::HirId>]> {\n             eval_always\n         }\n     }\n@@ -671,7 +671,7 @@ rustc_queries! {\n         // Does not include external symbols that don't have a corresponding DefId,\n         // like the compiler-generated `main` function and so on.\n         query reachable_non_generics(_: CrateNum)\n-            -> Lrc<DefIdMap<SymbolExportLevel>> {\n+            -> &'tcx DefIdMap<SymbolExportLevel> {\n             desc { \"looking up the exported symbols of a crate\" }\n         }\n         query is_reachable_non_generic(_: DefId) -> bool {}\n@@ -681,15 +681,15 @@ rustc_queries! {\n     Codegen {\n         query upstream_monomorphizations(\n             k: CrateNum\n-        ) -> Lrc<DefIdMap<Lrc<FxHashMap<SubstsRef<'tcx>, CrateNum>>>> {\n+        ) -> &'tcx DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n             desc { \"collecting available upstream monomorphizations `{:?}`\", k }\n         }\n         query upstream_monomorphizations_for(_: DefId)\n-            -> Option<Lrc<FxHashMap<SubstsRef<'tcx>, CrateNum>>> {}\n+            -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>> {}\n     }\n \n     Other {\n-        query foreign_modules(_: CrateNum) -> Lrc<Vec<ForeignModule>> {\n+        query foreign_modules(_: CrateNum) -> &'tcx [ForeignModule] {\n             desc { \"looking up the foreign modules of a linked crate\" }\n         }\n \n@@ -724,19 +724,19 @@ rustc_queries! {\n \n     TypeChecking {\n         query implementations_of_trait(_: (CrateNum, DefId))\n-            -> Lrc<Vec<DefId>> {\n+            -> &'tcx [DefId] {\n             no_force\n             desc { \"looking up implementations of a trait in a crate\" }\n         }\n         query all_trait_implementations(_: CrateNum)\n-            -> Lrc<Vec<DefId>> {\n+            -> &'tcx [DefId] {\n             desc { \"looking up all (?) trait implementations\" }\n         }\n     }\n \n     Other {\n         query dllimport_foreign_items(_: CrateNum)\n-            -> Lrc<FxHashSet<DefId>> {\n+            -> &'tcx FxHashSet<DefId> {\n             desc { \"dllimport_foreign_items\" }\n         }\n         query is_dllimport_foreign_item(_: DefId) -> bool {}\n@@ -754,19 +754,19 @@ rustc_queries! {\n \n     BorrowChecking {\n         // Lifetime resolution. See `middle::resolve_lifetimes`.\n-        query resolve_lifetimes(_: CrateNum) -> Lrc<ResolveLifetimes> {\n+        query resolve_lifetimes(_: CrateNum) -> &'tcx ResolveLifetimes {\n             desc { \"resolving lifetimes\" }\n         }\n         query named_region_map(_: DefIndex) ->\n-            Option<Lrc<FxHashMap<ItemLocalId, Region>>> {\n+            Option<&'tcx FxHashMap<ItemLocalId, Region>> {\n             desc { \"looking up a named region\" }\n         }\n         query is_late_bound_map(_: DefIndex) ->\n-            Option<Lrc<FxHashSet<ItemLocalId>>> {\n+            Option<&'tcx FxHashSet<ItemLocalId>> {\n             desc { \"testing if a region is late bound\" }\n         }\n         query object_lifetime_defaults_map(_: DefIndex)\n-            -> Option<Lrc<FxHashMap<ItemLocalId, Lrc<Vec<ObjectLifetimeDefault>>>>> {\n+            -> Option<&'tcx FxHashMap<ItemLocalId, Vec<ObjectLifetimeDefault>>> {\n             desc { \"looking up lifetime defaults for a region\" }\n         }\n     }\n@@ -784,29 +784,29 @@ rustc_queries! {\n             eval_always\n             desc { \"fetching what a crate is named\" }\n         }\n-        query item_children(_: DefId) -> Lrc<Vec<Export<hir::HirId>>> {}\n+        query item_children(_: DefId) -> &'tcx [Export<hir::HirId>] {}\n         query extern_mod_stmt_cnum(_: DefId) -> Option<CrateNum> {}\n \n-        query get_lib_features(_: CrateNum) -> Lrc<LibFeatures> {\n+        query get_lib_features(_: CrateNum) -> &'tcx LibFeatures {\n             eval_always\n             desc { \"calculating the lib features map\" }\n         }\n         query defined_lib_features(_: CrateNum)\n-            -> Lrc<Vec<(Symbol, Option<Symbol>)>> {\n+            -> &'tcx [(Symbol, Option<Symbol>)] {\n             desc { \"calculating the lib features defined in a crate\" }\n         }\n-        query get_lang_items(_: CrateNum) -> Lrc<LanguageItems> {\n+        query get_lang_items(_: CrateNum) -> &'tcx LanguageItems {\n             eval_always\n             desc { \"calculating the lang items map\" }\n         }\n-        query defined_lang_items(_: CrateNum) -> Lrc<Vec<(DefId, usize)>> {\n+        query defined_lang_items(_: CrateNum) -> &'tcx [(DefId, usize)] {\n             desc { \"calculating the lang items defined in a crate\" }\n         }\n-        query missing_lang_items(_: CrateNum) -> Lrc<Vec<LangItem>> {\n+        query missing_lang_items(_: CrateNum) -> &'tcx [LangItem] {\n             desc { \"calculating the missing lang items in a crate\" }\n         }\n         query visible_parent_map(_: CrateNum)\n-            -> Lrc<DefIdMap<DefId>> {\n+            -> &'tcx DefIdMap<DefId> {\n             desc { \"calculating the visible parent map\" }\n         }\n         query missing_extern_crate_item(_: CrateNum) -> bool {\n@@ -817,19 +817,19 @@ rustc_queries! {\n             eval_always\n             desc { \"looking at the source for a crate\" }\n         }\n-        query postorder_cnums(_: CrateNum) -> Lrc<Vec<CrateNum>> {\n+        query postorder_cnums(_: CrateNum) -> &'tcx [CrateNum] {\n             eval_always\n             desc { \"generating a postorder list of CrateNums\" }\n         }\n \n-        query upvars(_: DefId) -> Option<Lrc<Vec<hir::Upvar>>> {\n+        query upvars(_: DefId) -> Option<&'tcx [hir::Upvar]> {\n             eval_always\n         }\n         query maybe_unused_trait_import(_: DefId) -> bool {\n             eval_always\n         }\n         query maybe_unused_extern_crates(_: CrateNum)\n-            -> Lrc<Vec<(DefId, Span)>> {\n+            -> &'tcx [(DefId, Span)] {\n             eval_always\n             desc { \"looking up all possibly unused extern crates\" }\n         }\n@@ -838,19 +838,19 @@ rustc_queries! {\n             eval_always\n         }\n \n-        query stability_index(_: CrateNum) -> Lrc<stability::Index<'tcx>> {\n+        query stability_index(_: CrateNum) -> &'tcx stability::Index<'tcx> {\n             eval_always\n             desc { \"calculating the stability index for the local crate\" }\n         }\n-        query all_crate_nums(_: CrateNum) -> Lrc<Vec<CrateNum>> {\n+        query all_crate_nums(_: CrateNum) -> &'tcx [CrateNum] {\n             eval_always\n             desc { \"fetching all foreign CrateNum instances\" }\n         }\n \n         /// A vector of every trait accessible in the whole crate\n         /// (i.e., including those from subcrates). This is used only for\n         /// error reporting.\n-        query all_traits(_: CrateNum) -> Lrc<Vec<DefId>> {\n+        query all_traits(_: CrateNum) -> &'tcx [DefId] {\n             desc { \"fetching all foreign and local traits\" }\n         }\n     }\n@@ -1050,7 +1050,7 @@ rustc_queries! {\n     }\n \n     Other {\n-        query target_features_whitelist(_: CrateNum) -> Lrc<FxHashMap<String, Option<Symbol>>> {\n+        query target_features_whitelist(_: CrateNum) -> &'tcx FxHashMap<String, Option<Symbol>> {\n             eval_always\n             desc { \"looking up the whitelist of target features\" }\n         }\n@@ -1062,7 +1062,7 @@ rustc_queries! {\n             desc { |tcx| \"estimating size for `{}`\", tcx.def_path_str(def.def_id()) }\n         }\n \n-        query features_query(_: CrateNum) -> Lrc<feature_gate::Features> {\n+        query features_query(_: CrateNum) -> &'tcx feature_gate::Features {\n             eval_always\n             desc { \"looking up enabled feature gates\" }\n         }"}, {"sha": "d83b2ce842a88057df2322e1d550ad88e7d1882e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -201,6 +201,10 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n     }\n }\n \n+pub struct Common<'tcx> {\n+    pub empty_predicates: ty::GenericPredicates<'tcx>,\n+}\n+\n pub struct CommonTypes<'tcx> {\n     pub unit: Ty<'tcx>,\n     pub bool: Ty<'tcx>,\n@@ -1045,6 +1049,9 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub dep_graph: DepGraph,\n \n+    /// Common objects.\n+    pub common: Common<'tcx>,\n+\n     /// Common types, pre-interned for your convenience.\n     pub types: CommonTypes<'tcx>,\n \n@@ -1057,11 +1064,11 @@ pub struct GlobalCtxt<'tcx> {\n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve.\n     trait_map: FxHashMap<DefIndex,\n-                         Lrc<FxHashMap<ItemLocalId,\n-                                       Lrc<StableVec<TraitCandidate>>>>>,\n+                         FxHashMap<ItemLocalId,\n+                                   StableVec<TraitCandidate>>>,\n \n     /// Export map produced by name resolution.\n-    export_map: FxHashMap<DefId, Lrc<Vec<Export<hir::HirId>>>>,\n+    export_map: FxHashMap<DefId, Vec<Export<hir::HirId>>>,\n \n     hir_map: hir_map::Map<'tcx>,\n \n@@ -1074,7 +1081,7 @@ pub struct GlobalCtxt<'tcx> {\n     // Records the captured variables referenced by every closure\n     // expression. Do not track deps for this, just recompute it from\n     // scratch every time.\n-    upvars: FxHashMap<DefId, Lrc<Vec<hir::Upvar>>>,\n+    upvars: FxHashMap<DefId, Vec<hir::Upvar>>,\n \n     maybe_unused_trait_imports: FxHashSet<DefId>,\n     maybe_unused_extern_crates: Vec<(DefId, Span)>,\n@@ -1252,6 +1259,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             s.fatal(&err);\n         });\n         let interners = CtxtInterners::new(&arenas.interner);\n+        let common = Common {\n+            empty_predicates: ty::GenericPredicates {\n+                parent: None,\n+                predicates: vec![],\n+            },\n+        };\n         let common_types = CommonTypes::new(&interners);\n         let common_lifetimes = CommonLifetimes::new(&interners);\n         let common_consts = CommonConsts::new(&interners, &common_types);\n@@ -1292,13 +1305,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             None\n         };\n \n-        let mut trait_map: FxHashMap<_, Lrc<FxHashMap<_, _>>> = FxHashMap::default();\n+        let mut trait_map: FxHashMap<_, FxHashMap<_, _>> = FxHashMap::default();\n         for (k, v) in resolutions.trait_map {\n             let hir_id = hir.node_to_hir_id(k);\n             let map = trait_map.entry(hir_id.owner).or_default();\n-            Lrc::get_mut(map).unwrap()\n-                             .insert(hir_id.local_id,\n-                                     Lrc::new(StableVec::new(v)));\n+            map.insert(hir_id.local_id, StableVec::new(v));\n         }\n \n         GlobalCtxt {\n@@ -1308,6 +1319,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             global_arenas: &arenas.global,\n             global_interners: interners,\n             dep_graph,\n+            common,\n             types: common_types,\n             lifetimes: common_lifetimes,\n             consts: common_consts,\n@@ -1316,13 +1328,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 let exports: Vec<_> = v.into_iter().map(|e| {\n                     e.map_id(|id| hir.node_to_hir_id(id))\n                 }).collect();\n-                (k, Lrc::new(exports))\n+                (k, exports)\n             }).collect(),\n             upvars: resolutions.upvars.into_iter().map(|(k, v)| {\n                 let vars: Vec<_> = v.into_iter().map(|e| {\n                     e.map_id(|id| hir.node_to_hir_id(id))\n                 }).collect();\n-                (hir.local_def_id(k), Lrc::new(vars))\n+                (hir.local_def_id(k), vars)\n             }).collect(),\n             maybe_unused_trait_imports:\n                 resolutions.maybe_unused_trait_imports\n@@ -1364,11 +1376,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.sess.consider_optimizing(&cname, msg)\n     }\n \n-    pub fn lib_features(self) -> Lrc<middle::lib_features::LibFeatures> {\n+    pub fn lib_features(self) -> &'gcx middle::lib_features::LibFeatures {\n         self.get_lib_features(LOCAL_CRATE)\n     }\n \n-    pub fn lang_items(self) -> Lrc<middle::lang_items::LanguageItems> {\n+    pub fn lang_items(self) -> &'gcx middle::lang_items::LanguageItems {\n         self.get_lang_items(LOCAL_CRATE)\n     }\n \n@@ -1406,15 +1418,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         else { None }\n     }\n \n-    pub fn stability(self) -> Lrc<stability::Index<'tcx>> {\n+    pub fn stability(self) -> &'gcx stability::Index<'gcx> {\n         self.stability_index(LOCAL_CRATE)\n     }\n \n-    pub fn crates(self) -> Lrc<Vec<CrateNum>> {\n+    pub fn crates(self) -> &'gcx [CrateNum] {\n         self.all_crate_nums(LOCAL_CRATE)\n     }\n \n-    pub fn features(self) -> Lrc<feature_gate::Features> {\n+    pub fn features(self) -> &'gcx feature_gate::Features {\n         self.features_query(LOCAL_CRATE)\n     }\n \n@@ -2965,9 +2977,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         lint::struct_lint_level(self.sess, lint, level, src, None, msg)\n     }\n \n-    pub fn in_scope_traits(self, id: HirId) -> Option<Lrc<StableVec<TraitCandidate>>> {\n+    pub fn in_scope_traits(self, id: HirId) -> Option<&'gcx StableVec<TraitCandidate>> {\n         self.in_scope_traits_map(id.owner)\n-            .and_then(|map| map.get(&id.local_id).cloned())\n+            .and_then(|map| map.get(&id.local_id))\n     }\n \n     pub fn named_region(self, id: HirId) -> Option<resolve_lifetime::Region> {\n@@ -2982,10 +2994,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn object_lifetime_defaults(self, id: HirId)\n-        -> Option<Lrc<Vec<ObjectLifetimeDefault>>>\n+        -> Option<&'gcx [ObjectLifetimeDefault]>\n     {\n         self.object_lifetime_defaults_map(id.owner)\n-            .and_then(|map| map.get(&id.local_id).cloned())\n+            .and_then(|map| map.get(&id.local_id).map(|v| &**v))\n     }\n }\n \n@@ -3040,27 +3052,27 @@ fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {\n }\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n-    providers.in_scope_traits_map = |tcx, id| tcx.gcx.trait_map.get(&id).cloned();\n-    providers.module_exports = |tcx, id| tcx.gcx.export_map.get(&id).cloned();\n+    providers.in_scope_traits_map = |tcx, id| tcx.gcx.trait_map.get(&id);\n+    providers.module_exports = |tcx, id| tcx.gcx.export_map.get(&id).map(|v| &v[..]);\n     providers.crate_name = |tcx, id| {\n         assert_eq!(id, LOCAL_CRATE);\n         tcx.crate_name\n     };\n     providers.get_lib_features = |tcx, id| {\n         assert_eq!(id, LOCAL_CRATE);\n-        Lrc::new(middle::lib_features::collect(tcx))\n+        tcx.arena.alloc(middle::lib_features::collect(tcx))\n     };\n     providers.get_lang_items = |tcx, id| {\n         assert_eq!(id, LOCAL_CRATE);\n-        Lrc::new(middle::lang_items::collect(tcx))\n+        tcx.arena.alloc(middle::lang_items::collect(tcx))\n     };\n-    providers.upvars = |tcx, id| tcx.gcx.upvars.get(&id).cloned();\n+    providers.upvars = |tcx, id| tcx.gcx.upvars.get(&id).map(|v| &v[..]);\n     providers.maybe_unused_trait_import = |tcx, id| {\n         tcx.maybe_unused_trait_imports.contains(&id)\n     };\n     providers.maybe_unused_extern_crates = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        Lrc::new(tcx.maybe_unused_extern_crates.clone())\n+        &tcx.maybe_unused_extern_crates[..]\n     };\n     providers.names_imported_by_glob_use = |tcx, id| {\n         assert_eq!(id.krate, LOCAL_CRATE);\n@@ -3069,7 +3081,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n \n     providers.stability_index = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        Lrc::new(stability::Index::new(tcx))\n+        tcx.arena.alloc(stability::Index::new(tcx))\n     };\n     providers.lookup_stability = |tcx, id| {\n         assert_eq!(id.krate, LOCAL_CRATE);\n@@ -3087,19 +3099,19 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     };\n     providers.all_crate_nums = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        Lrc::new(tcx.cstore.crates_untracked())\n+        tcx.arena.alloc_slice(&tcx.cstore.crates_untracked())\n     };\n     providers.postorder_cnums = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        Lrc::new(tcx.cstore.postorder_cnums_untracked())\n+        tcx.arena.alloc_slice(&tcx.cstore.postorder_cnums_untracked())\n     };\n     providers.output_filenames = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n         tcx.output_filenames.clone()\n     };\n     providers.features_query = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        Lrc::new(tcx.sess.features_untracked().clone())\n+        tcx.arena.alloc(tcx.sess.features_untracked().clone())\n     };\n     providers.is_panic_runtime = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);"}, {"sha": "99c3293168754dd9a15cb2073996fa08088c0970", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -2298,7 +2298,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n \n     #[inline]\n-    pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Lrc<GenericPredicates<'gcx>> {\n+    pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx GenericPredicates<'gcx> {\n         tcx.predicates_of(self.did)\n     }\n \n@@ -3106,7 +3106,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n pub struct AssociatedItemsIterator<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    def_ids: Lrc<Vec<DefId>>,\n+    def_ids: &'gcx [DefId],\n     next_index: usize,\n }\n \n@@ -3183,26 +3183,27 @@ fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      def_id: DefId)\n-                                     -> Lrc<Vec<DefId>> {\n+                                     -> &'tcx [DefId] {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let item = tcx.hir().expect_item_by_hir_id(id);\n-    let vec: Vec<_> = match item.node {\n+    match item.node {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n-            trait_item_refs.iter()\n-                           .map(|trait_item_ref| trait_item_ref.id)\n-                           .map(|id| tcx.hir().local_def_id_from_hir_id(id.hir_id))\n-                           .collect()\n+            tcx.arena.alloc_from_iter(\n+                trait_item_refs.iter()\n+                               .map(|trait_item_ref| trait_item_ref.id)\n+                               .map(|id| tcx.hir().local_def_id_from_hir_id(id.hir_id))\n+            )\n         }\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n-            impl_item_refs.iter()\n-                          .map(|impl_item_ref| impl_item_ref.id)\n-                          .map(|id| tcx.hir().local_def_id_from_hir_id(id.hir_id))\n-                          .collect()\n+            tcx.arena.alloc_from_iter(\n+                impl_item_refs.iter()\n+                              .map(|impl_item_ref| impl_item_ref.id)\n+                              .map(|id| tcx.hir().local_def_id_from_hir_id(id.hir_id))\n+            )\n         }\n-        hir::ItemKind::TraitAlias(..) => vec![],\n+        hir::ItemKind::TraitAlias(..) => &[],\n         _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\")\n-    };\n-    Lrc::new(vec)\n+    }\n }\n \n fn def_span<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Span {\n@@ -3388,7 +3389,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n /// (constructing this map requires touching the entire crate).\n #[derive(Clone, Debug, Default, HashStable)]\n pub struct CrateInherentImpls {\n-    pub inherent_impls: DefIdMap<Lrc<Vec<DefId>>>,\n+    pub inherent_impls: DefIdMap<Vec<DefId>>,\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable)]"}, {"sha": "06db4b9b65bcaf545ebad92ab6f816d3b2015ab7", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -253,8 +253,8 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n             // 2. for an extern inferred from a path or an indirect crate,\n             //    where there is no explicit `extern crate`, we just prepend\n             //    the crate name.\n-            match *self.tcx().extern_crate(def_id) {\n-                Some(ExternCrate {\n+            match self.tcx().extern_crate(def_id) {\n+                Some(&ExternCrate {\n                     src: ExternCrateSource::Extern(def_id),\n                     direct: true,\n                     span,"}, {"sha": "01d431b0ef0e7a04fb8c50f51dfe72c6ea4e5653", "filename": "src/librustc/ty/query/values.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -14,12 +14,6 @@ impl<'tcx, T> Value<'tcx> for T {\n     }\n }\n \n-impl<'tcx, T: Default> Value<'tcx> for T {\n-    default fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> T {\n-        T::default()\n-    }\n-}\n-\n impl<'tcx> Value<'tcx> for Ty<'tcx> {\n     fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n         tcx.types.err"}, {"sha": "7dca47485bb928d8f531083ef6b7d4affa8a3214", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -32,7 +32,6 @@ use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::rc::Rc;\n-use rustc_data_structures::sync::Lrc;\n use std::hash::{Hash, Hasher};\n use syntax::source_map::CompilerDesugaringKind;\n use syntax_pos::{MultiSpan, Span};\n@@ -75,7 +74,7 @@ pub struct AnalysisData<'a, 'tcx: 'a> {\n }\n \n fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n-    -> Lrc<BorrowCheckResult>\n+    -> &'tcx BorrowCheckResult\n {\n     assert!(tcx.use_ast_borrowck() || tcx.migrate_borrowck());\n \n@@ -89,7 +88,7 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n             // those things (notably the synthesized constructors from\n             // tuple structs/variants) do not have an associated body\n             // and do not need borrowchecking.\n-            return Lrc::new(BorrowCheckResult {\n+            return tcx.arena.alloc(BorrowCheckResult {\n                 used_mut_nodes: Default::default(),\n                 signalled_any_error: SignalledError::NoErrorsSeen,\n             })\n@@ -136,7 +135,7 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n         check_loans::check_loans(&mut bccx, &loan_dfcx, &flowed_moves, &all_loans, body);\n     }\n \n-    Lrc::new(BorrowCheckResult {\n+    tcx.arena.alloc(BorrowCheckResult {\n         used_mut_nodes: bccx.used_mut_nodes.into_inner(),\n         signalled_any_error: bccx.signalled_any_error.into_inner(),\n     })"}, {"sha": "9d0e7dde34d131eb590afb5d7fc3a065944498e5", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -10,7 +10,6 @@ use rustc::ty::{self, TyCtxt, PolyFnSig};\n use rustc::ty::layout::HasTyCtxt;\n use rustc::ty::query::Providers;\n use rustc_data_structures::small_c_str::SmallCStr;\n-use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_target::spec::PanicStrategy;\n use rustc_codegen_ssa::traits::*;\n@@ -320,11 +319,11 @@ pub fn provide(providers: &mut Providers<'_>) {\n         if tcx.sess.opts.actually_rustdoc {\n             // rustdoc needs to be able to document functions that use all the features, so\n             // whitelist them all\n-            Lrc::new(llvm_util::all_known_features()\n+            tcx.arena.alloc(llvm_util::all_known_features()\n                 .map(|(a, b)| (a.to_string(), b))\n                 .collect())\n         } else {\n-            Lrc::new(llvm_util::target_feature_whitelist(tcx.sess)\n+            tcx.arena.alloc(llvm_util::target_feature_whitelist(tcx.sess)\n                 .iter()\n                 .map(|&(a, b)| (a.to_string(), b))\n                 .collect())\n@@ -364,7 +363,7 @@ pub fn provide_extern(providers: &mut Providers<'_>) {\n             }));\n         }\n \n-        Lrc::new(ret)\n+        tcx.arena.alloc(ret)\n     };\n }\n "}, {"sha": "fb7ef87646296b4fbe1711f5eaf7ad7f6d1cc1f1", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -1,4 +1,3 @@\n-use rustc_data_structures::sync::Lrc;\n use std::sync::Arc;\n \n use rustc::ty::Instance;\n@@ -49,12 +48,12 @@ pub fn crates_export_threshold(crate_types: &[config::CrateType]) -> SymbolExpor\n \n fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              cnum: CrateNum)\n-                                             -> Lrc<DefIdMap<SymbolExportLevel>>\n+                                             -> &'tcx DefIdMap<SymbolExportLevel>\n {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     if !tcx.sess.opts.output_types.should_codegen() {\n-        return Default::default();\n+        return tcx.arena.alloc(Default::default());\n     }\n \n     // Check to see if this crate is a \"special runtime crate\". These\n@@ -155,7 +154,7 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         reachable_non_generics.insert(id, SymbolExportLevel::C);\n     }\n \n-    Lrc::new(reachable_non_generics)\n+    tcx.arena.alloc(reachable_non_generics)\n }\n \n fn is_reachable_non_generic_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -282,7 +281,7 @@ fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn upstream_monomorphizations_provider<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cnum: CrateNum)\n-    -> Lrc<DefIdMap<Lrc<FxHashMap<SubstsRef<'tcx>, CrateNum>>>>\n+    -> &'tcx DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>>\n {\n     debug_assert!(cnum == LOCAL_CRATE);\n \n@@ -326,20 +325,16 @@ fn upstream_monomorphizations_provider<'a, 'tcx>(\n         }\n     }\n \n-    Lrc::new(instances.into_iter()\n-                      .map(|(key, value)| (key, Lrc::new(value)))\n-                      .collect())\n+    tcx.arena.alloc(instances)\n }\n \n fn upstream_monomorphizations_for_provider<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId)\n-    -> Option<Lrc<FxHashMap<SubstsRef<'tcx>, CrateNum>>>\n+    -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>>\n {\n     debug_assert!(!def_id.is_local());\n-    tcx.upstream_monomorphizations(LOCAL_CRATE)\n-       .get(&def_id)\n-       .cloned()\n+    tcx.upstream_monomorphizations(LOCAL_CRATE).get(&def_id)\n }\n \n fn is_unreachable_local_definition_provider(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> bool {"}, {"sha": "0b037f872475decc13b8adb23623f665d4c9b25f", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -33,7 +33,6 @@ use rustc_mir::monomorphize::Instance;\n use rustc_mir::monomorphize::partitioning::{CodegenUnit, CodegenUnitExt};\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_data_structures::sync::Lrc;\n use rustc_codegen_utils::{symbol_names_test, check_for_rustc_errors_attr};\n use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n use crate::mir::place::PlaceRef;\n@@ -916,7 +915,7 @@ pub fn provide_both(providers: &mut Providers<'_>) {\n             .map(|id| &module_map[&id])\n             .flat_map(|module| module.foreign_items.iter().cloned())\n             .collect();\n-        Lrc::new(dllimports)\n+        tcx.arena.alloc(dllimports)\n     };\n \n     providers.is_dllimport_foreign_item = |tcx, def_id| {"}, {"sha": "76aba33b6a404ddcb5cc6243106fb353701a9bb4", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -13,6 +13,7 @@ crate-type = [\"dylib\"]\n flate2 = \"1.0\"\n log = \"0.4\"\n memmap = \"0.6\"\n+smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }"}, {"sha": "fae4c244d6e1404a5e765c22255fa62b5e9386ff", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -21,6 +21,7 @@ use rustc::hir::map::definitions::DefPathTable;\n use rustc::util::nodemap::DefIdMap;\n use rustc_data_structures::svh::Svh;\n \n+use smallvec::SmallVec;\n use std::any::Any;\n use rustc_data_structures::sync::Lrc;\n use std::sync::Arc;\n@@ -95,9 +96,11 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     generics_of => {\n         tcx.alloc_generics(cdata.get_generics(def_id.index, tcx.sess))\n     }\n-    predicates_of => { Lrc::new(cdata.get_predicates(def_id.index, tcx)) }\n-    predicates_defined_on => { Lrc::new(cdata.get_predicates_defined_on(def_id.index, tcx)) }\n-    super_predicates_of => { Lrc::new(cdata.get_super_predicates(def_id.index, tcx)) }\n+    predicates_of => { tcx.arena.alloc(cdata.get_predicates(def_id.index, tcx)) }\n+    predicates_defined_on => {\n+        tcx.arena.alloc(cdata.get_predicates_defined_on(def_id.index, tcx))\n+    }\n+    super_predicates_of => { tcx.arena.alloc(cdata.get_super_predicates(def_id.index, tcx)) }\n     trait_def => {\n         tcx.alloc_trait_def(cdata.get_trait_def(def_id.index, tcx.sess))\n     }\n@@ -108,10 +111,10 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     }\n     variances_of => { tcx.arena.alloc_from_iter(cdata.get_item_variances(def_id.index)) }\n     associated_item_def_ids => {\n-        let mut result = vec![];\n+        let mut result = SmallVec::<[_; 8]>::new();\n         cdata.each_child_of_item(def_id.index,\n           |child| result.push(child.res.def_id()), tcx.sess);\n-        Lrc::new(result)\n+        tcx.arena.alloc_slice(&result)\n     }\n     associated_item => { cdata.get_associated_item(def_id.index) }\n     impl_trait_ref => { cdata.get_impl_trait(def_id.index, tcx) }\n@@ -134,7 +137,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         (cdata.mir_const_qualif(def_id.index), tcx.arena.alloc(BitSet::new_empty(0)))\n     }\n     fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n-    inherent_impls => { Lrc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n+    inherent_impls => { cdata.get_inherent_implementations_for_type(tcx, def_id.index) }\n     is_const_fn_raw => { cdata.is_const_fn_raw(def_id.index) }\n     is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n     static_mutability => { cdata.static_mutability(def_id.index) }\n@@ -160,7 +163,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     }\n     is_mir_available => { cdata.is_item_mir_available(def_id.index) }\n \n-    dylib_dependency_formats => { Lrc::new(cdata.get_dylib_dependency_formats()) }\n+    dylib_dependency_formats => { cdata.get_dylib_dependency_formats(tcx) }\n     is_panic_runtime => { cdata.root.panic_runtime }\n     is_compiler_builtins => { cdata.root.compiler_builtins }\n     has_global_allocator => { cdata.root.has_global_allocator }\n@@ -169,8 +172,8 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     is_profiler_runtime => { cdata.root.profiler_runtime }\n     panic_strategy => { cdata.root.panic_strategy }\n     extern_crate => {\n-        let r = Lrc::new(*cdata.extern_crate.lock());\n-        r\n+        let r = *cdata.extern_crate.lock();\n+        r.map(|c| &*tcx.arena.alloc(c))\n     }\n     is_no_builtins => { cdata.root.no_builtins }\n     impl_defaultness => { cdata.get_impl_defaultness(def_id.index) }\n@@ -187,10 +190,10 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n             })\n             .collect();\n \n-        Lrc::new(reachable_non_generics)\n+        tcx.arena.alloc(reachable_non_generics)\n     }\n     native_libraries => { Lrc::new(cdata.get_native_libraries(tcx.sess)) }\n-    foreign_modules => { Lrc::new(cdata.get_foreign_modules(tcx.sess)) }\n+    foreign_modules => { cdata.get_foreign_modules(tcx) }\n     plugin_registrar_fn => {\n         cdata.root.plugin_registrar_fn.map(|index| {\n             DefId { krate: def_id.krate, index }\n@@ -207,18 +210,12 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n \n     extra_filename => { cdata.root.extra_filename.clone() }\n \n-\n     implementations_of_trait => {\n-        let mut result = vec![];\n-        let filter = Some(other);\n-        cdata.get_implementations_for_trait(filter, &mut result);\n-        Lrc::new(result)\n+        cdata.get_implementations_for_trait(tcx, Some(other))\n     }\n \n     all_trait_implementations => {\n-        let mut result = vec![];\n-        cdata.get_implementations_for_trait(None, &mut result);\n-        Lrc::new(result)\n+        cdata.get_implementations_for_trait(tcx, None)\n     }\n \n     visibility => { cdata.get_visibility(def_id.index) }\n@@ -228,13 +225,13 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     }\n     crate_name => { cdata.name }\n     item_children => {\n-        let mut result = vec![];\n+        let mut result = SmallVec::<[_; 8]>::new();\n         cdata.each_child_of_item(def_id.index, |child| result.push(child), tcx.sess);\n-        Lrc::new(result)\n+        tcx.arena.alloc_slice(&result)\n     }\n-    defined_lib_features => { Lrc::new(cdata.get_lib_features()) }\n-    defined_lang_items => { Lrc::new(cdata.get_lang_items()) }\n-    missing_lang_items => { Lrc::new(cdata.get_missing_lang_items()) }\n+    defined_lib_features => { cdata.get_lib_features(tcx) }\n+    defined_lang_items => { cdata.get_lang_items(tcx) }\n+    missing_lang_items => { cdata.get_missing_lang_items(tcx) }\n \n     missing_extern_crate_item => {\n         let r = match *cdata.extern_crate.borrow() {\n@@ -288,7 +285,7 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n         },\n         foreign_modules: |tcx, cnum| {\n             assert_eq!(cnum, LOCAL_CRATE);\n-            Lrc::new(foreign_modules::collect(tcx))\n+            &tcx.arena.alloc(foreign_modules::collect(tcx))[..]\n         },\n         link_args: |tcx, cnum| {\n             assert_eq!(cnum, LOCAL_CRATE);\n@@ -325,7 +322,7 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n             // which is to say, its not deterministic in general. But\n             // we believe that libstd is consistently assigned crate\n             // num 1, so it should be enough to resolve #46112.\n-            let mut crates: Vec<CrateNum> = (*tcx.crates()).clone();\n+            let mut crates: Vec<CrateNum> = (*tcx.crates()).to_owned();\n             crates.sort();\n \n             for &cnum in crates.iter() {\n@@ -374,7 +371,7 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n                 }\n             }\n \n-            Lrc::new(visible_parent_map)\n+            tcx.arena.alloc(visible_parent_map)\n         },\n \n         ..*providers"}, {"sha": "958c81989ffd6707328578b888c95146a20c0923", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 55, "deletions": 38, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -708,26 +708,30 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over all the stability attributes in the given crate.\n-    pub fn get_lib_features(&self) -> Vec<(ast::Name, Option<ast::Name>)> {\n+    pub fn get_lib_features(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, '_>,\n+    ) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n         // FIXME: For a proc macro crate, not sure whether we should return the \"host\"\n         // features or an empty Vec. Both don't cause ICEs.\n-        self.root\n+        tcx.arena.alloc_from_iter(self.root\n             .lib_features\n-            .decode(self)\n-            .collect()\n+            .decode(self))\n     }\n \n     /// Iterates over the language items in the given crate.\n-    pub fn get_lang_items(&self) -> Vec<(DefId, usize)> {\n+    pub fn get_lang_items(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, '_>,\n+    ) -> &'tcx [(DefId, usize)] {\n         if self.proc_macros.is_some() {\n             // Proc macro crates do not export any lang-items to the target.\n-            vec![]\n+            &[]\n         } else {\n-            self.root\n+            tcx.arena.alloc_from_iter(self.root\n                 .lang_items\n                 .decode(self)\n-                .map(|(def_index, index)| (self.local_def_id(def_index), index))\n-                .collect()\n+                .map(|(def_index, index)| (self.local_def_id(def_index), index)))\n         }\n     }\n \n@@ -1013,39 +1017,45 @@ impl<'a, 'tcx> CrateMetadata {\n         None\n     }\n \n-    pub fn get_inherent_implementations_for_type(&self, id: DefIndex) -> Vec<DefId> {\n-        self.entry(id)\n-            .inherent_impls\n-            .decode(self)\n-            .map(|index| self.local_def_id(index))\n-            .collect()\n+    pub fn get_inherent_implementations_for_type(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, '_>,\n+        id: DefIndex\n+    ) -> &'tcx [DefId] {\n+        tcx.arena.alloc_from_iter(self.entry(id)\n+                                      .inherent_impls\n+                                      .decode(self)\n+                                      .map(|index| self.local_def_id(index)))\n     }\n \n-    pub fn get_implementations_for_trait(&self,\n-                                         filter: Option<DefId>,\n-                                         result: &mut Vec<DefId>) {\n+    pub fn get_implementations_for_trait(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, '_>,\n+        filter: Option<DefId>,\n+    ) -> &'tcx [DefId] {\n         if self.proc_macros.is_some() {\n             // proc-macro crates export no trait impls.\n-            return\n+            return &[]\n         }\n \n         // Do a reverse lookup beforehand to avoid touching the crate_num\n         // hash map in the loop below.\n         let filter = match filter.map(|def_id| self.reverse_translate_def_id(def_id)) {\n             Some(Some(def_id)) => Some((def_id.krate.as_u32(), def_id.index)),\n-            Some(None) => return,\n+            Some(None) => return &[],\n             None => None,\n         };\n \n         if let Some(filter) = filter {\n-            if let Some(impls) = self.trait_impls\n-                                     .get(&filter) {\n-                result.extend(impls.decode(self).map(|idx| self.local_def_id(idx)));\n+            if let Some(impls) = self.trait_impls.get(&filter) {\n+                tcx.arena.alloc_from_iter(impls.decode(self).map(|idx| self.local_def_id(idx)))\n+            } else {\n+                &[]\n             }\n         } else {\n-            for impls in self.trait_impls.values() {\n-                result.extend(impls.decode(self).map(|idx| self.local_def_id(idx)));\n-            }\n+            tcx.arena.alloc_from_iter(self.trait_impls.values().flat_map(|impls| {\n+                impls.decode(self).map(|idx| self.local_def_id(idx))\n+            }))\n         }\n     }\n \n@@ -1075,36 +1085,43 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_foreign_modules(&self, sess: &Session) -> Vec<ForeignModule> {\n+    pub fn get_foreign_modules(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, '_>,\n+    ) -> &'tcx [ForeignModule] {\n         if self.proc_macros.is_some() {\n             // Proc macro crates do not have any *target* foreign modules.\n-            vec![]\n+            &[]\n         } else {\n-            self.root.foreign_modules.decode((self, sess)).collect()\n+            tcx.arena.alloc_from_iter(self.root.foreign_modules.decode((self, tcx.sess)))\n         }\n     }\n \n-    pub fn get_dylib_dependency_formats(&self) -> Vec<(CrateNum, LinkagePreference)> {\n-        self.root\n+    pub fn get_dylib_dependency_formats(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, '_>,\n+    ) -> &'tcx [(CrateNum, LinkagePreference)] {\n+        tcx.arena.alloc_from_iter(self.root\n             .dylib_dependency_formats\n             .decode(self)\n             .enumerate()\n             .flat_map(|(i, link)| {\n                 let cnum = CrateNum::new(i + 1);\n                 link.map(|link| (self.cnum_map[cnum], link))\n-            })\n-            .collect()\n+            }))\n     }\n \n-    pub fn get_missing_lang_items(&self) -> Vec<lang_items::LangItem> {\n+    pub fn get_missing_lang_items(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, '_>,\n+    ) -> &'tcx [lang_items::LangItem] {\n         if self.proc_macros.is_some() {\n             // Proc macro crates do not depend on any target weak lang-items.\n-            vec![]\n+            &[]\n         } else {\n-            self.root\n+            tcx.arena.alloc_from_iter(self.root\n                 .lang_items_missing\n-                .decode(self)\n-                .collect()\n+                .decode(self))\n         }\n     }\n "}, {"sha": "1a9d996131dc0ee9325c99e0fcd94696cfd9ae80", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -673,7 +673,7 @@ impl EncodeContext<'_, 'tcx> {\n \n         let data = ModData {\n             reexports: match tcx.module_exports(def_id) {\n-                Some(ref exports) => self.lazy_seq_ref(&exports[..]),\n+                Some(exports) => self.lazy_seq_ref(exports),\n                 _ => LazySeq::empty(),\n             },\n         };"}, {"sha": "65b6a89aa0b4d4225cd98e14e44144f42d73feb3", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -24,7 +24,6 @@ use rustc::ty::query::Providers;\n use rustc::ty::subst::InternalSubsts;\n use rustc::util::nodemap::HirIdSet;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::sync::Lrc;\n use syntax::ast::Ident;\n use syntax::attr;\n use syntax::symbol::{kw, sym};\n@@ -67,7 +66,7 @@ trait DefIdVisitor<'a, 'tcx: 'a> {\n     fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> bool {\n         self.skeleton().visit_trait(trait_ref)\n     }\n-    fn visit_predicates(&mut self, predicates: Lrc<ty::GenericPredicates<'tcx>>) -> bool {\n+    fn visit_predicates(&mut self, predicates: &ty::GenericPredicates<'tcx>) -> bool {\n         self.skeleton().visit_predicates(predicates)\n     }\n }\n@@ -89,8 +88,8 @@ impl<'a, 'tcx, V> DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n         (!self.def_id_visitor.shallow() && substs.visit_with(self))\n     }\n \n-    fn visit_predicates(&mut self, predicates: Lrc<ty::GenericPredicates<'tcx>>) -> bool {\n-        let ty::GenericPredicates { parent: _, predicates } = &*predicates;\n+    fn visit_predicates(&mut self, predicates: &ty::GenericPredicates<'tcx>) -> bool {\n+        let ty::GenericPredicates { parent: _, predicates } = predicates;\n         for (predicate, _span) in predicates {\n             match predicate {\n                 ty::Predicate::Trait(poly_predicate) => {\n@@ -1851,7 +1850,7 @@ fn check_mod_privacy<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n fn privacy_access_levels<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     krate: CrateNum,\n-) -> Lrc<AccessLevels> {\n+) -> &'tcx AccessLevels {\n     assert_eq!(krate, LOCAL_CRATE);\n \n     // Build up a set of all exported items in the AST. This is a set of all\n@@ -1872,7 +1871,7 @@ fn privacy_access_levels<'tcx>(\n     }\n     visitor.update(hir::CRATE_HIR_ID, Some(AccessLevel::Public));\n \n-    Lrc::new(visitor.access_levels)\n+    tcx.arena.alloc(visitor.access_levels)\n }\n \n fn check_private_in_public<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, krate: CrateNum) {"}, {"sha": "55471dbc00be5c75a3dfbdbd8bd3b8ba8966078f", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -24,7 +24,6 @@ use rustc::session::config::{CrateType, Input, OutputType};\n use rustc::ty::{self, DefIdTree, TyCtxt};\n use rustc::{bug, span_bug};\n use rustc_codegen_utils::link::{filename_for_metadata, out_filename};\n-use rustc_data_structures::sync::Lrc;\n \n use std::cell::Cell;\n use std::default::Default;\n@@ -110,8 +109,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let mut result = Vec::with_capacity(self.tcx.crates().len());\n \n         for &n in self.tcx.crates().iter() {\n-            let span = match *self.tcx.extern_crate(n.as_def_id()) {\n-                Some(ExternCrate { span, .. }) => span,\n+            let span = match self.tcx.extern_crate(n.as_def_id()) {\n+                Some(&ExternCrate { span, .. }) => span,\n                 None => {\n                     debug!(\"Skipping crate {}, no data\", n);\n                     continue;\n@@ -1120,7 +1119,7 @@ pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n         // fallback in case the access levels couldn't have been correctly computed.\n         let access_levels = match tcx.sess.compile_status() {\n             Ok(..) => tcx.privacy_access_levels(LOCAL_CRATE),\n-            Err(..) => Lrc::new(AccessLevels::default()),\n+            Err(..) => tcx.arena.alloc(AccessLevels::default()),\n         };\n \n         let save_ctxt = SaveContext {"}, {"sha": "3a2b0178ce4d099c525ea7457ed1bc3bc7bb5737", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -17,7 +17,6 @@ use rustc::ty::{GenericParamDef, GenericParamDefKind};\n use rustc::ty::subst::{Kind, Subst, InternalSubsts, SubstsRef};\n use rustc::ty::wf::object_region_bounds;\n use rustc::mir::interpret::ConstValue;\n-use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::abi;\n use crate::require_c_abi_if_c_variadic;\n use smallvec::SmallVec;\n@@ -46,7 +45,7 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// Returns the set of bounds in scope for the type parameter with\n     /// the given id.\n     fn get_type_parameter_bounds(&self, span: Span, def_id: DefId)\n-                                 -> Lrc<ty::GenericPredicates<'tcx>>;\n+                                 -> &'tcx ty::GenericPredicates<'tcx>;\n \n     /// What lifetime should we use when a lifetime is omitted (and not elided)?\n     fn re_infer(&self, span: Span, _def: Option<&ty::GenericParamDef>)"}, {"sha": "dfe21edee41f3fb629f05580f2b477971f21a1c5", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -6,7 +6,6 @@ use crate::middle::lang_items::FnOnceTraitLangItem;\n use crate::namespace::Namespace;\n use crate::util::nodemap::FxHashSet;\n use errors::{Applicability, DiagnosticBuilder};\n-use rustc_data_structures::sync::Lrc;\n use rustc::hir::{self, ExprKind, Node, QPath};\n use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n@@ -844,7 +843,7 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     providers.all_traits = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        Lrc::new(compute_all_traits(tcx))\n+        &tcx.arena.alloc(compute_all_traits(tcx))[..]\n     }\n }\n "}, {"sha": "655bf5722ae5af7eb2959a3790d34286178343ff", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -97,7 +97,6 @@ use crate::namespace::Namespace;\n use rustc::infer::{self, InferCtxt, InferOk, InferResult};\n use rustc::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::abi::Abi;\n use rustc::infer::opaque_types::OpaqueTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin};\n@@ -808,8 +807,8 @@ fn has_typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn used_trait_imports<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 def_id: DefId)\n-                                -> Lrc<DefIdSet> {\n-    tcx.typeck_tables_of(def_id).used_trait_imports.clone()\n+                                -> &'tcx DefIdSet {\n+    &*tcx.typeck_tables_of(def_id).used_trait_imports\n }\n \n fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1907,15 +1906,15 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn get_type_parameter_bounds(&self, _: Span, def_id: DefId)\n-                                 -> Lrc<ty::GenericPredicates<'tcx>>\n+                                 -> &'tcx ty::GenericPredicates<'tcx>\n     {\n         let tcx = self.tcx;\n         let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let item_id = tcx.hir().ty_param_owner(hir_id);\n         let item_def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n         let generics = tcx.generics_of(item_def_id);\n         let index = generics.param_def_id_to_index[&def_id];\n-        Lrc::new(ty::GenericPredicates {\n+        tcx.arena.alloc(ty::GenericPredicates {\n             parent: None,\n             predicates: self.param_env.caller_bounds.iter().filter_map(|&predicate| {\n                 match predicate {"}, {"sha": "644d95963e652cdf5a882fbf05675178dafaec9c", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -13,14 +13,13 @@ use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::{self, CrateInherentImpls, TyCtxt};\n \n-use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax_pos::Span;\n \n /// On-demand query: yields a map containing all types mapped to their inherent impls.\n pub fn crate_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       crate_num: CrateNum)\n-                                      -> Lrc<CrateInherentImpls> {\n+                                      -> &'tcx CrateInherentImpls {\n     assert_eq!(crate_num, LOCAL_CRATE);\n \n     let krate = tcx.hir().krate();\n@@ -29,13 +28,13 @@ pub fn crate_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         impls_map: Default::default(),\n     };\n     krate.visit_all_item_likes(&mut collect);\n-    Lrc::new(collect.impls_map)\n+    tcx.arena.alloc(collect.impls_map)\n }\n \n /// On-demand query: yields a vector of the inherent impls for a specific type.\n pub fn inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 ty_def_id: DefId)\n-                                -> Lrc<Vec<DefId>> {\n+                                -> &'tcx [DefId] {\n     assert!(ty_def_id.is_local());\n \n     // NB. Until we adopt the red-green dep-tracking algorithm (see\n@@ -53,15 +52,11 @@ pub fn inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     //\n     // [the plan]: https://github.com/rust-lang/rust-roadmap/issues/4\n \n-    thread_local! {\n-        static EMPTY_DEF_ID_VEC: Lrc<Vec<DefId>> = Lrc::new(vec![])\n-    }\n-\n     let result = tcx.dep_graph.with_ignore(|| {\n         let crate_map = tcx.crate_inherent_impls(ty_def_id.krate);\n         match crate_map.inherent_impls.get(&ty_def_id) {\n-            Some(v) => v.clone(),\n-            None => EMPTY_DEF_ID_VEC.with(|v| v.clone())\n+            Some(v) => &v[..],\n+            None => &[],\n         }\n     });\n \n@@ -289,13 +284,8 @@ impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits.\n             let impl_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n-            let mut rc_vec = self.impls_map.inherent_impls\n-                                           .entry(def_id)\n-                                           .or_default();\n-\n-            // At this point, there should not be any clones of the\n-            // `Lrc`, so we can still safely push into it in place:\n-            Lrc::get_mut(&mut rc_vec).unwrap().push(impl_def_id);\n+            let vec = self.impls_map.inherent_impls.entry(def_id).or_default();\n+            vec.push(impl_def_id);\n         } else {\n             struct_span_err!(self.tcx.sess,\n                              item.span,"}, {"sha": "45380d757b97d77d981c89366f7c20d090cff79b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -31,7 +31,6 @@ use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::{ReprOptions, ToPredicate};\n use rustc::util::captures::Captures;\n use rustc::util::nodemap::FxHashMap;\n-use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::abi;\n \n use syntax::ast;\n@@ -178,7 +177,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n     }\n \n     fn get_type_parameter_bounds(&self, span: Span, def_id: DefId)\n-                                 -> Lrc<ty::GenericPredicates<'tcx>> {\n+                                 -> &'tcx ty::GenericPredicates<'tcx> {\n         self.tcx\n             .at(span)\n             .type_param_predicates((self.item_def_id, def_id))\n@@ -243,7 +242,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n fn type_param_predicates<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     (item_def_id, def_id): (DefId, DefId),\n-) -> Lrc<ty::GenericPredicates<'tcx>> {\n+) -> &'tcx ty::GenericPredicates<'tcx> {\n     use rustc::hir::*;\n \n     // In the AST, bounds can derive from two places. Either\n@@ -264,16 +263,11 @@ fn type_param_predicates<'a, 'tcx>(\n         tcx.generics_of(item_def_id).parent\n     };\n \n-    let mut result = parent.map_or_else(\n-        || Lrc::new(ty::GenericPredicates {\n-            parent: None,\n-            predicates: vec![],\n-        }),\n-        |parent| {\n-            let icx = ItemCtxt::new(tcx, parent);\n-            icx.get_type_parameter_bounds(DUMMY_SP, def_id)\n-        },\n-    );\n+    let result = parent.map_or(&tcx.common.empty_predicates, |parent| {\n+        let icx = ItemCtxt::new(tcx, parent);\n+        icx.get_type_parameter_bounds(DUMMY_SP, def_id)\n+    });\n+    let mut extend = None;\n \n     let item_hir_id = tcx.hir().as_local_hir_id(item_def_id).unwrap();\n     let ast_generics = match tcx.hir().get_by_hir_id(item_hir_id) {\n@@ -298,9 +292,7 @@ fn type_param_predicates<'a, 'tcx>(\n                     // Implied `Self: Trait` and supertrait bounds.\n                     if param_id == item_hir_id {\n                         let identity_trait_ref = ty::TraitRef::identity(tcx, item_def_id);\n-                        Lrc::make_mut(&mut result)\n-                            .predicates\n-                            .push((identity_trait_ref.to_predicate(), item.span));\n+                        extend = Some((identity_trait_ref.to_predicate(), item.span));\n                     }\n                     generics\n                 }\n@@ -317,11 +309,12 @@ fn type_param_predicates<'a, 'tcx>(\n     };\n \n     let icx = ItemCtxt::new(tcx, item_def_id);\n-    Lrc::make_mut(&mut result)\n-        .predicates\n-        .extend(icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty,\n-            OnlySelfBounds(true)));\n-    result\n+    let mut result = (*result).clone();\n+    result.predicates.extend(extend.into_iter());\n+    result.predicates\n+          .extend(icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty,\n+                  OnlySelfBounds(true)));\n+    tcx.arena.alloc(result)\n }\n \n impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n@@ -690,7 +683,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n fn super_predicates_of<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     trait_def_id: DefId,\n-) -> Lrc<ty::GenericPredicates<'tcx>> {\n+) -> &'tcx ty::GenericPredicates<'tcx> {\n     debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n     let trait_hir_id = tcx.hir().as_local_hir_id(trait_def_id).unwrap();\n \n@@ -734,7 +727,7 @@ fn super_predicates_of<'a, 'tcx>(\n         }\n     }\n \n-    Lrc::new(ty::GenericPredicates {\n+    tcx.arena.alloc(ty::GenericPredicates {\n         parent: None,\n         predicates: superbounds,\n     })\n@@ -1842,7 +1835,7 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n fn predicates_defined_on<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n-) -> Lrc<ty::GenericPredicates<'tcx>> {\n+) -> &'tcx ty::GenericPredicates<'tcx> {\n     debug!(\"predicates_defined_on({:?})\", def_id);\n     let mut result = tcx.explicit_predicates_of(def_id);\n     debug!(\n@@ -1858,9 +1851,9 @@ fn predicates_defined_on<'a, 'tcx>(\n             def_id,\n             inferred_outlives,\n         );\n-        Lrc::make_mut(&mut result)\n-            .predicates\n-            .extend(inferred_outlives.iter().map(|&p| (p, span)));\n+        let mut predicates = (*result).clone();\n+        predicates.predicates.extend(inferred_outlives.iter().map(|&p| (p, span)));\n+        result = tcx.arena.alloc(predicates);\n     }\n     debug!(\"predicates_defined_on({:?}) = {:?}\", def_id, result);\n     result\n@@ -1872,7 +1865,7 @@ fn predicates_defined_on<'a, 'tcx>(\n fn predicates_of<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n-) -> Lrc<ty::GenericPredicates<'tcx>> {\n+) -> &'tcx ty::GenericPredicates<'tcx> {\n     let mut result = tcx.predicates_defined_on(def_id);\n \n     if tcx.is_trait(def_id) {\n@@ -1889,9 +1882,9 @@ fn predicates_of<'a, 'tcx>(\n         // used, and adding the predicate into this list ensures\n         // that this is done.\n         let span = tcx.def_span(def_id);\n-        Lrc::make_mut(&mut result)\n-            .predicates\n-            .push((ty::TraitRef::identity(tcx, def_id).to_predicate(), span));\n+        let mut predicates = (*result).clone();\n+        predicates.predicates.push((ty::TraitRef::identity(tcx, def_id).to_predicate(), span));\n+        result = tcx.arena.alloc(predicates);\n     }\n     debug!(\"predicates_of(def_id={:?}) = {:?}\", def_id, result);\n     result\n@@ -1902,7 +1895,7 @@ fn predicates_of<'a, 'tcx>(\n fn explicit_predicates_of<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n-) -> Lrc<ty::GenericPredicates<'tcx>> {\n+) -> &'tcx ty::GenericPredicates<'tcx> {\n     use rustc::hir::*;\n     use rustc_data_structures::fx::FxHashSet;\n \n@@ -2017,7 +2010,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n \n                     if impl_trait_fn.is_some() {\n                         // impl Trait\n-                        return Lrc::new(ty::GenericPredicates {\n+                        return tcx.arena.alloc(ty::GenericPredicates {\n                             parent: None,\n                             predicates: bounds.predicates(tcx, opaque_ty),\n                         });\n@@ -2228,7 +2221,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n         );\n     }\n \n-    let result = Lrc::new(ty::GenericPredicates {\n+    let result = tcx.arena.alloc(ty::GenericPredicates {\n         parent: generics.parent,\n         predicates,\n     });"}, {"sha": "57787a75e4aefd683a7a6320aac19899215b4756", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -4,7 +4,6 @@ use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::UnpackedKind;\n use rustc::ty::{self, CratePredicatesMap, TyCtxt};\n-use rustc_data_structures::sync::Lrc;\n use syntax::symbol::sym;\n \n mod explicit;\n@@ -74,7 +73,7 @@ fn inferred_outlives_of<'a, 'tcx>(\n fn inferred_outlives_crate<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     crate_num: CrateNum,\n-) -> Lrc<CratePredicatesMap<'tcx>> {\n+) -> &'tcx CratePredicatesMap<'tcx> {\n     assert_eq!(crate_num, LOCAL_CRATE);\n \n     // Compute a map from each struct/enum/union S to the **explicit**\n@@ -120,7 +119,7 @@ fn inferred_outlives_crate<'tcx>(\n             (def_id, &*predicates)\n         }).collect();\n \n-    Lrc::new(ty::CratePredicatesMap {\n+    tcx.arena.alloc(ty::CratePredicatesMap {\n         predicates,\n     })\n }"}, {"sha": "47c4a9b39c865e024dc91be4c9984783f85ec1db", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -9,7 +9,6 @@ use hir::Node;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::ty::{self, CrateVariancesMap, TyCtxt};\n use rustc::ty::query::Providers;\n-use rustc_data_structures::sync::Lrc;\n \n /// Defines the `TermsContext` basically houses an arena where we can\n /// allocate terms.\n@@ -36,12 +35,12 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n fn crate_variances<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n-                             -> Lrc<CrateVariancesMap<'tcx>> {\n+                             -> &'tcx CrateVariancesMap<'tcx> {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     let mut arena = arena::TypedArena::default();\n     let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &mut arena);\n     let constraints_cx = constraints::add_constraints_from_crate(terms_cx);\n-    Lrc::new(solve::solve_constraints(constraints_cx))\n+    tcx.arena.alloc(solve::solve_constraints(constraints_cx))\n }\n \n fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)"}, {"sha": "8e2460a14b87a7e6d62c9e82540f5294d1094c16", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -104,8 +104,10 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     // Instead, we generate `impl !Send for Foo<T>`, which better\n                     // expresses the fact that `Foo<T>` never implements `Send`,\n                     // regardless of the choice of `T`.\n-                    let params = (self.cx.tcx.generics_of(param_env_def_id), &Default::default())\n-                        .clean(self.cx).params;\n+                    let params = (\n+                        self.cx.tcx.generics_of(param_env_def_id),\n+                        &&self.cx.tcx.common.empty_predicates,\n+                    ).clean(self.cx).params;\n \n                     Generics {\n                         params,"}, {"sha": "9c3f522d8470fcbd69fe30dc66d8d840a80b5104", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -10,7 +10,6 @@ mod auto_trait;\n mod blanket_impl;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n-use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::abi::Abi;\n use rustc_typeck::hir_ty_to_ty;\n use rustc::infer::region_constraints::{RegionConstraintData, Constraint};\n@@ -1687,7 +1686,7 @@ impl Clean<Generics> for hir::Generics {\n }\n \n impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n-                                    &'a Lrc<ty::GenericPredicates<'tcx>>) {\n+                                    &'a &'tcx ty::GenericPredicates<'tcx>) {\n     fn clean(&self, cx: &DocContext<'_>) -> Generics {\n         use self::WherePredicate as WP;\n \n@@ -4434,7 +4433,7 @@ pub fn path_to_def(tcx: TyCtxt<'_, '_, '_>, path: &[Symbol]) -> Option<DefId> {\n         loop {\n             let segment = path_it.next()?;\n \n-            for item in mem::replace(&mut items, Lrc::new(vec![])).iter() {\n+            for item in mem::replace(&mut items, &[]).iter() {\n                 if item.ident.name == *segment {\n                     if path_it.peek().is_none() {\n                         return match item.res {"}, {"sha": "27287d06d54b171b4573b235d1345fb42e6a56c7", "filename": "src/test/incremental/cyclic-trait-hierarchy.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Fincremental%2Fcyclic-trait-hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Fincremental%2Fcyclic-trait-hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcyclic-trait-hierarchy.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -7,7 +7,6 @@ pub trait T2 { }\n #[cfg(cfail2)]\n pub trait T2: T1 { }\n //[cfail2]~^ ERROR cycle detected when computing the supertraits of `T2`\n-//[cfail2]~| ERROR cycle detected when computing the supertraits of `T2`\n \n pub trait T1: T2 { }\n "}, {"sha": "1bab3f01aba04707ecd058eefcd21ba57037afbe", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -47,8 +47,8 @@ impl CodegenBackend for TheBackend {\n     fn provide(&self, providers: &mut Providers) {\n         rustc_codegen_utils::symbol_names::provide(providers);\n \n-        providers.target_features_whitelist = |_tcx, _cnum| {\n-            Default::default() // Just a dummy\n+        providers.target_features_whitelist = |tcx, _cnum| {\n+            tcx.arena.alloc(Default::default()) // Just a dummy\n         };\n         providers.is_reachable_non_generic = |_tcx, _defid| true;\n         providers.exported_symbols = |_tcx, _crate| Arc::new(Vec::new());"}, {"sha": "d3609acfdff63edd44e05599669eeb292e2083d2", "filename": "src/test/ui/cycle-projection-based-on-where-clause.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -16,7 +16,6 @@ struct A<T>\n     where T : Trait,\n           T : Add<T::Item>\n     //~^ ERROR cycle detected\n-    //~| ERROR associated type `Item` not found for `T`\n {\n     data: T\n }"}, {"sha": "59815138e2e36f32853b6a2cdfdb3960ee77ba61", "filename": "src/test/ui/cycle-projection-based-on-where-clause.stderr", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.stderr?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -11,13 +11,6 @@ note: cycle used when processing `A`\n LL |           T : Add<T::Item>\n    |                   ^^^^^^^\n \n-error[E0220]: associated type `Item` not found for `T`\n-  --> $DIR/cycle-projection-based-on-where-clause.rs:17:19\n-   |\n-LL |           T : Add<T::Item>\n-   |                   ^^^^^^^ associated type `Item` not found\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0220, E0391.\n-For more information about an error, try `rustc --explain E0220`.\n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "1500bc831528a599dcbd72bc45dbe8bc9d6c3616", "filename": "src/test/ui/issues/issue-20772.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Fui%2Fissues%2Fissue-20772.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Fui%2Fissues%2Fissue-20772.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20772.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -1,6 +1,5 @@\n trait T : Iterator<Item=Self::Item>\n //~^ ERROR cycle detected\n-//~| ERROR associated type `Item` not found for `Self`\n {}\n \n fn main() {}"}, {"sha": "d64636310a3687344adff5d67cd2482889abe8ae", "filename": "src/test/ui/issues/issue-20772.stderr", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Fui%2Fissues%2Fissue-20772.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Fui%2Fissues%2Fissue-20772.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20772.stderr?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -3,7 +3,6 @@ error[E0391]: cycle detected when computing the supertraits of `T`\n    |\n LL | / trait T : Iterator<Item=Self::Item>\n LL | |\n-LL | |\n LL | | {}\n    | |__^\n    |\n@@ -13,17 +12,9 @@ note: cycle used when collecting item types in top-level module\n    |\n LL | / trait T : Iterator<Item=Self::Item>\n LL | |\n-LL | |\n LL | | {}\n    | |__^\n \n-error[E0220]: associated type `Item` not found for `Self`\n-  --> $DIR/issue-20772.rs:1:25\n-   |\n-LL | trait T : Iterator<Item=Self::Item>\n-   |                         ^^^^^^^^^^ associated type `Item` not found\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0220, E0391.\n-For more information about an error, try `rustc --explain E0220`.\n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "258e362d1317c5ee38b7f0bb66d1320182fac0d7", "filename": "src/test/ui/issues/issue-21177.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Fui%2Fissues%2Fissue-21177.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Fui%2Fissues%2Fissue-21177.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21177.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -5,6 +5,5 @@ trait Trait {\n \n fn foo<T: Trait<A = T::B>>() { }\n //~^ ERROR cycle detected\n-//~| ERROR associated type `B` not found for `T`\n \n fn main() { }"}, {"sha": "00d9a3c46a723a5b98a5975da6bda4a3e7f08fbf", "filename": "src/test/ui/issues/issue-21177.stderr", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Fui%2Fissues%2Fissue-21177.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Fui%2Fissues%2Fissue-21177.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21177.stderr?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -11,13 +11,6 @@ note: cycle used when processing `foo`\n LL | fn foo<T: Trait<A = T::B>>() { }\n    |                     ^^^^\n \n-error[E0220]: associated type `B` not found for `T`\n-  --> $DIR/issue-21177.rs:6:21\n-   |\n-LL | fn foo<T: Trait<A = T::B>>() { }\n-   |                     ^^^^ associated type `B` not found\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0220, E0391.\n-For more information about an error, try `rustc --explain E0220`.\n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "da75f330798865ff2190f84c6009ff253716ee8e", "filename": "src/test/ui/issues/issue-23302-3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.rs?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -1,5 +1,4 @@\n const A: i32 = B; //~ ERROR cycle detected\n-//~^ ERROR cycle detected\n \n const B: i32 = A;\n "}, {"sha": "a7d643987f710293fc124fff8c16d8949a41709a", "filename": "src/test/ui/issues/issue-23302-3.stderr", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e9c86e056d9aacc6e4d333c4f881f5c3826bba/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr?ref=e0e9c86e056d9aacc6e4d333c4f881f5c3826bba", "patch": "@@ -10,36 +10,18 @@ note: ...which requires checking which parts of `A` are promotable to static...\n LL | const A: i32 = B;\n    |                ^\n note: ...which requires const checking if rvalue is promotable to static `B`...\n-  --> $DIR/issue-23302-3.rs:4:1\n+  --> $DIR/issue-23302-3.rs:3:1\n    |\n LL | const B: i32 = A;\n    | ^^^^^^^^^^^^^^^^^\n note: ...which requires checking which parts of `B` are promotable to static...\n-  --> $DIR/issue-23302-3.rs:4:16\n+  --> $DIR/issue-23302-3.rs:3:16\n    |\n LL | const B: i32 = A;\n    |                ^\n    = note: ...which again requires const checking if rvalue is promotable to static `A`, completing the cycle\n    = note: cycle used when running analysis passes on this crate\n \n-error[E0391]: cycle detected when processing `A`\n-  --> $DIR/issue-23302-3.rs:1:16\n-   |\n-LL | const A: i32 = B;\n-   |                ^\n-   |\n-note: ...which requires processing `B`...\n-  --> $DIR/issue-23302-3.rs:4:16\n-   |\n-LL | const B: i32 = A;\n-   |                ^\n-   = note: ...which again requires processing `A`, completing the cycle\n-note: cycle used when processing `A`\n-  --> $DIR/issue-23302-3.rs:1:1\n-   |\n-LL | const A: i32 = B;\n-   | ^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0391`."}]}