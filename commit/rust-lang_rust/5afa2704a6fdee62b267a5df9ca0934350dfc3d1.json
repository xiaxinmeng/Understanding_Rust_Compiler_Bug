{"sha": "5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhZmEyNzA0YTZmZGVlNjJiMjY3YTVkZjljYTA5MzQzNTBkZmMzZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-12T01:26:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-12T01:26:53Z"}, "message": "Auto merge of #23011 - nagisa:the-war-of-symbol-and-symbol, r=pnkfelix\n\nWe provide tools to tell what exact symbols to emit for any fn or static, but\r\ndon\u2019t quite check if that won\u2019t cause any issues later on. Some of the issues\r\ninclude LLVM mangling our names again and our names pointing to wrong locations,\r\nus generating dumb foreign call wrappers, linker errors, extern functions\r\nresolving to different symbols altogether (`extern {fn fail();} fail();` in some\r\ncases calling `fail1()`), etc.\r\n\r\nBefore the commit we had a function called `note_unique_llvm_symbol`, so it is\r\nclear somebody was aware of the issue at some point, but the function was barely\r\nused, mostly in irrelevant locations.\r\n\r\nAlong with working on it I took liberty to start refactoring trans/base into\r\na few smaller modules. The refactoring is incomplete and I hope I will find some\r\nmotivation to carry on with it.\r\n\r\nThis is possibly a [breaking-change] because it makes dumbly written code\r\nproperly invalid.\r\n\r\nThis fixes all those issues about incorrect use of #[no_mangle] being not reported/misreported/ICEd by the compiler.\r\n\r\nNB. This PR does not attempt to tackle the parallel codegen issue that was mentioned in https://github.com/rust-lang/rust/pull/22811, but I believe it should be very straightforward in a follow up PR by modifying `trans::declare::get_defined_value` to look at all the contexts.\r\n\r\ncc @alexcrichton @huonw @nrc because you commented on the original RFC issue.\r\n\r\nEDIT: wow, this became much bigger than I initially intended.", "tree": {"sha": "834dd80c3e70e530ba79a54b4e047610d9b33c19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/834dd80c3e70e530ba79a54b4e047610d9b33c19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "html_url": "https://github.com/rust-lang/rust/commit/5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6790b0e51967b1487728d155e0800a1ed03a30d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6790b0e51967b1487728d155e0800a1ed03a30d3", "html_url": "https://github.com/rust-lang/rust/commit/6790b0e51967b1487728d155e0800a1ed03a30d3"}, {"sha": "000db3841e49048c73ba61a0a2480b7878b6807f", "url": "https://api.github.com/repos/rust-lang/rust/commits/000db3841e49048c73ba61a0a2480b7878b6807f", "html_url": "https://github.com/rust-lang/rust/commit/000db3841e49048c73ba61a0a2480b7878b6807f"}], "stats": {"total": 1700, "additions": 1034, "deletions": 666}, "files": [{"sha": "7030ee5697954e11944e0108b207e573a8ecb7fc", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -157,7 +157,7 @@ bitflags! {\n #[derive(Copy, Clone)]\n pub enum OtherAttribute {\n     // The following are not really exposed in\n-    // the LLVM c api so instead to add these\n+    // the LLVM C api so instead to add these\n     // we call a wrapper function in RustWrapper\n     // that uses the C++ api.\n     SanitizeAddressAttribute = 1 << 32,\n@@ -912,6 +912,7 @@ extern {\n                                        AddressSpace: c_uint)\n                                        -> ValueRef;\n     pub fn LLVMGetNamedGlobal(M: ModuleRef, Name: *const c_char) -> ValueRef;\n+    pub fn LLVMGetOrInsertGlobal(M: ModuleRef, Name: *const c_char, T: TypeRef) -> ValueRef;\n     pub fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n     pub fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n     pub fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n@@ -924,6 +925,7 @@ extern {\n     pub fn LLVMSetThreadLocal(GlobalVar: ValueRef, IsThreadLocal: Bool);\n     pub fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n     pub fn LLVMSetGlobalConstant(GlobalVar: ValueRef, IsConstant: Bool);\n+    pub fn LLVMGetNamedValue(M: ModuleRef, Name: *const c_char) -> ValueRef;\n \n     /* Operations on aliases */\n     pub fn LLVMAddAlias(M: ModuleRef,\n@@ -957,6 +959,7 @@ extern {\n     pub fn LLVMAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n     pub fn LLVMRemoveFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n     pub fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_ulonglong;\n+    pub fn LLVMRemoveFunctionAttr(Fn: ValueRef, val: c_ulonglong);\n \n     /* Operations on parameters */\n     pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;"}, {"sha": "2615490a9fbc5a584b4b0b7f0fe525df9a0323fb", "filename": "src/librustc_trans/trans/attributes.rs", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -0,0 +1,281 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//! Set and unset common attributes on LLVM values.\n+\n+use libc::{c_uint, c_ulonglong};\n+use llvm::{self, ValueRef, AttrHelper};\n+use middle::ty::{self, ClosureTyper};\n+use syntax::abi;\n+use syntax::ast;\n+pub use syntax::attr::InlineAttr;\n+use trans::base;\n+use trans::common;\n+use trans::context::CrateContext;\n+use trans::machine;\n+use trans::type_of;\n+\n+/// Mark LLVM function to use split stack.\n+#[inline]\n+pub fn split_stack(val: ValueRef, set: bool) {\n+    unsafe {\n+        let attr = \"split-stack\\0\".as_ptr() as *const _;\n+        if set {\n+            llvm::LLVMAddFunctionAttrString(val, llvm::FunctionIndex as c_uint, attr);\n+        } else {\n+            llvm::LLVMRemoveFunctionAttrString(val, llvm::FunctionIndex as c_uint, attr);\n+        }\n+    }\n+}\n+\n+/// Mark LLVM function to use provided inline heuristic.\n+#[inline]\n+pub fn inline(val: ValueRef, inline: InlineAttr) {\n+    use self::InlineAttr::*;\n+    match inline {\n+        Hint   => llvm::SetFunctionAttribute(val, llvm::InlineHintAttribute),\n+        Always => llvm::SetFunctionAttribute(val, llvm::AlwaysInlineAttribute),\n+        Never  => llvm::SetFunctionAttribute(val, llvm::NoInlineAttribute),\n+        None   => {\n+            let attr = llvm::InlineHintAttribute |\n+                       llvm::AlwaysInlineAttribute |\n+                       llvm::NoInlineAttribute;\n+            unsafe {\n+                llvm::LLVMRemoveFunctionAttr(val, attr.bits() as c_ulonglong)\n+            }\n+        },\n+    };\n+}\n+\n+/// Tell LLVM to emit or not emit the information necessary to unwind the stack for the function.\n+#[inline]\n+pub fn emit_uwtable(val: ValueRef, emit: bool) {\n+    if emit {\n+        llvm::SetFunctionAttribute(val, llvm::UWTableAttribute);\n+    } else {\n+        unsafe {\n+            llvm::LLVMRemoveFunctionAttr(val, llvm::UWTableAttribute.bits() as c_ulonglong);\n+        }\n+    }\n+}\n+\n+/// Tell LLVM whether the function can or cannot unwind.\n+#[inline]\n+#[allow(dead_code)] // possibly useful function\n+pub fn unwind(val: ValueRef, can_unwind: bool) {\n+    if can_unwind {\n+        unsafe {\n+            llvm::LLVMRemoveFunctionAttr(val, llvm::NoUnwindAttribute.bits() as c_ulonglong);\n+        }\n+    } else {\n+        llvm::SetFunctionAttribute(val, llvm::NoUnwindAttribute);\n+    }\n+}\n+\n+/// Tell LLVM whether it should optimise function for size.\n+#[inline]\n+#[allow(dead_code)] // possibly useful function\n+pub fn set_optimize_for_size(val: ValueRef, optimize: bool) {\n+    if optimize {\n+        llvm::SetFunctionAttribute(val, llvm::OptimizeForSizeAttribute);\n+    } else {\n+        unsafe {\n+            llvm::LLVMRemoveFunctionAttr(val, llvm::OptimizeForSizeAttribute.bits() as c_ulonglong);\n+        }\n+    }\n+}\n+\n+/// Composite function which sets LLVM attributes for function depending on its AST (#[attribute])\n+/// attributes.\n+pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRef) {\n+    use syntax::attr::*;\n+    inline(llfn, find_inline_attr(Some(ccx.sess().diagnostic()), attrs));\n+\n+    for attr in attrs {\n+        if attr.check_name(\"no_stack_check\") {\n+            split_stack(llfn, false);\n+        } else if attr.check_name(\"cold\") {\n+            unsafe {\n+                llvm::LLVMAddFunctionAttribute(llfn,\n+                                               llvm::FunctionIndex as c_uint,\n+                                               llvm::ColdAttribute as u64)\n+            }\n+        } else if attr.check_name(\"allocator\") {\n+            llvm::NoAliasAttribute.apply_llfn(llvm::ReturnIndex as c_uint, llfn);\n+        }\n+    }\n+}\n+\n+/// Composite function which converts function type into LLVM attributes for the function.\n+pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx>)\n+                              -> llvm::AttrBuilder {\n+    use middle::ty::{BrAnon, ReLateBound};\n+\n+    let function_type;\n+    let (fn_sig, abi, env_ty) = match fn_type.sty {\n+        ty::ty_bare_fn(_, ref f) => (&f.sig, f.abi, None),\n+        ty::ty_closure(closure_did, substs) => {\n+            let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n+            function_type = typer.closure_type(closure_did, substs);\n+            let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n+            (&function_type.sig, abi::RustCall, Some(self_type))\n+        }\n+        _ => ccx.sess().bug(\"expected closure or function.\")\n+    };\n+\n+    let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n+\n+    let mut attrs = llvm::AttrBuilder::new();\n+    let ret_ty = fn_sig.output;\n+\n+    // These have an odd calling convention, so we need to manually\n+    // unpack the input ty's\n+    let input_tys = match fn_type.sty {\n+        ty::ty_closure(..) => {\n+            assert!(abi == abi::RustCall);\n+\n+            match fn_sig.inputs[0].sty {\n+                ty::ty_tup(ref inputs) => {\n+                    let mut full_inputs = vec![env_ty.expect(\"Missing closure environment\")];\n+                    full_inputs.push_all(inputs);\n+                    full_inputs\n+                }\n+                _ => ccx.sess().bug(\"expected tuple'd inputs\")\n+            }\n+        },\n+        ty::ty_bare_fn(..) if abi == abi::RustCall => {\n+            let mut inputs = vec![fn_sig.inputs[0]];\n+\n+            match fn_sig.inputs[1].sty {\n+                ty::ty_tup(ref t_in) => {\n+                    inputs.push_all(&t_in[..]);\n+                    inputs\n+                }\n+                _ => ccx.sess().bug(\"expected tuple'd inputs\")\n+            }\n+        }\n+        _ => fn_sig.inputs.clone()\n+    };\n+\n+    // Index 0 is the return value of the llvm func, so we start at 1\n+    let mut first_arg_offset = 1;\n+    if let ty::FnConverging(ret_ty) = ret_ty {\n+        // A function pointer is called without the declaration\n+        // available, so we have to apply any attributes with ABI\n+        // implications directly to the call instruction. Right now,\n+        // the only attribute we need to worry about is `sret`.\n+        if type_of::return_uses_outptr(ccx, ret_ty) {\n+            let llret_sz = machine::llsize_of_real(ccx, type_of::type_of(ccx, ret_ty));\n+\n+            // The outptr can be noalias and nocapture because it's entirely\n+            // invisible to the program. We also know it's nonnull as well\n+            // as how many bytes we can dereference\n+            attrs.arg(1, llvm::StructRetAttribute)\n+                 .arg(1, llvm::NoAliasAttribute)\n+                 .arg(1, llvm::NoCaptureAttribute)\n+                 .arg(1, llvm::DereferenceableAttribute(llret_sz));\n+\n+            // Add one more since there's an outptr\n+            first_arg_offset += 1;\n+        } else {\n+            // The `noalias` attribute on the return value is useful to a\n+            // function ptr caller.\n+            match ret_ty.sty {\n+                // `~` pointer return values never alias because ownership\n+                // is transferred\n+                ty::ty_uniq(it) if common::type_is_sized(ccx.tcx(), it) => {\n+                    attrs.ret(llvm::NoAliasAttribute);\n+                }\n+                _ => {}\n+            }\n+\n+            // We can also mark the return value as `dereferenceable` in certain cases\n+            match ret_ty.sty {\n+                // These are not really pointers but pairs, (pointer, len)\n+                ty::ty_rptr(_, ty::mt { ty: inner, .. })\n+                | ty::ty_uniq(inner) if common::type_is_sized(ccx.tcx(), inner) => {\n+                    let llret_sz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n+                    attrs.ret(llvm::DereferenceableAttribute(llret_sz));\n+                }\n+                _ => {}\n+            }\n+\n+            if let ty::ty_bool = ret_ty.sty {\n+                attrs.ret(llvm::ZExtAttribute);\n+            }\n+        }\n+    }\n+\n+    for (idx, &t) in input_tys.iter().enumerate().map(|(i, v)| (i + first_arg_offset, v)) {\n+        match t.sty {\n+            // this needs to be first to prevent fat pointers from falling through\n+            _ if !common::type_is_immediate(ccx, t) => {\n+                let llarg_sz = machine::llsize_of_real(ccx, type_of::type_of(ccx, t));\n+\n+                // For non-immediate arguments the callee gets its own copy of\n+                // the value on the stack, so there are no aliases. It's also\n+                // program-invisible so can't possibly capture\n+                attrs.arg(idx, llvm::NoAliasAttribute)\n+                     .arg(idx, llvm::NoCaptureAttribute)\n+                     .arg(idx, llvm::DereferenceableAttribute(llarg_sz));\n+            }\n+\n+            ty::ty_bool => {\n+                attrs.arg(idx, llvm::ZExtAttribute);\n+            }\n+\n+            // `~` pointer parameters never alias because ownership is transferred\n+            ty::ty_uniq(inner) => {\n+                let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n+\n+                attrs.arg(idx, llvm::NoAliasAttribute)\n+                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n+            }\n+\n+            // `&mut` pointer parameters never alias other parameters, or mutable global data\n+            //\n+            // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as both\n+            // `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely on\n+            // memory dependencies rather than pointer equality\n+            ty::ty_rptr(b, mt) if mt.mutbl == ast::MutMutable ||\n+                                  !ty::type_contents(ccx.tcx(), mt.ty).interior_unsafe() => {\n+\n+                let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n+                attrs.arg(idx, llvm::NoAliasAttribute)\n+                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n+\n+                if mt.mutbl == ast::MutImmutable {\n+                    attrs.arg(idx, llvm::ReadOnlyAttribute);\n+                }\n+\n+                if let ReLateBound(_, BrAnon(_)) = *b {\n+                    attrs.arg(idx, llvm::NoCaptureAttribute);\n+                }\n+            }\n+\n+            // When a reference in an argument has no named lifetime, it's impossible for that\n+            // reference to escape this function (returned or stored beyond the call by a closure).\n+            ty::ty_rptr(&ReLateBound(_, BrAnon(_)), mt) => {\n+                let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n+                attrs.arg(idx, llvm::NoCaptureAttribute)\n+                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n+            }\n+\n+            // & pointer parameters are also never null and we know exactly how\n+            // many bytes we can dereference\n+            ty::ty_rptr(_, mt) => {\n+                let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n+                attrs.arg(idx, llvm::DereferenceableAttribute(llsz));\n+            }\n+            _ => ()\n+        }\n+    }\n+\n+    attrs\n+}"}, {"sha": "7c51a193b984b0a61192593e78e2086f1a8e7684", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 115, "deletions": 536, "changes": 651, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -7,21 +7,20 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-\n-// trans.rs: Translate the completed AST to the LLVM IR.\n-//\n-// Some functions here, such as trans_block and trans_expr, return a value --\n-// the result of the translation to LLVM -- while others, such as trans_fn,\n-// trans_impl, and trans_item, are called only for the side effect of adding a\n-// particular definition to the LLVM IR output we're producing.\n-//\n-// Hopefully useful general knowledge about trans:\n-//\n-//   * There's no way to find out the Ty type of a ValueRef.  Doing so\n-//     would be \"trying to get the eggs out of an omelette\" (credit:\n-//     pcwalton).  You can, instead, find out its TypeRef by calling val_ty,\n-//     but one TypeRef corresponds to many `Ty`s; for instance, tup(int, int,\n-//     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n+//! Translate the completed AST to the LLVM IR.\n+//!\n+//! Some functions here, such as trans_block and trans_expr, return a value --\n+//! the result of the translation to LLVM -- while others, such as trans_fn,\n+//! trans_impl, and trans_item, are called only for the side effect of adding a\n+//! particular definition to the LLVM IR output we're producing.\n+//!\n+//! Hopefully useful general knowledge about trans:\n+//!\n+//!   * There's no way to find out the Ty type of a ValueRef.  Doing so\n+//!     would be \"trying to get the eggs out of an omelette\" (credit:\n+//!     pcwalton).  You can, instead, find out its TypeRef by calling val_ty,\n+//!     but one TypeRef corresponds to many `Ty`s; for instance, tup(int, int,\n+//!     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n \n #![allow(non_camel_case_types)]\n \n@@ -33,19 +32,20 @@ use super::ModuleTranslation;\n use back::link::mangle_exported_name;\n use back::{link, abi};\n use lint;\n-use llvm::{AttrHelper, BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n+use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n use llvm;\n use metadata::{csearch, encoder, loader};\n use middle::astencode;\n use middle::cfg;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::weak_lang_items;\n-use middle::subst::{Subst, Substs};\n+use middle::subst::Substs;\n use middle::ty::{self, Ty, ClosureTyper, type_is_simd, simd_size};\n use session::config::{self, NoDebugInfo};\n use session::Session;\n use trans::_match;\n use trans::adt;\n+use trans::attributes;\n use trans::build::*;\n use trans::builder::{Builder, noname};\n use trans::callee;\n@@ -54,7 +54,7 @@ use trans::cleanup;\n use trans::closure;\n use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_integral};\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n-use trans::common::{CrateContext, ExternMap, FunctionContext};\n+use trans::common::{CrateContext, FunctionContext};\n use trans::common::{Result, NodeIdAndSpan};\n use trans::common::{node_id_type, return_type_is_void};\n use trans::common::{type_is_immediate, type_is_zero_size, val_ty};\n@@ -64,10 +64,10 @@ use trans::context::SharedCrateContext;\n use trans::controlflow;\n use trans::datum;\n use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n+use trans::declare;\n use trans::expr;\n use trans::foreign;\n use trans::glue;\n-use trans::inline;\n use trans::intrinsic;\n use trans::machine;\n use trans::machine::{llsize_of, llsize_of_real};\n@@ -84,7 +84,7 @@ use util::sha2::Sha256;\n use util::nodemap::NodeMap;\n \n use arena::TypedArena;\n-use libc::{c_uint, uint64_t};\n+use libc::c_uint;\n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n use std::collections::HashSet;\n@@ -180,72 +180,17 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     }\n }\n \n-// only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n-pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n-               ty: Type, output: ty::FnOutput) -> ValueRef {\n-\n-    let buf = CString::new(name).unwrap();\n-    let llfn: ValueRef = unsafe {\n-        llvm::LLVMGetOrInsertFunction(ccx.llmod(), buf.as_ptr(), ty.to_ref())\n-    };\n-\n-    // diverging functions may unwind, but can never return normally\n-    if output == ty::FnDiverging {\n-        llvm::SetFunctionAttribute(llfn, llvm::NoReturnAttribute);\n-    }\n-\n-    if ccx.tcx().sess.opts.cg.no_redzone\n-        .unwrap_or(ccx.tcx().sess.target.target.options.disable_redzone) {\n-        llvm::SetFunctionAttribute(llfn, llvm::NoRedZoneAttribute)\n-    }\n-\n-    llvm::SetFunctionCallConv(llfn, cc);\n-    // Function addresses in Rust are never significant, allowing functions to be merged.\n-    llvm::SetUnnamedAddr(llfn, true);\n-\n-    if ccx.is_split_stack_supported() && !ccx.sess().opts.cg.no_stack_check {\n-        set_split_stack(llfn);\n-    }\n-\n-    llfn\n-}\n-\n-// only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n-pub fn decl_cdecl_fn(ccx: &CrateContext,\n-                     name: &str,\n-                     ty: Type,\n-                     output: Ty) -> ValueRef {\n-    decl_fn(ccx, name, llvm::CCallConv, ty, ty::FnConverging(output))\n-}\n-\n-// only use this for foreign function ABIs and glue, use `get_extern_rust_fn` for Rust functions\n-pub fn get_extern_fn(ccx: &CrateContext,\n-                     externs: &mut ExternMap,\n-                     name: &str,\n-                     cc: llvm::CallConv,\n-                     ty: Type,\n-                     output: Ty)\n-                     -> ValueRef {\n-    match externs.get(name) {\n-        Some(n) => return *n,\n-        None => {}\n-    }\n-    let f = decl_fn(ccx, name, cc, ty, ty::FnConverging(output));\n-    externs.insert(name.to_string(), f);\n-    f\n-}\n-\n fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n                                 name: &str, did: ast::DefId) -> ValueRef {\n     match ccx.externs().borrow().get(name) {\n         Some(n) => return *n,\n         None => ()\n     }\n \n-    let f = decl_rust_fn(ccx, fn_ty, name);\n+    let f = declare::declare_rust_fn(ccx, name, fn_ty);\n \n     let attrs = csearch::get_item_attrs(&ccx.sess().cstore, did);\n-    set_llvm_fn_attrs(ccx, &attrs[..], f);\n+    attributes::from_fn_attrs(ccx, &attrs[..], f);\n \n     ccx.externs().borrow_mut().insert(name.to_string(), f);\n     f\n@@ -272,63 +217,6 @@ pub fn kind_for_closure(ccx: &CrateContext, closure_id: ast::DefId) -> ty::Closu\n     *ccx.tcx().closure_kinds.borrow().get(&closure_id).unwrap()\n }\n \n-pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                              fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n-    debug!(\"decl_rust_fn(fn_ty={}, name={:?})\",\n-           fn_ty.repr(ccx.tcx()),\n-           name);\n-\n-    let fn_ty = monomorphize::normalize_associated_type(ccx.tcx(), &fn_ty);\n-\n-    debug!(\"decl_rust_fn: fn_ty={} (after normalized associated types)\",\n-           fn_ty.repr(ccx.tcx()));\n-\n-    let function_type; // placeholder so that the memory ownership works out ok\n-\n-    let (sig, abi, env) = match fn_ty.sty {\n-        ty::ty_bare_fn(_, ref f) => {\n-            (&f.sig, f.abi, None)\n-        }\n-        ty::ty_closure(closure_did, substs) => {\n-            let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n-            function_type = typer.closure_type(closure_did, substs);\n-            let self_type = self_type_for_closure(ccx, closure_did, fn_ty);\n-            let llenvironment_type = type_of_explicit_arg(ccx, self_type);\n-            debug!(\"decl_rust_fn: function_type={} self_type={}\",\n-                   function_type.repr(ccx.tcx()),\n-                   self_type.repr(ccx.tcx()));\n-            (&function_type.sig, RustCall, Some(llenvironment_type))\n-        }\n-        _ => ccx.sess().bug(\"expected closure or fn\")\n-    };\n-\n-    let sig = ty::erase_late_bound_regions(ccx.tcx(), sig);\n-    let sig = ty::Binder(sig);\n-\n-    debug!(\"decl_rust_fn: sig={} (after erasing regions)\",\n-           sig.repr(ccx.tcx()));\n-\n-    let llfty = type_of_rust_fn(ccx, env, &sig, abi);\n-\n-    debug!(\"decl_rust_fn: llfty={}\",\n-           ccx.tn().type_to_string(llfty));\n-\n-    let llfn = decl_fn(ccx, name, llvm::CCallConv, llfty, sig.0.output /* (1) */);\n-    let attrs = get_fn_llvm_attributes(ccx, fn_ty);\n-    attrs.apply_llfn(llfn);\n-\n-    // (1) it's ok to directly access sig.0.output because we erased all late-bound-regions above\n-\n-    llfn\n-}\n-\n-pub fn decl_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                       fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n-    let llfn = decl_rust_fn(ccx, fn_ty, name);\n-    llvm::SetLinkage(llfn, llvm::InternalLinkage);\n-    llfn\n-}\n-\n pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n                                   t: Ty<'tcx>) -> ValueRef {\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n@@ -337,23 +225,22 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n         Some(n) => return *n,\n         None => ()\n     }\n-    unsafe {\n-        let buf = CString::new(name.clone()).unwrap();\n-        let c = llvm::LLVMAddGlobal(ccx.llmod(), ty.to_ref(), buf.as_ptr());\n-        // Thread-local statics in some other crate need to *always* be linked\n-        // against in a thread-local fashion, so we need to be sure to apply the\n-        // thread-local attribute locally if it was present remotely. If we\n-        // don't do this then linker errors can be generated where the linker\n-        // complains that one object files has a thread local version of the\n-        // symbol and another one doesn't.\n-        for attr in &*ty::get_attrs(ccx.tcx(), did) {\n-            if attr.check_name(\"thread_local\") {\n-                llvm::set_thread_local(c, true);\n-            }\n+    // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n+    // FIXME(nagisa): investigate whether it can be changed into define_global\n+    let c = declare::declare_global(ccx, &name[..], ty);\n+    // Thread-local statics in some other crate need to *always* be linked\n+    // against in a thread-local fashion, so we need to be sure to apply the\n+    // thread-local attribute locally if it was present remotely. If we\n+    // don't do this then linker errors can be generated where the linker\n+    // complains that one object files has a thread local version of the\n+    // symbol and another one doesn't.\n+    for attr in &*ty::get_attrs(ccx.tcx(), did) {\n+        if attr.check_name(\"thread_local\") {\n+            llvm::set_thread_local(c, true);\n         }\n-        ccx.externs().borrow_mut().insert(name.to_string(), c);\n-        return c;\n     }\n+    ccx.externs().borrow_mut().insert(name.to_string(), c);\n+    return c;\n }\n \n fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -390,125 +277,6 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n \n-#[allow(dead_code)] // useful\n-pub fn set_optimize_for_size(f: ValueRef) {\n-    llvm::SetFunctionAttribute(f, llvm::OptimizeForSizeAttribute)\n-}\n-\n-pub fn set_no_inline(f: ValueRef) {\n-    llvm::SetFunctionAttribute(f, llvm::NoInlineAttribute)\n-}\n-\n-#[allow(dead_code)] // useful\n-pub fn set_no_unwind(f: ValueRef) {\n-    llvm::SetFunctionAttribute(f, llvm::NoUnwindAttribute)\n-}\n-\n-// Tell LLVM to emit the information necessary to unwind the stack for the\n-// function f.\n-pub fn set_uwtable(f: ValueRef) {\n-    llvm::SetFunctionAttribute(f, llvm::UWTableAttribute)\n-}\n-\n-pub fn set_inline_hint(f: ValueRef) {\n-    llvm::SetFunctionAttribute(f, llvm::InlineHintAttribute)\n-}\n-\n-pub fn set_llvm_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRef) {\n-    use syntax::attr::{find_inline_attr, InlineAttr};\n-    // Set the inline hint if there is one\n-    match find_inline_attr(Some(ccx.sess().diagnostic()), attrs) {\n-        InlineAttr::Hint   => set_inline_hint(llfn),\n-        InlineAttr::Always => set_always_inline(llfn),\n-        InlineAttr::Never  => set_no_inline(llfn),\n-        InlineAttr::None   => { /* fallthrough */ }\n-    }\n-\n-    for attr in attrs {\n-        let mut used = true;\n-        match &attr.name()[..] {\n-            \"no_stack_check\" => unset_split_stack(llfn),\n-            \"cold\" => unsafe {\n-                llvm::LLVMAddFunctionAttribute(llfn,\n-                                               llvm::FunctionIndex as c_uint,\n-                                               llvm::ColdAttribute as uint64_t)\n-            },\n-            \"allocator\" => {\n-                llvm::NoAliasAttribute.apply_llfn(llvm::ReturnIndex as c_uint, llfn);\n-            }\n-            _ => used = false,\n-        }\n-        if used {\n-            attr::mark_used(attr);\n-        }\n-    }\n-}\n-\n-pub fn set_always_inline(f: ValueRef) {\n-    llvm::SetFunctionAttribute(f, llvm::AlwaysInlineAttribute)\n-}\n-\n-pub fn set_split_stack(f: ValueRef) {\n-    unsafe {\n-        llvm::LLVMAddFunctionAttrString(f, llvm::FunctionIndex as c_uint,\n-                                        \"split-stack\\0\".as_ptr() as *const _);\n-    }\n-}\n-\n-pub fn unset_split_stack(f: ValueRef) {\n-    unsafe {\n-        llvm::LLVMRemoveFunctionAttrString(f, llvm::FunctionIndex as c_uint,\n-                                           \"split-stack\\0\".as_ptr() as *const _);\n-    }\n-}\n-\n-// Double-check that we never ask LLVM to declare the same symbol twice. It\n-// silently mangles such symbols, breaking our linkage model.\n-pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: String) {\n-    if ccx.all_llvm_symbols().borrow().contains(&sym) {\n-        ccx.sess().bug(&format!(\"duplicate LLVM symbol: {}\", sym));\n-    }\n-    ccx.all_llvm_symbols().borrow_mut().insert(sym);\n-}\n-\n-\n-pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                              did: ast::DefId,\n-                              t: Ty<'tcx>,\n-                              parent_id: ast::DefId,\n-                              substs: &Substs<'tcx>)\n-                              -> ValueRef {\n-    let _icx = push_ctxt(\"trans_res_dtor\");\n-    let did = inline::maybe_instantiate_inline(ccx, did);\n-\n-    if !substs.types.is_empty() {\n-        assert_eq!(did.krate, ast::LOCAL_CRATE);\n-\n-        // Since we're in trans we don't care for any region parameters\n-        let substs = ccx.tcx().mk_substs(Substs::erased(substs.types.clone()));\n-\n-        let (val, _, _) = monomorphize::monomorphic_fn(ccx, did, substs, None);\n-\n-        val\n-    } else if did.krate == ast::LOCAL_CRATE {\n-        get_item_val(ccx, did.node)\n-    } else {\n-        let tcx = ccx.tcx();\n-        let name = csearch::get_symbol(&ccx.sess().cstore, did);\n-        let class_ty = ty::lookup_item_type(tcx, parent_id).ty.subst(tcx, substs);\n-        let llty = type_of_dtor(ccx, class_ty);\n-        let dtor_ty = ty::mk_ctor_fn(ccx.tcx(),\n-                                     did,\n-                                     &[glue::get_drop_glue_type(ccx, t)],\n-                                     ty::mk_nil(ccx.tcx()));\n-        get_extern_fn(ccx,\n-                      &mut *ccx.externs().borrow_mut(),\n-                      &name[..],\n-                      llvm::CCallConv,\n-                      llty,\n-                      dtor_ty)\n-    }\n-}\n \n pub fn bin_op_to_icmp_predicate(ccx: &CrateContext, op: ast::BinOp_, signed: bool)\n                                 -> llvm::IntPredicate {\n@@ -898,7 +666,7 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 _ => {\n                     let llfn = foreign::register_foreign_item_fn(ccx, fn_ty.abi, t, &name[..]);\n                     let attrs = csearch::get_item_attrs(&ccx.sess().cstore, did);\n-                    set_llvm_fn_attrs(ccx, &attrs, llfn);\n+                    attributes::from_fn_attrs(ccx, &attrs, llfn);\n                     llfn\n                 }\n             }\n@@ -920,7 +688,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         return (C_null(Type::i8(bcx.ccx())), bcx);\n     }\n \n-    let attributes = get_fn_llvm_attributes(bcx.ccx(), fn_ty);\n+    let attributes = attributes::from_fn_type(bcx.ccx(), fn_ty);\n \n     match bcx.opt_node_id {\n         None => {\n@@ -1692,9 +1460,9 @@ pub fn build_return_block<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n     }\n }\n \n-// trans_closure: Builds an LLVM function out of a source function.\n-// If the function closes over its environment a closure will be\n-// returned.\n+/// Builds an LLVM function out of a source function.\n+///\n+/// If the function closes over its environment a closure will be returned.\n pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                    decl: &ast::FnDecl,\n                                    body: &ast::Block,\n@@ -1708,7 +1476,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n     let _icx = push_ctxt(\"trans_closure\");\n-    set_uwtable(llfndecl);\n+    attributes::emit_uwtable(llfndecl, true);\n \n     debug!(\"trans_closure(..., param_substs={})\",\n            param_substs.repr(ccx.tcx()));\n@@ -1827,8 +1595,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     finish_fn(&fcx, bcx, output_type, ret_debug_loc);\n }\n \n-// trans_fn: creates an LLVM function corresponding to a source language\n-// function.\n+/// Creates an LLVM function corresponding to a source language function.\n pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                           decl: &ast::FnDecl,\n                           body: &ast::Block,\n@@ -1842,15 +1609,7 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let fn_ty = ty::node_id_to_type(ccx.tcx(), id);\n     let output_type = ty::erase_late_bound_regions(ccx.tcx(), &ty::ty_fn_ret(fn_ty));\n     let abi = ty::ty_fn_abi(fn_ty);\n-    trans_closure(ccx,\n-                  decl,\n-                  body,\n-                  llfndecl,\n-                  param_substs,\n-                  id,\n-                  attrs,\n-                  output_type,\n-                  abi,\n+    trans_closure(ccx, decl, body, llfndecl, param_substs, id, attrs, output_type, abi,\n                   closure::ClosureEnv::NotClosure);\n }\n \n@@ -2195,27 +1954,24 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                 let llfn = get_item_val(ccx, item.id);\n                 let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n                 if abi != Rust {\n-                    foreign::trans_rust_fn_with_foreign_abi(ccx,\n-                                                            &**decl,\n-                                                            &**body,\n-                                                            &item.attrs,\n-                                                            llfn,\n-                                                            empty_substs,\n-                                                            item.id,\n-                                                            None);\n+                    foreign::trans_rust_fn_with_foreign_abi(ccx, &**decl, &**body, &item.attrs,\n+                                                            llfn, empty_substs, item.id, None);\n                 } else {\n-                    trans_fn(ccx,\n-                             &**decl,\n-                             &**body,\n-                             llfn,\n-                             empty_substs,\n-                             item.id,\n-                             &item.attrs);\n+                    trans_fn(ccx, &**decl, &**body, llfn, empty_substs, item.id, &item.attrs);\n                 }\n-                update_linkage(ccx,\n-                               llfn,\n-                               Some(item.id),\n+                update_linkage(ccx, llfn, Some(item.id),\n                                if is_origin { OriginalTranslation } else { InlinedCopy });\n+\n+                if is_entry_fn(ccx.sess(), item.id) {\n+                    create_entry_wrapper(ccx, item.span, llfn);\n+                    // check for the #[rustc_error] annotation, which forces an\n+                    // error in trans. This is used to write compile-fail tests\n+                    // that actually test that compilation succeeds without\n+                    // reporting an error.\n+                    if ty::has_attr(ccx.tcx(), local_def(item.id), \"rustc_error\") {\n+                        ccx.tcx().sess.span_fatal(item.span, \"compilation successful\");\n+                    }\n+                }\n             }\n         }\n \n@@ -2251,8 +2007,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n           let mut v = TransItemVisitor{ ccx: ccx };\n           v.visit_expr(&**expr);\n \n-          consts::trans_static(ccx, m, item.id);\n-          let g = get_item_val(ccx, item.id);\n+          let g = consts::trans_static(ccx, m, item.id);\n           update_linkage(ccx, g, Some(item.id), OriginalTranslation);\n \n           // Do static_assert checking. It can't really be done much earlier\n@@ -2304,7 +2059,25 @@ pub fn trans_mod(ccx: &CrateContext, m: &ast::Mod) {\n     }\n }\n \n-fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: String, node_id: ast::NodeId,\n+\n+// only use this for foreign function ABIs and glue, use `register_fn` for Rust functions\n+pub fn register_fn_llvmty(ccx: &CrateContext,\n+                          sp: Span,\n+                          sym: String,\n+                          node_id: ast::NodeId,\n+                      cc: llvm::CallConv,\n+                          llfty: Type) -> ValueRef {\n+    debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n+\n+    let llfn = declare::define_fn(ccx, &sym[..], cc, llfty,\n+                                   ty::FnConverging(ty::mk_nil(ccx.tcx()))).unwrap_or_else(||{\n+        ccx.sess().span_fatal(sp, &format!(\"symbol `{}` is already defined\", sym));\n+    });\n+    finish_register_fn(ccx, sym, node_id, llfn);\n+    llfn\n+}\n+\n+fn finish_register_fn(ccx: &CrateContext, sym: String, node_id: ast::NodeId,\n                       llfn: ValueRef) {\n     ccx.item_symbols().borrow_mut().insert(node_id, sym);\n \n@@ -2313,25 +2086,12 @@ fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: String, node_id: ast::N\n     // eh_personality functions need to be externally linkable.\n     let def = ast_util::local_def(node_id);\n     if ccx.tcx().lang_items.stack_exhausted() == Some(def) {\n-        unset_split_stack(llfn);\n+        attributes::split_stack(llfn, false);\n         llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n     }\n     if ccx.tcx().lang_items.eh_personality() == Some(def) {\n         llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n     }\n-\n-\n-    if is_entry_fn(ccx.sess(), node_id) {\n-        // check for the #[rustc_error] annotation, which forces an\n-        // error in trans. This is used to write compile-fail tests\n-        // that actually test that compilation succeeds without\n-        // reporting an error.\n-        if ty::has_attr(ccx.tcx(), local_def(node_id), \"rustc_error\") {\n-            ccx.tcx().sess.span_fatal(sp, \"compilation successful\");\n-        }\n-\n-        create_entry_wrapper(ccx, sp, llfn);\n-    }\n }\n \n fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -2350,196 +2110,10 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ccx.sess().span_bug(sp, \"expected bare rust function\")\n     }\n \n-    let llfn = decl_rust_fn(ccx, node_type, &sym[..]);\n-    finish_register_fn(ccx, sp, sym, node_id, llfn);\n-    llfn\n-}\n-\n-pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>)\n-                                        -> llvm::AttrBuilder\n-{\n-    use middle::ty::{BrAnon, ReLateBound};\n-\n-    let function_type;\n-    let (fn_sig, abi, env_ty) = match fn_ty.sty {\n-        ty::ty_bare_fn(_, ref f) => (&f.sig, f.abi, None),\n-        ty::ty_closure(closure_did, substs) => {\n-            let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n-            function_type = typer.closure_type(closure_did, substs);\n-            let self_type = self_type_for_closure(ccx, closure_did, fn_ty);\n-            (&function_type.sig, RustCall, Some(self_type))\n-        }\n-        _ => ccx.sess().bug(\"expected closure or function.\")\n-    };\n-\n-    let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n-\n-    let mut attrs = llvm::AttrBuilder::new();\n-    let ret_ty = fn_sig.output;\n-\n-    // These have an odd calling convention, so we need to manually\n-    // unpack the input ty's\n-    let input_tys = match fn_ty.sty {\n-        ty::ty_closure(..) => {\n-            assert!(abi == RustCall);\n-\n-            match fn_sig.inputs[0].sty {\n-                ty::ty_tup(ref inputs) => {\n-                    let mut full_inputs = vec![env_ty.expect(\"Missing closure environment\")];\n-                    full_inputs.push_all(inputs);\n-                    full_inputs\n-                }\n-                _ => ccx.sess().bug(\"expected tuple'd inputs\")\n-            }\n-        },\n-        ty::ty_bare_fn(..) if abi == RustCall => {\n-            let mut inputs = vec![fn_sig.inputs[0]];\n-\n-            match fn_sig.inputs[1].sty {\n-                ty::ty_tup(ref t_in) => {\n-                    inputs.push_all(&t_in[..]);\n-                    inputs\n-                }\n-                _ => ccx.sess().bug(\"expected tuple'd inputs\")\n-            }\n-        }\n-        _ => fn_sig.inputs.clone()\n-    };\n-\n-    // Index 0 is the return value of the llvm func, so we start at 1\n-    let mut first_arg_offset = 1;\n-    if let ty::FnConverging(ret_ty) = ret_ty {\n-        // A function pointer is called without the declaration\n-        // available, so we have to apply any attributes with ABI\n-        // implications directly to the call instruction. Right now,\n-        // the only attribute we need to worry about is `sret`.\n-        if type_of::return_uses_outptr(ccx, ret_ty) {\n-            let llret_sz = llsize_of_real(ccx, type_of::type_of(ccx, ret_ty));\n-\n-            // The outptr can be noalias and nocapture because it's entirely\n-            // invisible to the program. We also know it's nonnull as well\n-            // as how many bytes we can dereference\n-            attrs.arg(1, llvm::StructRetAttribute)\n-                 .arg(1, llvm::NoAliasAttribute)\n-                 .arg(1, llvm::NoCaptureAttribute)\n-                 .arg(1, llvm::DereferenceableAttribute(llret_sz));\n-\n-            // Add one more since there's an outptr\n-            first_arg_offset += 1;\n-        } else {\n-            // The `noalias` attribute on the return value is useful to a\n-            // function ptr caller.\n-            match ret_ty.sty {\n-                // `~` pointer return values never alias because ownership\n-                // is transferred\n-                ty::ty_uniq(it) if !common::type_is_sized(ccx.tcx(), it) => {}\n-                ty::ty_uniq(_) => {\n-                    attrs.ret(llvm::NoAliasAttribute);\n-                }\n-                _ => {}\n-            }\n-\n-            // We can also mark the return value as `dereferenceable` in certain cases\n-            match ret_ty.sty {\n-                // These are not really pointers but pairs, (pointer, len)\n-                ty::ty_uniq(it) |\n-                ty::ty_rptr(_, ty::mt { ty: it, .. }) if !common::type_is_sized(ccx.tcx(), it) => {}\n-                ty::ty_uniq(inner) | ty::ty_rptr(_, ty::mt { ty: inner, .. }) => {\n-                    let llret_sz = llsize_of_real(ccx, type_of::type_of(ccx, inner));\n-                    attrs.ret(llvm::DereferenceableAttribute(llret_sz));\n-                }\n-                _ => {}\n-            }\n-\n-            if let ty::ty_bool = ret_ty.sty {\n-                attrs.ret(llvm::ZExtAttribute);\n-            }\n-        }\n-    }\n-\n-    for (idx, &t) in input_tys.iter().enumerate().map(|(i, v)| (i + first_arg_offset, v)) {\n-        match t.sty {\n-            // this needs to be first to prevent fat pointers from falling through\n-            _ if !type_is_immediate(ccx, t) => {\n-                let llarg_sz = llsize_of_real(ccx, type_of::type_of(ccx, t));\n-\n-                // For non-immediate arguments the callee gets its own copy of\n-                // the value on the stack, so there are no aliases. It's also\n-                // program-invisible so can't possibly capture\n-                attrs.arg(idx, llvm::NoAliasAttribute)\n-                     .arg(idx, llvm::NoCaptureAttribute)\n-                     .arg(idx, llvm::DereferenceableAttribute(llarg_sz));\n-            }\n-\n-            ty::ty_bool => {\n-                attrs.arg(idx, llvm::ZExtAttribute);\n-            }\n-\n-            // `~` pointer parameters never alias because ownership is transferred\n-            ty::ty_uniq(inner) => {\n-                let llsz = llsize_of_real(ccx, type_of::type_of(ccx, inner));\n-\n-                attrs.arg(idx, llvm::NoAliasAttribute)\n-                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n-            }\n-\n-            // `&mut` pointer parameters never alias other parameters, or mutable global data\n-            //\n-            // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as both\n-            // `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely on\n-            // memory dependencies rather than pointer equality\n-            ty::ty_rptr(b, mt) if mt.mutbl == ast::MutMutable ||\n-                                  !ty::type_contents(ccx.tcx(), mt.ty).interior_unsafe() => {\n-\n-                let llsz = llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                attrs.arg(idx, llvm::NoAliasAttribute)\n-                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n-\n-                if mt.mutbl == ast::MutImmutable {\n-                    attrs.arg(idx, llvm::ReadOnlyAttribute);\n-                }\n-\n-                if let ReLateBound(_, BrAnon(_)) = *b {\n-                    attrs.arg(idx, llvm::NoCaptureAttribute);\n-                }\n-            }\n-\n-            // When a reference in an argument has no named lifetime, it's impossible for that\n-            // reference to escape this function (returned or stored beyond the call by a closure).\n-            ty::ty_rptr(&ReLateBound(_, BrAnon(_)), mt) => {\n-                let llsz = llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                attrs.arg(idx, llvm::NoCaptureAttribute)\n-                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n-            }\n-\n-            // & pointer parameters are also never null and we know exactly how\n-            // many bytes we can dereference\n-            ty::ty_rptr(_, mt) => {\n-                let llsz = llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                attrs.arg(idx, llvm::DereferenceableAttribute(llsz));\n-            }\n-            _ => ()\n-        }\n-    }\n-\n-    attrs\n-}\n-\n-// only use this for foreign function ABIs and glue, use `register_fn` for Rust functions\n-pub fn register_fn_llvmty(ccx: &CrateContext,\n-                          sp: Span,\n-                          sym: String,\n-                          node_id: ast::NodeId,\n-                          cc: llvm::CallConv,\n-                          llfty: Type) -> ValueRef {\n-    debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n-\n-    let llfn = decl_fn(ccx,\n-                       &sym[..],\n-                       cc,\n-                       llfty,\n-                       ty::FnConverging(ty::mk_nil(ccx.tcx())));\n-    finish_register_fn(ccx, sp, sym, node_id, llfn);\n+    let llfn = declare::define_rust_fn(ccx, &sym[..], node_type).unwrap_or_else(||{\n+        ccx.sess().span_fatal(sp, &format!(\"symbol `{}` is already defined\", sym));\n+    });\n+    finish_register_fn(ccx, sym, node_id, llfn);\n     llfn\n }\n \n@@ -2550,27 +2124,35 @@ pub fn is_entry_fn(sess: &Session, node_id: ast::NodeId) -> bool {\n     }\n }\n \n-// Create a _rust_main(args: ~[str]) function which will be called from the\n-// runtime rust_start function\n+/// Create the `main` function which will initialise the rust runtime and call users\u2019 main\n+/// function.\n pub fn create_entry_wrapper(ccx: &CrateContext,\n-                           _sp: Span,\n+                           sp: Span,\n                            main_llfn: ValueRef) {\n     let et = ccx.sess().entry_type.get().unwrap();\n     match et {\n         config::EntryMain => {\n-            create_entry_fn(ccx, main_llfn, true);\n+            create_entry_fn(ccx, sp, main_llfn, true);\n         }\n-        config::EntryStart => create_entry_fn(ccx, main_llfn, false),\n+        config::EntryStart => create_entry_fn(ccx, sp, main_llfn, false),\n         config::EntryNone => {}    // Do nothing.\n     }\n \n     fn create_entry_fn(ccx: &CrateContext,\n+                       sp: Span,\n                        rust_main: ValueRef,\n                        use_start_lang_item: bool) {\n         let llfty = Type::func(&[ccx.int_type(), Type::i8p(ccx).ptr_to()],\n                                &ccx.int_type());\n \n-        let llfn = decl_cdecl_fn(ccx, \"main\", llfty, ty::mk_nil(ccx.tcx()));\n+        let llfn = declare::define_cfn(ccx, \"main\", llfty,\n+                                       ty::mk_nil(ccx.tcx())).unwrap_or_else(||{\n+            ccx.sess().span_err(sp, \"entry symbol `main` defined multiple times\");\n+            // FIXME: We should be smart and show a better diagnostic here.\n+            ccx.sess().help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\");\n+            ccx.sess().abort_if_errors();\n+            panic!();\n+        });\n \n         // FIXME: #16581: Marking a symbol in the executable with `dllexport`\n         // linkage forces MinGW's linker to output a `.reloc` section for ASLR\n@@ -2645,10 +2227,9 @@ fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, id: ast::NodeId,\n         None => {}\n     }\n \n-    match attr::first_attr_value_str_by_name(attrs, \"export_name\") {\n+    match attr::find_export_name_attr(ccx.sess().diagnostic(), attrs) {\n         // Use provided name\n         Some(name) => name.to_string(),\n-\n         _ => ccx.tcx().map.with_path(id, |path| {\n             if attr::contains_name(attrs, \"no_mangle\") {\n                 // Don't mangle\n@@ -2707,14 +2288,15 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                         } else {\n                             llvm::LLVMTypeOf(v)\n                         };\n-                        if contains_null(&sym[..]) {\n-                            ccx.sess().fatal(\n-                                &format!(\"Illegal null byte in export_name \\\n-                                         value: `{}`\", sym));\n-                        }\n-                        let buf = CString::new(sym.clone()).unwrap();\n-                        let g = llvm::LLVMAddGlobal(ccx.llmod(), llty,\n-                                                    buf.as_ptr());\n+\n+                        // FIXME(nagisa): probably should be declare_global, because no definition\n+                        // is happening here, but we depend on it being defined here from\n+                        // const::trans_static. This all logic should be replaced.\n+                        let g = declare::define_global(ccx, &sym[..],\n+                                                       Type::from_ref(llty)).unwrap_or_else(||{\n+                            ccx.sess().span_fatal(i.span, &format!(\"symbol `{}` is already defined\",\n+                                                                   sym))\n+                        });\n \n                         if attr::contains_name(&i.attrs,\n                                                \"thread_local\") {\n@@ -2730,12 +2312,9 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     let llfn = if abi == Rust {\n                         register_fn(ccx, i.span, sym, i.id, ty)\n                     } else {\n-                        foreign::register_rust_fn_with_foreign_abi(ccx,\n-                                                                   i.span,\n-                                                                   sym,\n-                                                                   i.id)\n+                        foreign::register_rust_fn_with_foreign_abi(ccx, i.span, sym, i.id)\n                     };\n-                    set_llvm_fn_attrs(ccx, &i.attrs, llfn);\n+                    attributes::from_fn_attrs(ccx, &i.attrs, llfn);\n                     llfn\n                 }\n \n@@ -2796,7 +2375,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     let ty = ty::node_id_to_type(ccx.tcx(), ni.id);\n                     let name = foreign::link_name(&*ni);\n                     let llfn = foreign::register_foreign_item_fn(ccx, abi, ty, &name);\n-                    set_llvm_fn_attrs(ccx, &ni.attrs, llfn);\n+                    attributes::from_fn_attrs(ccx, &ni.attrs, llfn);\n                     llfn\n                 }\n                 ast::ForeignItemStatic(..) => {\n@@ -2828,7 +2407,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                 }\n                 _ => ccx.sess().bug(\"NodeVariant, shouldn't happen\")\n             };\n-            set_inline_hint(llfn);\n+            attributes::inline(llfn, attributes::InlineAttr::Hint);\n             llfn\n         }\n \n@@ -2850,7 +2429,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                     &struct_item.attrs);\n             let llfn = register_fn(ccx, struct_item.span,\n                                    sym, ctor_id, ty);\n-            set_inline_hint(llfn);\n+            attributes::inline(llfn, attributes::InlineAttr::Hint);\n             llfn\n         }\n \n@@ -2885,7 +2464,7 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n         } else {\n             foreign::register_rust_fn_with_foreign_abi(ccx, span, sym, id)\n         };\n-        set_llvm_fn_attrs(ccx, &attrs, llfn);\n+        attributes::from_fn_attrs(ccx, &attrs, llfn);\n         return llfn;\n     } else {\n         ccx.sess().span_bug(span, \"expected bare rust function\");"}, {"sha": "604f185f396b81994230f77d4738dd73d1334a0f", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -41,6 +41,7 @@ use trans::common::{self, Block, Result, NodeIdAndSpan, ExprId, CrateContext,\n use trans::consts;\n use trans::datum::*;\n use trans::debuginfo::{DebugLoc, ToDebugLoc};\n+use trans::declare;\n use trans::expr;\n use trans::glue;\n use trans::inline;\n@@ -326,13 +327,9 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     debug!(\"tuple_fn_ty: {}\", tuple_fn_ty.repr(tcx));\n \n     //\n-    let function_name =\n-        link::mangle_internal_name_by_type_and_seq(ccx, bare_fn_ty,\n-                                                   \"fn_pointer_shim\");\n-    let llfn =\n-        decl_internal_rust_fn(ccx,\n-                              tuple_fn_ty,\n-                              &function_name[..]);\n+    let function_name = link::mangle_internal_name_by_type_and_seq(ccx, bare_fn_ty,\n+                                                                   \"fn_pointer_shim\");\n+    let llfn = declare::declare_internal_rust_fn(ccx, &function_name[..], tuple_fn_ty);\n \n     //\n     let empty_substs = tcx.mk_substs(Substs::trans_empty());"}, {"sha": "61af5bfaef8dee5db3da83e9ff959fad99ab1963", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -126,6 +126,7 @@ use trans::callee;\n use trans::common;\n use trans::common::{Block, FunctionContext, ExprId, NodeIdAndSpan};\n use trans::debuginfo::{DebugLoc, ToDebugLoc};\n+use trans::declare;\n use trans::glue;\n use middle::region;\n use trans::type_::Type;\n@@ -844,10 +845,8 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                     Some(llpersonality) => llpersonality,\n                     None => {\n                         let fty = Type::variadic_func(&[], &Type::i32(self.ccx));\n-                        let f = base::decl_cdecl_fn(self.ccx,\n-                                                    \"rust_eh_personality\",\n-                                                    fty,\n-                                                    self.ccx.tcx().types.i32);\n+                        let f = declare::declare_cfn(self.ccx, \"rust_eh_personality\", fty,\n+                                                     self.ccx.tcx().types.i32);\n                         *personality = Some(f);\n                         f\n                     }"}, {"sha": "eb4acec25510ac7f28370210cfeced6fc5562f34", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -13,13 +13,15 @@ use back::link::{self, mangle_internal_name_by_path_and_seq};\n use llvm::{ValueRef, get_param};\n use middle::mem_categorization::Typer;\n use trans::adt;\n+use trans::attributes;\n use trans::base::*;\n use trans::build::*;\n use trans::callee::{self, ArgVals, Callee, TraitItem, MethodData};\n use trans::cleanup::{CleanupMethods, CustomScope, ScopeId};\n use trans::common::*;\n use trans::datum::{self, Datum, rvalue_scratch_datum, Rvalue, ByValue};\n use trans::debuginfo::{self, DebugLoc};\n+use trans::declare;\n use trans::expr;\n use trans::monomorphize::{self, MonoId};\n use trans::type_of::*;\n@@ -161,10 +163,14 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n         mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n \n-    let llfn = decl_internal_rust_fn(ccx, function_type, &symbol[..]);\n+    // Currently there\u2019s only a single user of get_or_create_declaration_if_closure and it\n+    // unconditionally defines the function, therefore we use define_* here.\n+    let llfn = declare::define_internal_rust_fn(ccx, &symbol[..], function_type).unwrap_or_else(||{\n+        ccx.sess().bug(&format!(\"symbol `{}` already defined\", symbol));\n+    });\n \n     // set an inline hint for all closures\n-    set_inline_hint(llfn);\n+    attributes::inline(llfn, attributes::InlineAttr::Hint);\n \n     debug!(\"get_or_create_declaration_if_closure(): inserting new \\\n             closure {:?} (type {})\",\n@@ -380,7 +386,10 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // Create the by-value helper.\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, llonce_fn_ty, \"once_shim\");\n-    let lloncefn = decl_internal_rust_fn(ccx, llonce_fn_ty, &function_name);\n+    let lloncefn = declare::define_internal_rust_fn(ccx, &function_name[..], llonce_fn_ty)\n+        .unwrap_or_else(||{\n+            ccx.sess().bug(&format!(\"symbol `{}` already defined\", function_name));\n+        });\n \n     let sig = ty::erase_late_bound_regions(tcx, &llonce_bare_fn_ty.sig);\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);"}, {"sha": "168a294159d4fe7a8d85d34eb9842267f9fa382c", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -31,6 +31,7 @@ use trans::cleanup;\n use trans::consts;\n use trans::datum;\n use trans::debuginfo::{self, DebugLoc};\n+use trans::declare;\n use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -871,9 +872,10 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n                                                 !null_terminated as Bool);\n \n         let gsym = token::gensym(\"str\");\n-        let buf = CString::new(format!(\"str{}\", gsym.usize()));\n-        let buf = buf.unwrap();\n-        let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(sc).to_ref(), buf.as_ptr());\n+        let sym = format!(\"str{}\", gsym.usize());\n+        let g = declare::define_global(cx, &sym[..], val_ty(sc)).unwrap_or_else(||{\n+            cx.sess().bug(&format!(\"symbol `{}` is already defined\", sym));\n+        });\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n         llvm::SetLinkage(g, llvm::InternalLinkage);"}, {"sha": "aff5f597bfd9fbb91ef38977555cbe3861fb07d5", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -25,6 +25,7 @@ use middle::const_eval::{const_int_checked_shr, const_uint_checked_shr};\n use trans::{adt, closure, debuginfo, expr, inline, machine};\n use trans::base::{self, push_ctxt};\n use trans::common::*;\n+use trans::declare;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n@@ -35,6 +36,7 @@ use util::ppaux::{Repr, ty_to_string};\n use std::iter::repeat;\n use libc::c_uint;\n use syntax::{ast, ast_util};\n+use syntax::parse::token;\n use syntax::ptr::P;\n \n pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n@@ -83,7 +85,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n         ast::LitBool(b) => C_bool(cx, b),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n         ast::LitBinary(ref data) => {\n-            addr_of(cx, C_bytes(cx, &data[..]), \"binary\", e.id)\n+            addr_of(cx, C_bytes(cx, &data[..]), \"binary\")\n         }\n     }\n }\n@@ -96,13 +98,16 @@ pub fn ptrcast(val: ValueRef, ty: Type) -> ValueRef {\n \n fn addr_of_mut(ccx: &CrateContext,\n                cv: ValueRef,\n-               kind: &str,\n-               id: ast::NodeId)\n+               kind: &str)\n                -> ValueRef {\n     unsafe {\n-        let name = format!(\"{}{}\\0\", kind, id);\n-        let gv = llvm::LLVMAddGlobal(ccx.llmod(), val_ty(cv).to_ref(),\n-                                     name.as_ptr() as *const _);\n+        // FIXME: this totally needs a better name generation scheme, perhaps a simple global\n+        // counter? Also most other uses of gensym in trans.\n+        let gsym = token::gensym(\"_\");\n+        let name = format!(\"{}{}\", kind, gsym.usize());\n+        let gv = declare::define_global(ccx, &name[..], val_ty(cv)).unwrap_or_else(||{\n+            ccx.sess().bug(&format!(\"symbol `{}` is already defined\", name));\n+        });\n         llvm::LLVMSetInitializer(gv, cv);\n         SetLinkage(gv, InternalLinkage);\n         SetUnnamedAddr(gv, true);\n@@ -112,14 +117,13 @@ fn addr_of_mut(ccx: &CrateContext,\n \n pub fn addr_of(ccx: &CrateContext,\n                cv: ValueRef,\n-               kind: &str,\n-               id: ast::NodeId)\n+               kind: &str)\n                -> ValueRef {\n     match ccx.const_globals().borrow().get(&cv) {\n         Some(&gv) => return gv,\n         None => {}\n     }\n-    let gv = addr_of_mut(ccx, cv, kind, id);\n+    let gv = addr_of_mut(ccx, cv, kind);\n     unsafe {\n         llvm::LLVMSetGlobalConstant(gv, True);\n     }\n@@ -233,7 +237,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     };\n \n-    let lvalue = addr_of(ccx, val, \"const\", expr.id);\n+    let lvalue = addr_of(ccx, val, \"const\");\n     ccx.const_values().borrow_mut().insert(key, lvalue);\n     lvalue\n }\n@@ -284,7 +288,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     if adj.autoderefs == 0 {\n                         // Don't copy data to do a deref+ref\n                         // (i.e., skip the last auto-deref).\n-                        llconst = addr_of(cx, llconst, \"autoref\", e.id);\n+                        llconst = addr_of(cx, llconst, \"autoref\");\n                     } else {\n                         // Seeing as we are deref'ing here and take a reference\n                         // again to make the pointer part of the far pointer below,\n@@ -312,7 +316,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 None => {}\n                 Some(box ty::AutoUnsafe(_, None)) |\n                 Some(box ty::AutoPtr(_, _, None)) => {\n-                    llconst = addr_of(cx, llconst, \"autoref\", e.id);\n+                    llconst = addr_of(cx, llconst, \"autoref\");\n                 }\n                 Some(box ty::AutoUnsize(ref k)) => {\n                     let info =\n@@ -711,12 +715,12 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                   // If this isn't the address of a static, then keep going through\n                   // normal constant evaluation.\n                   let (v, _) = const_expr(cx, &**sub, param_substs);\n-                  addr_of(cx, v, \"ref\", e.id)\n+                  addr_of(cx, v, \"ref\")\n               }\n           }\n           ast::ExprAddrOf(ast::MutMutable, ref sub) => {\n               let (v, _) = const_expr(cx, &**sub, param_substs);\n-              addr_of_mut(cx, v, \"ref_mut_slice\", e.id)\n+              addr_of_mut(cx, v, \"ref_mut_slice\")\n           }\n           ast::ExprTup(ref es) => {\n               let repr = adt::represent_type(cx, ety);\n@@ -862,7 +866,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n+pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) -> ValueRef {\n     unsafe {\n         let _icx = push_ctxt(\"trans_static\");\n         let g = base::get_item_val(ccx, id);\n@@ -888,6 +892,7 @@ pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n             }\n         }\n         debuginfo::create_global_var_metadata(ccx, id, g);\n+        g\n     }\n }\n "}, {"sha": "e54962dc085524e1b41fc337fc453503379c231d", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -20,6 +20,7 @@ use trans::base;\n use trans::builder::Builder;\n use trans::common::{ExternMap,BuilderRef_res};\n use trans::debuginfo;\n+use trans::declare;\n use trans::monomorphize::MonoId;\n use trans::type_::{Type, TypeNames};\n use middle::subst::Substs;\n@@ -133,7 +134,6 @@ pub struct LocalCrateContext<'tcx> {\n     llsizingtypes: RefCell<FnvHashMap<Ty<'tcx>, Type>>,\n     adt_reprs: RefCell<FnvHashMap<Ty<'tcx>, Rc<adt::Repr<'tcx>>>>,\n     type_hashcodes: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n-    all_llvm_symbols: RefCell<FnvHashSet<String>>,\n     int_type: Type,\n     opaque_vec_type: Type,\n     builder: BuilderRef_res,\n@@ -413,7 +413,6 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 llsizingtypes: RefCell::new(FnvHashMap()),\n                 adt_reprs: RefCell::new(FnvHashMap()),\n                 type_hashcodes: RefCell::new(FnvHashMap()),\n-                all_llvm_symbols: RefCell::new(FnvHashSet()),\n                 int_type: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n@@ -653,10 +652,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.type_hashcodes\n     }\n \n-    pub fn all_llvm_symbols<'a>(&'a self) -> &'a RefCell<FnvHashSet<String>> {\n-        &self.local.all_llvm_symbols\n-    }\n-\n     pub fn stats<'a>(&'a self) -> &'a Stats {\n         &self.shared.stats\n     }\n@@ -743,17 +738,16 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n     macro_rules! ifn {\n         ($name:expr, fn() -> $ret:expr) => (\n             if *key == $name {\n-                let f = base::decl_cdecl_fn(\n-                    ccx, $name, Type::func(&[], &$ret),\n-                    ty::mk_nil(ccx.tcx()));\n+                let f = declare::declare_cfn(ccx, $name, Type::func(&[], &$ret),\n+                                             ty::mk_nil(ccx.tcx()));\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n             if *key == $name {\n-                let f = base::decl_cdecl_fn(ccx, $name,\n-                                  Type::func(&[$($arg),*], &$ret), ty::mk_nil(ccx.tcx()));\n+                let f = declare::declare_cfn(ccx, $name, Type::func(&[$($arg),*], &$ret),\n+                                             ty::mk_nil(ccx.tcx()));\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n@@ -888,9 +882,9 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n                 // The `if key == $name` is already in ifn!\n                 ifn!($name, fn($($arg),*) -> $ret);\n             } else if *key == $name {\n-                let f = base::decl_cdecl_fn(ccx, stringify!($cname),\n-                                      Type::func(&[$($arg),*], &$ret),\n-                                      ty::mk_nil(ccx.tcx()));\n+                let f = declare::declare_cfn(ccx, stringify!($cname),\n+                                             Type::func(&[$($arg),*], &$ret),\n+                                             ty::mk_nil(ccx.tcx()));\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }"}, {"sha": "f544efe7401c4dc00a90f1ed0c7fe591dcf55650", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -416,8 +416,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let filename = C_str_slice(ccx, filename);\n     let line = C_u32(ccx, loc.line as u32);\n     let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n-    let expr_file_line = consts::addr_of(ccx, expr_file_line_const,\n-                                         \"panic_loc\", call_info.id);\n+    let expr_file_line = consts::addr_of(ccx, expr_file_line_const, \"panic_loc\");\n     let args = vec!(expr_file_line);\n     let did = langcall(bcx, Some(call_info.span), \"\", PanicFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n@@ -449,8 +448,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let filename = C_str_slice(ccx,  filename);\n     let line = C_u32(ccx, loc.line as u32);\n     let file_line_const = C_struct(ccx, &[filename, line], false);\n-    let file_line = consts::addr_of(ccx, file_line_const,\n-                                    \"panic_bounds_check_loc\", call_info.id);\n+    let file_line = consts::addr_of(ccx, file_line_const, \"panic_bounds_check_loc\");\n     let args = vec!(file_line, index, len);\n     let did = langcall(bcx, Some(call_info.span), \"\", PanicBoundsCheckFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,"}, {"sha": "a59616d09b1c1b6a7501bef06cc40d079da98481", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -196,8 +196,9 @@ use llvm::debuginfo::*;\n use metadata::csearch;\n use middle::subst::{self, Substs};\n use trans::{self, adt, machine, type_of};\n-use trans::common::{self, NodeIdAndSpan, CrateContext, FunctionContext, Block,\n-                    C_bytes, NormalizingClosureTyper};\n+use trans::common::{self, NodeIdAndSpan, CrateContext, FunctionContext, Block, C_bytes,\n+                    NormalizingClosureTyper};\n+use trans::declare;\n use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -4067,7 +4068,7 @@ pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext)\n /// section.\n fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n                                                   -> llvm::ValueRef {\n-    let section_var_name = b\"__rustc_debug_gdb_scripts_section__\\0\";\n+    let section_var_name = \"__rustc_debug_gdb_scripts_section__\";\n \n     let section_var = unsafe {\n         llvm::LLVMGetNamedGlobal(ccx.llmod(),\n@@ -4081,10 +4082,11 @@ fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n         unsafe {\n             let llvm_type = Type::array(&Type::i8(ccx),\n                                         section_contents.len() as u64);\n-            let section_var = llvm::LLVMAddGlobal(ccx.llmod(),\n-                                                  llvm_type.to_ref(),\n-                                                  section_var_name.as_ptr()\n-                                                    as *const _);\n+\n+            let section_var = declare::define_global(ccx, section_var_name,\n+                                                     llvm_type).unwrap_or_else(||{\n+                ccx.sess().bug(&format!(\"symbol `{}` is already defined\", section_var_name))\n+            });\n             llvm::LLVMSetSection(section_var, section_name.as_ptr() as *const _);\n             llvm::LLVMSetInitializer(section_var, C_bytes(ccx, section_contents));\n             llvm::LLVMSetGlobalConstant(section_var, llvm::True);"}, {"sha": "9e7449f670f0fe398f2c876e383a86186281b047", "filename": "src/librustc_trans/trans/declare.rs", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -0,0 +1,261 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//! Declare various LLVM values.\n+//!\n+//! Prefer using functions and methods from this module rather than calling LLVM functions\n+//! directly. These functions do some additional work to ensure we do the right thing given\n+//! the preconceptions of trans.\n+//!\n+//! Some useful guidelines:\n+//!\n+//! * Use declare_* family of methods if you are declaring, but are not interested in defining the\n+//! ValueRef they return.\n+//! * Use define_* family of methods when you might be defining the ValueRef.\n+//! * When in doubt, define.\n+use llvm::{self, ValueRef};\n+use middle::ty::{self, ClosureTyper};\n+use syntax::abi;\n+use trans::attributes;\n+use trans::base;\n+use trans::common;\n+use trans::context::CrateContext;\n+use trans::monomorphize;\n+use trans::type_::Type;\n+use trans::type_of;\n+use util::ppaux::Repr;\n+\n+use std::ffi::CString;\n+use libc::c_uint;\n+\n+\n+/// Declare a global value.\n+///\n+/// If there\u2019s a value with the same name already declared, the function will return its ValueRef\n+/// instead.\n+pub fn declare_global(ccx: &CrateContext, name: &str, ty: Type) -> llvm::ValueRef {\n+    debug!(\"declare_global(name={:?})\", name);\n+    let namebuf = CString::new(name).unwrap_or_else(|_|{\n+        ccx.sess().bug(&format!(\"name {:?} contains an interior null byte\", name))\n+    });\n+    unsafe {\n+        llvm::LLVMGetOrInsertGlobal(ccx.llmod(), namebuf.as_ptr(), ty.to_ref())\n+    }\n+}\n+\n+\n+/// Declare a function.\n+///\n+/// For rust functions use `declare_rust_fn` instead.\n+///\n+/// If there\u2019s a value with the same name already declared, the function will update the\n+/// declaration and return existing ValueRef instead.\n+pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty: Type,\n+                  output: ty::FnOutput) -> ValueRef {\n+    debug!(\"declare_fn(name={:?})\", name);\n+    let namebuf = CString::new(name).unwrap_or_else(|_|{\n+        ccx.sess().bug(&format!(\"name {:?} contains an interior null byte\", name))\n+    });\n+    let llfn = unsafe {\n+        llvm::LLVMGetOrInsertFunction(ccx.llmod(), namebuf.as_ptr(), ty.to_ref())\n+    };\n+\n+    llvm::SetFunctionCallConv(llfn, callconv);\n+    // Function addresses in Rust are never significant, allowing functions to be merged.\n+    llvm::SetUnnamedAddr(llfn, true);\n+\n+    if output == ty::FnDiverging {\n+        llvm::SetFunctionAttribute(llfn, llvm::NoReturnAttribute);\n+    }\n+\n+    if ccx.tcx().sess.opts.cg.no_redzone\n+        .unwrap_or(ccx.tcx().sess.target.target.options.disable_redzone) {\n+        llvm::SetFunctionAttribute(llfn, llvm::NoRedZoneAttribute)\n+    }\n+\n+    if ccx.is_split_stack_supported() && !ccx.sess().opts.cg.no_stack_check {\n+        attributes::split_stack(llfn, true);\n+    }\n+    llfn\n+}\n+\n+\n+/// Declare a C ABI function.\n+///\n+/// Only use this for foreign function ABIs and glue. For Rust functions use `declare_rust_fn`\n+/// instead.\n+///\n+/// If there\u2019s a value with the same name already declared, the function will update the\n+/// declaration and return existing ValueRef instead.\n+pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type, output: ty::Ty) -> ValueRef {\n+    declare_fn(ccx, name, llvm::CCallConv, fn_type, ty::FnConverging(output))\n+}\n+\n+\n+/// Declare a Rust function.\n+///\n+/// If there\u2019s a value with the same name already declared, the function will update the\n+/// declaration and return existing ValueRef instead.\n+pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n+                                 fn_type: ty::Ty<'tcx>) -> ValueRef {\n+    debug!(\"declare_rust_fn(name={:?}, fn_type={})\", name, fn_type.repr(ccx.tcx()));\n+    let fn_type = monomorphize::normalize_associated_type(ccx.tcx(), &fn_type);\n+    debug!(\"declare_rust_fn (after normalised associated types) fn_type={}\",\n+           fn_type.repr(ccx.tcx()));\n+\n+    let function_type; // placeholder so that the memory ownership works out ok\n+    let (sig, abi, env) = match fn_type.sty {\n+        ty::ty_bare_fn(_, ref f) => {\n+            (&f.sig, f.abi, None)\n+        }\n+        ty::ty_closure(closure_did, substs) => {\n+            let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n+            function_type = typer.closure_type(closure_did, substs);\n+            let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n+            let llenvironment_type = type_of::type_of_explicit_arg(ccx, self_type);\n+            debug!(\"declare_rust_fn function_type={} self_type={}\",\n+                   function_type.repr(ccx.tcx()), self_type.repr(ccx.tcx()));\n+            (&function_type.sig, abi::RustCall, Some(llenvironment_type))\n+        }\n+        _ => ccx.sess().bug(\"expected closure or fn\")\n+    };\n+\n+    let sig = ty::Binder(ty::erase_late_bound_regions(ccx.tcx(), sig));\n+    debug!(\"declare_rust_fn (after region erasure) sig={}\", sig.repr(ccx.tcx()));\n+    let llfty = type_of::type_of_rust_fn(ccx, env, &sig, abi);\n+    debug!(\"declare_rust_fn llfty={}\", ccx.tn().type_to_string(llfty));\n+\n+    // it is ok to directly access sig.0.output because we erased all late-bound-regions above\n+    let llfn = declare_fn(ccx, name, llvm::CCallConv, llfty, sig.0.output);\n+    attributes::from_fn_type(ccx, fn_type).apply_llfn(llfn);\n+    llfn\n+}\n+\n+\n+/// Declare a Rust function with internal linkage.\n+///\n+/// If there\u2019s a value with the same name already declared, the function will update the\n+/// declaration and return existing ValueRef instead.\n+pub fn declare_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n+                                          fn_type: ty::Ty<'tcx>) -> ValueRef {\n+    let llfn = declare_rust_fn(ccx, name, fn_type);\n+    llvm::SetLinkage(llfn, llvm::InternalLinkage);\n+    llfn\n+}\n+\n+\n+/// Declare a global with an intention to define it.\n+///\n+/// Use this function when you intend to define a global. This function will return None if the\n+/// name already has a definition associated with it. In that case an error should be reported to\n+/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n+/// #[export_name] attributes).\n+pub fn define_global(ccx: &CrateContext, name: &str, ty: Type) -> Option<ValueRef> {\n+    if get_defined_value(ccx, name).is_some() {\n+        None\n+    } else {\n+        Some(declare_global(ccx, name, ty))\n+    }\n+}\n+\n+\n+/// Declare a function with an intention to define it.\n+///\n+/// For rust functions use `define_rust_fn` instead.\n+///\n+/// Use this function when you intend to define a function. This function will return None if the\n+/// name already has a definition associated with it. In that case an error should be reported to\n+/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n+/// #[export_name] attributes).\n+pub fn define_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, fn_type: Type,\n+                 output: ty::FnOutput) -> Option<ValueRef> {\n+    if get_defined_value(ccx, name).is_some() {\n+        None\n+    } else {\n+        Some(declare_fn(ccx, name, callconv, fn_type, output))\n+    }\n+}\n+\n+\n+/// Declare a C ABI function with an intention to define it.\n+///\n+/// Use this function when you intend to define a function. This function will return None if the\n+/// name already has a definition associated with it. In that case an error should be reported to\n+/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n+/// #[export_name] attributes).\n+///\n+/// Only use this for foreign function ABIs and glue. For Rust functions use `declare_rust_fn`\n+/// instead.\n+pub fn define_cfn(ccx: &CrateContext, name: &str, fn_type: Type,\n+                  output: ty::Ty) -> Option<ValueRef> {\n+    if get_defined_value(ccx, name).is_some() {\n+        None\n+    } else {\n+        Some(declare_cfn(ccx, name, fn_type, output))\n+    }\n+}\n+\n+\n+/// Declare a Rust function with an intention to define it.\n+///\n+/// Use this function when you intend to define a function. This function will return None if the\n+/// name already has a definition associated with it. In that case an error should be reported to\n+/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n+/// #[export_name] attributes).\n+pub fn define_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n+                                fn_type: ty::Ty<'tcx>) -> Option<ValueRef> {\n+    if get_defined_value(ccx, name).is_some() {\n+        None\n+    } else {\n+        Some(declare_rust_fn(ccx, name, fn_type))\n+    }\n+}\n+\n+\n+/// Declare a Rust function with an intention to define it.\n+///\n+/// Use this function when you intend to define a function. This function will return None if the\n+/// name already has a definition associated with it. In that case an error should be reported to\n+/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n+/// #[export_name] attributes).\n+pub fn define_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n+                                         fn_type: ty::Ty<'tcx>) -> Option<ValueRef> {\n+    if get_defined_value(ccx, name).is_some() {\n+        None\n+    } else {\n+        Some(declare_internal_rust_fn(ccx, name, fn_type))\n+    }\n+}\n+\n+\n+/// Get defined or externally defined (AvailableExternally linkage) value by name.\n+fn get_defined_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n+    debug!(\"get_defined_value(name={:?})\", name);\n+    let namebuf = CString::new(name).unwrap_or_else(|_|{\n+        ccx.sess().bug(&format!(\"name {:?} contains an interior null byte\", name))\n+    });\n+    let val = unsafe { llvm::LLVMGetNamedValue(ccx.llmod(), namebuf.as_ptr()) };\n+    if val.is_null() {\n+        debug!(\"get_defined_value: {:?} value is null\", name);\n+        None\n+    } else {\n+        let (declaration, aext_link) = unsafe {\n+            let linkage = llvm::LLVMGetLinkage(val);\n+            (llvm::LLVMIsDeclaration(val) != 0,\n+             linkage == llvm::AvailableExternallyLinkage as c_uint)\n+        };\n+        debug!(\"get_defined_value: found {:?} value (declaration: {}, aext_link: {})\", name,\n+               declaration, aext_link);\n+        if !declaration || aext_link {\n+            Some(val)\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "8f3a51a5007096984835901d54f13b8f07b21150", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -13,12 +13,14 @@ use back::link;\n use llvm::{ValueRef, CallConv, get_param};\n use llvm;\n use middle::weak_lang_items;\n+use trans::attributes;\n use trans::base::{llvm_linkage_by_name, push_ctxt};\n use trans::base;\n use trans::build::*;\n use trans::cabi;\n use trans::common::*;\n use trans::debuginfo::DebugLoc;\n+use trans::declare;\n use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -27,7 +29,6 @@ use trans::type_of;\n use middle::ty::{self, Ty};\n use middle::subst::Substs;\n \n-use std::ffi::CString;\n use std::cmp;\n use libc::c_uint;\n use syntax::abi::{Cdecl, Aapcs, C, Win64, Abi};\n@@ -135,9 +136,7 @@ pub fn register_static(ccx: &CrateContext,\n             };\n             unsafe {\n                 // Declare a symbol `foo` with the desired linkage.\n-                let buf = CString::new(ident.as_bytes()).unwrap();\n-                let g1 = llvm::LLVMAddGlobal(ccx.llmod(), llty2.to_ref(),\n-                                             buf.as_ptr());\n+                let g1 = declare::declare_global(ccx, &ident[..], llty2);\n                 llvm::SetLinkage(g1, linkage);\n \n                 // Declare an internal global `extern_with_linkage_foo` which\n@@ -148,20 +147,35 @@ pub fn register_static(ccx: &CrateContext,\n                 // zero.\n                 let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n                 real_name.push_str(&ident);\n-                let real_name = CString::new(real_name).unwrap();\n-                let g2 = llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(),\n-                                             real_name.as_ptr());\n+                let g2 = declare::define_global(ccx, &real_name[..], llty).unwrap_or_else(||{\n+                    ccx.sess().span_fatal(foreign_item.span,\n+                                          &format!(\"symbol `{}` is already defined\", ident))\n+                });\n                 llvm::SetLinkage(g2, llvm::InternalLinkage);\n                 llvm::LLVMSetInitializer(g2, g1);\n                 g2\n             }\n         }\n-        None => unsafe {\n-            // Generate an external declaration.\n-            let buf = CString::new(ident.as_bytes()).unwrap();\n-            llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(), buf.as_ptr())\n-        }\n+        None => // Generate an external declaration.\n+            declare::declare_global(ccx, &ident[..], llty),\n+    }\n+}\n+\n+// only use this for foreign function ABIs and glue, use `get_extern_rust_fn` for Rust functions\n+pub fn get_extern_fn(ccx: &CrateContext,\n+                     externs: &mut ExternMap,\n+                     name: &str,\n+                     cc: llvm::CallConv,\n+                     ty: Type,\n+                     output: Ty)\n+                     -> ValueRef {\n+    match externs.get(name) {\n+        Some(n) => return *n,\n+        None => {}\n     }\n+    let f = declare::declare_fn(ccx, name, cc, ty, ty::FnConverging(output));\n+    externs.insert(name.to_string(), f);\n+    f\n }\n \n /// Registers a foreign function found in a library. Just adds a LLVM global.\n@@ -189,14 +203,8 @@ pub fn register_foreign_item_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Create the LLVM value for the C extern fn\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n \n-    let llfn = base::get_extern_fn(ccx,\n-                                   &mut *ccx.externs().borrow_mut(),\n-                                   name,\n-                                   cc,\n-                                   llfn_ty,\n-                                   fty);\n+    let llfn = get_extern_fn(ccx, &mut *ccx.externs().borrow_mut(), name, cc, llfn_ty, fty);\n     add_argument_attributes(&tys, llfn);\n-\n     llfn\n }\n \n@@ -471,7 +479,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n                     }\n \n                     let llfn = register_foreign_item_fn(ccx, abi, ty, &lname);\n-                    base::set_llvm_fn_attrs(ccx, &foreign_item.attrs, llfn);\n+                    attributes::from_fn_attrs(ccx, &foreign_item.attrs, llfn);\n                     // Unlike for other items, we shouldn't call\n                     // `base::update_linkage` here.  Foreign items have\n                     // special linkage requirements, which are handled\n@@ -522,7 +530,8 @@ pub fn decl_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         _ => panic!(\"expected bare fn in decl_rust_fn_with_foreign_abi\")\n     };\n-    let llfn = base::decl_fn(ccx, name, cconv, llfn_ty, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n+    let llfn = declare::declare_fn(ccx, name, cconv, llfn_ty,\n+                                   ty::FnConverging(ty::mk_nil(ccx.tcx())));\n     add_argument_attributes(&tys, llfn);\n     debug!(\"decl_rust_fn_with_foreign_abi(llfn_ty={}, llfn={})\",\n            ccx.tn().type_to_string(llfn_ty), ccx.tn().val_to_string(llfn));\n@@ -611,8 +620,10 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                ccx.tcx().map.path_to_string(id),\n                id, t.repr(tcx));\n \n-        let llfn = base::decl_internal_rust_fn(ccx, t, &ps[..]);\n-        base::set_llvm_fn_attrs(ccx, attrs, llfn);\n+        let llfn = declare::define_internal_rust_fn(ccx, &ps[..], t).unwrap_or_else(||{\n+            ccx.sess().bug(&format!(\"symbol `{}` already defined\", ps));\n+        });\n+        attributes::from_fn_attrs(ccx, attrs, llfn);\n         base::trans_fn(ccx, decl, body, llfn, param_substs, id, &[]);\n         llfn\n     }\n@@ -642,6 +653,11 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         //         return r;\n         //     }\n \n+        if llvm::LLVMCountBasicBlocks(llwrapfn) != 0 {\n+            ccx.sess().bug(\"wrapping a function inside non-empty wrapper, most likely cause is \\\n+                           multiple functions being wrapped\");\n+        }\n+\n         let ptr = \"the block\\0\".as_ptr();\n         let the_block = llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llwrapfn,\n                                                             ptr as *const _);\n@@ -800,7 +816,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Perform the call itself\n         debug!(\"calling llrustfn = {}, t = {}\",\n                ccx.tn().val_to_string(llrustfn), t.repr(ccx.tcx()));\n-        let attributes = base::get_fn_llvm_attributes(ccx, t);\n+        let attributes = attributes::from_fn_type(ccx, t);\n         let llrust_ret_val = builder.call(llrustfn, &llrust_args, Some(attributes));\n \n         // Get the return value where the foreign fn expects it."}, {"sha": "f974796e69cadb7462957d30a81cc67f107e010d", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -15,11 +15,13 @@\n \n use back::abi;\n use back::link::*;\n-use llvm::{ValueRef, get_param};\n use llvm;\n+use llvm::{ValueRef, get_param};\n+use metadata::csearch;\n use middle::lang_items::ExchangeFreeFnLangItem;\n use middle::subst;\n use middle::subst::{Subst, Substs};\n+use middle::ty::{self, Ty};\n use trans::adt;\n use trans::adt::GetDtorType; // for tcx.dtor_type()\n use trans::base::*;\n@@ -30,13 +32,16 @@ use trans::cleanup::CleanupMethods;\n use trans::common::*;\n use trans::datum;\n use trans::debuginfo::DebugLoc;\n+use trans::declare;\n use trans::expr;\n+use trans::foreign;\n+use trans::inline;\n use trans::machine::*;\n+use trans::monomorphize;\n+use trans::type_of::{type_of, type_of_dtor, sizing_type_of, align_of};\n use trans::type_::Type;\n-use trans::type_of::{type_of, sizing_type_of, align_of};\n-use middle::ty::{self, Ty};\n-use util::ppaux::{ty_to_short_str, Repr};\n use util::ppaux;\n+use util::ppaux::{ty_to_short_str, Repr};\n \n use arena::TypedArena;\n use libc::c_uint;\n@@ -178,14 +183,15 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n     // To avoid infinite recursion, don't `make_drop_glue` until after we've\n     // added the entry to the `drop_glues` cache.\n     if let Some(old_sym) = ccx.available_drop_glues().borrow().get(&t) {\n-        let llfn = decl_cdecl_fn(ccx, &old_sym, llfnty, ty::mk_nil(ccx.tcx()));\n+        let llfn = declare::declare_cfn(ccx, &old_sym, llfnty, ty::mk_nil(ccx.tcx()));\n         ccx.drop_glues().borrow_mut().insert(t, llfn);\n         return llfn;\n     };\n \n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, \"drop\");\n-    let llfn = decl_cdecl_fn(ccx, &fn_nm, llfnty, ty::mk_nil(ccx.tcx()));\n-    note_unique_llvm_symbol(ccx, fn_nm.clone());\n+    let llfn = declare::define_cfn(ccx, &fn_nm, llfnty, ty::mk_nil(ccx.tcx())).unwrap_or_else(||{\n+       ccx.sess().bug(&format!(\"symbol `{}` already defined\", fn_nm));\n+    });\n     ccx.available_drop_glues().borrow_mut().insert(t, fn_nm);\n \n     let _s = StatRecorder::new(ccx, format!(\"drop {}\", ty_to_short_str(ccx.tcx(), t)));\n@@ -259,6 +265,40 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n }\n \n+pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                              did: ast::DefId,\n+                              t: Ty<'tcx>,\n+                              parent_id: ast::DefId,\n+                              substs: &Substs<'tcx>)\n+                              -> ValueRef {\n+    let _icx = push_ctxt(\"trans_res_dtor\");\n+    let did = inline::maybe_instantiate_inline(ccx, did);\n+\n+    if !substs.types.is_empty() {\n+        assert_eq!(did.krate, ast::LOCAL_CRATE);\n+\n+        // Since we're in trans we don't care for any region parameters\n+        let substs = ccx.tcx().mk_substs(Substs::erased(substs.types.clone()));\n+\n+        let (val, _, _) = monomorphize::monomorphic_fn(ccx, did, substs, None);\n+\n+        val\n+    } else if did.krate == ast::LOCAL_CRATE {\n+        get_item_val(ccx, did.node)\n+    } else {\n+        let tcx = ccx.tcx();\n+        let name = csearch::get_symbol(&ccx.sess().cstore, did);\n+        let class_ty = ty::lookup_item_type(tcx, parent_id).ty.subst(tcx, substs);\n+        let llty = type_of_dtor(ccx, class_ty);\n+        let dtor_ty = ty::mk_ctor_fn(ccx.tcx(),\n+                                     did,\n+                                     &[get_drop_glue_type(ccx, t)],\n+                                     ty::mk_nil(ccx.tcx()));\n+        foreign::get_extern_fn(ccx, &mut *ccx.externs().borrow_mut(), &name[..], llvm::CCallConv,\n+                               llty, dtor_ty)\n+    }\n+}\n+\n fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  t: Ty<'tcx>,\n                                  v0: ValueRef,"}, {"sha": "e2f965a95fff78f130638f508f322287d2845e2c", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -28,6 +28,7 @@ use trans::common::*;\n use trans::consts;\n use trans::datum::*;\n use trans::debuginfo::DebugLoc;\n+use trans::declare;\n use trans::expr::SaveIn;\n use trans::expr;\n use trans::glue;\n@@ -590,10 +591,10 @@ pub fn trans_object_shim<'a, 'tcx>(\n     //\n     let shim_fn_ty = ty::mk_bare_fn(tcx, None, fty);\n     let method_bare_fn_ty = ty::mk_bare_fn(tcx, None, method_ty);\n-    let function_name =\n-        link::mangle_internal_name_by_type_and_seq(ccx, shim_fn_ty, \"object_shim\");\n-    let llfn =\n-        decl_internal_rust_fn(ccx, shim_fn_ty, &function_name);\n+    let function_name = link::mangle_internal_name_by_type_and_seq(ccx, shim_fn_ty, \"object_shim\");\n+    let llfn = declare::define_internal_rust_fn(ccx, &function_name, shim_fn_ty).unwrap_or_else(||{\n+        ccx.sess().bug(&format!(\"symbol `{}` already defined\", function_name));\n+    });\n \n     let sig = ty::erase_late_bound_regions(ccx.tcx(), &fty.sig);\n \n@@ -756,8 +757,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         C_uint(ccx, align)\n     ].into_iter().chain(methods).collect();\n \n-    let vtable = consts::addr_of(ccx, C_struct(ccx, &components, false),\n-                                 \"vtable\", trait_ref.def_id().node);\n+    let vtable = consts::addr_of(ccx, C_struct(ccx, &components, false), \"vtable\");\n \n     ccx.vtables().borrow_mut().insert(trait_ref, vtable);\n     vtable"}, {"sha": "7d568ff90ea43cbc0dbfe078f258000fa807b88b", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -19,43 +19,45 @@ pub use self::common::gensym_name;\n #[macro_use]\n mod macros;\n \n-mod inline;\n-mod monomorphize;\n-mod controlflow;\n-mod glue;\n-mod datum;\n-mod callee;\n-mod expr;\n-mod common;\n-mod context;\n-mod consts;\n-mod type_of;\n+mod adt;\n+mod asm;\n+mod attributes;\n+mod base;\n+mod basic_block;\n mod build;\n mod builder;\n-mod base;\n-mod _match;\n-mod closure;\n-mod tvec;\n-mod meth;\n mod cabi;\n-mod cabi_x86;\n-mod cabi_x86_64;\n-mod cabi_x86_win64;\n-mod cabi_arm;\n mod cabi_aarch64;\n+mod cabi_arm;\n mod cabi_mips;\n mod cabi_powerpc;\n+mod cabi_x86;\n+mod cabi_x86_64;\n+mod cabi_x86_win64;\n+mod callee;\n+mod cleanup;\n+mod closure;\n+mod common;\n+mod consts;\n+mod context;\n+mod controlflow;\n+mod datum;\n+mod debuginfo;\n+mod declare;\n+mod expr;\n mod foreign;\n+mod glue;\n+mod inline;\n mod intrinsic;\n-mod debuginfo;\n+mod llrepr;\n mod machine;\n-mod adt;\n-mod asm;\n+mod _match;\n+mod meth;\n+mod monomorphize;\n+mod tvec;\n mod type_;\n+mod type_of;\n mod value;\n-mod basic_block;\n-mod llrepr;\n-mod cleanup;\n \n #[derive(Copy, Clone)]\n pub struct ModuleTranslation {"}, {"sha": "1c8d020494fabfa0788d0c053d3ea0a37d38c3bb", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -17,11 +17,12 @@ use middle::subst;\n use middle::subst::{Subst, Substs};\n use middle::traits;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n-use trans::base::{set_llvm_fn_attrs, set_inline_hint};\n+use trans::attributes;\n use trans::base::{trans_enum_variant, push_ctxt, get_item_val};\n-use trans::base::{trans_fn, decl_internal_rust_fn};\n+use trans::base::trans_fn;\n use trans::base;\n use trans::common::*;\n+use trans::declare;\n use trans::foreign;\n use middle::ty::{self, HasProjectionTypes, Ty};\n use util::ppaux::Repr;\n@@ -143,15 +144,18 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let lldecl = if abi != abi::Rust {\n             foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, &s[..])\n         } else {\n-            decl_internal_rust_fn(ccx, mono_ty, &s[..])\n+            // FIXME(nagisa): perhaps needs a more fine grained selection? See setup_lldecl below.\n+            declare::define_internal_rust_fn(ccx, &s[..], mono_ty).unwrap_or_else(||{\n+                ccx.sess().bug(&format!(\"symbol `{}` already defined\", s));\n+            })\n         };\n \n         ccx.monomorphized().borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n         lldecl\n     };\n     let setup_lldecl = |lldecl, attrs: &[ast::Attribute]| {\n         base::update_linkage(ccx, lldecl, None, base::OriginalTranslation);\n-        set_llvm_fn_attrs(ccx, attrs, lldecl);\n+        attributes::from_fn_attrs(ccx, attrs, lldecl);\n \n         let is_first = !ccx.available_monomorphizations().borrow().contains(&s);\n         if is_first {\n@@ -200,7 +204,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let tvs = ty::enum_variants(ccx.tcx(), local_def(parent));\n             let this_tv = tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n             let d = mk_lldecl(abi::Rust);\n-            set_inline_hint(d);\n+            attributes::inline(d, attributes::InlineAttr::Hint);\n             match v.node.kind {\n                 ast::TupleVariantKind(ref args) => {\n                     trans_enum_variant(ccx,\n@@ -259,7 +263,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         ast_map::NodeStructCtor(struct_def) => {\n             let d = mk_lldecl(abi::Rust);\n-            set_inline_hint(d);\n+            attributes::inline(d, attributes::InlineAttr::Hint);\n             base::trans_tuple_struct(ccx,\n                                      &struct_def.fields,\n                                      struct_def.ctor_id.expect(\"ast-mapped tuple struct \\"}, {"sha": "755dd3bb4586fd72dae9b893a04d04ce8b09234e", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -282,6 +282,23 @@ pub fn find_crate_name(attrs: &[Attribute]) -> Option<InternedString> {\n     first_attr_value_str_by_name(attrs, \"crate_name\")\n }\n \n+/// Find the value of #[export_name=*] attribute and check its validity.\n+pub fn find_export_name_attr(diag: &SpanHandler, attrs: &[Attribute]) -> Option<InternedString> {\n+    attrs.iter().fold(None, |ia,attr| {\n+        if attr.check_name(\"export_name\") {\n+            if let s@Some(_) = attr.value_str() {\n+                s\n+            } else {\n+                diag.span_err(attr.span, \"export_name attribute has invalid format\");\n+                diag.handler.help(\"use #[export_name=\\\"*\\\"]\");\n+                None\n+            }\n+        } else {\n+            ia\n+        }\n+    })\n+}\n+\n #[derive(Copy, Clone, PartialEq)]\n pub enum InlineAttr {\n     None,"}, {"sha": "31f75ae03b0998688132ec9c75a311dac3e806ba", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -77,13 +77,24 @@ extern \"C\" void LLVMRustPrintPassTimings() {\n   TimerGroup::printAll(OS);\n }\n \n+extern \"C\" LLVMValueRef LLVMGetNamedValue(LLVMModuleRef M,\n+                                          const char* Name) {\n+    return wrap(unwrap(M)->getNamedValue(Name));\n+}\n+\n extern \"C\" LLVMValueRef LLVMGetOrInsertFunction(LLVMModuleRef M,\n                                                 const char* Name,\n                                                 LLVMTypeRef FunctionTy) {\n   return wrap(unwrap(M)->getOrInsertFunction(Name,\n                                              unwrap<FunctionType>(FunctionTy)));\n }\n \n+extern \"C\" LLVMValueRef LLVMGetOrInsertGlobal(LLVMModuleRef M,\n+                                              const char* Name,\n+                                              LLVMTypeRef Ty) {\n+  return wrap(unwrap(M)->getOrInsertGlobal(Name, unwrap(Ty)));\n+}\n+\n extern \"C\" LLVMTypeRef LLVMMetadataTypeInContext(LLVMContextRef C) {\n   return wrap(Type::getMetadataTy(*unwrap(C)));\n }"}, {"sha": "9fa4eafcad0ed9c8734efa1f9d8beabc5258f1d8", "filename": "src/test/compile-fail/dupe-symbols-1.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-1.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+#![crate_type=\"rlib\"]\n+#![allow(warnings)]\n+\n+#[export_name=\"fail\"]\n+pub fn a() {\n+}\n+\n+#[export_name=\"fail\"]\n+pub fn b() {\n+//~^ symbol `fail` is already defined\n+}"}, {"sha": "976a65589b86991ee7102d125361434a9f39da0a", "filename": "src/test/compile-fail/dupe-symbols-2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-2.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+#![crate_type=\"rlib\"]\n+#![allow(warnings)]\n+\n+mod a {\n+    #[no_mangle]\n+    pub extern fn fail() {\n+    }\n+}\n+\n+mod b {\n+    #[no_mangle]\n+    pub extern fn fail() {\n+    //~^ symbol `fail` is already defined\n+    }\n+}"}, {"sha": "98a61c33c584ab929c4324b3df7b665b48538ac3", "filename": "src/test/compile-fail/dupe-symbols-3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-3.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+#![crate_type=\"rlib\"]\n+#![allow(warnings)]\n+\n+#[export_name=\"fail\"]\n+pub fn a() {\n+}\n+\n+#[no_mangle]\n+pub fn fail() {\n+//~^ symbol `fail` is already defined\n+}"}, {"sha": "9e730699d2514339f4a5b669aafdb094993d0986", "filename": "src/test/compile-fail/dupe-symbols-4.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-4.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// error-pattern: symbol `fail` is already defined\n+#![crate_type=\"rlib\"]\n+#![allow(warnings)]\n+\n+\n+pub trait A {\n+    fn fail(self);\n+}\n+\n+struct B;\n+struct C;\n+\n+impl A for B {\n+    #[no_mangle]\n+    fn fail(self) {}\n+}\n+\n+impl A for C {\n+    #[no_mangle]\n+    fn fail(self) {}\n+}"}, {"sha": "eb4b50d03ca65e370a324b2fc06cd5097736b186", "filename": "src/test/compile-fail/dupe-symbols-5.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-5.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+#![crate_type=\"rlib\"]\n+#![allow(warnings)]\n+\n+#[export_name=\"fail\"]\n+static HELLO: u8 = 0;\n+\n+#[export_name=\"fail\"]\n+pub fn b() {\n+//~^ symbol `fail` is already defined\n+}"}, {"sha": "6f412d9a0de15fa47e90c98c5abcc3a52b45b11d", "filename": "src/test/compile-fail/dupe-symbols-6.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-6.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![crate_type=\"rlib\"]\n+#![allow(warnings)]\n+\n+#[export_name=\"fail\"]\n+static HELLO: u8 = 0;\n+\n+#[export_name=\"fail\"]\n+static HELLO_TWICE: u16 = 0;\n+//~^ symbol `fail` is already defined"}, {"sha": "c2880ba6f51e9f7f1c21caccb08ab8d8d596e5fd", "filename": "src/test/compile-fail/dupe-symbols-7.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-7.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// error-pattern: entry symbol `main` defined multiple times\n+#![allow(warnings)]\n+\n+#[no_mangle]\n+fn main(){}"}, {"sha": "da1e15d826d997b167ab1aaf7c40b29f918e170c", "filename": "src/test/run-pass/issue-15562.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Ftest%2Frun-pass%2Fissue-15562.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5afa2704a6fdee62b267a5df9ca0934350dfc3d1/src%2Ftest%2Frun-pass%2Fissue-15562.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15562.rs?ref=5afa2704a6fdee62b267a5df9ca0934350dfc3d1", "patch": "@@ -15,9 +15,6 @@\n extern crate issue_15562 as i;\n \n pub fn main() {\n-    extern {\n-        fn transmute();\n-    }\n     unsafe {\n         transmute();\n         i::transmute();"}]}