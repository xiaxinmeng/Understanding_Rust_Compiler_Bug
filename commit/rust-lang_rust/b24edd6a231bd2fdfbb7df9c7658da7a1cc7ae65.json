{"sha": "b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNGVkZDZhMjMxYmQyZmRmYmI3ZGY5Yzc2NThkYTdhMWNjN2FlNjU=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-06-15T11:05:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-15T11:05:50Z"}, "message": "Merge pull request #24 from oli-obk/typesafe_fn_calls\n\nTypesafe fn calls", "tree": {"sha": "0110ded0ec545c9c2690d3f047e0abf0198e3583", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0110ded0ec545c9c2690d3f047e0abf0198e3583"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65", "html_url": "https://github.com/rust-lang/rust/commit/b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "114650418439bb4a7d0bc17f0f50cee125686337", "url": "https://api.github.com/repos/rust-lang/rust/commits/114650418439bb4a7d0bc17f0f50cee125686337", "html_url": "https://github.com/rust-lang/rust/commit/114650418439bb4a7d0bc17f0f50cee125686337"}, {"sha": "c36dcff0056a4a48651b778ed272aba80f6edd93", "url": "https://api.github.com/repos/rust-lang/rust/commits/c36dcff0056a4a48651b778ed272aba80f6edd93", "html_url": "https://github.com/rust-lang/rust/commit/c36dcff0056a4a48651b778ed272aba80f6edd93"}], "stats": {"total": 170, "additions": 100, "deletions": 70}, "files": [{"sha": "35a978f2d2ea043965c943e31cee16ab833d81ae", "filename": "src/error.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65", "patch": "@@ -1,10 +1,12 @@\n use std::error::Error;\n use std::fmt;\n use rustc::mir::repr as mir;\n+use rustc::ty::BareFnTy;\n use memory::Pointer;\n \n #[derive(Clone, Debug)]\n-pub enum EvalError {\n+pub enum EvalError<'tcx> {\n+    FunctionPointerTyMismatch(&'tcx BareFnTy<'tcx>, &'tcx BareFnTy<'tcx>),\n     DanglingPointerDeref,\n     InvalidFunctionPointer,\n     InvalidBool,\n@@ -24,11 +26,13 @@ pub enum EvalError {\n     ExecuteMemory,\n }\n \n-pub type EvalResult<T> = Result<T, EvalError>;\n+pub type EvalResult<'tcx, T> = Result<T, EvalError<'tcx>>;\n \n-impl Error for EvalError {\n+impl<'tcx> Error for EvalError<'tcx> {\n     fn description(&self) -> &str {\n         match *self {\n+            EvalError::FunctionPointerTyMismatch(..) =>\n+                \"tried to call a function through a function pointer of a different type\",\n             EvalError::DanglingPointerDeref =>\n                 \"dangling pointer was dereferenced\",\n             EvalError::InvalidFunctionPointer =>\n@@ -60,13 +64,15 @@ impl Error for EvalError {\n     fn cause(&self) -> Option<&Error> { None }\n }\n \n-impl fmt::Display for EvalError {\n+impl<'tcx> fmt::Display for EvalError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             EvalError::PointerOutOfBounds { ptr, size, allocation_size } => {\n                 write!(f, \"memory access of {}..{} outside bounds of allocation {} which has size {}\",\n                        ptr.offset, ptr.offset + size, ptr.alloc_id, allocation_size)\n             },\n+            EvalError::FunctionPointerTyMismatch(expected, got) =>\n+                write!(f, \"tried to call a function of type {:?} through a function pointer of type {:?}\", expected, got),\n             _ => write!(f, \"{}\", self.description()),\n         }\n     }"}, {"sha": "5b2428d20c8c87bf5c21c50e7aa10486b6aae4d1", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65", "patch": "@@ -18,14 +18,14 @@ use syntax::attr;\n use syntax::codemap::{self, DUMMY_SP, Span};\n \n use error::{EvalError, EvalResult};\n-use memory::{Memory, Pointer};\n+use memory::{Memory, Pointer, FunctionDefinition};\n use primval::{self, PrimVal};\n \n use std::collections::HashMap;\n \n mod stepper;\n \n-pub fn step<'ecx, 'a: 'ecx, 'tcx: 'a>(ecx: &'ecx mut EvalContext<'a, 'tcx>) -> EvalResult<bool> {\n+pub fn step<'ecx, 'a: 'ecx, 'tcx: 'a>(ecx: &'ecx mut EvalContext<'a, 'tcx>) -> EvalResult<'tcx, bool> {\n     stepper::Stepper::new(ecx).step()\n }\n \n@@ -163,7 +163,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     // TODO(solson): Try making const_to_primval instead.\n-    fn const_to_ptr(&mut self, const_val: &const_val::ConstVal) -> EvalResult<Pointer> {\n+    fn const_to_ptr(&mut self, const_val: &const_val::ConstVal) -> EvalResult<'tcx, Pointer> {\n         use rustc::middle::const_val::ConstVal::*;\n         match *const_val {\n             Float(_f) => unimplemented!(),\n@@ -372,7 +372,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn eval_terminator(&mut self, terminator: &mir::Terminator<'tcx>)\n-            -> EvalResult<()> {\n+            -> EvalResult<'tcx, ()> {\n         use rustc::mir::repr::TerminatorKind::*;\n         match terminator.kind {\n             Return => self.pop_stack_frame(),\n@@ -438,7 +438,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let ptr = self.eval_operand(func)?;\n                         assert_eq!(ptr.offset, 0);\n                         let fn_ptr = self.memory.read_ptr(ptr)?;\n-                        let (def_id, substs) = self.memory.get_fn(fn_ptr.alloc_id)?;\n+                        let FunctionDefinition { def_id, substs, fn_ty } = self.memory.get_fn(fn_ptr.alloc_id)?;\n+                        if fn_ty != bare_fn_ty {\n+                            return Err(EvalError::FunctionPointerTyMismatch(fn_ty, bare_fn_ty));\n+                        }\n                         self.eval_fn_call(def_id, substs, bare_fn_ty, return_ptr, args,\n                                           terminator.source_info.span)?\n                     },\n@@ -484,7 +487,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         return_ptr: Option<Pointer>,\n         args: &[mir::Operand<'tcx>],\n         span: Span,\n-    ) -> EvalResult<()> {\n+    ) -> EvalResult<'tcx, ()> {\n         use syntax::abi::Abi;\n         match fn_ty.abi {\n             Abi::RustIntrinsic => {\n@@ -563,7 +566,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn drop(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<()> {\n+    fn drop(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n         if !self.type_needs_drop(ty) {\n             debug!(\"no need to drop {:?}\", ty);\n             return Ok(());\n@@ -605,7 +608,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<u64> {\n+    fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u64> {\n         use rustc::ty::layout::Layout::*;\n         let adt_layout = self.type_layout(adt_ty);\n \n@@ -633,7 +636,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(discr_val)\n     }\n \n-    fn read_nonnull_discriminant_value(&self, ptr: Pointer, nndiscr: u64) -> EvalResult<u64> {\n+    fn read_nonnull_discriminant_value(&self, ptr: Pointer, nndiscr: u64) -> EvalResult<'tcx, u64> {\n         let not_null = match self.memory.read_usize(ptr) {\n             Ok(0) => false,\n             Ok(_) | Err(EvalError::ReadPointerAsBytes) => true,\n@@ -650,7 +653,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         args: &[mir::Operand<'tcx>],\n         dest: Pointer,\n         dest_size: usize\n-    ) -> EvalResult<()> {\n+    ) -> EvalResult<'tcx, ()> {\n         let args_res: EvalResult<Vec<Pointer>> = args.iter()\n             .map(|arg| self.eval_operand(arg))\n             .collect();\n@@ -796,7 +799,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         args: &[mir::Operand<'tcx>],\n         dest: Pointer,\n         dest_size: usize,\n-    ) -> EvalResult<()> {\n+    ) -> EvalResult<'tcx, ()> {\n         let name = self.tcx.item_name(def_id);\n         let attrs = self.tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n@@ -859,7 +862,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest: Pointer,\n         offsets: I,\n         operands: &[mir::Operand<'tcx>],\n-    ) -> EvalResult<()> {\n+    ) -> EvalResult<'tcx, ()> {\n         for (offset, operand) in offsets.into_iter().zip(operands) {\n             let src = self.eval_operand(operand)?;\n             let src_ty = self.operand_ty(operand);\n@@ -870,7 +873,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn eval_assignment(&mut self, lvalue: &mir::Lvalue<'tcx>, rvalue: &mir::Rvalue<'tcx>)\n-        -> EvalResult<()>\n+        -> EvalResult<'tcx, ()>\n     {\n         let dest = self.eval_lvalue(lvalue)?.to_ptr();\n         let dest_ty = self.lvalue_ty(lvalue);\n@@ -1099,8 +1102,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n \n                     ReifyFnPointer => match self.operand_ty(operand).sty {\n-                        ty::TyFnDef(def_id, substs, _) => {\n-                            let fn_ptr = self.memory.create_fn_ptr(def_id, substs);\n+                        ty::TyFnDef(def_id, substs, fn_ty) => {\n+                            let fn_ptr = self.memory.create_fn_ptr(def_id, substs, fn_ty);\n                             self.memory.write_ptr(dest, fn_ptr)?;\n                         },\n                         ref other => panic!(\"reify fn pointer on {:?}\", other),\n@@ -1116,7 +1119,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn nonnull_offset(&self, ty: Ty<'tcx>, nndiscr: u64, discrfield: &[u32]) -> EvalResult<Size> {\n+    fn nonnull_offset(&self, ty: Ty<'tcx>, nndiscr: u64, discrfield: &[u32]) -> EvalResult<'tcx, Size> {\n         // Skip the constant 0 at the start meant for LLVM GEP.\n         let mut path = discrfield.iter().skip(1).map(|&i| i as usize);\n \n@@ -1137,7 +1140,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.field_path_offset(inner_ty, path)\n     }\n \n-    fn field_path_offset<I: Iterator<Item = usize>>(&self, mut ty: Ty<'tcx>, path: I) -> EvalResult<Size> {\n+    fn field_path_offset<I: Iterator<Item = usize>>(&self, mut ty: Ty<'tcx>, path: I) -> EvalResult<'tcx, Size> {\n         let mut offset = Size::from_bytes(0);\n \n         // Skip the initial 0 intended for LLVM GEP.\n@@ -1150,7 +1153,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(offset)\n     }\n \n-    fn get_field_ty(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<Ty<'tcx>> {\n+    fn get_field_ty(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, Ty<'tcx>> {\n         match ty.sty {\n             ty::TyStruct(adt_def, substs) => {\n                 Ok(adt_def.struct_variant().fields[field_index].ty(self.tcx, substs))\n@@ -1166,7 +1169,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn get_field_offset(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<Size> {\n+    fn get_field_offset(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, Size> {\n         let layout = self.type_layout(ty);\n \n         use rustc::ty::layout::Layout::*;\n@@ -1183,7 +1186,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<Pointer> {\n+    fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Pointer> {\n         use rustc::mir::repr::Operand::*;\n         match *op {\n             Consume(ref lvalue) => Ok(self.eval_lvalue(lvalue)?.to_ptr()),\n@@ -1217,7 +1220,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn eval_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<Lvalue> {\n+    fn eval_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue> {\n         use rustc::mir::repr::Lvalue::*;\n         let ptr = match *lvalue {\n             ReturnPointer => self.frame().return_ptr\n@@ -1325,7 +1328,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.monomorphize(self.mir().operand_ty(self.tcx, operand), self.substs())\n     }\n \n-    fn move_(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<()> {\n+    fn move_(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n         let size = self.type_size(ty);\n         self.memory.copy(src, dest, size)?;\n         if self.type_needs_drop(ty) {\n@@ -1334,7 +1337,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn read_primval(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<PrimVal> {\n+    pub fn read_primval(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         use syntax::ast::{IntTy, UintTy};\n         let val = match (self.memory.pointer_size, &ty.sty) {\n             (_, &ty::TyBool)              => PrimVal::Bool(self.memory.read_bool(ptr)?),"}, {"sha": "367119438411482f0a4f5af7b6d38ce358dbc774", "filename": "src/interpreter/stepper.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65/src%2Finterpreter%2Fstepper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65/src%2Finterpreter%2Fstepper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstepper.rs?ref=b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65", "patch": "@@ -23,15 +23,15 @@ impl<'ecx, 'a, 'tcx> Stepper<'ecx, 'a, 'tcx> {\n         }\n     }\n \n-    fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> EvalResult<()> {\n+    fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> EvalResult<'tcx, ()> {\n         trace!(\"{:?}\", stmt);\n         let mir::StatementKind::Assign(ref lvalue, ref rvalue) = stmt.kind;\n         self.ecx.eval_assignment(lvalue, rvalue)?;\n         self.ecx.frame_mut().stmt += 1;\n         Ok(())\n     }\n \n-    fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<()> {\n+    fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<'tcx, ()> {\n         // after a terminator we go to a new block\n         self.ecx.frame_mut().stmt = 0;\n         trace!(\"{:?}\", terminator.kind);\n@@ -43,7 +43,7 @@ impl<'ecx, 'a, 'tcx> Stepper<'ecx, 'a, 'tcx> {\n     }\n \n     // returns true as long as there are more things to do\n-    pub(super) fn step(&mut self) -> EvalResult<bool> {\n+    pub(super) fn step(&mut self) -> EvalResult<'tcx, bool> {\n         if self.ecx.stack.is_empty() {\n             return Ok(false);\n         }"}, {"sha": "e20d92207dbf2fe06a46daf10b58f44da1159e81", "filename": "src/memory.rs", "status": "modified", "additions": 49, "deletions": 37, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65", "patch": "@@ -4,6 +4,7 @@ use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n use std::{fmt, iter, mem, ptr};\n \n use rustc::hir::def_id::DefId;\n+use rustc::ty::BareFnTy;\n use rustc::ty::subst::Substs;\n \n use error::{EvalError, EvalResult};\n@@ -41,6 +42,13 @@ impl Pointer {\n     }\n }\n \n+#[derive(Debug, Copy, Clone)]\n+pub struct FunctionDefinition<'tcx> {\n+    pub def_id: DefId,\n+    pub substs: &'tcx Substs<'tcx>,\n+    pub fn_ty: &'tcx BareFnTy<'tcx>,\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Top-level interpreter memory\n ////////////////////////////////////////////////////////////////////////////////\n@@ -50,7 +58,7 @@ pub struct Memory<'tcx> {\n     alloc_map: HashMap<AllocId, Allocation>,\n     /// Function \"allocations\". They exist solely so pointers have something to point to, and\n     /// we can figure out what they point to.\n-    functions: HashMap<AllocId, (DefId, &'tcx Substs<'tcx>)>,\n+    functions: HashMap<AllocId, FunctionDefinition<'tcx>>,\n     next_id: AllocId,\n     pub pointer_size: usize,\n }\n@@ -68,11 +76,15 @@ impl<'tcx> Memory<'tcx> {\n \n     // FIXME: never create two pointers to the same def_id + substs combination\n     // maybe re-use the statics cache of the EvalContext?\n-    pub fn create_fn_ptr(&mut self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> Pointer {\n+    pub fn create_fn_ptr(&mut self, def_id: DefId, substs: &'tcx Substs<'tcx>, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n         let id = self.next_id;\n         debug!(\"creating fn ptr: {}\", id);\n         self.next_id.0 += 1;\n-        self.functions.insert(id, (def_id, substs));\n+        self.functions.insert(id, FunctionDefinition {\n+            def_id: def_id,\n+            substs: substs,\n+            fn_ty: fn_ty,\n+        });\n         Pointer {\n             alloc_id: id,\n             offset: 0,\n@@ -96,7 +108,7 @@ impl<'tcx> Memory<'tcx> {\n \n     // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n     // when reallocating/deallocating any others.\n-    pub fn reallocate(&mut self, ptr: Pointer, new_size: usize) -> EvalResult<()> {\n+    pub fn reallocate(&mut self, ptr: Pointer, new_size: usize) -> EvalResult<'tcx, ()> {\n         if ptr.offset != 0 {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n@@ -120,7 +132,7 @@ impl<'tcx> Memory<'tcx> {\n     }\n \n     // TODO(solson): See comment on `reallocate`.\n-    pub fn deallocate(&mut self, ptr: Pointer) -> EvalResult<()> {\n+    pub fn deallocate(&mut self, ptr: Pointer) -> EvalResult<'tcx, ()> {\n         if ptr.offset != 0 {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n@@ -139,7 +151,7 @@ impl<'tcx> Memory<'tcx> {\n     // Allocation accessors\n     ////////////////////////////////////////////////////////////////////////////////\n \n-    pub fn get(&self, id: AllocId) -> EvalResult<&Allocation> {\n+    pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n         match self.alloc_map.get(&id) {\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n@@ -149,7 +161,7 @@ impl<'tcx> Memory<'tcx> {\n         }\n     }\n \n-    pub fn get_mut(&mut self, id: AllocId) -> EvalResult<&mut Allocation> {\n+    pub fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation> {\n         match self.alloc_map.get_mut(&id) {\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n@@ -159,7 +171,7 @@ impl<'tcx> Memory<'tcx> {\n         }\n     }\n \n-    pub fn get_fn(&self, id: AllocId) -> EvalResult<(DefId, &'tcx Substs<'tcx>)> {\n+    pub fn get_fn(&self, id: AllocId) -> EvalResult<'tcx, FunctionDefinition<'tcx>> {\n         debug!(\"reading fn ptr: {}\", id);\n         match self.functions.get(&id) {\n             Some(&fn_id) => Ok(fn_id),\n@@ -229,7 +241,7 @@ impl<'tcx> Memory<'tcx> {\n     // Byte accessors\n     ////////////////////////////////////////////////////////////////////////////////\n \n-    fn get_bytes_unchecked(&self, ptr: Pointer, size: usize) -> EvalResult<&[u8]> {\n+    fn get_bytes_unchecked(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &[u8]> {\n         let alloc = self.get(ptr.alloc_id)?;\n         if ptr.offset + size > alloc.bytes.len() {\n             return Err(EvalError::PointerOutOfBounds {\n@@ -241,7 +253,7 @@ impl<'tcx> Memory<'tcx> {\n         Ok(&alloc.bytes[ptr.offset..ptr.offset + size])\n     }\n \n-    fn get_bytes_unchecked_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<&mut [u8]> {\n+    fn get_bytes_unchecked_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &mut [u8]> {\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         if ptr.offset + size > alloc.bytes.len() {\n             return Err(EvalError::PointerOutOfBounds {\n@@ -253,15 +265,15 @@ impl<'tcx> Memory<'tcx> {\n         Ok(&mut alloc.bytes[ptr.offset..ptr.offset + size])\n     }\n \n-    fn get_bytes(&self, ptr: Pointer, size: usize) -> EvalResult<&[u8]> {\n+    fn get_bytes(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &[u8]> {\n         if self.relocations(ptr, size)?.count() != 0 {\n             return Err(EvalError::ReadPointerAsBytes);\n         }\n         self.check_defined(ptr, size)?;\n         self.get_bytes_unchecked(ptr, size)\n     }\n \n-    fn get_bytes_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<&mut [u8]> {\n+    fn get_bytes_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &mut [u8]> {\n         self.clear_relocations(ptr, size)?;\n         self.mark_definedness(ptr, size, true)?;\n         self.get_bytes_unchecked_mut(ptr, size)\n@@ -271,7 +283,7 @@ impl<'tcx> Memory<'tcx> {\n     // Reading and writing\n     ////////////////////////////////////////////////////////////////////////////////\n \n-    pub fn copy(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<()> {\n+    pub fn copy(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n         self.check_relocation_edges(src, size)?;\n \n         let src_bytes = self.get_bytes_unchecked_mut(src, size)?.as_mut_ptr();\n@@ -294,27 +306,27 @@ impl<'tcx> Memory<'tcx> {\n         Ok(())\n     }\n \n-    pub fn read_bytes(&self, ptr: Pointer, size: usize) -> EvalResult<&[u8]> {\n+    pub fn read_bytes(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &[u8]> {\n         self.get_bytes(ptr, size)\n     }\n \n-    pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<()> {\n+    pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx, ()> {\n         let bytes = self.get_bytes_mut(ptr, src.len())?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n \n-    pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: usize) -> EvalResult<()> {\n+    pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: usize) -> EvalResult<'tcx, ()> {\n         let bytes = self.get_bytes_mut(ptr, count)?;\n         for b in bytes { *b = val; }\n         Ok(())\n     }\n \n-    pub fn drop_fill(&mut self, ptr: Pointer, size: usize) -> EvalResult<()> {\n+    pub fn drop_fill(&mut self, ptr: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n         self.write_repeat(ptr, mem::POST_DROP_U8, size)\n     }\n \n-    pub fn read_ptr(&self, ptr: Pointer) -> EvalResult<Pointer> {\n+    pub fn read_ptr(&self, ptr: Pointer) -> EvalResult<'tcx, Pointer> {\n         let size = self.pointer_size;\n         self.check_defined(ptr, size)?;\n         let offset = self.get_bytes_unchecked(ptr, size)?\n@@ -326,7 +338,7 @@ impl<'tcx> Memory<'tcx> {\n         }\n     }\n \n-    pub fn write_ptr(&mut self, dest: Pointer, ptr: Pointer) -> EvalResult<()> {\n+    pub fn write_ptr(&mut self, dest: Pointer, ptr: Pointer) -> EvalResult<'tcx, ()> {\n         {\n             let size = self.pointer_size;\n             let mut bytes = self.get_bytes_mut(dest, size)?;\n@@ -336,7 +348,7 @@ impl<'tcx> Memory<'tcx> {\n         Ok(())\n     }\n \n-    pub fn write_primval(&mut self, ptr: Pointer, val: PrimVal) -> EvalResult<()> {\n+    pub fn write_primval(&mut self, ptr: Pointer, val: PrimVal) -> EvalResult<'tcx, ()> {\n         let pointer_size = self.pointer_size;\n         match val {\n             PrimVal::Bool(b) => self.write_bool(ptr, b),\n@@ -353,7 +365,7 @@ impl<'tcx> Memory<'tcx> {\n         }\n     }\n \n-    pub fn read_bool(&self, ptr: Pointer) -> EvalResult<bool> {\n+    pub fn read_bool(&self, ptr: Pointer) -> EvalResult<'tcx, bool> {\n         let bytes = self.get_bytes(ptr, 1)?;\n         match bytes[0] {\n             0 => Ok(false),\n@@ -362,40 +374,40 @@ impl<'tcx> Memory<'tcx> {\n         }\n     }\n \n-    pub fn write_bool(&mut self, ptr: Pointer, b: bool) -> EvalResult<()> {\n+    pub fn write_bool(&mut self, ptr: Pointer, b: bool) -> EvalResult<'tcx, ()> {\n         self.get_bytes_mut(ptr, 1).map(|bytes| bytes[0] = b as u8)\n     }\n \n-    pub fn read_int(&self, ptr: Pointer, size: usize) -> EvalResult<i64> {\n+    pub fn read_int(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, i64> {\n         self.get_bytes(ptr, size).map(|mut b| b.read_int::<NativeEndian>(size).unwrap())\n     }\n \n-    pub fn write_int(&mut self, ptr: Pointer, n: i64, size: usize) -> EvalResult<()> {\n+    pub fn write_int(&mut self, ptr: Pointer, n: i64, size: usize) -> EvalResult<'tcx, ()> {\n         self.get_bytes_mut(ptr, size).map(|mut b| b.write_int::<NativeEndian>(n, size).unwrap())\n     }\n \n-    pub fn read_uint(&self, ptr: Pointer, size: usize) -> EvalResult<u64> {\n+    pub fn read_uint(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, u64> {\n         self.get_bytes(ptr, size).map(|mut b| b.read_uint::<NativeEndian>(size).unwrap())\n     }\n \n-    pub fn write_uint(&mut self, ptr: Pointer, n: u64, size: usize) -> EvalResult<()> {\n+    pub fn write_uint(&mut self, ptr: Pointer, n: u64, size: usize) -> EvalResult<'tcx, ()> {\n         self.get_bytes_mut(ptr, size).map(|mut b| b.write_uint::<NativeEndian>(n, size).unwrap())\n     }\n \n-    pub fn read_isize(&self, ptr: Pointer) -> EvalResult<i64> {\n+    pub fn read_isize(&self, ptr: Pointer) -> EvalResult<'tcx, i64> {\n         self.read_int(ptr, self.pointer_size)\n     }\n \n-    pub fn write_isize(&mut self, ptr: Pointer, n: i64) -> EvalResult<()> {\n+    pub fn write_isize(&mut self, ptr: Pointer, n: i64) -> EvalResult<'tcx, ()> {\n         let size = self.pointer_size;\n         self.write_int(ptr, n, size)\n     }\n \n-    pub fn read_usize(&self, ptr: Pointer) -> EvalResult<u64> {\n+    pub fn read_usize(&self, ptr: Pointer) -> EvalResult<'tcx, u64> {\n         self.read_uint(ptr, self.pointer_size)\n     }\n \n-    pub fn write_usize(&mut self, ptr: Pointer, n: u64) -> EvalResult<()> {\n+    pub fn write_usize(&mut self, ptr: Pointer, n: u64) -> EvalResult<'tcx, ()> {\n         let size = self.pointer_size;\n         self.write_uint(ptr, n, size)\n     }\n@@ -405,14 +417,14 @@ impl<'tcx> Memory<'tcx> {\n     ////////////////////////////////////////////////////////////////////////////////\n \n     fn relocations(&self, ptr: Pointer, size: usize)\n-        -> EvalResult<btree_map::Range<usize, AllocId>>\n+        -> EvalResult<'tcx, btree_map::Range<usize, AllocId>>\n     {\n         let start = ptr.offset.saturating_sub(self.pointer_size - 1);\n         let end = ptr.offset + size;\n         Ok(self.get(ptr.alloc_id)?.relocations.range(Included(&start), Excluded(&end)))\n     }\n \n-    fn clear_relocations(&mut self, ptr: Pointer, size: usize) -> EvalResult<()> {\n+    fn clear_relocations(&mut self, ptr: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n         // Find all relocations overlapping the given range.\n         let keys: Vec<_> = self.relocations(ptr, size)?.map(|(&k, _)| k).collect();\n         if keys.is_empty() { return Ok(()); }\n@@ -436,7 +448,7 @@ impl<'tcx> Memory<'tcx> {\n         Ok(())\n     }\n \n-    fn check_relocation_edges(&self, ptr: Pointer, size: usize) -> EvalResult<()> {\n+    fn check_relocation_edges(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n         let overlapping_start = self.relocations(ptr, 0)?.count();\n         let overlapping_end = self.relocations(ptr.offset(size as isize), 0)?.count();\n         if overlapping_start + overlapping_end != 0 {\n@@ -445,7 +457,7 @@ impl<'tcx> Memory<'tcx> {\n         Ok(())\n     }\n \n-    fn copy_relocations(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<()> {\n+    fn copy_relocations(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n         let relocations: Vec<_> = self.relocations(src, size)?\n             .map(|(&offset, &alloc_id)| {\n                 // Update relocation offsets for the new positions in the destination allocation.\n@@ -461,7 +473,7 @@ impl<'tcx> Memory<'tcx> {\n     ////////////////////////////////////////////////////////////////////////////////\n \n     // FIXME(solson): This is a very naive, slow version.\n-    fn copy_undef_mask(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<()> {\n+    fn copy_undef_mask(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n         let mut v = Vec::with_capacity(size);\n         for i in 0..size {\n@@ -474,7 +486,7 @@ impl<'tcx> Memory<'tcx> {\n         Ok(())\n     }\n \n-    fn check_defined(&self, ptr: Pointer, size: usize) -> EvalResult<()> {\n+    fn check_defined(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n         let alloc = self.get(ptr.alloc_id)?;\n         if !alloc.undef_mask.is_range_defined(ptr.offset, ptr.offset + size) {\n             return Err(EvalError::ReadUndefBytes);\n@@ -483,7 +495,7 @@ impl<'tcx> Memory<'tcx> {\n     }\n \n     pub fn mark_definedness(&mut self, ptr: Pointer, size: usize, new_state: bool)\n-        -> EvalResult<()>\n+        -> EvalResult<'tcx, ()>\n     {\n         let mut alloc = self.get_mut(ptr.alloc_id)?;\n         alloc.undef_mask.set_range(ptr.offset, ptr.offset + size, new_state);"}, {"sha": "5e1cdac45a1fb2fd68e3fd1818e85f0c3c6fa471", "filename": "src/primval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65", "patch": "@@ -13,7 +13,7 @@ pub enum PrimVal {\n     IntegerPtr(u64),\n }\n \n-pub fn binary_op(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResult<PrimVal> {\n+pub fn binary_op<'tcx>(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResult<'tcx, PrimVal> {\n     use rustc::mir::repr::BinOp::*;\n     use self::PrimVal::*;\n \n@@ -43,7 +43,7 @@ pub fn binary_op(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResul\n         })\n     }\n \n-    fn unrelated_ptr_ops(bin_op: mir::BinOp) -> EvalResult<PrimVal> {\n+    fn unrelated_ptr_ops<'tcx>(bin_op: mir::BinOp) -> EvalResult<'tcx, PrimVal> {\n         use rustc::mir::repr::BinOp::*;\n         match bin_op {\n             Eq => Ok(Bool(false)),\n@@ -108,7 +108,7 @@ pub fn binary_op(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResul\n     Ok(val)\n }\n \n-pub fn unary_op(un_op: mir::UnOp, val: PrimVal) -> EvalResult<PrimVal> {\n+pub fn unary_op<'tcx>(un_op: mir::UnOp, val: PrimVal) -> EvalResult<'tcx, PrimVal> {\n     use rustc::mir::repr::UnOp::*;\n     use self::PrimVal::*;\n     match (un_op, val) {"}, {"sha": "db87e9e422bd86f9f5381b797824a18071ff996d", "filename": "tests/compile-fail/cast_fn_ptr.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr.rs?ref=b24edd6a231bd2fdfbb7df9c7658da7a1cc7ae65", "patch": "@@ -0,0 +1,9 @@\n+fn main() { //~ ERROR tried to call a function of type\n+    fn f() {}\n+\n+    let g = unsafe {\n+        std::mem::transmute::<fn(), fn(i32)>(f)\n+    };\n+\n+    g(42)\n+}"}]}