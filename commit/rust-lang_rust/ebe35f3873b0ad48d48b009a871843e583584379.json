{"sha": "ebe35f3873b0ad48d48b009a871843e583584379", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViZTM1ZjM4NzNiMGFkNDhkNDhiMDA5YTg3MTg0M2U1ODM1ODQzNzk=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-05-07T03:29:54Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-05-07T03:56:36Z"}, "message": "remove borrowck workarounds from the containers", "tree": {"sha": "889cc1a5242c6d24f4371967d03673d16a991b39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/889cc1a5242c6d24f4371967d03673d16a991b39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebe35f3873b0ad48d48b009a871843e583584379", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebe35f3873b0ad48d48b009a871843e583584379", "html_url": "https://github.com/rust-lang/rust/commit/ebe35f3873b0ad48d48b009a871843e583584379", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebe35f3873b0ad48d48b009a871843e583584379/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b6864f2195250d34cbedf92ffaf23a400c71b9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b6864f2195250d34cbedf92ffaf23a400c71b9e", "html_url": "https://github.com/rust-lang/rust/commit/4b6864f2195250d34cbedf92ffaf23a400c71b9e"}], "stats": {"total": 93, "additions": 87, "deletions": 6}, "files": [{"sha": "4ec2e911bf86269d26f46ca3f52a192b56bff414", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 75, "deletions": 3, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ebe35f3873b0ad48d48b009a871843e583584379/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe35f3873b0ad48d48b009a871843e583584379/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=ebe35f3873b0ad48d48b009a871843e583584379", "patch": "@@ -347,16 +347,27 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Return a mutable reference to the value corresponding to the key\n+    #[cfg(stage0)]\n     fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n         let idx = match self.bucket_for_key(k) {\n             FoundEntry(idx) => idx,\n             TableFull | FoundHole(_) => return None\n         };\n-        unsafe {  // FIXME(#4903)---requires flow-sensitive borrow checker\n+        unsafe {\n             Some(::cast::transmute_mut_region(self.mut_value_for_bucket(idx)))\n         }\n     }\n \n+    /// Return a mutable reference to the value corresponding to the key\n+    #[cfg(not(stage0))]\n+    fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n+        let idx = match self.bucket_for_key(k) {\n+            FoundEntry(idx) => idx,\n+            TableFull | FoundHole(_) => return None\n+        };\n+        Some(self.mut_value_for_bucket(idx))\n+    }\n+\n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n@@ -429,6 +440,7 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, or insert\n     /// and return the value if it doesn't exist.\n+    #[cfg(stage0)]\n     fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n@@ -452,13 +464,43 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n             },\n         };\n \n-        unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n+        unsafe {\n             ::cast::transmute_region(self.value_for_bucket(idx))\n         }\n     }\n \n+    /// Return the value corresponding to the key in the map, or insert\n+    /// and return the value if it doesn't exist.\n+    #[cfg(not(stage0))]\n+    fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a V {\n+        if self.size >= self.resize_at {\n+            // n.b.: We could also do this after searching, so\n+            // that we do not resize if this call to insert is\n+            // simply going to update a key in place.  My sense\n+            // though is that it's worse to have to search through\n+            // buckets to find the right spot twice than to just\n+            // resize in this corner case.\n+            self.expand();\n+        }\n+\n+        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n+            TableFull => fail!(~\"Internal logic error\"),\n+            FoundEntry(idx) => idx,\n+            FoundHole(idx) => {\n+                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n+                                     value: v});\n+                self.size += 1;\n+                idx\n+            },\n+        };\n+\n+        self.value_for_bucket(idx)\n+    }\n+\n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n+    #[cfg(stage0)]\n     fn find_or_insert_with<'a>(&'a mut self, k: K, f: &fn(&K) -> V) -> &'a V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n@@ -483,11 +525,41 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n             },\n         };\n \n-        unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n+        unsafe {\n             ::cast::transmute_region(self.value_for_bucket(idx))\n         }\n     }\n \n+    /// Return the value corresponding to the key in the map, or create,\n+    /// insert, and return a new value if it doesn't exist.\n+    #[cfg(not(stage0))]\n+    fn find_or_insert_with<'a>(&'a mut self, k: K, f: &fn(&K) -> V) -> &'a V {\n+        if self.size >= self.resize_at {\n+            // n.b.: We could also do this after searching, so\n+            // that we do not resize if this call to insert is\n+            // simply going to update a key in place.  My sense\n+            // though is that it's worse to have to search through\n+            // buckets to find the right spot twice than to just\n+            // resize in this corner case.\n+            self.expand();\n+        }\n+\n+        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n+            TableFull => fail!(~\"Internal logic error\"),\n+            FoundEntry(idx) => idx,\n+            FoundHole(idx) => {\n+                let v = f(&k);\n+                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n+                                     value: v});\n+                self.size += 1;\n+                idx\n+            },\n+        };\n+\n+        self.value_for_bucket(idx)\n+    }\n+\n     fn consume(&mut self, f: &fn(K, V)) {\n         let mut buckets = ~[];\n         self.buckets <-> buckets;"}, {"sha": "f6cd898e08afc9f87938c8843c137ffa464a7939", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ebe35f3873b0ad48d48b009a871843e583584379/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe35f3873b0ad48d48b009a871843e583584379/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=ebe35f3873b0ad48d48b009a871843e583584379", "patch": "@@ -276,9 +276,9 @@ fn chunk(n: uint, idx: uint) -> uint {\n     (n >> sh) & MASK\n }\n \n-fn find_mut<'r, T>(child: &'r mut Child<T>, key: uint, idx: uint)\n-                -> Option<&'r mut T> {\n-    unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n+#[cfg(stage0)]\n+fn find_mut<'r, T>(child: &'r mut Child<T>, key: uint, idx: uint) -> Option<&'r mut T> {\n+    unsafe {\n         (match *child {\n             External(_, ref value) => Some(cast::transmute_mut(value)),\n             Internal(ref x) => find_mut(cast::transmute_mut(&x.children[chunk(key, idx)]),\n@@ -288,6 +288,15 @@ fn find_mut<'r, T>(child: &'r mut Child<T>, key: uint, idx: uint)\n     }\n }\n \n+#[cfg(not(stage0))]\n+fn find_mut<'r, T>(child: &'r mut Child<T>, key: uint, idx: uint) -> Option<&'r mut T> {\n+    match *child {\n+        External(_, ref mut value) => Some(value),\n+        Internal(ref mut x) => find_mut(&mut x.children[chunk(key, idx)], key, idx + 1),\n+        Nothing => None\n+    }\n+}\n+\n fn insert<T>(count: &mut uint, child: &mut Child<T>, key: uint, value: T,\n              idx: uint) -> bool {\n     let mut tmp = Nothing;"}]}