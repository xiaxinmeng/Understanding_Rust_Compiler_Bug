{"sha": "9339241b78ef7474e88de37738bdbece7767d333", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzMzkyNDFiNzhlZjc0NzRlODhkZTM3NzM4YmRiZWNlNzc2N2QzMzM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-04-09T20:04:59Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-04-14T09:28:53Z"}, "message": "Some cleanup", "tree": {"sha": "c253d26db406b0f6cac5db67a054f4334b016486", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c253d26db406b0f6cac5db67a054f4334b016486"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9339241b78ef7474e88de37738bdbece7767d333", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9339241b78ef7474e88de37738bdbece7767d333", "html_url": "https://github.com/rust-lang/rust/commit/9339241b78ef7474e88de37738bdbece7767d333", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9339241b78ef7474e88de37738bdbece7767d333/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1ed53a4f183b5826162eb9e998207b92be9c57f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1ed53a4f183b5826162eb9e998207b92be9c57f", "html_url": "https://github.com/rust-lang/rust/commit/a1ed53a4f183b5826162eb9e998207b92be9c57f"}], "stats": {"total": 209, "additions": 111, "deletions": 98}, "files": [{"sha": "b28bb47c6f3d87668c9f704bc326e8a4ae363c75", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 99, "deletions": 90, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/9339241b78ef7474e88de37738bdbece7767d333/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9339241b78ef7474e88de37738bdbece7767d333/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=9339241b78ef7474e88de37738bdbece7767d333", "patch": "@@ -461,6 +461,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         for segment in &path.segments[remaining_index..] {\n             let ty = match resolved {\n                 Resolution::Def(def) => {\n+                    // FIXME resolve associated items from traits as well\n                     let typable: Option<TypableDef> = def.into();\n                     let typable = typable?;\n \n@@ -750,12 +751,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn substs_for_method_call(\n         &mut self,\n         def_generics: Option<Arc<GenericParams>>,\n-        generic_args: &Option<GenericArgs>,\n+        generic_args: Option<&GenericArgs>,\n         receiver_ty: &Ty,\n     ) -> Substs {\n         let (parent_param_count, param_count) =\n             def_generics.as_ref().map_or((0, 0), |g| (g.count_parent_params(), g.params.len()));\n         let mut substs = Vec::with_capacity(parent_param_count + param_count);\n+        // Parent arguments are unknown, except for the receiver type\n         if let Some(parent_generics) = def_generics.and_then(|p| p.parent_params.clone()) {\n             for param in &parent_generics.params {\n                 if param.name.as_known_name() == Some(crate::KnownName::SelfType) {\n@@ -785,6 +787,100 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         Substs(substs.into())\n     }\n \n+    fn register_obligations_for_call(&mut self, callable_ty: &Ty) {\n+        match callable_ty {\n+            Ty::Apply(a_ty) => match a_ty.ctor {\n+                TypeCtor::FnDef(def) => {\n+                    // add obligation for trait implementation, if this is a trait method\n+                    // FIXME also register obligations from where clauses from the trait or impl and method\n+                    match def {\n+                        CallableDef::Function(f) => {\n+                            if let Some(trait_) = f.parent_trait(self.db) {\n+                                // construct a TraitDef\n+                                let substs = a_ty.parameters.prefix(\n+                                    trait_.generic_params(self.db).count_params_including_parent(),\n+                                );\n+                                self.obligations\n+                                    .push(Obligation::Trait(TraitRef { trait_, substs }));\n+                            }\n+                        }\n+                        CallableDef::Struct(_) | CallableDef::EnumVariant(_) => {}\n+                    }\n+                }\n+                _ => {}\n+            },\n+            _ => {}\n+        }\n+    }\n+\n+    fn infer_method_call(\n+        &mut self,\n+        tgt_expr: ExprId,\n+        receiver: ExprId,\n+        args: &[ExprId],\n+        method_name: &Name,\n+        generic_args: Option<&GenericArgs>,\n+    ) -> Ty {\n+        let receiver_ty = self.infer_expr(receiver, &Expectation::none());\n+        let resolved = receiver_ty.clone().lookup_method(self.db, method_name, &self.resolver);\n+        let (derefed_receiver_ty, method_ty, def_generics) = match resolved {\n+            Some((ty, func)) => {\n+                self.write_method_resolution(tgt_expr, func);\n+                (\n+                    ty,\n+                    self.db.type_for_def(func.into(), Namespace::Values),\n+                    Some(func.generic_params(self.db)),\n+                )\n+            }\n+            None => (receiver_ty, Ty::Unknown, None),\n+        };\n+        let substs =\n+            self.substs_for_method_call(def_generics.clone(), generic_args, &derefed_receiver_ty);\n+        let method_ty = method_ty.apply_substs(substs);\n+        let method_ty = self.insert_type_vars(method_ty);\n+        self.register_obligations_for_call(&method_ty);\n+        let (expected_receiver_ty, param_tys, ret_ty) = match &method_ty {\n+            Ty::Apply(a_ty) => match a_ty.ctor {\n+                TypeCtor::FnPtr => {\n+                    let sig = FnSig::from_fn_ptr_substs(&a_ty.parameters);\n+                    if !sig.params().is_empty() {\n+                        (sig.params()[0].clone(), sig.params()[1..].to_vec(), sig.ret().clone())\n+                    } else {\n+                        (Ty::Unknown, Vec::new(), sig.ret().clone())\n+                    }\n+                }\n+                TypeCtor::FnDef(def) => {\n+                    let sig = self.db.callable_item_signature(def);\n+                    let ret_ty = sig.ret().clone().subst(&a_ty.parameters);\n+\n+                    if !sig.params().is_empty() {\n+                        let mut params_iter =\n+                            sig.params().iter().map(|ty| ty.clone().subst(&a_ty.parameters));\n+                        let receiver_ty = params_iter.next().unwrap();\n+                        (receiver_ty, params_iter.collect(), ret_ty)\n+                    } else {\n+                        (Ty::Unknown, Vec::new(), ret_ty)\n+                    }\n+                }\n+                _ => (Ty::Unknown, Vec::new(), Ty::Unknown),\n+            },\n+            _ => (Ty::Unknown, Vec::new(), Ty::Unknown),\n+        };\n+        // Apply autoref so the below unification works correctly\n+        // FIXME: return correct autorefs from lookup_method\n+        let actual_receiver_ty = match expected_receiver_ty.as_reference() {\n+            Some((_, mutability)) => Ty::apply_one(TypeCtor::Ref(mutability), derefed_receiver_ty),\n+            _ => derefed_receiver_ty,\n+        };\n+        self.unify(&expected_receiver_ty, &actual_receiver_ty);\n+\n+        let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n+        for (arg, param) in args.iter().zip(param_iter) {\n+            self.infer_expr(*arg, &Expectation::has_type(param));\n+        }\n+        ret_ty\n+    }\n+\n     fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n         let ty = match &body[tgt_expr] {\n@@ -872,95 +968,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n                 ret_ty\n             }\n-            Expr::MethodCall { receiver, args, method_name, generic_args } => {\n-                let receiver_ty = self.infer_expr(*receiver, &Expectation::none());\n-                let resolved =\n-                    receiver_ty.clone().lookup_method(self.db, method_name, &self.resolver);\n-                let (derefed_receiver_ty, method_ty, def_generics) = match resolved {\n-                    Some((ty, func)) => {\n-                        self.write_method_resolution(tgt_expr, func);\n-                        (\n-                            ty,\n-                            self.db.type_for_def(func.into(), Namespace::Values),\n-                            Some(func.generic_params(self.db)),\n-                        )\n-                    }\n-                    None => (receiver_ty, Ty::Unknown, None),\n-                };\n-                let substs = self.substs_for_method_call(\n-                    def_generics.clone(),\n-                    generic_args,\n-                    &derefed_receiver_ty,\n-                );\n-                let method_ty = method_ty.apply_substs(substs);\n-                let method_ty = self.insert_type_vars(method_ty);\n-                let (expected_receiver_ty, param_tys, ret_ty) = match &method_ty {\n-                    Ty::Apply(a_ty) => match a_ty.ctor {\n-                        TypeCtor::FnPtr => {\n-                            let sig = FnSig::from_fn_ptr_substs(&a_ty.parameters);\n-                            if !sig.params().is_empty() {\n-                                (\n-                                    sig.params()[0].clone(),\n-                                    sig.params()[1..].to_vec(),\n-                                    sig.ret().clone(),\n-                                )\n-                            } else {\n-                                (Ty::Unknown, Vec::new(), sig.ret().clone())\n-                            }\n-                        }\n-                        TypeCtor::FnDef(def) => {\n-                            let sig = self.db.callable_item_signature(def);\n-                            let ret_ty = sig.ret().clone().subst(&a_ty.parameters);\n-\n-                            // add obligation for trait implementation, if this is a trait method\n-                            // FIXME also register obligations from where clauses from the trait or impl and method\n-                            match def {\n-                                CallableDef::Function(f) => {\n-                                    if let Some(trait_) = f.parent_trait(self.db) {\n-                                        // construct a TraitDef\n-                                        let substs = a_ty.parameters.prefix(\n-                                            def_generics\n-                                                .expect(\"trait parent should always have generics\")\n-                                                .count_parent_params(),\n-                                        );\n-                                        self.obligations\n-                                            .push(Obligation::Trait(TraitRef { trait_, substs }));\n-                                    }\n-                                }\n-                                CallableDef::Struct(_) | CallableDef::EnumVariant(_) => {}\n-                            }\n-\n-                            if !sig.params().is_empty() {\n-                                let mut params_iter = sig\n-                                    .params()\n-                                    .iter()\n-                                    .map(|ty| ty.clone().subst(&a_ty.parameters));\n-                                let receiver_ty = params_iter.next().unwrap();\n-                                (receiver_ty, params_iter.collect(), ret_ty)\n-                            } else {\n-                                (Ty::Unknown, Vec::new(), ret_ty)\n-                            }\n-                        }\n-                        _ => (Ty::Unknown, Vec::new(), Ty::Unknown),\n-                    },\n-                    _ => (Ty::Unknown, Vec::new(), Ty::Unknown),\n-                };\n-                // Apply autoref so the below unification works correctly\n-                // FIXME: return correct autorefs/derefs from lookup_method\n-                let actual_receiver_ty = match expected_receiver_ty.as_reference() {\n-                    Some((_, mutability)) => {\n-                        Ty::apply_one(TypeCtor::Ref(mutability), derefed_receiver_ty)\n-                    }\n-                    _ => derefed_receiver_ty,\n-                };\n-                self.unify(&expected_receiver_ty, &actual_receiver_ty);\n-\n-                let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n-                for (arg, param) in args.iter().zip(param_iter) {\n-                    self.infer_expr(*arg, &Expectation::has_type(param));\n-                }\n-                ret_ty\n-            }\n+            Expr::MethodCall { receiver, args, method_name, generic_args } => self\n+                .infer_method_call(tgt_expr, *receiver, &args, &method_name, generic_args.as_ref()),\n             Expr::Match { expr, arms } => {\n                 let expected = if expected.ty == Ty::Unknown {\n                     Expectation::has_type(self.new_type_var())"}, {"sha": "bb8fdd8c77ff05b464f80ed8c9d43e23add368d2", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9339241b78ef7474e88de37738bdbece7767d333/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9339241b78ef7474e88de37738bdbece7767d333/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=9339241b78ef7474e88de37738bdbece7767d333", "patch": "@@ -5,6 +5,7 @@\n //!  - Building the type for an item: This happens through the `type_for_def` query.\n //!\n //! This usually involves resolving names, collecting generic arguments etc.\n+use std::iter;\n \n use crate::{\n     Function, Struct, StructField, Enum, EnumVariant, Path,\n@@ -172,16 +173,18 @@ pub(super) fn substs_from_path_segment(\n ) -> Substs {\n     let mut substs = Vec::new();\n     let parent_param_count = def_generics.count_parent_params();\n-    substs.extend((0..parent_param_count).map(|_| Ty::Unknown));\n+    substs.extend(iter::repeat(Ty::Unknown).take(parent_param_count));\n     if add_self_param {\n         // FIXME this add_self_param argument is kind of a hack: Traits have the\n         // Self type as an implicit first type parameter, but it can't be\n         // actually provided in the type arguments\n+        // (well, actually sometimes it can, in the form of type-relative paths: `<Foo as Default>::default()`)\n         substs.push(Ty::Unknown);\n     }\n     if let Some(generic_args) = &segment.args_and_bindings {\n         // if args are provided, it should be all of them, but we can't rely on that\n-        let param_count = def_generics.params.len();\n+        let self_param_correction = if add_self_param { 1 } else { 0 };\n+        let param_count = def_generics.params.len() - self_param_correction;\n         for arg in generic_args.args.iter().take(param_count) {\n             match arg {\n                 GenericArg::Type(type_ref) => {"}, {"sha": "126edeaffe2a1301388748d90335abdedd6b2246", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9339241b78ef7474e88de37738bdbece7767d333/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9339241b78ef7474e88de37738bdbece7767d333/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=9339241b78ef7474e88de37738bdbece7767d333", "patch": "@@ -233,15 +233,16 @@ impl Ty {\n     }\n }\n \n+/// This creates Substs for a trait with the given Self type and type variables\n+/// for all other parameters. This is kind of a hack since these aren't 'real'\n+/// type variables; the resulting trait reference is just used for the\n+/// preliminary method candidate check.\n fn fresh_substs_for_trait(db: &impl HirDatabase, tr: Trait, self_ty: Ty) -> Substs {\n     let mut substs = Vec::new();\n-    let mut counter = 0;\n     let generics = tr.generic_params(db);\n     substs.push(self_ty);\n-    substs.extend(generics.params_including_parent().into_iter().skip(1).map(|_p| {\n-        let fresh_var = Ty::Infer(super::infer::InferTy::TypeVar(super::infer::TypeVarId(counter)));\n-        counter += 1;\n-        fresh_var\n-    }));\n+    substs.extend(generics.params_including_parent().into_iter().skip(1).enumerate().map(\n+        |(i, _p)| Ty::Infer(super::infer::InferTy::TypeVar(super::infer::TypeVarId(i as u32))),\n+    ));\n     substs.into()\n }"}]}