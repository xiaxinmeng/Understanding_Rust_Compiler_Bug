{"sha": "bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMmYwZmI1YTk3ODNhYjJkNzBhYTI4MzFiN2ZmZDA1NmY1YTE2ZTk=", "commit": {"author": {"name": "Jacob Pratt", "email": "jacob@jhpratt.dev", "date": "2021-04-02T04:58:45Z"}, "committer": {"name": "Jacob Pratt", "email": "jacob@jhpratt.dev", "date": "2021-05-26T22:07:09Z"}, "message": "Specialize implementations\n\nImplementations in stdlib are now optimized as they were before.", "tree": {"sha": "d187a294d6390f8fd6cc581efaf35e22232353a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d187a294d6390f8fd6cc581efaf35e22232353a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYIAB0WIQTgxeqBxcDGar1sVhy4DhnkZitapAUCYK7GjQAKCRC4DhnkZita\npDpTAQCQuD8WafcgRCQZ7HOmoOK8mTDuPonm+ulr1yxxVanuUgD/ZlDdKmZm0c/Z\nfO/vf5uPcW+MvuqHiujKse42ygccwQ0=\n=uvIn\n-----END PGP SIGNATURE-----", "payload": "tree d187a294d6390f8fd6cc581efaf35e22232353a3\nparent a87587602732a7fe6739fdcfadce025fafbb55dd\nauthor Jacob Pratt <jacob@jhpratt.dev> 1617339525 -0400\ncommitter Jacob Pratt <jacob@jhpratt.dev> 1622066829 -0400\n\nSpecialize implementations\n\nImplementations in stdlib are now optimized as they were before.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "html_url": "https://github.com/rust-lang/rust/commit/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/comments", "author": {"login": "jhpratt", "id": 3161395, "node_id": "MDQ6VXNlcjMxNjEzOTU=", "avatar_url": "https://avatars.githubusercontent.com/u/3161395?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jhpratt", "html_url": "https://github.com/jhpratt", "followers_url": "https://api.github.com/users/jhpratt/followers", "following_url": "https://api.github.com/users/jhpratt/following{/other_user}", "gists_url": "https://api.github.com/users/jhpratt/gists{/gist_id}", "starred_url": "https://api.github.com/users/jhpratt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jhpratt/subscriptions", "organizations_url": "https://api.github.com/users/jhpratt/orgs", "repos_url": "https://api.github.com/users/jhpratt/repos", "events_url": "https://api.github.com/users/jhpratt/events{/privacy}", "received_events_url": "https://api.github.com/users/jhpratt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jhpratt", "id": 3161395, "node_id": "MDQ6VXNlcjMxNjEzOTU=", "avatar_url": "https://avatars.githubusercontent.com/u/3161395?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jhpratt", "html_url": "https://github.com/jhpratt", "followers_url": "https://api.github.com/users/jhpratt/followers", "following_url": "https://api.github.com/users/jhpratt/following{/other_user}", "gists_url": "https://api.github.com/users/jhpratt/gists{/gist_id}", "starred_url": "https://api.github.com/users/jhpratt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jhpratt/subscriptions", "organizations_url": "https://api.github.com/users/jhpratt/orgs", "repos_url": "https://api.github.com/users/jhpratt/repos", "events_url": "https://api.github.com/users/jhpratt/events{/privacy}", "received_events_url": "https://api.github.com/users/jhpratt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a87587602732a7fe6739fdcfadce025fafbb55dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a87587602732a7fe6739fdcfadce025fafbb55dd", "html_url": "https://github.com/rust-lang/rust/commit/a87587602732a7fe6739fdcfadce025fafbb55dd"}], "stats": {"total": 504, "additions": 399, "deletions": 105}, "files": [{"sha": "14ecf27813d3109bb775b037c81465aa9fc99ba3", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "patch": "@@ -17,6 +17,8 @@\n #![feature(iter_zip)]\n #![feature(label_break_value)]\n #![feature(nll)]\n+#![feature(min_specialization)]\n+#![feature(trusted_step)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "7f3c410b1ec60bb3bcfbafa7328cc412a599dfb7", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "patch": "@@ -7,6 +7,8 @@\n #![cfg_attr(bootstrap, feature(extended_key_value_attributes))]\n #![feature(in_band_lifetimes)]\n #![feature(once_cell)]\n+#![feature(min_specialization)]\n+#![feature(trusted_step)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "04d62391c021b6d1256a30f3198507ec711ca74a", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "patch": "@@ -6,6 +6,7 @@\n #![feature(unboxed_closures)]\n #![feature(test)]\n #![feature(fn_traits)]\n+#![feature(trusted_step)]\n \n pub mod bit_set;\n pub mod vec;"}, {"sha": "440e0943d6ed3c051b521d5e3f87d139496daa55", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "patch": "@@ -204,6 +204,9 @@ macro_rules! newtype_index {\n             }\n         }\n \n+        // Safety: The implementation of `Step` upholds all invariants.\n+        unsafe impl ::std::iter::TrustedStep for $type {}\n+\n         impl From<$type> for u32 {\n             #[inline]\n             fn from(v: $type) -> u32 {"}, {"sha": "6b452bca8e70f65666d44224bc450e4e4e3f0b0b", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "patch": "@@ -22,6 +22,8 @@\n #![feature(never_type)]\n #![feature(in_band_lifetimes)]\n #![feature(control_flow_enum)]\n+#![feature(min_specialization)]\n+#![feature(trusted_step)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "6f97716e2e0d62e8469157c68c0d0cac1c1b49b5", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "patch": "@@ -50,6 +50,7 @@\n #![feature(associated_type_defaults)]\n #![feature(iter_zip)]\n #![feature(thread_local_const_init)]\n+#![feature(trusted_step)]\n #![recursion_limit = \"512\"]\n \n #[macro_use]"}, {"sha": "647c368d2bb8227d49dac90da7485b6411cfdf34", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "patch": "@@ -31,6 +31,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(option_get_or_insert_default)]\n #![feature(once_cell)]\n #![feature(control_flow_enum)]\n+#![feature(trusted_step)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "99b854ff066e3d538d7a2d03cb888c4de29257fa", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "patch": "@@ -10,6 +10,8 @@\n #![feature(bool_to_option)]\n #![feature(iter_zip)]\n #![feature(once_cell)]\n+#![feature(min_specialization)]\n+#![feature(trusted_step)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "4803148eba91004eb8854ddabea0d1a33a156ffd", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "patch": "@@ -10,6 +10,8 @@\n #![feature(in_band_lifetimes)]\n #![feature(iter_zip)]\n #![feature(nll)]\n+#![feature(min_specialization)]\n+#![feature(trusted_step)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "7df3804c986d0dd6f40de9d82e4bff225b6af541", "filename": "compiler/rustc_query_system/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Flib.rs?ref=bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "patch": "@@ -6,6 +6,7 @@\n #![feature(iter_zip)]\n #![feature(min_specialization)]\n #![feature(stmt_expr_attributes)]\n+#![feature(trusted_step)]\n \n #[macro_use]\n extern crate tracing;"}, {"sha": "39b7b36b853fb15843000651d258f3f1de7a9bb0", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "patch": "@@ -21,6 +21,7 @@\n #![feature(nll)]\n #![feature(min_specialization)]\n #![feature(thread_local_const_init)]\n+#![feature(trusted_step)]\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "a40de5ef18e0143e9be763818d99c0767536aedc", "filename": "compiler/rustc_target/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_target%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_target%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Flib.rs?ref=bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "patch": "@@ -14,6 +14,8 @@\n #![feature(never_type)]\n #![feature(associated_type_bounds)]\n #![feature(exhaustive_patterns)]\n+#![feature(min_specialization)]\n+#![feature(trusted_step)]\n \n use std::path::{Path, PathBuf};\n "}, {"sha": "3f4c8a72f1d489fac2dc5487418e4ddf5fb3cb40", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "patch": "@@ -1,3 +1,6 @@\n+#![feature(min_specialization)]\n+#![feature(trusted_step)]\n+\n #[macro_use]\n extern crate bitflags;\n #[macro_use]"}, {"sha": "bfb27da505eaf54fdd2e6ad4d879ffa5d3ef7a1c", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "patch": "@@ -384,6 +384,8 @@ pub use self::traits::FusedIterator;\n pub use self::traits::InPlaceIterable;\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n pub use self::traits::TrustedLen;\n+#[unstable(feature = \"trusted_step\", issue = \"85731\")]\n+pub use self::traits::TrustedStep;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::traits::{\n     DoubleEndedIterator, ExactSizeIterator, Extend, FromIterator, IntoIterator, Product, Sum,"}, {"sha": "bb7d3d048067748b9fff05f56873bac0919a37cb", "filename": "library/core/src/iter/range.rs", "status": "modified", "additions": 355, "deletions": 105, "changes": 460, "blob_url": "https://github.com/rust-lang/rust/blob/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Frange.rs?ref=bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "patch": "@@ -3,7 +3,16 @@ use crate::convert::TryFrom;\n use crate::mem;\n use crate::ops::{self, Try};\n \n-use super::{FusedIterator, TrustedLen, TrustedRandomAccess};\n+use super::{FusedIterator, TrustedLen, TrustedRandomAccess, TrustedStep};\n+\n+// Safety: All invariants are upheld.\n+macro_rules! unsafe_impl_trusted_step {\n+    ($($type:ty)*) => {$(\n+        #[unstable(feature = \"trusted_step\", issue = \"85731\")]\n+        unsafe impl TrustedStep for $type {}\n+    )*};\n+}\n+unsafe_impl_trusted_step![char i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize];\n \n /// Objects that have a notion of *successor* and *predecessor* operations.\n ///\n@@ -505,12 +514,24 @@ macro_rules! range_incl_exact_iter_impl {\n     )*)\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Step> Iterator for ops::Range<A> {\n+/// Specialization implementations for `Range`.\n+trait RangeIteratorImpl {\n+    type Item;\n+\n+    // Iterator\n+    fn spec_next(&mut self) -> Option<Self::Item>;\n+    fn spec_nth(&mut self, n: usize) -> Option<Self::Item>;\n+\n+    // DoubleEndedIterator\n+    fn spec_next_back(&mut self) -> Option<Self::Item>;\n+    fn spec_nth_back(&mut self, n: usize) -> Option<Self::Item>;\n+}\n+\n+impl<A: Step> RangeIteratorImpl for ops::Range<A> {\n     type Item = A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    default fn spec_next(&mut self) -> Option<A> {\n         if self.start < self.end {\n             let n =\n                 Step::forward_checked(self.start.clone(), 1).expect(\"`Step` invariants not upheld\");\n@@ -521,21 +542,63 @@ impl<A: Step> Iterator for ops::Range<A> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n+    default fn spec_nth(&mut self, n: usize) -> Option<A> {\n+        if let Some(plus_n) = Step::forward_checked(self.start.clone(), n) {\n+            if plus_n < self.end {\n+                self.start =\n+                    Step::forward_checked(plus_n.clone(), 1).expect(\"`Step` invariants not upheld\");\n+                return Some(plus_n);\n+            }\n+        }\n+\n+        self.start = self.end.clone();\n+        None\n+    }\n+\n+    #[inline]\n+    default fn spec_next_back(&mut self) -> Option<A> {\n         if self.start < self.end {\n-            let hint = Step::steps_between(&self.start, &self.end);\n-            (hint.unwrap_or(usize::MAX), hint)\n+            self.end =\n+                Step::backward_checked(self.end.clone(), 1).expect(\"`Step` invariants not upheld\");\n+            Some(self.end.clone())\n         } else {\n-            (0, Some(0))\n+            None\n         }\n     }\n \n     #[inline]\n-    fn nth(&mut self, n: usize) -> Option<A> {\n+    default fn spec_nth_back(&mut self, n: usize) -> Option<A> {\n+        if let Some(minus_n) = Step::backward_checked(self.end.clone(), n) {\n+            if minus_n > self.start {\n+                self.end =\n+                    Step::backward_checked(minus_n, 1).expect(\"`Step` invariants not upheld\");\n+                return Some(self.end.clone());\n+            }\n+        }\n+\n+        self.end = self.start.clone();\n+        None\n+    }\n+}\n+\n+impl<T: TrustedStep> RangeIteratorImpl for ops::Range<T> {\n+    #[inline]\n+    fn spec_next(&mut self) -> Option<T> {\n+        if self.start < self.end {\n+            // SAFETY: just checked precondition\n+            let n = unsafe { Step::forward_unchecked(self.start.clone(), 1) };\n+            Some(mem::replace(&mut self.start, n))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn spec_nth(&mut self, n: usize) -> Option<T> {\n         if let Some(plus_n) = Step::forward_checked(self.start.clone(), n) {\n             if plus_n < self.end {\n-                self.start =\n-                    Step::forward_checked(plus_n.clone(), 1).expect(\"`Step` invariants not upheld\");\n+                // SAFETY: just checked precondition\n+                self.start = unsafe { Step::forward_unchecked(plus_n.clone(), 1) };\n                 return Some(plus_n);\n             }\n         }\n@@ -544,6 +607,56 @@ impl<A: Step> Iterator for ops::Range<A> {\n         None\n     }\n \n+    #[inline]\n+    fn spec_next_back(&mut self) -> Option<T> {\n+        if self.start < self.end {\n+            // SAFETY: just checked precondition\n+            self.end = unsafe { Step::backward_unchecked(self.end.clone(), 1) };\n+            Some(self.end.clone())\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn spec_nth_back(&mut self, n: usize) -> Option<T> {\n+        if let Some(minus_n) = Step::backward_checked(self.end.clone(), n) {\n+            if minus_n > self.start {\n+                // SAFETY: just checked precondition\n+                self.end = unsafe { Step::backward_unchecked(minus_n, 1) };\n+                return Some(self.end.clone());\n+            }\n+        }\n+\n+        self.end = self.start.clone();\n+        None\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Step> Iterator for ops::Range<A> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        self.spec_next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.start < self.end {\n+            let hint = Step::steps_between(&self.start, &self.end);\n+            (hint.unwrap_or(usize::MAX), hint)\n+        } else {\n+            (0, Some(0))\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<A> {\n+        self.spec_nth(n)\n+    }\n+\n     #[inline]\n     fn last(mut self) -> Option<A> {\n         self.next_back()\n@@ -624,37 +737,36 @@ range_incl_exact_iter_impl! {\n impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n-        if self.start < self.end {\n-            self.end =\n-                Step::backward_checked(self.end.clone(), 1).expect(\"`Step` invariants not upheld\");\n-            Some(self.end.clone())\n-        } else {\n-            None\n-        }\n+        self.spec_next_back()\n     }\n \n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<A> {\n-        if let Some(minus_n) = Step::backward_checked(self.end.clone(), n) {\n-            if minus_n > self.start {\n-                self.end =\n-                    Step::backward_checked(minus_n, 1).expect(\"`Step` invariants not upheld\");\n-                return Some(self.end.clone());\n-            }\n-        }\n-\n-        self.end = self.start.clone();\n-        None\n+        self.spec_nth_back(n)\n     }\n }\n \n-macro_rules! impl_trusted_len_for_range {\n-    ($($type:ty)*) => {$(\n-        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-        unsafe impl TrustedLen for ops::Range<$type> {}\n-    )*}\n-}\n-impl_trusted_len_for_range![char i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize];\n+// Safety:\n+// The following invariants for `Step::steps_between` exist:\n+//\n+// > * `steps_between(&a, &b) == Some(n)` only if `a <= b`\n+// >   * Note that `a <= b` does _not_ imply `steps_between(&a, &b) != None`;\n+// >     this is the case when it would require more than `usize::MAX` steps to\n+// >     get to `b`\n+// > * `steps_between(&a, &b) == None` if `a > b`\n+//\n+// The first invariant is what is generally required for `TrustedLen` to be\n+// sound. The note addendum satisfies an additional `TrustedLen` invariant.\n+//\n+// > The upper bound must only be `None` if the actual iterator length is larger\n+// > than `usize::MAX`\n+//\n+// The second invariant logically follows the first so long as the `PartialOrd`\n+// implementation is correct; regardless it is explicitly stated. If `a < b`\n+// then `(0, Some(0))` is returned by `ops::Range<A: Step>::size_hint`. As such\n+// the second invariant is upheld.\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A: TrustedStep> TrustedLen for ops::Range<A> {}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::Range<A> {}\n@@ -682,23 +794,38 @@ impl<A: Step> Iterator for ops::RangeFrom<A> {\n     }\n }\n \n+// Safety: See above implementation for `ops::Range<A>`\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A: TrustedStep> TrustedLen for ops::RangeFrom<A> {}\n+\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::RangeFrom<A> {}\n \n-macro_rules! impl_trusted_len_for_range_from {\n-    ($($type:ty)*) => {$(\n-        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-        unsafe impl TrustedLen for ops::RangeFrom<$type> {}\n-    )*}\n+trait RangeInclusiveIteratorImpl {\n+    type Item;\n+\n+    // Iterator\n+    fn spec_next(&mut self) -> Option<Self::Item>;\n+    fn spec_try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>;\n+\n+    // DoubleEndedIterator\n+    fn spec_next_back(&mut self) -> Option<Self::Item>;\n+    fn spec_try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>;\n }\n-impl_trusted_len_for_range_from![char i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize];\n \n-#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-impl<A: Step> Iterator for ops::RangeInclusive<A> {\n+impl<A: Step> RangeInclusiveIteratorImpl for ops::RangeInclusive<A> {\n     type Item = A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    default fn spec_next(&mut self) -> Option<A> {\n         if self.is_empty() {\n             return None;\n         }\n@@ -713,6 +840,182 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         })\n     }\n \n+    #[inline]\n+    default fn spec_try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, A) -> R,\n+        R: Try<Output = B>,\n+    {\n+        if self.is_empty() {\n+            return try { init };\n+        }\n+\n+        let mut accum = init;\n+\n+        while self.start < self.end {\n+            let n =\n+                Step::forward_checked(self.start.clone(), 1).expect(\"`Step` invariants not upheld\");\n+            let n = mem::replace(&mut self.start, n);\n+            accum = f(accum, n)?;\n+        }\n+\n+        self.exhausted = true;\n+\n+        if self.start == self.end {\n+            accum = f(accum, self.start.clone())?;\n+        }\n+\n+        try { accum }\n+    }\n+\n+    #[inline]\n+    default fn spec_next_back(&mut self) -> Option<A> {\n+        if self.is_empty() {\n+            return None;\n+        }\n+        let is_iterating = self.start < self.end;\n+        Some(if is_iterating {\n+            let n =\n+                Step::backward_checked(self.end.clone(), 1).expect(\"`Step` invariants not upheld\");\n+            mem::replace(&mut self.end, n)\n+        } else {\n+            self.exhausted = true;\n+            self.end.clone()\n+        })\n+    }\n+\n+    #[inline]\n+    default fn spec_try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, A) -> R,\n+        R: Try<Output = B>,\n+    {\n+        if self.is_empty() {\n+            return try { init };\n+        }\n+\n+        let mut accum = init;\n+\n+        while self.start < self.end {\n+            let n =\n+                Step::backward_checked(self.end.clone(), 1).expect(\"`Step` invariants not upheld\");\n+            let n = mem::replace(&mut self.end, n);\n+            accum = f(accum, n)?;\n+        }\n+\n+        self.exhausted = true;\n+\n+        if self.start == self.end {\n+            accum = f(accum, self.start.clone())?;\n+        }\n+\n+        try { accum }\n+    }\n+}\n+\n+impl<T: TrustedStep> RangeInclusiveIteratorImpl for ops::RangeInclusive<T> {\n+    #[inline]\n+    fn spec_next(&mut self) -> Option<T> {\n+        if self.is_empty() {\n+            return None;\n+        }\n+        let is_iterating = self.start < self.end;\n+        Some(if is_iterating {\n+            // SAFETY: just checked precondition\n+            let n = unsafe { Step::forward_unchecked(self.start.clone(), 1) };\n+            mem::replace(&mut self.start, n)\n+        } else {\n+            self.exhausted = true;\n+            self.start.clone()\n+        })\n+    }\n+\n+    #[inline]\n+    fn spec_try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, T) -> R,\n+        R: Try<Output = B>,\n+    {\n+        if self.is_empty() {\n+            return try { init };\n+        }\n+\n+        let mut accum = init;\n+\n+        while self.start < self.end {\n+            // SAFETY: just checked precondition\n+            let n = unsafe { Step::forward_unchecked(self.start.clone(), 1) };\n+            let n = mem::replace(&mut self.start, n);\n+            accum = f(accum, n)?;\n+        }\n+\n+        self.exhausted = true;\n+\n+        if self.start == self.end {\n+            accum = f(accum, self.start.clone())?;\n+        }\n+\n+        try { accum }\n+    }\n+\n+    #[inline]\n+    fn spec_next_back(&mut self) -> Option<T> {\n+        if self.is_empty() {\n+            return None;\n+        }\n+        let is_iterating = self.start < self.end;\n+        Some(if is_iterating {\n+            // SAFETY: just checked precondition\n+            let n = unsafe { Step::backward_unchecked(self.end.clone(), 1) };\n+            mem::replace(&mut self.end, n)\n+        } else {\n+            self.exhausted = true;\n+            self.end.clone()\n+        })\n+    }\n+\n+    #[inline]\n+    fn spec_try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, T) -> R,\n+        R: Try<Output = B>,\n+    {\n+        if self.is_empty() {\n+            return try { init };\n+        }\n+\n+        let mut accum = init;\n+\n+        while self.start < self.end {\n+            // SAFETY: just checked precondition\n+            let n = unsafe { Step::backward_unchecked(self.end.clone(), 1) };\n+            let n = mem::replace(&mut self.end, n);\n+            accum = f(accum, n)?;\n+        }\n+\n+        self.exhausted = true;\n+\n+        if self.start == self.end {\n+            accum = f(accum, self.start.clone())?;\n+        }\n+\n+        try { accum }\n+    }\n+}\n+\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n+impl<A: Step> Iterator for ops::RangeInclusive<A> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        self.spec_next()\n+    }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         if self.is_empty() {\n@@ -754,32 +1057,13 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n     }\n \n     #[inline]\n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Output = B>,\n     {\n-        if self.is_empty() {\n-            return try { init };\n-        }\n-\n-        let mut accum = init;\n-\n-        while self.start < self.end {\n-            let n =\n-                Step::forward_checked(self.start.clone(), 1).expect(\"`Step` invariants not upheld\");\n-            let n = mem::replace(&mut self.start, n);\n-            accum = f(accum, n)?;\n-        }\n-\n-        self.exhausted = true;\n-\n-        if self.start == self.end {\n-            accum = f(accum, self.start.clone())?;\n-        }\n-\n-        try { accum }\n+        self.spec_try_fold(init, f)\n     }\n \n     #[inline]\n@@ -816,18 +1100,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n-        if self.is_empty() {\n-            return None;\n-        }\n-        let is_iterating = self.start < self.end;\n-        Some(if is_iterating {\n-            let n =\n-                Step::backward_checked(self.end.clone(), 1).expect(\"`Step` invariants not upheld\");\n-            mem::replace(&mut self.end, n)\n-        } else {\n-            self.exhausted = true;\n-            self.end.clone()\n-        })\n+        self.spec_next_back()\n     }\n \n     #[inline]\n@@ -859,32 +1132,13 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     }\n \n     #[inline]\n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Output = B>,\n     {\n-        if self.is_empty() {\n-            return try { init };\n-        }\n-\n-        let mut accum = init;\n-\n-        while self.start < self.end {\n-            let n =\n-                Step::backward_checked(self.end.clone(), 1).expect(\"`Step` invariants not upheld\");\n-            let n = mem::replace(&mut self.end, n);\n-            accum = f(accum, n)?;\n-        }\n-\n-        self.exhausted = true;\n-\n-        if self.start == self.end {\n-            accum = f(accum, self.start.clone())?;\n-        }\n-\n-        try { accum }\n+        self.spec_try_rfold(init, f)\n     }\n \n     #[inline]\n@@ -902,13 +1156,9 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     }\n }\n \n-macro_rules! impl_trusted_len_for_range_inclusive {\n-    ($($type:ty)*) => {$(\n-        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-        unsafe impl TrustedLen for ops::RangeInclusive<$type> {}\n-    )*}\n-}\n-impl_trusted_len_for_range_inclusive![char i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize];\n+// Safety: See above implementation for `ops::Range<A>`\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A: TrustedStep> TrustedLen for ops::RangeInclusive<A> {}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::RangeInclusive<A> {}"}, {"sha": "ebf37f97bc6178649deeddee6fae20f9a1539ccc", "filename": "library/core/src/iter/traits/marker.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs?ref=bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "patch": "@@ -1,3 +1,5 @@\n+use crate::iter::Step;\n+\n /// An iterator that always continues to yield `None` when exhausted.\n ///\n /// Calling next on a fused iterator that has returned `None` once is guaranteed\n@@ -55,3 +57,18 @@ unsafe impl<I: TrustedLen + ?Sized> TrustedLen for &mut I {}\n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n #[doc(hidden)]\n pub unsafe trait InPlaceIterable: Iterator {}\n+\n+/// A type that upholds all invariants of [`Step`].\n+///\n+/// The invariants of [`Step::steps_between()`] are a superset of the invariants\n+/// of [`TrustedLen`]. As such, [`TrustedLen`] is implemented for all range\n+/// types with the same generic type argument.\n+///\n+/// # Safety\n+///\n+/// The implementation of [`Step`] for the given type must guarantee all\n+/// invariants of all methods are upheld. See the [`Step`] trait's documentation\n+/// for details. Consumers are free to rely on the invariants in unsafe code.\n+#[unstable(feature = \"trusted_step\", issue = \"85731\")]\n+#[rustc_specialization_trait]\n+pub unsafe trait TrustedStep: Step {}"}, {"sha": "ffd745a46b12c0e1091bb423ae4265f33e66380d", "filename": "library/core/src/iter/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmod.rs?ref=bc2f0fb5a9783ab2d70aa2831b7ffd056f5a16e9", "patch": "@@ -13,5 +13,7 @@ pub use self::exact_size::ExactSizeIterator;\n pub use self::iterator::Iterator;\n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n pub use self::marker::InPlaceIterable;\n+#[unstable(feature = \"trusted_step\", issue = \"85731\")]\n+pub use self::marker::TrustedStep;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::marker::{FusedIterator, TrustedLen};"}]}