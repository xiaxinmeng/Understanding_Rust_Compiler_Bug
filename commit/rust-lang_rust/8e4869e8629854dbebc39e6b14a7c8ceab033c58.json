{"sha": "8e4869e8629854dbebc39e6b14a7c8ceab033c58", "node_id": "C_kwDOAAsO6NoAKDhlNDg2OWU4NjI5ODU0ZGJlYmMzOWU2YjE0YTdjOGNlYWIwMzNjNTg", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-09-29T02:42:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-29T02:42:05Z"}, "message": "Rollup merge of #102368 - beetrees:nano-niche, r=joshtriplett\n\nAdd a niche to `Duration`, unix `SystemTime`, and non-apple `Instant`\n\nAs the nanoseconds fields is always between `0` and `(NANOS_PER_SEC - 1)` inclusive, use the `rustc_layout_scalar_valid_range` attributes to create a niche in the nanosecond field of `Duration` and `Timespec` (which is used to implement unix `SystemTime` and non-apple unix `Instant`; windows `Instant` is implemented with `Duration` and therefore will also benefit). This change has the benefit of making `Option<T>` the same size as `T` for the previously mentioned types. Also shrinks the nanoseconds field of `Timespec` to a `u32` as nanoseconds do not need the extra range of an `i64`, shrinking `Timespec` by 4 bytes on 32-bit platforms.\n\nr? ```@joshtriplett```", "tree": {"sha": "93f1f3500ea86b6cf4068475ba6180656be61a83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93f1f3500ea86b6cf4068475ba6180656be61a83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e4869e8629854dbebc39e6b14a7c8ceab033c58", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjNQX9CRBK7hj4Ov3rIwAACucIAGi2nIf1ItsSSS7T2CNZYAmK\nojYU/ULlyeRIQIIwKXAii0vw4g45bnTnHglnYTlqMnRw44p5qrm/wQlixi98a039\n/e6ydMwTUDaZ8+0Rpseo9ynwX08wIqkKF1flOyG/vTwRdzCEDu2cEDLQaHYatTnP\n0Q8Z4NyD0PLPLg0T63O8eSJxf9XkdlEsu/Wq/GJjsrYPHv+zR9QCiJPFdRQaefVu\nn0fvl0ZQ3yWA2KWztSV1i1x6EKC1NnKN1qdOuyKkGft+wMIhSot8LRanjp6IX7QR\nszzK/kENRxnxzzfokdncUVQ1H0f8F5sa9zTuaqrQsGOeqBDIxLimNpId4axDPYo=\n=8P7L\n-----END PGP SIGNATURE-----\n", "payload": "tree 93f1f3500ea86b6cf4068475ba6180656be61a83\nparent 19e84b91e564eea334691ea064a742b32598d6f9\nparent a91327782906885ccd8b8bf25e1e7f9ea46f8428\nauthor Yuki Okushi <jtitor@2k36.org> 1664419325 +0900\ncommitter GitHub <noreply@github.com> 1664419325 +0900\n\nRollup merge of #102368 - beetrees:nano-niche, r=joshtriplett\n\nAdd a niche to `Duration`, unix `SystemTime`, and non-apple `Instant`\n\nAs the nanoseconds fields is always between `0` and `(NANOS_PER_SEC - 1)` inclusive, use the `rustc_layout_scalar_valid_range` attributes to create a niche in the nanosecond field of `Duration` and `Timespec` (which is used to implement unix `SystemTime` and non-apple unix `Instant`; windows `Instant` is implemented with `Duration` and therefore will also benefit). This change has the benefit of making `Option<T>` the same size as `T` for the previously mentioned types. Also shrinks the nanoseconds field of `Timespec` to a `u32` as nanoseconds do not need the extra range of an `i64`, shrinking `Timespec` by 4 bytes on 32-bit platforms.\n\nr? ```@joshtriplett```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e4869e8629854dbebc39e6b14a7c8ceab033c58", "html_url": "https://github.com/rust-lang/rust/commit/8e4869e8629854dbebc39e6b14a7c8ceab033c58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e4869e8629854dbebc39e6b14a7c8ceab033c58/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19e84b91e564eea334691ea064a742b32598d6f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/19e84b91e564eea334691ea064a742b32598d6f9", "html_url": "https://github.com/rust-lang/rust/commit/19e84b91e564eea334691ea064a742b32598d6f9"}, {"sha": "a91327782906885ccd8b8bf25e1e7f9ea46f8428", "url": "https://api.github.com/repos/rust-lang/rust/commits/a91327782906885ccd8b8bf25e1e7f9ea46f8428", "html_url": "https://github.com/rust-lang/rust/commit/a91327782906885ccd8b8bf25e1e7f9ea46f8428"}], "stats": {"total": 136, "additions": 75, "deletions": 61}, "files": [{"sha": "2b85d6e22258ffd8ce4a0afc40fb9fefe0a609bb", "filename": "library/core/src/time.rs", "status": "modified", "additions": 52, "deletions": 46, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/8e4869e8629854dbebc39e6b14a7c8ceab033c58/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4869e8629854dbebc39e6b14a7c8ceab033c58/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=8e4869e8629854dbebc39e6b14a7c8ceab033c58", "patch": "@@ -29,6 +29,20 @@ const NANOS_PER_MICRO: u32 = 1_000;\n const MILLIS_PER_SEC: u64 = 1_000;\n const MICROS_PER_SEC: u64 = 1_000_000;\n \n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[repr(transparent)]\n+#[rustc_layout_scalar_valid_range_start(0)]\n+#[rustc_layout_scalar_valid_range_end(999_999_999)]\n+struct Nanoseconds(u32);\n+\n+impl Default for Nanoseconds {\n+    #[inline]\n+    fn default() -> Self {\n+        // SAFETY: 0 is within the valid range\n+        unsafe { Nanoseconds(0) }\n+    }\n+}\n+\n /// A `Duration` type to represent a span of time, typically used for system\n /// timeouts.\n ///\n@@ -71,7 +85,7 @@ const MICROS_PER_SEC: u64 = 1_000_000;\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Duration\")]\n pub struct Duration {\n     secs: u64,\n-    nanos: u32, // Always 0 <= nanos < NANOS_PER_SEC\n+    nanos: Nanoseconds, // Always 0 <= nanos < NANOS_PER_SEC\n }\n \n impl Duration {\n@@ -188,7 +202,8 @@ impl Duration {\n             None => panic!(\"overflow in Duration::new\"),\n         };\n         let nanos = nanos % NANOS_PER_SEC;\n-        Duration { secs, nanos }\n+        // SAFETY: nanos % NANOS_PER_SEC < NANOS_PER_SEC, therefore nanos is within the valid range\n+        Duration { secs, nanos: unsafe { Nanoseconds(nanos) } }\n     }\n \n     /// Creates a new `Duration` from the specified number of whole seconds.\n@@ -208,7 +223,7 @@ impl Duration {\n     #[inline]\n     #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n     pub const fn from_secs(secs: u64) -> Duration {\n-        Duration { secs, nanos: 0 }\n+        Duration::new(secs, 0)\n     }\n \n     /// Creates a new `Duration` from the specified number of milliseconds.\n@@ -228,10 +243,7 @@ impl Duration {\n     #[inline]\n     #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n     pub const fn from_millis(millis: u64) -> Duration {\n-        Duration {\n-            secs: millis / MILLIS_PER_SEC,\n-            nanos: ((millis % MILLIS_PER_SEC) as u32) * NANOS_PER_MILLI,\n-        }\n+        Duration::new(millis / MILLIS_PER_SEC, ((millis % MILLIS_PER_SEC) as u32) * NANOS_PER_MILLI)\n     }\n \n     /// Creates a new `Duration` from the specified number of microseconds.\n@@ -251,10 +263,7 @@ impl Duration {\n     #[inline]\n     #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n     pub const fn from_micros(micros: u64) -> Duration {\n-        Duration {\n-            secs: micros / MICROS_PER_SEC,\n-            nanos: ((micros % MICROS_PER_SEC) as u32) * NANOS_PER_MICRO,\n-        }\n+        Duration::new(micros / MICROS_PER_SEC, ((micros % MICROS_PER_SEC) as u32) * NANOS_PER_MICRO)\n     }\n \n     /// Creates a new `Duration` from the specified number of nanoseconds.\n@@ -274,10 +283,7 @@ impl Duration {\n     #[inline]\n     #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n     pub const fn from_nanos(nanos: u64) -> Duration {\n-        Duration {\n-            secs: nanos / (NANOS_PER_SEC as u64),\n-            nanos: (nanos % (NANOS_PER_SEC as u64)) as u32,\n-        }\n+        Duration::new(nanos / (NANOS_PER_SEC as u64), (nanos % (NANOS_PER_SEC as u64)) as u32)\n     }\n \n     /// Returns true if this `Duration` spans no time.\n@@ -301,7 +307,7 @@ impl Duration {\n     #[rustc_const_stable(feature = \"duration_zero\", since = \"1.53.0\")]\n     #[inline]\n     pub const fn is_zero(&self) -> bool {\n-        self.secs == 0 && self.nanos == 0\n+        self.secs == 0 && self.nanos.0 == 0\n     }\n \n     /// Returns the number of _whole_ seconds contained by this `Duration`.\n@@ -352,7 +358,7 @@ impl Duration {\n     #[must_use]\n     #[inline]\n     pub const fn subsec_millis(&self) -> u32 {\n-        self.nanos / NANOS_PER_MILLI\n+        self.nanos.0 / NANOS_PER_MILLI\n     }\n \n     /// Returns the fractional part of this `Duration`, in whole microseconds.\n@@ -375,7 +381,7 @@ impl Duration {\n     #[must_use]\n     #[inline]\n     pub const fn subsec_micros(&self) -> u32 {\n-        self.nanos / NANOS_PER_MICRO\n+        self.nanos.0 / NANOS_PER_MICRO\n     }\n \n     /// Returns the fractional part of this `Duration`, in nanoseconds.\n@@ -398,7 +404,7 @@ impl Duration {\n     #[must_use]\n     #[inline]\n     pub const fn subsec_nanos(&self) -> u32 {\n-        self.nanos\n+        self.nanos.0\n     }\n \n     /// Returns the total number of whole milliseconds contained by this `Duration`.\n@@ -416,7 +422,7 @@ impl Duration {\n     #[must_use]\n     #[inline]\n     pub const fn as_millis(&self) -> u128 {\n-        self.secs as u128 * MILLIS_PER_SEC as u128 + (self.nanos / NANOS_PER_MILLI) as u128\n+        self.secs as u128 * MILLIS_PER_SEC as u128 + (self.nanos.0 / NANOS_PER_MILLI) as u128\n     }\n \n     /// Returns the total number of whole microseconds contained by this `Duration`.\n@@ -434,7 +440,7 @@ impl Duration {\n     #[must_use]\n     #[inline]\n     pub const fn as_micros(&self) -> u128 {\n-        self.secs as u128 * MICROS_PER_SEC as u128 + (self.nanos / NANOS_PER_MICRO) as u128\n+        self.secs as u128 * MICROS_PER_SEC as u128 + (self.nanos.0 / NANOS_PER_MICRO) as u128\n     }\n \n     /// Returns the total number of nanoseconds contained by this `Duration`.\n@@ -452,7 +458,7 @@ impl Duration {\n     #[must_use]\n     #[inline]\n     pub const fn as_nanos(&self) -> u128 {\n-        self.secs as u128 * NANOS_PER_SEC as u128 + self.nanos as u128\n+        self.secs as u128 * NANOS_PER_SEC as u128 + self.nanos.0 as u128\n     }\n \n     /// Checked `Duration` addition. Computes `self + other`, returning [`None`]\n@@ -475,7 +481,7 @@ impl Duration {\n     #[rustc_const_stable(feature = \"duration_consts_2\", since = \"1.58.0\")]\n     pub const fn checked_add(self, rhs: Duration) -> Option<Duration> {\n         if let Some(mut secs) = self.secs.checked_add(rhs.secs) {\n-            let mut nanos = self.nanos + rhs.nanos;\n+            let mut nanos = self.nanos.0 + rhs.nanos.0;\n             if nanos >= NANOS_PER_SEC {\n                 nanos -= NANOS_PER_SEC;\n                 if let Some(new_secs) = secs.checked_add(1) {\n@@ -485,7 +491,7 @@ impl Duration {\n                 }\n             }\n             debug_assert!(nanos < NANOS_PER_SEC);\n-            Some(Duration { secs, nanos })\n+            Some(Duration::new(secs, nanos))\n         } else {\n             None\n         }\n@@ -535,16 +541,16 @@ impl Duration {\n     #[rustc_const_stable(feature = \"duration_consts_2\", since = \"1.58.0\")]\n     pub const fn checked_sub(self, rhs: Duration) -> Option<Duration> {\n         if let Some(mut secs) = self.secs.checked_sub(rhs.secs) {\n-            let nanos = if self.nanos >= rhs.nanos {\n-                self.nanos - rhs.nanos\n+            let nanos = if self.nanos.0 >= rhs.nanos.0 {\n+                self.nanos.0 - rhs.nanos.0\n             } else if let Some(sub_secs) = secs.checked_sub(1) {\n                 secs = sub_secs;\n-                self.nanos + NANOS_PER_SEC - rhs.nanos\n+                self.nanos.0 + NANOS_PER_SEC - rhs.nanos.0\n             } else {\n                 return None;\n             };\n             debug_assert!(nanos < NANOS_PER_SEC);\n-            Some(Duration { secs, nanos })\n+            Some(Duration::new(secs, nanos))\n         } else {\n             None\n         }\n@@ -593,13 +599,13 @@ impl Duration {\n     #[rustc_const_stable(feature = \"duration_consts_2\", since = \"1.58.0\")]\n     pub const fn checked_mul(self, rhs: u32) -> Option<Duration> {\n         // Multiply nanoseconds as u64, because it cannot overflow that way.\n-        let total_nanos = self.nanos as u64 * rhs as u64;\n+        let total_nanos = self.nanos.0 as u64 * rhs as u64;\n         let extra_secs = total_nanos / (NANOS_PER_SEC as u64);\n         let nanos = (total_nanos % (NANOS_PER_SEC as u64)) as u32;\n         if let Some(s) = self.secs.checked_mul(rhs as u64) {\n             if let Some(secs) = s.checked_add(extra_secs) {\n                 debug_assert!(nanos < NANOS_PER_SEC);\n-                return Some(Duration { secs, nanos });\n+                return Some(Duration::new(secs, nanos));\n             }\n         }\n         None\n@@ -653,9 +659,9 @@ impl Duration {\n             let secs = self.secs / (rhs as u64);\n             let carry = self.secs - secs * (rhs as u64);\n             let extra_nanos = carry * (NANOS_PER_SEC as u64) / (rhs as u64);\n-            let nanos = self.nanos / rhs + (extra_nanos as u32);\n+            let nanos = self.nanos.0 / rhs + (extra_nanos as u32);\n             debug_assert!(nanos < NANOS_PER_SEC);\n-            Some(Duration { secs, nanos })\n+            Some(Duration::new(secs, nanos))\n         } else {\n             None\n         }\n@@ -677,7 +683,7 @@ impl Duration {\n     #[inline]\n     #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n     pub const fn as_secs_f64(&self) -> f64 {\n-        (self.secs as f64) + (self.nanos as f64) / (NANOS_PER_SEC as f64)\n+        (self.secs as f64) + (self.nanos.0 as f64) / (NANOS_PER_SEC as f64)\n     }\n \n     /// Returns the number of seconds contained by this `Duration` as `f32`.\n@@ -696,7 +702,7 @@ impl Duration {\n     #[inline]\n     #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n     pub const fn as_secs_f32(&self) -> f32 {\n-        (self.secs as f32) + (self.nanos as f32) / (NANOS_PER_SEC as f32)\n+        (self.secs as f32) + (self.nanos.0 as f32) / (NANOS_PER_SEC as f32)\n     }\n \n     /// Creates a new `Duration` from the specified number of seconds represented\n@@ -987,21 +993,21 @@ macro_rules! sum_durations {\n         for entry in $iter {\n             total_secs =\n                 total_secs.checked_add(entry.secs).expect(\"overflow in iter::sum over durations\");\n-            total_nanos = match total_nanos.checked_add(entry.nanos as u64) {\n+            total_nanos = match total_nanos.checked_add(entry.nanos.0 as u64) {\n                 Some(n) => n,\n                 None => {\n                     total_secs = total_secs\n                         .checked_add(total_nanos / NANOS_PER_SEC as u64)\n                         .expect(\"overflow in iter::sum over durations\");\n-                    (total_nanos % NANOS_PER_SEC as u64) + entry.nanos as u64\n+                    (total_nanos % NANOS_PER_SEC as u64) + entry.nanos.0 as u64\n                 }\n             };\n         }\n         total_secs = total_secs\n             .checked_add(total_nanos / NANOS_PER_SEC as u64)\n             .expect(\"overflow in iter::sum over durations\");\n         total_nanos = total_nanos % NANOS_PER_SEC as u64;\n-        Duration { secs: total_secs, nanos: total_nanos as u32 }\n+        Duration::new(total_secs, total_nanos as u32)\n     }};\n }\n \n@@ -1166,27 +1172,27 @@ impl fmt::Debug for Duration {\n         let prefix = if f.sign_plus() { \"+\" } else { \"\" };\n \n         if self.secs > 0 {\n-            fmt_decimal(f, self.secs, self.nanos, NANOS_PER_SEC / 10, prefix, \"s\")\n-        } else if self.nanos >= NANOS_PER_MILLI {\n+            fmt_decimal(f, self.secs, self.nanos.0, NANOS_PER_SEC / 10, prefix, \"s\")\n+        } else if self.nanos.0 >= NANOS_PER_MILLI {\n             fmt_decimal(\n                 f,\n-                (self.nanos / NANOS_PER_MILLI) as u64,\n-                self.nanos % NANOS_PER_MILLI,\n+                (self.nanos.0 / NANOS_PER_MILLI) as u64,\n+                self.nanos.0 % NANOS_PER_MILLI,\n                 NANOS_PER_MILLI / 10,\n                 prefix,\n                 \"ms\",\n             )\n-        } else if self.nanos >= NANOS_PER_MICRO {\n+        } else if self.nanos.0 >= NANOS_PER_MICRO {\n             fmt_decimal(\n                 f,\n-                (self.nanos / NANOS_PER_MICRO) as u64,\n-                self.nanos % NANOS_PER_MICRO,\n+                (self.nanos.0 / NANOS_PER_MICRO) as u64,\n+                self.nanos.0 % NANOS_PER_MICRO,\n                 NANOS_PER_MICRO / 10,\n                 prefix,\n                 \"\u00b5s\",\n             )\n         } else {\n-            fmt_decimal(f, self.nanos as u64, 0, 1, prefix, \"ns\")\n+            fmt_decimal(f, self.nanos.0 as u64, 0, 1, prefix, \"ns\")\n         }\n     }\n }\n@@ -1317,7 +1323,7 @@ macro_rules! try_from_secs {\n             return Err(FromFloatSecsError { kind: FromFloatSecsErrorKind::OverflowOrNan });\n         };\n \n-        Ok(Duration { secs, nanos })\n+        Ok(Duration::new(secs, nanos))\n     }};\n }\n "}, {"sha": "cca9c67670161161522d930666161cac896e7596", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8e4869e8629854dbebc39e6b14a7c8ceab033c58/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4869e8629854dbebc39e6b14a7c8ceab033c58/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=8e4869e8629854dbebc39e6b14a7c8ceab033c58", "patch": "@@ -6,6 +6,12 @@ pub use self::inner::Instant;\n const NSEC_PER_SEC: u64 = 1_000_000_000;\n pub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n \n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[repr(transparent)]\n+#[rustc_layout_scalar_valid_range_start(0)]\n+#[rustc_layout_scalar_valid_range_end(999_999_999)]\n+struct Nanoseconds(u32);\n+\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct SystemTime {\n     pub(in crate::sys::unix) t: Timespec,\n@@ -14,7 +20,7 @@ pub struct SystemTime {\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub(in crate::sys::unix) struct Timespec {\n     tv_sec: i64,\n-    tv_nsec: i64,\n+    tv_nsec: Nanoseconds,\n }\n \n impl SystemTime {\n@@ -46,18 +52,20 @@ impl fmt::Debug for SystemTime {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"SystemTime\")\n             .field(\"tv_sec\", &self.t.tv_sec)\n-            .field(\"tv_nsec\", &self.t.tv_nsec)\n+            .field(\"tv_nsec\", &self.t.tv_nsec.0)\n             .finish()\n     }\n }\n \n impl Timespec {\n     pub const fn zero() -> Timespec {\n-        Timespec { tv_sec: 0, tv_nsec: 0 }\n+        Timespec::new(0, 0)\n     }\n \n-    fn new(tv_sec: i64, tv_nsec: i64) -> Timespec {\n-        Timespec { tv_sec, tv_nsec }\n+    const fn new(tv_sec: i64, tv_nsec: i64) -> Timespec {\n+        assert!(tv_nsec >= 0 && tv_nsec < NSEC_PER_SEC as i64);\n+        // SAFETY: The assert above checks tv_nsec is within the valid range\n+        Timespec { tv_sec, tv_nsec: unsafe { Nanoseconds(tv_nsec as u32) } }\n     }\n \n     pub fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n@@ -75,12 +83,12 @@ impl Timespec {\n             //\n             // Ideally this code could be rearranged such that it more\n             // directly expresses the lower-cost behavior we want from it.\n-            let (secs, nsec) = if self.tv_nsec >= other.tv_nsec {\n-                ((self.tv_sec - other.tv_sec) as u64, (self.tv_nsec - other.tv_nsec) as u32)\n+            let (secs, nsec) = if self.tv_nsec.0 >= other.tv_nsec.0 {\n+                ((self.tv_sec - other.tv_sec) as u64, self.tv_nsec.0 - other.tv_nsec.0)\n             } else {\n                 (\n                     (self.tv_sec - other.tv_sec - 1) as u64,\n-                    self.tv_nsec as u32 + (NSEC_PER_SEC as u32) - other.tv_nsec as u32,\n+                    self.tv_nsec.0 + (NSEC_PER_SEC as u32) - other.tv_nsec.0,\n                 )\n             };\n \n@@ -102,7 +110,7 @@ impl Timespec {\n \n         // Nano calculations can't overflow because nanos are <1B which fit\n         // in a u32.\n-        let mut nsec = other.subsec_nanos() + self.tv_nsec as u32;\n+        let mut nsec = other.subsec_nanos() + self.tv_nsec.0;\n         if nsec >= NSEC_PER_SEC as u32 {\n             nsec -= NSEC_PER_SEC as u32;\n             secs = secs.checked_add(1)?;\n@@ -118,7 +126,7 @@ impl Timespec {\n             .and_then(|secs| self.tv_sec.checked_sub(secs))?;\n \n         // Similar to above, nanos can't overflow.\n-        let mut nsec = self.tv_nsec as i32 - other.subsec_nanos() as i32;\n+        let mut nsec = self.tv_nsec.0 as i32 - other.subsec_nanos() as i32;\n         if nsec < 0 {\n             nsec += NSEC_PER_SEC as i32;\n             secs = secs.checked_sub(1)?;\n@@ -130,7 +138,7 @@ impl Timespec {\n     pub fn to_timespec(&self) -> Option<libc::timespec> {\n         Some(libc::timespec {\n             tv_sec: self.tv_sec.try_into().ok()?,\n-            tv_nsec: self.tv_nsec.try_into().ok()?,\n+            tv_nsec: self.tv_nsec.0.try_into().ok()?,\n         })\n     }\n }\n@@ -293,7 +301,7 @@ mod inner {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n             f.debug_struct(\"Instant\")\n                 .field(\"tv_sec\", &self.t.tv_sec)\n-                .field(\"tv_nsec\", &self.t.tv_nsec)\n+                .field(\"tv_nsec\", &self.t.tv_nsec.0)\n                 .finish()\n         }\n     }\n@@ -334,7 +342,7 @@ mod inner {\n                     let mut t = MaybeUninit::uninit();\n                     cvt(unsafe { clock_gettime64(clock, t.as_mut_ptr()) }).unwrap();\n                     let t = unsafe { t.assume_init() };\n-                    return Timespec { tv_sec: t.tv_sec, tv_nsec: t.tv_nsec as i64 };\n+                    return Timespec::new(t.tv_sec, t.tv_nsec as i64);\n                 }\n             }\n "}, {"sha": "624d8cc5cc55a942d77d40494678922c113fd925", "filename": "src/etc/natvis/libcore.natvis", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e4869e8629854dbebc39e6b14a7c8ceab033c58/src%2Fetc%2Fnatvis%2Flibcore.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/8e4869e8629854dbebc39e6b14a7c8ceab033c58/src%2Fetc%2Fnatvis%2Flibcore.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Flibcore.natvis?ref=8e4869e8629854dbebc39e6b14a7c8ceab033c58", "patch": "@@ -154,10 +154,10 @@\n   </Type>\n \n   <Type Name=\"core::time::Duration\">\n-    <DisplayString>{secs,d}s {nanos,d}ns</DisplayString>\n+    <DisplayString>{secs,d}s {nanos.__0,d}ns</DisplayString>\n     <Expand>\n       <Item Name=\"seconds\">secs,d</Item>\n-      <Item Name=\"nanoseconds\">nanos,d</Item>\n+      <Item Name=\"nanoseconds\">nanos.__0,d</Item>\n     </Expand>\n   </Type>\n </AutoVisualizer>"}]}