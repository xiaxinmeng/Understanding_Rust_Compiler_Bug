{"sha": "27a1763eac38123bc206c77cb8b1431671afa81a", "node_id": "C_kwDOAAsO6NoAKDI3YTE3NjNlYWMzODEyM2JjMjA2Yzc3Y2I4YjE0MzE2NzFhZmE4MWE", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-11-05T22:05:04Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-11-11T15:38:00Z"}, "message": "Make author DRYer", "tree": {"sha": "540ef04e038e6405c1f8f9a19d33ae94bff08cf0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/540ef04e038e6405c1f8f9a19d33ae94bff08cf0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27a1763eac38123bc206c77cb8b1431671afa81a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27a1763eac38123bc206c77cb8b1431671afa81a", "html_url": "https://github.com/rust-lang/rust/commit/27a1763eac38123bc206c77cb8b1431671afa81a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27a1763eac38123bc206c77cb8b1431671afa81a/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72d7b9c097f5c9299a83ed7ec7ea97093400f92e", "url": "https://api.github.com/repos/rust-lang/rust/commits/72d7b9c097f5c9299a83ed7ec7ea97093400f92e", "html_url": "https://github.com/rust-lang/rust/commit/72d7b9c097f5c9299a83ed7ec7ea97093400f92e"}], "stats": {"total": 1468, "additions": 553, "deletions": 915}, "files": [{"sha": "ced879b6b2cd7da52f3063b5fa84b065b776b1b3", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27a1763eac38123bc206c77cb8b1431671afa81a/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27a1763eac38123bc206c77cb8b1431671afa81a/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=27a1763eac38123bc206c77cb8b1431671afa81a", "patch": "@@ -2,6 +2,7 @@\n \n #![feature(box_patterns)]\n #![feature(drain_filter)]\n+#![feature(format_args_capture)]\n #![feature(in_band_lifetimes)]\n #![feature(iter_zip)]\n #![feature(once_cell)]"}, {"sha": "d20bf3413185c1aa38cf6bed8a77af25a58d4759", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 482, "deletions": 858, "changes": 1340, "blob_url": "https://github.com/rust-lang/rust/blob/27a1763eac38123bc206c77cb8b1431671afa81a/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27a1763eac38123bc206c77cb8b1431671afa81a/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=27a1763eac38123bc206c77cb8b1431671afa81a", "patch": "@@ -3,14 +3,14 @@\n \n use clippy_utils::{get_attr, higher};\n use rustc_ast::ast::{LitFloatType, LitKind};\n-use rustc_ast::{walk_list, Label, LitIntType};\n+use rustc_ast::LitIntType;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n-use rustc_hir::{Arm, Block, Expr, ExprKind, FnRetTy, Lit, MatchSource, Pat, PatKind, QPath, Stmt, StmtKind, TyKind};\n+use rustc_hir::{ExprKind, FnRetTy, HirId, Lit, PatKind, QPath, StmtKind, TyKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::{Ident, Symbol};\n+use std::fmt::{Display, Formatter, Write as _};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -53,6 +53,42 @@ declare_clippy_lint! {\n \n declare_lint_pass!(Author => [LINT_AUTHOR]);\n \n+/// Writes a line of output with indentation added\n+macro_rules! out {\n+    ($($t:tt)*) => {\n+        println!(\"    {}\", format_args!($($t)*))\n+    };\n+}\n+\n+/// The variables passed in are replaced with `&Binding`s where the `value` field is set\n+/// to the original value of the variable. The `name` field is set to the name of the variable\n+/// (using `stringify!`) and is adjusted to avoid duplicate names.\n+/// Note that the `Binding` may be printed directly to output the `name`.\n+macro_rules! bind {\n+    ($self:ident $(, $name:ident)+) => {\n+        $(let $name = & $self.bind(stringify!($name), $name);)+\n+    };\n+}\n+\n+/// Transforms the given `Option<T>` varibles into `OptionPat<Binding<T>>`.\n+/// This displays as `Some($name)` or `None` when printed. The name of the inner binding\n+/// is set to the name of the variable passed to the macro.\n+macro_rules! opt_bind {\n+    ($self:ident $(, $name:ident)+) => {\n+        $(let $name = OptionPat::new($name.map(|o| $self.bind(stringify!($name), o)));)+\n+    };\n+}\n+\n+/// Creates a `Binding` that accesses the field of an existing `Binding`\n+macro_rules! field {\n+    ($binding:ident.$field:ident) => {\n+        &Binding {\n+            name: $binding.name.to_string() + stringify!(.$field),\n+            value: $binding.value.$field,\n+        }\n+    };\n+}\n+\n fn prelude() {\n     println!(\"if_chain! {{\");\n }\n@@ -66,1036 +102,624 @@ fn done() {\n \n impl<'tcx> LateLintPass<'tcx> for Author {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        if !has_attr(cx, item.hir_id()) {\n-            return;\n-        }\n-        prelude();\n-        PrintVisitor::new(\"item\", cx).visit_item(item);\n-        done();\n+        check_item(cx, item.hir_id());\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n-        if !has_attr(cx, item.hir_id()) {\n-            return;\n-        }\n-        prelude();\n-        PrintVisitor::new(\"item\", cx).visit_impl_item(item);\n-        done();\n+        check_item(cx, item.hir_id());\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n-        if !has_attr(cx, item.hir_id()) {\n-            return;\n-        }\n-        prelude();\n-        PrintVisitor::new(\"item\", cx).visit_trait_item(item);\n-        done();\n-    }\n-\n-    fn check_variant(&mut self, cx: &LateContext<'tcx>, var: &'tcx hir::Variant<'_>) {\n-        if !has_attr(cx, var.id) {\n-            return;\n-        }\n-        prelude();\n-        let parent_hir_id = cx.tcx.hir().get_parent_node(var.id);\n-        PrintVisitor::new(\"var\", cx).visit_variant(var, &hir::Generics::empty(), parent_hir_id);\n-        done();\n+        check_item(cx, item.hir_id());\n     }\n \n-    fn check_field_def(&mut self, cx: &LateContext<'tcx>, field: &'tcx hir::FieldDef<'_>) {\n-        if !has_attr(cx, field.hir_id) {\n-            return;\n-        }\n-        prelude();\n-        PrintVisitor::new(\"field\", cx).visit_field_def(field);\n-        done();\n+    fn check_arm(&mut self, cx: &LateContext<'tcx>, arm: &'tcx hir::Arm<'_>) {\n+        check_node(cx, arm.hir_id, |v| {\n+            v.arm(&v.bind(\"arm\", arm));\n+        });\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if !has_attr(cx, expr.hir_id) {\n-            return;\n-        }\n-        prelude();\n-        PrintVisitor::new(\"expr\", cx).visit_expr(expr);\n-        done();\n-    }\n-\n-    fn check_arm(&mut self, cx: &LateContext<'tcx>, arm: &'tcx hir::Arm<'_>) {\n-        if !has_attr(cx, arm.hir_id) {\n-            return;\n-        }\n-        prelude();\n-        PrintVisitor::new(\"arm\", cx).visit_arm(arm);\n-        done();\n+        check_node(cx, expr.hir_id, |v| {\n+            v.expr(&v.bind(\"expr\", expr));\n+        });\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n-        if !has_attr(cx, stmt.hir_id) {\n-            return;\n-        }\n         match stmt.kind {\n             StmtKind::Expr(e) | StmtKind::Semi(e) if has_attr(cx, e.hir_id) => return,\n             _ => {},\n         }\n+        check_node(cx, stmt.hir_id, |v| {\n+            v.stmt(&v.bind(\"stmt\", stmt));\n+        });\n+    }\n+}\n+\n+fn check_item(cx: &LateContext<'_>, hir_id: HirId) {\n+    let hir = cx.tcx.hir();\n+    if let Some(body_id) = hir.maybe_body_owned_by(hir_id) {\n+        check_node(cx, hir_id, |v| {\n+            v.expr(&v.bind(\"expr\", &hir.body(body_id).value));\n+        });\n+    }\n+}\n+\n+fn check_node(cx: &LateContext<'_>, hir_id: HirId, f: impl Fn(&PrintVisitor<'_, '_>)) {\n+    if has_attr(cx, hir_id) {\n         prelude();\n-        PrintVisitor::new(\"stmt\", cx).visit_stmt(stmt);\n+        f(&PrintVisitor::new(cx));\n         done();\n     }\n+}\n \n-    fn check_foreign_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ForeignItem<'_>) {\n-        if !has_attr(cx, item.hir_id()) {\n-            return;\n+struct Binding<T> {\n+    name: String,\n+    value: T,\n+}\n+\n+impl<T> Display for Binding<T> {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n+        f.write_str(&self.name)\n+    }\n+}\n+\n+struct OptionPat<T> {\n+    pub opt: Option<T>,\n+}\n+\n+impl<T> OptionPat<T> {\n+    fn new(opt: Option<T>) -> Self {\n+        Self { opt }\n+    }\n+\n+    fn if_some(&self, f: impl Fn(&T)) {\n+        if let Some(t) = &self.opt {\n+            f(t);\n+        }\n+    }\n+}\n+\n+impl<T: Display> Display for OptionPat<T> {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n+        match &self.opt {\n+            None => f.write_str(\"None\"),\n+            Some(node) => write!(f, \"Some({node})\"),\n         }\n-        prelude();\n-        PrintVisitor::new(\"item\", cx).visit_foreign_item(item);\n-        done();\n     }\n }\n \n+struct PrintVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    /// Fields are the current index that needs to be appended to pattern\n+    /// binding names\n+    ids: std::cell::Cell<FxHashMap<&'static str, u32>>,\n+}\n+\n+#[allow(clippy::unused_self)]\n impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n-    #[must_use]\n-    fn new(s: &'static str, cx: &'a LateContext<'tcx>) -> Self {\n+    fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n-            ids: FxHashMap::default(),\n-            current: s.to_owned(),\n             cx,\n+            ids: std::cell::Cell::default(),\n         }\n     }\n \n-    fn next(&mut self, s: &'static str) -> String {\n-        use std::collections::hash_map::Entry::{Occupied, Vacant};\n-        match self.ids.entry(s) {\n-            // already there: start numbering from `1`\n-            Occupied(mut occ) => {\n-                let val = occ.get_mut();\n-                *val += 1;\n-                format!(\"{}{}\", s, *val)\n-            },\n-            // not there: insert and return name as given\n-            Vacant(vac) => {\n-                vac.insert(0);\n-                s.to_owned()\n+    fn next(&self, s: &'static str) -> String {\n+        let mut ids = self.ids.take();\n+        let out = match *ids.entry(s).and_modify(|n| *n += 1).or_default() {\n+            // first usage of the name, use it as is\n+            0 => s.to_string(),\n+            // append a number starting with 1\n+            n => format!(\"{s}{n}\"),\n+        };\n+        self.ids.set(ids);\n+        out\n+    }\n+\n+    fn bind<T>(&self, name: &'static str, value: T) -> Binding<T> {\n+        let name = self.next(name);\n+        Binding { name, value }\n+    }\n+\n+    fn option<T: Copy>(&self, option: &Binding<Option<T>>, name: &'static str, f: impl Fn(&Binding<T>)) {\n+        match option.value {\n+            None => out!(\"if {option}.is_none();\"),\n+            Some(value) => {\n+                let value = &self.bind(name, value);\n+                out!(\"if let Some({value}) = {option};\");\n+                f(value);\n             },\n         }\n     }\n \n-    fn print_qpath(&mut self, path: &QPath<'_>) {\n-        if let QPath::LangItem(lang_item, _) = *path {\n-            println!(\n-                \"    if matches!({}, QPath::LangItem(LangItem::{:?}, _));\",\n-                self.current, lang_item,\n-            );\n+    fn slice<T>(&self, slice: &Binding<&[T]>, f: impl Fn(&Binding<&T>)) {\n+        if slice.value.is_empty() {\n+            out!(\"if {slice}.is_empty();\");\n         } else {\n-            print!(\"    if match_qpath({}, &[\", self.current);\n-            print_path(path, &mut true);\n-            println!(\"]);\");\n+            out!(\"if {slice}.len() == {};\", slice.value.len());\n+            for (i, value) in slice.value.iter().enumerate() {\n+                let name = format!(\"{slice}[{i}]\");\n+                f(&Binding { name, value });\n+            }\n         }\n     }\n \n-    fn print_label(&mut self, label: Option<Label>) {\n-        if let Some(label) = label {\n-            let label_bind = self.next(\"label\");\n+    fn destination(&self, destination: &Binding<hir::Destination>) {\n+        self.option(field!(destination.label), \"label\", |label| {\n+            self.ident(field!(label.ident));\n+        });\n+    }\n \n-            println!(\"    if let Some({}) = {};\", label_bind, self.current);\n+    fn ident(&self, ident: &Binding<Ident>) {\n+        out!(\"if {ident}.as_str() == {:?};\", ident.value.as_str());\n+    }\n \n-            let label_name_bind = self.next(\"label_name\");\n-            let label_name = label.ident.name;\n+    fn symbol(&self, symbol: &Binding<Symbol>) {\n+        out!(\"if {symbol}.as_str() == {:?};\", symbol.value.as_str());\n+    }\n \n-            println!(\n-                \"    if {}.ident.name.as_str() == {:?};\",\n-                label_name_bind,\n-                label_name.as_str()\n-            );\n+    fn qpath(&self, qpath: &Binding<&QPath<'_>>) {\n+        if let QPath::LangItem(lang_item, _) = *qpath.value {\n+            out!(\"if matches!({qpath}, QPath::LangItem(LangItem::{lang_item:?}, _));\");\n+        } else {\n+            out!(\"if match_qpath({qpath}, &[{}]);\", path_to_string(qpath.value));\n         }\n     }\n \n-    fn print_lit_expr(&mut self, lit: &Lit, current: &str) {\n-        let lit_pat = self.next(\"lit\");\n-\n-        println!(\"Lit(ref {}) = {};\", lit_pat, current);\n+    fn lit(&self, lit: &Binding<&Lit>) {\n+        let kind = |kind| out!(\"if let LitKind::{kind} = {lit}.node;\");\n+        macro_rules! kind {\n+            ($($t:tt)*) => (kind(format_args!($($t)*)));\n+        }\n \n-        match lit.node {\n-            LitKind::Bool(val) => println!(\"    if let LitKind::Bool({:?}) = {}.node;\", val, lit_pat),\n-            LitKind::Char(c) => println!(\"    if let LitKind::Char({:?}) = {}.node;\", c, lit_pat),\n-            LitKind::Err(val) => println!(\"    if let LitKind::Err({}) = {}.node;\", val, lit_pat),\n-            LitKind::Byte(b) => println!(\"    if let LitKind::Byte({}) = {}.node;\", b, lit_pat),\n+        match lit.value.node {\n+            LitKind::Bool(val) => kind!(\"Bool({val:?})\"),\n+            LitKind::Char(c) => kind!(\"Char({c:?})\"),\n+            LitKind::Err(val) => kind!(\"Err({val})\"),\n+            LitKind::Byte(b) => kind!(\"Byte({b})\"),\n             LitKind::Int(i, suffix) => {\n                 let int_ty = match suffix {\n-                    LitIntType::Signed(int_ty) => format!(\"LitIntType::Signed(IntTy::{:?})\", int_ty),\n-                    LitIntType::Unsigned(uint_ty) => format!(\"LitIntType::Unsigned(UintTy::{:?})\", uint_ty),\n+                    LitIntType::Signed(int_ty) => format!(\"LitIntType::Signed(IntTy::{int_ty:?})\"),\n+                    LitIntType::Unsigned(uint_ty) => format!(\"LitIntType::Unsigned(UintTy::{uint_ty:?})\"),\n                     LitIntType::Unsuffixed => String::from(\"LitIntType::Unsuffixed\"),\n                 };\n-\n-                println!(\"    if let LitKind::Int({}, {}) = {}.node;\", i, int_ty, lit_pat);\n+                kind!(\"Int({i}, {int_ty})\");\n             },\n             LitKind::Float(_, suffix) => {\n                 let float_ty = match suffix {\n-                    LitFloatType::Suffixed(suffix_ty) => format!(\"LitFloatType::Suffixed(FloatTy::{:?})\", suffix_ty),\n+                    LitFloatType::Suffixed(suffix_ty) => format!(\"LitFloatType::Suffixed(FloatTy::{suffix_ty:?})\"),\n                     LitFloatType::Unsuffixed => String::from(\"LitFloatType::Unsuffixed\"),\n                 };\n-\n-                println!(\"    if let LitKind::Float(_, {}) = {}.node;\", float_ty, lit_pat);\n+                kind!(\"Float(_, {float_ty})\");\n             },\n             LitKind::ByteStr(ref vec) => {\n-                let vec_pat = self.next(\"vec\");\n-\n-                println!(\"    if let LitKind::ByteStr(ref {}) = {}.node;\", vec_pat, lit_pat);\n-                println!(\"    if let [{:?}] = **{};\", vec, vec_pat);\n+                bind!(self, vec);\n+                kind!(\"ByteStr(ref {vec})\");\n+                out!(\"if let [{:?}] = **{vec};\", vec.value);\n             },\n-            LitKind::Str(text, _) => {\n-                let str_pat = self.next(\"s\");\n-\n-                println!(\"    if let LitKind::Str({}, _) = {}.node;\", str_pat, lit_pat);\n-                println!(\"    if {}.as_str() == {:?};\", str_pat, &*text.as_str());\n+            LitKind::Str(s, _) => {\n+                bind!(self, s);\n+                kind!(\"Str({s}, _)\");\n+                self.symbol(s);\n             },\n         }\n     }\n \n-    fn print_match_expr(&mut self, expr: &Expr<'_>, arms: &[Arm<'_>], des: MatchSource, current: &str) {\n-        let expr_pat = self.next(\"scrutinee\");\n-        let arms_pat = self.next(\"arms\");\n-\n-        println!(\n-            \"Match({}, {}, MatchSource::{:?}) = {};\",\n-            expr_pat, arms_pat, des, current\n-        );\n-\n-        self.current = expr_pat;\n-        self.visit_expr(expr);\n-\n-        println!(\"    if {}.len() == {};\", arms_pat, arms.len());\n-\n-        for (i, arm) in arms.iter().enumerate() {\n-            self.current = format!(\"{}[{}].pat\", arms_pat, i);\n-            self.visit_pat(arm.pat);\n-\n-            if let Some(guard) = &arm.guard {\n-                let guard_pat = self.next(\"guard\");\n-\n-                println!(\"    if let Some({}) = &{}[{}].guard;\", guard_pat, arms_pat, i);\n-\n-                match guard {\n-                    hir::Guard::If(if_expr) => {\n-                        let if_expr_pat = self.next(\"expr\");\n-\n-                        println!(\"    if let Guard::If({}) = {};\", if_expr_pat, guard_pat);\n-\n-                        self.current = if_expr_pat;\n-                        self.visit_expr(if_expr);\n-                    },\n-                    hir::Guard::IfLet(if_let_pat, if_let_expr) => {\n-                        let if_let_pat_pat = self.next(\"pat\");\n-                        let if_let_expr_pat = self.next(\"expr\");\n-\n-                        println!(\n-                            \"    if let Guard::IfLet({}, {}) = {};\",\n-                            if_let_pat_pat, if_let_expr_pat, guard_pat\n-                        );\n-\n-                        self.current = if_let_expr_pat;\n-                        self.visit_expr(if_let_expr);\n-\n-                        self.current = if_let_pat_pat;\n-                        self.visit_pat(if_let_pat);\n-                    },\n-                }\n-            }\n-            self.current = format!(\"{}[{}].body\", arms_pat, i);\n-            self.visit_expr(arm.body);\n+    fn arm(&self, arm: &Binding<&hir::Arm<'_>>) {\n+        self.pat(field!(arm.pat));\n+        match arm.value.guard {\n+            None => out!(\"if {arm}.guard.is_none();\"),\n+            Some(hir::Guard::If(expr)) => {\n+                bind!(self, expr);\n+                out!(\"if let Some(Guard::If({expr})) = {arm}.guard;\");\n+                self.expr(expr);\n+            },\n+            Some(hir::Guard::IfLet(pat, expr)) => {\n+                bind!(self, pat, expr);\n+                out!(\"if let Some(Guard::IfLet({pat}, {expr}) = {arm}.guard;\");\n+                self.pat(pat);\n+                self.expr(expr);\n+            },\n         }\n+        self.expr(field!(arm.body));\n     }\n \n-    fn check_higher(&mut self, expr: &Expr<'_>) -> bool {\n-        if let Some(higher::While { condition, body }) = higher::While::hir(expr) {\n-            let condition_pat = self.next(\"condition\");\n-            let body_pat = self.next(\"body\");\n-\n-            println!(\n-                \"    if let Some(higher::While {{ condition: {}, body: {} }}) = higher::While::hir({});\",\n-                condition_pat, body_pat, self.current\n+    #[allow(clippy::too_many_lines)]\n+    fn expr(&self, expr: &Binding<&hir::Expr<'_>>) {\n+        if let Some(higher::While { condition, body }) = higher::While::hir(expr.value) {\n+            bind!(self, condition, body);\n+            out!(\n+                \"if let Some(higher::While {{ condition: {condition}, body: {body} }}) \\\n+                = higher::While::hir({expr});\"\n             );\n-\n-            self.current = condition_pat;\n-            self.visit_expr(condition);\n-\n-            self.current = body_pat;\n-            self.visit_expr(body);\n-\n-            return true;\n+            self.expr(condition);\n+            self.expr(body);\n+            return;\n         }\n \n         if let Some(higher::WhileLet {\n             let_pat,\n             let_expr,\n             if_then,\n-        }) = higher::WhileLet::hir(expr)\n+        }) = higher::WhileLet::hir(expr.value)\n         {\n-            let let_pat_ = self.next(\"let_pat\");\n-            let let_expr_pat = self.next(\"let_expr\");\n-            let if_then_pat = self.next(\"if_then\");\n-\n-            println!(\n-                \"    if let Some(higher::WhileLet {{ let_pat: {}, let_expr: {}, if_then: {} }}) = higher::WhileLet::hir({});\",\n-                let_pat_, let_expr_pat, if_then_pat, self.current\n+            bind!(self, let_pat, let_expr, if_then);\n+            out!(\n+                \"if let Some(higher::WhileLet {{ let_pat: {let_pat}, let_expr: {let_expr}, if_then: {if_then} }}) \\\n+                = higher::WhileLet::hir({expr});\"\n             );\n-\n-            self.current = let_pat_;\n-            self.visit_pat(let_pat);\n-\n-            self.current = let_expr_pat;\n-            self.visit_expr(let_expr);\n-\n-            self.current = if_then_pat;\n-            self.visit_expr(if_then);\n-\n-            return true;\n-        }\n-\n-        if let Some(higher::IfLet {\n-            let_pat,\n-            let_expr,\n-            if_then,\n-            if_else,\n-        }) = higher::IfLet::hir(self.cx, expr)\n-        {\n-            let let_pat_ = self.next(\"let_pat\");\n-            let let_expr_pat = self.next(\"let_expr\");\n-            let if_then_pat = self.next(\"if_then\");\n-            let else_pat = self.next(\"else_expr\");\n-\n-            println!(\n-                \"    if let Some(higher::IfLet {{ let_pat: {}, let_expr: {}, if_then: {}, if_else: {}}}) = higher::IfLet::hir({});\",\n-                let_pat_, let_expr_pat, if_then_pat, else_pat, self.current\n-            );\n-\n-            self.current = let_pat_;\n-            self.visit_pat(let_pat);\n-\n-            self.current = let_expr_pat;\n-            self.visit_expr(let_expr);\n-\n-            self.current = if_then_pat;\n-            self.visit_expr(if_then);\n-\n-            if let Some(else_expr) = if_else {\n-                self.current = else_pat;\n-                self.visit_expr(else_expr);\n-            }\n-\n-            return true;\n-        }\n-\n-        if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr) {\n-            let cond_pat = self.next(\"cond\");\n-            let then_pat = self.next(\"then\");\n-            let else_pat = self.next(\"else_expr\");\n-\n-            println!(\n-                \"    if let Some(higher::If {{ cond: {}, then: {}, r#else: {}}}) = higher::If::hir({});\",\n-                cond_pat, then_pat, else_pat, self.current\n-            );\n-\n-            self.current = cond_pat;\n-            self.visit_expr(cond);\n-\n-            self.current = then_pat;\n-            self.visit_expr(then);\n-\n-            if let Some(else_expr) = r#else {\n-                self.current = else_pat;\n-                self.visit_expr(else_expr);\n-            }\n-\n-            return true;\n+            self.pat(let_pat);\n+            self.expr(let_expr);\n+            self.expr(if_then);\n+            return;\n         }\n \n-        if let Some(higher::ForLoop { pat, arg, body, .. }) = higher::ForLoop::hir(expr) {\n-            let pat_ = self.next(\"pat\");\n-            let arg_pat = self.next(\"arg\");\n-            let body_pat = self.next(\"body\");\n-\n-            println!(\n-                \"    if let Some(higher::ForLoop {{ pat: {}, arg: {}, body: {}, ..}}) = higher::ForLoop::hir({});\",\n-                pat_, arg_pat, body_pat, self.current\n+        if let Some(higher::ForLoop { pat, arg, body, .. }) = higher::ForLoop::hir(expr.value) {\n+            bind!(self, pat, arg, body);\n+            out!(\n+                \"if let Some(higher::ForLoop {{ pat: {pat}, arg: {arg}, body: {body}, .. }}) \\\n+                = higher::ForLoop::hir({expr});\"\n             );\n-\n-            self.current = pat_;\n-            self.visit_pat(pat);\n-\n-            self.current = arg_pat;\n-            self.visit_expr(arg);\n-\n-            self.current = body_pat;\n-            self.visit_expr(body);\n-\n-            return true;\n-        }\n-\n-        false\n-    }\n-}\n-\n-struct PrintVisitor<'a, 'tcx> {\n-    /// Fields are the current index that needs to be appended to pattern\n-    /// binding names\n-    ids: FxHashMap<&'static str, usize>,\n-    /// the name that needs to be destructured\n-    current: String,\n-    cx: &'a LateContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for PrintVisitor<'a, '_> {\n-    type Map = Map<'tcx>;\n-\n-    #[allow(clippy::too_many_lines)]\n-    fn visit_expr(&mut self, expr: &Expr<'_>) {\n-        if self.check_higher(expr) {\n+            self.pat(pat);\n+            self.expr(arg);\n+            self.expr(body);\n             return;\n         }\n \n-        print!(\"    if let ExprKind::\");\n-        let current = format!(\"{}.kind\", self.current);\n+        let kind = |kind| out!(\"if let ExprKind::{kind} = {expr}.kind;\");\n+        macro_rules! kind {\n+            ($($t:tt)*) => (kind(format_args!($($t)*)));\n+        }\n \n-        match expr.kind {\n+        match expr.value.kind {\n             ExprKind::Let(pat, expr, _) => {\n-                let let_pat = self.next(\"pat\");\n-                let let_expr = self.next(\"expr\");\n-\n-                println!(\"Let({}, {}, _) = {};\", let_pat, let_expr, current);\n-\n-                self.current = let_expr;\n-                self.visit_expr(expr);\n-\n-                self.current = let_pat;\n-                self.visit_pat(pat);\n+                bind!(self, pat, expr);\n+                kind!(\"Let({pat}, {expr}, _)\");\n+                self.pat(pat);\n+                self.expr(expr);\n             },\n             ExprKind::Box(inner) => {\n-                let inner_pat = self.next(\"inner\");\n-\n-                println!(\"Box({}) = {};\", inner_pat, current);\n-\n-                self.current = inner_pat;\n-                self.visit_expr(inner);\n+                bind!(self, inner);\n+                kind!(\"Box({inner})\");\n+                self.expr(inner);\n             },\n             ExprKind::Array(elements) => {\n-                let elements_pat = self.next(\"elements\");\n-\n-                println!(\"Array({}) = {};\", elements_pat, current);\n-\n-                println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n-\n-                for (i, element) in elements.iter().enumerate() {\n-                    self.current = format!(\"{}[{}]\", elements_pat, i);\n-                    self.visit_expr(element);\n-                }\n+                bind!(self, elements);\n+                kind!(\"Array({elements})\");\n+                self.slice(elements, |e| self.expr(e));\n             },\n             ExprKind::Call(func, args) => {\n-                let func_pat = self.next(\"func\");\n-                let args_pat = self.next(\"args\");\n-\n-                println!(\"Call({}, {}) = {};\", func_pat, args_pat, current);\n-\n-                self.current = func_pat;\n-                self.visit_expr(func);\n-\n-                println!(\"    if {}.len() == {};\", args_pat, args.len());\n-\n-                for (i, arg) in args.iter().enumerate() {\n-                    self.current = format!(\"{}[{}]\", args_pat, i);\n-                    self.visit_expr(arg);\n-                }\n+                bind!(self, func, args);\n+                kind!(\"Call({func}, {args})\");\n+                self.expr(func);\n+                self.slice(args, |e| self.expr(e));\n             },\n             ExprKind::MethodCall(method_name, _, args, _) => {\n-                let method_name_pat = self.next(\"method_name\");\n-                let args_pat = self.next(\"args\");\n-\n-                println!(\"MethodCall({}, _, {}, _) = {};\", method_name_pat, args_pat, current);\n-\n-                println!(\n-                    \"    if {}.ident.name.as_str() == {};\",\n-                    method_name_pat,\n-                    method_name.ident.name.as_str()\n-                );\n-\n-                println!(\"    if {}.len() == {};\", args_pat, args.len());\n-\n-                for (i, arg) in args.iter().enumerate() {\n-                    self.current = format!(\"{}[{}]\", args_pat, i);\n-                    self.visit_expr(arg);\n-                }\n+                bind!(self, method_name, args);\n+                kind!(\"MethodCall({method_name}, _, {args}, _)\");\n+                self.ident(field!(method_name.ident));\n+                self.slice(args, |e| self.expr(e));\n             },\n             ExprKind::Tup(elements) => {\n-                let elements_pat = self.next(\"elements\");\n-\n-                println!(\"Tup({}) = {};\", elements_pat, current);\n-\n-                println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n-\n-                for (i, element) in elements.iter().enumerate() {\n-                    self.current = format!(\"{}[{}]\", elements_pat, i);\n-                    self.visit_expr(element);\n-                }\n+                bind!(self, elements);\n+                kind!(\"Tup({elements})\");\n+                self.slice(elements, |e| self.expr(e));\n             },\n             ExprKind::Binary(op, left, right) => {\n-                let op_pat = self.next(\"op\");\n-                let left_pat = self.next(\"left\");\n-                let right_pat = self.next(\"right\");\n-\n-                println!(\"Binary({}, {}, {}) = {};\", op_pat, left_pat, right_pat, current);\n-\n-                println!(\"    if BinOpKind::{:?} == {}.node;\", op.node, op_pat);\n-\n-                self.current = left_pat;\n-                self.visit_expr(left);\n-\n-                self.current = right_pat;\n-                self.visit_expr(right);\n+                bind!(self, op, left, right);\n+                kind!(\"Binary({op}, {left}, {right})\");\n+                out!(\"if BinOpKind::{:?} == {op}.node;\", op.value.node);\n+                self.expr(left);\n+                self.expr(right);\n             },\n             ExprKind::Unary(op, inner) => {\n-                let inner_pat = self.next(\"inner\");\n-\n-                println!(\"Unary(UnOp::{:?}, {}) = {};\", op, inner_pat, current);\n-\n-                self.current = inner_pat;\n-                self.visit_expr(inner);\n-            },\n-            ExprKind::Lit(ref lit) => self.print_lit_expr(lit, &current),\n-            ExprKind::Cast(expr, ty) => {\n-                let cast_pat = self.next(\"expr\");\n-                let cast_ty = self.next(\"cast_ty\");\n-                let qp_label = self.next(\"qpath\");\n-\n-                println!(\"Cast({}, {}) = {};\", cast_pat, cast_ty, current);\n-\n-                if let TyKind::Path(ref qp) = ty.kind {\n-                    println!(\"    if let TyKind::Path(ref {}) = {}.kind;\", qp_label, cast_ty);\n-\n-                    self.current = qp_label;\n-                    self.print_qpath(qp);\n+                bind!(self, inner);\n+                kind!(\"Unary(UnOp::{op:?}, {inner})\");\n+                self.expr(inner);\n+            },\n+            ExprKind::Lit(ref lit) => {\n+                bind!(self, lit);\n+                kind!(\"Lit(ref {lit})\");\n+                self.lit(lit);\n+            },\n+            ExprKind::Cast(expr, cast_ty) => {\n+                bind!(self, expr, cast_ty);\n+                kind!(\"Cast({expr}, {cast_ty})\");\n+                if let TyKind::Path(ref qpath) = cast_ty.value.kind {\n+                    bind!(self, qpath);\n+                    out!(\"if let TyKind::Path(ref {qpath}) = {cast_ty}.kind;\");\n+                    self.qpath(qpath);\n                 }\n-\n-                self.current = cast_pat;\n-                self.visit_expr(expr);\n+                self.expr(expr);\n             },\n             ExprKind::Type(expr, _ty) => {\n-                let cast_pat = self.next(\"expr\");\n-\n-                println!(\"Type({}, _) = {};\", cast_pat, current);\n-\n-                self.current = cast_pat;\n-                self.visit_expr(expr);\n+                bind!(self, expr);\n+                kind!(\"Type({expr}, _)\");\n+                self.expr(expr);\n             },\n             ExprKind::Loop(body, label, des, _) => {\n-                let body_pat = self.next(\"body\");\n-                let label_pat = self.next(\"label\");\n-\n-                println!(\n-                    \"Loop({}, {}, LoopSource::{:?}, _) = {};\",\n-                    body_pat, label_pat, des, current\n-                );\n-\n-                self.current = body_pat;\n-                self.visit_block(body);\n-\n-                self.current = label_pat;\n-                self.print_label(label);\n-            },\n-            ExprKind::If(_, _, _) => {}, // Covered by check_higher\n-            ExprKind::Match(match_expr, arms, des) => self.print_match_expr(match_expr, arms, des, &current),\n-            ExprKind::Closure(capture_clause, fn_decl, body_id, _, movability) => {\n-                let capture_by = format!(\"CaptureBy::{:?}\", capture_clause);\n-\n-                let movability = if let Some(movability) = movability {\n-                    format!(\"Some(Movability::{:?})\", movability)\n-                } else {\n-                    String::from(\"None\")\n-                };\n+                bind!(self, body);\n+                opt_bind!(self, label);\n+                kind!(\"Loop({body}, {label}, LoopSource::{des:?}, _)\");\n+                self.block(body);\n+                label.if_some(|l| self.ident(field!(l.ident)));\n+            },\n+            ExprKind::If(cond, then, else_expr) => {\n+                bind!(self, cond, then);\n+                opt_bind!(self, else_expr);\n+                kind!(\"If({cond}, {then}, {else_expr})\");\n+                self.expr(cond);\n+                self.expr(then);\n+                else_expr.if_some(|e| self.expr(e));\n+            },\n+            ExprKind::Match(scrutinee, arms, des) => {\n+                bind!(self, scrutinee, arms);\n+                kind!(\"Match({scrutinee}, {arms}, MatchSource::{des:?})\");\n+                self.expr(scrutinee);\n+                self.slice(arms, |arm| self.arm(arm));\n+            },\n+            ExprKind::Closure(capture_by, fn_decl, body_id, _, movability) => {\n+                let movability = OptionPat::new(movability.map(|m| format!(\"Movability::{m:?}\")));\n \n                 let ret_ty = match fn_decl.output {\n                     FnRetTy::DefaultReturn(_) => \"FnRetTy::DefaultReturn(_)\",\n                     FnRetTy::Return(_) => \"FnRetTy::Return(_ty)\",\n                 };\n \n-                let fn_decl_pat = self.next(\"fn_decl\");\n-                let body_id_pat = self.next(\"body_id\");\n-\n-                println!(\n-                    \"Closure({}, {}, {}, _, {}) = {};\",\n-                    capture_by, fn_decl_pat, body_id_pat, movability, current\n-                );\n-                println!(\"    if let {} = {}.output;\", ret_ty, fn_decl_pat);\n-\n-                let hir = self.cx.tcx.hir();\n-                let body = hir.body(body_id);\n-\n-                let body_pat = self.next(\"body\");\n-\n-                println!(\"    let {} = cx.tcx.hir().body({});\", body_pat, body_id_pat);\n-\n-                self.current = format!(\"{}.value\", body_pat);\n-                self.visit_expr(&body.value);\n+                bind!(self, fn_decl, body_id);\n+                kind!(\"Closure(CaptureBy::{capture_by:?}, {fn_decl}, {body_id}, _, {movability})\");\n+                out!(\"if let {ret_ty} = {fn_decl}.output;\");\n+                self.body(body_id);\n             },\n             ExprKind::Yield(sub, source) => {\n-                let sub_pat = self.next(\"sub\");\n-\n-                println!(\"Yield(sub, YieldSource::{:?}) = {};\", source, current);\n-\n-                self.current = sub_pat;\n-                self.visit_expr(sub);\n+                bind!(self, sub);\n+                kind!(\"Yield(sub, YieldSource::{source:?})\");\n+                self.expr(sub);\n             },\n             ExprKind::Block(block, label) => {\n-                let block_pat = self.next(\"block\");\n-                let label_pat = self.next(\"label\");\n-\n-                println!(\"Block({}, {}) = {};\", block_pat, label_pat, current);\n-\n-                self.current = block_pat;\n-                self.visit_block(block);\n-\n-                self.current = label_pat;\n-                self.print_label(label);\n+                bind!(self, block);\n+                opt_bind!(self, label);\n+                kind!(\"Block({block}, {label})\");\n+                self.block(block);\n+                label.if_some(|l| self.ident(field!(l.ident)));\n             },\n             ExprKind::Assign(target, value, _) => {\n-                let target_pat = self.next(\"target\");\n-                let value_pat = self.next(\"value\");\n-\n-                println!(\"Assign({}, {}, _span) = {};\", target_pat, value_pat, current);\n-\n-                self.current = target_pat;\n-                self.visit_expr(target);\n-\n-                self.current = value_pat;\n-                self.visit_expr(value);\n+                bind!(self, target, value);\n+                kind!(\"Assign({target}, {value}, _span)\");\n+                self.expr(target);\n+                self.expr(value);\n             },\n             ExprKind::AssignOp(op, target, value) => {\n-                let op_pat = self.next(\"op\");\n-                let target_pat = self.next(\"target\");\n-                let value_pat = self.next(\"value\");\n-\n-                println!(\"AssignOp({}, {}, {}) = {};\", op_pat, target_pat, value_pat, current);\n-\n-                println!(\"    if BinOpKind::{:?} == {}.node;\", op.node, op_pat);\n-\n-                self.current = target_pat;\n-                self.visit_expr(target);\n-\n-                self.current = value_pat;\n-                self.visit_expr(value);\n-            },\n-            ExprKind::Field(object, field_ident) => {\n-                let obj_pat = self.next(\"object\");\n-                let field_name_pat = self.next(\"field_name\");\n-\n-                println!(\"Field({}, {}) = {};\", obj_pat, field_name_pat, current);\n-                println!(\"    if {}.as_str() == {:?};\", field_name_pat, field_ident.as_str());\n-\n-                self.current = obj_pat;\n-                self.visit_expr(object);\n+                bind!(self, op, target, value);\n+                kind!(\"AssignOp({op}, {target}, {value})\");\n+                out!(\"if BinOpKind::{:?} == {op}.node;\", op.value.node);\n+                self.expr(target);\n+                self.expr(value);\n+            },\n+            ExprKind::Field(object, field_name) => {\n+                bind!(self, object, field_name);\n+                kind!(\"Field({object}, {field_name})\");\n+                self.ident(field_name);\n+                self.expr(object);\n             },\n             ExprKind::Index(object, index) => {\n-                let object_pat = self.next(\"object\");\n-                let index_pat = self.next(\"index\");\n-\n-                println!(\"Index({}, {}) = {};\", object_pat, index_pat, current);\n-\n-                self.current = object_pat;\n-                self.visit_expr(object);\n-\n-                self.current = index_pat;\n-                self.visit_expr(index);\n+                bind!(self, object, index);\n+                kind!(\"Index({object}, {index})\");\n+                self.expr(object);\n+                self.expr(index);\n             },\n-            ExprKind::Path(ref path) => {\n-                let path_pat = self.next(\"qpath\");\n-\n-                println!(\"Path(ref {}) = {};\", path_pat, current);\n-\n-                self.current = path_pat;\n-                self.print_qpath(path);\n+            ExprKind::Path(ref qpath) => {\n+                bind!(self, qpath);\n+                kind!(\"Path(ref {qpath})\");\n+                self.qpath(qpath);\n             },\n             ExprKind::AddrOf(kind, mutability, inner) => {\n-                let inner_pat = self.next(\"inner\");\n-\n-                println!(\n-                    \"AddrOf(BorrowKind::{:?}, Mutability::{:?}, {}) = {};\",\n-                    kind, mutability, inner_pat, current\n-                );\n-\n-                self.current = inner_pat;\n-                self.visit_expr(inner);\n+                bind!(self, inner);\n+                kind!(\"AddrOf(BorrowKind::{kind:?}, Mutability::{mutability:?}, {inner})\");\n+                self.expr(inner);\n             },\n-            ExprKind::Break(destination, opt_value) => {\n-                let destination_pat = self.next(\"destination\");\n-\n-                if let Some(value) = opt_value {\n-                    let value_pat = self.next(\"value\");\n-\n-                    println!(\"Break({}, Some({})) = {};\", destination_pat, value_pat, current);\n-\n-                    self.current = value_pat;\n-                    self.visit_expr(value);\n-                } else {\n-                    println!(\"Break({}, None) = {};\", destination_pat, current);\n-                }\n-\n-                self.current = format!(\"{}.label\", destination_pat);\n-                self.print_label(destination.label);\n+            ExprKind::Break(destination, value) => {\n+                bind!(self, destination);\n+                opt_bind!(self, value);\n+                kind!(\"Break({destination}, {value})\");\n+                self.destination(destination);\n+                value.if_some(|e| self.expr(e));\n             },\n             ExprKind::Continue(destination) => {\n-                let destination_pat = self.next(\"destination\");\n-                println!(\"Continue({}) = {};\", destination_pat, current);\n-\n-                self.current = format!(\"{}.label\", destination_pat);\n-                self.print_label(destination.label);\n+                bind!(self, destination);\n+                kind!(\"Continue({destination})\");\n+                self.destination(destination);\n             },\n-            ExprKind::Ret(opt_value) => {\n-                if let Some(value) = opt_value {\n-                    let value_pat = self.next(\"value\");\n-\n-                    println!(\"Ret(Some({})) = {};\", value_pat, current);\n-\n-                    self.current = value_pat;\n-                    self.visit_expr(value);\n-                } else {\n-                    println!(\"Ret(None) = {};\", current);\n-                }\n+            ExprKind::Ret(value) => {\n+                opt_bind!(self, value);\n+                kind!(\"Ret({value})\");\n+                value.if_some(|e| self.expr(e));\n             },\n             ExprKind::InlineAsm(_) => {\n-                println!(\"InlineAsm(_) = {};\", current);\n-                println!(\"    // unimplemented: `ExprKind::InlineAsm` is not further destructured at the moment\");\n+                kind!(\"InlineAsm(_)\");\n+                out!(\"// unimplemented: `ExprKind::InlineAsm` is not further destructured at the moment\");\n             },\n             ExprKind::LlvmInlineAsm(_) => {\n-                println!(\"LlvmInlineAsm(_) = {};\", current);\n-                println!(\"    // unimplemented: `ExprKind::LlvmInlineAsm` is not further destructured at the moment\");\n-            },\n-            ExprKind::Struct(path, fields, opt_base) => {\n-                let path_pat = self.next(\"qpath\");\n-                let fields_pat = self.next(\"fields\");\n-\n-                if let Some(base) = opt_base {\n-                    let base_pat = self.next(\"base\");\n-\n-                    println!(\n-                        \"Struct({}, {}, Some({})) = {};\",\n-                        path_pat, fields_pat, base_pat, current\n-                    );\n-\n-                    self.current = base_pat;\n-                    self.visit_expr(base);\n-                } else {\n-                    println!(\"Struct({}, {}, None) = {};\", path_pat, fields_pat, current);\n-                }\n-\n-                self.current = path_pat;\n-                self.print_qpath(path);\n-\n-                println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n-\n-                for (i, field) in fields.iter().enumerate() {\n-                    println!(\n-                        \"    if {}[{}].ident.name.as_str() == {:?};\",\n-                        fields_pat,\n-                        i,\n-                        &*field.ident.name.as_str()\n-                    );\n-\n-                    self.current = format!(\"{}[{}].expr\", fields_pat, i);\n-                    self.visit_expr(field.expr);\n-                }\n-            },\n-            ExprKind::ConstBlock(_) => {\n-                let value_pat = self.next(\"value\");\n-                println!(\"Const({}) = {}\", value_pat, current);\n-                self.current = value_pat;\n-            },\n+                kind!(\"LlvmInlineAsm(_)\");\n+                out!(\"// unimplemented: `ExprKind::LlvmInlineAsm` is not further destructured at the moment\");\n+            },\n+            ExprKind::Struct(qpath, fields, base) => {\n+                bind!(self, qpath, fields);\n+                opt_bind!(self, base);\n+                kind!(\"Struct({qpath}, {fields}, {base})\");\n+                self.qpath(qpath);\n+                self.slice(fields, |field| {\n+                    self.ident(field!(field.ident));\n+                    self.expr(field!(field.expr));\n+                });\n+                base.if_some(|e| self.expr(e));\n+            },\n+            ExprKind::ConstBlock(_) => kind!(\"ConstBlock(_)\"),\n             ExprKind::Repeat(value, length) => {\n-                let value_pat = self.next(\"value\");\n-                let length_pat = self.next(\"length\");\n-\n-                println!(\"Repeat({}, {}) = {};\", value_pat, length_pat, current);\n-\n-                self.current = value_pat;\n-                self.visit_expr(value);\n-\n-                let hir = self.cx.tcx.hir();\n-                let body = hir.body(length.body);\n-\n-                self.current = format!(\"{}.value\", length_pat);\n-                self.visit_expr(&body.value);\n-            },\n-            ExprKind::Err => {\n-                println!(\"Err = {}\", current);\n+                bind!(self, value, length);\n+                kind!(\"Repeat({value}, {length})\");\n+                self.expr(value);\n+                self.body(field!(length.body));\n             },\n+            ExprKind::Err => kind!(\"Err\"),\n             ExprKind::DropTemps(expr) => {\n-                let expr_pat = self.next(\"expr\");\n-\n-                println!(\"DropTemps({}) = {};\", expr_pat, current);\n-\n-                self.current = expr_pat;\n-                self.visit_expr(expr);\n+                bind!(self, expr);\n+                kind!(\"DropTemps({expr})\");\n+                self.expr(expr);\n             },\n         }\n     }\n \n-    fn visit_block(&mut self, block: &Block<'_>) {\n-        println!(\"    if {}.stmts.len() == {};\", self.current, block.stmts.len());\n-\n-        let block_name = self.current.clone();\n-\n-        for (i, stmt) in block.stmts.iter().enumerate() {\n-            self.current = format!(\"{}.stmts[{}]\", block_name, i);\n-            self.visit_stmt(stmt);\n-        }\n-\n-        if let Some(expr) = block.expr {\n-            self.current = self.next(\"trailing_expr\");\n-            println!(\"    if let Some({}) = {}.expr;\", self.current, block_name);\n-            self.visit_expr(expr);\n-        } else {\n-            println!(\"    if {}.expr.is_none();\", block_name);\n-        }\n+    fn block(&self, block: &Binding<&hir::Block<'_>>) {\n+        self.slice(field!(block.stmts), |stmt| self.stmt(stmt));\n+        self.option(field!(block.expr), \"trailing_expr\", |expr| {\n+            self.expr(expr);\n+        });\n     }\n \n-    #[allow(clippy::too_many_lines)]\n-    fn visit_pat(&mut self, pat: &Pat<'_>) {\n-        print!(\"    if let PatKind::\");\n-        let current = format!(\"{}.kind\", self.current);\n-\n-        match pat.kind {\n-            PatKind::Wild => println!(\"Wild = {};\", current),\n-            PatKind::Binding(anno, .., ident, sub) => {\n-                let anno_pat = &format!(\"BindingAnnotation::{:?}\", anno);\n-                let name_pat = self.next(\"name\");\n-\n-                if let Some(sub) = sub {\n-                    let sub_pat = self.next(\"sub\");\n-\n-                    println!(\n-                        \"Binding({}, _, {}, Some({})) = {};\",\n-                        anno_pat, name_pat, sub_pat, current\n-                    );\n-\n-                    self.current = sub_pat;\n-                    self.visit_pat(sub);\n-                } else {\n-                    println!(\"Binding({}, _, {}, None) = {};\", anno_pat, name_pat, current);\n-                }\n-\n-                println!(\"    if {}.as_str() == \\\"{}\\\";\", name_pat, ident.as_str());\n-            },\n-            PatKind::Struct(ref path, fields, ignore) => {\n-                let path_pat = self.next(\"qpath\");\n-                let fields_pat = self.next(\"fields\");\n-                println!(\"Struct(ref {}, {}, {}) = {};\", path_pat, fields_pat, ignore, current);\n-\n-                self.current = path_pat;\n-                self.print_qpath(path);\n-\n-                println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n+    fn body(&self, body_id: &Binding<hir::BodyId>) {\n+        let expr = &self.cx.tcx.hir().body(body_id.value).value;\n+        bind!(self, expr);\n+        out!(\"let {expr} = &cx.tcx.hir().body({body_id}).value;\");\n+        self.expr(expr);\n+    }\n \n-                for (i, field) in fields.iter().enumerate() {\n-                    println!(\n-                        \"    if {}[{}].ident.name.as_str() == {:?};\",\n-                        fields_pat,\n-                        i,\n-                        &*field.ident.name.as_str()\n-                    );\n+    fn pat(&self, pat: &Binding<&hir::Pat<'_>>) {\n+        let kind = |kind| out!(\"if let PatKind::{kind} = {pat}.kind;\");\n+        macro_rules! kind {\n+            ($($t:tt)*) => (kind(format_args!($($t)*)));\n+        }\n \n-                    self.current = format!(\"{}[{}]\", fields_pat, i);\n-                    self.visit_pat(field.pat);\n-                }\n+        match pat.value.kind {\n+            PatKind::Wild => kind!(\"Wild\"),\n+            PatKind::Binding(anno, .., name, sub) => {\n+                bind!(self, name);\n+                opt_bind!(self, sub);\n+                kind!(\"Binding(BindingAnnotation::{anno:?}, _, {name}, {sub})\");\n+                self.ident(name);\n+                sub.if_some(|p| self.pat(p));\n+            },\n+            PatKind::Struct(ref qpath, fields, ignore) => {\n+                bind!(self, qpath, fields);\n+                kind!(\"Struct(ref {qpath}, {fields}, {ignore})\");\n+                self.qpath(qpath);\n+                self.slice(fields, |field| {\n+                    self.ident(field!(field.ident));\n+                    self.pat(field!(field.pat));\n+                });\n             },\n             PatKind::Or(fields) => {\n-                let fields_pat = self.next(\"fields\");\n-                println!(\"Or({}) = {};\", fields_pat, current);\n-                println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n-\n-                for (i, field) in fields.iter().enumerate() {\n-                    self.current = format!(\"{}[{}]\", fields_pat, i);\n-                    self.visit_pat(field);\n-                }\n+                bind!(self, fields);\n+                kind!(\"Or({fields})\");\n+                self.slice(fields, |pat| self.pat(pat));\n             },\n-            PatKind::TupleStruct(ref path, fields, skip_pos) => {\n-                let path_pat = self.next(\"qpath\");\n-                let fields_pat = self.next(\"fields\");\n-\n-                println!(\n-                    \"TupleStruct(ref {}, {}, {:?}) = {};\",\n-                    path_pat, fields_pat, skip_pos, current\n-                );\n-\n-                self.current = path_pat;\n-                self.print_qpath(path);\n-\n-                println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n-\n-                for (i, field) in fields.iter().enumerate() {\n-                    self.current = format!(\"{}[{}]\", fields_pat, i);\n-                    self.visit_pat(field);\n-                }\n+            PatKind::TupleStruct(ref qpath, fields, skip_pos) => {\n+                bind!(self, qpath, fields);\n+                kind!(\"TupleStruct(ref {qpath}, {fields}, {skip_pos:?})\");\n+                self.qpath(qpath);\n+                self.slice(fields, |pat| self.pat(pat));\n             },\n-            PatKind::Path(ref path) => {\n-                let path_pat = self.next(\"qpath\");\n-                println!(\"Path(ref {}) = {};\", path_pat, current);\n-\n-                self.current = path_pat;\n-                self.print_qpath(path);\n+            PatKind::Path(ref qpath) => {\n+                bind!(self, qpath);\n+                kind!(\"Path(ref {qpath})\");\n+                self.qpath(qpath);\n             },\n             PatKind::Tuple(fields, skip_pos) => {\n-                let fields_pat = self.next(\"fields\");\n-                println!(\"Tuple({}, {:?}) = {};\", fields_pat, skip_pos, current);\n-                println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n-\n-                for (i, field) in fields.iter().enumerate() {\n-                    self.current = format!(\"{}[{}]\", fields_pat, i);\n-                    self.visit_pat(field);\n-                }\n+                bind!(self, fields);\n+                kind!(\"Tuple({fields}, {skip_pos:?})\");\n+                self.slice(fields, |field| self.pat(field));\n             },\n             PatKind::Box(pat) => {\n-                let pat_pat = self.next(\"pat\");\n-                println!(\"Box({}) = {};\", pat_pat, current);\n-\n-                self.current = pat_pat;\n-                self.visit_pat(pat);\n+                bind!(self, pat);\n+                kind!(\"Box({pat})\");\n+                self.pat(pat);\n             },\n             PatKind::Ref(pat, muta) => {\n-                let pat_pat = self.next(\"pat\");\n-                println!(\"Ref({}, Mutability::{:?}) = {};\", pat_pat, muta, current);\n-\n-                self.current = pat_pat;\n-                self.visit_pat(pat);\n+                bind!(self, pat);\n+                kind!(\"Ref({pat}, Mutability::{muta:?})\");\n+                self.pat(pat);\n             },\n             PatKind::Lit(lit_expr) => {\n-                let lit_expr_pat = self.next(\"lit_expr\");\n-                println!(\"Lit({}) = {};\", lit_expr_pat, current);\n-\n-                self.current = lit_expr_pat;\n-                self.visit_expr(lit_expr);\n+                bind!(self, lit_expr);\n+                kind!(\"Lit({lit_expr})\");\n+                self.expr(lit_expr);\n             },\n             PatKind::Range(start, end, end_kind) => {\n-                let start_pat = self.next(\"start\");\n-                let end_pat = self.next(\"end\");\n-\n-                println!(\n-                    \"Range({}, {}, RangeEnd::{:?}) = {};\",\n-                    start_pat, end_pat, end_kind, current\n-                );\n-\n-                self.current = start_pat;\n-                walk_list!(self, visit_expr, start);\n-\n-                self.current = end_pat;\n-                walk_list!(self, visit_expr, end);\n+                opt_bind!(self, start, end);\n+                kind!(\"Range({start}, {end}, RangeEnd::{end_kind:?})\");\n+                start.if_some(|e| self.expr(e));\n+                end.if_some(|e| self.expr(e));\n             },\n             PatKind::Slice(start, middle, end) => {\n-                let start_pat = self.next(\"start\");\n-                let end_pat = self.next(\"end\");\n-\n-                if let Some(middle) = middle {\n-                    let middle_pat = self.next(\"middle\");\n-                    println!(\"Slice({}, Some({}), {}) = {};\", start_pat, middle_pat, end_pat, current);\n-                    self.current = middle_pat;\n-                    self.visit_pat(middle);\n-                } else {\n-                    println!(\"Slice({}, None, {}) = {};\", start_pat, end_pat, current);\n-                }\n-\n-                println!(\"    if {}.len() == {};\", start_pat, start.len());\n-\n-                for (i, pat) in start.iter().enumerate() {\n-                    self.current = format!(\"{}[{}]\", start_pat, i);\n-                    self.visit_pat(pat);\n-                }\n-\n-                println!(\"    if {}.len() == {};\", end_pat, end.len());\n-\n-                for (i, pat) in end.iter().enumerate() {\n-                    self.current = format!(\"{}[{}]\", end_pat, i);\n-                    self.visit_pat(pat);\n-                }\n+                bind!(self, start, end);\n+                opt_bind!(self, middle);\n+                kind!(\"Slice({start}, {middle}, {end})\");\n+                middle.if_some(|p| self.pat(p));\n+                self.slice(start, |pat| self.pat(pat));\n+                self.slice(end, |pat| self.pat(pat));\n             },\n         }\n     }\n \n-    fn visit_stmt(&mut self, s: &Stmt<'_>) {\n-        print!(\"    if let StmtKind::\");\n-        let current = format!(\"{}.kind\", self.current);\n+    fn stmt(&self, stmt: &Binding<&hir::Stmt<'_>>) {\n+        let kind = |kind| out!(\"if let StmtKind::{kind} = {stmt}.kind;\");\n+        macro_rules! kind {\n+            ($($t:tt)*) => (kind(format_args!($($t)*)));\n+        }\n \n-        match s.kind {\n-            // A local (let) binding:\n+        match stmt.value.kind {\n             StmtKind::Local(local) => {\n-                let local_pat = self.next(\"local\");\n-                println!(\"Local({}) = {};\", local_pat, current);\n-\n-                if let Some(init) = local.init {\n-                    let init_pat = self.next(\"init\");\n-                    println!(\"    if let Some({}) = {}.init;\", init_pat, local_pat);\n-\n-                    self.current = init_pat;\n-                    self.visit_expr(init);\n-                }\n-\n-                self.current = format!(\"{}.pat\", local_pat);\n-                self.visit_pat(local.pat);\n-            },\n-            // An item binding:\n-            StmtKind::Item(_) => {\n-                println!(\"Item(item_id) = {};\", current);\n-            },\n-\n-            // Expr without trailing semi-colon (must have unit type):\n+                bind!(self, local);\n+                kind!(\"Local({local})\");\n+                self.option(field!(local.init), \"init\", |init| {\n+                    self.expr(init);\n+                });\n+                self.pat(field!(local.pat));\n+            },\n+            StmtKind::Item(_) => kind!(\"Item(item_id)\"),\n             StmtKind::Expr(e) => {\n-                let e_pat = self.next(\"e\");\n-                println!(\"Expr({}, _) = {};\", e_pat, current);\n-\n-                self.current = e_pat;\n-                self.visit_expr(e);\n+                bind!(self, e);\n+                kind!(\"Expr({e})\");\n+                self.expr(e);\n             },\n-\n-            // Expr with trailing semi-colon (may have any type):\n             StmtKind::Semi(e) => {\n-                let e_pat = self.next(\"e\");\n-                println!(\"Semi({}) = {};\", e_pat, current);\n-\n-                self.current = e_pat;\n-                self.visit_expr(e);\n+                bind!(self, e);\n+                kind!(\"Semi({e})\");\n+                self.expr(e);\n             },\n         }\n     }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n }\n \n fn has_attr(cx: &LateContext<'_>, hir_id: hir::HirId) -> bool {\n     let attrs = cx.tcx.hir().attrs(hir_id);\n     get_attr(cx.sess(), attrs, \"author\").count() > 0\n }\n \n-fn print_path(path: &QPath<'_>, first: &mut bool) {\n-    match *path {\n-        QPath::Resolved(_, path) => {\n-            for segment in path.segments {\n-                if *first {\n-                    *first = false;\n-                } else {\n-                    print!(\", \");\n+fn path_to_string(path: &QPath<'_>) -> String {\n+    fn inner(s: &mut String, path: &QPath<'_>) {\n+        match *path {\n+            QPath::Resolved(_, path) => {\n+                for (i, segment) in path.segments.iter().enumerate() {\n+                    if i > 0 {\n+                        *s += \", \";\n+                    }\n+                    write!(s, \"{:?}\", segment.ident.as_str()).unwrap();\n                 }\n-                print!(\"{:?}\", segment.ident.as_str());\n-            }\n-        },\n-        QPath::TypeRelative(ty, segment) => match ty.kind {\n-            hir::TyKind::Path(ref inner_path) => {\n-                print_path(inner_path, first);\n-                if *first {\n-                    *first = false;\n-                } else {\n-                    print!(\", \");\n-                }\n-                print!(\"{:?}\", segment.ident.as_str());\n             },\n-            ref other => print!(\"/* unimplemented: {:?}*/\", other),\n-        },\n-        QPath::LangItem(..) => panic!(\"print_path: called for lang item qpath\"),\n+            QPath::TypeRelative(ty, segment) => match &ty.kind {\n+                hir::TyKind::Path(inner_path) => {\n+                    inner(s, inner_path);\n+                    *s += \", \";\n+                    write!(s, \"{:?}\", segment.ident.as_str()).unwrap();\n+                },\n+                other => write!(s, \"/* unimplemented: {:?}*/\", other).unwrap(),\n+            },\n+            QPath::LangItem(..) => panic!(\"path_to_string: called for lang item qpath\"),\n+        }\n     }\n+    let mut s = String::new();\n+    inner(&mut s, path);\n+    s\n }"}, {"sha": "2fc4a7d1f7fe87482ebe6edaef25c15f2f350107", "filename": "tests/ui/author/blocks.stdout", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/27a1763eac38123bc206c77cb8b1431671afa81a/tests%2Fui%2Fauthor%2Fblocks.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/27a1763eac38123bc206c77cb8b1431671afa81a/tests%2Fui%2Fauthor%2Fblocks.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fblocks.stdout?ref=27a1763eac38123bc206c77cb8b1431671afa81a", "patch": "@@ -1,5 +1,5 @@\n if_chain! {\n-    if let ExprKind::Block(block, label) = expr.kind;\n+    if let ExprKind::Block(block, None) = expr.kind;\n     if block.stmts.len() == 3;\n     if let StmtKind::Local(local) = block.stmts[0].kind;\n     if let Some(init) = local.init;\n@@ -23,14 +23,14 @@ if_chain! {\n     }\n }\n if_chain! {\n-    if let ExprKind::Block(block, label) = expr.kind;\n+    if let ExprKind::Block(block, None) = expr.kind;\n     if block.stmts.len() == 1;\n     if let StmtKind::Local(local) = block.stmts[0].kind;\n     if let Some(init) = local.init;\n     if let ExprKind::Call(func, args) = init.kind;\n     if let ExprKind::Path(ref qpath) = func.kind;\n     if match_qpath(qpath, &[\"String\", \"new\"]);\n-    if args.len() == 0;\n+    if args.is_empty();\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.kind;\n     if name.as_str() == \"expr\";\n     if let Some(trailing_expr) = block.expr;\n@@ -47,16 +47,16 @@ if_chain! {\n if_chain! {\n     if let ExprKind::Closure(CaptureBy::Value, fn_decl, body_id, _, None) = expr.kind;\n     if let FnRetTy::DefaultReturn(_) = fn_decl.output;\n-    let body = cx.tcx.hir().body(body_id);\n-    if let ExprKind::Call(func, args) = body.value.kind;\n+    let expr1 = &cx.tcx.hir().body(body_id).value;\n+    if let ExprKind::Call(func, args) = expr1.kind;\n     if let ExprKind::Path(ref qpath) = func.kind;\n     if matches!(qpath, QPath::LangItem(LangItem::FromGenerator, _));\n     if args.len() == 1;\n     if let ExprKind::Closure(CaptureBy::Value, fn_decl1, body_id1, _, Some(Movability::Static)) = args[0].kind;\n     if let FnRetTy::DefaultReturn(_) = fn_decl1.output;\n-    let body1 = cx.tcx.hir().body(body_id1);\n-    if let ExprKind::Block(block, label) = body1.value.kind;\n-    if block.stmts.len() == 0;\n+    let expr2 = &cx.tcx.hir().body(body_id1).value;\n+    if let ExprKind::Block(block, None) = expr2.kind;\n+    if block.stmts.is_empty();\n     if block.expr.is_none();\n     then {\n         // report your lint here"}, {"sha": "75ff3faf29aef6c97469970217f0732f748c25d2", "filename": "tests/ui/author/if.stdout", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/27a1763eac38123bc206c77cb8b1431671afa81a/tests%2Fui%2Fauthor%2Fif.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/27a1763eac38123bc206c77cb8b1431671afa81a/tests%2Fui%2Fauthor%2Fif.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fif.stdout?ref=27a1763eac38123bc206c77cb8b1431671afa81a", "patch": "@@ -1,10 +1,11 @@\n if_chain! {\n     if let StmtKind::Local(local) = stmt.kind;\n     if let Some(init) = local.init;\n-    if let Some(higher::If { cond: cond, then: then, r#else: else_expr}) = higher::If::hir(init);\n-    if let ExprKind::Lit(ref lit) = cond.kind;\n+    if let ExprKind::If(cond, then, Some(else_expr)) = init.kind;\n+    if let ExprKind::DropTemps(expr) = cond.kind;\n+    if let ExprKind::Lit(ref lit) = expr.kind;\n     if let LitKind::Bool(true) = lit.node;\n-    if let ExprKind::Block(block, label) = then.kind;\n+    if let ExprKind::Block(block, None) = then.kind;\n     if block.stmts.len() == 1;\n     if let StmtKind::Semi(e) = block.stmts[0].kind;\n     if let ExprKind::Binary(op, left, right) = e.kind;\n@@ -14,7 +15,7 @@ if_chain! {\n     if let ExprKind::Lit(ref lit2) = right.kind;\n     if let LitKind::Int(1, LitIntType::Unsuffixed) = lit2.node;\n     if block.expr.is_none();\n-    if let ExprKind::Block(block1, label1) = else_expr.kind;\n+    if let ExprKind::Block(block1, None) = else_expr.kind;\n     if block1.stmts.len() == 1;\n     if let StmtKind::Semi(e1) = block1.stmts[0].kind;\n     if let ExprKind::Binary(op1, left1, right1) = e1.kind;\n@@ -30,17 +31,18 @@ if_chain! {\n     }\n }\n if_chain! {\n-    if let Some(higher::IfLet { let_pat: let_pat, let_expr: let_expr, if_then: if_then, if_else: else_expr}) = higher::IfLet::hir(expr);\n-    if let PatKind::Lit(lit_expr) = let_pat.kind;\n+    if let ExprKind::If(cond, then, Some(else_expr)) = expr.kind;\n+    if let ExprKind::Let(pat, expr1, _) = cond.kind;\n+    if let PatKind::Lit(lit_expr) = pat.kind;\n     if let ExprKind::Lit(ref lit) = lit_expr.kind;\n     if let LitKind::Bool(true) = lit.node;\n-    if let ExprKind::Path(ref qpath) = let_expr.kind;\n+    if let ExprKind::Path(ref qpath) = expr1.kind;\n     if match_qpath(qpath, &[\"a\"]);\n-    if let ExprKind::Block(block, label) = if_then.kind;\n-    if block.stmts.len() == 0;\n+    if let ExprKind::Block(block, None) = then.kind;\n+    if block.stmts.is_empty();\n     if block.expr.is_none();\n-    if let ExprKind::Block(block1, label1) = else_expr.kind;\n-    if block1.stmts.len() == 0;\n+    if let ExprKind::Block(block1, None) = else_expr.kind;\n+    if block1.stmts.is_empty();\n     if block1.expr.is_none();\n     then {\n         // report your lint here"}, {"sha": "5a1f731ac4a69e7c753f0199bd4c34fdf5631c30", "filename": "tests/ui/author/loop.stdout", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/27a1763eac38123bc206c77cb8b1431671afa81a/tests%2Fui%2Fauthor%2Floop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/27a1763eac38123bc206c77cb8b1431671afa81a/tests%2Fui%2Fauthor%2Floop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Floop.stdout?ref=27a1763eac38123bc206c77cb8b1431671afa81a", "patch": "@@ -1,18 +1,18 @@\n if_chain! {\n-    if let ExprKind::DropTemps(expr) = expr.kind;\n-    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, ..}) = higher::ForLoop::hir(expr);\n+    if let ExprKind::DropTemps(expr1) = expr.kind;\n+    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr1);\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = pat.kind;\n     if name.as_str() == \"y\";\n     if let ExprKind::Struct(qpath, fields, None) = arg.kind;\n     if matches!(qpath, QPath::LangItem(LangItem::Range, _));\n     if fields.len() == 2;\n-    if fields[0].ident.name.as_str() == \"start\";\n+    if fields[0].ident.as_str() == \"start\";\n     if let ExprKind::Lit(ref lit) = fields[0].expr.kind;\n     if let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node;\n-    if fields[1].ident.name.as_str() == \"end\";\n+    if fields[1].ident.as_str() == \"end\";\n     if let ExprKind::Lit(ref lit1) = fields[1].expr.kind;\n     if let LitKind::Int(10, LitIntType::Unsuffixed) = lit1.node;\n-    if let ExprKind::Block(block, label) = body.kind;\n+    if let ExprKind::Block(block, None) = body.kind;\n     if block.stmts.len() == 1;\n     if let StmtKind::Local(local) = block.stmts[0].kind;\n     if let Some(init) = local.init;\n@@ -26,46 +26,47 @@ if_chain! {\n     }\n }\n if_chain! {\n-    if let ExprKind::DropTemps(expr) = expr.kind;\n-    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, ..}) = higher::ForLoop::hir(expr);\n+    if let ExprKind::DropTemps(expr1) = expr.kind;\n+    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr1);\n     if let PatKind::Wild = pat.kind;\n     if let ExprKind::Struct(qpath, fields, None) = arg.kind;\n     if matches!(qpath, QPath::LangItem(LangItem::Range, _));\n     if fields.len() == 2;\n-    if fields[0].ident.name.as_str() == \"start\";\n+    if fields[0].ident.as_str() == \"start\";\n     if let ExprKind::Lit(ref lit) = fields[0].expr.kind;\n     if let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node;\n-    if fields[1].ident.name.as_str() == \"end\";\n+    if fields[1].ident.as_str() == \"end\";\n     if let ExprKind::Lit(ref lit1) = fields[1].expr.kind;\n     if let LitKind::Int(10, LitIntType::Unsuffixed) = lit1.node;\n-    if let ExprKind::Block(block, label) = body.kind;\n+    if let ExprKind::Block(block, None) = body.kind;\n     if block.stmts.len() == 1;\n     if let StmtKind::Semi(e) = block.stmts[0].kind;\n     if let ExprKind::Break(destination, None) = e.kind;\n+    if destination.label.is_none();\n     if block.expr.is_none();\n     then {\n         // report your lint here\n     }\n }\n if_chain! {\n-    if let ExprKind::DropTemps(expr) = expr.kind;\n-    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, ..}) = higher::ForLoop::hir(expr);\n+    if let ExprKind::DropTemps(expr1) = expr.kind;\n+    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr1);\n     if let PatKind::Wild = pat.kind;\n     if let ExprKind::Struct(qpath, fields, None) = arg.kind;\n     if matches!(qpath, QPath::LangItem(LangItem::Range, _));\n     if fields.len() == 2;\n-    if fields[0].ident.name.as_str() == \"start\";\n+    if fields[0].ident.as_str() == \"start\";\n     if let ExprKind::Lit(ref lit) = fields[0].expr.kind;\n     if let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node;\n-    if fields[1].ident.name.as_str() == \"end\";\n+    if fields[1].ident.as_str() == \"end\";\n     if let ExprKind::Lit(ref lit1) = fields[1].expr.kind;\n     if let LitKind::Int(10, LitIntType::Unsuffixed) = lit1.node;\n-    if let ExprKind::Block(block, label) = body.kind;\n+    if let ExprKind::Block(block, None) = body.kind;\n     if block.stmts.len() == 1;\n     if let StmtKind::Semi(e) = block.stmts[0].kind;\n     if let ExprKind::Break(destination, None) = e.kind;\n-    if let Some(label1) = destination.label;\n-    if label_name.ident.name.as_str() == \"'label\";\n+    if let Some(label) = destination.label;\n+    if label.ident.as_str() == \"'label\";\n     if block.expr.is_none();\n     then {\n         // report your lint here\n@@ -75,10 +76,11 @@ if_chain! {\n     if let Some(higher::While { condition: condition, body: body }) = higher::While::hir(expr);\n     if let ExprKind::Path(ref qpath) = condition.kind;\n     if match_qpath(qpath, &[\"a\"]);\n-    if let ExprKind::Block(block, label) = body.kind;\n+    if let ExprKind::Block(block, None) = body.kind;\n     if block.stmts.len() == 1;\n     if let StmtKind::Semi(e) = block.stmts[0].kind;\n     if let ExprKind::Break(destination, None) = e.kind;\n+    if destination.label.is_none();\n     if block.expr.is_none();\n     then {\n         // report your lint here\n@@ -91,20 +93,22 @@ if_chain! {\n     if let LitKind::Bool(true) = lit.node;\n     if let ExprKind::Path(ref qpath) = let_expr.kind;\n     if match_qpath(qpath, &[\"a\"]);\n-    if let ExprKind::Block(block, label) = if_then.kind;\n+    if let ExprKind::Block(block, None) = if_then.kind;\n     if block.stmts.len() == 1;\n     if let StmtKind::Semi(e) = block.stmts[0].kind;\n     if let ExprKind::Break(destination, None) = e.kind;\n+    if destination.label.is_none();\n     if block.expr.is_none();\n     then {\n         // report your lint here\n     }\n }\n if_chain! {\n-    if let ExprKind::Loop(body, label, LoopSource::Loop, _) = expr.kind;\n+    if let ExprKind::Loop(body, None, LoopSource::Loop, _) = expr.kind;\n     if body.stmts.len() == 1;\n     if let StmtKind::Semi(e) = body.stmts[0].kind;\n     if let ExprKind::Break(destination, None) = e.kind;\n+    if destination.label.is_none();\n     if body.expr.is_none();\n     then {\n         // report your lint here"}, {"sha": "38444a0094ca972eb1a0a732dea4ab1ac51e2ad3", "filename": "tests/ui/author/matches.stdout", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27a1763eac38123bc206c77cb8b1431671afa81a/tests%2Fui%2Fauthor%2Fmatches.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/27a1763eac38123bc206c77cb8b1431671afa81a/tests%2Fui%2Fauthor%2Fmatches.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fmatches.stdout?ref=27a1763eac38123bc206c77cb8b1431671afa81a", "patch": "@@ -8,12 +8,14 @@ if_chain! {\n     if let PatKind::Lit(lit_expr) = arms[0].pat.kind;\n     if let ExprKind::Lit(ref lit1) = lit_expr.kind;\n     if let LitKind::Int(16, LitIntType::Unsuffixed) = lit1.node;\n+    if arms[0].guard.is_none();\n     if let ExprKind::Lit(ref lit2) = arms[0].body.kind;\n     if let LitKind::Int(5, LitIntType::Unsuffixed) = lit2.node;\n     if let PatKind::Lit(lit_expr1) = arms[1].pat.kind;\n     if let ExprKind::Lit(ref lit3) = lit_expr1.kind;\n     if let LitKind::Int(17, LitIntType::Unsuffixed) = lit3.node;\n-    if let ExprKind::Block(block, label) = arms[1].body.kind;\n+    if arms[1].guard.is_none();\n+    if let ExprKind::Block(block, None) = arms[1].body.kind;\n     if block.stmts.len() == 1;\n     if let StmtKind::Local(local1) = block.stmts[0].kind;\n     if let Some(init1) = local1.init;\n@@ -25,6 +27,7 @@ if_chain! {\n     if let ExprKind::Path(ref qpath) = trailing_expr.kind;\n     if match_qpath(qpath, &[\"x\"]);\n     if let PatKind::Wild = arms[2].pat.kind;\n+    if arms[2].guard.is_none();\n     if let ExprKind::Lit(ref lit5) = arms[2].body.kind;\n     if let LitKind::Int(1, LitIntType::Unsuffixed) = lit5.node;\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local.pat.kind;"}, {"sha": "f16350e4b5e6d38121a036bb6720a09fd75edc07", "filename": "tests/ui/author/repeat.stdout", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/27a1763eac38123bc206c77cb8b1431671afa81a/tests%2Fui%2Fauthor%2Frepeat.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/27a1763eac38123bc206c77cb8b1431671afa81a/tests%2Fui%2Fauthor%2Frepeat.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Frepeat.stdout?ref=27a1763eac38123bc206c77cb8b1431671afa81a", "patch": "@@ -2,7 +2,8 @@ if_chain! {\n     if let ExprKind::Repeat(value, length) = expr.kind;\n     if let ExprKind::Lit(ref lit) = value.kind;\n     if let LitKind::Int(1, LitIntType::Unsigned(UintTy::U8)) = lit.node;\n-    if let ExprKind::Lit(ref lit1) = length.value.kind;\n+    let expr1 = &cx.tcx.hir().body(length.body).value;\n+    if let ExprKind::Lit(ref lit1) = expr1.kind;\n     if let LitKind::Int(5, LitIntType::Unsuffixed) = lit1.node;\n     then {\n         // report your lint here"}, {"sha": "ded5abd8d334a13066d8bf514aa0d0e6f47857d1", "filename": "tests/ui/author/struct.stdout", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/27a1763eac38123bc206c77cb8b1431671afa81a/tests%2Fui%2Fauthor%2Fstruct.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/27a1763eac38123bc206c77cb8b1431671afa81a/tests%2Fui%2Fauthor%2Fstruct.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fstruct.stdout?ref=27a1763eac38123bc206c77cb8b1431671afa81a", "patch": "@@ -2,17 +2,18 @@ if_chain! {\n     if let ExprKind::Struct(qpath, fields, None) = expr.kind;\n     if match_qpath(qpath, &[\"Test\"]);\n     if fields.len() == 1;\n-    if fields[0].ident.name.as_str() == \"field\";\n-    if let Some(higher::If { cond: cond, then: then, r#else: else_expr}) = higher::If::hir(fields[0].expr);\n-    if let ExprKind::Lit(ref lit) = cond.kind;\n+    if fields[0].ident.as_str() == \"field\";\n+    if let ExprKind::If(cond, then, Some(else_expr)) = fields[0].expr.kind;\n+    if let ExprKind::DropTemps(expr1) = cond.kind;\n+    if let ExprKind::Lit(ref lit) = expr1.kind;\n     if let LitKind::Bool(true) = lit.node;\n-    if let ExprKind::Block(block, label) = then.kind;\n-    if block.stmts.len() == 0;\n+    if let ExprKind::Block(block, None) = then.kind;\n+    if block.stmts.is_empty();\n     if let Some(trailing_expr) = block.expr;\n     if let ExprKind::Lit(ref lit1) = trailing_expr.kind;\n     if let LitKind::Int(1, LitIntType::Unsuffixed) = lit1.node;\n-    if let ExprKind::Block(block1, label1) = else_expr.kind;\n-    if block1.stmts.len() == 0;\n+    if let ExprKind::Block(block1, None) = else_expr.kind;\n+    if block1.stmts.is_empty();\n     if let Some(trailing_expr1) = block1.expr;\n     if let ExprKind::Lit(ref lit2) = trailing_expr1.kind;\n     if let LitKind::Int(0, LitIntType::Unsuffixed) = lit2.node;\n@@ -21,37 +22,39 @@ if_chain! {\n     }\n }\n if_chain! {\n-    if let PatKind::Struct(ref qpath, fields, false) = arm.kind;\n+    if let PatKind::Struct(ref qpath, fields, false) = arm.pat.kind;\n     if match_qpath(qpath, &[\"Test\"]);\n     if fields.len() == 1;\n-    if fields[0].ident.name.as_str() == \"field\";\n-    if let PatKind::Lit(lit_expr) = fields[0].kind;\n+    if fields[0].ident.as_str() == \"field\";\n+    if let PatKind::Lit(lit_expr) = fields[0].pat.kind;\n     if let ExprKind::Lit(ref lit) = lit_expr.kind;\n     if let LitKind::Int(1, LitIntType::Unsuffixed) = lit.node;\n-    if let ExprKind::Block(block, label) = lit_expr.kind;\n-    if block.stmts.len() == 0;\n+    if arm.guard.is_none();\n+    if let ExprKind::Block(block, None) = arm.body.kind;\n+    if block.stmts.is_empty();\n     if block.expr.is_none();\n     then {\n         // report your lint here\n     }\n }\n if_chain! {\n-    if let PatKind::TupleStruct(ref qpath, fields, None) = arm.kind;\n+    if let PatKind::TupleStruct(ref qpath, fields, None) = arm.pat.kind;\n     if match_qpath(qpath, &[\"TestTuple\"]);\n     if fields.len() == 1;\n     if let PatKind::Lit(lit_expr) = fields[0].kind;\n     if let ExprKind::Lit(ref lit) = lit_expr.kind;\n     if let LitKind::Int(1, LitIntType::Unsuffixed) = lit.node;\n-    if let ExprKind::Block(block, label) = lit_expr.kind;\n-    if block.stmts.len() == 0;\n+    if arm.guard.is_none();\n+    if let ExprKind::Block(block, None) = arm.body.kind;\n+    if block.stmts.is_empty();\n     if block.expr.is_none();\n     then {\n         // report your lint here\n     }\n }\n if_chain! {\n     if let ExprKind::MethodCall(method_name, _, args, _) = expr.kind;\n-    if method_name.ident.name.as_str() == test;\n+    if method_name.ident.as_str() == \"test\";\n     if args.len() == 1;\n     if let ExprKind::Path(ref qpath) = args[0].kind;\n     if match_qpath(qpath, &[\"test_method_call\"]);"}]}