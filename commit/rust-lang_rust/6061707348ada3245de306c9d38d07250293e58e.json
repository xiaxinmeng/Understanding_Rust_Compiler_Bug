{"sha": "6061707348ada3245de306c9d38d07250293e58e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwNjE3MDczNDhhZGEzMjQ1ZGUzMDZjOWQzOGQwNzI1MDI5M2U1OGU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-15T22:10:55Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-18T22:18:43Z"}, "message": "rustc: leave only one free top-level function in ppaux, and private.", "tree": {"sha": "8e1e175f4827ba93386cb59c6f035f472df846eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e1e175f4827ba93386cb59c6f035f472df846eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6061707348ada3245de306c9d38d07250293e58e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6061707348ada3245de306c9d38d07250293e58e", "html_url": "https://github.com/rust-lang/rust/commit/6061707348ada3245de306c9d38d07250293e58e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6061707348ada3245de306c9d38d07250293e58e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96ad4a486381497da00ad12413bfc0fbac201189", "url": "https://api.github.com/repos/rust-lang/rust/commits/96ad4a486381497da00ad12413bfc0fbac201189", "html_url": "https://github.com/rust-lang/rust/commit/96ad4a486381497da00ad12413bfc0fbac201189"}], "stats": {"total": 698, "additions": 331, "deletions": 367}, "files": [{"sha": "515e8b82a78f9e5289aa35ef9df0ed2e8e86777f", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 124, "deletions": 4, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/6061707348ada3245de306c9d38d07250293e58e/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6061707348ada3245de306c9d38d07250293e58e/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=6061707348ada3245de306c9d38d07250293e58e", "patch": "@@ -75,6 +75,7 @@ use std::collections::HashSet;\n use ast_map;\n use middle::def;\n use middle::infer;\n+use middle::region;\n use middle::subst;\n use middle::ty::{self, Ty};\n use middle::ty::{Region, ReFree};\n@@ -84,16 +85,135 @@ use std::string::String;\n use syntax::ast;\n use syntax::ast_util::name_to_dummy_lifetime;\n use syntax::owned_slice::OwnedSlice;\n-use syntax::codemap;\n+use syntax::codemap::{Pos, Span};\n use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use util::ppaux::note_and_explain_region;\n \n // Note: only import UserString, not Repr, since user-facing error\n // messages shouldn't include debug serializations.\n use util::ppaux::UserString;\n \n+pub fn note_and_explain_region(tcx: &ty::ctxt,\n+                               prefix: &str,\n+                               region: ty::Region,\n+                               suffix: &str) {\n+    fn item_scope_tag(item: &ast::Item) -> &'static str {\n+        match item.node {\n+            ast::ItemImpl(..) => \"impl\",\n+            ast::ItemStruct(..) => \"struct\",\n+            ast::ItemEnum(..) => \"enum\",\n+            ast::ItemTrait(..) => \"trait\",\n+            ast::ItemFn(..) => \"function body\",\n+            _ => \"item\"\n+        }\n+    }\n+\n+    fn explain_span(tcx: &ty::ctxt, heading: &str, span: Span)\n+                    -> (String, Option<Span>) {\n+        let lo = tcx.sess.codemap().lookup_char_pos_adj(span.lo);\n+        (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize()),\n+         Some(span))\n+    }\n+\n+    let (description, span) = match region {\n+        ty::ReScope(scope) => {\n+            let new_string;\n+            let unknown_scope = || {\n+                format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n+                        prefix, scope, suffix)\n+            };\n+            let span = match scope.span(&tcx.map) {\n+                Some(s) => s,\n+                None => return tcx.sess.note(&unknown_scope())\n+            };\n+            let tag = match tcx.map.find(scope.node_id()) {\n+                Some(ast_map::NodeBlock(_)) => \"block\",\n+                Some(ast_map::NodeExpr(expr)) => match expr.node {\n+                    ast::ExprCall(..) => \"call\",\n+                    ast::ExprMethodCall(..) => \"method call\",\n+                    ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) => \"if let\",\n+                    ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) =>  \"while let\",\n+                    ast::ExprMatch(_, _, ast::MatchSource::ForLoopDesugar) =>  \"for\",\n+                    ast::ExprMatch(..) => \"match\",\n+                    _ => \"expression\",\n+                },\n+                Some(ast_map::NodeStmt(_)) => \"statement\",\n+                Some(ast_map::NodeItem(it)) => item_scope_tag(&*it),\n+                Some(_) | None => {\n+                    return tcx.sess.span_note(span, &unknown_scope());\n+                }\n+            };\n+            let scope_decorated_tag = match scope {\n+                region::CodeExtent::Misc(_) => tag,\n+                region::CodeExtent::ParameterScope { .. } => {\n+                    \"scope of parameters for function\"\n+                }\n+                region::CodeExtent::DestructionScope(_) => {\n+                    new_string = format!(\"destruction scope surrounding {}\", tag);\n+                    &new_string[..]\n+                }\n+                region::CodeExtent::Remainder(r) => {\n+                    new_string = format!(\"block suffix following statement {}\",\n+                                         r.first_statement_index);\n+                    &new_string[..]\n+                }\n+            };\n+            explain_span(tcx, scope_decorated_tag, span)\n+        }\n+\n+        ty::ReFree(ref fr) => {\n+            let prefix = match fr.bound_region {\n+                ty::BrAnon(idx) => {\n+                    format!(\"the anonymous lifetime #{} defined on\", idx + 1)\n+                }\n+                ty::BrFresh(_) => \"an anonymous lifetime defined on\".to_owned(),\n+                _ => {\n+                    format!(\"the lifetime {} as defined on\",\n+                            fr.bound_region.user_string(tcx))\n+                }\n+            };\n+\n+            match tcx.map.find(fr.scope.node_id) {\n+                Some(ast_map::NodeBlock(ref blk)) => {\n+                    let (msg, opt_span) = explain_span(tcx, \"block\", blk.span);\n+                    (format!(\"{} {}\", prefix, msg), opt_span)\n+                }\n+                Some(ast_map::NodeItem(it)) => {\n+                    let tag = item_scope_tag(&*it);\n+                    let (msg, opt_span) = explain_span(tcx, tag, it.span);\n+                    (format!(\"{} {}\", prefix, msg), opt_span)\n+                }\n+                Some(_) | None => {\n+                    // this really should not happen\n+                    (format!(\"{} unknown free region bounded by scope {:?}\",\n+                             prefix, fr.scope), None)\n+                }\n+            }\n+        }\n+\n+        ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n+\n+        ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n+\n+        ty::ReEarlyBound(ref data) => {\n+            (format!(\"{}\", token::get_name(data.name)), None)\n+        }\n+\n+        // I believe these cases should not occur (except when debugging,\n+        // perhaps)\n+        ty::ReInfer(_) | ty::ReLateBound(..) => {\n+            (format!(\"lifetime {:?}\", region), None)\n+        }\n+    };\n+    let message = format!(\"{}{}{}\", prefix, description, suffix);\n+    if let Some(span) = span {\n+        tcx.sess.span_note(span, &message);\n+    } else {\n+        tcx.sess.note(&message);\n+    }\n+}\n+\n pub trait ErrorReporting<'tcx> {\n     fn report_region_errors(&self,\n                             errors: &Vec<RegionResolutionError<'tcx>>);\n@@ -161,7 +281,7 @@ trait ErrorReportingHelpers<'tcx> {\n                                 ident: ast::Ident,\n                                 opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                                 generics: &ast::Generics,\n-                                span: codemap::Span);\n+                                span: Span);\n }\n \n impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n@@ -1430,7 +1550,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                                 ident: ast::Ident,\n                                 opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                                 generics: &ast::Generics,\n-                                span: codemap::Span) {\n+                                span: Span) {\n         let suggested_fn = pprust::fun_to_string(decl, unsafety, constness, ident,\n                                                  opt_explicit_self, generics);\n         let msg = format!(\"consider using an explicit lifetime \\"}, {"sha": "474865305a0757e3ffafb27add2391112e684080", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6061707348ada3245de306c9d38d07250293e58e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6061707348ada3245de306c9d38d07250293e58e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=6061707348ada3245de306c9d38d07250293e58e", "patch": "@@ -48,6 +48,7 @@ use middle::def::{self, DefMap, ExportMap};\n use middle::dependency_format;\n use middle::fast_reject;\n use middle::free_region::FreeRegionMap;\n+use middle::infer::error_reporting::note_and_explain_region;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::mem_categorization as mc;\n use middle::region;\n@@ -61,7 +62,6 @@ use middle::traits;\n use middle::ty;\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n use middle::ty_walk::{self, TypeWalker};\n-use util::ppaux::note_and_explain_region;\n use util::ppaux::{Repr, UserString};\n use util::common::{memoized, ErrorReported};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};"}, {"sha": "c4f69a7f5fe93d70ccdaf65438d3292ce9ba8276", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 193, "deletions": 352, "changes": 545, "blob_url": "https://github.com/rust-lang/rust/blob/6061707348ada3245de306c9d38d07250293e58e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6061707348ada3245de306c9d38d07250293e58e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=6061707348ada3245de306c9d38d07250293e58e", "patch": "@@ -32,7 +32,7 @@ use std::collections::hash_state::HashState;\n use std::hash::Hash;\n use std::rc::Rc;\n use syntax::abi;\n-use syntax::codemap::{Span, Pos};\n+use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n@@ -49,349 +49,15 @@ pub trait UserString<'tcx> : Repr<'tcx> {\n     fn user_string(&self, tcx: &ctxt<'tcx>) -> String;\n }\n \n-pub fn note_and_explain_region(cx: &ctxt,\n-                               prefix: &str,\n-                               region: ty::Region,\n-                               suffix: &str) {\n-    let (description, span) = explain_region_and_span(cx, region);\n-    let message = format!(\"{}{}{}\", prefix, description, suffix);\n-    if let Some(span) = span {\n-        cx.sess.span_note(span, &message);\n-    } else {\n-        cx.sess.note(&message);\n-    }\n-}\n-\n-/// When a free region is associated with `item`, how should we describe the item in the error\n-/// message.\n-fn item_scope_tag(item: &ast::Item) -> &'static str {\n-    match item.node {\n-        ast::ItemImpl(..) => \"impl\",\n-        ast::ItemStruct(..) => \"struct\",\n-        ast::ItemEnum(..) => \"enum\",\n-        ast::ItemTrait(..) => \"trait\",\n-        ast::ItemFn(..) => \"function body\",\n-        _ => \"item\"\n-    }\n-}\n-\n-fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n-                           -> (String, Option<Span>) {\n-    return match region {\n-      ReScope(scope) => {\n-        let new_string;\n-        let on_unknown_scope = || {\n-          (format!(\"unknown scope: {:?}.  Please report a bug.\", scope), None)\n-        };\n-        let span = match scope.span(&cx.map) {\n-          Some(s) => s,\n-          None => return on_unknown_scope(),\n-        };\n-        let tag = match cx.map.find(scope.node_id()) {\n-          Some(ast_map::NodeBlock(_)) => \"block\",\n-          Some(ast_map::NodeExpr(expr)) => match expr.node {\n-              ast::ExprCall(..) => \"call\",\n-              ast::ExprMethodCall(..) => \"method call\",\n-              ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) => \"if let\",\n-              ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) =>  \"while let\",\n-              ast::ExprMatch(_, _, ast::MatchSource::ForLoopDesugar) =>  \"for\",\n-              ast::ExprMatch(..) => \"match\",\n-              _ => \"expression\",\n-          },\n-          Some(ast_map::NodeStmt(_)) => \"statement\",\n-          Some(ast_map::NodeItem(it)) => item_scope_tag(&*it),\n-          Some(_) | None => {\n-            // this really should not happen\n-            return on_unknown_scope();\n-          }\n-        };\n-        let scope_decorated_tag = match scope {\n-            region::CodeExtent::Misc(_) => tag,\n-            region::CodeExtent::ParameterScope { .. } => {\n-                \"scope of parameters for function\"\n-            }\n-            region::CodeExtent::DestructionScope(_) => {\n-                new_string = format!(\"destruction scope surrounding {}\", tag);\n-                &*new_string\n-            }\n-            region::CodeExtent::Remainder(r) => {\n-                new_string = format!(\"block suffix following statement {}\",\n-                                     r.first_statement_index);\n-                &*new_string\n-            }\n-        };\n-        explain_span(cx, scope_decorated_tag, span)\n-\n-      }\n-\n-      ReFree(ref fr) => {\n-        let prefix = match fr.bound_region {\n-          BrAnon(idx) => {\n-              format!(\"the anonymous lifetime #{} defined on\", idx + 1)\n-          }\n-          BrFresh(_) => \"an anonymous lifetime defined on\".to_string(),\n-          _ => {\n-              format!(\"the lifetime {} as defined on\",\n-                      fr.bound_region.user_string(cx))\n-          }\n-        };\n-\n-        match cx.map.find(fr.scope.node_id) {\n-          Some(ast_map::NodeBlock(ref blk)) => {\n-              let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n-              (format!(\"{} {}\", prefix, msg), opt_span)\n-          }\n-          Some(ast_map::NodeItem(it)) => {\n-              let tag = item_scope_tag(&*it);\n-              let (msg, opt_span) = explain_span(cx, tag, it.span);\n-              (format!(\"{} {}\", prefix, msg), opt_span)\n-          }\n-          Some(_) | None => {\n-              // this really should not happen\n-              (format!(\"{} unknown free region bounded by scope {:?}\", prefix, fr.scope), None)\n-          }\n-        }\n-      }\n-\n-      ReStatic => { (\"the static lifetime\".to_string(), None) }\n-\n-      ReEmpty => { (\"the empty lifetime\".to_string(), None) }\n-\n-      ReEarlyBound(ref data) => {\n-        (format!(\"{}\", token::get_name(data.name)), None)\n-      }\n-\n-      // I believe these cases should not occur (except when debugging,\n-      // perhaps)\n-      ty::ReInfer(_) | ty::ReLateBound(..) => {\n-        (format!(\"lifetime {:?}\", region), None)\n-      }\n-    };\n-\n-    fn explain_span(cx: &ctxt, heading: &str, span: Span)\n-                    -> (String, Option<Span>) {\n-        let lo = cx.sess.codemap().lookup_char_pos_adj(span.lo);\n-        (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize()),\n-         Some(span))\n-    }\n-}\n-\n-pub fn mutability_to_string(m: ast::Mutability) -> String {\n-    match m {\n-        ast::MutMutable => \"mut \".to_string(),\n-        ast::MutImmutable => \"\".to_string(),\n-    }\n-}\n-\n-pub fn mt_to_string<'tcx>(cx: &ctxt<'tcx>, m: &mt<'tcx>) -> String {\n-    format!(\"{}{}\",\n-        mutability_to_string(m.mutbl),\n-         m.ty.user_string(cx))\n-}\n-\n-pub fn vec_map_to_string<T, F>(ts: &[T], f: F) -> String where\n-    F: FnMut(&T) -> String,\n-{\n-    let tstrs = ts.iter().map(f).collect::<Vec<String>>();\n-    format!(\"[{}]\", tstrs.connect(\", \"))\n-}\n-\n-fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n-    fn bare_fn_to_string<'tcx>(cx: &ctxt<'tcx>,\n-                               opt_def_id: Option<ast::DefId>,\n-                               unsafety: ast::Unsafety,\n-                               abi: abi::Abi,\n-                               ident: Option<ast::Ident>,\n-                               sig: &ty::PolyFnSig<'tcx>)\n-                               -> String {\n-        let mut s = String::new();\n-\n-        match unsafety {\n-            ast::Unsafety::Normal => {}\n-            ast::Unsafety::Unsafe => {\n-                s.push_str(&unsafety.to_string());\n-                s.push(' ');\n-            }\n-        };\n-\n-        if abi != abi::Rust {\n-            s.push_str(&format!(\"extern {} \", abi.to_string()));\n-        };\n-\n-        s.push_str(\"fn\");\n-\n-        match ident {\n-            Some(i) => {\n-                s.push(' ');\n-                s.push_str(&token::get_ident(i));\n-            }\n-            _ => { }\n-        }\n-\n-        push_sig_to_string(cx, &mut s, '(', ')', sig);\n-\n-        match opt_def_id {\n-            Some(def_id) => {\n-                s.push_str(\" {\");\n-                let path_str = ty::item_path_str(cx, def_id);\n-                s.push_str(&path_str[..]);\n-                s.push_str(\"}\");\n-            }\n-            None => { }\n-        }\n-\n-        s\n-    }\n-\n-    fn closure_to_string<'tcx>(cx: &ctxt<'tcx>,\n-                               cty: &ty::ClosureTy<'tcx>,\n-                               did: &ast::DefId)\n-                               -> String {\n-        let mut s = String::new();\n-        s.push_str(\"[closure\");\n-        push_sig_to_string(cx, &mut s, '(', ')', &cty.sig);\n-        if cx.sess.verbose() {\n-            s.push_str(&format!(\" id={:?}]\", did));\n-        } else {\n-            s.push(']');\n-        }\n-        s\n-    }\n-\n-    fn push_sig_to_string<'tcx>(cx: &ctxt<'tcx>,\n-                                s: &mut String,\n-                                bra: char,\n-                                ket: char,\n-                                sig: &ty::PolyFnSig<'tcx>) {\n-        s.push(bra);\n-        let strs = sig.0.inputs\n-            .iter()\n-            .map(|a| a.user_string(cx))\n-            .collect::<Vec<_>>();\n-        s.push_str(&strs.connect(\", \"));\n-        if sig.0.variadic {\n-            s.push_str(\", ...\");\n-        }\n-        s.push(ket);\n-\n-        match sig.0.output {\n-            ty::FnConverging(t) => {\n-                if !ty::type_is_nil(t) {\n-                   s.push_str(\" -> \");\n-                   s.push_str(& t.user_string(cx));\n-                }\n-            }\n-            ty::FnDiverging => {\n-                s.push_str(\" -> !\");\n-            }\n-        }\n-    }\n-\n-    fn infer_ty_to_string(cx: &ctxt, ty: ty::InferTy) -> String {\n-        let print_var_ids = cx.sess.verbose();\n-        match ty {\n-            ty::TyVar(ref vid) if print_var_ids => vid.repr(cx),\n-            ty::IntVar(ref vid) if print_var_ids => vid.repr(cx),\n-            ty::FloatVar(ref vid) if print_var_ids => vid.repr(cx),\n-            ty::TyVar(_) | ty::IntVar(_) | ty::FloatVar(_) => format!(\"_\"),\n-            ty::FreshTy(v) => format!(\"FreshTy({})\", v),\n-            ty::FreshIntTy(v) => format!(\"FreshIntTy({})\", v),\n-            ty::FreshFloatTy(v) => format!(\"FreshFloatTy({})\", v)\n-        }\n-    }\n-\n-    // pretty print the structural type representation:\n-    match typ.sty {\n-        TyBool => \"bool\".to_string(),\n-        TyChar => \"char\".to_string(),\n-        TyInt(t) => ast_util::int_ty_to_string(t, None).to_string(),\n-        TyUint(t) => ast_util::uint_ty_to_string(t, None).to_string(),\n-        TyFloat(t) => ast_util::float_ty_to_string(t).to_string(),\n-        TyBox(typ) => format!(\"Box<{}>\",  typ.user_string(cx)),\n-        TyRawPtr(ref tm) => {\n-            format!(\"*{} {}\", match tm.mutbl {\n-                ast::MutMutable => \"mut\",\n-                ast::MutImmutable => \"const\",\n-            },  tm.ty.user_string(cx))\n-        }\n-        TyRef(r, ref tm) => {\n-            let mut buf = \"&\".to_owned();\n-            buf.push_str(&r.user_string(cx));\n-            if !buf.is_empty() {\n-                buf.push_str(\" \");\n-            }\n-            buf.push_str(&mt_to_string(cx, tm));\n-            buf\n-        }\n-        TyTuple(ref elems) => {\n-            let strs = elems\n-                .iter()\n-                .map(|elem| elem.user_string(cx))\n-                .collect::<Vec<_>>();\n-            match &strs[..] {\n-                [ref string] => format!(\"({},)\", string),\n-                strs => format!(\"({})\", strs.connect(\", \"))\n-            }\n-        }\n-        TyBareFn(opt_def_id, ref f) => {\n-            bare_fn_to_string(cx, opt_def_id, f.unsafety, f.abi, None, &f.sig)\n-        }\n-        TyInfer(infer_ty) => infer_ty_to_string(cx, infer_ty),\n-        TyError => \"[type error]\".to_string(),\n-        TyParam(ref param_ty) => param_ty.user_string(cx),\n-        TyEnum(did, substs) | TyStruct(did, substs) => {\n-            let base = ty::item_path_str(cx, did);\n-            parameterized(cx, &base, substs, did, &[],\n-                          || ty::lookup_item_type(cx, did).generics)\n-        }\n-        TyTrait(ref data) => {\n-            data.user_string(cx)\n-        }\n-        ty::TyProjection(ref data) => {\n-            format!(\"<{} as {}>::{}\",\n-                    data.trait_ref.self_ty().user_string(cx),\n-                    data.trait_ref.user_string(cx),\n-                    data.item_name.user_string(cx))\n-        }\n-        TyStr => \"str\".to_string(),\n-        TyClosure(ref did, substs) => {\n-            let closure_tys = cx.closure_tys.borrow();\n-            closure_tys.get(did).map(|closure_type| {\n-                closure_to_string(cx, &closure_type.subst(cx, substs), did)\n-            }).unwrap_or_else(|| {\n-                let id_str = if cx.sess.verbose() {\n-                    format!(\" id={:?}\", did)\n-                } else {\n-                    \"\".to_owned()\n-                };\n-\n-\n-                if did.krate == ast::LOCAL_CRATE {\n-                    let span = cx.map.span(did.node);\n-                    format!(\"[closure {}{}]\", span.repr(cx), id_str)\n-                } else {\n-                    format!(\"[closure{}]\", id_str)\n-                }\n-            })\n-        }\n-        TyArray(t, sz) => {\n-            format!(\"[{}; {}]\",  t.user_string(cx), sz)\n-        }\n-        TySlice(t) => {\n-            format!(\"[{}]\",  t.user_string(cx))\n-        }\n-    }\n-}\n-\n fn parameterized<'tcx, GG>(cx: &ctxt<'tcx>,\n-                           base: &str,\n                            substs: &subst::Substs<'tcx>,\n                            did: ast::DefId,\n                            projections: &[ty::ProjectionPredicate<'tcx>],\n                            get_generics: GG)\n                            -> String\n     where GG : FnOnce() -> ty::Generics<'tcx>\n {\n+    let base = ty::item_path_str(cx, did);\n     if cx.sess.verbose() {\n         let mut strings = vec![];\n         match substs.regions {\n@@ -557,27 +223,23 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Box<T> {\n     }\n }\n \n-fn repr_vec<'tcx, T:Repr<'tcx>>(tcx: &ctxt<'tcx>, v: &[T]) -> String {\n-    vec_map_to_string(v, |t| t.repr(tcx))\n-}\n-\n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for [T] {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, self)\n+        format!(\"[{}]\", self.iter().map(|t| t.repr(tcx)).collect::<Vec<_>>().connect(\", \"))\n     }\n }\n \n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for OwnedSlice<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, &self[..])\n+        self[..].repr(tcx)\n     }\n }\n \n // This is necessary to handle types like Option<Vec<T>>, for which\n // autoderef cannot convert the &[T] handler\n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Vec<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, &self[..])\n+        self[..].repr(tcx)\n     }\n }\n \n@@ -618,9 +280,7 @@ type TraitAndProjections<'tcx> =\n impl<'tcx> UserString<'tcx> for TraitAndProjections<'tcx> {\n     fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         let &(ref trait_ref, ref projection_bounds) = self;\n-        let base = ty::item_path_str(tcx, trait_ref.def_id);\n         parameterized(tcx,\n-                      &base,\n                       trait_ref.substs,\n                       trait_ref.def_id,\n                       &projection_bounds[..],\n@@ -684,7 +344,9 @@ impl<'tcx> Repr<'tcx> for ty::TyS<'tcx> {\n \n impl<'tcx> Repr<'tcx> for ty::mt<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        mt_to_string(tcx, self)\n+        format!(\"{}{}\",\n+            if self.mutbl == ast::MutMutable { \"mut \" } else { \"\" },\n+            self.ty.user_string(tcx))\n     }\n }\n \n@@ -751,9 +413,7 @@ impl<'tcx> Repr<'tcx> for ty::TraitRef<'tcx> {\n         // when printing out the debug representation, we don't need\n         // to enumerate the `for<...>` etc because the debruijn index\n         // tells you everything you need to know.\n-        let base = ty::item_path_str(tcx, self.def_id);\n-        let result = parameterized(tcx, &base, self.substs, self.def_id, &[],\n-                      || ty::lookup_trait_def(tcx, self.def_id).generics.clone());\n+        let result = self.user_string(tcx);\n         match self.substs.self_ty() {\n             None => result,\n             Some(sty) => format!(\"<{} as {}>\", sty.repr(tcx), result)\n@@ -1290,15 +950,196 @@ impl<'tcx, T> UserString<'tcx> for ty::Binder<T>\n \n impl<'tcx> UserString<'tcx> for ty::TraitRef<'tcx> {\n     fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        let path_str = ty::item_path_str(tcx, self.def_id);\n-        parameterized(tcx, &path_str, self.substs, self.def_id, &[],\n+        parameterized(tcx, self.substs, self.def_id, &[],\n                       || ty::lookup_trait_def(tcx, self.def_id).generics.clone())\n     }\n }\n \n impl<'tcx> UserString<'tcx> for ty::TyS<'tcx> {\n     fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        ty_to_string(tcx, self)\n+        fn bare_fn_to_string<'tcx>(cx: &ctxt<'tcx>,\n+                                   opt_def_id: Option<ast::DefId>,\n+                                   unsafety: ast::Unsafety,\n+                                   abi: abi::Abi,\n+                                   ident: Option<ast::Ident>,\n+                                   sig: &ty::PolyFnSig<'tcx>)\n+                                   -> String {\n+            let mut s = String::new();\n+\n+            match unsafety {\n+                ast::Unsafety::Normal => {}\n+                ast::Unsafety::Unsafe => {\n+                    s.push_str(&unsafety.to_string());\n+                    s.push(' ');\n+                }\n+            };\n+\n+            if abi != abi::Rust {\n+                s.push_str(&format!(\"extern {} \", abi.to_string()));\n+            };\n+\n+            s.push_str(\"fn\");\n+\n+            match ident {\n+                Some(i) => {\n+                    s.push(' ');\n+                    s.push_str(&token::get_ident(i));\n+                }\n+                _ => { }\n+            }\n+\n+            push_sig_to_string(cx, &mut s, '(', ')', sig);\n+\n+            match opt_def_id {\n+                Some(def_id) => {\n+                    s.push_str(\" {\");\n+                    let path_str = ty::item_path_str(cx, def_id);\n+                    s.push_str(&path_str[..]);\n+                    s.push_str(\"}\");\n+                }\n+                None => { }\n+            }\n+\n+            s\n+        }\n+\n+        fn closure_to_string<'tcx>(cx: &ctxt<'tcx>,\n+                                   cty: &ty::ClosureTy<'tcx>,\n+                                   did: &ast::DefId)\n+                                   -> String {\n+            let mut s = String::new();\n+            s.push_str(\"[closure\");\n+            push_sig_to_string(cx, &mut s, '(', ')', &cty.sig);\n+            if cx.sess.verbose() {\n+                s.push_str(&format!(\" id={:?}]\", did));\n+            } else {\n+                s.push(']');\n+            }\n+            s\n+        }\n+\n+        fn push_sig_to_string<'tcx>(cx: &ctxt<'tcx>,\n+                                    s: &mut String,\n+                                    bra: char,\n+                                    ket: char,\n+                                    sig: &ty::PolyFnSig<'tcx>) {\n+            s.push(bra);\n+            let strs = sig.0.inputs\n+                .iter()\n+                .map(|a| a.user_string(cx))\n+                .collect::<Vec<_>>();\n+            s.push_str(&strs.connect(\", \"));\n+            if sig.0.variadic {\n+                s.push_str(\", ...\");\n+            }\n+            s.push(ket);\n+\n+            match sig.0.output {\n+                ty::FnConverging(t) => {\n+                    if !ty::type_is_nil(t) {\n+                        s.push_str(\" -> \");\n+                        s.push_str(& t.user_string(cx));\n+                    }\n+                }\n+                ty::FnDiverging => {\n+                    s.push_str(\" -> !\");\n+                }\n+            }\n+        }\n+\n+        fn infer_ty_to_string(cx: &ctxt, ty: ty::InferTy) -> String {\n+            let print_var_ids = cx.sess.verbose();\n+            match ty {\n+                ty::TyVar(ref vid) if print_var_ids => vid.repr(cx),\n+                ty::IntVar(ref vid) if print_var_ids => vid.repr(cx),\n+                ty::FloatVar(ref vid) if print_var_ids => vid.repr(cx),\n+                ty::TyVar(_) | ty::IntVar(_) | ty::FloatVar(_) => format!(\"_\"),\n+                ty::FreshTy(v) => format!(\"FreshTy({})\", v),\n+                ty::FreshIntTy(v) => format!(\"FreshIntTy({})\", v),\n+                ty::FreshFloatTy(v) => format!(\"FreshFloatTy({})\", v)\n+            }\n+        }\n+\n+        // pretty print the structural type representation:\n+        match self.sty {\n+            TyBool => \"bool\".to_string(),\n+            TyChar => \"char\".to_string(),\n+            TyInt(t) => ast_util::int_ty_to_string(t, None).to_string(),\n+            TyUint(t) => ast_util::uint_ty_to_string(t, None).to_string(),\n+            TyFloat(t) => ast_util::float_ty_to_string(t).to_string(),\n+            TyBox(typ) => format!(\"Box<{}>\",  typ.user_string(tcx)),\n+            TyRawPtr(ref tm) => {\n+                format!(\"*{} {}\", match tm.mutbl {\n+                    ast::MutMutable => \"mut\",\n+                    ast::MutImmutable => \"const\",\n+                },  tm.ty.user_string(tcx))\n+            }\n+            TyRef(r, ref tm) => {\n+                let mut buf = \"&\".to_owned();\n+                buf.push_str(&r.user_string(tcx));\n+                if !buf.is_empty() {\n+                    buf.push_str(\" \");\n+                }\n+                buf.push_str(&tm.repr(tcx));\n+                buf\n+            }\n+            TyTuple(ref elems) => {\n+                let strs = elems\n+                    .iter()\n+                    .map(|elem| elem.user_string(tcx))\n+                    .collect::<Vec<_>>();\n+                match &strs[..] {\n+                    [ref string] => format!(\"({},)\", string),\n+                    strs => format!(\"({})\", strs.connect(\", \"))\n+                }\n+            }\n+            TyBareFn(opt_def_id, ref f) => {\n+                bare_fn_to_string(tcx, opt_def_id, f.unsafety, f.abi, None, &f.sig)\n+            }\n+            TyInfer(infer_ty) => infer_ty_to_string(tcx, infer_ty),\n+            TyError => \"[type error]\".to_string(),\n+            TyParam(ref param_ty) => param_ty.user_string(tcx),\n+            TyEnum(did, substs) | TyStruct(did, substs) => {\n+                parameterized(tcx, substs, did, &[],\n+                              || ty::lookup_item_type(tcx, did).generics)\n+            }\n+            TyTrait(ref data) => {\n+                data.user_string(tcx)\n+            }\n+            ty::TyProjection(ref data) => {\n+                format!(\"<{} as {}>::{}\",\n+                        data.trait_ref.self_ty().user_string(tcx),\n+                        data.trait_ref.user_string(tcx),\n+                        data.item_name.user_string(tcx))\n+            }\n+            TyStr => \"str\".to_string(),\n+            TyClosure(ref did, substs) => {\n+                let closure_tys = tcx.closure_tys.borrow();\n+                closure_tys.get(did).map(|closure_type| {\n+                    closure_to_string(tcx, &closure_type.subst(tcx, substs), did)\n+                }).unwrap_or_else(|| {\n+                    let id_str = if tcx.sess.verbose() {\n+                        format!(\" id={:?}\", did)\n+                    } else {\n+                        \"\".to_owned()\n+                    };\n+\n+\n+                    if did.krate == ast::LOCAL_CRATE {\n+                        let span = tcx.map.span(did.node);\n+                        format!(\"[closure {}{}]\", span.repr(tcx), id_str)\n+                    } else {\n+                        format!(\"[closure{}]\", id_str)\n+                    }\n+                })\n+            }\n+            TyArray(t, sz) => {\n+                format!(\"[{}; {}]\",  t.user_string(tcx), sz)\n+            }\n+            TySlice(t) => {\n+                format!(\"[{}]\",  t.user_string(tcx))\n+            }\n+        }\n     }\n }\n "}, {"sha": "5833386dd1f022e2ad4f5344809c490f8ba18bf7", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6061707348ada3245de306c9d38d07250293e58e/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6061707348ada3245de306c9d38d07250293e58e/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=6061707348ada3245de306c9d38d07250293e58e", "patch": "@@ -28,11 +28,12 @@ use rustc::middle::dataflow::BitwiseOperator;\n use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::dataflow::KillFrom;\n use rustc::middle::expr_use_visitor as euv;\n-use rustc::middle::mem_categorization as mc;\n use rustc::middle::free_region::FreeRegionMap;\n+use rustc::middle::infer::error_reporting::note_and_explain_region;\n+use rustc::middle::mem_categorization as mc;\n use rustc::middle::region;\n use rustc::middle::ty::{self, Ty};\n-use rustc::util::ppaux::{note_and_explain_region, Repr, UserString};\n+use rustc::util::ppaux::{Repr, UserString};\n use std::mem;\n use std::rc::Rc;\n use std::string::String;"}, {"sha": "898b9b9662db42def54da5954f3f1a50401d00df", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6061707348ada3245de306c9d38d07250293e58e/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6061707348ada3245de306c9d38d07250293e58e/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=6061707348ada3245de306c9d38d07250293e58e", "patch": "@@ -217,7 +217,7 @@ use middle::ty::{self, Ty};\n use session::config::{NoDebugInfo, FullDebugInfo};\n use util::common::indenter;\n use util::nodemap::FnvHashMap;\n-use util::ppaux::{Repr, vec_map_to_string};\n+use util::ppaux::Repr;\n \n use std;\n use std::cmp::Ordering;\n@@ -937,11 +937,11 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      chk: &FailureHandler,\n                                      has_genuine_default: bool)\n                                      -> Block<'blk, 'tcx> {\n-    debug!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals={})\",\n+    debug!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals=[{}])\",\n            bcx.to_str(),\n            bcx.expr_to_string(guard_expr),\n            m.repr(bcx.tcx()),\n-           vec_map_to_string(vals, |v| bcx.val_to_string(*v)));\n+           vals.iter().map(|v| bcx.val_to_string(*v)).collect::<Vec<_>>().connect(\", \"));\n     let _indenter = indenter();\n \n     let mut bcx = insert_lllocals(bcx, &data.bindings_map, None);\n@@ -983,10 +983,10 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         vals: &[ValueRef],\n                                         chk: &FailureHandler,\n                                         has_genuine_default: bool) {\n-    debug!(\"compile_submatch(bcx={}, m={}, vals={})\",\n+    debug!(\"compile_submatch(bcx={}, m={}, vals=[{}])\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n-           vec_map_to_string(vals, |v| bcx.val_to_string(*v)));\n+           vals.iter().map(|v| bcx.val_to_string(*v)).collect::<Vec<_>>().connect(\", \"));\n     let _indenter = indenter();\n     let _icx = push_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;"}, {"sha": "cec267b8f7658312fbde6e32944bb8092365e569", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6061707348ada3245de306c9d38d07250293e58e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6061707348ada3245de306c9d38d07250293e58e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6061707348ada3245de306c9d38d07250293e58e", "patch": "@@ -61,7 +61,7 @@ use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope, ExplicitRscope\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::FnvHashSet;\n-use util::ppaux::{self, Repr, UserString};\n+use util::ppaux::{Repr, UserString};\n \n use std::iter::repeat;\n use std::slice;\n@@ -985,19 +985,21 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n             });\n             match (&ty.node, full_span) {\n                 (&ast::TyRptr(None, ref mut_ty), Some(full_span)) => {\n+                    let mutbl_str = if mut_ty.mutbl == ast::MutMutable { \"mut \" } else { \"\" };\n                     this.tcx().sess\n                         .span_suggestion(full_span, \"try adding parentheses (per RFC 438):\",\n                                          format!(\"&{}({} +{})\",\n-                                                 ppaux::mutability_to_string(mut_ty.mutbl),\n+                                                 mutbl_str,\n                                                  pprust::ty_to_string(&*mut_ty.ty),\n                                                  pprust::bounds_to_string(bounds)));\n                 }\n                 (&ast::TyRptr(Some(ref lt), ref mut_ty), Some(full_span)) => {\n+                    let mutbl_str = if mut_ty.mutbl == ast::MutMutable { \"mut \" } else { \"\" };\n                     this.tcx().sess\n                         .span_suggestion(full_span, \"try adding parentheses (per RFC 438):\",\n                                          format!(\"&{} {}({} +{})\",\n                                                  pprust::lifetime_to_string(lt),\n-                                                 ppaux::mutability_to_string(mut_ty.mutbl),\n+                                                 mutbl_str,\n                                                  pprust::ty_to_string(&*mut_ty.ty),\n                                                  pprust::bounds_to_string(bounds)));\n                 }"}]}