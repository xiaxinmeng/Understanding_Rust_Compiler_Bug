{"sha": "3e20129a18b34ba3aa13efaa53ddfa09dfb1fb7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMjAxMjlhMThiMzRiYTNhYTEzZWZhYTUzZGRmYTA5ZGZiMWZiN2I=", "commit": {"author": {"name": "Smitty", "email": "me@smitop.com", "date": "2021-06-30T19:38:31Z"}, "committer": {"name": "Smitty", "email": "me@smitop.com", "date": "2021-06-30T19:38:31Z"}, "message": "Delay ICE on evaluation fail", "tree": {"sha": "9783c788b4733dbde082c05fac0624ba14f10869", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9783c788b4733dbde082c05fac0624ba14f10869"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e20129a18b34ba3aa13efaa53ddfa09dfb1fb7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e20129a18b34ba3aa13efaa53ddfa09dfb1fb7b", "html_url": "https://github.com/rust-lang/rust/commit/3e20129a18b34ba3aa13efaa53ddfa09dfb1fb7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e20129a18b34ba3aa13efaa53ddfa09dfb1fb7b/comments", "author": {"login": "syvb", "id": 10530973, "node_id": "MDQ6VXNlcjEwNTMwOTcz", "avatar_url": "https://avatars.githubusercontent.com/u/10530973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/syvb", "html_url": "https://github.com/syvb", "followers_url": "https://api.github.com/users/syvb/followers", "following_url": "https://api.github.com/users/syvb/following{/other_user}", "gists_url": "https://api.github.com/users/syvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/syvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/syvb/subscriptions", "organizations_url": "https://api.github.com/users/syvb/orgs", "repos_url": "https://api.github.com/users/syvb/repos", "events_url": "https://api.github.com/users/syvb/events{/privacy}", "received_events_url": "https://api.github.com/users/syvb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "syvb", "id": 10530973, "node_id": "MDQ6VXNlcjEwNTMwOTcz", "avatar_url": "https://avatars.githubusercontent.com/u/10530973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/syvb", "html_url": "https://github.com/syvb", "followers_url": "https://api.github.com/users/syvb/followers", "following_url": "https://api.github.com/users/syvb/following{/other_user}", "gists_url": "https://api.github.com/users/syvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/syvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/syvb/subscriptions", "organizations_url": "https://api.github.com/users/syvb/orgs", "repos_url": "https://api.github.com/users/syvb/repos", "events_url": "https://api.github.com/users/syvb/events{/privacy}", "received_events_url": "https://api.github.com/users/syvb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12a8d106f6a38f45ec01c1b7d3b2c4bfe62d741d", "url": "https://api.github.com/repos/rust-lang/rust/commits/12a8d106f6a38f45ec01c1b7d3b2c4bfe62d741d", "html_url": "https://github.com/rust-lang/rust/commit/12a8d106f6a38f45ec01c1b7d3b2c4bfe62d741d"}], "stats": {"total": 88, "additions": 20, "deletions": 68}, "files": [{"sha": "49e0af9a3a48a45c76a6b0e9d4607befa4ce2abf", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e20129a18b34ba3aa13efaa53ddfa09dfb1fb7b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e20129a18b34ba3aa13efaa53ddfa09dfb1fb7b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=3e20129a18b34ba3aa13efaa53ddfa09dfb1fb7b", "patch": "@@ -8,13 +8,15 @@ use std::ptr;\n \n use rustc_ast::Mutability;\n use rustc_data_structures::sorted_map::SortedMap;\n+use rustc_span::DUMMY_SP;\n use rustc_target::abi::{Align, HasDataLayout, Size};\n \n use super::{\n     read_target_uint, write_target_uint, AllocId, InterpError, InterpResult, Pointer,\n     ResourceExhaustionInfo, Scalar, ScalarMaybeUninit, UndefinedBehaviorInfo, UninitBytesAccess,\n     UnsupportedOpInfo,\n };\n+use crate::ty;\n \n /// This type represents an Allocation in the Miri/CTFE core engine.\n ///\n@@ -132,6 +134,9 @@ impl<Tag> Allocation<Tag> {\n             // deterministic. However, we can be non-determinstic here because all uses of const\n             // evaluation (including ConstProp!) will make compilation fail (via hard error\n             // or ICE) upon encountering a `MemoryExhausted` error.\n+            ty::tls::with(|tcx| {\n+                tcx.sess.delay_span_bug(DUMMY_SP, \"exhausted memory during interpreation\")\n+            });\n             InterpError::ResourceExhaustion(ResourceExhaustionInfo::MemoryExhausted)\n         })?;\n         bytes.resize(size.bytes_usize(), 0);"}, {"sha": "2a6924d354a86730ac775f1f04a27976c9838fcc", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 15, "deletions": 68, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3e20129a18b34ba3aa13efaa53ddfa09dfb1fb7b/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e20129a18b34ba3aa13efaa53ddfa09dfb1fb7b/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=3e20129a18b34ba3aa13efaa53ddfa09dfb1fb7b", "patch": "@@ -31,9 +31,9 @@ use rustc_trait_selection::traits;\n use crate::const_eval::ConstEvalErr;\n use crate::interpret::{\n     self, compile_time_machine, AllocId, Allocation, ConstValue, CtfeValidationMode, Frame, ImmTy,\n-    Immediate, InterpCx, InterpError, InterpResult, LocalState, LocalValue, MemPlace, Memory,\n-    MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer, ResourceExhaustionInfo, Scalar,\n-    ScalarMaybeUninit, StackPopCleanup, StackPopUnwind,\n+    Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemPlace, Memory, MemoryKind, OpTy,\n+    Operand as InterpOperand, PlaceTy, Pointer, Scalar, ScalarMaybeUninit, StackPopCleanup,\n+    StackPopUnwind,\n };\n use crate::transform::MirPass;\n \n@@ -393,12 +393,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             .filter(|ret_layout| {\n                 !ret_layout.is_zst() && ret_layout.size < Size::from_bytes(MAX_ALLOC_LIMIT)\n             })\n-            .and_then(|ret_layout| {\n-                let alloc = ecx.allocate(ret_layout, MemoryKind::Stack);\n-                Self::check_interpresult(tcx, &alloc);\n-                alloc.ok()\n-            })\n-            .map(Into::into);\n+            .map(|ret_layout| {\n+                ecx.allocate(ret_layout, MemoryKind::Stack)\n+                    .expect(\"couldn't perform small allocation\")\n+                    .into()\n+            });\n \n         ecx.push_stack_frame(\n             Instance::new(def_id, substs),\n@@ -421,27 +420,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    /// Some `InterpError`s could be ignored but must not be to ensure that queries are stable.\n-    fn check_interpresult<T>(tcx: TyCtxt<'tcx>, error: &InterpResult<'tcx, T>) {\n-        if let Err(e) = error {\n-            if matches!(\n-                e.kind(),\n-                InterpError::ResourceExhaustion(ResourceExhaustionInfo::MemoryExhausted)\n-            ) {\n-                // Memory errors can't be ignored since otherwise the amount of available\n-                // memory influences the result of optimization and the build. The error\n-                // doesn't need to be fatal since no code will actually be generated anyways.\n-                tcx.sess.fatal(\"memory exhausted during optimization\");\n-            }\n-        }\n-    }\n-\n     fn get_const(&self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n         let op = match self.ecx.eval_place_to_op(place, None) {\n             Ok(op) => op,\n             Err(e) => {\n                 trace!(\"get_const failed: {}\", e);\n-                Self::check_interpresult::<()>(self.tcx, &Err(e));\n                 return None;\n             }\n         };\n@@ -513,19 +496,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                         },\n                         ConstantKind::Val(_, ty) => ty.needs_subst(),\n                     };\n-                    // Memory errors can't be ignored since otherwise the amount of available\n-                    // memory influences the result of optimization and the build. The error\n-                    // doesn't need to be fatal since no code will actually be generated anyways.\n-                    // FIXME(#86255): use err.error.is_hard_err(), but beware of backwards\n-                    // compatibility and interactions with promoteds\n-                    if lint_only\n-                        && !matches!(\n-                            err.error,\n-                            InterpError::ResourceExhaustion(\n-                                ResourceExhaustionInfo::MemoryExhausted,\n-                            ),\n-                        )\n-                    {\n+                    if lint_only {\n                         // Out of backwards compatibility we cannot report hard errors in unused\n                         // generic functions using associated constants of the generic parameters.\n                         err.report_as_lint(tcx, \"erroneous constant used\", lint_root, Some(c.span));\n@@ -543,12 +514,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     /// Returns the value, if any, of evaluating `place`.\n     fn eval_place(&mut self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n-        let tcx = self.tcx;\n-        self.use_ecx(|this| {\n-            let val = this.ecx.eval_place_to_op(place, None);\n-            Self::check_interpresult(tcx, &val);\n-            val\n-        })\n+        self.use_ecx(|this| this.ecx.eval_place_to_op(place, None))\n     }\n \n     /// Returns the value, if any, of evaluating `op`. Calls upon `eval_constant`\n@@ -609,17 +575,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         right: &Operand<'tcx>,\n         source_info: SourceInfo,\n     ) -> Option<()> {\n-        let tcx = self.tcx;\n-        let r = self.use_ecx(|this| {\n-            let val = this.ecx.read_immediate(&this.ecx.eval_operand(right, None)?);\n-            Self::check_interpresult(tcx, &val);\n-            val\n-        });\n-        let l = self.use_ecx(|this| {\n-            let val = this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?);\n-            Self::check_interpresult(tcx, &val);\n-            val\n-        });\n+        let r = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(right, None)?));\n+        let l = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?));\n         // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n         if op == BinOp::Shr || op == BinOp::Shl {\n             let r = r?;\n@@ -785,24 +742,18 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         rvalue: &Rvalue<'tcx>,\n         place: Place<'tcx>,\n     ) -> Option<()> {\n-        let tcx = self.tcx;\n         self.use_ecx(|this| {\n             match rvalue {\n                 Rvalue::BinaryOp(op, box (left, right))\n                 | Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n                     let l = this.ecx.eval_operand(left, None);\n                     let r = this.ecx.eval_operand(right, None);\n-                    Self::check_interpresult(tcx, &l);\n-                    Self::check_interpresult(tcx, &r);\n \n                     let const_arg = match (l, r) {\n                         (Ok(ref x), Err(_)) | (Err(_), Ok(ref x)) => this.ecx.read_immediate(x)?,\n                         (Err(e), Err(_)) => return Err(e),\n                         (Ok(_), Ok(_)) => {\n-                            Self::check_interpresult(\n-                                tcx,\n-                                &this.ecx.eval_rvalue_into_place(rvalue, place),\n-                            );\n+                            this.ecx.eval_rvalue_into_place(rvalue, place)?;\n                             return Ok(());\n                         }\n                     };\n@@ -838,16 +789,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                             }\n                         }\n                         _ => {\n-                            let res = this.ecx.eval_rvalue_into_place(rvalue, place);\n-                            Self::check_interpresult(tcx, &res);\n-                            res?\n+                            this.ecx.eval_rvalue_into_place(rvalue, place)?;\n                         }\n                     }\n                 }\n                 _ => {\n-                    let res = this.ecx.eval_rvalue_into_place(rvalue, place);\n-                    Self::check_interpresult(tcx, &res);\n-                    res?\n+                    this.ecx.eval_rvalue_into_place(rvalue, place)?;\n                 }\n             }\n "}]}