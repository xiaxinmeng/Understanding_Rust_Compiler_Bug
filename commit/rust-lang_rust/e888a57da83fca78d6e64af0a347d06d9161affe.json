{"sha": "e888a57da83fca78d6e64af0a347d06d9161affe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ODhhNTdkYTgzZmNhNzhkNmU2NGFmMGEzNDdkMDZkOTE2MWFmZmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-20T00:16:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-20T00:16:45Z"}, "message": "Auto merge of #84334 - klensy:typo-compiler, r=jyn514\n\nfix few typos in comments", "tree": {"sha": "856acce58191c92f9690379fdbf7731f0b2316ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/856acce58191c92f9690379fdbf7731f0b2316ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e888a57da83fca78d6e64af0a347d06d9161affe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e888a57da83fca78d6e64af0a347d06d9161affe", "html_url": "https://github.com/rust-lang/rust/commit/e888a57da83fca78d6e64af0a347d06d9161affe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e888a57da83fca78d6e64af0a347d06d9161affe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d9c2c92b834c430f102ea96f65119e37320776e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d9c2c92b834c430f102ea96f65119e37320776e", "html_url": "https://github.com/rust-lang/rust/commit/9d9c2c92b834c430f102ea96f65119e37320776e"}, {"sha": "f43ee8ebf696eec5a8a844629e4f7e910f9f0afd", "url": "https://api.github.com/repos/rust-lang/rust/commits/f43ee8ebf696eec5a8a844629e4f7e910f9f0afd", "html_url": "https://github.com/rust-lang/rust/commit/f43ee8ebf696eec5a8a844629e4f7e910f9f0afd"}], "stats": {"total": 78, "additions": 39, "deletions": 39}, "files": [{"sha": "e7f19f06ebef5c07197d45a2213c2f5722dcc4fc", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -1346,7 +1346,7 @@ pub enum ExprKind {\n     Field(P<Expr>, Ident),\n     /// An indexing operation (e.g., `foo[2]`).\n     Index(P<Expr>, P<Expr>),\n-    /// A range (e.g., `1..2`, `1..`, `..2`, `1..=2`, `..=2`; and `..` in destructuring assingment).\n+    /// A range (e.g., `1..2`, `1..`, `..2`, `1..=2`, `..=2`; and `..` in destructuring assignment).\n     Range(Option<P<Expr>>, Option<P<Expr>>, RangeLimits),\n     /// An underscore, used in destructuring assignment to ignore a value.\n     Underscore,"}, {"sha": "2d463a4588c561ecd8e1df5da5eca65000a10b5e", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -301,7 +301,7 @@ impl AttrAnnotatedTokenStream {\n /// tokens.\n ///\n /// For example, `#[cfg(FALSE)] struct Foo {}` would\n-/// have an `attrs` field contaiing the `#[cfg(FALSE)]` attr,\n+/// have an `attrs` field containing the `#[cfg(FALSE)]` attr,\n /// and a `tokens` field storing the (unparesd) tokens `struct Foo {}`\n #[derive(Clone, Debug, Encodable, Decodable)]\n pub struct AttributesData {"}, {"sha": "f1a31f0d4f5c9eac35b9fd29d8520afc838f26a3", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -321,7 +321,7 @@ struct HandlerInner {\n \n     /// This set contains the `DiagnosticId` of all emitted diagnostics to avoid\n     /// emitting the same diagnostic with extended help (`--teach`) twice, which\n-    /// would be uneccessary repetition.\n+    /// would be unnecessary repetition.\n     taught_diagnostics: FxHashSet<DiagnosticId>,\n \n     /// Used to suggest rustc --explain <error code>"}, {"sha": "5244ac36bba5de5badcc923c8728078b06e229b8", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -69,7 +69,7 @@ enum KleeneOp {\n     ZeroOrMore,\n     /// Kleene plus (`+`) for one or more repetitions\n     OneOrMore,\n-    /// Kleene optional (`?`) for zero or one reptitions\n+    /// Kleene optional (`?`) for zero or one repetitions\n     ZeroOrOne,\n }\n "}, {"sha": "f9e7c4254bc495b29b08898fa1b8018f0c34ca61", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -209,7 +209,7 @@ pub(super) fn transcribe<'a>(\n                             }\n                         } else {\n                             // 0 is the initial counter (we have done 0 repretitions so far). `len`\n-                            // is the total number of reptitions we should generate.\n+                            // is the total number of repetitions we should generate.\n                             repeats.push((0, len));\n \n                             // The first time we encounter the sequence we push it to the stack. It\n@@ -362,7 +362,7 @@ impl LockstepIterSize {\n /// appropriate meta-vars in `interpolations`.\n ///\n /// Note that if `repeats` does not match the exact correct depth of a meta-var,\n-/// `lookup_cur_matched` will return `None`, which is why this still works even in the presnece of\n+/// `lookup_cur_matched` will return `None`, which is why this still works even in the presence of\n /// multiple nested matcher sequences.\n fn lockstep_iter_size(\n     tree: &mbe::TokenTree,"}, {"sha": "30214e94203d81d078d413709ea2365f8b8487fa", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -191,7 +191,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n     ///\n     /// This also tests if the given const `ct` contains an inference variable which was previously\n     /// unioned with `target_vid`. If this is the case, inferring `target_vid` to `ct`\n-    /// would result in an infinite type as we continously replace an inference variable\n+    /// would result in an infinite type as we continuously replace an inference variable\n     /// in `ct` with `ct` itself.\n     ///\n     /// This is especially important as unevaluated consts use their parents generics."}, {"sha": "077d2cc20a25c3fdaf7bc8f20c4325f024baf5d1", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -279,7 +279,7 @@ where\n     /// Relate a type inference variable with a value type. This works\n     /// by creating a \"generalization\" G of the value where all the\n     /// lifetimes are replaced with fresh inference values. This\n-    /// genearlization G becomes the value of the inference variable,\n+    /// generalization G becomes the value of the inference variable,\n     /// and is then related in turn to the value. So e.g. if you had\n     /// `vid = ?0` and `value = &'a u32`, we might first instantiate\n     /// `?0` to a type like `&'0 u32` where `'0` is a fresh variable,"}, {"sha": "3965a3dcdfd5d9d623a2d2a634cb553f2fb02829", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -3022,7 +3022,7 @@ impl<'tcx> LateLintPass<'tcx> for DerefNullPtr {\n             false\n         }\n \n-        /// test if experssion is the literal `0`\n+        /// test if expression is the literal `0`\n         fn is_zero(expr: &hir::Expr<'_>) -> bool {\n             match &expr.kind {\n                 rustc_hir::ExprKind::Lit(ref lit) => {"}, {"sha": "f15a7cc5ec2caf88252e0514cd383e7413a6e24e", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -2483,7 +2483,7 @@ declare_lint! {\n     ///\n     /// On x86, `asm!` uses the intel assembly syntax by default. While this\n     /// can be switched using assembler directives like `.att_syntax`, using the\n-    /// `att_syntax` option is recomended instead because it will also properly\n+    /// `att_syntax` option is recommended instead because it will also properly\n     /// prefix register placeholders with `%` as required by AT&T syntax.\n     pub BAD_ASM_STYLE,\n     Warn,\n@@ -2678,7 +2678,7 @@ declare_lint! {\n     /// Statics with an uninhabited type can never be initialized, so they are impossible to define.\n     /// However, this can be side-stepped with an `extern static`, leading to problems later in the\n     /// compiler which assumes that there are no initialized uninhabited places (such as locals or\n-    /// statics). This was accientally allowed, but is being phased out.\n+    /// statics). This was accidentally allowed, but is being phased out.\n     pub UNINHABITED_STATIC,\n     Warn,\n     \"uninhabited static\","}, {"sha": "cc0df127434e50b3967fdc01e9d4fb9611f56540", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -45,7 +45,7 @@ static_assert_size!(InterpErrorInfo<'_>, 8);\n \n /// Packages the kind of error we got from the const code interpreter\n /// up with a Rust-level backtrace of where the error occurred.\n-/// Thsese should always be constructed by calling `.into()` on\n+/// These should always be constructed by calling `.into()` on\n /// a `InterpError`. In `rustc_mir::interpret`, we have `throw_err_*`\n /// macros for this.\n #[derive(Debug)]"}, {"sha": "998868211401f0384f4385ee59bf03d2db1233ce", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -1521,7 +1521,7 @@ pub enum StatementKind<'tcx> {\n     /// Marks the start of a \"coverage region\", injected with '-Zinstrument-coverage'. A\n     /// `Coverage` statement carries metadata about the coverage region, used to inject a coverage\n     /// map into the binary. If `Coverage::kind` is a `Counter`, the statement also generates\n-    /// executable code, to increment a counter varible at runtime, each time the code region is\n+    /// executable code, to increment a counter variable at runtime, each time the code region is\n     /// executed.\n     Coverage(Box<Coverage>),\n "}, {"sha": "a1a56eb1b5b44c4a8f4010e30abddf255eedbe8c", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -1280,7 +1280,7 @@ rustc_queries! {\n         desc { \"testing if a region is late bound\" }\n     }\n     /// For a given item (like a struct), gets the default lifetimes to be used\n-    /// for each paramter if a trait object were to be passed for that parameter.\n+    /// for each parameter if a trait object were to be passed for that parameter.\n     /// For example, for `struct Foo<'a, T, U>`, this would be `['static, 'static]`.\n     /// For `struct Foo<'a, T: 'a, U>`, this would instead be `['a, 'static]`.\n     query object_lifetime_defaults_map(_: LocalDefId)"}, {"sha": "887a5831cd720e3a4971b877d137d1d9ff82369b", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -160,7 +160,7 @@ impl CapturedPlace<'tcx> {\n         }\n     }\n \n-    /// Returns the `LocalDefId` of the closure that captureed this Place\n+    /// Returns the `LocalDefId` of the closure that captured this Place\n     pub fn get_closure_local_def_id(&self) -> LocalDefId {\n         match self.place.base {\n             HirPlaceBase::Upvar(upvar_id) => upvar_id.closure_expr_id,"}, {"sha": "7dc3434bf333867fd21707db468d8d7ed4869b79", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -1,4 +1,4 @@\n-//! Contains utilities for generating suggestions for borrowck errors related to unsatisified\n+//! Contains utilities for generating suggestions for borrowck errors related to unsatisfied\n //! outlives constraints.\n \n use std::collections::BTreeMap;"}, {"sha": "8e9148f5b6643f7a3830d5c8cea5d17b56646024", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -53,7 +53,7 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n /// Extra machine state for CTFE, and the Machine instance\n pub struct CompileTimeInterpreter<'mir, 'tcx> {\n     /// For now, the number of terminators that can be evaluated before we throw a resource\n-    /// exhuastion error.\n+    /// exhaustion error.\n     ///\n     /// Setting this to `0` disables the limit and allows the interpreter to run forever.\n     pub steps_remaining: usize,"}, {"sha": "344d7b9becd1955c4c69cb2c83ab970e6e032707", "filename": "compiler/rustc_mir/src/dataflow/framework/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fmod.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -510,7 +510,7 @@ impl EffectIndex {\n         }\n     }\n \n-    /// Returns `true` if the effect at `self` should be applied eariler than the effect at `other`\n+    /// Returns `true` if the effect at `self` should be applied earlier than the effect at `other`\n     /// in forward order.\n     fn precedes_in_forward_order(self, other: Self) -> bool {\n         let ord = self"}, {"sha": "e5bc9320260c64b900b25e78f01677fb1fe4a9ca", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -225,7 +225,7 @@ impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag> {\n }\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    /// Normalice `place.ptr` to a `Pointer` if this is a place and not a ZST.\n+    /// Normalize `place.ptr` to a `Pointer` if this is a place and not a ZST.\n     /// Can be helpful to avoid lots of `force_ptr` calls later, if this place is used a lot.\n     #[inline]\n     pub fn force_op_ptr("}, {"sha": "ac8c748ea85710a4dc9d09d01ac75f75ae499472", "filename": "compiler/rustc_mir/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -29,11 +29,11 @@ pub fn in_any_value_of_ty(\n /// Normally, we would determine what qualifications apply to each type and error when an illegal\n /// operation is performed on such a type. However, this was found to be too imprecise, especially\n /// in the presence of `enum`s. If only a single variant of an enum has a certain qualification, we\n-/// needn't reject code unless it actually constructs and operates on the qualifed variant.\n+/// needn't reject code unless it actually constructs and operates on the qualified variant.\n ///\n /// To accomplish this, const-checking and promotion use a value-based analysis (as opposed to a\n /// type-based one). Qualifications propagate structurally across variables: If a local (or a\n-/// projection of a local) is assigned a qualifed value, that local itself becomes qualifed.\n+/// projection of a local) is assigned a qualified value, that local itself becomes qualified.\n pub trait Qualif {\n     /// The name of the file used to debug the dataflow analysis that computes this qualif.\n     const ANALYSIS_NAME: &'static str;"}, {"sha": "48361483099f2f325f1b67e9443a74acddd1d32f", "filename": "compiler/rustc_mir/src/transform/coverage/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -816,7 +816,7 @@ fn bcb_to_string_sections(\n     sections\n }\n \n-/// Returns a simple string representation of a `TerminatorKind` variant, indenpendent of any\n+/// Returns a simple string representation of a `TerminatorKind` variant, independent of any\n /// values it might hold.\n pub(super) fn term_type(kind: &TerminatorKind<'tcx>) -> &'static str {\n     match kind {"}, {"sha": "dee112443d337f9952bd538d793f315e9b789a8d", "filename": "compiler/rustc_mir/src/transform/coverage/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -17,7 +17,7 @@\n //! Also note, some basic features of `Span` also rely on the `Span`s own \"session globals\", which\n //! are unrelated to the `TyCtxt` global. Without initializing the `Span` session globals, some\n //! basic, coverage-specific features would be impossible to test, but thankfully initializing these\n-//! globals is comparitively simpler. The easiest way is to wrap the test in a closure argument\n+//! globals is comparatively simpler. The easiest way is to wrap the test in a closure argument\n //! to: `rustc_span::with_default_session_globals(|| { test_here(); })`.\n \n use super::counters;"}, {"sha": "33ad128eeeb7503847c1c63974e5ab491de1830e", "filename": "compiler/rustc_mir/src/util/find_self_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_mir%2Fsrc%2Futil%2Ffind_self_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_mir%2Fsrc%2Futil%2Ffind_self_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Ffind_self_call.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -3,7 +3,7 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::def_id::DefId;\n \n-/// Checks if the specified `local` is used as the `self` prameter of a method call\n+/// Checks if the specified `local` is used as the `self` parameter of a method call\n /// in the provided `BasicBlock`. If it is, then the `DefId` of the called method is\n /// returned.\n pub fn find_self_call<'tcx>("}, {"sha": "1053890e61837bd7efe0955942bc8ab79698531d", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -80,7 +80,7 @@ crate struct PlaceBuilder<'tcx> {\n /// The projections are truncated to represent a path that might be captured by a\n /// closure/generator. This implies the vector returned from this function doesn't contain\n /// ProjectionElems `Downcast`, `ConstantIndex`, `Index`, or `Subslice` because those will never be\n-/// part of a path that is captued by a closure. We stop applying projections once we see the first\n+/// part of a path that is captured by a closure. We stop applying projections once we see the first\n /// projection that isn't captured by a closure.\n fn convert_to_hir_projections_and_truncate_for_capture<'tcx>(\n     mir_projections: &[PlaceElem<'tcx>],\n@@ -578,7 +578,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// Lower a captured upvar. Note we might not know the actual capture index,\n     /// so we create a place starting from `PlaceBase::Upvar`, which will be resolved\n-    /// once all projections that allow us to indentify a capture have been applied.\n+    /// once all projections that allow us to identify a capture have been applied.\n     fn lower_captured_upvar(\n         &mut self,\n         block: BasicBlock,"}, {"sha": "299b9a959c56ff03c90d79ca3cc00f380ea10ebc", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -1448,7 +1448,7 @@ impl<'a> Parser<'a> {\n         Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, macro_rules: false })))\n     }\n \n-    /// Is this unambiguously the start of a `macro_rules! foo` item defnition?\n+    /// Is this unambiguously the start of a `macro_rules! foo` item definition?\n     fn is_macro_rules_item(&mut self) -> bool {\n         self.check_keyword(kw::MacroRules)\n             && self.look_ahead(1, |t| *t == token::Not)"}, {"sha": "d37a5be2fe515d058c3de9bf910b3b536b5d064c", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -1114,7 +1114,7 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n \n ////////////////////////////////////////////////////////////////////////////////////////////\n /// Type privacy visitor, checks types for privacy and reports violations.\n-/// Both explicitly written types and inferred types of expressions and patters are checked.\n+/// Both explicitly written types and inferred types of expressions and patterns are checked.\n /// Checks are performed on \"semantic\" types regardless of names and their hygiene.\n ////////////////////////////////////////////////////////////////////////////////////////////\n "}, {"sha": "fc1ea4ec846294eda44574c57d0ccab1b6673e3b", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -245,7 +245,7 @@ enum Scope<'a> {\n         opaque_type_parent: bool,\n \n         /// True only if this `Binder` scope is from the quantifiers on a\n-        /// `PolyTraitRef`. This is necessary for `assocated_type_bounds`, which\n+        /// `PolyTraitRef`. This is necessary for `associated_type_bounds`, which\n         /// requires binders of nested trait refs to be merged.\n         from_poly_trait_ref: bool,\n \n@@ -303,7 +303,7 @@ enum Scope<'a> {\n     /// of. Other than that, if ask for bound vars for each, we expect\n     /// `['a, 'b]`. If we *didn't* allow binders before `T`, then we would\n     /// always introduce a binder scope at the inner trait ref. This is great,\n-    /// becauase later on during type-checking, we will ask \"what are the late\n+    /// because later on during type-checking, we will ask \"what are the late\n     /// bound vars on this trait ref\". However, because we allow bound vars on\n     /// the bound itself, we have to have some way of keeping track of the fact\n     /// that we actually want to store the late bound vars as being associated"}, {"sha": "f75fe22767f47008499b1938c22cb9fb7cdfdf1d", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -748,7 +748,7 @@ pub struct ExpnData {\n \n     /// Used to force two `ExpnData`s to have different `Fingerprint`s.\n     /// Due to macro expansion, it's possible to end up with two `ExpnId`s\n-    /// that have identical `ExpnData`s. This violates the constract of `HashStable`\n+    /// that have identical `ExpnData`s. This violates the contract of `HashStable`\n     /// - the two `ExpnId`s are not equal, but their `Fingerprint`s are equal\n     /// (since the numerical `ExpnId` value is not considered by the `HashStable`\n     /// implementation)."}, {"sha": "0cf2441d84e04c5655a2fedf31208e08691d696c", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -73,8 +73,8 @@ mod attr_impl {\n }\n \n /// Sometimes an ABI requires small integers to be extended to a full or partial register. This enum\n-/// defines if this extension should be zero-extension or sign-extension when necssary. When it is\n-/// not necesary to extend the argument, this enum is ignored.\n+/// defines if this extension should be zero-extension or sign-extension when necessary. When it is\n+/// not necessary to extend the argument, this enum is ignored.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum ArgExtension {\n     None,"}, {"sha": "da5a1af7f770e929e49f5e9a6259bac5522ff4a7", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -1954,7 +1954,7 @@ pub enum ArgKind {\n     Arg(String, String),\n \n     /// An argument of tuple type. For a \"found\" argument, the span is\n-    /// the locationo in the source of the pattern. For a \"expected\"\n+    /// the location in the source of the pattern. For a \"expected\"\n     /// argument, it will be None. The vector is a list of (name, ty)\n     /// strings for the components of the tuple.\n     Tuple(Option<Span>, Vec<(String, String)>),"}, {"sha": "e4aabbdb7ede7be92a145e5850c5e4967db34243", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -944,7 +944,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// subobligations without taking in a 'parent' depth, causing the\n     /// generated subobligations to have a `recursion_depth` of `0`.\n     ///\n-    /// To ensure that obligation_depth never decreasees, we force all subobligations\n+    /// To ensure that obligation_depth never decreases, we force all subobligations\n     /// to have at least the depth of the original obligation.\n     fn add_depth<T: 'cx, I: Iterator<Item = &'cx mut Obligation<'tcx, T>>>(\n         &self,"}, {"sha": "c2998c841312f926d50b7c54e8a840a920fab7db", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -158,7 +158,7 @@ enum ProbeResult {\n \n /// When adjusting a receiver we often want to do one of\n ///\n-/// - Add a `&` (or `&mut`), converting the recevier from `T` to `&T` (or `&mut T`)\n+/// - Add a `&` (or `&mut`), converting the receiver from `T` to `&T` (or `&mut T`)\n /// - If the receiver has type `*mut T`, convert it to `*const T`\n ///\n /// This type tells us which one to do."}, {"sha": "751eebb9f95644ed2eaa0b0271f2122f6a475ab8", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -1588,7 +1588,7 @@ fn migration_suggestion_for_2229(\n /// If both the CaptureKind and Expression are considered to be equivalent,\n /// then `CaptureInfo` A is preferred. This can be useful in cases where we want to priortize\n /// expressions reported back to the user as part of diagnostics based on which appears earlier\n-/// in the closure. This can be acheived simply by calling\n+/// in the closure. This can be achieved simply by calling\n /// `determine_capture_info(existing_info, current_info)`. This works out because the\n /// expressions that occur earlier in the closure body than the current expression are processed before.\n /// Consider the following example"}, {"sha": "532ee00daf8a0a306aa62ab1d79455a2287371b1", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e888a57da83fca78d6e64af0a347d06d9161affe/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=e888a57da83fca78d6e64af0a347d06d9161affe", "patch": "@@ -671,7 +671,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// In the following example the closures `c` only captures `p.x`` even though `incr`\n     /// is a capture of the nested closure\n     ///\n-    /// ```rust,ignore(cannot-test-this-because-pseduo-code)\n+    /// ```rust,ignore(cannot-test-this-because-pseudo-code)\n     /// let p = ..;\n     /// let c = || {\n     ///    let incr = 10;\n@@ -715,7 +715,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                             // The only places we want to fake read before creating the parent closure are the ones that\n                             // are not local to it/ defined by it.\n                             //\n-                            // ```rust,ignore(cannot-test-this-because-pseduo-code)\n+                            // ```rust,ignore(cannot-test-this-because-pseudo-code)\n                             // let v1 = (0, 1);\n                             // let c = || { // fake reads: v1\n                             //    let v2 = (0, 1);"}]}