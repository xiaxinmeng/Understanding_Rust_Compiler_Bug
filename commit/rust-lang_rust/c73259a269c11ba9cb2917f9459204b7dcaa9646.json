{"sha": "c73259a269c11ba9cb2917f9459204b7dcaa9646", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MzI1OWEyNjljMTFiYTljYjI5MTdmOTQ1OTIwNGI3ZGNhYTk2NDY=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-01T18:00:23Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-14T01:15:38Z"}, "message": "libcore: convert binop traits to by value", "tree": {"sha": "941e5b8b80ce78df0aaad626202986b96f9e1b0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/941e5b8b80ce78df0aaad626202986b96f9e1b0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c73259a269c11ba9cb2917f9459204b7dcaa9646", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c73259a269c11ba9cb2917f9459204b7dcaa9646", "html_url": "https://github.com/rust-lang/rust/commit/c73259a269c11ba9cb2917f9459204b7dcaa9646", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c73259a269c11ba9cb2917f9459204b7dcaa9646/comments", "author": null, "committer": null, "parents": [{"sha": "227435a11eb3bf06049b2420ce648b238decfcd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/227435a11eb3bf06049b2420ce648b238decfcd5", "html_url": "https://github.com/rust-lang/rust/commit/227435a11eb3bf06049b2420ce648b238decfcd5"}], "stats": {"total": 437, "additions": 437, "deletions": 0}, "files": [{"sha": "d283d70815c33b599e1385e95764d48cd7cfbc1a", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 437, "deletions": 0, "changes": 437, "blob_url": "https://github.com/rust-lang/rust/blob/c73259a269c11ba9cb2917f9459204b7dcaa9646/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73259a269c11ba9cb2917f9459204b7dcaa9646/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=c73259a269c11ba9cb2917f9459204b7dcaa9646", "patch": "@@ -103,12 +103,16 @@ pub trait Drop {\n ///   Foo + Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"add\"]\n pub trait Add<Sized? RHS,Result> for Sized? {\n     /// The method for the `+` operator\n     fn add(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! add_impl(\n     ($($t:ty)*) => ($(\n         impl Add<$t, $t> for $t {\n@@ -118,6 +122,44 @@ macro_rules! add_impl(\n     )*)\n )\n \n+/// The `Add` trait is used to specify the functionality of `+`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Add`. When `Foo + Foo` happens, it ends up\n+/// calling `add`, and therefore, `main` prints `Adding!`.\n+///\n+/// ```rust\n+/// struct Foo;\n+///\n+/// impl Add<Foo, Foo> for Foo {\n+///     fn add(&self, _rhs: &Foo) -> Foo {\n+///       println!(\"Adding!\");\n+///       *self\n+///   }\n+/// }\n+///\n+/// fn main() {\n+///   Foo + Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"add\"]\n+pub trait Add<RHS, Result> {\n+    /// The method for the `+` operator\n+    fn add(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! add_impl(\n+    ($($t:ty)*) => ($(\n+        impl Add<$t, $t> for $t {\n+            #[inline]\n+            fn add(self, other: $t) -> $t { self + other }\n+        }\n+    )*)\n+)\n+\n add_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n \n /// The `Sub` trait is used to specify the functionality of `-`.\n@@ -143,12 +185,16 @@ add_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n ///     Foo - Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"sub\"]\n pub trait Sub<Sized? RHS, Result> for Sized? {\n     /// The method for the `-` operator\n     fn sub(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! sub_impl(\n     ($($t:ty)*) => ($(\n         impl Sub<$t, $t> for $t {\n@@ -158,6 +204,44 @@ macro_rules! sub_impl(\n     )*)\n )\n \n+/// The `Sub` trait is used to specify the functionality of `-`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Sub`. When `Foo - Foo` happens, it ends up\n+/// calling `sub`, and therefore, `main` prints `Subtracting!`.\n+///\n+/// ```rust\n+/// struct Foo;\n+///\n+/// impl Sub<Foo, Foo> for Foo {\n+///     fn sub(&self, _rhs: &Foo) -> Foo {\n+///         println!(\"Subtracting!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo - Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"sub\"]\n+pub trait Sub<RHS, Result> {\n+    /// The method for the `-` operator\n+    fn sub(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! sub_impl(\n+    ($($t:ty)*) => ($(\n+        impl Sub<$t, $t> for $t {\n+            #[inline]\n+            fn sub(self, other: $t) -> $t { self - other }\n+        }\n+    )*)\n+)\n+\n sub_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n \n /// The `Mul` trait is used to specify the functionality of `*`.\n@@ -183,12 +267,16 @@ sub_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n ///     Foo * Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"mul\"]\n pub trait Mul<Sized? RHS, Result>  for Sized? {\n     /// The method for the `*` operator\n     fn mul(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! mul_impl(\n     ($($t:ty)*) => ($(\n         impl Mul<$t, $t> for $t {\n@@ -198,6 +286,44 @@ macro_rules! mul_impl(\n     )*)\n )\n \n+/// The `Mul` trait is used to specify the functionality of `*`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Mul`. When `Foo * Foo` happens, it ends up\n+/// calling `mul`, and therefore, `main` prints `Multiplying!`.\n+///\n+/// ```rust\n+/// struct Foo;\n+///\n+/// impl Mul<Foo, Foo> for Foo {\n+///     fn mul(&self, _rhs: &Foo) -> Foo {\n+///         println!(\"Multiplying!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo * Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"mul\"]\n+pub trait Mul<RHS, Result> {\n+    /// The method for the `*` operator\n+    fn mul(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! mul_impl(\n+    ($($t:ty)*) => ($(\n+        impl Mul<$t, $t> for $t {\n+            #[inline]\n+            fn mul(self, other: $t) -> $t { self * other }\n+        }\n+    )*)\n+)\n+\n mul_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n \n /// The `Div` trait is used to specify the functionality of `/`.\n@@ -223,12 +349,16 @@ mul_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n ///     Foo / Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"div\"]\n pub trait Div<Sized? RHS, Result> for Sized? {\n     /// The method for the `/` operator\n     fn div(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! div_impl(\n     ($($t:ty)*) => ($(\n         impl Div<$t, $t> for $t {\n@@ -238,6 +368,44 @@ macro_rules! div_impl(\n     )*)\n )\n \n+/// The `Div` trait is used to specify the functionality of `/`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Div`. When `Foo / Foo` happens, it ends up\n+/// calling `div`, and therefore, `main` prints `Dividing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl Div<Foo, Foo> for Foo {\n+///     fn div(&self, _rhs: &Foo) -> Foo {\n+///         println!(\"Dividing!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo / Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"div\"]\n+pub trait Div<RHS, Result> {\n+    /// The method for the `/` operator\n+    fn div(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! div_impl(\n+    ($($t:ty)*) => ($(\n+        impl Div<$t, $t> for $t {\n+            #[inline]\n+            fn div(self, other: $t) -> $t { self / other }\n+        }\n+    )*)\n+)\n+\n div_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n \n /// The `Rem` trait is used to specify the functionality of `%`.\n@@ -263,12 +431,16 @@ div_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n ///     Foo % Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"rem\"]\n pub trait Rem<Sized? RHS, Result>  for Sized? {\n     /// The method for the `%` operator\n     fn rem(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! rem_impl(\n     ($($t:ty)*) => ($(\n         impl Rem<$t, $t> for $t {\n@@ -278,6 +450,8 @@ macro_rules! rem_impl(\n     )*)\n )\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! rem_float_impl(\n     ($t:ty, $fmod:ident) => {\n         impl Rem<$t, $t> for $t {\n@@ -290,6 +464,57 @@ macro_rules! rem_float_impl(\n     }\n )\n \n+/// The `Rem` trait is used to specify the functionality of `%`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Rem`. When `Foo % Foo` happens, it ends up\n+/// calling `rem`, and therefore, `main` prints `Remainder-ing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl Rem<Foo, Foo> for Foo {\n+///     fn rem(&self, _rhs: &Foo) -> Foo {\n+///         println!(\"Remainder-ing!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo % Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"rem\"]\n+pub trait Rem<RHS, Result> {\n+    /// The method for the `%` operator\n+    fn rem(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! rem_impl(\n+    ($($t:ty)*) => ($(\n+        impl Rem<$t, $t> for $t {\n+            #[inline]\n+            fn rem(self, other: $t) -> $t { self % other }\n+        }\n+    )*)\n+)\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! rem_float_impl(\n+    ($t:ty, $fmod:ident) => {\n+        impl Rem<$t, $t> for $t {\n+            #[inline]\n+            fn rem(self, other: $t) -> $t {\n+                extern { fn $fmod(a: $t, b: $t) -> $t; }\n+                unsafe { $fmod(self, other) }\n+            }\n+        }\n+    }\n+)\n+\n rem_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n rem_float_impl!(f32, fmodf)\n rem_float_impl!(f64, fmod)\n@@ -414,12 +639,16 @@ not_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n ///     Foo & Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"bitand\"]\n pub trait BitAnd<Sized? RHS, Result> for Sized? {\n     /// The method for the `&` operator\n     fn bitand(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! bitand_impl(\n     ($($t:ty)*) => ($(\n         impl BitAnd<$t, $t> for $t {\n@@ -429,6 +658,44 @@ macro_rules! bitand_impl(\n     )*)\n )\n \n+/// The `BitAnd` trait is used to specify the functionality of `&`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `BitAnd`. When `Foo & Foo` happens, it ends up\n+/// calling `bitand`, and therefore, `main` prints `Bitwise And-ing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl BitAnd<Foo, Foo> for Foo {\n+///     fn bitand(&self, _rhs: &Foo) -> Foo {\n+///         println!(\"Bitwise And-ing!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo & Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"bitand\"]\n+pub trait BitAnd<RHS, Result> {\n+    /// The method for the `&` operator\n+    fn bitand(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! bitand_impl(\n+    ($($t:ty)*) => ($(\n+        impl BitAnd<$t, $t> for $t {\n+            #[inline]\n+            fn bitand(self, rhs: $t) -> $t { self & rhs }\n+        }\n+    )*)\n+)\n+\n bitand_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n /// The `BitOr` trait is used to specify the functionality of `|`.\n@@ -454,12 +721,16 @@ bitand_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n ///     Foo | Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"bitor\"]\n pub trait BitOr<Sized? RHS, Result> for Sized? {\n     /// The method for the `|` operator\n     fn bitor(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! bitor_impl(\n     ($($t:ty)*) => ($(\n         impl BitOr<$t,$t> for $t {\n@@ -469,6 +740,44 @@ macro_rules! bitor_impl(\n     )*)\n )\n \n+/// The `BitOr` trait is used to specify the functionality of `|`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `BitOr`. When `Foo | Foo` happens, it ends up\n+/// calling `bitor`, and therefore, `main` prints `Bitwise Or-ing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl BitOr<Foo, Foo> for Foo {\n+///     fn bitor(&self, _rhs: &Foo) -> Foo {\n+///         println!(\"Bitwise Or-ing!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo | Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"bitor\"]\n+pub trait BitOr<RHS, Result> {\n+    /// The method for the `|` operator\n+    fn bitor(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! bitor_impl(\n+    ($($t:ty)*) => ($(\n+        impl BitOr<$t,$t> for $t {\n+            #[inline]\n+            fn bitor(self, rhs: $t) -> $t { self | rhs }\n+        }\n+    )*)\n+)\n+\n bitor_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n /// The `BitXor` trait is used to specify the functionality of `^`.\n@@ -494,12 +803,16 @@ bitor_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n ///     Foo ^ Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"bitxor\"]\n pub trait BitXor<Sized? RHS, Result> for Sized? {\n     /// The method for the `^` operator\n     fn bitxor(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! bitxor_impl(\n     ($($t:ty)*) => ($(\n         impl BitXor<$t, $t> for $t {\n@@ -509,6 +822,44 @@ macro_rules! bitxor_impl(\n     )*)\n )\n \n+/// The `BitXor` trait is used to specify the functionality of `^`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `BitXor`. When `Foo ^ Foo` happens, it ends up\n+/// calling `bitxor`, and therefore, `main` prints `Bitwise Xor-ing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl BitXor<Foo, Foo> for Foo {\n+///     fn bitxor(&self, _rhs: &Foo) -> Foo {\n+///         println!(\"Bitwise Xor-ing!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo ^ Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"bitxor\"]\n+pub trait BitXor<RHS, Result> {\n+    /// The method for the `^` operator\n+    fn bitxor(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! bitxor_impl(\n+    ($($t:ty)*) => ($(\n+        impl BitXor<$t, $t> for $t {\n+            #[inline]\n+            fn bitxor(self, other: $t) -> $t { self ^ other }\n+        }\n+    )*)\n+)\n+\n bitxor_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n /// The `Shl` trait is used to specify the functionality of `<<`.\n@@ -534,12 +885,16 @@ bitxor_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n ///     Foo << Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"shl\"]\n pub trait Shl<Sized? RHS, Result> for Sized? {\n     /// The method for the `<<` operator\n     fn shl(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! shl_impl(\n     ($($t:ty)*) => ($(\n         impl Shl<uint, $t> for $t {\n@@ -551,6 +906,46 @@ macro_rules! shl_impl(\n     )*)\n )\n \n+/// The `Shl` trait is used to specify the functionality of `<<`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Shl`. When `Foo << Foo` happens, it ends up\n+/// calling `shl`, and therefore, `main` prints `Shifting left!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl Shl<Foo, Foo> for Foo {\n+///     fn shl(&self, _rhs: &Foo) -> Foo {\n+///         println!(\"Shifting left!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo << Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"shl\"]\n+pub trait Shl<RHS, Result> {\n+    /// The method for the `<<` operator\n+    fn shl(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! shl_impl(\n+    ($($t:ty)*) => ($(\n+        impl Shl<uint, $t> for $t {\n+            #[inline]\n+            fn shl(self, other: uint) -> $t {\n+                self << other\n+            }\n+        }\n+    )*)\n+)\n+\n shl_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n /// The `Shr` trait is used to specify the functionality of `>>`.\n@@ -576,12 +971,16 @@ shl_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n ///     Foo >> Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"shr\"]\n pub trait Shr<Sized? RHS, Result> for Sized? {\n     /// The method for the `>>` operator\n     fn shr(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! shr_impl(\n     ($($t:ty)*) => ($(\n         impl Shr<uint, $t> for $t {\n@@ -591,6 +990,44 @@ macro_rules! shr_impl(\n     )*)\n )\n \n+/// The `Shr` trait is used to specify the functionality of `>>`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Shr`. When `Foo >> Foo` happens, it ends up\n+/// calling `shr`, and therefore, `main` prints `Shifting right!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl Shr<Foo, Foo> for Foo {\n+///     fn shr(&self, _rhs: &Foo) -> Foo {\n+///         println!(\"Shifting right!\");\n+///         *self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo >> Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"shr\"]\n+pub trait Shr<RHS, Result> {\n+    /// The method for the `>>` operator\n+    fn shr(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! shr_impl(\n+    ($($t:ty)*) => ($(\n+        impl Shr<uint, $t> for $t {\n+            #[inline]\n+            fn shr(self, other: uint) -> $t { self >> other }\n+        }\n+    )*)\n+)\n+\n shr_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n /// The `Index` trait is used to specify the functionality of indexing operations"}]}