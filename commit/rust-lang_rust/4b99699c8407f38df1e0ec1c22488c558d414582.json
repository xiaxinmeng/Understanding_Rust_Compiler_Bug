{"sha": "4b99699c8407f38df1e0ec1c22488c558d414582", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiOTk2OTljODQwN2YzOGRmMWUwZWMxYzIyNDg4YzU1OGQ0MTQ1ODI=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2020-07-17T11:28:23Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2020-07-20T18:35:37Z"}, "message": "index: introduce and use `FiniteBitSet`\n\nThis commit introduces a `FiniteBitSet` type which replaces the manual\nbit manipulation which was being performed in polymorphization.\n\nSigned-off-by: David Wood <david@davidtw.co>", "tree": {"sha": "98559db351e8a350ce7165c1125c4d5ffdfc0b24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98559db351e8a350ce7165c1125c4d5ffdfc0b24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b99699c8407f38df1e0ec1c22488c558d414582", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEfgm2/wUjk9OnjxlyJZLnbIc4H9kFAl8V4/kACgkQJZLnbIc4\nH9lTtQ//dbozPgKq5wX5z4Sgia+UcoX+4y2L2nFSS/xXWa7UjklF/bgFkA0bwla3\nAVMCbXPDic/oLIRD+8JRcoZcd0s3bFYRVBj6SP4xvlXvfxh57owqpdlwIseBO/Pe\njtXhMGEEZbXlMbdXtjaPLmTTXzdI/AWgtSwROHajykuxBqgC2gZI+XNRTyVJcbRY\n326UiYfOQrfYRS1Sl3zWNEBbhEAnh6F/k2hH/XDBcL+VaLwQMI7DYegK48XuL7Rd\nqrCilT8X2mkbMDuwaxIFVrjFIktMCh2CSt9SoGIFI7LvH/UuG11kBew3sEXZCRVD\n1y8I6kWZOVPHAeq8k1m0kq9b4fK7PR6dKeIOVyCoLn7p6fUKx29lRiOBLGkleFNW\n3r0gQXl3C5ZkWRiyYJLtGl/AXcEpbOmIa81MCxsD5jBqXW8Wp3OtUUB7/cOYEsNq\ny/dI2xgfi+4rHkC/A7HZc9l4Xnh8j0NuzHKs9X88Q2ad6mX9YKXIeYwGm+cwTX2W\ndFxNSJG/BPqak87ZSMkbvfL1o/H0aflzYrqTEkRAcQmKxhsbdch+NkW87urZCGCG\n+os8EhxLh/P93XUQYLOxFY3ccKSMHaj9ZOXVhY0wzteiN5h1nn2E8EmIMBUsT1AX\n/BDyfmAgewPzFVCtC5fr8rXM2qmgIIAwGVvthx/+2TrqTznCBn0=\n=E36K\n-----END PGP SIGNATURE-----", "payload": "tree 98559db351e8a350ce7165c1125c4d5ffdfc0b24\nparent b1f8bd635696644f86bdb5ea69fb69ec50bc6d9b\nauthor David Wood <david@davidtw.co> 1594985303 +0100\ncommitter David Wood <david@davidtw.co> 1595270137 +0100\n\nindex: introduce and use `FiniteBitSet`\n\nThis commit introduces a `FiniteBitSet` type which replaces the manual\nbit manipulation which was being performed in polymorphization.\n\nSigned-off-by: David Wood <david@davidtw.co>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b99699c8407f38df1e0ec1c22488c558d414582", "html_url": "https://github.com/rust-lang/rust/commit/4b99699c8407f38df1e0ec1c22488c558d414582", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b99699c8407f38df1e0ec1c22488c558d414582/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1f8bd635696644f86bdb5ea69fb69ec50bc6d9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1f8bd635696644f86bdb5ea69fb69ec50bc6d9b", "html_url": "https://github.com/rust-lang/rust/commit/b1f8bd635696644f86bdb5ea69fb69ec50bc6d9b"}], "stats": {"total": 284, "additions": 211, "deletions": 73}, "files": [{"sha": "c1c79b174f415e93d4637ca0f684f54856a6871f", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=4b99699c8407f38df1e0ec1c22488c558d414582", "patch": "@@ -469,6 +469,15 @@ impl<R: vec::Idx, C: vec::Idx, CTX> HashStable<CTX> for bit_set::BitMatrix<R, C>\n     }\n }\n \n+impl<T, CTX> HashStable<CTX> for bit_set::FiniteBitSet<T>\n+where\n+    T: HashStable<CTX> + bit_set::FiniteBitSetTy,\n+{\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        self.0.hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl_stable_hash_via_hash!(::std::path::Path);\n impl_stable_hash_via_hash!(::std::path::PathBuf);\n "}, {"sha": "4e94250fc62b49a42fbb822136febde2890cd5d4", "filename": "src/librustc_index/bit_set.rs", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Flibrustc_index%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Flibrustc_index%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fbit_set.rs?ref=4b99699c8407f38df1e0ec1c22488c558d414582", "patch": "@@ -4,6 +4,7 @@ use std::fmt;\n use std::iter;\n use std::marker::PhantomData;\n use std::mem;\n+use std::ops::{BitAnd, BitAndAssign, BitOrAssign, Not, Range, Shl};\n use std::slice;\n \n #[cfg(test)]\n@@ -1001,3 +1002,137 @@ fn word_index_and_mask<T: Idx>(elem: T) -> (usize, Word) {\n     let mask = 1 << (elem % WORD_BITS);\n     (word_index, mask)\n }\n+\n+/// Integral type used to represent the bit set.\n+pub trait FiniteBitSetTy:\n+    BitAnd<Output = Self>\n+    + BitAndAssign\n+    + BitOrAssign\n+    + Clone\n+    + Copy\n+    + Shl\n+    + Not<Output = Self>\n+    + PartialEq\n+    + Sized\n+{\n+    /// Size of the domain representable by this type, e.g. 64 for `u64`.\n+    const DOMAIN_SIZE: u32;\n+\n+    /// Value which represents the `FiniteBitSet` having every bit set.\n+    const FILLED: Self;\n+    /// Value which represents the `FiniteBitSet` having no bits set.\n+    const EMPTY: Self;\n+\n+    /// Value for one as the integral type.\n+    const ONE: Self;\n+    /// Value for zero as the integral type.\n+    const ZERO: Self;\n+\n+    /// Perform a checked left shift on the integral type.\n+    fn checked_shl(self, rhs: u32) -> Option<Self>;\n+    /// Perform a checked right shift on the integral type.\n+    fn checked_shr(self, rhs: u32) -> Option<Self>;\n+}\n+\n+impl FiniteBitSetTy for u64 {\n+    const DOMAIN_SIZE: u32 = 64;\n+\n+    const FILLED: Self = Self::MAX;\n+    const EMPTY: Self = Self::MIN;\n+\n+    const ONE: Self = 1u64;\n+    const ZERO: Self = 0u64;\n+\n+    fn checked_shl(self, rhs: u32) -> Option<Self> {\n+        self.checked_shl(rhs)\n+    }\n+\n+    fn checked_shr(self, rhs: u32) -> Option<Self> {\n+        self.checked_shr(rhs)\n+    }\n+}\n+\n+impl std::fmt::Debug for FiniteBitSet<u64> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:064b}\", self.0)\n+    }\n+}\n+\n+impl FiniteBitSetTy for u128 {\n+    const DOMAIN_SIZE: u32 = 128;\n+\n+    const FILLED: Self = Self::MAX;\n+    const EMPTY: Self = Self::MIN;\n+\n+    const ONE: Self = 1u128;\n+    const ZERO: Self = 0u128;\n+\n+    fn checked_shl(self, rhs: u32) -> Option<Self> {\n+        self.checked_shl(rhs)\n+    }\n+\n+    fn checked_shr(self, rhs: u32) -> Option<Self> {\n+        self.checked_shr(rhs)\n+    }\n+}\n+\n+impl std::fmt::Debug for FiniteBitSet<u128> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:0128b}\", self.0)\n+    }\n+}\n+\n+/// A fixed-sized bitset type represented by an integer type. Indices outwith than the range\n+/// representable by `T` are considered set.\n+#[derive(Copy, Clone, Eq, PartialEq, RustcDecodable, RustcEncodable)]\n+pub struct FiniteBitSet<T: FiniteBitSetTy>(pub T);\n+\n+impl<T: FiniteBitSetTy> FiniteBitSet<T> {\n+    /// Creates a new, empty bitset.\n+    pub fn new_empty() -> Self {\n+        Self(T::EMPTY)\n+    }\n+\n+    /// Sets the `index`th bit.\n+    pub fn set(&mut self, index: u32) {\n+        self.0 |= T::ONE.checked_shl(index).unwrap_or(T::ZERO);\n+    }\n+\n+    /// Unsets the `index`th bit.\n+    pub fn clear(&mut self, index: u32) {\n+        self.0 &= !T::ONE.checked_shl(index).unwrap_or(T::ZERO);\n+    }\n+\n+    /// Sets the `i`th to `j`th bits.\n+    pub fn set_range(&mut self, range: Range<u32>) {\n+        let bits = T::FILLED\n+            .checked_shl(range.end - range.start)\n+            .unwrap_or(T::ZERO)\n+            .not()\n+            .checked_shl(range.start)\n+            .unwrap_or(T::ZERO);\n+        self.0 |= bits;\n+    }\n+\n+    /// Is the set empty?\n+    pub fn is_empty(&self) -> bool {\n+        self.0 == T::EMPTY\n+    }\n+\n+    /// Returns the domain size of the bitset.\n+    pub fn within_domain(&self, index: u32) -> bool {\n+        index < T::DOMAIN_SIZE\n+    }\n+\n+    /// Returns if the `index`th bit is set.\n+    pub fn contains(&self, index: u32) -> Option<bool> {\n+        self.within_domain(index)\n+            .then(|| ((self.0.checked_shr(index).unwrap_or(T::ONE)) & T::ONE) == T::ONE)\n+    }\n+}\n+\n+impl<T: FiniteBitSetTy> Default for FiniteBitSet<T> {\n+    fn default() -> Self {\n+        Self::new_empty()\n+    }\n+}"}, {"sha": "7ee881b0639daf53f363e82d6878fc12e0a1735c", "filename": "src/librustc_index/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Flibrustc_index%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Flibrustc_index%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Flib.rs?ref=4b99699c8407f38df1e0ec1c22488c558d414582", "patch": "@@ -1,4 +1,5 @@\n #![feature(allow_internal_unstable)]\n+#![feature(bool_to_option)]\n #![feature(const_fn)]\n #![feature(const_panic)]\n #![feature(extend_one)]"}, {"sha": "a6d708ebe9048d0b24779ab8b90d676e0e9c6a00", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=4b99699c8407f38df1e0ec1c22488c558d414582", "patch": "@@ -1132,7 +1132,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, tcx))\n     }\n \n-    fn get_unused_generic_params(&self, id: DefIndex) -> u64 {\n+    fn get_unused_generic_params(&self, id: DefIndex) -> FiniteBitSet<u64> {\n         self.root\n             .tables\n             .unused_generic_params"}, {"sha": "e616e8cf00a2f5d1127b043fc1f224d5f2cc996b", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=4b99699c8407f38df1e0ec1c22488c558d414582", "patch": "@@ -9,7 +9,7 @@ use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{DefId, DefIndex};\n use rustc_hir::lang_items;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n use rustc_middle::hir::exports::Export;\n use rustc_middle::middle::cstore::{DepKind, ForeignModule, LinkagePreference, NativeLib};\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n@@ -277,7 +277,7 @@ define_tables! {\n     super_predicates: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n     mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n     promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n-    unused_generic_params: Table<DefIndex, Lazy<u64>>,\n+    unused_generic_params: Table<DefIndex, Lazy<FiniteBitSet<u64>>>,\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]"}, {"sha": "9b2242dd037e4ffe19fa98dca3d5c17294456791", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=4b99699c8407f38df1e0ec1c22488c558d414582", "patch": "@@ -1309,7 +1309,7 @@ rustc_queries! {\n         query codegen_unit(_: Symbol) -> &'tcx CodegenUnit<'tcx> {\n             desc { \"codegen_unit\" }\n         }\n-        query unused_generic_params(key: DefId) -> u64 {\n+        query unused_generic_params(key: DefId) -> FiniteBitSet<u64> {\n             cache_on_disk_if { key.is_local() }\n             desc {\n                 |tcx| \"determining which generic parameters are unused by `{}`\","}, {"sha": "cdb883da32bb0314eb85fc314e47e3dbb2d24399", "filename": "src/librustc_middle/ty/instance.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Flibrustc_middle%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Flibrustc_middle%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Finstance.rs?ref=4b99699c8407f38df1e0ec1c22488c558d414582", "patch": "@@ -474,20 +474,20 @@ impl<'tcx> Instance<'tcx> {\n         }\n \n         if let InstanceDef::Item(def) = self.def {\n-            let results = tcx.unused_generic_params(def.did);\n+            let unused = tcx.unused_generic_params(def.did);\n \n-            if results == 0 {\n+            if unused.is_empty() {\n                 // Exit early if every parameter was used.\n                 return self;\n             }\n \n-            debug!(\"polymorphize: results={:064b}\", results);\n+            debug!(\"polymorphize: unused={:?}\", unused);\n             let polymorphized_substs =\n                 InternalSubsts::for_item(tcx, def.did, |param, _| match param.kind {\n                 // If parameter is a const or type parameter..\n                 ty::GenericParamDefKind::Const | ty::GenericParamDefKind::Type { .. } if\n                     // ..and is within range and unused..\n-                    param.index < 64 && ((results >> param.index) & 1) == 1 =>\n+                    unused.contains(param.index).unwrap_or(false) =>\n                         // ..then use the identity for this parameter.\n                         tcx.mk_param_from_def(param),\n                 // Otherwise, use the parameter as before."}, {"sha": "2f7a9aee536d84593461e77df6956f118f276b1a", "filename": "src/librustc_middle/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs?ref=4b99699c8407f38df1e0ec1c22488c558d414582", "patch": "@@ -44,7 +44,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId};\n use rustc_hir::lang_items::{LangItem, LanguageItems};\n use rustc_hir::{Crate, HirIdSet, ItemLocalId, TraitCandidate};\n-use rustc_index::vec::IndexVec;\n+use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n use rustc_session::utils::NativeLibKind;\n use rustc_session::CrateDisambiguator;"}, {"sha": "071b9bb97113907b916f0d6cf0a21be6b3f9404c", "filename": "src/librustc_mir/monomorphize/polymorphize.rs", "status": "modified", "additions": 47, "deletions": 62, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs?ref=4b99699c8407f38df1e0ec1c22488c558d414582", "patch": "@@ -6,6 +6,7 @@\n //! for their size, offset of a field, etc.).\n \n use rustc_hir::{def::DefKind, def_id::DefId};\n+use rustc_index::bit_set::FiniteBitSet;\n use rustc_middle::mir::{\n     visit::{TyContext, Visitor},\n     Local, LocalDecl, Location,\n@@ -25,122 +26,105 @@ pub fn provide(providers: &mut Providers) {\n }\n \n /// Determine which generic parameters are used by the function/method/closure represented by\n-/// `def_id`. Returns a `u64` where a bit is set if the parameter with that index is unused (ie.\n-/// a value of zero indicates that all parameters are used).\n-fn unused_generic_params(tcx: TyCtxt<'_>, def_id: DefId) -> u64 {\n+/// `def_id`. Returns a bitset where bits representing unused parameters are set (`is_empty`\n+/// indicates all parameters are used).\n+fn unused_generic_params(tcx: TyCtxt<'_>, def_id: DefId) -> FiniteBitSet<u64> {\n     debug!(\"unused_generic_params({:?})\", def_id);\n \n     if !tcx.sess.opts.debugging_opts.polymorphize {\n         // If polymorphization disabled, then all parameters are used.\n-        return 0;\n+        return FiniteBitSet::new_empty();\n     }\n \n     let generics = tcx.generics_of(def_id);\n     debug!(\"unused_generic_params: generics={:?}\", generics);\n \n     // Exit early when there are no parameters to be unused.\n     if generics.count() == 0 {\n-        return 0;\n+        return FiniteBitSet::new_empty();\n     }\n \n     // Exit early when there is no MIR available.\n     if !tcx.is_mir_available(def_id) {\n         debug!(\"unused_generic_params: (no mir available) def_id={:?}\", def_id);\n-        return 0;\n+        return FiniteBitSet::new_empty();\n     }\n \n-    // Use a `u64` as a bitset. Starting with all ones, shift left by the number of parameters,\n-    // leaving N zeros for each parameter. When a parameter is marked as used, the bit (from the\n-    // left) corresponding to the parameter index will be flipped. This is the opposite of what\n-    // will be returned.\n+    // Create a bitset with N rightmost ones for each parameter.\n     let generics_count: u32 =\n         generics.count().try_into().expect(\"more generic parameters than can fit into a `u32`\");\n-    let mut used_parameters = u64::max_value().checked_shl(generics_count).unwrap_or(0);\n-    debug!(\"unused_generic_params: (start) used_parameters={:064b}\", used_parameters);\n-    mark_used_by_default_parameters(tcx, def_id, generics, &mut used_parameters);\n-    debug!(\"unused_generic_params: (after default) used_parameters={:064b}\", used_parameters);\n+    let mut unused_parameters = FiniteBitSet::<u64>::new_empty();\n+    unused_parameters.set_range(0..generics_count);\n+    debug!(\"unused_generic_params: (start) unused_parameters={:?}\", unused_parameters);\n+    mark_used_by_default_parameters(tcx, def_id, generics, &mut unused_parameters);\n+    debug!(\"unused_generic_params: (after default) unused_parameters={:?}\", unused_parameters);\n \n     // Visit MIR and accumululate used generic parameters.\n     let body = tcx.optimized_mir(def_id);\n     let mut vis =\n-        UsedGenericParametersVisitor { tcx, def_id, used_parameters: &mut used_parameters };\n+        UsedGenericParametersVisitor { tcx, def_id, unused_parameters: &mut unused_parameters };\n     vis.visit_body(body);\n-    debug!(\"unused_generic_params: (after visitor) used_parameters={:064b}\", used_parameters);\n+    debug!(\"unused_generic_params: (after visitor) unused_parameters={:?}\", unused_parameters);\n \n-    mark_used_by_predicates(tcx, def_id, &mut used_parameters);\n-    debug!(\"unused_generic_params: (after predicates) used_parameters={:064b}\", used_parameters);\n-\n-    // Invert the u64 so that used is 0 and unused is 1. This makes checking if all parameters are\n-    // used easy - just compare with zero.\n-    debug!(\"unused_generic_params: (end) used_parameters={:064b}\", used_parameters);\n-    let unused_parameters: u64 = !used_parameters;\n-    debug!(\"unused_generic_params: (flipped) unused_parameters={:064b}\", unused_parameters);\n+    mark_used_by_predicates(tcx, def_id, &mut unused_parameters);\n+    debug!(\"unused_generic_params: (end) unused_parameters={:?}\", unused_parameters);\n \n     // Emit errors for debugging and testing if enabled.\n-    let is_full = unused_parameters == 0;\n-    if !is_full {\n-        emit_unused_generic_params_error(tcx, def_id, generics, unused_parameters);\n+    if !unused_parameters.is_empty() {\n+        emit_unused_generic_params_error(tcx, def_id, generics, &unused_parameters);\n     }\n \n     unused_parameters\n }\n \n-/// Checks if the `param_index`th bit is set (or out-of-range).\n-fn is_bit_set(parameters: u64, param_index: u32) -> bool {\n-    param_index >= 64 || ((parameters.checked_shr(param_index).unwrap_or(1)) & 1) == 1\n-}\n-\n-/// Flips the bit corresponding to the parameter index.\n-fn set_bit(used_parameters: &mut u64, param_index: u32) {\n-    debug!(\"set_bit: used_parameters={:064b} param_index={:?}\", used_parameters, param_index);\n-    *used_parameters |= 1u64.checked_shl(param_index).unwrap_or(0);\n-    debug!(\"set_bit: used_parameters={:064b}\", used_parameters);\n-}\n-\n /// Some parameters are considered used-by-default, such as non-generic parameters and the dummy\n /// generic parameters from closures, this function marks them as used. `leaf_is_closure` should\n /// be `true` if the item that `unused_generic_params` was invoked on is a closure.\n fn mark_used_by_default_parameters<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     generics: &'tcx ty::Generics,\n-    used_parameters: &mut u64,\n+    unused_parameters: &mut FiniteBitSet<u64>,\n ) {\n     if !tcx.is_trait(def_id) && (tcx.is_closure(def_id) || tcx.type_of(def_id).is_generator()) {\n         for param in &generics.params {\n             debug!(\"mark_used_by_default_parameters: (closure/gen) param={:?}\", param);\n-            set_bit(used_parameters, param.index);\n+            unused_parameters.clear(param.index);\n         }\n     } else {\n         for param in &generics.params {\n             debug!(\"mark_used_by_default_parameters: (other) param={:?}\", param);\n             if let ty::GenericParamDefKind::Lifetime = param.kind {\n-                set_bit(used_parameters, param.index);\n+                unused_parameters.clear(param.index);\n             }\n         }\n     }\n \n     if let Some(parent) = generics.parent {\n-        mark_used_by_default_parameters(tcx, parent, tcx.generics_of(parent), used_parameters);\n+        mark_used_by_default_parameters(tcx, parent, tcx.generics_of(parent), unused_parameters);\n     }\n }\n \n /// Search the predicates on used generic parameters for any unused generic parameters, and mark\n /// those as used.\n-fn mark_used_by_predicates<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, used_parameters: &mut u64) {\n+fn mark_used_by_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    unused_parameters: &mut FiniteBitSet<u64>,\n+) {\n     let def_id = tcx.closure_base_def_id(def_id);\n \n-    let is_self_ty_used = |used_parameters: &mut u64, self_ty: Ty<'tcx>| {\n+    let is_self_ty_used = |unused_parameters: &mut FiniteBitSet<u64>, self_ty: Ty<'tcx>| {\n         debug!(\"unused_generic_params: self_ty={:?}\", self_ty);\n         if let ty::Param(param) = self_ty.kind {\n-            is_bit_set(*used_parameters, param.index)\n+            !unused_parameters.contains(param.index).unwrap_or(false)\n         } else {\n             false\n         }\n     };\n \n-    let mark_ty = |used_parameters: &mut u64, ty: Ty<'tcx>| {\n-        let mut vis = UsedGenericParametersVisitor { tcx, def_id, used_parameters };\n+    let mark_ty = |unused_parameters: &mut FiniteBitSet<u64>, ty: Ty<'tcx>| {\n+        let mut vis = UsedGenericParametersVisitor { tcx, def_id, unused_parameters };\n         ty.visit_with(&mut vis);\n     };\n \n@@ -150,19 +134,19 @@ fn mark_used_by_predicates<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, used_paramete\n         match predicate.kind() {\n             ty::PredicateKind::Trait(predicate, ..) => {\n                 let trait_ref = predicate.skip_binder().trait_ref;\n-                if is_self_ty_used(used_parameters, trait_ref.self_ty()) {\n+                if is_self_ty_used(unused_parameters, trait_ref.self_ty()) {\n                     for ty in trait_ref.substs.types() {\n                         debug!(\"unused_generic_params: (trait) ty={:?}\", ty);\n-                        mark_ty(used_parameters, ty);\n+                        mark_ty(unused_parameters, ty);\n                     }\n                 }\n             }\n             ty::PredicateKind::Projection(predicate, ..) => {\n                 let self_ty = predicate.skip_binder().projection_ty.self_ty();\n-                if is_self_ty_used(used_parameters, self_ty) {\n+                if is_self_ty_used(unused_parameters, self_ty) {\n                     let ty = predicate.ty();\n                     debug!(\"unused_generic_params: (projection) ty={:?}\", ty);\n-                    mark_ty(used_parameters, ty.skip_binder());\n+                    mark_ty(unused_parameters, ty.skip_binder());\n                 }\n             }\n             _ => (),\n@@ -176,15 +160,15 @@ fn emit_unused_generic_params_error<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     generics: &'tcx ty::Generics,\n-    unused_parameters: u64,\n+    unused_parameters: &FiniteBitSet<u64>,\n ) {\n     debug!(\"emit_unused_generic_params_error: def_id={:?}\", def_id);\n     let base_def_id = tcx.closure_base_def_id(def_id);\n     if !tcx.get_attrs(base_def_id).iter().any(|a| a.check_name(sym::rustc_polymorphize_error)) {\n         return;\n     }\n \n-    debug!(\"emit_unused_generic_params_error: unused_parameters={:064b}\", unused_parameters);\n+    debug!(\"emit_unused_generic_params_error: unused_parameters={:?}\", unused_parameters);\n     let fn_span = match tcx.opt_item_name(def_id) {\n         Some(ident) => ident.span,\n         _ => tcx.def_span(def_id),\n@@ -195,7 +179,7 @@ fn emit_unused_generic_params_error<'tcx>(\n     let mut next_generics = Some(generics);\n     while let Some(generics) = next_generics {\n         for param in &generics.params {\n-            if is_bit_set(unused_parameters, param.index) {\n+            if unused_parameters.contains(param.index).unwrap_or(false) {\n                 debug!(\"emit_unused_generic_params_error: param={:?}\", param);\n                 let def_span = tcx.def_span(param.def_id);\n                 err.span_label(def_span, &format!(\"generic parameter `{}` is unused\", param.name));\n@@ -212,7 +196,7 @@ fn emit_unused_generic_params_error<'tcx>(\n struct UsedGenericParametersVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n-    used_parameters: &'a mut u64,\n+    unused_parameters: &'a mut FiniteBitSet<u64>,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for UsedGenericParametersVisitor<'a, 'tcx> {\n@@ -252,7 +236,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UsedGenericParametersVisitor<'a, 'tcx> {\n         match c.val {\n             ty::ConstKind::Param(param) => {\n                 debug!(\"visit_const: param={:?}\", param);\n-                set_bit(self.used_parameters, param.index);\n+                self.unused_parameters.clear(param.index);\n                 false\n             }\n             _ => c.super_visit_with(self),\n@@ -277,21 +261,22 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UsedGenericParametersVisitor<'a, 'tcx> {\n                 // parent.\n                 let unused = self.tcx.unused_generic_params(def_id);\n                 debug!(\n-                    \"visit_ty: used_parameters={:064b} unused={:064b}\",\n-                    self.used_parameters, unused\n+                    \"visit_ty: unused_parameters={:?} unused={:?}\",\n+                    self.unused_parameters, unused\n                 );\n                 for (i, arg) in substs.iter().enumerate() {\n-                    if !is_bit_set(unused, i.try_into().unwrap()) {\n+                    let i = i.try_into().unwrap();\n+                    if !unused.contains(i).unwrap_or(false) {\n                         arg.visit_with(self);\n                     }\n                 }\n-                debug!(\"visit_ty: used_parameters={:064b}\", self.used_parameters);\n+                debug!(\"visit_ty: unused_parameters={:?}\", self.unused_parameters);\n \n                 false\n             }\n             ty::Param(param) => {\n                 debug!(\"visit_ty: param={:?}\", param);\n-                set_bit(self.used_parameters, param.index);\n+                self.unused_parameters.clear(param.index);\n                 false\n             }\n             _ => ty.super_visit_with(self),"}, {"sha": "ec6244630fd1fc5616fa49d8a0439ce23c12574b", "filename": "src/test/ui/polymorphization/too-many-generic-params.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Ftest%2Fui%2Fpolymorphization%2Ftoo-many-generic-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b99699c8407f38df1e0ec1c22488c558d414582/src%2Ftest%2Fui%2Fpolymorphization%2Ftoo-many-generic-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Ftoo-many-generic-params.rs?ref=4b99699c8407f38df1e0ec1c22488c558d414582", "patch": "@@ -7,7 +7,7 @@\n #[rustc_polymorphize_error]\n fn bar<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, AA,\n        AB, AC, AD, AE, AF, AG, AH, AI, AJ, AK, AL, AM, AN, AO, AP, AQ, AR, AS, AT, AU, AV, AW,\n-       AX, AY, AZ, BA, BB, BC, BD, BE, BF, BG, BH, BI, BJ, BK, BL>()\n+       AX, AY, AZ, BA, BB, BC, BD, BE, BF, BG, BH, BI, BJ, BK, BL, BM>()\n {\n     let _: Option<A> = None;\n     let _: Option<B> = None;\n@@ -60,6 +60,7 @@ fn bar<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y\n     let _: Option<AW> = None;\n     let _: Option<AX> = None;\n     let _: Option<AY> = None;\n+    let _: Option<AZ> = None;\n     let _: Option<BA> = None;\n     let _: Option<BB> = None;\n     let _: Option<BC> = None;\n@@ -72,6 +73,13 @@ fn bar<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y\n     let _: Option<BJ> = None;\n     let _: Option<BK> = None;\n     let _: Option<BL> = None;\n+    let _: Option<BM> = None;\n }\n \n-fn main() { }\n+fn main() {\n+    bar::<u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32,\n+          u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32,\n+          u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32,\n+          u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32,\n+          u32>();\n+}"}]}