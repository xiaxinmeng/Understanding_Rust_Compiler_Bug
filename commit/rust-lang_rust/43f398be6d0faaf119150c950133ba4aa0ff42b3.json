{"sha": "43f398be6d0faaf119150c950133ba4aa0ff42b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzZjM5OGJlNmQwZmFhZjExOTE1MGM5NTAxMzNiYTRhYTBmZjQyYjM=", "commit": {"author": {"name": "oxalica", "email": "oxalicc@pm.me", "date": "2019-10-04T08:17:23Z"}, "committer": {"name": "oxalica", "email": "oxalicc@pm.me", "date": "2019-10-18T02:32:27Z"}, "message": "Prefer statx on linux if available", "tree": {"sha": "fef8247c46d5ac6191e1a1606014330ef8e97c5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fef8247c46d5ac6191e1a1606014330ef8e97c5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43f398be6d0faaf119150c950133ba4aa0ff42b3", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAl2pJDsACgkQztOS3gxI\nPQDbkBAAvxncC4Yi2vS0VQcBlBDHPbLkZhwEX02SblEG7FKUlR9S4bwXg3KRy1pM\nuEH4BwP6Ep6d8LrDuF47zk+bH1PPZ/RdNvfX2v1qVQFaGkGsr7R9tJddKmeT9sPG\npqJbV25IsDxUAW6Co4Dwzh0KASkgmn4wNjUqZmLb2eoeLN75pY1bx55WzroSm8Hn\n2aE66hsn9Lslq7D5JUNU+SPy127czHLTivyPB8asAfsW5EhoNU/8aXzvezW1FDgP\nwL6Ak/5NlsQdzKhsKb/MRFDw+u3Zfsjqegms8It0crthIG+BswnncCDEFMsV79PV\niOnqE5Kn4+flTtAlbz8Y5pWEYaWqVlXCq9VxyUF/fGs8LedNON7LVPXia8288gv3\netH/J06xcpiqZwu113GJu6w2HMHLJfVb1bTxRl0N5c1lkgXMCNPqlc8o9Yh94++z\nNy5WnzacTict40Pyp8rT0fib1fnC3EY21KiRM6T7En1P0P6MWgBLHLqaKjD7TdL+\nTWZWIen1ejURe3oTmyCXbKrthYckyXpbkaOgZahmpSAKKgUkToqZJ6Uxq9N25rQq\nOj2/b5IIccAejEMXOhgfDbIbISDiUmbsRiIx1+6ctMpv+SplB1JeEpy0TIpaQWVg\ngObof4Mn6lKdvqeUlhGN53SoqvIGF3Z3/TCc7WWtUu+jLzaBY08=\n=cZcI\n-----END PGP SIGNATURE-----", "payload": "tree fef8247c46d5ac6191e1a1606014330ef8e97c5d\nparent fa0f7d0080d8e7e9eb20aa9cbf8013f96c81287f\nauthor oxalica <oxalicc@pm.me> 1570177043 +0800\ncommitter oxalica <oxalicc@pm.me> 1571365947 +0800\n\nPrefer statx on linux if available\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43f398be6d0faaf119150c950133ba4aa0ff42b3", "html_url": "https://github.com/rust-lang/rust/commit/43f398be6d0faaf119150c950133ba4aa0ff42b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43f398be6d0faaf119150c950133ba4aa0ff42b3/comments", "author": {"login": "oxalica", "id": 14816024, "node_id": "MDQ6VXNlcjE0ODE2MDI0", "avatar_url": "https://avatars.githubusercontent.com/u/14816024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oxalica", "html_url": "https://github.com/oxalica", "followers_url": "https://api.github.com/users/oxalica/followers", "following_url": "https://api.github.com/users/oxalica/following{/other_user}", "gists_url": "https://api.github.com/users/oxalica/gists{/gist_id}", "starred_url": "https://api.github.com/users/oxalica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oxalica/subscriptions", "organizations_url": "https://api.github.com/users/oxalica/orgs", "repos_url": "https://api.github.com/users/oxalica/repos", "events_url": "https://api.github.com/users/oxalica/events{/privacy}", "received_events_url": "https://api.github.com/users/oxalica/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oxalica", "id": 14816024, "node_id": "MDQ6VXNlcjE0ODE2MDI0", "avatar_url": "https://avatars.githubusercontent.com/u/14816024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oxalica", "html_url": "https://github.com/oxalica", "followers_url": "https://api.github.com/users/oxalica/followers", "following_url": "https://api.github.com/users/oxalica/following{/other_user}", "gists_url": "https://api.github.com/users/oxalica/gists{/gist_id}", "starred_url": "https://api.github.com/users/oxalica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oxalica/subscriptions", "organizations_url": "https://api.github.com/users/oxalica/orgs", "repos_url": "https://api.github.com/users/oxalica/repos", "events_url": "https://api.github.com/users/oxalica/events{/privacy}", "received_events_url": "https://api.github.com/users/oxalica/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa0f7d0080d8e7e9eb20aa9cbf8013f96c81287f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa0f7d0080d8e7e9eb20aa9cbf8013f96c81287f", "html_url": "https://github.com/rust-lang/rust/commit/fa0f7d0080d8e7e9eb20aa9cbf8013f96c81287f"}], "stats": {"total": 193, "additions": 182, "deletions": 11}, "files": [{"sha": "6595f54162f0a8a1ceeca203cf93ba5205937622", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/43f398be6d0faaf119150c950133ba4aa0ff42b3/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43f398be6d0faaf119150c950133ba4aa0ff42b3/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=43f398be6d0faaf119150c950133ba4aa0ff42b3", "patch": "@@ -1090,13 +1090,14 @@ impl Metadata {\n \n     /// Returns the creation time listed in this metadata.\n     ///\n-    /// The returned value corresponds to the `birthtime` field of `stat` on\n-    /// Unix platforms and the `ftCreationTime` field on Windows platforms.\n+    /// The returned value corresponds to the `btime` field of `statx` on\n+    /// Linux kernel starting from to 4.11, the `birthtime` field of `stat` on other\n+    /// Unix platforms, and the `ftCreationTime` field on Windows platforms.\n     ///\n     /// # Errors\n     ///\n     /// This field may not be available on all platforms, and will return an\n-    /// `Err` on platforms where it is not available.\n+    /// `Err` on platforms or filesystems where it is not available.\n     ///\n     /// # Examples\n     ///\n@@ -1109,7 +1110,7 @@ impl Metadata {\n     ///     if let Ok(time) = metadata.created() {\n     ///         println!(\"{:?}\", time);\n     ///     } else {\n-    ///         println!(\"Not supported on this platform\");\n+    ///         println!(\"Not supported on this platform or filesystem\");\n     ///     }\n     ///     Ok(())\n     /// }\n@@ -3443,5 +3444,18 @@ mod tests {\n             check!(a.created());\n             check!(b.created());\n         }\n+\n+        if cfg!(target_os = \"linux\") {\n+            // Not always available\n+            match (a.created(), b.created()) {\n+                (Ok(t1), Ok(t2)) => assert!(t1 <= t2),\n+                (Err(e1), Err(e2)) if e1.kind() == ErrorKind::Other &&\n+                                      e2.kind() == ErrorKind::Other => {}\n+                (a, b) => panic!(\n+                    \"creation time must be always supported or not supported: {:?} {:?}\",\n+                    a, b,\n+                ),\n+            }\n+        }\n     }\n }"}, {"sha": "8113fe38165b07bcba9fef466738ce4d3eab955f", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 164, "deletions": 7, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/43f398be6d0faaf119150c950133ba4aa0ff42b3/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43f398be6d0faaf119150c950133ba4aa0ff42b3/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=43f398be6d0faaf119150c950133ba4aa0ff42b3", "patch": "@@ -44,6 +44,84 @@ pub struct File(FileDesc);\n #[derive(Clone)]\n pub struct FileAttr {\n     stat: stat64,\n+    #[cfg(target_os = \"linux\")]\n+    statx_extra_fields: Option<StatxExtraFields>,\n+}\n+\n+#[cfg(target_os = \"linux\")]\n+#[derive(Clone)]\n+struct StatxExtraFields {\n+    // This is needed to check if btime is supported by the filesystem.\n+    stx_mask: u32,\n+    stx_btime: libc::statx_timestamp,\n+}\n+\n+// We prefer `statx` on Linux if available, which contains file creation time.\n+// Default `stat64` contains no creation time.\n+#[cfg(target_os = \"linux\")]\n+unsafe fn try_statx(\n+    fd: c_int,\n+    path: *const libc::c_char,\n+    flags: i32,\n+    mask: u32,\n+) -> Option<io::Result<FileAttr>> {\n+    use crate::sync::atomic::{AtomicBool, Ordering};\n+\n+    // Linux kernel prior to 4.11 or glibc prior to glibc 2.28 don't support `statx`\n+    // We store the availability in a global to avoid unnecessary syscalls\n+    static HAS_STATX: AtomicBool = AtomicBool::new(true);\n+    syscall! {\n+        fn statx(\n+            fd: c_int,\n+            pathname: *const libc::c_char,\n+            flags: c_int,\n+            mask: libc::c_uint,\n+            statxbuf: *mut libc::statx\n+        ) -> c_int\n+    }\n+\n+    if !HAS_STATX.load(Ordering::Relaxed) {\n+        return None;\n+    }\n+\n+    let mut buf: libc::statx = mem::zeroed();\n+    let ret = cvt(statx(fd, path, flags, mask, &mut buf));\n+    match ret {\n+        Err(err) => match err.raw_os_error() {\n+            Some(libc::ENOSYS) => {\n+                HAS_STATX.store(false, Ordering::Relaxed);\n+                return None;\n+            }\n+            _ => return Some(Err(err)),\n+        }\n+        Ok(_) => {\n+            // We cannot fill `stat64` exhaustively because of private padding fields.\n+            let mut stat: stat64 = mem::zeroed();\n+            stat.st_dev = libc::makedev(buf.stx_dev_major, buf.stx_dev_minor);\n+            stat.st_ino = buf.stx_ino as libc::ino64_t;\n+            stat.st_nlink = buf.stx_nlink as libc::nlink_t;\n+            stat.st_mode = buf.stx_mode as libc::mode_t;\n+            stat.st_uid = buf.stx_uid as libc::uid_t;\n+            stat.st_gid = buf.stx_gid as libc::gid_t;\n+            stat.st_rdev = libc::makedev(buf.stx_rdev_major, buf.stx_rdev_minor);\n+            stat.st_size = buf.stx_size as off64_t;\n+            stat.st_blksize = buf.stx_blksize as libc::blksize_t;\n+            stat.st_blocks = buf.stx_blocks as libc::blkcnt64_t;\n+            stat.st_atime = buf.stx_atime.tv_sec as libc::time_t;\n+            stat.st_atime_nsec = buf.stx_atime.tv_nsec as libc::c_long;\n+            stat.st_mtime = buf.stx_mtime.tv_sec as libc::time_t;\n+            stat.st_mtime_nsec = buf.stx_mtime.tv_nsec as libc::c_long;\n+            stat.st_ctime = buf.stx_ctime.tv_sec as libc::time_t;\n+            stat.st_ctime_nsec = buf.stx_ctime.tv_nsec as libc::c_long;\n+\n+            let extra = StatxExtraFields {\n+                stx_mask: buf.stx_mask,\n+                stx_btime: buf.stx_btime,\n+            };\n+\n+            Some(Ok(FileAttr { stat, statx_extra_fields: Some(extra) }))\n+        }\n+    }\n }\n \n // all DirEntry's will have a reference to this struct\n@@ -98,6 +176,14 @@ pub struct FileType { mode: mode_t }\n pub struct DirBuilder { mode: mode_t }\n \n impl FileAttr {\n+    fn from_stat64(stat: stat64) -> Self {\n+        Self {\n+            stat,\n+            #[cfg(target_os = \"linux\")]\n+            statx_extra_fields: None,\n+        }\n+    }\n+\n     pub fn size(&self) -> u64 { self.stat.st_size as u64 }\n     pub fn perm(&self) -> FilePermissions {\n         FilePermissions { mode: (self.stat.st_mode as mode_t) }\n@@ -164,6 +250,23 @@ impl FileAttr {\n                   target_os = \"macos\",\n                   target_os = \"ios\")))]\n     pub fn created(&self) -> io::Result<SystemTime> {\n+        #[cfg(target_os = \"linux\")]\n+        {\n+            if let Some(ext) = &self.statx_extra_fields {\n+                return if (ext.stx_mask & libc::STATX_BTIME) != 0 {\n+                    Ok(SystemTime::from(libc::timespec {\n+                        tv_sec: ext.stx_btime.tv_sec as libc::time_t,\n+                        tv_nsec: ext.stx_btime.tv_nsec as libc::c_long,\n+                    }))\n+                } else {\n+                    Err(io::Error::new(\n+                        io::ErrorKind::Other,\n+                        \"creation time is not available for the filesystem\",\n+                    ))\n+                };\n+            }\n+        }\n+\n         Err(io::Error::new(io::ErrorKind::Other,\n                            \"creation time is not available on this platform \\\n                             currently\"))\n@@ -306,12 +409,26 @@ impl DirEntry {\n \n     #[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\"))]\n     pub fn metadata(&self) -> io::Result<FileAttr> {\n-        let fd = cvt(unsafe {dirfd(self.dir.inner.dirp.0)})?;\n+        let fd = cvt(unsafe { dirfd(self.dir.inner.dirp.0) })?;\n+        let name = self.entry.d_name.as_ptr();\n+\n+        #[cfg(target_os = \"linux\")]\n+        {\n+            if let Some(ret) = unsafe { try_statx(\n+                fd,\n+                name,\n+                libc::AT_SYMLINK_NOFOLLOW | libc::AT_STATX_SYNC_AS_STAT,\n+                libc::STATX_ALL,\n+            ) } {\n+                return ret;\n+            }\n+        }\n+\n         let mut stat: stat64 = unsafe { mem::zeroed() };\n         cvt(unsafe {\n-            fstatat64(fd, self.entry.d_name.as_ptr(), &mut stat, libc::AT_SYMLINK_NOFOLLOW)\n+            fstatat64(fd, name, &mut stat, libc::AT_SYMLINK_NOFOLLOW)\n         })?;\n-        Ok(FileAttr { stat })\n+        Ok(FileAttr::from_stat64(stat))\n     }\n \n     #[cfg(not(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\")))]\n@@ -517,11 +634,25 @@ impl File {\n     }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n+        let fd = self.0.raw();\n+\n+        #[cfg(target_os = \"linux\")]\n+        {\n+            if let Some(ret) = unsafe { try_statx(\n+                fd,\n+                b\"\\0\" as *const _ as *const libc::c_char,\n+                libc::AT_EMPTY_PATH | libc::AT_STATX_SYNC_AS_STAT,\n+                libc::STATX_ALL,\n+            ) } {\n+                return ret;\n+            }\n+        }\n+\n         let mut stat: stat64 = unsafe { mem::zeroed() };\n         cvt(unsafe {\n-            fstat64(self.0.raw(), &mut stat)\n+            fstat64(fd, &mut stat)\n         })?;\n-        Ok(FileAttr { stat })\n+        Ok(FileAttr::from_stat64(stat))\n     }\n \n     pub fn fsync(&self) -> io::Result<()> {\n@@ -798,20 +929,46 @@ pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n     let p = cstr(p)?;\n+\n+    #[cfg(target_os = \"linux\")]\n+    {\n+        if let Some(ret) = unsafe { try_statx(\n+            libc::AT_FDCWD,\n+            p.as_ptr(),\n+            libc::AT_STATX_SYNC_AS_STAT,\n+            libc::STATX_ALL,\n+        ) } {\n+            return ret;\n+        }\n+    }\n+\n     let mut stat: stat64 = unsafe { mem::zeroed() };\n     cvt(unsafe {\n         stat64(p.as_ptr(), &mut stat)\n     })?;\n-    Ok(FileAttr { stat })\n+    Ok(FileAttr::from_stat64(stat))\n }\n \n pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n     let p = cstr(p)?;\n+\n+    #[cfg(target_os = \"linux\")]\n+    {\n+        if let Some(ret) = unsafe { try_statx(\n+            libc::AT_FDCWD,\n+            p.as_ptr(),\n+            libc::AT_SYMLINK_NOFOLLOW | libc::AT_STATX_SYNC_AS_STAT,\n+            libc::STATX_ALL,\n+        ) } {\n+            return ret;\n+        }\n+    }\n+\n     let mut stat: stat64 = unsafe { mem::zeroed() };\n     cvt(unsafe {\n         lstat64(p.as_ptr(), &mut stat)\n     })?;\n-    Ok(FileAttr { stat })\n+    Ok(FileAttr::from_stat64(stat))\n }\n \n pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {"}]}