{"sha": "1186a7d05dacc0696b56244d83ec19e85e3555a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExODZhN2QwNWRhY2MwNjk2YjU2MjQ0ZDgzZWMxOWU4NWUzNTU1YTY=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-06-10T03:13:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-10T03:13:20Z"}, "message": "Merge pull request #18 from oli-obk/hold_the_state\n\nHold the state", "tree": {"sha": "5425a5e727b9054ff890772592a60f9ee84e2f97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5425a5e727b9054ff890772592a60f9ee84e2f97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1186a7d05dacc0696b56244d83ec19e85e3555a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1186a7d05dacc0696b56244d83ec19e85e3555a6", "html_url": "https://github.com/rust-lang/rust/commit/1186a7d05dacc0696b56244d83ec19e85e3555a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1186a7d05dacc0696b56244d83ec19e85e3555a6/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66a812f3e133400f269f2e2beea2c67c8ba7d181", "url": "https://api.github.com/repos/rust-lang/rust/commits/66a812f3e133400f269f2e2beea2c67c8ba7d181", "html_url": "https://github.com/rust-lang/rust/commit/66a812f3e133400f269f2e2beea2c67c8ba7d181"}, {"sha": "05eaa522a5486ba20bb564bf2b37179124d0951c", "url": "https://api.github.com/repos/rust-lang/rust/commits/05eaa522a5486ba20bb564bf2b37179124d0951c", "html_url": "https://github.com/rust-lang/rust/commit/05eaa522a5486ba20bb564bf2b37179124d0951c"}], "stats": {"total": 832, "additions": 565, "deletions": 267}, "files": [{"sha": "e085373a36dc04c77f23aa71bd8b6b9cf98a74f7", "filename": "benches/miri_helper.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1186a7d05dacc0696b56244d83ec19e85e3555a6/benches%2Fmiri_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1186a7d05dacc0696b56244d83ec19e85e3555a6/benches%2Fmiri_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fmiri_helper.rs?ref=1186a7d05dacc0696b56244d83ec19e85e3555a6", "patch": "@@ -10,7 +10,7 @@ extern crate test;\n \n use self::miri::interpreter;\n use self::rustc::session::Session;\n-use self::rustc_driver::{driver, CompilerCalls};\n+use self::rustc_driver::{driver, CompilerCalls, Compilation};\n use std::cell::RefCell;\n use std::rc::Rc;\n use std::env::var;\n@@ -35,6 +35,7 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls<'a> {\n \n         let bencher = self.0.clone();\n \n+        control.after_analysis.stop = Compilation::Stop;\n         control.after_analysis.callback = Box::new(move |state| {\n             state.session.abort_if_errors();\n             bencher.borrow_mut().iter(|| {"}, {"sha": "6c0d58f1c47e77dc3b3c660fbe236458655d3102", "filename": "src/interpreter/mod.rs", "status": "renamed", "additions": 325, "deletions": 264, "changes": 589, "blob_url": "https://github.com/rust-lang/rust/blob/1186a7d05dacc0696b56244d83ec19e85e3555a6/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1186a7d05dacc0696b56244d83ec19e85e3555a6/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=1186a7d05dacc0696b56244d83ec19e85e3555a6", "patch": "@@ -20,6 +20,10 @@ use error::{EvalError, EvalResult};\n use memory::{Memory, Pointer};\n use primval::{self, PrimVal};\n \n+use std::collections::HashMap;\n+\n+mod stepper;\n+\n struct GlobalEvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -33,16 +37,8 @@ struct GlobalEvalContext<'a, 'tcx: 'a> {\n     /// The virtual memory system.\n     memory: Memory,\n \n-    /// Another stack containing the type substitutions for the current function invocation. It\n-    /// exists separately from `stack` because it must contain the `Substs` for a function while\n-    /// *creating* the `Frame` for that same function.\n-    substs_stack: Vec<&'tcx Substs<'tcx>>,\n-\n-    // TODO(solson): Merge with `substs_stack`. Also try restructuring `Frame` to accomodate.\n-    /// A stack of the things necessary to print good strack traces:\n-    ///   * Function DefIds and Substs to print proper substituted function names.\n-    ///   * Spans pointing to specific function calls in the source.\n-    name_stack: Vec<(DefId, &'tcx Substs<'tcx>, codemap::Span)>,\n+    /// Precomputed statics, constants and promoteds\n+    statics: HashMap<ConstantId<'tcx>, Pointer>,\n }\n \n struct FnEvalContext<'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> {\n@@ -67,10 +63,19 @@ impl<'a, 'b, 'mir, 'tcx> DerefMut for FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n /// A stack frame.\n struct Frame<'a, 'tcx: 'a> {\n+    /// The def_id of the current function\n+    def_id: DefId,\n+\n+    /// The span of the call site\n+    span: codemap::Span,\n+\n+    /// type substitutions for the current function invocation\n+    substs: &'tcx Substs<'tcx>,\n+\n     /// The MIR for the function called on this frame.\n     mir: CachedMir<'a, 'tcx>,\n \n-    /// The block this frame will execute when a function call returns back to this frame.\n+    /// The block that is currently executed (or will be executed after the above call stacks return)\n     next_block: mir::BasicBlock,\n \n     /// A pointer for writing the return value of the current call if it's not a diverging call.\n@@ -86,6 +91,9 @@ struct Frame<'a, 'tcx: 'a> {\n \n     /// The offset of the first temporary in `self.locals`.\n     temp_offset: usize,\n+\n+    /// The index of the currently evaluated statment\n+    stmt: usize,\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -110,8 +118,8 @@ enum CachedMir<'mir, 'tcx: 'mir> {\n \n /// Represents the action to be taken in the main loop as a result of executing a terminator.\n enum TerminatorTarget {\n-    /// Make a local jump to the given block.\n-    Block(mir::BasicBlock),\n+    /// Make a local jump to the next block\n+    Block,\n \n     /// Start executing from the new current frame. (For function calls.)\n     Call,\n@@ -120,6 +128,26 @@ enum TerminatorTarget {\n     Return,\n }\n \n+#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n+/// Uniquely identifies a specific constant or static\n+struct ConstantId<'tcx> {\n+    /// the def id of the constant/static or in case of promoteds, the def id of the function they belong to\n+    def_id: DefId,\n+    /// In case of statics and constants this is `Substs::empty()`, so only promoteds and associated\n+    /// constants actually have something useful here. We could special case statics and constants,\n+    /// but that would only require more branching when working with constants, and not bring any\n+    /// real benefits.\n+    substs: &'tcx Substs<'tcx>,\n+    kind: ConstantKind,\n+}\n+\n+#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n+enum ConstantKind {\n+    Promoted(usize),\n+    /// Statics, constants and associated constants\n+    Global,\n+}\n+\n impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir_map: &'a MirMap<'tcx>) -> Self {\n         GlobalEvalContext {\n@@ -131,107 +159,253 @@ impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n                                    .uint_type\n                                    .bit_width()\n                                    .expect(\"Session::target::uint_type was usize\")/8),\n-            substs_stack: Vec::new(),\n-            name_stack: Vec::new(),\n+            statics: HashMap::new(),\n         }\n     }\n-}\n \n-impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n-    fn new(gecx: &'a mut GlobalEvalContext<'b, 'tcx>) -> Self {\n-        FnEvalContext {\n-            gecx: gecx,\n-            stack: Vec::new(),\n+    fn call(&mut self, mir: &mir::Mir<'tcx>, def_id: DefId) -> EvalResult<Option<Pointer>> {\n+        let substs = self.tcx.mk_substs(subst::Substs::empty());\n+        let return_ptr = self.alloc_ret_ptr(mir.return_ty, substs);\n+\n+        let mut nested_fecx = FnEvalContext::new(self);\n+\n+        nested_fecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, None);\n+\n+        nested_fecx.frame_mut().return_ptr = return_ptr;\n+\n+        nested_fecx.run()?;\n+        Ok(return_ptr)\n+    }\n+\n+    fn alloc_ret_ptr(&mut self, output_ty: ty::FnOutput<'tcx>, substs: &'tcx Substs<'tcx>) -> Option<Pointer> {\n+        match output_ty {\n+            ty::FnConverging(ty) => {\n+                let size = self.type_size(ty, substs);\n+                Some(self.memory.allocate(size))\n+            }\n+            ty::FnDiverging => None,\n         }\n     }\n \n-    fn maybe_report<T>(&self, span: codemap::Span, r: EvalResult<T>) -> EvalResult<T> {\n-        if let Err(ref e) = r {\n-            let mut err = self.tcx.sess.struct_span_err(span, &e.to_string());\n-            for &(def_id, substs, span) in self.name_stack.iter().rev() {\n-                // FIXME(solson): Find a way to do this without this Display impl hack.\n-                use rustc::util::ppaux;\n-                use std::fmt;\n-                struct Instance<'tcx>(DefId, &'tcx Substs<'tcx>);\n-                impl<'tcx> fmt::Display for Instance<'tcx> {\n-                    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                        ppaux::parameterized(f, self.1, self.0, ppaux::Ns::Value, &[],\n-                            |tcx| tcx.lookup_item_type(self.0).generics)\n-                    }\n-                }\n-                err.span_note(span, &format!(\"inside call to {}\", Instance(def_id, substs)));\n+    // TODO(solson): Try making const_to_primval instead.\n+    fn const_to_ptr(&mut self, const_val: &const_val::ConstVal) -> EvalResult<Pointer> {\n+        use rustc::middle::const_val::ConstVal::*;\n+        match *const_val {\n+            Float(_f) => unimplemented!(),\n+            Integral(int) => {\n+                // TODO(solson): Check int constant type.\n+                let ptr = self.memory.allocate(8);\n+                self.memory.write_uint(ptr, int.to_u64_unchecked(), 8)?;\n+                Ok(ptr)\n             }\n-            err.emit();\n+            Str(ref s) => {\n+                let psize = self.memory.pointer_size;\n+                let static_ptr = self.memory.allocate(s.len());\n+                let ptr = self.memory.allocate(psize * 2);\n+                self.memory.write_bytes(static_ptr, s.as_bytes())?;\n+                self.memory.write_ptr(ptr, static_ptr)?;\n+                self.memory.write_usize(ptr.offset(psize as isize), s.len() as u64)?;\n+                Ok(ptr)\n+            }\n+            ByteStr(ref bs) => {\n+                let psize = self.memory.pointer_size;\n+                let static_ptr = self.memory.allocate(bs.len());\n+                let ptr = self.memory.allocate(psize);\n+                self.memory.write_bytes(static_ptr, bs)?;\n+                self.memory.write_ptr(ptr, static_ptr)?;\n+                Ok(ptr)\n+            }\n+            Bool(b) => {\n+                let ptr = self.memory.allocate(1);\n+                self.memory.write_bool(ptr, b)?;\n+                Ok(ptr)\n+            }\n+            Char(_c)          => unimplemented!(),\n+            Struct(_node_id)  => unimplemented!(),\n+            Tuple(_node_id)   => unimplemented!(),\n+            Function(_def_id) => unimplemented!(),\n+            Array(_, _)       => unimplemented!(),\n+            Repeat(_, _)      => unimplemented!(),\n+            Dummy             => unimplemented!(),\n         }\n-        r\n     }\n \n-    fn run(&mut self) -> EvalResult<()> {\n-        'outer: while !self.stack.is_empty() {\n-            let mut current_block = self.frame().next_block;\n-\n-            loop {\n-                trace!(\"// {:?}\", current_block);\n-                let current_mir = self.mir().clone(); // Cloning a reference.\n-                let block_data = current_mir.basic_block_data(current_block);\n-\n-                for stmt in &block_data.statements {\n-                    trace!(\"{:?}\", stmt);\n-                    let mir::StatementKind::Assign(ref lvalue, ref rvalue) = stmt.kind;\n-                    let result = self.eval_assignment(lvalue, rvalue);\n-                    self.maybe_report(stmt.span, result)?;\n-                }\n+    fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n+        self.tcx.type_needs_drop_given_env(ty, &self.tcx.empty_parameter_environment())\n+    }\n \n-                let terminator = block_data.terminator();\n-                trace!(\"{:?}\", terminator.kind);\n+    fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n+        ty.is_sized(self.tcx, &self.tcx.empty_parameter_environment(), DUMMY_SP)\n+    }\n \n-                let result = self.eval_terminator(terminator);\n-                match self.maybe_report(terminator.span, result)? {\n-                    TerminatorTarget::Block(block) => current_block = block,\n-                    TerminatorTarget::Return => {\n-                        self.pop_stack_frame();\n-                        self.name_stack.pop();\n-                        continue 'outer;\n-                    }\n-                    TerminatorTarget::Call => continue 'outer,\n+    fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n+        // Do the initial selection for the obligation. This yields the shallow result we are\n+        // looking for -- that is, what specific impl.\n+        self.tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+            let mut selcx = traits::SelectionContext::new(&infcx);\n+\n+            let obligation = traits::Obligation::new(\n+                traits::ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID),\n+                trait_ref.to_poly_trait_predicate(),\n+            );\n+            let selection = selcx.select(&obligation).unwrap().unwrap();\n+\n+            // Currently, we use a fulfillment context to completely resolve all nested obligations.\n+            // This is because they can inform the inference of the impl's type parameters.\n+            let mut fulfill_cx = traits::FulfillmentContext::new();\n+            let vtable = selection.map(|predicate| {\n+                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+            });\n+            infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &vtable)\n+        })\n+    }\n+\n+    /// Trait method, which has to be resolved to an impl method.\n+    pub fn trait_method(\n+        &self,\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>\n+    ) -> (DefId, &'tcx Substs<'tcx>) {\n+        let method_item = self.tcx.impl_or_trait_item(def_id);\n+        let trait_id = method_item.container().id();\n+        let trait_ref = ty::Binder(substs.to_trait_ref(self.tcx, trait_id));\n+        match self.fulfill_obligation(trait_ref) {\n+            traits::VtableImpl(vtable_impl) => {\n+                let impl_did = vtable_impl.impl_def_id;\n+                let mname = self.tcx.item_name(def_id);\n+                // Create a concatenated set of substitutions which includes those from the impl\n+                // and those from the method:\n+                let impl_substs = vtable_impl.substs.with_method_from(substs);\n+                let substs = self.tcx.mk_substs(impl_substs);\n+                let mth = get_impl_method(self.tcx, impl_did, substs, mname);\n+\n+                (mth.method.def_id, mth.substs)\n+            }\n+\n+            traits::VtableClosure(vtable_closure) =>\n+                (vtable_closure.closure_def_id, vtable_closure.substs.func_substs),\n+\n+            traits::VtableFnPointer(_fn_ty) => {\n+                let _trait_closure_kind = self.tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+                unimplemented!()\n+                // let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, fn_ty);\n+\n+                // let method_ty = def_ty(tcx, def_id, substs);\n+                // let fn_ptr_ty = match method_ty.sty {\n+                //     ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n+                //     _ => unreachable!(\"expected fn item type, found {}\",\n+                //                       method_ty)\n+                // };\n+                // Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n+            }\n+\n+            traits::VtableObject(ref _data) => {\n+                unimplemented!()\n+                // Callee {\n+                //     data: Virtual(traits::get_vtable_index_of_object_method(\n+                //                   tcx, data, def_id)),\n+                //                   ty: def_ty(tcx, def_id, substs)\n+                // }\n+            }\n+            vtable => unreachable!(\"resolved vtable bad vtable {:?} in trans\", vtable),\n+        }\n+    }\n+\n+    fn load_mir(&self, def_id: DefId) -> CachedMir<'a, 'tcx> {\n+        match self.tcx.map.as_local_node_id(def_id) {\n+            Some(node_id) => CachedMir::Ref(self.mir_map.map.get(&node_id).unwrap()),\n+            None => {\n+                let mut mir_cache = self.mir_cache.borrow_mut();\n+                if let Some(mir) = mir_cache.get(&def_id) {\n+                    return CachedMir::Owned(mir.clone());\n                 }\n+\n+                let cs = &self.tcx.sess.cstore;\n+                let mir = cs.maybe_get_item_mir(self.tcx, def_id).unwrap_or_else(|| {\n+                    panic!(\"no mir for {:?}\", def_id);\n+                });\n+                let cached = Rc::new(mir);\n+                mir_cache.insert(def_id, cached.clone());\n+                CachedMir::Owned(cached)\n             }\n         }\n+    }\n \n-        Ok(())\n+    fn monomorphize(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+        let substituted = ty.subst(self.tcx, substs);\n+        self.tcx.normalize_associated_type(&substituted)\n+    }\n+\n+    fn type_size(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> usize {\n+        self.type_layout(ty, substs).size(&self.tcx.data_layout).bytes() as usize\n     }\n \n-    fn call_nested(&mut self, mir: &mir::Mir<'tcx>) -> EvalResult<Option<Pointer>> {\n-        let mut nested_fecx = FnEvalContext::new(self.gecx);\n+    fn type_layout(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> &'tcx Layout {\n+        // TODO(solson): Is this inefficient? Needs investigation.\n+        let ty = self.monomorphize(ty, substs);\n \n-        let return_ptr = match mir.return_ty {\n-            ty::FnConverging(ty) => {\n-                let size = nested_fecx.type_size(ty);\n-                Some(nested_fecx.memory.allocate(size))\n-            }\n-            ty::FnDiverging => None,\n+        self.tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+            // TODO(solson): Report this error properly.\n+            ty.layout(&infcx).unwrap()\n+        })\n+    }\n+}\n+\n+impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n+    fn new(gecx: &'a mut GlobalEvalContext<'b, 'tcx>) -> Self {\n+        FnEvalContext {\n+            gecx: gecx,\n+            stack: Vec::new(),\n+        }\n+    }\n+\n+    #[inline(never)]\n+    #[cold]\n+    fn report(&self, e: &EvalError) {\n+        let stmt = self.frame().stmt;\n+        let block = self.basic_block();\n+        let span = if stmt < block.statements.len() {\n+            block.statements[stmt].span\n+        } else {\n+            block.terminator().span\n         };\n+        let mut err = self.tcx.sess.struct_span_err(span, &e.to_string());\n+        for &Frame{ def_id, substs, span, .. } in self.stack.iter().rev() {\n+            // FIXME(solson): Find a way to do this without this Display impl hack.\n+            use rustc::util::ppaux;\n+            use std::fmt;\n+            struct Instance<'tcx>(DefId, &'tcx Substs<'tcx>);\n+            impl<'tcx> fmt::Display for Instance<'tcx> {\n+                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                    ppaux::parameterized(f, self.1, self.0, ppaux::Ns::Value, &[],\n+                        |tcx| tcx.lookup_item_type(self.0).generics)\n+                }\n+            }\n+            err.span_note(span, &format!(\"inside call to {}\", Instance(def_id, substs)));\n+        }\n+        err.emit();\n+    }\n \n-        let substs = nested_fecx.substs();\n-        nested_fecx.push_stack_frame(CachedMir::Ref(mir), substs, return_ptr);\n-        nested_fecx.run()?;\n-        Ok(return_ptr)\n+    fn maybe_report<T>(&self, r: EvalResult<T>) -> EvalResult<T> {\n+        if let Err(ref e) = r {\n+            self.report(e);\n+        }\n+        r\n+    }\n+\n+    fn run(&mut self) -> EvalResult<()> {\n+        let mut stepper = stepper::Stepper::new(self);\n+        while stepper.step()? {}\n+        Ok(())\n     }\n \n-    fn push_stack_frame(&mut self, mir: CachedMir<'mir, 'tcx>, substs: &'tcx Substs<'tcx>,\n+    fn push_stack_frame(&mut self, def_id: DefId, span: codemap::Span, mir: CachedMir<'mir, 'tcx>, substs: &'tcx Substs<'tcx>,\n         return_ptr: Option<Pointer>)\n     {\n-        self.substs_stack.push(substs);\n-\n         let arg_tys = mir.arg_decls.iter().map(|a| a.ty);\n         let var_tys = mir.var_decls.iter().map(|v| v.ty);\n         let temp_tys = mir.temp_decls.iter().map(|t| t.ty);\n \n-        let locals: Vec<Pointer> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {\n-            let size = self.type_size(ty);\n-            self.memory.allocate(size)\n-        }).collect();\n-\n         let num_args = mir.arg_decls.len();\n         let num_vars = mir.var_decls.len();\n \n@@ -241,17 +415,27 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             mir: mir.clone(),\n             next_block: mir::START_BLOCK,\n             return_ptr: return_ptr,\n-            locals: locals,\n+            locals: Vec::new(),\n             var_offset: num_args,\n             temp_offset: num_args + num_vars,\n+            span: span,\n+            def_id: def_id,\n+            substs: substs,\n+            stmt: 0,\n         });\n+\n+        let locals: Vec<Pointer> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {\n+            let size = self.type_size(ty);\n+            self.memory.allocate(size)\n+        }).collect();\n+\n+        self.frame_mut().locals = locals;\n     }\n \n     fn pop_stack_frame(&mut self) {\n         ::log_settings::settings().indentation -= 1;\n         let _frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n         // TODO(solson): Deallocate local variables.\n-        self.substs_stack.pop();\n     }\n \n     fn eval_terminator(&mut self, terminator: &mir::Terminator<'tcx>)\n@@ -260,12 +444,16 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         let target = match terminator.kind {\n             Return => TerminatorTarget::Return,\n \n-            Goto { target } => TerminatorTarget::Block(target),\n+            Goto { target } => {\n+                self.frame_mut().next_block = target;\n+                TerminatorTarget::Block\n+            },\n \n             If { ref cond, targets: (then_target, else_target) } => {\n                 let cond_ptr = self.eval_operand(cond)?;\n                 let cond_val = self.memory.read_bool(cond_ptr)?;\n-                TerminatorTarget::Block(if cond_val { then_target } else { else_target })\n+                self.frame_mut().next_block = if cond_val { then_target } else { else_target };\n+                TerminatorTarget::Block\n             }\n \n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n@@ -288,7 +476,8 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                     }\n                 }\n \n-                TerminatorTarget::Block(target_block)\n+                self.frame_mut().next_block = target_block;\n+                TerminatorTarget::Block\n             }\n \n             Switch { ref discr, ref targets, adt_def } => {\n@@ -299,7 +488,10 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                     .position(|v| discr_val == v.disr_val.to_u64_unchecked());\n \n                 match matching {\n-                    Some(i) => TerminatorTarget::Block(targets[i]),\n+                    Some(i) => {\n+                        self.frame_mut().next_block = targets[i];\n+                        TerminatorTarget::Block\n+                    },\n                     None => return Err(EvalError::InvalidDiscriminant),\n                 }\n             }\n@@ -378,8 +570,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                                 }\n \n                                 let mir = self.load_mir(resolved_def_id);\n-                                self.name_stack.push((def_id, substs, terminator.span));\n-                                self.push_stack_frame(mir, resolved_substs, return_ptr);\n+                                self.push_stack_frame(def_id, terminator.span, mir, resolved_substs, return_ptr);\n \n                                 for (i, (src, src_ty)) in arg_srcs.into_iter().enumerate() {\n                                     let dest = self.frame().locals[i];\n@@ -401,7 +592,8 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                 let ptr = self.eval_lvalue(value)?.to_ptr();\n                 let ty = self.lvalue_ty(value);\n                 self.drop(ptr, ty)?;\n-                TerminatorTarget::Block(target)\n+                self.frame_mut().next_block = target;\n+                TerminatorTarget::Block\n             }\n \n             Resume => unimplemented!(),\n@@ -992,18 +1184,30 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         use rustc::mir::repr::Operand::*;\n         match *op {\n             Consume(ref lvalue) => Ok(self.eval_lvalue(lvalue)?.to_ptr()),\n-            Constant(mir::Constant { ref literal, .. }) => {\n+            Constant(mir::Constant { ref literal, ty, .. }) => {\n                 use rustc::mir::repr::Literal::*;\n                 match *literal {\n                     Value { ref value } => Ok(self.const_to_ptr(value)?),\n-                    Item { .. } => unimplemented!(),\n+                    Item { def_id, substs } => {\n+                        if let ty::TyFnDef(..) = ty.sty {\n+                            Err(EvalError::Unimplemented(\"unimplemented: mentions of function items\".to_string()))\n+                        } else {\n+                            let cid = ConstantId {\n+                                def_id: def_id,\n+                                substs: substs,\n+                                kind: ConstantKind::Global,\n+                            };\n+                            Ok(*self.statics.get(&cid).expect(\"static should have been cached (rvalue)\"))\n+                        }\n+                    },\n                     Promoted { index } => {\n-                        // TODO(solson): Mark constants and statics as read-only and cache their\n-                        // values.\n-                        let current_mir = self.mir();\n-                        let mir = &current_mir.promoted[index];\n-                        self.call_nested(mir).map(Option::unwrap)\n-                    }\n+                        let cid = ConstantId {\n+                            def_id: self.frame().def_id,\n+                            substs: self.substs(),\n+                            kind: ConstantKind::Promoted(index),\n+                        };\n+                        Ok(*self.statics.get(&cid).expect(\"a promoted constant hasn't been precomputed\"))\n+                    },\n                 }\n             }\n         }\n@@ -1019,10 +1223,14 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             Temp(i) => self.frame().locals[self.frame().temp_offset + i as usize],\n \n             Static(def_id) => {\n-                // TODO(solson): Mark constants and statics as read-only and cache their values.\n-                let mir = self.load_mir(def_id);\n-                self.call_nested(&mir)?.unwrap()\n-            }\n+                let substs = self.tcx.mk_substs(subst::Substs::empty());\n+                let cid = ConstantId {\n+                    def_id: def_id,\n+                    substs: substs,\n+                    kind: ConstantKind::Global,\n+                };\n+                *self.gecx.statics.get(&cid).expect(\"static should have been cached (lvalue)\")\n+            },\n \n             Projection(ref proj) => {\n                 let base = self.eval_lvalue(&proj.base)?;\n@@ -1104,49 +1312,6 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         Ok(Lvalue { ptr: ptr, extra: LvalueExtra::None })\n     }\n \n-    // TODO(solson): Try making const_to_primval instead.\n-    fn const_to_ptr(&mut self, const_val: &const_val::ConstVal) -> EvalResult<Pointer> {\n-        use rustc::middle::const_val::ConstVal::*;\n-        match *const_val {\n-            Float(_f) => unimplemented!(),\n-            Integral(int) => {\n-                // TODO(solson): Check int constant type.\n-                let ptr = self.memory.allocate(8);\n-                self.memory.write_uint(ptr, int.to_u64_unchecked(), 8)?;\n-                Ok(ptr)\n-            }\n-            Str(ref s) => {\n-                let psize = self.memory.pointer_size;\n-                let static_ptr = self.memory.allocate(s.len());\n-                let ptr = self.memory.allocate(psize * 2);\n-                self.memory.write_bytes(static_ptr, s.as_bytes())?;\n-                self.memory.write_ptr(ptr, static_ptr)?;\n-                self.memory.write_usize(ptr.offset(psize as isize), s.len() as u64)?;\n-                Ok(ptr)\n-            }\n-            ByteStr(ref bs) => {\n-                let psize = self.memory.pointer_size;\n-                let static_ptr = self.memory.allocate(bs.len());\n-                let ptr = self.memory.allocate(psize);\n-                self.memory.write_bytes(static_ptr, bs)?;\n-                self.memory.write_ptr(ptr, static_ptr)?;\n-                Ok(ptr)\n-            }\n-            Bool(b) => {\n-                let ptr = self.memory.allocate(1);\n-                self.memory.write_bool(ptr, b)?;\n-                Ok(ptr)\n-            }\n-            Char(_c)          => unimplemented!(),\n-            Struct(_node_id)  => unimplemented!(),\n-            Tuple(_node_id)   => unimplemented!(),\n-            Function(_def_id) => unimplemented!(),\n-            Array(_, _)       => unimplemented!(),\n-            Repeat(_, _)      => unimplemented!(),\n-            Dummy             => unimplemented!(),\n-        }\n-    }\n-\n     fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n         self.monomorphize(self.mir().lvalue_ty(self.tcx, lvalue).to_ty(self.tcx))\n     }\n@@ -1156,12 +1321,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n     }\n \n     fn monomorphize(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let substituted = ty.subst(self.tcx, self.substs());\n-        self.tcx.normalize_associated_type(&substituted)\n-    }\n-\n-    fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        self.tcx.type_needs_drop_given_env(ty, &self.tcx.empty_parameter_environment())\n+        self.gecx.monomorphize(ty, self.substs())\n     }\n \n     fn move_(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<()> {\n@@ -1173,22 +1333,12 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         Ok(())\n     }\n \n-    fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_sized(self.tcx, &self.tcx.empty_parameter_environment(), DUMMY_SP)\n-    }\n-\n     fn type_size(&self, ty: Ty<'tcx>) -> usize {\n-        self.type_layout(ty).size(&self.tcx.data_layout).bytes() as usize\n+        self.gecx.type_size(ty, self.substs())\n     }\n \n     fn type_layout(&self, ty: Ty<'tcx>) -> &'tcx Layout {\n-        // TODO(solson): Is this inefficient? Needs investigation.\n-        let ty = self.monomorphize(ty);\n-\n-        self.tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n-            // TODO(solson): Report this error properly.\n-            ty.layout(&infcx).unwrap()\n-        })\n+        self.gecx.type_layout(ty, self.substs())\n     }\n \n     pub fn read_primval(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<PrimVal> {\n@@ -1234,6 +1384,11 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         self.stack.last().expect(\"no call frames exist\")\n     }\n \n+    fn basic_block(&self) -> &mir::BasicBlockData<'tcx> {\n+        let frame = self.frame();\n+        frame.mir.basic_block_data(frame.next_block)\n+    }\n+\n     fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx> {\n         self.stack.last_mut().expect(\"no call frames exist\")\n     }\n@@ -1243,100 +1398,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n     }\n \n     fn substs(&self) -> &'tcx Substs<'tcx> {\n-        self.substs_stack.last().cloned().unwrap_or_else(|| self.tcx.mk_substs(Substs::empty()))\n-    }\n-\n-    fn load_mir(&self, def_id: DefId) -> CachedMir<'mir, 'tcx> {\n-        match self.tcx.map.as_local_node_id(def_id) {\n-            Some(node_id) => CachedMir::Ref(self.mir_map.map.get(&node_id).unwrap()),\n-            None => {\n-                let mut mir_cache = self.mir_cache.borrow_mut();\n-                if let Some(mir) = mir_cache.get(&def_id) {\n-                    return CachedMir::Owned(mir.clone());\n-                }\n-\n-                let cs = &self.tcx.sess.cstore;\n-                let mir = cs.maybe_get_item_mir(self.tcx, def_id).unwrap_or_else(|| {\n-                    panic!(\"no mir for {:?}\", def_id);\n-                });\n-                let cached = Rc::new(mir);\n-                mir_cache.insert(def_id, cached.clone());\n-                CachedMir::Owned(cached)\n-            }\n-        }\n-    }\n-\n-    fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n-        // Do the initial selection for the obligation. This yields the shallow result we are\n-        // looking for -- that is, what specific impl.\n-        self.tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n-            let mut selcx = traits::SelectionContext::new(&infcx);\n-\n-            let obligation = traits::Obligation::new(\n-                traits::ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID),\n-                trait_ref.to_poly_trait_predicate(),\n-            );\n-            let selection = selcx.select(&obligation).unwrap().unwrap();\n-\n-            // Currently, we use a fulfillment context to completely resolve all nested obligations.\n-            // This is because they can inform the inference of the impl's type parameters.\n-            let mut fulfill_cx = traits::FulfillmentContext::new();\n-            let vtable = selection.map(|predicate| {\n-                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-            });\n-            infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &vtable)\n-        })\n-    }\n-\n-    /// Trait method, which has to be resolved to an impl method.\n-    pub fn trait_method(\n-        &self,\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>\n-    ) -> (DefId, &'tcx Substs<'tcx>) {\n-        let method_item = self.tcx.impl_or_trait_item(def_id);\n-        let trait_id = method_item.container().id();\n-        let trait_ref = ty::Binder(substs.to_trait_ref(self.tcx, trait_id));\n-        match self.fulfill_obligation(trait_ref) {\n-            traits::VtableImpl(vtable_impl) => {\n-                let impl_did = vtable_impl.impl_def_id;\n-                let mname = self.tcx.item_name(def_id);\n-                // Create a concatenated set of substitutions which includes those from the impl\n-                // and those from the method:\n-                let impl_substs = vtable_impl.substs.with_method_from(substs);\n-                let substs = self.tcx.mk_substs(impl_substs);\n-                let mth = get_impl_method(self.tcx, impl_did, substs, mname);\n-\n-                (mth.method.def_id, mth.substs)\n-            }\n-\n-            traits::VtableClosure(vtable_closure) =>\n-                (vtable_closure.closure_def_id, vtable_closure.substs.func_substs),\n-\n-            traits::VtableFnPointer(_fn_ty) => {\n-                let _trait_closure_kind = self.tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n-                unimplemented!()\n-                // let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, fn_ty);\n-\n-                // let method_ty = def_ty(tcx, def_id, substs);\n-                // let fn_ptr_ty = match method_ty.sty {\n-                //     ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n-                //     _ => unreachable!(\"expected fn item type, found {}\",\n-                //                       method_ty)\n-                // };\n-                // Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n-            }\n-\n-            traits::VtableObject(ref _data) => {\n-                unimplemented!()\n-                // Callee {\n-                //     data: Virtual(traits::get_vtable_index_of_object_method(\n-                //                   tcx, data, def_id)),\n-                //                   ty: def_ty(tcx, def_id, substs)\n-                // }\n-            }\n-            vtable => unreachable!(\"resolved vtable bad vtable {:?} in trans\", vtable),\n-        }\n+        self.frame().substs\n     }\n }\n \n@@ -1426,10 +1488,9 @@ pub fn interpret_start_points<'a, 'tcx>(\n                 debug!(\"Interpreting: {}\", item.name);\n \n                 let mut gecx = GlobalEvalContext::new(tcx, mir_map);\n-                let mut fecx = FnEvalContext::new(&mut gecx);\n-                match fecx.call_nested(mir) {\n+                match gecx.call(mir, tcx.map.local_def_id(id)) {\n                     Ok(Some(return_ptr)) => if log_enabled!(::log::LogLevel::Debug) {\n-                        fecx.memory.dump(return_ptr.alloc_id);\n+                        gecx.memory.dump(return_ptr.alloc_id);\n                     },\n                     Ok(None) => warn!(\"diverging function returned\"),\n                     Err(_e) => {", "previous_filename": "src/interpreter.rs"}, {"sha": "a113b8f98e8130fc1f156c0e757f8ae0d063c3d2", "filename": "src/interpreter/stepper.rs", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/1186a7d05dacc0696b56244d83ec19e85e3555a6/src%2Finterpreter%2Fstepper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1186a7d05dacc0696b56244d83ec19e85e3555a6/src%2Finterpreter%2Fstepper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstepper.rs?ref=1186a7d05dacc0696b56244d83ec19e85e3555a6", "patch": "@@ -0,0 +1,189 @@\n+use super::{\n+    FnEvalContext,\n+    CachedMir,\n+    TerminatorTarget,\n+    ConstantId,\n+    GlobalEvalContext,\n+    ConstantKind,\n+};\n+use error::EvalResult;\n+use rustc::mir::repr as mir;\n+use rustc::ty::{subst, self};\n+use rustc::hir::def_id::DefId;\n+use rustc::mir::visit::{Visitor, LvalueContext};\n+use syntax::codemap::Span;\n+use std::rc::Rc;\n+use memory::Pointer;\n+\n+pub struct Stepper<'fncx, 'a: 'fncx, 'b: 'a + 'mir, 'mir: 'fncx, 'tcx: 'b>{\n+    fncx: &'fncx mut FnEvalContext<'a, 'b, 'mir, 'tcx>,\n+\n+    // a cache of the constants to be computed before the next statement/terminator\n+    // this is an optimization, so we don't have to allocate a new vector for every statement\n+    constants: Vec<(ConstantId<'tcx>, Span, Pointer, CachedMir<'mir, 'tcx>)>,\n+}\n+\n+impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx> {\n+    pub(super) fn new(fncx: &'fncx mut FnEvalContext<'a, 'b, 'mir, 'tcx>) -> Self {\n+        Stepper {\n+            fncx: fncx,\n+            constants: Vec::new(),\n+        }\n+    }\n+\n+    fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> EvalResult<()> {\n+        trace!(\"{:?}\", stmt);\n+        let mir::StatementKind::Assign(ref lvalue, ref rvalue) = stmt.kind;\n+        let result = self.fncx.eval_assignment(lvalue, rvalue);\n+        self.fncx.maybe_report(result)?;\n+        self.fncx.frame_mut().stmt += 1;\n+        Ok(())\n+    }\n+\n+    fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<()> {\n+        // after a terminator we go to a new block\n+        self.fncx.frame_mut().stmt = 0;\n+        let term = {\n+            trace!(\"{:?}\", terminator.kind);\n+            let result = self.fncx.eval_terminator(terminator);\n+            self.fncx.maybe_report(result)?\n+        };\n+        match term {\n+            TerminatorTarget::Return => {\n+                self.fncx.pop_stack_frame();\n+            },\n+            TerminatorTarget::Block |\n+            TerminatorTarget::Call => trace!(\"// {:?}\", self.fncx.frame().next_block),\n+        }\n+        Ok(())\n+    }\n+\n+    // returns true as long as there are more things to do\n+    pub fn step(&mut self) -> EvalResult<bool> {\n+        if self.fncx.stack.is_empty() {\n+            return Ok(false);\n+        }\n+\n+        let block = self.fncx.frame().next_block;\n+        let stmt = self.fncx.frame().stmt;\n+        let mir = self.fncx.mir();\n+        let basic_block = mir.basic_block_data(block);\n+\n+        if let Some(ref stmt) = basic_block.statements.get(stmt) {\n+            assert!(self.constants.is_empty());\n+            ConstantExtractor {\n+                span: stmt.span,\n+                substs: self.fncx.substs(),\n+                def_id: self.fncx.frame().def_id,\n+                gecx: self.fncx.gecx,\n+                constants: &mut self.constants,\n+                mir: &mir,\n+            }.visit_statement(block, stmt);\n+            if self.constants.is_empty() {\n+                self.statement(stmt)?;\n+            } else {\n+                self.extract_constants()?;\n+            }\n+            return Ok(true);\n+        }\n+\n+        let terminator = basic_block.terminator();\n+        assert!(self.constants.is_empty());\n+        ConstantExtractor {\n+            span: terminator.span,\n+            substs: self.fncx.substs(),\n+            def_id: self.fncx.frame().def_id,\n+            gecx: self.fncx.gecx,\n+            constants: &mut self.constants,\n+            mir: &mir,\n+        }.visit_terminator(block, terminator);\n+        if self.constants.is_empty() {\n+            self.terminator(terminator)?;\n+        } else {\n+            self.extract_constants()?;\n+        }\n+        Ok(true)\n+    }\n+\n+    fn extract_constants(&mut self) -> EvalResult<()> {\n+        assert!(!self.constants.is_empty());\n+        for (cid, span, return_ptr, mir) in self.constants.drain(..) {\n+            trace!(\"queuing a constant\");\n+            self.fncx.push_stack_frame(cid.def_id, span, mir, cid.substs, Some(return_ptr));\n+        }\n+        // self.step() can't be \"done\", so it can't return false\n+        assert!(self.step()?);\n+        Ok(())\n+    }\n+}\n+\n+struct ConstantExtractor<'a, 'b: 'mir, 'mir: 'a, 'tcx: 'b> {\n+    span: Span,\n+    // FIXME: directly push the new stackframes instead of doing this intermediate caching\n+    constants: &'a mut Vec<(ConstantId<'tcx>, Span, Pointer, CachedMir<'mir, 'tcx>)>,\n+    gecx: &'a mut GlobalEvalContext<'b, 'tcx>,\n+    mir: &'a mir::Mir<'tcx>,\n+    def_id: DefId,\n+    substs: &'tcx subst::Substs<'tcx>,\n+}\n+\n+impl<'a, 'b, 'mir, 'tcx> ConstantExtractor<'a, 'b, 'mir, 'tcx> {\n+    fn global_item(&mut self, def_id: DefId, substs: &'tcx subst::Substs<'tcx>, span: Span) {\n+        let cid = ConstantId {\n+            def_id: def_id,\n+            substs: substs,\n+            kind: ConstantKind::Global,\n+        };\n+        if self.gecx.statics.contains_key(&cid) {\n+            return;\n+        }\n+        let mir = self.gecx.load_mir(def_id);\n+        let ptr = self.gecx.alloc_ret_ptr(mir.return_ty, substs).expect(\"there's no such thing as an unreachable static\");\n+        self.gecx.statics.insert(cid.clone(), ptr);\n+        self.constants.push((cid, span, ptr, mir));\n+    }\n+}\n+\n+impl<'a, 'b, 'mir, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'mir, 'tcx> {\n+    fn visit_constant(&mut self, constant: &mir::Constant<'tcx>) {\n+        self.super_constant(constant);\n+        match constant.literal {\n+            // already computed by rustc\n+            mir::Literal::Value { .. } => {}\n+            mir::Literal::Item { def_id, substs } => {\n+                if let ty::TyFnDef(..) = constant.ty.sty {\n+                    // No need to do anything here, even if function pointers are implemented,\n+                    // because the type is the actual function, not the signature of the function.\n+                    // Thus we can simply create a zero sized allocation in `evaluate_operand`\n+                } else {\n+                    self.global_item(def_id, substs, constant.span);\n+                }\n+            },\n+            mir::Literal::Promoted { index } => {\n+                let cid = ConstantId {\n+                    def_id: self.def_id,\n+                    substs: self.substs,\n+                    kind: ConstantKind::Promoted(index),\n+                };\n+                if self.gecx.statics.contains_key(&cid) {\n+                    return;\n+                }\n+                let mir = self.mir.promoted[index].clone();\n+                let return_ty = mir.return_ty;\n+                let return_ptr = self.gecx.alloc_ret_ptr(return_ty, cid.substs).expect(\"there's no such thing as an unreachable static\");\n+                let mir = CachedMir::Owned(Rc::new(mir));\n+                self.gecx.statics.insert(cid.clone(), return_ptr);\n+                self.constants.push((cid, constant.span, return_ptr, mir));\n+            }\n+        }\n+    }\n+\n+    fn visit_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>, context: LvalueContext) {\n+        self.super_lvalue(lvalue, context);\n+        if let mir::Lvalue::Static(def_id) = *lvalue {\n+            let substs = self.gecx.tcx.mk_substs(subst::Substs::empty());\n+            let span = self.span;\n+            self.global_item(def_id, substs, span);\n+        }\n+    }\n+}"}, {"sha": "4e06a3ce38d569fe0c34d9793cbdfbe53d4405b7", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1186a7d05dacc0696b56244d83ec19e85e3555a6/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1186a7d05dacc0696b56244d83ec19e85e3555a6/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=1186a7d05dacc0696b56244d83ec19e85e3555a6", "patch": "@@ -6,6 +6,7 @@\n     filling_drop,\n     question_mark,\n     rustc_private,\n+    pub_restricted,\n )]\n \n // From rustc."}, {"sha": "ab527a47c0bf5cbb57088e54ffa7fae6bfd5288d", "filename": "src/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1186a7d05dacc0696b56244d83ec19e85e3555a6/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1186a7d05dacc0696b56244d83ec19e85e3555a6/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=1186a7d05dacc0696b56244d83ec19e85e3555a6", "patch": "@@ -88,7 +88,7 @@ impl Memory {\n             alloc.bytes.extend(iter::repeat(0).take(amount));\n             alloc.undef_mask.grow(amount, false);\n         } else if size > new_size {\n-            return Err(EvalError::Unimplemented(format!(\"unimplemented allocation relocation\")));\n+            return Err(EvalError::Unimplemented(format!(\"unimplemented allocation relocation (from {} to {})\", size, new_size)));\n             // alloc.bytes.truncate(new_size);\n             // alloc.undef_mask.len = new_size;\n             // TODO: potentially remove relocations"}, {"sha": "754d3d9ee7e6dc17860aa38bb73cc930feb5665f", "filename": "tests/compile-fail/unimplemented.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1186a7d05dacc0696b56244d83ec19e85e3555a6/tests%2Fcompile-fail%2Funimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1186a7d05dacc0696b56244d83ec19e85e3555a6/tests%2Fcompile-fail%2Funimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funimplemented.rs?ref=1186a7d05dacc0696b56244d83ec19e85e3555a6", "patch": "@@ -0,0 +1,12 @@\n+#![feature(custom_attribute)]\n+#![allow(dead_code, unused_attributes)]\n+\n+//error-pattern:unimplemented: mentions of function items\n+\n+\n+#[miri_run]\n+fn failed_assertions() {\n+    assert_eq!(5, 6);\n+}\n+\n+fn main() {}"}, {"sha": "3006da2c163de0ade3939e0827fbcaf464bc67bd", "filename": "tests/run-pass/bug.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1186a7d05dacc0696b56244d83ec19e85e3555a6/tests%2Frun-pass%2Fbug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1186a7d05dacc0696b56244d83ec19e85e3555a6/tests%2Frun-pass%2Fbug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbug.rs?ref=1186a7d05dacc0696b56244d83ec19e85e3555a6", "patch": "@@ -0,0 +1,14 @@\n+#![feature(custom_attribute)]\n+#![allow(dead_code, unused_attributes)]\n+\n+static mut X: usize = 5;\n+\n+#[miri_run]\n+fn static_mut() {\n+    unsafe {\n+        X = 6;\n+        assert_eq!(X, 6);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ba68fb44a6c39469a0dca81685a894b163b6b02f", "filename": "tests/run-pass/calls.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1186a7d05dacc0696b56244d83ec19e85e3555a6/tests%2Frun-pass%2Fcalls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1186a7d05dacc0696b56244d83ec19e85e3555a6/tests%2Frun-pass%2Fcalls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcalls.rs?ref=1186a7d05dacc0696b56244d83ec19e85e3555a6", "patch": "@@ -1,4 +1,4 @@\n-#![feature(custom_attribute)]\n+#![feature(custom_attribute, const_fn)]\n #![allow(dead_code, unused_attributes)]\n \n #[miri_run]\n@@ -33,6 +33,15 @@ fn cross_crate_fn_call() -> i64 {\n     if 1i32.is_positive() { 1 } else { 0 }\n }\n \n+const fn foo(i: i64) -> i64 { *&i + 1 }\n+\n+#[miri_run]\n+fn const_fn_call() -> i64 {\n+    let x = 5 + foo(5);\n+    assert_eq!(x, 11);\n+    x\n+}\n+\n #[miri_run]\n fn main() {\n     assert_eq!(call(), 2);"}, {"sha": "3d6b08c340df57ab8fd5a4980f1ce8ff409f1dce", "filename": "tests/run-pass/constants.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1186a7d05dacc0696b56244d83ec19e85e3555a6/tests%2Frun-pass%2Fconstants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1186a7d05dacc0696b56244d83ec19e85e3555a6/tests%2Frun-pass%2Fconstants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconstants.rs?ref=1186a7d05dacc0696b56244d83ec19e85e3555a6", "patch": "@@ -0,0 +1,11 @@\n+#![feature(custom_attribute)]\n+#![allow(dead_code, unused_attributes)]\n+\n+const A: usize = *&5;\n+\n+#[miri_run]\n+fn foo() -> usize {\n+    A\n+}\n+\n+fn main() {}"}]}