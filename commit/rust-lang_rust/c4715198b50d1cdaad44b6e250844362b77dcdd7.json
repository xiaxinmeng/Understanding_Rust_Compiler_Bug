{"sha": "c4715198b50d1cdaad44b6e250844362b77dcdd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0NzE1MTk4YjUwZDFjZGFhZDQ0YjZlMjUwODQ0MzYyYjc3ZGNkZDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-05T19:06:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-05T19:06:50Z"}, "message": "Auto merge of #59369 - oli-obk:unwrap_usICE, r=eddyb,nikomatsakis\n\n`unwrap_usize` should at least try to evaluate the underlying constant\n\nr? @eddyb\n\nfixes #59016\n\nI know that I'm still using `ParamEnv` wrongly, but that's a preexisting issue not amplified by this PR.", "tree": {"sha": "e5b022013368c41a3f86af6fbc789a858a0f4f93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5b022013368c41a3f86af6fbc789a858a0f4f93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4715198b50d1cdaad44b6e250844362b77dcdd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4715198b50d1cdaad44b6e250844362b77dcdd7", "html_url": "https://github.com/rust-lang/rust/commit/c4715198b50d1cdaad44b6e250844362b77dcdd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4715198b50d1cdaad44b6e250844362b77dcdd7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6ecdc2f61b96de199be956cad853a7c02bcfb58", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6ecdc2f61b96de199be956cad853a7c02bcfb58", "html_url": "https://github.com/rust-lang/rust/commit/f6ecdc2f61b96de199be956cad853a7c02bcfb58"}, {"sha": "bd57498e7d509168609a685b264289643ef8b2c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd57498e7d509168609a685b264289643ef8b2c3", "html_url": "https://github.com/rust-lang/rust/commit/bd57498e7d509168609a685b264289643ef8b2c3"}], "stats": {"total": 440, "additions": 298, "deletions": 142}, "files": [{"sha": "4a9b68f24371d3da61eabe320b4a83898375f37d", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -340,6 +340,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             ambient_variance,\n             needs_wf: false,\n             root_ty: ty,\n+            param_env: self.param_env,\n         };\n \n         let ty = match generalize.relate(&ty, &ty) {\n@@ -379,6 +380,8 @@ struct Generalizer<'cx, 'tcx> {\n \n     /// The root type that we are generalizing. Used when reporting cycles.\n     root_ty: Ty<'tcx>,\n+\n+    param_env: ty::ParamEnv<'tcx>,\n }\n \n /// Result from a generalization operation. This includes\n@@ -419,6 +422,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> { self.param_env }\n \n     fn tag(&self) -> &'static str {\n         \"Generalizer\""}, {"sha": "5dfa0d29daf1b7e5647bfd791e7ebaba4881eca5", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -30,6 +30,8 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n \n     fn tcx(&self) -> TyCtxt<'tcx> { self.fields.tcx() }\n \n+    fn param_env(&self) -> ty::ParamEnv<'tcx> { self.fields.param_env }\n+\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn relate_item_substs(&mut self,"}, {"sha": "2cef521176269fb8f6c35e01e65f486819891674", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -27,6 +27,8 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n \n     fn tcx(&self) -> TyCtxt<'tcx> { self.fields.tcx() }\n \n+    fn param_env(&self) -> ty::ParamEnv<'tcx> { self.fields.param_env }\n+\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,"}, {"sha": "e20372f1513712359a007ba5af3a4c3e34c7c345", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -27,6 +27,8 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n \n     fn tcx(&self) -> TyCtxt<'tcx> { self.fields.tcx() }\n \n+    fn param_env(&self) -> ty::ParamEnv<'tcx> { self.fields.param_env }\n+\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,"}, {"sha": "5d521def65b0b91dc5e3ebee1ed97eba22765bc9", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -502,6 +502,9 @@ where\n         self.infcx.tcx\n     }\n \n+    // FIXME(oli-obk): not sure how to get the correct ParamEnv\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> { ty::ParamEnv::empty() }\n+\n     fn tag(&self) -> &'static str {\n         \"nll::subtype\"\n     }\n@@ -831,6 +834,9 @@ where\n         self.infcx.tcx\n     }\n \n+    // FIXME(oli-obk): not sure how to get the correct ParamEnv\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> { ty::ParamEnv::empty() }\n+\n     fn tag(&self) -> &'static str {\n         \"nll::generalizer\"\n     }"}, {"sha": "e6155454d46f1fe9ffbc774f9e07bffa60f40246", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -27,7 +27,7 @@ use crate::ty::{self, Ty};\n /// interested in the `OutlivesEnvironment`. -nmatsakis\n #[derive(Clone)]\n pub struct OutlivesEnvironment<'tcx> {\n-    param_env: ty::ParamEnv<'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n     free_region_map: FreeRegionMap<'tcx>,\n \n     // Contains, for each body B that we are checking (that is, the fn"}, {"sha": "cd1d206b5fca1282af18ff333f56c894678dfff0", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -35,6 +35,9 @@ impl<'combine, 'infcx, 'tcx> Sub<'combine, 'infcx, 'tcx> {\n impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Sub\" }\n     fn tcx(&self) -> TyCtxt<'tcx> { self.fields.infcx.tcx }\n+\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> { self.fields.param_env }\n+\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn with_cause<F,R>(&mut self, cause: Cause, f: F) -> R"}, {"sha": "a274d7bbee5f783fa395bdeb91222e97d3761e45", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -277,6 +277,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     ) -> Self {\n         ExprUseVisitor {\n             mc: mc::MemCategorizationContext::new(tcx,\n+                                                  param_env,\n                                                   body_owner,\n                                                   region_scope_tree,\n                                                   tables,\n@@ -299,6 +300,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         ExprUseVisitor {\n             mc: mc::MemCategorizationContext::with_infer(\n                 infcx,\n+                param_env,\n                 body_owner,\n                 region_scope_tree,\n                 tables,"}, {"sha": "77d6f3932445b0eb5ccdafacd1b48ac24c2d40ee", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -214,6 +214,7 @@ impl HirNode for hir::Pat {\n #[derive(Clone)]\n pub struct MemCategorizationContext<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     pub body_owner: DefId,\n     pub upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n     pub region_scope_tree: &'a region::ScopeTree,\n@@ -330,6 +331,7 @@ impl MutabilityCategory {\n impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     pub fn new(\n         tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         body_owner: DefId,\n         region_scope_tree: &'a region::ScopeTree,\n         tables: &'a ty::TypeckTables<'tcx>,\n@@ -342,7 +344,8 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             region_scope_tree,\n             tables,\n             rvalue_promotable_map,\n-            infcx: None\n+            infcx: None,\n+            param_env,\n         }\n     }\n }\n@@ -359,6 +362,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     ///   known, the results around upvar accesses may be incorrect.\n     pub fn with_infer(\n         infcx: &'a InferCtxt<'a, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         body_owner: DefId,\n         region_scope_tree: &'a region::ScopeTree,\n         tables: &'a ty::TypeckTables<'tcx>,\n@@ -379,6 +383,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             tables,\n             rvalue_promotable_map,\n             infcx: Some(infcx),\n+            param_env,\n         }\n     }\n \n@@ -896,7 +901,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n \n         // Always promote `[T; 0]` (even when e.g., borrowed mutably).\n         let promotable = match expr_ty.sty {\n-            ty::Array(_, len) if len.assert_usize(self.tcx) == Some(0) => true,\n+            ty::Array(_, len) if len.try_eval_usize(self.tcx, self.param_env) == Some(0) => true,\n             _ => promotable,\n         };\n "}, {"sha": "f8889380b2abf9341ddb420215c4840b605bd766", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -57,7 +57,7 @@ impl<'tcx> PlaceTy<'tcx> {\n     /// `PlaceElem`, where we can just use the `Ty` that is already\n     /// stored inline on field projection elems.\n     pub fn projection_ty(self, tcx: TyCtxt<'tcx>, elem: &PlaceElem<'tcx>) -> PlaceTy<'tcx> {\n-        self.projection_ty_core(tcx, elem, |_, _, ty| ty)\n+        self.projection_ty_core(tcx, ty::ParamEnv::empty(), elem, |_, _, ty| ty)\n     }\n \n     /// `place_ty.projection_ty_core(tcx, elem, |...| { ... })`\n@@ -68,6 +68,7 @@ impl<'tcx> PlaceTy<'tcx> {\n     pub fn projection_ty_core<V, T>(\n         self,\n         tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         elem: &ProjectionElem<V, T>,\n         mut handle_field: impl FnMut(&Self, &Field, &T) -> Ty<'tcx>,\n     ) -> PlaceTy<'tcx>\n@@ -90,7 +91,7 @@ impl<'tcx> PlaceTy<'tcx> {\n             ProjectionElem::Subslice { from, to } => {\n                 PlaceTy::from_ty(match self.ty.sty {\n                     ty::Array(inner, size) => {\n-                        let size = size.unwrap_usize(tcx);\n+                        let size = size.eval_usize(tcx, param_env);\n                         let len = size - (from as u64) - (to as u64);\n                         tcx.mk_array(inner, len)\n                     }"}, {"sha": "83bd5c56040e1f48c20ccc3fb6a84db41c6d89b3", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -417,7 +417,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     Some(format!(\"[{}]\", self.tcx.type_of(def.did).to_string())),\n                 ));\n                 let tcx = self.tcx;\n-                if let Some(len) = len.assert_usize(tcx) {\n+                if let Some(len) = len.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n                     flags.push((\n                         sym::_Self,\n                         Some(format!(\"[{}; {}]\", self.tcx.type_of(def.did).to_string(), len)),"}, {"sha": "da582c015e4ea4699deab770d0b5345913cea40f", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -1082,7 +1082,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n         if unbound_input_types && stack.iter().skip(1).any(|prev| {\n             stack.obligation.param_env == prev.obligation.param_env\n-                && self.match_fresh_trait_refs(&stack.fresh_trait_ref, &prev.fresh_trait_ref)\n+                && self.match_fresh_trait_refs(\n+                    &stack.fresh_trait_ref, &prev.fresh_trait_ref, prev.obligation.param_env)\n         }) {\n             debug!(\n                 \"evaluate_stack({:?}) --> unbound argument, recursive --> giving up\",\n@@ -3798,8 +3799,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &self,\n         previous: &ty::PolyTraitRef<'tcx>,\n         current: &ty::PolyTraitRef<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n     ) -> bool {\n-        let mut matcher = ty::_match::Match::new(self.tcx());\n+        let mut matcher = ty::_match::Match::new(self.tcx(), param_env);\n         matcher.relate(previous, current).is_ok()\n     }\n "}, {"sha": "f800a70e0becfadcb11fd8276e53a16fb4229c1f", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -21,17 +21,19 @@ use crate::mir::interpret::ConstValue;\n /// affects any type variables or unification state.\n pub struct Match<'tcx> {\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n }\n \n impl Match<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>) -> Match<'tcx> {\n-        Match { tcx }\n+    pub fn new(tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Match<'tcx> {\n+        Match { tcx, param_env }\n     }\n }\n \n impl TypeRelation<'tcx> for Match<'tcx> {\n     fn tag(&self) -> &'static str { \"Match\" }\n     fn tcx(&self) -> TyCtxt<'tcx> { self.tcx }\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> { self.param_env }\n     fn a_is_expected(&self) -> bool { true } // irrelevant\n \n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,"}, {"sha": "4a72794b61a6471e4ee509c8863c3aa46b0cf450", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -194,7 +194,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.def_path_str(def_id)).into(),\n             ty::Array(_, n) => {\n                 let n = tcx.lift_to_global(&n).unwrap();\n-                match n.assert_usize(tcx) {\n+                match n.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n                     Some(n) => format!(\"array of {} elements\", n).into(),\n                     None => \"array\".into(),\n                 }"}, {"sha": "2b3291656653fc9ce3c44c132723822672ff5ca3", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -3,6 +3,7 @@ use crate::ty::{AdtDef, VariantDef, FieldDef, Ty, TyS};\n use crate::ty::{DefId, SubstsRef};\n use crate::ty::{AdtKind, Visibility};\n use crate::ty::TyKind::*;\n+use crate::ty;\n \n pub use self::def_id_forest::DefIdForest;\n \n@@ -190,7 +191,7 @@ impl<'tcx> TyS<'tcx> {\n                 }))\n             }\n \n-            Array(ty, len) => match len.assert_usize(tcx) {\n+            Array(ty, len) => match len.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n                 // If the array is definitely non-empty, it's uninhabited if\n                 // the type of its elements is uninhabited.\n                 Some(n) if n != 0 => ty.uninhabited_from(tcx),"}, {"sha": "a66a4ac66f3f5edf8d63833f6cd8fe85ea31b930", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -594,7 +594,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     }\n                 }\n \n-                let count = count.assert_usize(tcx).ok_or(LayoutError::Unknown(ty))?;\n+                let count = count.try_eval_usize(tcx, param_env).ok_or(LayoutError::Unknown(ty))?;\n                 let element = self.layout_of(element)?;\n                 let size = element.size.checked_mul(count, dl)\n                     .ok_or(LayoutError::SizeOverflow(ty))?;"}, {"sha": "5fec95e2a3b34f31f84dec3071becbf8fff1db6c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -2357,7 +2357,7 @@ impl<'tcx> AdtDef {\n \n     #[inline]\n     pub fn eval_explicit_discr(&self, tcx: TyCtxt<'tcx>, expr_did: DefId) -> Option<Discr<'tcx>> {\n-        let param_env = ParamEnv::empty();\n+        let param_env = tcx.param_env(expr_did);\n         let repr_type = self.repr.discr_type();\n         let substs = InternalSubsts::identity_for_item(tcx.global_tcx(), expr_did);\n         let instance = ty::Instance::new(expr_did, substs);\n@@ -2368,7 +2368,7 @@ impl<'tcx> AdtDef {\n         match tcx.const_eval(param_env.and(cid)) {\n             Ok(val) => {\n                 // FIXME: Find the right type and use it instead of `val.ty` here\n-                if let Some(b) = val.assert_bits(tcx.global_tcx(), param_env.and(val.ty)) {\n+                if let Some(b) = val.try_eval_bits(tcx.global_tcx(), param_env, val.ty) {\n                     trace!(\"discriminants: {} ({:?})\", b, repr_type);\n                     Some(Discr {\n                         val: b,"}, {"sha": "b68e6a744872f4f3c786e5c59f8d64cd9008f0d9", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -89,7 +89,8 @@ impl DefPathBasedNames<'tcx> {\n             ty::Array(inner_type, len) => {\n                 output.push('[');\n                 self.push_type_name(inner_type, output, debug);\n-                write!(output, \"; {}\", len.unwrap_usize(self.tcx)).unwrap();\n+                let len = len.eval_usize(self.tcx, ty::ParamEnv::reveal_all());\n+                write!(output, \"; {}\", len).unwrap();\n                 output.push(']');\n             }\n             ty::Slice(inner_type) => {"}, {"sha": "017f67463c31be7240ff72b46acf3d74bd95426a", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -696,7 +696,12 @@ pub trait PrettyPrinter<'tcx>:\n             },\n             ty::Array(ty, sz) => {\n                 p!(write(\"[\"), print(ty), write(\"; \"));\n-                if let Some(n) = sz.assert_usize(self.tcx()) {\n+                if let ConstValue::Unevaluated(..) = sz.val {\n+                    // do not try to evalute unevaluated constants. If we are const evaluating an\n+                    // array length anon const, rustc will (with debug assertions) print the\n+                    // constant's path. Which will end up here again.\n+                    p!(write(\"_\"));\n+                } else if let Some(n) = sz.try_eval_usize(self.tcx(), ty::ParamEnv::empty()) {\n                     p!(write(\"{}\", n));\n                 } else {\n                     p!(write(\"_\"));\n@@ -915,7 +920,7 @@ pub trait PrettyPrinter<'tcx>:\n         if let ty::Ref(_, ref_ty, _) = ct.ty.sty {\n             let byte_str = match (ct.val, &ref_ty.sty) {\n                 (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::Array(t, n)) if *t == u8 => {\n-                    let n = n.unwrap_usize(self.tcx());\n+                    let n = n.eval_usize(self.tcx(), ty::ParamEnv::empty());\n                     Some(self.tcx()\n                         .alloc_map.lock()\n                         .unwrap_memory(ptr.alloc_id)"}, {"sha": "945e3e158eafb016c71bed74fdc8547e36e2db22", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -25,6 +25,8 @@ pub enum Cause {\n pub trait TypeRelation<'tcx>: Sized {\n     fn tcx(&self) -> TyCtxt<'tcx>;\n \n+    fn param_env(&self) -> ty::ParamEnv<'tcx>;\n+\n     /// Returns a static string we can use for printouts.\n     fn tag(&self) -> &'static str;\n \n@@ -466,7 +468,9 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n                 Err(err) => {\n                     // Check whether the lengths are both concrete/known values,\n                     // but are unequal, for better diagnostics.\n-                    match (sz_a.assert_usize(tcx), sz_b.assert_usize(tcx)) {\n+                    let sz_a = sz_a.try_eval_usize(tcx, relation.param_env());\n+                    let sz_b = sz_b.try_eval_usize(tcx, relation.param_env());\n+                    match (sz_a, sz_b) {\n                         (Some(sz_a_val), Some(sz_b_val)) => {\n                             Err(TypeError::FixedArraySize(\n                                 expected_found(relation, &sz_a_val, &sz_b_val)"}, {"sha": "769b6592b6fa80ceca715ddf2f05638f918819b6", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -15,7 +15,7 @@ use crate::ty::{self, AdtDef, Discr, DefIdTree, TypeFlags, Ty, TyCtxt, TypeFolda\n use crate::ty::{List, TyS, ParamEnvAnd, ParamEnv};\n use crate::ty::layout::VariantIdx;\n use crate::util::captures::Captures;\n-use crate::mir::interpret::{Scalar, Pointer};\n+use crate::mir::interpret::{Scalar, GlobalId};\n \n use smallvec::SmallVec;\n use std::borrow::Cow;\n@@ -1726,7 +1726,7 @@ impl<'tcx> TyS<'tcx> {\n                 ty.expect_ty().conservative_is_privately_uninhabited(tcx)\n             }),\n             ty::Array(ty, len) => {\n-                match len.assert_usize(tcx) {\n+                match len.try_eval_usize(tcx, ParamEnv::empty()) {\n                     // If the array is definitely non-empty, it's uninhabited if\n                     // the type of its elements is uninhabited.\n                     Some(n) if n != 0 => ty.conservative_is_privately_uninhabited(tcx),\n@@ -2291,50 +2291,58 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn to_bits(&self, tcx: TyCtxt<'tcx>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> Option<u128> {\n-        if self.ty != ty.value {\n-            return None;\n+    pub fn try_eval_bits(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Option<u128> {\n+        assert_eq!(self.ty, ty);\n+        // if `ty` does not depend on generic parameters, use an empty param_env\n+        let size = tcx.layout_of(param_env.with_reveal_all().and(ty)).ok()?.size;\n+        match self.val {\n+            // FIXME(const_generics): this doesn't work right now,\n+            // because it tries to relate an `Infer` to a `Param`.\n+            ConstValue::Unevaluated(did, substs) => {\n+                // if `substs` has no unresolved components, use and empty param_env\n+                let (param_env, substs) = param_env.with_reveal_all().and(substs).into_parts();\n+                // try to resolve e.g. associated constants to their definition on an impl\n+                let instance = ty::Instance::resolve(tcx, param_env, did, substs)?;\n+                let gid = GlobalId {\n+                    instance,\n+                    promoted: None,\n+                };\n+                let evaluated = tcx.const_eval(param_env.and(gid)).ok()?;\n+                evaluated.val.try_to_bits(size)\n+            },\n+            // otherwise just extract a `ConstValue`'s bits if possible\n+            _ => self.val.try_to_bits(size),\n         }\n-        let size = tcx.layout_of(ty).ok()?.size;\n-        self.val.try_to_bits(size)\n-    }\n-\n-    #[inline]\n-    pub fn to_ptr(&self) -> Option<Pointer> {\n-        self.val.try_to_ptr()\n-    }\n-\n-    #[inline]\n-    pub fn assert_bits(&self, tcx: TyCtxt<'tcx>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> Option<u128> {\n-        assert_eq!(self.ty, ty.value);\n-        let size = tcx.layout_of(ty).ok()?.size;\n-        self.val.try_to_bits(size)\n     }\n \n     #[inline]\n-    pub fn assert_bool(&self, tcx: TyCtxt<'tcx>) -> Option<bool> {\n-        self.assert_bits(tcx, ParamEnv::empty().and(tcx.types.bool)).and_then(|v| match v {\n+    pub fn try_eval_bool(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Option<bool> {\n+        self.try_eval_bits(tcx, param_env, tcx.types.bool).and_then(|v| match v {\n             0 => Some(false),\n             1 => Some(true),\n             _ => None,\n         })\n     }\n \n     #[inline]\n-    pub fn assert_usize(&self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n-        self.assert_bits(tcx, ParamEnv::empty().and(tcx.types.usize)).map(|v| v as u64)\n+    pub fn try_eval_usize(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Option<u64> {\n+        self.try_eval_bits(tcx, param_env, tcx.types.usize).map(|v| v as u64)\n     }\n \n     #[inline]\n-    pub fn unwrap_bits(&self, tcx: TyCtxt<'tcx>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> u128 {\n-        self.assert_bits(tcx, ty).unwrap_or_else(||\n-            bug!(\"expected bits of {}, got {:#?}\", ty.value, self))\n+    pub fn eval_bits(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, ty: Ty<'tcx>) -> u128 {\n+        self.try_eval_bits(tcx, param_env, ty).unwrap_or_else(||\n+            bug!(\"expected bits of {:#?}, got {:#?}\", ty, self))\n     }\n \n     #[inline]\n-    pub fn unwrap_usize(&self, tcx: TyCtxt<'tcx>) -> u64 {\n-        self.assert_usize(tcx).unwrap_or_else(||\n-            bug!(\"expected constant usize, got {:#?}\", self))\n+    pub fn eval_usize(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> u64 {\n+        self.eval_bits(tcx, param_env, tcx.types.usize) as u64\n     }\n }\n "}, {"sha": "3b7aee84862ce4743306caf49159e890e0aa761f", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -341,7 +341,7 @@ fn fixed_vec_metadata(\n     let (size, align) = cx.size_and_align_of(array_or_slice_type);\n \n     let upper_bound = match array_or_slice_type.sty {\n-        ty::Array(_, len) => len.unwrap_usize(cx.tcx) as c_longlong,\n+        ty::Array(_, len) => len.eval_usize(cx.tcx, ty::ParamEnv::reveal_all()) as c_longlong,\n         _ => -1\n     };\n "}, {"sha": "cdc54bb179ebf0f02b59485863efa5c7a54bea4a", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -132,7 +132,7 @@ pub fn unsized_info<'tcx, Cx: CodegenMethods<'tcx>>(\n         cx.tcx().struct_lockstep_tails_erasing_lifetimes(source, target, cx.param_env());\n     match (&source.sty, &target.sty) {\n         (&ty::Array(_, len), &ty::Slice(_)) => {\n-            cx.const_usize(len.unwrap_usize(cx.tcx()))\n+            cx.const_usize(len.eval_usize(cx.tcx(), ty::ParamEnv::reveal_all()))\n         }\n         (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n             // For now, upcasts are limited to changes in marker"}, {"sha": "ea39913d4b91ba6c6518485f8aaf186f72f2ce47", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -89,7 +89,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n         ty::Array(inner_type, len) => {\n             output.push('[');\n             push_debuginfo_type_name(tcx, inner_type, true, output, visited);\n-            output.push_str(&format!(\"; {}\", len.unwrap_usize(tcx)));\n+            output.push_str(&format!(\"; {}\", len.eval_usize(tcx, ty::ParamEnv::reveal_all())));\n             output.push(']');\n         },\n         ty::Slice(inner_type) => {"}, {"sha": "216e5a4645a462e01579877ebfd53c0f64ae32d6", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             .map(|c| {\n                 let field_ty = c.ty.builtin_index().unwrap();\n                 let fields = match c.ty.sty {\n-                    ty::Array(_, n) => n.unwrap_usize(bx.tcx()),\n+                    ty::Array(_, n) => n.eval_usize(bx.tcx(), ty::ParamEnv::reveal_all()),\n                     _ => bug!(\"invalid simd shuffle type: {}\", c.ty),\n                 };\n                 let values: Vec<_> = (0..fields).map(|field| {"}, {"sha": "21cedb7a9b39487261b39007bf0278065c453cf2", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -521,7 +521,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         } = *place {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::Array(_, n) = op.layout.ty.sty {\n-                    let n = n.unwrap_usize(bx.cx().tcx());\n+                    let n = n.eval_usize(bx.cx().tcx(), ty::ParamEnv::reveal_all());\n                     return bx.cx().const_usize(n);\n                 }\n             }"}, {"sha": "47601da8b7b23816643be91f9721d67a79d50435", "filename": "src/librustc_codegen_utils/symbol_names/v0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -512,7 +512,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         }\n         self = ct.ty.print(self)?;\n \n-        if let Some(bits) = ct.assert_bits(self.tcx, ty::ParamEnv::empty().and(ct.ty)) {\n+        if let Some(bits) = ct.try_eval_bits(self.tcx, ty::ParamEnv::reveal_all(), ct.ty) {\n             let _ = write!(self.out, \"{:x}_\", bits);\n         } else {\n             // NOTE(eddyb) despite having the path, we need to"}, {"sha": "23b5889202874883b044dde9f037d9f78885be0c", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -208,7 +208,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                     }\n                     has_emitted\n                 }\n-                ty::Array(ty, len) => match len.assert_usize(cx.tcx) {\n+                ty::Array(ty, len) => match len.try_eval_usize(cx.tcx, cx.param_env) {\n                     // If the array is definitely non-empty, we can do `#[must_use]` checking.\n                     Some(n) if n != 0 => {\n                         let descr_pre = &format!("}, {"sha": "340ca5747d84394489be9141ba688df729f0c88c", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -206,7 +206,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        Borrows::new(tcx, body, regioncx.clone(), &borrow_set),\n+        Borrows::new(tcx, body, param_env, regioncx.clone(), &borrow_set),\n         |rs, i| DebugFormatted::new(&rs.location(i)),\n     ));\n     let flow_uninits = FlowAtLocation::new(do_dataflow(\n@@ -242,6 +242,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         infcx,\n         body,\n         mir_def_id: def_id,\n+        param_env,\n         move_data: &mdpe.move_data,\n         location_table,\n         movable_generator,\n@@ -424,6 +425,7 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     crate infcx: &'cx InferCtxt<'cx, 'tcx>,\n     body: &'cx Body<'tcx>,\n     mir_def_id: DefId,\n+    param_env: ty::ParamEnv<'tcx>,\n     move_data: &'cx MoveData<'tcx>,\n \n     /// Map from MIR `Location` to `LocationIndex`; created\n@@ -1004,11 +1006,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let mut error_reported = false;\n         let tcx = self.infcx.tcx;\n         let body = self.body;\n+        let param_env = self.param_env;\n         let location_table = self.location_table.start_index(location);\n         let borrow_set = self.borrow_set.clone();\n         each_borrow_involving_path(\n             self,\n             tcx,\n+            param_env,\n             body,\n             location,\n             (sd, place_span.0),\n@@ -1480,6 +1484,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         if places_conflict::borrow_conflicts_with_place(\n             self.infcx.tcx,\n+            self.param_env,\n             self.body,\n             place,\n             borrow.kind,"}, {"sha": "5c230913a0da3a443db3b3b91ccab52b2cf5b7e5", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -18,6 +18,7 @@ use rustc::ty::subst::SubstsRef;\n \n pub(super) fn generate_constraints<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     liveness_constraints: &mut LivenessValues<RegionVid>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n@@ -31,6 +32,7 @@ pub(super) fn generate_constraints<'cx, 'tcx>(\n         location_table,\n         all_facts,\n         body,\n+        param_env,\n     };\n \n     for (bb, data) in body.basic_blocks().iter_enumerated() {\n@@ -41,6 +43,7 @@ pub(super) fn generate_constraints<'cx, 'tcx>(\n /// 'cg = the duration of the constraint generation process itself.\n struct ConstraintGeneration<'cg, 'cx, 'tcx> {\n     infcx: &'cg InferCtxt<'cx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     all_facts: &'cg mut Option<AllFacts>,\n     location_table: &'cg LocationTable,\n     liveness_constraints: &'cg mut LivenessValues<RegionVid>,\n@@ -271,6 +274,7 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n                         for &borrow_index in borrow_indices {\n                             let places_conflict = places_conflict::places_conflict(\n                                 self.infcx.tcx,\n+                                self.param_env,\n                                 self.body,\n                                 &self.borrow_set.borrows[borrow_index].borrowed_place,\n                                 place,"}, {"sha": "71106af767064683378eb16223a81fd01466ca34", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -9,7 +9,7 @@ use crate::borrow_check::{ReadKind, WriteKind};\n use crate::borrow_check::nll::facts::AllFacts;\n use crate::borrow_check::path_utils::*;\n use crate::dataflow::indexes::BorrowIndex;\n-use rustc::ty::TyCtxt;\n+use rustc::ty::{self, TyCtxt};\n use rustc::mir::visit::Visitor;\n use rustc::mir::{BasicBlock, Location, Body, Place, Rvalue};\n use rustc::mir::{Statement, StatementKind};\n@@ -19,6 +19,7 @@ use rustc_data_structures::graph::dominators::Dominators;\n \n pub(super) fn generate_invalidates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n     body: &Body<'tcx>,\n@@ -34,6 +35,7 @@ pub(super) fn generate_invalidates<'tcx>(\n         let mut ig = InvalidationGenerator {\n             all_facts,\n             borrow_set,\n+            param_env,\n             tcx,\n             location_table,\n             body,\n@@ -45,6 +47,7 @@ pub(super) fn generate_invalidates<'tcx>(\n \n struct InvalidationGenerator<'cx, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     all_facts: &'cx mut AllFacts,\n     location_table: &'cx LocationTable,\n     body: &'cx Body<'tcx>,\n@@ -401,11 +404,13 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n         );\n         let tcx = self.tcx;\n         let body = self.body;\n+        let param_env = self.param_env;\n         let borrow_set = self.borrow_set.clone();\n         let indices = self.borrow_set.borrows.indices();\n         each_borrow_involving_path(\n             self,\n             tcx,\n+            param_env,\n             body,\n             location,\n             (sd, place),"}, {"sha": "d65cdde303ca0a1ce278ee0cabcd0400b2e44210", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -138,6 +138,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n     constraint_generation::generate_constraints(\n         infcx,\n+        param_env,\n         &mut liveness_constraints,\n         &mut all_facts,\n         location_table,\n@@ -162,6 +163,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     // Generate various additional constraints.\n     invalidation::generate_invalidates(\n         infcx.tcx,\n+        param_env,\n         &mut all_facts,\n         location_table,\n         &body,"}, {"sha": "70d6c15d8e2a792c9f2de420375872702f43f261", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -669,7 +669,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             ProjectionElem::Subslice { from, to } => PlaceTy::from_ty(\n                 match base_ty.sty {\n                     ty::Array(inner, size) => {\n-                        let size = size.unwrap_usize(tcx);\n+                        let size = size.eval_usize(tcx, self.cx.param_env);\n                         let min_size = (from as u64) + (to as u64);\n                         if let Some(rest_size) = size.checked_sub(min_size) {\n                             tcx.mk_array(inner, rest_size)\n@@ -1214,10 +1214,15 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let tcx = self.infcx.tcx;\n \n         for proj in &user_ty.projs {\n-            let projected_ty = curr_projected_ty.projection_ty_core(tcx, proj, |this, field, &()| {\n-                let ty = this.field_ty(tcx, field);\n-                self.normalize(ty, locations)\n-            });\n+            let projected_ty = curr_projected_ty.projection_ty_core(\n+                tcx,\n+                self.param_env,\n+                proj,\n+                |this, field, &()| {\n+                    let ty = this.field_ty(tcx, field);\n+                    self.normalize(ty, locations)\n+                },\n+            );\n             curr_projected_ty = projected_ty;\n         }\n         debug!(\"user_ty base: {:?} freshened: {:?} projs: {:?} yields: {:?}\","}, {"sha": "43a012e1494f88e1df0a16c27cf7a4573f49510a", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -4,7 +4,7 @@ use crate::borrow_check::AccessDepth;\n use crate::dataflow::indexes::BorrowIndex;\n use rustc::mir::{BasicBlock, Location, Body, Place, PlaceBase};\n use rustc::mir::{ProjectionElem, BorrowKind};\n-use rustc::ty::TyCtxt;\n+use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::graph::dominators::Dominators;\n \n /// Returns `true` if the borrow represented by `kind` is\n@@ -25,6 +25,7 @@ pub(super) enum Control {\n pub(super) fn each_borrow_involving_path<'tcx, F, I, S>(\n     s: &mut S,\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n     _location: Location,\n     access_place: (AccessDepth, &Place<'tcx>),\n@@ -47,6 +48,7 @@ pub(super) fn each_borrow_involving_path<'tcx, F, I, S>(\n \n         if places_conflict::borrow_conflicts_with_place(\n             tcx,\n+            param_env,\n             body,\n             &borrowed.borrowed_place,\n             borrowed.kind,"}, {"sha": "4dd2794f11301bb977fd1d00fefdb7a341490c6c", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -26,13 +26,15 @@ crate enum PlaceConflictBias {\n /// dataflow).\n crate fn places_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     access_place: &Place<'tcx>,\n     bias: PlaceConflictBias,\n ) -> bool {\n     borrow_conflicts_with_place(\n         tcx,\n+        param_env,\n         body,\n         borrow_place,\n         BorrowKind::Mut { allow_two_phase_borrow: true },\n@@ -48,6 +50,7 @@ crate fn places_conflict<'tcx>(\n /// order to make the conservative choice and preserve soundness.\n pub(super) fn borrow_conflicts_with_place<'tcx>(\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     borrow_kind: BorrowKind,\n@@ -78,6 +81,7 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n         access_place.iterate(|access_base, access_projections| {\n             place_components_conflict(\n                 tcx,\n+                param_env,\n                 body,\n                 (borrow_base, borrow_projections),\n                 borrow_kind,\n@@ -91,6 +95,7 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n \n fn place_components_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n     borrow_projections: (&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>),\n     borrow_kind: BorrowKind,\n@@ -143,7 +148,7 @@ fn place_components_conflict<'tcx>(\n     let borrow_base = borrow_projections.0;\n     let access_base = access_projections.0;\n \n-    match place_base_conflict(tcx, borrow_base, access_base) {\n+    match place_base_conflict(tcx, param_env, borrow_base, access_base) {\n         Overlap::Arbitrary => {\n             bug!(\"Two base can't return Arbitrary\");\n         }\n@@ -306,6 +311,7 @@ fn place_components_conflict<'tcx>(\n // between `elem1` and `elem2`.\n fn place_base_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     elem1: &PlaceBase<'tcx>,\n     elem2: &PlaceBase<'tcx>,\n ) -> Overlap {\n@@ -339,7 +345,7 @@ fn place_base_conflict<'tcx>(\n                 (StaticKind::Promoted(promoted_1), StaticKind::Promoted(promoted_2)) => {\n                     if promoted_1 == promoted_2 {\n                         if let ty::Array(_, len) = s1.ty.sty {\n-                            if let Some(0) = len.assert_usize(tcx) {\n+                            if let Some(0) = len.try_eval_usize(tcx, param_env) {\n                                 // Ignore conflicts with promoted [T; 0].\n                                 debug!(\"place_element_conflict: IGNORE-LEN-0-PROMOTED\");\n                                 return Overlap::Disjoint;"}, {"sha": "1c93abd40ded25d70fb9234219bbbca520efa31e", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -109,10 +109,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         match *match_pair.pattern.kind {\n             PatternKind::Constant { value } => {\n-                let switch_ty = ty::ParamEnv::empty().and(switch_ty);\n                 indices.entry(value)\n                        .or_insert_with(|| {\n-                           options.push(value.unwrap_bits(self.hir.tcx(), switch_ty));\n+                           options.push(value.eval_bits(\n+                               self.hir.tcx(), self.hir.param_env, switch_ty,\n+                           ));\n                            options.len() - 1\n                        });\n                 true\n@@ -653,11 +654,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     use std::cmp::Ordering::*;\n                     use rustc::hir::RangeEnd::*;\n \n-                    let param_env = ty::ParamEnv::empty().and(test.ty);\n                     let tcx = self.hir.tcx();\n \n-                    let lo = compare_const_vals(tcx, test.lo, pat.hi, param_env)?;\n-                    let hi = compare_const_vals(tcx, test.hi, pat.lo, param_env)?;\n+                    let lo = compare_const_vals(tcx, test.lo, pat.hi, self.hir.param_env, test.ty)?;\n+                    let hi = compare_const_vals(tcx, test.hi, pat.lo, self.hir.param_env, test.ty)?;\n \n                     match (test.end, pat.end, lo, hi) {\n                         // pat < test\n@@ -772,11 +772,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) -> Option<bool> {\n         use std::cmp::Ordering::*;\n \n-        let param_env = ty::ParamEnv::empty().and(range.ty);\n         let tcx = self.hir.tcx();\n \n-        let a = compare_const_vals(tcx, range.lo, value, param_env)?;\n-        let b = compare_const_vals(tcx, value, range.hi, param_env)?;\n+        let a = compare_const_vals(tcx, range.lo, value, self.hir.param_env, range.ty)?;\n+        let b = compare_const_vals(tcx, value, range.hi, self.hir.param_env, range.ty)?;\n \n         match (b, range.end) {\n             (Less, _) |"}, {"sha": "018fd2e97b2645d44d7e571f3443e6a6260a35d3", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -2,7 +2,7 @@ use crate::borrow_check::borrow_set::{BorrowSet, BorrowData};\n use crate::borrow_check::place_ext::PlaceExt;\n \n use rustc::mir::{self, Location, Place, PlaceBase, Body};\n-use rustc::ty::TyCtxt;\n+use rustc::ty::{self, TyCtxt};\n use rustc::ty::RegionVid;\n \n use rustc_data_structures::bit_set::BitSet;\n@@ -32,6 +32,7 @@ newtype_index! {\n pub struct Borrows<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n \n     borrow_set: Rc<BorrowSet<'tcx>>,\n     borrows_out_of_scope_at_location: FxHashMap<Location, Vec<BorrowIndex>>,\n@@ -137,6 +138,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     crate fn new(\n         tcx: TyCtxt<'tcx>,\n         body: &'a Body<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n         borrow_set: &Rc<BorrowSet<'tcx>>,\n     ) -> Self {\n@@ -153,6 +155,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         Borrows {\n             tcx: tcx,\n             body: body,\n+            param_env,\n             borrow_set: borrow_set.clone(),\n             borrows_out_of_scope_at_location,\n             _nonlexical_regioncx: nonlexical_regioncx,\n@@ -218,6 +221,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n                 .filter(|&&i| {\n                     places_conflict::places_conflict(\n                         self.tcx,\n+                        self.param_env,\n                         self.body,\n                         &self.borrow_set.borrows[i].borrowed_place,\n                         place,"}, {"sha": "1c6a743155ee48ef5e62f1d9f4814645e92a3a91", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -556,7 +556,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             };\n             let span = cx.tcx.def_span(def_id);\n             let count = match cx.tcx.at(span).const_eval(cx.param_env.and(global_id)) {\n-                Ok(cv) => cv.unwrap_usize(cx.tcx),\n+                Ok(cv) => cv.eval_usize(cx.tcx, cx.param_env),\n                 Err(ErrorHandled::Reported) => 0,\n                 Err(ErrorHandled::TooGeneric) => {\n                     cx.tcx.sess.span_err(span, \"array lengths can't depend on generic parameters\");"}, {"sha": "8a3d904e77579bdada62fcb53ffc545b5e9a1abe", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 59, "deletions": 38, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -228,7 +228,7 @@ impl LiteralExpander<'tcx> {\n                 ConstValue::Slice {\n                     data: self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id),\n                     start: p.offset.bytes().try_into().unwrap(),\n-                    end: n.unwrap_usize(self.tcx).try_into().unwrap(),\n+                    end: n.eval_usize(self.tcx, ty::ParamEnv::empty()).try_into().unwrap(),\n                 }\n             },\n             // fat pointers stay the same\n@@ -646,8 +646,8 @@ fn all_constructors<'a, 'tcx>(\n                 ConstantValue(ty::Const::from_bool(cx.tcx, b))\n             }).collect()\n         }\n-        ty::Array(ref sub_ty, len) if len.assert_usize(cx.tcx).is_some() => {\n-            let len = len.unwrap_usize(cx.tcx);\n+        ty::Array(ref sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n+            let len = len.eval_usize(cx.tcx, cx.param_env);\n             if len != 0 && cx.is_uninhabited(sub_ty) {\n                 vec![]\n             } else {\n@@ -789,7 +789,7 @@ where\n                 match (value.val, &value.ty.sty) {\n                     (_, ty::Array(_, n)) => max_fixed_len = cmp::max(\n                         max_fixed_len,\n-                        n.unwrap_usize(cx.tcx),\n+                        n.eval_usize(cx.tcx, cx.param_env),\n                     ),\n                     (ConstValue::Slice{ start, end, .. }, ty::Slice(_)) => max_fixed_len = cmp::max(\n                         max_fixed_len,\n@@ -830,7 +830,11 @@ struct IntRange<'tcx> {\n }\n \n impl<'tcx> IntRange<'tcx> {\n-    fn from_ctor(tcx: TyCtxt<'tcx>, ctor: &Constructor<'tcx>) -> Option<IntRange<'tcx>> {\n+    fn from_ctor(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ctor: &Constructor<'tcx>,\n+    ) -> Option<IntRange<'tcx>> {\n         // Floating-point ranges are permitted and we don't want\n         // to consider them when constructing integer ranges.\n         fn is_integral(ty: Ty<'_>) -> bool {\n@@ -856,7 +860,7 @@ impl<'tcx> IntRange<'tcx> {\n             }\n             ConstantValue(val) if is_integral(val.ty) => {\n                 let ty = val.ty;\n-                if let Some(val) = val.assert_bits(tcx, ty::ParamEnv::empty().and(ty)) {\n+                if let Some(val) = val.try_eval_bits(tcx, param_env, ty) {\n                     let bias = IntRange::signed_bias(tcx, ty);\n                     let val = val ^ bias;\n                     Some(IntRange { range: val..=val, ty })\n@@ -868,13 +872,17 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n-    fn from_pat(tcx: TyCtxt<'tcx>, mut pat: &Pattern<'tcx>) -> Option<IntRange<'tcx>> {\n+    fn from_pat(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        mut pat: &Pattern<'tcx>,\n+    ) -> Option<IntRange<'tcx>> {\n         let range = loop {\n             match pat.kind {\n                 box PatternKind::Constant { value } => break ConstantValue(value),\n                 box PatternKind::Range(PatternRange { lo, hi, ty, end }) => break ConstantRange(\n-                    lo.to_bits(tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n-                    hi.to_bits(tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n+                    lo.eval_bits(tcx, param_env, ty),\n+                    hi.eval_bits(tcx, param_env, ty),\n                     ty,\n                     end,\n                 ),\n@@ -884,7 +892,7 @@ impl<'tcx> IntRange<'tcx> {\n                 _ => return None,\n             }\n         };\n-        Self::from_ctor(tcx, &range)\n+        Self::from_ctor(tcx, param_env, &range)\n     }\n \n     // The return value of `signed_bias` should be XORed with an endpoint to encode/decode it.\n@@ -919,10 +927,11 @@ impl<'tcx> IntRange<'tcx> {\n     fn subtract_from(\n         self,\n         tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         ranges: Vec<Constructor<'tcx>>,\n     ) -> Vec<Constructor<'tcx>> {\n         let ranges = ranges.into_iter().filter_map(|r| {\n-            IntRange::from_ctor(tcx, &r).map(|i| i.range)\n+            IntRange::from_ctor(tcx, param_env, &r).map(|i| i.range)\n         });\n         let mut remaining_ranges = vec![];\n         let ty = self.ty;\n@@ -989,6 +998,7 @@ enum MissingCtors<'tcx> {\n fn compute_missing_ctors<'tcx>(\n     info: MissingCtorsInfo,\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     all_ctors: &Vec<Constructor<'tcx>>,\n     used_ctors: &Vec<Constructor<'tcx>>,\n ) -> MissingCtors<'tcx> {\n@@ -1001,10 +1011,10 @@ fn compute_missing_ctors<'tcx>(\n                 // If a constructor appears in a `match` arm, we can\n                 // eliminate it straight away.\n                 refined_ctors = vec![]\n-            } else if let Some(interval) = IntRange::from_ctor(tcx, used_ctor) {\n+            } else if let Some(interval) = IntRange::from_ctor(tcx, param_env, used_ctor) {\n                 // Refine the required constructors for the type by subtracting\n                 // the range defined by the current constructor pattern.\n-                refined_ctors = interval.subtract_from(tcx, refined_ctors);\n+                refined_ctors = interval.subtract_from(tcx, param_env, refined_ctors);\n             }\n \n             // If the constructor patterns that have been considered so far\n@@ -1119,7 +1129,9 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         if is_declared_nonexhaustive {\n             Useful\n         } else {\n-            split_grouped_constructors(cx.tcx, constructors, matrix, pcx.ty).into_iter().map(|c|\n+            split_grouped_constructors(\n+                cx.tcx, cx.param_env, constructors, matrix, pcx.ty,\n+            ).into_iter().map(|c|\n                 is_useful_specialized(cx, matrix, v, c, pcx.ty, witness)\n             ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n         }\n@@ -1158,8 +1170,9 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         // non-wildcard patterns in the current column. We always determine if\n         // the set is empty, but we only fully construct them on-demand,\n         // because they're rarely used and can be big.\n-        let cheap_missing_ctors =\n-            compute_missing_ctors(MissingCtorsInfo::Emptiness, cx.tcx, &all_ctors, &used_ctors);\n+        let cheap_missing_ctors = compute_missing_ctors(\n+            MissingCtorsInfo::Emptiness, cx.tcx, cx.param_env, &all_ctors, &used_ctors,\n+        );\n \n         let is_privately_empty = all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n         let is_declared_nonexhaustive = cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n@@ -1172,9 +1185,10 @@ pub fn is_useful<'p, 'a, 'tcx>(\n             (pcx.ty.is_ptr_sized_integral() && !cx.tcx.features().precise_pointer_size_matching);\n \n         if cheap_missing_ctors == MissingCtors::Empty && !is_non_exhaustive {\n-            split_grouped_constructors(cx.tcx, all_ctors, matrix, pcx.ty).into_iter().map(|c| {\n-                is_useful_specialized(cx, matrix, v, c, pcx.ty, witness)\n-            }).find(|result| result.is_useful()).unwrap_or(NotUseful)\n+            split_grouped_constructors(cx.tcx, cx.param_env, all_ctors, matrix, pcx.ty)\n+                .into_iter().map(|c| is_useful_specialized(cx, matrix, v, c, pcx.ty, witness))\n+                .find(|result| result.is_useful())\n+                .unwrap_or(NotUseful)\n         } else {\n             let matrix = rows.iter().filter_map(|r| {\n                 if r[0].is_wildcard() {\n@@ -1242,9 +1256,9 @@ pub fn is_useful<'p, 'a, 'tcx>(\n                             witness\n                         }).collect()\n                     } else {\n-                        let expensive_missing_ctors =\n-                            compute_missing_ctors(MissingCtorsInfo::Ctors, cx.tcx, &all_ctors,\n-                                                  &used_ctors);\n+                        let expensive_missing_ctors = compute_missing_ctors(\n+                            MissingCtorsInfo::Ctors, cx.tcx, cx.param_env, &all_ctors, &used_ctors,\n+                        );\n                         if let MissingCtors::Ctors(missing_ctors) = expensive_missing_ctors {\n                             pats.into_iter().flat_map(|witness| {\n                                 missing_ctors.iter().map(move |ctor| {\n@@ -1327,14 +1341,14 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n         PatternKind::Constant { value } => Some(vec![ConstantValue(value)]),\n         PatternKind::Range(PatternRange { lo, hi, ty, end }) =>\n             Some(vec![ConstantRange(\n-                lo.to_bits(cx.tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n-                hi.to_bits(cx.tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n+                lo.eval_bits(cx.tcx, cx.param_env, ty),\n+                hi.eval_bits(cx.tcx, cx.param_env, ty),\n                 ty,\n                 end,\n             )]),\n         PatternKind::Array { .. } => match pcx.ty.sty {\n             ty::Array(_, length) => Some(vec![\n-                Slice(length.unwrap_usize(cx.tcx))\n+                Slice(length.eval_usize(cx.tcx, cx.param_env))\n             ]),\n             _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty)\n         },\n@@ -1402,7 +1416,8 @@ fn constructor_sub_pattern_tys<'a, 'tcx>(\n                         match ty.sty {\n                             // If the field type returned is an array of an unknown\n                             // size return an TyErr.\n-                            ty::Array(_, len) if len.assert_usize(cx.tcx).is_none() =>\n+                            ty::Array(_, len)\n+                                if len.try_eval_usize(cx.tcx, cx.param_env).is_none() =>\n                                 cx.tcx.types.err,\n                             _ => ty,\n                         }\n@@ -1432,11 +1447,12 @@ fn slice_pat_covered_by_const<'tcx>(\n     prefix: &[Pattern<'tcx>],\n     slice: &Option<Pattern<'tcx>>,\n     suffix: &[Pattern<'tcx>],\n+    param_env: ty::ParamEnv<'tcx>,\n ) -> Result<bool, ErrorReported> {\n     let data: &[u8] = match (const_val.val, &const_val.ty.sty) {\n         (ConstValue::ByRef { offset, alloc, .. }, ty::Array(t, n)) => {\n             assert_eq!(*t, tcx.types.u8);\n-            let n = n.assert_usize(tcx).unwrap();\n+            let n = n.eval_usize(tcx, param_env);\n             let ptr = Pointer::new(AllocId(0), offset);\n             alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n         },\n@@ -1464,7 +1480,7 @@ fn slice_pat_covered_by_const<'tcx>(\n     {\n         match pat.kind {\n             box PatternKind::Constant { value } => {\n-                let b = value.unwrap_bits(tcx, ty::ParamEnv::empty().and(pat.ty));\n+                let b = value.eval_bits(tcx, param_env, pat.ty);\n                 assert_eq!(b as u8 as u128, b);\n                 if b as u8 != *ch {\n                     return Ok(false);\n@@ -1526,6 +1542,7 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx>, ctor: &Constructor<'tcx>)\n /// merging operation depicted above.)\n fn split_grouped_constructors<'p, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     ctors: Vec<Constructor<'tcx>>,\n     &Matrix(ref m): &Matrix<'p, 'tcx>,\n     ty: Ty<'tcx>,\n@@ -1540,7 +1557,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n                 // We only care about finding all the subranges within the range of the constructor\n                 // range. Anything else is irrelevant, because it is guaranteed to result in\n                 // `NotUseful`, which is the default case anyway, and can be ignored.\n-                let ctor_range = IntRange::from_ctor(tcx, &ctor).unwrap();\n+                let ctor_range = IntRange::from_ctor(tcx, param_env, &ctor).unwrap();\n \n                 /// Represents a border between 2 integers. Because the intervals spanning borders\n                 /// must be able to cover every integer, we need to be able to represent\n@@ -1565,7 +1582,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n                 // `borders` is the set of borders between equivalence classes: each equivalence\n                 // class lies between 2 borders.\n                 let row_borders = m.iter()\n-                    .flat_map(|row| IntRange::from_pat(tcx, row[0]))\n+                    .flat_map(|row| IntRange::from_pat(tcx, param_env, row[0]))\n                     .flat_map(|range| ctor_range.intersection(&range))\n                     .flat_map(|range| range_borders(range));\n                 let ctor_borders = range_borders(ctor_range.clone());\n@@ -1604,11 +1621,12 @@ fn split_grouped_constructors<'p, 'tcx>(\n /// Checks whether there exists any shared value in either `ctor` or `pat` by intersecting them.\n fn constructor_intersects_pattern<'p, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     ctor: &Constructor<'tcx>,\n     pat: &'p Pattern<'tcx>,\n ) -> Option<SmallVec<[&'p Pattern<'tcx>; 2]>> {\n     if should_treat_range_exhaustively(tcx, ctor) {\n-        match (IntRange::from_ctor(tcx, ctor), IntRange::from_pat(tcx, pat)) {\n+        match (IntRange::from_ctor(tcx, param_env, ctor), IntRange::from_pat(tcx, param_env, pat)) {\n             (Some(ctor), Some(pat)) => {\n                 ctor.intersection(&pat).map(|_| {\n                     let (pat_lo, pat_hi) = pat.range.into_inner();\n@@ -1623,7 +1641,7 @@ fn constructor_intersects_pattern<'p, 'tcx>(\n         // Fallback for non-ranges and ranges that involve floating-point numbers, which are not\n         // conveniently handled by `IntRange`. For these cases, the constructor may not be a range\n         // so intersection actually devolves into being covered by the pattern.\n-        match constructor_covered_by_range(tcx, ctor, pat) {\n+        match constructor_covered_by_range(tcx, param_env, ctor, pat) {\n             Ok(true) => Some(smallvec![]),\n             Ok(false) | Err(ErrorReported) => None,\n         }\n@@ -1632,6 +1650,7 @@ fn constructor_intersects_pattern<'p, 'tcx>(\n \n fn constructor_covered_by_range<'tcx>(\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     ctor: &Constructor<'tcx>,\n     pat: &Pattern<'tcx>,\n ) -> Result<bool, ErrorReported> {\n@@ -1641,9 +1660,9 @@ fn constructor_covered_by_range<'tcx>(\n         _ => bug!(\"`constructor_covered_by_range` called with {:?}\", pat),\n     };\n     trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, from, to, ty);\n-    let cmp_from = |c_from| compare_const_vals(tcx, c_from, from, ty::ParamEnv::empty().and(ty))\n+    let cmp_from = |c_from| compare_const_vals(tcx, c_from, from, param_env, ty)\n         .map(|res| res != Ordering::Less);\n-    let cmp_to = |c_to| compare_const_vals(tcx, c_to, to, ty::ParamEnv::empty().and(ty));\n+    let cmp_to = |c_to| compare_const_vals(tcx, c_to, to, param_env, ty);\n     macro_rules! some_or_ok {\n         ($e:expr) => {\n             match $e {\n@@ -1760,7 +1779,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                                 ConstValue::ByRef { offset, alloc, .. } => (\n                                     alloc,\n                                     offset,\n-                                    n.unwrap_usize(cx.tcx),\n+                                    n.eval_usize(cx.tcx, cx.param_env),\n                                     t,\n                                 ),\n                                 _ => span_bug!(\n@@ -1821,7 +1840,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                     // If the constructor is a:\n                     //      Single value: add a row if the constructor equals the pattern.\n                     //      Range: add a row if the constructor contains the pattern.\n-                    constructor_intersects_pattern(cx.tcx, constructor, pat)\n+                    constructor_intersects_pattern(cx.tcx, cx.param_env, constructor, pat)\n                 }\n             }\n         }\n@@ -1830,7 +1849,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n             // If the constructor is a:\n             //      Single value: add a row if the pattern contains the constructor.\n             //      Range: add a row if the constructor intersects the pattern.\n-            constructor_intersects_pattern(cx.tcx, constructor, pat)\n+            constructor_intersects_pattern(cx.tcx, cx.param_env, constructor, pat)\n         }\n \n         PatternKind::Array { ref prefix, ref slice, ref suffix } |\n@@ -1854,7 +1873,9 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                     }\n                 }\n                 ConstantValue(cv) => {\n-                    match slice_pat_covered_by_const(cx.tcx, pat.span, cv, prefix, slice, suffix) {\n+                    match slice_pat_covered_by_const(\n+                        cx.tcx, pat.span, cv, prefix, slice, suffix, cx.param_env,\n+                    ) {\n                         Ok(true) => Some(smallvec![]),\n                         Ok(false) => None,\n                         Err(ErrorReported) => None"}, {"sha": "5ecfb84b632360d37eb79c3f57333c28b3df2d45", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -446,7 +446,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                             self.tcx,\n                             lo,\n                             hi,\n-                            self.param_env.and(ty),\n+                            self.param_env,\n+                            ty,\n                         );\n                         match (end, cmp) {\n                             (RangeEnd::Excluded, Some(Ordering::Less)) =>\n@@ -728,7 +729,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             ty::Array(_, len) => {\n                 // fixed-length array\n-                let len = len.unwrap_usize(self.tcx);\n+                let len = len.eval_usize(self.tcx, self.param_env);\n                 assert!(len >= prefix.len() as u64 + suffix.len() as u64);\n                 PatternKind::Array { prefix: prefix, slice: slice, suffix: suffix }\n             }\n@@ -1123,7 +1124,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n             ty::Array(_, n) => {\n                 PatternKind::Array {\n-                    prefix: (0..n.unwrap_usize(self.tcx))\n+                    prefix: (0..n.eval_usize(self.tcx, self.param_env))\n                         .map(|i| adt_subpattern(i as usize, None))\n                         .collect(),\n                     slice: None,\n@@ -1206,7 +1207,8 @@ fn search_for_adt_without_structural_match<'tcx>(tcx: TyCtxt<'tcx>,\n                     // (But still tell caller to continue search.)\n                     return false;\n                 }\n-                ty::Array(_, n) if n.assert_usize(self.tcx) == Some(0) => {\n+                ty::Array(_, n) if n.try_eval_usize(self.tcx, ty::ParamEnv::reveal_all()) == Some(0)\n+                => {\n                     // rust-lang/rust#62336: ignore type of contents\n                     // for empty array.\n                     return false;\n@@ -1451,7 +1453,8 @@ pub fn compare_const_vals<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     a: &'tcx ty::Const<'tcx>,\n     b: &'tcx ty::Const<'tcx>,\n-    ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n ) -> Option<Ordering> {\n     trace!(\"compare_const_vals: {:?}, {:?}\", a, b);\n \n@@ -1466,15 +1469,16 @@ pub fn compare_const_vals<'tcx>(\n     let fallback = || from_bool(a == b);\n \n     // Use the fallback if any type differs\n-    if a.ty != b.ty || a.ty != ty.value {\n+    if a.ty != b.ty || a.ty != ty {\n         return fallback();\n     }\n \n-    // FIXME: This should use assert_bits(ty) instead of use_bits\n-    // but triggers possibly bugs due to mismatching of arrays and slices\n-    if let (Some(a), Some(b)) = (a.to_bits(tcx, ty), b.to_bits(tcx, ty)) {\n+    let a_bits = a.try_eval_bits(tcx, param_env, ty);\n+    let b_bits = b.try_eval_bits(tcx, param_env, ty);\n+\n+    if let (Some(a), Some(b)) = (a_bits, b_bits) {\n         use ::rustc_apfloat::Float;\n-        return match ty.value.sty {\n+        return match ty.sty {\n             ty::Float(ast::FloatTy::F32) => {\n                 let l = ::rustc_apfloat::ieee::Single::from_bits(a);\n                 let r = ::rustc_apfloat::ieee::Single::from_bits(b);\n@@ -1497,7 +1501,7 @@ pub fn compare_const_vals<'tcx>(\n         }\n     }\n \n-    if let ty::Str = ty.value.sty {\n+    if let ty::Str = ty.sty {\n         match (a.val, b.val) {\n             (\n                 ConstValue::Slice { data: alloc_a, start: offset_a, end: end_a },"}, {"sha": "26cfbfe53a35cdf856320174e6dd7012bb403de9", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -253,7 +253,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // u64 cast is from usize to u64, which is always good\n                 let val = Immediate::new_slice(\n                     ptr,\n-                    length.unwrap_usize(self.tcx.tcx),\n+                    length.eval_usize(self.tcx.tcx, self.param_env),\n                     self,\n                 );\n                 self.write_immediate(val, dest)"}, {"sha": "1074ab941a761acbfc5eb23b388ebd2570b78c45", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -176,7 +176,8 @@ for\n                     (InternMode::ConstBase, hir::Mutability::MutMutable) |\n                     (InternMode::Const, hir::Mutability::MutMutable) => {\n                         match referenced_ty.sty {\n-                            ty::Array(_, n) if n.unwrap_usize(self.ecx.tcx.tcx) == 0 => {}\n+                            ty::Array(_, n)\n+                                if n.eval_usize(self.ecx.tcx.tcx, self.param_env) == 0 => {}\n                             ty::Slice(_)\n                                 if value.to_meta().unwrap().unwrap().to_usize(self.ecx)? == 0 => {}\n                             _ => bug!(\"const qualif failed to prevent mutable references\"),"}, {"sha": "42945c79ddf0edc73cce20b6c6d05d545e407b98", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -304,16 +304,18 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> Body<'tcx> {\n     debug!(\"build_clone_shim(def_id={:?})\", def_id);\n \n+    let param_env = tcx.param_env(def_id);\n+\n     let mut builder = CloneShimBuilder::new(tcx, def_id, self_ty);\n-    let is_copy = self_ty.is_copy_modulo_regions(tcx, tcx.param_env(def_id), builder.span);\n+    let is_copy = self_ty.is_copy_modulo_regions(tcx, param_env, builder.span);\n \n     let dest = Place::RETURN_PLACE;\n     let src = Place::from(Local::new(1+0)).deref();\n \n     match self_ty.sty {\n         _ if is_copy => builder.copy_shim(),\n         ty::Array(ty, len) => {\n-            let len = len.unwrap_usize(tcx);\n+            let len = len.eval_usize(tcx, param_env);\n             builder.array_shim(dest, src, ty, len)\n         }\n         ty::Closure(def_id, substs) => {"}, {"sha": "163d10b9bd5f399d950b2a9e110f127beeef112d", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -367,7 +367,7 @@ impl Qualif for HasMutInterior {\n                     } else if let ty::Array(_, len) = ty.sty {\n                         // FIXME(eddyb) the `cx.mode == Mode::NonConstFn` condition\n                         // seems unnecessary, given that this is merely a ZST.\n-                        match len.assert_usize(cx.tcx) {\n+                        match len.try_eval_usize(cx.tcx, cx.param_env) {\n                             Some(0) if cx.mode == Mode::NonConstFn => {},\n                             _ => return true,\n                         }"}, {"sha": "9ffa3db4c2eb073df0dbe44c0b50e632f37f26a1", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -1,6 +1,6 @@\n //! A pass that simplifies branches when their condition is known.\n \n-use rustc::ty::{TyCtxt, ParamEnv};\n+use rustc::ty::TyCtxt;\n use rustc::mir::*;\n use crate::transform::{MirPass, MirSource};\n \n@@ -19,15 +19,15 @@ impl MirPass for SimplifyBranches {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        let param_env = tcx.param_env(src.def_id());\n         for block in body.basic_blocks_mut() {\n             let terminator = block.terminator_mut();\n             terminator.kind = match terminator.kind {\n                 TerminatorKind::SwitchInt {\n                     discr: Operand::Constant(ref c), switch_ty, ref values, ref targets, ..\n                 } => {\n-                    let switch_ty = ParamEnv::empty().and(switch_ty);\n-                    let constant = c.literal.assert_bits(tcx, switch_ty);\n+                    let constant = c.literal.try_eval_bits(tcx, param_env, switch_ty);\n                     if let Some(constant) = constant {\n                         let (otherwise, targets) = targets.split_last().unwrap();\n                         let mut ret = TerminatorKind::Goto { target: *otherwise };\n@@ -44,7 +44,7 @@ impl MirPass for SimplifyBranches {\n                 },\n                 TerminatorKind::Assert {\n                     target, cond: Operand::Constant(ref c), expected, ..\n-                } if (c.literal.assert_bool(tcx) == Some(true)) == expected =>\n+                } if (c.literal.try_eval_bool(tcx, param_env) == Some(true)) == expected =>\n                     TerminatorKind::Goto { target },\n                 TerminatorKind::FalseEdges { real_target, .. } => {\n                     TerminatorKind::Goto { target: real_target }"}, {"sha": "60489e7fa36688ab5718c0d6377e91f06b755724", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -37,10 +37,11 @@ use crate::util::patch::MirPatch;\n pub struct UniformArrayMoveOut;\n \n impl MirPass for UniformArrayMoveOut {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut patch = MirPatch::new(body);\n+        let param_env = tcx.param_env(src.def_id());\n         {\n-            let mut visitor = UniformArrayMoveOutVisitor{body, patch: &mut patch, tcx};\n+            let mut visitor = UniformArrayMoveOutVisitor{body, patch: &mut patch, tcx, param_env};\n             visitor.visit_body(body);\n         }\n         patch.apply(body);\n@@ -51,6 +52,7 @@ struct UniformArrayMoveOutVisitor<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n     patch: &'a mut MirPatch<'tcx>,\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n@@ -68,7 +70,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                     let place_ty =\n                         Place::ty_from(&src_place.base, &proj.base, self.body, self.tcx).ty;\n                     if let ty::Array(item_ty, const_size) = place_ty.sty {\n-                        if let Some(size) = const_size.assert_usize(self.tcx) {\n+                        if let Some(size) = const_size.try_eval_usize(self.tcx, self.param_env) {\n                             assert!(size <= u32::max_value() as u64,\n                                     \"uniform array move out doesn't supported\n                                      for array bigger then u32\");\n@@ -183,8 +185,9 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n pub struct RestoreSubsliceArrayMoveOut;\n \n impl MirPass for RestoreSubsliceArrayMoveOut {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut patch = MirPatch::new(body);\n+        let param_env = tcx.param_env(src.def_id());\n         {\n             let mut visitor = RestoreDataCollector {\n                 locals_use: IndexVec::from_elem(LocalUse::new(), &body.local_decls),\n@@ -219,7 +222,7 @@ impl MirPass for RestoreSubsliceArrayMoveOut {\n                             let src_ty =\n                                 Place::ty_from(src_place.base, src_place.projection, body, tcx).ty;\n                             if let ty::Array(_, ref size_o) = src_ty.sty {\n-                                size_o.assert_usize(tcx)\n+                                size_o.try_eval_usize(tcx, param_env)\n                             } else {\n                                 None\n                             }"}, {"sha": "d17dcaafc04f5b07d0a351da68d631b18ada1ddf", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -821,7 +821,7 @@ where\n                 self.complete_drop(Some(DropFlagMode::Deep), succ, unwind)\n             }\n             ty::Array(ety, size) => {\n-                let size = size.assert_usize(self.tcx());\n+                let size = size.try_eval_usize(self.tcx(), self.elaborator.param_env());\n                 self.open_drop_for_array(ety, size)\n             },\n             ty::Slice(ety) => self.open_drop_for_array(ety, None),"}, {"sha": "c7aa6fe105e54fcf8ff7ca2675c834d6b17a6577", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -174,6 +174,11 @@ impl TypeRelation<'tcx> for AnswerSubstitutor<'cx, 'tcx> {\n         self.infcx.tcx\n     }\n \n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        // FIXME(oli-obk): learn chalk and create param envs\n+        ty::ParamEnv::empty()\n+    }\n+\n     fn tag(&self) -> &'static str {\n         \"chalk_context::answer_substitutor\"\n     }"}, {"sha": "3a43e764dd08e4e1bc022a9eb42fb8ee5c2ad22f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -423,7 +423,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let expected_ty = self.structurally_resolved_type(pat.span, expected);\n                 let (inner_ty, slice_ty) = match expected_ty.sty {\n                     ty::Array(inner_ty, size) => {\n-                        if let Some(size) = size.assert_usize(tcx) {\n+                        if let Some(size) = size.try_eval_usize(tcx, self.param_env) {\n                             let min_len = before.len() as u64 + after.len() as u64;\n                             if slice.is_none() {\n                                 if min_len != size {"}, {"sha": "d825358beaade1e6022c2e99fc16dd08f9a4cb2d", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -1386,7 +1386,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     ty::Array(_, len) => {\n                         if let (Some(len), Ok(user_index)) = (\n-                            len.assert_usize(self.tcx),\n+                            len.try_eval_usize(self.tcx, self.param_env),\n                             field.as_str().parse::<u64>()\n                         ) {\n                             let base = self.tcx.sess.source_map()"}, {"sha": "3f9e662c6f412c900c3dab70c4507b8506848eed", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -824,6 +824,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     {\n         f(mc::MemCategorizationContext::with_infer(\n             &self.infcx,\n+            self.outlives_environment.param_env,\n             self.body_owner,\n             &self.region_scope_tree,\n             &self.tables.borrow(),"}, {"sha": "b2a34f5877b194c6d08aaeafe8b702075aff60ed", "filename": "src/test/ui/consts/self_normalization.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Ftest%2Fui%2Fconsts%2Fself_normalization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Ftest%2Fui%2Fconsts%2Fself_normalization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fself_normalization.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+fn testfn(_arr: &mut [(); 0]) {}\n+\n+trait TestTrait {\n+    fn method();\n+}\n+\n+impl TestTrait for [(); 0] {\n+    fn method() {\n+        let mut arr: Self = [(); 0];\n+        testfn(&mut arr);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4fca38cba30bf66fd52b8534c3ce496e78af5b38", "filename": "src/test/ui/consts/self_normalization2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Ftest%2Fui%2Fconsts%2Fself_normalization2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4715198b50d1cdaad44b6e250844362b77dcdd7/src%2Ftest%2Fui%2Fconsts%2Fself_normalization2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fself_normalization2.rs?ref=c4715198b50d1cdaad44b6e250844362b77dcdd7", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+\n+trait Gen<T> {\n+    fn gen(x: Self) -> T;\n+}\n+\n+struct A;\n+\n+impl Gen<[(); 0]> for A {\n+    fn gen(x: Self) -> [(); 0] {\n+        []\n+    }\n+}\n+\n+fn array() -> impl Gen<[(); 0]> {\n+    A\n+}\n+\n+fn main() {\n+    let [] = Gen::gen(array());\n+}"}]}