{"sha": "6f35ede5a475c286066d8d88cb9a519be2133d0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmMzVlZGU1YTQ3NWMyODYwNjZkOGQ4OGNiOWE1MTliZTIxMzNkMGQ=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-08-30T14:22:19Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-08-30T17:50:46Z"}, "message": "Remove the branch merging optimisations for slice patterns\n\nThey were only correct in the simplest case. Some of the optimisations\nare certainly possible but should be introduced carefully and only\nwhen the whole pattern codegen infrastructure is in a better shape.\n\nFixes #16648.", "tree": {"sha": "9733c7f8994ab75a7a2a8b9c7f200d89cd81d381", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9733c7f8994ab75a7a2a8b9c7f200d89cd81d381"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f35ede5a475c286066d8d88cb9a519be2133d0d", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f35ede5a475c286066d8d88cb9a519be2133d0d", "html_url": "https://github.com/rust-lang/rust/commit/6f35ede5a475c286066d8d88cb9a519be2133d0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f35ede5a475c286066d8d88cb9a519be2133d0d/comments", "author": null, "committer": null, "parents": [{"sha": "d398eb76ae5fdb7c08bbb7c0e3d85dc22d42c5ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/d398eb76ae5fdb7c08bbb7c0e3d85dc22d42c5ce", "html_url": "https://github.com/rust-lang/rust/commit/d398eb76ae5fdb7c08bbb7c0e3d85dc22d42c5ce"}], "stats": {"total": 698, "additions": 334, "deletions": 364}, "files": [{"sha": "c23468247108025b30e59ab38e1aae6be87fa98d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6f35ede5a475c286066d8d88cb9a519be2133d0d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f35ede5a475c286066d8d88cb9a519be2133d0d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=6f35ede5a475c286066d8d88cb9a519be2133d0d", "patch": "@@ -28,8 +28,7 @@ use syntax::codemap::{Span, Spanned, DUMMY_SP};\n use syntax::fold::{Folder, noop_fold_pat};\n use syntax::print::pprust::pat_to_string;\n use syntax::parse::token;\n-use syntax::visit;\n-use syntax::visit::{Visitor, FnKind};\n+use syntax::visit::{mod, Visitor, FnKind};\n use util::ppaux::ty_to_string;\n \n struct Matrix(Vec<Vec<Gc<Pat>>>);\n@@ -103,7 +102,9 @@ pub enum Constructor {\n     /// Ranges of literal values (2..5).\n     ConstantRange(const_val, const_val),\n     /// Array patterns of length n.\n-    Slice(uint)\n+    Slice(uint),\n+    /// Array patterns with a subslice.\n+    SliceWithSubslice(uint, uint)\n }\n \n #[deriving(Clone, PartialEq)]\n@@ -270,13 +271,6 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n     }\n }\n \n-fn raw_pat(p: Gc<Pat>) -> Gc<Pat> {\n-    match p.node {\n-        PatIdent(_, _, Some(s)) => { raw_pat(s) }\n-        _ => { p }\n-    }\n-}\n-\n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n     match is_useful(cx, matrix, [wild()], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n@@ -821,6 +815,14 @@ pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n                     pats.push_all(after.as_slice());\n                     Some(pats)\n                 },\n+                SliceWithSubslice(prefix, suffix)\n+                    if before.len() == prefix\n+                        && after.len() == suffix\n+                        && slice.is_some() => {\n+                    let mut pats = before.clone();\n+                    pats.push_all(after.as_slice());\n+                    Some(pats)\n+                }\n                 _ => None\n             }\n         }"}, {"sha": "727f5ad9385a6e4d9b0956f4a41d22a4d3fbc564", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f35ede5a475c286066d8d88cb9a519be2133d0d/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f35ede5a475c286066d8d88cb9a519be2133d0d/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=6f35ede5a475c286066d8d88cb9a519be2133d0d", "patch": "@@ -119,6 +119,13 @@ pub fn wild() -> Gc<Pat> {\n     box (GC) Pat { id: 0, node: PatWild(PatWildSingle), span: DUMMY_SP }\n }\n \n+pub fn raw_pat(p: Gc<Pat>) -> Gc<Pat> {\n+    match p.node {\n+        PatIdent(_, _, Some(s)) => { raw_pat(s) }\n+        _ => { p }\n+    }\n+}\n+\n pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> Path {\n     ty::with_path(tcx, id, |mut path| Path {\n         global: false,"}, {"sha": "e9a9a75737f8b9001d97c95af136fd571118ed2e", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 281, "deletions": 342, "changes": 623, "blob_url": "https://github.com/rust-lang/rust/blob/6f35ede5a475c286066d8d88cb9a519be2133d0d/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f35ede5a475c286066d8d88cb9a519be2133d0d/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=6f35ede5a475c286066d8d88cb9a519be2133d0d", "patch": "@@ -186,12 +186,9 @@\n  *\n  */\n \n-#![allow(non_camel_case_types)]\n-\n use back::abi;\n use driver::config::FullDebugInfo;\n use llvm::{ValueRef, BasicBlockRef};\n-use llvm;\n use middle::check_match::StaticInliner;\n use middle::check_match;\n use middle::const_eval;\n@@ -203,17 +200,15 @@ use middle::pat_util::*;\n use middle::resolve::DefMap;\n use middle::trans::adt;\n use middle::trans::base::*;\n-use middle::trans::build::{And, BitCast, Br, CondBr, GEPi, InBoundsGEP, Load};\n-use middle::trans::build::{Mul, Not, Store, Sub, Switch, add_comment};\n+use middle::trans::build::{AddCase, And, BitCast, Br, CondBr, GEPi, InBoundsGEP, Load};\n+use middle::trans::build::{Mul, Not, Store, Sub, add_comment};\n use middle::trans::build;\n use middle::trans::callee;\n-use middle::trans::cleanup;\n-use middle::trans::cleanup::CleanupMethods;\n+use middle::trans::cleanup::{mod, CleanupMethods};\n use middle::trans::common::*;\n use middle::trans::consts;\n use middle::trans::datum::*;\n-use middle::trans::expr::Dest;\n-use middle::trans::expr;\n+use middle::trans::expr::{mod, Dest};\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::trans::debuginfo;\n@@ -223,83 +218,85 @@ use util::ppaux::{Repr, vec_map_to_string};\n \n use std;\n use std::collections::HashMap;\n-use std::rc::Rc;\n use std::gc::{Gc};\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::ast::Ident;\n use syntax::codemap::Span;\n use syntax::fold::Folder;\n \n-#[deriving(PartialEq)]\n-pub enum VecLenOpt {\n-    vec_len_eq,\n-    vec_len_ge(/* length of prefix */uint)\n+struct ConstantExpr<'a>(&'a ty::ctxt, Gc<ast::Expr>);\n+\n+impl<'a> Eq for ConstantExpr<'a> {\n+    fn assert_receiver_is_total_eq(&self) {}\n+}\n+\n+impl<'a> PartialEq for ConstantExpr<'a> {\n+    fn eq(&self, other: &ConstantExpr<'a>) -> bool {\n+        let &ConstantExpr(tcx, expr) = self;\n+        let &ConstantExpr(_, other_expr) = other;\n+        match const_eval::compare_lit_exprs(tcx, &*expr, &*other_expr) {\n+            Some(val1) => val1 == 0,\n+            None => fail!(\"compare_list_exprs: type mismatch\"),\n+        }\n+    }\n }\n \n-// An option identifying a branch (either a literal, an enum variant or a\n-// range)\n-enum Opt {\n-    lit(Gc<ast::Expr>),\n-    var(ty::Disr, Rc<adt::Repr>, ast::DefId),\n-    range(Gc<ast::Expr>, Gc<ast::Expr>),\n-    vec_len(/* length */ uint, VecLenOpt, /*range of matches*/(uint, uint))\n+// An option identifying a branch (either a literal, an enum variant or a range)\n+#[deriving(Eq, PartialEq)]\n+enum Opt<'a> {\n+    ConstantValue(ConstantExpr<'a>),\n+    ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>),\n+    Variant(ty::Disr, Rc<adt::Repr>, ast::DefId),\n+    SliceLengthEqual(uint),\n+    SliceLengthGreaterOrEqual(/* prefix length */ uint, /* suffix length */ uint),\n }\n \n-fn opt_eq(tcx: &ty::ctxt, a: &Opt, b: &Opt) -> bool {\n-    match (a, b) {\n-        (&lit(a_expr), &lit(b_expr)) => {\n-            match const_eval::compare_lit_exprs(tcx, &*a_expr, &*b_expr) {\n-                Some(val1) => val1 == 0,\n-                None => fail!(\"compare_list_exprs: type mismatch\"),\n+impl<'a> Opt<'a> {\n+    fn trans(&self, mut bcx: &'a Block<'a>) -> OptResult<'a> {\n+        let _icx = push_ctxt(\"match::trans_opt\");\n+        let ccx = bcx.ccx();\n+        match *self {\n+            ConstantValue(ConstantExpr(_, lit_expr)) => {\n+                let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_expr.id);\n+                let (llval, _, _) = consts::const_expr(ccx, &*lit_expr, true);\n+                let lit_datum = immediate_rvalue(llval, lit_ty);\n+                let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n+                SingleResult(Result::new(bcx, lit_datum.val))\n             }\n-        }\n-        (&range(ref a1, ref a2), &range(ref b1, ref b2)) => {\n-            let m1 = const_eval::compare_lit_exprs(tcx, &**a1, &**b1);\n-            let m2 = const_eval::compare_lit_exprs(tcx, &**a2, &**b2);\n-            match (m1, m2) {\n-                (Some(val1), Some(val2)) => (val1 == 0 && val2 == 0),\n-                _ => fail!(\"compare_list_exprs: type mismatch\"),\n+            ConstantRange(\n+                ConstantExpr(_, ref l1),\n+                ConstantExpr(_, ref l2)) => {\n+                let (l1, _, _) = consts::const_expr(ccx, &**l1, true);\n+                let (l2, _, _) = consts::const_expr(ccx, &**l2, true);\n+                RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n+            }\n+            Variant(disr_val, ref repr, _) => {\n+                adt::trans_case(bcx, &**repr, disr_val)\n+            }\n+            SliceLengthEqual(length) => {\n+                SingleResult(Result::new(bcx, C_uint(ccx, length)))\n+            }\n+            SliceLengthGreaterOrEqual(prefix, suffix) => {\n+                LowerBound(Result::new(bcx, C_uint(ccx, prefix + suffix)))\n             }\n         }\n-        (&var(a, _, _), &var(b, _, _)) => a == b,\n-        (&vec_len(a1, a2, _), &vec_len(b1, b2, _)) =>\n-            a1 == b1 && a2 == b2,\n-        _ => false\n     }\n }\n \n-pub enum opt_result<'a> {\n-    single_result(Result<'a>),\n-    lower_bound(Result<'a>),\n-    range_result(Result<'a>, Result<'a>),\n+#[deriving(PartialEq)]\n+pub enum BranchKind {\n+    NoBranch,\n+    Single,\n+    Switch,\n+    Compare,\n+    CompareSliceLength\n }\n \n-fn trans_opt<'a>(mut bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n-    let _icx = push_ctxt(\"match::trans_opt\");\n-    let ccx = bcx.ccx();\n-    match *o {\n-        lit(lit_expr) => {\n-            let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_expr.id);\n-            let (llval, _, _) = consts::const_expr(ccx, &*lit_expr, true);\n-            let lit_datum = immediate_rvalue(llval, lit_ty);\n-            let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n-            return single_result(Result::new(bcx, lit_datum.val));\n-        }\n-        var(disr_val, ref repr, _) => {\n-            return adt::trans_case(bcx, &**repr, disr_val);\n-        }\n-        range(ref l1, ref l2) => {\n-            let (l1, _, _) = consts::const_expr(ccx, &**l1, true);\n-            let (l2, _, _) = consts::const_expr(ccx, &**l2, true);\n-            return range_result(Result::new(bcx, l1), Result::new(bcx, l2));\n-        }\n-        vec_len(n, vec_len_eq, _) => {\n-            return single_result(Result::new(bcx, C_int(ccx, n as int)));\n-        }\n-        vec_len(n, vec_len_ge(_), _) => {\n-            return lower_bound(Result::new(bcx, C_int(ccx, n as int)));\n-        }\n-    }\n+pub enum OptResult<'a> {\n+    SingleResult(Result<'a>),\n+    RangeResult(Result<'a>, Result<'a>),\n+    LowerBound(Result<'a>)\n }\n \n #[deriving(Clone)]\n@@ -412,15 +409,15 @@ fn expand_nested_bindings<'a, 'b>(\n     }).collect()\n }\n \n-type enter_pats<'a> = |&[Gc<ast::Pat>]|: 'a -> Option<Vec<Gc<ast::Pat>>>;\n+type EnterPatterns<'a> = |&[Gc<ast::Pat>]|: 'a -> Option<Vec<Gc<ast::Pat>>>;\n \n fn enter_match<'a, 'b>(\n                bcx: &'b Block<'b>,\n                dm: &DefMap,\n                m: &'a [Match<'a, 'b>],\n                col: uint,\n                val: ValueRef,\n-               e: enter_pats)\n+               e: EnterPatterns)\n                -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n@@ -434,9 +431,20 @@ fn enter_match<'a, 'b>(\n             let this = *br.pats.get(col);\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n-                ast::PatIdent(_, ref path1, None) => {\n+                ast::PatIdent(_, ref path, None) => {\n                     if pat_is_binding(dm, &*this) {\n-                        bound_ptrs.push((path1.node, val));\n+                        bound_ptrs.push((path.node, val));\n+                    }\n+                }\n+                ast::PatVec(ref before, Some(slice), ref after) => {\n+                    match slice.node {\n+                        ast::PatIdent(_, ref path, None) => {\n+                            let subslice_val = bind_subslice_pat(\n+                                bcx, this.id, val,\n+                                before.len(), after.len());\n+                            bound_ptrs.push((path.node, subslice_val));\n+                        }\n+                        _ => {}\n                     }\n                 }\n                 _ => {}\n@@ -522,100 +530,36 @@ fn enter_opt<'a, 'b>(\n     let _indenter = indenter();\n \n     let ctor = match opt {\n-        &lit(expr) => check_match::ConstantValue(\n+        &ConstantValue(ConstantExpr(_, expr)) => check_match::ConstantValue(\n             const_eval::eval_const_expr(bcx.tcx(), &*expr)\n         ),\n-        &range(lo, hi) => check_match::ConstantRange(\n+        &ConstantRange(ConstantExpr(_, lo), ConstantExpr(_, hi)) => check_match::ConstantRange(\n             const_eval::eval_const_expr(bcx.tcx(), &*lo),\n             const_eval::eval_const_expr(bcx.tcx(), &*hi)\n         ),\n-        &vec_len(len, _, _) => check_match::Slice(len),\n-        &var(_, _, def_id) => check_match::Variant(def_id)\n+        &SliceLengthEqual(n) =>\n+            check_match::Slice(n),\n+        &SliceLengthGreaterOrEqual(before, after) =>\n+            check_match::SliceWithSubslice(before, after),\n+        &Variant(_, _, def_id) =>\n+            check_match::Variant(def_id)\n     };\n \n-    let mut i = 0;\n-    let tcx = bcx.tcx();\n     let mcx = check_match::MatchCheckCtxt { tcx: bcx.tcx() };\n-    enter_match(bcx, dm, m, col, val, |pats| {\n-        let span = pats[col].span;\n-        let specialized = match pats[col].node {\n-            ast::PatVec(ref before, slice, ref after) => {\n-                let (lo, hi) = match *opt {\n-                    vec_len(_, _, (lo, hi)) => (lo, hi),\n-                    _ => tcx.sess.span_bug(span,\n-                                           \"vec pattern but not vec opt\")\n-                };\n-\n-                let elems = match slice {\n-                    Some(slice) if i >= lo && i <= hi => {\n-                        let n = before.len() + after.len();\n-                        let this_opt = vec_len(n, vec_len_ge(before.len()),\n-                                               (lo, hi));\n-                        if opt_eq(tcx, &this_opt, opt) {\n-                            let mut new_before = Vec::new();\n-                            for pat in before.iter() {\n-                                new_before.push(*pat);\n-                            }\n-                            new_before.push(slice);\n-                            for pat in after.iter() {\n-                                new_before.push(*pat);\n-                            }\n-                            Some(new_before)\n-                        } else {\n-                            None\n-                        }\n-                    }\n-                    None if i >= lo && i <= hi => {\n-                        let n = before.len();\n-                        if opt_eq(tcx, &vec_len(n, vec_len_eq, (lo,hi)), opt) {\n-                            let mut new_before = Vec::new();\n-                            for pat in before.iter() {\n-                                new_before.push(*pat);\n-                            }\n-                            Some(new_before)\n-                        } else {\n-                            None\n-                        }\n-                    }\n-                    _ => None\n-                };\n-                elems.map(|head| head.append(pats.slice_to(col)).append(pats.slice_from(col + 1)))\n-            }\n-            _ => {\n-                check_match::specialize(&mcx, pats.as_slice(), &ctor, col, variant_size)\n-            }\n-        };\n-        i += 1;\n-        specialized\n-    })\n+    enter_match(bcx, dm, m, col, val, |pats|\n+        check_match::specialize(&mcx, pats.as_slice(), &ctor, col, variant_size)\n+    )\n }\n \n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n+fn get_branches<'a>(bcx: &'a Block, m: &[Match], col: uint) -> Vec<Opt<'a>> {\n     let ccx = bcx.ccx();\n-    fn add_to_set(tcx: &ty::ctxt, set: &mut Vec<Opt>, val: Opt) {\n-        if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n-        set.push(val);\n-    }\n-    // Vector comparisons are special in that since the actual\n-    // conditions over-match, we need to be careful about them. This\n-    // means that in order to properly handle things in order, we need\n-    // to not always merge conditions.\n-    fn add_veclen_to_set(set: &mut Vec<Opt> , i: uint,\n-                         len: uint, vlo: VecLenOpt) {\n-        match set.last() {\n-            // If the last condition in the list matches the one we want\n-            // to add, then extend its range. Otherwise, make a new\n-            // vec_len with a range just covering the new entry.\n-            Some(&vec_len(len2, vlo2, (start, end)))\n-                 if len == len2 && vlo == vlo2 => {\n-                let length = set.len();\n-                 *set.get_mut(length - 1) =\n-                     vec_len(len, vlo, (start, end+1))\n-            }\n-            _ => set.push(vec_len(len, vlo, (i, i)))\n+\n+    fn add_to_set<'a>(set: &mut Vec<Opt<'a>>, opt: Opt<'a>) {\n+        if !set.contains(&opt) {\n+            set.push(opt);\n         }\n     }\n \n@@ -624,36 +568,38 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n         let cur = *br.pats.get(col);\n         match cur.node {\n             ast::PatLit(l) => {\n-                add_to_set(ccx.tcx(), &mut found, lit(l));\n+                add_to_set(&mut found, ConstantValue(ConstantExpr(ccx.tcx(), l)));\n             }\n             ast::PatIdent(..) | ast::PatEnum(..) | ast::PatStruct(..) => {\n                 // This is either an enum variant or a variable binding.\n                 let opt_def = ccx.tcx.def_map.borrow().find_copy(&cur.id);\n                 match opt_def {\n                     Some(def::DefVariant(enum_id, var_id, _)) => {\n                         let variant = ty::enum_variant_with_id(ccx.tcx(), enum_id, var_id);\n-                        add_to_set(ccx.tcx(), &mut found,\n-                                   var(variant.disr_val,\n-                                       adt::represent_node(bcx, cur.id), var_id));\n+                        add_to_set(&mut found, Variant(\n+                            variant.disr_val,\n+                            adt::represent_node(bcx, cur.id), var_id\n+                        ));\n                     }\n                     _ => {}\n                 }\n             }\n             ast::PatRange(l1, l2) => {\n-                add_to_set(ccx.tcx(), &mut found, range(l1, l2));\n+                add_to_set(&mut found, ConstantRange(\n+                    ConstantExpr(ccx.tcx(), l1),\n+                    ConstantExpr(ccx.tcx(), l2)\n+                ));\n             }\n-            ast::PatVec(ref before, slice, ref after) => {\n-                let (len, vec_opt) = match slice {\n-                    None => (before.len(), vec_len_eq),\n-                    Some(_) => (before.len() + after.len(),\n-                                vec_len_ge(before.len()))\n-                };\n-                add_veclen_to_set(&mut found, i, len, vec_opt);\n+            ast::PatVec(ref before, None, ref after) => {\n+                add_to_set(&mut found, SliceLengthEqual(before.len() + after.len()));\n+            }\n+            ast::PatVec(ref before, Some(_), ref after) => {\n+                add_to_set(&mut found, SliceLengthGreaterOrEqual(before.len(), after.len()));\n             }\n             _ => {}\n         }\n     }\n-    return found;\n+    found\n }\n \n struct ExtractedBlock<'a> {\n@@ -675,62 +621,58 @@ fn extract_variant_args<'a>(\n     ExtractedBlock { vals: args, bcx: bcx }\n }\n \n-fn match_datum(bcx: &Block,\n-               val: ValueRef,\n-               pat_id: ast::NodeId)\n-               -> Datum<Lvalue> {\n+fn match_datum(val: ValueRef, left_ty: ty::t) -> Datum<Lvalue> {\n     /*!\n      * Helper for converting from the ValueRef that we pass around in\n      * the match code, which is always an lvalue, into a Datum. Eventually\n      * we should just pass around a Datum and be done with it.\n      */\n-\n-    let ty = node_id_type(bcx, pat_id);\n-    Datum::new(val, ty, Lvalue)\n+    Datum::new(val, left_ty, Lvalue)\n }\n \n+fn bind_subslice_pat<'a>(\n+                    bcx: &'a Block<'a>,\n+                    pat_id: ast::NodeId,\n+                    val: ValueRef,\n+                    offset_left: uint,\n+                    offset_right: uint) -> ValueRef {\n+    let _icx = push_ctxt(\"match::bind_subslice_pat\");\n+    let vec_ty = node_id_type(bcx, pat_id);\n+    let vt = tvec::vec_types(bcx, ty::sequence_element_type(bcx.tcx(), ty::type_content(vec_ty)));\n+    let vec_datum = match_datum(val, vec_ty);\n+    let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n+\n+    let slice_byte_offset = Mul(bcx, vt.llunit_size, C_uint(bcx.ccx(), offset_left));\n+    let slice_begin = tvec::pointer_add_byte(bcx, base, slice_byte_offset);\n+    let slice_len_offset = C_uint(bcx.ccx(), offset_left + offset_right);\n+    let slice_len = Sub(bcx, len, slice_len_offset);\n+    let slice_ty = ty::mk_slice(bcx.tcx(),\n+                                ty::ReStatic,\n+                                ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable});\n+    let scratch = rvalue_scratch_datum(bcx, slice_ty, \"\");\n+    Store(bcx, slice_begin,\n+          GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n+    Store(bcx, slice_len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n+    scratch.val\n+}\n \n fn extract_vec_elems<'a>(\n                      bcx: &'a Block<'a>,\n-                     pat_id: ast::NodeId,\n-                     elem_count: uint,\n-                     slice: Option<uint>,\n+                     left_ty: ty::t,\n+                     before: uint,\n+                     after: uint,\n                      val: ValueRef)\n                      -> ExtractedBlock<'a> {\n     let _icx = push_ctxt(\"match::extract_vec_elems\");\n-    let vec_datum = match_datum(bcx, val, pat_id);\n+    let vec_datum = match_datum(val, left_ty);\n     let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n-    let vec_ty = node_id_type(bcx, pat_id);\n-    let vt = tvec::vec_types(bcx, ty::sequence_element_type(bcx.tcx(), ty::type_content(vec_ty)));\n-\n-    let mut elems = Vec::from_fn(elem_count, |i| {\n-        match slice {\n-            None => GEPi(bcx, base, [i]),\n-            Some(n) if i < n => GEPi(bcx, base, [i]),\n-            Some(n) if i > n => {\n-                InBoundsGEP(bcx, base, [\n-                    Sub(bcx, len,\n-                        C_int(bcx.ccx(), (elem_count - i) as int))])\n-            }\n-            _ => unsafe { llvm::LLVMGetUndef(vt.llunit_ty.to_ref()) }\n-        }\n-    });\n-    if slice.is_some() {\n-        let n = slice.unwrap();\n-        let slice_byte_offset = Mul(bcx, vt.llunit_size, C_uint(bcx.ccx(), n));\n-        let slice_begin = tvec::pointer_add_byte(bcx, base, slice_byte_offset);\n-        let slice_len_offset = C_uint(bcx.ccx(), elem_count - 1u);\n-        let slice_len = Sub(bcx, len, slice_len_offset);\n-        let slice_ty = ty::mk_slice(bcx.tcx(),\n-                                    ty::ReStatic,\n-                                    ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable});\n-        let scratch = rvalue_scratch_datum(bcx, slice_ty, \"\");\n-        Store(bcx, slice_begin,\n-              GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n-        Store(bcx, slice_len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n-        *elems.get_mut(n) = scratch.val;\n-    }\n-\n+    let mut elems = vec![];\n+    elems.extend(range(0, before).map(|i| GEPi(bcx, base, [i])));\n+    elems.extend(range(0, after).rev().map(|i| {\n+        InBoundsGEP(bcx, base, [\n+            Sub(bcx, len, C_uint(bcx.ccx(), i + 1))\n+        ])\n+    }));\n     ExtractedBlock { vals: elems, bcx: bcx }\n }\n \n@@ -757,19 +699,19 @@ fn any_region_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, col, ast::PatRegion(_))\n }\n \n-fn any_irrefutable_adt_pat(bcx: &Block, m: &[Match], col: uint) -> bool {\n+fn any_irrefutable_adt_pat(tcx: &ty::ctxt, m: &[Match], col: uint) -> bool {\n     m.iter().any(|br| {\n         let pat = *br.pats.get(col);\n         match pat.node {\n             ast::PatTup(_) => true,\n             ast::PatStruct(..) => {\n-                match bcx.tcx().def_map.borrow().find(&pat.id) {\n+                match tcx.def_map.borrow().find(&pat.id) {\n                     Some(&def::DefVariant(..)) => false,\n                     _ => true,\n                 }\n             }\n             ast::PatEnum(..) | ast::PatIdent(_, _, None) => {\n-                match bcx.tcx().def_map.borrow().find(&pat.id) {\n+                match tcx.def_map.borrow().find(&pat.id) {\n                     Some(&def::DefFn(..)) |\n                     Some(&def::DefStruct(..)) => true,\n                     _ => false\n@@ -788,21 +730,21 @@ enum FailureHandler<'a> {\n }\n \n impl<'a> FailureHandler<'a> {\n-    fn is_infallible(&self) -> bool {\n+    fn is_fallible(&self) -> bool {\n         match *self {\n-            Infallible => true,\n-            _ => false\n+            Infallible => false,\n+            _ => true\n         }\n     }\n \n-    fn is_fallible(&self) -> bool {\n-        !self.is_infallible()\n+    fn is_infallible(&self) -> bool {\n+        !self.is_fallible()\n     }\n \n     fn handle_fail(&self, bcx: &Block) {\n         match *self {\n             Infallible =>\n-                fail!(\"attempted to fail in infallible failure handler!\"),\n+                fail!(\"attempted to fail in an infallible failure handler!\"),\n             JumpToBasicBlock(basic_block) =>\n                 Br(bcx, basic_block),\n             Unreachable =>\n@@ -840,9 +782,6 @@ fn pick_col(m: &[Match]) -> uint {\n     return best_col;\n }\n \n-#[deriving(PartialEq)]\n-pub enum branch_kind { no_branch, single, switch, compare, compare_vec_len }\n-\n // Compiles a comparison between two things.\n fn compare_values<'a>(\n                   cx: &'a Block<'a>,\n@@ -972,7 +911,7 @@ fn compile_guard<'a, 'b>(\n         }\n     }\n \n-    return with_cond(bcx, Not(bcx, val), |bcx| {\n+    with_cond(bcx, Not(bcx, val), |bcx| {\n         // Guard does not match: remove all bindings from the lllocals table\n         for (_, &binding_info) in data.bindings_map.iter() {\n             call_lifetime_end(bcx, binding_info.llmatch);\n@@ -990,7 +929,7 @@ fn compile_guard<'a, 'b>(\n             }\n         };\n         bcx\n-    });\n+    })\n }\n \n fn compile_submatch<'a, 'b>(\n@@ -1012,7 +951,9 @@ fn compile_submatch<'a, 'b>(\n         }\n         return;\n     }\n-    if m[0].pats.len() == 0u {\n+\n+    let col_count = m[0].pats.len();\n+    if col_count == 0u {\n         let data = &m[0].data;\n         for &(ref ident, ref value_ptr) in m[0].bound_ptrs.iter() {\n             let llmatch = data.bindings_map.get(ident).llmatch;\n@@ -1078,7 +1019,7 @@ fn compile_submatch_continue<'a, 'b>(\n     };\n \n     let mcx = check_match::MatchCheckCtxt { tcx: bcx.tcx() };\n-    let adt_vals = if any_irrefutable_adt_pat(bcx, m, col) {\n+    let adt_vals = if any_irrefutable_adt_pat(bcx.tcx(), m, col) {\n         let repr = adt::represent_type(bcx.ccx(), left_ty);\n         let arg_count = adt::num_args(&*repr, 0);\n         let field_vals: Vec<ValueRef> = std::iter::range(0, arg_count).map(|ix|\n@@ -1088,7 +1029,13 @@ fn compile_submatch_continue<'a, 'b>(\n     } else if any_uniq_pat(m, col) || any_region_pat(m, col) {\n         Some(vec!(Load(bcx, val)))\n     } else {\n-        None\n+        match ty::get(left_ty).sty {\n+            ty::ty_vec(_, Some(n)) => {\n+                let args = extract_vec_elems(bcx, left_ty, n, 0, val);\n+                Some(args.vals)\n+            }\n+            _ => None\n+        }\n     };\n \n     match adt_vals {\n@@ -1104,46 +1051,46 @@ fn compile_submatch_continue<'a, 'b>(\n     }\n \n     // Decide what kind of branch we need\n-    let opts = get_options(bcx, m, col);\n+    let opts = get_branches(bcx, m, col);\n     debug!(\"options={:?}\", opts);\n-    let mut kind = no_branch;\n+    let mut kind = NoBranch;\n     let mut test_val = val;\n     debug!(\"test_val={}\", bcx.val_to_string(test_val));\n     if opts.len() > 0u {\n         match *opts.get(0) {\n-            var(_, ref repr, _) => {\n+            ConstantValue(_) | ConstantRange(_, _) => {\n+                test_val = load_if_immediate(bcx, val, left_ty);\n+                kind = if ty::type_is_integral(left_ty) {\n+                    Switch\n+                } else {\n+                    Compare\n+                };\n+            }\n+            Variant(_, ref repr, _) => {\n                 let (the_kind, val_opt) = adt::trans_switch(bcx, &**repr, val);\n                 kind = the_kind;\n                 for &tval in val_opt.iter() { test_val = tval; }\n             }\n-            lit(_) => {\n-                test_val = load_if_immediate(bcx, val, left_ty);\n-                kind = if ty::type_is_integral(left_ty) { switch }\n-                else { compare };\n-            }\n-            range(_, _) => {\n-                test_val = Load(bcx, val);\n-                kind = compare;\n-            },\n-            vec_len(..) => {\n+            SliceLengthEqual(_) | SliceLengthGreaterOrEqual(_, _) => {\n                 let (_, len) = tvec::get_base_and_len(bcx, val, left_ty);\n                 test_val = len;\n-                kind = compare_vec_len;\n+                kind = Switch;\n             }\n         }\n     }\n     for o in opts.iter() {\n         match *o {\n-            range(_, _) => { kind = compare; break }\n+            ConstantRange(_, _) => { kind = Compare; break },\n+            SliceLengthGreaterOrEqual(_, _) => { kind = CompareSliceLength; break },\n             _ => ()\n         }\n     }\n     let else_cx = match kind {\n-        no_branch | single => bcx,\n+        NoBranch | Single => bcx,\n         _ => bcx.fcx.new_temp_block(\"match_else\")\n     };\n-    let sw = if kind == switch {\n-        Switch(bcx, test_val, else_cx.llbb, opts.len())\n+    let sw = if kind == Switch {\n+        build::Switch(bcx, test_val, else_cx.llbb, opts.len())\n     } else {\n         C_int(ccx, 0) // Placeholder for when not using a switch\n     };\n@@ -1160,119 +1107,106 @@ fn compile_submatch_continue<'a, 'b>(\n         // for the current conditional branch.\n         let mut branch_chk = None;\n         let mut opt_cx = else_cx;\n-        if !exhaustive || i+1 < len {\n+        if !exhaustive || i + 1 < len {\n             opt_cx = bcx.fcx.new_temp_block(\"match_case\");\n             match kind {\n-              single => Br(bcx, opt_cx.llbb),\n-              switch => {\n-                  match trans_opt(bcx, opt) {\n-                      single_result(r) => {\n-                        unsafe {\n-                          llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n-                          bcx = r.bcx;\n+                Single => Br(bcx, opt_cx.llbb),\n+                Switch => {\n+                    match opt.trans(bcx) {\n+                        SingleResult(r) => {\n+                            AddCase(sw, r.val, opt_cx.llbb);\n+                            bcx = r.bcx;\n+                        }\n+                        _ => {\n+                            bcx.sess().bug(\n+                                \"in compile_submatch, expected \\\n+                                 opt.trans() to return a SingleResult\")\n                         }\n-                      }\n-                      _ => {\n-                          bcx.sess().bug(\n-                              \"in compile_submatch, expected \\\n-                               trans_opt to return a single_result\")\n-                      }\n-                  }\n-              }\n-              compare | compare_vec_len => {\n-                  let t = if kind == compare {\n-                      left_ty\n-                  } else {\n-                      ty::mk_uint() // vector length\n-                  };\n-                  let Result {bcx: after_cx, val: matches} = {\n-                      match trans_opt(bcx, opt) {\n-                          single_result(Result {bcx, val}) => {\n-                              compare_values(bcx, test_val, val, t)\n-                          }\n-                          lower_bound(Result {bcx, val}) => {\n-                              compare_scalar_types(bcx, test_val, val, t, ast::BiGe)\n-                          }\n-                          range_result(Result {val: vbegin, ..},\n-                                       Result {bcx, val: vend}) => {\n-                              let Result {bcx, val: llge} =\n-                                  compare_scalar_types(\n-                                  bcx, test_val,\n-                                  vbegin, t, ast::BiGe);\n-                              let Result {bcx, val: llle} =\n-                                  compare_scalar_types(\n-                                  bcx, test_val, vend,\n-                                  t, ast::BiLe);\n-                              Result::new(bcx, And(bcx, llge, llle))\n-                          }\n-                      }\n-                  };\n-                  bcx = fcx.new_temp_block(\"compare_next\");\n-\n-                  // If none of the sub-cases match, and the current condition\n-                  // is guarded or has multiple patterns, move on to the next\n-                  // condition, if there is any, rather than falling back to\n-                  // the default.\n-                  let guarded = m[i].data.arm.guard.is_some();\n-                  let multi_pats = m[i].pats.len() > 1;\n-                  if i + 1 < len && (guarded || multi_pats || kind == compare_vec_len) {\n-                      branch_chk = Some(JumpToBasicBlock(bcx.llbb));\n-                  }\n-                  CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n-              }\n-              _ => ()\n+                    }\n+                }\n+                Compare | CompareSliceLength => {\n+                    let t = if kind == Compare {\n+                        left_ty\n+                    } else {\n+                        ty::mk_uint() // vector length\n+                    };\n+                    let Result { bcx: after_cx, val: matches } = {\n+                        match opt.trans(bcx) {\n+                            SingleResult(Result { bcx, val }) => {\n+                                compare_values(bcx, test_val, val, t)\n+                            }\n+                            RangeResult(Result { val: vbegin, .. },\n+                                        Result { bcx, val: vend }) => {\n+                                let Result { bcx, val: llge } =\n+                                    compare_scalar_types(\n+                                    bcx, test_val,\n+                                    vbegin, t, ast::BiGe);\n+                                let Result { bcx, val: llle } =\n+                                    compare_scalar_types(\n+                                    bcx, test_val, vend,\n+                                    t, ast::BiLe);\n+                                Result::new(bcx, And(bcx, llge, llle))\n+                            }\n+                            LowerBound(Result { bcx, val }) => {\n+                                compare_scalar_types(bcx, test_val, val, t, ast::BiGe)\n+                            }\n+                        }\n+                    };\n+                    bcx = fcx.new_temp_block(\"compare_next\");\n+\n+                    // If none of the sub-cases match, and the current condition\n+                    // is guarded or has multiple patterns, move on to the next\n+                    // condition, if there is any, rather than falling back to\n+                    // the default.\n+                    let guarded = m[i].data.arm.guard.is_some();\n+                    let multi_pats = m[i].pats.len() > 1;\n+                    if i + 1 < len && (guarded || multi_pats || kind == CompareSliceLength) {\n+                        branch_chk = Some(JumpToBasicBlock(bcx.llbb));\n+                    }\n+                    CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n+                }\n+                _ => ()\n             }\n-        } else if kind == compare || kind == compare_vec_len {\n+        } else if kind == Compare || kind == CompareSliceLength {\n             Br(bcx, else_cx.llbb);\n         }\n \n         let mut size = 0u;\n         let mut unpacked = Vec::new();\n         match *opt {\n-            var(disr_val, ref repr, _) => {\n+            Variant(disr_val, ref repr, _) => {\n                 let ExtractedBlock {vals: argvals, bcx: new_bcx} =\n                     extract_variant_args(opt_cx, &**repr, disr_val, val);\n                 size = argvals.len();\n                 unpacked = argvals;\n                 opt_cx = new_bcx;\n             }\n-            vec_len(n, vt, _) => {\n-                let (n, slice) = match vt {\n-                    vec_len_ge(i) => (n + 1u, Some(i)),\n-                    vec_len_eq => (n, None)\n-                };\n-                let args = extract_vec_elems(opt_cx, pat_id, n,\n-                                             slice, val);\n+            SliceLengthEqual(len) => {\n+                let args = extract_vec_elems(opt_cx, left_ty, len, 0, val);\n                 size = args.vals.len();\n                 unpacked = args.vals.clone();\n                 opt_cx = args.bcx;\n             }\n-            lit(_) | range(_, _) => ()\n+            SliceLengthGreaterOrEqual(before, after) => {\n+                let args = extract_vec_elems(opt_cx, left_ty, before, after, val);\n+                size = args.vals.len();\n+                unpacked = args.vals.clone();\n+                opt_cx = args.bcx;\n+            }\n+            ConstantValue(_) | ConstantRange(_, _) => ()\n         }\n         let opt_ms = enter_opt(opt_cx, pat_id, dm, m, opt, col, size, val);\n         let opt_vals = unpacked.append(vals_left.as_slice());\n-\n-        match branch_chk {\n-            None => {\n-                compile_submatch(opt_cx,\n-                                 opt_ms.as_slice(),\n-                                 opt_vals.as_slice(),\n-                                 chk,\n-                                 has_genuine_default)\n-            }\n-            Some(branch_chk) => {\n-                compile_submatch(opt_cx,\n-                                 opt_ms.as_slice(),\n-                                 opt_vals.as_slice(),\n-                                 &branch_chk,\n-                                 has_genuine_default)\n-            }\n-        }\n+        compile_submatch(opt_cx,\n+                         opt_ms.as_slice(),\n+                         opt_vals.as_slice(),\n+                         branch_chk.as_ref().unwrap_or(chk),\n+                         has_genuine_default);\n     }\n \n     // Compile the fall-through case, if any\n-    if !exhaustive && kind != single {\n-        if kind == compare || kind == compare_vec_len {\n+    if !exhaustive && kind != Single {\n+        if kind == Compare || kind == CompareSliceLength {\n             Br(bcx, else_cx.llbb);\n         }\n         match chk {\n@@ -1801,20 +1735,25 @@ fn bind_irrefutable_pat<'a>(\n             bcx = bind_irrefutable_pat(bcx, inner, loaded_val, binding_mode, cleanup_scope);\n         }\n         ast::PatVec(ref before, ref slice, ref after) => {\n-            let extracted = extract_vec_elems(\n-                bcx, pat.id, before.len() + 1u + after.len(),\n-                slice.map(|_| before.len()), val\n-            );\n+            let pat_ty = node_id_type(bcx, pat.id);\n+            let mut extracted = extract_vec_elems(bcx, pat_ty, before.len(), after.len(), val);\n+            match slice {\n+                &Some(_) => {\n+                    extracted.vals.insert(\n+                        before.len(),\n+                        bind_subslice_pat(bcx, pat.id, val, before.len(), after.len())\n+                    );\n+                }\n+                &None => ()\n+            }\n             bcx = before\n-                .iter().map(|v| Some(*v))\n-                .chain(Some(*slice).move_iter())\n-                .chain(after.iter().map(|v| Some(*v)))\n-                .zip(extracted.vals.iter())\n-                .fold(bcx, |bcx, (inner, elem)| {\n-                    inner.map_or(bcx, |inner| {\n-                        bind_irrefutable_pat(bcx, inner, *elem, binding_mode, cleanup_scope)\n-                    })\n-                });\n+                .iter()\n+                .chain(slice.iter())\n+                .chain(after.iter())\n+                .zip(extracted.vals.move_iter())\n+                .fold(bcx, |bcx, (&inner, elem)|\n+                    bind_irrefutable_pat(bcx, inner, elem, binding_mode, cleanup_scope)\n+                );\n         }\n         ast::PatMac(..) => {\n             bcx.sess().span_bug(pat.span, \"unexpanded macro\");"}, {"sha": "31d21cd707bc3c060fdeeb1e529985ad967c940e", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6f35ede5a475c286066d8d88cb9a519be2133d0d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f35ede5a475c286066d8d88cb9a519be2133d0d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=6f35ede5a475c286066d8d88cb9a519be2133d0d", "patch": "@@ -74,6 +74,7 @@ type Hint = attr::ReprAttr;\n \n \n /// Representations.\n+#[deriving(Eq, PartialEq)]\n pub enum Repr {\n     /// C-like enums; basically an int.\n     CEnum(IntType, Disr, Disr), // discriminant range (signedness based on the IntType)\n@@ -126,6 +127,7 @@ pub enum Repr {\n }\n \n /// For structs, and struct-like parts of anything fancier.\n+#[deriving(Eq, PartialEq)]\n pub struct Struct {\n     // If the struct is DST, then the size and alignment do not take into\n     // account the unsized fields of the struct.\n@@ -280,7 +282,7 @@ struct Case {\n }\n \n \n-#[deriving(Show)]\n+#[deriving(Eq, PartialEq, Show)]\n pub enum PointerField {\n     ThinPointer(uint),\n     FatPointer(uint, uint)\n@@ -572,14 +574,14 @@ fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool, dst: bool) -> V\n  * This should ideally be less tightly tied to `_match`.\n  */\n pub fn trans_switch(bcx: &Block, r: &Repr, scrutinee: ValueRef)\n-    -> (_match::branch_kind, Option<ValueRef>) {\n+    -> (_match::BranchKind, Option<ValueRef>) {\n     match *r {\n         CEnum(..) | General(..) |\n         RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n-            (_match::switch, Some(trans_get_discr(bcx, r, scrutinee, None)))\n+            (_match::Switch, Some(trans_get_discr(bcx, r, scrutinee, None)))\n         }\n         Univariant(..) => {\n-            (_match::single, None)\n+            (_match::Single, None)\n         }\n     }\n }\n@@ -664,14 +666,14 @@ fn load_discr(bcx: &Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n  * This should ideally be less tightly tied to `_match`.\n  */\n pub fn trans_case<'a>(bcx: &'a Block<'a>, r: &Repr, discr: Disr)\n-                  -> _match::opt_result<'a> {\n+                  -> _match::OptResult<'a> {\n     match *r {\n         CEnum(ity, _, _) => {\n-            _match::single_result(Result::new(bcx, C_integral(ll_inttype(bcx.ccx(), ity),\n+            _match::SingleResult(Result::new(bcx, C_integral(ll_inttype(bcx.ccx(), ity),\n                                                               discr as u64, true)))\n         }\n         General(ity, _, _) => {\n-            _match::single_result(Result::new(bcx, C_integral(ll_inttype(bcx.ccx(), ity),\n+            _match::SingleResult(Result::new(bcx, C_integral(ll_inttype(bcx.ccx(), ity),\n                                                               discr as u64, true)))\n         }\n         Univariant(..) => {\n@@ -680,7 +682,7 @@ pub fn trans_case<'a>(bcx: &'a Block<'a>, r: &Repr, discr: Disr)\n         RawNullablePointer { .. } |\n         StructWrappedNullablePointer { .. } => {\n             assert!(discr == 0 || discr == 1);\n-            _match::single_result(Result::new(bcx, C_bool(bcx.ccx(), discr != 0)))\n+            _match::SingleResult(Result::new(bcx, C_bool(bcx.ccx(), discr != 0)))\n         }\n     }\n }"}, {"sha": "d22dcb180707db839368bd6bbfedf1dbff13cbed", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f35ede5a475c286066d8d88cb9a519be2133d0d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f35ede5a475c286066d8d88cb9a519be2133d0d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=6f35ede5a475c286066d8d88cb9a519be2133d0d", "patch": "@@ -772,11 +772,11 @@ pub fn iter_structural_ty<'r,\n           // comparison know not to proceed when the discriminants differ.\n \n           match adt::trans_switch(cx, &*repr, av) {\n-              (_match::single, None) => {\n+              (_match::Single, None) => {\n                   cx = iter_variant(cx, &*repr, av, &**variants.get(0),\n                                     substs, f);\n               }\n-              (_match::switch, Some(lldiscrim_a)) => {\n+              (_match::Switch, Some(lldiscrim_a)) => {\n                   cx = f(cx, lldiscrim_a, ty::mk_int());\n                   let unr_cx = fcx.new_temp_block(\"enum-iter-unr\");\n                   Unreachable(unr_cx);\n@@ -791,7 +791,7 @@ pub fn iter_structural_ty<'r,\n                                       variant.disr_val.to_string().as_slice())\n                                      .as_slice());\n                       match adt::trans_case(cx, &*repr, variant.disr_val) {\n-                          _match::single_result(r) => {\n+                          _match::SingleResult(r) => {\n                               AddCase(llswitch, r.val, variant_cx.llbb)\n                           }\n                           _ => ccx.sess().unimpl(\"value from adt::trans_case \\"}, {"sha": "c234bea0a331ee90680fc3cf4f0138e78bf28c57", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f35ede5a475c286066d8d88cb9a519be2133d0d/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f35ede5a475c286066d8d88cb9a519be2133d0d/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=6f35ede5a475c286066d8d88cb9a519be2133d0d", "patch": "@@ -498,7 +498,7 @@ impl ReprAttr {\n     }\n }\n \n-#[deriving(PartialEq, Show)]\n+#[deriving(Eq, Hash, PartialEq, Show)]\n pub enum IntType {\n     SignedInt(ast::IntTy),\n     UnsignedInt(ast::UintTy)"}, {"sha": "7ddb20811a376a03c0f16fb3a9d6524b165ba119", "filename": "src/test/run-pass/issue-16648.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6f35ede5a475c286066d8d88cb9a519be2133d0d/src%2Ftest%2Frun-pass%2Fissue-16648.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f35ede5a475c286066d8d88cb9a519be2133d0d/src%2Ftest%2Frun-pass%2Fissue-16648.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16648.rs?ref=6f35ede5a475c286066d8d88cb9a519be2133d0d", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x: (int, &[int]) = (2i, &[1i, 2i]);\n+    assert_eq!(match x {\n+        (0, [_, _]) => 0,\n+        (1, _) => 1,\n+        (2, [_, _]) => 2,\n+        (2, _) => 3,\n+        _ => 4\n+    }, 2i);\n+}"}]}