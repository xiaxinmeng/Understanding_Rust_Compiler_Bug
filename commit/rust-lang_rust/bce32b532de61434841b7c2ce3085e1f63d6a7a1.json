{"sha": "bce32b532de61434841b7c2ce3085e1f63d6a7a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjZTMyYjUzMmRlNjE0MzQ4NDFiN2MyY2UzMDg1ZTFmNjNkNmE3YTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-13T13:28:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-13T13:28:55Z"}, "message": "Auto merge of #51987 - nikomatsakis:nll-region-infer-scc, r=pnkfelix\n\nnll experiment: compute SCCs instead of iterative region solving\n\nThis is an attempt to speed up region solving by replacing the current iterative dataflow with a SCC computation. The idea is to detect cycles (SCCs) amongst region constraints and then compute just one value per cycle. The graph with all cycles removed is of course a DAG, so we can then solve constraints \"bottom up\" once the liveness values are known.\n\nI kinda ran out of time this morning so the last commit is a bit sloppy but I wanted to get this posted, let travis run on it, and maybe do a perf run, before I clean it up.", "tree": {"sha": "ef1090c68f6bd8fd5c6a4639abeb07d88f123568", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef1090c68f6bd8fd5c6a4639abeb07d88f123568"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bce32b532de61434841b7c2ce3085e1f63d6a7a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bce32b532de61434841b7c2ce3085e1f63d6a7a1", "html_url": "https://github.com/rust-lang/rust/commit/bce32b532de61434841b7c2ce3085e1f63d6a7a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bce32b532de61434841b7c2ce3085e1f63d6a7a1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0955a34bcb17f0b31d7b86522a520ebe7fa93ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac", "html_url": "https://github.com/rust-lang/rust/commit/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac"}, {"sha": "6918c170488179bbba582d26af3b6b2c27a77641", "url": "https://api.github.com/repos/rust-lang/rust/commits/6918c170488179bbba582d26af3b6b2c27a77641", "html_url": "https://github.com/rust-lang/rust/commit/6918c170488179bbba582d26af3b6b2c27a77641"}], "stats": {"total": 2647, "additions": 1728, "deletions": 919}, "files": [{"sha": "aab70456dc18dbcef2e484c231cbe2916feadaca", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::graph;\n use cfg::*;\n use middle::region;\n-use ty::{self, TyCtxt};\n+use rustc_data_structures::graph::implementation as graph;\n use syntax::ptr::P;\n+use ty::{self, TyCtxt};\n \n use hir::{self, PatKind};\n use hir::def_id::DefId;"}, {"sha": "cf9c24cc58a623176f400e5968e3f3f230e1ab1d", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -11,7 +11,7 @@\n //! Module that constructs a control-flow graph representing an item.\n //! Uses `Graph` as the underlying representation.\n \n-use rustc_data_structures::graph;\n+use rustc_data_structures::graph::implementation as graph;\n use ty::TyCtxt;\n use hir;\n use hir::def_id::DefId;"}, {"sha": "ce0b5557a34bf1c2ac15fccbba3a317b893200f2", "filename": "src/librustc/dep_graph/query.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fquery.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -9,7 +9,9 @@\n // except according to those terms.\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::graph::{Direction, INCOMING, Graph, NodeIndex, OUTGOING};\n+use rustc_data_structures::graph::implementation::{\n+    Direction, INCOMING, Graph, NodeIndex, OUTGOING\n+};\n \n use super::DepNode;\n "}, {"sha": "120b45ec01e5ec018337c617b4a5c165ab28bd18", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -20,7 +20,7 @@ use infer::region_constraints::VerifyBound;\n use middle::free_region::RegionRelations;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n+use rustc_data_structures::graph::implementation::{Graph, Direction, NodeIndex, INCOMING, OUTGOING};\n use std::fmt;\n use std::u32;\n use ty::{self, TyCtxt};\n@@ -99,7 +99,7 @@ struct RegionAndOrigin<'tcx> {\n     origin: SubregionOrigin<'tcx>,\n }\n \n-type RegionGraph<'tcx> = graph::Graph<(), Constraint<'tcx>>;\n+type RegionGraph<'tcx> = Graph<(), Constraint<'tcx>>;\n \n struct LexicalResolver<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     region_rels: &'cx RegionRelations<'cx, 'gcx, 'tcx>,\n@@ -501,7 +501,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n     fn construct_graph(&self) -> RegionGraph<'tcx> {\n         let num_vars = self.num_vars();\n \n-        let mut graph = graph::Graph::new();\n+        let mut graph = Graph::new();\n \n         for _ in 0..num_vars {\n             graph.add_node(());\n@@ -550,9 +550,9 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n         let (mut lower_bounds, lower_dup) =\n-            self.collect_concrete_regions(graph, node_idx, graph::INCOMING, dup_vec);\n+            self.collect_concrete_regions(graph, node_idx, INCOMING, dup_vec);\n         let (mut upper_bounds, upper_dup) =\n-            self.collect_concrete_regions(graph, node_idx, graph::OUTGOING, dup_vec);\n+            self.collect_concrete_regions(graph, node_idx, OUTGOING, dup_vec);\n \n         if lower_dup || upper_dup {\n             return;"}, {"sha": "b949fd02126ba37d2912d93530389f08c399d2b0", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -22,7 +22,7 @@ use std::mem;\n use std::usize;\n use syntax::print::pprust::PrintState;\n \n-use rustc_data_structures::graph::OUTGOING;\n+use rustc_data_structures::graph::implementation::OUTGOING;\n \n use util::nodemap::FxHashMap;\n use hir;"}, {"sha": "f6076896385a6876ff423e2d5a3ff2cce19f3257", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -21,9 +21,8 @@ use mir::interpret::{EvalErrorKind, Scalar, Value};\n use mir::visit::MirVisitable;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n-use rustc_data_structures::control_flow_graph::dominators::{dominators, Dominators};\n-use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n-use rustc_data_structures::control_flow_graph::{GraphPredecessors, GraphSuccessors};\n+use rustc_data_structures::graph::dominators::{dominators, Dominators};\n+use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::small_vec::SmallVec;\n use rustc_data_structures::sync::Lrc;\n@@ -2289,23 +2288,32 @@ fn item_path_str(def_id: DefId) -> String {\n     ty::tls::with(|tcx| tcx.item_path_str(def_id))\n }\n \n-impl<'tcx> ControlFlowGraph for Mir<'tcx> {\n+impl<'tcx> graph::DirectedGraph for Mir<'tcx> {\n     type Node = BasicBlock;\n+}\n \n+impl<'tcx> graph::WithNumNodes for Mir<'tcx> {\n     fn num_nodes(&self) -> usize {\n         self.basic_blocks.len()\n     }\n+}\n \n+impl<'tcx> graph::WithStartNode for Mir<'tcx> {\n     fn start_node(&self) -> Self::Node {\n         START_BLOCK\n     }\n+}\n \n+impl<'tcx> graph::WithPredecessors for Mir<'tcx> {\n     fn predecessors<'graph>(\n         &'graph self,\n         node: Self::Node,\n     ) -> <Self as GraphPredecessors<'graph>>::Iter {\n         self.predecessors_for(node).clone().into_iter()\n     }\n+}\n+\n+impl<'tcx> graph::WithSuccessors for Mir<'tcx> {\n     fn successors<'graph>(\n         &'graph self,\n         node: Self::Node,\n@@ -2314,12 +2322,12 @@ impl<'tcx> ControlFlowGraph for Mir<'tcx> {\n     }\n }\n \n-impl<'a, 'b> GraphPredecessors<'b> for Mir<'a> {\n+impl<'a, 'b> graph::GraphPredecessors<'b> for Mir<'a> {\n     type Item = BasicBlock;\n     type Iter = IntoIter<BasicBlock>;\n }\n \n-impl<'a, 'b> GraphSuccessors<'b> for Mir<'a> {\n+impl<'a, 'b> graph::GraphSuccessors<'b> for Mir<'a> {\n     type Item = BasicBlock;\n     type Iter = iter::Cloned<Successors<'b>>;\n }"}, {"sha": "efd829c283f063ff8c1a20f49a162fad01ef12cf", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -12,7 +12,7 @@\n //! which do not.\n \n use rustc_data_structures::bitvec::BitVector;\n-use rustc_data_structures::control_flow_graph::dominators::Dominators;\n+use rustc_data_structures::graph::dominators::Dominators;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::mir::{self, Location, TerminatorKind};\n use rustc::mir::visit::{Visitor, PlaceContext};"}, {"sha": "7bf776675c6a0ad4f3482538b8457798e03a22d6", "filename": "src/librustc_data_structures/control_flow_graph/mod.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0955a34bcb17f0b31d7b86522a520ebe7fa93ac/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs?ref=c0955a34bcb17f0b31d7b86522a520ebe7fa93ac", "patch": "@@ -1,42 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use super::indexed_vec::Idx;\n-\n-pub mod dominators;\n-pub mod iterate;\n-mod reference;\n-\n-#[cfg(test)]\n-mod test;\n-\n-pub trait ControlFlowGraph\n-    where Self: for<'graph> GraphPredecessors<'graph, Item=<Self as ControlFlowGraph>::Node>,\n-          Self: for<'graph> GraphSuccessors<'graph, Item=<Self as ControlFlowGraph>::Node>\n-{\n-    type Node: Idx;\n-\n-    fn num_nodes(&self) -> usize;\n-    fn start_node(&self) -> Self::Node;\n-    fn predecessors<'graph>(&'graph self, node: Self::Node)\n-                            -> <Self as GraphPredecessors<'graph>>::Iter;\n-    fn successors<'graph>(&'graph self, node: Self::Node)\n-                            -> <Self as GraphSuccessors<'graph>>::Iter;\n-}\n-\n-pub trait GraphPredecessors<'graph> {\n-    type Item;\n-    type Iter: Iterator<Item = Self::Item>;\n-}\n-\n-pub trait GraphSuccessors<'graph> {\n-    type Item;\n-    type Iter: Iterator<Item = Self::Item>;\n-}"}, {"sha": "d134fad2855bbdd999907698e10e7e17cfd8e07b", "filename": "src/librustc_data_structures/graph/dominators/mod.rs", "status": "renamed", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -14,9 +14,9 @@\n //! Rice Computer Science TS-06-33870\n //! <https://www.cs.rice.edu/~keith/EMBED/dom.pdf>\n \n-use super::ControlFlowGraph;\n+use super::super::indexed_vec::{Idx, IndexVec};\n use super::iterate::reverse_post_order;\n-use super::super::indexed_vec::{IndexVec, Idx};\n+use super::ControlFlowGraph;\n \n use std::fmt;\n \n@@ -29,15 +29,16 @@ pub fn dominators<G: ControlFlowGraph>(graph: &G) -> Dominators<G::Node> {\n     dominators_given_rpo(graph, &rpo)\n }\n \n-pub fn dominators_given_rpo<G: ControlFlowGraph>(graph: &G,\n-                                                 rpo: &[G::Node])\n-                                                 -> Dominators<G::Node> {\n+pub fn dominators_given_rpo<G: ControlFlowGraph>(\n+    graph: &G,\n+    rpo: &[G::Node],\n+) -> Dominators<G::Node> {\n     let start_node = graph.start_node();\n     assert_eq!(rpo[0], start_node);\n \n     // compute the post order index (rank) for each node\n-    let mut post_order_rank: IndexVec<G::Node, usize> = IndexVec::from_elem_n(usize::default(),\n-                                                                              graph.num_nodes());\n+    let mut post_order_rank: IndexVec<G::Node, usize> =\n+        IndexVec::from_elem_n(usize::default(), graph.num_nodes());\n     for (index, node) in rpo.iter().rev().cloned().enumerate() {\n         post_order_rank[node] = index;\n     }\n@@ -56,10 +57,12 @@ pub fn dominators_given_rpo<G: ControlFlowGraph>(graph: &G,\n                 if immediate_dominators[pred].is_some() {\n                     // (*)\n                     // (*) dominators for `pred` have been calculated\n-                    new_idom = intersect_opt(&post_order_rank,\n-                                             &immediate_dominators,\n-                                             new_idom,\n-                                             Some(pred));\n+                    new_idom = intersect_opt(\n+                        &post_order_rank,\n+                        &immediate_dominators,\n+                        new_idom,\n+                        Some(pred),\n+                    );\n                 }\n             }\n \n@@ -76,23 +79,25 @@ pub fn dominators_given_rpo<G: ControlFlowGraph>(graph: &G,\n     }\n }\n \n-fn intersect_opt<Node: Idx>(post_order_rank: &IndexVec<Node, usize>,\n-                            immediate_dominators: &IndexVec<Node, Option<Node>>,\n-                            node1: Option<Node>,\n-                            node2: Option<Node>)\n-                            -> Option<Node> {\n+fn intersect_opt<Node: Idx>(\n+    post_order_rank: &IndexVec<Node, usize>,\n+    immediate_dominators: &IndexVec<Node, Option<Node>>,\n+    node1: Option<Node>,\n+    node2: Option<Node>,\n+) -> Option<Node> {\n     match (node1, node2) {\n         (None, None) => None,\n         (Some(n), None) | (None, Some(n)) => Some(n),\n         (Some(n1), Some(n2)) => Some(intersect(post_order_rank, immediate_dominators, n1, n2)),\n     }\n }\n \n-fn intersect<Node: Idx>(post_order_rank: &IndexVec<Node, usize>,\n-                        immediate_dominators: &IndexVec<Node, Option<Node>>,\n-                        mut node1: Node,\n-                        mut node2: Node)\n-                        -> Node {\n+fn intersect<Node: Idx>(\n+    post_order_rank: &IndexVec<Node, usize>,\n+    immediate_dominators: &IndexVec<Node, Option<Node>>,\n+    mut node1: Node,\n+    mut node2: Node,\n+) -> Node {\n     while node1 != node2 {\n         while post_order_rank[node1] < post_order_rank[node2] {\n             node1 = immediate_dominators[node1].unwrap();\n@@ -176,11 +181,13 @@ impl<Node: Idx> DominatorTree<Node> {\n \n impl<Node: Idx> fmt::Debug for DominatorTree<Node> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&DominatorTreeNode {\n-                            tree: self,\n-                            node: self.root,\n-                        },\n-                        fmt)\n+        fmt::Debug::fmt(\n+            &DominatorTreeNode {\n+                tree: self,\n+                node: self.root,\n+            },\n+            fmt,\n+        )\n     }\n }\n \n@@ -194,11 +201,9 @@ impl<'tree, Node: Idx> fmt::Debug for DominatorTreeNode<'tree, Node> {\n         let subtrees: Vec<_> = self.tree\n             .children(self.node)\n             .iter()\n-            .map(|&child| {\n-                DominatorTreeNode {\n-                    tree: self.tree,\n-                    node: child,\n-                }\n+            .map(|&child| DominatorTreeNode {\n+                tree: self.tree,\n+                node: child,\n             })\n             .collect();\n         fmt.debug_tuple(\"\")", "previous_filename": "src/librustc_data_structures/control_flow_graph/dominators/mod.rs"}, {"sha": "0af878cac2df1d23f0706aab4b0693aa22293b39", "filename": "src/librustc_data_structures/graph/dominators/test.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Ftest.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "previous_filename": "src/librustc_data_structures/control_flow_graph/dominators/test.rs"}, {"sha": "e2b393071ff5c4ec0333aaf2f343ed31db734902", "filename": "src/librustc_data_structures/graph/implementation/mod.rs", "status": "added", "additions": 417, "deletions": 0, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -0,0 +1,417 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A graph module for use in dataflow, region resolution, and elsewhere.\n+//!\n+//! # Interface details\n+//!\n+//! You customize the graph by specifying a \"node data\" type `N` and an\n+//! \"edge data\" type `E`. You can then later gain access (mutable or\n+//! immutable) to these \"user-data\" bits. Currently, you can only add\n+//! nodes or edges to the graph. You cannot remove or modify them once\n+//! added. This could be changed if we have a need.\n+//!\n+//! # Implementation details\n+//!\n+//! The main tricky thing about this code is the way that edges are\n+//! stored. The edges are stored in a central array, but they are also\n+//! threaded onto two linked lists for each node, one for incoming edges\n+//! and one for outgoing edges. Note that every edge is a member of some\n+//! incoming list and some outgoing list.  Basically you can load the\n+//! first index of the linked list from the node data structures (the\n+//! field `first_edge`) and then, for each edge, load the next index from\n+//! the field `next_edge`). Each of those fields is an array that should\n+//! be indexed by the direction (see the type `Direction`).\n+\n+use bitvec::BitVector;\n+use std::fmt::Debug;\n+use std::usize;\n+use snapshot_vec::{SnapshotVec, SnapshotVecDelegate};\n+\n+#[cfg(test)]\n+mod tests;\n+\n+pub struct Graph<N, E> {\n+    nodes: SnapshotVec<Node<N>>,\n+    edges: SnapshotVec<Edge<E>>,\n+}\n+\n+pub struct Node<N> {\n+    first_edge: [EdgeIndex; 2], // see module comment\n+    pub data: N,\n+}\n+\n+#[derive(Debug)]\n+pub struct Edge<E> {\n+    next_edge: [EdgeIndex; 2], // see module comment\n+    source: NodeIndex,\n+    target: NodeIndex,\n+    pub data: E,\n+}\n+\n+impl<N> SnapshotVecDelegate for Node<N> {\n+    type Value = Node<N>;\n+    type Undo = ();\n+\n+    fn reverse(_: &mut Vec<Node<N>>, _: ()) {}\n+}\n+\n+impl<N> SnapshotVecDelegate for Edge<N> {\n+    type Value = Edge<N>;\n+    type Undo = ();\n+\n+    fn reverse(_: &mut Vec<Edge<N>>, _: ()) {}\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct NodeIndex(pub usize);\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct EdgeIndex(pub usize);\n+\n+pub const INVALID_EDGE_INDEX: EdgeIndex = EdgeIndex(usize::MAX);\n+\n+// Use a private field here to guarantee no more instances are created:\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub struct Direction {\n+    repr: usize,\n+}\n+\n+pub const OUTGOING: Direction = Direction { repr: 0 };\n+\n+pub const INCOMING: Direction = Direction { repr: 1 };\n+\n+impl NodeIndex {\n+    /// Returns unique id (unique with respect to the graph holding associated node).\n+    pub fn node_id(&self) -> usize {\n+        self.0\n+    }\n+}\n+\n+impl<N: Debug, E: Debug> Graph<N, E> {\n+    pub fn new() -> Graph<N, E> {\n+        Graph {\n+            nodes: SnapshotVec::new(),\n+            edges: SnapshotVec::new(),\n+        }\n+    }\n+\n+    pub fn with_capacity(nodes: usize, edges: usize) -> Graph<N, E> {\n+        Graph {\n+            nodes: SnapshotVec::with_capacity(nodes),\n+            edges: SnapshotVec::with_capacity(edges),\n+        }\n+    }\n+\n+    // # Simple accessors\n+\n+    #[inline]\n+    pub fn all_nodes(&self) -> &[Node<N>] {\n+        &self.nodes\n+    }\n+\n+    #[inline]\n+    pub fn len_nodes(&self) -> usize {\n+        self.nodes.len()\n+    }\n+\n+    #[inline]\n+    pub fn all_edges(&self) -> &[Edge<E>] {\n+        &self.edges\n+    }\n+\n+    #[inline]\n+    pub fn len_edges(&self) -> usize {\n+        self.edges.len()\n+    }\n+\n+    // # Node construction\n+\n+    pub fn next_node_index(&self) -> NodeIndex {\n+        NodeIndex(self.nodes.len())\n+    }\n+\n+    pub fn add_node(&mut self, data: N) -> NodeIndex {\n+        let idx = self.next_node_index();\n+        self.nodes.push(Node {\n+            first_edge: [INVALID_EDGE_INDEX, INVALID_EDGE_INDEX],\n+            data,\n+        });\n+        idx\n+    }\n+\n+    pub fn mut_node_data(&mut self, idx: NodeIndex) -> &mut N {\n+        &mut self.nodes[idx.0].data\n+    }\n+\n+    pub fn node_data(&self, idx: NodeIndex) -> &N {\n+        &self.nodes[idx.0].data\n+    }\n+\n+    pub fn node(&self, idx: NodeIndex) -> &Node<N> {\n+        &self.nodes[idx.0]\n+    }\n+\n+    // # Edge construction and queries\n+\n+    pub fn next_edge_index(&self) -> EdgeIndex {\n+        EdgeIndex(self.edges.len())\n+    }\n+\n+    pub fn add_edge(&mut self, source: NodeIndex, target: NodeIndex, data: E) -> EdgeIndex {\n+        debug!(\"graph: add_edge({:?}, {:?}, {:?})\", source, target, data);\n+\n+        let idx = self.next_edge_index();\n+\n+        // read current first of the list of edges from each node\n+        let source_first = self.nodes[source.0].first_edge[OUTGOING.repr];\n+        let target_first = self.nodes[target.0].first_edge[INCOMING.repr];\n+\n+        // create the new edge, with the previous firsts from each node\n+        // as the next pointers\n+        self.edges.push(Edge {\n+            next_edge: [source_first, target_first],\n+            source,\n+            target,\n+            data,\n+        });\n+\n+        // adjust the firsts for each node target be the next object.\n+        self.nodes[source.0].first_edge[OUTGOING.repr] = idx;\n+        self.nodes[target.0].first_edge[INCOMING.repr] = idx;\n+\n+        return idx;\n+    }\n+\n+    pub fn edge(&self, idx: EdgeIndex) -> &Edge<E> {\n+        &self.edges[idx.0]\n+    }\n+\n+    // # Iterating over nodes, edges\n+\n+    pub fn enumerated_nodes(&self) -> impl Iterator<Item = (NodeIndex, &Node<N>)> {\n+        self.nodes\n+            .iter()\n+            .enumerate()\n+            .map(|(idx, n)| (NodeIndex(idx), n))\n+    }\n+\n+    pub fn enumerated_edges(&self) -> impl Iterator<Item = (EdgeIndex, &Edge<E>)> {\n+        self.edges\n+            .iter()\n+            .enumerate()\n+            .map(|(idx, e)| (EdgeIndex(idx), e))\n+    }\n+\n+    pub fn each_node<'a>(&'a self, mut f: impl FnMut(NodeIndex, &'a Node<N>) -> bool) -> bool {\n+        //! Iterates over all edges defined in the graph.\n+        self.enumerated_nodes()\n+            .all(|(node_idx, node)| f(node_idx, node))\n+    }\n+\n+    pub fn each_edge<'a>(&'a self, mut f: impl FnMut(EdgeIndex, &'a Edge<E>) -> bool) -> bool {\n+        //! Iterates over all edges defined in the graph\n+        self.enumerated_edges()\n+            .all(|(edge_idx, edge)| f(edge_idx, edge))\n+    }\n+\n+    pub fn outgoing_edges(&self, source: NodeIndex) -> AdjacentEdges<N, E> {\n+        self.adjacent_edges(source, OUTGOING)\n+    }\n+\n+    pub fn incoming_edges(&self, source: NodeIndex) -> AdjacentEdges<N, E> {\n+        self.adjacent_edges(source, INCOMING)\n+    }\n+\n+    pub fn adjacent_edges(&self, source: NodeIndex, direction: Direction) -> AdjacentEdges<N, E> {\n+        let first_edge = self.node(source).first_edge[direction.repr];\n+        AdjacentEdges {\n+            graph: self,\n+            direction,\n+            next: first_edge,\n+        }\n+    }\n+\n+    pub fn successor_nodes<'a>(\n+        &'a self,\n+        source: NodeIndex,\n+    ) -> impl Iterator<Item = NodeIndex> + 'a {\n+        self.outgoing_edges(source).targets()\n+    }\n+\n+    pub fn predecessor_nodes<'a>(\n+        &'a self,\n+        target: NodeIndex,\n+    ) -> impl Iterator<Item = NodeIndex> + 'a {\n+        self.incoming_edges(target).sources()\n+    }\n+\n+    pub fn depth_traverse<'a>(\n+        &'a self,\n+        start: NodeIndex,\n+        direction: Direction,\n+    ) -> DepthFirstTraversal<'a, N, E> {\n+        DepthFirstTraversal::with_start_node(self, start, direction)\n+    }\n+\n+    pub fn nodes_in_postorder<'a>(\n+        &'a self,\n+        direction: Direction,\n+        entry_node: NodeIndex,\n+    ) -> Vec<NodeIndex> {\n+        let mut visited = BitVector::new(self.len_nodes());\n+        let mut stack = vec![];\n+        let mut result = Vec::with_capacity(self.len_nodes());\n+        let mut push_node = |stack: &mut Vec<_>, node: NodeIndex| {\n+            if visited.insert(node.0) {\n+                stack.push((node, self.adjacent_edges(node, direction)));\n+            }\n+        };\n+\n+        for node in Some(entry_node)\n+            .into_iter()\n+            .chain(self.enumerated_nodes().map(|(node, _)| node))\n+        {\n+            push_node(&mut stack, node);\n+            while let Some((node, mut iter)) = stack.pop() {\n+                if let Some((_, child)) = iter.next() {\n+                    let target = child.source_or_target(direction);\n+                    // the current node needs more processing, so\n+                    // add it back to the stack\n+                    stack.push((node, iter));\n+                    // and then push the new node\n+                    push_node(&mut stack, target);\n+                } else {\n+                    result.push(node);\n+                }\n+            }\n+        }\n+\n+        assert_eq!(result.len(), self.len_nodes());\n+        result\n+    }\n+}\n+\n+// # Iterators\n+\n+pub struct AdjacentEdges<'g, N, E>\n+where\n+    N: 'g,\n+    E: 'g,\n+{\n+    graph: &'g Graph<N, E>,\n+    direction: Direction,\n+    next: EdgeIndex,\n+}\n+\n+impl<'g, N: Debug, E: Debug> AdjacentEdges<'g, N, E> {\n+    fn targets(self) -> impl Iterator<Item = NodeIndex> + 'g {\n+        self.into_iter().map(|(_, edge)| edge.target)\n+    }\n+\n+    fn sources(self) -> impl Iterator<Item = NodeIndex> + 'g {\n+        self.into_iter().map(|(_, edge)| edge.source)\n+    }\n+}\n+\n+impl<'g, N: Debug, E: Debug> Iterator for AdjacentEdges<'g, N, E> {\n+    type Item = (EdgeIndex, &'g Edge<E>);\n+\n+    fn next(&mut self) -> Option<(EdgeIndex, &'g Edge<E>)> {\n+        let edge_index = self.next;\n+        if edge_index == INVALID_EDGE_INDEX {\n+            return None;\n+        }\n+\n+        let edge = self.graph.edge(edge_index);\n+        self.next = edge.next_edge[self.direction.repr];\n+        Some((edge_index, edge))\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        // At most, all the edges in the graph.\n+        (0, Some(self.graph.len_edges()))\n+    }\n+}\n+\n+pub struct DepthFirstTraversal<'g, N, E>\n+where\n+    N: 'g,\n+    E: 'g,\n+{\n+    graph: &'g Graph<N, E>,\n+    stack: Vec<NodeIndex>,\n+    visited: BitVector,\n+    direction: Direction,\n+}\n+\n+impl<'g, N: Debug, E: Debug> DepthFirstTraversal<'g, N, E> {\n+    pub fn with_start_node(\n+        graph: &'g Graph<N, E>,\n+        start_node: NodeIndex,\n+        direction: Direction,\n+    ) -> Self {\n+        let mut visited = BitVector::new(graph.len_nodes());\n+        visited.insert(start_node.node_id());\n+        DepthFirstTraversal {\n+            graph,\n+            stack: vec![start_node],\n+            visited,\n+            direction,\n+        }\n+    }\n+\n+    fn visit(&mut self, node: NodeIndex) {\n+        if self.visited.insert(node.node_id()) {\n+            self.stack.push(node);\n+        }\n+    }\n+}\n+\n+impl<'g, N: Debug, E: Debug> Iterator for DepthFirstTraversal<'g, N, E> {\n+    type Item = NodeIndex;\n+\n+    fn next(&mut self) -> Option<NodeIndex> {\n+        let next = self.stack.pop();\n+        if let Some(idx) = next {\n+            for (_, edge) in self.graph.adjacent_edges(idx, self.direction) {\n+                let target = edge.source_or_target(self.direction);\n+                self.visit(target);\n+            }\n+        }\n+        next\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        // We will visit every node in the graph exactly once.\n+        let remaining = self.graph.len_nodes() - self.visited.count();\n+        (remaining, Some(remaining))\n+    }\n+}\n+\n+impl<'g, N: Debug, E: Debug> ExactSizeIterator for DepthFirstTraversal<'g, N, E> {}\n+\n+impl<E> Edge<E> {\n+    pub fn source(&self) -> NodeIndex {\n+        self.source\n+    }\n+\n+    pub fn target(&self) -> NodeIndex {\n+        self.target\n+    }\n+\n+    pub fn source_or_target(&self, direction: Direction) -> NodeIndex {\n+        if direction == OUTGOING {\n+            self.target\n+        } else {\n+            self.source\n+        }\n+    }\n+}"}, {"sha": "3814827b5df6edbdec8892723eb5aa57a36d143e", "filename": "src/librustc_data_structures/graph/implementation/tests.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Ftests.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use graph::*;\n+use graph::implementation::*;\n use std::fmt::Debug;\n \n type TestGraph = Graph<&'static str, &'static str>;", "previous_filename": "src/librustc_data_structures/graph/tests.rs"}, {"sha": "3afdc88d60279a001724064acbca44e3a1c7a091", "filename": "src/librustc_data_structures/graph/iterate/mod.rs", "status": "renamed", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -8,20 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::ControlFlowGraph;\n use super::super::indexed_vec::IndexVec;\n+use super::{DirectedGraph, WithSuccessors, WithNumNodes};\n \n #[cfg(test)]\n mod test;\n \n-pub fn post_order_from<G: ControlFlowGraph>(graph: &G, start_node: G::Node) -> Vec<G::Node> {\n+pub fn post_order_from<G: DirectedGraph + WithSuccessors + WithNumNodes>(\n+    graph: &G,\n+    start_node: G::Node,\n+) -> Vec<G::Node> {\n     post_order_from_to(graph, start_node, None)\n }\n \n-pub fn post_order_from_to<G: ControlFlowGraph>(graph: &G,\n-                                               start_node: G::Node,\n-                                               end_node: Option<G::Node>)\n-                                               -> Vec<G::Node> {\n+pub fn post_order_from_to<G: DirectedGraph + WithSuccessors + WithNumNodes>(\n+    graph: &G,\n+    start_node: G::Node,\n+    end_node: Option<G::Node>,\n+) -> Vec<G::Node> {\n     let mut visited: IndexVec<G::Node, bool> = IndexVec::from_elem_n(false, graph.num_nodes());\n     let mut result: Vec<G::Node> = Vec::with_capacity(graph.num_nodes());\n     if let Some(end_node) = end_node {\n@@ -31,10 +35,12 @@ pub fn post_order_from_to<G: ControlFlowGraph>(graph: &G,\n     result\n }\n \n-fn post_order_walk<G: ControlFlowGraph>(graph: &G,\n-                                        node: G::Node,\n-                                        result: &mut Vec<G::Node>,\n-                                        visited: &mut IndexVec<G::Node, bool>) {\n+fn post_order_walk<G: DirectedGraph + WithSuccessors + WithNumNodes>(\n+    graph: &G,\n+    node: G::Node,\n+    result: &mut Vec<G::Node>,\n+    visited: &mut IndexVec<G::Node, bool>,\n+) {\n     if visited[node] {\n         return;\n     }\n@@ -47,7 +53,10 @@ fn post_order_walk<G: ControlFlowGraph>(graph: &G,\n     result.push(node);\n }\n \n-pub fn reverse_post_order<G: ControlFlowGraph>(graph: &G, start_node: G::Node) -> Vec<G::Node> {\n+pub fn reverse_post_order<G: DirectedGraph + WithSuccessors + WithNumNodes>(\n+    graph: &G,\n+    start_node: G::Node,\n+) -> Vec<G::Node> {\n     let mut vec = post_order_from(graph, start_node);\n     vec.reverse();\n     vec", "previous_filename": "src/librustc_data_structures/control_flow_graph/iterate/mod.rs"}, {"sha": "100881ddfdd7706f25fc75a11af4fedcc5d09d4b", "filename": "src/librustc_data_structures/graph/iterate/test.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Ftest.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "previous_filename": "src/librustc_data_structures/control_flow_graph/iterate/test.rs"}, {"sha": "7265e4e8c7c66090ebb1600577c965355d1866cc", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 46, "deletions": 384, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,410 +8,72 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A graph module for use in dataflow, region resolution, and elsewhere.\n-//!\n-//! # Interface details\n-//!\n-//! You customize the graph by specifying a \"node data\" type `N` and an\n-//! \"edge data\" type `E`. You can then later gain access (mutable or\n-//! immutable) to these \"user-data\" bits. Currently, you can only add\n-//! nodes or edges to the graph. You cannot remove or modify them once\n-//! added. This could be changed if we have a need.\n-//!\n-//! # Implementation details\n-//!\n-//! The main tricky thing about this code is the way that edges are\n-//! stored. The edges are stored in a central array, but they are also\n-//! threaded onto two linked lists for each node, one for incoming edges\n-//! and one for outgoing edges. Note that every edge is a member of some\n-//! incoming list and some outgoing list.  Basically you can load the\n-//! first index of the linked list from the node data structures (the\n-//! field `first_edge`) and then, for each edge, load the next index from\n-//! the field `next_edge`). Each of those fields is an array that should\n-//! be indexed by the direction (see the type `Direction`).\n+use super::indexed_vec::Idx;\n \n-use bitvec::BitVector;\n-use std::fmt::Debug;\n-use std::usize;\n-use snapshot_vec::{SnapshotVec, SnapshotVecDelegate};\n+pub mod dominators;\n+pub mod implementation;\n+pub mod iterate;\n+mod reference;\n+pub mod scc;\n \n #[cfg(test)]\n-mod tests;\n+mod test;\n \n-pub struct Graph<N, E> {\n-    nodes: SnapshotVec<Node<N>>,\n-    edges: SnapshotVec<Edge<E>>,\n+pub trait DirectedGraph {\n+    type Node: Idx;\n }\n \n-pub struct Node<N> {\n-    first_edge: [EdgeIndex; 2], // see module comment\n-    pub data: N,\n+pub trait WithNumNodes: DirectedGraph {\n+    fn num_nodes(&self) -> usize;\n }\n \n-#[derive(Debug)]\n-pub struct Edge<E> {\n-    next_edge: [EdgeIndex; 2], // see module comment\n-    source: NodeIndex,\n-    target: NodeIndex,\n-    pub data: E,\n-}\n-\n-impl<N> SnapshotVecDelegate for Node<N> {\n-    type Value = Node<N>;\n-    type Undo = ();\n-\n-    fn reverse(_: &mut Vec<Node<N>>, _: ()) {}\n-}\n-\n-impl<N> SnapshotVecDelegate for Edge<N> {\n-    type Value = Edge<N>;\n-    type Undo = ();\n-\n-    fn reverse(_: &mut Vec<Edge<N>>, _: ()) {}\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct NodeIndex(pub usize);\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct EdgeIndex(pub usize);\n-\n-pub const INVALID_EDGE_INDEX: EdgeIndex = EdgeIndex(usize::MAX);\n-\n-// Use a private field here to guarantee no more instances are created:\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-pub struct Direction {\n-    repr: usize,\n-}\n-\n-pub const OUTGOING: Direction = Direction { repr: 0 };\n-\n-pub const INCOMING: Direction = Direction { repr: 1 };\n-\n-impl NodeIndex {\n-    /// Returns unique id (unique with respect to the graph holding associated node).\n-    pub fn node_id(&self) -> usize {\n-        self.0\n-    }\n-}\n-\n-impl<N: Debug, E: Debug> Graph<N, E> {\n-    pub fn new() -> Graph<N, E> {\n-        Graph {\n-            nodes: SnapshotVec::new(),\n-            edges: SnapshotVec::new(),\n-        }\n-    }\n-\n-    pub fn with_capacity(nodes: usize, edges: usize) -> Graph<N, E> {\n-        Graph {\n-            nodes: SnapshotVec::with_capacity(nodes),\n-            edges: SnapshotVec::with_capacity(edges),\n-        }\n-    }\n-\n-    // # Simple accessors\n-\n-    #[inline]\n-    pub fn all_nodes(&self) -> &[Node<N>] {\n-        &self.nodes\n-    }\n-\n-    #[inline]\n-    pub fn len_nodes(&self) -> usize {\n-        self.nodes.len()\n-    }\n-\n-    #[inline]\n-    pub fn all_edges(&self) -> &[Edge<E>] {\n-        &self.edges\n-    }\n-\n-    #[inline]\n-    pub fn len_edges(&self) -> usize {\n-        self.edges.len()\n-    }\n-\n-    // # Node construction\n-\n-    pub fn next_node_index(&self) -> NodeIndex {\n-        NodeIndex(self.nodes.len())\n-    }\n-\n-    pub fn add_node(&mut self, data: N) -> NodeIndex {\n-        let idx = self.next_node_index();\n-        self.nodes.push(Node {\n-            first_edge: [INVALID_EDGE_INDEX, INVALID_EDGE_INDEX],\n-            data,\n-        });\n-        idx\n-    }\n-\n-    pub fn mut_node_data(&mut self, idx: NodeIndex) -> &mut N {\n-        &mut self.nodes[idx.0].data\n-    }\n-\n-    pub fn node_data(&self, idx: NodeIndex) -> &N {\n-        &self.nodes[idx.0].data\n-    }\n-\n-    pub fn node(&self, idx: NodeIndex) -> &Node<N> {\n-        &self.nodes[idx.0]\n-    }\n-\n-    // # Edge construction and queries\n-\n-    pub fn next_edge_index(&self) -> EdgeIndex {\n-        EdgeIndex(self.edges.len())\n-    }\n-\n-    pub fn add_edge(&mut self, source: NodeIndex, target: NodeIndex, data: E) -> EdgeIndex {\n-        debug!(\"graph: add_edge({:?}, {:?}, {:?})\", source, target, data);\n-\n-        let idx = self.next_edge_index();\n-\n-        // read current first of the list of edges from each node\n-        let source_first = self.nodes[source.0].first_edge[OUTGOING.repr];\n-        let target_first = self.nodes[target.0].first_edge[INCOMING.repr];\n-\n-        // create the new edge, with the previous firsts from each node\n-        // as the next pointers\n-        self.edges.push(Edge {\n-            next_edge: [source_first, target_first],\n-            source,\n-            target,\n-            data,\n-        });\n-\n-        // adjust the firsts for each node target be the next object.\n-        self.nodes[source.0].first_edge[OUTGOING.repr] = idx;\n-        self.nodes[target.0].first_edge[INCOMING.repr] = idx;\n-\n-        return idx;\n-    }\n-\n-    pub fn edge(&self, idx: EdgeIndex) -> &Edge<E> {\n-        &self.edges[idx.0]\n-    }\n-\n-    // # Iterating over nodes, edges\n-\n-    pub fn enumerated_nodes(&self) -> impl Iterator<Item = (NodeIndex, &Node<N>)> {\n-        self.nodes\n-            .iter()\n-            .enumerate()\n-            .map(|(idx, n)| (NodeIndex(idx), n))\n-    }\n-\n-    pub fn enumerated_edges(&self) -> impl Iterator<Item = (EdgeIndex, &Edge<E>)> {\n-        self.edges\n-            .iter()\n-            .enumerate()\n-            .map(|(idx, e)| (EdgeIndex(idx), e))\n-    }\n-\n-    pub fn each_node<'a>(&'a self, mut f: impl FnMut(NodeIndex, &'a Node<N>) -> bool) -> bool {\n-        //! Iterates over all edges defined in the graph.\n-        self.enumerated_nodes()\n-            .all(|(node_idx, node)| f(node_idx, node))\n-    }\n-\n-    pub fn each_edge<'a>(&'a self, mut f: impl FnMut(EdgeIndex, &'a Edge<E>) -> bool) -> bool {\n-        //! Iterates over all edges defined in the graph\n-        self.enumerated_edges()\n-            .all(|(edge_idx, edge)| f(edge_idx, edge))\n-    }\n-\n-    pub fn outgoing_edges(&self, source: NodeIndex) -> AdjacentEdges<N, E> {\n-        self.adjacent_edges(source, OUTGOING)\n-    }\n-\n-    pub fn incoming_edges(&self, source: NodeIndex) -> AdjacentEdges<N, E> {\n-        self.adjacent_edges(source, INCOMING)\n-    }\n-\n-    pub fn adjacent_edges(&self, source: NodeIndex, direction: Direction) -> AdjacentEdges<N, E> {\n-        let first_edge = self.node(source).first_edge[direction.repr];\n-        AdjacentEdges {\n-            graph: self,\n-            direction,\n-            next: first_edge,\n-        }\n-    }\n-\n-    pub fn successor_nodes<'a>(\n-        &'a self,\n-        source: NodeIndex,\n-    ) -> impl Iterator<Item = NodeIndex> + 'a {\n-        self.outgoing_edges(source).targets()\n-    }\n-\n-    pub fn predecessor_nodes<'a>(\n-        &'a self,\n-        target: NodeIndex,\n-    ) -> impl Iterator<Item = NodeIndex> + 'a {\n-        self.incoming_edges(target).sources()\n-    }\n-\n-    pub fn depth_traverse<'a>(\n-        &'a self,\n-        start: NodeIndex,\n-        direction: Direction,\n-    ) -> DepthFirstTraversal<'a, N, E> {\n-        DepthFirstTraversal::with_start_node(self, start, direction)\n-    }\n-\n-    pub fn nodes_in_postorder<'a>(\n-        &'a self,\n-        direction: Direction,\n-        entry_node: NodeIndex,\n-    ) -> Vec<NodeIndex> {\n-        let mut visited = BitVector::new(self.len_nodes());\n-        let mut stack = vec![];\n-        let mut result = Vec::with_capacity(self.len_nodes());\n-        let mut push_node = |stack: &mut Vec<_>, node: NodeIndex| {\n-            if visited.insert(node.0) {\n-                stack.push((node, self.adjacent_edges(node, direction)));\n-            }\n-        };\n-\n-        for node in Some(entry_node)\n-            .into_iter()\n-            .chain(self.enumerated_nodes().map(|(node, _)| node))\n-        {\n-            push_node(&mut stack, node);\n-            while let Some((node, mut iter)) = stack.pop() {\n-                if let Some((_, child)) = iter.next() {\n-                    let target = child.source_or_target(direction);\n-                    // the current node needs more processing, so\n-                    // add it back to the stack\n-                    stack.push((node, iter));\n-                    // and then push the new node\n-                    push_node(&mut stack, target);\n-                } else {\n-                    result.push(node);\n-                }\n-            }\n-        }\n-\n-        assert_eq!(result.len(), self.len_nodes());\n-        result\n-    }\n-}\n-\n-// # Iterators\n-\n-pub struct AdjacentEdges<'g, N, E>\n+pub trait WithSuccessors: DirectedGraph\n where\n-    N: 'g,\n-    E: 'g,\n+    Self: for<'graph> GraphSuccessors<'graph, Item = <Self as DirectedGraph>::Node>,\n {\n-    graph: &'g Graph<N, E>,\n-    direction: Direction,\n-    next: EdgeIndex,\n+    fn successors<'graph>(\n+        &'graph self,\n+        node: Self::Node,\n+    ) -> <Self as GraphSuccessors<'graph>>::Iter;\n }\n \n-impl<'g, N: Debug, E: Debug> AdjacentEdges<'g, N, E> {\n-    fn targets(self) -> impl Iterator<Item = NodeIndex> + 'g {\n-        self.into_iter().map(|(_, edge)| edge.target)\n-    }\n-\n-    fn sources(self) -> impl Iterator<Item = NodeIndex> + 'g {\n-        self.into_iter().map(|(_, edge)| edge.source)\n-    }\n+pub trait GraphSuccessors<'graph> {\n+    type Item;\n+    type Iter: Iterator<Item = Self::Item>;\n }\n \n-impl<'g, N: Debug, E: Debug> Iterator for AdjacentEdges<'g, N, E> {\n-    type Item = (EdgeIndex, &'g Edge<E>);\n-\n-    fn next(&mut self) -> Option<(EdgeIndex, &'g Edge<E>)> {\n-        let edge_index = self.next;\n-        if edge_index == INVALID_EDGE_INDEX {\n-            return None;\n-        }\n-\n-        let edge = self.graph.edge(edge_index);\n-        self.next = edge.next_edge[self.direction.repr];\n-        Some((edge_index, edge))\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        // At most, all the edges in the graph.\n-        (0, Some(self.graph.len_edges()))\n-    }\n-}\n-\n-pub struct DepthFirstTraversal<'g, N, E>\n+pub trait WithPredecessors: DirectedGraph\n where\n-    N: 'g,\n-    E: 'g,\n+    Self: for<'graph> GraphPredecessors<'graph, Item = <Self as DirectedGraph>::Node>,\n {\n-    graph: &'g Graph<N, E>,\n-    stack: Vec<NodeIndex>,\n-    visited: BitVector,\n-    direction: Direction,\n+    fn predecessors<'graph>(\n+        &'graph self,\n+        node: Self::Node,\n+    ) -> <Self as GraphPredecessors<'graph>>::Iter;\n }\n \n-impl<'g, N: Debug, E: Debug> DepthFirstTraversal<'g, N, E> {\n-    pub fn with_start_node(\n-        graph: &'g Graph<N, E>,\n-        start_node: NodeIndex,\n-        direction: Direction,\n-    ) -> Self {\n-        let mut visited = BitVector::new(graph.len_nodes());\n-        visited.insert(start_node.node_id());\n-        DepthFirstTraversal {\n-            graph,\n-            stack: vec![start_node],\n-            visited,\n-            direction,\n-        }\n-    }\n-\n-    fn visit(&mut self, node: NodeIndex) {\n-        if self.visited.insert(node.node_id()) {\n-            self.stack.push(node);\n-        }\n-    }\n+pub trait GraphPredecessors<'graph> {\n+    type Item;\n+    type Iter: Iterator<Item = Self::Item>;\n }\n \n-impl<'g, N: Debug, E: Debug> Iterator for DepthFirstTraversal<'g, N, E> {\n-    type Item = NodeIndex;\n-\n-    fn next(&mut self) -> Option<NodeIndex> {\n-        let next = self.stack.pop();\n-        if let Some(idx) = next {\n-            for (_, edge) in self.graph.adjacent_edges(idx, self.direction) {\n-                let target = edge.source_or_target(self.direction);\n-                self.visit(target);\n-            }\n-        }\n-        next\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        // We will visit every node in the graph exactly once.\n-        let remaining = self.graph.len_nodes() - self.visited.count();\n-        (remaining, Some(remaining))\n-    }\n+pub trait WithStartNode: DirectedGraph {\n+    fn start_node(&self) -> Self::Node;\n }\n \n-impl<'g, N: Debug, E: Debug> ExactSizeIterator for DepthFirstTraversal<'g, N, E> {}\n-\n-impl<E> Edge<E> {\n-    pub fn source(&self) -> NodeIndex {\n-        self.source\n-    }\n-\n-    pub fn target(&self) -> NodeIndex {\n-        self.target\n-    }\n+pub trait ControlFlowGraph:\n+    DirectedGraph + WithStartNode + WithPredecessors + WithStartNode + WithSuccessors + WithNumNodes\n+{\n+    // convenient trait\n+}\n \n-    pub fn source_or_target(&self, direction: Direction) -> NodeIndex {\n-        if direction == OUTGOING {\n-            self.target\n-        } else {\n-            self.source\n-        }\n-    }\n+impl<T> ControlFlowGraph for T\n+where\n+    T: DirectedGraph\n+        + WithStartNode\n+        + WithPredecessors\n+        + WithStartNode\n+        + WithSuccessors\n+        + WithNumNodes,\n+{\n }"}, {"sha": "a7b763db8da293eed8ae251d6d4c3ebb5fc2ef51", "filename": "src/librustc_data_structures/graph/reference.rs", "status": "renamed", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Freference.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -10,34 +10,42 @@\n \n use super::*;\n \n-impl<'graph, G: ControlFlowGraph> ControlFlowGraph for &'graph G {\n+impl<'graph, G: DirectedGraph> DirectedGraph for &'graph G {\n     type Node = G::Node;\n+}\n \n+impl<'graph, G: WithNumNodes> WithNumNodes for &'graph G {\n     fn num_nodes(&self) -> usize {\n         (**self).num_nodes()\n     }\n+}\n \n+impl<'graph, G: WithStartNode> WithStartNode for &'graph G {\n     fn start_node(&self) -> Self::Node {\n         (**self).start_node()\n     }\n+}\n+\n+impl<'graph, G: WithSuccessors> WithSuccessors for &'graph G {\n+    fn successors<'iter>(&'iter self, node: Self::Node) -> <Self as GraphSuccessors<'iter>>::Iter {\n+        (**self).successors(node)\n+    }\n+}\n \n+impl<'graph, G: WithPredecessors> WithPredecessors for &'graph G {\n     fn predecessors<'iter>(&'iter self,\n                            node: Self::Node)\n                            -> <Self as GraphPredecessors<'iter>>::Iter {\n         (**self).predecessors(node)\n     }\n-\n-    fn successors<'iter>(&'iter self, node: Self::Node) -> <Self as GraphSuccessors<'iter>>::Iter {\n-        (**self).successors(node)\n-    }\n }\n \n-impl<'iter, 'graph, G: ControlFlowGraph> GraphPredecessors<'iter> for &'graph G {\n+impl<'iter, 'graph, G: WithPredecessors> GraphPredecessors<'iter> for &'graph G {\n     type Item = G::Node;\n     type Iter = <G as GraphPredecessors<'iter>>::Iter;\n }\n \n-impl<'iter, 'graph, G: ControlFlowGraph> GraphSuccessors<'iter> for &'graph G {\n+impl<'iter, 'graph, G: WithSuccessors> GraphSuccessors<'iter> for &'graph G {\n     type Item = G::Node;\n     type Iter = <G as GraphSuccessors<'iter>>::Iter;\n }", "previous_filename": "src/librustc_data_structures/control_flow_graph/reference.rs"}, {"sha": "a989a5401022219d8dd88c083025d121232bb861", "filename": "src/librustc_data_structures/graph/scc/mod.rs", "status": "added", "additions": 361, "deletions": 0, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -0,0 +1,361 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Routine to compute the strongly connected components (SCCs) of a\n+//! graph, as well as the resulting DAG if each SCC is replaced with a\n+//! node in the graph. This uses Tarjan's algorithm that completes in\n+//! O(n) time.\n+\n+use fx::FxHashSet;\n+use graph::{DirectedGraph, WithNumNodes, WithSuccessors};\n+use indexed_vec::{Idx, IndexVec};\n+use std::ops::Range;\n+\n+mod test;\n+\n+/// Strongly connected components (SCC) of a graph. The type `N` is\n+/// the index type for the graph nodes and `S` is the index type for\n+/// the SCCs. We can map from each node to the SCC that it\n+/// participates in, and we also have the successors of each SCC.\n+pub struct Sccs<N: Idx, S: Idx> {\n+    /// For each node, what is the SCC index of the SCC to which it\n+    /// belongs.\n+    scc_indices: IndexVec<N, S>,\n+\n+    /// Data about each SCC.\n+    scc_data: SccData<S>,\n+}\n+\n+struct SccData<S: Idx> {\n+    /// For each SCC, the range of `all_successors` where its\n+    /// successors can be found.\n+    ranges: IndexVec<S, Range<usize>>,\n+\n+    /// Contains the succcessors for all the Sccs, concatenated. The\n+    /// range of indices corresponding to a given SCC is found in its\n+    /// SccData.\n+    all_successors: Vec<S>,\n+}\n+\n+impl<N: Idx, S: Idx> Sccs<N, S> {\n+    pub fn new(graph: &(impl DirectedGraph<Node = N> + WithNumNodes + WithSuccessors)) -> Self {\n+        SccsConstruction::construct(graph)\n+    }\n+\n+    /// Returns the number of SCCs in the graph.\n+    pub fn num_sccs(&self) -> usize {\n+        self.scc_data.len()\n+    }\n+\n+    /// Returns an iterator over the SCCs in the graph.\n+    pub fn all_sccs(&self) -> impl Iterator<Item = S> {\n+        (0 .. self.scc_data.len()).map(S::new)\n+    }\n+\n+    /// Returns the SCC to which a node `r` belongs.\n+    pub fn scc(&self, r: N) -> S {\n+        self.scc_indices[r]\n+    }\n+\n+    /// Returns the successors of the given SCC.\n+    pub fn successors(&self, scc: S) -> &[S] {\n+        self.scc_data.successors(scc)\n+    }\n+}\n+\n+impl<S: Idx> SccData<S> {\n+    /// Number of SCCs,\n+    fn len(&self) -> usize {\n+        self.ranges.len()\n+    }\n+\n+    /// Returns the successors of the given SCC.\n+    fn successors(&self, scc: S) -> &[S] {\n+        // Annoyingly, `range` does not implement `Copy`, so we have\n+        // to do `range.start..range.end`:\n+        let range = &self.ranges[scc];\n+        &self.all_successors[range.start..range.end]\n+    }\n+\n+    /// Creates a new SCC with `successors` as its successors and\n+    /// returns the resulting index.\n+    fn create_scc(&mut self, successors: impl IntoIterator<Item = S>) -> S {\n+        // Store the successors on `scc_successors_vec`, remembering\n+        // the range of indices.\n+        let all_successors_start = self.all_successors.len();\n+        self.all_successors.extend(successors);\n+        let all_successors_end = self.all_successors.len();\n+\n+        debug!(\n+            \"create_scc({:?}) successors={:?}\",\n+            self.ranges.len(),\n+            &self.all_successors[all_successors_start..all_successors_end],\n+        );\n+\n+        self.ranges.push(all_successors_start..all_successors_end)\n+    }\n+}\n+\n+struct SccsConstruction<'c, G: DirectedGraph + WithNumNodes + WithSuccessors + 'c, S: Idx> {\n+    graph: &'c G,\n+\n+    /// The state of each node; used during walk to record the stack\n+    /// and after walk to record what cycle each node ended up being\n+    /// in.\n+    node_states: IndexVec<G::Node, NodeState<G::Node, S>>,\n+\n+    /// The stack of nodes that we are visiting as part of the DFS.\n+    node_stack: Vec<G::Node>,\n+\n+    /// The stack of successors: as we visit a node, we mark our\n+    /// position in this stack, and when we encounter a successor SCC,\n+    /// we push it on the stack. When we complete an SCC, we can pop\n+    /// everything off the stack that was found along the way.\n+    successors_stack: Vec<S>,\n+\n+    /// A set used to strip duplicates. As we accumulate successors\n+    /// into the successors_stack, we sometimes get duplicate entries.\n+    /// We use this set to remove those -- we also keep its storage\n+    /// around between successors to amortize memory allocation costs.\n+    duplicate_set: FxHashSet<S>,\n+\n+    scc_data: SccData<S>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum NodeState<N, S> {\n+    /// This node has not yet been visited as part of the DFS.\n+    ///\n+    /// After SCC construction is complete, this state ought to be\n+    /// impossible.\n+    NotVisited,\n+\n+    /// This node is currently being walk as part of our DFS. It is on\n+    /// the stack at the depth `depth`.\n+    ///\n+    /// After SCC construction is complete, this state ought to be\n+    /// impossible.\n+    BeingVisited { depth: usize },\n+\n+    /// Indicates that this node is a member of the given cycle.\n+    InCycle { scc_index: S },\n+\n+    /// Indicates that this node is a member of whatever cycle\n+    /// `parent` is a member of. This state is transient: whenever we\n+    /// see it, we try to overwrite it with the current state of\n+    /// `parent` (this is the \"path compression\" step of a union-find\n+    /// algorithm).\n+    InCycleWith { parent: N },\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum WalkReturn<S> {\n+    Cycle { min_depth: usize },\n+    Complete { scc_index: S },\n+}\n+\n+impl<'c, G, S> SccsConstruction<'c, G, S>\n+where\n+    G: DirectedGraph + WithNumNodes + WithSuccessors,\n+    S: Idx,\n+{\n+    /// Identifies SCCs in the graph `G` and computes the resulting\n+    /// DAG. This uses a variant of [Tarjan's\n+    /// algorithm][wikipedia]. The high-level summary of the algorithm\n+    /// is that we do a depth-first search. Along the way, we keep a\n+    /// stack of each node whose successors are being visited. We\n+    /// track the depth of each node on this stack (there is no depth\n+    /// if the node is not on the stack). When we find that some node\n+    /// N with depth D can reach some other node N' with lower depth\n+    /// D' (i.e., D' < D), we know that N, N', and all nodes in\n+    /// between them on the stack are part of an SCC.\n+    ///\n+    /// [wikipedia]: https://bit.ly/2EZIx84\n+    fn construct(graph: &'c G) -> Sccs<G::Node, S> {\n+        let num_nodes = graph.num_nodes();\n+\n+        let mut this = Self {\n+            graph,\n+            node_states: IndexVec::from_elem_n(NodeState::NotVisited, num_nodes),\n+            node_stack: Vec::with_capacity(num_nodes),\n+            successors_stack: Vec::new(),\n+            scc_data: SccData {\n+                ranges: IndexVec::new(),\n+                all_successors: Vec::new(),\n+            },\n+            duplicate_set: FxHashSet::default(),\n+        };\n+\n+        let scc_indices = (0..num_nodes)\n+            .map(G::Node::new)\n+            .map(|node| match this.walk_node(0, node) {\n+                WalkReturn::Complete { scc_index } => scc_index,\n+                WalkReturn::Cycle { min_depth } => panic!(\n+                    \"`walk_node(0, {:?})` returned cycle with depth {:?}\",\n+                    node, min_depth\n+                ),\n+            })\n+            .collect();\n+\n+        Sccs {\n+            scc_indices,\n+            scc_data: this.scc_data,\n+        }\n+    }\n+\n+    /// Visit a node during the DFS. We first examine its current\n+    /// state -- if it is not yet visited (`NotVisited`), we can push\n+    /// it onto the stack and start walking its successors.\n+    ///\n+    /// If it is already on the DFS stack it will be in the state\n+    /// `BeingVisited`. In that case, we have found a cycle and we\n+    /// return the depth from the stack.\n+    ///\n+    /// Otherwise, we are looking at a node that has already been\n+    /// completely visited. We therefore return `WalkReturn::Complete`\n+    /// with its associated SCC index.\n+    fn walk_node(&mut self, depth: usize, node: G::Node) -> WalkReturn<S> {\n+        debug!(\"walk_node(depth = {:?}, node = {:?})\", depth, node);\n+        match self.find_state(node) {\n+            NodeState::InCycle { scc_index } => WalkReturn::Complete { scc_index },\n+\n+            NodeState::BeingVisited { depth: min_depth } => WalkReturn::Cycle { min_depth },\n+\n+            NodeState::NotVisited => self.walk_unvisited_node(depth, node),\n+\n+            NodeState::InCycleWith { parent } => panic!(\n+                \"`find_state` returned `InCycleWith({:?})`, which ought to be impossible\",\n+                parent\n+            ),\n+        }\n+    }\n+\n+    /// Fetches the state of the node `r`. If `r` is recorded as being\n+    /// in a cycle with some other node `r2`, then fetches the state\n+    /// of `r2` (and updates `r` to reflect current result). This is\n+    /// basically the \"find\" part of a standard union-find algorithm\n+    /// (with path compression).\n+    fn find_state(&mut self, r: G::Node) -> NodeState<G::Node, S> {\n+        debug!(\"find_state(r = {:?} in state {:?})\", r, self.node_states[r]);\n+        match self.node_states[r] {\n+            NodeState::InCycle { scc_index } => NodeState::InCycle { scc_index },\n+            NodeState::BeingVisited { depth } => NodeState::BeingVisited { depth },\n+            NodeState::NotVisited => NodeState::NotVisited,\n+            NodeState::InCycleWith { parent } => {\n+                let parent_state = self.find_state(parent);\n+                debug!(\"find_state: parent_state = {:?}\", parent_state);\n+                match parent_state {\n+                    NodeState::InCycle { .. } => {\n+                        self.node_states[r] = parent_state;\n+                        parent_state\n+                    }\n+\n+                    NodeState::BeingVisited { depth } => {\n+                        self.node_states[r] = NodeState::InCycleWith {\n+                            parent: self.node_stack[depth],\n+                        };\n+                        parent_state\n+                    }\n+\n+                    NodeState::NotVisited | NodeState::InCycleWith { .. } => {\n+                        panic!(\"invalid parent state: {:?}\", parent_state)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Walks a node that has never been visited before.\n+    fn walk_unvisited_node(&mut self, depth: usize, node: G::Node) -> WalkReturn<S> {\n+        debug!(\n+            \"walk_unvisited_node(depth = {:?}, node = {:?})\",\n+            depth, node\n+        );\n+\n+        debug_assert!(match self.node_states[node] {\n+            NodeState::NotVisited => true,\n+            _ => false,\n+        });\n+\n+        // Push `node` onto the stack.\n+        self.node_states[node] = NodeState::BeingVisited { depth };\n+        self.node_stack.push(node);\n+\n+        // Walk each successor of the node, looking to see if any of\n+        // them can reach a node that is presently on the stack. If\n+        // so, that means they can also reach us.\n+        let mut min_depth = depth;\n+        let mut min_cycle_root = node;\n+        let successors_len = self.successors_stack.len();\n+        for successor_node in self.graph.successors(node) {\n+            debug!(\n+                \"walk_unvisited_node: node = {:?} successor_ode = {:?}\",\n+                node, successor_node\n+            );\n+            match self.walk_node(depth + 1, successor_node) {\n+                WalkReturn::Cycle {\n+                    min_depth: successor_min_depth,\n+                } => {\n+                    // Track the minimum depth we can reach.\n+                    assert!(successor_min_depth <= depth);\n+                    if successor_min_depth < min_depth {\n+                        debug!(\n+                            \"walk_unvisited_node: node = {:?} successor_min_depth = {:?}\",\n+                            node, successor_min_depth\n+                        );\n+                        min_depth = successor_min_depth;\n+                        min_cycle_root = successor_node;\n+                    }\n+                }\n+\n+                WalkReturn::Complete {\n+                    scc_index: successor_scc_index,\n+                } => {\n+                    // Push the completed SCC indices onto\n+                    // the `successors_stack` for later.\n+                    debug!(\n+                        \"walk_unvisited_node: node = {:?} successor_scc_index = {:?}\",\n+                        node, successor_scc_index\n+                    );\n+                    self.successors_stack.push(successor_scc_index);\n+                }\n+            }\n+        }\n+\n+        // Completed walk, remove `node` from the stack.\n+        let r = self.node_stack.pop();\n+        debug_assert_eq!(r, Some(node));\n+\n+        // If `min_depth == depth`, then we are the root of the\n+        // cycle: we can't reach anyone further down the stack.\n+        if min_depth == depth {\n+            // Note that successor stack may have duplicates, so we\n+            // want to remove those:\n+            let deduplicated_successors = {\n+                let duplicate_set = &mut self.duplicate_set;\n+                duplicate_set.clear();\n+                self.successors_stack\n+                    .drain(successors_len..)\n+                    .filter(move |&i| duplicate_set.insert(i))\n+            };\n+            let scc_index = self.scc_data.create_scc(deduplicated_successors);\n+            self.node_states[node] = NodeState::InCycle { scc_index };\n+            WalkReturn::Complete { scc_index }\n+        } else {\n+            // We are not the head of the cycle. Return back to our\n+            // caller. They will take ownership of the\n+            // `self.successors` data that we pushed.\n+            self.node_states[node] = NodeState::InCycleWith {\n+                parent: min_cycle_root,\n+            };\n+            WalkReturn::Cycle { min_depth }\n+        }\n+    }\n+}"}, {"sha": "405e1b3a6174876a795e6f07afc2281dfc016699", "filename": "src/librustc_data_structures/graph/scc/test.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Ftest.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -0,0 +1,180 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg(test)]\n+\n+use graph::test::TestGraph;\n+use super::*;\n+\n+#[test]\n+fn diamond() {\n+    let graph = TestGraph::new(0, &[(0, 1), (0, 2), (1, 3), (2, 3)]);\n+    let sccs: Sccs<_, usize> = Sccs::new(&graph);\n+    assert_eq!(sccs.num_sccs(), 4);\n+    assert_eq!(sccs.num_sccs(), 4);\n+}\n+\n+#[test]\n+fn test_big_scc() {\n+    // The order in which things will be visited is important to this\n+    // test.\n+    //\n+    // We will visit:\n+    //\n+    // 0 -> 1 -> 2 -> 0\n+    //\n+    // and at this point detect a cycle. 2 will return back to 1 which\n+    // will visit 3. 3 will visit 2 before the cycle is complete, and\n+    // hence it too will return a cycle.\n+\n+    /*\n++-> 0\n+|   |\n+|   v\n+|   1 -> 3\n+|   |    |\n+|   v    |\n++-- 2 <--+\n+     */\n+    let graph = TestGraph::new(0, &[\n+        (0, 1),\n+        (1, 2),\n+        (1, 3),\n+        (2, 0),\n+        (3, 2),\n+    ]);\n+    let sccs: Sccs<_, usize> = Sccs::new(&graph);\n+    assert_eq!(sccs.num_sccs(), 1);\n+}\n+\n+#[test]\n+fn test_three_sccs() {\n+    /*\n+    0\n+    |\n+    v\n++-> 1    3\n+|   |    |\n+|   v    |\n++-- 2 <--+\n+     */\n+    let graph = TestGraph::new(0, &[\n+        (0, 1),\n+        (1, 2),\n+        (2, 1),\n+        (3, 2),\n+    ]);\n+    let sccs: Sccs<_, usize> = Sccs::new(&graph);\n+    assert_eq!(sccs.num_sccs(), 3);\n+    assert_eq!(sccs.scc(0), 1);\n+    assert_eq!(sccs.scc(1), 0);\n+    assert_eq!(sccs.scc(2), 0);\n+    assert_eq!(sccs.scc(3), 2);\n+    assert_eq!(sccs.successors(0), &[]);\n+    assert_eq!(sccs.successors(1), &[0]);\n+    assert_eq!(sccs.successors(2), &[0]);\n+}\n+\n+#[test]\n+fn test_find_state_2() {\n+    // The order in which things will be visited is important to this\n+    // test. It tests part of the `find_state` behavior. Here is the\n+    // graph:\n+    //\n+    //\n+    //       /----+\n+    //     0 <--+ |\n+    //     |    | |\n+    //     v    | |\n+    // +-> 1 -> 3 4\n+    // |   |      |\n+    // |   v      |\n+    // +-- 2 <----+\n+\n+    let graph = TestGraph::new(0, &[\n+        (0, 1),\n+        (0, 4),\n+        (1, 2),\n+        (1, 3),\n+        (2, 1),\n+        (3, 0),\n+        (4, 2),\n+    ]);\n+\n+    // For this graph, we will start in our DFS by visiting:\n+    //\n+    // 0 -> 1 -> 2 -> 1\n+    //\n+    // and at this point detect a cycle. The state of 2 will thus be\n+    // `InCycleWith { 1 }`.  We will then visit the 1 -> 3 edge, which\n+    // will attempt to visit 0 as well, thus going to the state\n+    // `InCycleWith { 0 }`. Finally, node 1 will complete; the lowest\n+    // depth of any successor was 3 which had depth 0, and thus it\n+    // will be in the state `InCycleWith { 3 }`.\n+    //\n+    // When we finally traverse the `0 -> 4` edge and then visit node 2,\n+    // the states of the nodes are:\n+    //\n+    // 0 BeingVisited { 0 }\n+    // 1 InCycleWith { 3 }\n+    // 2 InCycleWith { 1 }\n+    // 3 InCycleWith { 0 }\n+    //\n+    // and hence 4 will traverse the links, finding an ultimate depth of 0.\n+    // If will also collapse the states to the following:\n+    //\n+    // 0 BeingVisited { 0 }\n+    // 1 InCycleWith { 3 }\n+    // 2 InCycleWith { 1 }\n+    // 3 InCycleWith { 0 }\n+\n+    let sccs: Sccs<_, usize> = Sccs::new(&graph);\n+    assert_eq!(sccs.num_sccs(), 1);\n+    assert_eq!(sccs.scc(0), 0);\n+    assert_eq!(sccs.scc(1), 0);\n+    assert_eq!(sccs.scc(2), 0);\n+    assert_eq!(sccs.scc(3), 0);\n+    assert_eq!(sccs.scc(4), 0);\n+    assert_eq!(sccs.successors(0), &[]);\n+}\n+\n+#[test]\n+fn test_find_state_3() {\n+    /*\n+      /----+\n+    0 <--+ |\n+    |    | |\n+    v    | |\n++-> 1 -> 3 4 5\n+|   |      | |\n+|   v      | |\n++-- 2 <----+-+\n+     */\n+    let graph = TestGraph::new(0, &[\n+        (0, 1),\n+        (0, 4),\n+        (1, 2),\n+        (1, 3),\n+        (2, 1),\n+        (3, 0),\n+        (4, 2),\n+        (5, 2),\n+    ]);\n+    let sccs: Sccs<_, usize> = Sccs::new(&graph);\n+    assert_eq!(sccs.num_sccs(), 2);\n+    assert_eq!(sccs.scc(0), 0);\n+    assert_eq!(sccs.scc(1), 0);\n+    assert_eq!(sccs.scc(2), 0);\n+    assert_eq!(sccs.scc(3), 0);\n+    assert_eq!(sccs.scc(4), 0);\n+    assert_eq!(sccs.scc(5), 1);\n+    assert_eq!(sccs.successors(0), &[]);\n+    assert_eq!(sccs.successors(1), &[0]);\n+}"}, {"sha": "48b654726b8f262e2a27d67f4f8b04e36dfd6958", "filename": "src/librustc_data_structures/graph/test.rs", "status": "renamed", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Fgraph%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Ftest.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -13,7 +13,7 @@ use std::cmp::max;\n use std::slice;\n use std::iter;\n \n-use super::{ControlFlowGraph, GraphPredecessors, GraphSuccessors};\n+use super::*;\n \n pub struct TestGraph {\n     num_nodes: usize,\n@@ -44,23 +44,31 @@ impl TestGraph {\n     }\n }\n \n-impl ControlFlowGraph for TestGraph {\n+impl DirectedGraph for TestGraph {\n     type Node = usize;\n+}\n \n+impl WithStartNode for TestGraph {\n     fn start_node(&self) -> usize {\n         self.start_node\n     }\n+}\n \n+impl WithNumNodes for TestGraph {\n     fn num_nodes(&self) -> usize {\n         self.num_nodes\n     }\n+}\n \n+impl WithPredecessors for TestGraph {\n     fn predecessors<'graph>(&'graph self,\n                             node: usize)\n                             -> <Self as GraphPredecessors<'graph>>::Iter {\n         self.predecessors[&node].iter().cloned()\n     }\n+}\n \n+impl WithSuccessors for TestGraph {\n     fn successors<'graph>(&'graph self, node: usize) -> <Self as GraphSuccessors<'graph>>::Iter {\n         self.successors[&node].iter().cloned()\n     }", "previous_filename": "src/librustc_data_structures/control_flow_graph/test.rs"}, {"sha": "26de2191090e3a8d70dc9dd2b789fa56aadc3b0e", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -14,6 +14,7 @@ use std::slice;\n use std::marker::PhantomData;\n use std::ops::{Index, IndexMut, Range, RangeBounds};\n use std::fmt;\n+use std::hash::Hash;\n use std::vec;\n use std::u32;\n \n@@ -22,7 +23,7 @@ use rustc_serialize as serialize;\n /// Represents some newtyped `usize` wrapper.\n ///\n /// (purpose: avoid mixing indexes for different bitvector domains.)\n-pub trait Idx: Copy + 'static + Eq + Debug {\n+pub trait Idx: Copy + 'static + Ord + Debug + Hash {\n     fn new(idx: usize) -> Self;\n     fn index(self) -> usize;\n }"}, {"sha": "508dc567fa01af71c632b569c5efe02c7a9b2524", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -61,7 +61,6 @@ pub mod small_vec;\n pub mod base_n;\n pub mod bitslice;\n pub mod bitvec;\n-pub mod graph;\n pub mod indexed_set;\n pub mod indexed_vec;\n pub mod obligation_forest;\n@@ -73,7 +72,7 @@ pub mod transitive_relation;\n pub use ena::unify;\n pub mod fx;\n pub mod tuple_slice;\n-pub mod control_flow_graph;\n+pub mod graph;\n pub mod flock;\n pub mod sync;\n pub mod owning_ref;"}, {"sha": "a78a2008eecc5087d0c22d03d87ddf67b96f0f1f", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -49,7 +49,9 @@ use rustc::dep_graph::debug::{DepNodeFilter, EdgeFilter};\n use rustc::hir::def_id::DefId;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::graph::{Direction, INCOMING, OUTGOING, NodeIndex};\n+use rustc_data_structures::graph::implementation::{\n+    Direction, INCOMING, OUTGOING, NodeIndex\n+};\n use rustc::hir;\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::ich::{ATTR_IF_THIS_CHANGED, ATTR_THEN_THIS_WOULD_NEED};"}, {"sha": "9c5203f43d23e8863874693f9f4a0b639905b57d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -23,7 +23,7 @@ use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n use rustc::ty::{self, ParamEnv, TyCtxt};\n \n-use rustc_data_structures::control_flow_graph::dominators::Dominators;\n+use rustc_data_structures::graph::dominators::Dominators;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;"}, {"sha": "68484888477c843400c60a734ce48fe1bd972ed4", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 3, "deletions": 139, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -13,14 +13,11 @@ use borrow_check::location::LocationTable;\n use borrow_check::nll::ToRegionVid;\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::RegionInferenceContext;\n-use borrow_check::nll::type_check::AtLocation;\n-use rustc::hir;\n use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n-use rustc::mir::Place::Projection;\n use rustc::mir::{BasicBlock, BasicBlockData, Location, Mir, Place, Rvalue};\n-use rustc::mir::{Local, PlaceProjection, ProjectionElem, Statement, Terminator};\n+use rustc::mir::{Local, Statement, Terminator};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, CanonicalTy, ClosureSubsts, GeneratorSubsts};\n@@ -41,7 +38,6 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n         regioncx,\n         location_table,\n         all_facts,\n-        mir,\n     };\n \n     cg.add_region_liveness_constraints_from_type_check(liveness_set_from_typeck);\n@@ -57,7 +53,6 @@ struct ConstraintGeneration<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n     all_facts: &'cg mut Option<AllFacts>,\n     location_table: &'cg LocationTable,\n     regioncx: &'cg mut RegionInferenceContext<'tcx>,\n-    mir: &'cg Mir<'tcx>,\n     borrow_set: &'cg BorrowSet<'tcx>,\n }\n \n@@ -184,41 +179,6 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n         self.super_terminator(block, terminator, location);\n     }\n \n-    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-        debug!(\"visit_rvalue(rvalue={:?}, location={:?})\", rvalue, location);\n-\n-        match rvalue {\n-            Rvalue::Ref(region, _borrow_kind, borrowed_place) => {\n-                // In some cases, e.g. when borrowing from an unsafe\n-                // place, we don't bother to create a loan, since\n-                // there are no conditions to validate.\n-                if let Some(all_facts) = self.all_facts {\n-                    if let Some(borrow_index) = self.borrow_set.location_map.get(&location) {\n-                        let region_vid = region.to_region_vid();\n-                        all_facts.borrow_region.push((\n-                            region_vid,\n-                            *borrow_index,\n-                            self.location_table.mid_index(location),\n-                        ));\n-                    }\n-                }\n-\n-                // Look for an rvalue like:\n-                //\n-                //     & L\n-                //\n-                // where L is the path that is borrowed. In that case, we have\n-                // to add the reborrow constraints (which don't fall out\n-                // naturally from the type-checker).\n-                self.add_reborrow_constraint(location, region, borrowed_place);\n-            }\n-\n-            _ => {}\n-        }\n-\n-        self.super_rvalue(rvalue, location);\n-    }\n-\n     fn visit_user_assert_ty(\n         &mut self,\n         _c_ty: &CanonicalTy<'tcx>,\n@@ -250,7 +210,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n         for (region, location) in liveness_set {\n             debug!(\"generate: {:#?} is live at {:#?}\", region, location);\n             let region_vid = regioncx.to_region_vid(region);\n-            regioncx.add_live_point(region_vid, *location);\n+            regioncx.add_live_element(region_vid, *location);\n         }\n \n         if let Some(all_facts) = all_facts {\n@@ -282,103 +242,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n             .tcx\n             .for_each_free_region(&live_ty, |live_region| {\n                 let vid = live_region.to_region_vid();\n-                self.regioncx.add_live_point(vid, location);\n+                self.regioncx.add_live_element(vid, location);\n             });\n     }\n-\n-    // Add the reborrow constraint at `location` so that `borrowed_place`\n-    // is valid for `borrow_region`.\n-    fn add_reborrow_constraint(\n-        &mut self,\n-        location: Location,\n-        borrow_region: ty::Region<'tcx>,\n-        borrowed_place: &Place<'tcx>,\n-    ) {\n-        let mut borrowed_place = borrowed_place;\n-\n-        debug!(\n-            \"add_reborrow_constraint({:?}, {:?}, {:?})\",\n-            location, borrow_region, borrowed_place\n-        );\n-        while let Projection(box PlaceProjection { base, elem }) = borrowed_place {\n-            debug!(\"add_reborrow_constraint - iteration {:?}\", borrowed_place);\n-\n-            match *elem {\n-                ProjectionElem::Deref => {\n-                    let tcx = self.infcx.tcx;\n-                    let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n-\n-                    debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n-                    match base_ty.sty {\n-                        ty::TyRef(ref_region, _, mutbl) => {\n-                            self.regioncx.add_outlives(\n-                                location.boring(),\n-                                ref_region.to_region_vid(),\n-                                borrow_region.to_region_vid(),\n-                            );\n-\n-                            if let Some(all_facts) = self.all_facts {\n-                                all_facts.outlives.push((\n-                                    ref_region.to_region_vid(),\n-                                    borrow_region.to_region_vid(),\n-                                    self.location_table.mid_index(location),\n-                                ));\n-                            }\n-\n-                            match mutbl {\n-                                hir::Mutability::MutImmutable => {\n-                                    // Immutable reference. We don't need the base\n-                                    // to be valid for the entire lifetime of\n-                                    // the borrow.\n-                                    break;\n-                                }\n-                                hir::Mutability::MutMutable => {\n-                                    // Mutable reference. We *do* need the base\n-                                    // to be valid, because after the base becomes\n-                                    // invalid, someone else can use our mutable deref.\n-\n-                                    // This is in order to make the following function\n-                                    // illegal:\n-                                    // ```\n-                                    // fn unsafe_deref<'a, 'b>(x: &'a &'b mut T) -> &'b mut T {\n-                                    //     &mut *x\n-                                    // }\n-                                    // ```\n-                                    //\n-                                    // As otherwise you could clone `&mut T` using the\n-                                    // following function:\n-                                    // ```\n-                                    // fn bad(x: &mut T) -> (&mut T, &mut T) {\n-                                    //     let my_clone = unsafe_deref(&'a x);\n-                                    //     ENDREGION 'a;\n-                                    //     (my_clone, x)\n-                                    // }\n-                                    // ```\n-                                }\n-                            }\n-                        }\n-                        ty::TyRawPtr(..) => {\n-                            // deref of raw pointer, guaranteed to be valid\n-                            break;\n-                        }\n-                        ty::TyAdt(def, _) if def.is_box() => {\n-                            // deref of `Box`, need the base to be valid - propagate\n-                        }\n-                        _ => bug!(\"unexpected deref ty {:?} in {:?}\", base_ty, borrowed_place),\n-                    }\n-                }\n-                ProjectionElem::Field(..)\n-                | ProjectionElem::Downcast(..)\n-                | ProjectionElem::Index(..)\n-                | ProjectionElem::ConstantIndex { .. }\n-                | ProjectionElem::Subslice { .. } => {\n-                    // other field access\n-                }\n-            }\n-\n-            // The \"propagate\" case. We need to check that our base is valid\n-            // for the borrow's lifetime.\n-            borrowed_place = base;\n-        }\n-    }\n }"}, {"sha": "45ed37a90efce39e0dab88b36e4e63182a09818e", "filename": "src/librustc_mir/borrow_check/nll/constraints/graph.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -0,0 +1,134 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::nll::constraints::{ConstraintIndex, ConstraintSet};\n+use rustc::ty::RegionVid;\n+use rustc_data_structures::graph;\n+use rustc_data_structures::indexed_vec::IndexVec;\n+\n+crate struct ConstraintGraph {\n+    first_constraints: IndexVec<RegionVid, Option<ConstraintIndex>>,\n+    next_constraints: IndexVec<ConstraintIndex, Option<ConstraintIndex>>,\n+}\n+\n+impl ConstraintGraph {\n+    /// Create a \"dependency graph\" where each region constraint `R1:\n+    /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n+    /// construct SCCs for region inference but also for error\n+    /// reporting.\n+    crate fn new(set: &ConstraintSet, num_region_vars: usize) -> Self {\n+        let mut first_constraints = IndexVec::from_elem_n(None, num_region_vars);\n+        let mut next_constraints = IndexVec::from_elem(None, &set.constraints);\n+\n+        for (idx, constraint) in set.constraints.iter_enumerated().rev() {\n+            let mut head = &mut first_constraints[constraint.sup];\n+            let mut next = &mut next_constraints[idx];\n+            debug_assert!(next.is_none());\n+            *next = *head;\n+            *head = Some(idx);\n+        }\n+\n+        Self {\n+            first_constraints,\n+            next_constraints,\n+        }\n+    }\n+\n+    /// Given a region `R`, iterate over all constraints `R: R1`.\n+    crate fn outgoing_edges(&self, region_sup: RegionVid) -> Edges<'_> {\n+        let first = self.first_constraints[region_sup];\n+        Edges {\n+            graph: self,\n+            pointer: first,\n+        }\n+    }\n+}\n+\n+crate struct Edges<'s> {\n+    graph: &'s ConstraintGraph,\n+    pointer: Option<ConstraintIndex>,\n+}\n+\n+impl<'s> Iterator for Edges<'s> {\n+    type Item = ConstraintIndex;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if let Some(p) = self.pointer {\n+            self.pointer = self.graph.next_constraints[p];\n+            Some(p)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+crate struct RegionGraph<'s> {\n+    set: &'s ConstraintSet,\n+    constraint_graph: &'s ConstraintGraph,\n+}\n+\n+impl<'s> RegionGraph<'s> {\n+    /// Create a \"dependency graph\" where each region constraint `R1:\n+    /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n+    /// construct SCCs for region inference but also for error\n+    /// reporting.\n+    crate fn new(set: &'s ConstraintSet, constraint_graph: &'s ConstraintGraph) -> Self {\n+        Self {\n+            set,\n+            constraint_graph,\n+        }\n+    }\n+\n+    /// Given a region `R`, iterate over all regions `R1` such that\n+    /// there exists a constraint `R: R1`.\n+    crate fn sub_regions(&self, region_sup: RegionVid) -> Successors<'_> {\n+        Successors {\n+            set: self.set,\n+            edges: self.constraint_graph.outgoing_edges(region_sup),\n+        }\n+    }\n+}\n+\n+crate struct Successors<'s> {\n+    set: &'s ConstraintSet,\n+    edges: Edges<'s>,\n+}\n+\n+impl<'s> Iterator for Successors<'s> {\n+    type Item = RegionVid;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.edges.next().map(|c| self.set[c].sub)\n+    }\n+}\n+\n+impl<'s> graph::DirectedGraph for RegionGraph<'s> {\n+    type Node = RegionVid;\n+}\n+\n+impl<'s> graph::WithNumNodes for RegionGraph<'s> {\n+    fn num_nodes(&self) -> usize {\n+        self.constraint_graph.first_constraints.len()\n+    }\n+}\n+\n+impl<'s> graph::WithSuccessors for RegionGraph<'s> {\n+    fn successors<'graph>(\n+        &'graph self,\n+        node: Self::Node,\n+    ) -> <Self as graph::GraphSuccessors<'graph>>::Iter {\n+        self.sub_regions(node)\n+    }\n+}\n+\n+impl<'s, 'graph> graph::GraphSuccessors<'graph> for RegionGraph<'s> {\n+    type Item = RegionVid;\n+    type Iter = Successors<'graph>;\n+}"}, {"sha": "597241234cdd5227a574c8cd7395f52f7037ec91", "filename": "src/librustc_mir/borrow_check/nll/constraints/mod.rs", "status": "renamed", "additions": 24, "deletions": 41, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -9,21 +9,24 @@\n // except according to those terms.\n \n use rustc::ty::RegionVid;\n+use rustc_data_structures::graph::scc::Sccs;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use borrow_check::nll::type_check::Locations;\n \n use std::fmt;\n use std::ops::Deref;\n \n+crate mod graph;\n+\n #[derive(Clone, Default)]\n crate struct ConstraintSet {\n     constraints: IndexVec<ConstraintIndex, OutlivesConstraint>,\n }\n \n impl ConstraintSet {\n-    pub fn push(&mut self, constraint: OutlivesConstraint) {\n+    crate fn push(&mut self, constraint: OutlivesConstraint) {\n         debug!(\n-            \"add_outlives({:?}: {:?} @ {:?})\",\n+            \"ConstraintSet::push({:?}: {:?} @ {:?}\",\n             constraint.sup, constraint.sub, constraint.locations\n         );\n         if constraint.sup == constraint.sub {\n@@ -33,44 +36,32 @@ impl ConstraintSet {\n         self.constraints.push(constraint);\n     }\n \n-    /// Once all constraints have been added, `link()` is used to thread together the constraints\n-    /// based on which would be affected when a particular region changes. See the next field of\n-    /// `OutlivesContraint` for more details.\n-    /// link returns a map that is needed later by `each_affected_by_dirty`.\n-    pub fn link(&mut self, len: usize) -> IndexVec<RegionVid, Option<ConstraintIndex>> {\n-        let mut map = IndexVec::from_elem_n(None, len);\n-\n-        for (idx, constraint) in self.constraints.iter_enumerated_mut().rev() {\n-            let mut head = &mut map[constraint.sub];\n-            debug_assert!(constraint.next.is_none());\n-            constraint.next = *head;\n-            *head = Some(idx);\n-        }\n-\n-        map\n+    /// Constructs a graph from the constraint set; the graph makes it\n+    /// easy to find the constraints affecting a particular region\n+    /// (you should not mutate the set once this graph is\n+    /// constructed).\n+    crate fn graph(&self, num_region_vars: usize) -> graph::ConstraintGraph {\n+        graph::ConstraintGraph::new(self, num_region_vars)\n     }\n \n-    /// When a region R1 changes, we need to reprocess all constraints R2: R1 to take into account\n-    /// any new elements that R1 now has. This method will quickly enumerate all such constraints\n-    /// (that is, constraints where R1 is in the \"subregion\" position).\n-    /// To use it, invoke with `map[R1]` where map is the map returned by `link`;\n-    /// the callback op will be invoked for each affected constraint.\n-    pub fn each_affected_by_dirty(\n+    /// Compute cycles (SCCs) in the graph of regions. In particular,\n+    /// find all regions R1, R2 such that R1: R2 and R2: R1 and group\n+    /// them into an SCC, and find the relationships between SCCs.\n+    crate fn compute_sccs(\n         &self,\n-        mut opt_dep_idx: Option<ConstraintIndex>,\n-        mut op: impl FnMut(ConstraintIndex),\n-    ) {\n-        while let Some(dep_idx) = opt_dep_idx {\n-            op(dep_idx);\n-            opt_dep_idx = self.constraints[dep_idx].next;\n-        }\n+        constraint_graph: &graph::ConstraintGraph,\n+    ) -> Sccs<RegionVid, ConstraintSccIndex> {\n+        let region_graph = &graph::RegionGraph::new(self, constraint_graph);\n+        Sccs::new(region_graph)\n     }\n }\n \n impl Deref for ConstraintSet {\n     type Target = IndexVec<ConstraintIndex, OutlivesConstraint>;\n \n-    fn deref(&self) -> &Self::Target { &self.constraints }\n+    fn deref(&self) -> &Self::Target {\n+        &self.constraints\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -85,16 +76,6 @@ pub struct OutlivesConstraint {\n     /// Region that must be outlived.\n     pub sub: RegionVid,\n \n-    /// Later on, we thread the constraints onto a linked list\n-    /// grouped by their `sub` field. So if you had:\n-    ///\n-    /// Index | Constraint | Next Field\n-    /// ----- | ---------- | ----------\n-    /// 0     | `'a: 'b`   | Some(2)\n-    /// 1     | `'b: 'c`   | None\n-    /// 2     | `'c: 'b`   | None\n-    pub next: Option<ConstraintIndex>,\n-\n     /// Where did this constraint arise?\n     pub locations: Locations,\n }\n@@ -110,3 +91,5 @@ impl fmt::Debug for OutlivesConstraint {\n }\n \n newtype_index!(ConstraintIndex { DEBUG_FORMAT = \"ConstraintIndex({})\" });\n+\n+newtype_index!(ConstraintSccIndex { DEBUG_FORMAT = \"ConstraintSccIndex({})\" });", "previous_filename": "src/librustc_mir/borrow_check/nll/constraint_set.rs"}, {"sha": "9fd9d6cd97c597e193c9fe42027cdf35645f29e4", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/find_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -57,7 +57,7 @@ impl<'cx, 'gcx, 'tcx> UseFinder<'cx, 'gcx, 'tcx> {\n \n         queue.push_back(self.start_point);\n         while let Some(p) = queue.pop_front() {\n-            if !self.regioncx.region_contains_point(self.region_vid, p) {\n+            if !self.regioncx.region_contains(self.region_vid, p) {\n                 continue;\n             }\n "}, {"sha": "301999cc4a51e120755a6755cde8d6d6a1e07cae", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -29,7 +29,7 @@ use rustc::mir::{Terminator, TerminatorKind};\n use rustc::mir::{Field, Operand, BorrowKind};\n use rustc::ty::{self, ParamEnv};\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_data_structures::control_flow_graph::dominators::Dominators;\n+use rustc_data_structures::graph::dominators::Dominators;\n \n pub(super) fn generate_invalidates<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,"}, {"sha": "acd9223e42545c40453e49f78377eb415ecd4df4", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -45,7 +45,7 @@ mod renumber;\n crate mod type_check;\n mod universal_regions;\n \n-crate mod constraint_set;\n+mod constraints;\n \n use self::facts::AllFacts;\n use self::region_infer::RegionInferenceContext;\n@@ -108,6 +108,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         def_id,\n         &universal_regions,\n         location_table,\n+        borrow_set,\n         &liveness,\n         &mut all_facts,\n         flow_inits,\n@@ -294,8 +295,15 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n     // Also dump the inference graph constraints as a graphviz file.\n     let _: io::Result<()> = do catch {\n         let mut file =\n-            pretty::create_dump_file(infcx.tcx, \"regioncx.dot\", None, \"nll\", &0, source)?;\n-        regioncx.dump_graphviz(&mut file)?;\n+            pretty::create_dump_file(infcx.tcx, \"regioncx.all.dot\", None, \"nll\", &0, source)?;\n+        regioncx.dump_graphviz_raw_constraints(&mut file)?;\n+    };\n+\n+    // Also dump the inference graph constraints as a graphviz file.\n+    let _: io::Result<()> = do catch {\n+        let mut file =\n+            pretty::create_dump_file(infcx.tcx, \"regioncx.scc.dot\", None, \"nll\", &0, source)?;\n+        regioncx.dump_graphviz_scc_constraints(&mut file)?;\n     };\n }\n "}, {"sha": "3c73203706dcb633f019328719ea51c2be7a647e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -83,7 +83,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 sup,\n                 sub,\n                 locations,\n-                next: _,\n             } = constraint;\n             with_msg(&format!(\n                 \"{:?}: {:?} due to {:?}\","}, {"sha": "c1b73fac893888f35e574edae22a167fd17fc9e7", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -50,18 +50,10 @@ impl fmt::Display for ConstraintCategory {\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Walks the graph of constraints (where `'a: 'b` is considered\n-    /// an edge `'b -> 'a`) to find all paths from `from_region` to\n+    /// an edge `'a -> 'b`) to find all paths from `from_region` to\n     /// `to_region`. The paths are accumulated into the vector\n     /// `results`. The paths are stored as a series of\n     /// `ConstraintIndex` values -- in other words, a list of *edges*.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `from_region`\n-    /// When reporting an error, it is useful to be able to determine\n-    /// which constraints influenced the region being reported as an\n-    /// error. This function finds all of the paths from the\n-    /// constraint.\n     fn find_constraint_paths_between_regions(\n         &self,\n         from_region: RegionVid,\n@@ -89,8 +81,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         stack: &mut Vec<ConstraintIndex>,\n         results: &mut Vec<Vec<ConstraintIndex>>,\n     ) {\n-        let dependency_map = self.dependency_map.as_ref().unwrap();\n-\n         // Check if we already visited this region.\n         if !visited.insert(current_region) {\n             return;\n@@ -99,26 +89,25 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Check if we reached the region we were looking for.\n         if target_test(current_region) {\n             if !stack.is_empty() {\n-                assert_eq!(self.constraints[stack[0]].sub, from_region);\n+                assert_eq!(self.constraints[stack[0]].sup, from_region);\n                 results.push(stack.clone());\n             }\n             return;\n         }\n \n-        self.constraints\n-            .each_affected_by_dirty(dependency_map[current_region], |constraint| {\n-                assert_eq!(self.constraints[constraint].sub, current_region);\n-                stack.push(constraint);\n-                self.find_constraint_paths_between_regions_helper(\n-                    from_region,\n-                    self.constraints[constraint].sup,\n-                    target_test,\n-                    visited,\n-                    stack,\n-                    results,\n-                );\n-                stack.pop();\n-            });\n+        for constraint in self.constraint_graph.outgoing_edges(current_region) {\n+            assert_eq!(self.constraints[constraint].sup, current_region);\n+            stack.push(constraint);\n+            self.find_constraint_paths_between_regions_helper(\n+                from_region,\n+                self.constraints[constraint].sub,\n+                target_test,\n+                visited,\n+                stack,\n+                results,\n+            );\n+            stack.pop();\n+        }\n     }\n \n     /// This function will return true if a constraint is interesting and false if a constraint\n@@ -210,7 +199,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n \n         // Find all paths\n-        let constraint_paths = self.find_constraint_paths_between_regions(outlived_fr, |r| r == fr);\n+        let constraint_paths = self.find_constraint_paths_between_regions(fr, |r| r == outlived_fr);\n         debug!(\"report_error: constraint_paths={:#?}\", constraint_paths);\n \n         // Find the shortest such path.\n@@ -319,7 +308,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         while changed {\n             changed = false;\n-            for constraint in &*self.constraints {\n+            for constraint in self.constraints.iter() {\n                 if let Some(n) = result_set[constraint.sup] {\n                     let m = n + 1;\n                     if result_set[constraint.sub]"}, {"sha": "13d754f5cab5c2c6877b1e3ad15bdafa98539ace", "filename": "src/librustc_mir/borrow_check/nll/region_infer/graphviz.rs", "status": "modified", "additions": 90, "deletions": 12, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -12,22 +12,40 @@\n //! libgraphviz traits, specialized to attaching borrowck analysis\n //! data to rendered labels.\n \n+use super::*;\n+use borrow_check::nll::constraints::OutlivesConstraint;\n use dot::{self, IntoCow};\n use rustc_data_structures::indexed_vec::Idx;\n use std::borrow::Cow;\n use std::io::{self, Write};\n-use super::*;\n-use borrow_check::nll::constraint_set::OutlivesConstraint;\n-\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Write out the region constraint graph.\n-    pub(crate) fn dump_graphviz(&self, mut w: &mut dyn Write) -> io::Result<()> {\n-        dot::render(self, &mut w)\n+    crate fn dump_graphviz_raw_constraints(&self, mut w: &mut dyn Write) -> io::Result<()> {\n+        dot::render(&RawConstraints { regioncx: self }, &mut w)\n+    }\n+\n+    /// Write out the region constraint graph.\n+    crate fn dump_graphviz_scc_constraints(&self, mut w: &mut dyn Write) -> io::Result<()> {\n+        let mut nodes_per_scc: IndexVec<ConstraintSccIndex, _> = self.constraint_sccs\n+            .all_sccs()\n+            .map(|_| Vec::new())\n+            .collect();\n+\n+        for region in self.definitions.indices() {\n+            let scc = self.constraint_sccs.scc(region);\n+            nodes_per_scc[scc].push(region);\n+        }\n+\n+        dot::render(&SccConstraints { regioncx: self, nodes_per_scc }, &mut w)\n     }\n }\n \n-impl<'this, 'tcx> dot::Labeller<'this> for RegionInferenceContext<'tcx> {\n+struct RawConstraints<'a, 'tcx: 'a> {\n+    regioncx: &'a RegionInferenceContext<'tcx>,\n+}\n+\n+impl<'a, 'this, 'tcx> dot::Labeller<'this> for RawConstraints<'a, 'tcx> {\n     type Node = RegionVid;\n     type Edge = OutlivesConstraint;\n \n@@ -48,26 +66,86 @@ impl<'this, 'tcx> dot::Labeller<'this> for RegionInferenceContext<'tcx> {\n     }\n }\n \n-impl<'this, 'tcx> dot::GraphWalk<'this> for RegionInferenceContext<'tcx> {\n+impl<'a, 'this, 'tcx> dot::GraphWalk<'this> for RawConstraints<'a, 'tcx> {\n     type Node = RegionVid;\n     type Edge = OutlivesConstraint;\n \n     fn nodes(&'this self) -> dot::Nodes<'this, RegionVid> {\n-        let vids: Vec<RegionVid> = self.definitions.indices().collect();\n+        let vids: Vec<RegionVid> = self.regioncx.definitions.indices().collect();\n         vids.into_cow()\n     }\n     fn edges(&'this self) -> dot::Edges<'this, OutlivesConstraint> {\n-        (&self.constraints.raw[..]).into_cow()\n+        (&self.regioncx.constraints.raw[..]).into_cow()\n     }\n \n-    // Render `a: b` as `a <- b`, indicating the flow\n+    // Render `a: b` as `a -> b`, indicating the flow\n     // of data during inference.\n \n     fn source(&'this self, edge: &OutlivesConstraint) -> RegionVid {\n-        edge.sub\n+        edge.sup\n     }\n \n     fn target(&'this self, edge: &OutlivesConstraint) -> RegionVid {\n-        edge.sup\n+        edge.sub\n+    }\n+}\n+\n+struct SccConstraints<'a, 'tcx: 'a> {\n+    regioncx: &'a RegionInferenceContext<'tcx>,\n+    nodes_per_scc: IndexVec<ConstraintSccIndex, Vec<RegionVid>>,\n+}\n+\n+impl<'a, 'this, 'tcx> dot::Labeller<'this> for SccConstraints<'a, 'tcx> {\n+    type Node = ConstraintSccIndex;\n+    type Edge = (ConstraintSccIndex, ConstraintSccIndex);\n+\n+    fn graph_id(&'this self) -> dot::Id<'this> {\n+        dot::Id::new(format!(\"RegionInferenceContext\")).unwrap()\n+    }\n+    fn node_id(&'this self, n: &ConstraintSccIndex) -> dot::Id<'this> {\n+        dot::Id::new(format!(\"r{}\", n.index())).unwrap()\n+    }\n+    fn node_shape(&'this self, _node: &ConstraintSccIndex) -> Option<dot::LabelText<'this>> {\n+        Some(dot::LabelText::LabelStr(Cow::Borrowed(\"box\")))\n+    }\n+    fn node_label(&'this self, n: &ConstraintSccIndex) -> dot::LabelText<'this> {\n+        let nodes = &self.nodes_per_scc[*n];\n+        dot::LabelText::LabelStr(format!(\"{:?} = {:?}\", n, nodes).into_cow())\n+    }\n+}\n+\n+impl<'a, 'this, 'tcx> dot::GraphWalk<'this> for SccConstraints<'a, 'tcx> {\n+    type Node = ConstraintSccIndex;\n+    type Edge = (ConstraintSccIndex, ConstraintSccIndex);\n+\n+    fn nodes(&'this self) -> dot::Nodes<'this, ConstraintSccIndex> {\n+        let vids: Vec<ConstraintSccIndex> = self.regioncx.constraint_sccs.all_sccs().collect();\n+        vids.into_cow()\n+    }\n+    fn edges(&'this self) -> dot::Edges<'this, (ConstraintSccIndex, ConstraintSccIndex)> {\n+        let edges: Vec<_> = self.regioncx\n+            .constraint_sccs\n+            .all_sccs()\n+            .flat_map(|scc_a| {\n+                self.regioncx\n+                    .constraint_sccs\n+                    .successors(scc_a)\n+                    .iter()\n+                    .map(move |&scc_b| (scc_a, scc_b))\n+            })\n+            .collect();\n+\n+        edges.into_cow()\n+    }\n+\n+    // Render `a: b` as `a -> b`, indicating the flow\n+    // of data during inference.\n+\n+    fn source(&'this self, edge: &(ConstraintSccIndex, ConstraintSccIndex)) -> ConstraintSccIndex {\n+        edge.0\n+    }\n+\n+    fn target(&'this self, edge: &(ConstraintSccIndex, ConstraintSccIndex)) -> ConstraintSccIndex {\n+        edge.1\n     }\n }"}, {"sha": "369f6bd36f84603538ee34db60c3f099c5346385", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 129, "deletions": 144, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -9,7 +9,11 @@\n // except according to those terms.\n \n use super::universal_regions::UniversalRegions;\n-use borrow_check::nll::constraint_set::{ConstraintIndex, ConstraintSet, OutlivesConstraint};\n+use borrow_check::nll::constraints::{\n+    ConstraintIndex, ConstraintSccIndex, ConstraintSet, OutlivesConstraint,\n+};\n+use borrow_check::nll::constraints::graph::ConstraintGraph;\n+use borrow_check::nll::region_infer::values::ToElementIndex;\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n@@ -23,8 +27,9 @@ use rustc::mir::{\n };\n use rustc::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common;\n-use rustc_data_structures::bitvec::BitVector;\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::graph::scc::Sccs;\n+use rustc_data_structures::indexed_set::{IdxSet, IdxSetBuf};\n+use rustc_data_structures::indexed_vec::IndexVec;\n \n use std::rc::Rc;\n \n@@ -51,28 +56,31 @@ pub struct RegionInferenceContext<'tcx> {\n     /// regions, these start out empty and steadily grow, though for\n     /// each universally quantified region R they start out containing\n     /// the entire CFG and `end(R)`.\n-    liveness_constraints: RegionValues,\n+    liveness_constraints: RegionValues<RegionVid>,\n \n-    /// The final inferred values of the inference variables; `None`\n-    /// until `solve` is invoked.\n-    inferred_values: Option<RegionValues>,\n+    /// The outlives constraints computed by the type-check.\n+    constraints: Rc<ConstraintSet>,\n \n-    /// For each variable, stores the index of the first constraint\n-    /// where that variable appears on the RHS. This is the start of a\n-    /// 'linked list' threaded by the `next` field in `Constraint`.\n-    ///\n-    /// This map is build when values are inferred.\n-    dependency_map: Option<IndexVec<RegionVid, Option<ConstraintIndex>>>,\n+    /// The constraint-set, but in graph form, making it easy to traverse\n+    /// the constraints adjacent to a particular region. Used to construct\n+    /// the SCC (see `constraint_sccs`) and for error reporting.\n+    constraint_graph: Rc<ConstraintGraph>,\n+\n+    /// The SCC computed from `constraints` and\n+    /// `constraint_graph`. Used to compute the values of each region.\n+    constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n \n-    /// The constraints we have accumulated and used during solving.\n-    constraints: ConstraintSet,\n+    /// The final inferred values of the region variables; we compute\n+    /// one value per SCC. To get the value for any given *region*,\n+    /// you first find which scc it is a part of.\n+    scc_values: RegionValues<ConstraintSccIndex>,\n \n     /// Type constraints that we check after solving.\n     type_tests: Vec<TypeTest<'tcx>>,\n \n     /// Information about the universally quantified regions in scope\n     /// on this function and their (known) relations to one another.\n-    universal_regions: UniversalRegions<'tcx>,\n+    universal_regions: Rc<UniversalRegions<'tcx>>,\n }\n \n struct RegionDefinition<'tcx> {\n@@ -203,27 +211,32 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         outlives_constraints: ConstraintSet,\n         type_tests: Vec<TypeTest<'tcx>>,\n     ) -> Self {\n-        // The `next` field should not yet have been initialized:\n-        debug_assert!(outlives_constraints.iter().all(|c| c.next.is_none()));\n-\n+        let universal_regions = Rc::new(universal_regions);\n         let num_region_variables = var_infos.len();\n         let num_universal_regions = universal_regions.len();\n \n         let elements = &Rc::new(RegionValueElements::new(mir, num_universal_regions));\n \n         // Create a RegionDefinition for each inference variable.\n-        let definitions = var_infos\n+        let definitions: IndexVec<_, _> = var_infos\n             .into_iter()\n             .map(|info| RegionDefinition::new(info.origin))\n             .collect();\n \n+        let constraints = Rc::new(outlives_constraints); // freeze constraints\n+        let constraint_graph = Rc::new(constraints.graph(definitions.len()));\n+        let constraint_sccs = Rc::new(constraints.compute_sccs(&constraint_graph));\n+\n+        let scc_values = RegionValues::new(elements, constraint_sccs.num_sccs());\n+\n         let mut result = Self {\n             definitions,\n             elements: elements.clone(),\n             liveness_constraints: RegionValues::new(elements, num_region_variables),\n-            inferred_values: None,\n-            dependency_map: None,\n-            constraints: outlives_constraints,\n+            constraints,\n+            constraint_sccs,\n+            constraint_graph,\n+            scc_values,\n             type_tests,\n             universal_regions,\n         };\n@@ -265,7 +278,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n \n         // For each universally quantified region X:\n-        for variable in self.universal_regions.universal_regions() {\n+        let elements = self.elements.clone();\n+        let universal_regions = self.universal_regions.clone();\n+        for variable in universal_regions.universal_regions() {\n             // These should be free-region variables.\n             assert!(match self.definitions[variable].origin {\n                 RegionVariableOrigin::NLL(NLLRegionVariableOrigin::FreeRegion) => true,\n@@ -275,12 +290,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.definitions[variable].is_universal = true;\n \n             // Add all nodes in the CFG to liveness constraints\n-            for point_index in self.elements.all_point_indices() {\n-                self.liveness_constraints.add_element(variable, point_index);\n+            for point_index in elements.all_point_indices() {\n+                self.add_live_element(variable, point_index);\n             }\n \n             // Add `end(X)` into the set for X.\n-            self.liveness_constraints.add_element(variable, variable);\n+            self.add_live_element(variable, variable);\n         }\n     }\n \n@@ -300,48 +315,38 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Returns true if the region `r` contains the point `p`.\n     ///\n     /// Panics if called before `solve()` executes,\n-    pub fn region_contains_point<R>(&self, r: R, p: Location) -> bool\n-    where\n-        R: ToRegionVid,\n-    {\n-        let inferred_values = self\n-            .inferred_values\n-            .as_ref()\n-            .expect(\"region values not yet inferred\");\n-        inferred_values.contains(r.to_region_vid(), p)\n+    crate fn region_contains(&self, r: impl ToRegionVid, p: impl ToElementIndex) -> bool {\n+        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        self.scc_values.contains(scc, p)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n     crate fn region_value_str(&self, r: RegionVid) -> String {\n-        let inferred_values = self\n-            .inferred_values\n-            .as_ref()\n-            .expect(\"region values not yet inferred\");\n-\n-        inferred_values.region_value_str(r)\n+        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        self.scc_values.region_value_str(scc)\n     }\n \n     /// Indicates that the region variable `v` is live at the point `point`.\n     ///\n     /// Returns `true` if this constraint is new and `false` is the\n     /// constraint was already present.\n-    pub(super) fn add_live_point(&mut self, v: RegionVid, point: Location) -> bool {\n-        debug!(\"add_live_point({:?}, {:?})\", v, point);\n-        assert!(self.inferred_values.is_none(), \"values already inferred\");\n+    pub(super) fn add_live_element(\n+        &mut self,\n+        v: RegionVid,\n+        elem: impl ToElementIndex,\n+    ) -> bool {\n+        debug!(\"add_live_element({:?}, {:?})\", v, elem);\n \n-        let element = self.elements.index(point);\n-        self.liveness_constraints.add_element(v, element)\n-    }\n+        // Add to the liveness values for `v`...\n+        if self.liveness_constraints.add_element(v, elem) {\n+            // ...but also add to the SCC in which `v` appears.\n+            let scc = self.constraint_sccs.scc(v);\n+            self.scc_values.add_element(scc, elem);\n \n-    /// Indicates that the region variable `sup` must outlive `sub` is live at the point `point`.\n-    pub(super) fn add_outlives(&mut self, locations: Locations, sup: RegionVid, sub: RegionVid) {\n-        assert!(self.inferred_values.is_none(), \"values already inferred\");\n-        self.constraints.push(OutlivesConstraint {\n-            locations,\n-            sup,\n-            sub,\n-            next: None,\n-        })\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     /// Perform region inference and report errors if we see any\n@@ -366,8 +371,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir: &Mir<'tcx>,\n         mir_def_id: DefId,\n     ) -> Option<ClosureRegionRequirements<'gcx>> {\n-        assert!(self.inferred_values.is_none(), \"values already inferred\");\n-\n         self.propagate_constraints(mir);\n \n         // If this is a closure, we can propagate unsatisfied\n@@ -402,65 +405,62 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n-    fn propagate_constraints(&mut self, mir: &Mir<'tcx>) {\n-        self.dependency_map = Some(self.build_dependency_map());\n-        let inferred_values = self.compute_region_values(mir);\n-        self.inferred_values = Some(inferred_values);\n-    }\n+    fn propagate_constraints(&mut self, _mir: &Mir<'tcx>) {\n+        debug!(\"propagate_constraints()\");\n \n-    fn compute_region_values(&self, _mir: &Mir<'tcx>) -> RegionValues {\n-        debug!(\"compute_region_values()\");\n-        debug!(\"compute_region_values: constraints={:#?}\", {\n+        debug!(\"propagate_constraints: constraints={:#?}\", {\n             let mut constraints: Vec<_> = self.constraints.iter().collect();\n             constraints.sort();\n             constraints\n         });\n \n-        // The initial values for each region are derived from the liveness\n-        // constraints we have accumulated.\n-        let mut inferred_values = self.liveness_constraints.clone();\n-\n-        let dependency_map = self.dependency_map.as_ref().unwrap();\n-\n-        // Constraints that may need to be repropagated (initially all):\n-        let mut dirty_list: Vec<_> = self.constraints.indices().collect();\n-\n-        // Set to 0 for each constraint that is on the dirty list:\n-        let mut clean_bit_vec = BitVector::new(dirty_list.len());\n+        // To propagate constriants, we walk the DAG induced by the\n+        // SCC. For each SCC, we visit its successors and compute\n+        // their values, then we union all those values to get our\n+        // own.\n+        let visited = &mut IdxSetBuf::new_empty(self.constraint_sccs.num_sccs());\n+        for scc_index in self.constraint_sccs.all_sccs() {\n+            self.propagate_constraint_sccs_if_new(scc_index, visited);\n+        }\n+    }\n \n-        debug!(\"propagate_constraints: --------------------\");\n-        while let Some(constraint_idx) = dirty_list.pop() {\n-            clean_bit_vec.insert(constraint_idx.index());\n+    #[inline]\n+    fn propagate_constraint_sccs_if_new(\n+        &mut self,\n+        scc_a: ConstraintSccIndex,\n+        visited: &mut IdxSet<ConstraintSccIndex>,\n+    ) {\n+        if visited.add(&scc_a) {\n+            self.propagate_constraint_sccs_new(scc_a, visited);\n+        }\n+    }\n \n-            let constraint = &self.constraints[constraint_idx];\n-            debug!(\"propagate_constraints: constraint={:?}\", constraint);\n+    fn propagate_constraint_sccs_new(\n+        &mut self,\n+        scc_a: ConstraintSccIndex,\n+        visited: &mut IdxSet<ConstraintSccIndex>,\n+    ) {\n+        let constraint_sccs = self.constraint_sccs.clone();\n \n-            if inferred_values.add_region(constraint.sup, constraint.sub) {\n-                debug!(\"propagate_constraints:   sub={:?}\", constraint.sub);\n-                debug!(\"propagate_constraints:   sup={:?}\", constraint.sup);\n+        // Walk each SCC `B` such that `A: B`...\n+        for &scc_b in constraint_sccs.successors(scc_a) {\n+            debug!(\n+                \"propagate_constraint_sccs: scc_a = {:?} scc_b = {:?}\",\n+                scc_a, scc_b\n+            );\n \n-                self.constraints.each_affected_by_dirty(\n-                    dependency_map[constraint.sup],\n-                    |dep_idx| {\n-                        if clean_bit_vec.remove(dep_idx.index()) {\n-                            dirty_list.push(dep_idx);\n-                        }\n-                    },\n-                );\n-            }\n+            // ...compute the value of `B`...\n+            self.propagate_constraint_sccs_if_new(scc_b, visited);\n \n-            debug!(\"\\n\");\n+            // ...and add elements from `B` into `A`.\n+            self.scc_values.add_region(scc_a, scc_b);\n         }\n \n-        inferred_values\n-    }\n-\n-    /// Builds up a map from each region variable X to a vector with the\n-    /// indices of constraints that need to be re-evaluated when X changes.\n-    /// These are constraints like Y: X @ P -- so if X changed, we may\n-    /// need to grow Y.\n-    fn build_dependency_map(&mut self) -> IndexVec<RegionVid, Option<ConstraintIndex>> {\n-        self.constraints.link(self.definitions.len())\n+        debug!(\n+            \"propagate_constraint_sccs: scc_a = {:?} has value {:?}\",\n+            scc_a,\n+            self.scc_values.region_value_str(scc_a),\n+        );\n     }\n \n     /// Once regions have been propagated, this method is used to see\n@@ -535,12 +535,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         if self.universal_regions.is_universal_region(r) {\n             return self.definitions[r].external_name;\n         } else {\n-            let inferred_values = self\n-                .inferred_values\n-                .as_ref()\n-                .expect(\"region values not yet inferred\");\n+            let r_scc = self.constraint_sccs.scc(r);\n             let upper_bound = self.universal_upper_bound(r);\n-            if inferred_values.contains(r, upper_bound) {\n+            if self.scc_values.contains(r_scc, upper_bound) {\n                 self.to_error_region(upper_bound)\n             } else {\n                 None\n@@ -575,11 +572,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // region, which ensures it can be encoded in a `ClosureOutlivesRequirement`.\n         let lower_bound_plus = self.non_local_universal_upper_bound(*lower_bound);\n         assert!(self.universal_regions.is_universal_region(lower_bound_plus));\n-        assert!(\n-            !self\n-                .universal_regions\n-                .is_local_free_region(lower_bound_plus)\n-        );\n+        assert!(!self.universal_regions\n+            .is_local_free_region(lower_bound_plus));\n \n         propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n             subject,\n@@ -607,10 +601,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Option<ClosureOutlivesSubject<'gcx>> {\n         let tcx = infcx.tcx;\n         let gcx = tcx.global_tcx();\n-        let inferred_values = self\n-            .inferred_values\n-            .as_ref()\n-            .expect(\"region values not yet inferred\");\n \n         debug!(\"try_promote_type_test_subject(ty = {:?})\", ty);\n \n@@ -653,7 +643,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // `'static` is not contained in `r`, we would fail to\n             // find an equivalent.\n             let upper_bound = self.non_local_universal_upper_bound(region_vid);\n-            if inferred_values.contains(region_vid, upper_bound) {\n+            if self.region_contains(region_vid, upper_bound) {\n                 tcx.mk_region(ty::ReClosureBound(upper_bound))\n             } else {\n                 // In the case of a failure, use a `ReVar`\n@@ -686,12 +676,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// except that it converts further takes the non-local upper\n     /// bound of `'y`, so that the final result is non-local.\n     fn non_local_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n-        let inferred_values = self.inferred_values.as_ref().unwrap();\n-\n         debug!(\n             \"non_local_universal_upper_bound(r={:?}={})\",\n             r,\n-            inferred_values.region_value_str(r)\n+            self.region_value_str(r)\n         );\n \n         let lub = self.universal_upper_bound(r);\n@@ -723,18 +711,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// - For each `end('x)` element in `'r`, compute the mutual LUB, yielding\n     ///   a result `'y`.\n     fn universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n-        let inferred_values = self.inferred_values.as_ref().unwrap();\n-\n         debug!(\n             \"universal_upper_bound(r={:?}={})\",\n             r,\n-            inferred_values.region_value_str(r)\n+            self.region_value_str(r)\n         );\n \n         // Find the smallest universal region that contains all other\n         // universal regions within `region`.\n         let mut lub = self.universal_regions.fr_fn_body;\n-        for ur in inferred_values.universal_regions_outlived_by(r) {\n+        let r_scc = self.constraint_sccs.scc(r);\n+        for ur in self.scc_values.universal_regions_outlived_by(r_scc) {\n             lub = self.universal_regions.postdom_upper_bound(lub, ur);\n         }\n \n@@ -779,31 +766,29 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> bool {\n         debug!(\"eval_outlives({:?}: {:?})\", sup_region, sub_region);\n \n-        let inferred_values = self\n-            .inferred_values\n-            .as_ref()\n-            .expect(\"values for regions not yet inferred\");\n-\n         debug!(\n             \"eval_outlives: sup_region's value = {:?}\",\n-            inferred_values.region_value_str(sup_region),\n+            self.region_value_str(sup_region),\n         );\n         debug!(\n             \"eval_outlives: sub_region's value = {:?}\",\n-            inferred_values.region_value_str(sub_region),\n+            self.region_value_str(sub_region),\n         );\n \n+        let sub_region_scc = self.constraint_sccs.scc(sub_region);\n+        let sup_region_scc = self.constraint_sccs.scc(sup_region);\n+\n         // Both the `sub_region` and `sup_region` consist of the union\n         // of some number of universal regions (along with the union\n         // of various points in the CFG; ignore those points for\n         // now). Therefore, the sup-region outlives the sub-region if,\n         // for each universal region R1 in the sub-region, there\n         // exists some region R2 in the sup-region that outlives R1.\n-        let universal_outlives = inferred_values\n-            .universal_regions_outlived_by(sub_region)\n+        let universal_outlives = self.scc_values\n+            .universal_regions_outlived_by(sub_region_scc)\n             .all(|r1| {\n-                inferred_values\n-                    .universal_regions_outlived_by(sup_region)\n+                self.scc_values\n+                    .universal_regions_outlived_by(sup_region_scc)\n                     .any(|r2| self.universal_regions.outlives(r2, r1))\n             });\n \n@@ -819,7 +804,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return true;\n         }\n \n-        inferred_values.contains_points(sup_region, sub_region)\n+        self.scc_values\n+            .contains_points(sup_region_scc, sub_region_scc)\n     }\n \n     /// Once regions have been propagated, this method is used to see\n@@ -848,8 +834,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) {\n         // The universal regions are always found in a prefix of the\n         // full list.\n-        let universal_definitions = self\n-            .definitions\n+        let universal_definitions = self.definitions\n             .iter_enumerated()\n             .take_while(|(_, fr_definition)| fr_definition.is_universal);\n \n@@ -883,13 +868,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n     ) {\n-        let inferred_values = self.inferred_values.as_ref().unwrap();\n-\n         debug!(\"check_universal_region(fr={:?})\", longer_fr);\n \n+        let longer_fr_scc = self.constraint_sccs.scc(longer_fr);\n+\n         // Find every region `o` such that `fr: o`\n         // (because `fr` includes `end(o)`).\n-        for shorter_fr in inferred_values.universal_regions_outlived_by(longer_fr) {\n+        for shorter_fr in self.scc_values.universal_regions_outlived_by(longer_fr_scc) {\n             // If it is known that `fr: o`, carry on.\n             if self.universal_regions.outlives(longer_fr, shorter_fr) {\n                 continue;"}, {"sha": "c5bfb1fc6a588addd9254223423593d56f1e6c78", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -18,15 +18,15 @@ use std::rc::Rc;\n \n /// Maps between the various kinds of elements of a region value to\n /// the internal indices that w use.\n-pub(super) struct RegionValueElements {\n+crate struct RegionValueElements {\n     /// For each basic block, how many points are contained within?\n     statements_before_block: IndexVec<BasicBlock, usize>,\n     num_points: usize,\n     num_universal_regions: usize,\n }\n \n impl RegionValueElements {\n-    pub(super) fn new(mir: &Mir<'_>, num_universal_regions: usize) -> Self {\n+    crate fn new(mir: &Mir<'_>, num_universal_regions: usize) -> Self {\n         let mut num_points = 0;\n         let statements_before_block = mir\n             .basic_blocks()\n@@ -56,22 +56,22 @@ impl RegionValueElements {\n     }\n \n     /// Total number of element indices that exist.\n-    pub(super) fn num_elements(&self) -> usize {\n+    crate fn num_elements(&self) -> usize {\n         self.num_points + self.num_universal_regions\n     }\n \n     /// Converts an element of a region value into a `RegionElementIndex`.\n-    pub(super) fn index<T: ToElementIndex>(&self, elem: T) -> RegionElementIndex {\n+    crate fn index<T: ToElementIndex>(&self, elem: T) -> RegionElementIndex {\n         elem.to_element_index(self)\n     }\n \n     /// Iterates over the `RegionElementIndex` for all points in the CFG.\n-    pub(super) fn all_point_indices<'a>(&'a self) -> impl Iterator<Item = RegionElementIndex> + 'a {\n+    crate fn all_point_indices<'a>(&'a self) -> impl Iterator<Item = RegionElementIndex> + 'a {\n         (0..self.num_points).map(move |i| RegionElementIndex::new(i + self.num_universal_regions))\n     }\n \n     /// Converts a particular `RegionElementIndex` to the `RegionElement` it represents.\n-    pub(super) fn to_element(&self, i: RegionElementIndex) -> RegionElement {\n+    crate fn to_element(&self, i: RegionElementIndex) -> RegionElement {\n         debug!(\"to_element(i={:?})\", i);\n \n         if let Some(r) = self.to_universal_region(i) {\n@@ -114,7 +114,7 @@ impl RegionValueElements {\n     /// Converts a particular `RegionElementIndex` to a universal\n     /// region, if that is what it represents. Returns `None`\n     /// otherwise.\n-    pub(super) fn to_universal_region(&self, i: RegionElementIndex) -> Option<RegionVid> {\n+    crate fn to_universal_region(&self, i: RegionElementIndex) -> Option<RegionVid> {\n         if i.index() < self.num_universal_regions {\n             Some(RegionVid::new(i.index()))\n         } else {\n@@ -138,15 +138,15 @@ newtype_index!(RegionElementIndex { DEBUG_FORMAT = \"RegionElementIndex({})\" });\n /// An individual element in a region value -- the value of a\n /// particular region variable consists of a set of these elements.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub(super) enum RegionElement {\n+crate enum RegionElement {\n     /// A point in the control-flow graph.\n     Location(Location),\n \n     /// An in-scope, universally quantified region (e.g., a lifetime parameter).\n     UniversalRegion(RegionVid),\n }\n \n-pub(super) trait ToElementIndex: Debug + Copy {\n+crate trait ToElementIndex: Debug + Copy {\n     fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex;\n }\n \n@@ -179,16 +179,16 @@ impl ToElementIndex for RegionElementIndex {\n /// variable. The columns consist of either universal regions or\n /// points in the CFG.\n #[derive(Clone)]\n-pub(super) struct RegionValues {\n+crate struct RegionValues<N: Idx> {\n     elements: Rc<RegionValueElements>,\n-    matrix: SparseBitMatrix<RegionVid, RegionElementIndex>,\n+    matrix: SparseBitMatrix<N, RegionElementIndex>,\n }\n \n-impl RegionValues {\n+impl<N: Idx> RegionValues<N> {\n     /// Creates a new set of \"region values\" that tracks causal information.\n     /// Each of the regions in num_region_variables will be initialized with an\n     /// empty set of points and no causal information.\n-    pub(super) fn new(elements: &Rc<RegionValueElements>, num_region_variables: usize) -> Self {\n+    crate fn new(elements: &Rc<RegionValueElements>, num_region_variables: usize) -> Self {\n         assert!(\n             elements.num_universal_regions <= num_region_variables,\n             \"universal regions are a subset of the region variables\"\n@@ -197,35 +197,39 @@ impl RegionValues {\n         Self {\n             elements: elements.clone(),\n             matrix: SparseBitMatrix::new(\n-                RegionVid::new(num_region_variables),\n+                N::new(num_region_variables),\n                 RegionElementIndex::new(elements.num_elements()),\n             ),\n         }\n     }\n \n     /// Adds the given element to the value for the given region. Returns true if\n     /// the element is newly added (i.e., was not already present).\n-    pub(super) fn add_element<E: ToElementIndex>(&mut self, r: RegionVid, elem: E) -> bool {\n+    crate fn add_element(\n+        &mut self,\n+        r: N,\n+        elem: impl ToElementIndex,\n+    ) -> bool {\n         let i = self.elements.index(elem);\n         debug!(\"add(r={:?}, elem={:?})\", r, elem);\n         self.matrix.add(r, i)\n     }\n \n     /// Add all elements in `r_from` to `r_to` (because e.g. `r_to:\n     /// r_from`).\n-    pub(super) fn add_region(&mut self, r_to: RegionVid, r_from: RegionVid) -> bool {\n+    crate fn add_region(&mut self, r_to: N, r_from: N) -> bool {\n         self.matrix.merge(r_from, r_to)\n     }\n \n     /// True if the region `r` contains the given element.\n-    pub(super) fn contains<E: ToElementIndex>(&self, r: RegionVid, elem: E) -> bool {\n+    crate fn contains(&self, r: N, elem: impl ToElementIndex) -> bool {\n         let i = self.elements.index(elem);\n         self.matrix.contains(r, i)\n     }\n \n     /// True if `sup_region` contains all the CFG points that\n     /// `sub_region` contains. Ignores universal regions.\n-    pub(super) fn contains_points(&self, sup_region: RegionVid, sub_region: RegionVid) -> bool {\n+    crate fn contains_points(&self, sup_region: N, sub_region: N) -> bool {\n         // This could be done faster by comparing the bitsets. But I\n         // am lazy.\n         self.element_indices_contained_in(sub_region)\n@@ -236,17 +240,17 @@ impl RegionValues {\n     /// Iterate over the value of the region `r`, yielding up element\n     /// indices. You may prefer `universal_regions_outlived_by` or\n     /// `elements_contained_in`.\n-    pub(super) fn element_indices_contained_in<'a>(\n+    crate fn element_indices_contained_in<'a>(\n         &'a self,\n-        r: RegionVid,\n+        r: N,\n     ) -> impl Iterator<Item = RegionElementIndex> + 'a {\n         self.matrix.iter(r).map(move |i| i)\n     }\n \n     /// Returns just the universal regions that are contained in a given region's value.\n-    pub(super) fn universal_regions_outlived_by<'a>(\n+    crate fn universal_regions_outlived_by<'a>(\n         &'a self,\n-        r: RegionVid,\n+        r: N,\n     ) -> impl Iterator<Item = RegionVid> + 'a {\n         self.element_indices_contained_in(r)\n             .map(move |i| self.elements.to_universal_region(i))\n@@ -255,16 +259,16 @@ impl RegionValues {\n     }\n \n     /// Returns all the elements contained in a given region's value.\n-    pub(super) fn elements_contained_in<'a>(\n+    crate fn elements_contained_in<'a>(\n         &'a self,\n-        r: RegionVid,\n+        r: N,\n     ) -> impl Iterator<Item = RegionElement> + 'a {\n         self.element_indices_contained_in(r)\n             .map(move |r| self.elements.to_element(r))\n     }\n \n     /// Returns a \"pretty\" string value of the region. Meant for debugging.\n-    pub(super) fn region_value_str(&self, r: RegionVid) -> String {\n+    crate fn region_value_str(&self, r: N) -> String {\n         let mut result = String::new();\n         result.push_str(\"{\");\n "}, {"sha": "64a61972a2206de18fdb52f5b5be8b20e67945d4", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -9,12 +9,11 @@\n // except according to those terms.\n \n use borrow_check::location::LocationTable;\n-use borrow_check::nll::constraint_set::OutlivesConstraint;\n+use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::{RegionTest, TypeTest};\n use borrow_check::nll::type_check::Locations;\n use borrow_check::nll::universal_regions::UniversalRegions;\n-use borrow_check::nll::constraint_set::ConstraintSet;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n use rustc::infer::region_constraints::{GenericKind, VerifyBound};\n@@ -186,7 +185,6 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n             locations: self.locations,\n             sub,\n             sup,\n-            next: None,\n         });\n     }\n "}, {"sha": "25f2be231772d58cfaaea9e108a6ca6cda522802", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 151, "deletions": 4, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -11,14 +11,17 @@\n //! This pass type-checks the MIR to ensure it is not broken.\n #![allow(unreachable_code)]\n \n+use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n-use borrow_check::nll::constraint_set::ConstraintSet;\n+use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n use borrow_check::nll::universal_regions::UniversalRegions;\n+use borrow_check::nll::ToRegionVid;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedPlaces;\n+use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::region_constraints::GenericKind;\n@@ -103,6 +106,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     mir_def_id: DefId,\n     universal_regions: &UniversalRegions<'tcx>,\n     location_table: &LocationTable,\n+    borrow_set: &BorrowSet<'tcx>,\n     liveness: &LivenessResults,\n     all_facts: &mut Option<AllFacts>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n@@ -119,6 +123,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n         Some(BorrowCheckContext {\n             universal_regions,\n             location_table,\n+            borrow_set,\n             all_facts,\n         }),\n         &mut |cx| {\n@@ -141,6 +146,7 @@ fn type_check_internal<'gcx, 'tcx>(\n ) -> MirTypeckRegionConstraints<'tcx> {\n     let mut checker = TypeChecker::new(\n         infcx,\n+        mir,\n         mir_def_id,\n         param_env,\n         region_bound_pairs,\n@@ -592,6 +598,7 @@ struct TypeChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n     last_span: Span,\n+    mir: &'a Mir<'tcx>,\n     mir_def_id: DefId,\n     region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n@@ -604,6 +611,7 @@ struct BorrowCheckContext<'a, 'tcx: 'a> {\n     universal_regions: &'a UniversalRegions<'tcx>,\n     location_table: &'a LocationTable,\n     all_facts: &'a mut Option<AllFacts>,\n+    borrow_set: &'a BorrowSet<'tcx>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n@@ -704,6 +712,7 @@ impl Locations {\n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn new(\n         infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+        mir: &'a Mir<'tcx>,\n         mir_def_id: DefId,\n         param_env: ty::ParamEnv<'gcx>,\n         region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n@@ -713,6 +722,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         TypeChecker {\n             infcx,\n             last_span: DUMMY_SP,\n+            mir,\n             mir_def_id,\n             param_env,\n             region_bound_pairs,\n@@ -857,8 +867,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n             StatementKind::UserAssertTy(ref c_ty, ref local) => {\n                 let local_ty = mir.local_decls()[*local].ty;\n-                let (ty, _) = self\n-                    .infcx\n+                let (ty, _) = self.infcx\n                     .instantiate_canonical_with_fresh_inference_vars(stmt.source_info.span, c_ty);\n                 debug!(\n                     \"check_stmt: user_assert_ty ty={:?} local_ty={:?}\",\n@@ -1400,9 +1409,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 CastKind::Misc => {}\n             },\n \n+            Rvalue::Ref(region, _borrow_kind, borrowed_place) => {\n+                self.add_reborrow_constraint(location, region, borrowed_place);\n+            }\n+\n             // FIXME: These other cases have to be implemented in future PRs\n             Rvalue::Use(..)\n-            | Rvalue::Ref(..)\n             | Rvalue::Len(..)\n             | Rvalue::BinaryOp(..)\n             | Rvalue::CheckedBinaryOp(..)\n@@ -1457,6 +1469,141 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Add the constraints that arise from a borrow expression `&'a P` at the location `L`.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `location`: the location `L` where the borrow expression occurs\n+    /// - `borrow_region`: the region `'a` associated with the borrow\n+    /// - `borrowed_place`: the place `P` being borrowed\n+    fn add_reborrow_constraint(\n+        &mut self,\n+        location: Location,\n+        borrow_region: ty::Region<'tcx>,\n+        borrowed_place: &Place<'tcx>,\n+    ) {\n+        // These constraints are only meaningful during borrowck:\n+        let BorrowCheckContext {\n+            borrow_set,\n+            location_table,\n+            all_facts,\n+            ..\n+        } = match &mut self.borrowck_context {\n+            Some(borrowck_context) => borrowck_context,\n+            None => return,\n+        };\n+\n+        // In Polonius mode, we also push a `borrow_region` fact\n+        // linking the loan to the region (in some cases, though,\n+        // there is no loan associated with this borrow expression --\n+        // that occurs when we are borrowing an unsafe place, for\n+        // example).\n+        if let Some(all_facts) = all_facts {\n+            if let Some(borrow_index) = borrow_set.location_map.get(&location) {\n+                let region_vid = borrow_region.to_region_vid();\n+                all_facts.borrow_region.push((\n+                    region_vid,\n+                    *borrow_index,\n+                    location_table.mid_index(location),\n+                ));\n+            }\n+        }\n+\n+        // If we are reborrowing the referent of another reference, we\n+        // need to add outlives relationships. In a case like `&mut\n+        // *p`, where the `p` has type `&'b mut Foo`, for example, we\n+        // need to ensure that `'b: 'a`.\n+\n+        let mut borrowed_place = borrowed_place;\n+\n+        debug!(\n+            \"add_reborrow_constraint({:?}, {:?}, {:?})\",\n+            location, borrow_region, borrowed_place\n+        );\n+        while let Place::Projection(box PlaceProjection { base, elem }) = borrowed_place {\n+            debug!(\"add_reborrow_constraint - iteration {:?}\", borrowed_place);\n+\n+            match *elem {\n+                ProjectionElem::Deref => {\n+                    let tcx = self.infcx.tcx;\n+                    let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n+\n+                    debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n+                    match base_ty.sty {\n+                        ty::TyRef(ref_region, _, mutbl) => {\n+                            self.constraints\n+                                .outlives_constraints\n+                                .push(OutlivesConstraint {\n+                                    sup: ref_region.to_region_vid(),\n+                                    sub: borrow_region.to_region_vid(),\n+                                    locations: location.boring(),\n+                                });\n+\n+                            if let Some(all_facts) = all_facts {\n+                                all_facts.outlives.push((\n+                                    ref_region.to_region_vid(),\n+                                    borrow_region.to_region_vid(),\n+                                    location_table.mid_index(location),\n+                                ));\n+                            }\n+\n+                            match mutbl {\n+                                hir::Mutability::MutImmutable => {\n+                                    // Immutable reference. We don't need the base\n+                                    // to be valid for the entire lifetime of\n+                                    // the borrow.\n+                                    break;\n+                                }\n+                                hir::Mutability::MutMutable => {\n+                                    // Mutable reference. We *do* need the base\n+                                    // to be valid, because after the base becomes\n+                                    // invalid, someone else can use our mutable deref.\n+\n+                                    // This is in order to make the following function\n+                                    // illegal:\n+                                    // ```\n+                                    // fn unsafe_deref<'a, 'b>(x: &'a &'b mut T) -> &'b mut T {\n+                                    //     &mut *x\n+                                    // }\n+                                    // ```\n+                                    //\n+                                    // As otherwise you could clone `&mut T` using the\n+                                    // following function:\n+                                    // ```\n+                                    // fn bad(x: &mut T) -> (&mut T, &mut T) {\n+                                    //     let my_clone = unsafe_deref(&'a x);\n+                                    //     ENDREGION 'a;\n+                                    //     (my_clone, x)\n+                                    // }\n+                                    // ```\n+                                }\n+                            }\n+                        }\n+                        ty::TyRawPtr(..) => {\n+                            // deref of raw pointer, guaranteed to be valid\n+                            break;\n+                        }\n+                        ty::TyAdt(def, _) if def.is_box() => {\n+                            // deref of `Box`, need the base to be valid - propagate\n+                        }\n+                        _ => bug!(\"unexpected deref ty {:?} in {:?}\", base_ty, borrowed_place),\n+                    }\n+                }\n+                ProjectionElem::Field(..)\n+                | ProjectionElem::Downcast(..)\n+                | ProjectionElem::Index(..)\n+                | ProjectionElem::ConstantIndex { .. }\n+                | ProjectionElem::Subslice { .. } => {\n+                    // other field access\n+                }\n+            }\n+\n+            // The \"propagate\" case. We need to check that our base is valid\n+            // for the borrow's lifetime.\n+            borrowed_place = base;\n+        }\n+    }\n+\n     fn prove_aggregate_predicates(\n         &mut self,\n         aggregate_kind: &AggregateKind<'tcx>,"}, {"sha": "499170acee31d980093e5e11593378c2b25da047", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -16,7 +16,7 @@ use dataflow::indexes::BorrowIndex;\n use rustc::mir::{BasicBlock, Location, Mir, Place};\n use rustc::mir::{ProjectionElem, BorrowKind};\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::control_flow_graph::dominators::Dominators;\n+use rustc_data_structures::graph::dominators::Dominators;\n \n /// Returns true if the borrow represented by `kind` is\n /// allowed to be split into separate Reservation and"}, {"sha": "9736ab797b2c14967f68ff9cbd93fad62239b6d4", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -76,7 +76,7 @@ fn precompute_borrows_out_of_scope<'a, 'tcx>(\n     while let Some(location) = stack.pop() {\n         // If region does not contain a point at the location, then add to list and skip\n         // successor locations.\n-        if !regioncx.region_contains_point(borrow_region, location) {\n+        if !regioncx.region_contains(borrow_region, location) {\n             debug!(\"borrow {:?} gets killed at {:?}\", borrow_index, location);\n             borrows_out_of_scope_at_location\n                 .entry(location)"}, {"sha": "39050864768ae3875f20830288e75c67f198a4b3", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -52,9 +52,9 @@ fn supply<'a, 'b, 'c>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>, cell_c: Cell\n         cell_c,\n         |_outlives1, _outlives2, _outlives3, x, y| {\n             // Only works if 'x: 'y:\n-            let p = x.get();\n+            let p = x.get(); //~ ERROR\n             //~^ WARN not reporting region error due to nll\n-            demand_y(x, y, p) //~ ERROR\n+            demand_y(x, y, p)\n         },\n     );\n }"}, {"sha": "6588cbe8bdf26c297f93e52a44527fe69ecbaed3", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -1,28 +1,28 @@\n warning: not reporting region error due to nll\n   --> $DIR/propagate-approximated-fail-no-postdom.rs:55:21\n    |\n-LL |             let p = x.get();\n+LL |             let p = x.get(); //~ ERROR\n    |                     ^^^^^^^\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/propagate-approximated-fail-no-postdom.rs:57:13\n+  --> $DIR/propagate-approximated-fail-no-postdom.rs:55:21\n    |\n LL |         |_outlives1, _outlives2, _outlives3, x, y| {\n    |          ----------              ---------- lifetime `'2` appears in this argument\n    |          |\n    |          lifetime `'1` appears in this argument\n-...\n-LL |             demand_y(x, y, p) //~ ERROR\n-   |             ^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n+LL |             // Only works if 'x: 'y:\n+LL |             let p = x.get(); //~ ERROR\n+   |                     ^^^^^^^ argument requires that `'1` must outlive `'2`\n \n note: No external requirements\n   --> $DIR/propagate-approximated-fail-no-postdom.rs:53:9\n    |\n LL | /         |_outlives1, _outlives2, _outlives3, x, y| {\n LL | |             // Only works if 'x: 'y:\n-LL | |             let p = x.get();\n+LL | |             let p = x.get(); //~ ERROR\n LL | |             //~^ WARN not reporting region error due to nll\n-LL | |             demand_y(x, y, p) //~ ERROR\n+LL | |             demand_y(x, y, p)\n LL | |         },\n    | |_________^\n    |"}, {"sha": "8fd5e898c8d9bff140e95e3701a7118ad3d50096", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -5,15 +5,15 @@ LL |     foo(cell, |cell_a, cell_x| {\n    |     ^^^\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:33:9\n+  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:33:20\n    |\n LL |     foo(cell, |cell_a, cell_x| {\n    |                ------  ------ lifetime `'1` appears in this argument\n    |                |\n    |                lifetime `'2` appears in this argument\n LL |         //~^ WARNING not reporting region error due to nll\n LL |         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n+   |                    ^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n \n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:31:15"}, {"sha": "c75b3e6670cdc018ff06ec43a3d3bf3eea0ef96e", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -5,15 +5,15 @@ LL |         demand_y(x, y, x.get())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:47:9\n+  --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:47:24\n    |\n LL |     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n    |                                                ---------  - lifetime `'1` appears in this argument\n    |                                                |\n    |                                                lifetime `'2` appears in this argument\n LL |         // Only works if 'x: 'y:\n LL |         demand_y(x, y, x.get())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n+   |                        ^^^^^^^ argument requires that `'1` must outlive `'2`\n \n note: No external requirements\n   --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:45:47"}, {"sha": "2465219ee552a809155510f9178d46559f1f5df0", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-wrong-bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce32b532de61434841b7c2ce3085e1f63d6a7a1/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr?ref=bce32b532de61434841b7c2ce3085e1f63d6a7a1", "patch": "@@ -5,15 +5,15 @@ LL |         demand_y(x, y, x.get())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:51:9\n+  --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:51:24\n    |\n LL |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n    |                                                ----------  ---------- lifetime `'2` appears in this argument\n    |                                                |\n    |                                                lifetime `'1` appears in this argument\n LL |         // Only works if 'x: 'y:\n LL |         demand_y(x, y, x.get())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n+   |                        ^^^^^^^ argument requires that `'1` must outlive `'2`\n \n note: No external requirements\n   --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:49:47"}]}