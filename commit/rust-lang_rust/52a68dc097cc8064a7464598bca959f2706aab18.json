{"sha": "52a68dc097cc8064a7464598bca959f2706aab18", "node_id": "C_kwDOAAsO6NoAKDUyYTY4ZGMwOTdjYzgwNjRhNzQ2NDU5OGJjYTk1OWYyNzA2YWFiMTg", "commit": {"author": {"name": "Alex Macleod", "email": "alex@macleod.io", "date": "2022-10-01T21:54:22Z"}, "committer": {"name": "Alex Macleod", "email": "alex@macleod.io", "date": "2022-10-01T22:31:10Z"}, "message": "lint nested patterns and slice patterns in `needless_borrowed_reference`", "tree": {"sha": "7077ccebce36421dd3a20e73bbba33c9a1208414", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7077ccebce36421dd3a20e73bbba33c9a1208414"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52a68dc097cc8064a7464598bca959f2706aab18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52a68dc097cc8064a7464598bca959f2706aab18", "html_url": "https://github.com/rust-lang/rust/commit/52a68dc097cc8064a7464598bca959f2706aab18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52a68dc097cc8064a7464598bca959f2706aab18/comments", "author": {"login": "Alexendoo", "id": 1830331, "node_id": "MDQ6VXNlcjE4MzAzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1830331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexendoo", "html_url": "https://github.com/Alexendoo", "followers_url": "https://api.github.com/users/Alexendoo/followers", "following_url": "https://api.github.com/users/Alexendoo/following{/other_user}", "gists_url": "https://api.github.com/users/Alexendoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexendoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexendoo/subscriptions", "organizations_url": "https://api.github.com/users/Alexendoo/orgs", "repos_url": "https://api.github.com/users/Alexendoo/repos", "events_url": "https://api.github.com/users/Alexendoo/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexendoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Alexendoo", "id": 1830331, "node_id": "MDQ6VXNlcjE4MzAzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1830331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexendoo", "html_url": "https://github.com/Alexendoo", "followers_url": "https://api.github.com/users/Alexendoo/followers", "following_url": "https://api.github.com/users/Alexendoo/following{/other_user}", "gists_url": "https://api.github.com/users/Alexendoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexendoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexendoo/subscriptions", "organizations_url": "https://api.github.com/users/Alexendoo/orgs", "repos_url": "https://api.github.com/users/Alexendoo/repos", "events_url": "https://api.github.com/users/Alexendoo/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexendoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64243c6f998df7cea3c86488c67481de09fec31c", "url": "https://api.github.com/repos/rust-lang/rust/commits/64243c6f998df7cea3c86488c67481de09fec31c", "html_url": "https://github.com/rust-lang/rust/commit/64243c6f998df7cea3c86488c67481de09fec31c"}], "stats": {"total": 354, "additions": 266, "deletions": 88}, "files": [{"sha": "ece4df95505ceb2de65d5bb5ba0e03f7cdc4d7cc", "filename": "clippy_lints/src/manual_clamp.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52a68dc097cc8064a7464598bca959f2706aab18/clippy_lints%2Fsrc%2Fmanual_clamp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52a68dc097cc8064a7464598bca959f2706aab18/clippy_lints%2Fsrc%2Fmanual_clamp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_clamp.rs?ref=52a68dc097cc8064a7464598bca959f2706aab18", "patch": "@@ -324,7 +324,7 @@ fn is_call_max_min_pattern<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>)\n         outer_arg: &'tcx Expr<'tcx>,\n         span: Span,\n     ) -> Option<ClampSuggestion<'tcx>> {\n-        if let ExprKind::Call(inner_fn, &[ref first, ref second]) = &inner_call.kind\n+        if let ExprKind::Call(inner_fn, [first, second]) = &inner_call.kind\n             && let Some(inner_seg) = segment(cx, inner_fn)\n             && let Some(outer_seg) = segment(cx, outer_fn)\n         {\n@@ -377,9 +377,7 @@ fn is_call_max_min_pattern<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>)\n /// # ;\n /// ```\n fn is_match_pattern<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<ClampSuggestion<'tcx>> {\n-    if let ExprKind::Match(value, &[ref first_arm, ref second_arm, ref last_arm], rustc_hir::MatchSource::Normal) =\n-        &expr.kind\n-    {\n+    if let ExprKind::Match(value, [first_arm, second_arm, last_arm], rustc_hir::MatchSource::Normal) = &expr.kind {\n         // Find possible min/max branches\n         let minmax_values = |a: &'tcx Arm<'tcx>| {\n             if let PatKind::Binding(_, var_hir_id, _, None) = &a.pat.kind"}, {"sha": "32da37a862d8ca02f30001805b013a8fc2f89a0d", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52a68dc097cc8064a7464598bca959f2706aab18/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52a68dc097cc8064a7464598bca959f2706aab18/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=52a68dc097cc8064a7464598bca959f2706aab18", "patch": "@@ -131,12 +131,12 @@ fn reduce_unit_expression<'a>(cx: &LateContext<'_>, expr: &'a hir::Expr<'_>) ->\n         },\n         hir::ExprKind::Block(block, _) => {\n             match (block.stmts, block.expr.as_ref()) {\n-                (&[], Some(inner_expr)) => {\n+                ([], Some(inner_expr)) => {\n                     // If block only contains an expression,\n                     // reduce `{ X }` to `X`\n                     reduce_unit_expression(cx, inner_expr)\n                 },\n-                (&[ref inner_stmt], None) => {\n+                ([inner_stmt], None) => {\n                     // If block only contains statements,\n                     // reduce `{ X; }` to `X` or `X;`\n                     match inner_stmt.kind {"}, {"sha": "d9fb4382181a20f8d13c0597bbd367f273ba6e21", "filename": "clippy_lints/src/methods/manual_ok_or.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52a68dc097cc8064a7464598bca959f2706aab18/clippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52a68dc097cc8064a7464598bca959f2706aab18/clippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs?ref=52a68dc097cc8064a7464598bca959f2706aab18", "patch": "@@ -55,7 +55,7 @@ fn is_ok_wrapping(cx: &LateContext<'_>, map_expr: &Expr<'_>) -> bool {\n         if let ExprKind::Closure(&Closure { body, .. }) = map_expr.kind;\n         let body = cx.tcx.hir().body(body);\n         if let PatKind::Binding(_, param_id, ..) = body.params[0].pat.kind;\n-        if let ExprKind::Call(Expr { kind: ExprKind::Path(ok_path), .. }, &[ref ok_arg]) = body.value.kind;\n+        if let ExprKind::Call(Expr { kind: ExprKind::Path(ok_path), .. }, [ok_arg]) = body.value.kind;\n         if is_lang_ctor(cx, ok_path, ResultOk);\n         then { path_to_local_id(ok_arg, param_id) } else { false }\n     }"}, {"sha": "10c3ff026b6d66100b3bee5a9b27d7c25799c184", "filename": "clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 79, "deletions": 42, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/52a68dc097cc8064a7464598bca959f2706aab18/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52a68dc097cc8064a7464598bca959f2706aab18/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=52a68dc097cc8064a7464598bca959f2706aab18", "patch": "@@ -1,43 +1,31 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::snippet_with_applicability;\n-use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BindingAnnotation, Mutability, Node, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for bindings that destructure a reference and borrow the inner\n+    /// Checks for bindings that needlessly destructure a reference and borrow the inner\n     /// value with `&ref`.\n     ///\n     /// ### Why is this bad?\n     /// This pattern has no effect in almost all cases.\n     ///\n-    /// ### Known problems\n-    /// In some cases, `&ref` is needed to avoid a lifetime mismatch error.\n-    /// Example:\n-    /// ```rust\n-    /// fn foo(a: &Option<String>, b: &Option<String>) {\n-    ///     match (a, b) {\n-    ///         (None, &ref c) | (&ref c, None) => (),\n-    ///         (&Some(ref c), _) => (),\n-    ///     };\n-    /// }\n-    /// ```\n-    ///\n     /// ### Example\n     /// ```rust\n     /// let mut v = Vec::<String>::new();\n-    /// # #[allow(unused)]\n     /// v.iter_mut().filter(|&ref a| a.is_empty());\n+    ///\n+    /// if let &[ref first, ref second] = v.as_slice() {}\n     /// ```\n     ///\n     /// Use instead:\n     /// ```rust\n     /// let mut v = Vec::<String>::new();\n-    /// # #[allow(unused)]\n     /// v.iter_mut().filter(|a| a.is_empty());\n+    ///\n+    /// if let [first, second] = v.as_slice() {}\n     /// ```\n     #[clippy::version = \"pre 1.29.0\"]\n     pub NEEDLESS_BORROWED_REFERENCE,\n@@ -54,34 +42,83 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrowedRef {\n             return;\n         }\n \n-        if_chain! {\n-            // Only lint immutable refs, because `&mut ref T` may be useful.\n-            if let PatKind::Ref(sub_pat, Mutability::Not) = pat.kind;\n+        // Do not lint patterns that are part of an OR `|` pattern, the binding mode must match in all arms\n+        for (_, node) in cx.tcx.hir().parent_iter(pat.hir_id) {\n+            let Node::Pat(pat) = node else { break };\n+\n+            if matches!(pat.kind, PatKind::Or(_)) {\n+                return;\n+            }\n+        }\n+\n+        // Only lint immutable refs, because `&mut ref T` may be useful.\n+        let PatKind::Ref(sub_pat, Mutability::Not) = pat.kind else { return };\n \n+        match sub_pat.kind {\n             // Check sub_pat got a `ref` keyword (excluding `ref mut`).\n-            if let PatKind::Binding(BindingAnnotation::REF, .., spanned_name, _) = sub_pat.kind;\n-            let parent_id = cx.tcx.hir().get_parent_node(pat.hir_id);\n-            if let Some(parent_node) = cx.tcx.hir().find(parent_id);\n-            then {\n-                // do not recurse within patterns, as they may have other references\n-                // XXXManishearth we can relax this constraint if we only check patterns\n-                // with a single ref pattern inside them\n-                if let Node::Pat(_) = parent_node {\n-                    return;\n+            PatKind::Binding(BindingAnnotation::REF, _, ident, None) => {\n+                span_lint_and_then(\n+                    cx,\n+                    NEEDLESS_BORROWED_REFERENCE,\n+                    pat.span,\n+                    \"this pattern takes a reference on something that is being dereferenced\",\n+                    |diag| {\n+                        // `&ref ident`\n+                        //  ^^^^^\n+                        let span = pat.span.until(ident.span);\n+                        diag.span_suggestion_verbose(\n+                            span,\n+                            \"try removing the `&ref` part\",\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    },\n+                );\n+            },\n+            // Slices where each element is `ref`: `&[ref a, ref b, ..., ref z]`\n+            PatKind::Slice(\n+                before,\n+                None\n+                | Some(Pat {\n+                    kind: PatKind::Wild, ..\n+                }),\n+                after,\n+            ) => {\n+                let mut suggestions = Vec::new();\n+\n+                for element_pat in itertools::chain(before, after) {\n+                    if let PatKind::Binding(BindingAnnotation::REF, _, ident, None) = element_pat.kind {\n+                        // `&[..., ref ident, ...]`\n+                        //         ^^^^\n+                        let span = element_pat.span.until(ident.span);\n+                        suggestions.push((span, String::new()));\n+                    } else {\n+                        return;\n+                    }\n                 }\n-                let mut applicability = Applicability::MachineApplicable;\n-                span_lint_and_then(cx, NEEDLESS_BORROWED_REFERENCE, pat.span,\n-                                   \"this pattern takes a reference on something that is being de-referenced\",\n-                                   |diag| {\n-                                       let hint = snippet_with_applicability(cx, spanned_name.span, \"..\", &mut applicability).into_owned();\n-                                       diag.span_suggestion(\n-                                           pat.span,\n-                                           \"try removing the `&ref` part and just keep\",\n-                                           hint,\n-                                           applicability,\n-                                       );\n-                                   });\n-            }\n+\n+                if !suggestions.is_empty() {\n+                    span_lint_and_then(\n+                        cx,\n+                        NEEDLESS_BORROWED_REFERENCE,\n+                        pat.span,\n+                        \"dereferencing a slice pattern where every element takes a reference\",\n+                        |diag| {\n+                            // `&[...]`\n+                            //  ^\n+                            let span = pat.span.until(sub_pat.span);\n+                            suggestions.push((span, String::new()));\n+\n+                            diag.multipart_suggestion(\n+                                \"try removing the `&` and `ref` parts\",\n+                                suggestions,\n+                                Applicability::MachineApplicable,\n+                            );\n+                        },\n+                    );\n+                }\n+            },\n+            _ => {},\n         }\n     }\n }"}, {"sha": "152459ba1c9d78b2a50a0b9b714b61584accdd75", "filename": "src/docs/needless_borrowed_reference.txt", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/52a68dc097cc8064a7464598bca959f2706aab18/src%2Fdocs%2Fneedless_borrowed_reference.txt", "raw_url": "https://github.com/rust-lang/rust/raw/52a68dc097cc8064a7464598bca959f2706aab18/src%2Fdocs%2Fneedless_borrowed_reference.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fneedless_borrowed_reference.txt?ref=52a68dc097cc8064a7464598bca959f2706aab18", "patch": "@@ -1,30 +1,22 @@\n ### What it does\n-Checks for bindings that destructure a reference and borrow the inner\n+Checks for bindings that needlessly destructure a reference and borrow the inner\n value with `&ref`.\n \n ### Why is this bad?\n This pattern has no effect in almost all cases.\n \n-### Known problems\n-In some cases, `&ref` is needed to avoid a lifetime mismatch error.\n-Example:\n-```\n-fn foo(a: &Option<String>, b: &Option<String>) {\n-    match (a, b) {\n-        (None, &ref c) | (&ref c, None) => (),\n-        (&Some(ref c), _) => (),\n-    };\n-}\n-```\n-\n ### Example\n ```\n let mut v = Vec::<String>::new();\n v.iter_mut().filter(|&ref a| a.is_empty());\n+\n+if let &[ref first, ref second] = v.as_slice() {}\n ```\n \n Use instead:\n ```\n let mut v = Vec::<String>::new();\n v.iter_mut().filter(|a| a.is_empty());\n+\n+if let [first, second] = v.as_slice() {}\n ```\n\\ No newline at end of file"}, {"sha": "bcb4eb2dd48a65615d4241b5f8f48f1370abd12c", "filename": "tests/ui/needless_borrowed_ref.fixed", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/52a68dc097cc8064a7464598bca959f2706aab18/tests%2Fui%2Fneedless_borrowed_ref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/52a68dc097cc8064a7464598bca959f2706aab18/tests%2Fui%2Fneedless_borrowed_ref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrowed_ref.fixed?ref=52a68dc097cc8064a7464598bca959f2706aab18", "patch": "@@ -1,17 +1,38 @@\n // run-rustfix\n \n-#[warn(clippy::needless_borrowed_reference)]\n-#[allow(unused_variables)]\n-fn main() {\n+#![warn(clippy::needless_borrowed_reference)]\n+#![allow(unused, clippy::needless_borrow)]\n+\n+fn main() {}\n+\n+fn should_lint(array: [u8; 4], slice: &[u8], slice_of_refs: &[&u8], vec: Vec<u8>) {\n     let mut v = Vec::<String>::new();\n     let _ = v.iter_mut().filter(|a| a.is_empty());\n-    //                            ^ should be linted\n \n     let var = 3;\n     let thingy = Some(&var);\n-    if let Some(&ref v) = thingy {\n-        //          ^ should be linted\n-    }\n+    if let Some(v) = thingy {}\n+\n+    if let &[a, ref b] = slice_of_refs {}\n+\n+    let [a, ..] = &array;\n+    let [a, b, ..] = &array;\n+\n+    if let [a, b] = slice {}\n+    if let [a, b] = &vec[..] {}\n+\n+    if let [a, b, ..] = slice {}\n+    if let [a, .., b] = slice {}\n+    if let [.., a, b] = slice {}\n+}\n+\n+fn should_not_lint(array: [u8; 4], slice: &[u8], slice_of_refs: &[&u8], vec: Vec<u8>) {\n+    if let [ref a] = slice {}\n+    if let &[ref a, b] = slice {}\n+    if let &[ref a, .., b] = slice {}\n+\n+    // must not be removed as variables must be bound consistently across | patterns\n+    if let (&[ref a], _) | ([], ref a) = (slice_of_refs, &1u8) {}\n \n     let mut var2 = 5;\n     let thingy2 = Some(&mut var2);\n@@ -28,17 +49,15 @@ fn main() {\n     }\n }\n \n-#[allow(dead_code)]\n enum Animal {\n     Cat(u64),\n     Dog(u64),\n }\n \n-#[allow(unused_variables)]\n-#[allow(dead_code)]\n fn foo(a: &Animal, b: &Animal) {\n     match (a, b) {\n-        (&Animal::Cat(v), &ref k) | (&ref k, &Animal::Cat(v)) => (), // lifetime mismatch error if there is no '&ref'\n+        // lifetime mismatch error if there is no '&ref' before `feature(nll)` stabilization in 1.63\n+        (&Animal::Cat(v), &ref k) | (&ref k, &Animal::Cat(v)) => (),\n         //                  ^    and   ^ should **not** be linted\n         (&Animal::Dog(ref a), &Animal::Dog(_)) => (), //              ^ should **not** be linted\n     }"}, {"sha": "f6de1a6d83d1bbdf965c19a28823899956608e44", "filename": "tests/ui/needless_borrowed_ref.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/52a68dc097cc8064a7464598bca959f2706aab18/tests%2Fui%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52a68dc097cc8064a7464598bca959f2706aab18/tests%2Fui%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrowed_ref.rs?ref=52a68dc097cc8064a7464598bca959f2706aab18", "patch": "@@ -1,17 +1,38 @@\n // run-rustfix\n \n-#[warn(clippy::needless_borrowed_reference)]\n-#[allow(unused_variables)]\n-fn main() {\n+#![warn(clippy::needless_borrowed_reference)]\n+#![allow(unused, clippy::needless_borrow)]\n+\n+fn main() {}\n+\n+fn should_lint(array: [u8; 4], slice: &[u8], slice_of_refs: &[&u8], vec: Vec<u8>) {\n     let mut v = Vec::<String>::new();\n     let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n-    //                            ^ should be linted\n \n     let var = 3;\n     let thingy = Some(&var);\n-    if let Some(&ref v) = thingy {\n-        //          ^ should be linted\n-    }\n+    if let Some(&ref v) = thingy {}\n+\n+    if let &[&ref a, ref b] = slice_of_refs {}\n+\n+    let &[ref a, ..] = &array;\n+    let &[ref a, ref b, ..] = &array;\n+\n+    if let &[ref a, ref b] = slice {}\n+    if let &[ref a, ref b] = &vec[..] {}\n+\n+    if let &[ref a, ref b, ..] = slice {}\n+    if let &[ref a, .., ref b] = slice {}\n+    if let &[.., ref a, ref b] = slice {}\n+}\n+\n+fn should_not_lint(array: [u8; 4], slice: &[u8], slice_of_refs: &[&u8], vec: Vec<u8>) {\n+    if let [ref a] = slice {}\n+    if let &[ref a, b] = slice {}\n+    if let &[ref a, .., b] = slice {}\n+\n+    // must not be removed as variables must be bound consistently across | patterns\n+    if let (&[ref a], _) | ([], ref a) = (slice_of_refs, &1u8) {}\n \n     let mut var2 = 5;\n     let thingy2 = Some(&mut var2);\n@@ -28,17 +49,15 @@ fn main() {\n     }\n }\n \n-#[allow(dead_code)]\n enum Animal {\n     Cat(u64),\n     Dog(u64),\n }\n \n-#[allow(unused_variables)]\n-#[allow(dead_code)]\n fn foo(a: &Animal, b: &Animal) {\n     match (a, b) {\n-        (&Animal::Cat(v), &ref k) | (&ref k, &Animal::Cat(v)) => (), // lifetime mismatch error if there is no '&ref'\n+        // lifetime mismatch error if there is no '&ref' before `feature(nll)` stabilization in 1.63\n+        (&Animal::Cat(v), &ref k) | (&ref k, &Animal::Cat(v)) => (),\n         //                  ^    and   ^ should **not** be linted\n         (&Animal::Dog(ref a), &Animal::Dog(_)) => (), //              ^ should **not** be linted\n     }"}, {"sha": "7453542e673f3bbf5f07f0003b408d4c9c77310f", "filename": "tests/ui/needless_borrowed_ref.stderr", "status": "modified", "additions": 117, "deletions": 4, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/52a68dc097cc8064a7464598bca959f2706aab18/tests%2Fui%2Fneedless_borrowed_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52a68dc097cc8064a7464598bca959f2706aab18/tests%2Fui%2Fneedless_borrowed_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrowed_ref.stderr?ref=52a68dc097cc8064a7464598bca959f2706aab18", "patch": "@@ -1,10 +1,123 @@\n-error: this pattern takes a reference on something that is being de-referenced\n-  --> $DIR/needless_borrowed_ref.rs:7:34\n+error: this pattern takes a reference on something that is being dereferenced\n+  --> $DIR/needless_borrowed_ref.rs:10:34\n    |\n LL |     let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n-   |                                  ^^^^^^ help: try removing the `&ref` part and just keep: `a`\n+   |                                  ^^^^^^\n    |\n    = note: `-D clippy::needless-borrowed-reference` implied by `-D warnings`\n+help: try removing the `&ref` part\n+   |\n+LL -     let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n+LL +     let _ = v.iter_mut().filter(|a| a.is_empty());\n+   |\n+\n+error: this pattern takes a reference on something that is being dereferenced\n+  --> $DIR/needless_borrowed_ref.rs:14:17\n+   |\n+LL |     if let Some(&ref v) = thingy {}\n+   |                 ^^^^^^\n+   |\n+help: try removing the `&ref` part\n+   |\n+LL -     if let Some(&ref v) = thingy {}\n+LL +     if let Some(v) = thingy {}\n+   |\n+\n+error: this pattern takes a reference on something that is being dereferenced\n+  --> $DIR/needless_borrowed_ref.rs:16:14\n+   |\n+LL |     if let &[&ref a, ref b] = slice_of_refs {}\n+   |              ^^^^^^\n+   |\n+help: try removing the `&ref` part\n+   |\n+LL -     if let &[&ref a, ref b] = slice_of_refs {}\n+LL +     if let &[a, ref b] = slice_of_refs {}\n+   |\n+\n+error: dereferencing a slice pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:18:9\n+   |\n+LL |     let &[ref a, ..] = &array;\n+   |         ^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     let &[ref a, ..] = &array;\n+LL +     let [a, ..] = &array;\n+   |\n+\n+error: dereferencing a slice pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:19:9\n+   |\n+LL |     let &[ref a, ref b, ..] = &array;\n+   |         ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     let &[ref a, ref b, ..] = &array;\n+LL +     let [a, b, ..] = &array;\n+   |\n+\n+error: dereferencing a slice pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:21:12\n+   |\n+LL |     if let &[ref a, ref b] = slice {}\n+   |            ^^^^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     if let &[ref a, ref b] = slice {}\n+LL +     if let [a, b] = slice {}\n+   |\n+\n+error: dereferencing a slice pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:22:12\n+   |\n+LL |     if let &[ref a, ref b] = &vec[..] {}\n+   |            ^^^^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     if let &[ref a, ref b] = &vec[..] {}\n+LL +     if let [a, b] = &vec[..] {}\n+   |\n+\n+error: dereferencing a slice pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:24:12\n+   |\n+LL |     if let &[ref a, ref b, ..] = slice {}\n+   |            ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     if let &[ref a, ref b, ..] = slice {}\n+LL +     if let [a, b, ..] = slice {}\n+   |\n+\n+error: dereferencing a slice pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:25:12\n+   |\n+LL |     if let &[ref a, .., ref b] = slice {}\n+   |            ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     if let &[ref a, .., ref b] = slice {}\n+LL +     if let [a, .., b] = slice {}\n+   |\n+\n+error: dereferencing a slice pattern where every element takes a reference\n+  --> $DIR/needless_borrowed_ref.rs:26:12\n+   |\n+LL |     if let &[.., ref a, ref b] = slice {}\n+   |            ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try removing the `&` and `ref` parts\n+   |\n+LL -     if let &[.., ref a, ref b] = slice {}\n+LL +     if let [.., a, b] = slice {}\n+   |\n \n-error: aborting due to previous error\n+error: aborting due to 10 previous errors\n "}]}