{"sha": "8e58f3088b5c86339f8d2cdbdb37d1c54af08bca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNThmMzA4OGI1Yzg2MzM5ZjhkMmNkYmRiMzdkMWM1NGFmMDhiY2E=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-09-18T21:05:22Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-09-25T01:53:57Z"}, "message": "implement entry API for HashMap\n\nDeprecates the `find_or_*` family of \"internal mutation\" methods on `HashMap` in\nfavour of the \"external mutation\" Entry API as part of RFC 60. Part of #17320,\nalthough this still needs to be done on the rest of the maps, they don't have\nany internal mutation methods defined, so they can be done without deprecating\nor breaking anything. Work on `BTree`'s is part of the complete rewrite in #17334.\n\nThe implemented API deviates from the API described in the RFC in two key places:\n\n* `VacantEntry.set` yields a mutable reference to the inserted element to avoid code\nduplication where complex logic needs to be done *regardless* of whether the entry\nwas vacant or not.\n* `OccupiedEntry.into_mut` was added so that it is possible to return a reference\ninto the map beyond the lifetime of the Entry itself, providing functional parity\nto `VacantEntry.set`.\n\nThis allows the full find_or_insert functionality to be implemented using this API.\nA PR will be submitted to the RFC to amend this.\n\n[breaking-change]", "tree": {"sha": "818d1aa7940b633b985f0255f841bbe83d5bc156", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/818d1aa7940b633b985f0255f841bbe83d5bc156"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e58f3088b5c86339f8d2cdbdb37d1c54af08bca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e58f3088b5c86339f8d2cdbdb37d1c54af08bca", "html_url": "https://github.com/rust-lang/rust/commit/8e58f3088b5c86339f8d2cdbdb37d1c54af08bca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e58f3088b5c86339f8d2cdbdb37d1c54af08bca/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d485e87c57f7b31f4a0683469d12e3106d33b0e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d485e87c57f7b31f4a0683469d12e3106d33b0e2", "html_url": "https://github.com/rust-lang/rust/commit/d485e87c57f7b31f4a0683469d12e3106d33b0e2"}], "stats": {"total": 295, "additions": 288, "deletions": 7}, "files": [{"sha": "2dba541881fb8e35246d653bbe2e7c7088777a4a", "filename": "src/jemalloc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fjemalloc?ref=8e58f3088b5c86339f8d2cdbdb37d1c54af08bca", "patch": "@@ -1 +1 @@\n-Subproject commit aae04170ccbfeea620502106b581c3c216cd132a\n+Subproject commit 2dba541881fb8e35246d653bbe2e7c7088777a4a"}, {"sha": "9cdf0facd5631689e42a8700ef5e03140d3d8b61", "filename": "src/libstd/collections/hashmap/map.rs", "status": "modified", "additions": 282, "deletions": 6, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/8e58f3088b5c86339f8d2cdbdb37d1c54af08bca/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58f3088b5c86339f8d2cdbdb37d1c54af08bca/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs?ref=8e58f3088b5c86339f8d2cdbdb37d1c54af08bca", "patch": "@@ -20,16 +20,19 @@ use hash::{Hash, Hasher, RandomSipHasher};\n use iter::{Iterator, FromIterator, Extendable};\n use iter;\n use mem::replace;\n+use mem;\n use num;\n use ops::{Deref, DerefMut};\n use option::{Some, None, Option};\n use result::{Ok, Err};\n use ops::Index;\n+use core::result::Result;\n \n use super::table;\n use super::table::{\n     Bucket,\n     Empty,\n+    EmptyBucket,\n     Full,\n     FullBucket,\n     FullBucketImm,\n@@ -328,11 +331,11 @@ fn search_hashed<K: Eq, V, M: Deref<RawTable<K, V>>>(table: M, hash: &SafeHash,\n     search_hashed_generic(table, hash, |k_| *k == *k_)\n }\n \n-fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> V {\n-    let (empty, _k, retval) = starting_bucket.take();\n+fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n+    let (empty, retkey, retval) = starting_bucket.take();\n     let mut gap = match empty.gap_peek() {\n         Some(b) => b,\n-        None => return retval\n+        None => return (retkey, retval)\n     };\n \n     while gap.full().distance() != 0 {\n@@ -343,7 +346,7 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> V {\n     }\n \n     // Now we've done all our shifting. Return the value we grabbed earlier.\n-    return retval;\n+    return (retkey, retval);\n }\n \n /// Perform robin hood bucket stealing at the given `bucket`. You must\n@@ -567,7 +570,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V, H>\n         self.make_some_room(potential_new_size);\n \n         self.search_mut(k).map(|bucket| {\n-            pop_internal(bucket)\n+            let (_k, val) = pop_internal(bucket);\n+            val\n         })\n     }\n }\n@@ -852,12 +856,28 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         self.insert_hashed_nocheck(hash, k, v)\n     }\n \n+    /// Deprecated: use `entry` as follows instead:\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hashmap::{Occupied, Vacant};\n+    ///\n+    /// let mut map = HashMap::new();\n+    ///\n+    /// let result = match map.entry(\"a\") {\n+    ///     Vacant(entry) => entry.set(1i),\n+    ///     Occupied(entry) => entry.into_mut(),\n+    /// };\n+    /// assert_eq!(*result, 1);\n+    /// ```\n+    ///\n     /// Return the value corresponding to the key in the map, or insert\n     /// and return the value if it doesn't exist.\n     ///\n     /// # Example\n     ///\n     /// ```\n+    /// #![allow(deprecated)]\n     /// use std::collections::HashMap;\n     /// let mut map = HashMap::new();\n     ///\n@@ -867,16 +887,34 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// // Find the existing key\n     /// assert_eq!(*map.find_or_insert(\"a\", -2), 1);\n     /// ```\n+    #[deprecated = \"use entry instead\"]\n+    #[allow(deprecated)]\n     pub fn find_or_insert(&mut self, k: K, v: V) -> &mut V {\n         self.find_with_or_insert_with(k, v, |_k, _v, _a| (), |_k, a| a)\n     }\n \n+    /// Deprecated: use `entry` as follows instead:\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hashmap::{Occupied, Vacant};\n+    ///\n+    /// let mut map = HashMap::new();\n+    ///\n+    /// let result = match map.entry(\"a\") {\n+    ///     Vacant(entry) => entry.set(1i),\n+    ///     Occupied(entry) => entry.into_mut(),\n+    /// };\n+    /// assert_eq!(*result, 1);\n+    /// ```\n+    ///\n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n     ///\n     /// # Example\n     ///\n     /// ```\n+    /// #![allow(deprecated)]\n     /// use std::collections::HashMap;\n     /// let mut map = HashMap::new();\n     ///\n@@ -886,18 +924,39 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// // Find the existing key\n     /// assert_eq!(*map.find_or_insert_with(2, |&key| key as uint), 10);\n     /// ```\n+    #[deprecated = \"use entry instead\"]\n+    #[allow(deprecated)]\n     pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: |&K| -> V)\n                                -> &'a mut V {\n         self.find_with_or_insert_with(k, (), |_k, _v, _a| (), |k, _a| f(k))\n     }\n \n+    /// Deprecated: use `entry` as follows instead:\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hashmap::{Occupied, Vacant};\n+    ///\n+    /// let mut map = HashMap::new();\n+    ///\n+    /// let result = match map.entry(\"a\") {\n+    ///     Vacant(entry) => entry.set(1u),\n+    ///     Occupied(mut entry) => {\n+    ///         *entry.get_mut() += 1;\n+    ///         entry.into_mut()\n+    ///     }\n+    /// };\n+    /// assert_eq!(*result, 1);\n+    /// ```\n+    ///\n     /// Insert a key-value pair into the map if the key is not already present.\n     /// Otherwise, modify the existing value for the key.\n     /// Returns the new or modified value for the key.\n     ///\n     /// # Example\n     ///\n     /// ```\n+    /// #![allow(deprecated)]\n     /// use std::collections::HashMap;\n     /// let mut map = HashMap::new();\n     ///\n@@ -908,6 +967,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(*map.insert_or_update_with(\"a\", 9, |_key, val| *val = 7), 7);\n     /// assert_eq!(map[\"a\"], 7);\n     /// ```\n+    #[deprecated = \"use entry instead\"]\n     pub fn insert_or_update_with<'a>(\n                                  &'a mut self,\n                                  k: K,\n@@ -921,6 +981,24 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         self.insert_or_replace_with(hash, k, v, |kref, vref, _v| f(kref, vref))\n     }\n \n+    /// Deprecated: use `entry` as follows instead:\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hashmap::{Occupied, Vacant};\n+    ///\n+    /// let mut map = HashMap::new();\n+    ///\n+    /// let result = match map.entry(\"a\") {\n+    ///     Vacant(entry) => entry.set(1u),\n+    ///     Occupied(mut entry) => {\n+    ///         *entry.get_mut() += 1;\n+    ///         entry.into_mut()\n+    ///     }\n+    /// };\n+    /// assert_eq!(*result, 1);\n+    /// ```\n+    ///\n     /// Modify and return the value corresponding to the key in the map, or\n     /// insert and return a new value if it doesn't exist.\n     ///\n@@ -934,6 +1012,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// # Example\n     ///\n     /// ```\n+    /// #![allow(deprecated)]\n     /// use std::collections::HashMap;\n     ///\n     /// // map some strings to vectors of strings\n@@ -965,6 +1044,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map[\"b key\"], vec![\"new value\"]);\n     /// assert_eq!(map[\"z key\"], vec![\"new value\", \"value\"]);\n     /// ```\n+    #[deprecated = \"use entry instead\"]\n     pub fn find_with_or_insert_with<'a, A>(&'a mut self,\n                                            k: K,\n                                            a: A,\n@@ -1124,7 +1204,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n         match self.search_equiv_mut(k) {\n             Some(bucket) => {\n-                Some(pop_internal(bucket))\n+                let (_k, val) = pop_internal(bucket);\n+                Some(val)\n             }\n             _ => None\n         }\n@@ -1254,6 +1335,68 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n             inner: self.table.into_iter().map(|(_, k, v)| (k, v))\n         }\n     }\n+\n+    /// Gets the given key's corresponding entry in the map for in-place manipulation\n+    pub fn entry<'a>(&'a mut self, key: K) -> Entry<'a, K, V> {\n+        // Gotta resize now, and we don't know which direction, so try both?\n+        let size = self.table.size();\n+        self.make_some_room(size + 1);\n+        if size > 0 {\n+            self.make_some_room(size - 1);\n+        }\n+\n+        let hash = self.make_hash(&key);\n+        search_entry_hashed(&mut self.table, hash, key)\n+    }\n+}\n+\n+fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: K)\n+        -> Entry<'a, K, V> {\n+    // Worst case, we'll find one empty bucket among `size + 1` buckets.\n+    let size = table.size();\n+    let mut probe = Bucket::new(table, &hash);\n+    let ib = probe.index();\n+\n+    loop {\n+        let bucket = match probe.peek() {\n+            Empty(bucket) => {\n+                // Found a hole!\n+                return Vacant(VacantEntry {\n+                    hash: hash,\n+                    key: k,\n+                    elem: NoElem(bucket),\n+                });\n+            },\n+            Full(bucket) => bucket\n+        };\n+\n+        if bucket.hash() == hash {\n+            let is_eq = {\n+                let (bucket_k, _) = bucket.read();\n+                k == *bucket_k\n+            };\n+\n+            if is_eq {\n+                return Occupied(OccupiedEntry{\n+                    elem: bucket,\n+                });\n+            }\n+        }\n+\n+        let robin_ib = bucket.index() as int - bucket.distance() as int;\n+\n+        if (ib as int) < robin_ib {\n+            // Found a luckier bucket than me. Better steal his spot.\n+            return Vacant(VacantEntry {\n+                hash: hash,\n+                key: k,\n+                elem: NeqElem(bucket, robin_ib as uint),\n+            });\n+        }\n+\n+        probe = bucket.next();\n+        assert!(probe.index() != ib + size + 1);\n+    }\n }\n \n impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n@@ -1353,6 +1496,35 @@ pub struct MoveEntries<K, V> {\n     inner: iter::Map<'static, (SafeHash, K, V), (K, V), table::MoveEntries<K, V>>\n }\n \n+/// A view into a single occupied location in a HashMap\n+pub struct OccupiedEntry<'a, K:'a, V:'a> {\n+    elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n+}\n+\n+/// A view into a single empty location in a HashMap\n+pub struct VacantEntry<'a, K:'a, V:'a> {\n+    hash: SafeHash,\n+    key: K,\n+    elem: VacantEntryState<K,V, &'a mut RawTable<K, V>>,\n+}\n+\n+/// A view into a single location in a map, which may be vacant or occupied\n+pub enum Entry<'a, K:'a, V:'a> {\n+    /// An occupied Entry\n+    Occupied(OccupiedEntry<'a, K, V>),\n+    /// A vacant Entry\n+    Vacant(VacantEntry<'a, K, V>),\n+}\n+\n+/// Possible states of a VacantEntry\n+enum VacantEntryState<K, V, M> {\n+    /// The index is occupied, but the key to insert has precedence,\n+    /// and will kick the current one out on insertion\n+    NeqElem(FullBucket<K, V, M>, uint),\n+    /// The index is genuinely vacant\n+    NoElem(EmptyBucket<K, V, M>),\n+}\n+\n impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n     #[inline]\n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n@@ -1386,6 +1558,57 @@ impl<K, V> Iterator<(K, V)> for MoveEntries<K, V> {\n     }\n }\n \n+impl<'a, K, V> OccupiedEntry<'a, K, V> {\n+    /// Gets a reference to the value in the entry\n+    pub fn get(&self) -> &V {\n+        let (_, v) = self.elem.read();\n+        v\n+    }\n+\n+    /// Gets a mutable reference to the value in the entry\n+    pub fn get_mut(&mut self) -> &mut V {\n+        let (_, v) = self.elem.read_mut();\n+        v\n+    }\n+\n+    /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n+    /// with a lifetime bound to the map itself\n+    pub fn into_mut(self) -> &'a mut V {\n+        let (_, v) = self.elem.into_mut_refs();\n+        v\n+    }\n+\n+    /// Sets the value of the entry, and returns the entry's old value\n+    pub fn set(&mut self, mut value: V) -> V {\n+        let old_value = self.get_mut();\n+        mem::swap(&mut value, old_value);\n+        value\n+    }\n+\n+    /// Takes the value out of the entry, and returns it\n+    pub fn take(self) -> V {\n+        let (_, _, v) = self.elem.take();\n+        v\n+    }\n+}\n+\n+impl<'a, K, V> VacantEntry<'a, K, V> {\n+    /// Sets the value of the entry with the VacantEntry's key,\n+    /// and returns a mutable reference to it\n+    pub fn set(self, value: V) -> &'a mut V {\n+        match self.elem {\n+            NeqElem(bucket, ib) => {\n+                robin_hood(bucket, ib, self.hash, self.key, value)\n+            }\n+            NoElem(bucket) => {\n+                let full = bucket.put(self.hash, self.key, value);\n+                let (_, v) = full.into_mut_refs();\n+                v\n+            }\n+        }\n+    }\n+}\n+\n /// HashMap keys iterator\n pub type Keys<'a, K, V> =\n     iter::Map<'static, (&'a K, &'a V), &'a K, Entries<'a, K, V>>;\n@@ -1416,6 +1639,7 @@ mod test_map {\n     use prelude::*;\n \n     use super::HashMap;\n+    use super::{Occupied, Vacant};\n     use cmp::Equiv;\n     use hash;\n     use iter::{Iterator,range_inclusive,range_step_inclusive};\n@@ -2026,4 +2250,56 @@ mod test_map {\n \n         map[4];\n     }\n+\n+    #[test]\n+    fn test_entry(){\n+        let xs = [(1i, 10i), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n+\n+        let mut map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n+\n+        // Existing key (insert)\n+        match map.entry(1) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(mut view) => {\n+                assert_eq!(view.get(), &10);\n+                assert_eq!(view.set(100), 10);\n+            }\n+        }\n+        assert_eq!(map.find(&1).unwrap(), &100);\n+        assert_eq!(map.len(), 6);\n+\n+\n+        // Existing key (update)\n+        match map.entry(2) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(mut view) => {\n+                let v = view.get_mut();\n+                let new_v = (*v) * 10;\n+                *v = new_v;\n+            }\n+        }\n+        assert_eq!(map.find(&2).unwrap(), &200);\n+        assert_eq!(map.len(), 6);\n+\n+        // Existing key (take)\n+        match map.entry(3) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(view) => {\n+                assert_eq!(view.take(), 30);\n+            }\n+        }\n+        assert_eq!(map.find(&3), None);\n+        assert_eq!(map.len(), 5);\n+\n+\n+        // Inexistent key (insert)\n+        match map.entry(10) {\n+            Occupied(_) => unreachable!(),\n+            Vacant(view) => {\n+                assert_eq!(*view.set(1000), 1000);\n+            }\n+        }\n+        assert_eq!(map.find(&10).unwrap(), &1000);\n+        assert_eq!(map.len(), 6);\n+    }\n }"}, {"sha": "6508d4609f1475a68d525f586bc36ab48e14eb89", "filename": "src/libstd/collections/hashmap/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e58f3088b5c86339f8d2cdbdb37d1c54af08bca/src%2Flibstd%2Fcollections%2Fhashmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58f3088b5c86339f8d2cdbdb37d1c54af08bca/src%2Flibstd%2Fcollections%2Fhashmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fmod.rs?ref=8e58f3088b5c86339f8d2cdbdb37d1c54af08bca", "patch": "@@ -14,6 +14,11 @@ pub use self::map::HashMap;\n pub use self::map::Entries;\n pub use self::map::MutEntries;\n pub use self::map::MoveEntries;\n+pub use self::map::Entry;\n+pub use self::map::Occupied;\n+pub use self::map::Vacant;\n+pub use self::map::OccupiedEntry;\n+pub use self::map::VacantEntry;\n pub use self::map::Keys;\n pub use self::map::Values;\n pub use self::map::INITIAL_CAPACITY;"}]}