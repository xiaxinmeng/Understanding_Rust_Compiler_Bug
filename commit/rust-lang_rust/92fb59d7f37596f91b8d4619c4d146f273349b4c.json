{"sha": "92fb59d7f37596f91b8d4619c4d146f273349b4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZmI1OWQ3ZjM3NTk2ZjkxYjhkNDYxOWM0ZDE0NmYyNzMzNDliNGM=", "commit": {"author": {"name": "marmeladema", "email": "xademax@gmail.com", "date": "2020-04-09T08:43:00Z"}, "committer": {"name": "marmeladema", "email": "xademax@gmail.com", "date": "2020-04-23T22:14:07Z"}, "message": "librustc_middle: return LocalDefId instead of DefId in local_def_id", "tree": {"sha": "7f0eb8b7afa4b4706a49181e504500fb9f3c70bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f0eb8b7afa4b4706a49181e504500fb9f3c70bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92fb59d7f37596f91b8d4619c4d146f273349b4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92fb59d7f37596f91b8d4619c4d146f273349b4c", "html_url": "https://github.com/rust-lang/rust/commit/92fb59d7f37596f91b8d4619c4d146f273349b4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92fb59d7f37596f91b8d4619c4d146f273349b4c/comments", "author": {"login": "marmeladema", "id": 1629419, "node_id": "MDQ6VXNlcjE2Mjk0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1629419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marmeladema", "html_url": "https://github.com/marmeladema", "followers_url": "https://api.github.com/users/marmeladema/followers", "following_url": "https://api.github.com/users/marmeladema/following{/other_user}", "gists_url": "https://api.github.com/users/marmeladema/gists{/gist_id}", "starred_url": "https://api.github.com/users/marmeladema/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marmeladema/subscriptions", "organizations_url": "https://api.github.com/users/marmeladema/orgs", "repos_url": "https://api.github.com/users/marmeladema/repos", "events_url": "https://api.github.com/users/marmeladema/events{/privacy}", "received_events_url": "https://api.github.com/users/marmeladema/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marmeladema", "id": 1629419, "node_id": "MDQ6VXNlcjE2Mjk0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1629419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marmeladema", "html_url": "https://github.com/marmeladema", "followers_url": "https://api.github.com/users/marmeladema/followers", "following_url": "https://api.github.com/users/marmeladema/following{/other_user}", "gists_url": "https://api.github.com/users/marmeladema/gists{/gist_id}", "starred_url": "https://api.github.com/users/marmeladema/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marmeladema/subscriptions", "organizations_url": "https://api.github.com/users/marmeladema/orgs", "repos_url": "https://api.github.com/users/marmeladema/repos", "events_url": "https://api.github.com/users/marmeladema/events{/privacy}", "received_events_url": "https://api.github.com/users/marmeladema/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14b15521c52549ebbb113173b4abecd124b5a823", "url": "https://api.github.com/repos/rust-lang/rust/commits/14b15521c52549ebbb113173b4abecd124b5a823", "html_url": "https://github.com/rust-lang/rust/commit/14b15521c52549ebbb113173b4abecd124b5a823"}], "stats": {"total": 1037, "additions": 545, "deletions": 492}, "files": [{"sha": "38a5f8d6d71cffc0c2b2133e191a6bfcd8b78d87", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -96,7 +96,7 @@ fn reachable_non_generics_provider(\n                     if !generics.requires_monomorphization(tcx) &&\n                         // Functions marked with #[inline] are only ever codegened\n                         // with \"internal\" linkage and are never exported.\n-                        !Instance::mono(tcx, def_id).def.generates_cgu_internal_copy(tcx)\n+                        !Instance::mono(tcx, def_id.to_def_id()).def.generates_cgu_internal_copy(tcx)\n                     {\n                         Some(def_id)\n                     } else {\n@@ -109,7 +109,7 @@ fn reachable_non_generics_provider(\n         })\n         .map(|def_id| {\n             let export_level = if special_runtime_crate {\n-                let name = tcx.symbol_name(Instance::mono(tcx, def_id)).name.as_str();\n+                let name = tcx.symbol_name(Instance::mono(tcx, def_id.to_def_id())).name.as_str();\n                 // We can probably do better here by just ensuring that\n                 // it has hidden visibility rather than public\n                 // visibility, as this is primarily here to ensure it's\n@@ -126,14 +126,14 @@ fn reachable_non_generics_provider(\n                     SymbolExportLevel::Rust\n                 }\n             } else {\n-                symbol_export_level(tcx, def_id)\n+                symbol_export_level(tcx, def_id.to_def_id())\n             };\n             debug!(\n                 \"EXPORTED SYMBOL (local): {} ({:?})\",\n-                tcx.symbol_name(Instance::mono(tcx, def_id)),\n+                tcx.symbol_name(Instance::mono(tcx, def_id.to_def_id())),\n                 export_level\n             );\n-            (def_id, export_level)\n+            (def_id.to_def_id(), export_level)\n         })\n         .collect();\n "}, {"sha": "610e9b9051040eb576ca2c391f8c8e6e233e711d", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -322,7 +322,7 @@ impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n     }\n \n     fn node_path(&self, id: hir::HirId) -> Option<String> {\n-        Some(self.tcx.def_path_str(self.tcx.hir().local_def_id(id)))\n+        Some(self.tcx.def_path_str(self.tcx.hir().local_def_id(id).to_def_id()))\n     }\n }\n "}, {"sha": "673d6e92b7ee3fb78dcbf78a54c2273e80e26fe8", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -115,7 +115,7 @@ impl IfThisChanged<'tcx> {\n \n     fn process_attrs(&mut self, hir_id: hir::HirId, attrs: &[ast::Attribute]) {\n         let def_id = self.tcx.hir().local_def_id(hir_id);\n-        let def_path_hash = self.tcx.def_path_hash(def_id);\n+        let def_path_hash = self.tcx.def_path_hash(def_id.to_def_id());\n         for attr in attrs {\n             if attr.check_name(sym::rustc_if_this_changed) {\n                 let dep_node_interned = self.argument(attr);\n@@ -131,7 +131,7 @@ impl IfThisChanged<'tcx> {\n                         }\n                     },\n                 };\n-                self.if_this_changed.push((attr.span, def_id, dep_node));\n+                self.if_this_changed.push((attr.span, def_id.to_def_id(), dep_node));\n             } else if attr.check_name(sym::rustc_then_this_would_need) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {"}, {"sha": "27aebf7b1b98df772db5d53ee63c66425403c119", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -434,16 +434,16 @@ impl DirtyCleanVisitor<'tcx> {\n \n     fn check_item(&mut self, item_id: hir::HirId, item_span: Span) {\n         let def_id = self.tcx.hir().local_def_id(item_id);\n-        for attr in self.tcx.get_attrs(def_id).iter() {\n+        for attr in self.tcx.get_attrs(def_id.to_def_id()).iter() {\n             let assertion = match self.assertion_maybe(item_id, attr) {\n                 Some(a) => a,\n                 None => continue,\n             };\n             self.checked_attrs.insert(attr.id);\n-            for dep_node in self.dep_nodes(&assertion.clean, def_id) {\n+            for dep_node in self.dep_nodes(&assertion.clean, def_id.to_def_id()) {\n                 self.assert_clean(item_span, dep_node);\n             }\n-            for dep_node in self.dep_nodes(&assertion.dirty, def_id) {\n+            for dep_node in self.dep_nodes(&assertion.dirty, def_id.to_def_id()) {\n                 self.assert_dirty(item_span, dep_node);\n             }\n         }"}, {"sha": "c74cba81ca9079017c16b132a20959af5505a429", "filename": "src/librustc_interface/proc_macro_decls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fproc_macro_decls.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -16,7 +16,7 @@ fn proc_macro_decls_static(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<DefId> {\n     let mut finder = Finder { decls: None };\n     tcx.hir().krate().visit_all_item_likes(&mut finder);\n \n-    finder.decls.map(|id| tcx.hir().local_def_id(id))\n+    finder.decls.map(|id| tcx.hir().local_def_id(id).to_def_id())\n }\n \n struct Finder {"}, {"sha": "0fba510e101a1c45ed383d8ecc0bd6017cf7c4db", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -461,7 +461,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         };\n \n         let def_id = cx.tcx.hir().local_def_id(it.hir_id);\n-        let (article, desc) = cx.tcx.article_and_description(def_id);\n+        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n \n         self.check_missing_docs_attrs(cx, Some(it.hir_id), &it.attrs, it.span, article, desc);\n     }\n@@ -472,7 +472,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         }\n \n         let def_id = cx.tcx.hir().local_def_id(trait_item.hir_id);\n-        let (article, desc) = cx.tcx.article_and_description(def_id);\n+        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n \n         self.check_missing_docs_attrs(\n             cx,\n@@ -491,7 +491,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         }\n \n         let def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n-        let (article, desc) = cx.tcx.article_and_description(def_id);\n+        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n         self.check_missing_docs_attrs(\n             cx,\n             Some(impl_item.hir_id),\n@@ -1531,7 +1531,8 @@ impl ExplicitOutlivesRequirements {\n         inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n         ty_generics: &'tcx ty::Generics,\n     ) -> Vec<ty::Region<'tcx>> {\n-        let index = ty_generics.param_def_id_to_index[&tcx.hir().local_def_id(param.hir_id)];\n+        let index =\n+            ty_generics.param_def_id_to_index[&tcx.hir().local_def_id(param.hir_id).to_def_id()];\n \n         match param.kind {\n             hir::GenericParamKind::Lifetime { .. } => {"}, {"sha": "8675197656a48f14f58c59b148ede9bab6b489c3", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -22,9 +22,11 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n         };\n \n         let foreign_items =\n-            fm.items.iter().map(|it| self.tcx.hir().local_def_id(it.hir_id)).collect();\n-        self.modules\n-            .push(ForeignModule { foreign_items, def_id: self.tcx.hir().local_def_id(it.hir_id) });\n+            fm.items.iter().map(|it| self.tcx.hir().local_def_id(it.hir_id).to_def_id()).collect();\n+        self.modules.push(ForeignModule {\n+            foreign_items,\n+            def_id: self.tcx.hir().local_def_id(it.hir_id).to_def_id(),\n+        });\n     }\n \n     fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem<'tcx>) {}"}, {"sha": "51c9950a5dfedd1ba40f382fe67802f736836384", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -51,7 +51,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                 name: None,\n                 kind: cstore::NativeUnknown,\n                 cfg: None,\n-                foreign_module: Some(self.tcx.hir().local_def_id(it.hir_id)),\n+                foreign_module: Some(self.tcx.hir().local_def_id(it.hir_id).to_def_id()),\n                 wasm_import_module: None,\n             };\n             let mut kind_specified = false;"}, {"sha": "ab5a6a798a5ddc256f0a7743169a348c721ab90b", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 54, "deletions": 48, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -605,9 +605,8 @@ impl EncodeContext<'tcx> {\n         record!(self.tables.ty[def_id] <- self.tcx.type_of(def_id));\n     }\n \n-    fn encode_enum_variant_info(&mut self, enum_did: DefId, index: VariantIdx) {\n+    fn encode_enum_variant_info(&mut self, def: &ty::AdtDef, index: VariantIdx) {\n         let tcx = self.tcx;\n-        let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n         let def_id = variant.def_id;\n         debug!(\"EncodeContext::encode_enum_variant_info({:?})\", def_id);\n@@ -618,7 +617,7 @@ impl EncodeContext<'tcx> {\n             ctor: variant.ctor_def_id.map(|did| did.index),\n         };\n \n-        let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n+        let enum_id = tcx.hir().as_local_hir_id(def.did).unwrap();\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n \n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n@@ -649,9 +648,8 @@ impl EncodeContext<'tcx> {\n         self.encode_promoted_mir(def_id);\n     }\n \n-    fn encode_enum_variant_ctor(&mut self, enum_did: DefId, index: VariantIdx) {\n+    fn encode_enum_variant_ctor(&mut self, def: &ty::AdtDef, index: VariantIdx) {\n         let tcx = self.tcx;\n-        let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n         let def_id = variant.ctor_def_id.unwrap();\n         debug!(\"EncodeContext::encode_enum_variant_ctor({:?})\", def_id);\n@@ -665,7 +663,7 @@ impl EncodeContext<'tcx> {\n \n         // Variant constructors have the same visibility as the parent enums, unless marked as\n         // non-exhaustive, in which case they are lowered to `pub(crate)`.\n-        let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n+        let enum_id = tcx.hir().as_local_hir_id(def.did).unwrap();\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n         let mut ctor_vis = ty::Visibility::from_hir(enum_vis, enum_id, tcx);\n         if variant.is_field_list_non_exhaustive() && ctor_vis == ty::Visibility::Public {\n@@ -697,7 +695,7 @@ impl EncodeContext<'tcx> {\n         vis: &hir::Visibility<'_>,\n     ) {\n         let tcx = self.tcx;\n-        let def_id = tcx.hir().local_def_id(id);\n+        let def_id = tcx.hir().local_def_id(id).to_def_id();\n         debug!(\"EncodeContext::encode_info_for_mod({:?})\", def_id);\n \n         let data = ModData {\n@@ -712,15 +710,20 @@ impl EncodeContext<'tcx> {\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id] <- attrs);\n         record!(self.tables.children[def_id] <- md.item_ids.iter().map(|item_id| {\n-            tcx.hir().local_def_id(item_id.id).index\n+            tcx.hir().local_def_id(item_id.id).local_def_index\n         }));\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n     }\n \n-    fn encode_field(&mut self, adt_def_id: DefId, variant_index: VariantIdx, field_index: usize) {\n+    fn encode_field(\n+        &mut self,\n+        adt_def: &ty::AdtDef,\n+        variant_index: VariantIdx,\n+        field_index: usize,\n+    ) {\n         let tcx = self.tcx;\n-        let variant = &tcx.adt_def(adt_def_id).variants[variant_index];\n+        let variant = &adt_def.variants[variant_index];\n         let field = &variant.fields[field_index];\n \n         let def_id = field.did;\n@@ -742,10 +745,9 @@ impl EncodeContext<'tcx> {\n         self.encode_inferred_outlives(def_id);\n     }\n \n-    fn encode_struct_ctor(&mut self, adt_def_id: DefId, def_id: DefId) {\n+    fn encode_struct_ctor(&mut self, adt_def: &ty::AdtDef, def_id: DefId) {\n         debug!(\"EncodeContext::encode_struct_ctor({:?})\", def_id);\n         let tcx = self.tcx;\n-        let adt_def = tcx.adt_def(adt_def_id);\n         let variant = adt_def.non_enum_variant();\n \n         let data = VariantData {\n@@ -754,7 +756,7 @@ impl EncodeContext<'tcx> {\n             ctor: Some(def_id.index),\n         };\n \n-        let struct_id = tcx.hir().as_local_hir_id(adt_def_id).unwrap();\n+        let struct_id = tcx.hir().as_local_hir_id(adt_def.did).unwrap();\n         let struct_vis = &tcx.hir().expect_item(struct_id).vis;\n         let mut ctor_vis = ty::Visibility::from_hir(struct_vis, struct_id, tcx);\n         for field in &variant.fields {\n@@ -1101,7 +1103,7 @@ impl EncodeContext<'tcx> {\n                 // for methods, write all the stuff get_trait_method\n                 // needs to know\n                 let ctor = struct_def.ctor_hir_id().map(|ctor_hir_id| {\n-                    self.tcx.hir().local_def_id(ctor_hir_id).index\n+                    self.tcx.hir().local_def_id(ctor_hir_id).local_def_index\n                 });\n \n                 EntryKind::Struct(self.lazy(VariantData {\n@@ -1182,7 +1184,7 @@ impl EncodeContext<'tcx> {\n                 fm.items\n                     .iter()\n                     .map(|foreign_item| tcx.hir().local_def_id(\n-                        foreign_item.hir_id).index)\n+                        foreign_item.hir_id).local_def_index)\n             ),\n             hir::ItemKind::Enum(..) => record!(self.tables.children[def_id] <-\n                 self.tcx.adt_def(def_id).variants.iter().map(|v| {\n@@ -1287,7 +1289,7 @@ impl EncodeContext<'tcx> {\n \n     /// Serialize the text of exported macros\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef<'_>) {\n-        let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n+        let def_id = self.tcx.hir().local_def_id(macro_def.hir_id).to_def_id();\n         record!(self.tables.kind[def_id] <- EntryKind::MacroDef(self.lazy(macro_def.ast.clone())));\n         record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n         record!(self.tables.span[def_id] <- macro_def.span);\n@@ -1306,7 +1308,8 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n-    fn encode_info_for_closure(&mut self, def_id: DefId) {\n+    fn encode_info_for_closure(&mut self, def_id: LocalDefId) {\n+        let def_id = def_id.to_def_id();\n         debug!(\"EncodeContext::encode_info_for_closure({:?})\", def_id);\n \n         // NOTE(eddyb) `tcx.type_of(def_id)` isn't used because it's fully generic,\n@@ -1336,7 +1339,8 @@ impl EncodeContext<'tcx> {\n         self.encode_promoted_mir(def_id);\n     }\n \n-    fn encode_info_for_anon_const(&mut self, def_id: DefId) {\n+    fn encode_info_for_anon_const(&mut self, def_id: LocalDefId) {\n+        let def_id = def_id.to_def_id();\n         debug!(\"EncodeContext::encode_info_for_anon_const({:?})\", def_id);\n         let id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n         let body_id = self.tcx.hir().body_owned_by(id);\n@@ -1573,14 +1577,14 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         match item.kind {\n             hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {} // ignore these\n-            _ => self.encode_info_for_item(def_id, item),\n+            _ => self.encode_info_for_item(def_id.to_def_id(), item),\n         }\n         self.encode_addl_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem<'tcx>) {\n         intravisit::walk_foreign_item(self, ni);\n         let def_id = self.tcx.hir().local_def_id(ni.hir_id);\n-        self.encode_info_for_foreign_item(def_id, ni);\n+        self.encode_info_for_foreign_item(def_id.to_def_id(), ni);\n     }\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n         intravisit::walk_generics(self, generics);\n@@ -1592,13 +1596,10 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n }\n \n impl EncodeContext<'tcx> {\n-    fn encode_fields(&mut self, adt_def_id: DefId) {\n-        let def = self.tcx.adt_def(adt_def_id);\n-        for (variant_index, variant) in def.variants.iter_enumerated() {\n+    fn encode_fields(&mut self, adt_def: &ty::AdtDef) {\n+        for (variant_index, variant) in adt_def.variants.iter_enumerated() {\n             for (field_index, _field) in variant.fields.iter().enumerate() {\n-                // FIXME(eddyb) `adt_def_id` is leftover from incremental isolation,\n-                // pass `def`, `variant` or `field` instead.\n-                self.encode_field(adt_def_id, variant_index, field_index);\n+                self.encode_field(adt_def, variant_index, field_index);\n             }\n         }\n     }\n@@ -1610,13 +1611,17 @@ impl EncodeContext<'tcx> {\n                 GenericParamKind::Lifetime { .. } => continue,\n                 GenericParamKind::Type { ref default, .. } => {\n                     self.encode_info_for_generic_param(\n-                        def_id,\n+                        def_id.to_def_id(),\n                         EntryKind::TypeParam,\n                         default.is_some(),\n                     );\n                 }\n                 GenericParamKind::Const { .. } => {\n-                    self.encode_info_for_generic_param(def_id, EntryKind::ConstParam, true);\n+                    self.encode_info_for_generic_param(\n+                        def_id.to_def_id(),\n+                        EntryKind::ConstParam,\n+                        true,\n+                    );\n                 }\n             }\n         }\n@@ -1654,40 +1659,40 @@ impl EncodeContext<'tcx> {\n                 // no sub-item recording needed in these cases\n             }\n             hir::ItemKind::Enum(..) => {\n-                self.encode_fields(def_id);\n+                let def = self.tcx.adt_def(def_id.to_def_id());\n+                self.encode_fields(def);\n \n-                let def = self.tcx.adt_def(def_id);\n                 for (i, variant) in def.variants.iter_enumerated() {\n-                    // FIXME(eddyb) `def_id` is leftover from incremental isolation,\n-                    // pass `def` or `variant` instead.\n-                    self.encode_enum_variant_info(def_id, i);\n+                    self.encode_enum_variant_info(def, i);\n \n-                    // FIXME(eddyb) `def_id` is leftover from incremental isolation,\n-                    // pass `def`, `variant` or `ctor_def_id` instead.\n                     if let Some(_ctor_def_id) = variant.ctor_def_id {\n-                        self.encode_enum_variant_ctor(def_id, i);\n+                        self.encode_enum_variant_ctor(def, i);\n                     }\n                 }\n             }\n             hir::ItemKind::Struct(ref struct_def, _) => {\n-                self.encode_fields(def_id);\n+                let def = self.tcx.adt_def(def_id.to_def_id());\n+                self.encode_fields(def);\n \n                 // If the struct has a constructor, encode it.\n                 if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n                     let ctor_def_id = self.tcx.hir().local_def_id(ctor_hir_id);\n-                    self.encode_struct_ctor(def_id, ctor_def_id);\n+                    self.encode_struct_ctor(def, ctor_def_id.to_def_id());\n                 }\n             }\n             hir::ItemKind::Union(..) => {\n-                self.encode_fields(def_id);\n+                let def = self.tcx.adt_def(def_id.to_def_id());\n+                self.encode_fields(def);\n             }\n             hir::ItemKind::Impl { .. } => {\n-                for &trait_item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n+                for &trait_item_def_id in\n+                    self.tcx.associated_item_def_ids(def_id.to_def_id()).iter()\n+                {\n                     self.encode_info_for_impl_item(trait_item_def_id);\n                 }\n             }\n             hir::ItemKind::Trait(..) => {\n-                for &item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n+                for &item_def_id in self.tcx.associated_item_def_ids(def_id.to_def_id()).iter() {\n                     self.encode_info_for_trait_item(item_def_id);\n                 }\n             }\n@@ -1704,8 +1709,8 @@ impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if let hir::ItemKind::Impl { .. } = item.kind {\n             let impl_id = self.tcx.hir().local_def_id(item.hir_id);\n-            if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n-                self.impls.entry(trait_ref.def_id).or_default().push(impl_id.index);\n+            if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id.to_def_id()) {\n+                self.impls.entry(trait_ref.def_id).or_default().push(impl_id.local_def_index);\n             }\n         }\n     }\n@@ -1725,7 +1730,8 @@ struct PrefetchVisitor<'tcx> {\n }\n \n impl<'tcx> PrefetchVisitor<'tcx> {\n-    fn prefetch_mir(&self, def_id: DefId) {\n+    fn prefetch_mir(&self, def_id: LocalDefId) {\n+        let def_id = def_id.to_def_id();\n         if self.mir_keys.contains(&def_id) {\n             self.tcx.optimized_mir(def_id);\n             self.tcx.promoted_mir(def_id);\n@@ -1743,9 +1749,9 @@ impl<'tcx, 'v> ParItemLikeVisitor<'v> for PrefetchVisitor<'tcx> {\n             }\n             hir::ItemKind::Fn(ref sig, ..) => {\n                 let def_id = tcx.hir().local_def_id(item.hir_id);\n-                let generics = tcx.generics_of(def_id);\n+                let generics = tcx.generics_of(def_id.to_def_id());\n                 let needs_inline = generics.requires_monomorphization(tcx)\n-                    || tcx.codegen_fn_attrs(def_id).requests_inline();\n+                    || tcx.codegen_fn_attrs(def_id.to_def_id()).requests_inline();\n                 if needs_inline || sig.header.constness == hir::Constness::Const {\n                     self.prefetch_mir(def_id)\n                 }\n@@ -1768,9 +1774,9 @@ impl<'tcx, 'v> ParItemLikeVisitor<'v> for PrefetchVisitor<'tcx> {\n             }\n             hir::ImplItemKind::Fn(ref sig, _) => {\n                 let def_id = tcx.hir().local_def_id(impl_item.hir_id);\n-                let generics = tcx.generics_of(def_id);\n+                let generics = tcx.generics_of(def_id.to_def_id());\n                 let needs_inline = generics.requires_monomorphization(tcx)\n-                    || tcx.codegen_fn_attrs(def_id).requests_inline();\n+                    || tcx.codegen_fn_attrs(def_id.to_def_id()).requests_inline();\n                 let is_const_fn = sig.header.constness == hir::Constness::Const;\n                 if needs_inline || is_const_fn {\n                     self.prefetch_mir(def_id)"}, {"sha": "f18410cedf30d0e99e2bc6abca2fc735c6d4f7fe", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -171,16 +171,14 @@ impl<'hir> Map<'hir> {\n \n     // FIXME(eddyb) this function can and should return `LocalDefId`.\n     #[inline]\n-    pub fn local_def_id(&self, hir_id: HirId) -> DefId {\n-        self.opt_local_def_id(hir_id)\n-            .unwrap_or_else(|| {\n-                bug!(\n-                    \"local_def_id: no entry for `{:?}`, which has a map of `{:?}`\",\n-                    hir_id,\n-                    self.find_entry(hir_id)\n-                )\n-            })\n-            .to_def_id()\n+    pub fn local_def_id(&self, hir_id: HirId) -> LocalDefId {\n+        self.opt_local_def_id(hir_id).unwrap_or_else(|| {\n+            bug!(\n+                \"local_def_id: no entry for `{:?}`, which has a map of `{:?}`\",\n+                hir_id,\n+                self.find_entry(hir_id)\n+            )\n+        })\n     }\n \n     #[inline]\n@@ -378,7 +376,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn body_owner_def_id(&self, id: BodyId) -> LocalDefId {\n-        self.local_def_id(self.body_owner(id)).expect_local()\n+        self.local_def_id(self.body_owner(id))\n     }\n \n     /// Given a `HirId`, returns the `BodyId` associated with it,\n@@ -729,7 +727,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_parent_did(&self, id: HirId) -> LocalDefId {\n-        self.local_def_id(self.get_parent_item(id)).expect_local()\n+        self.local_def_id(self.get_parent_item(id))\n     }\n \n     pub fn get_foreign_abi(&self, hir_id: HirId) -> Abi {\n@@ -995,7 +993,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId) -> String {\n         crate::ty::tls::with_opt(|tcx| {\n             if let Some(tcx) = tcx {\n                 let def_id = map.local_def_id(id);\n-                tcx.def_path_str(def_id)\n+                tcx.def_path_str(def_id.to_def_id())\n             } else if let Some(path) = map.def_path_from_hir_id(id) {\n                 path.data\n                     .into_iter()"}, {"sha": "3d3d9dcf41da58a080a9d76f149f464b4468523f", "filename": "src/librustc_middle/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmod.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -69,7 +69,6 @@ pub fn provide(providers: &mut Providers<'_>) {\n     providers.parent_module_from_def_id = |tcx, id| {\n         let hir = tcx.hir();\n         hir.local_def_id(hir.get_module_parent_node(hir.as_local_hir_id(id.to_def_id()).unwrap()))\n-            .expect_local()\n     };\n     providers.hir_crate = |tcx, _| tcx.untracked_crate;\n     providers.index_hir = map::index_hir;"}, {"sha": "9d95a700313d63f526d67c9aa59a58b59544c8fb", "filename": "src/librustc_middle/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -286,7 +286,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             if let Some(depr_entry) = self.lookup_deprecation_entry(def_id) {\n                 let parent_def_id = self.hir().local_def_id(self.hir().get_parent_item(id));\n                 let skip = self\n-                    .lookup_deprecation_entry(parent_def_id)\n+                    .lookup_deprecation_entry(parent_def_id.to_def_id())\n                     .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n \n                 if !skip {"}, {"sha": "ee6b06a1cc803568944a15b7f6ba12c94a875de4", "filename": "src/librustc_middle/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_middle%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_middle%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -32,7 +32,7 @@ impl<'tcx> DefIdForest {\n     #[inline]\n     pub fn full(tcx: TyCtxt<'tcx>) -> DefIdForest {\n         let crate_id = tcx.hir().local_def_id(CRATE_HIR_ID);\n-        DefIdForest::from_id(crate_id)\n+        DefIdForest::from_id(crate_id.to_def_id())\n     }\n \n     /// Creates a forest containing a `DefId` and all its descendants."}, {"sha": "0134ea1a4e95008c81b69b1b1ec21af35c99aab3", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -2269,8 +2269,9 @@ impl<'tcx> Const<'tcx> {\n                 let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n                 let item_id = tcx.hir().get_parent_node(hir_id);\n                 let item_def_id = tcx.hir().local_def_id(item_id);\n-                let generics = tcx.generics_of(item_def_id);\n-                let index = generics.param_def_id_to_index[&tcx.hir().local_def_id(hir_id)];\n+                let generics = tcx.generics_of(item_def_id.to_def_id());\n+                let index =\n+                    generics.param_def_id_to_index[&tcx.hir().local_def_id(hir_id).to_def_id()];\n                 let name = tcx.hir().name(hir_id);\n                 ty::ConstKind::Param(ty::ParamConst::new(index, name))\n             }"}, {"sha": "2686759ab971b965fccd41507c1752320fdf37f4", "filename": "src/librustc_middle/ty/trait_def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -217,7 +217,7 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> &Trai\n         }\n \n         for &hir_id in tcx.hir().trait_impls(trait_id) {\n-            add_impl(tcx.hir().local_def_id(hir_id));\n+            add_impl(tcx.hir().local_def_id(hir_id).to_def_id());\n         }\n     }\n "}, {"sha": "2dbfcb690179e5dd0315fa2838792dd82ac0bae9", "filename": "src/librustc_mir/borrow_check/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -777,7 +777,7 @@ fn for_each_late_bound_region_defined_on<'tcx>(\n             let region_def_id = tcx.hir().local_def_id(hir_id);\n             let liberated_region = tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                 scope: fn_def_id,\n-                bound_region: ty::BoundRegion::BrNamed(region_def_id, name),\n+                bound_region: ty::BoundRegion::BrNamed(region_def_id.to_def_id(), name),\n             }));\n             f(liberated_region);\n         }"}, {"sha": "b8f7596070f452413b918b94eea935c23ba84409", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -180,7 +180,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{par_iter, MTLock, MTRef, ParallelIterator};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, DefIdMap, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::lang_items::{ExchangeMallocFnLangItem, StartFnLangItem};\n use rustc_index::bit_set::GrowableBitSet;\n@@ -952,8 +952,8 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n                             def_id_to_string(self.tcx, def_id)\n                         );\n \n-                        let ty =\n-                            Instance::new(def_id, InternalSubsts::empty()).monomorphic_ty(self.tcx);\n+                        let ty = Instance::new(def_id.to_def_id(), InternalSubsts::empty())\n+                            .monomorphic_ty(self.tcx);\n                         visit_drop_use(self.tcx, ty, true, self.output);\n                     }\n                 }\n@@ -968,7 +968,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n             hir::ItemKind::Static(..) => {\n                 let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                 debug!(\"RootCollector: ItemKind::Static({})\", def_id_to_string(self.tcx, def_id));\n-                self.output.push(MonoItem::Static(def_id));\n+                self.output.push(MonoItem::Static(def_id.to_def_id()));\n             }\n             hir::ItemKind::Const(..) => {\n                 // const items only generate mono items if they are\n@@ -977,7 +977,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n                 // but even just declaring them must collect the items they refer to\n                 let def_id = self.tcx.hir().local_def_id(item.hir_id);\n \n-                if let Ok(val) = self.tcx.const_eval_poly(def_id) {\n+                if let Ok(val) = self.tcx.const_eval_poly(def_id.to_def_id()) {\n                     collect_const_value(self.tcx, val, &mut self.output);\n                 }\n             }\n@@ -1002,12 +1002,12 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n }\n \n impl RootCollector<'_, 'v> {\n-    fn is_root(&self, def_id: DefId) -> bool {\n+    fn is_root(&self, def_id: LocalDefId) -> bool {\n         !item_requires_monomorphization(self.tcx, def_id)\n             && match self.mode {\n                 MonoItemCollectionMode::Eager => true,\n                 MonoItemCollectionMode::Lazy => {\n-                    self.entry_fn.map(|(id, _)| id) == Some(def_id)\n+                    self.entry_fn.map(|(id, _)| id) == Some(def_id.to_def_id())\n                         || self.tcx.is_reachable_non_generic(def_id)\n                         || self\n                             .tcx\n@@ -1020,11 +1020,11 @@ impl RootCollector<'_, 'v> {\n \n     /// If `def_id` represents a root, pushes it onto the list of\n     /// outputs. (Note that all roots must be monomorphic.)\n-    fn push_if_root(&mut self, def_id: DefId) {\n+    fn push_if_root(&mut self, def_id: LocalDefId) {\n         if self.is_root(def_id) {\n             debug!(\"RootCollector::push_if_root: found root def_id={:?}\", def_id);\n \n-            let instance = Instance::mono(self.tcx, def_id);\n+            let instance = Instance::mono(self.tcx, def_id.to_def_id());\n             self.output.push(create_fn_mono_item(instance));\n         }\n     }\n@@ -1066,7 +1066,7 @@ impl RootCollector<'_, 'v> {\n     }\n }\n \n-fn item_requires_monomorphization(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+fn item_requires_monomorphization(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n     let generics = tcx.generics_of(def_id);\n     generics.requires_monomorphization(tcx)\n }\n@@ -1170,10 +1170,10 @@ fn collect_neighbours<'tcx>(\n     MirNeighborCollector { tcx, body: &body, output, instance }.visit_body(&body);\n }\n \n-fn def_id_to_string(tcx: TyCtxt<'_>, def_id: DefId) -> String {\n+fn def_id_to_string(tcx: TyCtxt<'_>, def_id: LocalDefId) -> String {\n     let mut output = String::new();\n     let printer = DefPathBasedNames::new(tcx, false, false);\n-    printer.push_def_path(def_id, &mut output);\n+    printer.push_def_path(def_id.to_def_id(), &mut output);\n     output\n }\n "}, {"sha": "cad5b114ae4550f28f5ec6a610814021e5984fec", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -306,7 +306,7 @@ fn mono_item_visibility(\n             let def_id = tcx.hir().local_def_id(*hir_id);\n             return if tcx.is_reachable_non_generic(def_id) {\n                 *can_be_internalized = false;\n-                default_visibility(tcx, def_id, false)\n+                default_visibility(tcx, def_id.to_def_id(), false)\n             } else {\n                 Visibility::Hidden\n             };\n@@ -755,7 +755,7 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n             Some(def_id)\n         }\n         MonoItem::Static(def_id) => Some(def_id),\n-        MonoItem::GlobalAsm(hir_id) => Some(tcx.hir().local_def_id(hir_id)),\n+        MonoItem::GlobalAsm(hir_id) => Some(tcx.hir().local_def_id(hir_id).to_def_id()),\n     }\n }\n "}, {"sha": "40f26d5c52ca95197706d8add7dc05d5f56ec0ba", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -80,7 +80,7 @@ fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> &DefIdSet {\n             _: Span,\n         ) {\n             if let hir::VariantData::Tuple(_, hir_id) = *v {\n-                self.set.insert(self.tcx.hir().local_def_id(hir_id));\n+                self.set.insert(self.tcx.hir().local_def_id(hir_id).to_def_id());\n             }\n             intravisit::walk_struct_def(self, v)\n         }"}, {"sha": "2d76e27451031f63bc515ae82712f93540ef8bb1", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -5,7 +5,7 @@ use crate::hair::{BindingMode, LintLevel, PatKind};\n use rustc_attr::{self as attr, UnwindAttr};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items;\n use rustc_hir::{GeneratorKind, HirIdMap, Node};\n use rustc_index::vec::{Idx, IndexVec};\n@@ -523,9 +523,9 @@ macro_rules! unpack {\n     }};\n }\n \n-fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: DefId, _abi: Abi) -> bool {\n+fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: LocalDefId, _abi: Abi) -> bool {\n     // Validate `#[unwind]` syntax regardless of platform-specific panic strategy.\n-    let attrs = &tcx.get_attrs(fn_def_id);\n+    let attrs = &tcx.get_attrs(fn_def_id.to_def_id());\n     let unwind_attr = attr::find_unwind_attr(Some(tcx.sess.diagnostic()), attrs);\n \n     // We never unwind, so it's not relevant to stop an unwind.\n@@ -613,7 +613,7 @@ where\n                         builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n                             builder.args_and_body(\n                                 block,\n-                                fn_def_id,\n+                                fn_def_id.to_def_id(),\n                                 &arguments,\n                                 arg_scope,\n                                 &body.value,\n@@ -643,7 +643,7 @@ where\n     } else {\n         None\n     };\n-    debug!(\"fn_id {:?} has attrs {:?}\", fn_def_id, tcx.get_attrs(fn_def_id));\n+    debug!(\"fn_id {:?} has attrs {:?}\", fn_def_id, tcx.get_attrs(fn_def_id.to_def_id()));\n \n     let mut body = builder.finish();\n     body.spread_arg = spread_arg;"}, {"sha": "e5cd05da805d23241547589919b3100359833f22", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -408,7 +408,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n \n         // Now comes the rote stuff:\n         hir::ExprKind::Repeat(ref v, ref count) => {\n-            let count_def_id = cx.tcx.hir().local_def_id(count.hir_id).expect_local();\n+            let count_def_id = cx.tcx.hir().local_def_id(count.hir_id);\n             let count = ty::Const::from_anon_const(cx.tcx, count_def_id);\n \n             ExprKind::Repeat { value: v.to_ref(), count }\n@@ -695,7 +695,7 @@ fn convert_path_expr<'a, 'tcx>(\n             let item_def_id = cx.tcx.hir().local_def_id(item_id);\n             let generics = cx.tcx.generics_of(item_def_id);\n             let local_def_id = cx.tcx.hir().local_def_id(hir_id);\n-            let index = generics.param_def_id_to_index[&local_def_id];\n+            let index = generics.param_def_id_to_index[&local_def_id.to_def_id()];\n             let name = cx.tcx.hir().name(hir_id);\n             let val = ty::ConstKind::Param(ty::ParamConst::new(index, name));\n             ExprKind::Literal {\n@@ -962,7 +962,7 @@ fn capture_upvar<'tcx>(\n ) -> ExprRef<'tcx> {\n     let upvar_id = ty::UpvarId {\n         var_path: ty::UpvarPath { hir_id: var_hir_id },\n-        closure_expr_id: cx.tcx.hir().local_def_id(closure_expr.hir_id).expect_local(),\n+        closure_expr_id: cx.tcx.hir().local_def_id(closure_expr.hir_id),\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);"}, {"sha": "46607fd07cdd731f69e4d4d0b96ef52fc207fcda", "filename": "src/librustc_mir_build/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -82,11 +82,11 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n             infcx,\n             root_lint_level: src_id,\n             param_env: tcx.param_env(src_def_id),\n-            identity_substs: InternalSubsts::identity_for_item(tcx, src_def_id),\n+            identity_substs: InternalSubsts::identity_for_item(tcx, src_def_id.to_def_id()),\n             region_scope_tree: tcx.region_scope_tree(src_def_id),\n             tables,\n             constness,\n-            body_owner: src_def_id,\n+            body_owner: src_def_id.to_def_id(),\n             body_owner_kind,\n             check_overflow,\n             control_flow_destroyed: Vec::new(),"}, {"sha": "bed2221fe60761298a8389fff969c303a91b9ddc", "filename": "src/librustc_passes/diagnostic_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_passes%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_passes%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostic_items.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> DiagnosticItemCollector<'tcx> {\n         if let Some(name) = extract(attrs) {\n             let def_id = self.tcx.hir().local_def_id(hir_id);\n             // insert into our table\n-            collect_item(self.tcx, &mut self.items, name, def_id);\n+            collect_item(self.tcx, &mut self.items, name, def_id.to_def_id());\n         }\n     }\n }"}, {"sha": "35805db8d59efad9c3bd18b943221b0412b85a8d", "filename": "src/librustc_passes/entry.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_passes%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_passes%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fentry.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -34,7 +34,7 @@ struct EntryContext<'a, 'tcx> {\n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx Item<'tcx>) {\n         let def_id = self.map.local_def_id(item.hir_id);\n-        let def_key = self.map.def_key(def_id.expect_local());\n+        let def_key = self.map.def_key(def_id);\n         let at_root = def_key.parent == Some(CRATE_DEF_INDEX);\n         find_item(item, self, at_root);\n     }\n@@ -145,11 +145,11 @@ fn find_item(item: &Item<'_>, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n \n fn configure_main(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) -> Option<(DefId, EntryFnType)> {\n     if let Some((hir_id, _)) = visitor.start_fn {\n-        Some((tcx.hir().local_def_id(hir_id), EntryFnType::Start))\n+        Some((tcx.hir().local_def_id(hir_id).to_def_id(), EntryFnType::Start))\n     } else if let Some((hir_id, _)) = visitor.attr_main_fn {\n-        Some((tcx.hir().local_def_id(hir_id), EntryFnType::Main))\n+        Some((tcx.hir().local_def_id(hir_id).to_def_id(), EntryFnType::Main))\n     } else if let Some((hir_id, _)) = visitor.main_fn {\n-        Some((tcx.hir().local_def_id(hir_id), EntryFnType::Main))\n+        Some((tcx.hir().local_def_id(hir_id).to_def_id(), EntryFnType::Main))\n     } else {\n         no_main_err(tcx, visitor);\n         None"}, {"sha": "80dfcd9c2417aa708a09d3e77e1310e03b51fed9", "filename": "src/librustc_passes/hir_id_validator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_passes%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_passes%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_id_validator.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -17,7 +17,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n     par_iter(&hir_map.krate().modules).for_each(|(module_id, _)| {\n         let local_def_id = hir_map.local_def_id(*module_id);\n         hir_map.visit_item_likes_in_module(\n-            local_def_id,\n+            local_def_id.to_def_id(),\n             &mut OuterVisitor { hir_map, errors: &errors },\n         );\n     });\n@@ -79,7 +79,7 @@ impl<'a, 'hir> HirIdValidator<'a, 'hir> {\n \n     fn check<F: FnOnce(&mut HirIdValidator<'a, 'hir>)>(&mut self, hir_id: HirId, walk: F) {\n         assert!(self.owner.is_none());\n-        let owner = self.hir_map.local_def_id(hir_id).expect_local();\n+        let owner = self.hir_map.local_def_id(hir_id);\n         self.owner = Some(owner);\n         walk(self);\n "}, {"sha": "c48e6f9133bcd88a8af6c66fd478907566e6ee98", "filename": "src/librustc_passes/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_passes%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_passes%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flang_items.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -34,7 +34,7 @@ impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n                 // Known lang item with attribute on correct target.\n                 Some((item_index, expected_target)) if actual_target == expected_target => {\n                     let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                    self.collect_item(item_index, def_id);\n+                    self.collect_item(item_index, def_id.to_def_id());\n                 }\n                 // Known lang item with attribute on incorrect target.\n                 Some((_, expected_target)) => {"}, {"sha": "c0826f8cc605fd24a1285d02ea7556b09a80e390", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -1,6 +1,6 @@\n use rustc_ast::ast::Attribute;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::ItemKind;\n use rustc_middle::ty::layout::{HasParamEnv, HasTyCtxt, TyAndLayout};\n@@ -29,7 +29,7 @@ impl ItemLikeVisitor<'tcx> for LayoutTest<'tcx> {\n             | ItemKind::Struct(..)\n             | ItemKind::Union(..)\n             | ItemKind::OpaqueTy(..) => {\n-                for attr in self.tcx.get_attrs(item_def_id).iter() {\n+                for attr in self.tcx.get_attrs(item_def_id.to_def_id()).iter() {\n                     if attr.check_name(sym::rustc_layout) {\n                         self.dump_layout_of(item_def_id, item, attr);\n                     }\n@@ -44,7 +44,7 @@ impl ItemLikeVisitor<'tcx> for LayoutTest<'tcx> {\n }\n \n impl LayoutTest<'tcx> {\n-    fn dump_layout_of(&self, item_def_id: DefId, item: &hir::Item<'tcx>, attr: &Attribute) {\n+    fn dump_layout_of(&self, item_def_id: LocalDefId, item: &hir::Item<'tcx>, attr: &Attribute) {\n         let tcx = self.tcx;\n         let param_env = self.tcx.param_env(item_def_id);\n         let ty = self.tcx.type_of(item_def_id);"}, {"sha": "25d53485bc54dc1180b9c35e3433e1e2bcafb8ce", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -361,7 +361,7 @@ fn visit_fn<'tcx>(\n \n     // swap in a new set of IR maps for this function body:\n     let def_id = ir.tcx.hir().local_def_id(id);\n-    let mut fn_maps = IrMaps::new(ir.tcx, def_id);\n+    let mut fn_maps = IrMaps::new(ir.tcx, def_id.to_def_id());\n \n     // Don't run unused pass for #[derive()]\n     if let FnKind::Method(..) = fk {\n@@ -398,7 +398,7 @@ fn visit_fn<'tcx>(\n     intravisit::walk_fn(&mut fn_maps, fk, decl, body_id, sp, id);\n \n     // compute liveness\n-    let mut lsets = Liveness::new(&mut fn_maps, def_id);\n+    let mut lsets = Liveness::new(&mut fn_maps, def_id.to_def_id());\n     let entry_ln = lsets.compute(&body.value);\n \n     // check for various error conditions\n@@ -496,7 +496,7 @@ fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr<'tcx>) {\n             }\n             ir.set_captures(expr.hir_id, call_caps);\n             let old_body_owner = ir.body_owner;\n-            ir.body_owner = closure_def_id;\n+            ir.body_owner = closure_def_id.to_def_id();\n             intravisit::walk_expr(ir, expr);\n             ir.body_owner = old_body_owner;\n         }"}, {"sha": "34522cfe97f352db8e586ff61216cb1cb16f1d2a", "filename": "src/librustc_plugin_impl/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_plugin_impl%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_plugin_impl%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Fbuild.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -42,7 +42,7 @@ fn plugin_registrar_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<DefId> {\n         0 => None,\n         1 => {\n             let (hir_id, _) = finder.registrars.pop().unwrap();\n-            Some(tcx.hir().local_def_id(hir_id))\n+            Some(tcx.hir().local_def_id(hir_id).to_def_id())\n         }\n         _ => {\n             let diagnostic = tcx.sess.diagnostic();"}, {"sha": "e8d016aa07a8d863e0f60811136114fd490de982", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -268,11 +268,11 @@ fn def_id_visibility<'tcx>(\n                         Node::Variant(..) => {\n                             let parent_did = tcx.hir().local_def_id(parent_hir_id);\n                             let (mut ctor_vis, mut span, mut descr) =\n-                                def_id_visibility(tcx, parent_did);\n+                                def_id_visibility(tcx, parent_did.to_def_id());\n \n                             let adt_def = tcx.adt_def(tcx.hir().get_parent_did(hir_id).to_def_id());\n                             let ctor_did = tcx.hir().local_def_id(vdata.ctor_hir_id().unwrap());\n-                            let variant = adt_def.variant_with_ctor_id(ctor_did);\n+                            let variant = adt_def.variant_with_ctor_id(ctor_did.to_def_id());\n \n                             if variant.is_field_list_non_exhaustive()\n                                 && ctor_vis == ty::Visibility::Public\n@@ -514,7 +514,7 @@ impl EmbargoVisitor<'tcx> {\n     ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n             access_level: cmp::min(access_level, Some(AccessLevel::Reachable)),\n-            item_def_id: self.tcx.hir().local_def_id(item_id),\n+            item_def_id: self.tcx.hir().local_def_id(item_id).to_def_id(),\n             ev: self,\n         }\n     }\n@@ -532,7 +532,7 @@ impl EmbargoVisitor<'tcx> {\n \n     fn update_macro_reachable_mod(&mut self, reachable_mod: hir::HirId, defining_mod: DefId) {\n         let module_def_id = self.tcx.hir().local_def_id(reachable_mod);\n-        let module = self.tcx.hir().get_module(module_def_id).0;\n+        let module = self.tcx.hir().get_module(module_def_id.to_def_id()).0;\n         for item_id in module.item_ids {\n             let hir_id = item_id.id;\n             let item_def_id = self.tcx.hir().local_def_id(hir_id);\n@@ -661,7 +661,7 @@ impl EmbargoVisitor<'tcx> {\n                     for item_id in m.item_ids {\n                         let item = self.tcx.hir().expect_item(item_id.id);\n                         let def_id = self.tcx.hir().local_def_id(item_id.id);\n-                        if !self.tcx.hygienic_eq(segment.ident, item.ident, def_id) {\n+                        if !self.tcx.hygienic_eq(segment.ident, item.ident, def_id.to_def_id()) {\n                             continue;\n                         }\n                         if let hir::ItemKind::Use(..) = item.kind {\n@@ -927,7 +927,8 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         }\n \n         let macro_module_def_id =\n-            ty::DefIdTree::parent(self.tcx, self.tcx.hir().local_def_id(md.hir_id)).unwrap();\n+            ty::DefIdTree::parent(self.tcx, self.tcx.hir().local_def_id(md.hir_id).to_def_id())\n+                .unwrap();\n         // FIXME(#71104) Should really be using just `as_local_hir_id` but\n         // some `DefId` do not seem to have a corresponding HirId.\n         let hir_id = macro_module_def_id\n@@ -1370,8 +1371,10 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     // Check types in item interfaces.\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item =\n-            mem::replace(&mut self.current_item, self.tcx.hir().local_def_id(item.hir_id));\n+        let orig_current_item = mem::replace(\n+            &mut self.current_item,\n+            self.tcx.hir().local_def_id(item.hir_id).to_def_id(),\n+        );\n         let orig_in_body = mem::replace(&mut self.in_body, false);\n         let orig_tables =\n             mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n@@ -1913,7 +1916,7 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n         SearchInterfaceForPrivateItemsVisitor {\n             tcx: self.tcx,\n             item_id,\n-            item_def_id: self.tcx.hir().local_def_id(item_id),\n+            item_def_id: self.tcx.hir().local_def_id(item_id).to_def_id(),\n             span: self.tcx.hir().span(item_id),\n             required_visibility,\n             has_pub_restricted: self.has_pub_restricted,"}, {"sha": "5839b9149069559c9c80391b9ee2c2ae923bb63e", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -62,7 +62,7 @@ impl RegionExt for Region {\n         let def_id = hir_map.local_def_id(param.hir_id);\n         let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n-        (param.name.normalize_to_macros_2_0(), Region::EarlyBound(i, def_id, origin))\n+        (param.name.normalize_to_macros_2_0(), Region::EarlyBound(i, def_id.to_def_id(), origin))\n     }\n \n     fn late(hir_map: &Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region) {\n@@ -73,7 +73,7 @@ impl RegionExt for Region {\n             \"Region::late: param={:?} depth={:?} def_id={:?} origin={:?}\",\n             param, depth, def_id, origin,\n         );\n-        (param.name.normalize_to_macros_2_0(), Region::LateBound(depth, def_id, origin))\n+        (param.name.normalize_to_macros_2_0(), Region::LateBound(depth, def_id.to_def_id(), origin))\n     }\n \n     fn late_anon(index: &Cell<u32>) -> Region {\n@@ -1278,7 +1278,7 @@ fn object_lifetime_defaults_for_item(\n                         _ => continue,\n                     };\n \n-                    if res == Res::Def(DefKind::TyParam, param_def_id) {\n+                    if res == Res::Def(DefKind::TyParam, param_def_id.to_def_id()) {\n                         add_bounds(&mut set, &data.bounds);\n                     }\n                 }\n@@ -1304,7 +1304,11 @@ fn object_lifetime_defaults_for_item(\n                                 .find(|&(_, (_, lt_name, _))| lt_name == name)\n                                 .map_or(Set1::Many, |(i, (id, _, origin))| {\n                                     let def_id = tcx.hir().local_def_id(id);\n-                                    Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n+                                    Set1::One(Region::EarlyBound(\n+                                        i as u32,\n+                                        def_id.to_def_id(),\n+                                        origin,\n+                                    ))\n                                 })\n                         }\n                     }\n@@ -1812,7 +1816,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     })\n                     | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) => {\n                         let scope = self.tcx.hir().local_def_id(fn_id);\n-                        def = Region::Free(scope, def.id().unwrap());\n+                        def = Region::Free(scope.to_def_id(), def.id().unwrap());\n                     }\n                     _ => {}\n                 }"}, {"sha": "5175b692e17b69156872693f9257d2ec4c597a95", "filename": "src/librustc_symbol_mangling/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_symbol_mangling%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_symbol_mangling%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_symbol_mangling%2Ftest.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -33,18 +33,18 @@ impl SymbolNamesTest<'tcx> {\n     fn process_attrs(&mut self, hir_id: hir::HirId) {\n         let tcx = self.tcx;\n         let def_id = tcx.hir().local_def_id(hir_id);\n-        for attr in tcx.get_attrs(def_id).iter() {\n+        for attr in tcx.get_attrs(def_id.to_def_id()).iter() {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n-                let instance = Instance::mono(tcx, def_id);\n+                let instance = Instance::mono(tcx, def_id.to_def_id());\n                 let mangled = self.tcx.symbol_name(instance);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", mangled));\n                 if let Ok(demangling) = rustc_demangle::try_demangle(&mangled.name.as_str()) {\n                     tcx.sess.span_err(attr.span, &format!(\"demangling({})\", demangling));\n                     tcx.sess.span_err(attr.span, &format!(\"demangling-alt({:#})\", demangling));\n                 }\n             } else if attr.check_name(DEF_PATH) {\n-                let path = tcx.def_path_str(def_id);\n+                let path = tcx.def_path_str(def_id.to_def_id());\n                 tcx.sess.span_err(attr.span, &format!(\"def-path({})\", path));\n             }\n "}, {"sha": "fffb41f8cb78e81a036853f9490bf766364c9a30", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -1040,7 +1040,8 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                         let parent_def_id = self.parent_def_id;\n                         let def_scope_default = || {\n                             let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n-                            parent_def_id == tcx.hir().local_def_id(opaque_parent_hir_id)\n+                            parent_def_id\n+                                == tcx.hir().local_def_id(opaque_parent_hir_id).to_def_id()\n                         };\n                         let (in_definition_scope, origin) = match tcx.hir().find(opaque_hir_id) {\n                             Some(Node::Item(item)) => match item.kind {"}, {"sha": "a3bf297db80b852f5722b631d0526b5e144657fc", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -1,6 +1,6 @@\n use rustc_data_structures::svh::Svh;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n@@ -78,7 +78,7 @@ fn sized_constraint_for_ty<'tcx>(\n \n fn associated_item_from_trait_item_ref(\n     tcx: TyCtxt<'_>,\n-    parent_def_id: DefId,\n+    parent_def_id: LocalDefId,\n     parent_vis: &hir::Visibility<'_>,\n     trait_item_ref: &hir::TraitItemRef,\n ) -> ty::AssocItem {\n@@ -96,15 +96,15 @@ fn associated_item_from_trait_item_ref(\n         // Visibility of trait items is inherited from their traits.\n         vis: ty::Visibility::from_hir(parent_vis, trait_item_ref.id.hir_id, tcx),\n         defaultness: trait_item_ref.defaultness,\n-        def_id,\n-        container: ty::TraitContainer(parent_def_id),\n+        def_id: def_id.to_def_id(),\n+        container: ty::TraitContainer(parent_def_id.to_def_id()),\n         fn_has_self_parameter: has_self,\n     }\n }\n \n fn associated_item_from_impl_item_ref(\n     tcx: TyCtxt<'_>,\n-    parent_def_id: DefId,\n+    parent_def_id: LocalDefId,\n     impl_item_ref: &hir::ImplItemRef<'_>,\n ) -> ty::AssocItem {\n     let def_id = tcx.hir().local_def_id(impl_item_ref.id.hir_id);\n@@ -121,8 +121,8 @@ fn associated_item_from_impl_item_ref(\n         // Visibility of trait impl items doesn't matter.\n         vis: ty::Visibility::from_hir(&impl_item_ref.vis, impl_item_ref.id.hir_id, tcx),\n         defaultness: impl_item_ref.defaultness,\n-        def_id,\n-        container: ty::ImplContainer(parent_def_id),\n+        def_id: def_id.to_def_id(),\n+        container: ty::ImplContainer(parent_def_id.to_def_id()),\n         fn_has_self_parameter: has_self,\n     }\n }\n@@ -207,13 +207,13 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n             trait_item_refs\n                 .iter()\n                 .map(|trait_item_ref| trait_item_ref.id)\n-                .map(|id| tcx.hir().local_def_id(id.hir_id)),\n+                .map(|id| tcx.hir().local_def_id(id.hir_id).to_def_id()),\n         ),\n         hir::ItemKind::Impl { ref items, .. } => tcx.arena.alloc_from_iter(\n             items\n                 .iter()\n                 .map(|impl_item_ref| impl_item_ref.id)\n-                .map(|id| tcx.hir().local_def_id(id.hir_id)),\n+                .map(|id| tcx.hir().local_def_id(id.hir_id).to_def_id()),\n         ),\n         hir::ItemKind::TraitAlias(..) => &[],\n         _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\"),"}, {"sha": "cd2f3af200e13f4b21375b55b691fc9c14dbdab3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -784,7 +784,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                 }\n                 (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n-                    let ct_def_id = tcx.hir().local_def_id(ct.value.hir_id).expect_local();\n+                    let ct_def_id = tcx.hir().local_def_id(ct.value.hir_id);\n                     ty::Const::from_anon_const(tcx, ct_def_id).into()\n                 }\n                 _ => unreachable!(),\n@@ -2759,7 +2759,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             hir::TyKind::Def(item_id, ref lifetimes) => {\n                 let did = tcx.hir().local_def_id(item_id.id);\n-                self.impl_trait_ty_to_ty(did, lifetimes)\n+                self.impl_trait_ty_to_ty(did.to_def_id(), lifetimes)\n             }\n             hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 debug!(\"ast_ty_to_ty: qself={:?} segment={:?}\", qself, segment);\n@@ -2775,7 +2775,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     .unwrap_or(tcx.types.err)\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n-                let length_def_id = tcx.hir().local_def_id(length.hir_id).expect_local();\n+                let length_def_id = tcx.hir().local_def_id(length.hir_id);\n                 let length = ty::Const::from_anon_const(tcx, length_def_id);\n                 let array_ty = tcx.mk_ty(ty::Array(self.ast_ty_to_ty(&ty), length));\n                 self.normalize_ty(ast_ty.span, array_ty)"}, {"sha": "fc4ca1e04b97bc400a427d951f798a93339a260b", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -71,49 +71,52 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let expr_def_id = self.tcx.hir().local_def_id(expr.hir_id);\n \n         let ClosureSignatures { bound_sig, liberated_sig } =\n-            self.sig_of_closure(expr_def_id, decl, body, expected_sig);\n+            self.sig_of_closure(expr_def_id.to_def_id(), decl, body, expected_sig);\n \n         debug!(\"check_closure: ty_of_closure returns {:?}\", liberated_sig);\n \n         let generator_types =\n             check_fn(self, self.param_env, liberated_sig, decl, expr.hir_id, body, gen).1;\n \n-        let base_substs =\n-            InternalSubsts::identity_for_item(self.tcx, self.tcx.closure_base_def_id(expr_def_id));\n+        let base_substs = InternalSubsts::identity_for_item(\n+            self.tcx,\n+            self.tcx.closure_base_def_id(expr_def_id.to_def_id()),\n+        );\n         // HACK(eddyb) this hardcodes indices into substs but it should rely on\n         // `ClosureSubsts` and `GeneratorSubsts` providing constructors, instead.\n         // That would also remove the need for most of the inference variables,\n         // as they immediately unified with the actual type below, including\n         // the `InferCtxt::closure_sig` and `ClosureSubsts::sig_ty` methods.\n         let tupled_upvars_idx = base_substs.len() + if generator_types.is_some() { 4 } else { 2 };\n-        let substs = base_substs.extend_to(self.tcx, expr_def_id, |param, _| match param.kind {\n-            GenericParamDefKind::Lifetime => span_bug!(expr.span, \"closure has lifetime param\"),\n-            GenericParamDefKind::Type { .. } => if param.index as usize == tupled_upvars_idx {\n-                self.tcx.mk_tup(self.tcx.upvars(expr_def_id).iter().flat_map(|upvars| {\n-                    upvars.iter().map(|(&var_hir_id, _)| {\n-                        // Create type variables (for now) to represent the transformed\n-                        // types of upvars. These will be unified during the upvar\n-                        // inference phase (`upvar.rs`).\n-                        self.infcx.next_ty_var(TypeVariableOrigin {\n-                            // FIXME(eddyb) distinguish upvar inference variables from the rest.\n-                            kind: TypeVariableOriginKind::ClosureSynthetic,\n-                            span: self.tcx.hir().span(var_hir_id),\n+        let substs =\n+            base_substs.extend_to(self.tcx, expr_def_id.to_def_id(), |param, _| match param.kind {\n+                GenericParamDefKind::Lifetime => span_bug!(expr.span, \"closure has lifetime param\"),\n+                GenericParamDefKind::Type { .. } => if param.index as usize == tupled_upvars_idx {\n+                    self.tcx.mk_tup(self.tcx.upvars(expr_def_id).iter().flat_map(|upvars| {\n+                        upvars.iter().map(|(&var_hir_id, _)| {\n+                            // Create type variables (for now) to represent the transformed\n+                            // types of upvars. These will be unified during the upvar\n+                            // inference phase (`upvar.rs`).\n+                            self.infcx.next_ty_var(TypeVariableOrigin {\n+                                // FIXME(eddyb) distinguish upvar inference variables from the rest.\n+                                kind: TypeVariableOriginKind::ClosureSynthetic,\n+                                span: self.tcx.hir().span(var_hir_id),\n+                            })\n                         })\n+                    }))\n+                } else {\n+                    // Create type variables (for now) to represent the various\n+                    // pieces of information kept in `{Closure,Generic}Substs`.\n+                    // They will either be unified below, or later during the upvar\n+                    // inference phase (`upvar.rs`)\n+                    self.infcx.next_ty_var(TypeVariableOrigin {\n+                        kind: TypeVariableOriginKind::ClosureSynthetic,\n+                        span: expr.span,\n                     })\n-                }))\n-            } else {\n-                // Create type variables (for now) to represent the various\n-                // pieces of information kept in `{Closure,Generic}Substs`.\n-                // They will either be unified below, or later during the upvar\n-                // inference phase (`upvar.rs`)\n-                self.infcx.next_ty_var(TypeVariableOrigin {\n-                    kind: TypeVariableOriginKind::ClosureSynthetic,\n-                    span: expr.span,\n-                })\n-            }\n-            .into(),\n-            GenericParamDefKind::Const => span_bug!(expr.span, \"closure has const param\"),\n-        });\n+                }\n+                .into(),\n+                GenericParamDefKind::Const => span_bug!(expr.span, \"closure has const param\"),\n+            });\n         if let Some(GeneratorTypes { resume_ty, yield_ty, interior, movability }) = generator_types\n         {\n             let generator_substs = substs.as_generator();\n@@ -126,7 +129,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // it should rely on `GeneratorSubsts` providing a constructor, instead.\n             let substs = self.resolve_vars_if_possible(&substs);\n \n-            return self.tcx.mk_generator(expr_def_id, substs, movability);\n+            return self.tcx.mk_generator(expr_def_id.to_def_id(), substs, movability);\n         }\n \n         // Tuple up the arguments and insert the resulting function type into\n@@ -157,7 +160,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // it should rely on `ClosureSubsts` providing a constructor, instead.\n         let substs = self.resolve_vars_if_possible(&substs);\n \n-        let closure_type = self.tcx.mk_closure(expr_def_id, substs);\n+        let closure_type = self.tcx.mk_closure(expr_def_id.to_def_id(), substs);\n \n         debug!(\"check_closure: expr.hir_id={:?} closure_type={:?}\", expr.hir_id, closure_type);\n "}, {"sha": "90a9f8a4d6f7705d938d4a86a1efdfaad3d02f58", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -198,7 +198,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             debug!(\"used_trait_import: {:?}\", import_def_id);\n             Lrc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n                 .unwrap()\n-                .insert(import_def_id);\n+                .insert(import_def_id.to_def_id());\n         }\n \n         self.tcx.check_stability(pick.item.def_id, Some(call_expr.hir_id), span);\n@@ -463,7 +463,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             for import_id in pick.import_ids {\n                 let import_def_id = tcx.hir().local_def_id(import_id);\n                 debug!(\"resolve_ufcs: used_trait_import: {:?}\", import_def_id);\n-                used_trait_imports.insert(import_def_id);\n+                used_trait_imports.insert(import_def_id.to_def_id());\n             }\n         }\n "}, {"sha": "45b384e2656e605692c32691a24ce09f002ca633", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -1258,7 +1258,7 @@ fn compute_all_traits(tcx: TyCtxt<'_>) -> Vec<DefId> {\n             match i.kind {\n                 hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..) => {\n                     let def_id = self.map.local_def_id(i.hir_id);\n-                    self.traits.push(def_id);\n+                    self.traits.push(def_id.to_def_id());\n                 }\n                 _ => (),\n             }"}, {"sha": "1a5862cd5c8f93321a35807e6c97a3361c72148d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 49, "deletions": 40, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -1332,7 +1332,7 @@ fn check_fn<'a, 'tcx>(\n         fcx.resume_yield_tys = Some((resume_ty, yield_ty));\n     }\n \n-    let outer_def_id = tcx.closure_base_def_id(hir.local_def_id(fn_id));\n+    let outer_def_id = tcx.closure_base_def_id(hir.local_def_id(fn_id).to_def_id());\n     let outer_hir_id = hir.as_local_hir_id(outer_def_id).unwrap();\n     GatherLocalsVisitor { fcx: &fcx, parent_id: outer_hir_id }.visit_body(body);\n \n@@ -1470,7 +1470,7 @@ fn check_fn<'a, 'tcx>(\n \n     // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n     if let Some(panic_impl_did) = tcx.lang_items().panic_impl() {\n-        if panic_impl_did == hir.local_def_id(fn_id) {\n+        if panic_impl_did == hir.local_def_id(fn_id).to_def_id() {\n             if let Some(panic_info_did) = tcx.lang_items().panic_info() {\n                 if declared_ret_ty.kind != ty::Never {\n                     sess.span_err(decl.output.span(), \"return type should be `!`\");\n@@ -1514,7 +1514,7 @@ fn check_fn<'a, 'tcx>(\n \n     // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n     if let Some(alloc_error_handler_did) = tcx.lang_items().oom() {\n-        if alloc_error_handler_did == hir.local_def_id(fn_id) {\n+        if alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id() {\n             if let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() {\n                 if declared_ret_ty.kind != ty::Never {\n                     sess.span_err(decl.output.span(), \"return type should be `!`\");\n@@ -1566,23 +1566,23 @@ fn check_struct(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n         check_simd(tcx, span, def_id);\n     }\n \n-    check_transparent(tcx, span, def_id);\n-    check_packed(tcx, span, def_id);\n+    check_transparent(tcx, span, def);\n+    check_packed(tcx, span, def);\n }\n \n fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n     let def_id = tcx.hir().local_def_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n-    check_transparent(tcx, span, def_id);\n+    check_transparent(tcx, span, def);\n     check_union_fields(tcx, span, def_id);\n-    check_packed(tcx, span, def_id);\n+    check_packed(tcx, span, def);\n }\n \n /// When the `#![feature(untagged_unions)]` gate is active,\n /// check that the fields of the `union` does not contain fields that need dropping.\n-fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: DefId) -> bool {\n+fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> bool {\n     let item_type = tcx.type_of(item_def_id);\n     if let ty::Adt(def, substs) = item_type.kind {\n         assert!(def.is_union());\n@@ -1614,7 +1614,7 @@ fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: DefId) -> bool {\n /// projections that would result in \"inheriting lifetimes\".\n fn check_opaque<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n     substs: SubstsRef<'tcx>,\n     span: Span,\n     origin: &hir::OpaqueTyOrigin,\n@@ -1625,9 +1625,10 @@ fn check_opaque<'tcx>(\n \n /// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n /// in \"inheriting lifetimes\".\n-fn check_opaque_for_inheriting_lifetimes(tcx: TyCtxt<'tcx>, def_id: DefId, span: Span) {\n-    let item =\n-        tcx.hir().expect_item(tcx.hir().as_local_hir_id(def_id).expect(\"opaque type is not local\"));\n+fn check_opaque_for_inheriting_lifetimes(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n+    let item = tcx.hir().expect_item(\n+        tcx.hir().as_local_hir_id(def_id.to_def_id()).expect(\"opaque type is not local\"),\n+    );\n     debug!(\n         \"check_opaque_for_inheriting_lifetimes: def_id={:?} span={:?} item={:?}\",\n         def_id, span, item\n@@ -1661,8 +1662,10 @@ fn check_opaque_for_inheriting_lifetimes(tcx: TyCtxt<'tcx>, def_id: DefId, span:\n             ..\n         }) => {\n             let mut visitor = ProhibitOpaqueVisitor {\n-                opaque_identity_ty: tcx\n-                    .mk_opaque(def_id, InternalSubsts::identity_for_item(tcx, def_id)),\n+                opaque_identity_ty: tcx.mk_opaque(\n+                    def_id.to_def_id(),\n+                    InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n+                ),\n                 generics: tcx.generics_of(def_id),\n             };\n             debug!(\"check_opaque_for_inheriting_lifetimes: visitor={:?}\", visitor);\n@@ -1699,12 +1702,13 @@ fn check_opaque_for_inheriting_lifetimes(tcx: TyCtxt<'tcx>, def_id: DefId, span:\n /// Checks that an opaque type does not contain cycles.\n fn check_opaque_for_cycles<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n     substs: SubstsRef<'tcx>,\n     span: Span,\n     origin: &hir::OpaqueTyOrigin,\n ) {\n-    if let Err(partially_expanded_type) = tcx.try_expand_impl_trait_type(def_id, substs) {\n+    if let Err(partially_expanded_type) = tcx.try_expand_impl_trait_type(def_id.to_def_id(), substs)\n+    {\n         if let hir::OpaqueTyOrigin::AsyncFn = origin {\n             struct_span_err!(tcx.sess, span, E0733, \"recursion in an `async fn` requires boxing\",)\n                 .span_label(span, \"recursive `async fn`\")\n@@ -1736,7 +1740,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n     debug!(\n         \"check_item_type(it.hir_id={}, it.name={})\",\n         it.hir_id,\n-        tcx.def_path_str(tcx.hir().local_def_id(it.hir_id))\n+        tcx.def_path_str(tcx.hir().local_def_id(it.hir_id).to_def_id())\n     );\n     let _indenter = indenter();\n     match it.kind {\n@@ -1764,7 +1768,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n         }\n         hir::ItemKind::Trait(_, _, _, _, ref items) => {\n             let def_id = tcx.hir().local_def_id(it.hir_id);\n-            check_on_unimplemented(tcx, def_id, it);\n+            check_on_unimplemented(tcx, def_id.to_def_id(), it);\n \n             for item in items.iter() {\n                 let item = tcx.hir().trait_item(item.id);\n@@ -1783,7 +1787,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n         hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n             let def_id = tcx.hir().local_def_id(it.hir_id);\n \n-            let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+            let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n             check_opaque(tcx, def_id, substs, it.span, &origin);\n         }\n         hir::ItemKind::TyAlias(..) => {\n@@ -1846,7 +1850,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n     }\n }\n \n-fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: DefId, span: Span) {\n+fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: LocalDefId, span: Span) {\n     // Only restricted on wasm32 target for now\n     if !tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n         return;\n@@ -1866,7 +1870,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: DefId, span: Span)\n     // `#[link_section]` may contain arbitrary, or even undefined bytes, but it is\n     // the consumer's responsibility to ensure all bytes that have been read\n     // have defined values.\n-    match tcx.const_eval_poly(id) {\n+    match tcx.const_eval_poly(id.to_def_id()) {\n         Ok(ConstValue::ByRef { alloc, .. }) => {\n             if alloc.relocations().len() != 0 {\n                 let msg = \"statics with a custom `#[link_section]` must be a \\\n@@ -1883,7 +1887,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: DefId, span: Span)\n fn check_on_unimplemented(tcx: TyCtxt<'_>, trait_def_id: DefId, item: &hir::Item<'_>) {\n     let item_def_id = tcx.hir().local_def_id(item.hir_id);\n     // an error would be reported if this fails.\n-    let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item_def_id);\n+    let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item_def_id.to_def_id());\n }\n \n fn report_forbidden_specialization(\n@@ -1987,7 +1991,7 @@ fn check_specialization_validity<'tcx>(\n fn check_impl_items_against_trait<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     full_impl_span: Span,\n-    impl_id: DefId,\n+    impl_id: LocalDefId,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n     impl_item_refs: &[hir::ImplItemRef<'_>],\n ) {\n@@ -2128,13 +2132,19 @@ fn check_impl_items_against_trait<'tcx>(\n                 }\n             }\n \n-            check_specialization_validity(tcx, trait_def, &ty_trait_item, impl_id, impl_item);\n+            check_specialization_validity(\n+                tcx,\n+                trait_def,\n+                &ty_trait_item,\n+                impl_id.to_def_id(),\n+                impl_item,\n+            );\n         }\n     }\n \n     // Check for missing items from trait\n     let mut missing_items = Vec::new();\n-    if let Ok(ancestors) = trait_def.ancestors(tcx, impl_id) {\n+    if let Ok(ancestors) = trait_def.ancestors(tcx, impl_id.to_def_id()) {\n         for trait_item in tcx.associated_items(impl_trait_ref.def_id).in_definition_order() {\n             let is_implemented = ancestors\n                 .leaf_def(tcx, trait_item.ident, trait_item.kind)\n@@ -2358,7 +2368,7 @@ fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n /// Checks whether a type can be represented in memory. In particular, it\n /// identifies types that contain themselves without indirection through a\n /// pointer, which would mean their size is unbounded.\n-fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: DefId) -> bool {\n+fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: LocalDefId) -> bool {\n     let rty = tcx.type_of(item_def_id);\n \n     // Check that it is possible to represent this type. This call identifies\n@@ -2368,7 +2378,7 @@ fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: DefId) -> bool {\n     // caught by case 1.\n     match rty.is_representable(tcx, sp) {\n         Representability::SelfRecursive(spans) => {\n-            let mut err = recursive_type_with_infinite_size_error(tcx, item_def_id);\n+            let mut err = recursive_type_with_infinite_size_error(tcx, item_def_id.to_def_id());\n             for span in spans {\n                 err.span_label(span, \"recursive without indirection\");\n             }\n@@ -2380,7 +2390,7 @@ fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: DefId) -> bool {\n     true\n }\n \n-pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n+pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n     let t = tcx.type_of(def_id);\n     if let ty::Adt(def, substs) = t.kind {\n         if def.is_struct() {\n@@ -2414,10 +2424,10 @@ pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n     }\n }\n \n-fn check_packed(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n-    let repr = tcx.adt_def(def_id).repr;\n+fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: &ty::AdtDef) {\n+    let repr = def.repr;\n     if repr.packed() {\n-        for attr in tcx.get_attrs(def_id).iter() {\n+        for attr in tcx.get_attrs(def.did).iter() {\n             for r in attr::find_repr_attrs(&tcx.sess.parse_sess, attr) {\n                 if let attr::ReprPacked(pack) = r {\n                     if let Some(repr_pack) = repr.pack {\n@@ -2443,7 +2453,7 @@ fn check_packed(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n             )\n             .emit();\n         } else {\n-            if let Some(def_spans) = check_packed_inner(tcx, def_id, &mut vec![]) {\n+            if let Some(def_spans) = check_packed_inner(tcx, def.did, &mut vec![]) {\n                 let mut err = struct_span_err!(\n                     tcx.sess,\n                     sp,\n@@ -2471,7 +2481,7 @@ fn check_packed(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n                                     &if first {\n                                         format!(\n                                             \"`{}` contains a field of type `{}`\",\n-                                            tcx.type_of(def_id),\n+                                            tcx.type_of(def.did),\n                                             ident\n                                         )\n                                     } else {\n@@ -2564,8 +2574,7 @@ fn bad_non_zero_sized_fields<'tcx>(\n     err.emit();\n }\n \n-fn check_transparent(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n-    let adt = tcx.adt_def(def_id);\n+fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: &'tcx ty::AdtDef) {\n     if !adt.repr.transparent() {\n         return;\n     }\n@@ -2582,7 +2591,7 @@ fn check_transparent(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n     }\n \n     if adt.variants.len() != 1 {\n-        bad_variant_count(tcx, adt, sp, def_id);\n+        bad_variant_count(tcx, adt, sp, adt.did);\n         if adt.variants.is_empty() {\n             // Don't bother checking the fields. No variants (and thus no fields) exist.\n             return;\n@@ -2634,7 +2643,7 @@ pub fn check_enum<'tcx>(\n     def.destructor(tcx); // force the destructor to be evaluated\n \n     if vs.is_empty() {\n-        let attributes = tcx.get_attrs(def_id);\n+        let attributes = tcx.get_attrs(def_id.to_def_id());\n         if let Some(attr) = attr::find_by_name(&attributes, sym::repr) {\n             struct_span_err!(\n                 tcx.sess,\n@@ -2714,7 +2723,7 @@ pub fn check_enum<'tcx>(\n     }\n \n     check_representable(tcx, sp, def_id);\n-    check_transparent(tcx, sp, def_id);\n+    check_transparent(tcx, sp, def);\n }\n \n fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span) {\n@@ -3243,7 +3252,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let (value, opaque_type_map) =\n             self.register_infer_ok_obligations(self.instantiate_opaque_types(\n-                parent_def_id,\n+                parent_def_id.to_def_id(),\n                 self.body_id,\n                 self.param_env,\n                 value,\n@@ -3348,7 +3357,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn to_const(&self, ast_c: &hir::AnonConst) -> &'tcx ty::Const<'tcx> {\n-        let const_def_id = self.tcx.hir().local_def_id(ast_c.hir_id).expect_local();\n+        let const_def_id = self.tcx.hir().local_def_id(ast_c.hir_id);\n         let c = ty::Const::from_anon_const(self.tcx, const_def_id);\n \n         // HACK(eddyb) emulate what a `WellFormedConst` obligation would do."}, {"sha": "58c8d56b55838883c19bcc23fe4d2e4ca10c4474", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -135,7 +135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self,\n             RepeatingScope(item_id),\n             item_id,\n-            Subject(subject),\n+            Subject(subject.to_def_id()),\n             self.param_env,\n         );\n         rcx.outlives_environment.add_implied_bounds(self, wf_tys, item_id, span);"}, {"sha": "3ff79a6b5de6c921b6b9f8c036b28061f489cee4", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -226,7 +226,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let upvar_ty = self.node_ty(var_hir_id);\n                     let upvar_id = ty::UpvarId {\n                         var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                        closure_expr_id: closure_def_id.expect_local(),\n+                        closure_expr_id: closure_def_id,\n                     };\n                     let capture = self.tables.borrow().upvar_capture(upvar_id);\n "}, {"sha": "574e5a4f8f1cc939420f71d6147d36e923b8b241", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -5,7 +5,7 @@ use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::itemlikevisit::ParItemLikeVisitor;\n use rustc_hir::lang_items;\n use rustc_hir::ItemKind;\n@@ -195,10 +195,10 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: DefId) {\n     check_associated_item(tcx, trait_item.hir_id, trait_item.span, method_sig);\n }\n \n-fn could_be_self(trait_def_id: DefId, ty: &hir::Ty<'_>) -> bool {\n+fn could_be_self(trait_def_id: LocalDefId, ty: &hir::Ty<'_>) -> bool {\n     match ty.kind {\n         hir::TyKind::TraitObject([trait_ref], ..) => match trait_ref.trait_ref.path.segments {\n-            [s] => s.res.and_then(|r| r.opt_def_id()) == Some(trait_def_id),\n+            [s] => s.res.and_then(|r| r.opt_def_id()) == Some(trait_def_id.to_def_id()),\n             _ => false,\n         },\n         _ => false,\n@@ -330,7 +330,7 @@ fn for_item<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>) -> CheckWfFcxBuilder<\n }\n \n fn for_id(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) -> CheckWfFcxBuilder<'_> {\n-    let def_id = tcx.hir().local_def_id(id).expect_local();\n+    let def_id = tcx.hir().local_def_id(id);\n     CheckWfFcxBuilder {\n         inherited: Inherited::build(tcx, def_id),\n         id,\n@@ -413,7 +413,7 @@ fn check_type_defn<'tcx, F>(\n             }\n         }\n \n-        check_where_clauses(tcx, fcx, item.span, def_id, None);\n+        check_where_clauses(tcx, fcx, item.span, def_id.to_def_id(), None);\n \n         // No implied bounds in a struct definition.\n         vec![]\n@@ -441,8 +441,8 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n     }\n \n     for_item(tcx, item).with_fcx(|fcx, _| {\n-        check_where_clauses(tcx, fcx, item.span, trait_def_id, None);\n-        check_associated_type_defaults(fcx, trait_def_id);\n+        check_where_clauses(tcx, fcx, item.span, trait_def_id.to_def_id(), None);\n+        check_associated_type_defaults(fcx, trait_def_id.to_def_id());\n \n         vec![]\n     });\n@@ -555,7 +555,15 @@ fn check_item_fn(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n             ItemKind::Fn(sig, ..) => sig,\n             _ => bug!(\"expected `ItemKind::Fn`, found `{:?}`\", item.kind),\n         };\n-        check_fn_or_method(tcx, fcx, item.ident.span, sig, hir_sig, def_id, &mut implied_bounds);\n+        check_fn_or_method(\n+            tcx,\n+            fcx,\n+            item.ident.span,\n+            sig,\n+            hir_sig,\n+            def_id.to_def_id(),\n+            &mut implied_bounds,\n+        );\n         implied_bounds\n     })\n }\n@@ -631,9 +639,9 @@ fn check_impl<'tcx>(\n             }\n         }\n \n-        check_where_clauses(tcx, fcx, item.span, item_def_id, None);\n+        check_where_clauses(tcx, fcx, item.span, item_def_id.to_def_id(), None);\n \n-        fcx.impl_implied_bounds(item_def_id, item.span)\n+        fcx.impl_implied_bounds(item_def_id.to_def_id(), item.span)\n     });\n }\n "}, {"sha": "83f5ba18ad7ea06717da8e253050fc6efe6b82bc", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -42,7 +42,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // This attribute causes us to dump some writeback information\n         // in the form of errors, which is uSymbol for unit tests.\n-        let rustc_dump_user_substs = self.tcx.has_attr(item_def_id, sym::rustc_dump_user_substs);\n+        let rustc_dump_user_substs =\n+            self.tcx.has_attr(item_def_id.to_def_id(), sym::rustc_dump_user_substs);\n \n         let mut wbcx = WritebackCx::new(self, body, rustc_dump_user_substs);\n         for param in body.params {"}, {"sha": "bb2e077ceb03ccf0f09b97c4e348ec4feca19ae6", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -50,7 +50,7 @@ impl CheckVisitor<'tcx> {\n             return;\n         }\n \n-        if self.used_trait_imports.contains(&def_id) {\n+        if self.used_trait_imports.contains(&def_id.to_def_id()) {\n             return;\n         }\n \n@@ -216,7 +216,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a, 'tcx> {\n         if let hir::ItemKind::ExternCrate(orig_name) = item.kind {\n             let extern_crate_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             self.crates_to_lint.push(ExternCrateToLint {\n-                def_id: extern_crate_def_id,\n+                def_id: extern_crate_def_id.to_def_id(),\n                 span: item.span,\n                 orig_name,\n                 warn_if_unused: !item.ident.as_str().starts_with('_'),"}, {"sha": "7cfb7fa712cca8e810f0d135553aee21e181ff64", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 143, "deletions": 145, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -3,7 +3,7 @@\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::UnsizeTraitLangItem;\n use rustc_hir::ItemKind;\n use rustc_infer::infer;\n@@ -35,7 +35,7 @@ struct Checker<'tcx> {\n impl<'tcx> Checker<'tcx> {\n     fn check<F>(&self, trait_def_id: Option<DefId>, mut f: F) -> &Self\n     where\n-        F: FnMut(TyCtxt<'tcx>, DefId),\n+        F: FnMut(TyCtxt<'tcx>, LocalDefId),\n     {\n         if Some(self.trait_def_id) == trait_def_id {\n             for &impl_id in self.tcx.hir().trait_impls(self.trait_def_id) {\n@@ -47,13 +47,14 @@ impl<'tcx> Checker<'tcx> {\n     }\n }\n \n-fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: DefId) {\n+fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     // Destructors only work on nominal types.\n     if let ty::Adt(..) | ty::Error = tcx.type_of(impl_did).kind {\n         return;\n     }\n \n-    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).expect(\"foreign Drop impl on non-ADT\");\n+    let impl_hir_id =\n+        tcx.hir().as_local_hir_id(impl_did.to_def_id()).expect(\"foreign Drop impl on non-ADT\");\n     let sp = match tcx.hir().expect_item(impl_hir_id).kind {\n         ItemKind::Impl { self_ty, .. } => self_ty.span,\n         _ => bug!(\"expected Drop impl item\"),\n@@ -69,10 +70,10 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: DefId) {\n     .emit();\n }\n \n-fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: DefId) {\n+fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_copy: impl_did={:?}\", impl_did);\n \n-    let impl_hir_id = if let Some(n) = tcx.hir().as_local_hir_id(impl_did) {\n+    let impl_hir_id = if let Some(n) = tcx.hir().as_local_hir_id(impl_did.to_def_id()) {\n         n\n     } else {\n         debug!(\"visit_implementation_of_copy(): impl not in this crate\");\n@@ -137,187 +138,184 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: DefId) {\n     }\n }\n \n-fn visit_implementation_of_coerce_unsized(tcx: TyCtxt<'tcx>, impl_did: DefId) {\n+fn visit_implementation_of_coerce_unsized(tcx: TyCtxt<'tcx>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_coerce_unsized: impl_did={:?}\", impl_did);\n \n     // Just compute this for the side-effects, in particular reporting\n     // errors; other parts of the code may demand it for the info of\n     // course.\n-    if impl_did.is_local() {\n-        let span = tcx.def_span(impl_did);\n-        tcx.at(span).coerce_unsized_info(impl_did);\n-    }\n+    let span = tcx.def_span(impl_did);\n+    tcx.at(span).coerce_unsized_info(impl_did);\n }\n \n-fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: DefId) {\n+fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_dispatch_from_dyn: impl_did={:?}\", impl_did);\n-    if impl_did.is_local() {\n-        let dispatch_from_dyn_trait = tcx.lang_items().dispatch_from_dyn_trait().unwrap();\n \n-        let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).unwrap();\n-        let span = tcx.hir().span(impl_hir_id);\n+    let dispatch_from_dyn_trait = tcx.lang_items().dispatch_from_dyn_trait().unwrap();\n \n-        let source = tcx.type_of(impl_did);\n-        assert!(!source.has_escaping_bound_vars());\n-        let target = {\n-            let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n-            assert_eq!(trait_ref.def_id, dispatch_from_dyn_trait);\n+    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did.to_def_id()).unwrap();\n+    let span = tcx.hir().span(impl_hir_id);\n \n-            trait_ref.substs.type_at(1)\n-        };\n+    let source = tcx.type_of(impl_did);\n+    assert!(!source.has_escaping_bound_vars());\n+    let target = {\n+        let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n+        assert_eq!(trait_ref.def_id, dispatch_from_dyn_trait);\n \n-        debug!(\"visit_implementation_of_dispatch_from_dyn: {:?} -> {:?}\", source, target);\n+        trait_ref.substs.type_at(1)\n+    };\n+\n+    debug!(\"visit_implementation_of_dispatch_from_dyn: {:?} -> {:?}\", source, target);\n \n-        let param_env = tcx.param_env(impl_did);\n+    let param_env = tcx.param_env(impl_did);\n \n-        let create_err = |msg: &str| struct_span_err!(tcx.sess, span, E0378, \"{}\", msg);\n+    let create_err = |msg: &str| struct_span_err!(tcx.sess, span, E0378, \"{}\", msg);\n \n-        tcx.infer_ctxt().enter(|infcx| {\n-            let cause = ObligationCause::misc(span, impl_hir_id);\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let cause = ObligationCause::misc(span, impl_hir_id);\n \n-            use ty::TyKind::*;\n-            match (&source.kind, &target.kind) {\n-                (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n-                    if infcx.at(&cause, param_env).eq(r_a, r_b).is_ok() && mutbl_a == *mutbl_b => {}\n-                (&RawPtr(tm_a), &RawPtr(tm_b)) if tm_a.mutbl == tm_b.mutbl => (),\n-                (&Adt(def_a, substs_a), &Adt(def_b, substs_b))\n-                    if def_a.is_struct() && def_b.is_struct() =>\n-                {\n-                    if def_a != def_b {\n-                        let source_path = tcx.def_path_str(def_a.did);\n-                        let target_path = tcx.def_path_str(def_b.did);\n+        use ty::TyKind::*;\n+        match (&source.kind, &target.kind) {\n+            (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n+                if infcx.at(&cause, param_env).eq(r_a, r_b).is_ok() && mutbl_a == *mutbl_b => {}\n+            (&RawPtr(tm_a), &RawPtr(tm_b)) if tm_a.mutbl == tm_b.mutbl => (),\n+            (&Adt(def_a, substs_a), &Adt(def_b, substs_b))\n+                if def_a.is_struct() && def_b.is_struct() =>\n+            {\n+                if def_a != def_b {\n+                    let source_path = tcx.def_path_str(def_a.did);\n+                    let target_path = tcx.def_path_str(def_b.did);\n \n-                        create_err(&format!(\n-                            \"the trait `DispatchFromDyn` may only be implemented \\\n+                    create_err(&format!(\n+                        \"the trait `DispatchFromDyn` may only be implemented \\\n                                 for a coercion between structures with the same \\\n                                 definition; expected `{}`, found `{}`\",\n-                            source_path, target_path,\n-                        ))\n-                        .emit();\n+                        source_path, target_path,\n+                    ))\n+                    .emit();\n \n-                        return;\n-                    }\n+                    return;\n+                }\n \n-                    if def_a.repr.c() || def_a.repr.packed() {\n-                        create_err(\n-                            \"structs implementing `DispatchFromDyn` may not have \\\n+                if def_a.repr.c() || def_a.repr.packed() {\n+                    create_err(\n+                        \"structs implementing `DispatchFromDyn` may not have \\\n                              `#[repr(packed)]` or `#[repr(C)]`\",\n-                        )\n-                        .emit();\n-                    }\n+                    )\n+                    .emit();\n+                }\n \n-                    let fields = &def_a.non_enum_variant().fields;\n+                let fields = &def_a.non_enum_variant().fields;\n \n-                    let coerced_fields = fields\n-                        .iter()\n-                        .filter_map(|field| {\n-                            let ty_a = field.ty(tcx, substs_a);\n-                            let ty_b = field.ty(tcx, substs_b);\n+                let coerced_fields = fields\n+                    .iter()\n+                    .filter_map(|field| {\n+                        let ty_a = field.ty(tcx, substs_a);\n+                        let ty_b = field.ty(tcx, substs_b);\n \n-                            if let Ok(layout) = tcx.layout_of(param_env.and(ty_a)) {\n-                                if layout.is_zst() && layout.align.abi.bytes() == 1 {\n-                                    // ignore ZST fields with alignment of 1 byte\n-                                    return None;\n-                                }\n+                        if let Ok(layout) = tcx.layout_of(param_env.and(ty_a)) {\n+                            if layout.is_zst() && layout.align.abi.bytes() == 1 {\n+                                // ignore ZST fields with alignment of 1 byte\n+                                return None;\n                             }\n+                        }\n \n-                            if let Ok(ok) = infcx.at(&cause, param_env).eq(ty_a, ty_b) {\n-                                if ok.obligations.is_empty() {\n-                                    create_err(\n-                                        \"the trait `DispatchFromDyn` may only be implemented \\\n+                        if let Ok(ok) = infcx.at(&cause, param_env).eq(ty_a, ty_b) {\n+                            if ok.obligations.is_empty() {\n+                                create_err(\n+                                    \"the trait `DispatchFromDyn` may only be implemented \\\n                                      for structs containing the field being coerced, \\\n                                      ZST fields with 1 byte alignment, and nothing else\",\n-                                    )\n-                                    .note(&format!(\n-                                        \"extra field `{}` of type `{}` is not allowed\",\n-                                        field.ident, ty_a,\n-                                    ))\n-                                    .emit();\n-\n-                                    return None;\n-                                }\n+                                )\n+                                .note(&format!(\n+                                    \"extra field `{}` of type `{}` is not allowed\",\n+                                    field.ident, ty_a,\n+                                ))\n+                                .emit();\n+\n+                                return None;\n                             }\n+                        }\n \n-                            Some(field)\n-                        })\n-                        .collect::<Vec<_>>();\n+                        Some(field)\n+                    })\n+                    .collect::<Vec<_>>();\n \n-                    if coerced_fields.is_empty() {\n-                        create_err(\n-                            \"the trait `DispatchFromDyn` may only be implemented \\\n+                if coerced_fields.is_empty() {\n+                    create_err(\n+                        \"the trait `DispatchFromDyn` may only be implemented \\\n                             for a coercion between structures with a single field \\\n                             being coerced, none found\",\n-                        )\n-                        .emit();\n-                    } else if coerced_fields.len() > 1 {\n-                        create_err(\n-                            \"implementing the `DispatchFromDyn` trait requires multiple coercions\",\n-                        )\n-                        .note(\n-                            \"the trait `DispatchFromDyn` may only be implemented \\\n+                    )\n+                    .emit();\n+                } else if coerced_fields.len() > 1 {\n+                    create_err(\n+                        \"implementing the `DispatchFromDyn` trait requires multiple coercions\",\n+                    )\n+                    .note(\n+                        \"the trait `DispatchFromDyn` may only be implemented \\\n                                 for a coercion between structures with a single field \\\n                                 being coerced\",\n-                        )\n-                        .note(&format!(\n-                            \"currently, {} fields need coercions: {}\",\n-                            coerced_fields.len(),\n-                            coerced_fields\n-                                .iter()\n-                                .map(|field| {\n-                                    format!(\n-                                        \"`{}` (`{}` to `{}`)\",\n-                                        field.ident,\n-                                        field.ty(tcx, substs_a),\n-                                        field.ty(tcx, substs_b),\n-                                    )\n-                                })\n-                                .collect::<Vec<_>>()\n-                                .join(\", \")\n-                        ))\n-                        .emit();\n-                    } else {\n-                        let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n-\n-                        for field in coerced_fields {\n-                            let predicate = predicate_for_trait_def(\n-                                tcx,\n-                                param_env,\n-                                cause.clone(),\n-                                dispatch_from_dyn_trait,\n-                                0,\n-                                field.ty(tcx, substs_a),\n-                                &[field.ty(tcx, substs_b).into()],\n-                            );\n-\n-                            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-                        }\n+                    )\n+                    .note(&format!(\n+                        \"currently, {} fields need coercions: {}\",\n+                        coerced_fields.len(),\n+                        coerced_fields\n+                            .iter()\n+                            .map(|field| {\n+                                format!(\n+                                    \"`{}` (`{}` to `{}`)\",\n+                                    field.ident,\n+                                    field.ty(tcx, substs_a),\n+                                    field.ty(tcx, substs_b),\n+                                )\n+                            })\n+                            .collect::<Vec<_>>()\n+                            .join(\", \")\n+                    ))\n+                    .emit();\n+                } else {\n+                    let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n+\n+                    for field in coerced_fields {\n+                        let predicate = predicate_for_trait_def(\n+                            tcx,\n+                            param_env,\n+                            cause.clone(),\n+                            dispatch_from_dyn_trait,\n+                            0,\n+                            field.ty(tcx, substs_a),\n+                            &[field.ty(tcx, substs_b).into()],\n+                        );\n \n-                        // Check that all transitive obligations are satisfied.\n-                        if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n-                            infcx.report_fulfillment_errors(&errors, None, false);\n-                        }\n+                        fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+                    }\n \n-                        // Finally, resolve all regions.\n-                        let region_scope_tree = region::ScopeTree::default();\n-                        let outlives_env = OutlivesEnvironment::new(param_env);\n-                        infcx.resolve_regions_and_report_errors(\n-                            impl_did,\n-                            &region_scope_tree,\n-                            &outlives_env,\n-                            RegionckMode::default(),\n-                        );\n+                    // Check that all transitive obligations are satisfied.\n+                    if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n+                        infcx.report_fulfillment_errors(&errors, None, false);\n                     }\n+\n+                    // Finally, resolve all regions.\n+                    let region_scope_tree = region::ScopeTree::default();\n+                    let outlives_env = OutlivesEnvironment::new(param_env);\n+                    infcx.resolve_regions_and_report_errors(\n+                        impl_did.to_def_id(),\n+                        &region_scope_tree,\n+                        &outlives_env,\n+                        RegionckMode::default(),\n+                    );\n                 }\n-                _ => {\n-                    create_err(\n-                        \"the trait `DispatchFromDyn` may only be implemented \\\n+            }\n+            _ => {\n+                create_err(\n+                    \"the trait `DispatchFromDyn` may only be implemented \\\n                         for a coercion between structures\",\n-                    )\n-                    .emit();\n-                }\n+                )\n+                .emit();\n             }\n-        })\n-    }\n+        }\n+    })\n }\n \n pub fn coerce_unsized_info(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedInfo {"}, {"sha": "6817312e303ae2f32ef9a4900a20da8082da6769", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -9,7 +9,7 @@\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::{self, CrateInherentImpls, TyCtxt};\n \n@@ -327,7 +327,7 @@ impl InherentCollect<'tcx> {\n             // the implementation does not have any associated traits.\n             let impl_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             let vec = self.impls_map.inherent_impls.entry(def_id).or_default();\n-            vec.push(impl_def_id);\n+            vec.push(impl_def_id.to_def_id());\n         } else {\n             struct_span_err!(\n                 self.tcx.sess,\n@@ -344,18 +344,18 @@ impl InherentCollect<'tcx> {\n \n     fn check_primitive_impl(\n         &self,\n-        impl_def_id: DefId,\n+        impl_def_id: LocalDefId,\n         lang_def_id: Option<DefId>,\n         lang_def_id2: Option<DefId>,\n         lang: &str,\n         ty: &str,\n         span: Span,\n     ) {\n         match (lang_def_id, lang_def_id2) {\n-            (Some(lang_def_id), _) if lang_def_id == impl_def_id => {\n+            (Some(lang_def_id), _) if lang_def_id == impl_def_id.to_def_id() => {\n                 // OK\n             }\n-            (_, Some(lang_def_id)) if lang_def_id == impl_def_id => {\n+            (_, Some(lang_def_id)) if lang_def_id == impl_def_id.to_def_id() => {\n                 // OK\n             }\n             _ => {"}, {"sha": "d8ffb9f6b4c07e080b169b92d7e3b3768ad40c44", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -6,7 +6,7 @@\n // mappings. That mapping code resides here.\n \n use rustc_errors::struct_span_err;\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n@@ -19,15 +19,15 @@ mod orphan;\n mod unsafety;\n \n /// Obtains the span of just the impl header of `impl_def_id`.\n-fn impl_header_span(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Span {\n-    tcx.sess.source_map().guess_head_span(tcx.span_of_impl(impl_def_id).unwrap())\n+fn impl_header_span(tcx: TyCtxt<'_>, impl_def_id: LocalDefId) -> Span {\n+    tcx.sess.source_map().guess_head_span(tcx.span_of_impl(impl_def_id.to_def_id()).unwrap())\n }\n \n-fn check_impl(tcx: TyCtxt<'_>, impl_def_id: DefId, trait_ref: ty::TraitRef<'_>) {\n+fn check_impl(tcx: TyCtxt<'_>, impl_def_id: LocalDefId, trait_ref: ty::TraitRef<'_>) {\n     debug!(\n         \"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n         trait_ref,\n-        tcx.def_path_str(impl_def_id)\n+        tcx.def_path_str(impl_def_id.to_def_id())\n     );\n \n     // Skip impls where one of the self type is an error type.\n@@ -40,7 +40,11 @@ fn check_impl(tcx: TyCtxt<'_>, impl_def_id: DefId, trait_ref: ty::TraitRef<'_>)\n     enforce_empty_impls_for_marker_traits(tcx, impl_def_id, trait_ref.def_id);\n }\n \n-fn enforce_trait_manually_implementable(tcx: TyCtxt<'_>, impl_def_id: DefId, trait_def_id: DefId) {\n+fn enforce_trait_manually_implementable(\n+    tcx: TyCtxt<'_>,\n+    impl_def_id: LocalDefId,\n+    trait_def_id: DefId,\n+) {\n     let did = Some(trait_def_id);\n     let li = tcx.lang_items();\n \n@@ -117,7 +121,11 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt<'_>, impl_def_id: DefId, tra\n \n /// We allow impls of marker traits to overlap, so they can't override impls\n /// as that could make it ambiguous which associated item to use.\n-fn enforce_empty_impls_for_marker_traits(tcx: TyCtxt<'_>, impl_def_id: DefId, trait_def_id: DefId) {\n+fn enforce_empty_impls_for_marker_traits(\n+    tcx: TyCtxt<'_>,\n+    impl_def_id: LocalDefId,\n+    trait_def_id: DefId,\n+) {\n     if !tcx.trait_def(trait_def_id).is_marker {\n         return;\n     }\n@@ -177,7 +185,7 @@ pub fn check_coherence(tcx: TyCtxt<'_>) {\n /// Checks whether an impl overlaps with the automatic `impl Trait for dyn Trait`.\n fn check_object_overlap<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_def_id: DefId,\n+    impl_def_id: LocalDefId,\n     trait_ref: ty::TraitRef<'tcx>,\n ) {\n     let trait_def_id = trait_ref.def_id;"}, {"sha": "71469770f2a33f642f058986d36ef540620fb2f9", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -35,7 +35,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n             let trait_def_id = trait_ref.def_id;\n             let sm = self.tcx.sess.source_map();\n             let sp = sm.guess_head_span(item.span);\n-            match traits::orphan_check(self.tcx, def_id) {\n+            match traits::orphan_check(self.tcx, def_id.to_def_id()) {\n                 Ok(()) => {}\n                 Err(traits::OrphanCheckErr::NonLocalInputType(tys)) => {\n                     let mut err = struct_span_err!("}, {"sha": "936ef0299cca8c87e81eb011cb9dcb40b3085dba", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -26,7 +26,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::weak_lang_items;\n use rustc_hir::{GenericParamKind, Node, Unsafety};\n@@ -497,8 +497,11 @@ fn type_param_predicates(\n     let ty = tcx.mk_ty_param(index, tcx.hir().ty_param_name(param_id));\n \n     // Don't look for bounds where the type parameter isn't in scope.\n-    let parent =\n-        if item_def_id == param_owner_def_id { None } else { tcx.generics_of(item_def_id).parent };\n+    let parent = if item_def_id == param_owner_def_id.to_def_id() {\n+        None\n+    } else {\n+        tcx.generics_of(item_def_id).parent\n+    };\n \n     let mut result = parent\n         .map(|parent| {\n@@ -613,7 +616,7 @@ fn is_param(tcx: TyCtxt<'_>, ast_ty: &hir::Ty<'_>, param_id: hir::HirId) -> bool\n     if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.kind {\n         match path.res {\n             Res::SelfTy(Some(def_id), None) | Res::Def(DefKind::TyParam, def_id) => {\n-                def_id == tcx.hir().local_def_id(param_id)\n+                def_id == tcx.hir().local_def_id(param_id).to_def_id()\n             }\n             _ => false,\n         }\n@@ -647,7 +650,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n-            convert_enum_variant_types(tcx, def_id, &enum_definition.variants);\n+            convert_enum_variant_types(tcx, def_id.to_def_id(), &enum_definition.variants);\n         }\n         hir::ItemKind::Impl { .. } => {\n             tcx.generics_of(def_id);\n@@ -769,7 +772,7 @@ fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId, variants: &[hir::V\n         prev_discr = Some(\n             if let Some(ref e) = variant.disr_expr {\n                 let expr_did = tcx.hir().local_def_id(e.hir_id);\n-                def.eval_explicit_discr(tcx, expr_did)\n+                def.eval_explicit_discr(tcx, expr_did.to_def_id())\n             } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n                 Some(discr)\n             } else {\n@@ -805,16 +808,19 @@ fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId, variants: &[hir::V\n \n fn convert_variant(\n     tcx: TyCtxt<'_>,\n-    variant_did: Option<DefId>,\n-    ctor_did: Option<DefId>,\n+    variant_did: Option<LocalDefId>,\n+    ctor_did: Option<LocalDefId>,\n     ident: Ident,\n     discr: ty::VariantDiscr,\n     def: &hir::VariantData<'_>,\n     adt_kind: ty::AdtKind,\n     parent_did: DefId,\n ) -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<ast::Ident, Span> = Default::default();\n-    let hir_id = tcx.hir().as_local_hir_id(variant_did.unwrap_or(parent_did)).unwrap();\n+    let hir_id = tcx\n+        .hir()\n+        .as_local_hir_id(variant_did.map(LocalDefId::to_def_id).unwrap_or(parent_did))\n+        .unwrap();\n     let fields = def\n         .fields()\n         .iter()\n@@ -837,7 +843,7 @@ fn convert_variant(\n             }\n \n             ty::FieldDef {\n-                did: fid,\n+                did: fid.to_def_id(),\n                 ident: f.ident,\n                 vis: ty::Visibility::from_hir(&f.vis, hir_id, tcx),\n             }\n@@ -850,8 +856,8 @@ fn convert_variant(\n     ty::VariantDef::new(\n         tcx,\n         ident,\n-        variant_did,\n-        ctor_did,\n+        variant_did.map(LocalDefId::to_def_id),\n+        ctor_did.map(LocalDefId::to_def_id),\n         discr,\n         fields,\n         CtorKind::from_hir(def),\n@@ -884,7 +890,7 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n \n                     let discr = if let Some(ref e) = v.disr_expr {\n                         distance_from_explicit = 0;\n-                        ty::VariantDiscr::Explicit(tcx.hir().local_def_id(e.hir_id))\n+                        ty::VariantDiscr::Explicit(tcx.hir().local_def_id(e.hir_id).to_def_id())\n                     } else {\n                         ty::VariantDiscr::Relative(distance_from_explicit)\n                     };\n@@ -906,7 +912,7 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n             (AdtKind::Enum, variants)\n         }\n         ItemKind::Struct(ref def, _) => {\n-            let variant_did = None;\n+            let variant_did = None::<LocalDefId>;\n             let ctor_did = def.ctor_hir_id().map(|hir_id| tcx.hir().local_def_id(hir_id));\n \n             let variants = std::iter::once(convert_variant(\n@@ -1170,7 +1176,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n         | Node::Ctor(..)\n         | Node::Field(_) => {\n             let parent_id = tcx.hir().get_parent_item(hir_id);\n-            Some(tcx.hir().local_def_id(parent_id))\n+            Some(tcx.hir().local_def_id(parent_id).to_def_id())\n         }\n         // FIXME(#43408) enable this always when we get lazy normalization.\n         Node::AnonConst(_) => {\n@@ -1181,7 +1187,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             // `feature(const_generics)` is enabled, so that const expressions\n             // used with const generics, e.g. `Foo<{N+1}>`, can work at all.\n             if tcx.features().const_generics {\n-                Some(parent_def_id)\n+                Some(parent_def_id.to_def_id())\n             } else {\n                 let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n                 match parent_node {\n@@ -1191,7 +1197,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                     Node::Expr(&Expr { kind: ExprKind::Repeat(_, ref constant), .. })\n                         if constant.hir_id == hir_id =>\n                     {\n-                        Some(parent_def_id)\n+                        Some(parent_def_id.to_def_id())\n                     }\n \n                     _ => None,\n@@ -1214,7 +1220,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                         if let Node::Item(hir::Item { kind: ItemKind::OpaqueTy(..), .. }) =\n                             tcx.hir().get(parent_id)\n                         {\n-                            Some(tcx.hir().local_def_id(parent_id))\n+                            Some(tcx.hir().local_def_id(parent_id).to_def_id())\n                         } else {\n                             None\n                         }\n@@ -1261,7 +1267,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                     opt_self = Some(ty::GenericParamDef {\n                         index: 0,\n                         name: kw::SelfUpper,\n-                        def_id: tcx.hir().local_def_id(param_id),\n+                        def_id: tcx.hir().local_def_id(param_id).to_def_id(),\n                         pure_wrt_drop: false,\n                         kind: ty::GenericParamDefKind::Type {\n                             has_default: false,\n@@ -1304,7 +1310,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n     params.extend(early_lifetimes.enumerate().map(|(i, param)| ty::GenericParamDef {\n         name: param.name.ident().name,\n         index: own_start + i as u32,\n-        def_id: tcx.hir().local_def_id(param.hir_id),\n+        def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n         pure_wrt_drop: param.pure_wrt_drop,\n         kind: ty::GenericParamDefKind::Lifetime,\n     }));\n@@ -1350,7 +1356,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             let param_def = ty::GenericParamDef {\n                 index: type_start + i as u32,\n                 name: param.name.ident().name,\n-                def_id: tcx.hir().local_def_id(param.hir_id),\n+                def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n                 pure_wrt_drop: param.pure_wrt_drop,\n                 kind,\n             };\n@@ -1366,7 +1372,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             let param_def = ty::GenericParamDef {\n                 index: type_start + i as u32,\n                 name: param.name.ident().name,\n-                def_id: tcx.hir().local_def_id(param.hir_id),\n+                def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n                 pure_wrt_drop: param.pure_wrt_drop,\n                 kind: ty::GenericParamDefKind::Const,\n             };\n@@ -1845,7 +1851,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     let mut index = parent_count + has_own_self as u32;\n     for param in early_bound_lifetimes_from_generics(tcx, ast_generics) {\n         let region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            def_id: tcx.hir().local_def_id(param.hir_id),\n+            def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n             index,\n             name: param.name.ident().name,\n         }));\n@@ -2064,12 +2070,13 @@ fn associated_item_predicates(\n         // the `Binder` around the the predicate.\n         //\n         // FIXME(generic_associated_types): Currently only lifetimes are handled.\n-        self_trait_ref.substs.extend_to(tcx, item_def_id, mk_bound_param)\n+        self_trait_ref.substs.extend_to(tcx, item_def_id.to_def_id(), mk_bound_param)\n     } else {\n         self_trait_ref.substs\n     };\n \n-    let assoc_ty = tcx.mk_projection(tcx.hir().local_def_id(trait_item.hir_id), bound_substs);\n+    let assoc_ty =\n+        tcx.mk_projection(tcx.hir().local_def_id(trait_item.hir_id).to_def_id(), bound_substs);\n \n     let bounds = AstConv::compute_bounds(\n         &ItemCtxt::new(tcx, def_id),"}, {"sha": "5d05cfe74a199ce0ddd833c493e583b19974f48c", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -484,13 +484,13 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n             if let hir::ExprKind::Closure(..) = ex.kind {\n                 let def_id = self.tcx.hir().local_def_id(ex.hir_id);\n-                self.check(def_id);\n+                self.check(def_id.to_def_id());\n             }\n             intravisit::walk_expr(self, ex);\n         }\n         fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n-            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n+            let def_id = self.tcx.hir().local_def_id(it.hir_id).to_def_id();\n             // The opaque type itself or its children are not within its reveal scope.\n             if def_id != self.def_id {\n                 self.check(def_id);\n@@ -499,7 +499,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n-            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n+            let def_id = self.tcx.hir().local_def_id(it.hir_id).to_def_id();\n             // The opaque type itself or its children are not within its reveal scope.\n             if def_id != self.def_id {\n                 self.check(def_id);\n@@ -509,7 +509,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n             let def_id = self.tcx.hir().local_def_id(it.hir_id);\n-            self.check(def_id);\n+            self.check(def_id.to_def_id());\n             intravisit::walk_trait_item(self, it);\n         }\n     }"}, {"sha": "2244a89f12963ad47bd826e4924ba923f5d850f3", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -519,7 +519,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             for &var_id in upvars.keys() {\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath { hir_id: var_id },\n-                    closure_expr_id: closure_def_id.expect_local(),\n+                    closure_expr_id: closure_def_id,\n                 };\n                 let upvar_capture = self.mc.tables.upvar_capture(upvar_id);\n                 let captured_place = return_if_err!(self.cat_captured_var("}, {"sha": "e13d9ea2b262647ff78d860866bf4544685e9051", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -14,7 +14,7 @@ use min_specialization::check_min_specialization;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n@@ -59,7 +59,7 @@ pub fn impl_wf_check(tcx: TyCtxt<'_>) {\n     // but it's one that we must perform earlier than the rest of\n     // WfCheck.\n     for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().check_mod_impl_wf(tcx.hir().local_def_id(module));\n+        tcx.ensure().check_mod_impl_wf(tcx.hir().local_def_id(module).to_def_id());\n     }\n }\n \n@@ -85,7 +85,7 @@ impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n             enforce_impl_params_are_constrained(self.tcx, impl_def_id, items);\n             enforce_impl_items_are_distinct(self.tcx, items);\n             if self.min_specialization {\n-                check_min_specialization(self.tcx, impl_def_id, item.span);\n+                check_min_specialization(self.tcx, impl_def_id.to_def_id(), item.span);\n             }\n         }\n     }\n@@ -97,7 +97,7 @@ impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n \n fn enforce_impl_params_are_constrained(\n     tcx: TyCtxt<'_>,\n-    impl_def_id: DefId,\n+    impl_def_id: LocalDefId,\n     impl_item_refs: &[hir::ImplItemRef<'_>],\n ) {\n     // Every lifetime used in an associated type must be constrained."}, {"sha": "04e037c83adf53f5349549593019c3fadf4cf568", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -378,7 +378,7 @@ pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n     // scope.  This is derived from the enclosing item-like thing.\n     let env_node_id = tcx.hir().get_parent_item(hir_ty.hir_id);\n     let env_def_id = tcx.hir().local_def_id(env_node_id);\n-    let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n+    let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n \n     astconv::AstConv::ast_ty_to_ty(&item_cx, hir_ty)\n }\n@@ -393,7 +393,7 @@ pub fn hir_trait_to_predicates<'tcx>(\n     // scope.  This is derived from the enclosing item-like thing.\n     let env_hir_id = tcx.hir().get_parent_item(hir_trait.hir_ref_id);\n     let env_def_id = tcx.hir().local_def_id(env_hir_id);\n-    let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n+    let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n     let mut bounds = Bounds::default();\n     let _ = AstConv::instantiate_poly_trait_ref_inner(\n         &item_cx,"}, {"sha": "6a9cbc544f85792dc541163648219144084e02a9", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -53,7 +53,7 @@ pub struct InferVisitor<'cx, 'tcx> {\n \n impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let item_did = self.tcx.hir().local_def_id(item.hir_id);\n+        let item_did = self.tcx.hir().local_def_id(item.hir_id).to_def_id();\n \n         debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n "}, {"sha": "abe9319d71c591438c5faa42a46949d6ba107468", "filename": "src/librustc_typeck/outlives/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -18,7 +18,7 @@ impl ItemLikeVisitor<'tcx> for OutlivesTest<'tcx> {\n \n         // For unit testing: check for a special \"rustc_outlives\"\n         // attribute and report an error with various results if found.\n-        if self.tcx.has_attr(item_def_id, sym::rustc_outlives) {\n+        if self.tcx.has_attr(item_def_id.to_def_id(), sym::rustc_outlives) {\n             let inferred_outlives_of = self.tcx.inferred_outlives_of(item_def_id);\n             struct_span_err!(self.tcx.sess, item.span, E0640, \"{:?}\", inferred_outlives_of).emit();\n         }"}, {"sha": "83be3e2c8780257b938f568797195e9b281815b5", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -121,7 +121,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn visit_node_helper(&mut self, id: hir::HirId) {\n         let tcx = self.terms_cx.tcx;\n         let def_id = tcx.hir().local_def_id(id);\n-        self.build_constraints_for_item(def_id);\n+        self.build_constraints_for_item(def_id.to_def_id());\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {"}, {"sha": "7402117a7ebb1aca558d4f33e6aac1e5e6965f9d", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -115,7 +115,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                     }\n                 }\n \n-                (def_id, &*variances)\n+                (def_id.to_def_id(), &*variances)\n             })\n             .collect()\n     }"}, {"sha": "1aab89310c6e881ccc41eb096fb2051e7a63da8e", "filename": "src/librustc_typeck/variance/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -18,7 +18,7 @@ impl ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {\n \n         // For unit testing: check for a special \"rustc_variance\"\n         // attribute and report an error with various results if found.\n-        if self.tcx.has_attr(item_def_id, sym::rustc_variance) {\n+        if self.tcx.has_attr(item_def_id.to_def_id(), sym::rustc_variance) {\n             let variances_of = self.tcx.variances_of(item_def_id);\n             struct_span_err!(self.tcx.sess, item.span, E0208, \"{:?}\", variances_of).emit();\n         }"}, {"sha": "f7e61a723dabaf64c24e5cc90cbfbc364921543c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 45, "deletions": 41, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -137,15 +137,16 @@ impl Clean<ExternalCrate> for CrateNum {\n                 .filter_map(|&id| {\n                     let item = cx.tcx.hir().expect_item(id.id);\n                     match item.kind {\n-                        hir::ItemKind::Mod(_) => {\n-                            as_primitive(Res::Def(DefKind::Mod, cx.tcx.hir().local_def_id(id.id)))\n-                        }\n+                        hir::ItemKind::Mod(_) => as_primitive(Res::Def(\n+                            DefKind::Mod,\n+                            cx.tcx.hir().local_def_id(id.id).to_def_id(),\n+                        )),\n                         hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                             if item.vis.node.is_pub() =>\n                         {\n                             as_primitive(path.res).map(|(_, prim, attrs)| {\n                                 // Pretend the primitive is local.\n-                                (cx.tcx.hir().local_def_id(id.id), prim, attrs)\n+                                (cx.tcx.hir().local_def_id(id.id).to_def_id(), prim, attrs)\n                             })\n                         }\n                         _ => None,\n@@ -191,14 +192,15 @@ impl Clean<ExternalCrate> for CrateNum {\n                 .filter_map(|&id| {\n                     let item = cx.tcx.hir().expect_item(id.id);\n                     match item.kind {\n-                        hir::ItemKind::Mod(_) => {\n-                            as_keyword(Res::Def(DefKind::Mod, cx.tcx.hir().local_def_id(id.id)))\n-                        }\n+                        hir::ItemKind::Mod(_) => as_keyword(Res::Def(\n+                            DefKind::Mod,\n+                            cx.tcx.hir().local_def_id(id.id).to_def_id(),\n+                        )),\n                         hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                             if item.vis.node.is_pub() =>\n                         {\n                             as_keyword(path.res).map(|(_, prim, attrs)| {\n-                                (cx.tcx.hir().local_def_id(id.id), prim, attrs)\n+                                (cx.tcx.hir().local_def_id(id.id).to_def_id(), prim, attrs)\n                             })\n                         }\n                         _ => None,\n@@ -273,7 +275,7 @@ impl Clean<Item> for doctree::Module<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             inner: ModuleItem(Module { is_crate: self.is_crate, items }),\n         }\n     }\n@@ -624,7 +626,7 @@ impl Clean<GenericParamDef> for hir::GenericParam<'_> {\n             hir::GenericParamKind::Type { ref default, synthetic } => (\n                 self.name.ident().name.clean(cx),\n                 GenericParamDefKind::Type {\n-                    did: cx.tcx.hir().local_def_id(self.hir_id),\n+                    did: cx.tcx.hir().local_def_id(self.hir_id).to_def_id(),\n                     bounds: self.bounds.clean(cx),\n                     default: default.clean(cx),\n                     synthetic,\n@@ -633,7 +635,7 @@ impl Clean<GenericParamDef> for hir::GenericParam<'_> {\n             hir::GenericParamKind::Const { ref ty } => (\n                 self.name.ident().name.clean(cx),\n                 GenericParamDefKind::Const {\n-                    did: cx.tcx.hir().local_def_id(self.hir_id),\n+                    did: cx.tcx.hir().local_def_id(self.hir_id).to_def_id(),\n                     ty: ty.clean(cx),\n                 },\n             ),\n@@ -894,7 +896,7 @@ impl Clean<Item> for doctree::Function<'_> {\n             enter_impl_trait(cx, || (self.generics.clean(cx), (self.decl, self.body).clean(cx)));\n \n         let did = cx.tcx.hir().local_def_id(self.id);\n-        let constness = if is_min_const_fn(cx.tcx, did) {\n+        let constness = if is_min_const_fn(cx.tcx, did.to_def_id()) {\n             hir::Constness::Const\n         } else {\n             hir::Constness::NotConst\n@@ -907,7 +909,7 @@ impl Clean<Item> for doctree::Function<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            def_id: did,\n+            def_id: did.to_def_id(),\n             inner: FunctionItem(Function {\n                 decl,\n                 generics,\n@@ -1016,7 +1018,7 @@ impl Clean<Item> for doctree::Trait<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs,\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -1039,7 +1041,7 @@ impl Clean<Item> for doctree::TraitAlias<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs,\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -1120,10 +1122,10 @@ impl Clean<Item> for hir::TraitItem<'_> {\n             name: Some(self.ident.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: local_did,\n+            def_id: local_did.to_def_id(),\n             visibility: Visibility::Inherited,\n-            stability: get_stability(cx, local_did),\n-            deprecation: get_deprecation(cx, local_did),\n+            stability: get_stability(cx, local_did.to_def_id()),\n+            deprecation: get_deprecation(cx, local_did.to_def_id()),\n             inner,\n         }\n     }\n@@ -1153,10 +1155,10 @@ impl Clean<Item> for hir::ImplItem<'_> {\n             name: Some(self.ident.name.clean(cx)),\n             source: self.span.clean(cx),\n             attrs: self.attrs.clean(cx),\n-            def_id: local_did,\n+            def_id: local_did.to_def_id(),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, local_did),\n-            deprecation: get_deprecation(cx, local_did),\n+            stability: get_stability(cx, local_did.to_def_id()),\n+            deprecation: get_deprecation(cx, local_did.to_def_id()),\n             inner,\n         }\n     }\n@@ -1348,7 +1350,7 @@ impl Clean<Type> for hir::Ty<'_> {\n             TyKind::Slice(ref ty) => Slice(box ty.clean(cx)),\n             TyKind::Array(ref ty, ref length) => {\n                 let def_id = cx.tcx.hir().local_def_id(length.hir_id);\n-                let length = match cx.tcx.const_eval_poly(def_id) {\n+                let length = match cx.tcx.const_eval_poly(def_id.to_def_id()) {\n                     Ok(length) => {\n                         print_const(cx, ty::Const::from_value(cx.tcx, length, cx.tcx.types.usize))\n                     }\n@@ -1415,7 +1417,7 @@ impl Clean<Type> for hir::Ty<'_> {\n                                     if let Some(lt) = lifetime.cloned() {\n                                         if !lt.is_elided() {\n                                             let lt_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n-                                            lt_substs.insert(lt_def_id, lt.clean(cx));\n+                                            lt_substs.insert(lt_def_id.to_def_id(), lt.clean(cx));\n                                         }\n                                     }\n                                     indices.lifetimes += 1;\n@@ -1435,9 +1437,10 @@ impl Clean<Type> for hir::Ty<'_> {\n                                             _ => None,\n                                         });\n                                     if let Some(ty) = type_ {\n-                                        ty_substs.insert(ty_param_def_id, ty.clean(cx));\n+                                        ty_substs.insert(ty_param_def_id.to_def_id(), ty.clean(cx));\n                                     } else if let Some(default) = *default {\n-                                        ty_substs.insert(ty_param_def_id, default.clean(cx));\n+                                        ty_substs\n+                                            .insert(ty_param_def_id.to_def_id(), default.clean(cx));\n                                     }\n                                     indices.types += 1;\n                                 }\n@@ -1457,7 +1460,8 @@ impl Clean<Type> for hir::Ty<'_> {\n                                             _ => None,\n                                         });\n                                     if let Some(ct) = const_ {\n-                                        ct_substs.insert(const_param_def_id, ct.clean(cx));\n+                                        ct_substs\n+                                            .insert(const_param_def_id.to_def_id(), ct.clean(cx));\n                                     }\n                                     // FIXME(const_generics:defaults)\n                                     indices.consts += 1;\n@@ -1749,9 +1753,9 @@ impl Clean<Item> for hir::StructField<'_> {\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, local_did),\n-            deprecation: get_deprecation(cx, local_did),\n-            def_id: local_did,\n+            stability: get_stability(cx, local_did.to_def_id()),\n+            deprecation: get_deprecation(cx, local_did.to_def_id()),\n+            def_id: local_did.to_def_id(),\n             inner: StructFieldItem(self.ty.clean(cx)),\n         }\n     }\n@@ -1799,7 +1803,7 @@ impl Clean<Item> for doctree::Struct<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -1819,7 +1823,7 @@ impl Clean<Item> for doctree::Union<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -1849,7 +1853,7 @@ impl Clean<Item> for doctree::Enum<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -1871,7 +1875,7 @@ impl Clean<Item> for doctree::Variant<'_> {\n             visibility: Inherited,\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             inner: VariantItem(Variant { kind: self.def.clean(cx) }),\n         }\n     }\n@@ -2020,7 +2024,7 @@ impl Clean<Item> for doctree::Typedef<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -2035,7 +2039,7 @@ impl Clean<Item> for doctree::OpaqueTy<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -2066,7 +2070,7 @@ impl Clean<Item> for doctree::Static<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -2087,14 +2091,14 @@ impl Clean<Item> for doctree::Constant<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id,\n+            def_id: def_id.to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             inner: ConstantItem(Constant {\n                 type_: self.type_.clean(cx),\n                 expr: print_const_expr(cx, self.expr),\n-                value: print_evaluated_const(cx, def_id),\n+                value: print_evaluated_const(cx, def_id.to_def_id()),\n                 is_literal: is_literal_expr(cx, self.expr.hir_id),\n             }),\n         }\n@@ -2141,7 +2145,7 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id,\n+            def_id: def_id.to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -2299,7 +2303,7 @@ impl Clean<Item> for doctree::ForeignItem<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -2343,7 +2347,7 @@ impl Clean<Item> for doctree::ProcMacro<'_> {\n             visibility: Public,\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             inner: ProcMacroItem(ProcMacro { kind: self.kind, helpers: self.helpers.clean(cx) }),\n         }\n     }"}, {"sha": "f26f6d3eff917db93ee3cc2f73dacce5ed85f8d8", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -389,7 +389,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                     map: access_levels\n                         .map\n                         .iter()\n-                        .map(|(&k, &v)| (tcx.hir().local_def_id(k), v))\n+                        .map(|(&k, &v)| (tcx.hir().local_def_id(k).to_def_id(), v))\n                         .collect(),\n                 };\n "}, {"sha": "6ef01c3dec79f918f683a3d8b6d85e7b34e3a313", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -120,7 +120,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     for &trait_did in cx.tcx.all_traits(LOCAL_CRATE).iter() {\n         for &impl_node in cx.tcx.hir().trait_impls(trait_did) {\n             let impl_did = cx.tcx.hir().local_def_id(impl_node);\n-            inline::build_impl(cx, impl_did, None, &mut new_items);\n+            inline::build_impl(cx, impl_did.to_def_id(), None, &mut new_items);\n         }\n     }\n "}, {"sha": "fa2a08479aa78b3588ec4274da32c067cde0f250", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fb59d7f37596f91b8d4619c4d146f273349b4c/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=92fb59d7f37596f91b8d4619c4d146f273349b4c", "patch": "@@ -391,7 +391,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         if item.vis.node.is_pub() {\n             let def_id = self.cx.tcx.hir().local_def_id(item.hir_id);\n-            self.store_path(def_id);\n+            self.store_path(def_id.to_def_id());\n         }\n \n         match item.kind {\n@@ -629,7 +629,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         Macro {\n             hid: def.hir_id,\n-            def_id: self.cx.tcx.hir().local_def_id(def.hir_id),\n+            def_id: self.cx.tcx.hir().local_def_id(def.hir_id).to_def_id(),\n             attrs: &def.attrs,\n             name: renamed.unwrap_or(def.ident.name),\n             whence: def.span,"}]}