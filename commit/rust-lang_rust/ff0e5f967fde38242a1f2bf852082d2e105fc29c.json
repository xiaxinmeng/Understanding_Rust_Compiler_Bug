{"sha": "ff0e5f967fde38242a1f2bf852082d2e105fc29c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMGU1Zjk2N2ZkZTM4MjQyYTFmMmJmODUyMDgyZDJlMTA1ZmMyOWM=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-07-22T22:19:07Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-07-22T22:19:07Z"}, "message": "Rewrite the print/write macro checks as a PreExpansionPass", "tree": {"sha": "b5dd6a3b79c52995af4ecf3e08b03e5791b2f36b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5dd6a3b79c52995af4ecf3e08b03e5791b2f36b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff0e5f967fde38242a1f2bf852082d2e105fc29c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff0e5f967fde38242a1f2bf852082d2e105fc29c", "html_url": "https://github.com/rust-lang/rust/commit/ff0e5f967fde38242a1f2bf852082d2e105fc29c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff0e5f967fde38242a1f2bf852082d2e105fc29c/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8085ed733fefeaf37aca0a39da93344326de5d57", "url": "https://api.github.com/repos/rust-lang/rust/commits/8085ed733fefeaf37aca0a39da93344326de5d57", "html_url": "https://github.com/rust-lang/rust/commit/8085ed733fefeaf37aca0a39da93344326de5d57"}], "stats": {"total": 610, "additions": 251, "deletions": 359}, "files": [{"sha": "53a37f23fa4d075279b0f0f216ec187d88cd643a", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff0e5f967fde38242a1f2bf852082d2e105fc29c/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0e5f967fde38242a1f2bf852082d2e105fc29c/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=ff0e5f967fde38242a1f2bf852082d2e105fc29c", "patch": "@@ -16,6 +16,7 @@\n \n use toml;\n use rustc_plugin;\n+use rustc;\n \n \n macro_rules! declare_clippy_lint {\n@@ -175,6 +176,10 @@ mod reexport {\n     crate use syntax::ast::{Name, NodeId};\n }\n \n+pub fn register_pre_expansion_lints(session: &rustc::session::Session, store: &mut rustc::lint::LintStore) {\n+    store.register_pre_expansion_pass(Some(session), box write::Pass);\n+}\n+\n #[cfg_attr(rustfmt, rustfmt_skip)]\n pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     let conf = match utils::conf::file_from_args(reg.args()) {\n@@ -320,7 +325,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box strings::StringLitAsBytes);\n     reg.register_late_lint_pass(box derive::Derive);\n     reg.register_late_lint_pass(box types::CharLitAsU8);\n-    reg.register_late_lint_pass(box write::Pass);\n     reg.register_late_lint_pass(box vec::Pass);\n     reg.register_early_lint_pass(box non_expressive_names::NonExpressiveNames {\n         single_char_binding_names_threshold: conf.single_char_binding_names_threshold,"}, {"sha": "c4b5a9ccefc98457572335ec7f0d145bc77b3c75", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 130, "deletions": 304, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/ff0e5f967fde38242a1f2bf852082d2e105fc29c/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0e5f967fde38242a1f2bf852082d2e105fc29c/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=ff0e5f967fde38242a1f2bf852082d2e105fc29c", "patch": "@@ -1,15 +1,9 @@\n-use rustc::hir::map::Node::{NodeImplItem, NodeItem};\n-use rustc::hir::*;\n use rustc::lint::*;\n use rustc::{declare_lint, lint_array};\n-use if_chain::if_chain;\n-use std::ops::Deref;\n-use syntax::ast::LitKind;\n-use syntax::ptr;\n-use syntax::symbol::LocalInternedString;\n-use syntax_pos::Span;\n-use crate::utils::{is_expn_of, match_def_path, match_path, resolve_node, span_lint, span_lint_and_sugg};\n-use crate::utils::{opt_def_id, paths, last_path_segment};\n+use syntax::ast::*;\n+use syntax::tokenstream::{ThinTokenStream, TokenStream};\n+use syntax::parse::{token, parser};\n+use crate::utils::{span_lint, span_lint_and_sugg};\n \n /// **What it does:** This lint warns when you use `println!(\"\")` to\n /// print a newline.\n@@ -173,317 +167,149 @@ impl LintPass for Pass {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        match expr.node {\n-            // print!()\n-            ExprKind::Call(ref fun, ref args) => {\n-                if_chain! {\n-                    if let ExprKind::Path(ref qpath) = fun.node;\n-                    if let Some(fun_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n-                    then {\n-                        check_print_variants(cx, expr, fun_id, args);\n-                    }\n-                }\n-            },\n-            // write!()\n-            ExprKind::MethodCall(ref fun, _, ref args) => {\n-                if fun.ident.name == \"write_fmt\" {\n-                    check_write_variants(cx, expr, args);\n-                }\n-            },\n-            _ => (),\n-        }\n-    }\n-}\n-\n-fn check_write_variants<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, write_args: &ptr::P<[Expr]>) {\n-    // `writeln!` uses `write!`.\n-    if let Some(span) = is_expn_of(expr.span, \"write\") {\n-        let (span, name) = match is_expn_of(span, \"writeln\") {\n-            Some(span) => (span, \"writeln\"),\n-            None => (span, \"write\"),\n-        };\n-\n-        if_chain! {\n-            // ensure we're calling Arguments::new_v1 or Arguments::new_v1_formatted\n-            if write_args.len() == 2;\n-            if let ExprKind::Call(ref args_fun, ref args_args) = write_args[1].node;\n-            if let ExprKind::Path(ref qpath) = args_fun.node;\n-            if let Some(const_def_id) = opt_def_id(resolve_node(cx, qpath, args_fun.hir_id));\n-            if match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1) ||\n-               match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1FORMATTED);\n-            then {\n-                // Check for literals in the write!/writeln! args\n-                check_fmt_args_for_literal(cx, args_args, |span| {\n-                    span_lint(cx, WRITE_LITERAL, span, \"writing a literal with an empty format string\");\n-                });\n-\n-                if_chain! {\n-                    if args_args.len() >= 2;\n-                    if let ExprKind::AddrOf(_, ref match_expr) = args_args[1].node;\n-                    if let ExprKind::Match(ref args, _, _) = match_expr.node;\n-                    if let ExprKind::Tup(ref args) = args.node;\n-                    if let Some((fmtstr, fmtlen)) = get_argument_fmtstr_parts(&args_args[0]);\n-                    then {\n-                        match name {\n-                            \"write\" => if has_newline_end(args, fmtstr, fmtlen) {\n-                                span_lint(cx, WRITE_WITH_NEWLINE, span,\n-                                        \"using `write!()` with a format string that ends in a \\\n-                                        newline, consider using `writeln!()` instead\");\n-                            },\n-                            \"writeln\" => if let Some(final_span) = has_empty_arg(cx, span, fmtstr, fmtlen) {\n-                                span_lint_and_sugg(\n-                                    cx,\n-                                    WRITE_WITH_NEWLINE,\n-                                    final_span,\n-                                    \"using `writeln!(v, \\\"\\\")`\",\n-                                    \"replace it with\",\n-                                    \"writeln!(v)\".to_string(),\n-                                );\n-                            },\n-                            _ => (),\n-                        }\n-                    }\n+impl EarlyLintPass for Pass {\n+    fn check_mac(&mut self, cx: &EarlyContext, mac: &Mac) {\n+        if mac.node.path == \"println\" {\n+            span_lint(cx, PRINT_STDOUT, mac.span, \"use of `println!`\");\n+            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false) {\n+                if fmtstr == \"\" {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        PRINTLN_EMPTY_STRING,\n+                        mac.span,\n+                        \"using `println!(\\\"\\\")`\",\n+                        \"replace it with\",\n+                        \"println!()\".to_string(),\n+                    );\n                 }\n             }\n-        }\n-    }\n-}\n-\n-fn check_print_variants<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx Expr,\n-    fun_id: def_id::DefId,\n-    args: &ptr::P<[Expr]>,\n-) {\n-    // Search for `std::io::_print(..)` which is unique in a\n-    // `print!` expansion.\n-    if match_def_path(cx.tcx, fun_id, &paths::IO_PRINT) {\n-        if let Some(span) = is_expn_of(expr.span, \"print\") {\n-            // `println!` uses `print!`.\n-            let (span, name) = match is_expn_of(span, \"println\") {\n-                Some(span) => (span, \"println\"),\n-                None => (span, \"print\"),\n-            };\n-\n-            span_lint(cx, PRINT_STDOUT, span, &format!(\"use of `{}!`\", name));\n-            if_chain! {\n-                // ensure we're calling Arguments::new_v1\n-                if args.len() == 1;\n-                if let ExprKind::Call(ref args_fun, ref args_args) = args[0].node;\n-                then {\n-                    // Check for literals in the print!/println! args\n-                    check_fmt_args_for_literal(cx, args_args, |span| {\n-                        span_lint(cx, PRINT_LITERAL, span, \"printing a literal with an empty format string\");\n-                    });\n-\n-                    if_chain! {\n-                        if let ExprKind::Path(ref qpath) = args_fun.node;\n-                        if let Some(const_def_id) = opt_def_id(resolve_node(cx, qpath, args_fun.hir_id));\n-                        if match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1);\n-                        if args_args.len() == 2;\n-                        if let ExprKind::AddrOf(_, ref match_expr) = args_args[1].node;\n-                        if let ExprKind::Match(ref args, _, _) = match_expr.node;\n-                        if let ExprKind::Tup(ref args) = args.node;\n-                        if let Some((fmtstr, fmtlen)) = get_argument_fmtstr_parts(&args_args[0]);\n-                        then {\n-                            match name {\n-                                \"print\" =>\n-                                    if has_newline_end(args, fmtstr, fmtlen) {\n-                                        span_lint(cx, PRINT_WITH_NEWLINE, span,\n-                                                \"using `print!()` with a format string that ends in a \\\n-                                                newline, consider using `println!()` instead\");\n-                                    },\n-                                \"println\" =>\n-                                    if let Some(final_span) = has_empty_arg(cx, span, fmtstr, fmtlen) {\n-                                        span_lint_and_sugg(\n-                                            cx,\n-                                            PRINT_WITH_NEWLINE,\n-                                            final_span,\n-                                            \"using `println!(\\\"\\\")`\",\n-                                            \"replace it with\",\n-                                            \"println!()\".to_string(),\n-                                        );\n-                                    },\n-                                _ => (),\n-                            }\n-                        }\n-                    }\n+        } else if mac.node.path == \"print\" {\n+            span_lint(cx, PRINT_STDOUT, mac.span, \"use of `print!`\");\n+            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false) {\n+                if fmtstr.ends_with(\"\\\\n\") {\n+                    span_lint(cx, PRINT_WITH_NEWLINE, mac.span,\n+                            \"using `print!()` with a format string that ends in a \\\n+                            newline, consider using `println!()` instead\");\n                 }\n             }\n-        }\n-    }\n-    // Search for something like\n-    // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n-    else if args.len() == 2 && match_def_path(cx.tcx, fun_id, &paths::FMT_ARGUMENTV1_NEW) {\n-        if let ExprKind::Path(ref qpath) = args[1].node {\n-            if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, args[1].hir_id)) {\n-                if match_def_path(cx.tcx, def_id, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr)\n-                    && is_expn_of(expr.span, \"panic\").is_none()\n-                {\n-                    span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n+        } else if mac.node.path == \"write\" {\n+            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, true) {\n+                if fmtstr.ends_with(\"\\\\n\") {\n+                    span_lint(cx, WRITE_WITH_NEWLINE, mac.span,\n+                            \"using `write!()` with a format string that ends in a \\\n+                            newline, consider using `writeln!()` instead\");\n                 }\n             }\n-        }\n-    }\n-}\n-\n-// Check for literals in write!/writeln! and print!/println! args\n-// ensuring the format string for the literal is `DISPLAY_FMT_METHOD`\n-// e.g., `writeln!(buf, \"... {} ...\", \"foo\")`\n-//                                    ^ literal in `writeln!`\n-// e.g., `println!(\"... {} ...\", \"foo\")`\n-//                                ^ literal in `println!`\n-fn check_fmt_args_for_literal<'a, 'tcx, F>(cx: &LateContext<'a, 'tcx>, args: &HirVec<Expr>, lint_fn: F)\n-where\n-    F: Fn(Span),\n-{\n-    if_chain! {\n-        if args.len() >= 2;\n-\n-        // the match statement\n-        if let ExprKind::AddrOf(_, ref match_expr) = args[1].node;\n-        if let ExprKind::Match(ref matchee, ref arms, _) = match_expr.node;\n-        if let ExprKind::Tup(ref tup) = matchee.node;\n-        if arms.len() == 1;\n-        if let ExprKind::Array(ref arm_body_exprs) = arms[0].body.node;\n-        then {\n-            // it doesn't matter how many args there are in the `write!`/`writeln!`,\n-            // if there's one literal, we should warn the user\n-            for (idx, tup_arg) in tup.iter().enumerate() {\n-                if_chain! {\n-                    // first, make sure we're dealing with a literal (i.e., an ExprKind::Lit)\n-                    if let ExprKind::AddrOf(_, ref tup_val) = tup_arg.node;\n-                    if let ExprKind::Lit(_) = tup_val.node;\n-\n-                    // next, check the corresponding match arm body to ensure\n-                    // this is DISPLAY_FMT_METHOD\n-                    if let ExprKind::Call(_, ref body_args) = arm_body_exprs[idx].node;\n-                    if body_args.len() == 2;\n-                    if let ExprKind::Path(ref body_qpath) = body_args[1].node;\n-                    if let Some(fun_def_id) = opt_def_id(resolve_node(cx, body_qpath, body_args[1].hir_id));\n-                    if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n-                    then {\n-                        if args.len() == 2 {\n-                            lint_fn(tup_val.span);\n-                        }\n-\n-                        // ensure the format str has no options (e.g., width, precision, alignment, etc.)\n-                        // and is just \"{}\"\n-                        if_chain! {\n-                            if args.len() == 3;\n-                            if let ExprKind::AddrOf(_, ref format_expr) = args[2].node;\n-                            if let ExprKind::Array(ref format_exprs) = format_expr.node;\n-                            if format_exprs.len() >= 1;\n-                            if let ExprKind::Struct(_, ref fields, _) = format_exprs[idx].node;\n-                            if let Some(format_field) = fields.iter().find(|f| f.ident.name == \"format\");\n-                            if check_unformatted(&format_field.expr);\n-                            then {\n-                                lint_fn(tup_val.span);\n-                            }\n-                        }\n-                    }\n+        } else if mac.node.path == \"writeln\" {\n+            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, true) {\n+                if fmtstr == \"\" {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        WRITELN_EMPTY_STRING,\n+                        mac.span,\n+                        \"using `writeln!(v, \\\"\\\")`\",\n+                        \"replace it with\",\n+                        \"writeln!(v)\".to_string(),\n+                    );\n                 }\n             }\n         }\n     }\n }\n \n-/// Check for fmtstr = \"... \\n\"\n-fn has_newline_end(args: &HirVec<Expr>, fmtstr: LocalInternedString, fmtlen: usize) -> bool {\n-    if_chain! {\n-        // check the final format string part\n-        if let Some('\\n') = fmtstr.chars().last();\n-\n-        // \"foo{}bar\" is made into two strings + one argument,\n-        // if the format string starts with `{}` (eg. \"{}foo\"),\n-        // the string array is prepended an empty string \"\".\n-        // We only want to check the last string after any `{}`:\n-        if args.len() < fmtlen;\n-        then {\n-            return true\n-        }\n+fn check_tts(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -> Option<String> {\n+    let tts = TokenStream::from(tts.clone());\n+    let mut parser = parser::Parser::new(\n+        &cx.sess.parse_sess,\n+        tts,\n+        None,\n+        false,\n+        false,\n+    );\n+    if is_write {\n+        // skip the initial write target\n+        parser.parse_expr().map_err(|mut err| err.cancel()).ok()?;\n+        // might be `writeln!(foo)`\n+        parser.expect(&token::Comma).map_err(|mut err| err.cancel()).ok()?;\n     }\n-    false\n-}\n-\n-/// Check for writeln!(v, \"\") / println!(\"\")\n-fn has_empty_arg<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, fmtstr: LocalInternedString, fmtlen: usize) -> Option<Span> {\n-    if_chain! {\n-        // check that the string is empty\n-        if fmtlen == 1;\n-        if fmtstr.deref() == \"\\n\";\n-\n-        // check the presence of that string\n-        if let Ok(snippet) = cx.sess().codemap().span_to_snippet(span);\n-        if snippet.contains(\"\\\"\\\"\");\n-        then {\n-            if snippet.ends_with(';') {\n-                return Some(cx.sess().codemap().span_until_char(span, ';'));\n-            }\n-            return Some(span)\n+    let fmtstr = parser.parse_str().map_err(|mut err| err.cancel()).ok()?.0.to_string();\n+    use fmt_macros::*;\n+    let tmp = fmtstr.clone();\n+    let mut args = vec![];\n+    let mut fmt_parser = Parser::new(&tmp, None);\n+    while let Some(piece) = fmt_parser.next() {\n+        if !fmt_parser.errors.is_empty() {\n+            return None;\n         }\n-    }\n-    None\n-}\n-\n-/// Returns the slice of format string parts in an `Arguments::new_v1` call.\n-fn get_argument_fmtstr_parts(expr: &Expr) -> Option<(LocalInternedString, usize)> {\n-    if_chain! {\n-        if let ExprKind::AddrOf(_, ref expr) = expr.node; // &[\"\u2026\", \"\u2026\", \u2026]\n-        if let ExprKind::Array(ref exprs) = expr.node;\n-        if let Some(expr) = exprs.last();\n-        if let ExprKind::Lit(ref lit) = expr.node;\n-        if let LitKind::Str(ref lit, _) = lit.node;\n-        then {\n-            return Some((lit.as_str(), exprs.len()));\n-        }\n-    }\n-    None\n-}\n-\n-fn is_in_debug_impl(cx: &LateContext, expr: &Expr) -> bool {\n-    let map = &cx.tcx.hir;\n-\n-    // `fmt` method\n-    if let Some(NodeImplItem(item)) = map.find(map.get_parent(expr.id)) {\n-        // `Debug` impl\n-        if let Some(NodeItem(item)) = map.find(map.get_parent(item.id)) {\n-            if let ItemKind::Impl(_, _, _, _, Some(ref tr), _, _) = item.node {\n-                return match_path(&tr.path, &[\"Debug\"]);\n+        if let Piece::NextArgument(arg) = piece {\n+            if arg.format.ty == \"?\" {\n+                // FIXME: modify rustc's fmt string parser to give us the current span\n+                span_lint(cx, USE_DEBUG, parser.prev_span, \"use of `Debug`-based formatting\");\n             }\n+            args.push(arg);\n         }\n     }\n-    false\n-}\n-\n-/// Checks if the expression matches\n-/// ```rust,ignore\n-/// &[_ {\n-///    format: _ {\n-///         width: _::Implied,\n-///         ...\n-///    },\n-///    ...,\n-/// }]\n-/// ```\n-pub fn check_unformatted(format_field: &Expr) -> bool {\n-    if_chain! {\n-        if let ExprKind::Struct(_, ref fields, _) = format_field.node;\n-        if let Some(width_field) = fields.iter().find(|f| f.ident.name == \"width\");\n-        if let ExprKind::Path(ref qpath) = width_field.expr.node;\n-        if last_path_segment(qpath).ident.name == \"Implied\";\n-        if let Some(align_field) = fields.iter().find(|f| f.ident.name == \"align\");\n-        if let ExprKind::Path(ref qpath) = align_field.expr.node;\n-        if last_path_segment(qpath).ident.name == \"Unknown\";\n-        if let Some(precision_field) = fields.iter().find(|f| f.ident.name == \"precision\");\n-        if let ExprKind::Path(ref qpath_precision) = precision_field.expr.node;\n-        if last_path_segment(qpath_precision).ident.name == \"Implied\";\n-        then {\n-            return true;\n+    let lint = if is_write {\n+        WRITE_LITERAL\n+    } else {\n+        PRINT_LITERAL\n+    };\n+    let mut idx = 0;\n+    loop {\n+        if !parser.eat(&token::Comma) {\n+            assert!(parser.eat(&token::Eof));\n+            return Some(fmtstr);\n+        }\n+        let expr = parser.parse_expr().map_err(|mut err| err.cancel()).ok()?;\n+        const SIMPLE: FormatSpec = FormatSpec {\n+            fill: None,\n+            align: AlignUnknown,\n+            flags: 0,\n+            precision: CountImplied,\n+            width: CountImplied,\n+            ty: \"\",\n+        };\n+        match &expr.node {\n+            ExprKind::Lit(_) => {\n+                let mut all_simple = true;\n+                let mut seen = false;\n+                for arg in &args {\n+                    match arg.position {\n+                        | ArgumentImplicitlyIs(n)\n+                        | ArgumentIs(n)\n+                        => if n == idx {\n+                            all_simple &= arg.format == SIMPLE;\n+                            seen = true;\n+                        },\n+                        ArgumentNamed(_) => {},\n+                    }\n+                }\n+                if all_simple && seen {\n+                    span_lint(cx, lint, expr.span, \"literal with an empty format string\");\n+                }\n+                idx += 1;\n+            },\n+            ExprKind::Assign(lhs, rhs) => {\n+                if let ExprKind::Path(_, p) = &lhs.node {\n+                    let mut all_simple = true;\n+                    let mut seen = false;\n+                    for arg in &args {\n+                        match arg.position {\n+                            | ArgumentImplicitlyIs(_)\n+                            | ArgumentIs(_)\n+                            => {},\n+                            ArgumentNamed(name) => if *p == name {\n+                                seen = true;\n+                                all_simple &= arg.format == SIMPLE;\n+                            },\n+                        }\n+                    }\n+                    if all_simple && seen {\n+                        span_lint(cx, lint, rhs.span, \"literal with an empty format string\");\n+                    }\n+                }\n+            },\n+            _ => idx += 1,\n         }\n     }\n-\n-    false\n }"}, {"sha": "e9e81bb88e3de13e90e2446ababa441147e9e4b4", "filename": "src/driver.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff0e5f967fde38242a1f2bf852082d2e105fc29c/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0e5f967fde38242a1f2bf852082d2e105fc29c/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=ff0e5f967fde38242a1f2bf852082d2e105fc29c", "patch": "@@ -118,6 +118,7 @@ pub fn main() {\n             for (name, to) in lint_groups {\n                 ls.register_group(Some(sess), true, name, to);\n             }\n+            clippy_lints::register_pre_expansion_lints(sess, &mut ls);\n \n             sess.plugin_llvm_passes.borrow_mut().extend(llvm_passes);\n             sess.plugin_attributes.borrow_mut().extend(attributes);"}, {"sha": "88f24d27dbc4a7d7f1e252009a961aaae2418f7f", "filename": "tests/ui/excessive_precision.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexcessive_precision.rs?ref=ff0e5f967fde38242a1f2bf852082d2e105fc29c", "patch": "@@ -22,7 +22,7 @@ fn main() {\n     const BAD64_3: f64 = 0.100_000_000_000_000_000_1;\n \n     // Literal as param\n-    println!(\"{}\", 8.888_888_888_888_888_888_888);\n+    println!(\"{:?}\", 8.888_888_888_888_888_888_888);\n \n     // // TODO add inferred type tests for f32\n     // Locals"}, {"sha": "295846e9d7e011cdba69b53308e811658afc8acf", "filename": "tests/ui/excessive_precision.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fexcessive_precision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fexcessive_precision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexcessive_precision.stderr?ref=ff0e5f967fde38242a1f2bf852082d2e105fc29c", "patch": "@@ -43,10 +43,10 @@ error: float has excessive precision\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `0.1`\n \n error: float has excessive precision\n-  --> $DIR/excessive_precision.rs:25:20\n+  --> $DIR/excessive_precision.rs:25:22\n    |\n-25 |     println!(\"{}\", 8.888_888_888_888_888_888_888);\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `8.888_888_888_888_89`\n+25 |     println!(\"{:?}\", 8.888_888_888_888_888_888_888);\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `8.888_888_888_888_89`\n \n error: float has excessive precision\n   --> $DIR/excessive_precision.rs:36:22"}, {"sha": "6554b6d344929eb9066914100549fed2c9f9b4db", "filename": "tests/ui/matches.stderr", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fmatches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fmatches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatches.stderr?ref=ff0e5f967fde38242a1f2bf852082d2e105fc29c", "patch": "@@ -26,6 +26,23 @@ help: instead of prefixing all patterns with `&`, you can dereference the expres\n 32 |             None => println!(\"none\"),\n    |\n \n+error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/matches.rs:40:5\n+   |\n+40 | /     match tup {\n+41 | |         &(v, 1) => println!(\"{}\", v),\n+42 | |         _ => println!(\"none\"),\n+43 | |     }\n+   | |_____^\n+help: try this\n+   |\n+40 |     if let &(v, 1) = tup {\n+41 | # [ cfg ( not ( stage0 ) ) ] {\n+42 | ( $ crate :: io :: _print ( format_args_nl ! ( $ ( $ arg ) * ) ) ) ; } # [\n+43 | cfg ( stage0 ) ] { print ! ( \"{}/n\" , format_args ! ( $ ( $ arg ) * ) ) } } else {\n+44 | ( $ crate :: io :: _print ( format_args_nl ! ( $ ( $ arg ) * ) ) ) ; }\n+   |\n+\n error: you don't need to add `&` to all patterns\n   --> $DIR/matches.rs:40:5\n    |\n@@ -350,5 +367,5 @@ error: use as_mut() instead\n 221 | |     };\n     | |_____^ help: try this: `mut_owned.as_mut()`\n \n-error: aborting due to 25 previous errors\n+error: aborting due to 26 previous errors\n "}, {"sha": "c63b493db8d2fe57b2863a8337c044e6431fbfbc", "filename": "tests/ui/non_expressive_names.stderr", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fnon_expressive_names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fnon_expressive_names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnon_expressive_names.stderr?ref=ff0e5f967fde38242a1f2bf852082d2e105fc29c", "patch": "@@ -1,3 +1,23 @@\n+error: using `println!(\"\")`\n+  --> $DIR/non_expressive_names.rs:60:14\n+   |\n+60 |         _ => println!(\"\"),\n+   |              ^^^^^^^^^^^^ help: replace it with: `println!()`\n+   |\n+   = note: `-D println-empty-string` implied by `-D warnings`\n+\n+error: using `println!(\"\")`\n+   --> $DIR/non_expressive_names.rs:128:18\n+    |\n+128 |             1 => println!(\"\"),\n+    |                  ^^^^^^^^^^^^ help: replace it with: `println!()`\n+\n+error: using `println!(\"\")`\n+   --> $DIR/non_expressive_names.rs:132:18\n+    |\n+132 |             1 => println!(\"\"),\n+    |                  ^^^^^^^^^^^^ help: replace it with: `println!()`\n+\n error: binding's name is too similar to existing binding\n   --> $DIR/non_expressive_names.rs:18:9\n    |\n@@ -167,5 +187,5 @@ error: consider choosing a more descriptive name\n 151 |         let __1___2 = 12;\n     |             ^^^^^^^\n \n-error: aborting due to 17 previous errors\n+error: aborting due to 20 previous errors\n "}, {"sha": "f2d2afd9bf782d1695e62c94d064c7ac6954ee3f", "filename": "tests/ui/print.stderr", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fprint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fprint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint.stderr?ref=ff0e5f967fde38242a1f2bf852082d2e105fc29c", "patch": "@@ -1,54 +1,60 @@\n error: use of `Debug`-based formatting\n-  --> $DIR/print.rs:13:27\n+  --> $DIR/print.rs:13:19\n    |\n 13 |         write!(f, \"{:?}\", 43.1415)\n-   |                           ^^^^^^^\n+   |                   ^^^^^^\n    |\n    = note: `-D use-debug` implied by `-D warnings`\n \n+error: use of `Debug`-based formatting\n+  --> $DIR/print.rs:20:19\n+   |\n+20 |         write!(f, \"{:?}\", 42.718)\n+   |                   ^^^^^^\n+\n error: use of `println!`\n   --> $DIR/print.rs:25:5\n    |\n 25 |     println!(\"Hello\");\n-   |     ^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D print-stdout` implied by `-D warnings`\n \n error: use of `print!`\n   --> $DIR/print.rs:26:5\n    |\n 26 |     print!(\"Hello\");\n-   |     ^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^\n \n error: use of `print!`\n   --> $DIR/print.rs:28:5\n    |\n 28 |     print!(\"Hello {}\", \"World\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of `print!`\n   --> $DIR/print.rs:30:5\n    |\n 30 |     print!(\"Hello {:?}\", \"World\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of `Debug`-based formatting\n-  --> $DIR/print.rs:30:26\n+  --> $DIR/print.rs:30:12\n    |\n 30 |     print!(\"Hello {:?}\", \"World\");\n-   |                          ^^^^^^^\n+   |            ^^^^^^^^^^^^\n \n error: use of `print!`\n   --> $DIR/print.rs:32:5\n    |\n 32 |     print!(\"Hello {:#?}\", \"#orld\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of `Debug`-based formatting\n-  --> $DIR/print.rs:32:27\n+  --> $DIR/print.rs:32:12\n    |\n 32 |     print!(\"Hello {:#?}\", \"#orld\");\n-   |                           ^^^^^^^\n+   |            ^^^^^^^^^^^^^\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "39e0387cb5ec3ccc8128d6d428c399e01df09ecf", "filename": "tests/ui/print_literal.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fprint_literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fprint_literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_literal.stderr?ref=ff0e5f967fde38242a1f2bf852082d2e105fc29c", "patch": "@@ -1,84 +1,84 @@\n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:23:71\n    |\n 23 |     println!(\"{} of {:b} people know binary, the other half doesn't\", 1, 2);\n    |                                                                       ^\n    |\n    = note: `-D print-literal` implied by `-D warnings`\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:24:24\n    |\n 24 |     print!(\"Hello {}\", \"world\");\n    |                        ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:25:36\n    |\n 25 |     println!(\"Hello {} {}\", world, \"world\");\n    |                                    ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:26:26\n    |\n 26 |     println!(\"Hello {}\", \"world\");\n    |                          ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:27:30\n    |\n 27 |     println!(\"10 / 4 is {}\", 2.5);\n    |                              ^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:28:28\n    |\n 28 |     println!(\"2 + 1 = {}\", 3);\n    |                            ^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:33:25\n    |\n 33 |     println!(\"{0} {1}\", \"hello\", \"world\");\n    |                         ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:33:34\n    |\n 33 |     println!(\"{0} {1}\", \"hello\", \"world\");\n    |                                  ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:34:25\n    |\n 34 |     println!(\"{1} {0}\", \"hello\", \"world\");\n    |                         ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:34:34\n    |\n 34 |     println!(\"{1} {0}\", \"hello\", \"world\");\n    |                                  ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:37:33\n    |\n 37 |     println!(\"{foo} {bar}\", foo=\"hello\", bar=\"world\");\n    |                                 ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:37:46\n    |\n 37 |     println!(\"{foo} {bar}\", foo=\"hello\", bar=\"world\");\n    |                                              ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:38:33\n    |\n 38 |     println!(\"{bar} {foo}\", foo=\"hello\", bar=\"world\");\n    |                                 ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:38:46\n    |\n 38 |     println!(\"{bar} {foo}\", foo=\"hello\", bar=\"world\");"}, {"sha": "181f16b5cb71066bb6c80a39181ef0804a850d9a", "filename": "tests/ui/print_with_newline.stderr", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fprint_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fprint_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_with_newline.stderr?ref=ff0e5f967fde38242a1f2bf852082d2e105fc29c", "patch": "@@ -2,9 +2,27 @@ error: using `print!()` with a format string that ends in a newline, consider us\n  --> $DIR/print_with_newline.rs:7:5\n   |\n 7 |     print!(\"Hello/n\");\n-  |     ^^^^^^^^^^^^^^^^^^\n+  |     ^^^^^^^^^^^^^^^^^\n   |\n   = note: `-D print-with-newline` implied by `-D warnings`\n \n-error: aborting due to previous error\n+error: using `print!()` with a format string that ends in a newline, consider using `println!()` instead\n+ --> $DIR/print_with_newline.rs:8:5\n+  |\n+8 |     print!(\"Hello {}/n\", \"world\");\n+  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: using `print!()` with a format string that ends in a newline, consider using `println!()` instead\n+ --> $DIR/print_with_newline.rs:9:5\n+  |\n+9 |     print!(\"Hello {} {}/n/n\", \"world\", \"#2\");\n+  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: using `print!()` with a format string that ends in a newline, consider using `println!()` instead\n+  --> $DIR/print_with_newline.rs:10:5\n+   |\n+10 |     print!(\"{}/n\", 1265);\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "cff3f988052a1dd14a6041510d15c7a7bb5b6c21", "filename": "tests/ui/println_empty_string.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fprintln_empty_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fprintln_empty_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprintln_empty_string.stderr?ref=ff0e5f967fde38242a1f2bf852082d2e105fc29c", "patch": "@@ -4,7 +4,7 @@ error: using `println!(\"\")`\n 3 |     println!(\"\");\n   |     ^^^^^^^^^^^^ help: replace it with: `println!()`\n   |\n-  = note: `-D print-with-newline` implied by `-D warnings`\n+  = note: `-D println-empty-string` implied by `-D warnings`\n \n error: using `println!(\"\")`\n  --> $DIR/println_empty_string.rs:6:14"}, {"sha": "70855ef8187068b1716eb56c39f2895030d9ccfa", "filename": "tests/ui/write_literal.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fwrite_literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fwrite_literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_literal.stderr?ref=ff0e5f967fde38242a1f2bf852082d2e105fc29c", "patch": "@@ -1,84 +1,84 @@\n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:26:79\n    |\n 26 |     writeln!(&mut v, \"{} of {:b} people know binary, the other half doesn't\", 1, 2);\n    |                                                                               ^\n    |\n    = note: `-D write-literal` implied by `-D warnings`\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:27:32\n    |\n 27 |     write!(&mut v, \"Hello {}\", \"world\");\n    |                                ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:28:44\n    |\n 28 |     writeln!(&mut v, \"Hello {} {}\", world, \"world\");\n    |                                            ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:29:34\n    |\n 29 |     writeln!(&mut v, \"Hello {}\", \"world\");\n    |                                  ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:30:38\n    |\n 30 |     writeln!(&mut v, \"10 / 4 is {}\", 2.5);\n    |                                      ^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:31:36\n    |\n 31 |     writeln!(&mut v, \"2 + 1 = {}\", 3);\n    |                                    ^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:36:33\n    |\n 36 |     writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n    |                                 ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:36:42\n    |\n 36 |     writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n    |                                          ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:37:33\n    |\n 37 |     writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n    |                                 ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:37:42\n    |\n 37 |     writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n    |                                          ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:40:41\n    |\n 40 |     writeln!(&mut v, \"{foo} {bar}\", foo=\"hello\", bar=\"world\");\n    |                                         ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:40:54\n    |\n 40 |     writeln!(&mut v, \"{foo} {bar}\", foo=\"hello\", bar=\"world\");\n    |                                                      ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:41:41\n    |\n 41 |     writeln!(&mut v, \"{bar} {foo}\", foo=\"hello\", bar=\"world\");\n    |                                         ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:41:54\n    |\n 41 |     writeln!(&mut v, \"{bar} {foo}\", foo=\"hello\", bar=\"world\");"}, {"sha": "7bb9b99731ffb7740a3753ac6c6c73be20174f0f", "filename": "tests/ui/write_with_newline.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fwrite_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fwrite_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_with_newline.stderr?ref=ff0e5f967fde38242a1f2bf852082d2e105fc29c", "patch": "@@ -2,27 +2,27 @@ error: using `write!()` with a format string that ends in a newline, consider us\n   --> $DIR/write_with_newline.rs:10:5\n    |\n 10 |     write!(&mut v, \"Hello/n\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D write-with-newline` implied by `-D warnings`\n \n error: using `write!()` with a format string that ends in a newline, consider using `writeln!()` instead\n   --> $DIR/write_with_newline.rs:11:5\n    |\n 11 |     write!(&mut v, \"Hello {}/n\", \"world\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: using `write!()` with a format string that ends in a newline, consider using `writeln!()` instead\n   --> $DIR/write_with_newline.rs:12:5\n    |\n 12 |     write!(&mut v, \"Hello {} {}/n/n\", \"world\", \"#2\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: using `write!()` with a format string that ends in a newline, consider using `writeln!()` instead\n   --> $DIR/write_with_newline.rs:13:5\n    |\n 13 |     write!(&mut v, \"{}/n\", 1265);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "16a8e0a203d3a3f26cea4c32e025710d79015bc7", "filename": "tests/ui/writeln_empty_string.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fwriteln_empty_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff0e5f967fde38242a1f2bf852082d2e105fc29c/tests%2Fui%2Fwriteln_empty_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwriteln_empty_string.stderr?ref=ff0e5f967fde38242a1f2bf852082d2e105fc29c", "patch": "@@ -4,7 +4,7 @@ error: using `writeln!(v, \"\")`\n 9 |     writeln!(&mut v, \"\");\n   |     ^^^^^^^^^^^^^^^^^^^^ help: replace it with: `writeln!(v)`\n   |\n-  = note: `-D write-with-newline` implied by `-D warnings`\n+  = note: `-D writeln-empty-string` implied by `-D warnings`\n \n error: aborting due to previous error\n "}]}