{"sha": "37ba5f3b3252aceb28c037021225bbb6a27006f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3YmE1ZjNiMzI1MmFjZWIyOGMwMzcwMjEyMjViYmI2YTI3MDA2ZjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-04T06:03:07Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-05T18:44:38Z"}, "message": "make parser handle parenthesized block-sugar exprs properly", "tree": {"sha": "06009f95a065ae2f9bf5c948ea5c6827bfc1f3b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06009f95a065ae2f9bf5c948ea5c6827bfc1f3b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37ba5f3b3252aceb28c037021225bbb6a27006f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37ba5f3b3252aceb28c037021225bbb6a27006f3", "html_url": "https://github.com/rust-lang/rust/commit/37ba5f3b3252aceb28c037021225bbb6a27006f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37ba5f3b3252aceb28c037021225bbb6a27006f3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e02ab2d65fb8d0830ccaa7fcc163244311ee88de", "url": "https://api.github.com/repos/rust-lang/rust/commits/e02ab2d65fb8d0830ccaa7fcc163244311ee88de", "html_url": "https://github.com/rust-lang/rust/commit/e02ab2d65fb8d0830ccaa7fcc163244311ee88de"}], "stats": {"total": 229, "additions": 130, "deletions": 99}, "files": [{"sha": "59aa5ee516af565430e8d4d37e5cdd6b67cf4ed4", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 80, "deletions": 49, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/37ba5f3b3252aceb28c037021225bbb6a27006f3/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ba5f3b3252aceb28c037021225bbb6a27006f3/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=37ba5f3b3252aceb28c037021225bbb6a27006f3", "patch": "@@ -736,7 +736,29 @@ fn mk_lit_u32(p: parser, i: u32) -> @ast::expr {\n     ret @{id: p.get_id(), node: ast::expr_lit(lv_lit), span: span};\n }\n \n-fn parse_bottom_expr(p: parser) -> @ast::expr {\n+// We don't allow single-entry tuples in the true AST; that indicates a\n+// parenthesized expression.  However, we preserve them temporarily while\n+// parsing because `(while{...})+3` parses differently from `while{...}+3`.\n+//\n+// To reflect the fact that the @ast::expr is not a true expr that should be\n+// part of the AST, we wrap such expressions in the pexpr tag.  They\n+// can then be converted to true expressions by a call to `to_expr()`.\n+tag pexpr {\n+    pexpr(@ast::expr);\n+}\n+\n+fn mk_pexpr(p: parser, lo: uint, hi: uint, node: ast::expr_) -> pexpr {\n+    ret pexpr(mk_expr(p, lo, hi, node));\n+}\n+\n+fn to_expr(e: pexpr) -> @ast::expr {\n+    alt e.node {\n+      ast::expr_tup(es) when vec::len(es) == 1u { es[0u] }\n+      _ { *e }\n+    }\n+}\n+\n+fn parse_bottom_expr(p: parser) -> pexpr {\n     let lo = p.get_lo_pos();\n     let hi = p.get_hi_pos();\n \n@@ -747,15 +769,19 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n             hi = p.get_hi_pos();\n             p.bump();\n             let lit = @spanned(lo, hi, ast::lit_nil);\n-            ret mk_expr(p, lo, hi, ast::expr_lit(lit));\n+            ret mk_pexpr(p, lo, hi, ast::expr_lit(lit));\n         }\n         let es = [parse_expr(p)];\n         while p.peek() == token::COMMA { p.bump(); es += [parse_expr(p)]; }\n         hi = p.get_hi_pos();\n         expect(p, token::RPAREN);\n-        if vec::len(es) == 1u {\n-            ret mk_expr(p, lo, hi, es[0].node);\n-        } else { ret mk_expr(p, lo, hi, ast::expr_tup(es)); }\n+\n+        // Note: we retain the expr_tup() even for simple\n+        // parenthesized expressions, but only for a \"little while\".\n+        // This is so that wrappers around parse_bottom_expr()\n+        // can tell whether the expression was parenthesized or not,\n+        // which affects expr_is_complete().\n+        ret mk_pexpr(p, lo, hi, ast::expr_tup(es));\n     } else if p.peek() == token::LBRACE {\n         p.bump();\n         if is_word(p, \"mutable\") ||\n@@ -775,34 +801,34 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n             expect(p, token::RBRACE);\n             ex = ast::expr_rec(fields, base);\n         } else if is_bar(p.peek()) {\n-            ret parse_fn_block_expr(p);\n+            ret pexpr(parse_fn_block_expr(p));\n         } else {\n             let blk = parse_block_tail(p, lo, ast::default_blk);\n-            ret mk_expr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n+            ret mk_pexpr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n         }\n     } else if eat_word(p, \"if\") {\n-        ret parse_if_expr(p);\n+        ret pexpr(parse_if_expr(p));\n     } else if eat_word(p, \"for\") {\n-        ret parse_for_expr(p);\n+        ret pexpr(parse_for_expr(p));\n     } else if eat_word(p, \"while\") {\n-        ret parse_while_expr(p);\n+        ret pexpr(parse_while_expr(p));\n     } else if eat_word(p, \"do\") {\n-        ret parse_do_while_expr(p);\n+        ret pexpr(parse_do_while_expr(p));\n     } else if eat_word(p, \"alt\") {\n-        ret parse_alt_expr(p);\n+        ret pexpr(parse_alt_expr(p));\n     } else if eat_word(p, \"fn\") {\n         let proto = parse_fn_ty_proto(p);\n-        ret parse_fn_expr(p, proto);\n+        ret pexpr(parse_fn_expr(p, proto));\n     } else if eat_word(p, \"block\") {\n-        ret parse_fn_expr(p, ast::proto_block);\n+        ret pexpr(parse_fn_expr(p, ast::proto_block));\n     } else if eat_word(p, \"lambda\") {\n-        ret parse_fn_expr(p, ast::proto_shared(ast::sugar_sexy));\n+        ret pexpr(parse_fn_expr(p, ast::proto_shared(ast::sugar_sexy)));\n     } else if eat_word(p, \"sendfn\") {\n-        ret parse_fn_expr(p, ast::proto_send);\n+        ret pexpr(parse_fn_expr(p, ast::proto_send));\n     } else if eat_word(p, \"unchecked\") {\n-        ret parse_block_expr(p, lo, ast::unchecked_blk);\n+        ret pexpr(parse_block_expr(p, lo, ast::unchecked_blk));\n     } else if eat_word(p, \"unsafe\") {\n-        ret parse_block_expr(p, lo, ast::unsafe_blk);\n+        ret pexpr(parse_block_expr(p, lo, ast::unsafe_blk));\n     } else if p.peek() == token::LBRACKET {\n         p.bump();\n         let mut = parse_mutability(p);\n@@ -816,15 +842,16 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n         expect(p, token::GT);\n \n         /* hack: early return to take advantage of specialized function */\n-        ret mk_mac_expr(p, lo, p.get_hi_pos(), ast::mac_embed_type(ty));\n+        ret pexpr(mk_mac_expr(p, lo, p.get_hi_pos(),\n+                              ast::mac_embed_type(ty)));\n     } else if p.peek() == token::POUND_LBRACE {\n         p.bump();\n         let blk = ast::mac_embed_block(\n             parse_block_tail(p, lo, ast::default_blk));\n-        ret mk_mac_expr(p, lo, p.get_hi_pos(), blk);\n+        ret pexpr(mk_mac_expr(p, lo, p.get_hi_pos(), blk));\n     } else if p.peek() == token::ELLIPSIS {\n         p.bump();\n-        ret mk_mac_expr(p, lo, p.get_hi_pos(), ast::mac_ellipsis);\n+        ret pexpr(mk_mac_expr(p, lo, p.get_hi_pos(), ast::mac_ellipsis));\n     } else if eat_word(p, \"obj\") {\n         // Anonymous object\n \n@@ -941,7 +968,7 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n         hi = lit.span.hi;\n         ex = ast::expr_lit(@lit);\n     }\n-    ret mk_expr(p, lo, hi, ex);\n+    ret mk_pexpr(p, lo, hi, ex);\n }\n \n fn parse_block_expr(p: parser,\n@@ -977,7 +1004,7 @@ fn parse_syntax_ext_naked(p: parser, lo: uint) -> @ast::expr {\n     ret mk_mac_expr(p, lo, hi, ast::mac_invoc(pth, e, none));\n }\n \n-fn parse_dot_or_call_expr(p: parser) -> @ast::expr {\n+fn parse_dot_or_call_expr(p: parser) -> pexpr {\n     let b = parse_bottom_expr(p);\n     parse_dot_or_call_expr_with(p, b)\n }\n@@ -986,33 +1013,33 @@ fn permits_call(p: parser) -> bool {\n     ret p.get_restriction() != RESTRICT_NO_CALL_EXPRS;\n }\n \n-fn parse_dot_or_call_expr_with(p: parser, e: @ast::expr) -> @ast::expr {\n+fn parse_dot_or_call_expr_with(p: parser, e0: pexpr) -> pexpr {\n+    let e = e0;\n     let lo = e.span.lo;\n     let hi = e.span.hi;\n-    let e = e;\n     while !expr_is_complete(p, e) {\n         alt p.peek() {\n           // expr(...)\n           token::LPAREN. when permits_call(p) {\n             let es = parse_seq(token::LPAREN, token::RPAREN,\n                                seq_sep(token::COMMA), parse_expr, p);\n             hi = es.span.hi;\n-            let nd = ast::expr_call(e, es.node, false);\n-            e = mk_expr(p, lo, hi, nd);\n+            let nd = ast::expr_call(to_expr(e), es.node, false);\n+            e = mk_pexpr(p, lo, hi, nd);\n           }\n \n-          // expr { || ... }\n+          // expr {|| ... }\n           token::LBRACE. when is_bar(p.look_ahead(1u)) && permits_call(p) {\n             p.bump();\n             let blk = parse_fn_block_expr(p);\n             alt e.node {\n               ast::expr_call(f, args, false) {\n-                e = @{node: ast::expr_call(f, args + [blk], true)\n-                      with *e};\n+                e = pexpr(@{node: ast::expr_call(f, args + [blk], true)\n+                            with *to_expr(e)});\n               }\n               _ {\n-                e = mk_expr(p, lo, p.get_last_hi_pos(),\n-                            ast::expr_call(e, [blk], true));\n+                e = mk_pexpr(p, lo, p.get_last_hi_pos(),\n+                            ast::expr_call(to_expr(e), [blk], true));\n               }\n             }\n           }\n@@ -1023,7 +1050,7 @@ fn parse_dot_or_call_expr_with(p: parser, e: @ast::expr) -> @ast::expr {\n             let ix = parse_expr(p);\n             hi = ix.span.hi;\n             expect(p, token::RBRACKET);\n-            e = mk_expr(p, lo, hi, ast::expr_index(e, ix));\n+            e = mk_pexpr(p, lo, hi, ast::expr_index(to_expr(e), ix));\n           }\n \n           // expr.f\n@@ -1038,7 +1065,10 @@ fn parse_dot_or_call_expr_with(p: parser, e: @ast::expr) -> @ast::expr {\n                     parse_seq_to_gt(some(token::COMMA),\n                                     {|p| parse_ty(p, false)}, p)\n                 } else { [] };\n-                e = mk_expr(p, lo, hi, ast::expr_field(e, p.get_str(i), tys));\n+                e = mk_pexpr(p, lo, hi,\n+                             ast::expr_field(to_expr(e),\n+                                             p.get_str(i),\n+                                             tys));\n               }\n               t { unexpected(p, t); }\n             }\n@@ -1050,29 +1080,29 @@ fn parse_dot_or_call_expr_with(p: parser, e: @ast::expr) -> @ast::expr {\n     ret e;\n }\n \n-fn parse_prefix_expr(p: parser) -> @ast::expr {\n+fn parse_prefix_expr(p: parser) -> pexpr {\n     let lo = p.get_lo_pos();\n     let hi = p.get_hi_pos();\n \n     let ex;\n     alt p.peek() {\n       token::NOT. {\n         p.bump();\n-        let e = parse_prefix_expr(p);\n+        let e = to_expr(parse_prefix_expr(p));\n         hi = e.span.hi;\n         ex = ast::expr_unary(ast::not, e);\n       }\n       token::BINOP(b) {\n         alt b {\n           token::MINUS. {\n             p.bump();\n-            let e = parse_prefix_expr(p);\n+            let e = to_expr(parse_prefix_expr(p));\n             hi = e.span.hi;\n             ex = ast::expr_unary(ast::neg, e);\n           }\n           token::STAR. {\n             p.bump();\n-            let e = parse_prefix_expr(p);\n+            let e = to_expr(parse_prefix_expr(p));\n             hi = e.span.hi;\n             ex = ast::expr_unary(ast::deref, e);\n           }\n@@ -1082,20 +1112,20 @@ fn parse_prefix_expr(p: parser) -> @ast::expr {\n       token::AT. {\n         p.bump();\n         let m = parse_mutability(p);\n-        let e = parse_prefix_expr(p);\n+        let e = to_expr(parse_prefix_expr(p));\n         hi = e.span.hi;\n         ex = ast::expr_unary(ast::box(m), e);\n       }\n       token::TILDE. {\n         p.bump();\n         let m = parse_mutability(p);\n-        let e = parse_prefix_expr(p);\n+        let e = to_expr(parse_prefix_expr(p));\n         hi = e.span.hi;\n         ex = ast::expr_unary(ast::uniq(m), e);\n       }\n       _ { ret parse_dot_or_call_expr(p); }\n     }\n-    ret mk_expr(p, lo, hi, ex);\n+    ret mk_pexpr(p, lo, hi, ex);\n }\n \n fn parse_ternary(p: parser) -> @ast::expr {\n@@ -1146,9 +1176,10 @@ const unop_prec: int = 100;\n const as_prec: int = 5;\n const ternary_prec: int = 0;\n \n-fn parse_more_binops(p: parser, lhs: @ast::expr, min_prec: int) ->\n+fn parse_more_binops(p: parser, plhs: pexpr, min_prec: int) ->\n    @ast::expr {\n-    if expr_is_complete(p, lhs) { ret lhs; }\n+    let lhs = to_expr(plhs);\n+    if expr_is_complete(p, plhs) { ret lhs; }\n     let peeked = p.peek();\n     if peeked == token::BINOP(token::OR) &&\n        p.get_restriction() == RESTRICT_NO_BAR_OP { ret lhs; }\n@@ -1157,15 +1188,15 @@ fn parse_more_binops(p: parser, lhs: @ast::expr, min_prec: int) ->\n             p.bump();\n             let expr = parse_prefix_expr(p);\n             let rhs = parse_more_binops(p, expr, cur.prec);\n-            let bin = mk_expr(p, lhs.span.lo, rhs.span.hi,\n+            let bin = mk_pexpr(p, lhs.span.lo, rhs.span.hi,\n                               ast::expr_binary(cur.op, lhs, rhs));\n             ret parse_more_binops(p, bin, min_prec);\n         }\n     }\n     if as_prec > min_prec && eat_word(p, \"as\") {\n         let rhs = parse_ty(p, true);\n         let _as =\n-            mk_expr(p, lhs.span.lo, rhs.span.hi, ast::expr_cast(lhs, rhs));\n+            mk_pexpr(p, lhs.span.lo, rhs.span.hi, ast::expr_cast(lhs, rhs));\n         ret parse_more_binops(p, _as, min_prec);\n     }\n     ret lhs;\n@@ -1587,12 +1618,12 @@ fn parse_stmt(p: parser) -> @ast::stmt {\n     }\n }\n \n-fn expr_is_complete(p: parser, e: @ast::expr) -> bool {\n+fn expr_is_complete(p: parser, e: pexpr) -> bool {\n     log(debug, (\"expr_is_complete\", p.get_restriction(),\n-                print::pprust::expr_to_str(e),\n-                expr_requires_semi_to_be_stmt(e)));\n+                print::pprust::expr_to_str(*e),\n+                expr_requires_semi_to_be_stmt(*e)));\n     ret p.get_restriction() == RESTRICT_STMT_EXPR &&\n-        !expr_requires_semi_to_be_stmt(e);\n+        !expr_requires_semi_to_be_stmt(*e);\n }\n \n fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {"}, {"sha": "efcb5af30aed8146384029df05e338e0922be5ab", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/37ba5f3b3252aceb28c037021225bbb6a27006f3/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ba5f3b3252aceb28c037021225bbb6a27006f3/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=37ba5f3b3252aceb28c037021225bbb6a27006f3", "patch": "@@ -558,22 +558,6 @@ fn print_attribute(s: ps, attr: ast::attribute) {\n     word(s.s, \"]\");\n }\n \n-// An expression that begins with a dual-form statement/expression like `{\n-// ... }-10` would be parsed as `{ ... };-10` unless parentheses are used (ie,\n-// `({...}-10)`).  These parentheses are not, however, preserved by the\n-// parser. This function specifies whether parentheses must be inserted.\n-fn stmt_expr_requires_parens(ex: @ast::expr) -> bool {\n-    fn helper(ex: @ast::expr, inner: bool) -> bool {\n-        alt ex.node {\n-          ast::expr_call(subex, _, _) | ast::expr_binary(_, subex, _) {\n-            be helper(subex, true);\n-          }\n-          _ when !inner { ret false; }\n-          _ { ret !parse::parser::expr_requires_semi_to_be_stmt(ex); }\n-        }\n-    }\n-    ret helper(ex, false);\n-}\n \n fn print_stmt(s: ps, st: ast::stmt) {\n     maybe_print_comment(s, st.span.lo);\n@@ -583,13 +567,7 @@ fn print_stmt(s: ps, st: ast::stmt) {\n       }\n       ast::stmt_expr(expr, _) {\n         space_if_not_bol(s);\n-        if stmt_expr_requires_parens(expr) {\n-            popen(s);\n-            print_expr(s, expr);\n-            pclose(s);\n-        } else {\n-            print_expr(s, expr);\n-        }\n+        print_tl_expr(s, expr);\n       }\n     }\n     if parse::parser::stmt_ends_with_semi(st) { word(s.s, \";\"); }\n@@ -626,7 +604,7 @@ fn print_possibly_embedded_block(s: ps, blk: ast::blk, embedded: embed_type,\n     alt blk.node.expr {\n       some(expr) {\n         space_if_not_bol(s);\n-        print_expr(s, expr);\n+        print_tl_expr(s, expr);\n         maybe_print_trailing_comment(s, expr.span, some(blk.span.hi));\n       }\n       _ { }\n@@ -714,6 +692,37 @@ fn print_mac(s: ps, m: ast::mac) {\n     }\n }\n \n+// An expression that begins with a dual-form statement/expression like `{\n+// ... }-10` would be parsed as `{ ... };-10` unless parentheses are used (ie,\n+// `({...}-10)`).  These parentheses are not, however, preserved by the\n+// parser. This function specifies whether parentheses must be inserted.\n+fn print_tl_expr(s: ps, &&expr: @ast::expr) {\n+    fn stmt_expr_requires_parens(ex: @ast::expr) -> bool {\n+        fn helper(ex: @ast::expr, inner: bool) -> bool {\n+            log(debug, (\"helper\", ex, inner));\n+            if inner && !parse::parser::expr_requires_semi_to_be_stmt(ex) {\n+                ret true;\n+            }\n+            alt ex.node {\n+              ast::expr_call(subex, _, _) | ast::expr_binary(_, subex, _) {\n+                be helper(subex, true);\n+              }\n+              _ { ret false; }\n+            }\n+        }\n+        ret helper(ex, false);\n+    }\n+\n+    #debug(\"print_tl_expr %s\", expr_to_str(expr));\n+    if stmt_expr_requires_parens(expr) {\n+        popen(s);\n+        print_expr(s, expr);\n+        pclose(s);\n+    } else {\n+        print_expr(s, expr);\n+    }\n+}\n+\n fn print_expr(s: ps, &&expr: @ast::expr) {\n     maybe_print_comment(s, expr.span.lo);\n     ibox(s, indent_unit);\n@@ -1380,15 +1389,8 @@ fn need_parens(expr: @ast::expr, outer_prec: int) -> bool {\n       ast::expr_binary(op, _, _) { operator_prec(op) < outer_prec }\n       ast::expr_cast(_, _) { parse::parser::as_prec < outer_prec }\n       ast::expr_ternary(_, _, _) { parse::parser::ternary_prec < outer_prec }\n-\n-\n-\n-\n-\n       // This may be too conservative in some cases\n-      ast::expr_assign(_, _) {\n-        true\n-      }\n+      ast::expr_assign(_, _) { true }\n       ast::expr_move(_, _) { true }\n       ast::expr_swap(_, _) { true }\n       ast::expr_assign_op(_, _, _) { true }"}, {"sha": "35b02da64d887f02ae891f2f3570a015d5f957f2", "filename": "src/test/run-pass/block-arg-in-parentheses.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/37ba5f3b3252aceb28c037021225bbb6a27006f3/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ba5f3b3252aceb28c037021225bbb6a27006f3/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs?ref=37ba5f3b3252aceb28c037021225bbb6a27006f3", "patch": "@@ -1,23 +1,21 @@\n-// xfail-test\n+fn w_semi(v: [int]) -> int {\n+    vec::foldl(0, v) {|x,y| x+y};\n+    -10\n+}\n+\n+fn wo_paren(v: [int]) -> int {\n+    // Perhaps surprising: this is parsed equivalently to w_semi()\n+    vec::foldl(0, v) {|x,y| x+y} - 10\n+}\n \n-// FIXME: Parser doesn't distinguish expression in parentheses (as in\n-// this example) from one that is not!  It is somewhat of a pain to\n-// fix this though there are no theoretical difficulties.  We could\n-// either add paren to the AST (better for pretty-print, I suppose) or\n-// modify the parser to track whether the expression in question is\n-// parenthesized.  I did the latter once and it was a bit of pain but\n-// not terribly difficult.  We could also the decision as to whether\n-// something is an \"expression with a value\" down into the\n-// parse_expr() codepath, where we *know* if there are parentheses or\n-// not, but we'd probably have to be a bit more careful then with\n-// clearing the top-level restrction flag (which we ought to do\n-// anyhow!)\n+fn w_paren(v: [int]) -> int {\n+    // Here the parentheses force interpretation as an expression:\n+    (vec::foldl(0, v) {|x,y| x+y}) - 10\n+}\n \n fn main() {\n-    let v = [1f, 2f, 3f];\n-    let w =\n-        if true { (vec::any(v) { |e| float::nonnegative(e) }) }\n-        else { false };\n-    assert w;\n+    assert wo_paren([0, 1, 2, 3]) == -10;\n+    assert w_semi([0, 1, 2, 3]) == -10;\n+    assert w_paren([0, 1, 2, 3]) == -4;\n }\n "}]}