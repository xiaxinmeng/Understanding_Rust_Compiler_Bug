{"sha": "12c7e273309e7fb3c8309e0d6217d96baa7cbc89", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyYzdlMjczMzA5ZTdmYjNjODMwOWUwZDYyMTdkOTZiYWE3Y2JjODk=", "commit": {"author": {"name": "Mikhail Modin", "email": "mikhailm1@gmail.com", "date": "2018-02-19T16:42:00Z"}, "committer": {"name": "Mikhail Modin", "email": "mikhailm1@gmail.com", "date": "2018-02-25T15:59:16Z"}, "message": "restore Subslice move out from array after elaborate drops and borrowck", "tree": {"sha": "bb933c46c9bd6178a8ac3735a9d83fe875a21467", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb933c46c9bd6178a8ac3735a9d83fe875a21467"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12c7e273309e7fb3c8309e0d6217d96baa7cbc89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12c7e273309e7fb3c8309e0d6217d96baa7cbc89", "html_url": "https://github.com/rust-lang/rust/commit/12c7e273309e7fb3c8309e0d6217d96baa7cbc89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12c7e273309e7fb3c8309e0d6217d96baa7cbc89/comments", "author": {"login": "mikhail-m1", "id": 5663581, "node_id": "MDQ6VXNlcjU2NjM1ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/5663581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikhail-m1", "html_url": "https://github.com/mikhail-m1", "followers_url": "https://api.github.com/users/mikhail-m1/followers", "following_url": "https://api.github.com/users/mikhail-m1/following{/other_user}", "gists_url": "https://api.github.com/users/mikhail-m1/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikhail-m1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikhail-m1/subscriptions", "organizations_url": "https://api.github.com/users/mikhail-m1/orgs", "repos_url": "https://api.github.com/users/mikhail-m1/repos", "events_url": "https://api.github.com/users/mikhail-m1/events{/privacy}", "received_events_url": "https://api.github.com/users/mikhail-m1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mikhail-m1", "id": 5663581, "node_id": "MDQ6VXNlcjU2NjM1ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/5663581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikhail-m1", "html_url": "https://github.com/mikhail-m1", "followers_url": "https://api.github.com/users/mikhail-m1/followers", "following_url": "https://api.github.com/users/mikhail-m1/following{/other_user}", "gists_url": "https://api.github.com/users/mikhail-m1/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikhail-m1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikhail-m1/subscriptions", "organizations_url": "https://api.github.com/users/mikhail-m1/orgs", "repos_url": "https://api.github.com/users/mikhail-m1/repos", "events_url": "https://api.github.com/users/mikhail-m1/events{/privacy}", "received_events_url": "https://api.github.com/users/mikhail-m1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31253d5557f8c161ac97028a3966d617491b86a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/31253d5557f8c161ac97028a3966d617491b86a6", "html_url": "https://github.com/rust-lang/rust/commit/31253d5557f8c161ac97028a3966d617491b86a6"}], "stats": {"total": 224, "additions": 213, "deletions": 11}, "files": [{"sha": "f721cdf714dcad8f6f30bf911b912f597341936d", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/12c7e273309e7fb3c8309e0d6217d96baa7cbc89/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c7e273309e7fb3c8309e0d6217d96baa7cbc89/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=12c7e273309e7fb3c8309e0d6217d96baa7cbc89", "patch": "@@ -257,6 +257,7 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n \n \n         // Optimizations begin.\n+        uniform_array_move_out::RestoreSubsliceArrayMoveOut,\n         inline::Inline,\n         instcombine::InstCombine,\n         deaggregator::Deaggregator,"}, {"sha": "e46de170479861dc07e47b1bfe137dc40e8bb627", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 187, "deletions": 11, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/12c7e273309e7fb3c8309e0d6217d96baa7cbc89/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c7e273309e7fb3c8309e0d6217d96baa7cbc89/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=12c7e273309e7fb3c8309e0d6217d96baa7cbc89", "patch": "@@ -34,15 +34,15 @@\n //  and mir statement _11 = move _2[-1 of 1]; replaced by:\n //  _11 = move _2[2 of 3];\n //\n-// FIXME: convert to Subslice back for performance reason\n // FIXME: integrate this transformation to the mir build\n \n use rustc::ty;\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n-use rustc::mir::visit::Visitor;\n+use rustc::mir::visit::{Visitor, PlaceContext};\n use transform::{MirPass, MirSource};\n use util::patch::MirPatch;\n+use rustc_data_structures::indexed_vec::{IndexVec};\n \n pub struct UniformArrayMoveOut;\n \n@@ -67,12 +67,12 @@ struct UniformArrayMoveOutVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n-    fn visit_statement(&mut self,\n-                       block: BasicBlock,\n-                       statement: &Statement<'tcx>,\n-                       location: Location) {\n-        if let StatementKind::Assign(ref dst_place,\n-                                     Rvalue::Use(Operand::Move(ref src_place))) = statement.kind {\n+    fn visit_assign(&mut self,\n+                    block: BasicBlock,\n+                    dst_place: &Place<'tcx>,\n+                    rvalue: &Rvalue<'tcx>,\n+                    location: Location) {\n+        if let Rvalue::Use(Operand::Move(ref src_place)) = rvalue {\n             if let Place::Projection(ref proj) = *src_place {\n                 if let ProjectionElem::ConstantIndex{offset: _,\n                                                      min_length: _,\n@@ -92,7 +92,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                 }\n             }\n         }\n-        return self.super_statement(block, statement, location);\n+        self.super_assign(block, dst_place, rvalue, location)\n     }\n }\n \n@@ -104,7 +104,7 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n                item_ty: &'tcx ty::TyS<'tcx>,\n                size: u32) {\n         match proj.elem {\n-            // uniform _10 = move _2[:-1];\n+            // uniforms statements like_10 = move _2[:-1];\n             ProjectionElem::Subslice{from, to} => {\n                 self.patch.make_nop(location);\n                 let temps : Vec<_> = (from..(size-to)).map(|i| {\n@@ -133,7 +133,7 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n                     self.patch.add_statement(location, StatementKind::StorageDead(temp));\n                 }\n             }\n-            // _11 = move _2[-1 of 1];\n+            // uniforms statements like _11 = move _2[-1 of 1];\n             ProjectionElem::ConstantIndex{offset, min_length: _, from_end: true} => {\n                 self.patch.make_nop(location);\n                 self.patch.add_assign(location,\n@@ -151,3 +151,179 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n         }\n     }\n }\n+\n+// Restore Subslice move out after analysis\n+// Example:\n+//\n+//  next statements:\n+//   StorageLive(_12);\n+//   _12 = move _2[0 of 3];\n+//   StorageLive(_13);\n+//   _13 = move _2[1 of 3];\n+//   _10 = [move _12, move _13]\n+//   StorageDead(_12);\n+//   StorageDead(_13);\n+//\n+// replaced by _10 = move _2[:-1];\n+\n+pub struct RestoreSubsliceArrayMoveOut;\n+\n+impl MirPass for RestoreSubsliceArrayMoveOut {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _src: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n+        let mut patch = MirPatch::new(mir);\n+        {\n+            let mut visitor = RestoreDataCollector {\n+                locals_use: IndexVec::from_elem(LocalUse::new(), &mir.local_decls),\n+                candidates: vec![],\n+            };\n+            visitor.visit_mir(mir);\n+\n+            for candidate in &visitor.candidates {\n+                let statement = &mir[candidate.block].statements[candidate.statement_index];\n+                if let StatementKind::Assign(ref dst_place, ref rval) = statement.kind {\n+                    if let Rvalue::Aggregate(box AggregateKind::Array(_), ref items) = *rval {\n+                        let items : Vec<_> = items.iter().map(|item| {\n+                            if let Operand::Move(Place::Local(local)) = item {\n+                                let local_use = &visitor.locals_use[*local];\n+                                let opt_index_and_place = Self::try_get_item_source(local_use, mir);\n+                                // each local should be used twice:\n+                                //  in assign and in aggregate statments\n+                                if local_use.use_count == 2 && opt_index_and_place.is_some() {\n+                                    let (index, src_place) = opt_index_and_place.unwrap();\n+                                    return Some((local_use, index, src_place));\n+                                }\n+                            }\n+                            None\n+                        }).collect();\n+\n+                        let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n+                        let opt_size = opt_src_place.and_then(|src_place| {\n+                            let src_ty = src_place.ty(mir, tcx).to_ty(tcx);\n+                            if let ty::TyArray(_, ref size_o) = src_ty.sty {\n+                                size_o.val.to_const_int().and_then(|v| v.to_u64())\n+                            } else {\n+                                None\n+                            }\n+                        });\n+                        Self::check_and_patch(*candidate, &items, opt_size, &mut patch, dst_place);\n+                    }\n+                }\n+            }\n+        }\n+        patch.apply(mir);\n+    }\n+}\n+\n+impl RestoreSubsliceArrayMoveOut {\n+    // Checks that source has size, all locals are inited from same source place and\n+    // indices is an integer interval. If all checks pass do the replacent.\n+    // items are Vec<Option<LocalUse, index in source array, source place for init local>>\n+    fn check_and_patch<'tcx>(candidate: Location,\n+                             items: &Vec<Option<(&LocalUse, u32, &Place<'tcx>)>>,\n+                             opt_size: Option<u64>,\n+                             patch: &mut MirPatch<'tcx>,\n+                             dst_place: &Place<'tcx>) {\n+        let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n+\n+        if opt_size.is_some() && items.iter().all(\n+            |l| l.is_some() && l.unwrap().2 == opt_src_place.unwrap()) {\n+\n+            let indicies: Vec<_> = items.iter().map(|x| x.unwrap().1).collect();\n+            for i in 1..indicies.len() {\n+                if indicies[i - 1] + 1 != indicies[i] {\n+                    return;\n+                }\n+            }\n+\n+            let min = *indicies.first().unwrap();\n+            let max = *indicies.last().unwrap();\n+\n+            for item in items {\n+                let locals_use = item.unwrap().0;\n+                patch.make_nop(locals_use.alive.unwrap());\n+                patch.make_nop(locals_use.dead.unwrap());\n+                patch.make_nop(locals_use.first_use.unwrap());\n+            }\n+            patch.make_nop(candidate);\n+            let size = opt_size.unwrap() as u32;\n+            patch.add_assign(candidate,\n+                             dst_place.clone(),\n+                             Rvalue::Use(\n+                                 Operand::Move(\n+                                     Place::Projection(box PlaceProjection{\n+                                         base: opt_src_place.unwrap().clone(),\n+                                         elem: ProjectionElem::Subslice{\n+                                             from: min, to: size - max - 1}}))));\n+        }\n+    }\n+\n+    fn try_get_item_source<'a, 'tcx>(local_use: &LocalUse,\n+                                     mir: &'a Mir<'tcx>) -> Option<(u32, &'a Place<'tcx>)> {\n+        if let Some(location) = local_use.first_use {\n+            let block = &mir[location.block];\n+            if block.statements.len() > location.statement_index {\n+                let statement = &block.statements[location.statement_index];\n+                if let StatementKind::Assign(\n+                    Place::Local(_),\n+                    Rvalue::Use(Operand::Move(Place::Projection(box PlaceProjection{\n+                        ref base, elem: ProjectionElem::ConstantIndex{\n+                            offset, min_length: _, from_end: false}})))) = statement.kind {\n+                    return Some((offset, base))\n+                }\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+struct LocalUse {\n+    alive: Option<Location>,\n+    dead: Option<Location>,\n+    use_count: u32,\n+    first_use: Option<Location>,\n+}\n+\n+impl LocalUse {\n+    pub fn new() -> Self {\n+        LocalUse{alive: None, dead: None, use_count: 0, first_use: None}\n+    }\n+}\n+\n+struct RestoreDataCollector {\n+    locals_use: IndexVec<Local, LocalUse>,\n+    candidates: Vec<Location>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for RestoreDataCollector {\n+    fn visit_assign(&mut self,\n+                    block: BasicBlock,\n+                    place: &Place<'tcx>,\n+                    rvalue: &Rvalue<'tcx>,\n+                    location: Location) {\n+        if let Rvalue::Aggregate(box AggregateKind::Array(_), _) = *rvalue {\n+            self.candidates.push(location);\n+        }\n+        self.super_assign(block, place, rvalue, location)\n+    }\n+\n+    fn visit_local(&mut self,\n+                   local: &Local,\n+                   context: PlaceContext<'tcx>,\n+                   location: Location) {\n+        let local_use = &mut self.locals_use[*local];\n+        match context {\n+            PlaceContext::StorageLive => local_use.alive = Some(location),\n+            PlaceContext::StorageDead => local_use.dead = Some(location),\n+            _ => {\n+                local_use.use_count += 1;\n+                if local_use.first_use.is_none() {\n+                    local_use.first_use = Some(location);\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "482b69a59ddbc1bcdd34a065f669194081758001", "filename": "src/test/mir-opt/uniform_array_move_out.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/12c7e273309e7fb3c8309e0d6217d96baa7cbc89/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c7e273309e7fb3c8309e0d6217d96baa7cbc89/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs?ref=12c7e273309e7fb3c8309e0d6217d96baa7cbc89", "patch": "@@ -57,3 +57,28 @@ fn main() {\n //     nop;\n //     _0 = ();\n // END rustc.move_out_by_subslice.UniformArrayMoveOut.after.mir\n+\n+// START rustc.move_out_by_subslice.RestoreSubsliceArrayMoveOut.before.mir\n+//     StorageLive(_6);\n+//     StorageLive(_7);\n+//     _7 = move _1[0 of 2];\n+//     StorageLive(_8);\n+//     _8 = move _1[1 of 2];\n+//     _6 = [move _7, move _8];\n+//     StorageDead(_7);\n+//     StorageDead(_8);\n+//     _0 = ();\n+// END rustc.move_out_by_subslice.RestoreSubsliceArrayMoveOut.before.mir\n+\n+// START rustc.move_out_by_subslice.RestoreSubsliceArrayMoveOut.after.mir\n+//     StorageLive(_6);\n+//     nop;\n+//     nop;\n+//     nop;\n+//     nop;\n+//     _6 = move _1[0:];\n+//     nop;\n+//     nop;\n+//     nop;\n+//     _0 = ();\n+// END rustc.move_out_by_subslice.RestoreSubsliceArrayMoveOut.after.mir"}]}