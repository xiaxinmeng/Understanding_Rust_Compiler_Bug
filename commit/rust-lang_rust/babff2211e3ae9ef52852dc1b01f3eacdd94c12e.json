{"sha": "babff2211e3ae9ef52852dc1b01f3eacdd94c12e", "node_id": "C_kwDOAAsO6NoAKGJhYmZmMjIxMWUzYWU5ZWY1Mjg1MmRjMWIwMWYzZWFjZGQ5NGMxMmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-25T00:20:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-25T00:20:43Z"}, "message": "Auto merge of #97581 - AngelicosPhosphoros:improve_calloc_check_in_vec_macro_for_tuples, r=Mark-Simulacrum\n\nSupport vec zero-alloc optimization for tuples and byte arrays\n\n* Implement IsZero trait for tuples up to 8 IsZero elements;\n* Implement IsZero for u8/i8, leading to implementation of it for arrays of them too;\n* Add more codegen tests for this optimization.\n* Lower size of array for IsZero trait because it fails to inline checks", "tree": {"sha": "bd54c992772691b4f4d2e0edbdaff92c9f5e3e40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd54c992772691b4f4d2e0edbdaff92c9f5e3e40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/babff2211e3ae9ef52852dc1b01f3eacdd94c12e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/babff2211e3ae9ef52852dc1b01f3eacdd94c12e", "html_url": "https://github.com/rust-lang/rust/commit/babff2211e3ae9ef52852dc1b01f3eacdd94c12e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/babff2211e3ae9ef52852dc1b01f3eacdd94c12e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ae03e027a66744e934a7bfa7127256489bed3c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ae03e027a66744e934a7bfa7127256489bed3c2", "html_url": "https://github.com/rust-lang/rust/commit/3ae03e027a66744e934a7bfa7127256489bed3c2"}, {"sha": "86d445eda8ca2d884551fd0ac00a89e4bfe1cc81", "url": "https://api.github.com/repos/rust-lang/rust/commits/86d445eda8ca2d884551fd0ac00a89e4bfe1cc81", "html_url": "https://github.com/rust-lang/rust/commit/86d445eda8ca2d884551fd0ac00a89e4bfe1cc81"}], "stats": {"total": 199, "additions": 170, "deletions": 29}, "files": [{"sha": "92a32779b8e64b4866e0fb9a9707b10a51c6c261", "filename": "library/alloc/src/vec/is_zero.rs", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/babff2211e3ae9ef52852dc1b01f3eacdd94c12e/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/babff2211e3ae9ef52852dc1b01f3eacdd94c12e/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs?ref=babff2211e3ae9ef52852dc1b01f3eacdd94c12e", "patch": "@@ -17,12 +17,14 @@ macro_rules! impl_is_zero {\n     };\n }\n \n+impl_is_zero!(i8, |x| x == 0); // It is needed to impl for arrays and tuples of i8.\n impl_is_zero!(i16, |x| x == 0);\n impl_is_zero!(i32, |x| x == 0);\n impl_is_zero!(i64, |x| x == 0);\n impl_is_zero!(i128, |x| x == 0);\n impl_is_zero!(isize, |x| x == 0);\n \n+impl_is_zero!(u8, |x| x == 0); // It is needed to impl for arrays and tuples of u8.\n impl_is_zero!(u16, |x| x == 0);\n impl_is_zero!(u32, |x| x == 0);\n impl_is_zero!(u64, |x| x == 0);\n@@ -54,15 +56,41 @@ unsafe impl<T: IsZero, const N: usize> IsZero for [T; N] {\n     fn is_zero(&self) -> bool {\n         // Because this is generated as a runtime check, it's not obvious that\n         // it's worth doing if the array is really long.  The threshold here\n-        // is largely arbitrary, but was picked because as of 2022-05-01 LLVM\n-        // can const-fold the check in `vec![[0; 32]; n]` but not in\n-        // `vec![[0; 64]; n]`: https://godbolt.org/z/WTzjzfs5b\n+        // is largely arbitrary, but was picked because as of 2022-07-01 LLVM\n+        // fails to const-fold the check in `vec![[1; 32]; n]`\n+        // See https://github.com/rust-lang/rust/pull/97581#issuecomment-1166628022\n         // Feel free to tweak if you have better evidence.\n \n-        N <= 32 && self.iter().all(IsZero::is_zero)\n+        N <= 16 && self.iter().all(IsZero::is_zero)\n     }\n }\n \n+// This is recursive macro.\n+macro_rules! impl_for_tuples {\n+    // Stopper\n+    () => {\n+        // No use for implementing for empty tuple because it is ZST.\n+    };\n+    ($first_arg:ident $(,$rest:ident)*) => {\n+        unsafe impl <$first_arg: IsZero, $($rest: IsZero,)*> IsZero for ($first_arg, $($rest,)*){\n+            #[inline]\n+            fn is_zero(&self) -> bool{\n+                // Destructure tuple to N references\n+                // Rust allows to hide generic params by local variable names.\n+                #[allow(non_snake_case)]\n+                let ($first_arg, $($rest,)*) = self;\n+\n+                $first_arg.is_zero()\n+                    $( && $rest.is_zero() )*\n+            }\n+        }\n+\n+        impl_for_tuples!($($rest),*);\n+    }\n+}\n+\n+impl_for_tuples!(A, B, C, D, E, F, G, H);\n+\n // `Option<&T>` and `Option<Box<T>>` are guaranteed to represent `None` as null.\n // For fat pointers, the bytes that would be the pointer metadata in the `Some`\n // variant are padding in the `None` variant, so ignoring them and"}, {"sha": "ff364c033ee98f4f09616d9bc7c317a77353b4a3", "filename": "library/alloc/src/vec/spec_from_elem.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/babff2211e3ae9ef52852dc1b01f3eacdd94c12e/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_elem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/babff2211e3ae9ef52852dc1b01f3eacdd94c12e/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_elem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_elem.rs?ref=babff2211e3ae9ef52852dc1b01f3eacdd94c12e", "patch": "@@ -1,6 +1,7 @@\n+use core::ptr;\n+\n use crate::alloc::Allocator;\n use crate::raw_vec::RawVec;\n-use core::ptr::{self};\n \n use super::{ExtendElement, IsZero, Vec};\n \n@@ -17,6 +18,18 @@ impl<T: Clone> SpecFromElem for T {\n     }\n }\n \n+impl<T: Clone + IsZero> SpecFromElem for T {\n+    #[inline]\n+    default fn from_elem<A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<T, A> {\n+        if elem.is_zero() {\n+            return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n+        }\n+        let mut v = Vec::with_capacity_in(n, alloc);\n+        v.extend_with(n, ExtendElement(elem));\n+        v\n+    }\n+}\n+\n impl SpecFromElem for i8 {\n     #[inline]\n     fn from_elem<A: Allocator>(elem: i8, n: usize, alloc: A) -> Vec<i8, A> {\n@@ -46,15 +59,3 @@ impl SpecFromElem for u8 {\n         }\n     }\n }\n-\n-impl<T: Clone + IsZero> SpecFromElem for T {\n-    #[inline]\n-    fn from_elem<A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<T, A> {\n-        if elem.is_zero() {\n-            return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n-        }\n-        let mut v = Vec::with_capacity_in(n, alloc);\n-        v.extend_with(n, ExtendElement(elem));\n-        v\n-    }\n-}"}, {"sha": "08302796c41a1e14a8cbdb124d6078442e857eb5", "filename": "src/test/codegen/vec-calloc.rs", "status": "modified", "additions": 124, "deletions": 12, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/babff2211e3ae9ef52852dc1b01f3eacdd94c12e/src%2Ftest%2Fcodegen%2Fvec-calloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/babff2211e3ae9ef52852dc1b01f3eacdd94c12e/src%2Ftest%2Fcodegen%2Fvec-calloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvec-calloc.rs?ref=babff2211e3ae9ef52852dc1b01f3eacdd94c12e", "patch": "@@ -4,29 +4,141 @@\n \n #![crate_type = \"lib\"]\n \n+// CHECK-LABEL: @vec_zero_bytes\n+#[no_mangle]\n+pub fn vec_zero_bytes(n: usize) -> Vec<u8> {\n+    // CHECK-NOT: call {{.*}}alloc::vec::from_elem\n+    // CHECK-NOT: call {{.*}}reserve\n+    // CHECK-NOT: call {{.*}}__rust_alloc(\n+    // CHECK-NOT: call {{.*}}llvm.memset\n+\n+    // CHECK: call {{.*}}__rust_alloc_zeroed(\n+\n+    // CHECK-NOT: call {{.*}}alloc::vec::from_elem\n+    // CHECK-NOT: call {{.*}}reserve\n+    // CHECK-NOT: call {{.*}}__rust_alloc(\n+    // CHECK-NOT: call {{.*}}llvm.memset\n+\n+    // CHECK: ret void\n+    vec![0; n]\n+}\n+\n+// CHECK-LABEL: @vec_one_bytes\n+#[no_mangle]\n+pub fn vec_one_bytes(n: usize) -> Vec<u8> {\n+    // CHECK-NOT: call {{.*}}alloc::vec::from_elem\n+    // CHECK-NOT: call {{.*}}reserve\n+    // CHECK-NOT: call {{.*}}__rust_alloc_zeroed(\n+\n+    // CHECK: call {{.*}}__rust_alloc(\n+    // CHECK: call {{.*}}llvm.memset\n+\n+    // CHECK-NOT: call {{.*}}alloc::vec::from_elem\n+    // CHECK-NOT: call {{.*}}reserve\n+    // CHECK-NOT: call {{.*}}__rust_alloc_zeroed(\n+\n+    // CHECK: ret void\n+    vec![1; n]\n+}\n+\n // CHECK-LABEL: @vec_zero_scalar\n #[no_mangle]\n pub fn vec_zero_scalar(n: usize) -> Vec<i32> {\n-    // CHECK-NOT: __rust_alloc(\n-    // CHECK: __rust_alloc_zeroed(\n-    // CHECK-NOT: __rust_alloc(\n+    // CHECK-NOT: call {{.*}}alloc::vec::from_elem\n+    // CHECK-NOT: call {{.*}}reserve\n+    // CHECK-NOT: call {{.*}}__rust_alloc(\n+\n+    // CHECK: call {{.*}}__rust_alloc_zeroed(\n+\n+    // CHECK-NOT: call {{.*}}alloc::vec::from_elem\n+    // CHECK-NOT: call {{.*}}reserve\n+    // CHECK-NOT: call {{.*}}__rust_alloc(\n+\n+    // CHECK: ret void\n     vec![0; n]\n }\n \n+// CHECK-LABEL: @vec_one_scalar\n+#[no_mangle]\n+pub fn vec_one_scalar(n: usize) -> Vec<i32> {\n+    // CHECK-NOT: call {{.*}}alloc::vec::from_elem\n+    // CHECK-NOT: call {{.*}}reserve\n+    // CHECK-NOT: call {{.*}}__rust_alloc_zeroed(\n+\n+    // CHECK: call {{.*}}__rust_alloc(\n+\n+    // CHECK-NOT: call {{.*}}alloc::vec::from_elem\n+    // CHECK-NOT: call {{.*}}reserve\n+    // CHECK-NOT: call {{.*}}__rust_alloc_zeroed(\n+\n+    // CHECK: ret void\n+    vec![1; n]\n+}\n+\n // CHECK-LABEL: @vec_zero_rgb48\n #[no_mangle]\n pub fn vec_zero_rgb48(n: usize) -> Vec<[u16; 3]> {\n-    // CHECK-NOT: __rust_alloc(\n-    // CHECK: __rust_alloc_zeroed(\n-    // CHECK-NOT: __rust_alloc(\n+    // CHECK-NOT: call {{.*}}alloc::vec::from_elem\n+    // CHECK-NOT: call {{.*}}reserve\n+    // CHECK-NOT: call {{.*}}__rust_alloc(\n+\n+    // CHECK: call {{.*}}__rust_alloc_zeroed(\n+\n+    // CHECK-NOT: call {{.*}}alloc::vec::from_elem\n+    // CHECK-NOT: call {{.*}}reserve\n+    // CHECK-NOT: call {{.*}}__rust_alloc(\n+\n+    // CHECK: ret void\n     vec![[0, 0, 0]; n]\n }\n \n-// CHECK-LABEL: @vec_zero_array_32\n+// CHECK-LABEL: @vec_zero_array_16\n+#[no_mangle]\n+pub fn vec_zero_array_16(n: usize) -> Vec<[i64; 16]> {\n+    // CHECK-NOT: call {{.*}}alloc::vec::from_elem\n+    // CHECK-NOT: call {{.*}}reserve\n+    // CHECK-NOT: call {{.*}}__rust_alloc(\n+\n+    // CHECK: call {{.*}}__rust_alloc_zeroed(\n+\n+    // CHECK-NOT: call {{.*}}alloc::vec::from_elem\n+    // CHECK-NOT: call {{.*}}reserve\n+    // CHECK-NOT: call {{.*}}__rust_alloc(\n+\n+    // CHECK: ret void\n+    vec![[0_i64; 16]; n]\n+}\n+\n+// CHECK-LABEL: @vec_zero_tuple\n+#[no_mangle]\n+pub fn vec_zero_tuple(n: usize) -> Vec<(i16, u8, char)> {\n+    // CHECK-NOT: call {{.*}}alloc::vec::from_elem\n+    // CHECK-NOT: call {{.*}}reserve\n+    // CHECK-NOT: call {{.*}}__rust_alloc(\n+\n+    // CHECK: call {{.*}}__rust_alloc_zeroed(\n+\n+    // CHECK-NOT: call {{.*}}alloc::vec::from_elem\n+    // CHECK-NOT: call {{.*}}reserve\n+    // CHECK-NOT: call {{.*}}__rust_alloc(\n+\n+    // CHECK: ret void\n+    vec![(0, 0, '\\0'); n]\n+}\n+\n+// CHECK-LABEL: @vec_non_zero_tuple\n #[no_mangle]\n-pub fn vec_zero_array_32(n: usize) -> Vec<[i64; 32]> {\n-    // CHECK-NOT: __rust_alloc(\n-    // CHECK: __rust_alloc_zeroed(\n-    // CHECK-NOT: __rust_alloc(\n-    vec![[0_i64; 32]; n]\n+pub fn vec_non_zero_tuple(n: usize) -> Vec<(i16, u8, char)> {\n+    // CHECK-NOT: call {{.*}}alloc::vec::from_elem\n+    // CHECK-NOT: call {{.*}}reserve\n+    // CHECK-NOT: call {{.*}}__rust_alloc_zeroed(\n+\n+    // CHECK: call {{.*}}__rust_alloc(\n+\n+    // CHECK-NOT: call {{.*}}alloc::vec::from_elem\n+    // CHECK-NOT: call {{.*}}reserve\n+    // CHECK-NOT: call {{.*}}__rust_alloc_zeroed(\n+\n+    // CHECK: ret void\n+    vec![(0, 0, 'A'); n]\n }"}]}