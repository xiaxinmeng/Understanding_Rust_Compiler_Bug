{"sha": "c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzZmQ1ZDBkZGVhZDViMTRjZTUzMjFiMDZiYzViZWQ2MGQwY2RmMmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-17T08:54:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-17T08:54:22Z"}, "message": "Auto merge of #48904 - Zoxc:code-and-file-maps, r=michaelwoerister\n\nMake CodeMap and FileMap thread-safe\n\nr? @michaelwoerister", "tree": {"sha": "f4fd63a65fc416b01bd812f528c8758642d56ac6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4fd63a65fc416b01bd812f528c8758642d56ac6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f", "html_url": "https://github.com/rust-lang/rust/commit/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cabda4ce8d675868acff69e69250ad0b08d059b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cabda4ce8d675868acff69e69250ad0b08d059b", "html_url": "https://github.com/rust-lang/rust/commit/8cabda4ce8d675868acff69e69250ad0b08d059b"}, {"sha": "65b49902538b319f9fb07532beff9d02efd3197f", "url": "https://api.github.com/repos/rust-lang/rust/commits/65b49902538b319f9fb07532beff9d02efd3197f", "html_url": "https://github.com/rust-lang/rust/commit/65b49902538b319f9fb07532beff9d02efd3197f"}], "stats": {"total": 211, "additions": 112, "deletions": 99}, "files": [{"sha": "289bc753d7fecb7d938d50003509f5c3e9c9b570", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f", "patch": "@@ -417,24 +417,27 @@ impl<'a> HashStable<StableHashingContext<'a>> for FileMap {\n         src_hash.hash_stable(hcx, hasher);\n \n         // We only hash the relative position within this filemap\n-        let lines = lines.borrow();\n-        lines.len().hash_stable(hcx, hasher);\n-        for &line in lines.iter() {\n-            stable_byte_pos(line, start_pos).hash_stable(hcx, hasher);\n-        }\n+        lines.with_lock(|lines| {\n+            lines.len().hash_stable(hcx, hasher);\n+            for &line in lines.iter() {\n+                stable_byte_pos(line, start_pos).hash_stable(hcx, hasher);\n+            }\n+        });\n \n         // We only hash the relative position within this filemap\n-        let multibyte_chars = multibyte_chars.borrow();\n-        multibyte_chars.len().hash_stable(hcx, hasher);\n-        for &char_pos in multibyte_chars.iter() {\n-            stable_multibyte_char(char_pos, start_pos).hash_stable(hcx, hasher);\n-        }\n+        multibyte_chars.with_lock(|multibyte_chars| {\n+            multibyte_chars.len().hash_stable(hcx, hasher);\n+            for &char_pos in multibyte_chars.iter() {\n+                stable_multibyte_char(char_pos, start_pos).hash_stable(hcx, hasher);\n+            }\n+        });\n \n-        let non_narrow_chars = non_narrow_chars.borrow();\n-        non_narrow_chars.len().hash_stable(hcx, hasher);\n-        for &char_pos in non_narrow_chars.iter() {\n-            stable_non_narrow_char(char_pos, start_pos).hash_stable(hcx, hasher);\n-        }\n+        non_narrow_chars.with_lock(|non_narrow_chars| {\n+            non_narrow_chars.len().hash_stable(hcx, hasher);\n+            for &char_pos in non_narrow_chars.iter() {\n+                stable_non_narrow_char(char_pos, start_pos).hash_stable(hcx, hasher);\n+            }\n+        });\n     }\n }\n "}, {"sha": "f1f3a0519bbcb2044bb4f1db598695073a0fa532", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f", "patch": "@@ -444,7 +444,7 @@ fn get_trans_sysroot(backend_name: &str) -> fn() -> Box<TransCrate> {\n // The FileLoader provides a way to load files from sources other than the file system.\n pub fn run_compiler<'a>(args: &[String],\n                         callbacks: &mut CompilerCalls<'a>,\n-                        file_loader: Option<Box<FileLoader + 'static>>,\n+                        file_loader: Option<Box<FileLoader + Send + Sync + 'static>>,\n                         emitter_dest: Option<Box<Write + Send>>)\n                         -> (CompileResult, Option<Session>)\n {\n@@ -455,7 +455,7 @@ pub fn run_compiler<'a>(args: &[String],\n \n fn run_compiler_impl<'a>(args: &[String],\n                          callbacks: &mut CompilerCalls<'a>,\n-                         file_loader: Option<Box<FileLoader + 'static>>,\n+                         file_loader: Option<Box<FileLoader + Send + Sync + 'static>>,\n                          emitter_dest: Option<Box<Write + Send>>)\n                          -> (CompileResult, Option<Session>)\n {"}, {"sha": "ca5d3f55a0fea4988d75505405c1a32d05917145", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f", "patch": "@@ -12,7 +12,7 @@ use self::Destination::*;\n \n use syntax_pos::{DUMMY_SP, FileMap, Span, MultiSpan};\n \n-use {Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic, CodeMapper, DiagnosticId};\n+use {Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic, CodeMapperDyn, DiagnosticId};\n use snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, StyledString, Style};\n use styled_buffer::StyledBuffer;\n \n@@ -120,7 +120,7 @@ impl ColorConfig {\n \n pub struct EmitterWriter {\n     dst: Destination,\n-    cm: Option<Lrc<CodeMapper>>,\n+    cm: Option<Lrc<CodeMapperDyn>>,\n     short_message: bool,\n     teach: bool,\n     ui_testing: bool,\n@@ -134,7 +134,7 @@ struct FileWithAnnotatedLines {\n \n impl EmitterWriter {\n     pub fn stderr(color_config: ColorConfig,\n-                  code_map: Option<Lrc<CodeMapper>>,\n+                  code_map: Option<Lrc<CodeMapperDyn>>,\n                   short_message: bool,\n                   teach: bool)\n                   -> EmitterWriter {\n@@ -149,7 +149,7 @@ impl EmitterWriter {\n     }\n \n     pub fn new(dst: Box<Write + Send>,\n-               code_map: Option<Lrc<CodeMapper>>,\n+               code_map: Option<Lrc<CodeMapperDyn>>,\n                short_message: bool,\n                teach: bool)\n                -> EmitterWriter {\n@@ -1195,8 +1195,6 @@ impl EmitterWriter {\n                                level: &Level,\n                                max_line_num_len: usize)\n                                -> io::Result<()> {\n-        use std::borrow::Borrow;\n-\n         if let Some(ref cm) = self.cm {\n             let mut buffer = StyledBuffer::new();\n \n@@ -1213,7 +1211,7 @@ impl EmitterWriter {\n                                Some(Style::HeaderMsg));\n \n             // Render the replacements for each suggestion\n-            let suggestions = suggestion.splice_lines(cm.borrow());\n+            let suggestions = suggestion.splice_lines(&**cm);\n \n             let mut row_num = 2;\n             for &(ref complete, ref parts) in suggestions.iter().take(MAX_SUGGESTIONS) {"}, {"sha": "a25c3668bb13b168a5a17c79b4bda065416a1d2d", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f", "patch": "@@ -36,7 +36,7 @@ use self::Level::*;\n \n use emitter::{Emitter, EmitterWriter};\n \n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{self, Lrc};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::stable_hasher::StableHasher;\n \n@@ -106,6 +106,8 @@ pub struct SubstitutionPart {\n     pub snippet: String,\n }\n \n+pub type CodeMapperDyn = CodeMapper + sync::Send + sync::Sync;\n+\n pub trait CodeMapper {\n     fn lookup_char_pos(&self, pos: BytePos) -> Loc;\n     fn span_to_lines(&self, sp: Span) -> FileLinesResult;\n@@ -119,7 +121,8 @@ pub trait CodeMapper {\n \n impl CodeSuggestion {\n     /// Returns the assembled code suggestions and whether they should be shown with an underline.\n-    pub fn splice_lines(&self, cm: &CodeMapper) -> Vec<(String, Vec<SubstitutionPart>)> {\n+    pub fn splice_lines(&self, cm: &CodeMapperDyn)\n+                        -> Vec<(String, Vec<SubstitutionPart>)> {\n         use syntax_pos::{CharPos, Loc, Pos};\n \n         fn push_trailing(buf: &mut String,\n@@ -290,7 +293,7 @@ impl Handler {\n     pub fn with_tty_emitter(color_config: ColorConfig,\n                             can_emit_warnings: bool,\n                             treat_err_as_bug: bool,\n-                            cm: Option<Lrc<CodeMapper>>)\n+                            cm: Option<Lrc<CodeMapperDyn>>)\n                             -> Handler {\n         Handler::with_tty_emitter_and_flags(\n             color_config,\n@@ -303,7 +306,7 @@ impl Handler {\n     }\n \n     pub fn with_tty_emitter_and_flags(color_config: ColorConfig,\n-                                      cm: Option<Lrc<CodeMapper>>,\n+                                      cm: Option<Lrc<CodeMapperDyn>>,\n                                       flags: HandlerFlags)\n                                       -> Handler {\n         let emitter = Box::new(EmitterWriter::stderr(color_config, cm, false, false));"}, {"sha": "a1aec0520885922fe5e2539be3c9f033b95d4ce4", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f", "patch": "@@ -24,8 +24,7 @@ pub use self::ExpnFormat::*;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n-use rustc_data_structures::sync::Lrc;\n-use std::cell::{RefCell, Ref};\n+use rustc_data_structures::sync::{Lrc, Lock, LockGuard};\n use std::cmp;\n use std::hash::Hash;\n use std::path::{Path, PathBuf};\n@@ -125,13 +124,17 @@ impl StableFilemapId {\n // CodeMap\n //\n \n+pub(super) struct CodeMapFiles {\n+    pub(super) file_maps: Vec<Lrc<FileMap>>,\n+    stable_id_to_filemap: FxHashMap<StableFilemapId, Lrc<FileMap>>\n+}\n+\n pub struct CodeMap {\n-    pub(super) files: RefCell<Vec<Lrc<FileMap>>>,\n-    file_loader: Box<FileLoader>,\n+    pub(super) files: Lock<CodeMapFiles>,\n+    file_loader: Box<FileLoader + Sync + Send>,\n     // This is used to apply the file path remapping as specified via\n     // --remap-path-prefix to all FileMaps allocated within this CodeMap.\n     path_mapping: FilePathMapping,\n-    stable_id_to_filemap: RefCell<FxHashMap<StableFilemapId, Lrc<FileMap>>>,\n     /// In case we are in a doctest, replace all file names with the PathBuf,\n     /// and add the given offsets to the line info\n     doctest_offset: Option<(FileName, isize)>,\n@@ -140,10 +143,12 @@ pub struct CodeMap {\n impl CodeMap {\n     pub fn new(path_mapping: FilePathMapping) -> CodeMap {\n         CodeMap {\n-            files: RefCell::new(Vec::new()),\n+            files: Lock::new(CodeMapFiles {\n+                file_maps: Vec::new(),\n+                stable_id_to_filemap: FxHashMap(),\n+            }),\n             file_loader: Box::new(RealFileLoader),\n             path_mapping,\n-            stable_id_to_filemap: RefCell::new(FxHashMap()),\n             doctest_offset: None,\n         }\n     }\n@@ -157,14 +162,16 @@ impl CodeMap {\n \n     }\n \n-    pub fn with_file_loader(file_loader: Box<FileLoader>,\n+    pub fn with_file_loader(file_loader: Box<FileLoader + Sync + Send>,\n                             path_mapping: FilePathMapping)\n                             -> CodeMap {\n         CodeMap {\n-            files: RefCell::new(Vec::new()),\n-            file_loader,\n+            files: Lock::new(CodeMapFiles {\n+                file_maps: Vec::new(),\n+                stable_id_to_filemap: FxHashMap(),\n+            }),\n+            file_loader: file_loader,\n             path_mapping,\n-            stable_id_to_filemap: RefCell::new(FxHashMap()),\n             doctest_offset: None,\n         }\n     }\n@@ -187,17 +194,16 @@ impl CodeMap {\n         Ok(self.new_filemap(filename, src))\n     }\n \n-    pub fn files(&self) -> Ref<Vec<Lrc<FileMap>>> {\n-        self.files.borrow()\n+    pub fn files(&self) -> LockGuard<Vec<Lrc<FileMap>>> {\n+        LockGuard::map(self.files.borrow(), |files| &mut files.file_maps)\n     }\n \n     pub fn filemap_by_stable_id(&self, stable_id: StableFilemapId) -> Option<Lrc<FileMap>> {\n-        self.stable_id_to_filemap.borrow().get(&stable_id).map(|fm| fm.clone())\n+        self.files.borrow().stable_id_to_filemap.get(&stable_id).map(|fm| fm.clone())\n     }\n \n     fn next_start_pos(&self) -> usize {\n-        let files = self.files.borrow();\n-        match files.last() {\n+        match self.files.borrow().file_maps.last() {\n             None => 0,\n             // Add one so there is some space between files. This lets us distinguish\n             // positions in the codemap, even in the presence of zero-length files.\n@@ -207,9 +213,9 @@ impl CodeMap {\n \n     /// Creates a new filemap without setting its line information. If you don't\n     /// intend to set the line information yourself, you should use new_filemap_and_lines.\n+    /// This does not ensure that only one FileMap exists per file name.\n     pub fn new_filemap(&self, filename: FileName, src: String) -> Lrc<FileMap> {\n         let start_pos = self.next_start_pos();\n-        let mut files = self.files.borrow_mut();\n \n         // The path is used to determine the directory for loading submodules and\n         // include files, so it must be before remapping.\n@@ -233,16 +239,16 @@ impl CodeMap {\n             Pos::from_usize(start_pos),\n         ));\n \n-        files.push(filemap.clone());\n+        let mut files = self.files.borrow_mut();\n \n-        self.stable_id_to_filemap\n-            .borrow_mut()\n-            .insert(StableFilemapId::new(&filemap), filemap.clone());\n+        files.file_maps.push(filemap.clone());\n+        files.stable_id_to_filemap.insert(StableFilemapId::new(&filemap), filemap.clone());\n \n         filemap\n     }\n \n     /// Creates a new filemap and sets its line information.\n+    /// This does not ensure that only one FileMap exists per file name.\n     pub fn new_filemap_and_lines(&self, filename: &Path, src: &str) -> Lrc<FileMap> {\n         let fm = self.new_filemap(filename.to_owned().into(), src.to_owned());\n         let mut byte_pos: u32 = fm.start_pos.0;\n@@ -273,7 +279,6 @@ impl CodeMap {\n                                 mut file_local_non_narrow_chars: Vec<NonNarrowChar>)\n                                 -> Lrc<FileMap> {\n         let start_pos = self.next_start_pos();\n-        let mut files = self.files.borrow_mut();\n \n         let end_pos = Pos::from_usize(start_pos + source_len);\n         let start_pos = Pos::from_usize(start_pos);\n@@ -297,20 +302,19 @@ impl CodeMap {\n             crate_of_origin,\n             src: None,\n             src_hash,\n-            external_src: RefCell::new(ExternalSource::AbsentOk),\n+            external_src: Lock::new(ExternalSource::AbsentOk),\n             start_pos,\n             end_pos,\n-            lines: RefCell::new(file_local_lines),\n-            multibyte_chars: RefCell::new(file_local_multibyte_chars),\n-            non_narrow_chars: RefCell::new(file_local_non_narrow_chars),\n+            lines: Lock::new(file_local_lines),\n+            multibyte_chars: Lock::new(file_local_multibyte_chars),\n+            non_narrow_chars: Lock::new(file_local_non_narrow_chars),\n             name_hash,\n         });\n \n-        files.push(filemap.clone());\n+        let mut files = self.files.borrow_mut();\n \n-        self.stable_id_to_filemap\n-            .borrow_mut()\n-            .insert(StableFilemapId::new(&filemap), filemap.clone());\n+        files.file_maps.push(filemap.clone());\n+        files.stable_id_to_filemap.insert(StableFilemapId::new(&filemap), filemap.clone());\n \n         filemap\n     }\n@@ -401,8 +405,7 @@ impl CodeMap {\n     pub fn lookup_line(&self, pos: BytePos) -> Result<FileMapAndLine, Lrc<FileMap>> {\n         let idx = self.lookup_filemap_idx(pos);\n \n-        let files = self.files.borrow();\n-        let f = (*files)[idx].clone();\n+        let f = (*self.files.borrow().file_maps)[idx].clone();\n \n         match f.lookup_line(pos) {\n             Some(line) => Ok(FileMapAndLine { fm: f, line: line }),\n@@ -456,7 +459,7 @@ impl CodeMap {\n     }\n \n     pub fn span_to_string(&self, sp: Span) -> String {\n-        if self.files.borrow().is_empty() && sp.source_equal(&DUMMY_SP) {\n+        if self.files.borrow().file_maps.is_empty() && sp.source_equal(&DUMMY_SP) {\n             return \"no-location\".to_string();\n         }\n \n@@ -799,7 +802,7 @@ impl CodeMap {\n     }\n \n     pub fn get_filemap(&self, filename: &FileName) -> Option<Lrc<FileMap>> {\n-        for fm in self.files.borrow().iter() {\n+        for fm in self.files.borrow().file_maps.iter() {\n             if *filename == fm.name {\n                 return Some(fm.clone());\n             }\n@@ -810,16 +813,15 @@ impl CodeMap {\n     /// For a global BytePos compute the local offset within the containing FileMap\n     pub fn lookup_byte_offset(&self, bpos: BytePos) -> FileMapAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);\n-        let fm = (*self.files.borrow())[idx].clone();\n+        let fm = (*self.files.borrow().file_maps)[idx].clone();\n         let offset = bpos - fm.start_pos;\n         FileMapAndBytePos {fm: fm, pos: offset}\n     }\n \n     /// Converts an absolute BytePos to a CharPos relative to the filemap.\n     pub fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos {\n         let idx = self.lookup_filemap_idx(bpos);\n-        let files = self.files.borrow();\n-        let map = &(*files)[idx];\n+        let map = &(*self.files.borrow().file_maps)[idx];\n \n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n@@ -845,7 +847,7 @@ impl CodeMap {\n     // Return the index of the filemap (in self.files) which contains pos.\n     pub fn lookup_filemap_idx(&self, pos: BytePos) -> usize {\n         let files = self.files.borrow();\n-        let files = &*files;\n+        let files = &files.file_maps;\n         let count = files.len();\n \n         // Binary search for the filemap."}, {"sha": "b4f34fb12e36a1c846af690e37114823a7729f0a", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f", "patch": "@@ -26,7 +26,7 @@ use errors::{DiagnosticBuilder, SubDiagnostic, CodeSuggestion, CodeMapper};\n use errors::DiagnosticId;\n use errors::emitter::{Emitter, EmitterWriter};\n \n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{self, Lrc};\n use std::io::{self, Write};\n use std::vec;\n use std::sync::{Arc, Mutex};\n@@ -36,7 +36,7 @@ use rustc_serialize::json::{as_json, as_pretty_json};\n pub struct JsonEmitter {\n     dst: Box<Write + Send>,\n     registry: Option<Registry>,\n-    cm: Lrc<CodeMapper + 'static>,\n+    cm: Lrc<CodeMapper + sync::Send + sync::Sync>,\n     pretty: bool,\n     /// Whether \"approximate suggestions\" are enabled in the config\n     approximate_suggestions: bool,"}, {"sha": "815ba49a60a72ffe5c6314d692b3f54ac737dd38", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f", "patch": "@@ -611,7 +611,7 @@ impl<'a> StringReader<'a> {\n                 // I guess this is the only way to figure out if\n                 // we're at the beginning of the file...\n                 let cmap = CodeMap::new(FilePathMapping::empty());\n-                cmap.files.borrow_mut().push(self.filemap.clone());\n+                cmap.files.borrow_mut().file_maps.push(self.filemap.clone());\n                 let loc = cmap.lookup_char_pos_adj(self.pos);\n                 debug!(\"Skipping a shebang\");\n                 if loc.line == 1 && loc.col == CharPos(0) {"}, {"sha": "4711d43bfab1a2e289769b24ed3f36a9d423db1a", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 37, "deletions": 30, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f", "patch": "@@ -27,7 +27,7 @@\n #![feature(specialization)]\n \n use std::borrow::Cow;\n-use std::cell::{Cell, RefCell};\n+use std::cell::Cell;\n use std::cmp::{self, Ordering};\n use std::fmt;\n use std::hash::{Hasher, Hash};\n@@ -699,17 +699,17 @@ pub struct FileMap {\n     pub src_hash: u128,\n     /// The external source code (used for external crates, which will have a `None`\n     /// value as `self.src`.\n-    pub external_src: RefCell<ExternalSource>,\n+    pub external_src: Lock<ExternalSource>,\n     /// The start position of this source in the CodeMap\n     pub start_pos: BytePos,\n     /// The end position of this source in the CodeMap\n     pub end_pos: BytePos,\n     /// Locations of lines beginnings in the source code\n-    pub lines: RefCell<Vec<BytePos>>,\n+    pub lines: Lock<Vec<BytePos>>,\n     /// Locations of multi-byte characters in the source code\n-    pub multibyte_chars: RefCell<Vec<MultiByteChar>>,\n+    pub multibyte_chars: Lock<Vec<MultiByteChar>>,\n     /// Width of characters that are not narrow in the source code\n-    pub non_narrow_chars: RefCell<Vec<NonNarrowChar>>,\n+    pub non_narrow_chars: Lock<Vec<NonNarrowChar>>,\n     /// A hash of the filename, used for speeding up the incr. comp. hashing.\n     pub name_hash: u128,\n }\n@@ -839,10 +839,10 @@ impl Decodable for FileMap {\n                 end_pos,\n                 src: None,\n                 src_hash,\n-                external_src: RefCell::new(ExternalSource::AbsentOk),\n-                lines: RefCell::new(lines),\n-                multibyte_chars: RefCell::new(multibyte_chars),\n-                non_narrow_chars: RefCell::new(non_narrow_chars),\n+                external_src: Lock::new(ExternalSource::AbsentOk),\n+                lines: Lock::new(lines),\n+                multibyte_chars: Lock::new(multibyte_chars),\n+                non_narrow_chars: Lock::new(non_narrow_chars),\n                 name_hash,\n             })\n         })\n@@ -882,12 +882,12 @@ impl FileMap {\n             crate_of_origin: 0,\n             src: Some(Lrc::new(src)),\n             src_hash,\n-            external_src: RefCell::new(ExternalSource::Unneeded),\n+            external_src: Lock::new(ExternalSource::Unneeded),\n             start_pos,\n             end_pos: Pos::from_usize(end_pos),\n-            lines: RefCell::new(Vec::new()),\n-            multibyte_chars: RefCell::new(Vec::new()),\n-            non_narrow_chars: RefCell::new(Vec::new()),\n+            lines: Lock::new(Vec::new()),\n+            multibyte_chars: Lock::new(Vec::new()),\n+            non_narrow_chars: Lock::new(Vec::new()),\n             name_hash,\n         }\n     }\n@@ -919,19 +919,24 @@ impl FileMap {\n         if *self.external_src.borrow() == ExternalSource::AbsentOk {\n             let src = get_src();\n             let mut external_src = self.external_src.borrow_mut();\n-            if let Some(src) = src {\n-                let mut hasher: StableHasher<u128> = StableHasher::new();\n-                hasher.write(src.as_bytes());\n-\n-                if hasher.finish() == self.src_hash {\n-                    *external_src = ExternalSource::Present(src);\n-                    return true;\n+            // Check that no-one else have provided the source while we were getting it\n+            if *external_src == ExternalSource::AbsentOk {\n+                if let Some(src) = src {\n+                    let mut hasher: StableHasher<u128> = StableHasher::new();\n+                    hasher.write(src.as_bytes());\n+\n+                    if hasher.finish() == self.src_hash {\n+                        *external_src = ExternalSource::Present(src);\n+                        return true;\n+                    }\n+                } else {\n+                    *external_src = ExternalSource::AbsentErr;\n                 }\n+\n+                false\n             } else {\n-                *external_src = ExternalSource::AbsentErr;\n+                self.src.is_some() || external_src.get_source().is_some()\n             }\n-\n-            false\n         } else {\n             self.src.is_some() || self.external_src.borrow().get_source().is_some()\n         }\n@@ -951,14 +956,16 @@ impl FileMap {\n             }\n         }\n \n-        let lines = self.lines.borrow();\n-        let line = if let Some(line) = lines.get(line_number) {\n-            line\n-        } else {\n-            return None;\n+        let begin = {\n+            let lines = self.lines.borrow();\n+            let line = if let Some(line) = lines.get(line_number) {\n+                line\n+            } else {\n+                return None;\n+            };\n+            let begin: BytePos = *line - self.start_pos;\n+            begin.to_usize()\n         };\n-        let begin: BytePos = *line - self.start_pos;\n-        let begin = begin.to_usize();\n \n         if let Some(ref src) = self.src {\n             Some(Cow::from(get_until_newline(src, begin)))"}]}