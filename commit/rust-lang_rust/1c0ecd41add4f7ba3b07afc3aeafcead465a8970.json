{"sha": "1c0ecd41add4f7ba3b07afc3aeafcead465a8970", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjMGVjZDQxYWRkNGY3YmEzYjA3YWZjM2FlYWZjZWFkNDY1YTg5NzA=", "commit": {"author": {"name": "Jacob Hoffman-Andrews", "email": "github@hoffman-andrews.com", "date": "2021-06-08T04:16:35Z"}, "committer": {"name": "Jacob Hoffman-Andrews", "email": "github@hoffman-andrews.com", "date": "2021-06-08T04:40:56Z"}, "message": "Refactor: Extract render_summary from render_impl.\n\nThis allows for a more readable straight-through logic in render_impl\nwithout need for a closure.", "tree": {"sha": "a416def85277d967e7cad4d14edd77e5c31d7013", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a416def85277d967e7cad4d14edd77e5c31d7013"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c0ecd41add4f7ba3b07afc3aeafcead465a8970", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c0ecd41add4f7ba3b07afc3aeafcead465a8970", "html_url": "https://github.com/rust-lang/rust/commit/1c0ecd41add4f7ba3b07afc3aeafcead465a8970", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c0ecd41add4f7ba3b07afc3aeafcead465a8970/comments", "author": {"login": "jsha", "id": 220205, "node_id": "MDQ6VXNlcjIyMDIwNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/220205?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsha", "html_url": "https://github.com/jsha", "followers_url": "https://api.github.com/users/jsha/followers", "following_url": "https://api.github.com/users/jsha/following{/other_user}", "gists_url": "https://api.github.com/users/jsha/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsha/subscriptions", "organizations_url": "https://api.github.com/users/jsha/orgs", "repos_url": "https://api.github.com/users/jsha/repos", "events_url": "https://api.github.com/users/jsha/events{/privacy}", "received_events_url": "https://api.github.com/users/jsha/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsha", "id": 220205, "node_id": "MDQ6VXNlcjIyMDIwNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/220205?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsha", "html_url": "https://github.com/jsha", "followers_url": "https://api.github.com/users/jsha/followers", "following_url": "https://api.github.com/users/jsha/following{/other_user}", "gists_url": "https://api.github.com/users/jsha/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsha/subscriptions", "organizations_url": "https://api.github.com/users/jsha/orgs", "repos_url": "https://api.github.com/users/jsha/repos", "events_url": "https://api.github.com/users/jsha/events{/privacy}", "received_events_url": "https://api.github.com/users/jsha/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4a60327063e82413eed50a10df3b7d19b77bda0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4a60327063e82413eed50a10df3b7d19b77bda0", "html_url": "https://github.com/rust-lang/rust/commit/e4a60327063e82413eed50a10df3b7d19b77bda0"}], "stats": {"total": 164, "additions": 86, "deletions": 78}, "files": [{"sha": "2e940a31c2aff0e540cb487e08c6d5c4a76115a7", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 86, "deletions": 78, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/1c0ecd41add4f7ba3b07afc3aeafcead465a8970/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c0ecd41add4f7ba3b07afc3aeafcead465a8970/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=1c0ecd41add4f7ba3b07afc3aeafcead465a8970", "patch": "@@ -1286,7 +1286,6 @@ fn render_impl(\n     // in documentation pages for trait with automatic implementations like \"Send\" and \"Sync\".\n     aliases: &[String],\n ) {\n-    let tcx = cx.tcx();\n     let cache = cx.cache();\n     let traits = &cache.traits;\n     let trait_ = i.trait_did_full(cache).map(|did| &traits[&did]);\n@@ -1558,94 +1557,34 @@ fn render_impl(\n             );\n         }\n     }\n-    let toggled = !impl_items.is_empty() || !default_impl_items.is_empty();\n-    let open_details = |close_tags: &mut String, is_collapsed: bool| {\n+    if render_mode == RenderMode::Normal {\n+        let is_implementing_trait = i.inner_impl().trait_.is_some();\n+        let toggled = !impl_items.is_empty() || !default_impl_items.is_empty();\n         if toggled {\n             close_tags.insert_str(0, \"</details>\");\n-            if is_collapsed {\n-                \"<details class=\\\"rustdoc-toggle implementors-toggle\\\"><summary>\"\n+            if is_implementing_trait {\n+                write!(w, \"<details class=\\\"rustdoc-toggle implementors-toggle\\\">\");\n             } else {\n-                \"<details class=\\\"rustdoc-toggle implementors-toggle\\\" open><summary>\"\n+                write!(w, \"<details class=\\\"rustdoc-toggle implementors-toggle\\\" open>\");\n             }\n-        } else {\n-            \"\"\n         }\n-    };\n-    if render_mode == RenderMode::Normal {\n-        let is_implementing_trait;\n-        let id = cx.derive_id(match i.inner_impl().trait_ {\n-            Some(ref t) => {\n-                is_implementing_trait = true;\n-                if is_on_foreign_type {\n-                    get_id_for_impl_on_foreign_type(&i.inner_impl().for_, t, cx)\n-                } else {\n-                    format!(\"impl-{}\", small_url_encode(format!(\"{:#}\", t.print(cx))))\n-                }\n-            }\n-            None => {\n-                is_implementing_trait = false;\n-                \"impl\".to_string()\n-            }\n-        });\n-        let aliases = if aliases.is_empty() {\n-            String::new()\n-        } else {\n-            format!(\" data-aliases=\\\"{}\\\"\", aliases.join(\",\"))\n-        };\n-        if let Some(use_absolute) = use_absolute {\n-            write!(\n-                w,\n-                \"{}<div id=\\\"{}\\\" class=\\\"impl has-srclink\\\"{}>\\\n-                     <code class=\\\"in-band\\\">\",\n-                open_details(&mut close_tags, is_implementing_trait),\n-                id,\n-                aliases\n-            );\n-            write!(w, \"{}\", i.inner_impl().print(use_absolute, cx));\n-            if show_def_docs {\n-                for it in &i.inner_impl().items {\n-                    if let clean::TypedefItem(ref tydef, _) = *it.kind {\n-                        w.write_str(\"<span class=\\\"where fmt-newline\\\">  \");\n-                        assoc_type(\n-                            w,\n-                            it,\n-                            &[],\n-                            Some(&tydef.type_),\n-                            AssocItemLink::Anchor(None),\n-                            \"\",\n-                            cx,\n-                        );\n-                        w.write_str(\";</span>\");\n-                    }\n-                }\n-            }\n-            w.write_str(\"</code>\");\n-        } else {\n-            write!(\n-                w,\n-                \"{}<div id=\\\"{}\\\" class=\\\"impl has-srclink\\\"{}>\\\n-                     <code class=\\\"in-band\\\">{}</code>\",\n-                open_details(&mut close_tags, is_implementing_trait),\n-                id,\n-                aliases,\n-                i.inner_impl().print(false, cx)\n-            );\n+        if toggled {\n+            write!(w, \"<summary>\")\n         }\n-        write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n-        render_stability_since_raw(\n+        render_impl_summary(\n             w,\n-            i.impl_item.stable_since(tcx).as_deref(),\n-            i.impl_item.const_stable_since(tcx).as_deref(),\n+            cx,\n+            i,\n             outer_version,\n             outer_const_version,\n+            show_def_docs,\n+            use_absolute,\n+            is_on_foreign_type,\n+            aliases,\n         );\n-        write_srclink(cx, &i.impl_item, w);\n-        if !toggled {\n-            w.write_str(\"</div>\");\n-        } else {\n-            w.write_str(\"</div></summary>\");\n+        if toggled {\n+            write!(w, \"</summary>\")\n         }\n-\n         if trait_.is_some() {\n             if let Some(portability) = portability(&i.impl_item, Some(parent)) {\n                 write!(w, \"<div class=\\\"item-info\\\">{}</div>\", portability);\n@@ -1678,6 +1617,75 @@ fn render_impl(\n     w.write_str(&close_tags);\n }\n \n+fn render_impl_summary(\n+    w: &mut Buffer,\n+    cx: &Context<'_>,\n+    i: &Impl,\n+    outer_version: Option<&str>,\n+    outer_const_version: Option<&str>,\n+    show_def_docs: bool,\n+    use_absolute: Option<bool>,\n+    is_on_foreign_type: bool,\n+    // This argument is used to reference same type with different paths to avoid duplication\n+    // in documentation pages for trait with automatic implementations like \"Send\" and \"Sync\".\n+    aliases: &[String],\n+) {\n+    let tcx = cx.tcx();\n+    let id = cx.derive_id(match i.inner_impl().trait_ {\n+        Some(ref t) => {\n+            if is_on_foreign_type {\n+                get_id_for_impl_on_foreign_type(&i.inner_impl().for_, t, cx)\n+            } else {\n+                format!(\"impl-{}\", small_url_encode(format!(\"{:#}\", t.print(cx))))\n+            }\n+        }\n+        None => \"impl\".to_string(),\n+    });\n+    let aliases = if aliases.is_empty() {\n+        String::new()\n+    } else {\n+        format!(\" data-aliases=\\\"{}\\\"\", aliases.join(\",\"))\n+    };\n+    if let Some(use_absolute) = use_absolute {\n+        write!(\n+            w,\n+            \"<div id=\\\"{}\\\" class=\\\"impl has-srclink\\\"{}>\\\n+                     <code class=\\\"in-band\\\">\",\n+            id, aliases\n+        );\n+        write!(w, \"{}\", i.inner_impl().print(use_absolute, cx));\n+        if show_def_docs {\n+            for it in &i.inner_impl().items {\n+                if let clean::TypedefItem(ref tydef, _) = *it.kind {\n+                    w.write_str(\"<span class=\\\"where fmt-newline\\\">  \");\n+                    assoc_type(w, it, &[], Some(&tydef.type_), AssocItemLink::Anchor(None), \"\", cx);\n+                    w.write_str(\";</span>\");\n+                }\n+            }\n+        }\n+        w.write_str(\"</code>\");\n+    } else {\n+        write!(\n+            w,\n+            \"<div id=\\\"{}\\\" class=\\\"impl has-srclink\\\"{}>\\\n+                     <code class=\\\"in-band\\\">{}</code>\",\n+            id,\n+            aliases,\n+            i.inner_impl().print(false, cx)\n+        );\n+    }\n+    write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n+    render_stability_since_raw(\n+        w,\n+        i.impl_item.stable_since(tcx).as_deref(),\n+        i.impl_item.const_stable_since(tcx).as_deref(),\n+        outer_version,\n+        outer_const_version,\n+    );\n+    write_srclink(cx, &i.impl_item, w);\n+    w.write_str(\"</div>\");\n+}\n+\n fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer) {\n     let parentlen = cx.current.len() - if it.is_mod() { 1 } else { 0 };\n "}]}