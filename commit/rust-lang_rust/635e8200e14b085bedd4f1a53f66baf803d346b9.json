{"sha": "635e8200e14b085bedd4f1a53f66baf803d346b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzNWU4MjAwZTE0YjA4NWJlZGQ0ZjFhNTNmNjZiYWY4MDNkMzQ2Yjk=", "commit": {"author": {"name": "Haitao Li", "email": "lihaitao@gmail.com", "date": "2012-01-20T18:45:25Z"}, "committer": {"name": "Haitao Li", "email": "lihaitao@gmail.com", "date": "2012-01-21T10:03:09Z"}, "message": "rustc: Always resolve reexported names from original def\n\nIssue #1501", "tree": {"sha": "1499b007185758f795c49003e0aea091f7ac4bda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1499b007185758f795c49003e0aea091f7ac4bda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/635e8200e14b085bedd4f1a53f66baf803d346b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/635e8200e14b085bedd4f1a53f66baf803d346b9", "html_url": "https://github.com/rust-lang/rust/commit/635e8200e14b085bedd4f1a53f66baf803d346b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/635e8200e14b085bedd4f1a53f66baf803d346b9/comments", "author": {"login": "lht", "id": 19508, "node_id": "MDQ6VXNlcjE5NTA4", "avatar_url": "https://avatars.githubusercontent.com/u/19508?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lht", "html_url": "https://github.com/lht", "followers_url": "https://api.github.com/users/lht/followers", "following_url": "https://api.github.com/users/lht/following{/other_user}", "gists_url": "https://api.github.com/users/lht/gists{/gist_id}", "starred_url": "https://api.github.com/users/lht/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lht/subscriptions", "organizations_url": "https://api.github.com/users/lht/orgs", "repos_url": "https://api.github.com/users/lht/repos", "events_url": "https://api.github.com/users/lht/events{/privacy}", "received_events_url": "https://api.github.com/users/lht/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lht", "id": 19508, "node_id": "MDQ6VXNlcjE5NTA4", "avatar_url": "https://avatars.githubusercontent.com/u/19508?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lht", "html_url": "https://github.com/lht", "followers_url": "https://api.github.com/users/lht/followers", "following_url": "https://api.github.com/users/lht/following{/other_user}", "gists_url": "https://api.github.com/users/lht/gists{/gist_id}", "starred_url": "https://api.github.com/users/lht/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lht/subscriptions", "organizations_url": "https://api.github.com/users/lht/orgs", "repos_url": "https://api.github.com/users/lht/repos", "events_url": "https://api.github.com/users/lht/events{/privacy}", "received_events_url": "https://api.github.com/users/lht/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a303fd98c71a29f3abe769cfafa2b84caa6ff4fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a303fd98c71a29f3abe769cfafa2b84caa6ff4fb", "html_url": "https://github.com/rust-lang/rust/commit/a303fd98c71a29f3abe769cfafa2b84caa6ff4fb"}], "stats": {"total": 97, "additions": 64, "deletions": 33}, "files": [{"sha": "7968b74457bc035a4cc0cf9f4802064513523e69", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/635e8200e14b085bedd4f1a53f66baf803d346b9/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/635e8200e14b085bedd4f1a53f66baf803d346b9/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=635e8200e14b085bedd4f1a53f66baf803d346b9", "patch": "@@ -1,6 +1,7 @@\n // Searching for information from the cstore\n \n import syntax::ast;\n+import syntax::ast_util;\n import middle::ty;\n import option::{some, none};\n import driver::session;\n@@ -12,7 +13,6 @@ export get_tag_variants;\n export get_impls_for_mod;\n export get_iface_methods;\n export get_type;\n-export get_item_name;\n export get_impl_iface;\n \n fn get_symbol(cstore: cstore::cstore, def: ast::def_id) -> str {\n@@ -81,11 +81,6 @@ fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     decoder::get_type(cdata, def.node, tcx)\n }\n \n-fn get_item_name(cstore: cstore::cstore, cnum: int, id: int) -> ast::ident {\n-    let cdata = cstore::get_crate_data(cstore, cnum).data;\n-    ret decoder::lookup_item_name(cdata, id);\n-}\n-\n fn get_impl_iface(tcx: ty::ctxt, def: ast::def_id)\n     -> option::t<ty::t> {\n     let cstore = tcx.sess.cstore;"}, {"sha": "3c75df586befa959594c566165665b46c0ca3919", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/635e8200e14b085bedd4f1a53f66baf803d346b9/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/635e8200e14b085bedd4f1a53f66baf803d346b9/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=635e8200e14b085bedd4f1a53f66baf803d346b9", "patch": "@@ -4,6 +4,7 @@\n import core::{vec, str};\n import std::map;\n import syntax::ast;\n+import util::common::*;\n \n export cstore;\n export cnum_map;\n@@ -22,6 +23,7 @@ export get_used_link_args;\n export add_use_stmt_cnum;\n export get_use_stmt_cnum;\n export get_dep_hashes;\n+export get_path;\n \n \n // A map from external crate numbers (as decoded from some crate file) to\n@@ -30,6 +32,11 @@ export get_dep_hashes;\n // own crate numbers.\n type cnum_map = map::hashmap<ast::crate_num, ast::crate_num>;\n \n+// Multiple items may have the same def_id in crate metadata. They may be\n+// renamed imports or reexports. This map keeps the \"real\" module path\n+// and def_id.\n+type mod_path_map = map::hashmap<ast::def_id, str>;\n+\n type crate_metadata = @{name: str,\n                         data: @[u8],\n                         cnum_map: cnum_map,\n@@ -45,6 +52,7 @@ enum cstore { private(cstore_private), }\n type cstore_private =\n     @{metas: map::hashmap<ast::crate_num, crate_metadata>,\n       use_crate_map: use_crate_map,\n+      mod_path_map: mod_path_map,\n       mutable used_crate_files: [str],\n       mutable used_libraries: [str],\n       mutable used_link_args: [str]};\n@@ -58,8 +66,10 @@ fn p(cstore: cstore) -> cstore_private { alt cstore { private(p) { p } } }\n fn mk_cstore() -> cstore {\n     let meta_cache = map::new_int_hash::<crate_metadata>();\n     let crate_map = map::new_int_hash::<ast::crate_num>();\n+    let mod_path_map = new_def_hash();\n     ret private(@{metas: meta_cache,\n                   use_crate_map: crate_map,\n+                  mod_path_map: mod_path_map,\n                   mutable used_crate_files: [],\n                   mutable used_libraries: [],\n                   mutable used_link_args: []});\n@@ -72,6 +82,11 @@ fn get_crate_data(cstore: cstore, cnum: ast::crate_num) -> crate_metadata {\n fn set_crate_data(cstore: cstore, cnum: ast::crate_num,\n                   data: crate_metadata) {\n     p(cstore).metas.insert(cnum, data);\n+    vec::iter(decoder::get_crate_module_paths(data.data)) {|dp|\n+        let (did, path) = dp;\n+        let d = {crate: cnum, node: did.node};\n+        p(cstore).mod_path_map.insert(d, path);\n+    }\n }\n \n fn have_crate_data(cstore: cstore, cnum: ast::crate_num) -> bool {\n@@ -144,6 +159,13 @@ fn get_dep_hashes(cstore: cstore) -> [str] {\n     fn mapper(ch: crate_hash) -> str { ret ch.hash; }\n     ret vec::map(sorted, mapper);\n }\n+\n+fn get_path(cstore: cstore, d: ast::def_id) -> [str] {\n+    alt p(cstore).mod_path_map.find(d) {\n+      option::some(ds) { str::split_str(ds, \"::\") }\n+      option::none { [] }\n+    }\n+}\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "9855fa75d42ca85d55ea593526d5c5643fefa355", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/635e8200e14b085bedd4f1a53f66baf803d346b9/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/635e8200e14b085bedd4f1a53f66baf803d346b9/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=635e8200e14b085bedd4f1a53f66baf803d346b9", "patch": "@@ -1,6 +1,6 @@\n // Decoding metadata from a single crate's metadata\n \n-import std::{ebml, io};\n+import std::{ebml, map, io};\n import io::writer_util;\n import syntax::{ast, ast_util};\n import front::attr;\n@@ -26,6 +26,8 @@ export get_crate_deps;\n export get_crate_hash;\n export get_impls_for_mod;\n export get_iface_methods;\n+export get_crate_module_paths;\n+\n // A function that takes a def_id relative to the crate being searched and\n // returns a def_id relative to the compilation environment, i.e. if we hit a\n // def_id for an item defined in another crate, somebody needs to figure out\n@@ -451,8 +453,16 @@ fn get_crate_hash(data: @[u8]) -> str {\n \n fn list_crate_items(bytes: @[u8], md: ebml::doc, out: io::writer) {\n     out.write_str(\"=Items=\\n\");\n-    let paths = ebml::get_doc(md, tag_paths);\n     let items = ebml::get_doc(md, tag_items);\n+    iter_crate_items(bytes) {|path, did|\n+        out.write_str(#fmt[\"%s (%s)\\n\", path, describe_def(items, did)]);\n+    }\n+    out.write_str(\"\\n\");\n+}\n+\n+fn iter_crate_items(bytes: @[u8], proc: block(str, ast::def_id)) {\n+    let md = ebml::new_doc(bytes);\n+    let paths = ebml::get_doc(md, tag_paths);\n     let index = ebml::get_doc(paths, tag_index);\n     let bs = ebml::get_doc(index, tag_index_buckets);\n     ebml::tagged_docs(bs, tag_index_buckets_bucket) {|bucket|\n@@ -462,11 +472,35 @@ fn list_crate_items(bytes: @[u8], md: ebml::doc, out: io::writer) {\n             let def = ebml::doc_at(bytes, data.pos);\n             let did_doc = ebml::get_doc(def, tag_def_id);\n             let did = parse_def_id(ebml::doc_data(did_doc));\n-            out.write_str(#fmt[\"%s (%s)\\n\", data.path,\n-                               describe_def(items, did)]);\n+            proc(data.path, did);\n         };\n     };\n-    out.write_str(\"\\n\");\n+}\n+\n+fn get_crate_module_paths(bytes: @[u8]) -> [(ast::def_id, str)] {\n+    fn mod_of_path(p: str) -> str {\n+        str::connect(vec::init(str::split_str(p, \"::\")), \"::\")\n+    }\n+\n+    // find all module (path, def_ids), which are not\n+    // fowarded path due to renamed import or reexport\n+    let res = [];\n+    let mods = map::new_str_hash();\n+    iter_crate_items(bytes) {|path, did|\n+        let m = mod_of_path(path);\n+        if str::is_not_empty(m) {\n+            // if m has a sub-item, it must be a module\n+            mods.insert(m, true);\n+        }\n+        // Collect everything by now. There might be multiple\n+        // paths pointing to the same did. Those will be\n+        // unified later by using the mods map\n+        res += [(did, path)];\n+    }\n+    ret vec::filter(res) {|x|\n+        let (_, xp) = x;\n+        mods.contains_key(xp)\n+    }\n }\n \n fn list_crate_metadata(bytes: @[u8], out: io::writer) {"}, {"sha": "6f0ae757049c959429cbde65f024e2d08c95f4a7", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/635e8200e14b085bedd4f1a53f66baf803d346b9/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/635e8200e14b085bedd4f1a53f66baf803d346b9/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=635e8200e14b085bedd4f1a53f66baf803d346b9", "patch": "@@ -1187,7 +1187,7 @@ fn lookup_in_mod(e: env, m: def, sp: span, name: ident, ns: namespace,\n         if !is_none(cached) { ret cached; }\n         let path = [name];\n         if defid.node != ast::crate_node_id {\n-            path = e.ext_map.get(defid) + path;\n+            path = cstore::get_path(e.cstore, defid) + path;\n         }\n         let fnd = lookup_external(e, defid.crate, path, ns);\n         if !is_none(fnd) {\n@@ -1484,27 +1484,7 @@ fn ns_ok(wanted:namespace, actual:namespace) -> bool {\n fn lookup_external(e: env, cnum: int, ids: [ident], ns: namespace) ->\n    option::t<def> {\n     for d: def in csearch::lookup_defs(e.sess.cstore, cnum, ids) {\n-        let did = def_id_of_def(d);\n-        alt d {\n-          def_mod(_) | def_native_mod(_) {\n-            // The [native] module name might have renamed when importing,\n-            // find the original name for further lookup of names inside the\n-            // [native] module\n-            if did.crate != ast::local_crate {\n-                let cname = cstore::get_crate_data(e.cstore, did.crate).name;\n-                let name =\n-                    csearch::get_item_name(e.cstore, did.crate, did.node);\n-                #debug(\"lookup_external: %s %d, %d, %s, %s\", cname,\n-                       did.crate, did.node, str::connect(ids, \"::\"), name);\n-                e.ext_map.insert(did, vec::init(ids) + [name]);\n-            } else {\n-                e.ext_map.insert(did, ids);\n-            }\n-          }\n-          _ {\n-            e.ext_map.insert(did, ids);\n-          }\n-        }\n+        e.ext_map.insert(def_id_of_def(d), ids);\n         if ns_ok(ns, ns_for_def(d)) { ret some(d); }\n     }\n     ret none::<def>;"}]}