{"sha": "a128051f87be0baa953adbedfe780c1ef35379b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExMjgwNTFmODdiZTBiYWE5NTNhZGJlZGZlNzgwYzFlZjM1Mzc5YjY=", "commit": {"author": {"name": "gaurikholkar", "email": "f2013002@goa.bits-pilani.ac.in", "date": "2017-09-11T19:04:52Z"}, "committer": {"name": "gaurikholkar", "email": "f2013002@goa.bits-pilani.ac.in", "date": "2017-09-12T04:40:11Z"}, "message": "fixes", "tree": {"sha": "c0667406d84b6d3d528b480c4a54e25ac9dcb593", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0667406d84b6d3d528b480c4a54e25ac9dcb593"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a128051f87be0baa953adbedfe780c1ef35379b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a128051f87be0baa953adbedfe780c1ef35379b6", "html_url": "https://github.com/rust-lang/rust/commit/a128051f87be0baa953adbedfe780c1ef35379b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a128051f87be0baa953adbedfe780c1ef35379b6/comments", "author": {"login": "gaurikholkar", "id": 117768111, "node_id": "U_kgDOBwT_rw", "avatar_url": "https://avatars.githubusercontent.com/u/117768111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaurikholkar", "html_url": "https://github.com/gaurikholkar", "followers_url": "https://api.github.com/users/gaurikholkar/followers", "following_url": "https://api.github.com/users/gaurikholkar/following{/other_user}", "gists_url": "https://api.github.com/users/gaurikholkar/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaurikholkar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaurikholkar/subscriptions", "organizations_url": "https://api.github.com/users/gaurikholkar/orgs", "repos_url": "https://api.github.com/users/gaurikholkar/repos", "events_url": "https://api.github.com/users/gaurikholkar/events{/privacy}", "received_events_url": "https://api.github.com/users/gaurikholkar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gaurikholkar", "id": 117768111, "node_id": "U_kgDOBwT_rw", "avatar_url": "https://avatars.githubusercontent.com/u/117768111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaurikholkar", "html_url": "https://github.com/gaurikholkar", "followers_url": "https://api.github.com/users/gaurikholkar/followers", "following_url": "https://api.github.com/users/gaurikholkar/following{/other_user}", "gists_url": "https://api.github.com/users/gaurikholkar/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaurikholkar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaurikholkar/subscriptions", "organizations_url": "https://api.github.com/users/gaurikholkar/orgs", "repos_url": "https://api.github.com/users/gaurikholkar/repos", "events_url": "https://api.github.com/users/gaurikholkar/events{/privacy}", "received_events_url": "https://api.github.com/users/gaurikholkar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54af57018b57810c4467b6ed092a0294c3467ef5", "url": "https://api.github.com/repos/rust-lang/rust/commits/54af57018b57810c4467b6ed092a0294c3467ef5", "html_url": "https://github.com/rust-lang/rust/commit/54af57018b57810c4467b6ed092a0294c3467ef5"}], "stats": {"total": 338, "additions": 0, "deletions": 338}, "files": [{"sha": "420ac040b309d0a81c16ae95031abfee19e34a33", "filename": "src/librustc/infer/error_reporting/anon_anon_conflict.rs", "status": "removed", "additions": 0, "deletions": 338, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/54af57018b57810c4467b6ed092a0294c3467ef5/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54af57018b57810c4467b6ed092a0294c3467ef5/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs?ref=54af57018b57810c4467b6ed092a0294c3467ef5", "patch": "@@ -1,338 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Error Reporting for Anonymous Region Lifetime Errors\n-//! where both the regions are anonymous.\n-use hir;\n-use infer::InferCtxt;\n-use ty::{self, Region};\n-use infer::region_inference::RegionResolutionError::*;\n-use infer::region_inference::RegionResolutionError;\n-use hir::map as hir_map;\n-use middle::resolve_lifetime as rl;\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n-\n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    // This method prints the error message for lifetime errors when both the concerned regions\n-    // are anonymous.\n-    // Consider a case where we have\n-    // fn foo(x: &mut Vec<&u8>, y: &u8)\n-    //    { x.push(y); }.\n-    // The example gives\n-    // fn foo(x: &mut Vec<&u8>, y: &u8) {\n-    //                    ---      --- these references are declared with different lifetimes...\n-    //            x.push(y);\n-    //            ^ ...but data from `y` flows into `x` here\n-    // It has been extended for the case of structs too.\n-    // Consider the example\n-    // struct Ref<'a> { x: &'a u32 }\n-    // fn foo(mut x: Vec<Ref>, y: Ref) {\n-    //                   ---      --- these structs are declared with different lifetimes...\n-    //               x.push(y);\n-    //               ^ ...but data from `y` flows into `x` here\n-    // }\n-    // It will later be extended to trait objects.\n-    pub fn try_report_anon_anon_conflict(&self, error: &RegionResolutionError<'tcx>) -> bool {\n-        let (span, sub, sup) = match *error {\n-            ConcreteFailure(ref origin, sub, sup) => (origin.span(), sub, sup),\n-            _ => return false, // inapplicable\n-        };\n-\n-        // Determine whether the sub and sup consist of both anonymous (elided) regions.\n-        let (ty1, ty2, scope_def_id_1, scope_def_id_2, bregion1, bregion2) = if\n-            self.is_suitable_anonymous_region(sup, true).is_some() &&\n-            self.is_suitable_anonymous_region(sub, true).is_some() {\n-            if let (Some(anon_reg1), Some(anon_reg2)) =\n-                (self.is_suitable_anonymous_region(sup, true),\n-                 self.is_suitable_anonymous_region(sub, true)) {\n-                let ((def_id1, br1), (def_id2, br2)) = (anon_reg1, anon_reg2);\n-                let found_arg1 = self.find_anon_type(sup, &br1);\n-                let found_arg2 = self.find_anon_type(sub, &br2);\n-                match (found_arg1, found_arg2) {\n-                    (Some(anonarg_1), Some(anonarg_2)) => {\n-                        (anonarg_1, anonarg_2, def_id1, def_id2, br1, br2)\n-                    }\n-                    _ => {\n-                        return false;\n-                    }\n-                }\n-\n-            } else {\n-                return false;\n-            }\n-        } else {\n-            return false; //inapplicable\n-        };\n-\n-        let (label1, label2) = if let (Some(sup_arg), Some(sub_arg)) =\n-            (self.find_arg_with_anonymous_region(sup, sup),\n-             self.find_arg_with_anonymous_region(sub, sub)) {\n-\n-            let ((anon_arg1, _, _, is_first1), (anon_arg2, _, _, is_first2)) = (sup_arg, sub_arg);\n-            if self.is_self_anon(is_first1, scope_def_id_1) ||\n-               self.is_self_anon(is_first2, scope_def_id_2) {\n-                return false;\n-            }\n-\n-            if self.is_return_type_anon(scope_def_id_1, bregion1) ||\n-               self.is_return_type_anon(scope_def_id_2, bregion2) {\n-                return false;\n-            }\n-\n-\n-\n-\n-            if anon_arg1 == anon_arg2 {\n-                (format!(\" with one lifetime\"), format!(\" into the other\"))\n-            } else {\n-                let span_label_var1 = if let Some(simple_name) = anon_arg1.pat.simple_name() {\n-                    format!(\" from `{}`\", simple_name)\n-                } else {\n-                    format!(\"\")\n-                };\n-\n-                let span_label_var2 = if let Some(simple_name) = anon_arg2.pat.simple_name() {\n-                    format!(\" into `{}`\", simple_name)\n-                } else {\n-                    format!(\"\")\n-                };\n-\n-                (span_label_var1, span_label_var2)\n-            }\n-        } else {\n-            return false;\n-        };\n-\n-        struct_span_err!(self.tcx.sess, span, E0623, \"lifetime mismatch\")\n-            .span_label(ty1.span,\n-                        format!(\"these two types are declared with different lifetimes...\"))\n-            .span_label(ty2.span, format!(\"\"))\n-            .span_label(span, format!(\"...but data{} flows{} here\", label1, label2))\n-            .emit();\n-        return true;\n-\n-    }\n-\n-    /// This function calls the `visit_ty` method for the parameters\n-    /// corresponding to the anonymous regions. The `nested_visitor.found_type`\n-    /// contains the anonymous type.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// region - the anonymous region corresponding to the anon_anon conflict\n-    /// br - the bound region corresponding to the above region which is of type `BrAnon(_)`\n-    ///\n-    /// # Example\n-    /// ```\n-    /// fn foo(x: &mut Vec<&u8>, y: &u8)\n-    ///    { x.push(y); }\n-    /// ```\n-    /// The function returns the nested type corresponding to the anonymous region\n-    /// for e.g. `&u8` and Vec<`&u8`.\n-    pub fn find_anon_type(&self, region: Region<'tcx>, br: &ty::BoundRegion) -> Option<(&hir::Ty)> {\n-        if let Some(anon_reg) = self.is_suitable_anonymous_region(region, true) {\n-            let (def_id, _) = anon_reg;\n-            if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                let ret_ty = self.tcx.type_of(def_id);\n-                if let ty::TyFnDef(_, _) = ret_ty.sty {\n-                    if let hir_map::NodeItem(it) = self.tcx.hir.get(node_id) {\n-                        if let hir::ItemFn(ref fndecl, _, _, _, _, _) = it.node {\n-                            return fndecl\n-                                       .inputs\n-                                       .iter()\n-                                       .filter_map(|arg| {\n-                                                       self.find_visitor_found_type(&**arg, br)\n-                                                   })\n-                                       .next();\n-                        }\n-                    } else if let hir_map::NodeTraitItem(it) = self.tcx.hir.get(node_id) {\n-                        if let hir::TraitItemKind::Method(ref fndecl, _) = it.node {\n-                            return fndecl\n-                                       .decl\n-                                       .inputs\n-                                       .iter()\n-                                       .filter_map(|arg| {\n-                                                       self.find_visitor_found_type(&**arg, br)\n-                                                   })\n-                                       .next();\n-                        }\n-                    } else if let hir_map::NodeImplItem(it) = self.tcx.hir.get(node_id) {\n-                        if let hir::ImplItemKind::Method(ref fndecl, _) = it.node {\n-                            return fndecl\n-                                       .decl\n-                                       .inputs\n-                                       .iter()\n-                                       .filter_map(|arg| {\n-                                                       self.find_visitor_found_type(&**arg, br)\n-                                                   })\n-                                       .next();\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        None\n-    }\n-\n-    // This method creates a FindNestedTypeVisitor which returns the type corresponding\n-    // to the anonymous region.\n-    fn find_visitor_found_type(&self,\n-                               arg: &'gcx hir::Ty,\n-                               br: &ty::BoundRegion)\n-                               -> Option<(&'gcx hir::Ty)> {\n-        let mut nested_visitor = FindNestedTypeVisitor {\n-            infcx: &self,\n-            hir_map: &self.tcx.hir,\n-            bound_region: *br,\n-            found_type: None,\n-            depth: 1,\n-        };\n-        nested_visitor.visit_ty(arg);\n-        nested_visitor.found_type\n-    }\n-}\n-\n-// The FindNestedTypeVisitor captures the corresponding `hir::Ty` of the\n-// anonymous region. The example above would lead to a conflict between\n-// the two anonymous lifetimes for &u8 in x and y respectively. This visitor\n-// would be invoked twice, once for each lifetime, and would\n-// walk the types like &mut Vec<&u8> and &u8 looking for the HIR\n-// where that lifetime appears. This allows us to highlight the\n-// specific part of the type in the error message.\n-struct FindNestedTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    hir_map: &'a hir::map::Map<'gcx>,\n-    // The bound_region corresponding to the Refree(freeregion)\n-    // associated with the anonymous region we are looking for.\n-    bound_region: ty::BoundRegion,\n-    // The type where the anonymous lifetime appears\n-    // for e.g. Vec<`&u8`> and <`&u8`>\n-    found_type: Option<&'gcx hir::Ty>,\n-    depth: u32,\n-}\n-\n-impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.hir_map)\n-    }\n-\n-    fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n-        // Find the index of the anonymous region that was part of the\n-        // error. We will then search the function parameters for a bound\n-        // region at the right depth with the same index.\n-        let br_index = match self.bound_region {\n-            ty::BrAnon(index) => index,\n-            _ => return,\n-        };\n-\n-        match arg.node {\n-\n-            hir::TyBareFn(ref fndecl) => {\n-                self.depth += 1;\n-                intravisit::walk_ty(self, arg);\n-                self.depth -= 1;\n-                return;\n-            }\n-\n-            hir::TyRptr(ref lifetime, _) => {\n-                match self.infcx.tcx.named_region_map.defs.get(&lifetime.id) {\n-                    // the lifetime of the TyRptr\n-                    Some(&rl::Region::LateBoundAnon(debuijn_index, anon_index)) => {\n-                        if debuijn_index.depth == 1 && anon_index == br_index {\n-                            self.found_type = Some(arg);\n-                            return; // we can stop visiting now\n-                        }\n-                    }\n-                    Some(&rl::Region::Static) |\n-                    Some(&rl::Region::EarlyBound(_, _)) |\n-                    Some(&rl::Region::LateBound(_, _)) |\n-                    Some(&rl::Region::Free(_, _)) |\n-                    None => {\n-                        debug!(\"no arg found\");\n-                    }\n-                }\n-            }\n-            // Checks if it is of type `hir::TyPath` which corresponds to a struct.\n-            hir::TyPath(_) => {\n-                let subvisitor = &mut TyPathVisitor {\n-                                          infcx: self.infcx,\n-                                          found_it: false,\n-                                          bound_region: self.bound_region,\n-                                          hir_map: self.hir_map,\n-                                      };\n-                intravisit::walk_ty(subvisitor, arg); // call walk_ty; as visit_ty is empty,\n-                // this will visit only outermost type\n-                if subvisitor.found_it {\n-                    self.found_type = Some(arg);\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-        // walk the embedded contents: e.g., if we are visiting `Vec<&Foo>`,\n-        // go on to visit `&Foo`\n-        debug!(\"depth is {:?}\", self.depth);\n-        intravisit::walk_ty(self, arg);\n-\n-    }\n-}\n-\n-// The visitor captures the corresponding `hir::Ty` of the anonymous region\n-// in the case of structs ie. `hir::TyPath`.\n-// This visitor would be invoked for each lifetime corresponding to a struct,\n-// and would walk the types like Vec<Ref> in the above example and Ref looking for the HIR\n-// where that lifetime appears. This allows us to highlight the\n-// specific part of the type in the error message.\n-struct TyPathVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    hir_map: &'a hir::map::Map<'gcx>,\n-    found_it: bool,\n-    bound_region: ty::BoundRegion,\n-}\n-\n-impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.hir_map)\n-    }\n-\n-    fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n-        let br_index = match self.bound_region {\n-            ty::BrAnon(index) => index,\n-            _ => return,\n-        };\n-\n-        match self.infcx.tcx.named_region_map.defs.get(&lifetime.id) {\n-            // the lifetime of the TyPath!\n-            Some(&rl::Region::LateBoundAnon(debuijn_index, anon_index)) => {\n-                if debuijn_index.depth == 1 && anon_index == br_index {\n-                    self.found_it = true;\n-                }\n-            }\n-            Some(&rl::Region::Static) |\n-            Some(&rl::Region::EarlyBound(_, _)) |\n-            Some(&rl::Region::LateBound(_, _)) |\n-            Some(&rl::Region::Free(_, _)) |\n-            None => {\n-                debug!(\"no arg found\");\n-            }\n-        }\n-    }\n-\n-    fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n-        // ignore nested types\n-        //\n-        // If you have a type like `Foo<'a, &Ty>` we\n-        // are only interested in the immediate lifetimes ('a).\n-        //\n-        // Making `visit_ty` empty will ignore the `&Ty` embedded\n-        // inside, it will get reached by the outer visitor.\n-        debug!(\"`Ty` corresponding to a struct is {:?}\", arg);\n-    }\n-}"}]}