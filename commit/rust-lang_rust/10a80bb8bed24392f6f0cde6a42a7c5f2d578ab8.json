{"sha": "10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwYTgwYmI4YmVkMjQzOTJmNmYwY2RlNmE0MmE3YzVmMmQ1NzhhYjg=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-08-18T19:10:30Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-08-19T19:31:27Z"}, "message": "Add an option to forgo backups", "tree": {"sha": "44b1579e67097f6812ae8dea261f4cca1cd9efb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44b1579e67097f6812ae8dea261f4cca1cd9efb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8", "html_url": "https://github.com/rust-lang/rust/commit/10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "229415bca226ea0ba23c77c92e0e1b6310213f5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/229415bca226ea0ba23c77c92e0e1b6310213f5b", "html_url": "https://github.com/rust-lang/rust/commit/229415bca226ea0ba23c77c92e0e1b6310213f5b"}], "stats": {"total": 144, "additions": 98, "deletions": 46}, "files": [{"sha": "61e01dcb9fde267598da8b47a0db3bd11260a4b5", "filename": "README.md", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8", "patch": "@@ -13,12 +13,18 @@ the rustfmt command. You can look at this repo for an example default.toml file.\n \n `cargo test` to run all tests.\n \n-`cargo run filename` to run on a file, if the file includes out of line modules,\n+`cargo run -- filename` to run on a file, if the file includes out of line modules,\n then we reformat those too. So to run on a whole module or crate, you just need\n-to run on the top file. You'll probably want to set the `WriteMode` in the call\n-to `run` in `main()`. Eventually you should be able to set the mode from the\n-command line or from a config file or something.\n+to run on the top file. \n \n+You'll probably want to specify the write mode. Currently, there are the replace,\n+overwrite and display mode. The replace mode is the default and overwrites the\n+original files after renaming them. In overwrite mode, rustfmt does not backup\n+the source files. To print the output to stdout, use the display mode. The write\n+mode can be set by passing the `--write-mode` flag on the command line.\n+\n+`cargo run -- filename --write-mode=display` prints the output of rustfmt to the\n+screen, for example.\n \n ## Use cases\n "}, {"sha": "6ec0f9556c8b0c04ab765e1b81f3b01adc0a9615", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8", "patch": "@@ -9,23 +9,47 @@\n // except according to those terms.\n \n #![cfg(not(test))]\n+#![feature(result_expect)]\n \n extern crate rustfmt;\n \n use rustfmt::{WriteMode, run};\n+use rustfmt::config::Config;\n \n use std::fs::File;\n use std::io::Read;\n+use std::str::FromStr;\n \n fn main() {\n-    let args: Vec<_> = std::env::args().collect();\n     let mut def_config_file = File::open(\"default.toml\").unwrap_or_else(|e| {\n         panic!(\"Unable to open configuration file [default.toml] {}\",e)\n     });\n     let mut def_config = String::new();\n     def_config_file.read_to_string(&mut def_config).unwrap();\n+    let config = Box::new(Config::from_toml(&def_config));\n+    let (args, write_mode) = determine_params(std::env::args());\n \n-    run(args, WriteMode::Overwrite, &def_config);\n+    run(args, write_mode, config);\n \n     std::process::exit(0);\n }\n+\n+fn determine_params<I>(args: I) -> (Vec<String>, WriteMode)\n+    where I: Iterator<Item = String>\n+{\n+    let prefix = \"--write-mode=\";\n+    let mut write_mode = WriteMode::Replace;\n+\n+    // The NewFile option currently isn't supported because it requires another\n+    // parameter, but it can be added later.\n+    let args = args.filter(|arg| {\n+        if arg.starts_with(prefix) {\n+            write_mode = FromStr::from_str(&arg[prefix.len()..]).expect(\"Unrecognized write mode\");\n+            false\n+        } else {\n+            true\n+        }\n+    }).collect();\n+\n+    (args, write_mode)\n+}"}, {"sha": "ff50522eec6eddc5856b456da2b06bb245d32f92", "filename": "src/filemap.rs", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8", "patch": "@@ -73,40 +73,46 @@ fn write_file(text: &StringBuffer,\n     }\n \n     match mode {\n-            WriteMode::Overwrite => {\n-                // Do a little dance to make writing safer - write to a temp file\n-                // rename the original to a .bk, then rename the temp file to the\n-                // original.\n-                let tmp_name = filename.to_owned() + \".tmp\";\n-                let bk_name = filename.to_owned() + \".bk\";\n-                {\n-                    // Write text to temp file\n-                    let tmp_file = try!(File::create(&tmp_name));\n-                    try!(write_system_newlines(tmp_file, text, config));\n-                }\n-\n-                try!(fs::rename(filename, bk_name));\n-                try!(fs::rename(tmp_name, filename));\n-            }\n-            WriteMode::NewFile(extn) => {\n-                let filename = filename.to_owned() + \".\" + extn;\n-                let file = try!(File::create(&filename));\n-                try!(write_system_newlines(file, text, config));\n-            }\n-            WriteMode::Display => {\n-                println!(\"{}:\\n\", filename);\n-                let stdout = stdout();\n-                let stdout_lock = stdout.lock();\n-                try!(write_system_newlines(stdout_lock, text, config));\n-            }\n-            WriteMode::Return(_) => {\n-                // io::Write is not implemented for String, working around with Vec<u8>\n-                let mut v = Vec::new();\n-                try!(write_system_newlines(&mut v, text, config));\n-                // won't panic, we are writing correct utf8\n-                return Ok(Some(String::from_utf8(v).unwrap()));\n+        WriteMode::Replace => {\n+            // Do a little dance to make writing safer - write to a temp file\n+            // rename the original to a .bk, then rename the temp file to the\n+            // original.\n+            let tmp_name = filename.to_owned() + \".tmp\";\n+            let bk_name = filename.to_owned() + \".bk\";\n+            {\n+                // Write text to temp file\n+                let tmp_file = try!(File::create(&tmp_name));\n+                try!(write_system_newlines(tmp_file, text, config));\n             }\n+\n+            try!(fs::rename(filename, bk_name));\n+            try!(fs::rename(tmp_name, filename));\n         }\n+        WriteMode::Overwrite => {\n+            // Write text directly over original file.\n+            let file = try!(File::create(filename));\n+            try!(write_system_newlines(file, text, config));\n+        }\n+        WriteMode::NewFile(extn) => {\n+            let filename = filename.to_owned() + \".\" + extn;\n+            let file = try!(File::create(&filename));\n+            try!(write_system_newlines(file, text, config));\n+        }\n+        WriteMode::Display => {\n+            println!(\"{}:\\n\", filename);\n+            let stdout = stdout();\n+            let stdout_lock = stdout.lock();\n+            try!(write_system_newlines(stdout_lock, text, config));\n+        }\n+        WriteMode::Return(_) => {\n+            // io::Write is not implemented for String, working around with\n+            // Vec<u8>\n+            let mut v = Vec::new();\n+            try!(write_system_newlines(&mut v, text, config));\n+            // won't panic, we are writing correct utf8\n+            return Ok(Some(String::from_utf8(v).unwrap()));\n+        }\n+    }\n \n     Ok(None)\n }"}, {"sha": "cc7111aae27f11928d6154ae46f8f82ffbd63e7d", "filename": "src/lib.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8", "patch": "@@ -42,6 +42,7 @@ use std::path::PathBuf;\n use std::collections::HashMap;\n use std::fmt;\n use std::mem::swap;\n+use std::str::FromStr;\n \n use issues::{BadIssueSeeker, Issue};\n use filemap::FileMap;\n@@ -71,15 +72,31 @@ const SKIP_ANNOTATION: &'static str = \"rustfmt_skip\";\n \n #[derive(Copy, Clone)]\n pub enum WriteMode {\n+    // Backups the original file and overwrites the orignal.\n+    Replace,\n+    // Overwrites original file without backup.\n     Overwrite,\n-    // str is the extension of the new file\n+    // str is the extension of the new file.\n     NewFile(&'static str),\n     // Write the output to stdout.\n     Display,\n     // Return the result as a mapping from filenames to StringBuffers.\n     Return(&'static Fn(HashMap<String, String>)),\n }\n \n+impl FromStr for WriteMode {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"replace\" => Ok(WriteMode::Replace),\n+            \"display\" => Ok(WriteMode::Display),\n+            \"overwrite\" => Ok(WriteMode::Overwrite),\n+            _ => Err(())\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n pub enum NewlineStyle {\n     Windows, // \\r\\n\n@@ -343,9 +360,7 @@ impl<'a> CompilerCalls<'a> for RustFmtCalls {\n // to the compiler.\n // write_mode determines what happens to the result of running rustfmt, see\n // WriteMode.\n-// default_config is a string of toml data to be used to configure rustfmt.\n-pub fn run(args: Vec<String>, write_mode: WriteMode, default_config: &str) {\n-    let config = Some(Box::new(config::Config::from_toml(default_config)));\n-    let mut call_ctxt = RustFmtCalls { write_mode: write_mode, config: config };\n+pub fn run(args: Vec<String>, write_mode: WriteMode, config: Box<Config>) {\n+    let mut call_ctxt = RustFmtCalls { write_mode: write_mode, config: Some(config) };\n     rustc_driver::run_compiler(&args, &mut call_ctxt);\n }"}, {"sha": "19a68fc4b7baa80378f352e98f8af7b0907c4c86", "filename": "tests/system.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=10a80bb8bed24392f6f0cde6a42a7c5f2d578ab8", "patch": "@@ -19,6 +19,7 @@ use std::fs;\n use std::io::{self, Read, BufRead, BufReader};\n use std::thread;\n use rustfmt::*;\n+use rustfmt::config::Config;\n \n fn get_path_string(dir_entry: io::Result<fs::DirEntry>) -> String {\n     let path = dir_entry.ok().expect(\"Couldn't get DirEntry.\").path();\n@@ -103,14 +104,14 @@ pub fn idempotent_check(filename: String) -> Result<(), HashMap<String, String>>\n     // panic to return a result in case of failure. This has the advantage of smoothing the road to\n     // multithreaded rustfmt\n     thread::catch_panic(move || {\n-        run(args, WriteMode::Return(HANDLE_RESULT), &config);\n+        run(args, WriteMode::Return(HANDLE_RESULT), config);\n     }).map_err(|any|\n         *any.downcast().ok().expect(\"Downcast failed.\")\n     )\n }\n \n // Reads test config file from comments and loads it\n-fn get_config(file_name: &str) -> String {\n+fn get_config(file_name: &str) -> Box<Config> {\n     let config_file_name = read_significant_comment(file_name, \"config\")\n         .map(|file_name| {\n             let mut full_path = \"tests/config/\".to_owned();\n@@ -123,7 +124,7 @@ fn get_config(file_name: &str) -> String {\n     let mut def_config = String::new();\n     def_config_file.read_to_string(&mut def_config).ok().expect(\"Couldn't read config.\");\n \n-    def_config\n+    Box::new(Config::from_toml(&def_config))\n }\n \n fn read_significant_comment(file_name: &str, option: &str) -> Option<String> {"}]}