{"sha": "a15dab9ce28f46fbcebbe117b18fc4a55d2b89b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNWRhYjljZTI4ZjQ2ZmJjZWJiZTExN2IxOGZjNGE1NWQyYjg5YjY=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2021-08-30T18:34:26Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2021-08-31T14:25:51Z"}, "message": "Use right span in prelude collision suggestions with macros.", "tree": {"sha": "7296d5d0b101e54cf60068c44b40e0eb46a18342", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7296d5d0b101e54cf60068c44b40e0eb46a18342"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a15dab9ce28f46fbcebbe117b18fc4a55d2b89b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a15dab9ce28f46fbcebbe117b18fc4a55d2b89b6", "html_url": "https://github.com/rust-lang/rust/commit/a15dab9ce28f46fbcebbe117b18fc4a55d2b89b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a15dab9ce28f46fbcebbe117b18fc4a55d2b89b6/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a06daa86361c1c96c6ac7b85b3b049b93c364e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a06daa86361c1c96c6ac7b85b3b049b93c364e2", "html_url": "https://github.com/rust-lang/rust/commit/2a06daa86361c1c96c6ac7b85b3b049b93c364e2"}], "stats": {"total": 29, "additions": 19, "deletions": 10}, "files": [{"sha": "59590c00df5f8324f12573dbbaf59987f81d218a", "filename": "compiler/rustc_typeck/src/check/method/prelude2021.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a15dab9ce28f46fbcebbe117b18fc4a55d2b89b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dab9ce28f46fbcebbe117b18fc4a55d2b89b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs?ref=a15dab9ce28f46fbcebbe117b18fc4a55d2b89b6", "patch": "@@ -156,15 +156,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         segment.ident.name\n                     ));\n \n-                    let (self_adjusted, precise) = self.adjust_expr(pick, self_expr);\n+                    let (self_adjusted, precise) = self.adjust_expr(pick, self_expr, sp);\n                     if precise {\n                         let args = args\n                             .iter()\n                             .skip(1)\n                             .map(|arg| {\n+                                let span = arg.span.find_ancestor_inside(sp).unwrap_or_default();\n                                 format!(\n                                     \", {}\",\n-                                    self.sess().source_map().span_to_snippet(arg.span).unwrap()\n+                                    self.sess().source_map().span_to_snippet(span).unwrap()\n                                 )\n                             })\n                             .collect::<String>();\n@@ -275,7 +276,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let mut self_ty_name = self\n                 .sess()\n                 .source_map()\n-                .span_to_snippet(self_ty_span)\n+                .span_to_snippet(self_ty_span.find_ancestor_inside(span).unwrap_or_default())\n                 .unwrap_or_else(|_| self_ty.to_string());\n \n             // Get the number of generics the self type has (if an Adt) unless we can determine that\n@@ -370,7 +371,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Creates a string version of the `expr` that includes explicit adjustments.\n     /// Returns the string and also a bool indicating whther this is a *precise*\n     /// suggestion.\n-    fn adjust_expr(&self, pick: &Pick<'tcx>, expr: &hir::Expr<'tcx>) -> (String, bool) {\n+    fn adjust_expr(\n+        &self,\n+        pick: &Pick<'tcx>,\n+        expr: &hir::Expr<'tcx>,\n+        outer: Span,\n+    ) -> (String, bool) {\n         let derefs = \"*\".repeat(pick.autoderefs);\n \n         let autoref = match pick.autoref_or_ptr_adjustment {\n@@ -379,12 +385,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Some(probe::AutorefOrPtrAdjustment::ToConstPtr) | None => \"\",\n         };\n \n-        let (expr_text, precise) =\n-            if let Ok(expr_text) = self.sess().source_map().span_to_snippet(expr.span) {\n-                (expr_text, true)\n-            } else {\n-                (\"(..)\".to_string(), false)\n-            };\n+        let (expr_text, precise) = if let Ok(expr_text) = self\n+            .sess()\n+            .source_map()\n+            .span_to_snippet(expr.span.find_ancestor_inside(outer).unwrap_or_default())\n+        {\n+            (expr_text, true)\n+        } else {\n+            (\"(..)\".to_string(), false)\n+        };\n \n         let adjusted_text = if let Some(probe::AutorefOrPtrAdjustment::ToConstPtr) =\n             pick.autoref_or_ptr_adjustment"}]}