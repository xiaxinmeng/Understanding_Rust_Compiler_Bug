{"sha": "d893285b657b39bc9703270179a50e3562dd38e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4OTMyODViNjU3YjM5YmM5NzAzMjcwMTc5YTUwZTM1NjJkZDM4ZTg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-10-10T20:38:07Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:43:56Z"}, "message": "rustc: use layout::Abi::ScalarPair for structs in more cases.", "tree": {"sha": "b6d6fdb4e5067c6542ec0c917ce3075e77480ffa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6d6fdb4e5067c6542ec0c917ce3075e77480ffa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d893285b657b39bc9703270179a50e3562dd38e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d893285b657b39bc9703270179a50e3562dd38e8", "html_url": "https://github.com/rust-lang/rust/commit/d893285b657b39bc9703270179a50e3562dd38e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d893285b657b39bc9703270179a50e3562dd38e8/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "801a1a0fc10706ac908e29d66a598ff121a923cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/801a1a0fc10706ac908e29d66a598ff121a923cd", "html_url": "https://github.com/rust-lang/rust/commit/801a1a0fc10706ac908e29d66a598ff121a923cd"}], "stats": {"total": 96, "additions": 54, "deletions": 42}, "files": [{"sha": "81d25a772183e8ab0a4dc4223afebd8a119ada29", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 54, "deletions": 42, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/d893285b657b39bc9703270179a50e3562dd38e8/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d893285b657b39bc9703270179a50e3562dd38e8/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=d893285b657b39bc9703270179a50e3562dd38e8", "patch": "@@ -1078,60 +1078,72 @@ impl<'a, 'tcx> CachedLayout {\n                 packed\n             };\n \n-            // Unpack newtype ABIs.\n-            if sized && optimize && size.bytes() > 0 {\n-                // All but one field must be ZSTs, and so they all start at 0.\n-                if offsets.iter().all(|o| o.bytes() == 0) {\n-                    let mut non_zst_fields = fields.iter().filter(|f| !f.is_zst());\n-\n-                    // We have exactly one non-ZST field.\n-                    match (non_zst_fields.next(), non_zst_fields.next()) {\n-                        (Some(field), None) => {\n-                            // Field size matches and it has a scalar or scalar pair ABI.\n-                            if size == field.size {\n+            // Unpack newtype ABIs and find scalar pairs.\n+            if sized && size.bytes() > 0 {\n+                // All other fields must be ZSTs, and we need them to all start at 0.\n+                let mut zst_offsets =\n+                    offsets.iter().enumerate().filter(|&(i, _)| fields[i].is_zst());\n+                if zst_offsets.all(|(_, o)| o.bytes() == 0) {\n+                    let mut non_zst_fields =\n+                        fields.iter().enumerate().filter(|&(_, f)| !f.is_zst());\n+\n+                    match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n+                        // We have exactly one non-ZST field.\n+                        (Some((i, field)), None, None) => {\n+                            // Field fills the struct and it has a scalar or scalar pair ABI.\n+                            if offsets[i].bytes() == 0 && size == field.size {\n                                 match field.abi {\n-                                    Abi::Scalar(_) |\n+                                    // For plain scalars we can't unpack newtypes\n+                                    // for `#[repr(C)]`, as that affects C ABIs.\n+                                    Abi::Scalar(_) if optimize => {\n+                                        abi = field.abi.clone();\n+                                    }\n+                                    // But scalar pairs are Rust-specific and get\n+                                    // treated as aggregates by C ABIs anyway.\n                                     Abi::ScalarPair(..) => {\n                                         abi = field.abi.clone();\n                                     }\n                                     _ => {}\n                                 }\n                             }\n                         }\n-                        _ => {}\n-                    }\n-                }\n-            }\n \n-            // Look for a scalar pair, as an ABI optimization.\n-            // FIXME(eddyb) ignore extra ZST fields and field ordering.\n-            if sized && !packed && fields.len() == 2 {\n-                match (&fields[0].abi, &fields[1].abi) {\n-                    (&Abi::Scalar(ref a), &Abi::Scalar(ref b)) => {\n-                        let pair = scalar_pair(a.clone(), b.clone());\n-                        let pair_offsets = match pair.fields {\n-                            FieldPlacement::Arbitrary {\n-                                ref offsets,\n-                                ref memory_index\n-                            } => {\n-                                assert_eq!(memory_index, &[0, 1]);\n-                                offsets\n+                        // Two non-ZST fields, and they're both scalars.\n+                        (Some((i, &TyLayout {\n+                            cached: &CachedLayout { abi: Abi::Scalar(ref a), .. }, ..\n+                        })), Some((j, &TyLayout {\n+                            cached: &CachedLayout { abi: Abi::Scalar(ref b), .. }, ..\n+                        })), None) => {\n+                            // Order by the memory placement, not source order.\n+                            let ((i, a), (j, b)) = if offsets[i] < offsets[j] {\n+                                ((i, a), (j, b))\n+                            } else {\n+                                ((j, b), (i, a))\n+                            };\n+                            let pair = scalar_pair(a.clone(), b.clone());\n+                            let pair_offsets = match pair.fields {\n+                                FieldPlacement::Arbitrary {\n+                                    ref offsets,\n+                                    ref memory_index\n+                                } => {\n+                                    assert_eq!(memory_index, &[0, 1]);\n+                                    offsets\n+                                }\n+                                _ => bug!()\n+                            };\n+                            if offsets[i] == pair_offsets[0] &&\n+                               offsets[j] == pair_offsets[1] &&\n+                               align == pair.align &&\n+                               primitive_align == pair.primitive_align &&\n+                               size == pair.size {\n+                                // We can use `ScalarPair` only when it matches our\n+                                // already computed layout (including `#[repr(C)]`).\n+                                abi = pair.abi;\n                             }\n-                            _ => bug!()\n-                        };\n-                        if offsets[0] == pair_offsets[0] &&\n-                           offsets[1] == pair_offsets[1] &&\n-                           memory_index[0] == 0 &&\n-                           memory_index[1] == 1 &&\n-                           align == pair.align &&\n-                           primitive_align == pair.primitive_align &&\n-                           size == pair.size {\n-                            // We can use `ScalarPair` only when it matches our\n-                            // already computed layout (including `#[repr(C)]`).\n-                            abi = pair.abi;\n                         }\n+\n+                        _ => {}\n                     }\n-                    _ => {}\n                 }\n             }\n "}]}