{"sha": "1ad0cf5841e2fb577c4c26a051067fdd06e24796", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhZDBjZjU4NDFlMmZiNTc3YzRjMjZhMDUxMDY3ZmRkMDZlMjQ3OTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-16T01:23:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-16T01:23:14Z"}, "message": "auto merge of #8503 : thestinger/rust/iterator, r=alexcrichton", "tree": {"sha": "485cd217a260eb2b6357f5f7ff539fb7659c3673", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/485cd217a260eb2b6357f5f7ff539fb7659c3673"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ad0cf5841e2fb577c4c26a051067fdd06e24796", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ad0cf5841e2fb577c4c26a051067fdd06e24796", "html_url": "https://github.com/rust-lang/rust/commit/1ad0cf5841e2fb577c4c26a051067fdd06e24796", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ad0cf5841e2fb577c4c26a051067fdd06e24796/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4656cfd045ef436377b3dfeebaa265c2c92a00f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4656cfd045ef436377b3dfeebaa265c2c92a00f", "html_url": "https://github.com/rust-lang/rust/commit/c4656cfd045ef436377b3dfeebaa265c2c92a00f"}, {"sha": "3cec67bbf2ced2b01ef158ebb5ccc828e852d595", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cec67bbf2ced2b01ef158ebb5ccc828e852d595", "html_url": "https://github.com/rust-lang/rust/commit/3cec67bbf2ced2b01ef158ebb5ccc828e852d595"}], "stats": {"total": 260, "additions": 23, "deletions": 237}, "files": [{"sha": "1f47c3df14f89b346dd53542334f3d303f51e01f", "filename": "doc/tutorial-container.md", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1ad0cf5841e2fb577c4c26a051067fdd06e24796/doc%2Ftutorial-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/1ad0cf5841e2fb577c4c26a051067fdd06e24796/doc%2Ftutorial-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-container.md?ref=1ad0cf5841e2fb577c4c26a051067fdd06e24796", "patch": "@@ -112,10 +112,10 @@ iterator object. For example, vector slices several iterators available:\n \n * `iter()` and `rev_iter()`, for immutable references to the elements\n * `mut_iter()` and `mut_rev_iter()`, for mutable references to the elements\n-* `consume_iter()` and `consume_rev_iter`, to move the elements out by-value\n+* `move_iter()` and `move_rev_iter`, to move the elements out by-value\n \n A typical mutable container will implement at least `iter()`, `mut_iter()` and\n-`consume_iter()` along with the reverse variants if it maintains an order.\n+`move_iter()` along with the reverse variants if it maintains an order.\n \n ### Freezing\n \n@@ -139,9 +139,9 @@ and `&mut`.\n \n ## Iterator adaptors\n \n-The `IteratorUtil` trait implements common algorithms as methods extending\n-every `Iterator` implementation. For example, the `fold` method will accumulate\n-the items yielded by an `Iterator` into a single value:\n+The `Iterator` trait provides many common algorithms as default methods. For\n+example, the `fold` method will accumulate the items yielded by an `Iterator`\n+into a single value:\n \n ~~~\n let xs = [1, 9, 2, 3, 14, 12];\n@@ -154,14 +154,10 @@ Some adaptors return an adaptor object implementing the `Iterator` trait itself:\n ~~~\n let xs = [1, 9, 2, 3, 14, 12];\n let ys = [5, 2, 1, 8];\n-let sum = xs.iter().chain_(ys.iter()).fold(0, |a, b| a + *b);\n+let sum = xs.iter().chain(ys.iter()).fold(0, |a, b| a + *b);\n assert_eq!(sum, 57);\n ~~~\n \n-Note that some adaptors like the `chain_` method above use a trailing\n-underscore to work around an issue with method resolve. The underscores will be\n-dropped when they become unnecessary.\n-\n ## For loops\n \n The `for` keyword can be used as sugar for iterating through any iterator:\n@@ -212,7 +208,7 @@ Iterators offer generic conversion to containers with the `collect` adaptor:\n \n ~~~\n let xs = [0, 1, 1, 2, 3, 5, 8];\n-let ys = xs.rev_iter().skip(1).transform(|&x| x * 2).collect::<~[int]>();\n+let ys = xs.rev_iter().skip(1).map(|&x| x * 2).collect::<~[int]>();\n assert_eq!(ys, ~[10, 6, 4, 2, 2, 0]);\n ~~~\n \n@@ -307,13 +303,13 @@ for &x in it.invert() {\n The `rev_iter` and `mut_rev_iter` methods on vectors just return an inverted\n version of the standard immutable and mutable vector iterators.\n \n-The `chain_`, `transform`, `filter`, `filter_map` and `peek` adaptors are\n+The `chain`, `map`, `filter`, `filter_map` and `inspect` adaptors are\n `DoubleEndedIterator` implementations if the underlying iterators are.\n \n ~~~\n let xs = [1, 2, 3, 4];\n let ys = [5, 6, 7, 8];\n-let mut it = xs.iter().chain_(ys.iter()).transform(|&x| x * 2);\n+let mut it = xs.iter().chain(ys.iter()).map(|&x| x * 2);\n \n printfln!(\"%?\", it.next()); // prints `Some(2)`\n \n@@ -329,13 +325,13 @@ The `RandomAccessIterator` trait represents an iterator offering random access\n to the whole range. The `indexable` method retrieves the number of elements\n accessible with the `idx` method.\n \n-The `chain_` adaptor is an implementation of `RandomAccessIterator` if the\n+The `chain` adaptor is an implementation of `RandomAccessIterator` if the\n underlying iterators are.\n \n ~~~\n let xs = [1, 2, 3, 4, 5];\n let ys = ~[7, 9, 11];\n-let mut it = xs.iter().chain_(ys.iter());\n+let mut it = xs.iter().chain(ys.iter());\n printfln!(\"%?\", it.idx(0)); // prints `Some(&1)`\n printfln!(\"%?\", it.idx(5)); // prints `Some(&7)`\n printfln!(\"%?\", it.idx(7)); // prints `Some(&11)`"}, {"sha": "bea7868fd32b7c96d0dbd4196ced81b76d5336fa", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ad0cf5841e2fb577c4c26a051067fdd06e24796/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad0cf5841e2fb577c4c26a051067fdd06e24796/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=1ad0cf5841e2fb577c4c26a051067fdd06e24796", "patch": "@@ -782,11 +782,8 @@ mod test_qsort3 {\n \n #[cfg(test)]\n mod test_qsort {\n-\n     use sort::*;\n \n-    use std::vec;\n-\n     fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = v1.len();\n         fn leual(a: &int, b: &int) -> bool { *a <= *b }\n@@ -835,9 +832,7 @@ mod test_qsort {\n \n         let immut_names = names;\n \n-        let pairs = vec::zip_slice(expected, immut_names);\n-        for p in pairs.iter() {\n-            let (a, b) = *p;\n+        for (&a, &b) in expected.iter().zip(immut_names.iter()) {\n             debug!(\"%d %d\", a, b);\n             assert_eq!(a, b);\n         }"}, {"sha": "9778248f005423468d2f4e1d46ae60d65e3ce687", "filename": "src/libextra/test.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1ad0cf5841e2fb577c4c26a051067fdd06e24796/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad0cf5841e2fb577c4c26a051067fdd06e24796/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=1ad0cf5841e2fb577c4c26a051067fdd06e24796", "patch": "@@ -1121,7 +1121,6 @@ mod tests {\n \n     use std::either;\n     use std::comm::{stream, SharedChan};\n-    use std::vec;\n     use tempfile;\n     use std::os;\n \n@@ -1309,14 +1308,8 @@ mod tests {\n               ~\"test::parse_ignored_flag\",\n               ~\"test::sort_tests\"];\n \n-        let pairs = vec::zip(expected, filtered);\n-\n-        for p in pairs.iter() {\n-            match *p {\n-                (ref a, ref b) => {\n-                    assert!(*a == b.desc.name.to_str());\n-                }\n-            }\n+        for (a, b) in expected.iter().zip(filtered.iter()) {\n+            assert!(*a == b.desc.name.to_str());\n         }\n     }\n "}, {"sha": "34bbe9292a5cb9ec318e3c50ab9a98a9bc844767", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ad0cf5841e2fb577c4c26a051067fdd06e24796/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad0cf5841e2fb577c4c26a051067fdd06e24796/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=1ad0cf5841e2fb577c4c26a051067fdd06e24796", "patch": "@@ -174,6 +174,7 @@ pub trait Iterator<A> {\n     /// assert!(it.peek().is_none());\n     /// assert!(it.next().is_none());\n     /// ~~~\n+    #[inline]\n     fn peekable(self) -> Peekable<A, Self> {\n         Peekable{iter: self, peeked: None}\n     }\n@@ -931,17 +932,15 @@ impl<'self, A, B, T: Iterator<A>> Iterator<B> for Map<'self, A, B, T> {\n     }\n }\n \n-impl<'self, A, B, T: DoubleEndedIterator<A>> DoubleEndedIterator<B>\n-for Map<'self, A, B, T> {\n+impl<'self, A, B, T: DoubleEndedIterator<A>> DoubleEndedIterator<B> for Map<'self, A, B, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n         let next = self.iter.next_back();\n         self.do_map(next)\n     }\n }\n \n-impl<'self, A, B, T: RandomAccessIterator<A>> RandomAccessIterator<B>\n-for Map<'self, A, B, T> {\n+impl<'self, A, B, T: RandomAccessIterator<A>> RandomAccessIterator<B> for Map<'self, A, B, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.iter.indexable()"}, {"sha": "6a48e18a3cc2a3340826c9eed45a0a5d23d112f4", "filename": "src/libstd/kinds.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1ad0cf5841e2fb577c4c26a051067fdd06e24796/src%2Flibstd%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad0cf5841e2fb577c4c26a051067fdd06e24796/src%2Flibstd%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkinds.rs?ref=1ad0cf5841e2fb577c4c26a051067fdd06e24796", "patch": "@@ -18,27 +18,21 @@ intrinsic properties of the type. These classifications, often called\n They cannot be implemented by user code, but are instead implemented\n by the compiler automatically for the types to which they apply.\n \n-The 2 kinds are\n-\n-* Send - owned types and types containing owned types.  These types\n-  may be transferred across task boundaries.\n-\n-* Freeze - types that are deeply immutable.\n-\n */\n \n-#[allow(missing_doc)];\n-\n+/// Types able to be transferred across task boundaries.\n #[lang=\"send\"]\n pub trait Send {\n     // empty.\n }\n \n+/// Types that are either immutable or have inherited mutability.\n #[lang=\"freeze\"]\n pub trait Freeze {\n     // empty.\n }\n \n+/// Types with a constant size known at compile-time.\n #[lang=\"sized\"]\n pub trait Sized {\n     // Empty."}, {"sha": "63f73002009312c21ccf7204f4c4aebba73bf72a", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ad0cf5841e2fb577c4c26a051067fdd06e24796/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad0cf5841e2fb577c4c26a051067fdd06e24796/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=1ad0cf5841e2fb577c4c26a051067fdd06e24796", "patch": "@@ -69,7 +69,7 @@ pub use str::{Str, StrVector, StrSlice, OwnedStr};\n pub use from_str::FromStr;\n pub use to_bytes::IterBytes;\n pub use to_str::{ToStr, ToStrConsume};\n-pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};\n+pub use tuple::{CopyableTuple, ImmutableTuple};\n pub use tuple::{CloneableTuple1, ImmutableTuple1};\n pub use tuple::{CloneableTuple2, CloneableTuple3, CloneableTuple4, CloneableTuple5};\n pub use tuple::{CloneableTuple6, CloneableTuple7, CloneableTuple8, CloneableTuple9};"}, {"sha": "50c25a2f722f841d322a5e8557ceb7597f46c17e", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ad0cf5841e2fb577c4c26a051067fdd06e24796/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad0cf5841e2fb577c4c26a051067fdd06e24796/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=1ad0cf5841e2fb577c4c26a051067fdd06e24796", "patch": "@@ -47,6 +47,7 @@ pub unsafe fn buf_len<T>(buf: **T) -> uint {\n }\n \n impl<T> Clone for *T {\n+    #[inline]\n     fn clone(&self) -> *T {\n         *self\n     }"}, {"sha": "12073a1f4f0951e4db9d64ba54de5279a5bed565", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1ad0cf5841e2fb577c4c26a051067fdd06e24796/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad0cf5841e2fb577c4c26a051067fdd06e24796/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=1ad0cf5841e2fb577c4c26a051067fdd06e24796", "patch": "@@ -13,9 +13,6 @@\n #[allow(missing_doc)];\n \n use clone::Clone;\n-use vec;\n-use vec::ImmutableVector;\n-use iterator::Iterator;\n \n pub use self::inner::*;\n \n@@ -79,55 +76,6 @@ impl<T, U> ImmutableTuple<T, U> for (T, U) {\n     }\n }\n \n-pub trait ExtendedTupleOps<A,B> {\n-    fn zip(&self) -> ~[(A, B)];\n-    fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C];\n-}\n-\n-impl<'self,\n-     A:Clone,\n-     B:Clone>\n-     ExtendedTupleOps<A,B> for\n-     (&'self [A], &'self [B]) {\n-    #[inline]\n-    fn zip(&self) -> ~[(A, B)] {\n-        match *self {\n-            (ref a, ref b) => {\n-                vec::zip_slice(*a, *b)\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C] {\n-        match *self {\n-            (ref a, ref b) => {\n-                a.iter().zip(b.iter()).map(|(aa, bb)| f(aa, bb)).collect()\n-            }\n-        }\n-    }\n-}\n-\n-impl<A:Clone, B:Clone> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n-    #[inline]\n-    fn zip(&self) -> ~[(A, B)] {\n-        match *self {\n-            (ref a, ref b) => {\n-                vec::zip_slice(*a, *b)\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C] {\n-        match *self {\n-            (ref a, ref b) => {\n-                a.iter().zip(b.iter()).map(|(aa, bb)| f(aa, bb)).collect()\n-            }\n-        }\n-    }\n-}\n-\n // macro for implementing n-ary tuple functions and operations\n \n macro_rules! tuple_impls {"}, {"sha": "7748c040a1ddc28aeac01d8f86a49821d88d93f4", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 1, "deletions": 53, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1ad0cf5841e2fb577c4c26a051067fdd06e24796/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad0cf5841e2fb577c4c26a051067fdd06e24796/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=1ad0cf5841e2fb577c4c26a051067fdd06e24796", "patch": "@@ -390,39 +390,6 @@ pub fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n     (ts, us)\n }\n \n-/**\n- * Convert two vectors to a vector of pairs, by reference. As zip().\n- */\n-pub fn zip_slice<T:Clone,U:Clone>(v: &[T], u: &[U]) -> ~[(T, U)] {\n-    let mut zipped = ~[];\n-    let sz = v.len();\n-    let mut i = 0u;\n-    assert_eq!(sz, u.len());\n-    while i < sz {\n-        zipped.push((v[i].clone(), u[i].clone()));\n-        i += 1u;\n-    }\n-    zipped\n-}\n-\n-/**\n- * Convert two vectors to a vector of pairs.\n- *\n- * Returns a vector of tuples, where the i-th tuple contains the\n- * i-th elements from each of the input vectors.\n- */\n-pub fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n-    let mut i = v.len();\n-    assert_eq!(i, u.len());\n-    let mut w = with_capacity(i);\n-    while i > 0 {\n-        w.push((v.pop(),u.pop()));\n-        i -= 1;\n-    }\n-    w.reverse();\n-    w\n-}\n-\n /**\n  * Iterate over all permutations of vector `v`.\n  *\n@@ -724,12 +691,6 @@ impl<T> Vector<T> for @[T] {\n }\n \n impl<'self, T> Container for &'self [T] {\n-    /// Returns true if a vector contains no elements\n-    #[inline]\n-    fn is_empty(&self) -> bool {\n-        self.as_imm_buf(|_p, len| len == 0u)\n-    }\n-\n     /// Returns the length of a vector\n     #[inline]\n     fn len(&self) -> uint {\n@@ -738,12 +699,6 @@ impl<'self, T> Container for &'self [T] {\n }\n \n impl<T> Container for ~[T] {\n-    /// Returns true if a vector contains no elements\n-    #[inline]\n-    fn is_empty(&self) -> bool {\n-        self.as_imm_buf(|_p, len| len == 0u)\n-    }\n-\n     /// Returns the length of a vector\n     #[inline]\n     fn len(&self) -> uint {\n@@ -2865,14 +2820,7 @@ mod tests {\n \n     #[test]\n     fn test_zip_unzip() {\n-        let v1 = ~[1, 2, 3];\n-        let v2 = ~[4, 5, 6];\n-\n-        let z1 = zip(v1, v2);\n-\n-        assert_eq!((1, 4), z1[0]);\n-        assert_eq!((2, 5), z1[1]);\n-        assert_eq!((3, 6), z1[2]);\n+        let z1 = ~[(1, 4), (2, 5), (3, 6)];\n \n         let (left, right) = unzip(z1);\n "}, {"sha": "f31fea526391ce8177b57e311a1ee9a165734820", "filename": "src/test/run-fail/zip-different-lengths.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c4656cfd045ef436377b3dfeebaa265c2c92a00f/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4656cfd045ef436377b3dfeebaa265c2c92a00f/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs?ref=c4656cfd045ef436377b3dfeebaa265c2c92a00f", "patch": "@@ -1,44 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// In this case, the code should compile but\n-// the assert should fail at runtime\n-// error-pattern:assertion failed\n-extern mod extra;\n-use std::vec::{same_length, zip};\n-\n-fn enum_chars(start: u8, end: u8) -> ~[char] {\n-    assert!(start < end);\n-    let mut i = start;\n-    let mut r = ~[];\n-    while i <= end { r.push(i as char); i += 1 as u8; }\n-    return r;\n-}\n-\n-fn enum_uints(start: uint, end: uint) -> ~[uint] {\n-    assert!(start < end);\n-    let mut i = start;\n-    let mut r = ~[];\n-    while i <= end { r.push(i); i += 1; }\n-    return r;\n-}\n-\n-fn main() {\n-    let a = 'a' as u8;\n-    let j = 'j' as u8;\n-    let k = 1;\n-    let l = 9;\n-    let chars = enum_chars(a, j);\n-    let ints = enum_uints(k, l);\n-\n-    assert!(same_length(chars, ints));\n-    let ps = zip(chars, ints);\n-    fail!(\"the impossible happened\");\n-}"}, {"sha": "d97148746d01b2342f4e007142c937cb49013d68", "filename": "src/test/run-pass/zip-same-length.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c4656cfd045ef436377b3dfeebaa265c2c92a00f/src%2Ftest%2Frun-pass%2Fzip-same-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4656cfd045ef436377b3dfeebaa265c2c92a00f/src%2Ftest%2Frun-pass%2Fzip-same-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzip-same-length.rs?ref=c4656cfd045ef436377b3dfeebaa265c2c92a00f", "patch": "@@ -1,44 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// In this case, the code should compile and should\n-// succeed at runtime\n-\n-use std::vec;\n-\n-fn enum_chars(start: u8, end: u8) -> ~[char] {\n-    assert!(start < end);\n-    let mut i = start;\n-    let mut r = ~[];\n-    while i <= end { r.push(i as char); i += 1u as u8; }\n-    return r;\n-}\n-\n-fn enum_uints(start: uint, end: uint) -> ~[uint] {\n-    assert!(start < end);\n-    let mut i = start;\n-    let mut r = ~[];\n-    while i <= end { r.push(i); i += 1u; }\n-    return r;\n-}\n-\n-pub fn main() {\n-    let a = 'a' as u8;\n-    let j = 'j' as u8;\n-    let k = 1u;\n-    let l = 10u;\n-    let chars = enum_chars(a, j);\n-    let ints = enum_uints(k, l);\n-\n-    let ps = vec::zip(chars, ints);\n-\n-    assert_eq!(ps.head(), &('a', 1u));\n-    assert_eq!(ps.last(), &(j as char, 10u));\n-}"}]}