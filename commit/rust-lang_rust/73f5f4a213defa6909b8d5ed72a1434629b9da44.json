{"sha": "73f5f4a213defa6909b8d5ed72a1434629b9da44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczZjVmNGEyMTNkZWZhNjkwOWI4ZDVlZDcyYTE0MzQ2MjliOWRhNDQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2016-03-15T22:24:26Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2016-03-15T22:24:26Z"}, "message": "Merge pull request #869 from ConnorGBrewster/add-trait-formatting\n\nAdd trait formatting", "tree": {"sha": "23a6524dc79dbd6ad44286fc83159aa16ae35719", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23a6524dc79dbd6ad44286fc83159aa16ae35719"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73f5f4a213defa6909b8d5ed72a1434629b9da44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73f5f4a213defa6909b8d5ed72a1434629b9da44", "html_url": "https://github.com/rust-lang/rust/commit/73f5f4a213defa6909b8d5ed72a1434629b9da44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73f5f4a213defa6909b8d5ed72a1434629b9da44/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "204e732c1bfa2909bcd4bb85430e1f537a99d9c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/204e732c1bfa2909bcd4bb85430e1f537a99d9c0", "html_url": "https://github.com/rust-lang/rust/commit/204e732c1bfa2909bcd4bb85430e1f537a99d9c0"}, {"sha": "0a665aacebd5b2b4fa579c49fbb16dbb67e9347e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a665aacebd5b2b4fa579c49fbb16dbb67e9347e", "html_url": "https://github.com/rust-lang/rust/commit/0a665aacebd5b2b4fa579c49fbb16dbb67e9347e"}], "stats": {"total": 332, "additions": 303, "deletions": 29}, "files": [{"sha": "8435de621475fb4934de9f464cffb44de00ed72a", "filename": "src/items.rs", "status": "modified", "additions": 198, "deletions": 6, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/73f5f4a213defa6909b8d5ed72a1434629b9da44/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f5f4a213defa6909b8d5ed72a1434629b9da44/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=73f5f4a213defa6909b8d5ed72a1434629b9da44", "patch": "@@ -22,7 +22,7 @@ use rewrite::{Rewrite, RewriteContext};\n use config::{Config, BlockIndentStyle, Density, ReturnIndent, BraceStyle, StructLitStyle};\n use syntax::codemap;\n \n-use syntax::{ast, abi};\n+use syntax::{ast, abi, ptr};\n use syntax::codemap::{Span, BytePos, mk_sp};\n use syntax::parse::token;\n use syntax::ast::ImplItem;\n@@ -607,6 +607,133 @@ pub fn format_struct(context: &RewriteContext,\n     }\n }\n \n+pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent) -> Option<String> {\n+    if let ast::ItemKind::Trait(unsafety, ref generics, ref type_param_bounds, ref trait_items) =\n+           item.node {\n+        let mut result = String::new();\n+        let header = format!(\"{}{}trait {}\",\n+                             format_visibility(item.vis),\n+                             format_unsafety(unsafety),\n+                             item.ident);\n+\n+        result.push_str(&header);\n+\n+        let body_lo = context.codemap.span_after(item.span, \"{\");\n+\n+        let generics_str = try_opt!(rewrite_generics(context,\n+                                                     generics,\n+                                                     offset,\n+                                                     context.config.max_width,\n+                                                     offset + result.len(),\n+                                                     mk_sp(item.span.lo, body_lo)));\n+        result.push_str(&generics_str);\n+\n+        let trait_bound_str = try_opt!(rewrite_trait_bounds(context,\n+                                                            type_param_bounds,\n+                                                            offset,\n+                                                            context.config.max_width));\n+        // If the trait, generics, and trait bound cannot fit on the same line,\n+        // put the trait bounds on an indented new line\n+        if offset.width() + last_line_width(&result) + trait_bound_str.len() >\n+           context.config.ideal_width {\n+            result.push('\\n');\n+            let width = context.block_indent.width() + context.config.tab_spaces;\n+            let trait_indent = Indent::new(0, width);\n+            result.push_str(&trait_indent.to_string(context.config));\n+        }\n+        result.push_str(&trait_bound_str);\n+\n+        let has_body = !trait_items.is_empty();\n+\n+        let where_density = if (context.config.where_density == Density::Compressed &&\n+                                (!result.contains('\\n') ||\n+                                 context.config.fn_args_layout == StructLitStyle::Block)) ||\n+                               (context.config.fn_args_layout == StructLitStyle::Block &&\n+                                result.is_empty()) ||\n+                               (context.config.where_density == Density::CompressedIfEmpty &&\n+                                !has_body &&\n+                                !result.contains('\\n')) {\n+            Density::Compressed\n+        } else {\n+            Density::Tall\n+        };\n+\n+        let where_budget = try_opt!(context.config\n+                                           .max_width\n+                                           .checked_sub(last_line_width(&result)));\n+        let where_clause_str = try_opt!(rewrite_where_clause(context,\n+                                                             &generics.where_clause,\n+                                                             context.config,\n+                                                             context.config.item_brace_style,\n+                                                             context.block_indent,\n+                                                             where_budget,\n+                                                             where_density,\n+                                                             \"{\",\n+                                                             has_body,\n+                                                             None));\n+        // If the where clause cannot fit on the same line,\n+        // put the where clause on a new line\n+        if !where_clause_str.contains('\\n') &&\n+           last_line_width(&result) + where_clause_str.len() + offset.width() >\n+           context.config.ideal_width {\n+            result.push('\\n');\n+            let width = context.block_indent.width() + context.config.tab_spaces - 1;\n+            let where_indent = Indent::new(0, width);\n+            result.push_str(&where_indent.to_string(context.config));\n+        }\n+        result.push_str(&where_clause_str);\n+\n+        match context.config.item_brace_style {\n+            BraceStyle::AlwaysNextLine => {\n+                result.push('\\n');\n+                result.push_str(&offset.to_string(context.config));\n+            }\n+            BraceStyle::PreferSameLine => result.push(' '),\n+            BraceStyle::SameLineWhere => {\n+                if !where_clause_str.is_empty() &&\n+                   (trait_items.len() > 0 || result.contains('\\n')) {\n+                    result.push('\\n');\n+                    result.push_str(&offset.to_string(context.config));\n+                } else {\n+                    result.push(' ');\n+                }\n+            }\n+        }\n+        result.push('{');\n+\n+        let snippet = context.snippet(item.span);\n+        let open_pos = try_opt!(snippet.find_uncommented(\"{\")) + 1;\n+\n+        if !trait_items.is_empty() || contains_comment(&snippet[open_pos..]) {\n+            let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n+            visitor.block_indent = context.block_indent.block_indent(context.config);\n+            visitor.last_pos = item.span.lo + BytePos(open_pos as u32);\n+\n+            for item in trait_items {\n+                visitor.visit_trait_item(&item);\n+            }\n+\n+            visitor.format_missing(item.span.hi - BytePos(1));\n+\n+            let inner_indent_str = visitor.block_indent.to_string(context.config);\n+            let outer_indent_str = context.block_indent.to_string(context.config);\n+\n+            result.push('\\n');\n+            result.push_str(&inner_indent_str);\n+            result.push_str(&trim_newlines(&visitor.buffer.to_string().trim()));\n+            result.push('\\n');\n+            result.push_str(&outer_indent_str);\n+        } else if result.contains('\\n') {\n+            result.push('\\n');\n+        }\n+\n+        result.push('}');\n+        Some(result)\n+    } else {\n+        unreachable!();\n+    }\n+}\n+\n fn format_unit_struct(item_name: &str, ident: ast::Ident, vis: ast::Visibility) -> Option<String> {\n     let mut result = String::with_capacity(1024);\n \n@@ -894,7 +1021,7 @@ pub fn rewrite_static(prefix: &str,\n                       ident: ast::Ident,\n                       ty: &ast::Ty,\n                       mutability: ast::Mutability,\n-                      expr: &ast::Expr,\n+                      expr_opt: Option<&ptr::P<ast::Expr>>,\n                       context: &RewriteContext)\n                       -> Option<String> {\n     let prefix = format!(\"{}{} {}{}: \",\n@@ -907,11 +1034,54 @@ pub fn rewrite_static(prefix: &str,\n                                      context.config.max_width - context.block_indent.width() -\n                                      prefix.len() - 2,\n                                      context.block_indent));\n-    let lhs = format!(\"{}{} =\", prefix, ty_str);\n \n-    // 1 = ;\n-    let remaining_width = context.config.max_width - context.block_indent.width() - 1;\n-    rewrite_assign_rhs(context, lhs, expr, remaining_width, context.block_indent).map(|s| s + \";\")\n+    if let Some(ref expr) = expr_opt {\n+        let lhs = format!(\"{}{} =\", prefix, ty_str);\n+        // 1 = ;\n+        let remaining_width = context.config.max_width - context.block_indent.width() - 1;\n+        rewrite_assign_rhs(context, lhs, expr, remaining_width, context.block_indent)\n+            .map(|s| s + \";\")\n+    } else {\n+        let lhs = format!(\"{}{};\", prefix, ty_str);\n+        Some(lhs)\n+    }\n+}\n+\n+pub fn rewrite_associated_type(ident: ast::Ident,\n+                               ty_opt: Option<&ptr::P<ast::Ty>>,\n+                               ty_param_bounds_opt: Option<&ast::TyParamBounds>,\n+                               context: &RewriteContext,\n+                               indent: Indent)\n+                               -> Option<String> {\n+    let prefix = format!(\"type {}\", ident);\n+\n+    let type_bounds_str = if let Some(ty_param_bounds) = ty_param_bounds_opt {\n+        let bounds: &[_] = &ty_param_bounds.as_slice();\n+        let bound_str = bounds.iter()\n+                              .filter_map(|ty_bound| {\n+                                  ty_bound.rewrite(context, context.config.max_width, indent)\n+                              })\n+                              .collect::<Vec<String>>()\n+                              .join(\" + \");\n+        if bounds.len() > 0 {\n+            format!(\": {}\", bound_str)\n+        } else {\n+            String::new()\n+        }\n+    } else {\n+        String::new()\n+    };\n+\n+    if let Some(ty) = ty_opt {\n+        let ty_str = try_opt!(ty.rewrite(context,\n+                                         context.config.max_width - context.block_indent.width() -\n+                                         prefix.len() -\n+                                         2,\n+                                         context.block_indent));\n+        Some(format!(\"{} = {};\", prefix, ty_str))\n+    } else {\n+        Some(format!(\"{}{};\", prefix, type_bounds_str))\n+    }\n }\n \n impl Rewrite for ast::FunctionRetTy {\n@@ -1482,6 +1652,28 @@ fn rewrite_generics(context: &RewriteContext,\n     Some(format!(\"<{}>\", list_str))\n }\n \n+fn rewrite_trait_bounds(context: &RewriteContext,\n+                        type_param_bounds: &ast::TyParamBounds,\n+                        indent: Indent,\n+                        width: usize)\n+                        -> Option<String> {\n+    let bounds: &[_] = &type_param_bounds.as_slice();\n+\n+    if bounds.is_empty() {\n+        return Some(String::new());\n+    }\n+\n+    let bound_str = bounds.iter()\n+                          .filter_map(|ty_bound| ty_bound.rewrite(&context, width, indent))\n+                          .collect::<Vec<String>>()\n+                          .join(\" + \");\n+\n+    let mut result = String::new();\n+    result.push_str(\": \");\n+    result.push_str(&bound_str);\n+    Some(result)\n+}\n+\n fn rewrite_where_clause(context: &RewriteContext,\n                         where_clause: &ast::WhereClause,\n                         config: &Config,"}, {"sha": "62fbfd7613fa316acce7c0b892ab315f651a9712", "filename": "src/visitor.rs", "status": "modified", "additions": 43, "deletions": 19, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/73f5f4a213defa6909b8d5ed72a1434629b9da44/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f5f4a213defa6909b8d5ed72a1434629b9da44/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=73f5f4a213defa6909b8d5ed72a1434629b9da44", "patch": "@@ -21,7 +21,7 @@ use config::Config;\n use rewrite::{Rewrite, RewriteContext};\n use comment::rewrite_comment;\n use macros::rewrite_macro;\n-use items::{rewrite_static, rewrite_type_alias, format_impl};\n+use items::{rewrite_static, rewrite_associated_type, rewrite_type_alias, format_impl, format_trait};\n \n pub struct FmtVisitor<'a> {\n     pub parse_session: &'a ParseSess,\n@@ -207,14 +207,14 @@ impl<'a> FmtVisitor<'a> {\n                     self.last_pos = item.span.hi;\n                 }\n             }\n-            // FIXME(#78): format traits.\n-            ast::ItemKind::Trait(_, _, _, ref trait_items) => {\n+            ast::ItemKind::Trait(..) => {\n                 self.format_missing_with_indent(item.span.lo);\n-                self.block_indent = self.block_indent.block_indent(self.config);\n-                for item in trait_items {\n-                    self.visit_trait_item(&item);\n+                if let Some(trait_str) = format_trait(&self.get_context(),\n+                                                      item,\n+                                                      self.block_indent) {\n+                    self.buffer.push_str(&trait_str);\n+                    self.last_pos = item.span.hi;\n                 }\n-                self.block_indent = self.block_indent.block_unindent(self.config);\n             }\n             ast::ItemKind::ExternCrate(_) => {\n                 self.format_missing_with_indent(item.span.lo);\n@@ -266,7 +266,7 @@ impl<'a> FmtVisitor<'a> {\n                                              item.ident,\n                                              ty,\n                                              mutability,\n-                                             expr,\n+                                             Some(expr),\n                                              &self.get_context());\n                 self.push_rewrite(item.span, rewrite);\n             }\n@@ -276,7 +276,7 @@ impl<'a> FmtVisitor<'a> {\n                                              item.ident,\n                                              ty,\n                                              ast::Mutability::Immutable,\n-                                             expr,\n+                                             Some(expr),\n                                              &self.get_context());\n                 self.push_rewrite(item.span, rewrite);\n             }\n@@ -308,14 +308,21 @@ impl<'a> FmtVisitor<'a> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+    pub fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n         if self.visit_attrs(&ti.attrs) {\n             return;\n         }\n \n         match ti.node {\n-            ast::TraitItemKind::Const(..) => {\n-                // FIXME: Implement\n+            ast::TraitItemKind::Const(ref ty, ref expr_opt) => {\n+                let rewrite = rewrite_static(\"const\",\n+                                             ast::Visibility::Inherited,\n+                                             ti.ident,\n+                                             ty,\n+                                             ast::Mutability::Immutable,\n+                                             expr_opt.as_ref(),\n+                                             &self.get_context());\n+                self.push_rewrite(ti.span, rewrite);\n             }\n             ast::TraitItemKind::Method(ref sig, None) => {\n                 let indent = self.block_indent;\n@@ -329,8 +336,13 @@ impl<'a> FmtVisitor<'a> {\n                               ti.span,\n                               ti.id);\n             }\n-            ast::TraitItemKind::Type(..) => {\n-                // FIXME: Implement\n+            ast::TraitItemKind::Type(ref type_param_bounds, _) => {\n+                let rewrite = rewrite_associated_type(ti.ident,\n+                                                      None,\n+                                                      Some(type_param_bounds),\n+                                                      &self.get_context(),\n+                                                      self.block_indent);\n+                self.push_rewrite(ti.span, rewrite);\n             }\n         }\n     }\n@@ -348,11 +360,23 @@ impl<'a> FmtVisitor<'a> {\n                               ii.span,\n                               ii.id);\n             }\n-            ast::ImplItemKind::Const(..) => {\n-                // FIXME: Implement\n-            }\n-            ast::ImplItemKind::Type(_) => {\n-                // FIXME: Implement\n+            ast::ImplItemKind::Const(ref ty, ref expr) => {\n+                let rewrite = rewrite_static(\"const\",\n+                                             ast::Visibility::Inherited,\n+                                             ii.ident,\n+                                             ty,\n+                                             ast::Mutability::Immutable,\n+                                             Some(expr),\n+                                             &self.get_context());\n+                self.push_rewrite(ii.span, rewrite);\n+            }\n+            ast::ImplItemKind::Type(ref ty) => {\n+                let rewrite = rewrite_associated_type(ii.ident,\n+                                                      Some(ty),\n+                                                      None,\n+                                                      &self.get_context(),\n+                                                      self.block_indent);\n+                self.push_rewrite(ii.span, rewrite);\n             }\n             ast::ImplItemKind::Macro(ref mac) => {\n                 self.format_missing_with_indent(ii.span.lo);"}, {"sha": "a3a8033b07f2c250cea9e5fd41ba75bd22995c22", "filename": "tests/source/impls.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73f5f4a213defa6909b8d5ed72a1434629b9da44/tests%2Fsource%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f5f4a213defa6909b8d5ed72a1434629b9da44/tests%2Fsource%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fimpls.rs?ref=73f5f4a213defa6909b8d5ed72a1434629b9da44", "patch": "@@ -1,6 +1,10 @@\n impl Foo for Bar { fn foo() { \"hi\" } }\n \n pub impl Foo for Bar {\n+    // Associated Constants\n+    const   Baz:   i32 =   16;\n+    // Associated Types\n+    type   FooBar  =   usize;\n     // Comment 1\n     fn foo() { \"hi\" }\n     // Comment 2"}, {"sha": "faac57179c202560d2807a6beae527ac8aa86f1a", "filename": "tests/source/trait.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/73f5f4a213defa6909b8d5ed72a1434629b9da44/tests%2Fsource%2Ftrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f5f4a213defa6909b8d5ed72a1434629b9da44/tests%2Fsource%2Ftrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Ftrait.rs?ref=73f5f4a213defa6909b8d5ed72a1434629b9da44", "patch": "@@ -35,3 +35,21 @@ trait TraitWithExpr {\n trait Test {\n     fn read_struct<T, F>(&mut self, s_name: &str, len: usize, f: F) -> Result<T, Self::Error> where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n }\n+\n+trait T<> {}\n+\n+trait Foo { type Bar: Baz;}\n+\n+trait ConstCheck<T>:Foo   where   T: Baz { \n+        const   J:   i32;\n+}\n+\n+trait Tttttttttttttttttttttttttttttttttttttttttttttttttttttttttt<T> \n+    where T: Foo {}\n+\n+trait Ttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt<T> where T: Foo {}\n+\n+trait FooBar<T> : Tttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt where J: Bar { fn test(); }\n+\n+trait WhereList<T, J> where T: Foo, J: Bar {}\n+"}, {"sha": "c2c1a3185bcb0b3be36e327ad4dee1fd1e57a5f3", "filename": "tests/source/where-trailing-comma.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/73f5f4a213defa6909b8d5ed72a1434629b9da44/tests%2Fsource%2Fwhere-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f5f4a213defa6909b8d5ed72a1434629b9da44/tests%2Fsource%2Fwhere-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fwhere-trailing-comma.rs?ref=73f5f4a213defa6909b8d5ed72a1434629b9da44", "patch": "@@ -20,7 +20,7 @@ struct Pair<S, T> where T: P, S: P + Q {\n \n struct TupPair<S, T> (S, T) where T: P, S: P + Q;\n \n-enum E<S, T> where S: P, T: P { \n+enum E<S, T> where S: P, T: P {\n     A {a: T},\n }\n \n@@ -30,7 +30,6 @@ extern \"C\" {\n     fn f<S, T>(x: T, y: S) -> T where T: P, S: Q;\n }\n \n-// Note: trait declarations are not fully formatted (issue #78)\n trait Q<S, T> where T: P, S: R\n {\n     fn f<U, V>(self, x: T, y: S, z: U) -> Self where U: P, V: P;"}, {"sha": "c81de4d40fea99f3d1bdeb99c03c04419a448b6e", "filename": "tests/target/impls.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73f5f4a213defa6909b8d5ed72a1434629b9da44/tests%2Ftarget%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f5f4a213defa6909b8d5ed72a1434629b9da44/tests%2Ftarget%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimpls.rs?ref=73f5f4a213defa6909b8d5ed72a1434629b9da44", "patch": "@@ -5,6 +5,10 @@ impl Foo for Bar {\n }\n \n pub impl Foo for Bar {\n+    // Associated Constants\n+    const Baz: i32 = 16;\n+    // Associated Types\n+    type FooBar = usize;\n     // Comment 1\n     fn foo() {\n         \"hi\""}, {"sha": "d8acc1ba229b12fed6192b73ae1758409c0bd786", "filename": "tests/target/trait.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/73f5f4a213defa6909b8d5ed72a1434629b9da44/tests%2Ftarget%2Ftrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f5f4a213defa6909b8d5ed72a1434629b9da44/tests%2Ftarget%2Ftrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftrait.rs?ref=73f5f4a213defa6909b8d5ed72a1434629b9da44", "patch": "@@ -34,3 +34,35 @@ trait Test {\n     fn read_struct<T, F>(&mut self, s_name: &str, len: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n }\n+\n+trait T {}\n+\n+trait Foo {\n+    type Bar: Baz;\n+}\n+\n+trait ConstCheck<T>: Foo\n+    where T: Baz\n+{\n+    const J: i32;\n+}\n+\n+trait Tttttttttttttttttttttttttttttttttttttttttttttttttttttttttt<T> where T: Foo {}\n+\n+trait Ttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt<T>\n+    where T: Foo\n+{\n+}\n+\n+trait FooBar<T>\n+    : Tttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt\n+    where J: Bar\n+{\n+    fn test();\n+}\n+\n+trait WhereList<T, J>\n+    where T: Foo,\n+          J: Bar\n+{\n+}"}, {"sha": "c8682237ae6afab7cf4e6a07550590a00e857b4b", "filename": "tests/target/where-trailing-comma.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/73f5f4a213defa6909b8d5ed72a1434629b9da44/tests%2Ftarget%2Fwhere-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f5f4a213defa6909b8d5ed72a1434629b9da44/tests%2Ftarget%2Fwhere-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fwhere-trailing-comma.rs?ref=73f5f4a213defa6909b8d5ed72a1434629b9da44", "patch": "@@ -48,8 +48,9 @@ extern \"C\" {\n               S: Q;\n }\n \n-// Note: trait declarations are not fully formatted (issue #78)\n-trait Q<S, T> where T: P, S: R\n+trait Q<S, T>\n+    where T: P,\n+          S: R,\n {\n     fn f<U, V>(self, x: T, y: S, z: U) -> Self\n         where U: P,"}]}