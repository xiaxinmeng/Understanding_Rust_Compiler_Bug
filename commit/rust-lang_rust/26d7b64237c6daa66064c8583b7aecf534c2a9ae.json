{"sha": "26d7b64237c6daa66064c8583b7aecf534c2a9ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2ZDdiNjQyMzdjNmRhYTY2MDY0Yzg1ODNiN2FlY2Y1MzRjMmE5YWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-08T01:24:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-08T01:24:15Z"}, "message": "Auto merge of #52993 - alexcrichton:fix-some-vis, r=michaelwoerister\n\nrustc: Tweak visibility of some lang items\n\nThis commit tweaks the linker-level visibility of some lang items that rustc\nuses and defines. Notably this means that `#[panic_implementation]` and\n`#[alloc_error_handler]` functions are never marked as `internal`. It's up to\nthe linker to eliminate these, not rustc.\n\nAdditionally `#[global_allocator]` generated symbols are no longer forced to\n`Default` visibility (fully exported), but rather they're relaxed to `Hidden`\nvisibility). This symbols are *not* needed across DLL boundaries, only as a\nlocal implementation detail of the compiler-injected allocator symbols, so\n`Hidden` should suffice.\n\nCloses #51342\nCloses #52795", "tree": {"sha": "1abd68a78dbab63a894988da5253c07e65ed10f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1abd68a78dbab63a894988da5253c07e65ed10f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26d7b64237c6daa66064c8583b7aecf534c2a9ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26d7b64237c6daa66064c8583b7aecf534c2a9ae", "html_url": "https://github.com/rust-lang/rust/commit/26d7b64237c6daa66064c8583b7aecf534c2a9ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26d7b64237c6daa66064c8583b7aecf534c2a9ae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f4f18f098183bf60820e4304433c4c4d9cceaaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f4f18f098183bf60820e4304433c4c4d9cceaaa", "html_url": "https://github.com/rust-lang/rust/commit/3f4f18f098183bf60820e4304433c4c4d9cceaaa"}, {"sha": "7c58ab671fb49200c0cbd1ad9218713a5c3afe0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d", "html_url": "https://github.com/rust-lang/rust/commit/7c58ab671fb49200c0cbd1ad9218713a5c3afe0d"}], "stats": {"total": 497, "additions": 345, "deletions": 152}, "files": [{"sha": "a09942258e22d9b2aba6d54b974b75b9b4544bf9", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26d7b64237c6daa66064c8583b7aecf534c2a9ae/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d7b64237c6daa66064c8583b7aecf534c2a9ae/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=26d7b64237c6daa66064c8583b7aecf534c2a9ae", "patch": "@@ -15,7 +15,7 @@\n // makes all other generics or inline functions that it references\n // reachable as well.\n \n-use hir::CodegenFnAttrs;\n+use hir::{CodegenFnAttrs, CodegenFnAttrFlags};\n use hir::map as hir_map;\n use hir::def::Def;\n use hir::def_id::{DefId, CrateNum};\n@@ -28,7 +28,6 @@ use util::nodemap::{NodeSet, FxHashSet};\n \n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n-use syntax::attr;\n use hir;\n use hir::def_id::LOCAL_CRATE;\n use hir::intravisit::{Visitor, NestedVisitorMap};\n@@ -359,8 +358,12 @@ struct CollectPrivateImplItemsVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         // Anything which has custom linkage gets thrown on the worklist no\n-        // matter where it is in the crate.\n-        if attr::contains_name(&item.attrs, \"linkage\") {\n+        // matter where it is in the crate, along with \"special std symbols\"\n+        // which are currently akin to allocator symbols.\n+        let def_id = self.tcx.hir.local_def_id(item.id);\n+        let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n+        if codegen_attrs.linkage.is_some() ||\n+            codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n             self.worklist.push(item.id);\n         }\n "}, {"sha": "05843852ee0de713c0a25a4b51ecc152bbce6bbb", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26d7b64237c6daa66064c8583b7aecf534c2a9ae/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d7b64237c6daa66064c8583b7aecf534c2a9ae/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=26d7b64237c6daa66064c8583b7aecf534c2a9ae", "patch": "@@ -13,7 +13,7 @@ use rustc_errors;\n use syntax::{\n     ast::{\n         self, Arg, Attribute, Crate, Expr, FnHeader, Generics, Ident, Item, ItemKind,\n-        LitKind, Mac, Mod, Mutability, StrStyle, Ty, TyKind, Unsafety, VisibilityKind,\n+        Mac, Mod, Mutability, Ty, TyKind, Unsafety, VisibilityKind,\n     },\n     attr,\n     codemap::{\n@@ -236,17 +236,12 @@ impl<'a> AllocFnFactory<'a> {\n     }\n \n     fn attrs(&self) -> Vec<Attribute> {\n-        let key = Symbol::intern(\"linkage\");\n-        let value = LitKind::Str(Symbol::intern(\"external\"), StrStyle::Cooked);\n-        let linkage = self.cx.meta_name_value(self.span, key, value);\n-\n         let no_mangle = Symbol::intern(\"no_mangle\");\n         let no_mangle = self.cx.meta_word(self.span, no_mangle);\n \n         let special = Symbol::intern(\"rustc_std_internal_symbol\");\n         let special = self.cx.meta_word(self.span, special);\n         vec![\n-            self.cx.attribute(self.span, linkage),\n             self.cx.attribute(self.span, no_mangle),\n             self.cx.attribute(self.span, special),\n         ]"}, {"sha": "0beb8a8844c958f281f98f9e902c4b8dcb9a3fb3", "filename": "src/librustc_codegen_llvm/allocator.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26d7b64237c6daa66064c8583b7aecf534c2a9ae/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d7b64237c6daa66064c8583b7aecf534c2a9ae/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fallocator.rs?ref=26d7b64237c6daa66064c8583b7aecf534c2a9ae", "patch": "@@ -67,14 +67,15 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind\n         if tcx.sess.target.target.options.default_hidden_visibility {\n             llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n         }\n-       if tcx.sess.target.target.options.requires_uwtable {\n-           attributes::emit_uwtable(llfn, true);\n-       }\n+        if tcx.sess.target.target.options.requires_uwtable {\n+            attributes::emit_uwtable(llfn, true);\n+        }\n \n         let callee = CString::new(kind.fn_name(method.name)).unwrap();\n         let callee = llvm::LLVMRustGetOrInsertFunction(llmod,\n                                                        callee.as_ptr(),\n                                                        ty);\n+        llvm::LLVMRustSetVisibility(callee, llvm::Visibility::Hidden);\n \n         let llbb = llvm::LLVMAppendBasicBlockInContext(llcx,\n                                                        llfn,"}, {"sha": "0a8bc03d8d41cf38edc31116bba2055d39793ba2", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/26d7b64237c6daa66064c8583b7aecf534c2a9ae/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d7b64237c6daa66064c8583b7aecf534c2a9ae/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=26d7b64237c6daa66064c8583b7aecf534c2a9ae", "patch": "@@ -809,8 +809,28 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         rx,\n         codegen_units.len());\n \n-    // Codegen an allocator shim, if any\n-    let allocator_module = if let Some(kind) = *tcx.sess.allocator_kind.get() {\n+    // Codegen an allocator shim, if necessary.\n+    //\n+    // If the crate doesn't have an `allocator_kind` set then there's definitely\n+    // no shim to generate. Otherwise we also check our dependency graph for all\n+    // our output crate types. If anything there looks like its a `Dynamic`\n+    // linkage, then it's already got an allocator shim and we'll be using that\n+    // one instead. If nothing exists then it's our job to generate the\n+    // allocator!\n+    let any_dynamic_crate = tcx.sess.dependency_formats.borrow()\n+        .iter()\n+        .any(|(_, list)| {\n+            use rustc::middle::dependency_format::Linkage;\n+            list.iter().any(|linkage| {\n+                match linkage {\n+                    Linkage::Dynamic => true,\n+                    _ => false,\n+                }\n+            })\n+        });\n+    let allocator_module = if any_dynamic_crate {\n+        None\n+    } else if let Some(kind) = *tcx.sess.allocator_kind.get() {\n         unsafe {\n             let llmod_id = \"allocator\";\n             let modules = ModuleLlvm::new(tcx.sess, llmod_id);"}, {"sha": "4e32ca483a1253e9dffee63e63aedcdc8d52adfc", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 202, "deletions": 137, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/26d7b64237c6daa66064c8583b7aecf534c2a9ae/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d7b64237c6daa66064c8583b7aecf534c2a9ae/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=26d7b64237c6daa66064c8583b7aecf534c2a9ae", "patch": "@@ -104,6 +104,7 @@\n \n use monomorphize::collector::InliningMap;\n use rustc::dep_graph::WorkProductId;\n+use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::mir::mono::{Linkage, Visibility};\n@@ -322,146 +323,16 @@ fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             None => fallback_cgu_name(tcx),\n         };\n \n-        let make_codegen_unit = || {\n-            CodegenUnit::new(codegen_unit_name.clone())\n-        };\n-\n         let codegen_unit = codegen_units.entry(codegen_unit_name.clone())\n-                                            .or_insert_with(make_codegen_unit);\n+            .or_insert_with(|| CodegenUnit::new(codegen_unit_name.clone()));\n \n         let mut can_be_internalized = true;\n-        let default_visibility = |id: DefId, is_generic: bool| {\n-            if !tcx.sess.target.target.options.default_hidden_visibility {\n-                return Visibility::Default\n-            }\n-\n-            // Generic functions never have export level C\n-            if is_generic {\n-                return Visibility::Hidden\n-            }\n-\n-            // Things with export level C don't get instantiated in downstream\n-            // crates\n-            if !id.is_local() {\n-                return Visibility::Hidden\n-            }\n-\n-            if let Some(&SymbolExportLevel::C) = tcx.reachable_non_generics(id.krate)\n-                                                    .get(&id) {\n-                Visibility::Default\n-            } else {\n-                Visibility::Hidden\n-            }\n-        };\n-        let (linkage, visibility) = match mono_item.explicit_linkage(tcx) {\n-            Some(explicit_linkage) => (explicit_linkage, Visibility::Default),\n-            None => {\n-                match mono_item {\n-                    MonoItem::Fn(ref instance) => {\n-                        let visibility = match instance.def {\n-                            InstanceDef::Item(def_id) => {\n-                                let is_generic = instance.substs\n-                                                         .types()\n-                                                         .next()\n-                                                         .is_some();\n-\n-                                // The `start_fn` lang item is actually a\n-                                // monomorphized instance of a function in the\n-                                // standard library, used for the `main`\n-                                // function. We don't want to export it so we\n-                                // tag it with `Hidden` visibility but this\n-                                // symbol is only referenced from the actual\n-                                // `main` symbol which we unfortunately don't\n-                                // know anything about during\n-                                // partitioning/collection. As a result we\n-                                // forcibly keep this symbol out of the\n-                                // `internalization_candidates` set.\n-                                //\n-                                // FIXME: eventually we don't want to always\n-                                // force this symbol to have hidden\n-                                // visibility, it should indeed be a candidate\n-                                // for internalization, but we have to\n-                                // understand that it's referenced from the\n-                                // `main` symbol we'll generate later.\n-                                if tcx.lang_items().start_fn() == Some(def_id) {\n-                                    can_be_internalized = false;\n-                                    Visibility::Hidden\n-                                } else if def_id.is_local() {\n-                                    if is_generic {\n-                                        if export_generics {\n-                                            if tcx.is_unreachable_local_definition(def_id) {\n-                                                // This instance cannot be used\n-                                                // from another crate.\n-                                                Visibility::Hidden\n-                                            } else {\n-                                                // This instance might be useful in\n-                                                // a downstream crate.\n-                                                can_be_internalized = false;\n-                                                default_visibility(def_id, true)\n-                                            }\n-                                        } else {\n-                                            // We are not exporting generics or\n-                                            // the definition is not reachable\n-                                            // for downstream crates, we can\n-                                            // internalize its instantiations.\n-                                            Visibility::Hidden\n-                                        }\n-                                    } else {\n-                                        // This isn't a generic function.\n-                                        if tcx.is_reachable_non_generic(def_id) {\n-                                            can_be_internalized = false;\n-                                            debug_assert!(!is_generic);\n-                                            default_visibility(def_id, false)\n-                                        } else {\n-                                            Visibility::Hidden\n-                                        }\n-                                    }\n-                                } else {\n-                                    // This is an upstream DefId.\n-                                    if export_generics && is_generic {\n-                                        // If it is a upstream monomorphization\n-                                        // and we export generics, we must make\n-                                        // it available to downstream crates.\n-                                        can_be_internalized = false;\n-                                        default_visibility(def_id, true)\n-                                    } else {\n-                                        Visibility::Hidden\n-                                    }\n-                                }\n-                            }\n-                            InstanceDef::FnPtrShim(..) |\n-                            InstanceDef::Virtual(..) |\n-                            InstanceDef::Intrinsic(..) |\n-                            InstanceDef::ClosureOnceShim { .. } |\n-                            InstanceDef::DropGlue(..) |\n-                            InstanceDef::CloneShim(..) => {\n-                                Visibility::Hidden\n-                            }\n-                        };\n-                        (Linkage::External, visibility)\n-                    }\n-                    MonoItem::Static(def_id) => {\n-                        let visibility = if tcx.is_reachable_non_generic(def_id) {\n-                            can_be_internalized = false;\n-                            default_visibility(def_id, false)\n-                        } else {\n-                            Visibility::Hidden\n-                        };\n-                        (Linkage::External, visibility)\n-                    }\n-                    MonoItem::GlobalAsm(node_id) => {\n-                        let def_id = tcx.hir.local_def_id(node_id);\n-                        let visibility = if tcx.is_reachable_non_generic(def_id) {\n-                            can_be_internalized = false;\n-                            default_visibility(def_id, false)\n-                        } else {\n-                            Visibility::Hidden\n-                        };\n-                        (Linkage::External, visibility)\n-                    }\n-                }\n-            }\n-        };\n+        let (linkage, visibility) = mono_item_linkage_and_visibility(\n+            tcx,\n+            &mono_item,\n+            &mut can_be_internalized,\n+            export_generics,\n+        );\n         if visibility == Visibility::Hidden && can_be_internalized {\n             internalization_candidates.insert(mono_item);\n         }\n@@ -487,6 +358,200 @@ fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+fn mono_item_linkage_and_visibility(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mono_item: &MonoItem<'tcx>,\n+    can_be_internalized: &mut bool,\n+    export_generics: bool,\n+) -> (Linkage, Visibility) {\n+    if let Some(explicit_linkage) = mono_item.explicit_linkage(tcx) {\n+        return (explicit_linkage, Visibility::Default)\n+    }\n+    let vis = mono_item_visibility(\n+        tcx,\n+        mono_item,\n+        can_be_internalized,\n+        export_generics,\n+    );\n+    (Linkage::External, vis)\n+}\n+\n+fn mono_item_visibility(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mono_item: &MonoItem<'tcx>,\n+    can_be_internalized: &mut bool,\n+    export_generics: bool,\n+) -> Visibility {\n+    let instance = match mono_item {\n+        // This is pretty complicated, go below\n+        MonoItem::Fn(instance) => instance,\n+\n+        // Misc handling for generics and such, but otherwise\n+        MonoItem::Static(def_id) => {\n+            return if tcx.is_reachable_non_generic(*def_id) {\n+                *can_be_internalized = false;\n+                default_visibility(tcx, *def_id, false)\n+            } else {\n+                Visibility::Hidden\n+            };\n+        }\n+        MonoItem::GlobalAsm(node_id) => {\n+            let def_id = tcx.hir.local_def_id(*node_id);\n+            return if tcx.is_reachable_non_generic(def_id) {\n+                *can_be_internalized = false;\n+                default_visibility(tcx, def_id, false)\n+            } else {\n+                Visibility::Hidden\n+            };\n+        }\n+    };\n+\n+    let def_id = match instance.def {\n+        InstanceDef::Item(def_id) => def_id,\n+\n+        // These are all compiler glue and such, never exported, always hidden.\n+        InstanceDef::FnPtrShim(..) |\n+        InstanceDef::Virtual(..) |\n+        InstanceDef::Intrinsic(..) |\n+        InstanceDef::ClosureOnceShim { .. } |\n+        InstanceDef::DropGlue(..) |\n+        InstanceDef::CloneShim(..) => {\n+            return Visibility::Hidden\n+        }\n+    };\n+\n+    // The `start_fn` lang item is actually a monomorphized instance of a\n+    // function in the standard library, used for the `main` function. We don't\n+    // want to export it so we tag it with `Hidden` visibility but this symbol\n+    // is only referenced from the actual `main` symbol which we unfortunately\n+    // don't know anything about during partitioning/collection. As a result we\n+    // forcibly keep this symbol out of the `internalization_candidates` set.\n+    //\n+    // FIXME: eventually we don't want to always force this symbol to have\n+    //        hidden visibility, it should indeed be a candidate for\n+    //        internalization, but we have to understand that it's referenced\n+    //        from the `main` symbol we'll generate later.\n+    //\n+    //        This may be fixable with a new `InstanceDef` perhaps? Unsure!\n+    if tcx.lang_items().start_fn() == Some(def_id) {\n+        *can_be_internalized = false;\n+        return Visibility::Hidden\n+    }\n+\n+    let is_generic = instance.substs.types().next().is_some();\n+\n+    // Upstream `DefId` instances get different handling than local ones\n+    if !def_id.is_local() {\n+        return if export_generics && is_generic {\n+            // If it is a upstream monomorphization\n+            // and we export generics, we must make\n+            // it available to downstream crates.\n+            *can_be_internalized = false;\n+            default_visibility(tcx, def_id, true)\n+        } else {\n+            Visibility::Hidden\n+        }\n+    }\n+\n+    if is_generic {\n+        if export_generics {\n+            if tcx.is_unreachable_local_definition(def_id) {\n+                // This instance cannot be used\n+                // from another crate.\n+                Visibility::Hidden\n+            } else {\n+                // This instance might be useful in\n+                // a downstream crate.\n+                *can_be_internalized = false;\n+                default_visibility(tcx, def_id, true)\n+            }\n+        } else {\n+            // We are not exporting generics or\n+            // the definition is not reachable\n+            // for downstream crates, we can\n+            // internalize its instantiations.\n+            Visibility::Hidden\n+        }\n+    } else {\n+\n+        // If this isn't a generic function then we mark this a `Default` if\n+        // this is a reachable item, meaning that it's a symbol other crates may\n+        // access when they link to us.\n+        if tcx.is_reachable_non_generic(def_id) {\n+            *can_be_internalized = false;\n+            debug_assert!(!is_generic);\n+            return default_visibility(tcx, def_id, false)\n+        }\n+\n+        // If this isn't reachable then we're gonna tag this with `Hidden`\n+        // visibility. In some situations though we'll want to prevent this\n+        // symbol from being internalized.\n+        //\n+        // There's two categories of items here:\n+        //\n+        // * First is weak lang items. These are basically mechanisms for\n+        //   libcore to forward-reference symbols defined later in crates like\n+        //   the standard library or `#[panic_implementation]` definitions. The\n+        //   definition of these weak lang items needs to be referenceable by\n+        //   libcore, so we're no longer a candidate for internalization.\n+        //   Removal of these functions can't be done by LLVM but rather must be\n+        //   done by the linker as it's a non-local decision.\n+        //\n+        // * Second is \"std internal symbols\". Currently this is primarily used\n+        //   for allocator symbols. Allocators are a little weird in their\n+        //   implementation, but the idea is that the compiler, at the last\n+        //   minute, defines an allocator with an injected object file. The\n+        //   `alloc` crate references these symbols (`__rust_alloc`) and the\n+        //   definition doesn't get hooked up until a linked crate artifact is\n+        //   generated.\n+        //\n+        //   The symbols synthesized by the compiler (`__rust_alloc`) are thin\n+        //   veneers around the actual implementation, some other symbol which\n+        //   implements the same ABI. These symbols (things like `__rg_alloc`,\n+        //   `__rdl_alloc`, `__rde_alloc`, etc), are all tagged with \"std\n+        //   internal symbols\".\n+        //\n+        //   The std-internal symbols here **should not show up in a dll as an\n+        //   exported interface**, so they return `false` from\n+        //   `is_reachable_non_generic` above and we'll give them `Hidden`\n+        //   visibility below. Like the weak lang items, though, we can't let\n+        //   LLVM internalize them as this decision is left up to the linker to\n+        //   omit them, so prevent them from being internalized.\n+        let codegen_fn_attrs = tcx.codegen_fn_attrs(def_id);\n+        let std_internal_symbol = codegen_fn_attrs.flags\n+            .contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL);\n+        if tcx.is_weak_lang_item(def_id) || std_internal_symbol {\n+            *can_be_internalized = false;\n+        }\n+\n+        Visibility::Hidden\n+    }\n+}\n+\n+fn default_visibility(tcx: TyCtxt, id: DefId, is_generic: bool) -> Visibility {\n+    if !tcx.sess.target.target.options.default_hidden_visibility {\n+        return Visibility::Default\n+    }\n+\n+    // Generic functions never have export level C\n+    if is_generic {\n+        return Visibility::Hidden\n+    }\n+\n+    // Things with export level C don't get instantiated in\n+    // downstream crates\n+    if !id.is_local() {\n+        return Visibility::Hidden\n+    }\n+\n+    // C-export level items remain at `Default`, all other internal\n+    // items become `Hidden`\n+    match tcx.reachable_non_generics(id.krate).get(&id) {\n+        Some(SymbolExportLevel::C) => Visibility::Default,\n+        _ => Visibility::Hidden,\n+    }\n+}\n+\n fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n                              target_cgu_count: usize,\n                              crate_name: &str) {"}, {"sha": "872825113a84538863f015e3be738d27f96d53d3", "filename": "src/test/run-make/wasm-symbols-not-exported/Makefile", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26d7b64237c6daa66064c8583b7aecf534c2a9ae/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/26d7b64237c6daa66064c8583b7aecf534c2a9ae/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2FMakefile?ref=26d7b64237c6daa66064c8583b7aecf534c2a9ae", "patch": "@@ -0,0 +1,16 @@\n+-include ../../run-make-fulldeps/tools.mk\n+\n+ifeq ($(TARGET),wasm32-unknown-unknown)\n+all:\n+\t$(RUSTC) foo.rs --target wasm32-unknown-unknown\n+\t$(NODE) verify-exported-symbols.js $(TMPDIR)/foo.wasm\n+\t$(RUSTC) foo.rs --target wasm32-unknown-unknown -O\n+\t$(NODE) verify-exported-symbols.js $(TMPDIR)/foo.wasm\n+\t$(RUSTC) bar.rs --target wasm32-unknown-unknown\n+\t$(NODE) verify-exported-symbols.js $(TMPDIR)/bar.wasm\n+\t$(RUSTC) bar.rs --target wasm32-unknown-unknown -O\n+\t$(NODE) verify-exported-symbols.js $(TMPDIR)/bar.wasm\n+else\n+all:\n+endif\n+"}, {"sha": "979ec44b040776407dd955a1b5a5cf4ade1e057c", "filename": "src/test/run-make/wasm-symbols-not-exported/bar.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/26d7b64237c6daa66064c8583b7aecf534c2a9ae/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d7b64237c6daa66064c8583b7aecf534c2a9ae/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2Fbar.rs?ref=26d7b64237c6daa66064c8583b7aecf534c2a9ae", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(panic_implementation, alloc_error_handler)]\n+#![crate_type = \"cdylib\"]\n+#![no_std]\n+\n+use core::alloc::*;\n+\n+struct B;\n+\n+unsafe impl GlobalAlloc for B {\n+    unsafe fn alloc(&self, x: Layout) -> *mut u8 {\n+        1 as *mut u8\n+    }\n+\n+    unsafe fn dealloc(&self, ptr: *mut u8, x: Layout) {\n+    }\n+}\n+\n+#[global_allocator]\n+static A: B = B;\n+\n+#[no_mangle]\n+pub extern fn foo(a: u32) -> u32 {\n+    assert_eq!(a, 3);\n+    a * 2\n+}\n+\n+#[alloc_error_handler]\n+fn a(_: core::alloc::Layout) -> ! {\n+    loop {}\n+}\n+\n+#[panic_implementation]\n+fn b(_: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}"}, {"sha": "cd8c7cb205d96b2b31c82059e9e7e4beefbf5333", "filename": "src/test/run-make/wasm-symbols-not-exported/foo.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/26d7b64237c6daa66064c8583b7aecf534c2a9ae/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d7b64237c6daa66064c8583b7aecf534c2a9ae/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2Ffoo.rs?ref=26d7b64237c6daa66064c8583b7aecf534c2a9ae", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"cdylib\"]\n+\n+#[no_mangle]\n+pub extern fn foo() {\n+    println!(\"foo\");\n+    panic!(\"test\");\n+}"}, {"sha": "060830eb01a7191183743f4eae91d1ef3fbbcaf3", "filename": "src/test/run-make/wasm-symbols-not-exported/verify-exported-symbols.js", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/26d7b64237c6daa66064c8583b7aecf534c2a9ae/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2Fverify-exported-symbols.js", "raw_url": "https://github.com/rust-lang/rust/raw/26d7b64237c6daa66064c8583b7aecf534c2a9ae/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2Fverify-exported-symbols.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-symbols-not-exported%2Fverify-exported-symbols.js?ref=26d7b64237c6daa66064c8583b7aecf534c2a9ae", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const fs = require('fs');\n+const process = require('process');\n+const assert = require('assert');\n+const buffer = fs.readFileSync(process.argv[2]);\n+\n+let m = new WebAssembly.Module(buffer);\n+let list = WebAssembly.Module.exports(m);\n+console.log('exports', list);\n+\n+let bad = false;\n+for (let i = 0; i < list.length; i++) {\n+  const e = list[i];\n+  if (e.name == \"foo\" || e.kind != \"function\")\n+    continue;\n+\n+  console.log('unexpected exported symbol:', e.name);\n+  bad = true;\n+}\n+\n+if (bad)\n+  process.exit(1);"}]}