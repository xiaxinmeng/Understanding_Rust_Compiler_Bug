{"sha": "35614c762378f472ebefa12434b7e54a38a94eb9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NjE0Yzc2MjM3OGY0NzJlYmVmYTEyNDM0YjdlNTRhMzhhOTRlYjk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-04T18:29:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-04T18:29:53Z"}, "message": "Merge #8328\n\n8328: Move things in hir_ty into submodules r=flodiebold a=flodiebold\n\n - all the types that will be replaced by Chalk go to `types`\r\n - `TypeWalk` impls go to `walk`\r\n - also fix signature of `Substitution::interned`\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "7230e16cd37c447be8576876789f7049d2b70495", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7230e16cd37c447be8576876789f7049d2b70495"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35614c762378f472ebefa12434b7e54a38a94eb9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgagWhCRBK7hj4Ov3rIwAAdHIIAG3y9lSfJpb9beOxEvuA39XO\nm2NbgQo9JsWjkKIFoV/kxr9lbcKPIPqRdILUufJ+a3v+DlBql4ZOOUWXNvgfsqea\nTIVciWkDZHFHQokpS0VxlTMUsn6R6jxXjQx9FTJAz/u2lDsYk3snPzf2XLwXPQtg\nffeDE/shrO5mmTAdMnfx9350GsFJ48hZtvQL2vUU0IpEk8xcbU4HvGLaTQ2V9iYi\ncfDjnB7+hHA1Qc2d3j2SpSt3uUxxLah7Trhn8rWyhuF7cnzBtEr8H3RBBFuv/OA5\n0WIiHD08BqMuPTXr3mAAWoF9hBI3k8M2UztnsKXjGSPYZ+QJgat3Rm/FKwqJmYo=\n=WQJK\n-----END PGP SIGNATURE-----\n", "payload": "tree 7230e16cd37c447be8576876789f7049d2b70495\nparent 0924888cce5f48e0ea0dc7fd8641db92850ef660\nparent 645a9c3a274109512839b79d8e86a805a39cd6e1\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1617560993 +0000\ncommitter GitHub <noreply@github.com> 1617560993 +0000\n\nMerge #8328\n\n8328: Move things in hir_ty into submodules r=flodiebold a=flodiebold\n\n - all the types that will be replaced by Chalk go to `types`\r\n - `TypeWalk` impls go to `walk`\r\n - also fix signature of `Substitution::interned`\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35614c762378f472ebefa12434b7e54a38a94eb9", "html_url": "https://github.com/rust-lang/rust/commit/35614c762378f472ebefa12434b7e54a38a94eb9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35614c762378f472ebefa12434b7e54a38a94eb9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0924888cce5f48e0ea0dc7fd8641db92850ef660", "url": "https://api.github.com/repos/rust-lang/rust/commits/0924888cce5f48e0ea0dc7fd8641db92850ef660", "html_url": "https://github.com/rust-lang/rust/commit/0924888cce5f48e0ea0dc7fd8641db92850ef660"}, {"sha": "645a9c3a274109512839b79d8e86a805a39cd6e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/645a9c3a274109512839b79d8e86a805a39cd6e1", "html_url": "https://github.com/rust-lang/rust/commit/645a9c3a274109512839b79d8e86a805a39cd6e1"}], "stats": {"total": 1669, "additions": 855, "deletions": 814}, "files": [{"sha": "e41efb3856f92cbfa589a987c326cb6f8f04df25", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=35614c762378f472ebefa12434b7e54a38a94eb9", "patch": "@@ -55,10 +55,11 @@ use hir_ty::{\n     autoderef, could_unify,\n     method_resolution::{self, TyFingerprint},\n     primitive::UintTy,\n-    traits::{FnTrait, Solution, SolutionVariables},\n+    traits::FnTrait,\n     AliasEq, AliasTy, BoundVar, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast,\n-    DebruijnIndex, InEnvironment, Interner, QuantifiedWhereClause, Scalar, Substitution,\n-    TraitEnvironment, Ty, TyBuilder, TyDefId, TyKind, TyVariableKind, WhereClause,\n+    DebruijnIndex, InEnvironment, Interner, QuantifiedWhereClause, Scalar, Solution,\n+    SolutionVariables, Substitution, TraitEnvironment, Ty, TyBuilder, TyDefId, TyKind,\n+    TyVariableKind, WhereClause,\n };\n use itertools::Itertools;\n use rustc_hash::FxHashSet;\n@@ -1822,7 +1823,7 @@ impl Type {\n         match db.trait_solve(self.krate, goal)? {\n             Solution::Unique(SolutionVariables(subst)) => subst\n                 .value\n-                .interned(&Interner)\n+                .interned()\n                 .first()\n                 .map(|ty| self.derived(ty.assert_ty_ref(&Interner).clone())),\n             Solution::Ambig(_) => None,"}, {"sha": "7ca4af80e4fb87a1c4d1fd0b43ea49cfb4b891eb", "filename": "crates/hir_ty/src/autoderef.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs?ref=35614c762378f472ebefa12434b7e54a38a94eb9", "patch": "@@ -12,10 +12,8 @@ use hir_expand::name::name;\n use log::{info, warn};\n \n use crate::{\n-    db::HirDatabase,\n-    traits::{InEnvironment, Solution},\n-    AliasEq, AliasTy, BoundVar, Canonical, CanonicalVarKinds, DebruijnIndex, Interner, Ty,\n-    TyBuilder, TyKind,\n+    db::HirDatabase, AliasEq, AliasTy, BoundVar, Canonical, CanonicalVarKinds, DebruijnIndex,\n+    InEnvironment, Interner, Solution, Ty, TyBuilder, TyKind,\n };\n \n const AUTODEREF_RECURSION_LIMIT: usize = 10;"}, {"sha": "0bac31e4ca4a52b801e8b73d20567a44502a620c", "filename": "crates/hir_ty/src/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs?ref=35614c762378f472ebefa12434b7e54a38a94eb9", "patch": "@@ -33,7 +33,7 @@ impl<D> TyBuilder<D> {\n     fn build_internal(self) -> (D, Substitution) {\n         assert_eq!(self.vec.len(), self.param_count);\n         // FIXME: would be good to have a way to construct a chalk_ir::Substitution from the interned form\n-        let subst = Substitution(self.vec);\n+        let subst = Substitution::intern(self.vec);\n         (self.data, subst)\n     }\n \n@@ -138,7 +138,7 @@ impl TyBuilder<hir_def::AdtId> {\n                 self.vec.push(fallback().cast(&Interner));\n             } else {\n                 // each default can depend on the previous parameters\n-                let subst_so_far = Substitution(self.vec.clone());\n+                let subst_so_far = Substitution::intern(self.vec.clone());\n                 self.vec.push(default_ty.clone().subst(&subst_so_far).cast(&Interner));\n             }\n         }"}, {"sha": "4300680d98f975ba7c80f93ef3bce63de9a6dde7", "filename": "crates/hir_ty/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdb.rs?ref=35614c762378f472ebefa12434b7e54a38a94eb9", "patch": "@@ -123,7 +123,7 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n         &self,\n         krate: CrateId,\n         goal: crate::Canonical<crate::InEnvironment<crate::DomainGoal>>,\n-    ) -> Option<crate::traits::Solution>;\n+    ) -> Option<crate::Solution>;\n \n     #[salsa::invoke(crate::traits::chalk::program_clauses_for_chalk_env_query)]\n     fn program_clauses_for_chalk_env("}, {"sha": "148eb7506266623a191690bcdd8cfea0d1507ab4", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=35614c762378f472ebefa12434b7e54a38a94eb9", "patch": "@@ -260,7 +260,7 @@ impl HirDisplay for ProjectionTy {\n         write!(f, \"<{} as {}\", first_parameter, trait_.name)?;\n         if self.substitution.len(&Interner) > 1 {\n             write!(f, \"<\")?;\n-            f.write_joined(&self.substitution.interned(&Interner)[1..], \", \")?;\n+            f.write_joined(&self.substitution.interned()[1..], \", \")?;\n             write!(f, \">\")?;\n         }\n         write!(f, \">::{}\", f.db.type_alias_data(from_assoc_type_id(self.associated_ty_id)).name)?;\n@@ -387,7 +387,7 @@ impl HirDisplay for Ty {\n                     write!(f, \",)\")?;\n                 } else {\n                     write!(f, \"(\")?;\n-                    f.write_joined(&*substs.0, \", \")?;\n+                    f.write_joined(&*substs.interned(), \", \")?;\n                     write!(f, \")\")?;\n                 }\n             }\n@@ -415,7 +415,7 @@ impl HirDisplay for Ty {\n                     // We print all params except implicit impl Trait params. Still a bit weird; should we leave out parent and self?\n                     if total_len > 0 {\n                         write!(f, \"<\")?;\n-                        f.write_joined(&parameters.0[..total_len], \", \")?;\n+                        f.write_joined(&parameters.interned()[..total_len], \", \")?;\n                         write!(f, \">\")?;\n                     }\n                 }\n@@ -468,7 +468,7 @@ impl HirDisplay for Ty {\n                             .map(|generic_def_id| f.db.generic_defaults(generic_def_id))\n                             .filter(|defaults| !defaults.is_empty())\n                         {\n-                            None => parameters.0.as_ref(),\n+                            None => parameters.interned().as_ref(),\n                             Some(default_parameters) => {\n                                 let mut default_from = 0;\n                                 for (i, parameter) in parameters.iter(&Interner).enumerate() {\n@@ -490,11 +490,11 @@ impl HirDisplay for Ty {\n                                         }\n                                     }\n                                 }\n-                                &parameters.0[0..default_from]\n+                                &parameters.interned()[0..default_from]\n                             }\n                         }\n                     } else {\n-                        parameters.0.as_ref()\n+                        parameters.interned().as_ref()\n                     };\n                     if !parameters_to_write.is_empty() {\n                         write!(f, \"<\")?;\n@@ -517,7 +517,7 @@ impl HirDisplay for Ty {\n                     write!(f, \"{}::{}\", trait_.name, type_alias_data.name)?;\n                     if parameters.len(&Interner) > 0 {\n                         write!(f, \"<\")?;\n-                        f.write_joined(&*parameters.0, \", \")?;\n+                        f.write_joined(&*parameters.interned(), \", \")?;\n                         write!(f, \">\")?;\n                     }\n                 } else {\n@@ -727,13 +727,13 @@ fn write_bounds_like_dyn_trait(\n                 // existential) here, which is the only thing that's\n                 // possible in actual Rust, and hence don't print it\n                 write!(f, \"{}\", f.db.trait_data(trait_).name)?;\n-                if let [_, params @ ..] = &*trait_ref.substitution.0 {\n+                if let [_, params @ ..] = &*trait_ref.substitution.interned() {\n                     if is_fn_trait {\n                         if let Some(args) =\n                             params.first().and_then(|it| it.assert_ty_ref(&Interner).as_tuple())\n                         {\n                             write!(f, \"(\")?;\n-                            f.write_joined(&*args.0, \", \")?;\n+                            f.write_joined(&*args.interned(), \", \")?;\n                             write!(f, \")\")?;\n                         }\n                     } else if !params.is_empty() {\n@@ -789,7 +789,7 @@ impl TraitRef {\n         write!(f, \"{}\", f.db.trait_data(self.hir_trait_id()).name)?;\n         if self.substitution.len(&Interner) > 1 {\n             write!(f, \"<\")?;\n-            f.write_joined(&self.substitution.interned(&Interner)[1..], \", \")?;\n+            f.write_joined(&self.substitution.interned()[1..], \", \")?;\n             write!(f, \">\")?;\n         }\n         Ok(())"}, {"sha": "bb885db350613ba87434e8ac032f259e2e003125", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=35614c762378f472ebefa12434b7e54a38a94eb9", "patch": "@@ -37,8 +37,8 @@ use stdx::impl_from;\n use syntax::SmolStr;\n \n use super::{\n-    traits::{DomainGoal, Guidance, Solution},\n-    InEnvironment, ProjectionTy, TraitEnvironment, TraitRef, Ty, TypeWalk,\n+    DomainGoal, Guidance, InEnvironment, ProjectionTy, Solution, TraitEnvironment, TraitRef, Ty,\n+    TypeWalk,\n };\n use crate::{\n     db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode,"}, {"sha": "32c273afcd308a5065f473a825ae2a171c6bbacd", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=35614c762378f472ebefa12434b7e54a38a94eb9", "patch": "@@ -7,7 +7,7 @@\n use chalk_ir::{cast::Cast, Mutability, TyVariableKind};\n use hir_def::lang_item::LangItemTarget;\n \n-use crate::{autoderef, traits::Solution, Interner, Ty, TyBuilder, TyKind};\n+use crate::{autoderef, Interner, Solution, Ty, TyBuilder, TyKind};\n \n use super::{InEnvironment, InferenceContext};\n "}, {"sha": "ccaae53e983e8fb43445830cfb6d15f5ef3a7087", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=35614c762378f472ebefa12434b7e54a38a94eb9", "patch": "@@ -20,10 +20,10 @@ use crate::{\n     method_resolution, op,\n     primitive::{self, UintTy},\n     to_chalk_trait_id,\n-    traits::{chalk::from_chalk, FnTrait, InEnvironment},\n+    traits::{chalk::from_chalk, FnTrait},\n     utils::{generics, variant_data, Generics},\n-    AdtId, Binders, CallableDefId, FnPointer, FnSig, Interner, Rawness, Scalar, Substitution,\n-    TraitRef, Ty, TyBuilder, TyKind,\n+    AdtId, Binders, CallableDefId, FnPointer, FnSig, InEnvironment, Interner, Rawness, Scalar,\n+    Substitution, TraitRef, Ty, TyBuilder, TyKind,\n };\n \n use super::{\n@@ -452,11 +452,7 @@ impl<'a> InferenceContext<'a> {\n                     };\n                     match canonicalized.decanonicalize_ty(derefed_ty.value).kind(&Interner) {\n                         TyKind::Tuple(_, substs) => name.as_tuple_index().and_then(|idx| {\n-                            substs\n-                                .interned(&Interner)\n-                                .get(idx)\n-                                .map(|a| a.assert_ty_ref(&Interner))\n-                                .cloned()\n+                            substs.interned().get(idx).map(|a| a.assert_ty_ref(&Interner)).cloned()\n                         }),\n                         TyKind::Adt(AdtId(hir_def::AdtId::StructId(s)), parameters) => {\n                             let local_id = self.db.struct_data(*s).variant_data.field(name)?;"}, {"sha": "469f37dd99512ea500acbdfb1bbb27b25a61dac1", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=35614c762378f472ebefa12434b7e54a38a94eb9", "patch": "@@ -123,7 +123,7 @@ impl<'a> InferenceContext<'a> {\n         let ty = match &body[pat] {\n             &Pat::Tuple { ref args, ellipsis } => {\n                 let expectations = match expected.as_tuple() {\n-                    Some(parameters) => &*parameters.0,\n+                    Some(parameters) => &*parameters.interned(),\n                     _ => &[],\n                 };\n \n@@ -239,7 +239,7 @@ impl<'a> InferenceContext<'a> {\n                     let (inner_ty, alloc_ty) = match expected.as_adt() {\n                         Some((adt, subst)) if adt == box_adt => (\n                             subst.at(&Interner, 0).assert_ty_ref(&Interner).clone(),\n-                            subst.interned(&Interner).get(1).and_then(|a| a.ty(&Interner).cloned()),\n+                            subst.interned().get(1).and_then(|a| a.ty(&Interner).cloned()),\n                         ),\n                         _ => (self.result.standard_types.unknown.clone(), None),\n                     };"}, {"sha": "637341b53ee42f14baf2ca66e53483efaa5134aa", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=35614c762378f472ebefa12434b7e54a38a94eb9", "patch": "@@ -98,7 +98,7 @@ impl<'a> InferenceContext<'a> {\n         let substs = ctx.substs_from_path(path, typable, true);\n         let ty = TyBuilder::value_ty(self.db, typable)\n             .use_parent_substs(&parent_substs)\n-            .fill(substs.interned(&Interner)[parent_substs.len(&Interner)..].iter().cloned())\n+            .fill(substs.interned()[parent_substs.len(&Interner)..].iter().cloned())\n             .build();\n         Some(ty)\n     }"}, {"sha": "b7bc4856998f3537e3698a972fc30436983e3683", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=35614c762378f472ebefa12434b7e54a38a94eb9", "patch": "@@ -284,7 +284,7 @@ impl InferenceTable {\n         substs2: &Substitution,\n         depth: usize,\n     ) -> bool {\n-        substs1.0.iter().zip(substs2.0.iter()).all(|(t1, t2)| {\n+        substs1.iter(&Interner).zip(substs2.iter(&Interner)).all(|(t1, t2)| {\n             self.unify_inner(t1.assert_ty_ref(&Interner), t2.assert_ty_ref(&Interner), depth)\n         })\n     }"}, {"sha": "76609e2dfb1c8a02d4e2bada1c12b6e3c1e90f4f", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 16, "deletions": 681, "changes": 697, "blob_url": "https://github.com/rust-lang/rust/blob/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=35614c762378f472ebefa12434b7e54a38a94eb9", "patch": "@@ -16,6 +16,8 @@ pub(crate) mod utils;\n mod chalk_cast;\n mod chalk_ext;\n mod builder;\n+mod walk;\n+mod types;\n \n pub mod display;\n pub mod db;\n@@ -26,23 +28,18 @@ mod tests;\n #[cfg(test)]\n mod test_db;\n \n-use std::{mem, sync::Arc};\n+use std::sync::Arc;\n \n-use chalk_ir::cast::{CastTo, Caster};\n use itertools::Itertools;\n use smallvec::SmallVec;\n \n use base_db::salsa;\n use hir_def::{\n-    expr::ExprId, type_ref::Rawness, AssocContainerId, FunctionId, GenericDefId, HasModule,\n-    LifetimeParamId, Lookup, TraitId, TypeAliasId, TypeParamId,\n+    expr::ExprId, type_ref::Rawness, AssocContainerId, FunctionId, GenericDefId, HasModule, Lookup,\n+    TraitId, TypeAliasId, TypeParamId,\n };\n \n-use crate::{\n-    db::HirDatabase,\n-    display::HirDisplay,\n-    utils::{generics, make_mut_slice},\n-};\n+use crate::{db::HirDatabase, display::HirDisplay, utils::generics};\n \n pub use autoderef::autoderef;\n pub use builder::TyBuilder;\n@@ -52,7 +49,9 @@ pub use lower::{\n     associated_type_shorthand_candidates, callable_item_sig, CallableDefId, ImplTraitLoweringMode,\n     TyDefId, TyLoweringContext, ValueTyDefId,\n };\n-pub use traits::{AliasEq, DomainGoal, InEnvironment, TraitEnvironment};\n+pub use traits::TraitEnvironment;\n+pub use types::*;\n+pub use walk::TypeWalk;\n \n pub use chalk_ir::{\n     cast::Cast, AdtId, BoundVar, DebruijnIndex, Mutability, Safety, Scalar, TyVariableKind,\n@@ -71,41 +70,6 @@ pub type CanonicalVarKinds = chalk_ir::CanonicalVarKinds<Interner>;\n \n pub type ChalkTraitId = chalk_ir::TraitId<Interner>;\n \n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum Lifetime {\n-    Parameter(LifetimeParamId),\n-    Static,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct OpaqueTy {\n-    pub opaque_ty_id: OpaqueTyId,\n-    pub substitution: Substitution,\n-}\n-\n-impl TypeWalk for OpaqueTy {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        self.substitution.walk(f);\n-    }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        self.substitution.walk_mut_binders(f, binders);\n-    }\n-}\n-\n-/// A \"projection\" type corresponds to an (unnormalized)\n-/// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n-/// trait and all its parameters are fully known.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct ProjectionTy {\n-    pub associated_ty_id: AssocTypeId,\n-    pub substitution: Substitution,\n-}\n-\n impl ProjectionTy {\n     pub fn trait_ref(&self, db: &dyn HirDatabase) -> TraitRef {\n         TraitRef {\n@@ -115,7 +79,7 @@ impl ProjectionTy {\n     }\n \n     pub fn self_type_parameter(&self) -> &Ty {\n-        &self.substitution.interned(&Interner)[0].assert_ty_ref(&Interner)\n+        &self.substitution.interned()[0].assert_ty_ref(&Interner)\n     }\n \n     fn trait_(&self, db: &dyn HirDatabase) -> TraitId {\n@@ -126,341 +90,25 @@ impl ProjectionTy {\n     }\n }\n \n-impl TypeWalk for ProjectionTy {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        self.substitution.walk(f);\n-    }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        self.substitution.walk_mut_binders(f, binders);\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct DynTy {\n-    /// The unknown self type.\n-    pub bounds: Binders<QuantifiedWhereClauses>,\n-}\n-\n pub type FnSig = chalk_ir::FnSig<Interner>;\n \n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct FnPointer {\n-    pub num_args: usize,\n-    pub sig: FnSig,\n-    pub substs: Substitution,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum AliasTy {\n-    /// A \"projection\" type corresponds to an (unnormalized)\n-    /// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n-    /// trait and all its parameters are fully known.\n-    Projection(ProjectionTy),\n-    /// An opaque type (`impl Trait`).\n-    ///\n-    /// This is currently only used for return type impl trait; each instance of\n-    /// `impl Trait` in a return type gets its own ID.\n-    Opaque(OpaqueTy),\n-}\n-\n-impl TypeWalk for AliasTy {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        match self {\n-            AliasTy::Projection(it) => it.walk(f),\n-            AliasTy::Opaque(it) => it.walk(f),\n-        }\n-    }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        match self {\n-            AliasTy::Projection(it) => it.walk_mut_binders(f, binders),\n-            AliasTy::Opaque(it) => it.walk_mut_binders(f, binders),\n-        }\n-    }\n-}\n-/// A type.\n-///\n-/// See also the `TyKind` enum in rustc (librustc/ty/sty.rs), which represents\n-/// the same thing (but in a different way).\n-///\n-/// This should be cheap to clone.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum TyKind {\n-    /// Structures, enumerations and unions.\n-    Adt(AdtId<Interner>, Substitution),\n-\n-    /// Represents an associated item like `Iterator::Item`.  This is used\n-    /// when we have tried to normalize a projection like `T::Item` but\n-    /// couldn't find a better representation.  In that case, we generate\n-    /// an **application type** like `(Iterator::Item)<T>`.\n-    AssociatedType(AssocTypeId, Substitution),\n-\n-    /// a scalar type like `bool` or `u32`\n-    Scalar(Scalar),\n-\n-    /// A tuple type.  For example, `(i32, bool)`.\n-    Tuple(usize, Substitution),\n-\n-    /// An array with the given length. Written as `[T; n]`.\n-    Array(Ty),\n-\n-    /// The pointee of an array slice.  Written as `[T]`.\n-    Slice(Ty),\n-\n-    /// A raw pointer. Written as `*mut T` or `*const T`\n-    Raw(Mutability, Ty),\n-\n-    /// A reference; a pointer with an associated lifetime. Written as\n-    /// `&'a mut T` or `&'a T`.\n-    Ref(Mutability, Ty),\n-\n-    /// This represents a placeholder for an opaque type in situations where we\n-    /// don't know the hidden type (i.e. currently almost always). This is\n-    /// analogous to the `AssociatedType` type constructor.\n-    /// It is also used as the type of async block, with one type parameter\n-    /// representing the Future::Output type.\n-    OpaqueType(OpaqueTyId, Substitution),\n-\n-    /// The anonymous type of a function declaration/definition. Each\n-    /// function has a unique type, which is output (for a function\n-    /// named `foo` returning an `i32`) as `fn() -> i32 {foo}`.\n-    ///\n-    /// This includes tuple struct / enum variant constructors as well.\n-    ///\n-    /// For example the type of `bar` here:\n-    ///\n-    /// ```\n-    /// fn foo() -> i32 { 1 }\n-    /// let bar = foo; // bar: fn() -> i32 {foo}\n-    /// ```\n-    FnDef(FnDefId, Substitution),\n-\n-    /// The pointee of a string slice. Written as `str`.\n-    Str,\n-\n-    /// The never type `!`.\n-    Never,\n-\n-    /// The type of a specific closure.\n-    ///\n-    /// The closure signature is stored in a `FnPtr` type in the first type\n-    /// parameter.\n-    Closure(ClosureId, Substitution),\n-\n-    /// Represents a foreign type declared in external blocks.\n-    ForeignType(ForeignDefId),\n-\n-    /// A pointer to a function.  Written as `fn() -> i32`.\n-    ///\n-    /// For example the type of `bar` here:\n-    ///\n-    /// ```\n-    /// fn foo() -> i32 { 1 }\n-    /// let bar: fn() -> i32 = foo;\n-    /// ```\n-    Function(FnPointer),\n-\n-    /// An \"alias\" type represents some form of type alias, such as:\n-    /// - An associated type projection like `<T as Iterator>::Item`\n-    /// - `impl Trait` types\n-    /// - Named type aliases like `type Foo<X> = Vec<X>`\n-    Alias(AliasTy),\n-\n-    /// A placeholder for a type parameter; for example, `T` in `fn f<T>(x: T)\n-    /// {}` when we're type-checking the body of that function. In this\n-    /// situation, we know this stands for *some* type, but don't know the exact\n-    /// type.\n-    Placeholder(PlaceholderIndex),\n-\n-    /// A bound type variable. This is used in various places: when representing\n-    /// some polymorphic type like the type of function `fn f<T>`, the type\n-    /// parameters get turned into variables; during trait resolution, inference\n-    /// variables get turned into bound variables and back; and in `Dyn` the\n-    /// `Self` type is represented with a bound variable as well.\n-    BoundVar(BoundVar),\n-\n-    /// A type variable used during type checking.\n-    InferenceVar(InferenceVar, TyVariableKind),\n-\n-    /// A trait object (`dyn Trait` or bare `Trait` in pre-2018 Rust).\n-    ///\n-    /// The predicates are quantified over the `Self` type, i.e. `Ty::Bound(0)`\n-    /// represents the `Self` type inside the bounds. This is currently\n-    /// implicit; Chalk has the `Binders` struct to make it explicit, but it\n-    /// didn't seem worth the overhead yet.\n-    Dyn(DynTy),\n-\n-    /// A placeholder for a type which could not be computed; this is propagated\n-    /// to avoid useless error messages. Doubles as a placeholder where type\n-    /// variables are inserted before type checking, since we want to try to\n-    /// infer a better type here anyway -- for the IDE use case, we want to try\n-    /// to infer as much as possible even in the presence of type errors.\n-    Unknown,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Ty(Arc<TyKind>);\n-\n-impl TyKind {\n-    pub fn intern(self, _interner: &Interner) -> Ty {\n-        Ty(Arc::new(self))\n-    }\n-}\n-\n-impl Ty {\n-    pub fn kind(&self, _interner: &Interner) -> &TyKind {\n-        &self.0\n-    }\n-\n-    pub fn interned_mut(&mut self) -> &mut TyKind {\n-        Arc::make_mut(&mut self.0)\n-    }\n-\n-    pub fn into_inner(self) -> TyKind {\n-        Arc::try_unwrap(self.0).unwrap_or_else(|a| (*a).clone())\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct GenericArg {\n-    interned: GenericArgData,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum GenericArgData {\n-    Ty(Ty),\n-}\n-\n-impl GenericArg {\n-    /// Constructs a generic argument using `GenericArgData`.\n-    pub fn new(_interner: &Interner, data: GenericArgData) -> Self {\n-        GenericArg { interned: data }\n-    }\n-\n-    /// Gets the interned value.\n-    pub fn interned(&self) -> &GenericArgData {\n-        &self.interned\n-    }\n-\n-    /// Asserts that this is a type argument.\n-    pub fn assert_ty_ref(&self, interner: &Interner) -> &Ty {\n-        self.ty(interner).unwrap()\n-    }\n-\n-    /// Checks whether the generic argument is a type.\n-    pub fn is_ty(&self, _interner: &Interner) -> bool {\n-        match self.interned() {\n-            GenericArgData::Ty(_) => true,\n-        }\n-    }\n-\n-    /// Returns the type if it is one, `None` otherwise.\n-    pub fn ty(&self, _interner: &Interner) -> Option<&Ty> {\n-        match self.interned() {\n-            GenericArgData::Ty(t) => Some(t),\n-        }\n-    }\n-}\n-\n-impl TypeWalk for GenericArg {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        match &self.interned {\n-            GenericArgData::Ty(ty) => {\n-                ty.walk(f);\n-            }\n-        }\n-    }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        match &mut self.interned {\n-            GenericArgData::Ty(ty) => {\n-                ty.walk_mut_binders(f, binders);\n-            }\n-        }\n-    }\n-}\n-\n-/// A list of substitutions for generic parameters.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Substitution(SmallVec<[GenericArg; 2]>);\n-\n-impl TypeWalk for Substitution {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        for t in self.0.iter() {\n-            t.walk(f);\n-        }\n-    }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        for t in &mut self.0 {\n-            t.walk_mut_binders(f, binders);\n-        }\n-    }\n-}\n-\n impl Substitution {\n-    pub fn interned(&self, _: &Interner) -> &[GenericArg] {\n-        &self.0\n-    }\n-\n-    pub fn len(&self, _: &Interner) -> usize {\n-        self.0.len()\n-    }\n-\n-    pub fn is_empty(&self, _: &Interner) -> bool {\n-        self.0.is_empty()\n-    }\n-\n-    pub fn at(&self, _: &Interner, i: usize) -> &GenericArg {\n-        &self.0[i]\n-    }\n-\n-    pub fn empty(_: &Interner) -> Substitution {\n-        Substitution(SmallVec::new())\n-    }\n-\n-    pub fn iter(&self, _: &Interner) -> std::slice::Iter<'_, GenericArg> {\n-        self.0.iter()\n-    }\n-\n     pub fn single(ty: Ty) -> Substitution {\n-        Substitution({\n+        Substitution::intern({\n             let mut v = SmallVec::new();\n             v.push(ty.cast(&Interner));\n             v\n         })\n     }\n \n     pub fn prefix(&self, n: usize) -> Substitution {\n-        Substitution(self.0[..std::cmp::min(self.0.len(), n)].into())\n+        Substitution::intern(self.interned()[..std::cmp::min(self.len(&Interner), n)].into())\n     }\n \n     pub fn suffix(&self, n: usize) -> Substitution {\n-        Substitution(self.0[self.0.len() - std::cmp::min(self.0.len(), n)..].into())\n-    }\n-\n-    pub fn from_iter(\n-        interner: &Interner,\n-        elements: impl IntoIterator<Item = impl CastTo<GenericArg>>,\n-    ) -> Self {\n-        Substitution(elements.into_iter().casted(interner).collect())\n+        Substitution::intern(\n+            self.interned()[self.len(&Interner) - std::cmp::min(self.len(&Interner), n)..].into(),\n+        )\n     }\n }\n \n@@ -469,12 +117,6 @@ pub fn param_idx(db: &dyn HirDatabase, id: TypeParamId) -> Option<usize> {\n     generics(db.upcast(), id.parent).param_idx(id)\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Binders<T> {\n-    pub num_binders: usize,\n-    pub value: T,\n-}\n-\n impl<T> Binders<T> {\n     pub fn new(num_binders: usize, value: T) -> Self {\n         Self { num_binders, value }\n@@ -522,27 +164,6 @@ impl<T: TypeWalk> Binders<T> {\n     }\n }\n \n-impl<T: TypeWalk> TypeWalk for Binders<T> {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        self.value.walk(f);\n-    }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        self.value.walk_mut_binders(f, binders.shifted_in())\n-    }\n-}\n-\n-/// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct TraitRef {\n-    pub trait_id: ChalkTraitId,\n-    pub substitution: Substitution,\n-}\n-\n impl TraitRef {\n     pub fn self_type_parameter(&self) -> &Ty {\n         &self.substitution.at(&Interner, 0).assert_ty_ref(&Interner)\n@@ -553,30 +174,6 @@ impl TraitRef {\n     }\n }\n \n-impl TypeWalk for TraitRef {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        self.substitution.walk(f);\n-    }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        self.substitution.walk_mut_binders(f, binders);\n-    }\n-}\n-\n-/// Like `generics::WherePredicate`, but with resolved types: A condition on the\n-/// parameters of a generic item.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum WhereClause {\n-    /// The given trait needs to be implemented for its type parameters.\n-    Implemented(TraitRef),\n-    /// An associated type bindings like in `Iterator<Item = T>`.\n-    AliasEq(AliasEq),\n-}\n-\n impl WhereClause {\n     pub fn is_implemented(&self) -> bool {\n         matches!(self, WhereClause::Implemented(_))\n@@ -593,56 +190,6 @@ impl WhereClause {\n     }\n }\n \n-impl TypeWalk for WhereClause {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        match self {\n-            WhereClause::Implemented(trait_ref) => trait_ref.walk(f),\n-            WhereClause::AliasEq(alias_eq) => alias_eq.walk(f),\n-        }\n-    }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        match self {\n-            WhereClause::Implemented(trait_ref) => trait_ref.walk_mut_binders(f, binders),\n-            WhereClause::AliasEq(alias_eq) => alias_eq.walk_mut_binders(f, binders),\n-        }\n-    }\n-}\n-\n-pub type QuantifiedWhereClause = Binders<WhereClause>;\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct QuantifiedWhereClauses(Arc<[QuantifiedWhereClause]>);\n-\n-impl QuantifiedWhereClauses {\n-    pub fn from_iter(\n-        _interner: &Interner,\n-        elements: impl IntoIterator<Item = QuantifiedWhereClause>,\n-    ) -> Self {\n-        QuantifiedWhereClauses(elements.into_iter().collect())\n-    }\n-\n-    pub fn interned(&self) -> &Arc<[QuantifiedWhereClause]> {\n-        &self.0\n-    }\n-}\n-\n-/// Basically a claim (currently not validated / checked) that the contained\n-/// type / trait ref contains no inference variables; any inference variables it\n-/// contained have been replaced by bound variables, and `kinds` tells us how\n-/// many there are and whether they were normal or float/int variables. This is\n-/// used to erase irrelevant differences between types before using them in\n-/// queries.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Canonical<T> {\n-    pub value: T,\n-    pub binders: CanonicalVarKinds,\n-}\n-\n impl<T> Canonical<T> {\n     pub fn new(value: T, kinds: impl IntoIterator<Item = TyVariableKind>) -> Self {\n         let kinds = kinds.into_iter().map(|tk| {\n@@ -679,7 +226,7 @@ impl CallableSig {\n                 .substs\n                 .clone()\n                 .shift_bound_vars_out(DebruijnIndex::ONE)\n-                .interned(&Interner)\n+                .interned()\n                 .iter()\n                 .map(|arg| arg.assert_ty_ref(&Interner).clone())\n                 .collect(),\n@@ -696,24 +243,6 @@ impl CallableSig {\n     }\n }\n \n-impl TypeWalk for CallableSig {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        for t in self.params_and_return.iter() {\n-            t.walk(f);\n-        }\n-    }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        for t in make_mut_slice(&mut self.params_and_return) {\n-            t.walk_mut_binders(f, binders);\n-        }\n-    }\n-}\n-\n impl Ty {\n     pub fn as_reference(&self) -> Option<(&Ty, Mutability)> {\n         match self.kind(&Interner) {\n@@ -984,200 +513,6 @@ impl Ty {\n     }\n }\n \n-/// This allows walking structures that contain types to do something with those\n-/// types, similar to Chalk's `Fold` trait.\n-pub trait TypeWalk {\n-    fn walk(&self, f: &mut impl FnMut(&Ty));\n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        self.walk_mut_binders(&mut |ty, _binders| f(ty), DebruijnIndex::INNERMOST);\n-    }\n-    /// Walk the type, counting entered binders.\n-    ///\n-    /// `TyKind::Bound` variables use DeBruijn indexing, which means that 0 refers\n-    /// to the innermost binder, 1 to the next, etc.. So when we want to\n-    /// substitute a certain bound variable, we can't just walk the whole type\n-    /// and blindly replace each instance of a certain index; when we 'enter'\n-    /// things that introduce new bound variables, we have to keep track of\n-    /// that. Currently, the only thing that introduces bound variables on our\n-    /// side are `TyKind::Dyn` and `TyKind::Opaque`, which each introduce a bound\n-    /// variable for the self type.\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    );\n-\n-    fn fold_binders(\n-        mut self,\n-        f: &mut impl FnMut(Ty, DebruijnIndex) -> Ty,\n-        binders: DebruijnIndex,\n-    ) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.walk_mut_binders(\n-            &mut |ty_mut, binders| {\n-                let ty = mem::replace(ty_mut, TyKind::Unknown.intern(&Interner));\n-                *ty_mut = f(ty, binders);\n-            },\n-            binders,\n-        );\n-        self\n-    }\n-\n-    fn fold(mut self, f: &mut impl FnMut(Ty) -> Ty) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.walk_mut(&mut |ty_mut| {\n-            let ty = mem::replace(ty_mut, TyKind::Unknown.intern(&Interner));\n-            *ty_mut = f(ty);\n-        });\n-        self\n-    }\n-\n-    /// Substitutes `TyKind::Bound` vars with the given substitution.\n-    fn subst_bound_vars(self, substs: &Substitution) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.subst_bound_vars_at_depth(substs, DebruijnIndex::INNERMOST)\n-    }\n-\n-    /// Substitutes `TyKind::Bound` vars with the given substitution.\n-    fn subst_bound_vars_at_depth(mut self, substs: &Substitution, depth: DebruijnIndex) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.walk_mut_binders(\n-            &mut |ty, binders| {\n-                if let &mut TyKind::BoundVar(bound) = ty.interned_mut() {\n-                    if bound.debruijn >= binders {\n-                        *ty = substs.0[bound.index]\n-                            .assert_ty_ref(&Interner)\n-                            .clone()\n-                            .shift_bound_vars(binders);\n-                    }\n-                }\n-            },\n-            depth,\n-        );\n-        self\n-    }\n-\n-    /// Shifts up debruijn indices of `TyKind::Bound` vars by `n`.\n-    fn shift_bound_vars(self, n: DebruijnIndex) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.fold_binders(\n-            &mut |ty, binders| match ty.kind(&Interner) {\n-                TyKind::BoundVar(bound) if bound.debruijn >= binders => {\n-                    TyKind::BoundVar(bound.shifted_in_from(n)).intern(&Interner)\n-                }\n-                _ => ty,\n-            },\n-            DebruijnIndex::INNERMOST,\n-        )\n-    }\n-\n-    /// Shifts debruijn indices of `TyKind::Bound` vars out (down) by `n`.\n-    fn shift_bound_vars_out(self, n: DebruijnIndex) -> Self\n-    where\n-        Self: Sized + std::fmt::Debug,\n-    {\n-        self.fold_binders(\n-            &mut |ty, binders| match ty.kind(&Interner) {\n-                TyKind::BoundVar(bound) if bound.debruijn >= binders => {\n-                    TyKind::BoundVar(bound.shifted_out_to(n).unwrap_or(bound.clone()))\n-                        .intern(&Interner)\n-                }\n-                _ => ty,\n-            },\n-            DebruijnIndex::INNERMOST,\n-        )\n-    }\n-}\n-\n-impl TypeWalk for Ty {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        match self.kind(&Interner) {\n-            TyKind::Alias(AliasTy::Projection(p_ty)) => {\n-                for t in p_ty.substitution.iter(&Interner) {\n-                    t.walk(f);\n-                }\n-            }\n-            TyKind::Alias(AliasTy::Opaque(o_ty)) => {\n-                for t in o_ty.substitution.iter(&Interner) {\n-                    t.walk(f);\n-                }\n-            }\n-            TyKind::Dyn(dyn_ty) => {\n-                for p in dyn_ty.bounds.value.interned().iter() {\n-                    p.walk(f);\n-                }\n-            }\n-            TyKind::Slice(ty) | TyKind::Array(ty) | TyKind::Ref(_, ty) | TyKind::Raw(_, ty) => {\n-                ty.walk(f);\n-            }\n-            _ => {\n-                if let Some(substs) = self.substs() {\n-                    for t in substs.iter(&Interner) {\n-                        t.walk(f);\n-                    }\n-                }\n-            }\n-        }\n-        f(self);\n-    }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        match self.interned_mut() {\n-            TyKind::Alias(AliasTy::Projection(p_ty)) => {\n-                p_ty.substitution.walk_mut_binders(f, binders);\n-            }\n-            TyKind::Dyn(dyn_ty) => {\n-                for p in make_mut_slice(&mut dyn_ty.bounds.value.0) {\n-                    p.walk_mut_binders(f, binders.shifted_in());\n-                }\n-            }\n-            TyKind::Alias(AliasTy::Opaque(o_ty)) => {\n-                o_ty.substitution.walk_mut_binders(f, binders);\n-            }\n-            TyKind::Slice(ty) | TyKind::Array(ty) | TyKind::Ref(_, ty) | TyKind::Raw(_, ty) => {\n-                ty.walk_mut_binders(f, binders);\n-            }\n-            _ => {\n-                if let Some(substs) = self.substs_mut() {\n-                    substs.walk_mut_binders(f, binders);\n-                }\n-            }\n-        }\n-        f(self, binders);\n-    }\n-}\n-\n-impl<T: TypeWalk> TypeWalk for Vec<T> {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        for t in self {\n-            t.walk(f);\n-        }\n-    }\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        for t in self {\n-            t.walk_mut_binders(f, binders);\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub enum ImplTraitId {\n     ReturnTypeImplTrait(hir_def::FunctionId, u16),"}, {"sha": "0e4a620b612099fdee38d4ff5d6157a32a4f1ebd", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=35614c762378f472ebefa12434b7e54a38a94eb9", "patch": "@@ -800,7 +800,7 @@ pub fn implements_trait_unique(\n     let goal = generic_implements_goal(db, env, trait_, ty.clone());\n     let solution = db.trait_solve(krate, goal);\n \n-    matches!(solution, Some(crate::traits::Solution::Unique(_)))\n+    matches!(solution, Some(crate::Solution::Unique(_)))\n }\n \n /// This creates Substs for a trait with the given Self type and type variables"}, {"sha": "66d600bfc18976a7493f2333d162307f2e2837ea", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 2, "deletions": 86, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=35614c762378f472ebefa12434b7e54a38a94eb9", "patch": "@@ -8,8 +8,8 @@ use hir_def::{lang_item::LangItemTarget, TraitId};\n use stdx::panic_context;\n \n use crate::{\n-    db::HirDatabase, AliasTy, Canonical, DebruijnIndex, HirDisplay, Substitution, Ty, TyKind,\n-    TypeWalk, WhereClause,\n+    db::HirDatabase, AliasEq, AliasTy, Canonical, DomainGoal, Guidance, HirDisplay, InEnvironment,\n+    Solution, SolutionVariables, Ty, TyKind, WhereClause,\n };\n \n use self::chalk::{from_chalk, Interner, ToChalk};\n@@ -70,55 +70,6 @@ impl Default for TraitEnvironment {\n     }\n }\n \n-/// Something (usually a goal), along with an environment.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct InEnvironment<T> {\n-    pub environment: chalk_ir::Environment<Interner>,\n-    pub goal: T,\n-}\n-\n-impl<T> InEnvironment<T> {\n-    pub fn new(environment: chalk_ir::Environment<Interner>, value: T) -> InEnvironment<T> {\n-        InEnvironment { environment, goal: value }\n-    }\n-}\n-\n-/// Something that needs to be proven (by Chalk) during type checking, e.g. that\n-/// a certain type implements a certain trait. Proving the Obligation might\n-/// result in additional information about inference variables.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum DomainGoal {\n-    Holds(WhereClause),\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct AliasEq {\n-    pub alias: AliasTy,\n-    pub ty: Ty,\n-}\n-\n-impl TypeWalk for AliasEq {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        self.ty.walk(f);\n-        match &self.alias {\n-            AliasTy::Projection(projection_ty) => projection_ty.walk(f),\n-            AliasTy::Opaque(opaque) => opaque.walk(f),\n-        }\n-    }\n-\n-    fn walk_mut_binders(\n-        &mut self,\n-        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n-        binders: DebruijnIndex,\n-    ) {\n-        self.ty.walk_mut_binders(f, binders);\n-        match &mut self.alias {\n-            AliasTy::Projection(projection_ty) => projection_ty.walk_mut_binders(f, binders),\n-            AliasTy::Opaque(opaque) => opaque.walk_mut_binders(f, binders),\n-        }\n-    }\n-}\n-\n /// Solve a trait goal using Chalk.\n pub(crate) fn trait_solve_query(\n     db: &dyn HirDatabase,\n@@ -246,41 +197,6 @@ fn solution_from_chalk(\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub struct SolutionVariables(pub Canonical<Substitution>);\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-/// A (possible) solution for a proposed goal.\n-pub enum Solution {\n-    /// The goal indeed holds, and there is a unique value for all existential\n-    /// variables.\n-    Unique(SolutionVariables),\n-\n-    /// The goal may be provable in multiple ways, but regardless we may have some guidance\n-    /// for type inference. In this case, we don't return any lifetime\n-    /// constraints, since we have not \"committed\" to any particular solution\n-    /// yet.\n-    Ambig(Guidance),\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-/// When a goal holds ambiguously (e.g., because there are multiple possible\n-/// solutions), we issue a set of *guidance* back to type inference.\n-pub enum Guidance {\n-    /// The existential variables *must* have the given values if the goal is\n-    /// ever to hold, but that alone isn't enough to guarantee the goal will\n-    /// actually hold.\n-    Definite(SolutionVariables),\n-\n-    /// There are multiple plausible values for the existentials, but the ones\n-    /// here are suggested as the preferred choice heuristically. These should\n-    /// be used for inference fallback only.\n-    Suggested(SolutionVariables),\n-\n-    /// There's no useful information to feed back to type inference\n-    Unknown,\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum FnTrait {\n     FnOnce,"}, {"sha": "5e4f97a46f8f47943ea785e8a9e4a73bb5cccd3d", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=35614c762378f472ebefa12434b7e54a38a94eb9", "patch": "@@ -10,11 +10,9 @@ use base_db::salsa::InternKey;\n use hir_def::{GenericDefId, TypeAliasId};\n \n use crate::{\n-    db::HirDatabase,\n-    primitive::UintTy,\n-    traits::{Canonical, DomainGoal},\n-    AliasTy, CallableDefId, FnPointer, GenericArg, InEnvironment, OpaqueTy, ProjectionTy,\n-    QuantifiedWhereClause, Scalar, Substitution, TraitRef, Ty, TypeWalk, WhereClause,\n+    db::HirDatabase, primitive::UintTy, AliasTy, CallableDefId, Canonical, DomainGoal, FnPointer,\n+    GenericArg, InEnvironment, OpaqueTy, ProjectionTy, QuantifiedWhereClause, Scalar, Substitution,\n+    TraitRef, Ty, TypeWalk, WhereClause,\n };\n \n use super::interner::*;\n@@ -220,8 +218,8 @@ impl ToChalk for GenericArg {\n     type Chalk = chalk_ir::GenericArg<Interner>;\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> Self::Chalk {\n-        match self.interned {\n-            crate::GenericArgData::Ty(ty) => ty.to_chalk(db).cast(&Interner),\n+        match self.interned() {\n+            crate::GenericArgData::Ty(ty) => ty.clone().to_chalk(db).cast(&Interner),\n         }\n     }\n \n@@ -249,7 +247,7 @@ impl ToChalk for Substitution {\n         parameters: chalk_ir::Substitution<Interner>,\n     ) -> Substitution {\n         let tys = parameters.iter(&Interner).map(|p| from_chalk(db, p.clone())).collect();\n-        Substitution(tys)\n+        Substitution::intern(tys)\n     }\n }\n \n@@ -546,7 +544,7 @@ pub(super) fn generic_predicate_to_inline_bound(\n                 // have the expected self type\n                 return None;\n             }\n-            let args_no_self = trait_ref.substitution.interned(&Interner)[1..]\n+            let args_no_self = trait_ref.substitution.interned()[1..]\n                 .iter()\n                 .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n                 .collect();\n@@ -558,7 +556,7 @@ pub(super) fn generic_predicate_to_inline_bound(\n                 return None;\n             }\n             let trait_ = projection_ty.trait_(db);\n-            let args_no_self = projection_ty.substitution.interned(&Interner)[1..]\n+            let args_no_self = projection_ty.substitution.interned()[1..]\n                 .iter()\n                 .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n                 .collect();"}, {"sha": "53662fcdcc7faabda1e18726a06147e2c7fb5740", "filename": "crates/hir_ty/src/types.rs", "status": "added", "additions": 416, "deletions": 0, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftypes.rs?ref=35614c762378f472ebefa12434b7e54a38a94eb9", "patch": "@@ -0,0 +1,416 @@\n+//! This is the home of `Ty` etc. until they get replaced by their chalk_ir\n+//! equivalents.\n+\n+use std::sync::Arc;\n+\n+use chalk_ir::{\n+    cast::{CastTo, Caster},\n+    BoundVar, Mutability, Scalar, TyVariableKind,\n+};\n+use hir_def::LifetimeParamId;\n+use smallvec::SmallVec;\n+\n+use crate::{\n+    AssocTypeId, CanonicalVarKinds, ChalkTraitId, ClosureId, FnDefId, FnSig, ForeignDefId,\n+    InferenceVar, Interner, OpaqueTyId, PlaceholderIndex,\n+};\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum Lifetime {\n+    Parameter(LifetimeParamId),\n+    Static,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct OpaqueTy {\n+    pub opaque_ty_id: OpaqueTyId,\n+    pub substitution: Substitution,\n+}\n+\n+/// A \"projection\" type corresponds to an (unnormalized)\n+/// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n+/// trait and all its parameters are fully known.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct ProjectionTy {\n+    pub associated_ty_id: AssocTypeId,\n+    pub substitution: Substitution,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct DynTy {\n+    /// The unknown self type.\n+    pub bounds: Binders<QuantifiedWhereClauses>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct FnPointer {\n+    pub num_args: usize,\n+    pub sig: FnSig,\n+    pub substs: Substitution,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum AliasTy {\n+    /// A \"projection\" type corresponds to an (unnormalized)\n+    /// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n+    /// trait and all its parameters are fully known.\n+    Projection(ProjectionTy),\n+    /// An opaque type (`impl Trait`).\n+    ///\n+    /// This is currently only used for return type impl trait; each instance of\n+    /// `impl Trait` in a return type gets its own ID.\n+    Opaque(OpaqueTy),\n+}\n+\n+/// A type.\n+///\n+/// See also the `TyKind` enum in rustc (librustc/ty/sty.rs), which represents\n+/// the same thing (but in a different way).\n+///\n+/// This should be cheap to clone.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum TyKind {\n+    /// Structures, enumerations and unions.\n+    Adt(chalk_ir::AdtId<Interner>, Substitution),\n+\n+    /// Represents an associated item like `Iterator::Item`.  This is used\n+    /// when we have tried to normalize a projection like `T::Item` but\n+    /// couldn't find a better representation.  In that case, we generate\n+    /// an **application type** like `(Iterator::Item)<T>`.\n+    AssociatedType(AssocTypeId, Substitution),\n+\n+    /// a scalar type like `bool` or `u32`\n+    Scalar(Scalar),\n+\n+    /// A tuple type.  For example, `(i32, bool)`.\n+    Tuple(usize, Substitution),\n+\n+    /// An array with the given length. Written as `[T; n]`.\n+    Array(Ty),\n+\n+    /// The pointee of an array slice.  Written as `[T]`.\n+    Slice(Ty),\n+\n+    /// A raw pointer. Written as `*mut T` or `*const T`\n+    Raw(Mutability, Ty),\n+\n+    /// A reference; a pointer with an associated lifetime. Written as\n+    /// `&'a mut T` or `&'a T`.\n+    Ref(Mutability, Ty),\n+\n+    /// This represents a placeholder for an opaque type in situations where we\n+    /// don't know the hidden type (i.e. currently almost always). This is\n+    /// analogous to the `AssociatedType` type constructor.\n+    /// It is also used as the type of async block, with one type parameter\n+    /// representing the Future::Output type.\n+    OpaqueType(OpaqueTyId, Substitution),\n+\n+    /// The anonymous type of a function declaration/definition. Each\n+    /// function has a unique type, which is output (for a function\n+    /// named `foo` returning an `i32`) as `fn() -> i32 {foo}`.\n+    ///\n+    /// This includes tuple struct / enum variant constructors as well.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar = foo; // bar: fn() -> i32 {foo}\n+    /// ```\n+    FnDef(FnDefId, Substitution),\n+\n+    /// The pointee of a string slice. Written as `str`.\n+    Str,\n+\n+    /// The never type `!`.\n+    Never,\n+\n+    /// The type of a specific closure.\n+    ///\n+    /// The closure signature is stored in a `FnPtr` type in the first type\n+    /// parameter.\n+    Closure(ClosureId, Substitution),\n+\n+    /// Represents a foreign type declared in external blocks.\n+    ForeignType(ForeignDefId),\n+\n+    /// A pointer to a function.  Written as `fn() -> i32`.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar: fn() -> i32 = foo;\n+    /// ```\n+    Function(FnPointer),\n+\n+    /// An \"alias\" type represents some form of type alias, such as:\n+    /// - An associated type projection like `<T as Iterator>::Item`\n+    /// - `impl Trait` types\n+    /// - Named type aliases like `type Foo<X> = Vec<X>`\n+    Alias(AliasTy),\n+\n+    /// A placeholder for a type parameter; for example, `T` in `fn f<T>(x: T)\n+    /// {}` when we're type-checking the body of that function. In this\n+    /// situation, we know this stands for *some* type, but don't know the exact\n+    /// type.\n+    Placeholder(PlaceholderIndex),\n+\n+    /// A bound type variable. This is used in various places: when representing\n+    /// some polymorphic type like the type of function `fn f<T>`, the type\n+    /// parameters get turned into variables; during trait resolution, inference\n+    /// variables get turned into bound variables and back; and in `Dyn` the\n+    /// `Self` type is represented with a bound variable as well.\n+    BoundVar(BoundVar),\n+\n+    /// A type variable used during type checking.\n+    InferenceVar(InferenceVar, TyVariableKind),\n+\n+    /// A trait object (`dyn Trait` or bare `Trait` in pre-2018 Rust).\n+    ///\n+    /// The predicates are quantified over the `Self` type, i.e. `Ty::Bound(0)`\n+    /// represents the `Self` type inside the bounds. This is currently\n+    /// implicit; Chalk has the `Binders` struct to make it explicit, but it\n+    /// didn't seem worth the overhead yet.\n+    Dyn(DynTy),\n+\n+    /// A placeholder for a type which could not be computed; this is propagated\n+    /// to avoid useless error messages. Doubles as a placeholder where type\n+    /// variables are inserted before type checking, since we want to try to\n+    /// infer a better type here anyway -- for the IDE use case, we want to try\n+    /// to infer as much as possible even in the presence of type errors.\n+    Unknown,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct Ty(Arc<TyKind>);\n+\n+impl TyKind {\n+    pub fn intern(self, _interner: &Interner) -> Ty {\n+        Ty(Arc::new(self))\n+    }\n+}\n+\n+impl Ty {\n+    pub fn kind(&self, _interner: &Interner) -> &TyKind {\n+        &self.0\n+    }\n+\n+    pub fn interned_mut(&mut self) -> &mut TyKind {\n+        Arc::make_mut(&mut self.0)\n+    }\n+\n+    pub fn into_inner(self) -> TyKind {\n+        Arc::try_unwrap(self.0).unwrap_or_else(|a| (*a).clone())\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct GenericArg {\n+    interned: GenericArgData,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum GenericArgData {\n+    Ty(Ty),\n+}\n+\n+impl GenericArg {\n+    /// Constructs a generic argument using `GenericArgData`.\n+    pub fn new(_interner: &Interner, data: GenericArgData) -> Self {\n+        GenericArg { interned: data }\n+    }\n+\n+    /// Gets the interned value.\n+    pub fn interned(&self) -> &GenericArgData {\n+        &self.interned\n+    }\n+\n+    /// Asserts that this is a type argument.\n+    pub fn assert_ty_ref(&self, interner: &Interner) -> &Ty {\n+        self.ty(interner).unwrap()\n+    }\n+\n+    /// Checks whether the generic argument is a type.\n+    pub fn is_ty(&self, _interner: &Interner) -> bool {\n+        match self.interned() {\n+            GenericArgData::Ty(_) => true,\n+        }\n+    }\n+\n+    /// Returns the type if it is one, `None` otherwise.\n+    pub fn ty(&self, _interner: &Interner) -> Option<&Ty> {\n+        match self.interned() {\n+            GenericArgData::Ty(t) => Some(t),\n+        }\n+    }\n+\n+    pub fn interned_mut(&mut self) -> &mut GenericArgData {\n+        &mut self.interned\n+    }\n+}\n+\n+/// A list of substitutions for generic parameters.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct Substitution(SmallVec<[GenericArg; 2]>);\n+\n+impl Substitution {\n+    pub fn interned(&self) -> &[GenericArg] {\n+        &self.0\n+    }\n+\n+    pub fn len(&self, _: &Interner) -> usize {\n+        self.0.len()\n+    }\n+\n+    pub fn is_empty(&self, _: &Interner) -> bool {\n+        self.0.is_empty()\n+    }\n+\n+    pub fn at(&self, _: &Interner, i: usize) -> &GenericArg {\n+        &self.0[i]\n+    }\n+\n+    pub fn empty(_: &Interner) -> Substitution {\n+        Substitution(SmallVec::new())\n+    }\n+\n+    pub fn iter(&self, _: &Interner) -> std::slice::Iter<'_, GenericArg> {\n+        self.0.iter()\n+    }\n+\n+    pub fn from_iter(\n+        interner: &Interner,\n+        elements: impl IntoIterator<Item = impl CastTo<GenericArg>>,\n+    ) -> Self {\n+        Substitution(elements.into_iter().casted(interner).collect())\n+    }\n+\n+    // We can hopefully add this to Chalk\n+    pub fn intern(interned: SmallVec<[GenericArg; 2]>) -> Substitution {\n+        Substitution(interned)\n+    }\n+\n+    pub fn interned_mut(&mut self) -> &mut SmallVec<[GenericArg; 2]> {\n+        &mut self.0\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct Binders<T> {\n+    pub num_binders: usize,\n+    pub value: T,\n+}\n+\n+/// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct TraitRef {\n+    pub trait_id: ChalkTraitId,\n+    pub substitution: Substitution,\n+}\n+\n+/// Like `generics::WherePredicate`, but with resolved types: A condition on the\n+/// parameters of a generic item.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum WhereClause {\n+    /// The given trait needs to be implemented for its type parameters.\n+    Implemented(TraitRef),\n+    /// An associated type bindings like in `Iterator<Item = T>`.\n+    AliasEq(AliasEq),\n+}\n+\n+pub type QuantifiedWhereClause = Binders<WhereClause>;\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct QuantifiedWhereClauses(Arc<[QuantifiedWhereClause]>);\n+\n+impl QuantifiedWhereClauses {\n+    pub fn from_iter(\n+        _interner: &Interner,\n+        elements: impl IntoIterator<Item = QuantifiedWhereClause>,\n+    ) -> Self {\n+        QuantifiedWhereClauses(elements.into_iter().collect())\n+    }\n+\n+    pub fn interned(&self) -> &Arc<[QuantifiedWhereClause]> {\n+        &self.0\n+    }\n+\n+    pub fn interned_mut(&mut self) -> &mut Arc<[QuantifiedWhereClause]> {\n+        &mut self.0\n+    }\n+}\n+\n+/// Basically a claim (currently not validated / checked) that the contained\n+/// type / trait ref contains no inference variables; any inference variables it\n+/// contained have been replaced by bound variables, and `kinds` tells us how\n+/// many there are and whether they were normal or float/int variables. This is\n+/// used to erase irrelevant differences between types before using them in\n+/// queries.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Canonical<T> {\n+    pub value: T,\n+    pub binders: CanonicalVarKinds,\n+}\n+\n+/// Something (usually a goal), along with an environment.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct InEnvironment<T> {\n+    pub environment: chalk_ir::Environment<Interner>,\n+    pub goal: T,\n+}\n+\n+impl<T> InEnvironment<T> {\n+    pub fn new(environment: chalk_ir::Environment<Interner>, value: T) -> InEnvironment<T> {\n+        InEnvironment { environment, goal: value }\n+    }\n+}\n+\n+/// Something that needs to be proven (by Chalk) during type checking, e.g. that\n+/// a certain type implements a certain trait. Proving the Obligation might\n+/// result in additional information about inference variables.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum DomainGoal {\n+    Holds(WhereClause),\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct AliasEq {\n+    pub alias: AliasTy,\n+    pub ty: Ty,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct SolutionVariables(pub Canonical<Substitution>);\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+/// A (possible) solution for a proposed goal.\n+pub enum Solution {\n+    /// The goal indeed holds, and there is a unique value for all existential\n+    /// variables.\n+    Unique(SolutionVariables),\n+\n+    /// The goal may be provable in multiple ways, but regardless we may have some guidance\n+    /// for type inference. In this case, we don't return any lifetime\n+    /// constraints, since we have not \"committed\" to any particular solution\n+    /// yet.\n+    Ambig(Guidance),\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+/// When a goal holds ambiguously (e.g., because there are multiple possible\n+/// solutions), we issue a set of *guidance* back to type inference.\n+pub enum Guidance {\n+    /// The existential variables *must* have the given values if the goal is\n+    /// ever to hold, but that alone isn't enough to guarantee the goal will\n+    /// actually hold.\n+    Definite(SolutionVariables),\n+\n+    /// There are multiple plausible values for the existentials, but the ones\n+    /// here are suggested as the preferred choice heuristically. These should\n+    /// be used for inference fallback only.\n+    Suggested(SolutionVariables),\n+\n+    /// There's no useful information to feed back to type inference\n+    Unknown,\n+}"}, {"sha": "bfb3f1041eeca276e8536264e6961698b78ab4b0", "filename": "crates/hir_ty/src/walk.rs", "status": "added", "additions": 381, "deletions": 0, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35614c762378f472ebefa12434b7e54a38a94eb9/crates%2Fhir_ty%2Fsrc%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fwalk.rs?ref=35614c762378f472ebefa12434b7e54a38a94eb9", "patch": "@@ -0,0 +1,381 @@\n+//! The `TypeWalk` trait (probably to be replaced by Chalk's `Fold` and\n+//! `Visit`).\n+\n+use std::mem;\n+\n+use chalk_ir::DebruijnIndex;\n+\n+use crate::{\n+    utils::make_mut_slice, AliasEq, AliasTy, Binders, CallableSig, GenericArg, GenericArgData,\n+    Interner, OpaqueTy, ProjectionTy, Substitution, TraitRef, Ty, TyKind, WhereClause,\n+};\n+\n+/// This allows walking structures that contain types to do something with those\n+/// types, similar to Chalk's `Fold` trait.\n+pub trait TypeWalk {\n+    fn walk(&self, f: &mut impl FnMut(&Ty));\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+        self.walk_mut_binders(&mut |ty, _binders| f(ty), DebruijnIndex::INNERMOST);\n+    }\n+    /// Walk the type, counting entered binders.\n+    ///\n+    /// `TyKind::Bound` variables use DeBruijn indexing, which means that 0 refers\n+    /// to the innermost binder, 1 to the next, etc.. So when we want to\n+    /// substitute a certain bound variable, we can't just walk the whole type\n+    /// and blindly replace each instance of a certain index; when we 'enter'\n+    /// things that introduce new bound variables, we have to keep track of\n+    /// that. Currently, the only thing that introduces bound variables on our\n+    /// side are `TyKind::Dyn` and `TyKind::Opaque`, which each introduce a bound\n+    /// variable for the self type.\n+    fn walk_mut_binders(\n+        &mut self,\n+        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n+        binders: DebruijnIndex,\n+    );\n+\n+    fn fold_binders(\n+        mut self,\n+        f: &mut impl FnMut(Ty, DebruijnIndex) -> Ty,\n+        binders: DebruijnIndex,\n+    ) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.walk_mut_binders(\n+            &mut |ty_mut, binders| {\n+                let ty = mem::replace(ty_mut, TyKind::Unknown.intern(&Interner));\n+                *ty_mut = f(ty, binders);\n+            },\n+            binders,\n+        );\n+        self\n+    }\n+\n+    fn fold(mut self, f: &mut impl FnMut(Ty) -> Ty) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.walk_mut(&mut |ty_mut| {\n+            let ty = mem::replace(ty_mut, TyKind::Unknown.intern(&Interner));\n+            *ty_mut = f(ty);\n+        });\n+        self\n+    }\n+\n+    /// Substitutes `TyKind::Bound` vars with the given substitution.\n+    fn subst_bound_vars(self, substs: &Substitution) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.subst_bound_vars_at_depth(substs, DebruijnIndex::INNERMOST)\n+    }\n+\n+    /// Substitutes `TyKind::Bound` vars with the given substitution.\n+    fn subst_bound_vars_at_depth(mut self, substs: &Substitution, depth: DebruijnIndex) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.walk_mut_binders(\n+            &mut |ty, binders| {\n+                if let &mut TyKind::BoundVar(bound) = ty.interned_mut() {\n+                    if bound.debruijn >= binders {\n+                        *ty = substs.interned()[bound.index]\n+                            .assert_ty_ref(&Interner)\n+                            .clone()\n+                            .shift_bound_vars(binders);\n+                    }\n+                }\n+            },\n+            depth,\n+        );\n+        self\n+    }\n+\n+    /// Shifts up debruijn indices of `TyKind::Bound` vars by `n`.\n+    fn shift_bound_vars(self, n: DebruijnIndex) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.fold_binders(\n+            &mut |ty, binders| match ty.kind(&Interner) {\n+                TyKind::BoundVar(bound) if bound.debruijn >= binders => {\n+                    TyKind::BoundVar(bound.shifted_in_from(n)).intern(&Interner)\n+                }\n+                _ => ty,\n+            },\n+            DebruijnIndex::INNERMOST,\n+        )\n+    }\n+\n+    /// Shifts debruijn indices of `TyKind::Bound` vars out (down) by `n`.\n+    fn shift_bound_vars_out(self, n: DebruijnIndex) -> Self\n+    where\n+        Self: Sized + std::fmt::Debug,\n+    {\n+        self.fold_binders(\n+            &mut |ty, binders| match ty.kind(&Interner) {\n+                TyKind::BoundVar(bound) if bound.debruijn >= binders => {\n+                    TyKind::BoundVar(bound.shifted_out_to(n).unwrap_or(bound.clone()))\n+                        .intern(&Interner)\n+                }\n+                _ => ty,\n+            },\n+            DebruijnIndex::INNERMOST,\n+        )\n+    }\n+}\n+\n+impl TypeWalk for Ty {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        match self.kind(&Interner) {\n+            TyKind::Alias(AliasTy::Projection(p_ty)) => {\n+                for t in p_ty.substitution.iter(&Interner) {\n+                    t.walk(f);\n+                }\n+            }\n+            TyKind::Alias(AliasTy::Opaque(o_ty)) => {\n+                for t in o_ty.substitution.iter(&Interner) {\n+                    t.walk(f);\n+                }\n+            }\n+            TyKind::Dyn(dyn_ty) => {\n+                for p in dyn_ty.bounds.value.interned().iter() {\n+                    p.walk(f);\n+                }\n+            }\n+            TyKind::Slice(ty) | TyKind::Array(ty) | TyKind::Ref(_, ty) | TyKind::Raw(_, ty) => {\n+                ty.walk(f);\n+            }\n+            _ => {\n+                if let Some(substs) = self.substs() {\n+                    for t in substs.iter(&Interner) {\n+                        t.walk(f);\n+                    }\n+                }\n+            }\n+        }\n+        f(self);\n+    }\n+\n+    fn walk_mut_binders(\n+        &mut self,\n+        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n+        binders: DebruijnIndex,\n+    ) {\n+        match self.interned_mut() {\n+            TyKind::Alias(AliasTy::Projection(p_ty)) => {\n+                p_ty.substitution.walk_mut_binders(f, binders);\n+            }\n+            TyKind::Dyn(dyn_ty) => {\n+                for p in make_mut_slice(dyn_ty.bounds.value.interned_mut()) {\n+                    p.walk_mut_binders(f, binders.shifted_in());\n+                }\n+            }\n+            TyKind::Alias(AliasTy::Opaque(o_ty)) => {\n+                o_ty.substitution.walk_mut_binders(f, binders);\n+            }\n+            TyKind::Slice(ty) | TyKind::Array(ty) | TyKind::Ref(_, ty) | TyKind::Raw(_, ty) => {\n+                ty.walk_mut_binders(f, binders);\n+            }\n+            _ => {\n+                if let Some(substs) = self.substs_mut() {\n+                    substs.walk_mut_binders(f, binders);\n+                }\n+            }\n+        }\n+        f(self, binders);\n+    }\n+}\n+\n+impl<T: TypeWalk> TypeWalk for Vec<T> {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        for t in self {\n+            t.walk(f);\n+        }\n+    }\n+    fn walk_mut_binders(\n+        &mut self,\n+        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n+        binders: DebruijnIndex,\n+    ) {\n+        for t in self {\n+            t.walk_mut_binders(f, binders);\n+        }\n+    }\n+}\n+\n+impl TypeWalk for OpaqueTy {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.substitution.walk(f);\n+    }\n+\n+    fn walk_mut_binders(\n+        &mut self,\n+        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n+        binders: DebruijnIndex,\n+    ) {\n+        self.substitution.walk_mut_binders(f, binders);\n+    }\n+}\n+\n+impl TypeWalk for ProjectionTy {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.substitution.walk(f);\n+    }\n+\n+    fn walk_mut_binders(\n+        &mut self,\n+        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n+        binders: DebruijnIndex,\n+    ) {\n+        self.substitution.walk_mut_binders(f, binders);\n+    }\n+}\n+\n+impl TypeWalk for AliasTy {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        match self {\n+            AliasTy::Projection(it) => it.walk(f),\n+            AliasTy::Opaque(it) => it.walk(f),\n+        }\n+    }\n+\n+    fn walk_mut_binders(\n+        &mut self,\n+        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n+        binders: DebruijnIndex,\n+    ) {\n+        match self {\n+            AliasTy::Projection(it) => it.walk_mut_binders(f, binders),\n+            AliasTy::Opaque(it) => it.walk_mut_binders(f, binders),\n+        }\n+    }\n+}\n+\n+impl TypeWalk for GenericArg {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        match &self.interned() {\n+            GenericArgData::Ty(ty) => {\n+                ty.walk(f);\n+            }\n+        }\n+    }\n+\n+    fn walk_mut_binders(\n+        &mut self,\n+        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n+        binders: DebruijnIndex,\n+    ) {\n+        match self.interned_mut() {\n+            GenericArgData::Ty(ty) => {\n+                ty.walk_mut_binders(f, binders);\n+            }\n+        }\n+    }\n+}\n+\n+impl TypeWalk for Substitution {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        for t in self.iter(&Interner) {\n+            t.walk(f);\n+        }\n+    }\n+\n+    fn walk_mut_binders(\n+        &mut self,\n+        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n+        binders: DebruijnIndex,\n+    ) {\n+        for t in self.interned_mut() {\n+            t.walk_mut_binders(f, binders);\n+        }\n+    }\n+}\n+\n+impl<T: TypeWalk> TypeWalk for Binders<T> {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.value.walk(f);\n+    }\n+\n+    fn walk_mut_binders(\n+        &mut self,\n+        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n+        binders: DebruijnIndex,\n+    ) {\n+        self.value.walk_mut_binders(f, binders.shifted_in())\n+    }\n+}\n+\n+impl TypeWalk for TraitRef {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.substitution.walk(f);\n+    }\n+\n+    fn walk_mut_binders(\n+        &mut self,\n+        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n+        binders: DebruijnIndex,\n+    ) {\n+        self.substitution.walk_mut_binders(f, binders);\n+    }\n+}\n+\n+impl TypeWalk for WhereClause {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        match self {\n+            WhereClause::Implemented(trait_ref) => trait_ref.walk(f),\n+            WhereClause::AliasEq(alias_eq) => alias_eq.walk(f),\n+        }\n+    }\n+\n+    fn walk_mut_binders(\n+        &mut self,\n+        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n+        binders: DebruijnIndex,\n+    ) {\n+        match self {\n+            WhereClause::Implemented(trait_ref) => trait_ref.walk_mut_binders(f, binders),\n+            WhereClause::AliasEq(alias_eq) => alias_eq.walk_mut_binders(f, binders),\n+        }\n+    }\n+}\n+\n+impl TypeWalk for CallableSig {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        for t in self.params_and_return.iter() {\n+            t.walk(f);\n+        }\n+    }\n+\n+    fn walk_mut_binders(\n+        &mut self,\n+        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n+        binders: DebruijnIndex,\n+    ) {\n+        for t in make_mut_slice(&mut self.params_and_return) {\n+            t.walk_mut_binders(f, binders);\n+        }\n+    }\n+}\n+\n+impl TypeWalk for AliasEq {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.ty.walk(f);\n+        match &self.alias {\n+            AliasTy::Projection(projection_ty) => projection_ty.walk(f),\n+            AliasTy::Opaque(opaque) => opaque.walk(f),\n+        }\n+    }\n+\n+    fn walk_mut_binders(\n+        &mut self,\n+        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n+        binders: DebruijnIndex,\n+    ) {\n+        self.ty.walk_mut_binders(f, binders);\n+        match &mut self.alias {\n+            AliasTy::Projection(projection_ty) => projection_ty.walk_mut_binders(f, binders),\n+            AliasTy::Opaque(opaque) => opaque.walk_mut_binders(f, binders),\n+        }\n+    }\n+}"}]}