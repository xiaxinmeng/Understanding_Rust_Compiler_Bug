{"sha": "ebd15e790aceeaacb01bdd5c4361c5b4be2db237", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViZDE1ZTc5MGFjZWVhYWNiMDFiZGQ1YzQzNjFjNWI0YmUyZGIyMzc=", "commit": {"author": {"name": "Matt Brubeck", "email": "mbrubeck@limpet.net", "date": "2020-08-10T23:19:54Z"}, "committer": {"name": "Matt Brubeck", "email": "mbrubeck@limpet.net", "date": "2020-09-09T00:24:23Z"}, "message": "Implement HashSet in terms of hashbrown::HashSet", "tree": {"sha": "3d365e241eaf9911ffcfcbe51340583719d8869d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d365e241eaf9911ffcfcbe51340583719d8869d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebd15e790aceeaacb01bdd5c4361c5b4be2db237", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebd15e790aceeaacb01bdd5c4361c5b4be2db237", "html_url": "https://github.com/rust-lang/rust/commit/ebd15e790aceeaacb01bdd5c4361c5b4be2db237", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebd15e790aceeaacb01bdd5c4361c5b4be2db237/comments", "author": {"login": "mbrubeck", "id": 5920, "node_id": "MDQ6VXNlcjU5MjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5920?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbrubeck", "html_url": "https://github.com/mbrubeck", "followers_url": "https://api.github.com/users/mbrubeck/followers", "following_url": "https://api.github.com/users/mbrubeck/following{/other_user}", "gists_url": "https://api.github.com/users/mbrubeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbrubeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbrubeck/subscriptions", "organizations_url": "https://api.github.com/users/mbrubeck/orgs", "repos_url": "https://api.github.com/users/mbrubeck/repos", "events_url": "https://api.github.com/users/mbrubeck/events{/privacy}", "received_events_url": "https://api.github.com/users/mbrubeck/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mbrubeck", "id": 5920, "node_id": "MDQ6VXNlcjU5MjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5920?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbrubeck", "html_url": "https://github.com/mbrubeck", "followers_url": "https://api.github.com/users/mbrubeck/followers", "following_url": "https://api.github.com/users/mbrubeck/following{/other_user}", "gists_url": "https://api.github.com/users/mbrubeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbrubeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbrubeck/subscriptions", "organizations_url": "https://api.github.com/users/mbrubeck/orgs", "repos_url": "https://api.github.com/users/mbrubeck/repos", "events_url": "https://api.github.com/users/mbrubeck/events{/privacy}", "received_events_url": "https://api.github.com/users/mbrubeck/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15ccdeb2248f697c3873a60eea538110ed5b2f8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/15ccdeb2248f697c3873a60eea538110ed5b2f8f", "html_url": "https://github.com/rust-lang/rust/commit/15ccdeb2248f697c3873a60eea538110ed5b2f8f"}], "stats": {"total": 162, "additions": 90, "deletions": 72}, "files": [{"sha": "fc0175332a769b97e78aaa1cde97ffc73ffc10b2", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebd15e790aceeaacb01bdd5c4361c5b4be2db237/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebd15e790aceeaacb01bdd5c4361c5b4be2db237/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=ebd15e790aceeaacb01bdd5c4361c5b4be2db237", "patch": "@@ -2698,7 +2698,7 @@ fn map_entry<'a, K: 'a, V: 'a>(raw: base::RustcEntry<'a, K, V>) -> Entry<'a, K,\n }\n \n #[inline]\n-fn map_try_reserve_error(err: hashbrown::TryReserveError) -> TryReserveError {\n+pub(super) fn map_try_reserve_error(err: hashbrown::TryReserveError) -> TryReserveError {\n     match err {\n         hashbrown::TryReserveError::CapacityOverflow => TryReserveError::CapacityOverflow,\n         hashbrown::TryReserveError::AllocError { layout } => {"}, {"sha": "f9bc2e933dcf9b9431340d3c0aa168c71a7d79a5", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 52, "deletions": 57, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/ebd15e790aceeaacb01bdd5c4361c5b4be2db237/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebd15e790aceeaacb01bdd5c4361c5b4be2db237/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=ebd15e790aceeaacb01bdd5c4361c5b4be2db237", "patch": "@@ -1,14 +1,16 @@\n #[cfg(test)]\n mod tests;\n \n+use hashbrown::hash_set as base;\n+\n use crate::borrow::Borrow;\n use crate::collections::TryReserveError;\n use crate::fmt;\n use crate::hash::{BuildHasher, Hash};\n use crate::iter::{Chain, FromIterator, FusedIterator};\n use crate::ops::{BitAnd, BitOr, BitXor, Sub};\n \n-use super::map::{self, HashMap, Keys, RandomState};\n+use super::map::{map_try_reserve_error, RandomState};\n \n // Future Optimization (FIXME!)\n // ============================\n@@ -101,13 +103,14 @@ use super::map::{self, HashMap, Keys, RandomState};\n /// // use the values stored in the set\n /// ```\n ///\n+/// [`HashMap`]: crate::collections::HashMap\n /// [`RefCell`]: crate::cell::RefCell\n /// [`Cell`]: crate::cell::Cell\n #[derive(Clone)]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"hashset_type\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct HashSet<T, S = RandomState> {\n-    map: HashMap<T, (), S>,\n+    base: base::HashSet<T, S>,\n }\n \n impl<T> HashSet<T, RandomState> {\n@@ -125,7 +128,7 @@ impl<T> HashSet<T, RandomState> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> HashSet<T, RandomState> {\n-        HashSet { map: HashMap::new() }\n+        Default::default()\n     }\n \n     /// Creates an empty `HashSet` with the specified capacity.\n@@ -143,7 +146,7 @@ impl<T> HashSet<T, RandomState> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize) -> HashSet<T, RandomState> {\n-        HashSet { map: HashMap::with_capacity(capacity) }\n+        HashSet { base: base::HashSet::with_capacity_and_hasher(capacity, Default::default()) }\n     }\n }\n \n@@ -160,7 +163,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.map.capacity()\n+        self.base.capacity()\n     }\n \n     /// An iterator visiting all elements in arbitrary order.\n@@ -182,7 +185,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, T> {\n-        Iter { iter: self.map.keys() }\n+        Iter { base: self.base.iter() }\n     }\n \n     /// Returns the number of elements in the set.\n@@ -200,7 +203,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {\n-        self.map.len()\n+        self.base.len()\n     }\n \n     /// Returns `true` if the set contains no elements.\n@@ -218,7 +221,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n-        self.map.is_empty()\n+        self.base.is_empty()\n     }\n \n     /// Clears the set, returning all elements in an iterator.\n@@ -241,7 +244,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain(&mut self) -> Drain<'_, T> {\n-        Drain { iter: self.map.drain() }\n+        Drain { base: self.base.drain() }\n     }\n \n     /// Clears the set, removing all values.\n@@ -259,7 +262,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        self.map.clear()\n+        self.base.clear()\n     }\n \n     /// Creates a new empty hash set which will use the given hasher to hash\n@@ -288,7 +291,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_hasher(hasher: S) -> HashSet<T, S> {\n-        HashSet { map: HashMap::with_hasher(hasher) }\n+        HashSet { base: base::HashSet::with_hasher(hasher) }\n     }\n \n     /// Creates an empty `HashSet` with the specified capacity, using\n@@ -318,7 +321,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> HashSet<T, S> {\n-        HashSet { map: HashMap::with_capacity_and_hasher(capacity, hasher) }\n+        HashSet { base: base::HashSet::with_capacity_and_hasher(capacity, hasher) }\n     }\n \n     /// Returns a reference to the set's [`BuildHasher`].\n@@ -336,7 +339,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"hashmap_public_hasher\", since = \"1.9.0\")]\n     pub fn hasher(&self) -> &S {\n-        self.map.hasher()\n+        self.base.hasher()\n     }\n }\n \n@@ -364,7 +367,7 @@ where\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n-        self.map.reserve(additional)\n+        self.base.reserve(additional)\n     }\n \n     /// Tries to reserve capacity for at least `additional` more elements to be inserted\n@@ -387,7 +390,7 @@ where\n     #[inline]\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n     pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n-        self.map.try_reserve(additional)\n+        self.base.try_reserve(additional).map_err(map_try_reserve_error)\n     }\n \n     /// Shrinks the capacity of the set as much as possible. It will drop\n@@ -409,7 +412,7 @@ where\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n-        self.map.shrink_to_fit()\n+        self.base.shrink_to_fit()\n     }\n \n     /// Shrinks the capacity of the set with a lower limit. It will drop\n@@ -437,7 +440,7 @@ where\n     #[inline]\n     #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n     pub fn shrink_to(&mut self, min_capacity: usize) {\n-        self.map.shrink_to(min_capacity)\n+        self.base.shrink_to(min_capacity)\n     }\n \n     /// Visits the values representing the difference,\n@@ -577,7 +580,7 @@ where\n         T: Borrow<Q>,\n         Q: Hash + Eq,\n     {\n-        self.map.contains_key(value)\n+        self.base.contains(value)\n     }\n \n     /// Returns a reference to the value in the set, if any, that is equal to the given value.\n@@ -602,7 +605,7 @@ where\n         T: Borrow<Q>,\n         Q: Hash + Eq,\n     {\n-        self.map.get_key_value(value).map(|(k, _)| k)\n+        self.base.get(value)\n     }\n \n     /// Inserts the given `value` into the set if it is not present, then\n@@ -626,7 +629,7 @@ where\n     pub fn get_or_insert(&mut self, value: T) -> &T {\n         // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n         // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n-        self.map.raw_entry_mut().from_key(&value).or_insert(value, ()).0\n+        self.base.get_or_insert(value)\n     }\n \n     /// Inserts an owned copy of the given `value` into the set if it is not\n@@ -658,7 +661,7 @@ where\n     {\n         // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n         // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n-        self.map.raw_entry_mut().from_key(value).or_insert_with(|| (value.to_owned(), ())).0\n+        self.base.get_or_insert_owned(value)\n     }\n \n     /// Inserts a value computed from `f` into the set if the given `value` is\n@@ -691,7 +694,7 @@ where\n     {\n         // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n         // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n-        self.map.raw_entry_mut().from_key(value).or_insert_with(|| (f(value), ())).0\n+        self.base.get_or_insert_with(value, f)\n     }\n \n     /// Returns `true` if `self` has no elements in common with `other`.\n@@ -788,7 +791,7 @@ where\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: T) -> bool {\n-        self.map.insert(value, ()).is_none()\n+        self.base.insert(value)\n     }\n \n     /// Adds a value to the set, replacing the existing value, if any, that is equal to the given\n@@ -809,13 +812,7 @@ where\n     #[inline]\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn replace(&mut self, value: T) -> Option<T> {\n-        match self.map.entry(value) {\n-            map::Entry::Occupied(occupied) => Some(occupied.replace_key()),\n-            map::Entry::Vacant(vacant) => {\n-                vacant.insert(());\n-                None\n-            }\n-        }\n+        self.base.replace(value)\n     }\n \n     /// Removes a value from the set. Returns whether the value was\n@@ -843,7 +840,7 @@ where\n         T: Borrow<Q>,\n         Q: Hash + Eq,\n     {\n-        self.map.remove(value).is_some()\n+        self.base.remove(value)\n     }\n \n     /// Removes and returns the value in the set, if any, that is equal to the given one.\n@@ -868,7 +865,7 @@ where\n         T: Borrow<Q>,\n         Q: Hash + Eq,\n     {\n-        self.map.remove_entry(value).map(|(k, _)| k)\n+        self.base.take(value)\n     }\n \n     /// Retains only the elements specified by the predicate.\n@@ -886,11 +883,11 @@ where\n     /// assert_eq!(set.len(), 3);\n     /// ```\n     #[stable(feature = \"retain_hash_collection\", since = \"1.18.0\")]\n-    pub fn retain<F>(&mut self, mut f: F)\n+    pub fn retain<F>(&mut self, f: F)\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        self.map.retain(|k, _| f(k));\n+        self.base.retain(f)\n     }\n }\n \n@@ -949,17 +946,17 @@ where\n {\n     #[inline]\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n-        self.map.extend(iter.into_iter().map(|k| (k, ())));\n+        self.base.extend(iter);\n     }\n \n     #[inline]\n     fn extend_one(&mut self, item: T) {\n-        self.map.insert(item, ());\n+        self.base.insert(item);\n     }\n \n     #[inline]\n     fn extend_reserve(&mut self, additional: usize) {\n-        self.map.extend_reserve(additional);\n+        self.base.extend_reserve(additional);\n     }\n }\n \n@@ -976,7 +973,7 @@ where\n \n     #[inline]\n     fn extend_one(&mut self, &item: &'a T) {\n-        self.map.insert(item, ());\n+        self.base.insert(item);\n     }\n \n     #[inline]\n@@ -993,7 +990,7 @@ where\n     /// Creates an empty `HashSet<T, S>` with the `Default` value for the hasher.\n     #[inline]\n     fn default() -> HashSet<T, S> {\n-        HashSet { map: HashMap::default() }\n+        HashSet { base: Default::default() }\n     }\n }\n \n@@ -1137,7 +1134,7 @@ where\n /// [`iter`]: HashSet::iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a> {\n-    iter: Keys<'a, K, ()>,\n+    base: base::Iter<'a, K>,\n }\n \n /// An owning iterator over the items of a `HashSet`.\n@@ -1148,7 +1145,7 @@ pub struct Iter<'a, K: 'a> {\n /// [`into_iter`]: IntoIterator::into_iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K> {\n-    iter: map::IntoIter<K, ()>,\n+    base: base::IntoIter<K>,\n }\n \n /// A draining iterator over the items of a `HashSet`.\n@@ -1159,7 +1156,7 @@ pub struct IntoIter<K> {\n /// [`drain`]: HashSet::drain\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Drain<'a, K: 'a> {\n-    iter: map::Drain<'a, K, ()>,\n+    base: base::Drain<'a, K>,\n }\n \n /// A lazy iterator producing elements in the intersection of `HashSet`s.\n@@ -1250,15 +1247,15 @@ impl<T, S> IntoIterator for HashSet<T, S> {\n     /// ```\n     #[inline]\n     fn into_iter(self) -> IntoIter<T> {\n-        IntoIter { iter: self.map.into_iter() }\n+        IntoIter { base: self.base.into_iter() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> Clone for Iter<'_, K> {\n     #[inline]\n     fn clone(&self) -> Self {\n-        Iter { iter: self.iter.clone() }\n+        Iter { base: self.base.clone() }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1267,18 +1264,18 @@ impl<'a, K> Iterator for Iter<'a, K> {\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a K> {\n-        self.iter.next()\n+        self.base.next()\n     }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n+        self.base.size_hint()\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> ExactSizeIterator for Iter<'_, K> {\n     #[inline]\n     fn len(&self) -> usize {\n-        self.iter.len()\n+        self.base.len()\n     }\n }\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1297,18 +1294,18 @@ impl<K> Iterator for IntoIter<K> {\n \n     #[inline]\n     fn next(&mut self) -> Option<K> {\n-        self.iter.next().map(|(k, _)| k)\n+        self.base.next()\n     }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n+        self.base.size_hint()\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> ExactSizeIterator for IntoIter<K> {\n     #[inline]\n     fn len(&self) -> usize {\n-        self.iter.len()\n+        self.base.len()\n     }\n }\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1317,8 +1314,7 @@ impl<K> FusedIterator for IntoIter<K> {}\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<K: fmt::Debug> fmt::Debug for IntoIter<K> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let entries_iter = self.iter.iter().map(|(k, _)| k);\n-        f.debug_list().entries(entries_iter).finish()\n+        fmt::Debug::fmt(&self.base, f)\n     }\n }\n \n@@ -1328,18 +1324,18 @@ impl<'a, K> Iterator for Drain<'a, K> {\n \n     #[inline]\n     fn next(&mut self) -> Option<K> {\n-        self.iter.next().map(|(k, _)| k)\n+        self.base.next()\n     }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n+        self.base.size_hint()\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> ExactSizeIterator for Drain<'_, K> {\n     #[inline]\n     fn len(&self) -> usize {\n-        self.iter.len()\n+        self.base.len()\n     }\n }\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1348,8 +1344,7 @@ impl<K> FusedIterator for Drain<'_, K> {}\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<K: fmt::Debug> fmt::Debug for Drain<'_, K> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let entries_iter = self.iter.iter().map(|(k, _)| k);\n-        f.debug_list().entries(entries_iter).finish()\n+        fmt::Debug::fmt(&self.base, f)\n     }\n }\n "}, {"sha": "a5a1824c84e78be919f81ea5f4119d70686b7121", "filename": "src/etc/gdb_lookup.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebd15e790aceeaacb01bdd5c4361c5b4be2db237/src%2Fetc%2Fgdb_lookup.py", "raw_url": "https://github.com/rust-lang/rust/raw/ebd15e790aceeaacb01bdd5c4361c5b4be2db237/src%2Fetc%2Fgdb_lookup.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_lookup.py?ref=ebd15e790aceeaacb01bdd5c4361c5b4be2db237", "patch": "@@ -69,9 +69,9 @@ def lookup(valobj):\n         else:\n             return StdOldHashMapProvider(valobj)\n     if rust_type == RustType.STD_HASH_SET:\n-        hash_map = valobj[\"map\"]\n+        hash_map = valobj[valobj.type.fields()[0]]\n         if is_hashbrown_hashmap(hash_map):\n-            return StdHashMapProvider(hash_map, show_values=False)\n+            return StdHashMapProvider(valobj, show_values=False)\n         else:\n             return StdOldHashMapProvider(hash_map, show_values=False)\n "}, {"sha": "bae51e6f9ee93a394ba51718ebfe5b81a9f1c5a5", "filename": "src/etc/gdb_providers.py", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ebd15e790aceeaacb01bdd5c4361c5b4be2db237/src%2Fetc%2Fgdb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/ebd15e790aceeaacb01bdd5c4361c5b4be2db237/src%2Fetc%2Fgdb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_providers.py?ref=ebd15e790aceeaacb01bdd5c4361c5b4be2db237", "patch": "@@ -347,7 +347,7 @@ def __init__(self, valobj, show_values=True):\n         self.valobj = valobj\n         self.show_values = show_values\n \n-        table = self.valobj[\"base\"][\"table\"]\n+        table = self.table()\n         capacity = int(table[\"bucket_mask\"]) + 1\n         ctrl = table[\"ctrl\"][\"pointer\"]\n \n@@ -368,6 +368,18 @@ def __init__(self, valobj, show_values=True):\n             if is_presented:\n                 self.valid_indices.append(idx)\n \n+    def table(self):\n+        if self.show_values:\n+            hashbrown_hashmap = self.valobj[\"base\"]\n+        elif self.valobj.type.fields()[0].name == \"map\":\n+            # BACKCOMPAT: rust 1.47\n+            # HashSet wraps std::collections::HashMap, which wraps hashbrown::HashMap\n+            hashbrown_hashmap = self.valobj[\"map\"][\"base\"]\n+        else:\n+            # HashSet wraps hashbrown::HashSet, which wraps hashbrown::HashMap\n+            hashbrown_hashmap = self.valobj[\"base\"][\"map\"]\n+        return hashbrown_hashmap[\"table\"]\n+\n     def to_string(self):\n         if self.show_values:\n             return \"HashMap(size={})\".format(self.size)"}, {"sha": "3cee51982ba9f921eac8be4e9eeed216df09680b", "filename": "src/etc/lldb_lookup.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebd15e790aceeaacb01bdd5c4361c5b4be2db237/src%2Fetc%2Flldb_lookup.py", "raw_url": "https://github.com/rust-lang/rust/raw/ebd15e790aceeaacb01bdd5c4361c5b4be2db237/src%2Fetc%2Flldb_lookup.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_lookup.py?ref=ebd15e790aceeaacb01bdd5c4361c5b4be2db237", "patch": "@@ -94,7 +94,7 @@ def synthetic_lookup(valobj, dict):\n     if rust_type == RustType.STD_HASH_SET:\n         hash_map = valobj.GetChildAtIndex(0)\n         if is_hashbrown_hashmap(hash_map):\n-            return StdHashMapSyntheticProvider(hash_map, dict, show_values=False)\n+            return StdHashMapSyntheticProvider(valobj, dict, show_values=False)\n         else:\n             return StdOldHashMapSyntheticProvider(hash_map, dict, show_values=False)\n "}, {"sha": "64cb9837943b902b0b8fcdf9749859848c25e884", "filename": "src/etc/lldb_providers.py", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ebd15e790aceeaacb01bdd5c4361c5b4be2db237/src%2Fetc%2Flldb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/ebd15e790aceeaacb01bdd5c4361c5b4be2db237/src%2Fetc%2Flldb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_providers.py?ref=ebd15e790aceeaacb01bdd5c4361c5b4be2db237", "patch": "@@ -526,7 +526,7 @@ def get_child_at_index(self, index):\n \n     def update(self):\n         # type: () -> None\n-        table = self.valobj.GetChildMemberWithName(\"base\").GetChildMemberWithName(\"table\")\n+        table = self.table()\n         capacity = table.GetChildMemberWithName(\"bucket_mask\").GetValueAsUnsigned() + 1\n         ctrl = table.GetChildMemberWithName(\"ctrl\").GetChildAtIndex(0)\n \n@@ -552,6 +552,17 @@ def update(self):\n             if is_present:\n                 self.valid_indices.append(idx)\n \n+    def table(self):\n+        # type: () -> SBValue\n+        if self.show_values:\n+            hashbrown_hashmap = self.valobj.GetChildMemberWithName(\"base\")\n+        else:\n+            # BACKCOMPAT: rust 1.47\n+            # HashSet wraps either std HashMap or hashbrown::HashSet, which both\n+            # wrap hashbrown::HashMap, so either way we \"unwrap\" twice.\n+            hashbrown_hashmap = self.valobj.GetChildAtIndex(0).GetChildAtIndex(0)\n+        return hashbrown_hashmap.GetChildMemberWithName(\"table\")\n+\n     def has_children(self):\n         # type: () -> bool\n         return True"}, {"sha": "9550c25f2fcfe5da1b78cc5b2ab743f3f1ab105f", "filename": "src/etc/natvis/libstd.natvis", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ebd15e790aceeaacb01bdd5c4361c5b4be2db237/src%2Fetc%2Fnatvis%2Flibstd.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/ebd15e790aceeaacb01bdd5c4361c5b4be2db237/src%2Fetc%2Fnatvis%2Flibstd.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Flibstd.natvis?ref=ebd15e790aceeaacb01bdd5c4361c5b4be2db237", "patch": "@@ -5,7 +5,7 @@\n \n     Current std impls:\n       std::collections::hash::set::HashSet<K, S>      is implemented in terms of...\n-      std::collections::hash::map::HashMap<K, V, S>   is implemented in terms of...\n+      hashbrown::set::HashSet<K, S>                   is implemented in terms of...\n       hashbrown::map::HashMap<K, V, S>                is implemented in terms of...\n       hashbrown::raw::RawTable<(K, V)>\n \n@@ -50,22 +50,22 @@\n   </Type>\n \n   <Type Name=\"std::collections::hash::set::HashSet&lt;*,*&gt;\">\n-    <DisplayString>{{ size={map.base.table.items} }}</DisplayString>\n+    <DisplayString>{{ size={base.map.table.items} }}</DisplayString>\n     <Expand>\n-      <Item Name=\"[size]\">map.base.table.items</Item>\n-      <Item Name=\"[capacity]\">map.base.table.items + map.base.table.growth_left</Item>\n-      <Item Name=\"[state]\">map.base.hash_builder</Item>\n+      <Item Name=\"[size]\">base.map.table.items</Item>\n+      <Item Name=\"[capacity]\">base.map.table.items + base.map.table.growth_left</Item>\n+      <Item Name=\"[state]\">base.map.hash_builder</Item>\n \n       <CustomListItems>\n         <Variable Name=\"i\" InitialValue=\"0\" />\n-        <Variable Name=\"n\" InitialValue=\"map.base.table.items\" />\n-        <Size>map.base.table.items</Size>\n+        <Variable Name=\"n\" InitialValue=\"base.map.table.items\" />\n+        <Size>base.map.table.items</Size>\n         <Loop>\n           <Break Condition=\"n == 0\" />\n-          <If Condition=\"(map.base.table.ctrl.pointer[i] &amp; 0x80) == 0\">\n+          <If Condition=\"(base.map.table.ctrl.pointer[i] &amp; 0x80) == 0\">\n             <!-- Bucket is populated -->\n             <Exec>n--</Exec>\n-            <Item>(($T1*)map.base.table.ctrl.pointer)[-(i + 1)]</Item>\n+            <Item>(($T1*)base.map.table.ctrl.pointer)[-(i + 1)]</Item>\n           </If>\n           <Exec>i++</Exec>\n         </Loop>"}]}