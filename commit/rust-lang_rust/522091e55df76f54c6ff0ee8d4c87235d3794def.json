{"sha": "522091e55df76f54c6ff0ee8d4c87235d3794def", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMjA5MWU1NWRmNzZmNTRjNmZmMGVlOGQ0Yzg3MjM1ZDM3OTRkZWY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-17T10:11:30Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-17T10:11:30Z"}, "message": "Rollup merge of #21990 - steveklabnik:doc_core_cmp, r=huonw\n\nFix up, add examples, make them all the same.", "tree": {"sha": "fb98d9bd906a253c1e8e0437fbf819bee8aea871", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb98d9bd906a253c1e8e0437fbf819bee8aea871"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/522091e55df76f54c6ff0ee8d4c87235d3794def", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/522091e55df76f54c6ff0ee8d4c87235d3794def", "html_url": "https://github.com/rust-lang/rust/commit/522091e55df76f54c6ff0ee8d4c87235d3794def", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/522091e55df76f54c6ff0ee8d4c87235d3794def/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860", "html_url": "https://github.com/rust-lang/rust/commit/f1bb6c2f46f08c1d7b6d695f5b3cf93142cb8860"}, {"sha": "17f9d36d354a0f97e73ff897a2a1b2502c29400e", "url": "https://api.github.com/repos/rust-lang/rust/commits/17f9d36d354a0f97e73ff897a2a1b2502c29400e", "html_url": "https://github.com/rust-lang/rust/commit/17f9d36d354a0f97e73ff897a2a1b2502c29400e"}], "stats": {"total": 272, "additions": 206, "deletions": 66}, "files": [{"sha": "5bc634936cff43f1d35b937fd4f38a1c1d964127", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 206, "deletions": 66, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/522091e55df76f54c6ff0ee8d4c87235d3794def/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522091e55df76f54c6ff0ee8d4c87235d3794def/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=522091e55df76f54c6ff0ee8d4c87235d3794def", "patch": "@@ -8,35 +8,33 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Defines the `PartialOrd` and `PartialEq` comparison traits.\n+//! Functionality for ordering and comparison.\n //!\n-//! This module defines both `PartialOrd` and `PartialEq` traits which are used by the\n-//! compiler to implement comparison operators. Rust programs may implement\n-//!`PartialOrd` to overload the `<`, `<=`, `>`, and `>=` operators, and may implement\n-//! `PartialEq` to overload the `==` and `!=` operators.\n+//! This module defines both `PartialOrd` and `PartialEq` traits which are used by the compiler to\n+//! implement comparison operators. Rust programs may implement `PartialOrd` to overload the `<`,\n+//! `<=`, `>`, and `>=` operators, and may implement `PartialEq` to overload the `==` and `!=`\n+//! operators.\n //!\n-//! For example, to define a type with a customized definition for the PartialEq\n-//! operators, you could do the following:\n+//! For example, to define a type with a customized definition for the PartialEq operators, you\n+//! could do the following:\n //!\n-//! ```rust\n+//! ```\n //! use core::num::SignedInt;\n //!\n-//! // Our type.\n-//! struct SketchyNum {\n-//!     num : int\n+//! struct FuzzyNum {\n+//!     num: i32,\n //! }\n //!\n-//! // Our implementation of `PartialEq` to support `==` and `!=`.\n-//! impl PartialEq for SketchyNum {\n+//! impl PartialEq for FuzzyNum {\n //!     // Our custom eq allows numbers which are near each other to be equal! :D\n-//!     fn eq(&self, other: &SketchyNum) -> bool {\n+//!     fn eq(&self, other: &FuzzyNum) -> bool {\n //!         (self.num - other.num).abs() < 5\n //!     }\n //! }\n //!\n //! // Now these binary operators will work when applied!\n-//! assert!(SketchyNum {num: 37} == SketchyNum {num: 34});\n-//! assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n+//! assert!(FuzzyNum { num: 37 } == FuzzyNum { num: 34 });\n+//! assert!(FuzzyNum { num: 25 } != FuzzyNum { num: 57 });\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -49,24 +47,22 @@ use option::Option::{self, Some, None};\n /// Trait for equality comparisons which are [partial equivalence relations](\n /// http://en.wikipedia.org/wiki/Partial_equivalence_relation).\n ///\n-/// This trait allows for partial equality, for types that do not have a full\n-/// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n-/// so floating point types implement `PartialEq` but not `Eq`.\n+/// This trait allows for partial equality, for types that do not have a full equivalence relation.\n+/// For example, in floating point numbers `NaN != NaN`, so floating point types implement\n+/// `PartialEq` but not `Eq`.\n ///\n /// Formally, the equality must be (for all `a`, `b` and `c`):\n ///\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n ///\n-/// Note that these requirements mean that the trait itself must be\n-/// implemented symmetrically and transitively: if `T: PartialEq<U>`\n-/// and `U: PartialEq<V>` then `U: PartialEq<T>` and `T:\n+/// Note that these requirements mean that the trait itself must be implemented symmetrically and\n+/// transitively: if `T: PartialEq<U>` and `U: PartialEq<V>` then `U: PartialEq<T>` and `T:\n /// PartialEq<V>`.\n ///\n-/// PartialEq only requires the `eq` method to be implemented; `ne` is defined\n-/// in terms of it by default. Any manual implementation of `ne` *must* respect\n-/// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n-/// only if `a != b`.\n+/// PartialEq only requires the `eq` method to be implemented; `ne` is defined in terms of it by\n+/// default. Any manual implementation of `ne` *must* respect the rule that `eq` is a strict\n+/// inverse of `ne`; that is, `!(a == b)` if and only if `a != b`.\n #[lang=\"eq\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[old_orphan_check]\n@@ -84,12 +80,15 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n /// Trait for equality comparisons which are [equivalence relations](\n /// https://en.wikipedia.org/wiki/Equivalence_relation).\n ///\n-/// This means, that in addition to `a == b` and `a != b` being strict\n-/// inverses, the equality must be (for all `a`, `b` and `c`):\n+/// This means, that in addition to `a == b` and `a != b` being strict inverses, the equality must\n+/// be (for all `a`, `b` and `c`):\n ///\n /// - reflexive: `a == a`;\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n+///\n+/// This property cannot be checked by the compiler, and therefore `Eq` implies `PartialEq`, and\n+/// has no extra methods.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Eq: PartialEq<Self> {\n     // FIXME #13101: this method is used solely by #[deriving] to\n@@ -104,7 +103,22 @@ pub trait Eq: PartialEq<Self> {\n     fn assert_receiver_is_total_eq(&self) {}\n }\n \n-/// An ordering is, e.g, a result of a comparison between two values.\n+/// An `Ordering` is the result of a comparison between two values.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::cmp::Ordering;\n+///\n+/// let result = 1.cmp(&2);\n+/// assert_eq!(Ordering::Less, result);\n+///\n+/// let result = 1.cmp(&1);\n+/// assert_eq!(Ordering::Equal, result);\n+///\n+/// let result = 2.cmp(&1);\n+/// assert_eq!(Ordering::Greater, result);\n+/// ```\n #[derive(Clone, Copy, PartialEq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Ordering {\n@@ -120,17 +134,28 @@ pub enum Ordering {\n }\n \n impl Ordering {\n-    /// Reverse the `Ordering`, so that `Less` becomes `Greater` and\n-    /// vice versa.\n+    /// Reverse the `Ordering`.\n     ///\n-    /// # Example\n+    /// * `Less` becomes `Greater`.\n+    /// * `Greater` becomes `Less`.\n+    /// * `Equal` becomes `Equal`.\n     ///\n-    /// ```rust\n-    /// use std::cmp::Ordering::{Less, Equal, Greater};\n+    /// # Examples\n     ///\n-    /// assert_eq!(Less.reverse(), Greater);\n-    /// assert_eq!(Equal.reverse(), Equal);\n-    /// assert_eq!(Greater.reverse(), Less);\n+    /// Basic behavior:\n+    ///\n+    /// ```\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// assert_eq!(Ordering::Less.reverse(), Ordering::Greater);\n+    /// assert_eq!(Ordering::Equal.reverse(), Ordering::Equal);\n+    /// assert_eq!(Ordering::Greater.reverse(), Ordering::Less);\n+    /// ```\n+    ///\n+    /// This method can be used to reverse a comparison:\n+    ///\n+    /// ```\n+    /// use std::cmp::Ordering;\n     ///\n     /// let mut data: &mut [_] = &mut [2, 10, 5, 8];\n     ///\n@@ -155,28 +180,27 @@ impl Ordering {\n     }\n }\n \n-/// Trait for types that form a [total order](\n-/// https://en.wikipedia.org/wiki/Total_order).\n+/// Trait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order).\n ///\n /// An order is a total order if it is (for all `a`, `b` and `c`):\n ///\n-/// - total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is\n-///   true; and\n-/// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n-///   both `==` and `>`.\n+/// - total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is true; and\n+/// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Ord: Eq + PartialOrd<Self> {\n-    /// This method returns an ordering between `self` and `other` values.\n+    /// This method returns an `Ordering` between `self` and `other`.\n+    ///\n+    /// By convention, `self.cmp(&other)` returns the ordering matching the expression\n+    /// `self <operator> other` if true.\n     ///\n-    /// By convention, `self.cmp(&other)` returns the ordering matching\n-    /// the expression `self <operator> other` if true.  For example:\n+    /// # Examples\n     ///\n     /// ```\n-    /// use std::cmp::Ordering::{Less, Equal, Greater};\n+    /// use std::cmp::Ordering;\n     ///\n-    /// assert_eq!( 5.cmp(&10), Less);     // because 5 < 10\n-    /// assert_eq!(10.cmp(&5),  Greater);  // because 10 > 5\n-    /// assert_eq!( 5.cmp(&5),  Equal);    // because 5 == 5\n+    /// assert_eq!(5.cmp(&10), Ordering::Less);\n+    /// assert_eq!(10.cmp(&5), Ordering::Greater);\n+    /// assert_eq!(5.cmp(&5), Ordering::Equal);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cmp(&self, other: &Self) -> Ordering;\n@@ -208,30 +232,60 @@ impl PartialOrd for Ordering {\n /// The comparison must satisfy, for all `a`, `b` and `c`:\n ///\n /// - antisymmetry: if `a < b` then `!(a > b)` and vice versa; and\n-/// - transitivity: `a < b` and `b < c` implies `a < c`. The same must hold for\n-///   both `==` and `>`.\n+/// - transitivity: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n ///\n-/// Note that these requirements mean that the trait itself must be\n-/// implemented symmetrically and transitively: if `T: PartialOrd<U>`\n-/// and `U: PartialOrd<V>` then `U: PartialOrd<T>` and `T:\n+/// Note that these requirements mean that the trait itself must be implemented symmetrically and\n+/// transitively: if `T: PartialOrd<U>` and `U: PartialOrd<V>` then `U: PartialOrd<T>` and `T:\n /// PartialOrd<V>`.\n ///\n-/// PartialOrd only requires implementation of the `partial_cmp` method,\n-/// with the others generated from default implementations.\n+/// PartialOrd only requires implementation of the `partial_cmp` method, with the others generated\n+/// from default implementations.\n ///\n-/// However it remains possible to implement the others separately for types\n-/// which do not have a total order. For example, for floating point numbers,\n-/// `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section\n-/// 5.11).\n+/// However it remains possible to implement the others separately for types which do not have a\n+/// total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 ==\n+/// false` (cf. IEEE 754-2008 section 5.11).\n #[lang=\"ord\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n-    /// This method returns an ordering between `self` and `other` values\n-    /// if one exists.\n+    /// This method returns an ordering between `self` and `other` values if one exists.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// let result = 1.0.partial_cmp(&2.0);\n+    /// assert_eq!(result, Some(Ordering::Less));\n+    ///\n+    /// let result = 1.0.partial_cmp(&1.0);\n+    /// assert_eq!(result, Some(Ordering::Equal));\n+    ///\n+    /// let result = 2.0.partial_cmp(&1.0);\n+    /// assert_eq!(result, Some(Ordering::Greater));\n+    /// ```\n+    ///\n+    /// When comparison is impossible:\n+    ///\n+    /// ```\n+    /// let result = std::f64::NAN.partial_cmp(&1.0);\n+    /// assert_eq!(result, None);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;\n \n     /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// let result = 1.0 < 2.0;\n+    /// assert_eq!(result, true);\n+    ///\n+    /// let result = 2.0 < 1.0;\n+    /// assert_eq!(result, false);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lt(&self, other: &Rhs) -> bool {\n@@ -241,7 +295,18 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n         }\n     }\n \n-    /// This method tests less than or equal to (`<=`).\n+    /// This method tests less than or equal to (for `self` and `other`) and is used by the `<=`\n+    /// operator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let result = 1.0 <= 2.0;\n+    /// assert_eq!(result, true);\n+    ///\n+    /// let result = 2.0 <= 2.0;\n+    /// assert_eq!(result, true);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn le(&self, other: &Rhs) -> bool {\n@@ -251,7 +316,17 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n         }\n     }\n \n-    /// This method tests greater than (`>`).\n+    /// This method tests greater than (for `self` and `other`) and is used by the `>` operator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let result = 1.0 > 2.0;\n+    /// assert_eq!(result, false);\n+    ///\n+    /// let result = 2.0 > 2.0;\n+    /// assert_eq!(result, false);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn gt(&self, other: &Rhs) -> bool {\n@@ -261,7 +336,18 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n         }\n     }\n \n-    /// This method tests greater than or equal to (`>=`).\n+    /// This method tests greater than or equal to (for `self` and `other`) and is used by the `>=`\n+    /// operator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let result = 2.0 >= 1.0;\n+    /// assert_eq!(result, true);\n+    ///\n+    /// let result = 2.0 >= 2.0;\n+    /// assert_eq!(result, true);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ge(&self, other: &Rhs) -> bool {\n@@ -273,13 +359,31 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n }\n \n /// Compare and return the minimum of two values.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::cmp;\n+///\n+/// assert_eq!(1, cmp::min(1, 2));\n+/// assert_eq!(2, cmp::min(2, 2));\n+/// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min<T: Ord>(v1: T, v2: T) -> T {\n     if v1 < v2 { v1 } else { v2 }\n }\n \n /// Compare and return the maximum of two values.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::cmp;\n+///\n+/// assert_eq!(2, cmp::max(1, 2));\n+/// assert_eq!(2, cmp::max(2, 2));\n+/// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn max<T: Ord>(v1: T, v2: T) -> T {\n@@ -289,6 +393,24 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n /// Compare and return the minimum of two values if there is one.\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::cmp;\n+///\n+/// assert_eq!(Some(1), cmp::partial_min(1, 2));\n+/// assert_eq!(Some(2), cmp::partial_min(2, 2));\n+/// ```\n+///\n+/// When comparison is impossible:\n+///\n+/// ```\n+/// use std::cmp;\n+///\n+/// let result = cmp::partial_min(std::f64::NAN, &1.0);\n+/// assert_eq!(result, None);\n+/// ```\n #[inline]\n #[unstable(feature = \"core\")]\n pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n@@ -302,6 +424,24 @@ pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n /// Compare and return the maximum of two values if there is one.\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::cmp;\n+///\n+/// assert_eq!(Some(2), cmp::partial_max(1, 2));\n+/// assert_eq!(Some(2), cmp::partial_max(2, 2));\n+/// ```\n+///\n+/// When comparison is impossible:\n+///\n+/// ```\n+/// use std::cmp;\n+///\n+/// let result = cmp::partial_max(std::f64::NAN, &1.0);\n+/// assert_eq!(result, None);\n+/// ```\n #[inline]\n #[unstable(feature = \"core\")]\n pub fn partial_max<T: PartialOrd>(v1: T, v2: T) -> Option<T> {"}]}