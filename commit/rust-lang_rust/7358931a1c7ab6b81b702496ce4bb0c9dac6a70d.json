{"sha": "7358931a1c7ab6b81b702496ce4bb0c9dac6a70d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNTg5MzFhMWM3YWI2YjgxYjcwMjQ5NmNlNGJiMGM5ZGFjNmE3MGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-08T20:22:04Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-26T14:49:24Z"}, "message": "improve `trivial_case` handling", "tree": {"sha": "73ac966fbeaf8be2b30b409dcec20a9fa8ce74e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73ac966fbeaf8be2b30b409dcec20a9fa8ce74e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7358931a1c7ab6b81b702496ce4bb0c9dac6a70d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7358931a1c7ab6b81b702496ce4bb0c9dac6a70d", "html_url": "https://github.com/rust-lang/rust/commit/7358931a1c7ab6b81b702496ce4bb0c9dac6a70d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7358931a1c7ab6b81b702496ce4bb0c9dac6a70d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8cf710ce032e87947d0107dcfb5d3f4c90a6849", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8cf710ce032e87947d0107dcfb5d3f4c90a6849", "html_url": "https://github.com/rust-lang/rust/commit/c8cf710ce032e87947d0107dcfb5d3f4c90a6849"}], "stats": {"total": 47, "additions": 29, "deletions": 18}, "files": [{"sha": "96bed1223502ab8d0c3f574148e881b6f092fc60", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7358931a1c7ab6b81b702496ce4bb0c9dac6a70d/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7358931a1c7ab6b81b702496ce4bb0c9dac6a70d/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=7358931a1c7ab6b81b702496ce4bb0c9dac6a70d", "patch": "@@ -210,7 +210,7 @@ impl_stable_hash_for!(struct DtorckConstraint<'tcx> {\n ///\n /// Note also that `needs_drop` requires a \"global\" type (i.e., one\n /// with erased regions), but this funtcion does not.\n-fn trivial_dropck_outlives<'cx, 'tcx>(tcx: TyCtxt<'cx, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         // None of these types have a destructor and hence they do not\n         // require anything in particular to outlive the dtor's"}, {"sha": "6ba1a70f6126a39e3bd37b1e040d161c606174f4", "filename": "src/librustc_mir/borrow_check/nll/type_check/type_op/mod.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7358931a1c7ab6b81b702496ce4bb0c9dac6a70d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7358931a1c7ab6b81b702496ce4bb0c9dac6a70d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fmod.rs?ref=7358931a1c7ab6b81b702496ce4bb0c9dac6a70d", "patch": "@@ -11,12 +11,13 @@\n use rustc::infer::canonical::query_result;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::{InferCtxt, InferOk, InferResult};\n+use rustc::traits::query::dropck_outlives::trivial_dropck_outlives;\n use rustc::traits::query::NoSolution;\n use rustc::traits::{Normalized, Obligation, ObligationCause, PredicateObligation, TraitEngine};\n use rustc::ty::error::TypeError;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Kind;\n-use rustc::ty::{ParamEnv, Predicate, Ty};\n+use rustc::ty::{ParamEnv, Predicate, Ty, TyCtxt};\n use std::fmt;\n use std::rc::Rc;\n use syntax::codemap::DUMMY_SP;\n@@ -26,7 +27,7 @@ pub(super) trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n \n     /// Micro-optimization: returns `Ok(x)` if we can trivially\n     /// produce the output, else returns `Err(self)` back.\n-    fn trivial_noop(self) -> Result<Self::Output, Self>;\n+    fn trivial_noop(self, tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self>;\n \n     /// Given an infcx, performs **the kernel** of the operation: this does the\n     /// key action and then, optionally, returns a set of obligations which must be proven.\n@@ -40,29 +41,35 @@ pub(super) trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n     /// Processes the operation and all resulting obligations,\n     /// returning the final result along with any region constraints\n     /// (they will be given over to the NLL region solver).\n-    #[inline(never)]\n     fn fully_perform(\n         self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n     ) -> Result<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>), TypeError<'tcx>> {\n-        let op = match self.trivial_noop() {\n-            Ok(r) => return Ok((r, None)),\n-            Err(op) => op,\n-        };\n+        match self.trivial_noop(infcx.tcx) {\n+            Ok(r) => Ok((r, None)),\n+            Err(op) => op.fully_perform_nontrivial(infcx),\n+        }\n+    }\n \n+    /// Helper for `fully_perform` that handles the nontrivial cases.\n+    #[inline(never)] // just to help with profiling\n+    fn fully_perform_nontrivial(\n+        self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    ) -> Result<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>), TypeError<'tcx>> {\n         if cfg!(debug_assertions) {\n-            info!(\"fully_perform_op_and_get_region_constraint_data({:?})\", op);\n+            info!(\"fully_perform_op_and_get_region_constraint_data({:?})\", self);\n         }\n \n         let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n         let dummy_body_id = ObligationCause::dummy().body_id;\n-        let InferOk { value, obligations } = infcx.commit_if_ok(|_| op.perform(infcx))?;\n+        let InferOk { value, obligations } = infcx.commit_if_ok(|_| self.perform(infcx))?;\n         debug_assert!(obligations.iter().all(|o| o.cause.body_id == dummy_body_id));\n         fulfill_cx.register_predicate_obligations(infcx, obligations);\n         if let Err(e) = fulfill_cx.select_all_or_error(infcx) {\n             infcx.tcx.sess.diagnostic().delay_span_bug(\n                 DUMMY_SP,\n-                &format!(\"errors selecting obligation during MIR typeck: {:?}\", e)\n+                &format!(\"errors selecting obligation during MIR typeck: {:?}\", e),\n             );\n         }\n \n@@ -109,7 +116,7 @@ where\n {\n     type Output = R;\n \n-    fn trivial_noop(self) -> Result<Self::Output, Self> {\n+    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n         Err(self)\n     }\n \n@@ -147,7 +154,7 @@ impl<'tcx> Subtype<'tcx> {\n impl<'gcx, 'tcx> TypeOp<'gcx, 'tcx> for Subtype<'tcx> {\n     type Output = ();\n \n-    fn trivial_noop(self) -> Result<Self::Output, Self> {\n+    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n         if self.sub == self.sup {\n             Ok(())\n         } else {\n@@ -178,7 +185,7 @@ impl<'tcx> Eq<'tcx> {\n impl<'gcx, 'tcx> TypeOp<'gcx, 'tcx> for Eq<'tcx> {\n     type Output = ();\n \n-    fn trivial_noop(self) -> Result<Self::Output, Self> {\n+    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n         if self.a == self.b {\n             Ok(())\n         } else {\n@@ -215,7 +222,7 @@ impl<'tcx> ProvePredicates<'tcx> {\n impl<'gcx, 'tcx> TypeOp<'gcx, 'tcx> for ProvePredicates<'tcx> {\n     type Output = ();\n \n-    fn trivial_noop(self) -> Result<Self::Output, Self> {\n+    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n         if self.obligations.is_empty() {\n             Ok(())\n         } else {\n@@ -252,7 +259,7 @@ where\n {\n     type Output = T;\n \n-    fn trivial_noop(self) -> Result<Self::Output, Self> {\n+    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n         if !self.value.has_projections() {\n             Ok(self.value)\n         } else {\n@@ -289,8 +296,12 @@ impl<'tcx> DropckOutlives<'tcx> {\n impl<'gcx, 'tcx> TypeOp<'gcx, 'tcx> for DropckOutlives<'tcx> {\n     type Output = Vec<Kind<'tcx>>;\n \n-    fn trivial_noop(self) -> Result<Self::Output, Self> {\n-        Err(self)\n+    fn trivial_noop(self, tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n+        if trivial_dropck_outlives(tcx, self.dropped_ty) {\n+            Ok(vec![])\n+        } else {\n+            Err(self)\n+        }\n     }\n \n     fn perform(self, infcx: &InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, Self::Output> {"}]}