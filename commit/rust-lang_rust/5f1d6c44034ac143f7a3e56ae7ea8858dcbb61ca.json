{"sha": "5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMWQ2YzQ0MDM0YWMxNDNmN2EzZTU2YWU3ZWE4ODU4ZGNiYjYxY2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-04T08:22:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-04T08:22:05Z"}, "message": "Auto merge of #65947 - eddyb:fn-abi, r=oli-obk,nagisa\n\nrustc: split FnAbi's into definitions/direct calls (\"of_instance\") and indirect calls (\"of_fn_ptr\").\n\nAfter this PR:\n* `InstanceDef::Virtual` is only used for \"direct\" virtual calls, and shims around those calls use `InstanceDef::ReifyShim` (i.e. for `<dyn Trait as Trait>::f as fn(_)`)\n  * this could easily be done for intrinsics as well, to allow their reification, but I didn't do it\n* `FnAbi::of_instance` is **always** used for declaring/defining an `fn`, and for direct calls to an `fn`\n  * this is great for e.g. https://github.com/rust-lang/rust/pull/65881 (`#[track_caller]`), which can introduce the \"caller location\" argument into \"codegen signatures\" by only changing `FnAbi::of_instance`, after this PR\n* `FnAbi::of_fn_ptr` is used primarily for indirect calls, i.e. to `fn` pointers\n  * *not* virtual calls (which use `FnAbi::of_instance` with `InstanceDef::Virtual`)\n  * there's also a couple uses where the `rustc_codegen_llvm` needs to declare (i.e. FFI-import) an LLVM function that has no Rust declaration available at all\n    * at least one of them could probably be a \"weak lang item\" instead\n\nAs there are many steps, this PR is best reviewed commit by commit - some of which arguably should be in their own PRs, I may have gotten carried away a bit.\n\ncc @nagisa @rkruppe @oli-obk @anp", "tree": {"sha": "8ce8e889e897fa1514cece0e96b6f632de2411d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ce8e889e897fa1514cece0e96b6f632de2411d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "html_url": "https://github.com/rust-lang/rust/commit/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7fc0939ca4f8f951ce39e85ec5d149c7bb1501c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7fc0939ca4f8f951ce39e85ec5d149c7bb1501c", "html_url": "https://github.com/rust-lang/rust/commit/a7fc0939ca4f8f951ce39e85ec5d149c7bb1501c"}, {"sha": "c2f4c57296f0d929618baed0b0d6eb594abf01eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2f4c57296f0d929618baed0b0d6eb594abf01eb", "html_url": "https://github.com/rust-lang/rust/commit/c2f4c57296f0d929618baed0b0d6eb594abf01eb"}], "stats": {"total": 813, "additions": 387, "deletions": 426}, "files": [{"sha": "95e9f098da3fb35649878448eaffba42b7d0208c", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -279,18 +279,10 @@ impl<'a, 'b, 'tcx> graph::GraphSuccessors<'b> for ReadOnlyBodyCache<'a, 'tcx> {\n \n \n impl Deref for ReadOnlyBodyCache<'a, 'tcx> {\n-    type Target = Body<'tcx>;\n+    type Target = &'a Body<'tcx>;\n \n     fn deref(&self) -> &Self::Target {\n-        self.body\n-    }\n-}\n-\n-impl Index<BasicBlock> for ReadOnlyBodyCache<'a, 'tcx> {\n-    type Output = BasicBlockData<'tcx>;\n-\n-    fn index(&self, index: BasicBlock) -> &BasicBlockData<'tcx> {\n-        &self.body[index]\n+        &self.body\n     }\n }\n "}, {"sha": "801dfa81ef1785e2595379dfbf02f7f8acef5afd", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 26, "deletions": 80, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -1,16 +1,14 @@\n use crate::hir::CodegenFnAttrFlags;\n-use crate::hir::Unsafety;\n use crate::hir::def::Namespace;\n use crate::hir::def_id::DefId;\n-use crate::ty::{self, Ty, PolyFnSig, TypeFoldable, SubstsRef, TyCtxt};\n+use crate::ty::{self, Ty, TypeFoldable, SubstsRef, TyCtxt};\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::traits;\n use crate::middle::lang_items::DropInPlaceFnLangItem;\n use rustc_target::spec::abi::Abi;\n use rustc_macros::HashStable;\n \n use std::fmt;\n-use std::iter;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n #[derive(HashStable, Lift)]\n@@ -29,17 +27,26 @@ pub enum InstanceDef<'tcx> {\n \n     /// `fn()` pointer where the function itself cannot be turned into a pointer.\n     ///\n-    /// One example in the compiler today is functions annotated with `#[track_caller]`, which\n-    /// must have their implicit caller location argument populated for a call. Because this is a\n-    /// required part of the function's ABI but can't be tracked as a property of the function\n-    /// pointer, we create a single \"caller location\" at the site where the function is reified.\n+    /// One example is `<dyn Trait as Trait>::fn`, where the shim contains\n+    /// a virtual call, which codegen supports only via a direct call to the\n+    /// `<dyn Trait as Trait>::fn` instance (an `InstanceDef::Virtual`).\n+    ///\n+    /// Another example is functions annotated with `#[track_caller]`, which\n+    /// must have their implicit caller location argument populated for a call.\n+    /// Because this is a required part of the function's ABI but can't be tracked\n+    /// as a property of the function pointer, we use a single \"caller location\"\n+    /// (the definition of the function itself).\n     ReifyShim(DefId),\n \n     /// `<fn() as FnTrait>::call_*`\n     /// `DefId` is `FnTrait::call_*`.\n     FnPtrShim(DefId, Ty<'tcx>),\n \n-    /// `<dyn Trait as Trait>::fn`\n+    /// `<dyn Trait as Trait>::fn`, \"direct calls\" of which are implicitly\n+    /// codegen'd as virtual calls.\n+    ///\n+    /// NB: if this is reified to a `fn` pointer, a `ReifyShim` is used\n+    /// (see `ReifyShim` above for more details on that).\n     Virtual(DefId, usize),\n \n     /// `<[mut closure] as FnOnce>::call_once`\n@@ -61,70 +68,6 @@ impl<'tcx> Instance<'tcx> {\n             &ty,\n         )\n     }\n-\n-    fn fn_sig_noadjust(&self, tcx: TyCtxt<'tcx>) -> PolyFnSig<'tcx> {\n-        let ty = self.ty(tcx);\n-        match ty.kind {\n-            ty::FnDef(..) |\n-            // Shims currently have type FnPtr. Not sure this should remain.\n-            ty::FnPtr(_) => ty.fn_sig(tcx),\n-            ty::Closure(def_id, substs) => {\n-                let sig = substs.as_closure().sig(def_id, tcx);\n-\n-                let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n-                sig.map_bound(|sig| tcx.mk_fn_sig(\n-                    iter::once(*env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n-                    sig.output(),\n-                    sig.c_variadic,\n-                    sig.unsafety,\n-                    sig.abi\n-                ))\n-            }\n-            ty::Generator(def_id, substs, _) => {\n-                let sig = substs.as_generator().poly_sig(def_id, tcx);\n-\n-                let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n-                let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n-\n-                let pin_did = tcx.lang_items().pin_type().unwrap();\n-                let pin_adt_ref = tcx.adt_def(pin_did);\n-                let pin_substs = tcx.intern_substs(&[env_ty.into()]);\n-                let env_ty = tcx.mk_adt(pin_adt_ref, pin_substs);\n-\n-                sig.map_bound(|sig| {\n-                    let state_did = tcx.lang_items().gen_state().unwrap();\n-                    let state_adt_ref = tcx.adt_def(state_did);\n-                    let state_substs = tcx.intern_substs(&[\n-                        sig.yield_ty.into(),\n-                        sig.return_ty.into(),\n-                    ]);\n-                    let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n-\n-                    tcx.mk_fn_sig(iter::once(env_ty),\n-                        ret_ty,\n-                        false,\n-                        Unsafety::Normal,\n-                        Abi::Rust\n-                    )\n-                })\n-            }\n-            _ => bug!(\"unexpected type {:?} in Instance::fn_sig_noadjust\", ty)\n-        }\n-    }\n-\n-    pub fn fn_sig(&self, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        let mut fn_sig = self.fn_sig_noadjust(tcx);\n-        if let InstanceDef::VtableShim(..) = self.def {\n-            // Modify `fn(self, ...)` to `fn(self: *mut Self, ...)`.\n-            fn_sig = fn_sig.map_bound(|mut fn_sig| {\n-                let mut inputs_and_output = fn_sig.inputs_and_output.to_vec();\n-                inputs_and_output[0] = tcx.mk_mut_ptr(inputs_and_output[0]);\n-                fn_sig.inputs_and_output = tcx.intern_type_list(&inputs_and_output);\n-                fn_sig\n-            });\n-        }\n-        fn_sig\n-    }\n }\n \n impl<'tcx> InstanceDef<'tcx> {\n@@ -196,7 +139,7 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n                 write!(f, \" - intrinsic\")\n             }\n             InstanceDef::Virtual(_, num) => {\n-                write!(f, \" - shim(#{})\", num)\n+                write!(f, \" - virtual#{}\", num)\n             }\n             InstanceDef::FnPtrShim(_, ty) => {\n                 write!(f, \" - shim({:?})\", ty)\n@@ -311,20 +254,23 @@ impl<'tcx> Instance<'tcx> {\n         substs: SubstsRef<'tcx>,\n     ) -> Option<Instance<'tcx>> {\n         debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n-        Instance::resolve(tcx, param_env, def_id, substs).map(|resolved| {\n+        Instance::resolve(tcx, param_env, def_id, substs).map(|mut resolved| {\n             let has_track_caller = |def| tcx.codegen_fn_attrs(def).flags\n                 .contains(CodegenFnAttrFlags::TRACK_CALLER);\n \n             match resolved.def {\n                 InstanceDef::Item(def_id) if has_track_caller(def_id) => {\n                     debug!(\" => fn pointer created for function with #[track_caller]\");\n-                    Instance {\n-                        def: InstanceDef::ReifyShim(def_id),\n-                        substs,\n-                    }\n-                },\n-                _ => resolved,\n+                    resolved.def = InstanceDef::ReifyShim(def_id);\n+                }\n+                InstanceDef::Virtual(def_id, _) => {\n+                    debug!(\" => fn pointer created for virtual call\");\n+                    resolved.def = InstanceDef::ReifyShim(def_id);\n+                }\n+                _ => {}\n             }\n+\n+            resolved\n         })\n     }\n "}, {"sha": "7f93e8c91e9d939171e707f4bf4ecfaf2e14e14a", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 96, "deletions": 18, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -2339,6 +2339,76 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for LayoutError<'tcx> {\n     }\n }\n \n+\n+impl<'tcx> ty::Instance<'tcx> {\n+    // NOTE(eddyb) this is private to avoid using it from outside of\n+    // `FnAbi::of_instance` - any other uses are either too high-level\n+    // for `Instance` (e.g. typeck would use `Ty::fn_sig` instead),\n+    // or should go through `FnAbi` instead, to avoid losing any\n+    // adjustments `FnAbi::of_instance` might be performing.\n+    fn fn_sig_for_fn_abi(&self, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n+        let ty = self.ty(tcx);\n+        match ty.kind {\n+            ty::FnDef(..) |\n+            // Shims currently have type FnPtr. Not sure this should remain.\n+            ty::FnPtr(_) => {\n+                let mut sig = ty.fn_sig(tcx);\n+                if let ty::InstanceDef::VtableShim(..) = self.def {\n+                    // Modify `fn(self, ...)` to `fn(self: *mut Self, ...)`.\n+                    sig = sig.map_bound(|mut sig| {\n+                        let mut inputs_and_output = sig.inputs_and_output.to_vec();\n+                        inputs_and_output[0] = tcx.mk_mut_ptr(inputs_and_output[0]);\n+                        sig.inputs_and_output = tcx.intern_type_list(&inputs_and_output);\n+                        sig\n+                    });\n+                }\n+                sig\n+            }\n+            ty::Closure(def_id, substs) => {\n+                let sig = substs.as_closure().sig(def_id, tcx);\n+\n+                let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n+                sig.map_bound(|sig| tcx.mk_fn_sig(\n+                    iter::once(*env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n+                    sig.output(),\n+                    sig.c_variadic,\n+                    sig.unsafety,\n+                    sig.abi\n+                ))\n+            }\n+            ty::Generator(def_id, substs, _) => {\n+                let sig = substs.as_generator().poly_sig(def_id, tcx);\n+\n+                let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n+                let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n+\n+                let pin_did = tcx.lang_items().pin_type().unwrap();\n+                let pin_adt_ref = tcx.adt_def(pin_did);\n+                let pin_substs = tcx.intern_substs(&[env_ty.into()]);\n+                let env_ty = tcx.mk_adt(pin_adt_ref, pin_substs);\n+\n+                sig.map_bound(|sig| {\n+                    let state_did = tcx.lang_items().gen_state().unwrap();\n+                    let state_adt_ref = tcx.adt_def(state_did);\n+                    let state_substs = tcx.intern_substs(&[\n+                        sig.yield_ty.into(),\n+                        sig.return_ty.into(),\n+                    ]);\n+                    let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n+\n+                    tcx.mk_fn_sig(iter::once(env_ty),\n+                        ret_ty,\n+                        false,\n+                        hir::Unsafety::Normal,\n+                        rustc_target::spec::abi::Abi::Rust\n+                    )\n+                })\n+            }\n+            _ => bug!(\"unexpected type {:?} in Instance::fn_sig\", ty)\n+        }\n+    }\n+}\n+\n pub trait FnAbiExt<'tcx, C>\n where\n     C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n@@ -2347,12 +2417,22 @@ where\n         + HasTyCtxt<'tcx>\n         + HasParamEnv<'tcx>,\n {\n-    fn of_instance(cx: &C, instance: ty::Instance<'tcx>) -> Self;\n-    fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n-    fn new_vtable(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n+    /// Compute a `FnAbi` suitable for indirect calls, i.e. to `fn` pointers.\n+    ///\n+    /// NB: this doesn't handle virtual calls - those should use `FnAbi::of_instance`\n+    /// instead, where the instance is a `InstanceDef::Virtual`.\n+    fn of_fn_ptr(cx: &C, sig: ty::PolyFnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n+\n+    /// Compute a `FnAbi` suitable for declaring/defining an `fn` instance, and for\n+    /// direct calls to an `fn`.\n+    ///\n+    /// NB: that includes virtual calls, which are represented by \"direct calls\"\n+    /// to a `InstanceDef::Virtual` instance (of `<dyn Trait as Trait>::fn`).\n+    fn of_instance(cx: &C, instance: ty::Instance<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n+\n     fn new_internal(\n         cx: &C,\n-        sig: ty::FnSig<'tcx>,\n+        sig: ty::PolyFnSig<'tcx>,\n         extra_args: &[Ty<'tcx>],\n         mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgAbi<'tcx, Ty<'tcx>>,\n     ) -> Self;\n@@ -2367,25 +2447,19 @@ where\n         + HasTyCtxt<'tcx>\n         + HasParamEnv<'tcx>,\n {\n-    fn of_instance(cx: &C, instance: ty::Instance<'tcx>) -> Self {\n-        let sig = instance.fn_sig(cx.tcx());\n-        let sig = cx\n-            .tcx()\n-            .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-        call::FnAbi::new(cx, sig, &[])\n-    }\n-\n-    fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n+    fn of_fn_ptr(cx: &C, sig: ty::PolyFnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n         call::FnAbi::new_internal(cx, sig, extra_args, |ty, _| ArgAbi::new(cx.layout_of(ty)))\n     }\n \n-    fn new_vtable(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n-        FnAbiExt::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n+    fn of_instance(cx: &C, instance: ty::Instance<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n+        let sig = instance.fn_sig_for_fn_abi(cx.tcx());\n+\n+        call::FnAbi::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n             let mut layout = cx.layout_of(ty);\n             // Don't pass the vtable, it's not an argument of the virtual fn.\n             // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n             // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n-            if arg_idx == Some(0) {\n+            if let (ty::InstanceDef::Virtual(..), Some(0)) = (&instance.def, arg_idx) {\n                 let fat_pointer_ty = if layout.is_unsized() {\n                     // unsized `self` is passed as a pointer to `self`\n                     // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n@@ -2436,15 +2510,19 @@ where\n \n     fn new_internal(\n         cx: &C,\n-        sig: ty::FnSig<'tcx>,\n+        sig: ty::PolyFnSig<'tcx>,\n         extra_args: &[Ty<'tcx>],\n         mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgAbi<'tcx, Ty<'tcx>>,\n     ) -> Self {\n         debug!(\"FnAbi::new_internal({:?}, {:?})\", sig, extra_args);\n \n+        let sig = cx\n+            .tcx()\n+            .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+\n         use rustc_target::spec::abi::Abi::*;\n         let conv = match cx.tcx().sess.target.target.adjust_abi(sig.abi) {\n-            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => Conv::C,\n+            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => Conv::Rust,\n \n             // It's the ABI's job to select this, not ours.\n             System => bug!(\"system abi should be selected elsewhere\"),"}, {"sha": "1f3c8e1953e4f1709f2df3771f626ef37fae38f1", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -372,7 +372,7 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n \n     fn llvm_cconv(&self) -> llvm::CallConv {\n         match self.conv {\n-            Conv::C => llvm::CCallConv,\n+            Conv::C | Conv::Rust => llvm::CCallConv,\n             Conv::AmdGpuKernel => llvm::AmdGpuKernel,\n             Conv::ArmAapcs => llvm::ArmAapcsCallConv,\n             Conv::Msp430Intr => llvm::Msp430Intr,\n@@ -388,6 +388,11 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n     }\n \n     fn apply_attrs_llfn(&self, cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value) {\n+        // FIXME(eddyb) can this also be applied to callsites?\n+        if self.ret.layout.abi.is_uninhabited() {\n+            llvm::Attribute::NoReturn.apply_llfn(llvm::AttributePlace::Function, llfn);\n+        }\n+\n         let mut i = 0;\n         let mut apply = |attrs: &ArgAttributes, ty: Option<&Type>| {\n             attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn, ty);"}, {"sha": "33dc2513de5844892e35e0a94007dab34904bc21", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -2,19 +2,20 @@\n \n use std::ffi::CString;\n \n-use rustc::hir::{CodegenFnAttrFlags, CodegenFnAttrs};\n+use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::session::Session;\n use rustc::session::config::{Sanitizer, OptLevel};\n-use rustc::ty::{self, TyCtxt, PolyFnSig};\n+use rustc::ty::{self, TyCtxt, Ty};\n use rustc::ty::layout::HasTyCtxt;\n use rustc::ty::query::Providers;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_target::abi::call::Conv;\n use rustc_target::spec::PanicStrategy;\n use rustc_codegen_ssa::traits::*;\n \n-use crate::abi::Abi;\n+use crate::abi::FnAbi;\n use crate::attributes;\n use crate::llvm::{self, Attribute};\n use crate::llvm::AttributePlace::Function;\n@@ -26,7 +27,7 @@ use crate::value::Value;\n \n /// Mark LLVM function to use provided inline heuristic.\n #[inline]\n-pub fn inline(cx: &CodegenCx<'ll, '_>, val: &'ll Value, inline: InlineAttr) {\n+fn inline(cx: &CodegenCx<'ll, '_>, val: &'ll Value, inline: InlineAttr) {\n     use self::InlineAttr::*;\n     match inline {\n         Hint   => Attribute::InlineHint.apply_llfn(Function, val),\n@@ -58,7 +59,7 @@ fn unwind(val: &'ll Value, can_unwind: bool) {\n \n /// Tell LLVM if this function should be 'naked', i.e., skip the epilogue and prologue.\n #[inline]\n-pub fn naked(val: &'ll Value, is_naked: bool) {\n+fn naked(val: &'ll Value, is_naked: bool) {\n     Attribute::Naked.toggle_llfn(Function, val, is_naked);\n }\n \n@@ -72,7 +73,7 @@ pub fn set_frame_pointer_elimination(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value)\n \n /// Tell LLVM what instrument function to insert.\n #[inline]\n-pub fn set_instrument_function(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n+fn set_instrument_function(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     if cx.sess().instrument_mcount() {\n         // Similar to `clang -pg` behavior. Handled by the\n         // `post-inline-ee-instrument` LLVM pass.\n@@ -88,7 +89,7 @@ pub fn set_instrument_function(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     }\n }\n \n-pub fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n+fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     // Only use stack probes if the target specification indicates that we\n     // should be using stack probes\n     if !cx.sess().target.target.options.stack_probes {\n@@ -202,11 +203,10 @@ pub(crate) fn default_optimisation_attrs(sess: &Session, llfn: &'ll Value) {\n pub fn from_fn_attrs(\n     cx: &CodegenCx<'ll, 'tcx>,\n     llfn: &'ll Value,\n-    id: Option<DefId>,\n-    sig: PolyFnSig<'tcx>,\n+    instance: ty::Instance<'tcx>,\n+    fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n ) {\n-    let codegen_fn_attrs = id.map(|id| cx.tcx.codegen_fn_attrs(id))\n-        .unwrap_or_else(|| CodegenFnAttrs::new());\n+    let codegen_fn_attrs = cx.tcx.codegen_fn_attrs(instance.def_id());\n \n     match codegen_fn_attrs.optimize {\n         OptimizeAttr::None => {\n@@ -224,6 +224,11 @@ pub fn from_fn_attrs(\n         }\n     }\n \n+    // FIXME(eddyb) consolidate these two `inline` calls (and avoid overwrites).\n+    if instance.def.is_inline(cx.tcx) {\n+        inline(cx, llfn, attributes::InlineAttr::Hint);\n+    }\n+\n     inline(cx, llfn, codegen_fn_attrs.inline);\n \n     // The `uwtable` attribute according to LLVM is:\n@@ -276,8 +281,7 @@ pub fn from_fn_attrs(\n         // Special attribute for allocator functions, which can't unwind.\n         false\n     } else {\n-        let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-        if sig.abi == Abi::Rust || sig.abi == Abi::RustCall {\n+        if fn_abi.conv == Conv::Rust {\n             // Any Rust method (or `extern \"Rust\" fn` or `extern\n             // \"rust-call\" fn`) is explicitly allowed to unwind\n             // (unless it has no-unwind attribute, handled above).\n@@ -331,16 +335,14 @@ pub fn from_fn_attrs(\n     // Note that currently the `wasm-import-module` doesn't do anything, but\n     // eventually LLVM 7 should read this and ferry the appropriate import\n     // module to the output file.\n-    if let Some(id) = id {\n-        if cx.tcx.sess.target.target.arch == \"wasm32\" {\n-            if let Some(module) = wasm_import_module(cx.tcx, id) {\n-                llvm::AddFunctionAttrStringValue(\n-                    llfn,\n-                    llvm::AttributePlace::Function,\n-                    const_cstr!(\"wasm-import-module\"),\n-                    &module,\n-                );\n-            }\n+    if cx.tcx.sess.target.target.arch == \"wasm32\" {\n+        if let Some(module) = wasm_import_module(cx.tcx, instance.def_id()) {\n+            llvm::AddFunctionAttrStringValue(\n+                llfn,\n+                llvm::AttributePlace::Function,\n+                const_cstr!(\"wasm-import-module\"),\n+                &module,\n+            );\n         }\n     }\n }"}, {"sha": "e0db7cae99e1ae8ed2a9756f513baa13268e0215", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -4,14 +4,15 @@\n //! and methods are represented as just a fn ptr and not a full\n //! closure.\n \n+use crate::abi::{FnAbi, FnAbiLlvmExt};\n use crate::attributes;\n use crate::llvm;\n use crate::context::CodegenCx;\n use crate::value::Value;\n use rustc_codegen_ssa::traits::*;\n \n use rustc::ty::{TypeFoldable, Instance};\n-use rustc::ty::layout::{LayoutOf, HasTyCtxt};\n+use rustc::ty::layout::{FnAbiExt, HasTyCtxt};\n \n /// Codegens a reference to a fn/method item, monomorphizing and\n /// inlining as it goes.\n@@ -32,19 +33,19 @@ pub fn get_fn(\n     assert!(!instance.substs.has_escaping_bound_vars());\n     assert!(!instance.substs.has_param_types());\n \n-    let sig = instance.fn_sig(cx.tcx());\n     if let Some(&llfn) = cx.instances.borrow().get(&instance) {\n         return llfn;\n     }\n \n     let sym = tcx.symbol_name(instance).name.as_str();\n-    debug!(\"get_fn({:?}: {:?}) => {}\", instance, sig, sym);\n+    debug!(\"get_fn({:?}: {:?}) => {}\", instance, instance.ty(cx.tcx()), sym);\n \n-    // Create a fn pointer with the substituted signature.\n-    let fn_ptr_ty = tcx.mk_fn_ptr(sig);\n-    let llptrty = cx.backend_type(cx.layout_of(fn_ptr_ty));\n+    let fn_abi = FnAbi::of_instance(cx, instance, &[]);\n \n     let llfn = if let Some(llfn) = cx.get_declared_value(&sym) {\n+        // Create a fn pointer with the new signature.\n+        let llptrty = fn_abi.ptr_to_llvm_type(cx);\n+\n         // This is subtle and surprising, but sometimes we have to bitcast\n         // the resulting fn pointer.  The reason has to do with external\n         // functions.  If you have two crates that both bind the same C\n@@ -76,14 +77,10 @@ pub fn get_fn(\n             llfn\n         }\n     } else {\n-        let llfn = cx.declare_fn(&sym, sig);\n-        assert_eq!(cx.val_ty(llfn), llptrty);\n+        let llfn = cx.declare_fn(&sym, &fn_abi);\n         debug!(\"get_fn: not casting pointer!\");\n \n-        if instance.def.is_inline(tcx) {\n-            attributes::inline(cx, llfn, attributes::InlineAttr::Hint);\n-        }\n-        attributes::from_fn_attrs(cx, llfn, Some(instance.def.def_id()), sig);\n+        attributes::from_fn_attrs(cx, llfn, instance, &fn_abi);\n \n         let instance_def_id = instance.def_id();\n "}, {"sha": "39ea1f6f5dccf0be55a8dc59f7064befd9fcb99e", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -1,3 +1,4 @@\n+use crate::abi::FnAbi;\n use crate::attributes;\n use crate::llvm;\n use crate::llvm_util;\n@@ -15,7 +16,7 @@ use rustc::mir::mono::CodegenUnit;\n use rustc::session::config::{self, DebugInfo};\n use rustc::session::Session;\n use rustc::ty::layout::{\n-    LayoutError, LayoutOf, PointeeInfo, Size, TyLayout, VariantIdx, HasParamEnv\n+    FnAbiExt, LayoutError, LayoutOf, PointeeInfo, Size, TyLayout, VariantIdx, HasParamEnv\n };\n use rustc::ty::{self, Ty, TyCtxt, Instance};\n use rustc::util::nodemap::FxHashMap;\n@@ -420,7 +421,8 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             Abi::C\n         ));\n \n-        let llfn = self.declare_fn(\"rust_eh_unwind_resume\", sig);\n+        let fn_abi = FnAbi::of_fn_ptr(self, sig, &[]);\n+        let llfn = self.declare_fn(\"rust_eh_unwind_resume\", &fn_abi);\n         attributes::apply_target_cpu_attr(self, llfn);\n         unwresume.set(Some(llfn));\n         llfn"}, {"sha": "c2359a2fe6d94c184cee24d26d69f0193d5d3f1c", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -16,7 +16,7 @@ use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::ty::subst::{SubstsRef, GenericArgKind};\n \n-use crate::abi::Abi;\n+use crate::abi::FnAbi;\n use crate::common::CodegenCx;\n use crate::builder::Builder;\n use crate::value::Value;\n@@ -280,7 +280,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn create_function_debug_context(\n         &self,\n         instance: Instance<'tcx>,\n-        sig: ty::FnSig<'tcx>,\n+        fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n         llfn: &'ll Value,\n         mir: &mir::Body<'_>,\n     ) -> Option<FunctionDebugContext<&'ll DIScope>> {\n@@ -308,7 +308,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let file_metadata = file_metadata(self, &loc.file.name, def_id.krate);\n \n         let function_type_metadata = unsafe {\n-            let fn_signature = get_function_signature(self, sig);\n+            let fn_signature = get_function_signature(self, fn_abi);\n             llvm::LLVMRustDIBuilderCreateSubroutineType(DIB(self), file_metadata, fn_signature)\n         };\n \n@@ -338,7 +338,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         let mut flags = DIFlags::FlagPrototyped;\n \n-        if self.layout_of(sig.output()).abi.is_uninhabited() {\n+        if fn_abi.ret.layout.abi.is_uninhabited() {\n             flags |= DIFlags::FlagNoReturn;\n         }\n \n@@ -392,25 +392,20 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         fn get_function_signature<'ll, 'tcx>(\n             cx: &CodegenCx<'ll, 'tcx>,\n-            sig: ty::FnSig<'tcx>,\n+            fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n         ) -> &'ll DIArray {\n             if cx.sess().opts.debuginfo == DebugInfo::Limited {\n                 return create_DIArray(DIB(cx), &[]);\n             }\n \n-            let mut signature = Vec::with_capacity(sig.inputs().len() + 1);\n+            let mut signature = Vec::with_capacity(fn_abi.args.len() + 1);\n \n             // Return type -- llvm::DIBuilder wants this at index 0\n-            signature.push(match sig.output().kind {\n-                ty::Tuple(ref tys) if tys.is_empty() => None,\n-                _ => Some(type_metadata(cx, sig.output(), syntax_pos::DUMMY_SP))\n-            });\n-\n-            let inputs = if sig.abi == Abi::RustCall {\n-                &sig.inputs()[..sig.inputs().len() - 1]\n+            signature.push(if fn_abi.ret.is_ignore() {\n+                None\n             } else {\n-                sig.inputs()\n-            };\n+                Some(type_metadata(cx, fn_abi.ret.layout.ty, syntax_pos::DUMMY_SP))\n+            });\n \n             // Arguments types\n             if cx.sess().target.target.options.is_like_msvc {\n@@ -424,7 +419,8 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 // and a function `fn bar(x: [(); 7])` as `fn bar(x: *const ())`.\n                 // This transformed type is wrong, but these function types are\n                 // already inaccurate due to ABI adjustments (see #42800).\n-                signature.extend(inputs.iter().map(|&t| {\n+                signature.extend(fn_abi.args.iter().map(|arg| {\n+                    let t = arg.layout.ty;\n                     let t = match t.kind {\n                         ty::Array(ct, _)\n                             if (ct == cx.tcx.types.u8) || cx.layout_of(ct).is_zst() => {\n@@ -435,21 +431,11 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                     Some(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n                 }));\n             } else {\n-                signature.extend(inputs.iter().map(|t| {\n-                    Some(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n+                signature.extend(fn_abi.args.iter().map(|arg| {\n+                    Some(type_metadata(cx, arg.layout.ty, syntax_pos::DUMMY_SP))\n                 }));\n             }\n \n-            if sig.abi == Abi::RustCall && !sig.inputs().is_empty() {\n-                if let ty::Tuple(args) = sig.inputs()[sig.inputs().len() - 1].kind {\n-                    signature.extend(\n-                        args.iter().map(|argument_type| {\n-                            Some(type_metadata(cx, argument_type.expect_ty(), syntax_pos::DUMMY_SP))\n-                        })\n-                    );\n-                }\n-            }\n-\n             create_DIArray(DIB(cx), &signature[..])\n         }\n "}, {"sha": "8b6fedc87db968b35a5ac02ca0b60b91c4bf2687", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 3, "deletions": 35, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -18,8 +18,7 @@ use crate::attributes;\n use crate::context::CodegenCx;\n use crate::type_::Type;\n use crate::value::Value;\n-use rustc::ty::{self, PolyFnSig};\n-use rustc::ty::layout::{FnAbiExt, LayoutOf};\n+use rustc::ty::Ty;\n use rustc::session::config::Sanitizer;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_codegen_ssa::traits::*;\n@@ -94,21 +93,12 @@ impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn declare_fn(\n         &self,\n         name: &str,\n-        sig: PolyFnSig<'tcx>,\n+        fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n     ) -> &'ll Value {\n-        debug!(\"declare_rust_fn(name={:?}, sig={:?})\", name, sig);\n-        let sig = self.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-        debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n+        debug!(\"declare_rust_fn(name={:?}, fn_abi={:?})\", name, fn_abi);\n \n-        let fn_abi = FnAbi::new(self, sig, &[]);\n         let llfn = declare_raw_fn(self, name, fn_abi.llvm_cconv(), fn_abi.llvm_type(self));\n-\n-        if self.layout_of(sig.output()).abi.is_uninhabited() {\n-            llvm::Attribute::NoReturn.apply_llfn(Function, llfn);\n-        }\n-\n         fn_abi.apply_attrs_llfn(self, llfn);\n-\n         llfn\n     }\n \n@@ -130,28 +120,6 @@ impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn define_fn(\n-        &self,\n-        name: &str,\n-        fn_sig: PolyFnSig<'tcx>,\n-    ) -> &'ll Value {\n-        if self.get_defined_value(name).is_some() {\n-            self.sess().fatal(&format!(\"symbol `{}` already defined\", name))\n-        } else {\n-            self.declare_fn(name, fn_sig)\n-        }\n-    }\n-\n-    fn define_internal_fn(\n-        &self,\n-        name: &str,\n-        fn_sig: PolyFnSig<'tcx>,\n-    ) -> &'ll Value {\n-        let llfn = self.define_fn(name, fn_sig);\n-        unsafe { llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::InternalLinkage) };\n-        llfn\n-    }\n-\n     fn get_declared_value(&self, name: &str) -> Option<&'ll Value> {\n         debug!(\"get_declared_value(name={:?})\", name);\n         let namebuf = SmallCStr::new(name);"}, {"sha": "9df75a800f1239a971a56e771181aace6cd88fc6", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -1,4 +1,3 @@\n-use crate::attributes;\n use crate::llvm;\n use crate::llvm_util;\n use crate::abi::{Abi, FnAbi, LlvmType, PassMode};\n@@ -14,7 +13,7 @@ use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::glue;\n use rustc_codegen_ssa::base::{to_immediate, wants_msvc_seh, compare_simd_types};\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, Primitive};\n+use rustc::ty::layout::{self, FnAbiExt, LayoutOf, HasTyCtxt, Primitive};\n use rustc::mir::interpret::GlobalId;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n use rustc::hir;\n@@ -992,8 +991,10 @@ fn gen_fn<'ll, 'tcx>(\n         hir::Unsafety::Unsafe,\n         Abi::Rust\n     ));\n-    let llfn = cx.define_internal_fn(name, rust_fn_sig);\n-    attributes::from_fn_attrs(cx, llfn, None, rust_fn_sig);\n+    let fn_abi = FnAbi::of_fn_ptr(cx, rust_fn_sig, &[]);\n+    let llfn = cx.declare_fn(name, &fn_abi);\n+    // FIXME(eddyb) find a nicer way to do this.\n+    unsafe { llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::InternalLinkage) };\n     let bx = Builder::new_block(cx, llfn, \"entry-block\");\n     codegen(bx);\n     llfn"}, {"sha": "cbc8af4fd27109ed6e1672a9020f463dacba4228", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -1,3 +1,4 @@\n+use crate::abi::FnAbi;\n use crate::attributes;\n use crate::base;\n use crate::context::CodegenCx;\n@@ -6,7 +7,7 @@ use crate::type_of::LayoutLlvmExt;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::mir::mono::{Linkage, Visibility};\n use rustc::ty::{TypeFoldable, Instance};\n-use rustc::ty::layout::{LayoutOf, HasTyCtxt};\n+use rustc::ty::layout::{FnAbiExt, LayoutOf};\n use rustc_codegen_ssa::traits::*;\n \n pub use rustc::mir::mono::MonoItem;\n@@ -42,10 +43,10 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         assert!(!instance.substs.needs_infer() &&\n                 !instance.substs.has_param_types());\n \n-        let mono_sig = instance.fn_sig(self.tcx());\n-        let attrs = self.tcx.codegen_fn_attrs(instance.def_id());\n-        let lldecl = self.declare_fn(symbol_name, mono_sig);\n+        let fn_abi = FnAbi::of_instance(self, instance, &[]);\n+        let lldecl = self.declare_fn(symbol_name, &fn_abi);\n         unsafe { llvm::LLVMRustSetLinkage(lldecl, base::linkage_to_llvm(linkage)) };\n+        let attrs = self.tcx.codegen_fn_attrs(instance.def_id());\n         base::set_link_section(lldecl, &attrs);\n         if linkage == Linkage::LinkOnceODR ||\n             linkage == Linkage::WeakODR {\n@@ -67,16 +68,9 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             }\n         }\n \n-        debug!(\"predefine_fn: mono_sig = {:?} instance = {:?}\", mono_sig, instance);\n-        if instance.def.is_inline(self.tcx) {\n-            attributes::inline(self, lldecl, attributes::InlineAttr::Hint);\n-        }\n-        attributes::from_fn_attrs(\n-            self,\n-            lldecl,\n-            Some(instance.def.def_id()),\n-            mono_sig,\n-        );\n+        debug!(\"predefine_fn: instance = {:?}\", instance);\n+\n+        attributes::from_fn_attrs(self, lldecl, instance, &fn_abi);\n \n         self.instances.borrow_mut().insert(instance, lldecl);\n     }"}, {"sha": "d77bbb279216a79e77b8905cea153cc020b75c54", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -235,11 +235,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                     cx.type_ptr_to(cx.layout_of(self.ty.boxed_ty()).llvm_type(cx))\n                 }\n                 ty::FnPtr(sig) => {\n-                    let sig = cx.tcx.normalize_erasing_late_bound_regions(\n-                        ty::ParamEnv::reveal_all(),\n-                        &sig,\n-                    );\n-                    cx.fn_ptr_backend_type(&FnAbi::new(cx, sig, &[]))\n+                    cx.fn_ptr_backend_type(&FnAbi::of_fn_ptr(cx, sig, &[]))\n                 }\n                 _ => self.scalar_llvm_type_at(cx, scalar, Size::ZERO)\n             };"}, {"sha": "f6725e66f03e6dd3552a3954970eb100359137b5", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -368,13 +368,7 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     // release builds.\n     info!(\"codegen_instance({})\", instance);\n \n-    let sig = instance.fn_sig(cx.tcx());\n-    let sig = cx.tcx().normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-\n-    let lldecl = cx.get_fn(instance);\n-\n-    let mir = cx.tcx().instance_mir(instance.def);\n-    mir::codegen_mir::<Bx>(cx, lldecl, mir, instance, sig);\n+    mir::codegen_mir::<Bx>(cx, instance);\n }\n \n /// Creates the `main` function which will initialize the rust runtime and call"}, {"sha": "6c627085b2ed8734c4b868d022f0764e7d38015f", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -131,7 +131,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             };\n             if is_consume {\n                 let base_ty =\n-                    mir::Place::ty_from(place_ref.base, proj_base, &*self.fx.mir, cx.tcx());\n+                    mir::Place::ty_from(place_ref.base, proj_base, *self.fx.mir, cx.tcx());\n                 let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access."}, {"sha": "6dccf329c9f645cae71dc6c41c183ae00b9b5783", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -24,28 +24,28 @@ use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n /// Used by `FunctionCx::codegen_terminator` for emitting common patterns\n /// e.g., creating a basic block, calling a function, etc.\n-struct TerminatorCodegenHelper<'a, 'tcx> {\n-    bb: &'a mir::BasicBlock,\n-    terminator: &'a mir::Terminator<'tcx>,\n+struct TerminatorCodegenHelper<'tcx> {\n+    bb: mir::BasicBlock,\n+    terminator: &'tcx mir::Terminator<'tcx>,\n     funclet_bb: Option<mir::BasicBlock>,\n }\n \n-impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n+impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n     /// Returns the associated funclet from `FunctionCx::funclets` for the\n     /// `funclet_bb` member if it is not `None`.\n-    fn funclet<'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n+    fn funclet<'b, Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n-        fx: &'c mut FunctionCx<'b, 'tcx, Bx>,\n-    ) -> Option<&'c Bx::Funclet> {\n+        fx: &'b mut FunctionCx<'a, 'tcx, Bx>,\n+    ) -> Option<&'b Bx::Funclet> {\n         match self.funclet_bb {\n             Some(funcl) => fx.funclets[funcl].as_ref(),\n             None => None,\n         }\n     }\n \n-    fn lltarget<'b, 'c, Bx: BuilderMethods<'b, 'tcx>>(\n+    fn lltarget<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n-        fx: &'c mut FunctionCx<'b, 'tcx, Bx>,\n+        fx: &mut FunctionCx<'a, 'tcx, Bx>,\n         target: mir::BasicBlock,\n     ) -> (Bx::BasicBlock, bool) {\n         let span = self.terminator.source_info.span;\n@@ -63,9 +63,9 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n     }\n \n     /// Create a basic block.\n-    fn llblock<'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n+    fn llblock<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n-        fx: &'c mut FunctionCx<'b, 'tcx, Bx>,\n+        fx: &mut FunctionCx<'a, 'tcx, Bx>,\n         target: mir::BasicBlock,\n     ) -> Bx::BasicBlock {\n         let (lltarget, is_cleanupret) = self.lltarget(fx, target);\n@@ -83,9 +83,9 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n         }\n     }\n \n-    fn funclet_br<'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n+    fn funclet_br<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n-        fx: &'c mut FunctionCx<'b, 'tcx, Bx>,\n+        fx: &mut FunctionCx<'a, 'tcx, Bx>,\n         bx: &mut Bx,\n         target: mir::BasicBlock,\n     ) {\n@@ -101,9 +101,9 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n \n     /// Call `fn_ptr` of `fn_abi` with the arguments `llargs`, the optional\n     /// return destination `destination` and the cleanup function `cleanup`.\n-    fn do_call<'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n+    fn do_call<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n-        fx: &'c mut FunctionCx<'b, 'tcx, Bx>,\n+        fx: &mut FunctionCx<'a, 'tcx, Bx>,\n         bx: &mut Bx,\n         fn_abi: FnAbi<'tcx, Ty<'tcx>>,\n         fn_ptr: Bx::Value,\n@@ -132,7 +132,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n         } else {\n             let llret = bx.call(fn_ptr, &llargs, self.funclet(fx));\n             bx.apply_attrs_callsite(&fn_abi, llret);\n-            if fx.mir[*self.bb].is_cleanup {\n+            if fx.mir[self.bb].is_cleanup {\n                 // Cleanup is always the cold path. Don't inline\n                 // drop glue. Also, when there is a deeply-nested\n                 // struct, there are \"symmetry\" issues that cause\n@@ -151,15 +151,15 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n \n     // Generate sideeffect intrinsic if jumping to any of the targets can form\n     // a loop.\n-    fn maybe_sideeffect<'b, 'tcx2: 'b, Bx: BuilderMethods<'b, 'tcx2>>(\n+    fn maybe_sideeffect<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n-        mir: mir::ReadOnlyBodyCache<'b, 'tcx>,\n+        mir: mir::ReadOnlyBodyCache<'tcx, 'tcx>,\n         bx: &mut Bx,\n         targets: &[mir::BasicBlock],\n     ) {\n         if bx.tcx().sess.opts.debugging_opts.insert_sideeffect {\n-            if targets.iter().any(|target| {\n-                *target <= *self.bb\n+            if targets.iter().any(|&target| {\n+                target <= self.bb\n                     && target\n                         .start_location()\n                         .is_predecessor_of(self.bb.start_location(), mir)\n@@ -173,9 +173,9 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n /// Codegen implementations for some terminator variants.\n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     /// Generates code for a `Resume` terminator.\n-    fn codegen_resume_terminator<'b>(\n+    fn codegen_resume_terminator(\n         &mut self,\n-        helper: TerminatorCodegenHelper<'b, 'tcx>,\n+        helper: TerminatorCodegenHelper<'tcx>,\n         mut bx: Bx,\n     ) {\n         if let Some(funclet) = helper.funclet(self) {\n@@ -201,9 +201,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n     }\n \n-    fn codegen_switchint_terminator<'b>(\n+    fn codegen_switchint_terminator(\n         &mut self,\n-        helper: TerminatorCodegenHelper<'b, 'tcx>,\n+        helper: TerminatorCodegenHelper<'tcx>,\n         mut bx: Bx,\n         discr: &mir::Operand<'tcx>,\n         switch_ty: Ty<'tcx>,\n@@ -316,15 +316,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     }\n \n \n-    fn codegen_drop_terminator<'b>(\n+    fn codegen_drop_terminator(\n         &mut self,\n-        helper: TerminatorCodegenHelper<'b, 'tcx>,\n+        helper: TerminatorCodegenHelper<'tcx>,\n         mut bx: Bx,\n         location: &mir::Place<'tcx>,\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n     ) {\n-        let ty = location.ty(&*self.mir, bx.tcx()).ty;\n+        let ty = location.ty(*self.mir, bx.tcx()).ty;\n         let ty = self.monomorphize(&ty);\n         let drop_fn = Instance::resolve_drop_in_place(bx.tcx(), ty);\n \n@@ -345,20 +345,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             &args1[..]\n         };\n         let (drop_fn, fn_abi) = match ty.kind {\n+            // FIXME(eddyb) perhaps move some of this logic into\n+            // `Instance::resolve_drop_in_place`?\n             ty::Dynamic(..) => {\n-                let sig = drop_fn.fn_sig(self.cx.tcx());\n-                let sig = self.cx.tcx().normalize_erasing_late_bound_regions(\n-                    ty::ParamEnv::reveal_all(),\n-                    &sig,\n-                );\n-                let fn_abi = FnAbi::new_vtable(&bx, sig, &[]);\n+                let virtual_drop = Instance {\n+                    def: ty::InstanceDef::Virtual(drop_fn.def_id(), 0),\n+                    substs: drop_fn.substs,\n+                };\n+                let fn_abi = FnAbi::of_instance(&bx, virtual_drop, &[]);\n                 let vtable = args[1];\n                 args = &args[..1];\n                 (meth::DESTRUCTOR.get_fn(&mut bx, vtable, &fn_abi), fn_abi)\n             }\n             _ => {\n                 (bx.get_fn_addr(drop_fn),\n-                 FnAbi::of_instance(&bx, drop_fn))\n+                 FnAbi::of_instance(&bx, drop_fn, &[]))\n             }\n         };\n         helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n@@ -367,9 +368,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                        unwind);\n     }\n \n-    fn codegen_assert_terminator<'b>(\n+    fn codegen_assert_terminator(\n         &mut self,\n-        helper: TerminatorCodegenHelper<'b, 'tcx>,\n+        helper: TerminatorCodegenHelper<'tcx>,\n         mut bx: Bx,\n         terminator: &mir::Terminator<'tcx>,\n         cond: &mir::Operand<'tcx>,\n@@ -439,16 +440,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Obtain the panic entry point.\n         let def_id = common::langcall(bx.tcx(), Some(span), \"\", lang_item);\n         let instance = ty::Instance::mono(bx.tcx(), def_id);\n-        let fn_abi = FnAbi::of_instance(&bx, instance);\n+        let fn_abi = FnAbi::of_instance(&bx, instance, &[]);\n         let llfn = bx.get_fn_addr(instance);\n \n         // Codegen the actual panic invoke/call.\n         helper.do_call(self, &mut bx, fn_abi, llfn, &args, None, cleanup);\n     }\n \n-    fn codegen_call_terminator<'b>(\n+    fn codegen_call_terminator(\n         &mut self,\n-        helper: TerminatorCodegenHelper<'b, 'tcx>,\n+        helper: TerminatorCodegenHelper<'tcx>,\n         mut bx: Bx,\n         terminator: &mir::Terminator<'tcx>,\n         func: &mir::Operand<'tcx>,\n@@ -474,12 +475,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             _ => bug!(\"{} is not callable\", callee.layout.ty),\n         };\n         let def = instance.map(|i| i.def);\n+\n+        if let Some(ty::InstanceDef::DropGlue(_, None)) = def {\n+            // Empty drop glue; a no-op.\n+            let &(_, target) = destination.as_ref().unwrap();\n+            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+            helper.funclet_br(self, &mut bx, target);\n+            return;\n+        }\n+\n+        // FIXME(eddyb) avoid computing this if possible, when `instance` is\n+        // available - right now `sig` is only needed for getting the `abi`\n+        // and figuring out how many extra args were passed to a C-variadic `fn`.\n         let sig = callee.layout.ty.fn_sig(bx.tcx());\n-        let sig = bx.tcx().normalize_erasing_late_bound_regions(\n-            ty::ParamEnv::reveal_all(),\n-            &sig,\n-        );\n-        let abi = sig.abi;\n+        let abi = sig.abi();\n \n         // Handle intrinsics old codegen wants Expr's for, ourselves.\n         let intrinsic = match def {\n@@ -489,6 +498,17 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         };\n         let intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n \n+        let extra_args = &args[sig.inputs().skip_binder().len()..];\n+        let extra_args = extra_args.iter().map(|op_arg| {\n+            let op_ty = op_arg.ty(*self.mir, bx.tcx());\n+            self.monomorphize(&op_ty)\n+        }).collect::<Vec<_>>();\n+\n+        let fn_abi = match instance {\n+            Some(instance) => FnAbi::of_instance(&bx, instance, &extra_args),\n+            None => FnAbi::of_fn_ptr(&bx, sig, &extra_args)\n+        };\n+\n         if intrinsic == Some(\"transmute\") {\n             if let Some(destination_ref) = destination.as_ref() {\n                 let &(ref dest, target) = destination_ref;\n@@ -502,32 +522,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // we can do what we like. Here, we declare that transmuting\n                 // into an uninhabited type is impossible, so anything following\n                 // it must be unreachable.\n-                assert_eq!(bx.layout_of(sig.output()).abi, layout::Abi::Uninhabited);\n+                assert_eq!(fn_abi.ret.layout.abi, layout::Abi::Uninhabited);\n                 bx.unreachable();\n             }\n             return;\n         }\n \n-        let extra_args = &args[sig.inputs().len()..];\n-        let extra_args = extra_args.iter().map(|op_arg| {\n-            let op_ty = op_arg.ty(&*self.mir, bx.tcx());\n-            self.monomorphize(&op_ty)\n-        }).collect::<Vec<_>>();\n-\n-        let fn_abi = match def {\n-            Some(ty::InstanceDef::Virtual(..)) => {\n-                FnAbi::new_vtable(&bx, sig, &extra_args)\n-            }\n-            Some(ty::InstanceDef::DropGlue(_, None)) => {\n-                // Empty drop glue; a no-op.\n-                let &(_, target) = destination.as_ref().unwrap();\n-                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n-                helper.funclet_br(self, &mut bx, target);\n-                return;\n-            }\n-            _ => FnAbi::new(&bx, sig, &extra_args)\n-        };\n-\n         // For normal codegen, this Miri-specific intrinsic is just a NOP.\n         if intrinsic == Some(\"miri_start_panic\") {\n             let target = destination.as_ref().unwrap().1;\n@@ -549,7 +549,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let def_id =\n                     common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                let fn_abi = FnAbi::of_instance(&bx, instance);\n+                let fn_abi = FnAbi::of_instance(&bx, instance, &[]);\n                 let llfn = bx.get_fn_addr(instance);\n \n                 if let Some((_, target)) = destination.as_ref() {\n@@ -807,14 +807,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         &mut self,\n         mut bx: Bx,\n         bb: mir::BasicBlock,\n-        terminator: &mir::Terminator<'tcx>\n+        terminator: &'tcx mir::Terminator<'tcx>\n     ) {\n         debug!(\"codegen_terminator: {:?}\", terminator);\n \n         // Create the cleanup bundle, if needed.\n         let funclet_bb = self.cleanup_kinds[bb].funclet_bb(bb);\n         let helper = TerminatorCodegenHelper {\n-            bb: &bb, terminator, funclet_bb\n+            bb, terminator, funclet_bb\n         };\n \n         self.set_debug_loc(&mut bx, terminator.source_info);"}, {"sha": "3a157ca24a47092a759c75d8158aa4369f1cfb70", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -1,6 +1,6 @@\n use rustc::ty::{self, Ty, TypeFoldable, Instance};\n use rustc::ty::layout::{TyLayout, HasTyCtxt, FnAbiExt};\n-use rustc::mir::{self, Body, ReadOnlyBodyCache};\n+use rustc::mir;\n use rustc_target::abi::call::{FnAbi, PassMode};\n use crate::base;\n use crate::traits::*;\n@@ -21,7 +21,7 @@ use self::operand::{OperandRef, OperandValue};\n pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     instance: Instance<'tcx>,\n \n-    mir: mir::ReadOnlyBodyCache<'a, 'tcx>,\n+    mir: mir::ReadOnlyBodyCache<'tcx, 'tcx>,\n \n     debug_context: Option<FunctionDebugContext<Bx::DIScope>>,\n \n@@ -76,7 +76,7 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n \n     /// All `VarDebuginfo` from the MIR body, partitioned by `Local`.\n     /// This is `None` if no variable debuginfo/names are needed.\n-    per_local_var_debug_info: Option<IndexVec<mir::Local, Vec<&'a mir::VarDebugInfo<'tcx>>>>,\n+    per_local_var_debug_info: Option<IndexVec<mir::Local, Vec<&'tcx mir::VarDebugInfo<'tcx>>>>,\n }\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n@@ -121,18 +121,18 @@ impl<'a, 'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n \n pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n-    llfn: Bx::Function,\n-    mir: ReadOnlyBodyCache<'a, 'tcx>,\n     instance: Instance<'tcx>,\n-    sig: ty::FnSig<'tcx>,\n ) {\n     assert!(!instance.substs.needs_infer());\n \n-    let fn_abi = FnAbi::new(cx, sig, &[]);\n+    let llfn = cx.get_fn(instance);\n+\n+    let mir = cx.tcx().instance_mir(instance.def);\n+\n+    let fn_abi = FnAbi::of_instance(cx, instance, &[]);\n     debug!(\"fn_abi: {:?}\", fn_abi);\n \n-    let debug_context =\n-        cx.create_function_debug_context(instance, sig, llfn, &mir);\n+    let debug_context = cx.create_function_debug_context(instance, &fn_abi, llfn, &mir);\n \n     let mut bx = Bx::new_block(cx, llfn, \"start\");\n \n@@ -156,7 +156,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         }).collect();\n \n     let (landing_pads, funclets) = create_funclets(&mir, &mut bx, &cleanup_kinds, &block_bxs);\n-    let mir_body: &Body<'_> = mir.body();\n+    let mir_body: &mir::Body<'_> = mir.body();\n     let mut fx = FunctionCx {\n         instance,\n         mir,\n@@ -248,8 +248,8 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-fn create_funclets<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n-    mir: &'b Body<'tcx>,\n+fn create_funclets<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    mir: &'tcx mir::Body<'tcx>,\n     bx: &mut Bx,\n     cleanup_kinds: &IndexVec<mir::BasicBlock, CleanupKind>,\n     block_bxs: &IndexVec<mir::BasicBlock, Bx::BasicBlock>,"}, {"sha": "e2507394ce68170a8d610f4360a7c1eb1fe9d093", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -594,7 +594,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let place_ty = mir::Place::ty_from(\n             place_ref.base,\n             place_ref.projection,\n-            &*self.mir,\n+            *self.mir,\n             tcx,\n         );\n         self.monomorphize(&place_ty.ty)"}, {"sha": "488ae8dbf9036c91701a4f3038564679b558851b", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -460,7 +460,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::Discriminant(ref place) => {\n-                let discr_ty = rvalue.ty(&*self.mir, bx.tcx());\n+                let discr_ty = rvalue.ty(*self.mir, bx.tcx());\n                 let discr =  self.codegen_place(&mut bx, &place.as_ref())\n                     .codegen_get_discr(&mut bx, discr_ty);\n                 (bx, OperandRef {\n@@ -513,7 +513,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::Rvalue::Aggregate(..) => {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n-                let ty = rvalue.ty(&*self.mir, self.cx.tcx());\n+                let ty = rvalue.ty(*self.mir, self.cx.tcx());\n                 let operand = OperandRef::new_zst(\n                     &mut bx,\n                     self.cx.layout_of(self.monomorphize(&ty)),\n@@ -710,7 +710,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 true,\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) => {\n-                let ty = rvalue.ty(&*self.mir, self.cx.tcx());\n+                let ty = rvalue.ty(*self.mir, self.cx.tcx());\n                 let ty = self.monomorphize(&ty);\n                 self.cx.spanned_layout_of(ty, span).is_zst()\n             }"}, {"sha": "e67201b710698ac1cc64f083a32423a8c33bbf61", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -2,8 +2,9 @@ use super::BackendTypes;\n use crate::mir::debuginfo::{FunctionDebugContext, VariableKind};\n use rustc::hir::def_id::CrateNum;\n use rustc::mir;\n-use rustc::ty::{self, Ty, Instance};\n+use rustc::ty::{Ty, Instance};\n use rustc::ty::layout::Size;\n+use rustc_target::abi::call::FnAbi;\n use syntax::ast::Name;\n use syntax_pos::{SourceFile, Span};\n \n@@ -17,7 +18,7 @@ pub trait DebugInfoMethods<'tcx>: BackendTypes {\n     fn create_function_debug_context(\n         &self,\n         instance: Instance<'tcx>,\n-        sig: ty::FnSig<'tcx>,\n+        fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n         llfn: Self::Function,\n         mir: &mir::Body<'_>,\n     ) -> Option<FunctionDebugContext<Self::DIScope>>;"}, {"sha": "1dd2c74dd4fa2c919e8eaa65684c8b0484aee28b", "filename": "src/librustc_codegen_ssa/traits/declare.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -1,7 +1,8 @@\n use super::BackendTypes;\n use rustc::hir::def_id::DefId;\n use rustc::mir::mono::{Linkage, Visibility};\n-use rustc::ty::{self, Instance};\n+use rustc::ty::{Instance, Ty};\n+use rustc_target::abi::call::FnAbi;\n \n pub trait DeclareMethods<'tcx>: BackendTypes {\n     /// Declare a global value.\n@@ -23,7 +24,7 @@ pub trait DeclareMethods<'tcx>: BackendTypes {\n     ///\n     /// If there\u2019s a value with the same name already declared, the function will\n     /// update the declaration and return existing Value instead.\n-    fn declare_fn(&self, name: &str, sig: ty::PolyFnSig<'tcx>) -> Self::Function;\n+    fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Self::Function;\n \n     /// Declare a global with an intention to define it.\n     ///\n@@ -38,20 +39,6 @@ pub trait DeclareMethods<'tcx>: BackendTypes {\n     /// Use this function when you intend to define a global without a name.\n     fn define_private_global(&self, ty: Self::Type) -> Self::Value;\n \n-    /// Declare a Rust function with an intention to define it.\n-    ///\n-    /// Use this function when you intend to define a function. This function will\n-    /// return panic if the name already has a definition associated with it. This\n-    /// can happen with #[no_mangle] or #[export_name], for example.\n-    fn define_fn(&self, name: &str, fn_sig: ty::PolyFnSig<'tcx>) -> Self::Value;\n-\n-    /// Declare a Rust function with an intention to define it.\n-    ///\n-    /// Use this function when you intend to define a function. This function will\n-    /// return panic if the name already has a definition associated with it. This\n-    /// can happen with #[no_mangle] or #[export_name], for example.\n-    fn define_internal_fn(&self, name: &str, fn_sig: ty::PolyFnSig<'tcx>) -> Self::Value;\n-\n     /// Gets declared value by name.\n     fn get_declared_value(&self, name: &str) -> Option<Self::Value>;\n "}, {"sha": "b1e327cdb0ef3c42d4d03ace8c5be38d574b09af", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -208,7 +208,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let ty = Place::ty_from(\n                 used_place.base,\n                 used_place.projection,\n-                &*self.body,\n+                *self.body,\n                 self.infcx.tcx\n             ).ty;\n             let needs_note = match ty.kind {\n@@ -225,7 +225,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let mpi = self.move_data.moves[move_out_indices[0]].path;\n                 let place = &self.move_data.move_paths[mpi].place;\n \n-                let ty = place.ty(&*self.body, self.infcx.tcx).ty;\n+                let ty = place.ty(*self.body, self.infcx.tcx).ty;\n                 let opt_name =\n                     self.describe_place_with_options(place.as_ref(), IncludingDowncast(true));\n                 let note_msg = match opt_name {\n@@ -625,7 +625,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let ty = Place::ty_from(\n                 place_base,\n                 place_projection,\n-                &*self.body,\n+                *self.body,\n                 self.infcx.tcx\n             ).ty;\n             ty.ty_adt_def().filter(|adt| adt.is_union()).map(|_| ty)\n@@ -1635,7 +1635,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 Place::ty_from(\n                                     &place.base,\n                                     proj_base,\n-                                    &*self.body,\n+                                    *self.body,\n                                     tcx\n                                 ).ty.is_box(),\n                                 \"Drop of value behind a reference or raw pointer\"\n@@ -1648,7 +1648,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         let base_ty = Place::ty_from(\n                             &place.base,\n                             proj_base,\n-                            &*self.body,\n+                            *self.body,\n                             tcx\n                         ).ty;\n                         match base_ty.kind {"}, {"sha": "9953d2807437a31711b6d970c786c8bb9c1f486f", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -372,7 +372,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let base_ty = Place::ty_from(\n                         place.base,\n                         place.projection,\n-                        &*self.body,\n+                        *self.body,\n                         self.infcx.tcx).ty;\n                     self.describe_field_from_ty(&base_ty, field, Some(*variant_index))\n                 }\n@@ -502,7 +502,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         ..\n                     }) = bbd.terminator {\n                         if let Some(source) = BorrowedContentSource::from_call(\n-                            func.ty(&*self.body, tcx),\n+                            func.ty(*self.body, tcx),\n                             tcx\n                         ) {\n                             return source;\n@@ -519,7 +519,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let base_ty = Place::ty_from(\n             deref_base.base,\n             deref_base.projection,\n-            &*self.body,\n+            *self.body,\n             tcx\n         ).ty;\n         if base_ty.is_unsafe_ptr() {"}, {"sha": "bacff0b3e54d2eb446faf00e850351ffbb9d92ef", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -646,7 +646,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                 let tcx = self.infcx.tcx;\n \n                 // Compute the type with accurate region information.\n-                let drop_place_ty = drop_place.ty(&*self.body, self.infcx.tcx);\n+                let drop_place_ty = drop_place.ty(*self.body, self.infcx.tcx);\n \n                 // Erase the regions.\n                 let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty).ty;"}, {"sha": "fd779767d7a890a5b2cdb20762642d377eca3462", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -300,7 +300,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         // Inspect the type of the content behind the\n         // borrow to provide feedback about why this\n         // was a move rather than a copy.\n-        let ty = deref_target_place.ty(&*self.body, self.infcx.tcx).ty;\n+        let ty = deref_target_place.ty(*self.body, self.infcx.tcx).ty;\n         let upvar_field = self.prefixes(move_place.as_ref(), PrefixSet::All)\n             .find_map(|p| self.is_upvar_field_projection(p));\n \n@@ -411,7 +411,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         };\n         let move_ty = format!(\n             \"{:?}\",\n-            move_place.ty(&*self.body, self.infcx.tcx).ty,\n+            move_place.ty(*self.body, self.infcx.tcx).ty,\n         );\n         if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n             let is_option = move_ty.starts_with(\"std::option::Option\");\n@@ -454,7 +454,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n \n                 if binds_to.is_empty() {\n-                    let place_ty = move_from.ty(&*self.body, self.infcx.tcx).ty;\n+                    let place_ty = move_from.ty(*self.body, self.infcx.tcx).ty;\n                     let place_desc = match self.describe_place(move_from.as_ref()) {\n                         Some(desc) => format!(\"`{}`\", desc),\n                         None => format!(\"value\"),\n@@ -482,7 +482,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // No binding. Nothing to suggest.\n             GroupedMoveError::OtherIllegalMove { ref original_path, use_spans, .. } => {\n                 let span = use_spans.var_or_use();\n-                let place_ty = original_path.ty(&*self.body, self.infcx.tcx).ty;\n+                let place_ty = original_path.ty(*self.body, self.infcx.tcx).ty;\n                 let place_desc = match self.describe_place(original_path.as_ref()) {\n                     Some(desc) => format!(\"`{}`\", desc),\n                     None => format!(\"value\"),"}, {"sha": "98a7b101d56f755386d243dfa979253b7d1a815e", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     Place::ty_from(\n                         &the_place_err.base,\n                         proj_base,\n-                        &*self.body,\n+                        *self.body,\n                         self.infcx.tcx\n                     ).ty));\n \n@@ -115,7 +115,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         Place::ty_from(\n                             the_place_err.base,\n                             the_place_err.projection,\n-                            &*self.body,\n+                            *self.body,\n                             self.infcx.tcx\n                         )\n                         .ty\n@@ -229,7 +229,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 if let Some((span, message)) = annotate_struct_field(\n                     self.infcx.tcx,\n-                    Place::ty_from(base, proj_base, &*self.body, self.infcx.tcx).ty,\n+                    Place::ty_from(base, proj_base, *self.body, self.infcx.tcx).ty,\n                     field,\n                 ) {\n                     err.span_suggestion(\n@@ -304,7 +304,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(base, proj_base, &*self.body, self.infcx.tcx).ty\n+                    Place::ty_from(base, proj_base, *self.body, self.infcx.tcx).ty\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));"}, {"sha": "de304202a08406ebda6507868dc39307dd5bd8c2", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -1413,9 +1413,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     _ => ConstraintCategory::Assignment,\n                 };\n \n-                let place_ty = place.ty(&*body, tcx).ty;\n+                let place_ty = place.ty(*body, tcx).ty;\n                 let place_ty = self.normalize(place_ty, location);\n-                let rv_ty = rv.ty(&*body, tcx);\n+                let rv_ty = rv.ty(*body, tcx);\n                 let rv_ty = self.normalize(rv_ty, location);\n                 if let Err(terr) =\n                     self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n@@ -1467,7 +1467,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 ref place,\n                 variant_index,\n             } => {\n-                let place_type = place.ty(&*body, tcx).ty;\n+                let place_type = place.ty(*body, tcx).ty;\n                 let adt = match place_type.kind {\n                     ty::Adt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n@@ -1489,7 +1489,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 };\n             }\n             StatementKind::AscribeUserType(box(ref place, ref projection), variance) => {\n-                let place_ty = place.ty(&*body, tcx).ty;\n+                let place_ty = place.ty(*body, tcx).ty;\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n                     variance,\n@@ -2010,7 +2010,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     // While this is located in `nll::typeck` this error is not an NLL error, it's\n                     // a required check to make sure that repeated elements implement `Copy`.\n                     let span = body.source_info(location).span;\n-                    let ty = operand.ty(&*body, tcx);\n+                    let ty = operand.ty(*body, tcx);\n                     if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n                         // To determine if `const_in_array_repeat_expressions` feature gate should\n                         // be mentioned, need to check if the rvalue is promotable.\n@@ -2064,7 +2064,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             Rvalue::Cast(cast_kind, op, ty) => {\n                 match cast_kind {\n                     CastKind::Pointer(PointerCast::ReifyFnPointer) => {\n-                        let fn_sig = op.ty(&*body, tcx).fn_sig(tcx);\n+                        let fn_sig = op.ty(*body, tcx).fn_sig(tcx);\n \n                         // The type that we see in the fcx is like\n                         // `foo::<'a, 'b>`, where `foo` is the path to a\n@@ -2093,7 +2093,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::ClosureFnPointer(unsafety)) => {\n-                        let sig = match op.ty(&*body, tcx).kind {\n+                        let sig = match op.ty(*body, tcx).kind {\n                             ty::Closure(def_id, substs) => {\n                                 substs.as_closure().sig_ty(def_id, tcx).fn_sig(tcx)\n                             }\n@@ -2119,7 +2119,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::UnsafeFnPointer) => {\n-                        let fn_sig = op.ty(&*body, tcx).fn_sig(tcx);\n+                        let fn_sig = op.ty(*body, tcx).fn_sig(tcx);\n \n                         // The type that we see in the fcx is like\n                         // `foo::<'a, 'b>`, where `foo` is the path to a\n@@ -2151,7 +2151,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let &ty = ty;\n                         let trait_ref = ty::TraitRef {\n                             def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n-                            substs: tcx.mk_substs_trait(op.ty(&*body, tcx), &[ty.into()]),\n+                            substs: tcx.mk_substs_trait(op.ty(*body, tcx), &[ty.into()]),\n                         };\n \n                         self.prove_trait_ref(\n@@ -2162,7 +2162,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::MutToConstPointer) => {\n-                        let ty_from = match op.ty(&*body, tcx).kind {\n+                        let ty_from = match op.ty(*body, tcx).kind {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_from,\n                                 mutbl: hir::Mutability::Mutable,\n@@ -2210,7 +2210,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::ArrayToPointer)  => {\n-                        let ty_from = op.ty(&*body, tcx);\n+                        let ty_from = op.ty(*body, tcx);\n \n                         let opt_ty_elem = match ty_from.kind {\n                             ty::RawPtr(\n@@ -2272,7 +2272,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Misc => {\n-                        let ty_from = op.ty(&*body, tcx);\n+                        let ty_from = op.ty(*body, tcx);\n                         let cast_ty_from = CastTy::from_ty(ty_from);\n                         let cast_ty_to = CastTy::from_ty(ty);\n                         match (cast_ty_from, cast_ty_to) {\n@@ -2339,9 +2339,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             | Rvalue::BinaryOp(BinOp::Le, left, right)\n             | Rvalue::BinaryOp(BinOp::Gt, left, right)\n             | Rvalue::BinaryOp(BinOp::Ge, left, right) => {\n-                let ty_left = left.ty(&*body, tcx);\n+                let ty_left = left.ty(*body, tcx);\n                 if let ty::RawPtr(_) | ty::FnPtr(_) = ty_left.kind {\n-                    let ty_right = right.ty(&*body, tcx);\n+                    let ty_right = right.ty(*body, tcx);\n                     let common_ty = self.infcx.next_ty_var(\n                         TypeVariableOrigin {\n                             kind: TypeVariableOriginKind::MiscVariable,"}, {"sha": "b58bf737a3575313bbd89539395e560caad3404d", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -143,7 +143,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                     // derefs, except we stop at the deref of a shared\n                     // reference.\n \n-                    let ty = Place::ty_from(cursor.base, proj_base, &*self.body, self.tcx).ty;\n+                    let ty = Place::ty_from(cursor.base, proj_base, *self.body, self.tcx).ty;\n                     match ty.kind {\n                         ty::RawPtr(_) |\n                         ty::Ref("}, {"sha": "93a76712b2869410948b877a665343cbe3f5cc72", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -741,23 +741,21 @@ fn visit_instance_use<'tcx>(\n     }\n \n     match instance.def {\n-        ty::InstanceDef::Intrinsic(def_id) => {\n+        ty::InstanceDef::Virtual(..) |\n+        ty::InstanceDef::Intrinsic(_) => {\n             if !is_direct_call {\n-                bug!(\"intrinsic {:?} being reified\", def_id);\n+                bug!(\"{:?} being reified\", instance);\n             }\n         }\n-        ty::InstanceDef::VtableShim(..) |\n-        ty::InstanceDef::ReifyShim(..) |\n-        ty::InstanceDef::Virtual(..) |\n         ty::InstanceDef::DropGlue(_, None) => {\n-            // Don't need to emit shim if we are calling directly.\n+            // Don't need to emit noop drop glue if we are calling directly.\n             if !is_direct_call {\n                 output.push(create_fn_mono_item(instance));\n             }\n         }\n-        ty::InstanceDef::DropGlue(_, Some(_)) => {\n-            output.push(create_fn_mono_item(instance));\n-        }\n+        ty::InstanceDef::DropGlue(_, Some(_)) |\n+        ty::InstanceDef::VtableShim(..) |\n+        ty::InstanceDef::ReifyShim(..) |\n         ty::InstanceDef::ClosureOnceShim { .. } |\n         ty::InstanceDef::Item(..) |\n         ty::InstanceDef::FnPtrShim(..) |"}, {"sha": "5b208dd85876377ab4a17443efbd98f3637b0325", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -35,7 +35,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n         ty::InstanceDef::VtableShim(def_id) => {\n             build_call_shim(\n                 tcx,\n-                def_id,\n+                instance,\n                 Adjustment::DerefMove,\n                 CallKind::Direct(def_id),\n                 None,\n@@ -60,27 +60,27 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n \n             build_call_shim(\n                 tcx,\n-                def_id,\n+                instance,\n                 adjustment,\n                 CallKind::Indirect,\n                 Some(arg_tys)\n             )\n         }\n         // We are generating a call back to our def-id, which the\n-        // codegen backend knows to turn to an actual virtual call.\n-        ty::InstanceDef::Virtual(def_id, _) |\n-        // ...or we are generating a direct call to a function for which indirect calls must be\n-        // codegen'd differently than direct ones (example: #[track_caller])\n+        // codegen backend knows to turn to an actual call, be it\n+        // a virtual call, or a direct call to a function for which\n+        // indirect calls must be codegen'd differently than direct ones\n+        // (such as `#[track_caller]`).\n         ty::InstanceDef::ReifyShim(def_id) => {\n             build_call_shim(\n                 tcx,\n-                def_id,\n+                instance,\n                 Adjustment::Identity,\n                 CallKind::Direct(def_id),\n                 None\n             )\n         }\n-        ty::InstanceDef::ClosureOnceShim { call_once } => {\n+        ty::InstanceDef::ClosureOnceShim { call_once: _ } => {\n             let fn_mut = tcx.lang_items().fn_mut_trait().unwrap();\n             let call_mut = tcx\n                 .associated_items(fn_mut)\n@@ -89,7 +89,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n \n             build_call_shim(\n                 tcx,\n-                call_once,\n+                instance,\n                 Adjustment::RefMut,\n                 CallKind::Direct(call_mut),\n                 None\n@@ -109,6 +109,9 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n                 bug!(\"builtin clone shim {:?} not supported\", instance)\n             }\n         }\n+        ty::InstanceDef::Virtual(..) => {\n+            bug!(\"InstanceDef::Virtual ({:?}) is for direct calls only\", instance)\n+        }\n         ty::InstanceDef::Intrinsic(_) => {\n             bug!(\"creating shims from intrinsics ({:?}) is unsupported\", instance)\n         }\n@@ -697,25 +700,38 @@ impl CloneShimBuilder<'tcx> {\n     }\n }\n \n-/// Builds a \"call\" shim for `def_id`. The shim calls the\n+/// Builds a \"call\" shim for `instance`. The shim calls the\n /// function specified by `call_kind`, first adjusting its first\n /// argument according to `rcvr_adjustment`.\n ///\n /// If `untuple_args` is a vec of types, the second argument of the\n /// function will be untupled as these types.\n fn build_call_shim<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n+    instance: ty::InstanceDef<'tcx>,\n     rcvr_adjustment: Adjustment,\n     call_kind: CallKind,\n     untuple_args: Option<&[Ty<'tcx>]>,\n ) -> BodyCache<'tcx> {\n-    debug!(\"build_call_shim(def_id={:?}, rcvr_adjustment={:?}, \\\n+    debug!(\"build_call_shim(instance={:?}, rcvr_adjustment={:?}, \\\n             call_kind={:?}, untuple_args={:?})\",\n-           def_id, rcvr_adjustment, call_kind, untuple_args);\n+           instance, rcvr_adjustment, call_kind, untuple_args);\n \n+    let def_id = instance.def_id();\n     let sig = tcx.fn_sig(def_id);\n-    let sig = tcx.erase_late_bound_regions(&sig);\n+    let mut sig = tcx.erase_late_bound_regions(&sig);\n+\n+    // FIXME(eddyb) avoid having this snippet both here and in\n+    // `Instance::fn_sig` (introduce `InstanceDef::fn_sig`?).\n+    if let ty::InstanceDef::VtableShim(..) = instance {\n+        // Modify fn(self, ...) to fn(self: *mut Self, ...)\n+        let mut inputs_and_output = sig.inputs_and_output.to_vec();\n+        let self_arg = &mut inputs_and_output[0];\n+        debug_assert!(tcx.generics_of(def_id).has_self && *self_arg == tcx.types.self_param);\n+        *self_arg = tcx.mk_mut_ptr(*self_arg);\n+        sig.inputs_and_output = tcx.intern_type_list(&inputs_and_output);\n+    }\n+\n     let span = tcx.def_span(def_id);\n \n     debug!(\"build_call_shim: sig={:?}\", sig);\n@@ -730,14 +746,7 @@ fn build_call_shim<'tcx>(\n     let rcvr = match rcvr_adjustment {\n         Adjustment::Identity => Operand::Move(rcvr_l),\n         Adjustment::Deref => Operand::Copy(tcx.mk_place_deref(rcvr_l)),\n-        Adjustment::DerefMove => {\n-            // fn(Self, ...) -> fn(*mut Self, ...)\n-            let arg_ty = local_decls[rcvr_arg].ty;\n-            debug_assert!(tcx.generics_of(def_id).has_self && arg_ty == tcx.types.self_param);\n-            local_decls[rcvr_arg].ty = tcx.mk_mut_ptr(arg_ty);\n-\n-            Operand::Move(tcx.mk_place_deref(rcvr_l))\n-        }\n+        Adjustment::DerefMove => Operand::Move(tcx.mk_place_deref(rcvr_l)),\n         Adjustment::RefMut => {\n             // let rcvr = &mut rcvr;\n             let ref_rcvr = local_decls.push(temp_decl("}, {"sha": "223a5f8d605fcc518594a0fc0951c3d894e2bc2d", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -51,7 +51,7 @@ pub trait Qualif {\n             });\n             let qualif = base_qualif && Self::in_any_value_of_ty(\n                 cx,\n-                Place::ty_from(place.base, proj_base, &*cx.body, cx.tcx)\n+                Place::ty_from(place.base, proj_base, *cx.body, cx.tcx)\n                     .projection_ty(cx.tcx, elem)\n                     .ty,\n             );\n@@ -155,7 +155,7 @@ pub trait Qualif {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n                     if ProjectionElem::Deref == elem {\n-                        let base_ty = Place::ty_from(&place.base, proj_base, &*cx.body, cx.tcx).ty;\n+                        let base_ty = Place::ty_from(&place.base, proj_base, *cx.body, cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.kind {\n                             return Self::in_place(cx, per_local, PlaceRef {\n                                 base: &place.base,\n@@ -221,7 +221,7 @@ impl Qualif for HasMutInterior {\n             Rvalue::Aggregate(ref kind, _) => {\n                 if let AggregateKind::Adt(def, ..) = **kind {\n                     if Some(def.did) == cx.tcx.lang_items().unsafe_cell_type() {\n-                        let ty = rvalue.ty(&*cx.body, cx.tcx);\n+                        let ty = rvalue.ty(*cx.body, cx.tcx);\n                         assert_eq!(Self::in_any_value_of_ty(cx, ty), true);\n                         return true;\n                     }"}, {"sha": "cb542484be6336c9d717771556cfa067a52d708c", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -77,7 +77,7 @@ where\n         args: &[mir::Operand<'tcx>],\n         return_place: &mir::Place<'tcx>,\n     ) {\n-        let return_ty = return_place.ty(&*self.item.body, self.item.tcx).ty;\n+        let return_ty = return_place.ty(*self.item.body, self.item.tcx).ty;\n         let qualif = Q::in_call(\n             self.item,\n             &|l| self.qualifs_per_local.contains(l),"}, {"sha": "663a5243e8fe22dc15d137254feb11f11ca1660d", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -304,7 +304,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         // Special-case reborrows to be more like a copy of a reference.\n         if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n-            if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, &*self.body, place) {\n+            if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, *self.body, place) {\n                 let ctx = match kind {\n                     BorrowKind::Shared => PlaceContext::NonMutatingUse(\n                         NonMutatingUseContext::SharedBorrow,\n@@ -342,7 +342,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             | Rvalue::Ref(_, kind @ BorrowKind::Mut { .. }, ref place)\n             | Rvalue::Ref(_, kind @ BorrowKind::Unique, ref place)\n             => {\n-                let ty = place.ty(&*self.body, self.tcx).ty;\n+                let ty = place.ty(*self.body, self.tcx).ty;\n                 let is_allowed = match ty.kind {\n                     // Inside a `static mut`, `&mut [...]` is allowed.\n                     ty::Array(..) | ty::Slice(_) if self.const_kind() == ConstKind::StaticMut\n@@ -390,7 +390,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             }\n \n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n-                let operand_ty = operand.ty(&*self.body, self.tcx);\n+                let operand_ty = operand.ty(*self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n \n@@ -401,7 +401,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(&*self.body, self.tcx).kind {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(*self.body, self.tcx).kind {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt ||\n@@ -475,7 +475,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match elem {\n             ProjectionElem::Deref => {\n-                let base_ty = Place::ty_from(place_base, proj_base, &*self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(place_base, proj_base, *self.body, self.tcx).ty;\n                 if let ty::RawPtr(_) = base_ty.kind {\n                     if proj_base.is_empty() {\n                         if let (PlaceBase::Local(local), []) = (place_base, proj_base) {\n@@ -499,7 +499,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             ProjectionElem::Subslice {..} |\n             ProjectionElem::Field(..) |\n             ProjectionElem::Index(_) => {\n-                let base_ty = Place::ty_from(place_base, proj_base, &*self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(place_base, proj_base, *self.body, self.tcx).ty;\n                 match base_ty.ty_adt_def() {\n                     Some(def) if def.is_union() => {\n                         self.check_op(ops::UnionAccess);\n@@ -548,7 +548,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match kind {\n             TerminatorKind::Call { func, .. } => {\n-                let fn_ty = func.ty(&*self.body, self.tcx);\n+                let fn_ty = func.ty(*self.body, self.tcx);\n \n                 let def_id = match fn_ty.kind {\n                     ty::FnDef(def_id, _) => def_id,\n@@ -609,7 +609,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 // Check to see if the type of this place can ever have a drop impl. If not, this\n                 // `Drop` terminator is frivolous.\n                 let ty_needs_drop = dropped_place\n-                    .ty(&*self.body, self.tcx)\n+                    .ty(*self.body, self.tcx)\n                     .ty\n                     .needs_drop(self.tcx, self.param_env);\n "}, {"sha": "c758ccfd11d919e3e985bef10bff4d1852608971", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -350,7 +350,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                                 let ty = Place::ty_from(\n                                         &place.base,\n                                         proj_base,\n-                                        &*self.body,\n+                                        *self.body,\n                                         self.tcx\n                                     )\n                                     .projection_ty(self.tcx, elem)\n@@ -373,7 +373,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         }\n \n                         if let BorrowKind::Mut { .. } = kind {\n-                            let ty = place.ty(&*self.body, self.tcx).ty;\n+                            let ty = place.ty(*self.body, self.tcx).ty;\n \n                             // In theory, any zero-sized value could be borrowed\n                             // mutably without consequences. However, only &mut []\n@@ -522,7 +522,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     ProjectionElem::Field(..) => {\n                         if self.const_kind.is_none() {\n                             let base_ty =\n-                                Place::ty_from(place.base, proj_base, &*self.body, self.tcx).ty;\n+                                Place::ty_from(place.base, proj_base, *self.body, self.tcx).ty;\n                             if let Some(def) = base_ty.ty_adt_def() {\n                                 // No promotion of union field accesses.\n                                 if def.is_union() {\n@@ -571,7 +571,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n         match *rvalue {\n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if self.const_kind.is_none() => {\n-                let operand_ty = operand.ty(&*self.body, self.tcx);\n+                let operand_ty = operand.ty(*self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n@@ -585,7 +585,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) if self.const_kind.is_none() => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(&*self.body, self.tcx).kind {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(*self.body, self.tcx).kind {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt ||\n@@ -620,7 +620,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n             Rvalue::Ref(_, kind, place) => {\n                 if let BorrowKind::Mut { .. } = kind {\n-                    let ty = place.ty(&*self.body, self.tcx).ty;\n+                    let ty = place.ty(*self.body, self.tcx).ty;\n \n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n@@ -647,7 +647,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 let mut place = place.as_ref();\n                 if let [proj_base @ .., ProjectionElem::Deref] = &place.projection {\n                     let base_ty =\n-                        Place::ty_from(&place.base, proj_base, &*self.body, self.tcx).ty;\n+                        Place::ty_from(&place.base, proj_base, *self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         place = PlaceRef {\n                             base: &place.base,\n@@ -673,7 +673,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     while let [proj_base @ .., elem] = place_projection {\n                         // FIXME(eddyb) this is probably excessive, with\n                         // the exception of `union` member accesses.\n-                        let ty = Place::ty_from(place.base, proj_base, &*self.body, self.tcx)\n+                        let ty = Place::ty_from(place.base, proj_base, *self.body, self.tcx)\n                             .projection_ty(self.tcx, elem)\n                             .ty;\n                         if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n@@ -706,7 +706,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n         callee: &Operand<'tcx>,\n         args: &[Operand<'tcx>],\n     ) -> Result<(), Unpromotable> {\n-        let fn_ty = callee.ty(&*self.body, self.tcx);\n+        let fn_ty = callee.ty(*self.body, self.tcx);\n \n         if !self.explicit && self.const_kind.is_none() {\n             if let ty::FnDef(def_id, _) = fn_ty.kind {"}, {"sha": "6f53577b450550ca064cae8aa7c192c6ada7da65", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "patch": "@@ -492,7 +492,12 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum Conv {\n+    // General language calling conventions, for which every target\n+    // should have its own backend (e.g. LLVM) support.\n     C,\n+    Rust,\n+\n+    // Target-specific calling conventions.\n \n     ArmAapcs,\n "}]}