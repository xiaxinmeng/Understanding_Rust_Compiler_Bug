{"sha": "1ced0b61a43d67ef209fc2fa8c4da783daa2471e", "node_id": "C_kwDOAAsO6NoAKDFjZWQwYjYxYTQzZDY3ZWYyMDlmYzJmYThjNGRhNzgzZGFhMjQ3MWU", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-09T16:26:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-09T16:26:25Z"}, "message": "Rollup merge of #94794 - mlodato517:mlodato517-clarify-string-indexing-docs, r=Mark-Simulacrum\n\nClarify indexing into Strings\n\n**This Commit**\nAdds some clarity around indexing into Strings.\n\n**Why?**\nI was reading through the `Range` documentation and saw an\nimplementation for `SliceIndex<str>`. I was surprised to see this and\nwent to read the [`String`][0] documentation and, to me, it seemed to\nsay (at least) three things:\n\n1. you cannot index into a `String`\n2. indexing into a `String` could not be constant-time\n3. indexing into a `String` does not have an obvious return type\n\nI absolutely agree with the last point but the first two seemed\ncontradictory to the documentation around [`SliceIndex<str>`][1]\nwhich mention:\n\n1. you can do substring slicing (which is probably different than\n   \"indexing\" but, because the method is called `index` and I associate\n   anything with square brackets with \"indexing\" it was enough to\n   confuse me)\n2. substring slicing is constant-time (this may be algorithmic ignorance\n   on my part but if `&s[i..i+1]` is O(1) then it seems confusing that\n   `&s[i]` _could not possibly_ be O(1))\n\nSo I was hoping to clarify a couple things and, hopefully, in this PR\nreview learn a little more about the nuances here that confused me in\nthe first place.\n\n[0]: https://doc.rust-lang.org/stable/std/string/struct.String.html#utf-8\n[1]: https://doc.rust-lang.org/stable/std/slice/trait.SliceIndex.html#impl-SliceIndex%3Cstr%3E", "tree": {"sha": "b425109449ed7c0124634c941714ce16e7af2eef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b425109449ed7c0124634c941714ce16e7af2eef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ced0b61a43d67ef209fc2fa8c4da783daa2471e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiUbOxCRBK7hj4Ov3rIwAAJ/UIAKGhZh3S/A93vT/GvBKkIn9G\naqKAWUjbHuBSXu5aUDRRyEZD2KEYps7VpoZsG6LWcZ/0xq4BlDjUtZHrQmuFqdtA\n3MnQ6mhk0jZdSzsQvSjlORsAHuc0ID2Dii7U7D8ipHKawSFTyKYf3zr1cFkUt8Ce\ng9Y71G1h0O3A609r9vAvkuF2LEn9n9NUotmVcFPrZT0OrmhT/y5i0k+gSjgjnTOK\npM3zZYSoR/YKtb2+CEGsCixmJuqH9H0a/qlExSkTFUZNBWhF0ZdRDcaMO4FJq2NY\nfXIW3SE836y9eiFK6rNxPv41Bm7u/ClKp34N+kIH/n1IO69UO2OptG/q2xCiqzk=\n=fkdE\n-----END PGP SIGNATURE-----\n", "payload": "tree b425109449ed7c0124634c941714ce16e7af2eef\nparent 8c1fb2eb23964b56bd279b12aa925935d8559870\nparent 9cf35a6c06da5699efcf417eecaa2d33b3a0d13b\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1649521585 +0200\ncommitter GitHub <noreply@github.com> 1649521585 +0200\n\nRollup merge of #94794 - mlodato517:mlodato517-clarify-string-indexing-docs, r=Mark-Simulacrum\n\nClarify indexing into Strings\n\n**This Commit**\nAdds some clarity around indexing into Strings.\n\n**Why?**\nI was reading through the `Range` documentation and saw an\nimplementation for `SliceIndex<str>`. I was surprised to see this and\nwent to read the [`String`][0] documentation and, to me, it seemed to\nsay (at least) three things:\n\n1. you cannot index into a `String`\n2. indexing into a `String` could not be constant-time\n3. indexing into a `String` does not have an obvious return type\n\nI absolutely agree with the last point but the first two seemed\ncontradictory to the documentation around [`SliceIndex<str>`][1]\nwhich mention:\n\n1. you can do substring slicing (which is probably different than\n   \"indexing\" but, because the method is called `index` and I associate\n   anything with square brackets with \"indexing\" it was enough to\n   confuse me)\n2. substring slicing is constant-time (this may be algorithmic ignorance\n   on my part but if `&s[i..i+1]` is O(1) then it seems confusing that\n   `&s[i]` _could not possibly_ be O(1))\n\nSo I was hoping to clarify a couple things and, hopefully, in this PR\nreview learn a little more about the nuances here that confused me in\nthe first place.\n\n[0]: https://doc.rust-lang.org/stable/std/string/struct.String.html#utf-8\n[1]: https://doc.rust-lang.org/stable/std/slice/trait.SliceIndex.html#impl-SliceIndex%3Cstr%3E\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ced0b61a43d67ef209fc2fa8c4da783daa2471e", "html_url": "https://github.com/rust-lang/rust/commit/1ced0b61a43d67ef209fc2fa8c4da783daa2471e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ced0b61a43d67ef209fc2fa8c4da783daa2471e/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c1fb2eb23964b56bd279b12aa925935d8559870", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c1fb2eb23964b56bd279b12aa925935d8559870", "html_url": "https://github.com/rust-lang/rust/commit/8c1fb2eb23964b56bd279b12aa925935d8559870"}, {"sha": "9cf35a6c06da5699efcf417eecaa2d33b3a0d13b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cf35a6c06da5699efcf417eecaa2d33b3a0d13b", "html_url": "https://github.com/rust-lang/rust/commit/9cf35a6c06da5699efcf417eecaa2d33b3a0d13b"}], "stats": {"total": 92, "additions": 82, "deletions": 10}, "files": [{"sha": "e97c1637fd5a26fea0b4674e7e7de6419d363ac5", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 82, "deletions": 10, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/1ced0b61a43d67ef209fc2fa8c4da783daa2471e/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ced0b61a43d67ef209fc2fa8c4da783daa2471e/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=1ced0b61a43d67ef209fc2fa8c4da783daa2471e", "patch": "@@ -117,27 +117,99 @@ use crate::vec::Vec;\n ///\n /// # UTF-8\n ///\n-/// `String`s are always valid UTF-8. This has a few implications, the first of\n-/// which is that if you need a non-UTF-8 string, consider [`OsString`]. It is\n-/// similar, but without the UTF-8 constraint. The second implication is that\n-/// you cannot index into a `String`:\n+/// `String`s are always valid UTF-8. If you need a non-UTF-8 string, consider\n+/// [`OsString`]. It is similar, but without the UTF-8 constraint. Because UTF-8\n+/// is a variable width encoding, `String`s are typically smaller than an array of\n+/// the same `chars`:\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// // `s` is ASCII which represents each `char` as one byte\n+/// let s = \"hello\";\n+/// assert_eq!(s.len(), 5);\n+///\n+/// // A `char` array with the same contents would be longer because\n+/// // every `char` is four bytes\n+/// let s = ['h', 'e', 'l', 'l', 'o'];\n+/// let size: usize = s.into_iter().map(|c| mem::size_of_val(&c)).sum();\n+/// assert_eq!(size, 20);\n+///\n+/// // However, for non-ASCII strings, the difference will be smaller\n+/// // and sometimes they are the same\n+/// let s = \"\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\";\n+/// assert_eq!(s.len(), 20);\n+///\n+/// let s = ['\ud83d\udc96', '\ud83d\udc96', '\ud83d\udc96', '\ud83d\udc96', '\ud83d\udc96'];\n+/// let size: usize = s.into_iter().map(|c| mem::size_of_val(&c)).sum();\n+/// assert_eq!(size, 20);\n+/// ```\n+///\n+/// This raises interesting questions as to how `s[i]` should work.\n+/// What should `i` be here? Several options include byte indices and\n+/// `char` indices but, because of UTF-8 encoding, only byte indices\n+/// would provide constant time indexing. Getting the `i`th `char`, for\n+/// example, is available using [`chars`]:\n+///\n+/// ```\n+/// let s = \"hello\";\n+/// let third_character = s.chars().nth(2);\n+/// assert_eq!(third_character, Some('l'));\n+///\n+/// let s = \"\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\";\n+/// let third_character = s.chars().nth(2);\n+/// assert_eq!(third_character, Some('\ud83d\udc96'));\n+/// ```\n+///\n+/// Next, what should `s[i]` return? Because indexing returns a reference\n+/// to underlying data it could be `&u8`, `&[u8]`, or something else similar.\n+/// Since we're only providing one index, `&u8` makes the most sense but that\n+/// might not be what the user expects and can be explicitly achieved with\n+/// [`as_bytes()`]:\n+///\n+/// ```\n+/// // The first byte is 104 - the byte value of `'h'`\n+/// let s = \"hello\";\n+/// assert_eq!(s.as_bytes()[0], 104);\n+/// // or\n+/// assert_eq!(s.as_bytes()[0], b'h');\n+///\n+/// // The first byte is 240 which isn't obviously useful\n+/// let s = \"\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\";\n+/// assert_eq!(s.as_bytes()[0], 240);\n+/// ```\n+///\n+/// Due to these ambiguities/restrictions, indexing with a `usize` is simply\n+/// forbidden:\n ///\n /// ```compile_fail,E0277\n /// let s = \"hello\";\n ///\n-/// println!(\"The first letter of s is {}\", s[0]); // ERROR!!!\n+/// // The following will not compile!\n+/// println!(\"The first letter of s is {}\", s[0]);\n /// ```\n ///\n+/// It is more clear, however, how `&s[i..j]` should work (that is,\n+/// indexing with a range). It should accept byte indices (to be constant-time)\n+/// and return a `&str` which is UTF-8 encoded. This is also called \"string slicing\".\n+/// Note this will panic if the byte indices provided are not character\n+/// boundaries - see [`is_char_boundary`] for more details. See the implementations\n+/// for [`SliceIndex<str>`] for more details on string slicing. For a non-panicking\n+/// version of string slicing, see [`get`].\n+///\n /// [`OsString`]: ../../std/ffi/struct.OsString.html \"ffi::OsString\"\n+/// [`SliceIndex<str>`]: core::slice::SliceIndex\n+/// [`as_bytes()`]: str::as_bytes\n+/// [`get`]: str::get\n+/// [`is_char_boundary`]: str::is_char_boundary\n ///\n-/// Indexing is intended to be a constant-time operation, but UTF-8 encoding\n-/// does not allow us to do this. Furthermore, it's not clear what sort of\n-/// thing the index should return: a byte, a codepoint, or a grapheme cluster.\n-/// The [`bytes`] and [`chars`] methods return iterators over the first\n-/// two, respectively.\n+/// The [`bytes`] and [`chars`] methods return iterators over the bytes and\n+/// codepoints of the string, respectively. To iterate over codepoints along\n+/// with byte indices, use [`char_indices`].\n ///\n /// [`bytes`]: str::bytes\n /// [`chars`]: str::chars\n+/// [`char_indices`]: str::char_indices\n ///\n /// # Deref\n ///"}]}