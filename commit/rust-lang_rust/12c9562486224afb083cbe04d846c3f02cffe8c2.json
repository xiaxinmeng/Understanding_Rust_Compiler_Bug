{"sha": "12c9562486224afb083cbe04d846c3f02cffe8c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyYzk1NjI0ODYyMjRhZmIwODNjYmUwNGQ4NDZjM2YwMmNmZmU4YzI=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-01-30T00:46:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-30T00:46:38Z"}, "message": "Rollup merge of #66648 - crgl:btree-clone-from, r=Amanieu\n\nImplement clone_from for BTreeMap and BTreeSet\n\nSee #28481. This results in up to 90% speedups on simple data types when `self` and `other` are the same size, and is generally comparable or faster. Some concerns:\n\n1. This implementation requires an `Ord` bound on the `Clone` implementation for `BTreeMap` and `BTreeSet`. Since these structs can only be created externally for keys with `Ord` implemented, this should be fine? If not, there's certainly a less safe way to do this.\n2. Changing `next_unchecked` on `RangeMut` to return mutable key references allows for replacing the entire overlapping portion of both maps without changing the external interface in any way. However, if `clone_from` fails it can leave the `BTreeMap` in an invalid state, which might be unacceptable.\n\n~This probably needs an FCP since it changes a trait bound, but (as far as I know?) that change cannot break any external code.~", "tree": {"sha": "bea4c517ba60a1b8f93ee9080694a125fcd9cbdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bea4c517ba60a1b8f93ee9080694a125fcd9cbdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12c9562486224afb083cbe04d846c3f02cffe8c2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeMiduCRBK7hj4Ov3rIwAAdHIIAAEoWbtr6xLuqduXJ3APyzbN\nZjxM9xuGfYWMUZe+o9DlQfu6uuClgnHYHvYyItHrK2ImXBCrjBM9GG0LptXVNtqj\nsT4JEwgfRYI7hb3pfGLlmHj8+2+yKmaaJnJpAkrgzqE+tzhIzolSkhySNwNkeX8W\ndtvEu34cN41ImOtfa86yZ+hLllgt+W6ISP/r24Ar7J6SgQl3pWHwzmFGmFJ3ZOIO\nAsWqCXcnx3QfIevg1SjN9Jme51b8cHd3OO6E9h01HGQ4WX8gDdWu6KsYSEBi88v8\nXGbZvIfOTOK0XWyLDJg85krmodW+Wv105+kvnynC9tIgDZTc82y7esL6FiDA+kU=\n=lCD9\n-----END PGP SIGNATURE-----\n", "payload": "tree bea4c517ba60a1b8f93ee9080694a125fcd9cbdf\nparent 9ed29b6ff6aa2e048b09c27af8f62ee3040bdb37\nparent 6c3e477d134511094ab301fc15c504cc79804e41\nauthor Dylan DPC <dylan.dpc@gmail.com> 1580345198 +0100\ncommitter GitHub <noreply@github.com> 1580345198 +0100\n\nRollup merge of #66648 - crgl:btree-clone-from, r=Amanieu\n\nImplement clone_from for BTreeMap and BTreeSet\n\nSee #28481. This results in up to 90% speedups on simple data types when `self` and `other` are the same size, and is generally comparable or faster. Some concerns:\n\n1. This implementation requires an `Ord` bound on the `Clone` implementation for `BTreeMap` and `BTreeSet`. Since these structs can only be created externally for keys with `Ord` implemented, this should be fine? If not, there's certainly a less safe way to do this.\n2. Changing `next_unchecked` on `RangeMut` to return mutable key references allows for replacing the entire overlapping portion of both maps without changing the external interface in any way. However, if `clone_from` fails it can leave the `BTreeMap` in an invalid state, which might be unacceptable.\n\n~This probably needs an FCP since it changes a trait bound, but (as far as I know?) that change cannot break any external code.~\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12c9562486224afb083cbe04d846c3f02cffe8c2", "html_url": "https://github.com/rust-lang/rust/commit/12c9562486224afb083cbe04d846c3f02cffe8c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12c9562486224afb083cbe04d846c3f02cffe8c2/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ed29b6ff6aa2e048b09c27af8f62ee3040bdb37", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ed29b6ff6aa2e048b09c27af8f62ee3040bdb37", "html_url": "https://github.com/rust-lang/rust/commit/9ed29b6ff6aa2e048b09c27af8f62ee3040bdb37"}, {"sha": "6c3e477d134511094ab301fc15c504cc79804e41", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c3e477d134511094ab301fc15c504cc79804e41", "html_url": "https://github.com/rust-lang/rust/commit/6c3e477d134511094ab301fc15c504cc79804e41"}], "stats": {"total": 115, "additions": 106, "deletions": 9}, "files": [{"sha": "11c81ceb19430a8faf5084139a7cbacc4da5f15e", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 74, "deletions": 8, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/12c9562486224afb083cbe04d846c3f02cffe8c2/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c9562486224afb083cbe04d846c3f02cffe8c2/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=12c9562486224afb083cbe04d846c3f02cffe8c2", "patch": "@@ -207,6 +207,60 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n             clone_subtree(self.root.as_ref())\n         }\n     }\n+\n+    fn clone_from(&mut self, other: &Self) {\n+        BTreeClone::clone_from(self, other);\n+    }\n+}\n+\n+trait BTreeClone {\n+    fn clone_from(&mut self, other: &Self);\n+}\n+\n+impl<K: Clone, V: Clone> BTreeClone for BTreeMap<K, V> {\n+    default fn clone_from(&mut self, other: &Self) {\n+        *self = other.clone();\n+    }\n+}\n+\n+impl<K: Clone + Ord, V: Clone> BTreeClone for BTreeMap<K, V> {\n+    fn clone_from(&mut self, other: &Self) {\n+        // This truncates `self` to `other.len()` by calling `split_off` on\n+        // the first key after `other.len()` elements if it exists\n+        let split_off_key = if self.len() > other.len() {\n+            let diff = self.len() - other.len();\n+            if diff <= other.len() {\n+                self.iter().nth_back(diff - 1).map(|pair| (*pair.0).clone())\n+            } else {\n+                self.iter().nth(other.len()).map(|pair| (*pair.0).clone())\n+            }\n+        } else {\n+            None\n+        };\n+        if let Some(key) = split_off_key {\n+            self.split_off(&key);\n+        }\n+\n+        let mut siter = self.range_mut(..);\n+        let mut oiter = other.iter();\n+        // After truncation, `self` is at most as long as `other` so this loop\n+        // replaces every key-value pair in `self`. Since `oiter` is in sorted\n+        // order and the structure of the `BTreeMap` stays the same,\n+        // the BTree invariants are maintained at the end of the loop\n+        while !siter.is_empty() {\n+            if let Some((ok, ov)) = oiter.next() {\n+                // SAFETY: This is safe because the `siter.front != siter.back` check\n+                // ensures that `siter` is nonempty\n+                let (sk, sv) = unsafe { siter.next_unchecked() };\n+                sk.clone_from(ok);\n+                sv.clone_from(ov);\n+            } else {\n+                break;\n+            }\n+        }\n+        // If `other` is longer than `self`, the remaining elements are inserted\n+        self.extend(oiter.map(|(k, v)| ((*k).clone(), (*v).clone())));\n+    }\n }\n \n impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n@@ -1357,7 +1411,10 @@ impl<'a, K: 'a, V: 'a> Iterator for IterMut<'a, K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            unsafe { Some(self.range.next_unchecked()) }\n+            unsafe {\n+                let (k, v) = self.range.next_unchecked();\n+                Some((k, v)) // coerce k from `&mut K` to `&K`\n+            }\n         }\n     }\n \n@@ -1736,7 +1793,14 @@ impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        if self.front == self.back { None } else { unsafe { Some(self.next_unchecked()) } }\n+        if self.is_empty() {\n+            None\n+        } else {\n+            unsafe {\n+                let (k, v) = self.next_unchecked();\n+                Some((k, v)) // coerce k from `&mut K` to `&K`\n+            }\n+        }\n     }\n \n     fn last(mut self) -> Option<(&'a K, &'a mut V)> {\n@@ -1745,16 +1809,19 @@ impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n }\n \n impl<'a, K, V> RangeMut<'a, K, V> {\n-    unsafe fn next_unchecked(&mut self) -> (&'a K, &'a mut V) {\n+    fn is_empty(&self) -> bool {\n+        self.front == self.back\n+    }\n+\n+    unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n         let handle = ptr::read(&self.front);\n \n         let mut cur_handle = match handle.right_kv() {\n             Ok(kv) => {\n                 self.front = ptr::read(&kv).right_edge();\n                 // Doing the descend invalidates the references returned by `into_kv_mut`,\n                 // so we have to do this last.\n-                let (k, v) = kv.into_kv_mut();\n-                return (k, v); // coerce k from `&mut K` to `&K`\n+                return kv.into_kv_mut();\n             }\n             Err(last_edge) => {\n                 let next_level = last_edge.into_node().ascend().ok();\n@@ -1768,8 +1835,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n                     self.front = first_leaf_edge(ptr::read(&kv).right_edge().descend());\n                     // Doing the descend invalidates the references returned by `into_kv_mut`,\n                     // so we have to do this last.\n-                    let (k, v) = kv.into_kv_mut();\n-                    return (k, v); // coerce k from `&mut K` to `&K`\n+                    return kv.into_kv_mut();\n                 }\n                 Err(last_edge) => {\n                     let next_level = last_edge.into_node().ascend().ok();\n@@ -1783,7 +1849,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        if self.front == self.back { None } else { unsafe { Some(self.next_back_unchecked()) } }\n+        if self.is_empty() { None } else { unsafe { Some(self.next_back_unchecked()) } }\n     }\n }\n "}, {"sha": "b100ce754caad589b92089d51c9c89e087faba4c", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/12c9562486224afb083cbe04d846c3f02cffe8c2/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c9562486224afb083cbe04d846c3f02cffe8c2/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=12c9562486224afb083cbe04d846c3f02cffe8c2", "patch": "@@ -56,12 +56,23 @@ use crate::collections::btree_map::{self, BTreeMap, Keys};\n ///     println!(\"{}\", book);\n /// }\n /// ```\n-#[derive(Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n+#[derive(Hash, PartialEq, Eq, Ord, PartialOrd)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeSet<T> {\n     map: BTreeMap<T, ()>,\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Clone> Clone for BTreeSet<T> {\n+    fn clone(&self) -> Self {\n+        BTreeSet { map: self.map.clone() }\n+    }\n+\n+    fn clone_from(&mut self, other: &Self) {\n+        self.map.clone_from(&other.map);\n+    }\n+}\n+\n /// An iterator over the items of a `BTreeSet`.\n ///\n /// This `struct` is created by the [`iter`] method on [`BTreeSet`]."}, {"sha": "0d009507fc7aac1ba3202a2fe9df8980abb6be64", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/12c9562486224afb083cbe04d846c3f02cffe8c2/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c9562486224afb083cbe04d846c3f02cffe8c2/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=12c9562486224afb083cbe04d846c3f02cffe8c2", "patch": "@@ -785,6 +785,26 @@ fn test_clone() {\n     }\n }\n \n+#[test]\n+fn test_clone_from() {\n+    let mut map1 = BTreeMap::new();\n+    let size = 30;\n+\n+    for i in 0..size {\n+        let mut map2 = BTreeMap::new();\n+        for j in 0..i {\n+            let mut map1_copy = map2.clone();\n+            map1_copy.clone_from(&map1);\n+            assert_eq!(map1_copy, map1);\n+            let mut map2_copy = map1.clone();\n+            map2_copy.clone_from(&map2);\n+            assert_eq!(map2_copy, map2);\n+            map2.insert(100 * j + 1, 2 * j + 1);\n+        }\n+        map1.insert(i, 10 * i);\n+    }\n+}\n+\n #[test]\n #[allow(dead_code)]\n fn test_variance() {"}]}