{"sha": "15ea4a8dd8242a0ee01169872bc538c974e748c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZWE0YThkZDgyNDJhMGVlMDExNjk4NzJiYzUzOGM5NzRlNzQ4Yzk=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-07-16T17:25:06Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-07-17T15:21:41Z"}, "message": "Generate better code for intrinsics\n\nCurrently, our intrinsics are generated as functions that have the\nusual setup, which means an alloca, and therefore also a jump, for\nthose intrinsics that return an immediate value. This is especially bad\nfor unoptimized builds because it means that an intrinsic like\n\"contains_managed\" that should be just \"ret 0\" or \"ret 1\" actually ends\nup allocating stack space, doing a jump and a store/load sequence\nbefore it finally returns the value.\n\nTo fix that, we need a way to stop the generic function declaration\nmechanism from allocating stack space for the return value. This\nimplicitly also kills the jump, because the block for static allocas\nisn't required anymore.\n\nAdditionally, trans_intrinsic needs to build the return itself instead\nof calling finish_fn, because the latter relies on the availability of\nthe return value pointer.\n\nWith these changes, we get the bare minimum code required for our\nintrinsics, which makes them small enough that inlining them makes the\nresulting code smaller, so we can mark them as \"always inline\" to get\nbetter performing unoptimized builds.\n\nOptimized builds also benefit slightly from this change as there's less\ncode for LLVM to translate and the smaller intrinsics help it to make\nbetter inlining decisions for a few code paths.\n\nBuilding stage2 librustc gets ~1% faster for the optimized version and 5% for\nthe unoptimized version.", "tree": {"sha": "35c668c1895e506808af19b2d3c68526026cdd78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35c668c1895e506808af19b2d3c68526026cdd78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15ea4a8dd8242a0ee01169872bc538c974e748c9", "comment_count": 8, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15ea4a8dd8242a0ee01169872bc538c974e748c9", "html_url": "https://github.com/rust-lang/rust/commit/15ea4a8dd8242a0ee01169872bc538c974e748c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15ea4a8dd8242a0ee01169872bc538c974e748c9/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e572511af26f5b469cbfded83069ca215c74740", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e572511af26f5b469cbfded83069ca215c74740", "html_url": "https://github.com/rust-lang/rust/commit/3e572511af26f5b469cbfded83069ca215c74740"}], "stats": {"total": 93, "additions": 61, "deletions": 32}, "files": [{"sha": "b2d14dce4d854797042d7798a618e01df1fd87c6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15ea4a8dd8242a0ee01169872bc538c974e748c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea4a8dd8242a0ee01169872bc538c974e748c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=15ea4a8dd8242a0ee01169872bc538c974e748c9", "patch": "@@ -1610,6 +1610,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n                         llfndecl: ValueRef,\n                         id: ast::node_id,\n                         output_type: ty::t,\n+                        skip_retptr: bool,\n                         param_substs: Option<@param_substs>,\n                         sp: Option<span>)\n                      -> fn_ctxt {\n@@ -1653,7 +1654,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n     fcx.llenv = unsafe {\n           llvm::LLVMGetParam(llfndecl, fcx.env_arg_pos() as c_uint)\n     };\n-    if !ty::type_is_nil(substd_output_type) {\n+    if !ty::type_is_nil(substd_output_type) && !(is_immediate && skip_retptr) {\n         fcx.llretptr = Some(make_return_pointer(fcx, substd_output_type));\n     }\n     fcx\n@@ -1665,7 +1666,7 @@ pub fn new_fn_ctxt(ccx: @mut CrateContext,\n                    output_type: ty::t,\n                    sp: Option<span>)\n                 -> fn_ctxt {\n-    new_fn_ctxt_w_id(ccx, path, llfndecl, -1, output_type, None, sp)\n+    new_fn_ctxt_w_id(ccx, path, llfndecl, -1, output_type, false, None, sp)\n }\n \n // NB: must keep 4 fns in sync:\n@@ -1859,6 +1860,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n                                llfndecl,\n                                id,\n                                output_type,\n+                               false,\n                                param_substs,\n                                Some(body.span));\n     let raw_llargs = create_llargs_for_fn_args(fcx, self_arg, decl.inputs);\n@@ -2068,6 +2070,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n                                llfndecl,\n                                ctor_id,\n                                result_ty,\n+                               false,\n                                param_substs,\n                                None);\n "}, {"sha": "d9de1657da27365378002ad1a35483ed4803abce", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 56, "deletions": 30, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/15ea4a8dd8242a0ee01169872bc538c974e748c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea4a8dd8242a0ee01169872bc538c974e748c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=15ea4a8dd8242a0ee01169872bc538c974e748c9", "patch": "@@ -10,7 +10,7 @@\n \n \n use back::{link, abi};\n-use lib::llvm::{ValueRef};\n+use lib::llvm::{Pointer, ValueRef};\n use lib;\n use middle::trans::base::*;\n use middle::trans::cabi;\n@@ -558,7 +558,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             args[i] = get_param(bcx.fcx.llfn, first_real_arg + i);\n         }\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        Store(bcx, Call(bcx, llfn, args.slice(0, num_args)), bcx.fcx.llretptr.get());\n+        Ret(bcx, Call(bcx, llfn, args.slice(0, num_args)));\n     }\n \n     fn memcpy_intrinsic(bcx: block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n@@ -579,6 +579,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         let volatile = C_i1(false);\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);\n         Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n+        RetVoid(bcx);\n     }\n \n     fn memset_intrinsic(bcx: block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n@@ -599,13 +600,14 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         let volatile = C_i1(false);\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);\n         Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile]);\n+        RetVoid(bcx);\n     }\n \n     fn count_zeros_intrinsic(bcx: block, name: &'static str) {\n         let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n         let y = C_i1(false);\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        Store(bcx, Call(bcx, llfn, [x, y]), bcx.fcx.llretptr.get())\n+        Ret(bcx, Call(bcx, llfn, [x, y]));\n     }\n \n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n@@ -615,16 +617,18 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                                decl,\n                                item.id,\n                                output_type,\n+                               true,\n                                Some(substs),\n                                Some(item.span));\n \n+    set_always_inline(fcx.llfn);\n+\n     // Set the fixed stack segment flag if necessary.\n     if attr::attrs_contains_name(attributes, \"fixed_stack_segment\") {\n         set_fixed_stack_segment(fcx.llfn);\n     }\n \n     let mut bcx = top_scope_block(fcx, None);\n-    let lltop = bcx.llbb;\n     let first_real_arg = fcx.arg_pos(0u);\n \n     let nm = ccx.sess.str_of(item.ident);\n@@ -653,17 +657,18 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                                         get_param(decl, first_real_arg + 1u),\n                                         get_param(decl, first_real_arg + 2u),\n                                         order);\n-                Store(bcx, old, fcx.llretptr.get());\n+                Ret(bcx, old);\n             }\n             \"load\" => {\n                 let old = AtomicLoad(bcx, get_param(decl, first_real_arg),\n                                      order);\n-                Store(bcx, old, fcx.llretptr.get());\n+                Ret(bcx, old);\n             }\n             \"store\" => {\n                 AtomicStore(bcx, get_param(decl, first_real_arg + 1u),\n                             get_param(decl, first_real_arg),\n                             order);\n+                RetVoid(bcx);\n             }\n             op => {\n                 // These are all AtomicRMW ops\n@@ -685,21 +690,18 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                 let old = AtomicRMW(bcx, atom_op, get_param(decl, first_real_arg),\n                                     get_param(decl, first_real_arg + 1u),\n                                     order);\n-                Store(bcx, old, fcx.llretptr.get());\n+                Ret(bcx, old);\n             }\n         }\n \n-        finish_fn(fcx, lltop, bcx);\n-\n         return;\n     }\n \n     match name {\n         \"size_of\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            Store(bcx, C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty)),\n-                  fcx.llretptr.get());\n+            Ret(bcx, C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty)));\n         }\n         \"move_val\" => {\n             // Create a datum reflecting the value being moved.\n@@ -713,6 +715,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                              ty: tp_ty, mode: mode};\n             bcx = src.move_to(bcx, DROP_EXISTING,\n                               get_param(decl, first_real_arg));\n+            RetVoid(bcx);\n         }\n         \"move_val_init\" => {\n             // See comments for `\"move_val\"`.\n@@ -721,18 +724,17 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n                              ty: tp_ty, mode: mode};\n             bcx = src.move_to(bcx, INIT, get_param(decl, first_real_arg));\n+            RetVoid(bcx);\n         }\n         \"min_align_of\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            Store(bcx, C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty)),\n-                  fcx.llretptr.get());\n+            Ret(bcx, C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty)));\n         }\n         \"pref_align_of\"=> {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            Store(bcx, C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty)),\n-                  fcx.llretptr.get());\n+            Ret(bcx, C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty)));\n         }\n         \"get_tydesc\" => {\n             let tp_ty = substs.tys[0];\n@@ -745,19 +747,31 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             // the llvm type of intrinsic::TyDesc struct.\n             let userland_tydesc_ty = type_of::type_of(ccx, output_type);\n             let td = PointerCast(bcx, static_ti.tydesc, userland_tydesc_ty);\n-            Store(bcx, td, fcx.llretptr.get());\n+            Ret(bcx, td);\n         }\n         \"init\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            if !ty::type_is_nil(tp_ty) {\n-                Store(bcx, C_null(lltp_ty), fcx.llretptr.get());\n+            match bcx.fcx.llretptr {\n+                Some(ptr) => { Store(bcx, C_null(lltp_ty), ptr); RetVoid(bcx); }\n+                None if ty::type_is_nil(tp_ty) => RetVoid(bcx),\n+                None => Ret(bcx, C_null(lltp_ty)),\n             }\n         }\n         \"uninit\" => {\n             // Do nothing, this is effectively a no-op\n+            let retty = substs.tys[0];\n+            if ty::type_is_immediate(ccx.tcx, retty) && !ty::type_is_nil(retty) {\n+                unsafe {\n+                    Ret(bcx, lib::llvm::llvm::LLVMGetUndef(type_of(ccx, retty).to_ref()));\n+                }\n+            } else {\n+                RetVoid(bcx)\n+            }\n+        }\n+        \"forget\" => {\n+            RetVoid(bcx);\n         }\n-        \"forget\" => {}\n         \"transmute\" => {\n             let (in_type, out_type) = (substs.tys[0], substs.tys[1]);\n             let llintype = type_of::type_of(ccx, in_type);\n@@ -784,34 +798,45 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             }\n \n             if !ty::type_is_nil(out_type) {\n-                let lldestptr = fcx.llretptr.get();\n                 let llsrcval = get_param(decl, first_real_arg);\n                 if ty::type_is_immediate(ccx.tcx, in_type) {\n-                    let lldestptr = PointerCast(bcx, lldestptr, llintype.ptr_to());\n-                    Store(bcx, llsrcval, lldestptr);\n+                    match fcx.llretptr {\n+                        Some(llretptr) => {\n+                            Store(bcx, llsrcval, PointerCast(bcx, llretptr, llintype.ptr_to()));\n+                            RetVoid(bcx);\n+                        }\n+                        None => match (llintype.kind(), llouttype.kind()) {\n+                            (Pointer, other) | (other, Pointer) if other != Pointer => {\n+                                let tmp = Alloca(bcx, llouttype, \"\");\n+                                Store(bcx, llsrcval, PointerCast(bcx, tmp, llintype.ptr_to()));\n+                                Ret(bcx, Load(bcx, tmp));\n+                            }\n+                            _ => Ret(bcx, BitCast(bcx, llsrcval, llouttype))\n+                        }\n+                    }\n                 } else {\n                     // NB: Do not use a Load and Store here. This causes massive\n                     // code bloat when `transmute` is used on large structural\n                     // types.\n+                    let lldestptr = fcx.llretptr.get();\n                     let lldestptr = PointerCast(bcx, lldestptr, Type::i8p());\n                     let llsrcptr = PointerCast(bcx, llsrcval, Type::i8p());\n \n                     let llsize = llsize_of(ccx, llintype);\n                     call_memcpy(bcx, lldestptr, llsrcptr, llsize, 1);\n+                    RetVoid(bcx);\n                 };\n+            } else {\n+                RetVoid(bcx);\n             }\n         }\n         \"needs_drop\" => {\n             let tp_ty = substs.tys[0];\n-            Store(bcx,\n-                  C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)),\n-                  fcx.llretptr.get());\n+            Ret(bcx, C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)));\n         }\n         \"contains_managed\" => {\n             let tp_ty = substs.tys[0];\n-            Store(bcx,\n-                  C_bool(ty::type_contents(ccx.tcx, tp_ty).contains_managed()),\n-                  fcx.llretptr.get());\n+            Ret(bcx, C_bool(ty::type_contents(ccx.tcx, tp_ty).contains_managed()));\n         }\n         \"visit_tydesc\" => {\n             let td = get_param(decl, first_real_arg);\n@@ -821,6 +846,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let td = PointerCast(bcx, td, ccx.tydesc_type.ptr_to());\n             glue::call_tydesc_glue_full(bcx, visitor, td,\n                                         abi::tydesc_field_visit_glue, None);\n+            RetVoid(bcx);\n         }\n         \"frame_address\" => {\n             let frameaddress = ccx.intrinsics.get_copy(& &\"llvm.frameaddress\");\n@@ -847,6 +873,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                 bcx, None, fty, ty::mk_nil(),\n                 |bcx| Callee {bcx: bcx, data: Closure(datum)},\n                 ArgVals(arg_vals), Some(Ignore), DontAutorefArg).bcx;\n+            RetVoid(bcx);\n         }\n         \"morestack_addr\" => {\n             // XXX This is a hack to grab the address of this particular\n@@ -856,7 +883,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let morestack_addr = decl_cdecl_fn(\n                 bcx.ccx().llmod, \"__morestack\", llfty);\n             let morestack_addr = PointerCast(bcx, morestack_addr, Type::nil().ptr_to());\n-            Store(bcx, morestack_addr, fcx.llretptr.get());\n+            Ret(bcx, morestack_addr);\n         }\n         \"memcpy32\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i32\", substs.tys[0], 32),\n         \"memcpy64\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i64\", substs.tys[0], 64),\n@@ -915,7 +942,6 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             ccx.sess.span_bug(item.span, \"unknown intrinsic\");\n         }\n     }\n-    finish_fn(fcx, lltop, bcx);\n }\n \n /**"}]}