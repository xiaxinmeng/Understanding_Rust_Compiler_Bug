{"sha": "41c1f39fa8317fc16779ceda7536fe93f1c89c34", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxYzFmMzlmYTgzMTdmYzE2Nzc5Y2VkYTc1MzZmZTkzZjFjODljMzQ=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-06-27T18:06:26Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-17T17:41:10Z"}, "message": "Drop ExpnData::krate.", "tree": {"sha": "1d401468acc049864bd3cc7b879076f1fbf9a175", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d401468acc049864bd3cc7b879076f1fbf9a175"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41c1f39fa8317fc16779ceda7536fe93f1c89c34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41c1f39fa8317fc16779ceda7536fe93f1c89c34", "html_url": "https://github.com/rust-lang/rust/commit/41c1f39fa8317fc16779ceda7536fe93f1c89c34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41c1f39fa8317fc16779ceda7536fe93f1c89c34/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbd2d77641e87ac841d12db1ca8e1f38d96f85d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbd2d77641e87ac841d12db1ca8e1f38d96f85d3", "html_url": "https://github.com/rust-lang/rust/commit/dbd2d77641e87ac841d12db1ca8e1f38d96f85d3"}], "stats": {"total": 31, "additions": 11, "deletions": 20}, "files": [{"sha": "8bdd4313de4c3b6329a99cd8f045cb5d75058382", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41c1f39fa8317fc16779ceda7536fe93f1c89c34/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41c1f39fa8317fc16779ceda7536fe93f1c89c34/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=41c1f39fa8317fc16779ceda7536fe93f1c89c34", "patch": "@@ -1653,7 +1653,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         };\n \n         let data = self.root.expn_data.get(self, index).unwrap().decode(self);\n-        rustc_span::hygiene::register_expn_id(index, data, hash)\n+        rustc_span::hygiene::register_expn_id(self.cnum, index, data, hash)\n     }\n \n     /// Imports the source_map from an external crate into the source_map of the crate"}, {"sha": "49ad40fdf4d5be847c93b4ba75a9dd3e7232ebf4", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/41c1f39fa8317fc16779ceda7536fe93f1c89c34/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41c1f39fa8317fc16779ceda7536fe93f1c89c34/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=41c1f39fa8317fc16779ceda7536fe93f1c89c34", "patch": "@@ -184,7 +184,6 @@ impl LocalExpnId {\n         HygieneData::with(|data| {\n             let old_expn_data = &mut data.local_expn_data[self];\n             assert!(old_expn_data.is_none(), \"expansion data is reset for an expansion ID\");\n-            debug_assert_eq!(expn_data.krate, LOCAL_CRATE);\n             *old_expn_data = Some(expn_data);\n         });\n         update_disambiguator(self, ctx)\n@@ -337,11 +336,7 @@ impl HygieneData {\n     }\n \n     fn fresh_expn(&mut self, expn_data: Option<ExpnData>) -> LocalExpnId {\n-        if let Some(data) = &expn_data {\n-            debug_assert_eq!(data.krate, LOCAL_CRATE);\n-        }\n-        let expn_id = self.local_expn_data.next_index();\n-        self.local_expn_data.push(expn_data);\n+        let expn_id = self.local_expn_data.push(expn_data);\n         let _eid = self.local_expn_hashes.push(ExpnHash(Fingerprint::ZERO));\n         debug_assert_eq!(expn_id, _eid);\n         expn_id\n@@ -873,12 +868,6 @@ pub struct ExpnData {\n     /// call_site span would have its own ExpnData, with the call_site\n     /// pointing to the `foo!` invocation.\n     pub call_site: Span,\n-    /// The crate that originally created this `ExpnData`. During\n-    /// metadata serialization, we only encode `ExpnData`s that were\n-    /// created locally - when our serialized metadata is decoded,\n-    /// foreign `ExpnId`s will have their `ExpnData` looked up\n-    /// from the crate specified by `Crate\n-    krate: CrateNum,\n     /// Used to force two `ExpnData`s to have different `Fingerprint`s.\n     /// Due to macro expansion, it's possible to end up with two `ExpnId`s\n     /// that have identical `ExpnData`s. This violates the contract of `HashStable`\n@@ -944,7 +933,6 @@ impl ExpnData {\n             edition,\n             macro_def_id,\n             parent_module,\n-            krate: LOCAL_CRATE,\n             disambiguator: 0,\n         }\n     }\n@@ -968,7 +956,6 @@ impl ExpnData {\n             edition,\n             macro_def_id,\n             parent_module,\n-            krate: LOCAL_CRATE,\n             disambiguator: 0,\n         }\n     }\n@@ -1222,8 +1209,13 @@ pub fn register_local_expn_id(data: ExpnData, hash: ExpnHash) -> ExpnId {\n }\n \n /// Register an expansion which has been decoded from the metadata of a foreign crate.\n-pub fn register_expn_id(local_id: ExpnIndex, data: ExpnData, hash: ExpnHash) -> ExpnId {\n-    let expn_id = ExpnId { krate: data.krate, local_id };\n+pub fn register_expn_id(\n+    krate: CrateNum,\n+    local_id: ExpnIndex,\n+    data: ExpnData,\n+    hash: ExpnHash,\n+) -> ExpnId {\n+    let expn_id = ExpnId { krate, local_id };\n     HygieneData::with(|hygiene_data| {\n         let _old_data = hygiene_data.foreign_expn_data.insert(expn_id, data);\n         debug_assert!(_old_data.is_none());\n@@ -1260,9 +1252,8 @@ pub fn decode_expn_id(\n     // Don't decode the data inside `HygieneData::with`, since we need to recursively decode\n     // other ExpnIds\n     let (expn_data, hash) = decode_data(expn_id);\n-    debug_assert_eq!(krate, expn_data.krate);\n \n-    register_expn_id(index, expn_data, hash)\n+    register_expn_id(krate, index, expn_data, hash)\n }\n \n // Decodes `SyntaxContext`, using the provided `HygieneDecodeContext`\n@@ -1420,7 +1411,7 @@ impl<D: Decoder> Decodable<D> for SyntaxContext {\n /// This method is called only when an `ExpnData` is first associated\n /// with an `ExpnId` (when the `ExpnId` is initially constructed, or via\n /// `set_expn_data`). It is *not* called for foreign `ExpnId`s deserialized\n-/// from another crate's metadata - since `ExpnData` includes a `krate` field,\n+/// from another crate's metadata - since `ExpnHash` includes the stable crate id,\n /// collisions are only possible between `ExpnId`s within the same crate.\n fn update_disambiguator(expn_id: LocalExpnId, mut ctx: impl HashStableContext) {\n     let mut expn_data = expn_id.expn_data();"}]}