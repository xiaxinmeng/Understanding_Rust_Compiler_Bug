{"sha": "f05119673125efdd86ab53765d4571b5e757cf3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNTExOTY3MzEyNWVmZGQ4NmFiNTM3NjVkNDU3MWI1ZTc1N2NmM2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-06T03:50:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-06T03:50:53Z"}, "message": "auto merge of #8909 : lkuper/rust/default-methods-refactor, r=alexcrichton\n\n (cc: #3227)\r\n\r\nParts I'm unsure about and would like a reviewer to look at are:\r\n\r\n  * `pub trait GenericPath : Clone + Eq + ToStr` -- is this the done thing?  I've never done trait inheritance before, let alone from multiple traits, but it seemed to be necessary to be able to call all the methods we have to be able to call on `self`.\r\n\r\n  * changing the argument of `components` from `self` to `&self`, and having it return `self.components.clone()` instead of `self.components`; this was necessary to avoid move errors, but I'm not sure if it's the right thing.  (The default methods impls now all have to call `self.components()` instead of just referencing the field `self.components`.)", "tree": {"sha": "493de0205a2808856903936d48f2be08a82a7bd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/493de0205a2808856903936d48f2be08a82a7bd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f05119673125efdd86ab53765d4571b5e757cf3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f05119673125efdd86ab53765d4571b5e757cf3a", "html_url": "https://github.com/rust-lang/rust/commit/f05119673125efdd86ab53765d4571b5e757cf3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f05119673125efdd86ab53765d4571b5e757cf3a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a980f28028f4712efbb89017bd23c25183fddbfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/a980f28028f4712efbb89017bd23c25183fddbfe", "html_url": "https://github.com/rust-lang/rust/commit/a980f28028f4712efbb89017bd23c25183fddbfe"}, {"sha": "59291eb197fad9a0fe3e94afda826f3abf1761ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/59291eb197fad9a0fe3e94afda826f3abf1761ab", "html_url": "https://github.com/rust-lang/rust/commit/59291eb197fad9a0fe3e94afda826f3abf1761ab"}], "stats": {"total": 390, "additions": 156, "deletions": 234}, "files": [{"sha": "58668775136a303086dbfe460490a8b84ae3d2ea", "filename": "src/libstd/path.rs", "status": "modified", "additions": 156, "deletions": 234, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/f05119673125efdd86ab53765d4571b5e757cf3a/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05119673125efdd86ab53765d4571b5e757cf3a/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=f05119673125efdd86ab53765d4571b5e757cf3a", "patch": "@@ -57,64 +57,126 @@ pub fn PosixPath(s: &str) -> PosixPath {\n     GenericPath::from_str(s)\n }\n \n-pub trait GenericPath {\n-    /// Converts a string to a Path\n+pub trait GenericPath : Clone + Eq + ToStr {\n+    /// Converts a string to a path.\n     fn from_str(&str) -> Self;\n \n-    /// Returns the directory component of `self`, as a string\n-    fn dirname(&self) -> ~str;\n+    /// Returns the directory component of `self`, as a string.\n+    fn dirname(&self) -> ~str {\n+        let s = self.dir_path().to_str();\n+        match s.len() {\n+            0 => ~\".\",\n+            _ => s,\n+        }\n+    }\n+\n     /// Returns the file component of `self`, as a string option.\n     /// Returns None if `self` names a directory.\n-    fn filename<'a>(&'a self) -> Option<&'a str>;\n+    fn filename<'a>(&'a self) -> Option<&'a str> {\n+        match self.components().len() {\n+            0 => None,\n+            n => Some(self.components()[n - 1].as_slice()),\n+        }\n+    }\n+\n     /// Returns the stem of the file component of `self`, as a string option.\n     /// The stem is the slice of a filename starting at 0 and ending just before\n     /// the last '.' in the name.\n     /// Returns None if `self` names a directory.\n-    fn filestem<'a>(&'a self) -> Option<&'a str>;\n+    fn filestem<'a>(&'a self) -> Option<&'a str> {\n+        match self.filename() {\n+            None => None,\n+            Some(ref f) => {\n+                match f.rfind('.') {\n+                    Some(p) => Some(f.slice_to(p)),\n+                    None => Some((*f)),\n+                }\n+            }\n+        }\n+    }\n+\n     /// Returns the type of the file component of `self`, as a string option.\n     /// The file type is the slice of a filename starting just after the last\n     /// '.' in the name and ending at the last index in the filename.\n     /// Returns None if `self` names a directory.\n-    fn filetype<'a>(&'a self) -> Option<&'a str>;\n+    fn filetype<'a>(&'a self) -> Option<&'a str> {\n+        match self.filename() {\n+            None => None,\n+            Some(ref f) => {\n+                match f.rfind('.') {\n+                    Some(p) if p < f.len() => Some(f.slice_from(p)),\n+                    _ => None,\n+                }\n+            }\n+        }\n+    }\n \n     /// Returns a new path consisting of `self` with the parent directory component replaced\n     /// with the given string.\n     fn with_dirname(&self, (&str)) -> Self;\n+\n     /// Returns a new path consisting of `self` with the file component replaced\n     /// with the given string.\n     fn with_filename(&self, (&str)) -> Self;\n+\n     /// Returns a new path consisting of `self` with the file stem replaced\n     /// with the given string.\n-    fn with_filestem(&self, (&str)) -> Self;\n+    fn with_filestem(&self, s: &str) -> Self {\n+        match self.filetype() {\n+            None => self.with_filename(s),\n+            Some(ref t) => self.with_filename(s.to_owned() + *t),\n+        }\n+    }\n+\n     /// Returns a new path consisting of `self` with the file type replaced\n     /// with the given string.\n-    fn with_filetype(&self, (&str)) -> Self;\n+    fn with_filetype(&self, t: &str) -> Self {\n+        match (t.len(), self.filestem()) {\n+            (0, None)        => (*self).clone(),\n+            (0, Some(ref s)) => self.with_filename(*s),\n+            (_, None)        => self.with_filename(fmt!(\".%s\", t)),\n+            (_, Some(ref s)) => self.with_filename(fmt!(\"%s.%s\", *s, t)),\n+        }\n+    }\n \n     /// Returns the directory component of `self`, as a new path.\n     /// If `self` has no parent, returns `self`.\n-    fn dir_path(&self) -> Self;\n+    fn dir_path(&self) -> Self {\n+        match self.components().len() {\n+            0 => (*self).clone(),\n+            _ => self.pop(),\n+        }\n+    }\n+\n     /// Returns the file component of `self`, as a new path.\n     /// If `self` names a directory, returns the empty path.\n     fn file_path(&self) -> Self;\n \n-    /// Returns a new Path whose parent directory is `self` and whose\n+    /// Returns a new path whose parent directory is `self` and whose\n     /// file component is the given string.\n     fn push(&self, (&str)) -> Self;\n-    /// Returns a new Path consisting of the given path, made relative to `self`.\n-    fn push_rel(&self, (&Self)) -> Self;\n-    /// Returns a new Path consisting of the path given by the given vector\n+\n+    /// Returns a new path consisting of the given path, made relative to `self`.\n+    fn push_rel(&self, other: &Self) -> Self {\n+        assert!(!other.is_absolute());\n+        self.push_many(other.components())\n+    }\n+\n+    /// Returns a new path consisting of the path given by the given vector\n     /// of strings, relative to `self`.\n     fn push_many<S: Str>(&self, (&[S])) -> Self;\n+\n     /// Identical to `dir_path` except in the case where `self` has only one\n     /// component. In this case, `pop` returns the empty path.\n     fn pop(&self) -> Self;\n \n     /// The same as `push_rel`, except that the directory argument must not\n     /// contain directory separators in any of its components.\n     fn unsafe_join(&self, (&Self)) -> Self;\n-    /// On Unix, always returns false. On Windows, returns true iff `self`'s\n+\n+    /// On Unix, always returns `false`. On Windows, returns `true` iff `self`'s\n     /// file stem is one of: `con` `aux` `com1` `com2` `com3` `com4`\n-    /// `lpt1` `lpt2` `lpt3` `prn` `nul`\n+    /// `lpt1` `lpt2` `lpt3` `prn` `nul`.\n     fn is_restricted(&self) -> bool;\n \n     /// Returns a new path that names the same file as `self`, without containing\n@@ -125,10 +187,18 @@ pub trait GenericPath {\n     /// Returns `true` if `self` is an absolute path.\n     fn is_absolute(&self) -> bool;\n \n-    /// True if `self` is an ancestor of `other`. See `test_is_ancestor_of` for examples\n-    fn is_ancestor_of(&self, (&Self)) -> bool;\n+    /// True if `self` is an ancestor of `other`.\n+    // See `test_is_ancestor_of` for examples.\n+    fn is_ancestor_of(&self, other: &Self) -> bool {\n+        debug!(\"%s / %s %? %?\", self.to_str(), other.to_str(), self.is_absolute(),\n+               self.components().len());\n+        self == other ||\n+            (!other.components().is_empty() &&\n+             !(self.components().is_empty() && !self.is_absolute()) &&\n+             self.is_ancestor_of(&other.pop()))\n+    }\n \n-    /// Find the relative path from one file to another\n+    /// Finds the relative path from one file to another.\n     fn get_relative_to(&self, abs2: (&Self)) -> Self {\n         assert!(self.is_absolute());\n         assert!(abs2.is_absolute());\n@@ -447,7 +517,7 @@ impl PosixPath {\n         }\n     }\n \n-    /// Execute a function on p as well as all of its ancestors\n+    /// Executes a function `f` on `self` as well as on all of its ancestors.\n     pub fn each_parent(&self, f: &fn(&Path)) {\n         if !self.components.is_empty() {\n             f(self);\n@@ -549,7 +619,7 @@ impl WindowsPath {\n         }\n     }\n \n-    /// Execute a function on p as well as all of its ancestors\n+    /// Executes a function `f` on `self` as well as on all of its ancestors.\n     pub fn each_parent(&self, f: &fn(&Path)) {\n         if !self.components.is_empty() {\n             f(self);\n@@ -578,8 +648,6 @@ impl ToCStr for PosixPath {\n     }\n }\n \n-// FIXME (#3227): when default methods in traits are working, de-duplicate\n-// PosixPath and WindowsPath, most of their methods are common.\n impl GenericPath for PosixPath {\n     fn from_str(s: &str) -> PosixPath {\n         let components = s.split_iter('/')\n@@ -592,45 +660,6 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    fn dirname(&self) -> ~str {\n-        let s = self.dir_path().to_str();\n-        match s.len() {\n-            0 => ~\".\",\n-            _ => s,\n-        }\n-    }\n-\n-    fn filename<'a>(&'a self) -> Option<&'a str> {\n-        match self.components.len() {\n-            0 => None,\n-            n => Some(self.components[n - 1].as_slice()),\n-        }\n-    }\n-\n-    fn filestem<'a>(&'a self) -> Option<&'a str> {\n-        match self.filename() {\n-            None => None,\n-            Some(ref f) => {\n-                match f.rfind('.') {\n-                    Some(p) => Some(f.slice_to(p)),\n-                    None => Some((*f)),\n-                }\n-            }\n-        }\n-    }\n-\n-    fn filetype<'a>(&'a self) -> Option<&'a str> {\n-        match self.filename() {\n-            None => None,\n-            Some(ref f) => {\n-                match f.rfind('.') {\n-                    Some(p) if p < f.len() => Some(f.slice_from(p)),\n-                    _ => None,\n-                }\n-            }\n-        }\n-    }\n-\n     fn with_dirname(&self, d: &str) -> PosixPath {\n         let dpath = PosixPath(d);\n         match self.filename() {\n@@ -644,29 +673,6 @@ impl GenericPath for PosixPath {\n         self.dir_path().push(f)\n     }\n \n-    fn with_filestem(&self, s: &str) -> PosixPath {\n-        match self.filetype() {\n-            None => self.with_filename(s),\n-            Some(ref t) => self.with_filename(s.to_owned() + *t),\n-        }\n-    }\n-\n-    fn with_filetype(&self, t: &str) -> PosixPath {\n-        match (t.len(), self.filestem()) {\n-            (0, None)        => (*self).clone(),\n-            (0, Some(ref s)) => self.with_filename(*s),\n-            (_, None)        => self.with_filename(fmt!(\".%s\", t)),\n-            (_, Some(ref s)) => self.with_filename(fmt!(\"%s.%s\", *s, t)),\n-        }\n-    }\n-\n-    fn dir_path(&self) -> PosixPath {\n-        match self.components.len() {\n-            0 => (*self).clone(),\n-            _ => self.pop(),\n-        }\n-    }\n-\n     fn file_path(&self) -> PosixPath {\n         let cs = match self.filename() {\n           None => ~[],\n@@ -678,24 +684,17 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    fn push_rel(&self, other: &PosixPath) -> PosixPath {\n-        assert!(!other.is_absolute);\n-        self.push_many(other.components)\n-    }\n-\n-    fn unsafe_join(&self, other: &PosixPath) -> PosixPath {\n-        if other.is_absolute {\n-            PosixPath {\n-                is_absolute: true,\n-                components: other.components.clone(),\n+    fn push(&self, s: &str) -> PosixPath {\n+        let mut v = self.components.clone();\n+        for s in s.split_iter(posix::is_sep) {\n+            if !s.is_empty() {\n+                v.push(s.to_owned())\n             }\n-        } else {\n-            self.push_rel(other)\n         }\n-    }\n-\n-    fn is_restricted(&self) -> bool {\n-        false\n+        PosixPath {\n+            components: v,\n+            ..(*self).clone()\n+        }\n     }\n \n     fn push_many<S: Str>(&self, cs: &[S]) -> PosixPath {\n@@ -713,19 +712,6 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    fn push(&self, s: &str) -> PosixPath {\n-        let mut v = self.components.clone();\n-        for s in s.split_iter(posix::is_sep) {\n-            if !s.is_empty() {\n-                v.push(s.to_owned())\n-            }\n-        }\n-        PosixPath {\n-            components: v,\n-            ..(*self).clone()\n-        }\n-    }\n-\n     fn pop(&self) -> PosixPath {\n         let mut cs = self.components.clone();\n         if cs.len() != 0 {\n@@ -737,6 +723,21 @@ impl GenericPath for PosixPath {\n         } //..self }\n     }\n \n+    fn unsafe_join(&self, other: &PosixPath) -> PosixPath {\n+        if other.is_absolute {\n+            PosixPath {\n+                is_absolute: true,\n+                components: other.components.clone(),\n+            }\n+        } else {\n+            self.push_rel(other)\n+        }\n+    }\n+\n+    fn is_restricted(&self) -> bool {\n+        false\n+    }\n+\n     fn normalize(&self) -> PosixPath {\n         PosixPath {\n             is_absolute: self.is_absolute,\n@@ -748,15 +749,8 @@ impl GenericPath for PosixPath {\n         self.is_absolute\n     }\n \n-    fn is_ancestor_of(&self, other: &PosixPath) -> bool {\n-        debug!(\"%s / %s %? %?\", self.to_str(), other.to_str(), self.is_absolute,\n-               self.components.len());\n-        self == other ||\n-            (!other.components.is_empty() && !(self.components.is_empty() && !self.is_absolute) &&\n-             self.is_ancestor_of(&other.pop()))\n-    }\n+    fn components<'a>(&'a self) -> &'a [~str] { self.components.as_slice() }\n \n-   fn components<'a>(&'a self) -> &'a [~str] { self.components.as_slice() }\n }\n \n \n@@ -834,45 +828,6 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    fn dirname(&self) -> ~str {\n-        let s = self.dir_path().to_str();\n-        match s.len() {\n-            0 => ~\".\",\n-            _ => s,\n-        }\n-    }\n-\n-    fn filename<'a>(&'a self) -> Option<&'a str> {\n-        match self.components.len() {\n-            0 => None,\n-            n => Some(self.components[n - 1].as_slice()),\n-        }\n-    }\n-\n-    fn filestem<'a>(&'a self) -> Option<&'a str> {\n-        match self.filename() {\n-            None => None,\n-            Some(ref f) => {\n-                match f.rfind('.') {\n-                    Some(p) => Some(f.slice_to(p)),\n-                    None => Some((*f)),\n-                }\n-            }\n-        }\n-    }\n-\n-    fn filetype<'a>(&'a self) -> Option<&'a str> {\n-        match self.filename() {\n-          None => None,\n-          Some(ref f) => {\n-            match f.rfind('.') {\n-                Some(p) if p < f.len() => Some(f.slice_from(p)),\n-                _ => None,\n-            }\n-          }\n-        }\n-    }\n-\n     fn with_dirname(&self, d: &str) -> WindowsPath {\n         let dpath = WindowsPath(d);\n         match self.filename() {\n@@ -886,29 +841,6 @@ impl GenericPath for WindowsPath {\n         self.dir_path().push(f)\n     }\n \n-    fn with_filestem(&self, s: &str) -> WindowsPath {\n-        match self.filetype() {\n-            None => self.with_filename(s),\n-            Some(ref t) => self.with_filename(s.to_owned() + *t),\n-        }\n-    }\n-\n-    fn with_filetype(&self, t: &str) -> WindowsPath {\n-        match (t.len(), self.filestem()) {\n-            (0, None)        => (*self).clone(),\n-            (0, Some(ref s)) => self.with_filename(*s),\n-            (_, None)        => self.with_filename(fmt!(\".%s\", t)),\n-            (_, Some(ref s)) => self.with_filename(fmt!(\"%s.%s\", *s, t)),\n-        }\n-    }\n-\n-    fn dir_path(&self) -> WindowsPath {\n-        match self.components.len() {\n-            0 => (*self).clone(),\n-            _ => self.pop(),\n-        }\n-    }\n-\n     fn file_path(&self) -> WindowsPath {\n         WindowsPath {\n             host: None,\n@@ -921,9 +853,45 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    fn push_rel(&self, other: &WindowsPath) -> WindowsPath {\n-        assert!(!other.is_absolute);\n-        self.push_many(other.components)\n+    fn push(&self, s: &str) -> WindowsPath {\n+        let mut v = self.components.clone();\n+        for s in s.split_iter(windows::is_sep) {\n+            if !s.is_empty() {\n+                v.push(s.to_owned())\n+            }\n+        }\n+        WindowsPath { components: v, ..(*self).clone() }\n+    }\n+\n+    fn push_many<S: Str>(&self, cs: &[S]) -> WindowsPath {\n+        let mut v = self.components.clone();\n+        for e in cs.iter() {\n+            for s in e.as_slice().split_iter(windows::is_sep) {\n+                if !s.is_empty() {\n+                    v.push(s.to_owned())\n+                }\n+            }\n+        }\n+        // tedious, but as-is, we can't use ..self\n+        WindowsPath {\n+            host: self.host.clone(),\n+            device: self.device.clone(),\n+            is_absolute: self.is_absolute,\n+            components: v\n+        }\n+    }\n+\n+    fn pop(&self) -> WindowsPath {\n+        let mut cs = self.components.clone();\n+        if cs.len() != 0 {\n+            cs.pop();\n+        }\n+        WindowsPath {\n+            host: self.host.clone(),\n+            device: self.device.clone(),\n+            is_absolute: self.is_absolute,\n+            components: cs,\n+        }\n     }\n \n     fn unsafe_join(&self, other: &WindowsPath) -> WindowsPath {\n@@ -983,47 +951,6 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    fn push_many<S: Str>(&self, cs: &[S]) -> WindowsPath {\n-        let mut v = self.components.clone();\n-        for e in cs.iter() {\n-            for s in e.as_slice().split_iter(windows::is_sep) {\n-                if !s.is_empty() {\n-                    v.push(s.to_owned())\n-                }\n-            }\n-        }\n-        // tedious, but as-is, we can't use ..self\n-        WindowsPath {\n-            host: self.host.clone(),\n-            device: self.device.clone(),\n-            is_absolute: self.is_absolute,\n-            components: v\n-        }\n-    }\n-\n-    fn push(&self, s: &str) -> WindowsPath {\n-        let mut v = self.components.clone();\n-        for s in s.split_iter(windows::is_sep) {\n-            if !s.is_empty() {\n-                v.push(s.to_owned())\n-            }\n-        }\n-        WindowsPath { components: v, ..(*self).clone() }\n-    }\n-\n-    fn pop(&self) -> WindowsPath {\n-        let mut cs = self.components.clone();\n-        if cs.len() != 0 {\n-            cs.pop();\n-        }\n-        WindowsPath {\n-            host: self.host.clone(),\n-            device: self.device.clone(),\n-            is_absolute: self.is_absolute,\n-            components: cs,\n-        }\n-    }\n-\n     fn normalize(&self) -> WindowsPath {\n         WindowsPath {\n             host: self.host.clone(),\n@@ -1043,13 +970,8 @@ impl GenericPath for WindowsPath {\n         self.is_absolute\n     }\n \n-    fn is_ancestor_of(&self, other: &WindowsPath) -> bool {\n-        self == other ||\n-            (!other.components.is_empty() && !(self.components.is_empty() && !self.is_absolute) &&\n-             self.is_ancestor_of(&other.pop()))\n-    }\n+    fn components<'a>(&'a self) -> &'a [~str] { self.components.as_slice() }\n \n-   fn components<'a>(&'a self) -> &'a [~str] { self.components.as_slice() }\n }\n \n pub fn normalize(components: &[~str]) -> ~[~str] {"}]}