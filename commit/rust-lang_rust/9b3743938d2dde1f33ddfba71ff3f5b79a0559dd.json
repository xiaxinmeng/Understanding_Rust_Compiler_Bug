{"sha": "9b3743938d2dde1f33ddfba71ff3f5b79a0559dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliMzc0MzkzOGQyZGRlMWYzM2RkZmJhNzFmZjNmNWI3OWEwNTU5ZGQ=", "commit": {"author": {"name": "Philipp Br\u00fcschweiler", "email": "blei42@gmail.com", "date": "2013-06-05T11:29:22Z"}, "committer": {"name": "Philipp Br\u00fcschweiler", "email": "blei42@gmail.com", "date": "2013-06-07T08:00:48Z"}, "message": "rustc::metadata::decoder: cleanup and slightly speed up each_path", "tree": {"sha": "39a5a4df189a93500d788efed44b67859c4a92aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39a5a4df189a93500d788efed44b67859c4a92aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b3743938d2dde1f33ddfba71ff3f5b79a0559dd", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b3743938d2dde1f33ddfba71ff3f5b79a0559dd", "html_url": "https://github.com/rust-lang/rust/commit/9b3743938d2dde1f33ddfba71ff3f5b79a0559dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b3743938d2dde1f33ddfba71ff3f5b79a0559dd/comments", "author": {"login": "Blei", "id": 52674, "node_id": "MDQ6VXNlcjUyNjc0", "avatar_url": "https://avatars.githubusercontent.com/u/52674?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Blei", "html_url": "https://github.com/Blei", "followers_url": "https://api.github.com/users/Blei/followers", "following_url": "https://api.github.com/users/Blei/following{/other_user}", "gists_url": "https://api.github.com/users/Blei/gists{/gist_id}", "starred_url": "https://api.github.com/users/Blei/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Blei/subscriptions", "organizations_url": "https://api.github.com/users/Blei/orgs", "repos_url": "https://api.github.com/users/Blei/repos", "events_url": "https://api.github.com/users/Blei/events{/privacy}", "received_events_url": "https://api.github.com/users/Blei/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Blei", "id": 52674, "node_id": "MDQ6VXNlcjUyNjc0", "avatar_url": "https://avatars.githubusercontent.com/u/52674?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Blei", "html_url": "https://github.com/Blei", "followers_url": "https://api.github.com/users/Blei/followers", "following_url": "https://api.github.com/users/Blei/following{/other_user}", "gists_url": "https://api.github.com/users/Blei/gists{/gist_id}", "starred_url": "https://api.github.com/users/Blei/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Blei/subscriptions", "organizations_url": "https://api.github.com/users/Blei/orgs", "repos_url": "https://api.github.com/users/Blei/repos", "events_url": "https://api.github.com/users/Blei/events{/privacy}", "received_events_url": "https://api.github.com/users/Blei/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4abd83b18d5dffc8c2f3d827c333447c028998a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4abd83b18d5dffc8c2f3d827c333447c028998a0", "html_url": "https://github.com/rust-lang/rust/commit/4abd83b18d5dffc8c2f3d827c333447c028998a0"}], "stats": {"total": 152, "additions": 70, "deletions": 82}, "files": [{"sha": "5fa678e6121bfd92be912f2f0358ad57d2e6c21e", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 70, "deletions": 82, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/9b3743938d2dde1f33ddfba71ff3f5b79a0559dd/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3743938d2dde1f33ddfba71ff3f5b79a0559dd/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9b3743938d2dde1f33ddfba71ff3f5b79a0559dd", "patch": "@@ -476,103 +476,91 @@ pub fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) -> bool {\n }\n \n /// Iterates over all the paths in the given crate.\n-pub fn _each_path(intr: @ident_interner,\n-                  cdata: cmd,\n-                  get_crate_data: GetCrateDataCb,\n-                  f: &fn(&str, def_like, ast::visibility) -> bool)\n-                  -> bool {\n+pub fn each_path(intr: @ident_interner,\n+                 cdata: cmd,\n+                 get_crate_data: GetCrateDataCb,\n+                 f: &fn(&str, def_like, ast::visibility) -> bool)\n+                 -> bool {\n+    // FIXME #4572: This function needs to be nuked, as it's impossible to make fast.\n+    // It's the source of most of the performance problems when compiling small crates.\n+\n     let root = reader::Doc(cdata.data);\n     let items = reader::get_doc(root, tag_items);\n     let items_data = reader::get_doc(items, tag_items_data);\n \n-    let mut broken = false;\n-\n     // First, go through all the explicit items.\n     for reader::tagged_docs(items_data, tag_items_data_item) |item_doc| {\n-        if !broken {\n-            let path = ast_map::path_to_str_with_sep(\n-                item_path(item_doc), \"::\", intr);\n-            let path_is_empty = path.is_empty();\n-            if !path_is_empty {\n-                // Extract the def ID.\n-                let def_id = item_def_id(item_doc, cdata);\n-\n-                // Construct the def for this item.\n-                debug!(\"(each_path) yielding explicit item: %s\", path);\n-                let def_like = item_to_def_like(item_doc, def_id, cdata.cnum);\n-\n-                let vis = item_visibility(item_doc);\n-\n-                // Hand the information off to the iteratee.\n-                if !f(path, def_like, vis) {\n-                    broken = true;      // FIXME #4572: This is awful.\n-                }\n+        let path = ast_map::path_to_str(item_path(item_doc), intr);\n+        let path_is_empty = path.is_empty();\n+        if !path_is_empty {\n+            // Extract the def ID.\n+            let def_id = item_def_id(item_doc, cdata);\n+\n+            // Construct the def for this item.\n+            debug!(\"(each_path) yielding explicit item: %s\", path);\n+            let def_like = item_to_def_like(item_doc, def_id, cdata.cnum);\n+\n+            let vis = item_visibility(item_doc);\n+\n+            // Hand the information off to the iteratee.\n+            if !f(path, def_like, vis) {\n+                return false;\n             }\n+        }\n \n-            // If this is a module, find the reexports.\n-            for each_reexport(item_doc) |reexport_doc| {\n-                if !broken {\n-                    let def_id_doc =\n-                        reader::get_doc(reexport_doc,\n-                            tag_items_data_item_reexport_def_id);\n-                    let def_id =\n-                        reader::with_doc_data(def_id_doc,\n-                                              |d| parse_def_id(d));\n-                    let def_id = translate_def_id(cdata, def_id);\n-\n-                    let reexport_name_doc =\n-                        reader::get_doc(reexport_doc,\n-                                      tag_items_data_item_reexport_name);\n-                    let reexport_name = reader::doc_as_str(reexport_name_doc);\n-\n-                    let reexport_path;\n-                    if path_is_empty {\n-                        reexport_path = reexport_name;\n-                    } else {\n-                        reexport_path = path + \"::\" + reexport_name;\n-                    }\n+        // If this is a module, find the reexports.\n+        for each_reexport(item_doc) |reexport_doc| {\n+            let def_id_doc =\n+                reader::get_doc(reexport_doc,\n+                                tag_items_data_item_reexport_def_id);\n+            let def_id =\n+                reader::with_doc_data(def_id_doc,\n+                                      |d| parse_def_id(d));\n+            let def_id = translate_def_id(cdata, def_id);\n+\n+            let reexport_name_doc =\n+                reader::get_doc(reexport_doc,\n+                                tag_items_data_item_reexport_name);\n+            let reexport_name = reader::doc_as_str(reexport_name_doc);\n+\n+            let reexport_path;\n+            if path_is_empty {\n+                reexport_path = reexport_name;\n+            } else {\n+                reexport_path = path + \"::\" + reexport_name;\n+            }\n \n-                    // This reexport may be in yet another crate\n-                    let other_crates_items = if def_id.crate == cdata.cnum {\n-                        items\n-                    } else {\n-                        let crate_data = get_crate_data(def_id.crate);\n-                        let root = reader::Doc(crate_data.data);\n-                        reader::get_doc(root, tag_items)\n-                    };\n-\n-                    // Get the item.\n-                    match maybe_find_item(def_id.node, other_crates_items) {\n-                        None => {}\n-                        Some(item_doc) => {\n-                            // Construct the def for this item.\n-                            let def_like = item_to_def_like(item_doc,\n-                                                            def_id,\n-                                                            cdata.cnum);\n-\n-                            // Hand the information off to the iteratee.\n-                            debug!(\"(each_path) yielding reexported \\\n-                                    item: %s\", reexport_path);\n-\n-                            if (!f(reexport_path, def_like, ast::public)) {\n-                                broken = true;  // FIXME #4572: This is awful.\n-                            }\n-                        }\n+            // This reexport may be in yet another crate\n+            let other_crates_items = if def_id.crate == cdata.cnum {\n+                items\n+            } else {\n+                let crate_data = get_crate_data(def_id.crate);\n+                let root = reader::Doc(crate_data.data);\n+                reader::get_doc(root, tag_items)\n+            };\n+\n+            // Get the item.\n+            match maybe_find_item(def_id.node, other_crates_items) {\n+                None => {}\n+                Some(item_doc) => {\n+                    // Construct the def for this item.\n+                    let def_like = item_to_def_like(item_doc,\n+                                                    def_id,\n+                                                    cdata.cnum);\n+\n+                    // Hand the information off to the iteratee.\n+                    debug!(\"(each_path) yielding reexported \\\n+                           item: %s\", reexport_path);\n+\n+                    if (!f(reexport_path, def_like, ast::public)) {\n+                        return false;\n                     }\n                 }\n             }\n         }\n     }\n \n-    return broken;\n-}\n-\n-pub fn each_path(intr: @ident_interner,\n-                 cdata: cmd,\n-                 get_crate_data: GetCrateDataCb,\n-                 f: &fn(&str, def_like, ast::visibility) -> bool)\n-                 -> bool {\n-    _each_path(intr, cdata, get_crate_data, f)\n+    return true;\n }\n \n pub fn get_item_path(cdata: cmd, id: ast::node_id)"}]}