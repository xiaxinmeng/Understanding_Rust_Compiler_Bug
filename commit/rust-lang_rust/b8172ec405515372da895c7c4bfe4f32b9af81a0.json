{"sha": "b8172ec405515372da895c7c4bfe4f32b9af81a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MTcyZWM0MDU1MTUzNzJkYTg5NWM3YzRiZmU0ZjMyYjlhZjgxYTA=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-25T20:08:30Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-06-03T12:49:35Z"}, "message": "move candidate assembly into a submodule", "tree": {"sha": "8c45763b8673ba2beb2eab0a1eaf0867747a73eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c45763b8673ba2beb2eab0a1eaf0867747a73eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8172ec405515372da895c7c4bfe4f32b9af81a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8172ec405515372da895c7c4bfe4f32b9af81a0", "html_url": "https://github.com/rust-lang/rust/commit/b8172ec405515372da895c7c4bfe4f32b9af81a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8172ec405515372da895c7c4bfe4f32b9af81a0/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "634977f8f2315467392946c35e782570551da0c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/634977f8f2315467392946c35e782570551da0c3", "html_url": "https://github.com/rust-lang/rust/commit/634977f8f2315467392946c35e782570551da0c3"}], "stats": {"total": 1220, "additions": 613, "deletions": 607}, "files": [{"sha": "d42c31a5474b2a365f9043929e9543f55feef725", "filename": "src/librustc_trait_selection/traits/select/candidate_assembly.rs", "status": "added", "additions": 611, "deletions": 0, "changes": 611, "blob_url": "https://github.com/rust-lang/rust/blob/b8172ec405515372da895c7c4bfe4f32b9af81a0/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8172ec405515372da895c7c4bfe4f32b9af81a0/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=b8172ec405515372da895c7c4bfe4f32b9af81a0", "patch": "@@ -0,0 +1,611 @@\n+//! Candidate assembly.\n+//!\n+//! The selection process begins by examining all in-scope impls,\n+//! caller obligations, and so forth and assembling a list of\n+//! candidates. See the [rustc dev guide] for more details.\n+//!\n+//! [rustc dev guide]:https://rustc-dev-guide.rust-lang.org/traits/resolution.html#candidate-assembly\n+use rustc_hir as hir;\n+use rustc_infer::traits::{Obligation, SelectionError, TraitObligation};\n+use rustc_middle::ty::{self, TypeFoldable};\n+use rustc_target::spec::abi::Abi;\n+\n+use crate::traits::{util, SelectionResult};\n+\n+use super::BuiltinImplConditions;\n+use super::SelectionCandidate::{self, *};\n+use super::{SelectionCandidateSet, SelectionContext, TraitObligationStack};\n+\n+impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n+    pub(super) fn candidate_from_obligation<'o>(\n+        &mut self,\n+        stack: &TraitObligationStack<'o, 'tcx>,\n+    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n+        // Watch out for overflow. This intentionally bypasses (and does\n+        // not update) the cache.\n+        self.check_recursion_limit(&stack.obligation, &stack.obligation)?;\n+\n+        // Check the cache. Note that we freshen the trait-ref\n+        // separately rather than using `stack.fresh_trait_ref` --\n+        // this is because we want the unbound variables to be\n+        // replaced with fresh types starting from index 0.\n+        let cache_fresh_trait_pred = self.infcx.freshen(stack.obligation.predicate);\n+        debug!(\n+            \"candidate_from_obligation(cache_fresh_trait_pred={:?}, obligation={:?})\",\n+            cache_fresh_trait_pred, stack\n+        );\n+        debug_assert!(!stack.obligation.predicate.has_escaping_bound_vars());\n+\n+        if let Some(c) =\n+            self.check_candidate_cache(stack.obligation.param_env, cache_fresh_trait_pred)\n+        {\n+            debug!(\"CACHE HIT: SELECT({:?})={:?}\", cache_fresh_trait_pred, c);\n+            return c;\n+        }\n+\n+        // If no match, compute result and insert into cache.\n+        //\n+        // FIXME(nikomatsakis) -- this cache is not taking into\n+        // account cycles that may have occurred in forming the\n+        // candidate. I don't know of any specific problems that\n+        // result but it seems awfully suspicious.\n+        let (candidate, dep_node) =\n+            self.in_task(|this| this.candidate_from_obligation_no_cache(stack));\n+\n+        debug!(\"CACHE MISS: SELECT({:?})={:?}\", cache_fresh_trait_pred, candidate);\n+        self.insert_candidate_cache(\n+            stack.obligation.param_env,\n+            cache_fresh_trait_pred,\n+            dep_node,\n+            candidate.clone(),\n+        );\n+        candidate\n+    }\n+\n+    pub(super) fn assemble_candidates<'o>(\n+        &mut self,\n+        stack: &TraitObligationStack<'o, 'tcx>,\n+    ) -> Result<SelectionCandidateSet<'tcx>, SelectionError<'tcx>> {\n+        let TraitObligationStack { obligation, .. } = *stack;\n+        let obligation = &Obligation {\n+            param_env: obligation.param_env,\n+            cause: obligation.cause.clone(),\n+            recursion_depth: obligation.recursion_depth,\n+            predicate: self.infcx().resolve_vars_if_possible(&obligation.predicate),\n+        };\n+\n+        if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n+            // Self is a type variable (e.g., `_: AsRef<str>`).\n+            //\n+            // This is somewhat problematic, as the current scheme can't really\n+            // handle it turning to be a projection. This does end up as truly\n+            // ambiguous in most cases anyway.\n+            //\n+            // Take the fast path out - this also improves\n+            // performance by preventing assemble_candidates_from_impls from\n+            // matching every impl for this trait.\n+            return Ok(SelectionCandidateSet { vec: vec![], ambiguous: true });\n+        }\n+\n+        let mut candidates = SelectionCandidateSet { vec: Vec::new(), ambiguous: false };\n+\n+        self.assemble_candidates_for_trait_alias(obligation, &mut candidates)?;\n+\n+        // Other bounds. Consider both in-scope bounds from fn decl\n+        // and applicable impls. There is a certain set of precedence rules here.\n+        let def_id = obligation.predicate.def_id();\n+        let lang_items = self.tcx().lang_items();\n+\n+        if lang_items.copy_trait() == Some(def_id) {\n+            debug!(\"obligation self ty is {:?}\", obligation.predicate.skip_binder().self_ty());\n+\n+            // User-defined copy impls are permitted, but only for\n+            // structs and enums.\n+            self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n+\n+            // For other types, we'll use the builtin rules.\n+            let copy_conditions = self.copy_clone_conditions(obligation);\n+            self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates)?;\n+        } else if lang_items.discriminant_kind_trait() == Some(def_id) {\n+            // `DiscriminantKind` is automatically implemented for every type.\n+            candidates.vec.push(DiscriminantKindCandidate);\n+        } else if lang_items.sized_trait() == Some(def_id) {\n+            // Sized is never implementable by end-users, it is\n+            // always automatically computed.\n+            let sized_conditions = self.sized_conditions(obligation);\n+            self.assemble_builtin_bound_candidates(sized_conditions, &mut candidates)?;\n+        } else if lang_items.unsize_trait() == Some(def_id) {\n+            self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n+        } else {\n+            if lang_items.clone_trait() == Some(def_id) {\n+                // Same builtin conditions as `Copy`, i.e., every type which has builtin support\n+                // for `Copy` also has builtin support for `Clone`, and tuples/arrays of `Clone`\n+                // types have builtin support for `Clone`.\n+                let clone_conditions = self.copy_clone_conditions(obligation);\n+                self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates)?;\n+            }\n+\n+            self.assemble_generator_candidates(obligation, &mut candidates)?;\n+            self.assemble_closure_candidates(obligation, &mut candidates)?;\n+            self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n+            self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n+            self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n+        }\n+\n+        self.assemble_candidates_from_projected_tys(obligation, &mut candidates);\n+        self.assemble_candidates_from_caller_bounds(stack, &mut candidates)?;\n+        // Auto implementations have lower priority, so we only\n+        // consider triggering a default if there is no other impl that can apply.\n+        if candidates.vec.is_empty() {\n+            self.assemble_candidates_from_auto_impls(obligation, &mut candidates)?;\n+        }\n+        debug!(\"candidate list size: {}\", candidates.vec.len());\n+        Ok(candidates)\n+    }\n+\n+    fn assemble_candidates_from_projected_tys(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) {\n+        debug!(\"assemble_candidates_for_projected_tys({:?})\", obligation);\n+\n+        // Before we go into the whole placeholder thing, just\n+        // quickly check if the self-type is a projection at all.\n+        match obligation.predicate.skip_binder().trait_ref.self_ty().kind {\n+            ty::Projection(_) | ty::Opaque(..) => {}\n+            ty::Infer(ty::TyVar(_)) => {\n+                span_bug!(\n+                    obligation.cause.span,\n+                    \"Self=_ should have been handled by assemble_candidates\"\n+                );\n+            }\n+            _ => return,\n+        }\n+\n+        let result = self.infcx.probe(|snapshot| {\n+            self.match_projection_obligation_against_definition_bounds(obligation, snapshot)\n+        });\n+\n+        if result {\n+            candidates.vec.push(ProjectionCandidate);\n+        }\n+    }\n+\n+    /// Given an obligation like `<SomeTrait for T>`, searches the obligations that the caller\n+    /// supplied to find out whether it is listed among them.\n+    ///\n+    /// Never affects the inference environment.\n+    fn assemble_candidates_from_caller_bounds<'o>(\n+        &mut self,\n+        stack: &TraitObligationStack<'o, 'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) -> Result<(), SelectionError<'tcx>> {\n+        debug!(\"assemble_candidates_from_caller_bounds({:?})\", stack.obligation);\n+\n+        let all_bounds = stack\n+            .obligation\n+            .param_env\n+            .caller_bounds\n+            .iter()\n+            .filter_map(|o| o.to_opt_poly_trait_ref());\n+\n+        // Micro-optimization: filter out predicates relating to different traits.\n+        let matching_bounds =\n+            all_bounds.filter(|p| p.def_id() == stack.obligation.predicate.def_id());\n+\n+        // Keep only those bounds which may apply, and propagate overflow if it occurs.\n+        let mut param_candidates = vec![];\n+        for bound in matching_bounds {\n+            let wc = self.evaluate_where_clause(stack, bound)?;\n+            if wc.may_apply() {\n+                param_candidates.push(ParamCandidate(bound));\n+            }\n+        }\n+\n+        candidates.vec.extend(param_candidates);\n+\n+        Ok(())\n+    }\n+\n+    fn assemble_generator_candidates(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) -> Result<(), SelectionError<'tcx>> {\n+        if self.tcx().lang_items().gen_trait() != Some(obligation.predicate.def_id()) {\n+            return Ok(());\n+        }\n+\n+        // Okay to skip binder because the substs on generator types never\n+        // touch bound regions, they just capture the in-scope\n+        // type/region parameters.\n+        let self_ty = *obligation.self_ty().skip_binder();\n+        match self_ty.kind {\n+            ty::Generator(..) => {\n+                debug!(\n+                    \"assemble_generator_candidates: self_ty={:?} obligation={:?}\",\n+                    self_ty, obligation\n+                );\n+\n+                candidates.vec.push(GeneratorCandidate);\n+            }\n+            ty::Infer(ty::TyVar(_)) => {\n+                debug!(\"assemble_generator_candidates: ambiguous self-type\");\n+                candidates.ambiguous = true;\n+            }\n+            _ => {}\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Checks for the artificial impl that the compiler will create for an obligation like `X :\n+    /// FnMut<..>` where `X` is a closure type.\n+    ///\n+    /// Note: the type parameters on a closure candidate are modeled as *output* type\n+    /// parameters and hence do not affect whether this trait is a match or not. They will be\n+    /// unified during the confirmation step.\n+    fn assemble_closure_candidates(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) -> Result<(), SelectionError<'tcx>> {\n+        let kind = match self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()) {\n+            Some(k) => k,\n+            None => {\n+                return Ok(());\n+            }\n+        };\n+\n+        // Okay to skip binder because the substs on closure types never\n+        // touch bound regions, they just capture the in-scope\n+        // type/region parameters\n+        match obligation.self_ty().skip_binder().kind {\n+            ty::Closure(_, closure_substs) => {\n+                debug!(\"assemble_unboxed_candidates: kind={:?} obligation={:?}\", kind, obligation);\n+                match self.infcx.closure_kind(closure_substs) {\n+                    Some(closure_kind) => {\n+                        debug!(\"assemble_unboxed_candidates: closure_kind = {:?}\", closure_kind);\n+                        if closure_kind.extends(kind) {\n+                            candidates.vec.push(ClosureCandidate);\n+                        }\n+                    }\n+                    None => {\n+                        debug!(\"assemble_unboxed_candidates: closure_kind not yet known\");\n+                        candidates.vec.push(ClosureCandidate);\n+                    }\n+                }\n+            }\n+            ty::Infer(ty::TyVar(_)) => {\n+                debug!(\"assemble_unboxed_closure_candidates: ambiguous self-type\");\n+                candidates.ambiguous = true;\n+            }\n+            _ => {}\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Implements one of the `Fn()` family for a fn pointer.\n+    fn assemble_fn_pointer_candidates(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) -> Result<(), SelectionError<'tcx>> {\n+        // We provide impl of all fn traits for fn pointers.\n+        if self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()).is_none() {\n+            return Ok(());\n+        }\n+\n+        // Okay to skip binder because what we are inspecting doesn't involve bound regions.\n+        let self_ty = *obligation.self_ty().skip_binder();\n+        match self_ty.kind {\n+            ty::Infer(ty::TyVar(_)) => {\n+                debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n+                candidates.ambiguous = true; // Could wind up being a fn() type.\n+            }\n+            // Provide an impl, but only for suitable `fn` pointers.\n+            ty::FnDef(..) | ty::FnPtr(_) => {\n+                if let ty::FnSig {\n+                    unsafety: hir::Unsafety::Normal,\n+                    abi: Abi::Rust,\n+                    c_variadic: false,\n+                    ..\n+                } = self_ty.fn_sig(self.tcx()).skip_binder()\n+                {\n+                    candidates.vec.push(FnPointerCandidate);\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Searches for impls that might apply to `obligation`.\n+    fn assemble_candidates_from_impls(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) -> Result<(), SelectionError<'tcx>> {\n+        debug!(\"assemble_candidates_from_impls(obligation={:?})\", obligation);\n+\n+        self.tcx().for_each_relevant_impl(\n+            obligation.predicate.def_id(),\n+            obligation.predicate.skip_binder().trait_ref.self_ty(),\n+            |impl_def_id| {\n+                self.infcx.probe(|snapshot| {\n+                    if let Ok(_substs) = self.match_impl(impl_def_id, obligation, snapshot) {\n+                        candidates.vec.push(ImplCandidate(impl_def_id));\n+                    }\n+                });\n+            },\n+        );\n+\n+        Ok(())\n+    }\n+\n+    fn assemble_candidates_from_auto_impls(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) -> Result<(), SelectionError<'tcx>> {\n+        // Okay to skip binder here because the tests we do below do not involve bound regions.\n+        let self_ty = *obligation.self_ty().skip_binder();\n+        debug!(\"assemble_candidates_from_auto_impls(self_ty={:?})\", self_ty);\n+\n+        let def_id = obligation.predicate.def_id();\n+\n+        if self.tcx().trait_is_auto(def_id) {\n+            match self_ty.kind {\n+                ty::Dynamic(..) => {\n+                    // For object types, we don't know what the closed\n+                    // over types are. This means we conservatively\n+                    // say nothing; a candidate may be added by\n+                    // `assemble_candidates_from_object_ty`.\n+                }\n+                ty::Foreign(..) => {\n+                    // Since the contents of foreign types is unknown,\n+                    // we don't add any `..` impl. Default traits could\n+                    // still be provided by a manual implementation for\n+                    // this trait and type.\n+                }\n+                ty::Param(..) | ty::Projection(..) => {\n+                    // In these cases, we don't know what the actual\n+                    // type is.  Therefore, we cannot break it down\n+                    // into its constituent types. So we don't\n+                    // consider the `..` impl but instead just add no\n+                    // candidates: this means that typeck will only\n+                    // succeed if there is another reason to believe\n+                    // that this obligation holds. That could be a\n+                    // where-clause or, in the case of an object type,\n+                    // it could be that the object type lists the\n+                    // trait (e.g., `Foo+Send : Send`). See\n+                    // `compile-fail/typeck-default-trait-impl-send-param.rs`\n+                    // for an example of a test case that exercises\n+                    // this path.\n+                }\n+                ty::Infer(ty::TyVar(_)) => {\n+                    // The auto impl might apply; we don't know.\n+                    candidates.ambiguous = true;\n+                }\n+                ty::Generator(_, _, movability)\n+                    if self.tcx().lang_items().unpin_trait() == Some(def_id) =>\n+                {\n+                    match movability {\n+                        hir::Movability::Static => {\n+                            // Immovable generators are never `Unpin`, so\n+                            // suppress the normal auto-impl candidate for it.\n+                        }\n+                        hir::Movability::Movable => {\n+                            // Movable generators are always `Unpin`, so add an\n+                            // unconditional builtin candidate.\n+                            candidates.vec.push(BuiltinCandidate { has_nested: false });\n+                        }\n+                    }\n+                }\n+\n+                _ => candidates.vec.push(AutoImplCandidate(def_id)),\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Searches for impls that might apply to `obligation`.\n+    fn assemble_candidates_from_object_ty(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) {\n+        debug!(\n+            \"assemble_candidates_from_object_ty(self_ty={:?})\",\n+            obligation.self_ty().skip_binder()\n+        );\n+\n+        self.infcx.probe(|_snapshot| {\n+            // The code below doesn't care about regions, and the\n+            // self-ty here doesn't escape this probe, so just erase\n+            // any LBR.\n+            let self_ty = self.tcx().erase_late_bound_regions(&obligation.self_ty());\n+            let poly_trait_ref = match self_ty.kind {\n+                ty::Dynamic(ref data, ..) => {\n+                    if data.auto_traits().any(|did| did == obligation.predicate.def_id()) {\n+                        debug!(\n+                            \"assemble_candidates_from_object_ty: matched builtin bound, \\\n+                             pushing candidate\"\n+                        );\n+                        candidates.vec.push(BuiltinObjectCandidate);\n+                        return;\n+                    }\n+\n+                    if let Some(principal) = data.principal() {\n+                        if !self.infcx.tcx.features().object_safe_for_dispatch {\n+                            principal.with_self_ty(self.tcx(), self_ty)\n+                        } else if self.tcx().is_object_safe(principal.def_id()) {\n+                            principal.with_self_ty(self.tcx(), self_ty)\n+                        } else {\n+                            return;\n+                        }\n+                    } else {\n+                        // Only auto trait bounds exist.\n+                        return;\n+                    }\n+                }\n+                ty::Infer(ty::TyVar(_)) => {\n+                    debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n+                    candidates.ambiguous = true; // could wind up being an object type\n+                    return;\n+                }\n+                _ => return,\n+            };\n+\n+            debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={:?}\", poly_trait_ref);\n+\n+            // Count only those upcast versions that match the trait-ref\n+            // we are looking for. Specifically, do not only check for the\n+            // correct trait, but also the correct type parameters.\n+            // For example, we may be trying to upcast `Foo` to `Bar<i32>`,\n+            // but `Foo` is declared as `trait Foo: Bar<u32>`.\n+            let upcast_trait_refs = util::supertraits(self.tcx(), poly_trait_ref)\n+                .filter(|upcast_trait_ref| {\n+                    self.infcx\n+                        .probe(|_| self.match_poly_trait_ref(obligation, *upcast_trait_ref).is_ok())\n+                })\n+                .count();\n+\n+            if upcast_trait_refs > 1 {\n+                // Can be upcast in many ways; need more type information.\n+                candidates.ambiguous = true;\n+            } else if upcast_trait_refs == 1 {\n+                candidates.vec.push(ObjectCandidate);\n+            }\n+        })\n+    }\n+\n+    /// Searches for unsizing that might apply to `obligation`.\n+    fn assemble_candidates_for_unsizing(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) {\n+        // We currently never consider higher-ranked obligations e.g.\n+        // `for<'a> &'a T: Unsize<Trait+'a>` to be implemented. This is not\n+        // because they are a priori invalid, and we could potentially add support\n+        // for them later, it's just that there isn't really a strong need for it.\n+        // A `T: Unsize<U>` obligation is always used as part of a `T: CoerceUnsize<U>`\n+        // impl, and those are generally applied to concrete types.\n+        //\n+        // That said, one might try to write a fn with a where clause like\n+        //     for<'a> Foo<'a, T>: Unsize<Foo<'a, Trait>>\n+        // where the `'a` is kind of orthogonal to the relevant part of the `Unsize`.\n+        // Still, you'd be more likely to write that where clause as\n+        //     T: Trait\n+        // so it seems ok if we (conservatively) fail to accept that `Unsize`\n+        // obligation above. Should be possible to extend this in the future.\n+        let source = match obligation.self_ty().no_bound_vars() {\n+            Some(t) => t,\n+            None => {\n+                // Don't add any candidates if there are bound regions.\n+                return;\n+            }\n+        };\n+        let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n+\n+        debug!(\"assemble_candidates_for_unsizing(source={:?}, target={:?})\", source, target);\n+\n+        let may_apply = match (&source.kind, &target.kind) {\n+            // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n+            (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n+                // Upcasts permit two things:\n+                //\n+                // 1. Dropping auto traits, e.g., `Foo + Send` to `Foo`\n+                // 2. Tightening the region bound, e.g., `Foo + 'a` to `Foo + 'b` if `'a: 'b`\n+                //\n+                // Note that neither of these changes requires any\n+                // change at runtime. Eventually this will be\n+                // generalized.\n+                //\n+                // We always upcast when we can because of reason\n+                // #2 (region bounds).\n+                data_a.principal_def_id() == data_b.principal_def_id()\n+                    && data_b\n+                        .auto_traits()\n+                        // All of a's auto traits need to be in b's auto traits.\n+                        .all(|b| data_a.auto_traits().any(|a| a == b))\n+            }\n+\n+            // `T` -> `Trait`\n+            (_, &ty::Dynamic(..)) => true,\n+\n+            // Ambiguous handling is below `T` -> `Trait`, because inference\n+            // variables can still implement `Unsize<Trait>` and nested\n+            // obligations will have the final say (likely deferred).\n+            (&ty::Infer(ty::TyVar(_)), _) | (_, &ty::Infer(ty::TyVar(_))) => {\n+                debug!(\"assemble_candidates_for_unsizing: ambiguous\");\n+                candidates.ambiguous = true;\n+                false\n+            }\n+\n+            // `[T; n]` -> `[T]`\n+            (&ty::Array(..), &ty::Slice(_)) => true,\n+\n+            // `Struct<T>` -> `Struct<U>`\n+            (&ty::Adt(def_id_a, _), &ty::Adt(def_id_b, _)) if def_id_a.is_struct() => {\n+                def_id_a == def_id_b\n+            }\n+\n+            // `(.., T)` -> `(.., U)`\n+            (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => tys_a.len() == tys_b.len(),\n+\n+            _ => false,\n+        };\n+\n+        if may_apply {\n+            candidates.vec.push(BuiltinUnsizeCandidate);\n+        }\n+    }\n+\n+    fn assemble_candidates_for_trait_alias(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) -> Result<(), SelectionError<'tcx>> {\n+        // Okay to skip binder here because the tests we do below do not involve bound regions.\n+        let self_ty = *obligation.self_ty().skip_binder();\n+        debug!(\"assemble_candidates_for_trait_alias(self_ty={:?})\", self_ty);\n+\n+        let def_id = obligation.predicate.def_id();\n+\n+        if self.tcx().is_trait_alias(def_id) {\n+            candidates.vec.push(TraitAliasCandidate(def_id));\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Assembles the trait which are built-in to the language itself:\n+    /// `Copy`, `Clone` and `Sized`.\n+    fn assemble_builtin_bound_candidates(\n+        &mut self,\n+        conditions: BuiltinImplConditions<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) -> Result<(), SelectionError<'tcx>> {\n+        match conditions {\n+            BuiltinImplConditions::Where(nested) => {\n+                debug!(\"builtin_bound: nested={:?}\", nested);\n+                candidates\n+                    .vec\n+                    .push(BuiltinCandidate { has_nested: !nested.skip_binder().is_empty() });\n+            }\n+            BuiltinImplConditions::None => {}\n+            BuiltinImplConditions::Ambiguous => {\n+                debug!(\"assemble_builtin_bound_candidates: ambiguous builtin\");\n+                candidates.ambiguous = true;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "23ff107908b5cccfd788021ed77124106e8c7caf", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 607, "changes": 609, "blob_url": "https://github.com/rust-lang/rust/blob/b8172ec405515372da895c7c4bfe4f32b9af81a0/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8172ec405515372da895c7c4bfe4f32b9af81a0/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=b8172ec405515372da895c7c4bfe4f32b9af81a0", "patch": "@@ -53,7 +53,6 @@ use rustc_middle::ty::{\n     self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n };\n use rustc_span::symbol::sym;\n-use rustc_target::spec::abi::Abi;\n \n use std::cell::{Cell, RefCell};\n use std::cmp;\n@@ -63,6 +62,8 @@ use std::rc::Rc;\n \n pub use rustc_middle::traits::select::*;\n \n+mod candidate_assembly;\n+\n pub struct SelectionContext<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n \n@@ -932,61 +933,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(())\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    // CANDIDATE ASSEMBLY\n-    //\n-    // The selection process begins by examining all in-scope impls,\n-    // caller obligations, and so forth and assembling a list of\n-    // candidates. See the [rustc dev guide] for more details.\n-    //\n-    // [rustc dev guide]:\n-    // https://rustc-dev-guide.rust-lang.org/traits/resolution.html#candidate-assembly\n-\n-    fn candidate_from_obligation<'o>(\n-        &mut self,\n-        stack: &TraitObligationStack<'o, 'tcx>,\n-    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n-        // Watch out for overflow. This intentionally bypasses (and does\n-        // not update) the cache.\n-        self.check_recursion_limit(&stack.obligation, &stack.obligation)?;\n-\n-        // Check the cache. Note that we freshen the trait-ref\n-        // separately rather than using `stack.fresh_trait_ref` --\n-        // this is because we want the unbound variables to be\n-        // replaced with fresh types starting from index 0.\n-        let cache_fresh_trait_pred = self.infcx.freshen(stack.obligation.predicate);\n-        debug!(\n-            \"candidate_from_obligation(cache_fresh_trait_pred={:?}, obligation={:?})\",\n-            cache_fresh_trait_pred, stack\n-        );\n-        debug_assert!(!stack.obligation.predicate.has_escaping_bound_vars());\n-\n-        if let Some(c) =\n-            self.check_candidate_cache(stack.obligation.param_env, cache_fresh_trait_pred)\n-        {\n-            debug!(\"CACHE HIT: SELECT({:?})={:?}\", cache_fresh_trait_pred, c);\n-            return c;\n-        }\n-\n-        // If no match, compute result and insert into cache.\n-        //\n-        // FIXME(nikomatsakis) -- this cache is not taking into\n-        // account cycles that may have occurred in forming the\n-        // candidate. I don't know of any specific problems that\n-        // result but it seems awfully suspicious.\n-        let (candidate, dep_node) =\n-            self.in_task(|this| this.candidate_from_obligation_no_cache(stack));\n-\n-        debug!(\"CACHE MISS: SELECT({:?})={:?}\", cache_fresh_trait_pred, candidate);\n-        self.insert_candidate_cache(\n-            stack.obligation.param_env,\n-            cache_fresh_trait_pred,\n-            dep_node,\n-            candidate.clone(),\n-        );\n-        candidate\n-    }\n-\n     fn in_task<OP, R>(&mut self, op: OP) -> (R, DepNodeIndex)\n     where\n         OP: FnOnce(&mut Self) -> R,\n@@ -1320,116 +1266,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .insert(param_env.and(trait_ref), WithDepNode::new(dep_node, candidate));\n     }\n \n-    fn assemble_candidates<'o>(\n-        &mut self,\n-        stack: &TraitObligationStack<'o, 'tcx>,\n-    ) -> Result<SelectionCandidateSet<'tcx>, SelectionError<'tcx>> {\n-        let TraitObligationStack { obligation, .. } = *stack;\n-        let obligation = &Obligation {\n-            param_env: obligation.param_env,\n-            cause: obligation.cause.clone(),\n-            recursion_depth: obligation.recursion_depth,\n-            predicate: self.infcx().resolve_vars_if_possible(&obligation.predicate),\n-        };\n-\n-        if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n-            // Self is a type variable (e.g., `_: AsRef<str>`).\n-            //\n-            // This is somewhat problematic, as the current scheme can't really\n-            // handle it turning to be a projection. This does end up as truly\n-            // ambiguous in most cases anyway.\n-            //\n-            // Take the fast path out - this also improves\n-            // performance by preventing assemble_candidates_from_impls from\n-            // matching every impl for this trait.\n-            return Ok(SelectionCandidateSet { vec: vec![], ambiguous: true });\n-        }\n-\n-        let mut candidates = SelectionCandidateSet { vec: Vec::new(), ambiguous: false };\n-\n-        self.assemble_candidates_for_trait_alias(obligation, &mut candidates)?;\n-\n-        // Other bounds. Consider both in-scope bounds from fn decl\n-        // and applicable impls. There is a certain set of precedence rules here.\n-        let def_id = obligation.predicate.def_id();\n-        let lang_items = self.tcx().lang_items();\n-\n-        if lang_items.copy_trait() == Some(def_id) {\n-            debug!(\"obligation self ty is {:?}\", obligation.predicate.skip_binder().self_ty());\n-\n-            // User-defined copy impls are permitted, but only for\n-            // structs and enums.\n-            self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n-\n-            // For other types, we'll use the builtin rules.\n-            let copy_conditions = self.copy_clone_conditions(obligation);\n-            self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates)?;\n-        } else if lang_items.discriminant_kind_trait() == Some(def_id) {\n-            // `DiscriminantKind` is automatically implemented for every type.\n-            candidates.vec.push(DiscriminantKindCandidate);\n-        } else if lang_items.sized_trait() == Some(def_id) {\n-            // Sized is never implementable by end-users, it is\n-            // always automatically computed.\n-            let sized_conditions = self.sized_conditions(obligation);\n-            self.assemble_builtin_bound_candidates(sized_conditions, &mut candidates)?;\n-        } else if lang_items.unsize_trait() == Some(def_id) {\n-            self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n-        } else {\n-            if lang_items.clone_trait() == Some(def_id) {\n-                // Same builtin conditions as `Copy`, i.e., every type which has builtin support\n-                // for `Copy` also has builtin support for `Clone`, and tuples/arrays of `Clone`\n-                // types have builtin support for `Clone`.\n-                let clone_conditions = self.copy_clone_conditions(obligation);\n-                self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates)?;\n-            }\n-\n-            self.assemble_generator_candidates(obligation, &mut candidates)?;\n-            self.assemble_closure_candidates(obligation, &mut candidates)?;\n-            self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n-            self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n-            self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n-        }\n-\n-        self.assemble_candidates_from_projected_tys(obligation, &mut candidates);\n-        self.assemble_candidates_from_caller_bounds(stack, &mut candidates)?;\n-        // Auto implementations have lower priority, so we only\n-        // consider triggering a default if there is no other impl that can apply.\n-        if candidates.vec.is_empty() {\n-            self.assemble_candidates_from_auto_impls(obligation, &mut candidates)?;\n-        }\n-        debug!(\"candidate list size: {}\", candidates.vec.len());\n-        Ok(candidates)\n-    }\n-\n-    fn assemble_candidates_from_projected_tys(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) {\n-        debug!(\"assemble_candidates_for_projected_tys({:?})\", obligation);\n-\n-        // Before we go into the whole placeholder thing, just\n-        // quickly check if the self-type is a projection at all.\n-        match obligation.predicate.skip_binder().trait_ref.self_ty().kind {\n-            ty::Projection(_) | ty::Opaque(..) => {}\n-            ty::Infer(ty::TyVar(_)) => {\n-                span_bug!(\n-                    obligation.cause.span,\n-                    \"Self=_ should have been handled by assemble_candidates\"\n-                );\n-            }\n-            _ => return,\n-        }\n-\n-        let result = self.infcx.probe(|snapshot| {\n-            self.match_projection_obligation_against_definition_bounds(obligation, snapshot)\n-        });\n-\n-        if result {\n-            candidates.vec.push(ProjectionCandidate);\n-        }\n-    }\n-\n     fn match_projection_obligation_against_definition_bounds(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n@@ -1523,42 +1359,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             && self.infcx.leak_check(false, placeholder_map, snapshot).is_ok()\n     }\n \n-    /// Given an obligation like `<SomeTrait for T>`, searches the obligations that the caller\n-    /// supplied to find out whether it is listed among them.\n-    ///\n-    /// Never affects the inference environment.\n-    fn assemble_candidates_from_caller_bounds<'o>(\n-        &mut self,\n-        stack: &TraitObligationStack<'o, 'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n-        debug!(\"assemble_candidates_from_caller_bounds({:?})\", stack.obligation);\n-\n-        let all_bounds = stack\n-            .obligation\n-            .param_env\n-            .caller_bounds\n-            .iter()\n-            .filter_map(|o| o.to_opt_poly_trait_ref());\n-\n-        // Micro-optimization: filter out predicates relating to different traits.\n-        let matching_bounds =\n-            all_bounds.filter(|p| p.def_id() == stack.obligation.predicate.def_id());\n-\n-        // Keep only those bounds which may apply, and propagate overflow if it occurs.\n-        let mut param_candidates = vec![];\n-        for bound in matching_bounds {\n-            let wc = self.evaluate_where_clause(stack, bound)?;\n-            if wc.may_apply() {\n-                param_candidates.push(ParamCandidate(bound));\n-            }\n-        }\n-\n-        candidates.vec.extend(param_candidates);\n-\n-        Ok(())\n-    }\n-\n     fn evaluate_where_clause<'o>(\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n@@ -1574,383 +1374,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         })\n     }\n \n-    fn assemble_generator_candidates(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n-        if self.tcx().lang_items().gen_trait() != Some(obligation.predicate.def_id()) {\n-            return Ok(());\n-        }\n-\n-        // Okay to skip binder because the substs on generator types never\n-        // touch bound regions, they just capture the in-scope\n-        // type/region parameters.\n-        let self_ty = *obligation.self_ty().skip_binder();\n-        match self_ty.kind {\n-            ty::Generator(..) => {\n-                debug!(\n-                    \"assemble_generator_candidates: self_ty={:?} obligation={:?}\",\n-                    self_ty, obligation\n-                );\n-\n-                candidates.vec.push(GeneratorCandidate);\n-            }\n-            ty::Infer(ty::TyVar(_)) => {\n-                debug!(\"assemble_generator_candidates: ambiguous self-type\");\n-                candidates.ambiguous = true;\n-            }\n-            _ => {}\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// Checks for the artificial impl that the compiler will create for an obligation like `X :\n-    /// FnMut<..>` where `X` is a closure type.\n-    ///\n-    /// Note: the type parameters on a closure candidate are modeled as *output* type\n-    /// parameters and hence do not affect whether this trait is a match or not. They will be\n-    /// unified during the confirmation step.\n-    fn assemble_closure_candidates(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n-        let kind = match self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()) {\n-            Some(k) => k,\n-            None => {\n-                return Ok(());\n-            }\n-        };\n-\n-        // Okay to skip binder because the substs on closure types never\n-        // touch bound regions, they just capture the in-scope\n-        // type/region parameters\n-        match obligation.self_ty().skip_binder().kind {\n-            ty::Closure(_, closure_substs) => {\n-                debug!(\"assemble_unboxed_candidates: kind={:?} obligation={:?}\", kind, obligation);\n-                match self.infcx.closure_kind(closure_substs) {\n-                    Some(closure_kind) => {\n-                        debug!(\"assemble_unboxed_candidates: closure_kind = {:?}\", closure_kind);\n-                        if closure_kind.extends(kind) {\n-                            candidates.vec.push(ClosureCandidate);\n-                        }\n-                    }\n-                    None => {\n-                        debug!(\"assemble_unboxed_candidates: closure_kind not yet known\");\n-                        candidates.vec.push(ClosureCandidate);\n-                    }\n-                }\n-            }\n-            ty::Infer(ty::TyVar(_)) => {\n-                debug!(\"assemble_unboxed_closure_candidates: ambiguous self-type\");\n-                candidates.ambiguous = true;\n-            }\n-            _ => {}\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// Implements one of the `Fn()` family for a fn pointer.\n-    fn assemble_fn_pointer_candidates(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n-        // We provide impl of all fn traits for fn pointers.\n-        if self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()).is_none() {\n-            return Ok(());\n-        }\n-\n-        // Okay to skip binder because what we are inspecting doesn't involve bound regions.\n-        let self_ty = *obligation.self_ty().skip_binder();\n-        match self_ty.kind {\n-            ty::Infer(ty::TyVar(_)) => {\n-                debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n-                candidates.ambiguous = true; // Could wind up being a fn() type.\n-            }\n-            // Provide an impl, but only for suitable `fn` pointers.\n-            ty::FnDef(..) | ty::FnPtr(_) => {\n-                if let ty::FnSig {\n-                    unsafety: hir::Unsafety::Normal,\n-                    abi: Abi::Rust,\n-                    c_variadic: false,\n-                    ..\n-                } = self_ty.fn_sig(self.tcx()).skip_binder()\n-                {\n-                    candidates.vec.push(FnPointerCandidate);\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// Searches for impls that might apply to `obligation`.\n-    fn assemble_candidates_from_impls(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n-        debug!(\"assemble_candidates_from_impls(obligation={:?})\", obligation);\n-\n-        self.tcx().for_each_relevant_impl(\n-            obligation.predicate.def_id(),\n-            obligation.predicate.skip_binder().trait_ref.self_ty(),\n-            |impl_def_id| {\n-                self.infcx.probe(|snapshot| {\n-                    if let Ok(_substs) = self.match_impl(impl_def_id, obligation, snapshot) {\n-                        candidates.vec.push(ImplCandidate(impl_def_id));\n-                    }\n-                });\n-            },\n-        );\n-\n-        Ok(())\n-    }\n-\n-    fn assemble_candidates_from_auto_impls(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n-        // Okay to skip binder here because the tests we do below do not involve bound regions.\n-        let self_ty = *obligation.self_ty().skip_binder();\n-        debug!(\"assemble_candidates_from_auto_impls(self_ty={:?})\", self_ty);\n-\n-        let def_id = obligation.predicate.def_id();\n-\n-        if self.tcx().trait_is_auto(def_id) {\n-            match self_ty.kind {\n-                ty::Dynamic(..) => {\n-                    // For object types, we don't know what the closed\n-                    // over types are. This means we conservatively\n-                    // say nothing; a candidate may be added by\n-                    // `assemble_candidates_from_object_ty`.\n-                }\n-                ty::Foreign(..) => {\n-                    // Since the contents of foreign types is unknown,\n-                    // we don't add any `..` impl. Default traits could\n-                    // still be provided by a manual implementation for\n-                    // this trait and type.\n-                }\n-                ty::Param(..) | ty::Projection(..) => {\n-                    // In these cases, we don't know what the actual\n-                    // type is.  Therefore, we cannot break it down\n-                    // into its constituent types. So we don't\n-                    // consider the `..` impl but instead just add no\n-                    // candidates: this means that typeck will only\n-                    // succeed if there is another reason to believe\n-                    // that this obligation holds. That could be a\n-                    // where-clause or, in the case of an object type,\n-                    // it could be that the object type lists the\n-                    // trait (e.g., `Foo+Send : Send`). See\n-                    // `compile-fail/typeck-default-trait-impl-send-param.rs`\n-                    // for an example of a test case that exercises\n-                    // this path.\n-                }\n-                ty::Infer(ty::TyVar(_)) => {\n-                    // The auto impl might apply; we don't know.\n-                    candidates.ambiguous = true;\n-                }\n-                ty::Generator(_, _, movability)\n-                    if self.tcx().lang_items().unpin_trait() == Some(def_id) =>\n-                {\n-                    match movability {\n-                        hir::Movability::Static => {\n-                            // Immovable generators are never `Unpin`, so\n-                            // suppress the normal auto-impl candidate for it.\n-                        }\n-                        hir::Movability::Movable => {\n-                            // Movable generators are always `Unpin`, so add an\n-                            // unconditional builtin candidate.\n-                            candidates.vec.push(BuiltinCandidate { has_nested: false });\n-                        }\n-                    }\n-                }\n-\n-                _ => candidates.vec.push(AutoImplCandidate(def_id)),\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// Searches for impls that might apply to `obligation`.\n-    fn assemble_candidates_from_object_ty(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) {\n-        debug!(\n-            \"assemble_candidates_from_object_ty(self_ty={:?})\",\n-            obligation.self_ty().skip_binder()\n-        );\n-\n-        self.infcx.probe(|_snapshot| {\n-            // The code below doesn't care about regions, and the\n-            // self-ty here doesn't escape this probe, so just erase\n-            // any LBR.\n-            let self_ty = self.tcx().erase_late_bound_regions(&obligation.self_ty());\n-            let poly_trait_ref = match self_ty.kind {\n-                ty::Dynamic(ref data, ..) => {\n-                    if data.auto_traits().any(|did| did == obligation.predicate.def_id()) {\n-                        debug!(\n-                            \"assemble_candidates_from_object_ty: matched builtin bound, \\\n-                             pushing candidate\"\n-                        );\n-                        candidates.vec.push(BuiltinObjectCandidate);\n-                        return;\n-                    }\n-\n-                    if let Some(principal) = data.principal() {\n-                        if !self.infcx.tcx.features().object_safe_for_dispatch {\n-                            principal.with_self_ty(self.tcx(), self_ty)\n-                        } else if self.tcx().is_object_safe(principal.def_id()) {\n-                            principal.with_self_ty(self.tcx(), self_ty)\n-                        } else {\n-                            return;\n-                        }\n-                    } else {\n-                        // Only auto trait bounds exist.\n-                        return;\n-                    }\n-                }\n-                ty::Infer(ty::TyVar(_)) => {\n-                    debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n-                    candidates.ambiguous = true; // could wind up being an object type\n-                    return;\n-                }\n-                _ => return,\n-            };\n-\n-            debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={:?}\", poly_trait_ref);\n-\n-            // Count only those upcast versions that match the trait-ref\n-            // we are looking for. Specifically, do not only check for the\n-            // correct trait, but also the correct type parameters.\n-            // For example, we may be trying to upcast `Foo` to `Bar<i32>`,\n-            // but `Foo` is declared as `trait Foo: Bar<u32>`.\n-            let upcast_trait_refs = util::supertraits(self.tcx(), poly_trait_ref)\n-                .filter(|upcast_trait_ref| {\n-                    self.infcx\n-                        .probe(|_| self.match_poly_trait_ref(obligation, *upcast_trait_ref).is_ok())\n-                })\n-                .count();\n-\n-            if upcast_trait_refs > 1 {\n-                // Can be upcast in many ways; need more type information.\n-                candidates.ambiguous = true;\n-            } else if upcast_trait_refs == 1 {\n-                candidates.vec.push(ObjectCandidate);\n-            }\n-        })\n-    }\n-\n-    /// Searches for unsizing that might apply to `obligation`.\n-    fn assemble_candidates_for_unsizing(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) {\n-        // We currently never consider higher-ranked obligations e.g.\n-        // `for<'a> &'a T: Unsize<Trait+'a>` to be implemented. This is not\n-        // because they are a priori invalid, and we could potentially add support\n-        // for them later, it's just that there isn't really a strong need for it.\n-        // A `T: Unsize<U>` obligation is always used as part of a `T: CoerceUnsize<U>`\n-        // impl, and those are generally applied to concrete types.\n-        //\n-        // That said, one might try to write a fn with a where clause like\n-        //     for<'a> Foo<'a, T>: Unsize<Foo<'a, Trait>>\n-        // where the `'a` is kind of orthogonal to the relevant part of the `Unsize`.\n-        // Still, you'd be more likely to write that where clause as\n-        //     T: Trait\n-        // so it seems ok if we (conservatively) fail to accept that `Unsize`\n-        // obligation above. Should be possible to extend this in the future.\n-        let source = match obligation.self_ty().no_bound_vars() {\n-            Some(t) => t,\n-            None => {\n-                // Don't add any candidates if there are bound regions.\n-                return;\n-            }\n-        };\n-        let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n-\n-        debug!(\"assemble_candidates_for_unsizing(source={:?}, target={:?})\", source, target);\n-\n-        let may_apply = match (&source.kind, &target.kind) {\n-            // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n-            (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n-                // Upcasts permit two things:\n-                //\n-                // 1. Dropping auto traits, e.g., `Foo + Send` to `Foo`\n-                // 2. Tightening the region bound, e.g., `Foo + 'a` to `Foo + 'b` if `'a: 'b`\n-                //\n-                // Note that neither of these changes requires any\n-                // change at runtime. Eventually this will be\n-                // generalized.\n-                //\n-                // We always upcast when we can because of reason\n-                // #2 (region bounds).\n-                data_a.principal_def_id() == data_b.principal_def_id()\n-                    && data_b\n-                        .auto_traits()\n-                        // All of a's auto traits need to be in b's auto traits.\n-                        .all(|b| data_a.auto_traits().any(|a| a == b))\n-            }\n-\n-            // `T` -> `Trait`\n-            (_, &ty::Dynamic(..)) => true,\n-\n-            // Ambiguous handling is below `T` -> `Trait`, because inference\n-            // variables can still implement `Unsize<Trait>` and nested\n-            // obligations will have the final say (likely deferred).\n-            (&ty::Infer(ty::TyVar(_)), _) | (_, &ty::Infer(ty::TyVar(_))) => {\n-                debug!(\"assemble_candidates_for_unsizing: ambiguous\");\n-                candidates.ambiguous = true;\n-                false\n-            }\n-\n-            // `[T; n]` -> `[T]`\n-            (&ty::Array(..), &ty::Slice(_)) => true,\n-\n-            // `Struct<T>` -> `Struct<U>`\n-            (&ty::Adt(def_id_a, _), &ty::Adt(def_id_b, _)) if def_id_a.is_struct() => {\n-                def_id_a == def_id_b\n-            }\n-\n-            // `(.., T)` -> `(.., U)`\n-            (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => tys_a.len() == tys_b.len(),\n-\n-            _ => false,\n-        };\n-\n-        if may_apply {\n-            candidates.vec.push(BuiltinUnsizeCandidate);\n-        }\n-    }\n-\n-    fn assemble_candidates_for_trait_alias(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n-        // Okay to skip binder here because the tests we do below do not involve bound regions.\n-        let self_ty = *obligation.self_ty().skip_binder();\n-        debug!(\"assemble_candidates_for_trait_alias(self_ty={:?})\", self_ty);\n-\n-        let def_id = obligation.predicate.def_id();\n-\n-        if self.tcx().is_trait_alias(def_id) {\n-            candidates.vec.push(TraitAliasCandidate(def_id));\n-        }\n-\n-        Ok(())\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // WINNOW\n     //\n@@ -2128,34 +1551,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    // BUILTIN BOUNDS\n-    //\n-    // These cover the traits that are built-in to the language\n-    // itself: `Copy`, `Clone` and `Sized`.\n-\n-    fn assemble_builtin_bound_candidates(\n-        &mut self,\n-        conditions: BuiltinImplConditions<'tcx>,\n-        candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n-        match conditions {\n-            BuiltinImplConditions::Where(nested) => {\n-                debug!(\"builtin_bound: nested={:?}\", nested);\n-                candidates\n-                    .vec\n-                    .push(BuiltinCandidate { has_nested: !nested.skip_binder().is_empty() });\n-            }\n-            BuiltinImplConditions::None => {}\n-            BuiltinImplConditions::Ambiguous => {\n-                debug!(\"assemble_builtin_bound_candidates: ambiguous builtin\");\n-                candidates.ambiguous = true;\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n     fn sized_conditions(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,"}]}