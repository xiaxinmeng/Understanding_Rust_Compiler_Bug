{"sha": "a53a22eab94f31df31cb936755c9c47784771759", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1M2EyMmVhYjk0ZjMxZGYzMWNiOTM2NzU1YzljNDc3ODQ3NzE3NTk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-05T11:24:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-01T12:40:42Z"}, "message": "Implement the new region hierarchy rules, in which regions from distinct\nhierarchies are judged based on the lexical relationship of their\nrespective fn bodies.", "tree": {"sha": "a8581e982b2d1cba8603e034e3a045c1d97b6dfa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8581e982b2d1cba8603e034e3a045c1d97b6dfa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a53a22eab94f31df31cb936755c9c47784771759", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a53a22eab94f31df31cb936755c9c47784771759", "html_url": "https://github.com/rust-lang/rust/commit/a53a22eab94f31df31cb936755c9c47784771759", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a53a22eab94f31df31cb936755c9c47784771759/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc959fdb28c0b1456e9db431f68570a552a8ea50", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc959fdb28c0b1456e9db431f68570a552a8ea50", "html_url": "https://github.com/rust-lang/rust/commit/bc959fdb28c0b1456e9db431f68570a552a8ea50"}], "stats": {"total": 250, "additions": 110, "deletions": 140}, "files": [{"sha": "6e9b413f2579e542a0ba9b1ed2c71633b18f728a", "filename": "src/librustc/middle/infer/region_inference/README.md", "status": "modified", "additions": 55, "deletions": 108, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/a53a22eab94f31df31cb936755c9c47784771759/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a53a22eab94f31df31cb936755c9c47784771759/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2FREADME.md?ref=a53a22eab94f31df31cb936755c9c47784771759", "patch": "@@ -249,114 +249,61 @@ there is a reference created whose lifetime does not enclose\n the borrow expression, we must issue sufficient restrictions to ensure\n that the pointee remains valid.\n \n-## Adding closures\n-\n-The other significant complication to the region hierarchy is\n-closures. I will describe here how closures should work, though some\n-of the work to implement this model is ongoing at the time of this\n-writing.\n-\n-The body of closures are type-checked along with the function that\n-creates them. However, unlike other expressions that appear within the\n-function body, it is not entirely obvious when a closure body executes\n-with respect to the other expressions. This is because the closure\n-body will execute whenever the closure is called; however, we can\n-never know precisely when the closure will be called, especially\n-without some sort of alias analysis.\n-\n-However, we can place some sort of limits on when the closure\n-executes.  In particular, the type of every closure `fn:'r K` includes\n-a region bound `'r`. This bound indicates the maximum lifetime of that\n-closure; once we exit that region, the closure cannot be called\n-anymore. Therefore, we say that the lifetime of the closure body is a\n-sublifetime of the closure bound, but the closure body itself is unordered\n-with respect to other parts of the code.\n-\n-For example, consider the following fragment of code:\n-\n-    'a: {\n-         let closure: fn:'a() = || 'b: {\n-             'c: ...\n-         };\n-         'd: ...\n-    }\n-\n-Here we have four lifetimes, `'a`, `'b`, `'c`, and `'d`. The closure\n-`closure` is bounded by the lifetime `'a`. The lifetime `'b` is the\n-lifetime of the closure body, and `'c` is some statement within the\n-closure body. Finally, `'d` is a statement within the outer block that\n-created the closure.\n-\n-We can say that the closure body `'b` is a sublifetime of `'a` due to\n-the closure bound. By the usual lexical scoping conventions, the\n-statement `'c` is clearly a sublifetime of `'b`, and `'d` is a\n-sublifetime of `'d`. However, there is no ordering between `'c` and\n-`'d` per se (this kind of ordering between statements is actually only\n-an issue for dataflow; passes like the borrow checker must assume that\n-closures could execute at any time from the moment they are created\n-until they go out of scope).\n-\n-### Complications due to closure bound inference\n-\n-There is only one problem with the above model: in general, we do not\n-actually *know* the closure bounds during region inference! In fact,\n-closure bounds are almost always region variables! This is very tricky\n-because the inference system implicitly assumes that we can do things\n-like compute the LUB of two scoped lifetimes without needing to know\n-the values of any variables.\n-\n-Here is an example to illustrate the problem:\n-\n-    fn identify<T>(x: T) -> T { x }\n-\n-    fn foo() { // 'foo is the function body\n-      'a: {\n-           let closure = identity(|| 'b: {\n-               'c: ...\n-           });\n-           'd: closure();\n-      }\n-      'e: ...;\n-    }\n-\n-In this example, the closure bound is not explicit. At compile time,\n-we will create a region variable (let's call it `V0`) to represent the\n-closure bound.\n-\n-The primary difficulty arises during the constraint propagation phase.\n-Imagine there is some variable with incoming edges from `'c` and `'d`.\n-This means that the value of the variable must be `LUB('c,\n-'d)`. However, without knowing what the closure bound `V0` is, we\n-can't compute the LUB of `'c` and `'d`! Any we don't know the closure\n-bound until inference is done.\n-\n-The solution is to rely on the fixed point nature of inference.\n-Basically, when we must compute `LUB('c, 'd)`, we just use the current\n-value for `V0` as the closure's bound. If `V0`'s binding should\n-change, then we will do another round of inference, and the result of\n-`LUB('c, 'd)` will change.\n-\n-One minor implication of this is that the graph does not in fact track\n-the full set of dependencies between edges. We cannot easily know\n-whether the result of a LUB computation will change, since there may\n-be indirect dependencies on other variables that are not reflected on\n-the graph. Therefore, we must *always* iterate over all edges when\n-doing the fixed point calculation, not just those adjacent to nodes\n-whose values have changed.\n-\n-Were it not for this requirement, we could in fact avoid fixed-point\n-iteration altogether. In that universe, we could instead first\n-identify and remove strongly connected components (SCC) in the graph.\n-Note that such components must consist solely of region variables; all\n-of these variables can effectively be unified into a single variable.\n-Once SCCs are removed, we are left with a DAG.  At this point, we\n-could walk the DAG in topological order once to compute the expanding\n-nodes, and again in reverse topological order to compute the\n-contracting nodes. However, as I said, this does not work given the\n-current treatment of closure bounds, but perhaps in the future we can\n-address this problem somehow and make region inference somewhat more\n-efficient. Note that this is solely a matter of performance, not\n-expressiveness.\n+## Modeling closures\n+\n+Integrating closures properly into the model is a bit of\n+work-in-progress. In an ideal world, we would model closures as\n+closely as possible after their desugared equivalents. That is, a\n+closure type would be modeled as a struct, and the region hierarchy of\n+different closure bodies would be completely distinct from all other\n+fns. We are generally moving in that direction but there are\n+complications in terms of the implementation.\n+\n+In practice what we currently do is somewhat different. The basis for\n+the current approach is the observation that the only time that\n+regions from distinct fn bodies interact with one another is through\n+an upvar or the type of a fn parameter (since closures live in the fn\n+body namespace, they can in fact have fn parameters whose types\n+include regions from the surrounding fn body). For these cases, there\n+are separate mechanisms which ensure that the regions that appear in\n+upvars/parameters outlive the dynamic extent of each call to the\n+closure:\n+\n+1. Types must outlive the region of any expression where they are used.\n+   For a closure type `C` to outlive a region `'r`, that implies that the\n+   types of all its upvars must outlive `'r`.\n+2. Parameters must outlive the region of any fn that they are passed to.\n+\n+Therefore, we can -- sort of -- assume that when we are asked to\n+compare a region `'a` from a closure with a region `'b` from the fn\n+that encloses it, in fact `'b` is the larger region. And that is\n+precisely what we do: when building the region hierarchy, each region\n+lives in its own distinct subtree, but if we are asked to compute the\n+`LUB(r1, r2)` of two regions, and those regions are in disjoint\n+subtrees, we compare the lexical nesting of the two regions.\n+\n+*Ideas for improving the situation:* The correct argument here is\n+subtle and a bit hand-wavy. The ideal, as stated earlier, would be to\n+model things in such a way that it corresponds more closely to the\n+desugared code. The best approach for doing this is a bit unclear: it\n+may in fact be possible to *actually* desugar before we start, but I\n+don't think so. The main option that I've been thinking through is\n+imposing a \"view shift\" as we enter the fn body, so that regions\n+appearing in the types of fn parameters and upvars are translated from\n+being regions in the outer fn into free region parameters, just as\n+they would be if we applied the desugaring. The challenge here is that\n+type inference may not have fully run, so the types may not be fully\n+known: we could probably do this translation lazilly, as type\n+variables are instantiated. We would also have to apply a kind of\n+inverse translation to the return value. This would be a good idea\n+anyway, as right now it is possible for free regions instantiated\n+within the closure to leak into the parent: this currently leads to\n+type errors, since those regions cannot outlive any expressions within\n+the parent hierarchy. Much like the current handling of closures,\n+there are no known cases where this leads to a type-checking accepting\n+incorrect code (though it sometimes rejects what might be considered\n+correct code; see rust-lang/rust#22557), but it still doesn't feel\n+like the right approach.\n \n ### Skolemization\n "}, {"sha": "11627c24f5406ec7949c84d908fdd6a223642e7d", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 54, "deletions": 32, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a53a22eab94f31df31cb936755c9c47784771759/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a53a22eab94f31df31cb936755c9c47784771759/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=a53a22eab94f31df31cb936755c9c47784771759", "patch": "@@ -262,7 +262,9 @@ pub struct RegionMaps {\n     /// fn, if any. Thus the map structures the fn bodies into a\n     /// hierarchy based on their lexical mapping. This is used to\n     /// handle the relationships between regions in a fn and in a\n-    /// closure defined by that fn.\n+    /// closure defined by that fn. See the \"Modeling closures\"\n+    /// section of the README in middle::infer::region_inference for\n+    /// more details.\n     fn_tree: RefCell<NodeMap<ast::NodeId>>,\n }\n \n@@ -337,7 +339,9 @@ pub struct Context {\n     /// the root of the current region tree. This is typically the id\n     /// of the innermost fn body. Each fn forms its own disjoint tree\n     /// in the region hierarchy. These fn bodies are themselves\n-    /// arranged into a tree.\n+    /// arranged into a tree. See the \"Modeling closures\" section of\n+    /// the README in middle::infer::region_inference for more\n+    /// details.\n     root_id: Option<ast::NodeId>,\n \n     /// the scope that contains any new variables declared\n@@ -411,7 +415,18 @@ impl RegionMaps {\n         assert!(previous.is_none());\n     }\n \n-    fn record_encl_scope(&self, sub: CodeExtent, sup: CodeExtent) {\n+    fn fn_is_enclosed_by(&self, mut sub_fn: ast::NodeId, sup_fn: ast::NodeId) -> bool {\n+        let fn_tree = self.fn_tree.borrow();\n+        loop {\n+            if sub_fn == sup_fn { return true; }\n+            match fn_tree.get(&sub_fn) {\n+                Some(&s) => { sub_fn = s; }\n+                None => { return false; }\n+            }\n+        }\n+    }\n+\n+    pub fn record_encl_scope(&self, sub: CodeExtent, sup: CodeExtent) {\n         debug!(\"record_encl_scope(sub={:?}, sup={:?})\", sub, sup);\n         assert!(sub != sup);\n         self.scope_map.borrow_mut().insert(sub, sup);\n@@ -600,7 +615,7 @@ impl RegionMaps {\n         let mut a_index = a_ancestors.len() - 1;\n         let mut b_index = b_ancestors.len() - 1;\n \n-        // Here, ~[ab]_ancestors is a vector going from narrow to broad.\n+        // Here, [ab]_ancestors is a vector going from narrow to broad.\n         // The end of each vector will be the item where the scope is\n         // defined; if there are any common ancestors, then the tails of\n         // the vector will be the same.  So basically we want to walk\n@@ -609,7 +624,32 @@ impl RegionMaps {\n         // then the corresponding scope is a superscope of the other.\n \n         if a_ancestors[a_index] != b_ancestors[b_index] {\n-            return None;\n+            // In this case, the two regions belong to completely\n+            // different functions.  Compare those fn for lexical\n+            // nesting. The reasoning behind this is subtle.  See the\n+            // \"Modeling closures\" section of the README in\n+            // middle::infer::region_inference for more details.\n+            let a_root_scope = a_ancestors[a_index];\n+            let b_root_scope = a_ancestors[a_index];\n+            return match (a_root_scope, b_root_scope) {\n+                (CodeExtent::DestructionScope(a_root_id),\n+                 CodeExtent::DestructionScope(b_root_id)) => {\n+                    if self.fn_is_enclosed_by(a_root_id, b_root_id) {\n+                        // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n+                        Some(scope_b)\n+                    } else if self.fn_is_enclosed_by(b_root_id, a_root_id) {\n+                        // `b` is enclosed by `a`, hence `a` is the ancestor of everything in `b`\n+                        Some(scope_a)\n+                    } else {\n+                        // neither fn encloses the other\n+                        None\n+                    }\n+                }\n+                _ => {\n+                    // root ids are always Misc right now\n+                    unreachable!()\n+                }\n+            };\n         }\n \n         loop {\n@@ -675,6 +715,7 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n     let prev_cx = visitor.cx;\n \n     let blk_scope = CodeExtent::Misc(blk.id);\n+\n     // If block was previously marked as a terminating scope during\n     // the recursive visit of its parent node in the AST, then we need\n     // to account for the destruction scope representing the extent of\n@@ -1144,7 +1185,7 @@ fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &ast::Item) {\n }\n \n fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n-              fk: FnKind,\n+              _: FnKind,\n               decl: &ast::FnDecl,\n               body: &ast::Block,\n               sp: Span,\n@@ -1180,32 +1221,13 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n     };\n     visit::walk_fn_decl(visitor, decl);\n \n-    // The body of the fn itself is either a root scope (top-level fn)\n-    // or it continues with the inherited scope (closures).\n-    match fk {\n-        visit::FkItemFn(..) | visit::FkMethod(..) => {\n-            visitor.cx = Context {\n-                root_id: Some(body.id),\n-                parent: InnermostEnclosingExpr::None,\n-                var_parent: InnermostDeclaringBlock::None\n-            };\n-            visitor.visit_block(body);\n-        }\n-        visit::FkFnBlock(..) => {\n-            // FIXME(#3696) -- at present we are place the closure body\n-            // within the region hierarchy exactly where it appears lexically.\n-            // This is wrong because the closure may live longer\n-            // than the enclosing expression. We should probably fix this,\n-            // but the correct fix is a bit subtle, and I am also not sure\n-            // that the present approach is unsound -- it may not permit\n-            // any illegal programs. See issue for more details.\n-            visitor.cx = Context {\n-                root_id: Some(body.id),\n-                ..outer_cx\n-            };\n-            visitor.visit_block(body);\n-        }\n-    }\n+    // The body of the every fn is a root scope.\n+    visitor.cx = Context {\n+        root_id: Some(body.id),\n+        parent: InnermostEnclosingExpr::None,\n+        var_parent: InnermostDeclaringBlock::None\n+    };\n+    visitor.visit_block(body);\n \n     // Restore context we had at the start.\n     visitor.cx = outer_cx;"}, {"sha": "37ed134dbcbf647b5e265175d6b98b602f1102d9", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a53a22eab94f31df31cb936755c9c47784771759/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a53a22eab94f31df31cb936755c9c47784771759/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=a53a22eab94f31df31cb936755c9c47784771759", "patch": "@@ -588,6 +588,7 @@ fn lub_free_free() {\n fn lub_returning_scope() {\n     test_env(EMPTY_SOURCE_STR,\n              errors(&[\"cannot infer an appropriate lifetime\"]), |env| {\n+                 env.create_simple_region_hierarchy();\n                  let t_rptr_scope10 = env.t_rptr_scope(10);\n                  let t_rptr_scope11 = env.t_rptr_scope(11);\n "}]}