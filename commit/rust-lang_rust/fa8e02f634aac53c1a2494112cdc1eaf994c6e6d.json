{"sha": "fa8e02f634aac53c1a2494112cdc1eaf994c6e6d", "node_id": "C_kwDOAAsO6NoAKGZhOGUwMmY2MzRhYWM1M2MxYTI0OTQxMTJjZGMxZWFmOTk0YzZlNmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-12T13:05:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-12T13:05:11Z"}, "message": "Auto merge of #2827 - mojave2:memcpy, r=oli-obk\n\nadd `memcpy` and `strcpy` shims", "tree": {"sha": "2bf914678a4215370a28b7ee9b33b60f70876a26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bf914678a4215370a28b7ee9b33b60f70876a26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa8e02f634aac53c1a2494112cdc1eaf994c6e6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa8e02f634aac53c1a2494112cdc1eaf994c6e6d", "html_url": "https://github.com/rust-lang/rust/commit/fa8e02f634aac53c1a2494112cdc1eaf994c6e6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa8e02f634aac53c1a2494112cdc1eaf994c6e6d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dedac2d5e2ec863b65cf4adb34b7804becf140f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/dedac2d5e2ec863b65cf4adb34b7804becf140f8", "html_url": "https://github.com/rust-lang/rust/commit/dedac2d5e2ec863b65cf4adb34b7804becf140f8"}, {"sha": "7e37783f11c1b796b095ee9327e6caa1ee1a9596", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e37783f11c1b796b095ee9327e6caa1ee1a9596", "html_url": "https://github.com/rust-lang/rust/commit/7e37783f11c1b796b095ee9327e6caa1ee1a9596"}], "stats": {"total": 118, "additions": 118, "deletions": 0}, "files": [{"sha": "8cdd857992084b65282f84aa873f46b1b63d9ee7", "filename": "src/tools/miri/src/shims/foreign_items.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e02f634aac53c1a2494112cdc1eaf994c6e6d/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e02f634aac53c1a2494112cdc1eaf994c6e6d/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs?ref=fa8e02f634aac53c1a2494112cdc1eaf994c6e6d", "patch": "@@ -744,6 +744,44 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     dest,\n                 )?;\n             }\n+            \"memcpy\" => {\n+                let [ptr_dest, ptr_src, n] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let ptr_dest = this.read_pointer(ptr_dest)?;\n+                let ptr_src = this.read_pointer(ptr_src)?;\n+                let n = this.read_target_usize(n)?;\n+                this.mem_copy(\n+                    ptr_src,\n+                    Align::ONE,\n+                    ptr_dest,\n+                    Align::ONE,\n+                    Size::from_bytes(n),\n+                    true,\n+                )?;\n+                this.write_pointer(ptr_dest, dest)?;\n+            }\n+            \"strcpy\" => {\n+                let [ptr_dest, ptr_src] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let ptr_dest = this.read_pointer(ptr_dest)?;\n+                let ptr_src = this.read_pointer(ptr_src)?;\n+\n+                // We use `read_c_str` to determine the amount of data to copy,\n+                // and then use `mem_copy` for the actual copy. This means\n+                // pointer provenance is preserved by this implementation of `strcpy`.\n+                // That is probably overly cautious, but there also is no fundamental\n+                // reason to have `strcpy` destroy pointer provenance.\n+                let n = this.read_c_str(ptr_src)?.len().checked_add(1).unwrap();\n+                this.mem_copy(\n+                    ptr_src,\n+                    Align::ONE,\n+                    ptr_dest,\n+                    Align::ONE,\n+                    Size::from_bytes(n),\n+                    true,\n+                )?;\n+                this.write_pointer(ptr_dest, dest)?;\n+            }\n \n             // math functions (note that there are also intrinsics for some other functions)\n             #[rustfmt::skip]"}, {"sha": "8be9cd983a7b857805920de49cb99dadd451868a", "filename": "src/tools/miri/tests/pass-dep/shims/libc-misc.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e02f634aac53c1a2494112cdc1eaf994c6e6d/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e02f634aac53c1a2494112cdc1eaf994c6e6d/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs?ref=fa8e02f634aac53c1a2494112cdc1eaf994c6e6d", "patch": "@@ -302,6 +302,83 @@ fn test_posix_mkstemp() {\n     }\n }\n \n+fn test_memcpy() {\n+    unsafe {\n+        let src = [1i8, 2, 3];\n+        let dest = libc::calloc(3, 1);\n+        libc::memcpy(dest, src.as_ptr() as *const libc::c_void, 3);\n+        let slc = std::slice::from_raw_parts(dest as *const i8, 3);\n+        assert_eq!(*slc, [1i8, 2, 3]);\n+        libc::free(dest);\n+    }\n+\n+    unsafe {\n+        let src = [1i8, 2, 3];\n+        let dest = libc::calloc(4, 1);\n+        libc::memcpy(dest, src.as_ptr() as *const libc::c_void, 3);\n+        let slc = std::slice::from_raw_parts(dest as *const i8, 4);\n+        assert_eq!(*slc, [1i8, 2, 3, 0]);\n+        libc::free(dest);\n+    }\n+\n+    unsafe {\n+        let src = 123_i32;\n+        let mut dest = 0_i32;\n+        libc::memcpy(\n+            &mut dest as *mut i32 as *mut libc::c_void,\n+            &src as *const i32 as *const libc::c_void,\n+            std::mem::size_of::<i32>(),\n+        );\n+        assert_eq!(dest, src);\n+    }\n+\n+    unsafe {\n+        let src = Some(123);\n+        let mut dest: Option<i32> = None;\n+        libc::memcpy(\n+            &mut dest as *mut Option<i32> as *mut libc::c_void,\n+            &src as *const Option<i32> as *const libc::c_void,\n+            std::mem::size_of::<Option<i32>>(),\n+        );\n+        assert_eq!(dest, src);\n+    }\n+\n+    unsafe {\n+        let src = &123;\n+        let mut dest = &42;\n+        libc::memcpy(\n+            &mut dest as *mut &'static i32 as *mut libc::c_void,\n+            &src as *const &'static i32 as *const libc::c_void,\n+            std::mem::size_of::<&'static i32>(),\n+        );\n+        assert_eq!(*dest, 123);\n+    }\n+}\n+\n+fn test_strcpy() {\n+    use std::ffi::{CStr, CString};\n+\n+    // case: src_size equals dest_size\n+    unsafe {\n+        let src = CString::new(\"rust\").unwrap();\n+        let size = src.as_bytes_with_nul().len();\n+        let dest = libc::malloc(size);\n+        libc::strcpy(dest as *mut libc::c_char, src.as_ptr());\n+        assert_eq!(CStr::from_ptr(dest as *const libc::c_char), src.as_ref());\n+        libc::free(dest);\n+    }\n+\n+    // case: src_size is less than dest_size\n+    unsafe {\n+        let src = CString::new(\"rust\").unwrap();\n+        let size = src.as_bytes_with_nul().len();\n+        let dest = libc::malloc(size + 1);\n+        libc::strcpy(dest as *mut libc::c_char, src.as_ptr());\n+        assert_eq!(CStr::from_ptr(dest as *const libc::c_char), src.as_ref());\n+        libc::free(dest);\n+    }\n+}\n+\n #[cfg(target_os = \"linux\")]\n fn test_sigrt() {\n     let min = libc::SIGRTMIN();\n@@ -333,6 +410,9 @@ fn main() {\n     test_isatty();\n     test_clocks();\n \n+    test_memcpy();\n+    test_strcpy();\n+\n     #[cfg(target_os = \"linux\")]\n     {\n         test_posix_fadvise();"}]}