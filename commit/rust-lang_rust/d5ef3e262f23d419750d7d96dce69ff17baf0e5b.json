{"sha": "d5ef3e262f23d419750d7d96dce69ff17baf0e5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1ZWYzZTI2MmYyM2Q0MTk3NTBkN2Q5NmRjZTY5ZmYxN2JhZjBlNWI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-01T13:51:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-07T10:28:01Z"}, "message": "replace `InferCtxt::fn_sig` with `closure_sig`", "tree": {"sha": "9366d6c367ab16e7ed5dea4333d70f286ea8f8ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9366d6c367ab16e7ed5dea4333d70f286ea8f8ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5ef3e262f23d419750d7d96dce69ff17baf0e5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5ef3e262f23d419750d7d96dce69ff17baf0e5b", "html_url": "https://github.com/rust-lang/rust/commit/d5ef3e262f23d419750d7d96dce69ff17baf0e5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5ef3e262f23d419750d7d96dce69ff17baf0e5b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05441abd2bc1f0658aafa8b0161146fae34f7206", "url": "https://api.github.com/repos/rust-lang/rust/commits/05441abd2bc1f0658aafa8b0161146fae34f7206", "html_url": "https://github.com/rust-lang/rust/commit/05441abd2bc1f0658aafa8b0161146fae34f7206"}], "stats": {"total": 84, "additions": 38, "deletions": 46}, "files": [{"sha": "f5595d07340bb88024ce595ba64038fe81274b28", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 12, "deletions": 32, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d5ef3e262f23d419750d7d96dce69ff17baf0e5b/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ef3e262f23d419750d7d96dce69ff17baf0e5b/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=d5ef3e262f23d419750d7d96dce69ff17baf0e5b", "patch": "@@ -1480,38 +1480,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         closure_kind_ty.to_opt_closure_kind()\n     }\n \n-    /// Obtain the signature of a function or closure.\n-    /// For closures, unlike `tcx.fn_sig(def_id)`, this method will\n-    /// work during the type-checking of the enclosing function and\n-    /// return the closure signature in its partially inferred state.\n-    pub fn fn_sig(&self, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n-        // Do we have an in-progress set of tables we are inferring?\n-        if let Some(tables) = self.in_progress_tables {\n-            // Is this a local item?\n-            if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                // Is it a local *closure*?\n-                if self.tcx.is_closure(def_id) {\n-                    let hir_id = self.tcx.hir.node_to_hir_id(id);\n-                    // Is this local closure contained within the tables we are inferring?\n-                    if tables.borrow().local_id_root == Some(DefId::local(hir_id.owner)) {\n-                        // if so, extract signature from there.\n-                        let closure_ty = tables.borrow().node_id_to_type(hir_id);\n-                        let (closure_def_id, closure_substs) = match closure_ty.sty {\n-                            ty::TyClosure(closure_def_id, closure_substs) =>\n-                                (closure_def_id, closure_substs),\n-                            _ =>\n-                                bug!(\"closure with non-closure type: {:?}\", closure_ty),\n-                        };\n-                        assert_eq!(def_id, closure_def_id);\n-                        let closure_sig_ty = closure_substs.closure_sig_ty(def_id, self.tcx);\n-                        let closure_sig_ty = self.shallow_resolve(&closure_sig_ty);\n-                        return closure_sig_ty.fn_sig(self.tcx);\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.tcx.fn_sig(def_id)\n+    /// Obtain the signature of a closure.  For closures, unlike\n+    /// `tcx.fn_sig(def_id)`, this method will work during the\n+    /// type-checking of the enclosing function and return the closure\n+    /// signature in its partially inferred state.\n+    pub fn closure_sig(\n+        &self,\n+        def_id: DefId,\n+        substs: ty::ClosureSubsts<'tcx>\n+    ) -> ty::PolyFnSig<'tcx> {\n+        let closure_sig_ty = substs.closure_sig_ty(def_id, self.tcx);\n+        let closure_sig_ty = self.shallow_resolve(&closure_sig_ty);\n+        closure_sig_ty.fn_sig(self.tcx)\n     }\n \n     /// Normalizes associated types in `value`, potentially returning"}, {"sha": "3342d13dd6e5fa230b691ef6def7d6eebf13ccb9", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d5ef3e262f23d419750d7d96dce69ff17baf0e5b/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ef3e262f23d419750d7d96dce69ff17baf0e5b/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=d5ef3e262f23d419750d7d96dce69ff17baf0e5b", "patch": "@@ -1339,26 +1339,27 @@ fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n     vtable: VtableClosureData<'tcx, PredicateObligation<'tcx>>)\n     -> Progress<'tcx>\n {\n-    let closure_typer = selcx.closure_typer();\n-    let closure_type = closure_typer.fn_sig(vtable.closure_def_id)\n-        .subst(selcx.tcx(), vtable.substs.substs);\n+    let tcx = selcx.tcx();\n+    let infcx = selcx.infcx();\n+    let closure_sig_ty = vtable.substs.closure_sig_ty(vtable.closure_def_id, tcx);\n+    let closure_sig = infcx.shallow_resolve(&closure_sig_ty).fn_sig(tcx);\n     let Normalized {\n-        value: closure_type,\n+        value: closure_sig,\n         obligations\n     } = normalize_with_depth(selcx,\n                              obligation.param_env,\n                              obligation.cause.clone(),\n                              obligation.recursion_depth+1,\n-                             &closure_type);\n+                             &closure_sig);\n \n-    debug!(\"confirm_closure_candidate: obligation={:?},closure_type={:?},obligations={:?}\",\n+    debug!(\"confirm_closure_candidate: obligation={:?},closure_sig={:?},obligations={:?}\",\n            obligation,\n-           closure_type,\n+           closure_sig,\n            obligations);\n \n     confirm_callable_candidate(selcx,\n                                obligation,\n-                               closure_type,\n+                               closure_sig,\n                                util::TupleArgumentsFlag::No)\n         .with_addl_obligations(vtable.nested)\n         .with_addl_obligations(obligations)"}, {"sha": "e70de0e566e41c3daa75ad43c6aa911147fac00e", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d5ef3e262f23d419750d7d96dce69ff17baf0e5b/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ef3e262f23d419750d7d96dce69ff17baf0e5b/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=d5ef3e262f23d419750d7d96dce69ff17baf0e5b", "patch": "@@ -3183,8 +3183,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                       substs: ty::ClosureSubsts<'tcx>)\n                                       -> ty::PolyTraitRef<'tcx>\n     {\n-        let closure_type = self.infcx.fn_sig(closure_def_id)\n-            .subst(self.tcx(), substs.substs);\n+        let closure_type = self.infcx.closure_sig(closure_def_id, substs);\n         let ty::Binder((trait_ref, _)) =\n             self.tcx().closure_trait_ref_and_return_type(obligation.predicate.def_id(),\n                                                          obligation.predicate.0.self_ty(), // (1)"}, {"sha": "1755382516af4f04bed18f78df3bd23632f5b875", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5ef3e262f23d419750d7d96dce69ff17baf0e5b/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ef3e262f23d419750d7d96dce69ff17baf0e5b/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d5ef3e262f23d419750d7d96dce69ff17baf0e5b", "patch": "@@ -356,13 +356,17 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// Returns the closure kind for this closure; only usable outside\n     /// of an inference context, because in that context we know that\n     /// there are no type variables.\n+    ///\n+    /// If you have an inference context, use `infcx.closure_kind()`.\n     pub fn closure_kind(self, def_id: DefId, tcx: TyCtxt<'_, 'tcx, 'tcx>) -> ty::ClosureKind {\n         self.split(def_id, tcx).closure_kind_ty.to_opt_closure_kind().unwrap()\n     }\n \n     /// Extracts the signature from the closure; only usable outside\n     /// of an inference context, because in that context we know that\n     /// there are no type variables.\n+    ///\n+    /// If you have an inference context, use `infcx.closure_sig()`.\n     pub fn closure_sig(self, def_id: DefId, tcx: TyCtxt<'_, 'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n         match self.closure_sig_ty(def_id, tcx).sty {\n             ty::TyFnPtr(sig) => sig,"}, {"sha": "b614e280c55254e9c7df2d4cddc1092242b1d968", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d5ef3e262f23d419750d7d96dce69ff17baf0e5b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ef3e262f23d419750d7d96dce69ff17baf0e5b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=d5ef3e262f23d419750d7d96dce69ff17baf0e5b", "patch": "@@ -381,7 +381,10 @@ const FR: NLLRegionVariableOrigin = NLLRegionVariableOrigin::FreeRegion;\n \n impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n     fn build(mut self) -> UniversalRegions<'tcx> {\n+        debug!(\"build(mir_def_id={:?})\", self.mir_def_id);\n+\n         let param_env = self.param_env;\n+        debug!(\"build: param_env={:?}\", param_env);\n \n         assert_eq!(FIRST_GLOBAL_INDEX, self.infcx.num_region_vars());\n \n@@ -393,8 +396,10 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n         let first_extern_index = self.infcx.num_region_vars();\n \n         let defining_ty = self.defining_ty();\n+        debug!(\"build: defining_ty={:?}\", defining_ty);\n \n         let indices = self.compute_indices(fr_static, defining_ty);\n+        debug!(\"build: indices={:?}\", indices);\n \n         let bound_inputs_and_output = self.compute_inputs_and_output(&indices, defining_ty);\n \n@@ -410,12 +415,14 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n \n         // Add the implied bounds from inputs and outputs.\n         for ty in inputs_and_output {\n+            debug!(\"build: input_or_output={:?}\", ty);\n             self.add_implied_bounds(&indices, ty);\n         }\n \n         // Finally, outlives is reflexive, and static outlives every\n         // other free region.\n         for fr in (FIRST_GLOBAL_INDEX..num_universals).map(RegionVid::new) {\n+            debug!(\"build: relating free region {:?} to itself and to 'static\", fr);\n             self.relations.relate_universal_regions(fr, fr);\n             self.relations.relate_universal_regions(fr_static, fr);\n         }\n@@ -562,6 +569,7 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n     ///\n     /// Assumes that `universal_regions` indices map is fully constructed.\n     fn add_implied_bounds(&mut self, indices: &UniversalRegionIndices<'tcx>, ty: Ty<'tcx>) {\n+        debug!(\"add_implied_bounds(ty={:?})\", ty);\n         let span = self.infcx.tcx.def_span(self.mir_def_id);\n         let bounds = self.infcx\n             .implied_outlives_bounds(self.param_env, self.mir_node_id, ty, span);\n@@ -576,6 +584,8 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n         I: IntoIterator<Item = OutlivesBound<'tcx>>,\n     {\n         for outlives_bound in outlives_bounds {\n+            debug!(\"add_outlives_bounds(bound={:?})\", outlives_bound);\n+\n             match outlives_bound {\n                 OutlivesBound::RegionSubRegion(r1, r2) => {\n                     // The bound says that `r1 <= r2`; we store `r2: r1`."}, {"sha": "df1694a601056b8e0c66414ef2753b9959599710", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d5ef3e262f23d419750d7d96dce69ff17baf0e5b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ef3e262f23d419750d7d96dce69ff17baf0e5b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=d5ef3e262f23d419750d7d96dce69ff17baf0e5b", "patch": "@@ -16,7 +16,6 @@ use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::{infer, traits};\n use rustc::ty::{self, TyCtxt, TypeFoldable, LvaluePreference, Ty};\n-use rustc::ty::subst::Subst;\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use syntax::abi;\n use syntax::symbol::Symbol;\n@@ -109,7 +108,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // haven't yet decided on whether the closure is fn vs\n                 // fnmut vs fnonce. If so, we have to defer further processing.\n                 if self.closure_kind(def_id, substs).is_none() {\n-                    let closure_ty = self.fn_sig(def_id).subst(self.tcx, substs.substs);\n+                    let closure_ty = self.closure_sig(def_id, substs);\n                     let fn_sig = self.replace_late_bound_regions_with_fresh_var(call_expr.span,\n                                                                    infer::FnCall,\n                                                                    &closure_ty)"}, {"sha": "dc5d3141d4ca29323a34412faf411d1bf6c3c758", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d5ef3e262f23d419750d7d96dce69ff17baf0e5b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ef3e262f23d419750d7d96dce69ff17baf0e5b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=d5ef3e262f23d419750d7d96dce69ff17baf0e5b", "patch": "@@ -74,7 +74,6 @@ use rustc::ty::{self, LvaluePreference, TypeAndMut,\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n use rustc::ty::relate::RelateResult;\n-use rustc::ty::subst::Subst;\n use errors::DiagnosticBuilder;\n use syntax::abi;\n use syntax::feature_gate;\n@@ -670,7 +669,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n                 // to\n                 //     `fn(arg0,arg1,...) -> _`\n-                let sig = self.fn_sig(def_id_a).subst(self.tcx, substs_a.substs);\n+                let sig = self.closure_sig(def_id_a, substs_a);\n                 let converted_sig = sig.map_bound(|s| {\n                     let params_iter = match s.inputs()[0].sty {\n                         ty::TyTuple(params, _) => {"}]}