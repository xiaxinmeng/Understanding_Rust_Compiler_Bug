{"sha": "f098a2b31bffafdbd513f32e8c45d62e709173ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwOThhMmIzMWJmZmFmZGJkNTEzZjMyZThjNDVkNjJlNzA5MTczZWE=", "commit": {"author": {"name": "Domantas Jadenkus", "email": "djadenkus@gmail.com", "date": "2021-02-15T21:25:33Z"}, "committer": {"name": "Domantas Jadenkus", "email": "djadenkus@gmail.com", "date": "2021-02-27T10:21:06Z"}, "message": "move into_ and as_ generation to a separate file", "tree": {"sha": "2e1a74150ba31966cac27fd761f8af22dc5c8dc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e1a74150ba31966cac27fd761f8af22dc5c8dc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f098a2b31bffafdbd513f32e8c45d62e709173ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f098a2b31bffafdbd513f32e8c45d62e709173ea", "html_url": "https://github.com/rust-lang/rust/commit/f098a2b31bffafdbd513f32e8c45d62e709173ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f098a2b31bffafdbd513f32e8c45d62e709173ea/comments", "author": {"login": "jDomantas", "id": 8329015, "node_id": "MDQ6VXNlcjgzMjkwMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8329015?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jDomantas", "html_url": "https://github.com/jDomantas", "followers_url": "https://api.github.com/users/jDomantas/followers", "following_url": "https://api.github.com/users/jDomantas/following{/other_user}", "gists_url": "https://api.github.com/users/jDomantas/gists{/gist_id}", "starred_url": "https://api.github.com/users/jDomantas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jDomantas/subscriptions", "organizations_url": "https://api.github.com/users/jDomantas/orgs", "repos_url": "https://api.github.com/users/jDomantas/repos", "events_url": "https://api.github.com/users/jDomantas/events{/privacy}", "received_events_url": "https://api.github.com/users/jDomantas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jDomantas", "id": 8329015, "node_id": "MDQ6VXNlcjgzMjkwMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8329015?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jDomantas", "html_url": "https://github.com/jDomantas", "followers_url": "https://api.github.com/users/jDomantas/followers", "following_url": "https://api.github.com/users/jDomantas/following{/other_user}", "gists_url": "https://api.github.com/users/jDomantas/gists{/gist_id}", "starred_url": "https://api.github.com/users/jDomantas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jDomantas/subscriptions", "organizations_url": "https://api.github.com/users/jDomantas/orgs", "repos_url": "https://api.github.com/users/jDomantas/repos", "events_url": "https://api.github.com/users/jDomantas/events{/privacy}", "received_events_url": "https://api.github.com/users/jDomantas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f25fef36a9deb5a22a7bb4a380df664245dcfa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f25fef36a9deb5a22a7bb4a380df664245dcfa9", "html_url": "https://github.com/rust-lang/rust/commit/6f25fef36a9deb5a22a7bb4a380df664245dcfa9"}], "stats": {"total": 742, "additions": 340, "deletions": 402}, "files": [{"sha": "7e181a4801e3184adf07b325d2c6252b77ef74b1", "filename": "crates/ide_assists/src/handlers/generate_enum_match_method.rs", "status": "modified", "additions": 7, "deletions": 399, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/f098a2b31bffafdbd513f32e8c45d62e709173ea/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_enum_match_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f098a2b31bffafdbd513f32e8c45d62e709173ea/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_enum_match_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_enum_match_method.rs?ref=f098a2b31bffafdbd513f32e8c45d62e709173ea", "patch": "@@ -1,11 +1,9 @@\n-use itertools::Itertools;\n use stdx::to_lower_snake_case;\n use syntax::ast::VisibilityOwner;\n use syntax::ast::{self, AstNode, NameOwner};\n \n use crate::{\n-    assist_context::AssistBuilder,\n-    utils::{find_impl_block_end, find_struct_impl, generate_impl_text},\n+    utils::{add_method_to_adt, find_struct_impl},\n     AssistContext, AssistId, AssistKind, Assists,\n };\n \n@@ -39,7 +37,11 @@ pub(crate) fn generate_enum_is_method(acc: &mut Assists, ctx: &AssistContext) ->\n     let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n     let variant_name = variant.name()?;\n     let parent_enum = ast::Adt::Enum(variant.parent_enum());\n-    let variant_kind = variant_kind(&variant);\n+    let pattern_suffix = match variant.kind() {\n+        ast::StructKind::Record(_) => \" { .. }\",\n+        ast::StructKind::Tuple(_) => \"(..)\",\n+        ast::StructKind::Unit => \"\",\n+    };\n \n     let enum_lowercase_name = to_lower_snake_case(&parent_enum.name()?.to_string());\n     let fn_name = format!(\"is_{}\", &to_lower_snake_case(variant_name.text()));\n@@ -59,250 +61,14 @@ pub(crate) fn generate_enum_is_method(acc: &mut Assists, ctx: &AssistContext) ->\n     {}fn {}(&self) -> bool {{\n         matches!(self, Self::{}{})\n     }}\",\n-                enum_lowercase_name,\n-                variant_name,\n-                vis,\n-                fn_name,\n-                variant_name,\n-                variant_kind.pattern_suffix(),\n+                enum_lowercase_name, variant_name, vis, fn_name, variant_name, pattern_suffix,\n             );\n \n             add_method_to_adt(builder, &parent_enum, impl_def, &method);\n         },\n     )\n }\n \n-// Assist: generate_enum_into_method\n-//\n-// Generate an `into_` method for an enum variant.\n-//\n-// ```\n-// enum Value {\n-//  Number(i32),\n-//  Text(String)$0,\n-// }\n-// ```\n-// ->\n-// ```\n-// enum Value {\n-//  Number(i32),\n-//  Text(String),\n-// }\n-//\n-// impl Value {\n-//     fn into_text(self) -> Option<String> {\n-//         if let Self::Text(v) = self {\n-//             Some(v)\n-//         } else {\n-//             None\n-//         }\n-//     }\n-// }\n-// ```\n-pub(crate) fn generate_enum_into_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n-    let variant_name = variant.name()?;\n-    let parent_enum = ast::Adt::Enum(variant.parent_enum());\n-    let variant_kind = variant_kind(&variant);\n-\n-    let fn_name = format!(\"into_{}\", &to_lower_snake_case(variant_name.text()));\n-\n-    // Return early if we've found an existing new fn\n-    let impl_def = find_struct_impl(&ctx, &parent_enum, &fn_name)?;\n-\n-    let field_type = variant_kind.single_field_type()?;\n-    let (pattern_suffix, bound_name) = variant_kind.binding_pattern()?;\n-\n-    let target = variant.syntax().text_range();\n-    acc.add(\n-        AssistId(\"generate_enum_into_method\", AssistKind::Generate),\n-        \"Generate an `into_` method for an enum variant\",\n-        target,\n-        |builder| {\n-            let vis = parent_enum.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n-            let method = format!(\n-                \"    {}fn {}(self) -> Option<{}> {{\n-        if let Self::{}{} = self {{\n-            Some({})\n-        }} else {{\n-            None\n-        }}\n-    }}\",\n-                vis,\n-                fn_name,\n-                field_type.syntax(),\n-                variant_name,\n-                pattern_suffix,\n-                bound_name,\n-            );\n-\n-            add_method_to_adt(builder, &parent_enum, impl_def, &method);\n-        },\n-    )\n-}\n-\n-// Assist: generate_enum_as_method\n-//\n-// Generate an `as_` method for an enum variant.\n-//\n-// ```\n-// enum Value {\n-//  Number(i32),\n-//  Text(String)$0,\n-// }\n-// ```\n-// ->\n-// ```\n-// enum Value {\n-//  Number(i32),\n-//  Text(String),\n-// }\n-//\n-// impl Value {\n-//     fn as_text(&self) -> Option<&String> {\n-//         if let Self::Text(v) = self {\n-//             Some(v)\n-//         } else {\n-//             None\n-//         }\n-//     }\n-// }\n-// ```\n-pub(crate) fn generate_enum_as_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n-    let variant_name = variant.name()?;\n-    let parent_enum = ast::Adt::Enum(variant.parent_enum());\n-    let variant_kind = variant_kind(&variant);\n-\n-    let fn_name = format!(\"as_{}\", &to_lower_snake_case(variant_name.text()));\n-\n-    // Return early if we've found an existing new fn\n-    let impl_def = find_struct_impl(&ctx, &parent_enum, &fn_name)?;\n-\n-    let field_type = variant_kind.single_field_type()?;\n-    let (pattern_suffix, bound_name) = variant_kind.binding_pattern()?;\n-\n-    let target = variant.syntax().text_range();\n-    acc.add(\n-        AssistId(\"generate_enum_as_method\", AssistKind::Generate),\n-        \"Generate an `as_` method for an enum variant\",\n-        target,\n-        |builder| {\n-            let vis = parent_enum.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n-            let method = format!(\n-                \"    {}fn {}(&self) -> Option<&{}> {{\n-        if let Self::{}{} = self {{\n-            Some({})\n-        }} else {{\n-            None\n-        }}\n-    }}\",\n-                vis,\n-                fn_name,\n-                field_type.syntax(),\n-                variant_name,\n-                pattern_suffix,\n-                bound_name,\n-            );\n-\n-            add_method_to_adt(builder, &parent_enum, impl_def, &method);\n-        },\n-    )\n-}\n-\n-fn add_method_to_adt(\n-    builder: &mut AssistBuilder,\n-    adt: &ast::Adt,\n-    impl_def: Option<ast::Impl>,\n-    method: &str,\n-) {\n-    let mut buf = String::with_capacity(method.len() + 2);\n-    if impl_def.is_some() {\n-        buf.push('\\n');\n-    }\n-    buf.push_str(method);\n-\n-    let start_offset = impl_def\n-        .and_then(|impl_def| find_impl_block_end(impl_def, &mut buf))\n-        .unwrap_or_else(|| {\n-            buf = generate_impl_text(&adt, &buf);\n-            adt.syntax().text_range().end()\n-        });\n-\n-    builder.insert(start_offset, buf);\n-}\n-\n-enum VariantKind {\n-    Unit,\n-    /// Tuple with a single field\n-    NewtypeTuple {\n-        ty: Option<ast::Type>,\n-    },\n-    /// Tuple with 0 or more than 2 fields\n-    Tuple,\n-    /// Record with a single field\n-    NewtypeRecord {\n-        field_name: Option<ast::Name>,\n-        field_type: Option<ast::Type>,\n-    },\n-    /// Record with 0 or more than 2 fields\n-    Record,\n-}\n-\n-impl VariantKind {\n-    fn pattern_suffix(&self) -> &'static str {\n-        match self {\n-            VariantKind::Unit => \"\",\n-            VariantKind::NewtypeTuple { .. } | VariantKind::Tuple => \"(..)\",\n-            VariantKind::NewtypeRecord { .. } | VariantKind::Record => \" { .. }\",\n-        }\n-    }\n-\n-    fn binding_pattern(&self) -> Option<(String, String)> {\n-        match self {\n-            VariantKind::Unit\n-            | VariantKind::Tuple\n-            | VariantKind::Record\n-            | VariantKind::NewtypeRecord { field_name: None, .. } => None,\n-            VariantKind::NewtypeTuple { .. } => Some((\"(v)\".to_owned(), \"v\".to_owned())),\n-            VariantKind::NewtypeRecord { field_name: Some(name), .. } => {\n-                Some((format!(\" {{ {} }}\", name.syntax()), name.syntax().to_string()))\n-            }\n-        }\n-    }\n-\n-    fn single_field_type(&self) -> Option<&ast::Type> {\n-        match self {\n-            VariantKind::Unit | VariantKind::Tuple | VariantKind::Record => None,\n-            VariantKind::NewtypeTuple { ty } => ty.as_ref(),\n-            VariantKind::NewtypeRecord { field_type, .. } => field_type.as_ref(),\n-        }\n-    }\n-}\n-\n-fn variant_kind(variant: &ast::Variant) -> VariantKind {\n-    match variant.kind() {\n-        ast::StructKind::Record(record) => {\n-            if let Some((single_field,)) = record.fields().collect_tuple() {\n-                let field_name = single_field.name();\n-                let field_type = single_field.ty();\n-                VariantKind::NewtypeRecord { field_name, field_type }\n-            } else {\n-                VariantKind::Record\n-            }\n-        }\n-        ast::StructKind::Tuple(tuple) => {\n-            if let Some((single_field,)) = tuple.fields().collect_tuple() {\n-                let ty = single_field.ty();\n-                VariantKind::NewtypeTuple { ty }\n-            } else {\n-                VariantKind::Tuple\n-            }\n-        }\n-        ast::StructKind::Unit => VariantKind::Unit,\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -478,164 +244,6 @@ impl Variant {\n     fn is_major(&self) -> bool {\n         matches!(self, Self::Major)\n     }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_generate_enum_into_tuple_variant() {\n-        check_assist(\n-            generate_enum_into_method,\n-            r#\"\n-enum Value {\n-    Number(i32),\n-    Text(String)$0,\n-}\"#,\n-            r#\"enum Value {\n-    Number(i32),\n-    Text(String),\n-}\n-\n-impl Value {\n-    fn into_text(self) -> Option<String> {\n-        if let Self::Text(v) = self {\n-            Some(v)\n-        } else {\n-            None\n-        }\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_generate_enum_into_already_implemented() {\n-        check_assist_not_applicable(\n-            generate_enum_into_method,\n-            r#\"enum Value {\n-    Number(i32),\n-    Text(String)$0,\n-}\n-\n-impl Value {\n-    fn into_text(self) -> Option<String> {\n-        if let Self::Text(v) = self {\n-            Some(v)\n-        } else {\n-            None\n-        }\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_generate_enum_into_unit_variant() {\n-        check_assist_not_applicable(\n-            generate_enum_into_method,\n-            r#\"enum Value {\n-    Number(i32),\n-    Text(String),\n-    Unit$0,\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_generate_enum_into_record_with_multiple_fields() {\n-        check_assist_not_applicable(\n-            generate_enum_into_method,\n-            r#\"enum Value {\n-    Number(i32),\n-    Text(String),\n-    Both { first: i32, second: String }$0,\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_generate_enum_into_tuple_with_multiple_fields() {\n-        check_assist_not_applicable(\n-            generate_enum_into_method,\n-            r#\"enum Value {\n-    Number(i32),\n-    Text(String, String)$0,\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_generate_enum_into_record_variant() {\n-        check_assist(\n-            generate_enum_into_method,\n-            r#\"enum Value {\n-    Number(i32),\n-    Text { text: String }$0,\n-}\"#,\n-            r#\"enum Value {\n-    Number(i32),\n-    Text { text: String },\n-}\n-\n-impl Value {\n-    fn into_text(self) -> Option<String> {\n-        if let Self::Text { text } = self {\n-            Some(text)\n-        } else {\n-            None\n-        }\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_generate_enum_as_tuple_variant() {\n-        check_assist(\n-            generate_enum_as_method,\n-            r#\"\n-enum Value {\n-    Number(i32),\n-    Text(String)$0,\n-}\"#,\n-            r#\"enum Value {\n-    Number(i32),\n-    Text(String),\n-}\n-\n-impl Value {\n-    fn as_text(&self) -> Option<&String> {\n-        if let Self::Text(v) = self {\n-            Some(v)\n-        } else {\n-            None\n-        }\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_generate_enum_as_record_variant() {\n-        check_assist(\n-            generate_enum_as_method,\n-            r#\"enum Value {\n-    Number(i32),\n-    Text { text: String }$0,\n-}\"#,\n-            r#\"enum Value {\n-    Number(i32),\n-    Text { text: String },\n-}\n-\n-impl Value {\n-    fn as_text(&self) -> Option<&String> {\n-        if let Self::Text { text } = self {\n-            Some(text)\n-        } else {\n-            None\n-        }\n-    }\n }\"#,\n         );\n     }"}, {"sha": "71447f3104d2d615c852825c2da374bb75360994", "filename": "crates/ide_assists/src/handlers/generate_enum_projection_method.rs", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/f098a2b31bffafdbd513f32e8c45d62e709173ea/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f098a2b31bffafdbd513f32e8c45d62e709173ea/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs?ref=f098a2b31bffafdbd513f32e8c45d62e709173ea", "patch": "@@ -0,0 +1,307 @@\n+use itertools::Itertools;\n+use stdx::to_lower_snake_case;\n+use syntax::ast::VisibilityOwner;\n+use syntax::ast::{self, AstNode, NameOwner};\n+\n+use crate::{\n+    utils::{add_method_to_adt, find_struct_impl},\n+    AssistContext, AssistId, AssistKind, Assists,\n+};\n+\n+// Assist: generate_enum_into_method\n+//\n+// Generate an `into_` method for an enum variant.\n+//\n+// ```\n+// enum Value {\n+//  Number(i32),\n+//  Text(String)$0,\n+// }\n+// ```\n+// ->\n+// ```\n+// enum Value {\n+//  Number(i32),\n+//  Text(String),\n+// }\n+//\n+// impl Value {\n+//     fn into_text(self) -> Option<String> {\n+//         if let Self::Text(v) = self {\n+//             Some(v)\n+//         } else {\n+//             None\n+//         }\n+//     }\n+// }\n+// ```\n+pub(crate) fn generate_enum_into_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    generate_enum_projection_method(\n+        acc,\n+        ctx,\n+        \"generate_enum_into_method\",\n+        \"Generate an `into_` method for an enum variant\",\n+        \"into\",\n+        \"\",\n+    )\n+}\n+\n+// Assist: generate_enum_as_method\n+//\n+// Generate an `as_` method for an enum variant.\n+//\n+// ```\n+// enum Value {\n+//  Number(i32),\n+//  Text(String)$0,\n+// }\n+// ```\n+// ->\n+// ```\n+// enum Value {\n+//  Number(i32),\n+//  Text(String),\n+// }\n+//\n+// impl Value {\n+//     fn as_text(&self) -> Option<&String> {\n+//         if let Self::Text(v) = self {\n+//             Some(v)\n+//         } else {\n+//             None\n+//         }\n+//     }\n+// }\n+// ```\n+pub(crate) fn generate_enum_as_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    generate_enum_projection_method(\n+        acc,\n+        ctx,\n+        \"generate_enum_as_method\",\n+        \"Generate an `as_` method for an enum variant\",\n+        \"as\",\n+        \"&\",\n+    )\n+}\n+\n+pub(crate) fn generate_enum_projection_method(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+    assist_id: &'static str,\n+    assist_description: &str,\n+    fn_name_prefix: &str,\n+    ref_prefix: &str,\n+) -> Option<()> {\n+    let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n+    let variant_name = variant.name()?;\n+    let parent_enum = ast::Adt::Enum(variant.parent_enum());\n+\n+    let (pattern_suffix, field_type, bound_name) = match variant.kind() {\n+        ast::StructKind::Record(record) => {\n+            let (field,) = record.fields().collect_tuple()?;\n+            let name = field.name()?.to_string();\n+            let ty = field.ty()?;\n+            let pattern_suffix = format!(\" {{ {} }}\", name);\n+            (pattern_suffix, ty, name)\n+        }\n+        ast::StructKind::Tuple(tuple) => {\n+            let (field,) = tuple.fields().collect_tuple()?;\n+            let ty = field.ty()?;\n+            (\"(v)\".to_owned(), ty, \"v\".to_owned())\n+        }\n+        ast::StructKind::Unit => return None,\n+    };\n+\n+    let fn_name = format!(\"{}_{}\", fn_name_prefix, &to_lower_snake_case(variant_name.text()));\n+\n+    // Return early if we've found an existing new fn\n+    let impl_def = find_struct_impl(&ctx, &parent_enum, &fn_name)?;\n+\n+    let target = variant.syntax().text_range();\n+    acc.add(AssistId(assist_id, AssistKind::Generate), assist_description, target, |builder| {\n+        let vis = parent_enum.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n+        let method = format!(\n+            \"    {0}fn {1}({2}self) -> Option<{2}{3}> {{\n+        if let Self::{4}{5} = self {{\n+            Some({6})\n+        }} else {{\n+            None\n+        }}\n+    }}\",\n+            vis,\n+            fn_name,\n+            ref_prefix,\n+            field_type.syntax(),\n+            variant_name,\n+            pattern_suffix,\n+            bound_name,\n+        );\n+\n+        add_method_to_adt(builder, &parent_enum, impl_def, &method);\n+    })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_generate_enum_into_tuple_variant() {\n+        check_assist(\n+            generate_enum_into_method,\n+            r#\"\n+enum Value {\n+    Number(i32),\n+    Text(String)$0,\n+}\"#,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text(String),\n+}\n+\n+impl Value {\n+    fn into_text(self) -> Option<String> {\n+        if let Self::Text(v) = self {\n+            Some(v)\n+        } else {\n+            None\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_into_already_implemented() {\n+        check_assist_not_applicable(\n+            generate_enum_into_method,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text(String)$0,\n+}\n+\n+impl Value {\n+    fn into_text(self) -> Option<String> {\n+        if let Self::Text(v) = self {\n+            Some(v)\n+        } else {\n+            None\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_into_unit_variant() {\n+        check_assist_not_applicable(\n+            generate_enum_into_method,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text(String),\n+    Unit$0,\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_into_record_with_multiple_fields() {\n+        check_assist_not_applicable(\n+            generate_enum_into_method,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text(String),\n+    Both { first: i32, second: String }$0,\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_into_tuple_with_multiple_fields() {\n+        check_assist_not_applicable(\n+            generate_enum_into_method,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text(String, String)$0,\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_into_record_variant() {\n+        check_assist(\n+            generate_enum_into_method,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text { text: String }$0,\n+}\"#,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text { text: String },\n+}\n+\n+impl Value {\n+    fn into_text(self) -> Option<String> {\n+        if let Self::Text { text } = self {\n+            Some(text)\n+        } else {\n+            None\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_as_tuple_variant() {\n+        check_assist(\n+            generate_enum_as_method,\n+            r#\"\n+enum Value {\n+    Number(i32),\n+    Text(String)$0,\n+}\"#,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text(String),\n+}\n+\n+impl Value {\n+    fn as_text(&self) -> Option<&String> {\n+        if let Self::Text(v) = self {\n+            Some(v)\n+        } else {\n+            None\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_as_record_variant() {\n+        check_assist(\n+            generate_enum_as_method,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text { text: String }$0,\n+}\"#,\n+            r#\"enum Value {\n+    Number(i32),\n+    Text { text: String },\n+}\n+\n+impl Value {\n+    fn as_text(&self) -> Option<&String> {\n+        if let Self::Text { text } = self {\n+            Some(text)\n+        } else {\n+            None\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+}"}, {"sha": "4a7cd58486ac43c4238c597aed192932cd58636a", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f098a2b31bffafdbd513f32e8c45d62e709173ea/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f098a2b31bffafdbd513f32e8c45d62e709173ea/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=f098a2b31bffafdbd513f32e8c45d62e709173ea", "patch": "@@ -129,6 +129,7 @@ mod handlers {\n     mod generate_default_from_enum_variant;\n     mod generate_derive;\n     mod generate_enum_match_method;\n+    mod generate_enum_projection_method;\n     mod generate_from_impl_for_enum;\n     mod generate_function;\n     mod generate_getter;\n@@ -190,8 +191,8 @@ mod handlers {\n             generate_default_from_enum_variant::generate_default_from_enum_variant,\n             generate_derive::generate_derive,\n             generate_enum_match_method::generate_enum_is_method,\n-            generate_enum_match_method::generate_enum_into_method,\n-            generate_enum_match_method::generate_enum_as_method,\n+            generate_enum_projection_method::generate_enum_into_method,\n+            generate_enum_projection_method::generate_enum_as_method,\n             generate_from_impl_for_enum::generate_from_impl_for_enum,\n             generate_function::generate_function,\n             generate_getter::generate_getter,"}, {"sha": "880ab6fe3eb3426f7b4d7d5b43284553f816acb0", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f098a2b31bffafdbd513f32e8c45d62e709173ea/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f098a2b31bffafdbd513f32e8c45d62e709173ea/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=f098a2b31bffafdbd513f32e8c45d62e709173ea", "patch": "@@ -21,7 +21,7 @@ use syntax::{\n };\n \n use crate::{\n-    assist_context::AssistContext,\n+    assist_context::{AssistBuilder, AssistContext},\n     ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams},\n };\n \n@@ -464,3 +464,25 @@ fn generate_impl_text_inner(adt: &ast::Adt, trait_text: Option<&str>, code: &str\n \n     buf\n }\n+\n+pub(crate) fn add_method_to_adt(\n+    builder: &mut AssistBuilder,\n+    adt: &ast::Adt,\n+    impl_def: Option<ast::Impl>,\n+    method: &str,\n+) {\n+    let mut buf = String::with_capacity(method.len() + 2);\n+    if impl_def.is_some() {\n+        buf.push('\\n');\n+    }\n+    buf.push_str(method);\n+\n+    let start_offset = impl_def\n+        .and_then(|impl_def| find_impl_block_end(impl_def, &mut buf))\n+        .unwrap_or_else(|| {\n+            buf = generate_impl_text(&adt, &buf);\n+            adt.syntax().text_range().end()\n+        });\n+\n+    builder.insert(start_offset, buf);\n+}"}]}