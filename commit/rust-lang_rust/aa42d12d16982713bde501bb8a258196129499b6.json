{"sha": "aa42d12d16982713bde501bb8a258196129499b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNDJkMTJkMTY5ODI3MTNiZGU1MDFiYjhhMjU4MTk2MTI5NDk5YjY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-04-03T20:55:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-03T20:55:10Z"}, "message": "Rollup merge of #70707 - ecstatic-morse:dataflow-graphviz-cleanup, r=nikomatsakis\n\nRemove unused graphviz emitter\n\nThis was only used by the old dataflow framework that was removed in #69644.", "tree": {"sha": "05652846d172b82498fbd915d33dc7198045d8bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05652846d172b82498fbd915d33dc7198045d8bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa42d12d16982713bde501bb8a258196129499b6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeh6KuCRBK7hj4Ov3rIwAAdHIIAJwNJlvlnEZGK0bCjjtSgKLJ\nT4+rociLKYi+C/KJVwgDXgM9/dJtXote+Odi58mU8RvaT/qgcz/ZKkEIoDM6Z/Jw\nEYER+nGnZSasFlOWiivKryBvwPpuLCNyA8K9yWHe5M5cnvcOaTEcYsR1GlhOrrRt\noiNHrYsXnpG/FjjOvK4BvcBgGlOj/09klwHjcIle5/W38iK0BGHQgDrcg4rX/D9p\njcDeiDXb00xC1/V/+aRHBEdHZ7Tg/iuWnoiousHbTpAF+P/E62WzYX6LjsKVmm6c\nKWY5o2eY5542EceUa03uuMC32VAK4KR3/df1n1oSWJ53RvBpis1uiEXMP2iIF50=\n=BLG7\n-----END PGP SIGNATURE-----\n", "payload": "tree 05652846d172b82498fbd915d33dc7198045d8bd\nparent 752961b4ca5a596a3711cd493cf3f04076f9f539\nparent 6f3ff27ecc3e0f28d24b0696e037e5e9374c2a30\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1585947310 +0200\ncommitter GitHub <noreply@github.com> 1585947310 +0200\n\nRollup merge of #70707 - ecstatic-morse:dataflow-graphviz-cleanup, r=nikomatsakis\n\nRemove unused graphviz emitter\n\nThis was only used by the old dataflow framework that was removed in #69644.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa42d12d16982713bde501bb8a258196129499b6", "html_url": "https://github.com/rust-lang/rust/commit/aa42d12d16982713bde501bb8a258196129499b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa42d12d16982713bde501bb8a258196129499b6/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "752961b4ca5a596a3711cd493cf3f04076f9f539", "url": "https://api.github.com/repos/rust-lang/rust/commits/752961b4ca5a596a3711cd493cf3f04076f9f539", "html_url": "https://github.com/rust-lang/rust/commit/752961b4ca5a596a3711cd493cf3f04076f9f539"}, {"sha": "6f3ff27ecc3e0f28d24b0696e037e5e9374c2a30", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f3ff27ecc3e0f28d24b0696e037e5e9374c2a30", "html_url": "https://github.com/rust-lang/rust/commit/6f3ff27ecc3e0f28d24b0696e037e5e9374c2a30"}], "stats": {"total": 277, "additions": 0, "deletions": 277}, "files": [{"sha": "e74d27bafb2d90c588c1163e605fe45bfa9c1bf0", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "removed", "additions": 0, "deletions": 277, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/752961b4ca5a596a3711cd493cf3f04076f9f539/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752961b4ca5a596a3711cd493cf3f04076f9f539/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=752961b4ca5a596a3711cd493cf3f04076f9f539", "patch": "@@ -1,277 +0,0 @@\n-//! Hook into libgraphviz for rendering dataflow graphs for MIR.\n-\n-use rustc_hir::def_id::DefId;\n-use rustc_middle::mir::{BasicBlock, Body};\n-\n-use std::fs;\n-use std::io;\n-use std::marker::PhantomData;\n-use std::path::Path;\n-\n-use crate::util::graphviz_safe_def_name;\n-\n-use super::DataflowBuilder;\n-use super::DebugFormatted;\n-use super::{BitDenotation, DataflowState};\n-\n-pub trait MirWithFlowState<'tcx> {\n-    type BD: BitDenotation<'tcx>;\n-    fn def_id(&self) -> DefId;\n-    fn body(&self) -> &Body<'tcx>;\n-    fn flow_state(&self) -> &DataflowState<'tcx, Self::BD>;\n-}\n-\n-impl<'a, 'tcx, BD> MirWithFlowState<'tcx> for DataflowBuilder<'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    type BD = BD;\n-    fn def_id(&self) -> DefId {\n-        self.def_id\n-    }\n-    fn body(&self) -> &Body<'tcx> {\n-        self.flow_state.body()\n-    }\n-    fn flow_state(&self) -> &DataflowState<'tcx, Self::BD> {\n-        &self.flow_state.flow_state\n-    }\n-}\n-\n-struct Graph<'a, 'tcx, MWF, P>\n-where\n-    MWF: MirWithFlowState<'tcx>,\n-{\n-    mbcx: &'a MWF,\n-    phantom: PhantomData<&'tcx ()>,\n-    render_idx: P,\n-}\n-\n-pub(crate) fn print_borrowck_graph_to<'a, 'tcx, BD, P>(\n-    mbcx: &DataflowBuilder<'a, 'tcx, BD>,\n-    path: &Path,\n-    render_idx: P,\n-) -> io::Result<()>\n-where\n-    BD: BitDenotation<'tcx>,\n-    P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-{\n-    let g = Graph { mbcx, phantom: PhantomData, render_idx };\n-    let mut v = Vec::new();\n-    dot::render(&g, &mut v)?;\n-    debug!(\"print_borrowck_graph_to path: {} def_id: {:?}\", path.display(), mbcx.def_id);\n-    fs::write(path, v)\n-}\n-\n-pub type Node = BasicBlock;\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub struct Edge {\n-    source: BasicBlock,\n-    index: usize,\n-}\n-\n-fn outgoing(body: &Body<'_>, bb: BasicBlock) -> Vec<Edge> {\n-    (0..body[bb].terminator().successors().count())\n-        .map(|index| Edge { source: bb, index })\n-        .collect()\n-}\n-\n-impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n-where\n-    MWF: MirWithFlowState<'tcx>,\n-    P: Fn(&MWF::BD, <MWF::BD as BitDenotation<'tcx>>::Idx) -> DebugFormatted,\n-{\n-    type Node = Node;\n-    type Edge = Edge;\n-    fn graph_id(&self) -> dot::Id<'_> {\n-        let name = graphviz_safe_def_name(self.mbcx.def_id());\n-        dot::Id::new(format!(\"graph_for_def_id_{}\", name)).unwrap()\n-    }\n-\n-    fn node_id(&self, n: &Node) -> dot::Id<'_> {\n-        dot::Id::new(format!(\"bb_{}\", n.index())).unwrap()\n-    }\n-\n-    fn node_label(&self, n: &Node) -> dot::LabelText<'_> {\n-        // Node label is something like this:\n-        // +---------+----------------------------------+------------------+------------------+\n-        // | ENTRY   | MIR                              | GEN              | KILL             |\n-        // +---------+----------------------------------+------------------+------------------+\n-        // |         |  0: StorageLive(_7)              | bb3[2]: reserved | bb2[0]: reserved |\n-        // |         |  1: StorageLive(_8)              | bb3[2]: active   | bb2[0]: active   |\n-        // |         |  2: _8 = &mut _1                 |                  | bb4[2]: reserved |\n-        // |         |                                  |                  | bb4[2]: active   |\n-        // |         |                                  |                  | bb9[0]: reserved |\n-        // |         |                                  |                  | bb9[0]: active   |\n-        // |         |                                  |                  | bb10[0]: reserved|\n-        // |         |                                  |                  | bb10[0]: active  |\n-        // |         |                                  |                  | bb11[0]: reserved|\n-        // |         |                                  |                  | bb11[0]: active  |\n-        // +---------+----------------------------------+------------------+------------------+\n-        // | [00-00] | _7 = const Foo::twiddle(move _8) | [0c-00]          | [f3-0f]          |\n-        // +---------+----------------------------------+------------------+------------------+\n-        let mut v = Vec::new();\n-        self.node_label_internal(n, &mut v, *n, self.mbcx.body()).unwrap();\n-        dot::LabelText::html(String::from_utf8(v).unwrap())\n-    }\n-\n-    fn node_shape(&self, _n: &Node) -> Option<dot::LabelText<'_>> {\n-        Some(dot::LabelText::label(\"none\"))\n-    }\n-\n-    fn edge_label(&'a self, e: &Edge) -> dot::LabelText<'a> {\n-        let term = self.mbcx.body()[e.source].terminator();\n-        let label = &term.kind.fmt_successor_labels()[e.index];\n-        dot::LabelText::label(label.clone())\n-    }\n-}\n-\n-impl<'a, 'tcx, MWF, P> Graph<'a, 'tcx, MWF, P>\n-where\n-    MWF: MirWithFlowState<'tcx>,\n-    P: Fn(&MWF::BD, <MWF::BD as BitDenotation<'tcx>>::Idx) -> DebugFormatted,\n-{\n-    /// Generate the node label\n-    fn node_label_internal<W: io::Write>(\n-        &self,\n-        n: &Node,\n-        w: &mut W,\n-        block: BasicBlock,\n-        body: &Body<'_>,\n-    ) -> io::Result<()> {\n-        // Header rows\n-        const HDRS: [&str; 4] = [\"ENTRY\", \"MIR\", \"BLOCK GENS\", \"BLOCK KILLS\"];\n-        const HDR_FMT: &str = \"bgcolor=\\\"grey\\\"\";\n-        write!(w, \"<table><tr><td rowspan=\\\"{}\\\">\", HDRS.len())?;\n-        write!(w, \"{:?}\", block.index())?;\n-        write!(w, \"</td></tr><tr>\")?;\n-        for hdr in &HDRS {\n-            write!(w, \"<td {}>{}</td>\", HDR_FMT, hdr)?;\n-        }\n-        write!(w, \"</tr>\")?;\n-\n-        // Data row\n-        self.node_label_verbose_row(n, w, block, body)?;\n-        self.node_label_final_row(n, w, block, body)?;\n-        write!(w, \"</table>\")?;\n-\n-        Ok(())\n-    }\n-\n-    /// Builds the verbose row: full MIR data, and detailed gen/kill/entry sets.\n-    fn node_label_verbose_row<W: io::Write>(\n-        &self,\n-        n: &Node,\n-        w: &mut W,\n-        block: BasicBlock,\n-        body: &Body<'_>,\n-    ) -> io::Result<()> {\n-        let i = n.index();\n-\n-        macro_rules! dump_set_for {\n-            ($set:ident, $interpret:ident) => {\n-                write!(w, \"<td>\")?;\n-\n-                let flow = self.mbcx.flow_state();\n-                let entry_interp =\n-                    flow.$interpret(&flow.operator, flow.sets.$set(i), &self.render_idx);\n-                for e in &entry_interp {\n-                    write!(w, \"{:?}<br/>\", e)?;\n-                }\n-                write!(w, \"</td>\")?;\n-            };\n-        }\n-\n-        write!(w, \"<tr>\")?;\n-        // Entry\n-        dump_set_for!(entry_set_for, interpret_set);\n-\n-        // MIR statements\n-        write!(w, \"<td>\")?;\n-        {\n-            let data = &body[block];\n-            for (i, statement) in data.statements.iter().enumerate() {\n-                write!(\n-                    w,\n-                    \"{}<br align=\\\"left\\\"/>\",\n-                    dot::escape_html(&format!(\"{:3}: {:?}\", i, statement))\n-                )?;\n-            }\n-        }\n-        write!(w, \"</td>\")?;\n-\n-        // Gen\n-        dump_set_for!(gen_set_for, interpret_hybrid_set);\n-\n-        // Kill\n-        dump_set_for!(kill_set_for, interpret_hybrid_set);\n-\n-        write!(w, \"</tr>\")?;\n-\n-        Ok(())\n-    }\n-\n-    /// Builds the summary row: terminator, gen/kill/entry bit sets.\n-    fn node_label_final_row<W: io::Write>(\n-        &self,\n-        n: &Node,\n-        w: &mut W,\n-        block: BasicBlock,\n-        body: &Body<'_>,\n-    ) -> io::Result<()> {\n-        let i = n.index();\n-\n-        let flow = self.mbcx.flow_state();\n-\n-        write!(w, \"<tr>\")?;\n-\n-        // Entry\n-        let set = flow.sets.entry_set_for(i);\n-        write!(w, \"<td>{:?}</td>\", dot::escape_html(&set.to_string()))?;\n-\n-        // Terminator\n-        write!(w, \"<td>\")?;\n-        {\n-            let data = &body[block];\n-            let mut terminator_head = String::new();\n-            data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n-            write!(w, \"{}\", dot::escape_html(&terminator_head))?;\n-        }\n-        write!(w, \"</td>\")?;\n-\n-        // Gen/Kill\n-        let trans = flow.sets.trans_for(i);\n-        write!(w, \"<td>{:?}</td>\", dot::escape_html(&format!(\"{:?}\", trans.gen_set)))?;\n-        write!(w, \"<td>{:?}</td>\", dot::escape_html(&format!(\"{:?}\", trans.kill_set)))?;\n-\n-        write!(w, \"</tr>\")?;\n-\n-        Ok(())\n-    }\n-}\n-\n-impl<'a, 'tcx, MWF, P> dot::GraphWalk<'a> for Graph<'a, 'tcx, MWF, P>\n-where\n-    MWF: MirWithFlowState<'tcx>,\n-{\n-    type Node = Node;\n-    type Edge = Edge;\n-    fn nodes(&self) -> dot::Nodes<'_, Node> {\n-        self.mbcx.body().basic_blocks().indices().collect::<Vec<_>>().into()\n-    }\n-\n-    fn edges(&self) -> dot::Edges<'_, Edge> {\n-        let body = self.mbcx.body();\n-\n-        body.basic_blocks().indices().flat_map(|bb| outgoing(body, bb)).collect::<Vec<_>>().into()\n-    }\n-\n-    fn source(&self, edge: &Edge) -> Node {\n-        edge.source\n-    }\n-\n-    fn target(&self, edge: &Edge) -> Node {\n-        let body = self.mbcx.body();\n-        *body[edge.source].terminator().successors().nth(edge.index).unwrap()\n-    }\n-}"}]}