{"sha": "85c20698d494166e396740c352679980b63b116d", "node_id": "C_kwDOAAsO6NoAKDg1YzIwNjk4ZDQ5NDE2NmUzOTY3NDBjMzUyNjc5OTgwYjYzYjExNmQ", "commit": {"author": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2021-11-05T17:18:32Z"}, "committer": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2021-11-26T16:26:22Z"}, "message": "Add ICE test", "tree": {"sha": "e9abbac658c4b56ddcd0750b8c8b3a6f6d71eb57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9abbac658c4b56ddcd0750b8c8b3a6f6d71eb57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85c20698d494166e396740c352679980b63b116d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEQ7Fl7qPq2YcWF1dqAn35M4hird0FAmGhCq4ACgkQAn35M4hi\nrd2Wbg//Z85Tw5CPenX0+s56cn2RYWM/MFtyGCu7iJym+Mv2WLMVINPkTPqpvvqU\nf/eMfZWpSlicQybgZGxC3dVEuUjHB/32WPdub6rJGIaQ5FK63YpBsx7WrJxEZ0l/\nb5yAF/9k6EIaM3aVtVCuj5HcHHJA2K4SwT/npw65D1KtcMH9BPCNkTZViaHxGJCY\nE6nJd1thiA9RMVo1DSExgDchXghig9dhABdHYV6jqKX+IqyCs9gWmbBNkxFiRmJ1\nT32YfHXHYjRZloJRxAWyk+g3A3X1VoA1lw+thCuQ88Q0cw+6x94PHG/84vWE3wRL\nhOcXHkbyWNQgsvmrON9nBks4IcJdmGM6hEMmFsFs7siEfHovrXrsPBItzUqp6HyM\naH1FCMQna3KtKZDhy8F18fcwyf9LgqCWFl12qCUUa7JP1xA+YTvQJimC6qkLDxm6\nT2Lp2F3hyERiz4Pus5psb1Zla/sPdROgrZKjREmOX+mCRQLyKk4FUh3ajusAc5Tm\nR8lqcg7AFVKf34C3mYaskjHar47PrPMS8Eb5GC7nVAY/ZbGHfZvPHtVhOzKnOixV\niZoUMSndUja7MyvCIRjPxB+f1pWV+pUTY/6J1AJK5AdKAo91jiPikR87yK43Ma3l\nBNCc80slqXsl7z4hCd1hEjrgICspWSXZYhhopki7iF9dtgLkpkk=\n=RugW\n-----END PGP SIGNATURE-----", "payload": "tree e9abbac658c4b56ddcd0750b8c8b3a6f6d71eb57\nparent c86da9b7b2ae2c05d830fba463c12c58b7b3209e\nauthor Deadbeef <ent3rm4n@gmail.com> 1636132712 +0800\ncommitter Deadbeef <ent3rm4n@gmail.com> 1637943982 +0800\n\nAdd ICE test\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85c20698d494166e396740c352679980b63b116d", "html_url": "https://github.com/rust-lang/rust/commit/85c20698d494166e396740c352679980b63b116d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85c20698d494166e396740c352679980b63b116d/comments", "author": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c86da9b7b2ae2c05d830fba463c12c58b7b3209e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c86da9b7b2ae2c05d830fba463c12c58b7b3209e", "html_url": "https://github.com/rust-lang/rust/commit/c86da9b7b2ae2c05d830fba463c12c58b7b3209e"}], "stats": {"total": 472, "additions": 472, "deletions": 0}, "files": [{"sha": "df222376434024149024bddbe52bb7e473e9f126", "filename": "src/test/rustdoc-ui/scrape-examples-ice.rs", "status": "added", "additions": 472, "deletions": 0, "changes": 472, "blob_url": "https://github.com/rust-lang/rust/blob/85c20698d494166e396740c352679980b63b116d/src%2Ftest%2Frustdoc-ui%2Fscrape-examples-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85c20698d494166e396740c352679980b63b116d/src%2Ftest%2Frustdoc-ui%2Fscrape-examples-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fscrape-examples-ice.rs?ref=85c20698d494166e396740c352679980b63b116d", "patch": "@@ -0,0 +1,472 @@\n+// compile-flags: -Z unstable-options --scrape-examples-output-path t.calls --scrape-examples-target-crate foobar\n+// check-pass\n+\n+// Copyright 2013-2016 The rust-url developers.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! URLs use special characters to indicate the parts of the request.\n+//! For example, a `?` question mark marks the end of a path and the start of a query string.\n+//! In order for that character to exist inside a path, it needs to be encoded differently.\n+//!\n+//! Percent encoding replaces reserved characters with the `%` escape character\n+//! followed by a byte value as two hexadecimal digits.\n+//! For example, an ASCII space is replaced with `%20`.\n+//!\n+//! When encoding, the set of characters that can (and should, for readability) be left alone\n+//! depends on the context.\n+//! The `?` question mark mentioned above is not a separator when used literally\n+//! inside of a query string, and therefore does not need to be encoded.\n+//! The [`AsciiSet`] parameter of [`percent_encode`] and [`utf8_percent_encode`]\n+//! lets callers configure this.\n+//!\n+//! This crate deliberately does not provide many different sets.\n+//! Users should consider in what context the encoded string will be used,\n+//! read relevant specifications, and define their own set.\n+//! This is done by using the `add` method of an existing set.\n+//!\n+//! # Examples\n+//!\n+//! ```\n+//! use percent_encoding::{utf8_percent_encode, AsciiSet, CONTROLS};\n+//!\n+//! /// https://url.spec.whatwg.org/#fragment-percent-encode-set\n+//! const FRAGMENT: &AsciiSet = &CONTROLS.add(b' ').add(b'\"').add(b'<').add(b'>').add(b'`');\n+//!\n+//! assert_eq!(utf8_percent_encode(\"foo <bar>\", FRAGMENT).to_string(), \"foo%20%3Cbar%3E\");\n+//! ```\n+\n+#![no_std]\n+#[cfg(feature = \"alloc\")]\n+extern crate alloc;\n+\n+#[cfg(feature = \"alloc\")]\n+use alloc::{\n+    borrow::{Cow, ToOwned},\n+    string::String,\n+    vec::Vec,\n+};\n+use core::{fmt, mem, slice, str};\n+\n+/// Represents a set of characters or bytes in the ASCII range.\n+///\n+/// This is used in [`percent_encode`] and [`utf8_percent_encode`].\n+/// This is similar to [percent-encode sets](https://url.spec.whatwg.org/#percent-encoded-bytes).\n+///\n+/// Use the `add` method of an existing set to define a new set. For example:\n+///\n+/// ```\n+/// use percent_encoding::{AsciiSet, CONTROLS};\n+///\n+/// /// https://url.spec.whatwg.org/#fragment-percent-encode-set\n+/// const FRAGMENT: &AsciiSet = &CONTROLS.add(b' ').add(b'\"').add(b'<').add(b'>').add(b'`');\n+/// ```\n+pub struct AsciiSet {\n+    mask: [Chunk; ASCII_RANGE_LEN / BITS_PER_CHUNK],\n+}\n+\n+type Chunk = u32;\n+\n+const ASCII_RANGE_LEN: usize = 0x80;\n+\n+const BITS_PER_CHUNK: usize = 8 * mem::size_of::<Chunk>();\n+\n+impl AsciiSet {\n+    /// Called with UTF-8 bytes rather than code points.\n+    /// Not used for non-ASCII bytes.\n+    const fn contains(&self, byte: u8) -> bool {\n+        let chunk = self.mask[byte as usize / BITS_PER_CHUNK];\n+        let mask = 1 << (byte as usize % BITS_PER_CHUNK);\n+        (chunk & mask) != 0\n+    }\n+\n+    fn should_percent_encode(&self, byte: u8) -> bool {\n+        !byte.is_ascii() || self.contains(byte)\n+    }\n+\n+    pub const fn add(&self, byte: u8) -> Self {\n+        let mut mask = self.mask;\n+        mask[byte as usize / BITS_PER_CHUNK] |= 1 << (byte as usize % BITS_PER_CHUNK);\n+        AsciiSet { mask }\n+    }\n+\n+    pub const fn remove(&self, byte: u8) -> Self {\n+        let mut mask = self.mask;\n+        mask[byte as usize / BITS_PER_CHUNK] &= !(1 << (byte as usize % BITS_PER_CHUNK));\n+        AsciiSet { mask }\n+    }\n+}\n+\n+/// The set of 0x00\u00a0to 0x1F (C0 controls), and 0x7F (DEL).\n+///\n+/// Note that this includes the newline and tab characters, but not the space 0x20.\n+///\n+/// <https://url.spec.whatwg.org/#c0-control-percent-encode-set>\n+pub const CONTROLS: &AsciiSet = &AsciiSet {\n+    mask: [\n+        !0_u32, // C0: 0x00 to 0x1F (32 bits set)\n+        0,\n+        0,\n+        1 << (0x7F_u32 % 32), // DEL: 0x7F (one bit set)\n+    ],\n+};\n+\n+macro_rules! static_assert {\n+    ($( $bool: expr, )+) => {\n+        fn _static_assert() {\n+            $(\n+                let _ = mem::transmute::<[u8; $bool as usize], u8>;\n+            )+\n+        }\n+    }\n+}\n+\n+static_assert! {\n+    CONTROLS.contains(0x00),\n+    CONTROLS.contains(0x1F),\n+    !CONTROLS.contains(0x20),\n+    !CONTROLS.contains(0x7E),\n+    CONTROLS.contains(0x7F),\n+}\n+\n+/// Everything that is not an ASCII letter or digit.\n+///\n+/// This is probably more eager than necessary in any context.\n+pub const NON_ALPHANUMERIC: &AsciiSet = &CONTROLS\n+    .add(b' ')\n+    .add(b'!')\n+    .add(b'\"')\n+    .add(b'#')\n+    .add(b'$')\n+    .add(b'%')\n+    .add(b'&')\n+    .add(b'\\'')\n+    .add(b'(')\n+    .add(b')')\n+    .add(b'*')\n+    .add(b'+')\n+    .add(b',')\n+    .add(b'-')\n+    .add(b'.')\n+    .add(b'/')\n+    .add(b':')\n+    .add(b';')\n+    .add(b'<')\n+    .add(b'=')\n+    .add(b'>')\n+    .add(b'?')\n+    .add(b'@')\n+    .add(b'[')\n+    .add(b'\\\\')\n+    .add(b']')\n+    .add(b'^')\n+    .add(b'_')\n+    .add(b'`')\n+    .add(b'{')\n+    .add(b'|')\n+    .add(b'}')\n+    .add(b'~');\n+\n+/// Return the percent-encoding of the given byte.\n+///\n+/// This is unconditional, unlike `percent_encode()` which has an `AsciiSet` parameter.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use percent_encoding::percent_encode_byte;\n+///\n+/// assert_eq!(\"foo bar\".bytes().map(percent_encode_byte).collect::<String>(),\n+///            \"%66%6F%6F%20%62%61%72\");\n+/// ```\n+pub fn percent_encode_byte(byte: u8) -> &'static str {\n+    let index = usize::from(byte) * 3;\n+    &\"\\\n+      %00%01%02%03%04%05%06%07%08%09%0A%0B%0C%0D%0E%0F\\\n+      %10%11%12%13%14%15%16%17%18%19%1A%1B%1C%1D%1E%1F\\\n+      %20%21%22%23%24%25%26%27%28%29%2A%2B%2C%2D%2E%2F\\\n+      %30%31%32%33%34%35%36%37%38%39%3A%3B%3C%3D%3E%3F\\\n+      %40%41%42%43%44%45%46%47%48%49%4A%4B%4C%4D%4E%4F\\\n+      %50%51%52%53%54%55%56%57%58%59%5A%5B%5C%5D%5E%5F\\\n+      %60%61%62%63%64%65%66%67%68%69%6A%6B%6C%6D%6E%6F\\\n+      %70%71%72%73%74%75%76%77%78%79%7A%7B%7C%7D%7E%7F\\\n+      %80%81%82%83%84%85%86%87%88%89%8A%8B%8C%8D%8E%8F\\\n+      %90%91%92%93%94%95%96%97%98%99%9A%9B%9C%9D%9E%9F\\\n+      %A0%A1%A2%A3%A4%A5%A6%A7%A8%A9%AA%AB%AC%AD%AE%AF\\\n+      %B0%B1%B2%B3%B4%B5%B6%B7%B8%B9%BA%BB%BC%BD%BE%BF\\\n+      %C0%C1%C2%C3%C4%C5%C6%C7%C8%C9%CA%CB%CC%CD%CE%CF\\\n+      %D0%D1%D2%D3%D4%D5%D6%D7%D8%D9%DA%DB%DC%DD%DE%DF\\\n+      %E0%E1%E2%E3%E4%E5%E6%E7%E8%E9%EA%EB%EC%ED%EE%EF\\\n+      %F0%F1%F2%F3%F4%F5%F6%F7%F8%F9%FA%FB%FC%FD%FE%FF\\\n+      \"[index..index + 3]\n+}\n+\n+/// Percent-encode the given bytes with the given set.\n+///\n+/// Non-ASCII bytes and bytes in `ascii_set` are encoded.\n+///\n+/// The return type:\n+///\n+/// * Implements `Iterator<Item = &str>` and therefore has a `.collect::<String>()` method,\n+/// * Implements `Display` and therefore has a `.to_string()` method,\n+/// * Implements `Into<Cow<str>>` borrowing `input` when none of its bytes are encoded.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use percent_encoding::{percent_encode, NON_ALPHANUMERIC};\n+///\n+/// assert_eq!(percent_encode(b\"foo bar?\", NON_ALPHANUMERIC).to_string(), \"foo%20bar%3F\");\n+/// ```\n+#[inline]\n+pub fn percent_encode<'a>(input: &'a [u8], ascii_set: &'static AsciiSet) -> PercentEncode<'a> {\n+    PercentEncode {\n+        bytes: input,\n+        ascii_set,\n+    }\n+}\n+\n+/// Percent-encode the UTF-8 encoding of the given string.\n+///\n+/// See [`percent_encode`] regarding the return type.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use percent_encoding::{utf8_percent_encode, NON_ALPHANUMERIC};\n+///\n+/// assert_eq!(utf8_percent_encode(\"foo bar?\", NON_ALPHANUMERIC).to_string(), \"foo%20bar%3F\");\n+/// ```\n+#[inline]\n+pub fn utf8_percent_encode<'a>(input: &'a str, ascii_set: &'static AsciiSet) -> PercentEncode<'a> {\n+    percent_encode(input.as_bytes(), ascii_set)\n+}\n+\n+/// The return type of [`percent_encode`] and [`utf8_percent_encode`].\n+#[derive(Clone)]\n+pub struct PercentEncode<'a> {\n+    bytes: &'a [u8],\n+    ascii_set: &'static AsciiSet,\n+}\n+\n+impl<'a> Iterator for PercentEncode<'a> {\n+    type Item = &'a str;\n+\n+    fn next(&mut self) -> Option<&'a str> {\n+        if let Some((&first_byte, remaining)) = self.bytes.split_first() {\n+            if self.ascii_set.should_percent_encode(first_byte) {\n+                self.bytes = remaining;\n+                Some(percent_encode_byte(first_byte))\n+            } else {\n+                // The unsafe blocks here are appropriate because the bytes are\n+                // confirmed as a subset of UTF-8 in should_percent_encode.\n+                for (i, &byte) in remaining.iter().enumerate() {\n+                    if self.ascii_set.should_percent_encode(byte) {\n+                        // 1 for first_byte + i for previous iterations of this loop\n+                        let (unchanged_slice, remaining) = self.bytes.split_at(1 + i);\n+                        self.bytes = remaining;\n+                        return Some(unsafe { str::from_utf8_unchecked(unchanged_slice) });\n+                    }\n+                }\n+                let unchanged_slice = self.bytes;\n+                self.bytes = &[][..];\n+                Some(unsafe { str::from_utf8_unchecked(unchanged_slice) })\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.bytes.is_empty() {\n+            (0, Some(0))\n+        } else {\n+            (1, Some(self.bytes.len()))\n+        }\n+    }\n+}\n+\n+impl<'a> fmt::Display for PercentEncode<'a> {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        for c in (*self).clone() {\n+            formatter.write_str(c)?\n+        }\n+        Ok(())\n+    }\n+}\n+\n+#[cfg(feature = \"alloc\")]\n+impl<'a> From<PercentEncode<'a>> for Cow<'a, str> {\n+    fn from(mut iter: PercentEncode<'a>) -> Self {\n+        match iter.next() {\n+            None => \"\".into(),\n+            Some(first) => match iter.next() {\n+                None => first.into(),\n+                Some(second) => {\n+                    let mut string = first.to_owned();\n+                    string.push_str(second);\n+                    string.extend(iter);\n+                    string.into()\n+                }\n+            },\n+        }\n+    }\n+}\n+\n+/// Percent-decode the given string.\n+///\n+/// <https://url.spec.whatwg.org/#string-percent-decode>\n+///\n+/// See [`percent_decode`] regarding the return type.\n+#[inline]\n+pub fn percent_decode_str(input: &str) -> PercentDecode<'_> {\n+    percent_decode(input.as_bytes())\n+}\n+\n+/// Percent-decode the given bytes.\n+///\n+/// <https://url.spec.whatwg.org/#percent-decode>\n+///\n+/// Any sequence of `%` followed by two hexadecimal digits is decoded.\n+/// The return type:\n+///\n+/// * Implements `Into<Cow<u8>>` borrowing `input` when it contains no percent-encoded sequence,\n+/// * Implements `Iterator<Item = u8>` and therefore has a `.collect::<Vec<u8>>()` method,\n+/// * Has `decode_utf8()` and `decode_utf8_lossy()` methods.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use percent_encoding::percent_decode;\n+///\n+/// assert_eq!(percent_decode(b\"foo%20bar%3f\").decode_utf8().unwrap(), \"foo bar?\");\n+/// ```\n+#[inline]\n+pub fn percent_decode(input: &[u8]) -> PercentDecode<'_> {\n+    PercentDecode {\n+        bytes: input.iter(),\n+    }\n+}\n+\n+/// The return type of [`percent_decode`].\n+#[derive(Clone, Debug)]\n+pub struct PercentDecode<'a> {\n+    bytes: slice::Iter<'a, u8>,\n+}\n+\n+fn after_percent_sign(iter: &mut slice::Iter<'_, u8>) -> Option<u8> {\n+    let mut cloned_iter = iter.clone();\n+    let h = char::from(*cloned_iter.next()?).to_digit(16)?;\n+    let l = char::from(*cloned_iter.next()?).to_digit(16)?;\n+    *iter = cloned_iter;\n+    Some(h as u8 * 0x10 + l as u8)\n+}\n+\n+impl<'a> Iterator for PercentDecode<'a> {\n+    type Item = u8;\n+\n+    fn next(&mut self) -> Option<u8> {\n+        self.bytes.next().map(|&byte| {\n+            if byte == b'%' {\n+                after_percent_sign(&mut self.bytes).unwrap_or(byte)\n+            } else {\n+                byte\n+            }\n+        })\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let bytes = self.bytes.len();\n+        ((bytes + 2) / 3, Some(bytes))\n+    }\n+}\n+\n+#[cfg(feature = \"alloc\")]\n+impl<'a> From<PercentDecode<'a>> for Cow<'a, [u8]> {\n+    fn from(iter: PercentDecode<'a>) -> Self {\n+        match iter.if_any() {\n+            Some(vec) => Cow::Owned(vec),\n+            None => Cow::Borrowed(iter.bytes.as_slice()),\n+        }\n+    }\n+}\n+\n+impl<'a> PercentDecode<'a> {\n+    /// If the percent-decoding is different from the input, return it as a new bytes vector.\n+    #[cfg(feature = \"alloc\")]\n+    fn if_any(&self) -> Option<Vec<u8>> {\n+        let mut bytes_iter = self.bytes.clone();\n+        while bytes_iter.any(|&b| b == b'%') {\n+            if let Some(decoded_byte) = after_percent_sign(&mut bytes_iter) {\n+                let initial_bytes = self.bytes.as_slice();\n+                let unchanged_bytes_len = initial_bytes.len() - bytes_iter.len() - 3;\n+                let mut decoded = initial_bytes[..unchanged_bytes_len].to_owned();\n+                decoded.push(decoded_byte);\n+                decoded.extend(PercentDecode { bytes: bytes_iter });\n+                return Some(decoded);\n+            }\n+        }\n+        // Nothing to decode\n+        None\n+    }\n+\n+    /// Decode the result of percent-decoding as UTF-8.\n+    ///\n+    /// This is return `Err` when the percent-decoded bytes are not well-formed in UTF-8.\n+    #[cfg(feature = \"alloc\")]\n+    pub fn decode_utf8(self) -> Result<Cow<'a, str>, str::Utf8Error> {\n+        match self.clone().into() {\n+            Cow::Borrowed(bytes) => match str::from_utf8(bytes) {\n+                Ok(s) => Ok(s.into()),\n+                Err(e) => Err(e),\n+            },\n+            Cow::Owned(bytes) => match String::from_utf8(bytes) {\n+                Ok(s) => Ok(s.into()),\n+                Err(e) => Err(e.utf8_error()),\n+            },\n+        }\n+    }\n+\n+    /// Decode the result of percent-decoding as UTF-8, lossily.\n+    ///\n+    /// Invalid UTF-8 percent-encoded byte sequences will be replaced \ufffd U+FFFD,\n+    /// the replacement character.\n+    #[cfg(feature = \"alloc\")]\n+    pub fn decode_utf8_lossy(self) -> Cow<'a, str> {\n+        decode_utf8_lossy(self.clone().into())\n+    }\n+}\n+\n+#[cfg(feature = \"alloc\")]\n+fn decode_utf8_lossy(input: Cow<'_, [u8]>) -> Cow<'_, str> {\n+    // Note: This function is duplicated in `form_urlencoded/src/query_encoding.rs`.\n+    match input {\n+        Cow::Borrowed(bytes) => String::from_utf8_lossy(bytes),\n+        Cow::Owned(bytes) => {\n+            match String::from_utf8_lossy(&bytes) {\n+                Cow::Borrowed(utf8) => {\n+                    // If from_utf8_lossy returns a Cow::Borrowed, then we can\n+                    // be sure our original bytes were valid UTF-8. This is because\n+                    // if the bytes were invalid UTF-8 from_utf8_lossy would have\n+                    // to allocate a new owned string to back the Cow so it could\n+                    // replace invalid bytes with a placeholder.\n+\n+                    // First we do a debug_assert to confirm our description above.\n+                    let raw_utf8: *const [u8];\n+                    raw_utf8 = utf8.as_bytes();\n+                    debug_assert!(raw_utf8 == &*bytes as *const [u8]);\n+\n+                    // Given we know the original input bytes are valid UTF-8,\n+                    // and we have ownership of those bytes, we re-use them and\n+                    // return a Cow::Owned here.\n+                    Cow::Owned(unsafe { String::from_utf8_unchecked(bytes) })\n+                }\n+                Cow::Owned(s) => Cow::Owned(s),\n+            }\n+        }\n+    }\n+}"}]}