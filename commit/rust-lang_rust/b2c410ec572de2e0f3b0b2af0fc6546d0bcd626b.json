{"sha": "b2c410ec572de2e0f3b0b2af0fc6546d0bcd626b", "node_id": "C_kwDOAAsO6NoAKGIyYzQxMGVjNTcyZGUyZTBmM2IwYjJhZjBmYzY1NDZkMGJjZDYyNmI", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-06-15T21:14:40Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-06-24T18:29:36Z"}, "message": "scan mountinfo when hardcoded cgroupv1 mountpoints don't work", "tree": {"sha": "deee2845e829e1d21f53f3a8500ed421f5df578b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deee2845e829e1d21f53f3a8500ed421f5df578b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2c410ec572de2e0f3b0b2af0fc6546d0bcd626b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2c410ec572de2e0f3b0b2af0fc6546d0bcd626b", "html_url": "https://github.com/rust-lang/rust/commit/b2c410ec572de2e0f3b0b2af0fc6546d0bcd626b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2c410ec572de2e0f3b0b2af0fc6546d0bcd626b/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8234620109cf0f69089f37ca94c4fab22c0560f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8234620109cf0f69089f37ca94c4fab22c0560f", "html_url": "https://github.com/rust-lang/rust/commit/d8234620109cf0f69089f37ca94c4fab22c0560f"}], "stats": {"total": 102, "additions": 83, "deletions": 19}, "files": [{"sha": "af281a255cc261040be7f72df029c584586acefa", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 83, "deletions": 19, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/b2c410ec572de2e0f3b0b2af0fc6546d0bcd626b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c410ec572de2e0f3b0b2af0fc6546d0bcd626b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=b2c410ec572de2e0f3b0b2af0fc6546d0bcd626b", "patch": "@@ -381,19 +381,27 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n \n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n mod cgroups {\n+    //! Currently not covered\n+    //! * cgroup v2 in non-standard mountpoints\n+    //! * paths containing control characters or spaces, since those would be escaped in procfs\n+    //!   output and we don't unescape\n+    use crate::borrow::Cow;\n     use crate::ffi::OsString;\n     use crate::fs::{try_exists, File};\n     use crate::io::Read;\n+    use crate::io::{BufRead, BufReader};\n     use crate::os::unix::ffi::OsStringExt;\n+    use crate::path::Path;\n     use crate::path::PathBuf;\n     use crate::str::from_utf8;\n \n+    #[derive(PartialEq)]\n     enum Cgroup {\n         V1,\n         V2,\n     }\n \n-    /// Returns cgroup CPU quota in core-equivalents, rounded down, or usize::MAX if the quota cannot\n+    /// Returns cgroup CPU quota in core-equivalents, rounded down or usize::MAX if the quota cannot\n     /// be determined or is not set.\n     pub(super) fn quota() -> usize {\n         let mut quota = usize::MAX;\n@@ -407,27 +415,30 @@ mod cgroups {\n             let mut buf = Vec::with_capacity(128);\n             // find our place in the cgroup hierarchy\n             File::open(\"/proc/self/cgroup\").ok()?.read_to_end(&mut buf).ok()?;\n-            let (cgroup_path, version) = buf\n-                .split(|&c| c == b'\\n')\n-                .filter_map(|line| {\n+            let (cgroup_path, version) =\n+                buf.split(|&c| c == b'\\n').fold(None, |previous, line| {\n                     let mut fields = line.splitn(3, |&c| c == b':');\n                     // 2nd field is a list of controllers for v1 or empty for v2\n                     let version = match fields.nth(1) {\n-                        Some(b\"\") => Some(Cgroup::V2),\n+                        Some(b\"\") => Cgroup::V2,\n                         Some(controllers)\n                             if from_utf8(controllers)\n                                 .is_ok_and(|c| c.split(\",\").any(|c| c == \"cpu\")) =>\n                         {\n-                            Some(Cgroup::V1)\n+                            Cgroup::V1\n                         }\n-                        _ => None,\n-                    }?;\n+                        _ => return previous,\n+                    };\n+\n+                    // already-found v1 trumps v2 since it explicitly specifies its controllers\n+                    if previous.is_some() && version == Cgroup::V2 {\n+                        return previous;\n+                    }\n \n                     let path = fields.last()?;\n                     // skip leading slash\n                     Some((path[1..].to_owned(), version))\n-                })\n-                .next()?;\n+                })?;\n             let cgroup_path = PathBuf::from(OsString::from_vec(cgroup_path));\n \n             quota = match version {\n@@ -493,31 +504,38 @@ mod cgroups {\n         let mut read_buf = String::with_capacity(20);\n \n         // Hardcode commonly used locations mentioned in the cgroups(7) manpage\n-        // since scanning mountinfo can be expensive on some systems.\n-        // This isn't exactly standardized since cgroupv1 was meant to allow flexibly\n-        // mixing and matching controller hierarchies.\n-        let mounts = [\"/sys/fs/cgroup/cpu\", \"/sys/fs/cgroup/cpu,cpuacct\"];\n+        // if that doesn't work scan mountinfo and adjust `group_path` for bind-mounts\n+        let mounts: &[fn(&Path) -> Option<(_, &Path)>] = &[\n+            |p| Some((Cow::Borrowed(\"/sys/fs/cgroup/cpu\"), p)),\n+            |p| Some((Cow::Borrowed(\"/sys/fs/cgroup/cpu,cpuacct\"), p)),\n+            // this can be expensive on systems with tons of mountpoints\n+            // but we only get to this point when /proc/self/cgroups explicitly indicated\n+            // this process belongs to a cpu-controller cgroup v1 and the defaults didn't work\n+            find_mountpoint,\n+        ];\n \n         for mount in mounts {\n+            let Some((mount, group_path)) = mount(&group_path) else { continue };\n+\n             path.clear();\n-            path.push(mount);\n+            path.push(mount.as_ref());\n             path.push(&group_path);\n \n             // skip if we guessed the mount incorrectly\n             if matches!(try_exists(&path), Err(_) | Ok(false)) {\n                 continue;\n             }\n \n-            while path.starts_with(mount) {\n+            while path.starts_with(mount.as_ref()) {\n                 let mut parse_file = |name| {\n                     path.push(name);\n                     read_buf.clear();\n \n-                    let mut f = File::open(&path).ok()?;\n-                    f.read_to_string(&mut read_buf).ok()?;\n+                    let f = File::open(&path);\n+                    path.pop(); // restore buffer before any early returns\n+                    f.ok()?.read_to_string(&mut read_buf).ok()?;\n                     let parsed = read_buf.trim().parse::<usize>().ok()?;\n \n-                    path.pop();\n                     Some(parsed)\n                 };\n \n@@ -531,10 +549,56 @@ mod cgroups {\n \n                 path.pop();\n             }\n+\n+            // we passed the try_exists above so we should have traversed the correct hierarchy\n+            // when reaching this line\n+            break;\n         }\n \n         quota\n     }\n+\n+    /// Scan mountinfo for cgroup v1 mountpoint with a cpu controller\n+    ///\n+    /// If the cgroupfs is a bind mount then `group_path` is adjusted to skip\n+    /// over the already-included prefix\n+    fn find_mountpoint(group_path: &Path) -> Option<(Cow<'static, str>, &Path)> {\n+        let mut reader = BufReader::new(File::open(\"/proc/self/mountinfo\").ok()?);\n+        let mut line = String::with_capacity(256);\n+        loop {\n+            line.clear();\n+            if reader.read_line(&mut line).ok()? == 0 {\n+                break;\n+            }\n+\n+            let line = line.trim();\n+            let mut items = line.split(' ');\n+\n+            let sub_path = items.nth(3)?;\n+            let mount_point = items.next()?;\n+            let mount_opts = items.next_back()?;\n+            let filesystem_type = items.nth_back(1)?;\n+\n+            if filesystem_type != \"cgroup\" || !mount_opts.split(',').any(|opt| opt == \"cpu\") {\n+                // not a cgroup / not a cpu-controller\n+                continue;\n+            }\n+\n+            let sub_path = Path::new(sub_path).strip_prefix(\"/\").ok()?;\n+\n+            if !group_path.starts_with(sub_path) {\n+                // this is a bind-mount and the bound subdirectory\n+                // does not contain the cgroup this process belongs to\n+                continue;\n+            }\n+\n+            let trimmed_group_path = group_path.strip_prefix(sub_path).ok()?;\n+\n+            return Some((Cow::Owned(mount_point.to_owned()), trimmed_group_path));\n+        }\n+\n+        None\n+    }\n }\n \n #[cfg(all("}]}