{"sha": "578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3OGViNmQ2NWZiZmFhMzBmNmQwYWNkMjdlZDJkNTA2YWE0ZDYxMTc=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-06-10T02:02:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-10T02:02:10Z"}, "message": "Rollup merge of #84687 - a1phyr:improve_rwlock, r=m-ou-se\n\nMultiple improvements to RwLocks\n\nThis PR replicates #77147, #77380 and #84650 on RWLocks :\n- Split `sys_common::RWLock` in `StaticRWLock` and `MovableRWLock`\n- Unbox rwlocks on some platforms (Windows, Wasm and unsupported)\n- Simplify `RwLock::into_inner`\n\nNotes to reviewers :\n- For each target, I copied `MovableMutex` to guess if `MovableRWLock` should be boxed.\n- ~A comment says that `StaticMutex` is not re-entrant, I don't understand why and I don't know whether it applies to `StaticRWLock`.~\n\nr? `@m-ou-se`", "tree": {"sha": "7cc81f1b97b7c4bf8e96bdce889704a6069a2730", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cc81f1b97b7c4bf8e96bdce889704a6069a2730"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgwXKjCRBK7hj4Ov3rIwAA2qUIABKugWRfBXQU0Phm+dKs1F7c\nvEmOvnnT50ZtpqTzg3RxxlGIOMfqubMOEQdxASE2Iiib66nFnDCSTgRrSq0gSrL5\nUjGk8E+tzPsRczCRwZ/NEVKcOdrlAiAsktqdxlwqP+kQXTyoi5bSI+9GJeCVBiXN\nwZpetmq0YCWME3PaSsMC3UxIZ8YsrTT288VSmWqpLjpU1ES8Ql82d3KUOu5ZjBzF\n2nAyVzYhhFGXx9vL2oV/PFC3dNgCGoJrC1T5dILfMtoGvuwwSlJqSgCwovjO8rP6\n9Lt/ISydvjYf+asDIV/+VG7b24LMopNybBNnBqFgwX7SjJ7YRs5RpsFBP3Zf3GM=\n=5twA\n-----END PGP SIGNATURE-----\n", "payload": "tree 7cc81f1b97b7c4bf8e96bdce889704a6069a2730\nparent 27e84b89dae055fef9fd9e705be65c244b54e4c7\nparent ac470e95852336172197810a9a4f6d2e8c8b6574\nauthor Yuki Okushi <jtitor@2k36.org> 1623290530 +0900\ncommitter GitHub <noreply@github.com> 1623290530 +0900\n\nRollup merge of #84687 - a1phyr:improve_rwlock, r=m-ou-se\n\nMultiple improvements to RwLocks\n\nThis PR replicates #77147, #77380 and #84650 on RWLocks :\n- Split `sys_common::RWLock` in `StaticRWLock` and `MovableRWLock`\n- Unbox rwlocks on some platforms (Windows, Wasm and unsupported)\n- Simplify `RwLock::into_inner`\n\nNotes to reviewers :\n- For each target, I copied `MovableMutex` to guess if `MovableRWLock` should be boxed.\n- ~A comment says that `StaticMutex` is not re-entrant, I don't understand why and I don't know whether it applies to `StaticRWLock`.~\n\nr? `@m-ou-se`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117", "html_url": "https://github.com/rust-lang/rust/commit/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27e84b89dae055fef9fd9e705be65c244b54e4c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/27e84b89dae055fef9fd9e705be65c244b54e4c7", "html_url": "https://github.com/rust-lang/rust/commit/27e84b89dae055fef9fd9e705be65c244b54e4c7"}, {"sha": "ac470e95852336172197810a9a4f6d2e8c8b6574", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac470e95852336172197810a9a4f6d2e8c8b6574", "html_url": "https://github.com/rust-lang/rust/commit/ac470e95852336172197810a9a4f6d2e8c8b6574"}], "stats": {"total": 244, "additions": 111, "deletions": 133}, "files": [{"sha": "0b9c9fb479f51dd1f09f37deea5d50beccab494d", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117", "patch": "@@ -19,7 +19,7 @@ use crate::process;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sys::stdio::panic_output;\n use crate::sys_common::backtrace::{self, RustBacktrace};\n-use crate::sys_common::rwlock::RWLock;\n+use crate::sys_common::rwlock::StaticRWLock;\n use crate::sys_common::thread_info;\n use crate::thread;\n \n@@ -74,7 +74,7 @@ enum Hook {\n     Custom(*mut (dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send)),\n }\n \n-static HOOK_LOCK: RWLock = RWLock::new();\n+static HOOK_LOCK: StaticRWLock = StaticRWLock::new();\n static mut HOOK: Hook = Hook::Default;\n \n /// Registers a custom panic hook, replacing any that was previously registered.\n@@ -117,10 +117,10 @@ pub fn set_hook(hook: Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send>) {\n     }\n \n     unsafe {\n-        HOOK_LOCK.write();\n+        let guard = HOOK_LOCK.write();\n         let old_hook = HOOK;\n         HOOK = Hook::Custom(Box::into_raw(hook));\n-        HOOK_LOCK.write_unlock();\n+        drop(guard);\n \n         if let Hook::Custom(ptr) = old_hook {\n             #[allow(unused_must_use)]\n@@ -165,10 +165,10 @@ pub fn take_hook() -> Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send> {\n     }\n \n     unsafe {\n-        HOOK_LOCK.write();\n+        let guard = HOOK_LOCK.write();\n         let hook = HOOK;\n         HOOK = Hook::Default;\n-        HOOK_LOCK.write_unlock();\n+        drop(guard);\n \n         match hook {\n             Hook::Default => Box::new(default_hook),\n@@ -608,7 +608,7 @@ fn rust_panic_with_hook(\n \n     unsafe {\n         let mut info = PanicInfo::internal_constructor(message, location);\n-        HOOK_LOCK.read();\n+        let _guard = HOOK_LOCK.read();\n         match HOOK {\n             // Some platforms (like wasm) know that printing to stderr won't ever actually\n             // print anything, and if that's the case we can skip the default\n@@ -626,7 +626,6 @@ fn rust_panic_with_hook(\n                 (*ptr)(&info);\n             }\n         };\n-        HOOK_LOCK.read_unlock();\n     }\n \n     if panics > 1 {"}, {"sha": "0d00f74eaa1ec839e9356bd729fe7a42b6641ed1", "filename": "library/std/src/sync/rwlock.rs", "status": "modified", "additions": 4, "deletions": 30, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs?ref=578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117", "patch": "@@ -3,9 +3,7 @@ mod tests;\n \n use crate::cell::UnsafeCell;\n use crate::fmt;\n-use crate::mem;\n use crate::ops::{Deref, DerefMut};\n-use crate::ptr;\n use crate::sync::{poison, LockResult, TryLockError, TryLockResult};\n use crate::sys_common::rwlock as sys;\n \n@@ -66,7 +64,7 @@ use crate::sys_common::rwlock as sys;\n /// [`Mutex`]: super::Mutex\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLock<T: ?Sized> {\n-    inner: Box<sys::RWLock>,\n+    inner: sys::MovableRWLock,\n     poison: poison::Flag,\n     data: UnsafeCell<T>,\n }\n@@ -130,7 +128,7 @@ impl<T> RwLock<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> RwLock<T> {\n         RwLock {\n-            inner: box sys::RWLock::new(),\n+            inner: sys::MovableRWLock::new(),\n             poison: poison::Flag::new(),\n             data: UnsafeCell::new(t),\n         }\n@@ -376,24 +374,8 @@ impl<T: ?Sized> RwLock<T> {\n     where\n         T: Sized,\n     {\n-        // We know statically that there are no outstanding references to\n-        // `self` so there's no need to lock the inner lock.\n-        //\n-        // To get the inner value, we'd like to call `data.into_inner()`,\n-        // but because `RwLock` impl-s `Drop`, we can't move out of it, so\n-        // we'll have to destructure it manually instead.\n-        unsafe {\n-            // Like `let RwLock { inner, poison, data } = self`.\n-            let (inner, poison, data) = {\n-                let RwLock { ref inner, ref poison, ref data } = self;\n-                (ptr::read(inner), ptr::read(poison), ptr::read(data))\n-            };\n-            mem::forget(self);\n-            inner.destroy(); // Keep in sync with the `Drop` impl.\n-            drop(inner);\n-\n-            poison::map_result(poison.borrow(), |_| data.into_inner())\n-        }\n+        let data = self.data.into_inner();\n+        poison::map_result(self.poison.borrow(), |_| data)\n     }\n \n     /// Returns a mutable reference to the underlying data.\n@@ -424,14 +406,6 @@ impl<T: ?Sized> RwLock<T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T: ?Sized> Drop for RwLock<T> {\n-    fn drop(&mut self) {\n-        // IMPORTANT: This code needs to be kept in sync with `RwLock::into_inner`.\n-        unsafe { self.inner.destroy() }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "d2058180121dc9dee568f7142bdc51c7dd86b7c8", "filename": "library/std/src/sys/hermit/rwlock.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Frwlock.rs?ref=578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117", "patch": "@@ -8,6 +8,8 @@ pub struct RWLock {\n     state: UnsafeCell<State>,\n }\n \n+pub type MovableRWLock = Box<RWLock>;\n+\n enum State {\n     Unlocked,\n     Reading(usize),"}, {"sha": "2d038b518965b6988ecac528ec5e72ac03c14efd", "filename": "library/std/src/sys/sgx/rwlock.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock.rs?ref=578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117", "patch": "@@ -13,6 +13,8 @@ pub struct RWLock {\n     writer: SpinMutex<WaitVariable<bool>>,\n }\n \n+pub type MovableRWLock = Box<RWLock>;\n+\n // Check at compile time that RWLock size matches C definition (see test_c_rwlock_initializer below)\n //\n // # Safety"}, {"sha": "41ca9762390c6f4a5f0cc32c89b4e13d52a5d5e3", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117", "patch": "@@ -20,8 +20,7 @@ use crate::str;\n use crate::sys::cvt;\n use crate::sys::fd;\n use crate::sys::memchr;\n-use crate::sys::rwlock::{RWLockReadGuard, StaticRWLock};\n-use crate::sys_common::mutex::{StaticMutex, StaticMutexGuard};\n+use crate::sys_common::rwlock::{StaticRWLock, StaticRWLockReadGuard};\n use crate::vec;\n \n use libc::{c_char, c_int, c_void};\n@@ -490,8 +489,8 @@ pub unsafe fn environ() -> *mut *const *const c_char {\n \n static ENV_LOCK: StaticRWLock = StaticRWLock::new();\n \n-pub fn env_read_lock() -> RWLockReadGuard {\n-    ENV_LOCK.read_with_guard()\n+pub fn env_read_lock() -> StaticRWLockReadGuard {\n+    ENV_LOCK.read()\n }\n \n /// Returns a vector of (variable, value) byte-vector pairs for all the\n@@ -551,7 +550,7 @@ pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n     let v = CString::new(v.as_bytes())?;\n \n     unsafe {\n-        let _guard = ENV_LOCK.write_with_guard();\n+        let _guard = ENV_LOCK.write();\n         cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(drop)\n     }\n }\n@@ -560,7 +559,7 @@ pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n     let nbuf = CString::new(n.as_bytes())?;\n \n     unsafe {\n-        let _guard = ENV_LOCK.write_with_guard();\n+        let _guard = ENV_LOCK.write();\n         cvt(libc::unsetenv(nbuf.as_ptr())).map(drop)\n     }\n }"}, {"sha": "b1faf12c2261452e1b191c8a91f3b2810ae0a3ff", "filename": "library/std/src/sys/unix/rwlock.rs", "status": "modified", "additions": 2, "deletions": 52, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frwlock.rs?ref=578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117", "patch": "@@ -7,6 +7,8 @@ pub struct RWLock {\n     num_readers: AtomicUsize,\n }\n \n+pub type MovableRWLock = Box<RWLock>;\n+\n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n \n@@ -139,55 +141,3 @@ impl RWLock {\n         }\n     }\n }\n-\n-pub struct StaticRWLock(RWLock);\n-\n-impl StaticRWLock {\n-    pub const fn new() -> StaticRWLock {\n-        StaticRWLock(RWLock::new())\n-    }\n-\n-    /// Acquires shared access to the underlying lock, blocking the current\n-    /// thread to do so.\n-    ///\n-    /// The lock is automatically unlocked when the returned guard is dropped.\n-    #[inline]\n-    pub fn read_with_guard(&'static self) -> RWLockReadGuard {\n-        // SAFETY: All methods require static references, therefore self\n-        // cannot be moved between invocations.\n-        unsafe {\n-            self.0.read();\n-        }\n-        RWLockReadGuard(&self.0)\n-    }\n-\n-    /// Acquires write access to the underlying lock, blocking the current thread\n-    /// to do so.\n-    ///\n-    /// The lock is automatically unlocked when the returned guard is dropped.\n-    #[inline]\n-    pub fn write_with_guard(&'static self) -> RWLockWriteGuard {\n-        // SAFETY: All methods require static references, therefore self\n-        // cannot be moved between invocations.\n-        unsafe {\n-            self.0.write();\n-        }\n-        RWLockWriteGuard(&self.0)\n-    }\n-}\n-\n-pub struct RWLockReadGuard(&'static RWLock);\n-\n-impl Drop for RWLockReadGuard {\n-    fn drop(&mut self) {\n-        unsafe { self.0.read_unlock() }\n-    }\n-}\n-\n-pub struct RWLockWriteGuard(&'static RWLock);\n-\n-impl Drop for RWLockWriteGuard {\n-    fn drop(&mut self) {\n-        unsafe { self.0.write_unlock() }\n-    }\n-}"}, {"sha": "8438adeb5b533b6098daa9d8535effc57a62cd5b", "filename": "library/std/src/sys/unsupported/rwlock.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Frwlock.rs?ref=578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117", "patch": "@@ -5,6 +5,8 @@ pub struct RWLock {\n     mode: Cell<isize>,\n }\n \n+pub type MovableRWLock = RWLock;\n+\n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {} // no threads on this platform\n "}, {"sha": "64eaa2fc482dc2ee31706d37e5a8515e6dee774d", "filename": "library/std/src/sys/wasm/atomics/rwlock.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Frwlock.rs?ref=578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117", "patch": "@@ -8,6 +8,8 @@ pub struct RWLock {\n     state: UnsafeCell<State>,\n }\n \n+pub type MovableRWLock = RWLock;\n+\n enum State {\n     Unlocked,\n     Reading(usize),"}, {"sha": "b7a5b1e7accd0cb9b3188a58543ec0648d1649e1", "filename": "library/std/src/sys/windows/rwlock.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frwlock.rs?ref=578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117", "patch": "@@ -5,6 +5,8 @@ pub struct RWLock {\n     inner: UnsafeCell<c::SRWLOCK>,\n }\n \n+pub type MovableRWLock = RWLock;\n+\n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n "}, {"sha": "07ec20f4dc6177fa0c4642ac9e96bab00d9affd7", "filename": "library/std/src/sys_common/rwlock.rs", "status": "modified", "additions": 83, "deletions": 37, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs?ref=578eb6d65fbfaa30f6d0acd27ed2d506aa4d6117", "patch": "@@ -1,63 +1,112 @@\n use crate::sys::rwlock as imp;\n \n+/// An OS-based reader-writer lock, meant for use in static variables.\n+///\n+/// This rwlock does not implement poisoning.\n+///\n+/// This rwlock has a const constructor ([`StaticRWLock::new`]), does not\n+/// implement `Drop` to cleanup resources.\n+pub struct StaticRWLock(imp::RWLock);\n+\n+impl StaticRWLock {\n+    /// Creates a new rwlock for use.\n+    pub const fn new() -> Self {\n+        Self(imp::RWLock::new())\n+    }\n+\n+    /// Acquires shared access to the underlying lock, blocking the current\n+    /// thread to do so.\n+    ///\n+    /// The lock is automatically unlocked when the returned guard is dropped.\n+    #[inline]\n+    pub fn read(&'static self) -> StaticRWLockReadGuard {\n+        unsafe { self.0.read() };\n+        StaticRWLockReadGuard(&self.0)\n+    }\n+\n+    /// Acquires write access to the underlying lock, blocking the current thread\n+    /// to do so.\n+    ///\n+    /// The lock is automatically unlocked when the returned guard is dropped.\n+    #[inline]\n+    pub fn write(&'static self) -> StaticRWLockWriteGuard {\n+        unsafe { self.0.write() };\n+        StaticRWLockWriteGuard(&self.0)\n+    }\n+}\n+\n+#[must_use]\n+pub struct StaticRWLockReadGuard(&'static imp::RWLock);\n+\n+impl Drop for StaticRWLockReadGuard {\n+    #[inline]\n+    fn drop(&mut self) {\n+        unsafe {\n+            self.0.read_unlock();\n+        }\n+    }\n+}\n+\n+#[must_use]\n+pub struct StaticRWLockWriteGuard(&'static imp::RWLock);\n+\n+impl Drop for StaticRWLockWriteGuard {\n+    #[inline]\n+    fn drop(&mut self) {\n+        unsafe {\n+            self.0.write_unlock();\n+        }\n+    }\n+}\n+\n /// An OS-based reader-writer lock.\n ///\n-/// This structure is entirely unsafe and serves as the lowest layer of a\n-/// cross-platform binding of system rwlocks. It is recommended to use the\n-/// safer types at the top level of this crate instead of this type.\n-pub struct RWLock(imp::RWLock);\n+/// This rwlock does *not* have a const constructor, cleans up its resources in\n+/// its `Drop` implementation and may safely be moved (when not borrowed).\n+///\n+/// This rwlock does not implement poisoning.\n+///\n+/// This is either a wrapper around `Box<imp::RWLock>` or `imp::RWLock`,\n+/// depending on the platform. It is boxed on platforms where `imp::RWLock` may\n+/// not be moved.\n+pub struct MovableRWLock(imp::MovableRWLock);\n \n-impl RWLock {\n+impl MovableRWLock {\n     /// Creates a new reader-writer lock for use.\n-    ///\n-    /// Behavior is undefined if the reader-writer lock is moved after it is\n-    /// first used with any of the functions below.\n-    pub const fn new() -> RWLock {\n-        RWLock(imp::RWLock::new())\n+    pub fn new() -> Self {\n+        Self(imp::MovableRWLock::from(imp::RWLock::new()))\n     }\n \n     /// Acquires shared access to the underlying lock, blocking the current\n     /// thread to do so.\n-    ///\n-    /// Behavior is undefined if the rwlock has been moved between this and any\n-    /// previous method call.\n     #[inline]\n-    pub unsafe fn read(&self) {\n-        self.0.read()\n+    pub fn read(&self) {\n+        unsafe { self.0.read() }\n     }\n \n     /// Attempts to acquire shared access to this lock, returning whether it\n     /// succeeded or not.\n     ///\n     /// This function does not block the current thread.\n-    ///\n-    /// Behavior is undefined if the rwlock has been moved between this and any\n-    /// previous method call.\n     #[inline]\n-    pub unsafe fn try_read(&self) -> bool {\n-        self.0.try_read()\n+    pub fn try_read(&self) -> bool {\n+        unsafe { self.0.try_read() }\n     }\n \n     /// Acquires write access to the underlying lock, blocking the current thread\n     /// to do so.\n-    ///\n-    /// Behavior is undefined if the rwlock has been moved between this and any\n-    /// previous method call.\n     #[inline]\n-    pub unsafe fn write(&self) {\n-        self.0.write()\n+    pub fn write(&self) {\n+        unsafe { self.0.write() }\n     }\n \n     /// Attempts to acquire exclusive access to this lock, returning whether it\n     /// succeeded or not.\n     ///\n     /// This function does not block the current thread.\n-    ///\n-    /// Behavior is undefined if the rwlock has been moved between this and any\n-    /// previous method call.\n     #[inline]\n-    pub unsafe fn try_write(&self) -> bool {\n-        self.0.try_write()\n+    pub fn try_write(&self) -> bool {\n+        unsafe { self.0.try_write() }\n     }\n \n     /// Unlocks previously acquired shared access to this lock.\n@@ -76,13 +125,10 @@ impl RWLock {\n     pub unsafe fn write_unlock(&self) {\n         self.0.write_unlock()\n     }\n+}\n \n-    /// Destroys OS-related resources with this RWLock.\n-    ///\n-    /// Behavior is undefined if there are any currently active users of this\n-    /// lock.\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        self.0.destroy()\n+impl Drop for MovableRWLock {\n+    fn drop(&mut self) {\n+        unsafe { self.0.destroy() };\n     }\n }"}]}