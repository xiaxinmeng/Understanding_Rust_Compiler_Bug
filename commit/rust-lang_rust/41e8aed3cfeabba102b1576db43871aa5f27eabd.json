{"sha": "41e8aed3cfeabba102b1576db43871aa5f27eabd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxZThhZWQzY2ZlYWJiYTEwMmIxNTc2ZGI0Mzg3MWFhNWYyN2VhYmQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T12:01:59Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T17:57:05Z"}, "message": "typeck/pat.rs: `check_pat_walk` -> `check_pat`.\n\nIt's just shorter and we usually don't use the `_walk` suffix.", "tree": {"sha": "dba0b6446da6569c0e562e6e8b58bdd2c3aec0c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dba0b6446da6569c0e562e6e8b58bdd2c3aec0c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41e8aed3cfeabba102b1576db43871aa5f27eabd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41e8aed3cfeabba102b1576db43871aa5f27eabd", "html_url": "https://github.com/rust-lang/rust/commit/41e8aed3cfeabba102b1576db43871aa5f27eabd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41e8aed3cfeabba102b1576db43871aa5f27eabd/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65deeae76dfcb8d0aeb389bbe12ef9990caf2f6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/65deeae76dfcb8d0aeb389bbe12ef9990caf2f6f", "html_url": "https://github.com/rust-lang/rust/commit/65deeae76dfcb8d0aeb389bbe12ef9990caf2f6f"}], "stats": {"total": 44, "additions": 19, "deletions": 25}, "files": [{"sha": "083d41f0963a624dc14ecee1463fe3997b9d1f0f", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/41e8aed3cfeabba102b1576db43871aa5f27eabd/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e8aed3cfeabba102b1576db43871aa5f27eabd/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=41e8aed3cfeabba102b1576db43871aa5f27eabd", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         discrim_span: Option<Span>,\n     ) {\n         let def_bm = ty::BindingMode::BindByValue(hir::Mutability::MutImmutable);\n-        self.check_pat_walk(pat, expected, def_bm, discrim_span);\n+        self.check_pat(pat, expected, def_bm, discrim_span);\n     }\n \n     /// `discrim_span` argument having a `Span` indicates that this pattern is part of a match\n@@ -55,14 +55,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///   = note: expected type `usize`\n     ///              found type `std::result::Result<_, _>`\n     /// ```\n-    fn check_pat_walk(\n+    fn check_pat(\n         &self,\n         pat: &'tcx hir::Pat,\n         expected: Ty<'tcx>,\n         def_bm: ty::BindingMode,\n         discrim_span: Option<Span>,\n     ) {\n-        debug!(\"check_pat_walk(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n+        debug!(\"check_pat(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n \n         let path_resolution = match &pat.node {\n             PatKind::Path(qpath) => Some(self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span)),\n@@ -104,7 +104,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             PatKind::Or(pats) => {\n                 let expected_ty = self.structurally_resolved_type(pat.span, expected);\n                 for pat in pats {\n-                    self.check_pat_walk(pat, expected, def_bm, discrim_span);\n+                    self.check_pat(pat, expected, def_bm, discrim_span);\n                 }\n                 expected_ty\n             }\n@@ -456,7 +456,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let Some(p) = sub {\n-            self.check_pat_walk(&p, expected, def_bm, discrim_span);\n+            self.check_pat(&p, expected, def_bm, discrim_span);\n         }\n \n         local_ty\n@@ -544,7 +544,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             variant_ty\n         } else {\n             for field in fields {\n-                self.check_pat_walk(&field.pat, self.tcx.types.err, def_bm, discrim_span);\n+                self.check_pat(&field.pat, self.tcx.types.err, def_bm, discrim_span);\n             }\n             return self.tcx.types.err;\n         };\n@@ -607,7 +607,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n         let on_error = || {\n             for pat in subpats {\n-                self.check_pat_walk(&pat, tcx.types.err, def_bm, match_arm_pat_span);\n+                self.check_pat(&pat, tcx.types.err, def_bm, match_arm_pat_span);\n             }\n         };\n         let report_unexpected_res = |res: Res| {\n@@ -677,7 +677,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n-                self.check_pat_walk(&subpat, field_ty, def_bm, match_arm_pat_span);\n+                self.check_pat(&subpat, field_ty, def_bm, match_arm_pat_span);\n \n                 self.tcx.check_stability(variant.fields[i].did, Some(pat.hir_id), subpat.span);\n             }\n@@ -734,17 +734,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // further errors being emitted when using the bindings. #50333\n             let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n             for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                self.check_pat_walk(elem, &tcx.types.err, def_bm, discrim_span);\n+                self.check_pat(elem, &tcx.types.err, def_bm, discrim_span);\n             }\n             tcx.mk_tup(element_tys_iter)\n         } else {\n             for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                self.check_pat_walk(\n-                    elem,\n-                    &element_tys[i].expect_ty(),\n-                    def_bm,\n-                    discrim_span,\n-                );\n+                self.check_pat(elem, &element_tys[i].expect_ty(), def_bm, discrim_span);\n             }\n             pat_ty\n         }\n@@ -813,7 +808,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             };\n \n-            self.check_pat_walk(&field.pat, field_ty, def_bm, None);\n+            self.check_pat(&field.pat, field_ty, def_bm, None);\n         }\n         let mut unmentioned_fields = variant.fields\n                 .iter()\n@@ -941,13 +936,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if self.check_dereferencable(span, expected, &inner) {\n             // Here, `demand::subtype` is good enough, but I don't\n-            // think any errors can be introduced by using\n-            // `demand::eqtype`.\n+            // think any errors can be introduced by using `demand::eqtype`.\n             self.demand_eqtype_pat(span, expected, uniq_ty, discrim_span);\n-            self.check_pat_walk(&inner, inner_ty, def_bm, discrim_span);\n+            self.check_pat(&inner, inner_ty, def_bm, discrim_span);\n             uniq_ty\n         } else {\n-            self.check_pat_walk(&inner, tcx.types.err, def_bm, discrim_span);\n+            self.check_pat(&inner, tcx.types.err, def_bm, discrim_span);\n             tcx.types.err\n         }\n     }\n@@ -998,10 +992,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             };\n \n-            self.check_pat_walk(&inner, inner_ty, def_bm, discrim_span);\n+            self.check_pat(&inner, inner_ty, def_bm, discrim_span);\n             rptr_ty\n         } else {\n-            self.check_pat_walk(&inner, tcx.types.err, def_bm, discrim_span);\n+            self.check_pat(&inner, tcx.types.err, def_bm, discrim_span);\n             tcx.types.err\n         }\n     }\n@@ -1079,13 +1073,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         for elt in before {\n-            self.check_pat_walk(&elt, inner_ty, def_bm, discrim_span);\n+            self.check_pat(&elt, inner_ty, def_bm, discrim_span);\n         }\n         if let Some(slice) = slice {\n-            self.check_pat_walk(&slice, slice_ty, def_bm, discrim_span);\n+            self.check_pat(&slice, slice_ty, def_bm, discrim_span);\n         }\n         for elt in after {\n-            self.check_pat_walk(&elt, inner_ty, def_bm, discrim_span);\n+            self.check_pat(&elt, inner_ty, def_bm, discrim_span);\n         }\n         expected_ty\n     }"}]}