{"sha": "078220daa89f060eba85251d0e9eebdcd69b4dc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3ODIyMGRhYTg5ZjA2MGViYTg1MjUxZDBlOWVlYmRjZDY5YjRkYzg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-23T18:27:49Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-25T03:38:21Z"}, "message": "extract a `best_blame_constraint` helper", "tree": {"sha": "73eb5ed1741a471949b04e99e99b92c58655d599", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73eb5ed1741a471949b04e99e99b92c58655d599"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/078220daa89f060eba85251d0e9eebdcd69b4dc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/078220daa89f060eba85251d0e9eebdcd69b4dc8", "html_url": "https://github.com/rust-lang/rust/commit/078220daa89f060eba85251d0e9eebdcd69b4dc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/078220daa89f060eba85251d0e9eebdcd69b4dc8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ba4d33e4345b14c78fcbdf72959d4a0232e46f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ba4d33e4345b14c78fcbdf72959d4a0232e46f4", "html_url": "https://github.com/rust-lang/rust/commit/9ba4d33e4345b14c78fcbdf72959d4a0232e46f4"}], "stats": {"total": 186, "additions": 123, "deletions": 63}, "files": [{"sha": "054af74881957377d67babedc8bc714ca675de9b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 123, "deletions": 63, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/078220daa89f060eba85251d0e9eebdcd69b4dc8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/078220daa89f060eba85251d0e9eebdcd69b4dc8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=078220daa89f060eba85251d0e9eebdcd69b4dc8", "patch": "@@ -28,7 +28,7 @@ mod var_name;\n /// Constraints that are considered interesting can be categorized to\n /// determine why they are interesting. Order of variants indicates\n /// sort order of the category, thereby influencing diagnostic output.\n-#[derive(Debug, Eq, PartialEq, PartialOrd, Ord)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]\n enum ConstraintCategory {\n     Cast,\n     Assignment,\n@@ -43,12 +43,14 @@ enum ConstraintCategory {\n impl fmt::Display for ConstraintCategory {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self {\n-            ConstraintCategory::Assignment |\n-            ConstraintCategory::AssignmentToUpvar => write!(f, \"assignment\"),\n+            ConstraintCategory::Assignment | ConstraintCategory::AssignmentToUpvar => {\n+                write!(f, \"assignment\")\n+            }\n             ConstraintCategory::Return => write!(f, \"return\"),\n             ConstraintCategory::Cast => write!(f, \"cast\"),\n-            ConstraintCategory::CallArgument |\n-            ConstraintCategory::CallArgumentToUpvar => write!(f, \"argument\"),\n+            ConstraintCategory::CallArgument | ConstraintCategory::CallArgumentToUpvar => {\n+                write!(f, \"argument\")\n+            }\n             _ => write!(f, \"free region\"),\n         }\n     }\n@@ -62,6 +64,43 @@ enum Trace {\n }\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n+    /// Tries to find the best constraint to blame for the fact that\n+    /// `R: from_region`, where `R` is some region that meets\n+    /// `target_test`. This works by following the constraint graph,\n+    /// creating a constraint path that forces `R` to outlive\n+    /// `from_region`, and then finding the best choices within that\n+    /// path to blame.\n+    fn best_blame_constraint(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        from_region: RegionVid,\n+        target_test: impl Fn(RegionVid) -> bool,\n+    ) -> (ConstraintCategory, Span) {\n+        debug!(\"best_blame_constraint(from_region={:?})\", from_region);\n+\n+        // Find all paths\n+        let path = self\n+            .find_constraint_paths_between_regions(from_region, target_test)\n+            .unwrap();\n+        debug!(\"best_blame_constraint: path={:#?}\", path);\n+\n+        // Classify each of the constraints along the path.\n+        let mut categorized_path: Vec<(ConstraintCategory, Span)> = path\n+            .iter()\n+            .map(|&index| self.classify_constraint(index, mir))\n+            .collect();\n+        debug!(\n+            \"best_blame_constraint: categorized_path={:?}\",\n+            categorized_path\n+        );\n+\n+        // Find what appears to be the most interesting path to report to the user.\n+        categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n+        debug!(\"best_blame_constraint: sorted_path={:?}\", categorized_path);\n+\n+        *categorized_path.first().unwrap()\n+    }\n+\n     /// Walks the graph of constraints (where `'a: 'b` is considered\n     /// an edge `'a -> 'b`) to find all paths from `from_region` to\n     /// `to_region`. The paths are accumulated into the vector\n@@ -89,7 +128,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 let mut p = r;\n                 loop {\n                     match context[p] {\n-                        Trace::NotVisited => bug!(\"found unvisited region {:?} on path to {:?}\", p, r),\n+                        Trace::NotVisited => {\n+                            bug!(\"found unvisited region {:?} on path to {:?}\", p, r)\n+                        }\n                         Trace::FromConstraint(c) => {\n                             result.push(c);\n                             p = self.constraints[c].sup;\n@@ -139,19 +180,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         index: ConstraintIndex,\n         mir: &Mir<'tcx>,\n-        _infcx: &InferCtxt<'_, '_, 'tcx>,\n     ) -> (ConstraintCategory, Span) {\n         let constraint = self.constraints[index];\n         debug!(\"classify_constraint: constraint={:?}\", constraint);\n         let span = constraint.locations.span(mir);\n-        let location = constraint.locations.from_location().unwrap_or(Location::START);\n+        let location = constraint\n+            .locations\n+            .from_location()\n+            .unwrap_or(Location::START);\n \n         if !self.constraint_is_interesting(index) {\n             return (ConstraintCategory::Boring, span);\n         }\n \n         let data = &mir[location.block];\n-        debug!(\"classify_constraint: location={:?} data={:?}\", location, data);\n+        debug!(\n+            \"classify_constraint: location={:?} data={:?}\",\n+            location, data\n+        );\n         let category = if location.statement_index == data.statements.len() {\n             if let Some(ref terminator) = data.terminator {\n                 debug!(\"classify_constraint: terminator.kind={:?}\", terminator.kind);\n@@ -174,8 +220,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     } else {\n                         match rvalue {\n                             Rvalue::Cast(..) => ConstraintCategory::Cast,\n-                            Rvalue::Use(..) |\n-                            Rvalue::Aggregate(..) => ConstraintCategory::Assignment,\n+                            Rvalue::Use(..) | Rvalue::Aggregate(..) => {\n+                                ConstraintCategory::Assignment\n+                            }\n                             _ => ConstraintCategory::Other,\n                         }\n                     }\n@@ -206,27 +253,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        // Find all paths\n-        let path = self.find_constraint_paths_between_regions(fr, |r| r == outlived_fr).unwrap();\n-        debug!(\"report_error: path={:#?}\", path);\n-\n-        // Classify each of the constraints along the path.\n-        let mut categorized_path: Vec<(ConstraintCategory, Span)> = path.iter()\n-            .map(|&index| self.classify_constraint(index, mir, infcx))\n-            .collect();\n-        debug!(\"report_error: categorized_path={:?}\", categorized_path);\n-\n-        // Find what appears to be the most interesting path to report to the user.\n-        categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n-        debug!(\"report_error: sorted_path={:?}\", categorized_path);\n-\n-        // Get a span\n-        let (category, span) = categorized_path.first().unwrap();\n+        let (category, span) = self.best_blame_constraint(mir, fr, |r| r == outlived_fr);\n \n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n             let tables = infcx.tcx.typeck_tables_of(mir_def_id);\n-            let nice = NiceRegionError::new_from_span(infcx.tcx, *span, o, f, Some(tables));\n+            let nice = NiceRegionError::new_from_span(infcx.tcx, span, o, f, Some(tables));\n             if let Some(_error_reported) = nice.try_report() {\n                 return;\n             }\n@@ -237,22 +269,36 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.universal_regions.is_local_free_region(fr),\n             self.universal_regions.is_local_free_region(outlived_fr),\n         ) {\n-            (ConstraintCategory::Assignment, true, false) =>\n-                &ConstraintCategory::AssignmentToUpvar,\n-            (ConstraintCategory::CallArgument, true, false) =>\n-                &ConstraintCategory::CallArgumentToUpvar,\n+            (ConstraintCategory::Assignment, true, false) => ConstraintCategory::AssignmentToUpvar,\n+            (ConstraintCategory::CallArgument, true, false) => {\n+                ConstraintCategory::CallArgumentToUpvar\n+            }\n             (category, _, _) => category,\n         };\n \n         debug!(\"report_error: category={:?}\", category);\n         match category {\n-            ConstraintCategory::AssignmentToUpvar |\n-            ConstraintCategory::CallArgumentToUpvar =>\n-                self.report_closure_error(\n-                    mir, infcx, mir_def_id, fr, outlived_fr, category, span, errors_buffer),\n-            _ =>\n-                self.report_general_error(\n-                    mir, infcx, mir_def_id, fr, outlived_fr, category, span, errors_buffer),\n+            ConstraintCategory::AssignmentToUpvar | ConstraintCategory::CallArgumentToUpvar => self\n+                .report_closure_error(\n+                    mir,\n+                    infcx,\n+                    mir_def_id,\n+                    fr,\n+                    outlived_fr,\n+                    category,\n+                    span,\n+                    errors_buffer,\n+                ),\n+            _ => self.report_general_error(\n+                mir,\n+                infcx,\n+                mir_def_id,\n+                fr,\n+                outlived_fr,\n+                category,\n+                span,\n+                errors_buffer,\n+            ),\n         }\n     }\n \n@@ -263,23 +309,31 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         fr: RegionVid,\n         outlived_fr: RegionVid,\n-        category: &ConstraintCategory,\n-        span: &Span,\n+        category: ConstraintCategory,\n+        span: Span,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n-        let fr_name_and_span  = self.get_var_name_and_span_for_region(\n-            infcx.tcx, mir, fr);\n-        let outlived_fr_name_and_span = self.get_var_name_and_span_for_region(\n-            infcx.tcx, mir,outlived_fr);\n+        let fr_name_and_span = self.get_var_name_and_span_for_region(infcx.tcx, mir, fr);\n+        let outlived_fr_name_and_span =\n+            self.get_var_name_and_span_for_region(infcx.tcx, mir, outlived_fr);\n \n         if fr_name_and_span.is_none() && outlived_fr_name_and_span.is_none() {\n             return self.report_general_error(\n-                mir, infcx, mir_def_id, fr, outlived_fr, category, span, errors_buffer);\n+                mir,\n+                infcx,\n+                mir_def_id,\n+                fr,\n+                outlived_fr,\n+                category,\n+                span,\n+                errors_buffer,\n+            );\n         }\n \n-        let mut diag = infcx.tcx.sess.struct_span_err(\n-            *span, &format!(\"borrowed data escapes outside of closure\"),\n-        );\n+        let mut diag = infcx\n+            .tcx\n+            .sess\n+            .struct_span_err(span, &format!(\"borrowed data escapes outside of closure\"));\n \n         if let Some((outlived_fr_name, outlived_fr_span)) = outlived_fr_name_and_span {\n             if let Some(name) = outlived_fr_name {\n@@ -294,10 +348,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if let Some(name) = fr_name {\n                 diag.span_label(\n                     fr_span,\n-                    format!(\"`{}` is a reference that is only valid in the closure body\", name),\n+                    format!(\n+                        \"`{}` is a reference that is only valid in the closure body\",\n+                        name\n+                    ),\n                 );\n \n-                diag.span_label(*span, format!(\"`{}` escapes the closure body here\", name));\n+                diag.span_label(span, format!(\"`{}` escapes the closure body here\", name));\n             }\n         }\n \n@@ -311,24 +368,27 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         fr: RegionVid,\n         outlived_fr: RegionVid,\n-        category: &ConstraintCategory,\n-        span: &Span,\n+        category: ConstraintCategory,\n+        span: Span,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n         let mut diag = infcx.tcx.sess.struct_span_err(\n-            *span, &format!(\"unsatisfied lifetime constraints\"), // FIXME\n+            span,\n+            &format!(\"unsatisfied lifetime constraints\"), // FIXME\n         );\n \n         let counter = &mut 1;\n-        let fr_name = self.give_region_a_name(\n-            infcx.tcx, mir, mir_def_id, fr, counter, &mut diag);\n-        let outlived_fr_name = self.give_region_a_name(\n-            infcx.tcx, mir, mir_def_id, outlived_fr, counter, &mut diag);\n-\n-        diag.span_label(*span, format!(\n-            \"{} requires that `{}` must outlive `{}`\",\n-            category, fr_name, outlived_fr_name,\n-        ));\n+        let fr_name = self.give_region_a_name(infcx.tcx, mir, mir_def_id, fr, counter, &mut diag);\n+        let outlived_fr_name =\n+            self.give_region_a_name(infcx.tcx, mir, mir_def_id, outlived_fr, counter, &mut diag);\n+\n+        diag.span_label(\n+            span,\n+            format!(\n+                \"{} requires that `{}` must outlive `{}`\",\n+                category, fr_name, outlived_fr_name,\n+            ),\n+        );\n \n         diag.buffer(errors_buffer);\n     }"}]}