{"sha": "b355936b4da0831f47afe8f251daee503c8caa32", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNTU5MzZiNGRhMDgzMWY0N2FmZThmMjUxZGFlZTUwM2M4Y2FhMzI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-02T00:30:05Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-02T02:16:06Z"}, "message": "Convert ret to return", "tree": {"sha": "9f870e26f773af714cbcf7f315de5ff3722300c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f870e26f773af714cbcf7f315de5ff3722300c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b355936b4da0831f47afe8f251daee503c8caa32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b355936b4da0831f47afe8f251daee503c8caa32", "html_url": "https://github.com/rust-lang/rust/commit/b355936b4da0831f47afe8f251daee503c8caa32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b355936b4da0831f47afe8f251daee503c8caa32/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc499f193e473abc78c557feaa86969bbe7aa159", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc499f193e473abc78c557feaa86969bbe7aa159", "html_url": "https://github.com/rust-lang/rust/commit/dc499f193e473abc78c557feaa86969bbe7aa159"}], "stats": {"total": 7683, "additions": 3880, "deletions": 3803}, "files": [{"sha": "30886f48e19079d4f956ff36f135f1f8457c4e56", "filename": "doc/rust.md", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -219,7 +219,7 @@ if impl import\n let log loop\n mod mut\n pure\n-ret\n+return\n true trait type\n unchecked unsafe\n while\n@@ -841,17 +841,17 @@ value has the corresponding [*function type*](#function-types), and can be\n used otherwise exactly as a function item (with a minor additional cost of\n calling the function indirectly).\n \n-Every control path in a function logically ends with a `ret` expression or a\n+Every control path in a function logically ends with a `return` expression or a\n diverging expression. If the outermost block of a function has a\n value-producing expression in its final-expression position, that expression\n-is interpreted as an implicit `ret` expression applied to the\n+is interpreted as an implicit `return` expression applied to the\n final-expression.\n \n An example of a function:\n \n ~~~~\n fn add(x: int, y: int) -> int {\n-    ret x + y;\n+    return x + y;\n }\n ~~~~\n \n@@ -876,7 +876,7 @@ unifies with any type. Rust has no syntax for $\\bot$.\n \n It might be necessary to declare a diverging function because as mentioned\n previously, the typechecker checks that every control path in a function ends\n-with a [`ret`](#return-expressions) or diverging expression. So, if `my_err`\n+with a [`return`](#return-expressions) or diverging expression. So, if `my_err`\n were declared without the `!` annotation, the following code would not\n typecheck:\n \n@@ -885,7 +885,7 @@ typecheck:\n \n fn f(i: int) -> int {\n    if i == 42 {\n-     ret 42;\n+     return 42;\n    }\n    else {\n      my_err(~\"Bad number!\");\n@@ -895,7 +895,7 @@ fn f(i: int) -> int {\n \n The typechecker would complain that `f` doesn't return a value in the\n `else` branch. Adding the `!` annotation on `my_err` would\n-express that `f` requires no explicit `ret`, as if it returns\n+express that `f` requires no explicit `return`, as if it returns\n control to the caller, it returns a value (true because it never returns\n control).\n \n@@ -915,7 +915,7 @@ An example of a predicate:\n \n ~~~~\n pure fn lt_42(x: int) -> bool {\n-    ret (x < 42);\n+    return (x < 42);\n }\n ~~~~\n \n@@ -1845,7 +1845,7 @@ An example of an `as` expression:\n fn avg(v: ~[float]) -> float {\n   let sum: float = sum(v);\n   let sz: float = len(v) as float;\n-  ret sum / sz;\n+  return sum / sz;\n }\n ~~~~\n \n@@ -2079,21 +2079,21 @@ For a block `b`, the expression `loop b` is semantically equivalent to\n typestate analysis pass takes into account that `loop`s are infinite.\n \n For example, the following (contrived) function uses a `loop` with a\n-`ret` expression:\n+`return` expression:\n \n ~~~~\n fn count() -> bool {\n   let mut i = 0;\n   loop {\n     i += 1;\n-    if i == 20 { ret true; }\n+    if i == 20 { return true; }\n   }\n }\n ~~~~\n \n This function compiles, because typestate recognizes that the `loop`\n-never terminates (except non-locally, with `ret`), thus there is no\n-need to insert a spurious `fail` or `ret` after the `loop`. If `loop`\n+never terminates (except non-locally, with `return`), thus there is no\n+need to insert a spurious `fail` or `return` after the `loop`. If `loop`\n were replaced with `while true`, the function would be rejected\n because from the compiler's perspective, there would be a control path\n along which `count` does not return a value (that is, if the loop\n@@ -2200,7 +2200,7 @@ let x: list<int> = cons(10, @cons(11, @nil));\n \n alt x {\n     cons(_, @nil) { fail ~\"singleton list\"; }\n-    cons(*)       { ret; }\n+    cons(*)       { return; }\n     nil           { fail ~\"empty list\"; }\n }\n ~~~~\n@@ -2235,7 +2235,7 @@ alt x {\n         process_ten();\n     }\n     nil {\n-        ret;\n+        return;\n     }\n     _ {\n         fail;\n@@ -2353,7 +2353,7 @@ fn read_file_lines(path: ~str) -> ~[~str] {\n     lines(f) |s| {\n         r += ~[s];\n     }\n-    ret r;\n+    return r;\n }\n ~~~~\n \n@@ -2372,23 +2372,23 @@ expression.\n ### Return expressions\n \n ~~~~~~~~{.ebnf .gram}\n-ret_expr : \"ret\" expr ? ;\n+return_expr : \"return\" expr ? ;\n ~~~~~~~~\n \n-Return expressions are denoted with the keyword `ret`. Evaluating a `ret`\n-expression^[A `ret` expression is analogous to a `return` expression\n+Return expressions are denoted with the keyword `return`. Evaluating a `return`\n+expression^[A `return` expression is analogous to a `return` expression\n in the C family.] moves its argument into the output slot of the current\n function, destroys the current function activation frame, and transfers\n control to the caller frame.\n \n-An example of a `ret` expression:\n+An example of a `return` expression:\n \n ~~~~\n fn max(a: int, b: int) -> int {\n    if a > b {\n-      ret a;\n+      return a;\n    }\n-   ret b;\n+   return b;\n }\n ~~~~\n \n@@ -2738,7 +2738,7 @@ An example of a `fn` type:\n \n ~~~~~~~~\n fn add(x: int, y: int) -> int {\n-  ret x + y;\n+  return x + y;\n }\n \n let mut x = add(5,7);\n@@ -2784,10 +2784,10 @@ Within the body of an item that has type parameter declarations, the names of it\n \n ~~~~~~~\n fn map<A: copy, B: copy>(f: fn(A) -> B, xs: ~[A]) -> ~[B] {\n-   if xs.len() == 0 { ret ~[]; }\n+   if xs.len() == 0 { return ~[]; }\n    let first: B = f(xs[0]);\n    let rest: ~[B] = map(f, xs.slice(1, xs.len()));\n-   ret ~[first] + rest;\n+   return ~[first] + rest;\n }\n ~~~~~~~\n "}, {"sha": "481e184e31bfc8ddf76957aba0e4aa36317306b8", "filename": "doc/tutorial.md", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -54,17 +54,15 @@ fn boring_old_factorial(n: int) -> int {\n         result *= i;\n         i += 1;\n     }\n-    ret result;\n+    return result;\n }\n ~~~~\n \n Several differences from C stand out. Types do not come before, but\n after variable names (preceded by a colon). For local variables\n (introduced with `let`), types are optional, and will be inferred when\n left off. Constructs like `while` and `if` do not require parentheses\n-around the condition (though they allow them). Also, there's a\n-tendency towards aggressive abbreviation in the keywords\u2014`fn` for\n-function, `ret` for return.\n+around the condition (though they allow them).\n \n You should, however, not conclude that Rust is simply an evolution of\n C. As will become clear in the rest of this tutorial, it goes in quite\n@@ -697,15 +695,15 @@ end of the block:\n fn signum(x: int) -> int {\n     if x < 0 { -1 }\n     else if x > 0 { 1 }\n-    else { ret 0; }\n+    else { return 0; }\n }\n ~~~~\n \n-The `ret` (return) and its semicolon could have been left out without\n+The `return` and its semicolon could have been left out without\n changing the meaning of this function, but it illustrates that you\n will not get a type error in this case, although the last arm doesn't\n have type `int`, because control doesn't reach the end of that arm\n-(`ret` is jumping out of the function).\n+(`return` is jumping out of the function).\n \n ## Pattern matching\n \n@@ -913,11 +911,11 @@ colons and the return type follows the arrow.\n \n ~~~~\n fn int_to_str(i: int) -> ~str {\n-    ret ~\"tube sock\";\n+    return ~\"tube sock\";\n }\n ~~~~\n \n-The `ret` keyword immediately returns from the body of a function. It\n+The `return` keyword immediately returns from the body of a function. It\n is optionally followed by an expression to return. A function can\n also return a value by having its top level block produce an\n expression.\n@@ -926,9 +924,9 @@ expression.\n # const copernicus: int = 0;\n fn int_to_str(i: int) -> ~str {\n     if i == copernicus {\n-        ret ~\"tube sock\";\n+        return ~\"tube sock\";\n     } else {\n-        ret ~\"violin\";\n+        return ~\"violin\";\n     }\n }\n ~~~~\n@@ -946,7 +944,7 @@ and both the return type and the return value may be omitted from\n the definition. The following two functions are equivalent.\n \n ~~~~\n-fn do_nothing_the_hard_way() -> () { ret (); }\n+fn do_nothing_the_hard_way() -> () { return (); }\n \n fn do_nothing_the_easy_way() { }\n ~~~~\n@@ -1552,7 +1550,7 @@ their environment\". For example you couldn't write the following:\n let foo = 10;\n \n fn bar() -> int {\n-   ret foo; // `bar` cannot refer to `foo`\n+   return foo; // `bar` cannot refer to `foo`\n }\n ~~~~\n \n@@ -1617,7 +1615,7 @@ returns it from a function, and then calls it:\n use std;\n \n fn mk_appender(suffix: ~str) -> fn@(~str) -> ~str {\n-    ret fn@(s: ~str) -> ~str { s + suffix };\n+    return fn@(s: ~str) -> ~str { s + suffix };\n }\n \n fn main() {\n@@ -1635,7 +1633,7 @@ be written:\n \n ~~~~\n fn mk_appender(suffix: ~str) -> fn@(~str) -> ~str {\n-    ret |s| s + suffix;\n+    return |s| s + suffix;\n }\n ~~~~\n \n@@ -1742,7 +1740,7 @@ Empty argument lists can be omitted from `do` expressions.\n \n Most iteration in Rust is done with `for` loops. Like `do`,\n `for` is a nice syntax for doing control flow with closures.\n-Additionally, within a `for` loop, `break`, `again`, and `ret`\n+Additionally, within a `for` loop, `break`, `again`, and `retern`\n work just as they do with `while` and `loop`.\n \n Consider again our `each` function, this time improved to\n@@ -1790,7 +1788,7 @@ for each(~[2, 4, 8, 5, 16]) |n| {\n }\n ~~~~\n \n-As an added bonus, you can use the `ret` keyword, which is not\n+As an added bonus, you can use the `return` keyword, which is not\n normally allowed in closures, in a block that appears as the body of a\n `for` loop \u2014 this will cause a return to happen from the outer\n function, not just the loop body.\n@@ -1799,7 +1797,7 @@ function, not just the loop body.\n # import each = vec::each;\n fn contains(v: ~[int], elt: int) -> bool {\n     for each(v) |x| {\n-        if (x == elt) { ret true; }\n+        if (x == elt) { return true; }\n     }\n     false\n }\n@@ -1960,7 +1958,7 @@ copy, that's a win.\n ~~~~\n type person = {name: ~str, address: ~str};\n fn make_person(+name: ~str, +address: ~str) -> person {\n-    ret {name: name, address: address};\n+    return {name: name, address: address};\n }\n ~~~~\n \n@@ -1987,7 +1985,7 @@ fn map<T, U>(vector: ~[T], function: fn(T) -> U) -> ~[U] {\n     for vector.each |element| {\n         vec::push(accumulator, function(element));\n     }\n-    ret accumulator;\n+    return accumulator;\n }\n ~~~~\n \n@@ -2473,7 +2471,7 @@ fn comma_sep<T: to_str>(elts: ~[T]) -> ~str {\n         else { result += ~\", \"; }\n         result += elt.to_str();\n     }\n-    ret result;\n+    return result;\n }\n ~~~~\n \n@@ -2633,14 +2631,14 @@ extern mod crypto {\n fn as_hex(data: ~[u8]) -> ~str {\n     let mut acc = ~\"\";\n     for data.each |byte| { acc += #fmt(\"%02x\", byte as uint); }\n-    ret acc;\n+    return acc;\n }\n \n fn sha1(data: ~str) -> ~str unsafe {\n     let bytes = str::bytes(data);\n     let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n                             vec::len(bytes) as c_uint, ptr::null());\n-    ret as_hex(vec::unsafe::from_buf(hash, 20u));\n+    return as_hex(vec::unsafe::from_buf(hash, 20u));\n }\n \n fn main(args: ~[~str]) {\n@@ -2740,7 +2738,7 @@ fn sha1(data: ~str) -> ~str {\n         let bytes = str::bytes(data);\n         let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n                                 vec::len(bytes), ptr::null());\n-        ret as_hex(vec::unsafe::from_buf(hash, 20u));\n+        return as_hex(vec::unsafe::from_buf(hash, 20u));\n     }\n }\n ~~~~\n@@ -2783,7 +2781,7 @@ Let's look at our `sha1` function again.\n let bytes = str::bytes(data);\n let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n                         vec::len(bytes), ptr::null());\n-ret as_hex(vec::unsafe::from_buf(hash, 20u));\n+return as_hex(vec::unsafe::from_buf(hash, 20u));\n # }\n # }\n ~~~~\n@@ -2830,7 +2828,7 @@ extern mod lib_c {\n fn unix_time_in_microseconds() -> u64 unsafe {\n     let x = {mut tv_sec: 0 as c_ulonglong, mut tv_usec: 0 as c_ulonglong};\n     lib_c::gettimeofday(ptr::addr_of(x), ptr::null());\n-    ret (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\n+    return (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\n }\n \n # fn main() { assert #fmt(\"%?\", unix_time_in_microseconds()) != ~\"\"; }"}, {"sha": "ab1ee6c052ee047d84abfdb0e389711bc11152fe", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 75, "deletions": 75, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -125,7 +125,7 @@ fn is_uuid(id: ~str) -> bool {\n             }\n \n             if !part.all(is_hex_digit) {\n-                ret false;\n+                return false;\n             }\n \n             alt i {\n@@ -148,10 +148,10 @@ fn is_uuid(id: ~str) -> bool {\n             }\n         }\n         if correct >= 5u {\n-            ret true;\n+            return true;\n         }\n     }\n-    ret false;\n+    return false;\n }\n \n #[test]\n@@ -207,10 +207,10 @@ fn is_git_url(url: ~str) -> bool {\n \n fn assume_source_method(url: ~str) -> ~str {\n     if is_git_url(url) {\n-        ret ~\"git\";\n+        return ~\"git\";\n     }\n     if str::starts_with(url, ~\"file://\") || os::path_exists(url) {\n-        ret ~\"file\";\n+        return ~\"file\";\n     }\n \n     ~\"curl\"\n@@ -350,7 +350,7 @@ fn load_crate(filename: ~str) -> option<crate> {\n                 crate_type: crate_type,\n                 deps: deps })\n         }\n-        _ { ret none; }\n+        _ { return none; }\n     }\n }\n \n@@ -367,7 +367,7 @@ fn rest(s: ~str, start: uint) -> ~str {\n }\n \n fn need_dir(s: ~str) {\n-    if os::path_is_dir(s) { ret; }\n+    if os::path_is_dir(s) { return; }\n     if !os::make_dir(s, 493_i32 /* oct: 755 */) {\n         fail fmt!{\"can't make_dir %s\", s};\n     }\n@@ -419,7 +419,7 @@ fn parse_source(name: ~str, j: json::json) -> source {\n             if method == ~\"file\" {\n                 url = os::make_absolute(url);\n             }\n-            ret @{\n+            return @{\n                 name: name,\n                 mut url: url,\n                 mut method: method,\n@@ -432,7 +432,7 @@ fn parse_source(name: ~str, j: json::json) -> source {\n }\n \n fn try_parse_sources(filename: ~str, sources: map::hashmap<~str, source>) {\n-    if !os::path_exists(filename)  { ret; }\n+    if !os::path_exists(filename)  { return; }\n     let c = io::read_whole_file_str(filename);\n     alt json::from_str(result::get(c)) {\n         ok(json::dict(j)) {\n@@ -454,13 +454,13 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n                      + src.name + ~\", '\" + *n + ~\"'\"+\n                      ~\" is an invalid name (alphanumeric, underscores and\" +\n                      ~\" dashes only)\");\n-                ret;\n+                return;\n             }\n             *n\n         }\n         _ {\n             warn(~\"malformed source json: \" + src.name + ~\" (missing name)\");\n-            ret;\n+            return;\n         }\n     };\n \n@@ -470,21 +470,21 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n                 warn(~\"malformed source json: \"\n                      + src.name + ~\", '\" + *n + ~\"'\"+\n                      ~\" is an invalid uuid\");\n-                ret;\n+                return;\n             }\n             *n\n         }\n         _ {\n             warn(~\"malformed source json: \" + src.name + ~\" (missing uuid)\");\n-            ret;\n+            return;\n         }\n     };\n \n     let url = alt p.find(~\"url\") {\n         some(json::string(n)) { *n }\n         _ {\n             warn(~\"malformed source json: \" + src.name + ~\" (missing url)\");\n-            ret;\n+            return;\n         }\n     };\n \n@@ -493,7 +493,7 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n         _ {\n             warn(~\"malformed source json: \"\n                  + src.name + ~\" (missing method)\");\n-            ret;\n+            return;\n         }\n     };\n \n@@ -520,7 +520,7 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n         _ {\n             warn(~\"malformed source json: \" + src.name\n                  + ~\" (missing description)\");\n-            ret;\n+            return;\n         }\n     };\n \n@@ -551,7 +551,7 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n fn load_source_info(c: cargo, src: source) {\n     let dir = path::connect(c.sourcedir, src.name);\n     let srcfile = path::connect(dir, ~\"source.json\");\n-    if !os::path_exists(srcfile) { ret; }\n+    if !os::path_exists(srcfile) { return; }\n     let srcstr = io::read_whole_file_str(srcfile);\n     alt json::from_str(result::get(srcstr)) {\n         ok(json::dict(s)) {\n@@ -573,7 +573,7 @@ fn load_source_packages(c: cargo, src: source) {\n     log(debug, ~\"loading source: \" + src.name);\n     let dir = path::connect(c.sourcedir, src.name);\n     let pkgfile = path::connect(dir, ~\"packages.json\");\n-    if !os::path_exists(pkgfile) { ret; }\n+    if !os::path_exists(pkgfile) { return; }\n     let pkgstr = io::read_whole_file_str(pkgfile);\n     alt json::from_str(result::get(pkgstr)) {\n         ok(json::list(js)) {\n@@ -718,15 +718,15 @@ fn run_in_buildpath(what: ~str, path: ~str, subdir: ~str, cf: ~str,\n                                 ~[~\"--out-dir\", buildpath, cf] + extra_flags);\n     if p.status != 0 {\n         error(fmt!{\"rustc failed: %d\\n%s\\n%s\", p.status, p.err, p.out});\n-        ret none;\n+        return none;\n     }\n     some(buildpath)\n }\n \n fn test_one_crate(_c: cargo, path: ~str, cf: ~str) {\n   let buildpath = alt run_in_buildpath(~\"testing\", path, ~\"/test\", cf,\n                                        ~[ ~\"--test\"]) {\n-      none { ret; }\n+      none { return; }\n       some(bp) { bp }\n   };\n   run_programs(buildpath);\n@@ -735,7 +735,7 @@ fn test_one_crate(_c: cargo, path: ~str, cf: ~str) {\n fn install_one_crate(c: cargo, path: ~str, cf: ~str) {\n     let buildpath = alt run_in_buildpath(~\"installing\", path,\n                                          ~\"/build\", cf, ~[]) {\n-      none { ret; }\n+      none { return; }\n       some(bp) { bp }\n     };\n     let newv = os::list_dir_path(buildpath);\n@@ -867,7 +867,7 @@ fn cargo_suggestion(c: cargo, fallback: fn())\n     if c.sources.size() == 0u {\n         error(~\"no sources defined - you may wish to run \" +\n               ~\"`cargo init`\");\n-        ret;\n+        return;\n     }\n     fallback();\n }\n@@ -882,12 +882,12 @@ fn install_uuid(c: cargo, wd: ~str, uuid: ~str) {\n     if vec::len(ps) == 1u {\n         let (sname, p) = copy ps[0];\n         install_package(c, sname, wd, p);\n-        ret;\n+        return;\n     } else if vec::len(ps) == 0u {\n         cargo_suggestion(c, || {\n             error(~\"can't find package: \" + uuid);\n         });\n-        ret;\n+        return;\n     }\n     error(~\"found multiple packages:\");\n     for ps.each |elt| {\n@@ -906,12 +906,12 @@ fn install_named(c: cargo, wd: ~str, name: ~str) {\n     if vec::len(ps) == 1u {\n         let (sname, p) = copy ps[0];\n         install_package(c, sname, wd, p);\n-        ret;\n+        return;\n     } else if vec::len(ps) == 0u {\n         cargo_suggestion(c, || {\n             error(~\"can't find package: \" + name);\n         });\n-        ret;\n+        return;\n     }\n     error(~\"found multiple packages:\");\n     for ps.each |elt| {\n@@ -929,7 +929,7 @@ fn install_uuid_specific(c: cargo, wd: ~str, src: ~str, uuid: ~str) {\n                 install_package(c, src, wd, p);\n                 true\n             } else { false }\n-        }) { ret; }\n+        }) { return; }\n       }\n       _ { }\n     }\n@@ -945,7 +945,7 @@ fn install_named_specific(c: cargo, wd: ~str, src: ~str, name: ~str) {\n                     install_package(c, src, wd, p);\n                     true\n                 } else { false }\n-            }) { ret; }\n+            }) { return; }\n         }\n         _ { }\n     }\n@@ -955,7 +955,7 @@ fn install_named_specific(c: cargo, wd: ~str, src: ~str, name: ~str) {\n fn cmd_uninstall(c: cargo) {\n     if vec::len(c.opts.free) < 3u {\n         cmd_usage();\n-        ret;\n+        return;\n     }\n \n     let lib = c.libdir;\n@@ -976,7 +976,7 @@ fn cmd_uninstall(c: cargo) {\n                     } else {\n                         error(~\"could not uninstall: '\" + full + ~\"'\");\n                     }\n-                    ret;\n+                    return;\n                 }\n                 none { again; }\n             }\n@@ -994,7 +994,7 @@ fn cmd_uninstall(c: cargo) {\n                     } else {\n                         error(~\"could not uninstall: '\" + full + ~\"'\");\n                     }\n-                    ret;\n+                    return;\n                 }\n                 none { again; }\n             }\n@@ -1008,7 +1008,7 @@ fn cmd_uninstall(c: cargo) {\n                     } else {\n                         error(~\"could not uninstall: '\" + full + ~\"'\");\n                     }\n-                    ret;\n+                    return;\n                 }\n                 none { again; }\n             }\n@@ -1022,7 +1022,7 @@ fn install_query(c: cargo, wd: ~str, target: ~str) {\n     alt c.dep_cache.find(target) {\n         some(inst) {\n             if inst {\n-                ret;\n+                return;\n             }\n         }\n         none {}\n@@ -1032,7 +1032,7 @@ fn install_query(c: cargo, wd: ~str, target: ~str) {\n \n     if is_archive_path(target) {\n         install_file(c, wd, target);\n-        ret;\n+        return;\n     } else if is_git_url(target) {\n         let reference = if c.opts.free.len() >= 4u {\n             some(c.opts.free[3u])\n@@ -1042,7 +1042,7 @@ fn install_query(c: cargo, wd: ~str, target: ~str) {\n         install_git(c, wd, target, reference);\n     } else if !valid_pkg_name(target) && has_archive_extension(target) {\n         install_curl(c, wd, target);\n-        ret;\n+        return;\n     } else {\n         let mut ps = copy target;\n \n@@ -1094,7 +1094,7 @@ fn cmd_install(c: cargo) unsafe {\n         }\n \n         install_source(c, wd);\n-        ret;\n+        return;\n     }\n \n     sync(c);\n@@ -1127,7 +1127,7 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n \n     if !os::copy_file(path::connect(url, ~\"packages.json\"), pkgfile) {\n         error(fmt!{\"fetch for source %s (url %s) failed\", name, url});\n-        ret false;\n+        return false;\n     }\n \n     if os::copy_file(path::connect(url, ~\"source.json\"), srcfile) {\n@@ -1143,7 +1143,7 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n                                         ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n             if p.status != 0 {\n                 error(fmt!{\"fetch for source %s (key %s) failed\", name, u});\n-                ret false;\n+                return false;\n             }\n             pgp::add(c.root, keyfile);\n         }\n@@ -1156,7 +1156,7 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n             if !r {\n                 error(fmt!{\"signature verification failed for source %s\",\n                           name});\n-                ret false;\n+                return false;\n             }\n \n             if has_src_file {\n@@ -1165,7 +1165,7 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n                 if !e {\n                     error(fmt!{\"signature verification failed for source %s\",\n                               name});\n-                    ret false;\n+                    return false;\n                 }\n             }\n         }\n@@ -1186,7 +1186,7 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n \n     info(fmt!{\"synced source: %s\", name});\n \n-    ret true;\n+    return true;\n }\n \n fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n@@ -1227,20 +1227,20 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n \n         if p.status != 0 {\n             error(fmt!{\"fetch for source %s (url %s) failed\", name, url});\n-            ret false;\n+            return false;\n         }\n     }\n     else {\n         if !os::change_dir(dir) {\n             error(fmt!{\"fetch for source %s (url %s) failed\", name, url});\n-            ret false;\n+            return false;\n         }\n \n         let p = run::program_output(~\"git\", ~[~\"pull\"]);\n \n         if p.status != 0 {\n             error(fmt!{\"fetch for source %s (url %s) failed\", name, url});\n-            ret false;\n+            return false;\n         }\n     }\n \n@@ -1253,7 +1253,7 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n             if p.status != 0 {\n                 error(fmt!{\"fetch for source %s (key %s) failed\", name, u});\n                 rollback(name, dir, false);\n-                ret false;\n+                return false;\n             }\n             pgp::add(c.root, keyfile);\n         }\n@@ -1267,7 +1267,7 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n                 error(fmt!{\"signature verification failed for source %s\",\n                           name});\n                 rollback(name, dir, false);\n-                ret false;\n+                return false;\n             }\n \n             if has_src_file {\n@@ -1277,7 +1277,7 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n                     error(fmt!{\"signature verification failed for source %s\",\n                               name});\n                     rollback(name, dir, false);\n-                    ret false;\n+                    return false;\n                 }\n             }\n         }\n@@ -1288,7 +1288,7 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n \n     info(fmt!{\"synced source: %s\", name});\n \n-    ret true;\n+    return true;\n }\n \n fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n@@ -1313,7 +1313,7 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n \n     if p.status != 0 {\n         error(fmt!{\"fetch for source %s (url %s) failed\", name, url});\n-        ret false;\n+        return false;\n     }\n     if smart {\n         url = src.url + ~\"/source.json\";\n@@ -1332,7 +1332,7 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n                                         ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n             if p.status != 0 {\n                 error(fmt!{\"fetch for source %s (key %s) failed\", name, u});\n-                ret false;\n+                return false;\n             }\n             pgp::add(c.root, keyfile);\n         }\n@@ -1351,15 +1351,15 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n                         sigfile, url]);\n             if p.status != 0 {\n                 error(fmt!{\"fetch for source %s (sig %s) failed\", name, url});\n-                ret false;\n+                return false;\n             }\n \n             let r = pgp::verify(c.root, pkgfile, sigfile, f);\n \n             if !r {\n                 error(fmt!{\"signature verification failed for source %s\",\n                           name});\n-                ret false;\n+                return false;\n             }\n \n             if smart && has_src_file {\n@@ -1371,15 +1371,15 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n                 if p.status != 0 {\n                     error(fmt!{\"fetch for source %s (sig %s) failed\",\n                           name, url});\n-                    ret false;\n+                    return false;\n                 }\n \n                 let e = pgp::verify(c.root, srcfile, srcsigfile, f);\n \n                 if !e {\n                     error(~\"signature verification failed for \" +\n                           ~\"source \" + name);\n-                    ret false;\n+                    return false;\n                 }\n             }\n         }\n@@ -1400,7 +1400,7 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n \n     info(fmt!{\"synced source: %s\", name});\n \n-    ret true;\n+    return true;\n }\n \n fn sync_one(c: cargo, src: source) {\n@@ -1435,20 +1435,20 @@ fn cmd_init(c: cargo) {\n         run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\", srcfile, srcurl]);\n     if p.status != 0 {\n         error(fmt!{\"fetch of sources.json failed: %s\", p.out});\n-        ret;\n+        return;\n     }\n \n     let p =\n         run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\", sigfile, sigurl]);\n     if p.status != 0 {\n         error(fmt!{\"fetch of sources.json.sig failed: %s\", p.out});\n-        ret;\n+        return;\n     }\n \n     let r = pgp::verify(c.root, srcfile, sigfile, pgp::signing_key_fp());\n     if !r {\n         error(fmt!{\"signature verification failed for '%s'\", srcfile});\n-        ret;\n+        return;\n     }\n \n     copy_warn(srcfile, destsrcfile);\n@@ -1518,7 +1518,7 @@ fn cmd_list(c: cargo) {\n fn cmd_search(c: cargo) {\n     if vec::len(c.opts.free) < 3u {\n         cmd_usage();\n-        ret;\n+        return;\n     }\n \n     sync(c);\n@@ -1559,7 +1559,7 @@ fn dump_cache(c: cargo) {\n }\n fn dump_sources(c: cargo) {\n     if c.sources.size() < 1u {\n-        ret;\n+        return;\n     }\n \n     need_dir(c.root);\n@@ -1618,7 +1618,7 @@ fn cmd_sources(c: cargo) {\n             info(fmt!{\"%s (%s) via %s\",\n                       v.name, v.url, v.method});\n         }\n-        ret;\n+        return;\n     }\n \n     let action = c.opts.free[2u];\n@@ -1634,15 +1634,15 @@ fn cmd_sources(c: cargo) {\n         ~\"add\" {\n             if vec::len(c.opts.free) < 5u {\n                 cmd_usage();\n-                ret;\n+                return;\n             }\n \n             let name = c.opts.free[3u];\n             let url = c.opts.free[4u];\n \n             if !valid_pkg_name(name) {\n                 error(fmt!{\"'%s' is an invalid source name\", name});\n-                ret;\n+                return;\n             }\n \n             alt c.sources.find(name) {\n@@ -1665,14 +1665,14 @@ fn cmd_sources(c: cargo) {\n         ~\"remove\" {\n             if vec::len(c.opts.free) < 4u {\n                 cmd_usage();\n-                ret;\n+                return;\n             }\n \n             let name = c.opts.free[3u];\n \n             if !valid_pkg_name(name) {\n                 error(fmt!{\"'%s' is an invalid source name\", name});\n-                ret;\n+                return;\n             }\n \n             alt c.sources.find(name) {\n@@ -1688,15 +1688,15 @@ fn cmd_sources(c: cargo) {\n         ~\"set-url\" {\n             if vec::len(c.opts.free) < 5u {\n                 cmd_usage();\n-                ret;\n+                return;\n             }\n \n             let name = c.opts.free[3u];\n             let url = c.opts.free[4u];\n \n             if !valid_pkg_name(name) {\n                 error(fmt!{\"'%s' is an invalid source name\", name});\n-                ret;\n+                return;\n             }\n \n             alt c.sources.find(name) {\n@@ -1719,15 +1719,15 @@ fn cmd_sources(c: cargo) {\n         ~\"set-method\" {\n             if vec::len(c.opts.free) < 5u {\n                 cmd_usage();\n-                ret;\n+                return;\n             }\n \n             let name = c.opts.free[3u];\n             let method = c.opts.free[4u];\n \n             if !valid_pkg_name(name) {\n                 error(fmt!{\"'%s' is an invalid source name\", name});\n-                ret;\n+                return;\n             }\n \n             alt c.sources.find(name) {\n@@ -1753,19 +1753,19 @@ fn cmd_sources(c: cargo) {\n         ~\"rename\" {\n             if vec::len(c.opts.free) < 5u {\n                 cmd_usage();\n-                ret;\n+                return;\n             }\n \n             let name = c.opts.free[3u];\n             let newn = c.opts.free[4u];\n \n             if !valid_pkg_name(name) {\n                 error(fmt!{\"'%s' is an invalid source name\", name});\n-                ret;\n+                return;\n             }\n             if !valid_pkg_name(newn) {\n                 error(fmt!{\"'%s' is an invalid source name\", newn});\n-                ret;\n+                return;\n             }\n \n             alt c.sources.find(name) {\n@@ -1879,7 +1879,7 @@ fn main(argv: ~[~str]) {\n \n     if vec::len(o.free) < 2u {\n         cmd_usage();\n-        ret;\n+        return;\n     }\n     if o.help {\n         alt o.free[1] {\n@@ -1891,11 +1891,11 @@ fn main(argv: ~[~str]) {\n             ~\"sources\" { cmd_usage_sources(); }\n             _ { cmd_usage(); }\n         }\n-        ret;\n+        return;\n     }\n     if o.free[1] == ~\"usage\" {\n         cmd_usage();\n-        ret;\n+        return;\n     }\n \n     let mut c = configure(o);"}, {"sha": "c79d7f3bcf3e8cca40343fe8f87c775edc06d612", "filename": "src/cargo/pgp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Fcargo%2Fpgp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Fcargo%2Fpgp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fpgp.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -1,5 +1,5 @@\n fn gpg(args: ~[~str]) -> { status: int, out: ~str, err: ~str } {\n-    ret run::program_output(~\"gpg\", args);\n+    return run::program_output(~\"gpg\", args);\n }\n \n fn signing_key() -> ~str {\n@@ -91,7 +91,7 @@ fn verify(root: ~str, data: ~str, sig: ~str, keyfp: ~str) -> bool {\n                  data]);\n     let res = ~\"Primary key fingerprint: \" + keyfp;\n     for str::split_char(p.err, '\\n').each |line| {\n-        if line == res { ret true; }\n+        if line == res { return true; }\n     }\n-    ret false;\n+    return false;\n }"}, {"sha": "4fc88009bc67a99757ab62799f7247fbebc48acb", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -47,7 +47,7 @@ fn parse_config(args: ~[~str]) -> config {\n           err(f) { fail getopts::fail_str(f) }\n         };\n \n-    ret {compile_lib_path: getopts::opt_str(matches, ~\"compile-lib-path\"),\n+    return {compile_lib_path: getopts::opt_str(matches, ~\"compile-lib-path\"),\n          run_lib_path: getopts::opt_str(matches, ~\"run-lib-path\"),\n          rustc_path: getopts::opt_str(matches, ~\"rustc-path\"),\n          src_base: getopts::opt_str(matches, ~\"src-base\"),\n@@ -143,7 +143,7 @@ fn make_tests(config: config) -> ~[test::test_desc] {\n             vec::push(tests, make_test(config, file))\n         }\n     }\n-    ret tests;\n+    return tests;\n }\n \n fn is_test(config: config, testfile: ~str) -> bool {\n@@ -163,7 +163,7 @@ fn is_test(config: config, testfile: ~str) -> bool {\n         if str::starts_with(name, pre) { valid = false; }\n     }\n \n-    ret valid;\n+    return valid;\n }\n \n fn make_test(config: config, testfile: ~str) ->"}, {"sha": "431843d92682743b2f5632080e77e5bac0981b28", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -17,14 +17,14 @@ fn load_errors(testfile: ~str) -> ~[expected_error] {\n         error_patterns += parse_expected(line_num, ln);\n         line_num += 1u;\n     }\n-    ret error_patterns;\n+    return error_patterns;\n }\n \n fn parse_expected(line_num: uint, line: ~str) -> ~[expected_error] unsafe {\n     let error_tag = ~\"//~\";\n     let mut idx;\n     alt str::find_str(line, error_tag) {\n-         option::none { ret ~[]; }\n+         option::none { return ~[]; }\n          option::some(nn) { idx = (nn as uint) + str::len(error_tag); }\n     }\n \n@@ -49,5 +49,5 @@ fn parse_expected(line_num: uint, line: ~str) -> ~[expected_error] unsafe {\n \n     debug!{\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg};\n \n-    ret ~[{line: line_num - adjust_line, kind: kind, msg: msg}];\n+    return ~[{line: line_num - adjust_line, kind: kind, msg: msg}];\n }"}, {"sha": "ec214f5b58627936a7d30b0738c5618b8a22adb7", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -51,7 +51,7 @@ fn load_props(testfile: ~str) -> test_props {\n             vec::push(exec_env, ee);\n         }\n     };\n-    ret {\n+    return {\n         error_patterns: error_patterns,\n         compile_flags: compile_flags,\n         pp_exact: pp_exact,\n@@ -63,12 +63,12 @@ fn load_props(testfile: ~str) -> test_props {\n fn is_test_ignored(config: config, testfile: ~str) -> bool {\n     let mut found = false;\n     for iter_header(testfile) |ln| {\n-        if parse_name_directive(ln, ~\"xfail-test\") { ret true; }\n-        if parse_name_directive(ln, xfail_target()) { ret true; }\n+        if parse_name_directive(ln, ~\"xfail-test\") { return true; }\n+        if parse_name_directive(ln, xfail_target()) { return true; }\n         if config.mode == common::mode_pretty &&\n-           parse_name_directive(ln, ~\"xfail-pretty\") { ret true; }\n+           parse_name_directive(ln, ~\"xfail-pretty\") { return true; }\n     };\n-    ret found;\n+    return found;\n \n     fn xfail_target() -> ~str {\n         ~\"xfail-\" + os::sysname()\n@@ -85,10 +85,10 @@ fn iter_header(testfile: ~str, it: fn(~str) -> bool) -> bool {\n         // with a warm page cache. Maybe with a cold one.\n         if str::starts_with(ln, ~\"fn\")\n             || str::starts_with(ln, ~\"mod\") {\n-            ret false;\n-        } else { if !(it(ln)) { ret false; } }\n+            return false;\n+        } else { if !(it(ln)) { return false; } }\n     }\n-    ret true;\n+    return true;\n }\n \n fn parse_error_pattern(line: ~str) -> option<~str> {"}, {"sha": "1a642915cd5e7d9960d1aa7239272e55830acb5a", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -21,7 +21,7 @@ fn target_env(lib_path: ~str, prog: ~str) -> ~[(~str,~str)] {\n     if str::ends_with(prog, ~\"rustc.exe\") {\n         vec::push(env, (~\"RUST_THREADS\", ~\"1\"));\n     }\n-    ret env;\n+    return env;\n }\n \n #[cfg(target_os = \"linux\")]\n@@ -84,7 +84,7 @@ fn run(lib_path: ~str,\n         };\n         count -= 1;\n     };\n-    ret {status: status, out: outs, err: errs};\n+    return {status: status, out: outs, err: errs};\n }\n \n fn writeclose(fd: c_int, s: option<~str>) {\n@@ -106,5 +106,5 @@ fn readclose(fd: c_int) -> ~str {\n         buf += str::from_bytes(bytes);\n     }\n     os::fclose(file);\n-    ret buf;\n+    return buf;\n }"}, {"sha": "ac5c3161c47bd2e3c5fb23e5a3f3b17e7314caf0", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -134,7 +134,7 @@ fn run_pretty_test(config: config, props: test_props, testfile: ~str) {\n         fatal_procres(~\"pretty-printed source does not typecheck\", procres);\n     }\n \n-    ret;\n+    return;\n \n     fn print_source(config: config, testfile: ~str, src: ~str) -> procres {\n         compose_and_run(config, testfile, make_pp_args(config, testfile),\n@@ -144,7 +144,7 @@ fn run_pretty_test(config: config, props: test_props, testfile: ~str) {\n     fn make_pp_args(config: config, _testfile: ~str) -> procargs {\n         let prog = config.rustc_path;\n         let args = ~[~\"-\", ~\"--pretty\", ~\"normal\"];\n-        ret {prog: prog, args: args};\n+        return {prog: prog, args: args};\n     }\n \n     fn compare_source(expected: ~str, actual: ~str) {\n@@ -181,7 +181,7 @@ actual:\\n\\\n                          ~\"--no-trans\", ~\"--lib\", ~\"-L\", config.build_base,\n                          ~\"-L\", aux_output_dir_name(config, testfile)];\n         args += split_maybe_args(config.rustcflags);\n-        ret {prog: prog, args: args};\n+        return {prog: prog, args: args};\n     }\n }\n \n@@ -211,7 +211,7 @@ fn check_error_patterns(props: test_props,\n             next_err_pat = props.error_patterns[next_err_idx];\n         }\n     }\n-    if done { ret; }\n+    if done { return; }\n \n     let missing_patterns =\n         vec::slice(props.error_patterns, next_err_idx,\n@@ -340,7 +340,7 @@ fn compose_and_run_compiler(\n }\n \n fn ensure_dir(path: path) {\n-    if os::path_is_dir(path) { ret; }\n+    if os::path_is_dir(path) { return; }\n     if !os::make_dir(path, 0x1c0i32) {\n         fail fmt!{\"can't make dir %s\", path};\n     }\n@@ -351,7 +351,7 @@ fn compose_and_run(config: config, testfile: ~str,\n                    procenv: ~[(~str, ~str)],\n                    lib_path: ~str,\n                    input: option<~str>) -> procres {\n-    ret program_output(config, testfile, lib_path,\n+    return program_output(config, testfile, lib_path,\n                        procargs.prog, procargs.args, procenv, input);\n }\n \n@@ -363,7 +363,7 @@ fn make_compile_args(config: config, props: test_props, extras: ~[~str],\n                     ~\"-L\", config.build_base] + extras;\n     args += split_maybe_args(config.rustcflags);\n     args += split_maybe_args(props.compile_flags);\n-    ret {prog: prog, args: args};\n+    return {prog: prog, args: args};\n }\n \n fn make_lib_name(config: config, auxfile: ~str, testfile: ~str) -> ~str {\n@@ -391,7 +391,7 @@ fn make_run_args(config: config, _props: test_props, testfile: ~str) ->\n         };\n \n     let args = toolargs + ~[make_exe_name(config, testfile)];\n-    ret {prog: args[0], args: vec::slice(args, 1u, vec::len(args))};\n+    return {prog: args[0], args: vec::slice(args, 1u, vec::len(args))};\n }\n \n fn split_maybe_args(argstr: option<~str>) -> ~[~str] {\n@@ -419,7 +419,7 @@ fn program_output(config: config, testfile: ~str, lib_path: ~str, prog: ~str,\n         };\n     let res = procsrv::run(lib_path, prog, args, env, input);\n     dump_output(config, testfile, res.out, res.err);\n-    ret {status: res.status,\n+    return {status: res.status,\n          stdout: res.out,\n          stderr: res.err,\n          cmdline: cmdline};"}, {"sha": "dc063438e04881570a99cd77d8dc1e149de156a0", "filename": "src/fuzzer/ast_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ffuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ffuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fast_match.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -5,17 +5,17 @@ fn vec_equal<T>(v: ~[T], u: ~[T],\n                 element_equality_test: fn@(&&T, &&T) -> bool) ->\n    bool {\n     let Lv = vec::len(v);\n-    if Lv != vec::len(u) { ret false; }\n+    if Lv != vec::len(u) { return false; }\n     let i = 0u;\n     while i < Lv {\n-        if !element_equality_test(v[i], u[i]) { ret false; }\n+        if !element_equality_test(v[i], u[i]) { return false; }\n         i += 1u;\n     }\n-    ret true;\n+    return true;\n }\n \n-pure fn builtin_equal<T>(&&a: T, &&b: T) -> bool { ret a == b; }\n-pure fn builtin_equal_int(&&a: int, &&b: int) -> bool { ret a == b; }\n+pure fn builtin_equal<T>(&&a: T, &&b: T) -> bool { return a == b; }\n+pure fn builtin_equal_int(&&a: int, &&b: int) -> bool { return a == b; }\n \n fn main() {\n     assert (builtin_equal(5, 5));"}, {"sha": "f0e2d7df3480b5cd8d9416c1d41813a6d24d4507", "filename": "src/fuzzer/cycles.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ffuzzer%2Fcycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ffuzzer%2Fcycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fcycles.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -39,7 +39,7 @@ type pointy = {\n // To add: objects; traits; anything type-parameterized?\n \n fn empty_pointy() -> @pointy {\n-    ret @{\n+    return @{\n         mut a : none,\n         mut b : ~none,\n         mut c : @none,"}, {"sha": "39f33b732d8cf62143480cf027a9f93c7322ece0", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -450,7 +450,7 @@ fn has_raw_pointers(c: ast::crate) -> bool {\n         visit::mk_simple_visitor(@{visit_ty: |a| visit_ty(has_rp, a)\n                                       with *visit::default_simple_visitor()});\n     visit::visit_crate(c, (), v);\n-    ret *has_rp;\n+    return *has_rp;\n }\n \n fn content_is_dangerous_to_run(code: ~str) -> bool {\n@@ -461,16 +461,16 @@ fn content_is_dangerous_to_run(code: ~str) -> bool {\n          ~\"unsafe\",\n          ~\"log\"];    // python --> rust pipe deadlock?\n \n-    for dangerous_patterns.each |p| { if contains(code, p) { ret true; } }\n-    ret false;\n+    for dangerous_patterns.each |p| { if contains(code, p) { return true; } }\n+    return false;\n }\n \n fn content_is_dangerous_to_compile(code: ~str) -> bool {\n     let dangerous_patterns =\n         ~[~\"xfail-test\"];\n \n-    for dangerous_patterns.each |p| { if contains(code, p) { ret true; } }\n-    ret false;\n+    for dangerous_patterns.each |p| { if contains(code, p) { return true; } }\n+    return false;\n }\n \n fn content_might_not_converge(code: ~str) -> bool {\n@@ -485,8 +485,8 @@ fn content_might_not_converge(code: ~str) -> bool {\n          ~\"\\n\\n\\n\\n\\n\"  // https://github.com/mozilla/rust/issues/850\n         ];\n \n-    for confusing_patterns.each |p| { if contains(code, p) { ret true; } }\n-    ret false;\n+    for confusing_patterns.each |p| { if contains(code, p) { return true; } }\n+    return false;\n }\n \n fn file_might_not_converge(filename: ~str) -> bool {\n@@ -499,9 +499,9 @@ fn file_might_not_converge(filename: ~str) -> bool {\n     ];\n \n \n-    for confusing_files.each |f| { if contains(filename, f) { ret true; } }\n+    for confusing_files.each |f| { if contains(filename, f) { return true; } }\n \n-    ret false;\n+    return false;\n }\n \n fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n@@ -512,7 +512,7 @@ fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n \n     while i < maxIters {\n         oldv = newv;\n-        if content_might_not_converge(*oldv) { ret; }\n+        if content_might_not_converge(*oldv) { return; }\n         newv = @parse_and_print(oldv);\n         if oldv == newv { break; }\n         i += 1u;\n@@ -592,7 +592,7 @@ fn check_variants(files: ~[~str], cx: context) {\n fn main(args: ~[~str]) {\n     if vec::len(args) != 2u {\n         error!{\"usage: %s <testdir>\", args[0]};\n-        ret;\n+        return;\n     }\n     let mut files = ~[];\n     let root = args[1];"}, {"sha": "709f2e10c3125d07af3f25f9074ca2663e557760", "filename": "src/fuzzer/ivec_fuzz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ffuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ffuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fivec_fuzz.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -91,7 +91,7 @@ fn vec_to_str(v: ~[int]) -> str {\n         if i + 1u < len(v) { s += \", \"; }\n         i += 1u;\n     }\n-    ret s + \"]\";\n+    return s + \"]\";\n }\n \n fn show_edits(a: ~[int], xs: ~[int]) {"}, {"sha": "035b2a5e448509acfaf7f26aebc03d63debfc305", "filename": "src/fuzzer/rand_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ffuzzer%2Frand_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ffuzzer%2Frand_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Frand_util.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -51,7 +51,7 @@ fn weighted_choice<T: copy>(r : rand::rng, v : ~[weighted<T>]) -> T {\n     for {weight: weight, item: item} in v {\n         so_far += weight;\n         if so_far > chosen {\n-            ret item;\n+            return item;\n         }\n     }\n     core::unreachable();"}, {"sha": "30bed71aa9534fb4760e780c7691dd767085a210", "filename": "src/libcore/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farc.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -61,7 +61,7 @@ fn get<T: const send>(rc: &arc<T>) -> &T {\n         // Cast us back into the correct region\n         let r = unsafe::reinterpret_cast(&ptr.data);\n         unsafe::forget(ptr);\n-        ret r;\n+        return r;\n     }\n }\n "}, {"sha": "b5d6e655e4a5ae5995dff663270c8588fe8d01d2", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -60,7 +60,7 @@ pure fn build_sized<A>(size: uint, builder: fn(push: pure fn(+A))) -> @[A] {\n             <fn(push: pure fn(+A)), fn(push: fn(+A))>\n             (builder)(|+x| unsafe::push(vec, x));\n     }\n-    ret vec;\n+    return vec;\n }\n \n /**"}, {"sha": "5849d19d8c166574a58b4d7a2df6e6640e7f02c9", "filename": "src/libcore/char.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -51,15 +51,15 @@ import is_XID_continue = unicode::derived_property::XID_Continue;\n  * in terms of the Unicode General Category 'Ll'\n  */\n pure fn is_lowercase(c: char) -> bool {\n-    ret unicode::general_category::Ll(c);\n+    return unicode::general_category::Ll(c);\n }\n \n /**\n  * Indicates whether a character is in upper case, defined\n  * in terms of the Unicode General Category 'Lu'.\n  */\n pure fn is_uppercase(c: char) -> bool {\n-    ret unicode::general_category::Lu(c);\n+    return unicode::general_category::Lu(c);\n }\n \n /**\n@@ -68,7 +68,7 @@ pure fn is_uppercase(c: char) -> bool {\n  * additional 'Cc'-category control codes in the range [0x09, 0x0d]\n  */\n pure fn is_whitespace(c: char) -> bool {\n-    ret ('\\x09' <= c && c <= '\\x0d')\n+    return ('\\x09' <= c && c <= '\\x0d')\n         || unicode::general_category::Zs(c)\n         || unicode::general_category::Zl(c)\n         || unicode::general_category::Zp(c);\n@@ -80,7 +80,7 @@ pure fn is_whitespace(c: char) -> bool {\n  * 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n  */\n pure fn is_alphanumeric(c: char) -> bool {\n-    ret unicode::derived_property::Alphabetic(c) ||\n+    return unicode::derived_property::Alphabetic(c) ||\n         unicode::general_category::Nd(c) ||\n         unicode::general_category::Nl(c) ||\n         unicode::general_category::No(c);\n@@ -93,7 +93,7 @@ pure fn is_ascii(c: char) -> bool {\n \n /// Indicates whether the character is numeric (Nd, Nl, or No)\n pure fn is_digit(c: char) -> bool {\n-    ret unicode::general_category::Nd(c) ||\n+    return unicode::general_category::Nd(c) ||\n         unicode::general_category::Nl(c) ||\n         unicode::general_category::No(c);\n }\n@@ -117,7 +117,7 @@ pure fn to_digit(c: char, radix: uint) -> option<uint> {\n       '0' to '9' { c as uint - ('0' as uint) }\n       'a' to 'z' { c as uint + 10u - ('a' as uint) }\n       'A' to 'Z' { c as uint + 10u - ('A' as uint) }\n-      _ { ret none; }\n+      _ { return none; }\n     };\n     if val < radix { some(val) }\n     else { none }\n@@ -142,7 +142,7 @@ fn escape_unicode(c: char) -> ~str {\n     str::push_str(out, str::from_char(c));\n     for uint::range(str::len(s), pad) |_i| { str::push_str(out, ~\"0\"); }\n     str::push_str(out, s);\n-    ret out;\n+    return out;\n }\n \n /**\n@@ -178,7 +178,7 @@ fn escape_default(c: char) -> ~str {\n  * -1 if a < b, 0 if a == b, +1 if a > b\n  */\n pure fn cmp(a: char, b: char) -> int {\n-    ret  if b > a { -1 }\n+    return  if b > a { -1 }\n     else if b < a { 1 }\n     else { 0 }\n }"}, {"sha": "fd1067241a8dcd34078a814bd499b2b73cb6c42d", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -207,7 +207,7 @@ fn recv_<T: send>(p: *rust_port) -> T {\n         // this is a good place to yield\n         task::yield();\n     }\n-    ret res;\n+    return res;\n }\n \n fn peek_(p: *rust_port) -> bool {"}, {"sha": "4f1e02d674d1e343407fb47bafb79273bae28f11", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -72,7 +72,7 @@ fn from_vec<A>(+v: ~[mut A]) -> dvec<A> {\n /// Consumes the vector and returns its contents\n fn unwrap<A>(-d: dvec<A>) -> ~[mut A] {\n     let dvec_({data: v}) <- d;\n-    ret v;\n+    return v;\n }\n \n impl private_methods<A> for dvec<A> {\n@@ -92,7 +92,7 @@ impl private_methods<A> for dvec<A> {\n             data <-> self.data;\n             let data_ptr: *() = unsafe::reinterpret_cast(data);\n             if data_ptr.is_null() { fail ~\"Recursive use of dvec\"; }\n-            ret f(data);\n+            return f(data);\n         }\n     }\n \n@@ -263,7 +263,7 @@ impl extensions<A:copy> for dvec<A> {\n     #[inline(always)]\n     pure fn get_elt(idx: uint) -> A {\n         self.check_not_borrowed();\n-        ret self.data[idx];\n+        return self.data[idx];\n     }\n \n     /// Overwrites the contents of the element at `idx` with `a`\n@@ -295,7 +295,7 @@ impl extensions<A:copy> for dvec<A> {\n             fail ~\"attempt to retrieve the last element of an empty vector\";\n         }\n \n-        ret self.data[length - 1u];\n+        return self.data[length - 1u];\n     }\n \n     /// Iterates over the elements in reverse order"}, {"sha": "64a7abd0f3576e6a836e4ea44cd9153d5d30bbb4", "filename": "src/libcore/either.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -28,7 +28,7 @@ fn lefts<T: copy, U>(eithers: ~[either<T, U>]) -> ~[T] {\n     for vec::each(eithers) |elt| {\n         alt elt { left(l) { vec::push(result, l); } _ {/* fallthrough */ } }\n     }\n-    ret result;\n+    return result;\n }\n \n fn rights<T, U: copy>(eithers: ~[either<T, U>]) -> ~[U] {\n@@ -38,7 +38,7 @@ fn rights<T, U: copy>(eithers: ~[either<T, U>]) -> ~[U] {\n     for vec::each(eithers) |elt| {\n         alt elt { right(r) { vec::push(result, r); } _ {/* fallthrough */ } }\n     }\n-    ret result;\n+    return result;\n }\n \n fn partition<T: copy, U: copy>(eithers: ~[either<T, U>])\n@@ -58,7 +58,7 @@ fn partition<T: copy, U: copy>(eithers: ~[either<T, U>])\n           right(r) { vec::push(rights, r); }\n         }\n     }\n-    ret {lefts: lefts, rights: rights};\n+    return {lefts: lefts, rights: rights};\n }\n \n pure fn flip<T: copy, U: copy>(eith: either<T, U>) -> either<U, T> {"}, {"sha": "a4e3b2144c9b359abe612e1e25288ede805bca5d", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -90,7 +90,7 @@ mod ct {\n                 let piece = piece_string(buf);\n                 vec::push(pieces, piece);\n             }\n-            ret ~\"\";\n+            return ~\"\";\n         }\n         let mut i = 0u;\n         while i < lim {\n@@ -114,15 +114,15 @@ mod ct {\n             } else { buf += curr; i += size; }\n         }\n         flush_buf(buf, pieces);\n-        ret pieces;\n+        return pieces;\n     }\n     fn peek_num(s: ~str, i: uint, lim: uint) ->\n        option<{num: uint, next: uint}> {\n-        if i >= lim { ret none; }\n+        if i >= lim { return none; }\n         let c = s[i];\n-        if !('0' as u8 <= c && c <= '9' as u8) { ret option::none; }\n+        if !('0' as u8 <= c && c <= '9' as u8) { return option::none; }\n         let n = (c - ('0' as u8)) as uint;\n-        ret alt peek_num(s, i + 1u, lim) {\n+        return alt peek_num(s, i + 1u, lim) {\n               none { some({num: n, next: i + 1u}) }\n               some(next) {\n                 let m = next.num;\n@@ -138,7 +138,7 @@ mod ct {\n         let width = parse_count(s, flags.next, lim);\n         let prec = parse_precision(s, width.next, lim);\n         let ty = parse_type(s, prec.next, lim, error);\n-        ret {piece:\n+        return {piece:\n                  piece_conv({param: parm.param,\n                              flags: flags.flags,\n                              width: width.count,\n@@ -148,9 +148,9 @@ mod ct {\n     }\n     fn parse_parameter(s: ~str, i: uint, lim: uint) ->\n        {param: option<int>, next: uint} {\n-        if i >= lim { ret {param: none, next: i}; }\n+        if i >= lim { return {param: none, next: i}; }\n         let num = peek_num(s, i, lim);\n-        ret alt num {\n+        return alt num {\n               none { {param: none, next: i} }\n               some(t) {\n                 let n = t.num;\n@@ -164,19 +164,19 @@ mod ct {\n     fn parse_flags(s: ~str, i: uint, lim: uint) ->\n        {flags: ~[flag], next: uint} {\n         let noflags: ~[flag] = ~[];\n-        if i >= lim { ret {flags: noflags, next: i}; }\n+        if i >= lim { return {flags: noflags, next: i}; }\n \n         fn more_(f: flag, s: ~str, i: uint, lim: uint) ->\n            {flags: ~[flag], next: uint} {\n             let next = parse_flags(s, i + 1u, lim);\n             let rest = next.flags;\n             let j = next.next;\n             let curr: ~[flag] = ~[f];\n-            ret {flags: vec::append(curr, rest), next: j};\n+            return {flags: vec::append(curr, rest), next: j};\n         }\n         let more = |x| more_(x, s, i, lim);\n         let f = s[i];\n-        ret if f == '-' as u8 {\n+        return if f == '-' as u8 {\n                 more(flag_left_justify)\n             } else if f == '0' as u8 {\n                 more(flag_left_zero_pad)\n@@ -190,7 +190,7 @@ mod ct {\n     }\n     fn parse_count(s: ~str, i: uint, lim: uint)\n         -> {count: count, next: uint} {\n-        ret if i >= lim {\n+        return if i >= lim {\n                 {count: count_implied, next: i}\n             } else if s[i] == '*' as u8 {\n                 let param = parse_parameter(s, i + 1u, lim);\n@@ -211,7 +211,7 @@ mod ct {\n     }\n     fn parse_precision(s: ~str, i: uint, lim: uint) ->\n        {count: count, next: uint} {\n-        ret if i >= lim {\n+        return if i >= lim {\n                 {count: count_implied, next: i}\n             } else if s[i] == '.' as u8 {\n                 let count = parse_count(s, i + 1u, lim);\n@@ -255,7 +255,7 @@ mod ct {\n             } else if str::eq(tstr, ~\"?\") {\n                 ty_poly\n             } else { error(~\"unknown type in conversion: \" + tstr) };\n-        ret {ty: t, next: i + 1u};\n+        return {ty: t, next: i + 1u};\n     }\n }\n \n@@ -288,7 +288,7 @@ mod rt {\n                 unchecked { str::unshift_char(s, ' ') };\n             }\n         }\n-        ret unchecked { pad(cv, s, pad_signed) };\n+        return unchecked { pad(cv, s, pad_signed) };\n     }\n     pure fn conv_uint(cv: conv, u: uint) -> ~str {\n         let prec = get_int_precision(cv);\n@@ -300,17 +300,17 @@ mod rt {\n               ty_bits { uint_to_str_prec(u, 2u, prec) }\n               ty_octal { uint_to_str_prec(u, 8u, prec) }\n             };\n-        ret unchecked { pad(cv, rs, pad_unsigned) };\n+        return unchecked { pad(cv, rs, pad_unsigned) };\n     }\n     pure fn conv_bool(cv: conv, b: bool) -> ~str {\n         let s = if b { ~\"true\" } else { ~\"false\" };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n-        ret conv_str(cv, s);\n+        return conv_str(cv, s);\n     }\n     pure fn conv_char(cv: conv, c: char) -> ~str {\n         let mut s = str::from_char(c);\n-        ret unchecked { pad(cv, s, pad_nozero) };\n+        return unchecked { pad(cv, s, pad_nozero) };\n     }\n     pure fn conv_str(cv: conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n@@ -323,7 +323,7 @@ mod rt {\n             } else { s.to_unique() }\n           }\n         };\n-        ret unchecked { pad(cv, unpadded, pad_nozero) };\n+        return unchecked { pad(cv, unpadded, pad_nozero) };\n     }\n     pure fn conv_float(cv: conv, f: float) -> ~str {\n         let (to_str, digits) = alt cv.precision {\n@@ -338,17 +338,17 @@ mod rt {\n                 s = ~\" \" + s;\n             }\n         }\n-        ret unchecked { pad(cv, s, pad_float) };\n+        return unchecked { pad(cv, s, pad_float) };\n     }\n     pure fn conv_poly<T>(cv: conv, v: T) -> ~str {\n         let s = sys::log_str(v);\n-        ret conv_str(cv, s);\n+        return conv_str(cv, s);\n     }\n \n     // Convert an int to string with minimum number of digits. If precision is\n     // 0 and num is 0 then the result is the empty string.\n     pure fn int_to_str_prec(num: int, radix: uint, prec: uint) -> ~str {\n-        ret if num < 0 {\n+        return if num < 0 {\n                 ~\"-\" + uint_to_str_prec(-num as uint, radix, prec)\n             } else { uint_to_str_prec(num as uint, radix, prec) };\n     }\n@@ -357,7 +357,7 @@ mod rt {\n     // is 0 and num is 0 then the result is the empty string. Could move this\n     // to uint: but it doesn't seem all that useful.\n     pure fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> ~str {\n-        ret if prec == 0u && num == 0u {\n+        return if prec == 0u && num == 0u {\n                 ~\"\"\n             } else {\n                 let s = uint::to_str(num, radix);\n@@ -370,27 +370,27 @@ mod rt {\n             };\n     }\n     pure fn get_int_precision(cv: conv) -> uint {\n-        ret alt cv.precision {\n+        return alt cv.precision {\n               count_is(c) { c as uint }\n               count_implied { 1u }\n             };\n     }\n     enum pad_mode { pad_signed, pad_unsigned, pad_nozero, pad_float }\n     fn pad(cv: conv, &s: ~str, mode: pad_mode) -> ~str {\n         let uwidth : uint = alt cv.width {\n-          count_implied { ret s; }\n+          count_implied { return s; }\n           count_is(width) {\n               // FIXME: width should probably be uint (see Issue #1996)\n               width as uint\n           }\n         };\n         let strlen = str::char_len(s);\n-        if uwidth <= strlen { ret s; }\n+        if uwidth <= strlen { return s; }\n         let mut padchar = ' ';\n         let diff = uwidth - strlen;\n         if have_flag(cv.flags, flag_left_justify) {\n             let padstr = str::from_chars(vec::from_elem(diff, padchar));\n-            ret s + padstr;\n+            return s + padstr;\n         }\n         let {might_zero_pad, signed} = alt mode {\n           pad_nozero {   {might_zero_pad:false, signed:false} }\n@@ -399,7 +399,7 @@ mod rt {\n           pad_unsigned { {might_zero_pad:true,  signed:false} }\n         };\n         pure fn have_precision(cv: conv) -> bool {\n-            ret alt cv.precision { count_implied { false } _ { true } };\n+            return alt cv.precision { count_implied { false } _ { true } };\n         }\n         let zero_padding = {\n             if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n@@ -420,13 +420,13 @@ mod rt {\n             let head = str::shift_char(s);\n             if head == '+' || head == '-' || head == ' ' {\n                 let headstr = str::from_chars(vec::from_elem(1u, head));\n-                ret headstr + padstr + s;\n+                return headstr + padstr + s;\n             }\n             else {\n                 str::unshift_char(s, head);\n             }\n         }\n-        ret padstr + s;\n+        return padstr + s;\n     }\n     pure fn have_flag(flags: u32, f: u32) -> bool {\n         flags & f != 0"}, {"sha": "c9852eb67b6429188b04c53e07d9bb38f6c5f7d2", "filename": "src/libcore/f32.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff32.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -31,46 +31,46 @@ const neg_infinity: f32 = -1.0_f32/0.0_f32;\n \n pure fn is_NaN(f: f32) -> bool { f != f }\n \n-pure fn add(x: f32, y: f32) -> f32 { ret x + y; }\n+pure fn add(x: f32, y: f32) -> f32 { return x + y; }\n \n-pure fn sub(x: f32, y: f32) -> f32 { ret x - y; }\n+pure fn sub(x: f32, y: f32) -> f32 { return x - y; }\n \n-pure fn mul(x: f32, y: f32) -> f32 { ret x * y; }\n+pure fn mul(x: f32, y: f32) -> f32 { return x * y; }\n \n-pure fn div(x: f32, y: f32) -> f32 { ret x / y; }\n+pure fn div(x: f32, y: f32) -> f32 { return x / y; }\n \n-pure fn rem(x: f32, y: f32) -> f32 { ret x % y; }\n+pure fn rem(x: f32, y: f32) -> f32 { return x % y; }\n \n-pure fn lt(x: f32, y: f32) -> bool { ret x < y; }\n+pure fn lt(x: f32, y: f32) -> bool { return x < y; }\n \n-pure fn le(x: f32, y: f32) -> bool { ret x <= y; }\n+pure fn le(x: f32, y: f32) -> bool { return x <= y; }\n \n-pure fn eq(x: f32, y: f32) -> bool { ret x == y; }\n+pure fn eq(x: f32, y: f32) -> bool { return x == y; }\n \n-pure fn ne(x: f32, y: f32) -> bool { ret x != y; }\n+pure fn ne(x: f32, y: f32) -> bool { return x != y; }\n \n-pure fn ge(x: f32, y: f32) -> bool { ret x >= y; }\n+pure fn ge(x: f32, y: f32) -> bool { return x >= y; }\n \n-pure fn gt(x: f32, y: f32) -> bool { ret x > y; }\n+pure fn gt(x: f32, y: f32) -> bool { return x > y; }\n \n // FIXME (#1999): replace the predicates below with llvm intrinsics or\n // calls to the libmath macros in the rust runtime for performance.\n \n /// Returns true if `x` is a positive number, including +0.0f320 and +Infinity\n pure fn is_positive(x: f32) -> bool\n-    { ret x > 0.0f32 || (1.0f32/x) == infinity; }\n+    { return x > 0.0f32 || (1.0f32/x) == infinity; }\n \n /// Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n pure fn is_negative(x: f32) -> bool\n-    { ret x < 0.0f32 || (1.0f32/x) == neg_infinity; }\n+    { return x < 0.0f32 || (1.0f32/x) == neg_infinity; }\n \n /**\n  * Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n  *\n  * This is the same as `f32::is_negative`.\n  */\n pure fn is_nonpositive(x: f32) -> bool {\n-  ret x < 0.0f32 || (1.0f32/x) == neg_infinity;\n+  return x < 0.0f32 || (1.0f32/x) == neg_infinity;\n }\n \n /**\n@@ -79,22 +79,22 @@ pure fn is_nonpositive(x: f32) -> bool {\n  * This is the same as `f32::is_positive`.)\n  */\n pure fn is_nonnegative(x: f32) -> bool {\n-  ret x > 0.0f32 || (1.0f32/x) == infinity;\n+  return x > 0.0f32 || (1.0f32/x) == infinity;\n }\n \n /// Returns true if `x` is a zero number (positive or negative zero)\n pure fn is_zero(x: f32) -> bool {\n-    ret x == 0.0f32 || x == -0.0f32;\n+    return x == 0.0f32 || x == -0.0f32;\n }\n \n /// Returns true if `x`is an infinite number\n pure fn is_infinite(x: f32) -> bool {\n-    ret x == infinity || x == neg_infinity;\n+    return x == infinity || x == neg_infinity;\n }\n \n /// Returns true if `x`is a finite number\n pure fn is_finite(x: f32) -> bool {\n-    ret !(is_NaN(x) || is_infinite(x));\n+    return !(is_NaN(x) || is_infinite(x));\n }\n \n // FIXME (#1999): add is_normal, is_subnormal, and fpclassify.\n@@ -145,38 +145,38 @@ mod consts {\n }\n \n pure fn signbit(x: f32) -> int {\n-    if is_negative(x) { ret 1; } else { ret 0; }\n+    if is_negative(x) { return 1; } else { return 0; }\n }\n \n #[cfg(target_os=\"linux\")]\n #[cfg(target_os=\"macos\")]\n #[cfg(target_os=\"win32\")]\n pure fn logarithm(n: f32, b: f32) -> f32 {\n-    ret log2(n) / log2(b);\n+    return log2(n) / log2(b);\n }\n \n #[cfg(target_os=\"freebsd\")]\n pure fn logarithm(n: f32, b: f32) -> f32 {\n     // FIXME (#2000): check if it is good to use log2 instead of ln here;\n     // in theory should be faster since the radix is 2\n-    ret ln(n) / ln(b);\n+    return ln(n) / ln(b);\n }\n \n #[cfg(target_os=\"freebsd\")]\n pure fn log2(n: f32) -> f32 {\n-    ret ln(n) / consts::ln_2;\n+    return ln(n) / consts::ln_2;\n }\n \n impl num of num::num for f32 {\n-    pure fn add(&&other: f32)    -> f32 { ret self + other; }\n-    pure fn sub(&&other: f32)    -> f32 { ret self - other; }\n-    pure fn mul(&&other: f32)    -> f32 { ret self * other; }\n-    pure fn div(&&other: f32)    -> f32 { ret self / other; }\n-    pure fn modulo(&&other: f32) -> f32 { ret self % other; }\n-    pure fn neg()                -> f32 { ret -self;        }\n-\n-    pure fn to_int()         -> int { ret self as int; }\n-    pure fn from_int(n: int) -> f32 { ret n as f32;    }\n+    pure fn add(&&other: f32)    -> f32 { return self + other; }\n+    pure fn sub(&&other: f32)    -> f32 { return self - other; }\n+    pure fn mul(&&other: f32)    -> f32 { return self * other; }\n+    pure fn div(&&other: f32)    -> f32 { return self / other; }\n+    pure fn modulo(&&other: f32) -> f32 { return self % other; }\n+    pure fn neg()                -> f32 { return -self;        }\n+\n+    pure fn to_int()         -> int { return self as int; }\n+    pure fn from_int(n: int) -> f32 { return n as f32;    }\n }\n \n //"}, {"sha": "550ed568be4a99a37a9a252533b55061d0292859", "filename": "src/libcore/f64.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff64.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -57,47 +57,47 @@ const neg_infinity: f64 = -1.0_f64/0.0_f64;\n \n pure fn is_NaN(f: f64) -> bool { f != f }\n \n-pure fn add(x: f64, y: f64) -> f64 { ret x + y; }\n+pure fn add(x: f64, y: f64) -> f64 { return x + y; }\n \n-pure fn sub(x: f64, y: f64) -> f64 { ret x - y; }\n+pure fn sub(x: f64, y: f64) -> f64 { return x - y; }\n \n-pure fn mul(x: f64, y: f64) -> f64 { ret x * y; }\n+pure fn mul(x: f64, y: f64) -> f64 { return x * y; }\n \n-pure fn div(x: f64, y: f64) -> f64 { ret x / y; }\n+pure fn div(x: f64, y: f64) -> f64 { return x / y; }\n \n-pure fn rem(x: f64, y: f64) -> f64 { ret x % y; }\n+pure fn rem(x: f64, y: f64) -> f64 { return x % y; }\n \n-pure fn lt(x: f64, y: f64) -> bool { ret x < y; }\n+pure fn lt(x: f64, y: f64) -> bool { return x < y; }\n \n-pure fn le(x: f64, y: f64) -> bool { ret x <= y; }\n+pure fn le(x: f64, y: f64) -> bool { return x <= y; }\n \n-pure fn eq(x: f64, y: f64) -> bool { ret x == y; }\n+pure fn eq(x: f64, y: f64) -> bool { return x == y; }\n \n-pure fn ne(x: f64, y: f64) -> bool { ret x != y; }\n+pure fn ne(x: f64, y: f64) -> bool { return x != y; }\n \n-pure fn ge(x: f64, y: f64) -> bool { ret x >= y; }\n+pure fn ge(x: f64, y: f64) -> bool { return x >= y; }\n \n-pure fn gt(x: f64, y: f64) -> bool { ret x > y; }\n+pure fn gt(x: f64, y: f64) -> bool { return x > y; }\n \n pure fn sqrt(x: f64) -> f64 {\n     cmath::c_double::sqrt(x as libc::c_double) as f64\n }\n \n /// Returns true if `x` is a positive number, including +0.0f640 and +Infinity\n pure fn is_positive(x: f64) -> bool\n-    { ret x > 0.0f64 || (1.0f64/x) == infinity; }\n+    { return x > 0.0f64 || (1.0f64/x) == infinity; }\n \n /// Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n pure fn is_negative(x: f64) -> bool\n-    { ret x < 0.0f64 || (1.0f64/x) == neg_infinity; }\n+    { return x < 0.0f64 || (1.0f64/x) == neg_infinity; }\n \n /**\n  * Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n  *\n  * This is the same as `f64::is_negative`.\n  */\n pure fn is_nonpositive(x: f64) -> bool {\n-  ret x < 0.0f64 || (1.0f64/x) == neg_infinity;\n+  return x < 0.0f64 || (1.0f64/x) == neg_infinity;\n }\n \n /**\n@@ -106,22 +106,22 @@ pure fn is_nonpositive(x: f64) -> bool {\n  * This is the same as `f64::positive`.\n  */\n pure fn is_nonnegative(x: f64) -> bool {\n-  ret x > 0.0f64 || (1.0f64/x) == infinity;\n+  return x > 0.0f64 || (1.0f64/x) == infinity;\n }\n \n /// Returns true if `x` is a zero number (positive or negative zero)\n pure fn is_zero(x: f64) -> bool {\n-    ret x == 0.0f64 || x == -0.0f64;\n+    return x == 0.0f64 || x == -0.0f64;\n }\n \n /// Returns true if `x`is an infinite number\n pure fn is_infinite(x: f64) -> bool {\n-    ret x == infinity || x == neg_infinity;\n+    return x == infinity || x == neg_infinity;\n }\n \n /// Returns true if `x`is a finite number\n pure fn is_finite(x: f64) -> bool {\n-    ret !(is_NaN(x) || is_infinite(x));\n+    return !(is_NaN(x) || is_infinite(x));\n }\n \n // FIXME (#1999): add is_normal, is_subnormal, and fpclassify\n@@ -172,38 +172,38 @@ mod consts {\n }\n \n pure fn signbit(x: f64) -> int {\n-    if is_negative(x) { ret 1; } else { ret 0; }\n+    if is_negative(x) { return 1; } else { return 0; }\n }\n \n #[cfg(target_os=\"linux\")]\n #[cfg(target_os=\"macos\")]\n #[cfg(target_os=\"win32\")]\n pure fn logarithm(n: f64, b: f64) -> f64 {\n-    ret log2(n) / log2(b);\n+    return log2(n) / log2(b);\n }\n \n #[cfg(target_os=\"freebsd\")]\n pure fn logarithm(n: f64, b: f64) -> f64 {\n     // FIXME (#2000): check if it is good to use log2 instead of ln here; in\n     // theory should be faster since the radix is 2\n-    ret ln(n) / ln(b);\n+    return ln(n) / ln(b);\n }\n \n #[cfg(target_os=\"freebsd\")]\n pure fn log2(n: f64) -> f64 {\n-    ret ln(n) / consts::ln_2;\n+    return ln(n) / consts::ln_2;\n }\n \n impl num of num::num for f64 {\n-    pure fn add(&&other: f64)    -> f64 { ret self + other; }\n-    pure fn sub(&&other: f64)    -> f64 { ret self - other; }\n-    pure fn mul(&&other: f64)    -> f64 { ret self * other; }\n-    pure fn div(&&other: f64)    -> f64 { ret self / other; }\n-    pure fn modulo(&&other: f64) -> f64 { ret self % other; }\n-    pure fn neg()                -> f64 { ret -self;        }\n-\n-    pure fn to_int()         -> int { ret self as int; }\n-    pure fn from_int(n: int) -> f64 { ret n as f64;    }\n+    pure fn add(&&other: f64)    -> f64 { return self + other; }\n+    pure fn sub(&&other: f64)    -> f64 { return self - other; }\n+    pure fn mul(&&other: f64)    -> f64 { return self * other; }\n+    pure fn div(&&other: f64)    -> f64 { return self / other; }\n+    pure fn modulo(&&other: f64) -> f64 { return self % other; }\n+    pure fn neg()                -> f64 { return -self;        }\n+\n+    pure fn to_int()         -> int { return self as int; }\n+    pure fn from_int(n: int) -> f64 { return n as f64;    }\n }\n \n //"}, {"sha": "e9dd26d23ce5a233bd1687e1dfd0169fd6677f55", "filename": "src/libcore/float.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -103,9 +103,9 @@ mod consts {\n  * * exact - Whether to enforce the exact number of significant digits\n  */\n fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n-    if is_NaN(num) { ret ~\"NaN\"; }\n-    if num == infinity { ret ~\"inf\"; }\n-    if num == neg_infinity { ret ~\"-inf\"; }\n+    if is_NaN(num) { return ~\"NaN\"; }\n+    if num == infinity { return ~\"inf\"; }\n+    if num == neg_infinity { return ~\"-inf\"; }\n \n     let mut (num, sign) = if num < 0.0 { (-num, ~\"-\") } else { (num, ~\"\") };\n \n@@ -122,7 +122,7 @@ fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n     // This used to return right away without rounding, as \"~[-]num\",\n     // but given epsilon like in f64.rs, I don't see how the comparison\n     // to epsilon did much when only used there.\n-    //    if (frac < epsilon && !exact) || digits == 0u { ret accum; }\n+    //    if (frac < epsilon && !exact) || digits == 0u { return accum; }\n     //\n     // With something better, possibly weird results like this can be avoided:\n     //     assert \"3.14158999999999988262\" == my_to_str_exact(3.14159, 20u);\n@@ -176,7 +176,7 @@ fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n         acc = sign + ones + ~\".\" + racc;\n     }\n \n-    ret acc;\n+    return acc;\n }\n \n /**\n@@ -240,25 +240,25 @@ fn to_str(num: float, digits: uint) -> ~str {\n  */\n fn from_str(num: ~str) -> option<float> {\n    if num == ~\"inf\" {\n-       ret some(infinity as float);\n+       return some(infinity as float);\n    } else if num == ~\"-inf\" {\n-       ret some(neg_infinity as float);\n+       return some(neg_infinity as float);\n    } else if num == ~\"NaN\" {\n-       ret some(NaN as float);\n+       return some(NaN as float);\n    }\n \n    let mut pos = 0u;               //Current byte position in the string.\n                                    //Used to walk the string in O(n).\n    let len = str::len(num);        //Length of the string, in bytes.\n \n-   if len == 0u { ret none; }\n+   if len == 0u { return none; }\n    let mut total = 0f;             //Accumulated result\n    let mut c     = 'z';            //Latest char.\n \n    //The string must start with one of the following characters.\n    alt str::char_at(num, 0u) {\n       '-' | '+' | '0' to '9' | '.' {}\n-      _ { ret none; }\n+      _ { return none; }\n    }\n \n    //Determine if first char is '-'/'+'. Set [pos] and [neg] accordingly.\n@@ -288,7 +288,7 @@ fn from_str(num: ~str) -> option<float> {\n            break;\n          }\n          _ {\n-           ret none;\n+           return none;\n          }\n        }\n    }\n@@ -308,7 +308,7 @@ fn from_str(num: ~str) -> option<float> {\n                  break;\n              }\n              _ {\n-                 ret none;\n+                 return none;\n              }\n          }\n       }\n@@ -353,17 +353,17 @@ fn from_str(num: ~str) -> option<float> {\n              total = total * multiplier;\n           }\n       } else {\n-         ret none;\n+         return none;\n       }\n    }\n \n    if(pos < len) {\n-     ret none;\n+     return none;\n    } else {\n      if(neg) {\n         total *= -1f;\n      }\n-     ret some(total);\n+     return some(total);\n    }\n }\n \n@@ -386,9 +386,9 @@ fn from_str(num: ~str) -> option<float> {\n fn pow_with_uint(base: uint, pow: uint) -> float {\n     if base == 0u {\n         if pow == 0u {\n-            ret NaN as float;\n+            return NaN as float;\n         }\n-        ret 0.;\n+        return 0.;\n     }\n     let mut my_pow     = pow;\n     let mut total      = 1f;\n@@ -400,7 +400,7 @@ fn pow_with_uint(base: uint, pow: uint) -> float {\n         my_pow     /= 2u;\n         multiplier *= multiplier;\n     }\n-    ret total;\n+    return total;\n }\n \n pure fn is_positive(x: float) -> bool { f64::is_positive(x as f64) }\n@@ -420,15 +420,15 @@ pure fn cos(x: float) -> float { f64::cos(x as f64) as float }\n pure fn tan(x: float) -> float { f64::tan(x as f64) as float }\n \n impl num of num::num for float {\n-    pure fn add(&&other: float)    -> float { ret self + other; }\n-    pure fn sub(&&other: float)    -> float { ret self - other; }\n-    pure fn mul(&&other: float)    -> float { ret self * other; }\n-    pure fn div(&&other: float)    -> float { ret self / other; }\n-    pure fn modulo(&&other: float) -> float { ret self % other; }\n-    pure fn neg()                  -> float { ret -self;        }\n-\n-    pure fn to_int()         -> int   { ret self as int; }\n-    pure fn from_int(n: int) -> float { ret n as float;  }\n+    pure fn add(&&other: float)    -> float { return self + other; }\n+    pure fn sub(&&other: float)    -> float { return self - other; }\n+    pure fn mul(&&other: float)    -> float { return self * other; }\n+    pure fn div(&&other: float)    -> float { return self / other; }\n+    pure fn modulo(&&other: float) -> float { return self % other; }\n+    pure fn neg()                  -> float { return -self;        }\n+\n+    pure fn to_int()         -> int   { return self as int; }\n+    pure fn from_int(n: int) -> float { return n as float;  }\n }\n \n #[test]"}, {"sha": "1b2a933c67f8cb781a40bcbe26bb34499ec9485d", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -10,7 +10,7 @@\n  */\n \n pure fn hash_bytes(buf: &[const u8]) -> u64 {\n-    ret hash_bytes_keyed(buf, 0u64, 0u64);\n+    return hash_bytes_keyed(buf, 0u64, 0u64);\n }\n \n pure fn hash_u64(val: u64) -> u64 {\n@@ -113,7 +113,7 @@ pure fn hash_bytes_keyed(buf: &[const u8], k0: u64, k1: u64) -> u64 {\n     compress!{v0,v1,v2,v3};\n     compress!{v0,v1,v2,v3};\n \n-    ret v0 ^ v1 ^ v2 ^ v3;\n+    return v0 ^ v1 ^ v2 ^ v3;\n }\n \n \n@@ -156,7 +156,7 @@ fn siphash(key0 : u64, key1 : u64) -> streaming {\n                 }\n                 st.ntail += length;\n \n-                ret;\n+                return;\n             }\n \n             let mut t = 0;\n@@ -229,7 +229,7 @@ fn siphash(key0 : u64, key1 : u64) -> streaming {\n \n         let h = v0 ^ v1 ^ v2 ^ v3;\n \n-        ret ~[\n+        return ~[\n             (h >> 0) as u8,\n             (h >> 8) as u8,\n             (h >> 16) as u8,\n@@ -252,12 +252,12 @@ fn siphash(key0 : u64, key1 : u64) -> streaming {\n         }\n         fn input(msg: ~[u8]) { add_input(self, msg); }\n         fn input_str(msg: ~str) { add_input(self, str::bytes(msg)); }\n-        fn result() -> ~[u8] { ret mk_result(self); }\n+        fn result() -> ~[u8] { return mk_result(self); }\n         fn result_str() -> ~str {\n             let r = mk_result(self);\n             let mut s = ~\"\";\n             for vec::each(r) |b| { s += uint::to_str(b as uint, 16u); }\n-            ret s;\n+            return s;\n         }\n     }\n \n@@ -275,7 +275,7 @@ fn siphash(key0 : u64, key1 : u64) -> streaming {\n \n     let sh = st as streaming;\n     sh.reset();\n-    ret sh;\n+    return sh;\n }\n \n #[test]\n@@ -357,7 +357,7 @@ fn test_siphash() {\n     fn to_hex_str(r:[u8]/8) -> ~str {\n         let mut s = ~\"\";\n         for vec::each(r) |b| { s += uint::to_str(b as uint, 16u); }\n-        ret s;\n+        return s;\n     }\n \n     while t < 64 {"}, {"sha": "46413517a5bc508727cbafc011df2ed3eb570d24", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -67,7 +67,7 @@ pure fn abs(i: T) -> T {\n  * * radix - The base of the number\n  */\n fn parse_buf(buf: ~[u8], radix: uint) -> option<T> {\n-    if vec::len(buf) == 0u { ret none; }\n+    if vec::len(buf) == 0u { return none; }\n     let mut i = vec::len(buf) - 1u;\n     let mut start = 0u;\n     let mut power = 1 as T;\n@@ -80,10 +80,10 @@ fn parse_buf(buf: ~[u8], radix: uint) -> option<T> {\n     loop {\n         alt char::to_digit(buf[i] as char, radix) {\n           some(d) { n += (d as T) * power; }\n-          none { ret none; }\n+          none { return none; }\n         }\n         power *= radix as T;\n-        if i <= start { ret some(n); }\n+        if i <= start { return some(n); }\n         i -= 1u;\n     };\n }\n@@ -109,30 +109,30 @@ fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n }\n \n /// Convert to a string\n-fn str(i: T) -> ~str { ret to_str(i, 10u); }\n+fn str(i: T) -> ~str { return to_str(i, 10u); }\n \n impl ord of ord for T {\n     pure fn lt(&&other: T) -> bool {\n-        ret self < other;\n+        return self < other;\n     }\n }\n \n impl eq of eq for T {\n     pure fn eq(&&other: T) -> bool {\n-        ret self == other;\n+        return self == other;\n     }\n }\n \n impl num of num::num for T {\n-    pure fn add(&&other: T)    -> T { ret self + other; }\n-    pure fn sub(&&other: T)    -> T { ret self - other; }\n-    pure fn mul(&&other: T)    -> T { ret self * other; }\n-    pure fn div(&&other: T)    -> T { ret self / other; }\n-    pure fn modulo(&&other: T) -> T { ret self % other; }\n-    pure fn neg()              -> T { ret -self;        }\n-\n-    pure fn to_int()         -> int { ret self as int; }\n-    pure fn from_int(n: int) -> T   { ret n as T;      }\n+    pure fn add(&&other: T)    -> T { return self + other; }\n+    pure fn sub(&&other: T)    -> T { return self - other; }\n+    pure fn mul(&&other: T)    -> T { return self * other; }\n+    pure fn div(&&other: T)    -> T { return self / other; }\n+    pure fn modulo(&&other: T) -> T { return self % other; }\n+    pure fn neg()              -> T { return -self;        }\n+\n+    pure fn to_int()         -> int { return self as int; }\n+    pure fn from_int(n: int) -> T   { return n as T;      }\n }\n \n impl times of iter::times for T {"}, {"sha": "500316de2f78a9a5b539adbed6dfe9397180ec55", "filename": "src/libcore/int-template/int.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fint.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -7,12 +7,12 @@ const bits: T = 32 as T;\n const bits: T = 64 as T;\n \n /// Produce a uint suitable for use in a hash table\n-pure fn hash(&&x: int) -> uint { ret x as uint; }\n+pure fn hash(&&x: int) -> uint { return x as uint; }\n \n /// Returns `base` raised to the power of `exponent`\n fn pow(base: int, exponent: uint) -> int {\n-    if exponent == 0u { ret 1; } //Not mathemtically true if ~[base == 0]\n-    if base     == 0  { ret 0; }\n+    if exponent == 0u { return 1; } //Not mathemtically true if ~[base == 0]\n+    if base     == 0  { return 0; }\n     let mut my_pow  = exponent;\n     let mut acc     = 1;\n     let mut multiplier = base;\n@@ -23,7 +23,7 @@ fn pow(base: int, exponent: uint) -> int {\n       my_pow     /= 2u;\n       multiplier *= multiplier;\n     }\n-    ret acc;\n+    return acc;\n }\n \n #[test]"}, {"sha": "1831938496aa34ffad763b4a5d5e8f7fec4d739f", "filename": "src/libcore/io.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -69,7 +69,7 @@ impl reader_util for reader {\n                 }\n                 // can't satisfy this char with the existing data\n                 if end > vec::len(buf) {\n-                    ret (i - 1u, end - vec::len(buf));\n+                    return (i - 1u, end - vec::len(buf));\n                 }\n                 let mut val = 0u;\n                 while i < end {\n@@ -85,7 +85,7 @@ impl reader_util for reader {\n                     << (w - 1u) * 6u - w - 1u;\n                 vec::push(chars,  val as char );\n             }\n-            ret (i, 0u);\n+            return (i, 0u);\n         }\n         let mut buf: ~[u8] = ~[];\n         let mut chars: ~[char] = ~[];\n@@ -115,10 +115,10 @@ impl reader_util for reader {\n     fn read_char() -> char {\n         let c = self.read_chars(1u);\n         if vec::len(c) == 0u {\n-            ret -1 as char; // FIXME will this stay valid? // #2004\n+            return -1 as char; // FIXME will this stay valid? // #2004\n         }\n         assert(vec::len(c) == 1u);\n-        ret c[0];\n+        return c[0];\n     }\n \n     fn read_line() -> ~str {\n@@ -196,7 +196,7 @@ impl reader_util for reader {\n // Reader implementations\n \n fn convert_whence(whence: seek_style) -> i32 {\n-    ret alt whence {\n+    return alt whence {\n       seek_set { 0i32 }\n       seek_cur { 1i32 }\n       seek_end { 2i32 }\n@@ -214,14 +214,14 @@ impl of reader for *libc::FILE {\n             count as uint\n         }\n     }\n-    fn read_byte() -> int { ret libc::fgetc(self) as int; }\n+    fn read_byte() -> int { return libc::fgetc(self) as int; }\n     fn unread_byte(byte: int) { libc::ungetc(byte as c_int, self); }\n-    fn eof() -> bool { ret libc::feof(self) != 0 as c_int; }\n+    fn eof() -> bool { return libc::feof(self) != 0 as c_int; }\n     fn seek(offset: int, whence: seek_style) {\n         assert libc::fseek(self, offset as c_long, convert_whence(whence))\n             == 0 as c_int;\n     }\n-    fn tell() -> uint { ret libc::ftell(self) as uint; }\n+    fn tell() -> uint { return libc::ftell(self) as uint; }\n }\n \n // A forwarding impl of reader that also holds on to a resource for the\n@@ -262,7 +262,7 @@ fn file_reader(path: ~str) -> result<reader, ~str> {\n             libc::fopen(pathbuf, modebuf)\n         )\n     });\n-    ret if f as uint == 0u { result::err(~\"error opening \" + path) }\n+    return if f as uint == 0u { result::err(~\"error opening \" + path) }\n     else {\n         result::ok(FILE_reader(f, true))\n     }\n@@ -285,10 +285,10 @@ impl of reader for byte_buf {\n         count\n     }\n     fn read_byte() -> int {\n-        if self.pos == self.len { ret -1; }\n+        if self.pos == self.len { return -1; }\n         let b = self.buf[self.pos];\n         self.pos += 1u;\n-        ret b as int;\n+        return b as int;\n     }\n     // FIXME (#2738): implement this\n     fn unread_byte(_byte: int) { error!{\"Unimplemented: unread_byte\"}; fail; }\n@@ -530,7 +530,7 @@ fn u64_from_be_bytes(data: ~[u8], start: uint, size: uint) -> u64 {\n         val += (data[pos] as u64) << ((sz * 8u) as u64);\n         pos += 1u;\n     }\n-    ret val;\n+    return val;\n }\n \n impl writer_util for writer {\n@@ -616,7 +616,7 @@ fn buffered_file_writer(path: ~str) -> result<writer, ~str> {\n             libc::fopen(pathbuf, modebuf)\n         }\n     };\n-    ret if f as uint == 0u { result::err(~\"error opening \" + path) }\n+    return if f as uint == 0u { result::err(~\"error opening \" + path) }\n     else { result::ok(FILE_writer(f, true)) }\n }\n \n@@ -639,7 +639,7 @@ impl of writer for mem_buffer {\n         if self.pos == buf_len {\n             self.buf.push_all(v);\n             self.pos += vlen;\n-            ret;\n+            return;\n         }\n \n         // FIXME #2004--use memcpy here?\n@@ -696,7 +696,7 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n       seek_end { bpos = blen + offset; }\n     }\n     if bpos < 0 { bpos = 0; } else if bpos > blen { bpos = blen; }\n-    ret bpos as uint;\n+    return bpos as uint;\n }\n \n fn read_whole_file_str(file: ~str) -> result<~str, ~str> {\n@@ -764,7 +764,7 @@ mod fsync {\n         blk(res({\n             val: file.f, opt_level: opt_level,\n             fsync_fn: fn@(&&file: *libc::FILE, l: level) -> int {\n-                ret os::fsync_fd(libc::fileno(file), l) as int;\n+                return os::fsync_fd(libc::fileno(file), l) as int;\n             }\n         }));\n     }\n@@ -775,7 +775,7 @@ mod fsync {\n         blk(res({\n             val: fd.fd, opt_level: opt_level,\n             fsync_fn: fn@(&&fd: fd_t, l: level) -> int {\n-                ret os::fsync_fd(fd, l) as int;\n+                return os::fsync_fd(fd, l) as int;\n             }\n         }));\n     }\n@@ -787,7 +787,7 @@ mod fsync {\n     fn obj_sync(&&o: t, opt_level: option<level>, blk: fn(&&res<t>)) {\n         blk(res({\n             val: o, opt_level: opt_level,\n-            fsync_fn: fn@(&&o: t, l: level) -> int { ret o.fsync(l); }\n+            fsync_fn: fn@(&&o: t, l: level) -> int { return o.fsync(l); }\n         }));\n     }\n }"}, {"sha": "a7ba67ec1bd6303ae73de358e2ee1850afac117d", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -41,8 +41,8 @@ impl extensions<A:copy> of iter::copyable_iter<A> for IMPL_T<A> {\n \n     fn find(p: fn(A) -> bool) -> option<A> {\n         for self.each |i| {\n-            if p(i) { ret some(i) }\n+            if p(i) { return some(i) }\n         }\n-        ret none;\n+        return none;\n     }\n }"}, {"sha": "0e635eeb0026bcb58fdc46d03acfe3aefb6da44b", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -39,16 +39,16 @@ fn eachi<A,IA:base_iter<A>>(self: IA, blk: fn(uint, A) -> bool) {\n \n fn all<A,IA:base_iter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n     for self.each |a| {\n-        if !blk(a) { ret false; }\n+        if !blk(a) { return false; }\n     }\n-    ret true;\n+    return true;\n }\n \n fn any<A,IA:base_iter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n     for self.each |a| {\n-        if blk(a) { ret true; }\n+        if blk(a) { return true; }\n     }\n-    ret false;\n+    return false;\n }\n \n fn filter_to_vec<A:copy,IA:base_iter<A>>(self: IA,\n@@ -58,7 +58,7 @@ fn filter_to_vec<A:copy,IA:base_iter<A>>(self: IA,\n     for self.each |a| {\n         if prd(a) { vec::push(result, a); }\n     }\n-    ret result;\n+    return result;\n }\n \n fn map_to_vec<A:copy,B,IA:base_iter<A>>(self: IA, op: fn(A) -> B) -> ~[B] {\n@@ -67,7 +67,7 @@ fn map_to_vec<A:copy,B,IA:base_iter<A>>(self: IA, op: fn(A) -> B) -> ~[B] {\n     for self.each |a| {\n         vec::push(result, op(a));\n     }\n-    ret result;\n+    return result;\n }\n \n fn flat_map_to_vec<A:copy,B:copy,IA:base_iter<A>,IB:base_iter<B>>(\n@@ -79,15 +79,15 @@ fn flat_map_to_vec<A:copy,B:copy,IA:base_iter<A>,IB:base_iter<B>>(\n             vec::push(result, b);\n         }\n     }\n-    ret result;\n+    return result;\n }\n \n fn foldl<A,B,IA:base_iter<A>>(self: IA, +b0: B, blk: fn(B, A) -> B) -> B {\n     let mut b <- b0;\n     for self.each |a| {\n         b = blk(b, a);\n     }\n-    ret b;\n+    return b;\n }\n \n fn to_vec<A:copy,IA:base_iter<A>>(self: IA) -> ~[A] {\n@@ -96,9 +96,9 @@ fn to_vec<A:copy,IA:base_iter<A>>(self: IA) -> ~[A] {\n \n fn contains<A,IA:base_iter<A>>(self: IA, x: A) -> bool {\n     for self.each |a| {\n-        if a == x { ret true; }\n+        if a == x { return true; }\n     }\n-    ret false;\n+    return false;\n }\n \n fn count<A,IA:base_iter<A>>(self: IA, x: A) -> uint {\n@@ -115,10 +115,10 @@ fn position<A,IA:base_iter<A>>(self: IA, f: fn(A) -> bool)\n         -> option<uint> {\n     let mut i = 0;\n     for self.each |a| {\n-        if f(a) { ret some(i); }\n+        if f(a) { return some(i); }\n         i += 1;\n     }\n-    ret none;\n+    return none;\n }\n \n // note: 'rposition' would only make sense to provide with a bidirectional\n@@ -191,7 +191,7 @@ fn test_map_directly_on_vec() {\n #[test]\n fn test_filter_on_int_range() {\n     fn is_even(&&i: int) -> bool {\n-        ret (i % 2) == 0;\n+        return (i % 2) == 0;\n     }\n \n     let l = to_vec(bind filter(bind int::range(0, 10, _), is_even, _));\n@@ -201,7 +201,7 @@ fn test_filter_on_int_range() {\n #[test]\n fn test_filter_on_uint_range() {\n     fn is_even(&&i: uint) -> bool {\n-        ret (i % 2u) == 0u;\n+        return (i % 2u) == 0u;\n     }\n \n     let l = to_vec(bind filter(bind uint::range(0u, 10u, _), is_even, _));"}, {"sha": "84fa8ec354476ab9421e7418a4a743033be1f129", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -23,7 +23,7 @@ pure fn get<T: copy>(opt: option<T>) -> T {\n      * Fails if the value equals `none`\n      */\n \n-    alt opt { some(x) { ret x; } none { fail ~\"option none\"; } }\n+    alt opt { some(x) { return x; } none { fail ~\"option none\"; } }\n }\n \n pure fn expect<T: copy>(opt: option<T>, reason: ~str) -> T {\n@@ -116,7 +116,7 @@ pure fn unwrap<T>(-opt: option<T>) -> T {\n         };\n         let liberated_value = unsafe::reinterpret_cast(*addr);\n         unsafe::forget(opt);\n-        ret liberated_value;\n+        return liberated_value;\n     }\n }\n "}, {"sha": "f758c1b62cbd9f239de7aa6e4d2157f391ccb8af", "filename": "src/libcore/os.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -100,7 +100,7 @@ mod win32 {\n                 }\n             }\n         }\n-        ret res;\n+        return res;\n     }\n \n     fn as_utf16_p<T>(s: ~str, f: fn(*u16) -> T) -> T {\n@@ -209,14 +209,14 @@ mod global_env {\n                 assert vec::len(vs) == 2u;\n                 vec::push(pairs, (vs[0], vs[1]));\n             }\n-            ret pairs;\n+            return pairs;\n         }\n \n         #[cfg(unix)]\n         fn getenv(n: ~str) -> option<~str> {\n             unsafe {\n                 let s = str::as_c_str(n, libc::getenv);\n-                ret if unsafe::reinterpret_cast(s) == 0 {\n+                return if unsafe::reinterpret_cast(s) == 0 {\n                     option::none::<~str>\n                 } else {\n                     let s = unsafe::reinterpret_cast(s);\n@@ -267,7 +267,7 @@ mod global_env {\n }\n \n fn fdopen(fd: c_int) -> *FILE {\n-    ret do as_c_charp(~\"r\") |modebuf| {\n+    return do as_c_charp(~\"r\") |modebuf| {\n         libc::fdopen(fd, modebuf)\n     };\n }\n@@ -278,16 +278,16 @@ fn fdopen(fd: c_int) -> *FILE {\n #[cfg(windows)]\n fn fsync_fd(fd: c_int, _level: io::fsync::level) -> c_int {\n     import libc::funcs::extra::msvcrt::*;\n-    ret commit(fd);\n+    return commit(fd);\n }\n \n #[cfg(target_os = \"linux\")]\n fn fsync_fd(fd: c_int, level: io::fsync::level) -> c_int {\n     import libc::funcs::posix01::unistd::*;\n     alt level {\n       io::fsync::fsync\n-      | io::fsync::fullfsync { ret fsync(fd); }\n-      io::fsync::fdatasync { ret fdatasync(fd); }\n+      | io::fsync::fullfsync { return fsync(fd); }\n+      io::fsync::fdatasync { return fdatasync(fd); }\n     }\n }\n \n@@ -297,27 +297,27 @@ fn fsync_fd(fd: c_int, level: io::fsync::level) -> c_int {\n     import libc::funcs::posix88::fcntl::*;\n     import libc::funcs::posix01::unistd::*;\n     alt level {\n-      io::fsync::fsync { ret fsync(fd); }\n+      io::fsync::fsync { return fsync(fd); }\n       _ {\n         // According to man fnctl, the ok retval is only specified to be !=-1\n         if (fcntl(F_FULLFSYNC as c_int, fd) == -1 as c_int)\n-            { ret -1 as c_int; }\n+            { return -1 as c_int; }\n         else\n-            { ret 0 as c_int; }\n+            { return 0 as c_int; }\n       }\n     }\n }\n \n #[cfg(target_os = \"freebsd\")]\n fn fsync_fd(fd: c_int, _l: io::fsync::level) -> c_int {\n     import libc::funcs::posix01::unistd::*;\n-    ret fsync(fd);\n+    return fsync(fd);\n }\n \n \n #[cfg(windows)]\n fn waitpid(pid: pid_t) -> c_int {\n-    ret rustrt::rust_process_wait(pid);\n+    return rustrt::rust_process_wait(pid);\n }\n \n #[cfg(unix)]\n@@ -327,7 +327,7 @@ fn waitpid(pid: pid_t) -> c_int {\n \n     assert (waitpid(pid, ptr::mut_addr_of(status),\n                     0 as c_int) != (-1 as c_int));\n-    ret status;\n+    return status;\n }\n \n \n@@ -336,7 +336,7 @@ fn pipe() -> {in: c_int, out: c_int} {\n     let fds = {mut in: 0 as c_int,\n                mut out: 0 as c_int };\n     assert (libc::pipe(ptr::mut_addr_of(fds.in)) == (0 as c_int));\n-    ret {in: fds.in, out: fds.out};\n+    return {in: fds.in, out: fds.out};\n }\n \n \n@@ -358,12 +358,12 @@ fn pipe() -> {in: c_int, out: c_int} {\n     assert (res == 0 as c_int);\n     assert (fds.in != -1 as c_int && fds.in != 0 as c_int);\n     assert (fds.out != -1 as c_int && fds.in != 0 as c_int);\n-    ret {in: fds.in, out: fds.out};\n+    return {in: fds.in, out: fds.out};\n }\n \n \n fn dll_filename(base: ~str) -> ~str {\n-    ret pre() + base + dll_suffix();\n+    return pre() + base + dll_suffix();\n \n     #[cfg(unix)]\n     fn pre() -> ~str { ~\"lib\" }\n@@ -442,7 +442,7 @@ fn self_exe_path() -> option<path> {\n  * Otherwise, homedir returns option::none.\n  */\n fn homedir() -> option<path> {\n-    ret alt getenv(~\"HOME\") {\n+    return alt getenv(~\"HOME\") {\n         some(p) {\n             if !str::is_empty(p) {\n                 some(p)\n@@ -497,7 +497,7 @@ fn walk_dir(p: path, f: fn(path) -> bool) {\n                 }\n             }\n         }\n-        ret keepgoing;\n+        return keepgoing;\n     }\n }\n \n@@ -538,7 +538,7 @@ fn make_absolute(p: path) -> path {\n \n /// Creates a directory at the specified path\n fn make_dir(p: path, mode: c_int) -> bool {\n-    ret mkdir(p, mode);\n+    return mkdir(p, mode);\n \n     #[cfg(windows)]\n     fn mkdir(p: path, _mode: c_int) -> bool {\n@@ -600,60 +600,60 @@ fn list_dir_path(p: path) -> ~[~str] {\n \n /// Removes a directory at the specified path\n fn remove_dir(p: path) -> bool {\n-   ret rmdir(p);\n+   return rmdir(p);\n \n     #[cfg(windows)]\n     fn rmdir(p: path) -> bool {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;\n-        ret do as_utf16_p(p) |buf| {\n+        return do as_utf16_p(p) |buf| {\n             RemoveDirectoryW(buf) != (0 as BOOL)\n         };\n     }\n \n     #[cfg(unix)]\n     fn rmdir(p: path) -> bool {\n-        ret do as_c_charp(p) |buf| {\n+        return do as_c_charp(p) |buf| {\n             libc::rmdir(buf) == (0 as c_int)\n         };\n     }\n }\n \n fn change_dir(p: path) -> bool {\n-    ret chdir(p);\n+    return chdir(p);\n \n     #[cfg(windows)]\n     fn chdir(p: path) -> bool {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;\n-        ret do as_utf16_p(p) |buf| {\n+        return do as_utf16_p(p) |buf| {\n             SetCurrentDirectoryW(buf) != (0 as BOOL)\n         };\n     }\n \n     #[cfg(unix)]\n     fn chdir(p: path) -> bool {\n-        ret do as_c_charp(p) |buf| {\n+        return do as_c_charp(p) |buf| {\n             libc::chdir(buf) == (0 as c_int)\n         };\n     }\n }\n \n /// Copies a file from one location to another\n fn copy_file(from: path, to: path) -> bool {\n-    ret do_copy_file(from, to);\n+    return do_copy_file(from, to);\n \n     #[cfg(windows)]\n     fn do_copy_file(from: path, to: path) -> bool {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;\n-        ret do as_utf16_p(from) |fromp| {\n+        return do as_utf16_p(from) |fromp| {\n             do as_utf16_p(to) |top| {\n                 CopyFileW(fromp, top, (0 as BOOL)) != (0 as BOOL)\n             }\n@@ -668,7 +668,7 @@ fn copy_file(from: path, to: path) -> bool {\n             }\n         };\n         if istream as uint == 0u {\n-            ret false;\n+            return false;\n         }\n         let ostream = do as_c_charp(to) |top| {\n             do as_c_charp(~\"w+b\") |modebuf| {\n@@ -677,7 +677,7 @@ fn copy_file(from: path, to: path) -> bool {\n         };\n         if ostream as uint == 0u {\n             fclose(istream);\n-            ret false;\n+            return false;\n         }\n         let mut buf : ~[mut u8] = ~[mut];\n         let bufsize = 8192u;\n@@ -702,13 +702,13 @@ fn copy_file(from: path, to: path) -> bool {\n         }\n         fclose(istream);\n         fclose(ostream);\n-        ret ok;\n+        return ok;\n     }\n }\n \n /// Deletes an existing file\n fn remove_file(p: path) -> bool {\n-    ret unlink(p);\n+    return unlink(p);\n \n     #[cfg(windows)]\n     fn unlink(p: path) -> bool {\n@@ -717,14 +717,14 @@ fn remove_file(p: path) -> bool {\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;\n-        ret do as_utf16_p(p) |buf| {\n+        return do as_utf16_p(p) |buf| {\n             DeleteFileW(buf) != (0 as BOOL)\n         };\n     }\n \n     #[cfg(unix)]\n     fn unlink(p: path) -> bool {\n-        ret do as_c_charp(p) |buf| {\n+        return do as_c_charp(p) |buf| {\n             libc::unlink(buf) == (0 as c_int)\n         };\n     }"}, {"sha": "beccdcf05389ee0efb1deb04e8ed14fe0879d96c", "filename": "src/libcore/path.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -51,14 +51,14 @@ fn path_is_absolute(p: path) -> bool {\n \n #[cfg(windows)]\n fn path_is_absolute(p: ~str) -> bool {\n-    ret str::char_at(p, 0u) == '/' ||\n+    return str::char_at(p, 0u) == '/' ||\n         str::char_at(p, 1u) == ':'\n         && (str::char_at(p, 2u) == consts::path_sep\n             || str::char_at(p, 2u) == consts::alt_path_sep);\n }\n \n /// Get the default path separator for the host platform\n-fn path_sep() -> ~str { ret str::from_char(consts::path_sep); }\n+fn path_sep() -> ~str { return str::from_char(consts::path_sep); }\n \n fn split_dirname_basename (pp: path) -> {dirname: ~str, basename: ~str} {\n     alt str::rfind(pp, |ch|\n@@ -82,7 +82,7 @@ fn split_dirname_basename (pp: path) -> {dirname: ~str, basename: ~str} {\n  * If the path is not prefixed with a directory, then \".\" is returned.\n  */\n fn dirname(pp: path) -> path {\n-    ret split_dirname_basename(pp).dirname;\n+    return split_dirname_basename(pp).dirname;\n }\n \n /**\n@@ -95,7 +95,7 @@ fn dirname(pp: path) -> path {\n  * with a path separator then an empty path is returned.\n  */\n fn basename(pp: path) -> path {\n-    ret split_dirname_basename(pp).basename;\n+    return split_dirname_basename(pp).basename;\n }\n \n /**\n@@ -119,7 +119,7 @@ fn connect(pre: path, post: path) -> path {\n             str::unsafe::shift_byte(post_);\n         }\n     }\n-    ret pre_ + path_sep() + post_;\n+    return pre_ + path_sep() + post_;\n }\n \n /**\n@@ -128,7 +128,7 @@ fn connect(pre: path, post: path) -> path {\n  * Inserts path separators as needed.\n  */\n fn connect_many(paths: ~[path]) -> path {\n-    ret if vec::len(paths) == 1u {\n+    return if vec::len(paths) == 1u {\n         paths[0]\n     } else {\n         let rest = vec::slice(paths, 1u, vec::len(paths));\n@@ -231,7 +231,7 @@ fn normalize(p: path) -> path {\n         s\n     };\n \n-    ret s;\n+    return s;\n \n     fn strip_dots(s: ~[path]) -> ~[path] {\n         vec::filter_map(s, |elem|\n@@ -244,7 +244,7 @@ fn normalize(p: path) -> path {\n \n     fn rollup_doubledots(s: ~[path]) -> ~[path] {\n         if vec::is_empty(s) {\n-            ret ~[];\n+            return ~[];\n         }\n \n         let mut t = ~[];\n@@ -267,7 +267,7 @@ fn normalize(p: path) -> path {\n             vec::push(t, ~\"..\");\n             skip -= 1;\n         }\n-        ret t;\n+        return t;\n     }\n \n     #[cfg(unix)]\n@@ -292,9 +292,9 @@ fn normalize(p: path) -> path {\n         let last = orig[str::len(orig) - 1u];\n         if last == consts::path_sep as u8\n             || last == consts::path_sep as u8 {\n-            ret newp + path_sep();\n+            return newp + path_sep();\n         } else {\n-            ret newp;\n+            return newp;\n         }\n     }\n }"}, {"sha": "bc8785b45acf5067646946c2e1547d8783156e97", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -390,11 +390,11 @@ fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n             let mut payload = none;\n             payload <-> p.payload;\n             p.header.state = empty;\n-            ret some(option::unwrap(payload))\n+            return some(option::unwrap(payload))\n           }\n           terminated {\n             assert old_state == terminated;\n-            ret none;\n+            return none;\n           }\n         }\n         first = false;\n@@ -906,7 +906,7 @@ struct port_set<T: send> : recv<T> {\n         // It'd be nice to use self.port.each, but that version isn't\n         // pure.\n         for vec::each(self.ports) |p| {\n-            if p.peek() { ret true }\n+            if p.peek() { return true }\n         }\n         false\n     }"}, {"sha": "d82c46832fe502033e5916505ae88bf8a42cb875", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -79,7 +79,7 @@ unsafe fn buf_len<T>(buf: **T) -> uint {\n unsafe fn position<T>(buf: *T, f: fn(T) -> bool) -> uint {\n     let mut i = 0u;\n     loop {\n-        if f(*offset(buf, i)) { ret i; }\n+        if f(*offset(buf, i)) { return i; }\n         else { i += 1u; }\n     }\n }"}, {"sha": "82a88e6718f61919cf5065b43541bfbdb8b5fc33", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -110,7 +110,7 @@ impl extensions for rng {\n         let u2 = self.next() as f64;\n         let u3 = self.next() as f64;\n         const scale : f64 = (u32::max_value as f64) + 1.0f64;\n-        ret ((u1 / scale + u2) / scale + u3) / scale;\n+        return ((u1 / scale + u2) / scale + u3) / scale;\n     }\n \n     /// Return a random char\n@@ -195,14 +195,14 @@ impl extensions for rng {\n             total += item.weight;\n         }\n         if total == 0u {\n-            ret none;\n+            return none;\n         }\n         let chosen = self.gen_uint_range(0u, total);\n         let mut so_far = 0u;\n         for v.each |item| {\n             so_far += item.weight;\n             if so_far > chosen {\n-                ret some(item.item);\n+                return some(item.item);\n             }\n         }\n         unreachable();\n@@ -226,7 +226,7 @@ impl extensions for rng {\n     fn shuffle<T:copy>(values: ~[T]) -> ~[T] {\n         let mut m = vec::to_mut(values);\n         self.shuffle_mut(m);\n-        ret vec::from_mut(m);\n+        return vec::from_mut(m);\n     }\n \n     /// Shuffle a mutable vec in place\n@@ -249,7 +249,7 @@ class rand_res {\n }\n \n impl of rng for @rand_res {\n-    fn next() -> u32 { ret rustrt::rand_next((*self).c); }\n+    fn next() -> u32 { return rustrt::rand_next((*self).c); }\n }\n \n /// Create a new random seed for seeded_rng"}, {"sha": "58a4c5580509f4cbc69feee1a3de99134a9b4c94", "filename": "src/libcore/result.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -244,8 +244,8 @@ impl extensions<T:copy, E:copy> for result<T,E> {\n  * checking for overflow:\n  *\n  *     fn inc_conditionally(x: uint) -> result<uint,str> {\n- *         if x == uint::max_value { ret err(\"overflow\"); }\n- *         else { ret ok(x+1u); }\n+ *         if x == uint::max_value { return err(\"overflow\"); }\n+ *         else { return ok(x+1u); }\n  *     }\n  *     map(~[1u, 2u, 3u], inc_conditionally).chain {|incd|\n  *         assert incd == ~[2u, 3u, 4u];\n@@ -259,10 +259,10 @@ fn map_vec<T,U:copy,V:copy>(\n     for vec::each(ts) |t| {\n         alt op(t) {\n           ok(v) { vec::push(vs, v); }\n-          err(u) { ret err(u); }\n+          err(u) { return err(u); }\n         }\n     }\n-    ret ok(vs);\n+    return ok(vs);\n }\n \n fn map_opt<T,U:copy,V:copy>(\n@@ -299,11 +299,11 @@ fn map_vec2<S,T,U:copy,V:copy>(ss: ~[S], ts: ~[T],\n     while i < n {\n         alt op(ss[i],ts[i]) {\n           ok(v) { vec::push(vs, v); }\n-          err(u) { ret err(u); }\n+          err(u) { return err(u); }\n         }\n         i += 1u;\n     }\n-    ret ok(vs);\n+    return ok(vs);\n }\n \n /**\n@@ -320,11 +320,11 @@ fn iter_vec2<S,T,U:copy>(ss: ~[S], ts: ~[T],\n     while i < n {\n         alt op(ss[i],ts[i]) {\n           ok(()) { }\n-          err(u) { ret err(u); }\n+          err(u) { return err(u); }\n         }\n         i += 1u;\n     }\n-    ret ok(());\n+    return ok(());\n }\n \n /// Unwraps a result, assuming it is an `ok(T)`\n@@ -336,7 +336,7 @@ fn unwrap<T, U>(-res: result<T, U>) -> T {\n         };\n         let liberated_value = unsafe::reinterpret_cast(*addr);\n         unsafe::forget(res);\n-        ret liberated_value;\n+        return liberated_value;\n     }\n }\n "}, {"sha": "0b4038656ef86b3e1c4336e463937d2a1a8ea95e", "filename": "src/libcore/rt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -34,7 +34,7 @@ fn rt_fail(expr: *c_char, file: *c_char, line: size_t) {\n \n #[rt(exchange_malloc)]\n fn rt_exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n-    ret rustrt::rust_upcall_exchange_malloc(td, size);\n+    return rustrt::rust_upcall_exchange_malloc(td, size);\n }\n \n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n@@ -47,7 +47,7 @@ fn rt_exchange_free(ptr: *c_char) {\n \n #[rt(malloc)]\n fn rt_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n-    ret rustrt::rust_upcall_malloc(td, size);\n+    return rustrt::rust_upcall_malloc(td, size);\n }\n \n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from"}, {"sha": "bb604d7748acb247c1b3a33eb2982222518bf385", "filename": "src/libcore/run.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -169,7 +169,7 @@ fn run_program(prog: ~str, args: ~[~str]) -> int {\n     let pid = spawn_process(prog, args, none, none,\n                             0i32, 0i32, 0i32);\n     if pid == -1 as pid_t { fail; }\n-    ret waitpid(pid);\n+    return waitpid(pid);\n }\n \n /**\n@@ -216,10 +216,10 @@ fn start_program(prog: ~str, args: ~[~str]) -> program {\n         }\n     }\n     fn finish_repr(r: prog_repr) -> int {\n-        if r.finished { ret 0; }\n+        if r.finished { return 0; }\n         r.finished = true;\n         close_repr_input(r);\n-        ret waitpid(r.pid);\n+        return waitpid(r.pid);\n     }\n     fn destroy_repr(r: prog_repr) {\n         finish_repr(r);\n@@ -233,7 +233,7 @@ fn start_program(prog: ~str, args: ~[~str]) -> program {\n     }\n \n     impl of program for prog_res {\n-        fn get_id() -> pid_t { ret self.r.pid; }\n+        fn get_id() -> pid_t { return self.r.pid; }\n         fn input() -> io::writer { io::fd_writer(self.r.in_fd, false) }\n         fn output() -> io::reader { io::FILE_reader(self.r.out_file, false) }\n         fn err() -> io::reader { io::FILE_reader(self.r.err_file, false) }\n@@ -246,7 +246,7 @@ fn start_program(prog: ~str, args: ~[~str]) -> program {\n                 out_file: os::fdopen(pipe_output.in),\n                 err_file: os::fdopen(pipe_err.in),\n                 mut finished: false};\n-    ret prog_res(repr) as program;\n+    return prog_res(repr) as program;\n }\n \n fn read_all(rd: io::reader) -> ~str {\n@@ -255,7 +255,7 @@ fn read_all(rd: io::reader) -> ~str {\n         let bytes = rd.read_bytes(4096u);\n         buf += str::from_bytes(bytes);\n     }\n-    ret buf;\n+    return buf;\n }\n \n /**\n@@ -323,7 +323,7 @@ fn program_output(prog: ~str, args: ~[~str]) ->\n         };\n         count -= 1;\n     };\n-    ret {status: status, out: outs, err: errs};\n+    return {status: status, out: outs, err: errs};\n }\n \n fn writeclose(fd: c_int, s: ~str) {\n@@ -345,12 +345,12 @@ fn readclose(fd: c_int) -> ~str {\n         buf += str::from_bytes(bytes);\n     }\n     os::fclose(file);\n-    ret buf;\n+    return buf;\n }\n \n /// Waits for a process to exit and returns the exit code\n fn waitpid(pid: pid_t) -> int {\n-    ret waitpid_os(pid);\n+    return waitpid_os(pid);\n \n     #[cfg(windows)]\n     fn waitpid_os(pid: pid_t) -> int {\n@@ -382,7 +382,7 @@ fn waitpid(pid: pid_t) -> int {\n         }\n \n         let status = os::waitpid(pid);\n-        ret if WIFEXITED(status) {\n+        return if WIFEXITED(status) {\n             WEXITSTATUS(status) as int\n         } else {\n             1"}, {"sha": "df019f5739783c59b79d3c7fd02a66c2f23db5db", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -80,7 +80,7 @@ mod linear {\n             unsafe{ // argh. log not considered pure.\n                 debug!{\"next_bucket(%?, %?) = %?\", idx, len_buckets, n};\n             }\n-            ret n;\n+            return n;\n         }\n \n         #[inline(always)]\n@@ -90,11 +90,11 @@ mod linear {\n             let mut idx = start_idx;\n             loop {\n                 if !op(idx) {\n-                    ret idx;\n+                    return idx;\n                 }\n                 idx = self.next_bucket(idx, len_buckets);\n                 if idx == start_idx {\n-                    ret start_idx;\n+                    return start_idx;\n                 }\n             }\n         }\n@@ -118,15 +118,15 @@ mod linear {\n                 alt buckets[i] {\n                   some(bkt) {\n                     if bkt.hash == hash && self.eqfn(k, &bkt.key) {\n-                        ret found_entry(i);\n+                        return found_entry(i);\n                     }\n                   }\n                   none => {\n-                    ret found_hole(i);\n+                    return found_hole(i);\n                   }\n                 }\n             };\n-            ret table_full;\n+            return table_full;\n         }\n     }\n \n@@ -167,13 +167,13 @@ mod linear {\n                        k, v, idx, hash};\n                 self.buckets[idx] = some({hash: hash, key: k, value: v});\n                 self.size += 1;\n-                ret true;\n+                return true;\n               }\n               found_entry(idx) => {\n                 debug!{\"insert overwrite (%?->%?) at idx %?, hash %?\",\n                        k, v, idx, hash};\n                 self.buckets[idx] = some({hash: hash, key: k, value: v});\n-                ret false;\n+                return false;\n               }\n             }\n         }\n@@ -213,7 +213,7 @@ mod linear {\n \n             let mut idx = alt self.bucket_for_key(self.buckets, k) {\n               table_full | found_hole(_) => {\n-                ret false;\n+                return false;\n               }\n               found_entry(idx) => {\n                 idx\n@@ -230,7 +230,7 @@ mod linear {\n                 idx = self.next_bucket(idx, len_buckets);\n             }\n             self.size -= 1;\n-            ret true;\n+            return true;\n         }\n     }\n \n@@ -339,7 +339,7 @@ mod test {\n     pure fn uint_eq(x: &uint, y: &uint) -> bool { *x == *y }\n \n     fn int_linear_map<V>() -> linear_map<uint,V> {\n-        ret linear_map(uint_hash, uint_eq);\n+        return linear_map(uint_hash, uint_eq);\n     }\n \n     #[test]"}, {"sha": "939cdfade825ace9f79d727d829c991ac9a7eedc", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -51,7 +51,7 @@ fn test_simple() {\n #[test]\n fn test_simple_deep() {\n     fn run(i: int) {\n-        if i == 0 { ret }\n+        if i == 0 { return }\n \n         for walk_stack |_frame| {\n             unsafe {"}, {"sha": "cdc3a826b67cd8d7b83c0591ab472f1c5d4fb4d0", "filename": "src/libcore/str.rs", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -128,7 +128,7 @@ Section: Creating a string\n  */\n pure fn from_bytes(vv: &[const u8]) -> ~str {\n     assert is_utf8(vv);\n-    ret unsafe { unsafe::from_bytes(vv) };\n+    return unsafe { unsafe::from_bytes(vv) };\n }\n \n /// Copy a slice into a new unique str\n@@ -229,7 +229,7 @@ fn push_char(&s: ~str, ch: char) {\n pure fn from_char(ch: char) -> ~str {\n     let mut buf = ~\"\";\n     unchecked { push_char(buf, ch); }\n-    ret buf;\n+    return buf;\n }\n \n /// Convert a vector of chars to a string\n@@ -239,7 +239,7 @@ pure fn from_chars(chs: &[char]) -> ~str {\n         reserve(buf, chs.len());\n         for vec::each(chs) |ch| { push_char(buf, ch); }\n     }\n-    ret buf;\n+    return buf;\n }\n \n /// Appends a string slice to the back of a string, without overallocating\n@@ -282,15 +282,15 @@ pure fn append(+lhs: ~str, rhs: &str) -> ~str {\n     unchecked {\n         push_str_no_overallocate(v, rhs);\n     }\n-    ret v;\n+    return v;\n }\n \n \n /// Concatenate a vector of strings\n pure fn concat(v: &[~str]) -> ~str {\n     let mut s: ~str = ~\"\";\n     for vec::each(v) |ss| { unchecked { push_str(s, ss) }; }\n-    ret s;\n+    return s;\n }\n \n /// Concatenate a vector of strings, placing a given separator between each\n@@ -300,7 +300,7 @@ pure fn connect(v: &[~str], sep: &str) -> ~str {\n         if first { first = false; } else { unchecked { push_str(s, sep); } }\n         unchecked { push_str(s, ss) };\n     }\n-    ret s;\n+    return s;\n }\n \n /*\n@@ -319,7 +319,7 @@ fn pop_char(&s: ~str) -> char {\n     assert end > 0u;\n     let {ch, prev} = char_range_at_reverse(s, end);\n     unsafe { unsafe::set_len(s, prev); }\n-    ret ch;\n+    return ch;\n }\n \n /**\n@@ -332,7 +332,7 @@ fn pop_char(&s: ~str) -> char {\n fn shift_char(&s: ~str) -> char {\n     let {ch, next} = char_range_at(s, 0u);\n     s = unsafe { unsafe::slice_bytes(s, next, len(s)) };\n-    ret ch;\n+    return ch;\n }\n \n /// Prepend a char to a string\n@@ -376,7 +376,7 @@ pure fn bytes(s: &str) -> ~[u8] {\n         let mut s_copy = from_slice(s);\n         let mut v: ~[u8] = ::unsafe::transmute(s_copy);\n         vec::unsafe::set_len(v, len(s));\n-        ret v;\n+        return v;\n     }\n }\n \n@@ -397,7 +397,7 @@ pure fn chars(s: &str) -> ~[char] {\n         unchecked { vec::push(buf, ch); }\n         i = next;\n     }\n-    ret buf;\n+    return buf;\n }\n \n /**\n@@ -643,16 +643,16 @@ pure fn eq(&&a: ~str, &&b: ~str) -> bool {\n     // shape code.\n     let a_len = a.len();\n     let b_len = b.len();\n-    if a_len != b_len { ret false; }\n+    if a_len != b_len { return false; }\n     let mut end = uint::min(a_len, b_len);\n \n     let mut i = 0u;\n     while i < end {\n-        if a[i] != b[i] { ret false; }\n+        if a[i] != b[i] { return false; }\n         i += 1u;\n     }\n \n-    ret true;\n+    return true;\n }\n \n /// Bytewise less than or equal\n@@ -663,7 +663,7 @@ pure fn hash(&&s: ~str) -> uint {\n     let x = do as_bytes(s) |bytes| {\n         hash::hash_bytes(bytes)\n     };\n-    ret x as uint;\n+    return x as uint;\n }\n \n /*\n@@ -855,10 +855,10 @@ pure fn find_char_between(s: &str, c: char, start: uint, end: uint)\n         let mut i = start;\n         let b = c as u8;\n         while i < end {\n-            if s[i] == b { ret some(i); }\n+            if s[i] == b { return some(i); }\n             i += 1u;\n         }\n-        ret none;\n+        return none;\n     } else {\n         find_between(s, start, end, |x| x == c)\n     }\n@@ -935,9 +935,9 @@ pure fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n         let b = c as u8;\n         while i > end {\n             i -= 1u;\n-            if s[i] == b { ret some(i); }\n+            if s[i] == b { return some(i); }\n         }\n-        ret none;\n+        return none;\n     } else {\n         rfind_between(s, start, end, |x| x == c)\n     }\n@@ -1016,10 +1016,10 @@ pure fn find_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n     let mut i = start;\n     while i < end {\n         let {ch, next} = char_range_at(s, i);\n-        if f(ch) { ret some(i); }\n+        if f(ch) { return some(i); }\n         i = next;\n     }\n-    ret none;\n+    return none;\n }\n \n /**\n@@ -1095,17 +1095,17 @@ pure fn rfind_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n     let mut i = start;\n     while i > end {\n         let {ch, prev} = char_range_at_reverse(s, i);\n-        if f(ch) { ret some(prev); }\n+        if f(ch) { return some(prev); }\n         i = prev;\n     }\n-    ret none;\n+    return none;\n }\n \n // Utility used by various searching functions\n pure fn match_at(haystack: &a/str, needle: &b/str, at: uint) -> bool {\n     let mut i = at;\n-    for each(needle) |c| { if haystack[i] != c { ret false; } i += 1u; }\n-    ret true;\n+    for each(needle) |c| { if haystack[i] != c { return false; } i += 1u; }\n+    return true;\n }\n \n /**\n@@ -1175,16 +1175,16 @@ pure fn find_str_between(haystack: &a/str, needle: &b/str, start: uint,\n     // See Issue #1932 for why this is a naive search\n     assert end <= len(haystack);\n     let needle_len = len(needle);\n-    if needle_len == 0u { ret some(start); }\n-    if needle_len > end { ret none; }\n+    if needle_len == 0u { return some(start); }\n+    if needle_len > end { return none; }\n \n     let mut i = start;\n     let e = end - needle_len;\n     while i <= e {\n-        if match_at(haystack, needle, i) { ret some(i); }\n+        if match_at(haystack, needle, i) { return some(i); }\n         i += 1u;\n     }\n-    ret none;\n+    return none;\n }\n \n /**\n@@ -1248,8 +1248,8 @@ Section: String properties\n /// Determines if a string contains only ASCII characters\n pure fn is_ascii(s: &str) -> bool {\n     let mut i: uint = len(s);\n-    while i > 0u { i -= 1u; if !u8::is_ascii(s[i]) { ret false; } }\n-    ret true;\n+    while i > 0u { i -= 1u; if !u8::is_ascii(s[i]) { return false; } }\n+    return true;\n }\n \n /// Returns true if the string has length 0\n@@ -1264,7 +1264,7 @@ pure fn is_not_empty(s: &str) -> bool { !is_empty(s) }\n  * Whitespace characters are determined by `char::is_whitespace`\n  */\n pure fn is_whitespace(s: &str) -> bool {\n-    ret all(s, char::is_whitespace);\n+    return all(s, char::is_whitespace);\n }\n \n /**\n@@ -1273,7 +1273,7 @@ pure fn is_whitespace(s: &str) -> bool {\n  * Alphanumeric characters are determined by `char::is_alphanumeric`\n  */\n fn is_alphanumeric(s: &str) -> bool {\n-    ret all(s, char::is_alphanumeric);\n+    return all(s, char::is_alphanumeric);\n }\n \n /// Returns the string length/size in bytes not counting the null terminator\n@@ -1294,16 +1294,16 @@ pure fn is_utf8(v: &[const u8]) -> bool {\n     let total = vec::len::<u8>(v);\n     while i < total {\n         let mut chsize = utf8_char_width(v[i]);\n-        if chsize == 0u { ret false; }\n-        if i + chsize > total { ret false; }\n+        if chsize == 0u { return false; }\n+        if i + chsize > total { return false; }\n         i += 1u;\n         while chsize > 1u {\n-            if v[i] & 192u8 != tag_cont_u8 { ret false; }\n+            if v[i] & 192u8 != tag_cont_u8 { return false; }\n             i += 1u;\n             chsize -= 1u;\n         }\n     }\n-    ret true;\n+    return true;\n }\n \n /// Determines if a vector of `u16` contains valid UTF-16\n@@ -1317,14 +1317,14 @@ pure fn is_utf16(v: &[u16]) -> bool {\n             i += 1u;\n \n         } else {\n-            if i+1u < len { ret false; }\n+            if i+1u < len { return false; }\n             let u2 = v[i+1u];\n-            if u < 0xD7FF_u16 || u > 0xDBFF_u16 { ret false; }\n-            if u2 < 0xDC00_u16 || u2 > 0xDFFF_u16 { ret false; }\n+            if u < 0xD7FF_u16 || u > 0xDBFF_u16 { return false; }\n+            if u2 < 0xDC00_u16 || u2 > 0xDFFF_u16 { return false; }\n             i += 2u;\n         }\n     }\n-    ret true;\n+    return true;\n }\n \n /// Converts to a vector of `u16` encoded as UTF-16\n@@ -1347,7 +1347,7 @@ pure fn to_utf16(s: &str) -> ~[u16] {\n             vec::push_all(u, ~[w1, w2])\n         }\n     }\n-    ret u;\n+    return u;\n }\n \n pure fn utf16_chars(v: &[u16], f: fn(char)) {\n@@ -1381,7 +1381,7 @@ pure fn from_utf16(v: &[u16]) -> ~str {\n         reserve(buf, vec::len(v));\n         utf16_chars(v, |ch| push_char(buf, ch));\n     }\n-    ret buf;\n+    return buf;\n }\n \n \n@@ -1407,7 +1407,7 @@ pure fn count_chars(s: &str, start: uint, end: uint) -> uint {\n         len += 1u;\n         i = next;\n     }\n-    ret len;\n+    return len;\n }\n \n /// Counts the number of bytes taken by the `n` in `s` starting from `start`.\n@@ -1427,24 +1427,24 @@ pure fn count_bytes(s: &b/str, start: uint, n: uint) -> uint {\n /// Given a first byte, determine how many bytes are in this UTF-8 character\n pure fn utf8_char_width(b: u8) -> uint {\n     let byte: uint = b as uint;\n-    if byte < 128u { ret 1u; }\n+    if byte < 128u { return 1u; }\n     // Not a valid start byte\n-    if byte < 192u { ret 0u; }\n-    if byte < 224u { ret 2u; }\n-    if byte < 240u { ret 3u; }\n-    if byte < 248u { ret 4u; }\n-    if byte < 252u { ret 5u; }\n-    ret 6u;\n+    if byte < 192u { return 0u; }\n+    if byte < 224u { return 2u; }\n+    if byte < 240u { return 3u; }\n+    if byte < 248u { return 4u; }\n+    if byte < 252u { return 5u; }\n+    return 6u;\n }\n \n /**\n  * Returns false if the index points into the middle of a multi-byte\n  * character sequence.\n  */\n pure fn is_char_boundary(s: &str, index: uint) -> bool {\n-    if index == len(s) { ret true; }\n+    if index == len(s) { return true; }\n     let b = s[index];\n-    ret b < 128u8 || b >= 192u8;\n+    return b < 128u8 || b >= 192u8;\n }\n \n /**\n@@ -1500,7 +1500,7 @@ pure fn char_range_at(s: &str, i: uint) -> {ch: char, next: uint} {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n     assert (w != 0u);\n-    if w == 1u { ret {ch: b0 as char, next: i + 1u}; }\n+    if w == 1u { return {ch: b0 as char, next: i + 1u}; }\n     let mut val = 0u;\n     let end = i + w;\n     let mut i = i + 1u;\n@@ -1515,11 +1515,11 @@ pure fn char_range_at(s: &str, i: uint) -> {ch: char, next: uint} {\n     // the first to clip off the marker bits at the left of the byte, and then\n     // a second (as uint) to get it to the right position.\n     val += ((b0 << ((w + 1u) as u8)) as uint) << ((w - 1u) * 6u - w - 1u);\n-    ret {ch: val as char, next: i};\n+    return {ch: val as char, next: i};\n }\n \n /// Pluck a character out of a string\n-pure fn char_at(s: &str, i: uint) -> char { ret char_range_at(s, i).ch; }\n+pure fn char_at(s: &str, i: uint) -> char { return char_range_at(s, i).ch; }\n \n /**\n  * Given a byte position and a str, return the previous char and its position\n@@ -1540,7 +1540,7 @@ pure fn char_range_at_reverse(ss: &str, start: uint)\n     prev -= 1u;\n \n     let ch = char_at(ss, prev);\n-    ret {ch:ch, prev:prev};\n+    return {ch:ch, prev:prev};\n }\n \n /**\n@@ -1571,10 +1571,10 @@ pure fn all_between(s: &str, start: uint, end: uint,\n     let mut i = start;\n     while i < end {\n         let {ch, next} = char_range_at(s, i);\n-        if !it(ch) { ret false; }\n+        if !it(ch) { return false; }\n         i = next;\n     }\n-    ret true;\n+    return true;\n }\n \n /**\n@@ -1747,7 +1747,7 @@ pure fn escape_default(s: &str) -> ~str {\n         reserve_at_least(out, str::len(s));\n         chars_iter(s, |c| push_str(out, char::escape_default(c)));\n     }\n-    ret out;\n+    return out;\n }\n \n /// Escape each char in `s` with char::escape_unicode.\n@@ -1757,7 +1757,7 @@ pure fn escape_unicode(s: &str) -> ~str {\n         reserve_at_least(out, str::len(s));\n         chars_iter(s, |c| push_str(out, char::escape_unicode(c)));\n     }\n-    ret out;\n+    return out;\n }\n \n /// Unsafe operations\n@@ -1781,7 +1781,7 @@ mod unsafe {\n             i += 1u;\n             curr = ptr::offset(buf, i);\n         }\n-        ret from_buf_len(buf, i);\n+        return from_buf_len(buf, i);\n     }\n \n     /// Create a Rust string from a *u8 buffer of the given length\n@@ -1793,7 +1793,7 @@ mod unsafe {\n         vec::push(v, 0u8);\n \n         assert is_utf8(v);\n-        ret ::unsafe::transmute(v);\n+        return ::unsafe::transmute(v);\n     }\n \n     /// Create a Rust string from a null-terminated C string\n@@ -1861,7 +1861,7 @@ mod unsafe {\n        assert (len > 0u);\n        let b = s[len - 1u];\n        unsafe { set_len(s, len - 1u) };\n-       ret b;\n+       return b;\n    }\n \n    /// Removes the first byte from a string and returns it. (Not UTF-8 safe).\n@@ -1870,7 +1870,7 @@ mod unsafe {\n        assert (len > 0u);\n        let b = s[0];\n        s = unsafe { unsafe::slice_bytes(s, 1u, len) };\n-       ret b;\n+       return b;\n    }\n \n     /// Sets the length of the string and adds the null terminator\n@@ -2405,13 +2405,13 @@ mod tests {\n                 let mut i = 0;\n                 let mut rs = ~\"\";\n                 while i < 100000 { push_str(rs, ~\"aaaaaaaaaa\"); i += 1; }\n-                ret rs;\n+                return rs;\n             }\n             fn half_a_million_letter_a() -> ~str {\n                 let mut i = 0;\n                 let mut rs = ~\"\";\n                 while i < 100000 { push_str(rs, ~\"aaaaa\"); i += 1; }\n-                ret rs;\n+                return rs;\n             }\n             assert eq(half_a_million_letter_a(),\n                       unsafe::slice_bytes(a_million_letter_a(),\n@@ -2516,13 +2516,13 @@ mod tests {\n             let mut i = 0;\n             let mut rs = ~\"\";\n             while i < 100000 { push_str(rs, ~\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n-            ret rs;\n+            return rs;\n         }\n         fn half_a_million_letter_X() -> ~str {\n             let mut i = 0;\n             let mut rs = ~\"\";\n             while i < 100000 { push_str(rs, ~\"\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n-            ret rs;\n+            return rs;\n         }\n         assert eq(half_a_million_letter_X(),\n                   slice(a_million_letter_X(), 0u, 3u * 500000u));"}, {"sha": "b39f384ae0a7624430e1f6df73b96b0b7213faa4", "filename": "src/libcore/task.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -833,7 +833,7 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n     //         if parent_group {\n     //             if !enlist_in_group(parent_group) {\n     //                 leave_group(child_group); // Roll back\n-    //                 ret; // Parent group failed. Don't run child's f().\n+    //                 return; // Parent group failed. Don't run child's f().\n     //             }\n     //         }\n     //         stash_taskgroup_data_in_TLS(child_group, parent_group);\n@@ -1024,7 +1024,7 @@ unsafe fn local_get_helper<T: owned>(\n     do_pop: bool) -> option<@T> {\n \n     let map = get_task_local_map(task);\n-    // Interpret our findings from the map\n+    // Interpreturn our findings from the map\n     do local_data_lookup(map, key).map |result| {\n         // A reference count magically appears on 'data' out of thin air. It\n         // was referenced in the local_data box, though, not here, so before\n@@ -1743,7 +1743,7 @@ fn test_child_doesnt_ref_parent() {\n     // climbing the task tree to dereference each ancestor. (See #1789)\n     const generations: uint = 128;\n     fn child_no(x: uint) -> fn~() {\n-        ret || {\n+        return || {\n             if x < generations {\n                 task::spawn(child_no(x+1));\n             }"}, {"sha": "a92ca63dd8ba518308fe71424c65a33f70ef742d", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -11,19 +11,19 @@ impl extensions <T:copy, U:copy> of tuple_ops<T,U> for (T, U) {\n     /// Return the first element of self\n     pure fn first() -> T {\n         let (t, _) = self;\n-        ret t;\n+        return t;\n     }\n \n     /// Return the second element of self\n     pure fn second() -> U {\n         let (_, u) = self;\n-        ret u;\n+        return u;\n     }\n \n     /// Return the results of swapping the two elements of self\n     pure fn swap() -> (U, T) {\n         let (t, u) = self;\n-        ret (u, t);\n+        return (u, t);\n     }\n \n }"}, {"sha": "13746df26218bd3cd7948e10bd8211da8de7798b", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -54,26 +54,26 @@ pure fn compl(i: T) -> T {\n \n impl ord of ord for T {\n     pure fn lt(&&other: T) -> bool {\n-        ret self < other;\n+        return self < other;\n     }\n }\n \n impl eq of eq for T {\n     pure fn eq(&&other: T) -> bool {\n-        ret self == other;\n+        return self == other;\n     }\n }\n \n impl num of num::num for T {\n-    pure fn add(&&other: T)    -> T { ret self + other; }\n-    pure fn sub(&&other: T)    -> T { ret self - other; }\n-    pure fn mul(&&other: T)    -> T { ret self * other; }\n-    pure fn div(&&other: T)    -> T { ret self / other; }\n-    pure fn modulo(&&other: T) -> T { ret self % other; }\n-    pure fn neg()              -> T { ret -self;        }\n-\n-    pure fn to_int()         -> int { ret self as int; }\n-    pure fn from_int(n: int) -> T   { ret n as T;      }\n+    pure fn add(&&other: T)    -> T { return self + other; }\n+    pure fn sub(&&other: T)    -> T { return self - other; }\n+    pure fn mul(&&other: T)    -> T { return self * other; }\n+    pure fn div(&&other: T)    -> T { return self / other; }\n+    pure fn modulo(&&other: T) -> T { return self % other; }\n+    pure fn neg()              -> T { return -self;        }\n+\n+    pure fn to_int()         -> int { return self as int; }\n+    pure fn from_int(n: int) -> T   { return n as T;      }\n }\n \n /**\n@@ -89,17 +89,17 @@ impl num of num::num for T {\n  * `buf` must not be empty\n  */\n fn parse_buf(buf: ~[u8], radix: uint) -> option<T> {\n-    if vec::len(buf) == 0u { ret none; }\n+    if vec::len(buf) == 0u { return none; }\n     let mut i = vec::len(buf) - 1u;\n     let mut power = 1u as T;\n     let mut n = 0u as T;\n     loop {\n         alt char::to_digit(buf[i] as char, radix) {\n           some(d) { n += d as T * power; }\n-          none { ret none; }\n+          none { return none; }\n         }\n         power *= radix as T;\n-        if i == 0u { ret some(n); }\n+        if i == 0u { return some(n); }\n         i -= 1u;\n     };\n }\n@@ -138,16 +138,16 @@ fn from_str(s: ~str) -> option<T> { parse_buf(str::bytes(s), 10u) }\n \n /// Parse a string as an unsigned integer.\n fn from_str_radix(buf: ~str, radix: u64) -> option<u64> {\n-    if str::len(buf) == 0u { ret none; }\n+    if str::len(buf) == 0u { return none; }\n     let mut i = str::len(buf) - 1u;\n     let mut power = 1u64, n = 0u64;\n     loop {\n         alt char::to_digit(buf[i] as char, radix as uint) {\n           some(d) { n += d as u64 * power; }\n-          none { ret none; }\n+          none { return none; }\n         }\n         power *= radix;\n-        if i == 0u { ret some(n); }\n+        if i == 0u { return some(n); }\n         i -= 1u;\n     };\n }\n@@ -233,7 +233,7 @@ pure fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n }\n \n /// Convert to a string\n-fn str(i: T) -> ~str { ret to_str(i, 10u); }\n+fn str(i: T) -> ~str { return to_str(i, 10u); }\n \n #[test]\n fn test_to_str() {"}, {"sha": "96b2dd6d9c3b1f70e246092ce0a7df08978192cf", "filename": "src/libcore/uint-template/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fuint-template%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fuint-template%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fu8.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -3,4 +3,4 @@ type T = u8;\n // Type-specific functions here. These must be reexported by the\n // parent module so that they appear in core::u8 and not core::u8::u8;\n \n-pure fn is_ascii(x: T) -> bool { ret 0 as T == x & 128 as T; }\n+pure fn is_ascii(x: T) -> bool { return 0 as T == x & 128 as T; }"}, {"sha": "401cb8c04c4fb662bd0d521ce0e78bfbec745a01", "filename": "src/libcore/uint-template/uint.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fuint.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -14,8 +14,8 @@ type T = uint;\n  */\n pure fn div_ceil(x: uint, y: uint) -> uint {\n     let div = div(x, y);\n-    if x % y == 0u { ret div;}\n-    else { ret div + 1u; }\n+    if x % y == 0u { return div;}\n+    else { return div + 1u; }\n }\n \n /**\n@@ -32,8 +32,8 @@ pure fn div_ceil(x: uint, y: uint) -> uint {\n  */\n pure fn div_round(x: uint, y: uint) -> uint {\n     let div = div(x, y);\n-    if x % y * 2u  < y { ret div;}\n-    else { ret div + 1u; }\n+    if x % y * 2u  < y { return div;}\n+    else { return div + 1u; }\n }\n \n /**\n@@ -51,10 +51,10 @@ pure fn div_round(x: uint, y: uint) -> uint {\n  * The smallest integer `q` such that `x/y <= q`. This\n  * is either `x/y` or `x/y + 1`.\n  */\n-pure fn div_floor(x: uint, y: uint) -> uint { ret x / y; }\n+pure fn div_floor(x: uint, y: uint) -> uint { return x / y; }\n \n /// Produce a uint suitable for use in a hash table\n-pure fn hash(&&x: uint) -> uint { ret x; }\n+pure fn hash(&&x: uint) -> uint { return x; }\n \n /**\n  * Iterate over the range [`lo`..`hi`), or stop when requested\n@@ -74,10 +74,10 @@ pure fn hash(&&x: uint) -> uint { ret x; }\n pure fn iterate(lo: uint, hi: uint, it: fn(uint) -> bool) -> bool {\n     let mut i = lo;\n     while i < hi {\n-        if (!it(i)) { ret false; }\n+        if (!it(i)) { return false; }\n         i += 1u;\n     }\n-    ret true;\n+    return true;\n }\n \n /// Returns the smallest power of 2 greater than or equal to `n`\n@@ -87,7 +87,7 @@ fn next_power_of_two(n: uint) -> uint {\n     let mut tmp: uint = n - 1u;\n     let mut shift: uint = 1u;\n     while shift <= halfbits { tmp |= tmp >> shift; shift <<= 1u; }\n-    ret tmp + 1u;\n+    return tmp + 1u;\n }\n \n #[test]"}, {"sha": "61fd8d40f234229f08a918f15cb6f45982eaa3cc", "filename": "src/libcore/unicode.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -1,6 +1,6 @@\n mod general_category {\n     pure fn Cc(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\x00' to '\\x1f'\n             | '\\x7f' to '\\x9f'\n               { true }\n@@ -9,7 +9,7 @@ mod general_category {\n     }\n \n     pure fn Cf(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\xad'\n             | '\\u0600' to '\\u0603'\n             | '\\u06dd'\n@@ -29,23 +29,23 @@ mod general_category {\n     }\n \n     pure fn Co(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\ue000' to '\\uf8ff'\n               { true }\n             _ { false }\n         };\n     }\n \n     pure fn Cs(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\ud800' to '\\udfff'\n               { true }\n             _ { false }\n         };\n     }\n \n     pure fn Ll(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\x61' to '\\x7a'\n             | '\\xaa'\n             | '\\xb5'\n@@ -650,7 +650,7 @@ mod general_category {\n     }\n \n     pure fn Lm(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\u02b0' to '\\u02c1'\n             | '\\u02c6' to '\\u02d1'\n             | '\\u02e0' to '\\u02e4'\n@@ -706,7 +706,7 @@ mod general_category {\n     }\n \n     pure fn Lo(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\u01bb'\n             | '\\u01c0' to '\\u01c3'\n             | '\\u0294'\n@@ -892,7 +892,7 @@ mod general_category {\n     }\n \n     pure fn Lt(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\u01c5'\n             | '\\u01c8'\n             | '\\u01cb'\n@@ -909,7 +909,7 @@ mod general_category {\n     }\n \n     pure fn Lu(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\x41' to '\\x5a'\n             | '\\xc0' to '\\xd6'\n             | '\\xd8' to '\\xde'\n@@ -1501,7 +1501,7 @@ mod general_category {\n     }\n \n     pure fn Mc(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\u0903'\n             | '\\u093b'\n             | '\\u093e' to '\\u0940'\n@@ -1612,7 +1612,7 @@ mod general_category {\n     }\n \n     pure fn Me(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\u0488' to '\\u0489'\n             | '\\u20dd' to '\\u20e0'\n             | '\\u20e2' to '\\u20e4'\n@@ -1623,7 +1623,7 @@ mod general_category {\n     }\n \n     pure fn Mn(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\u0300' to '\\u036f'\n             | '\\u0483' to '\\u0487'\n             | '\\u0591' to '\\u05bd'\n@@ -1816,7 +1816,7 @@ mod general_category {\n     }\n \n     pure fn Nd(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\x30' to '\\x39'\n             | '\\u0660' to '\\u0669'\n             | '\\u06f0' to '\\u06f9'\n@@ -1860,7 +1860,7 @@ mod general_category {\n     }\n \n     pure fn Nl(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\u16ee' to '\\u16f0'\n             | '\\u2160' to '\\u2182'\n             | '\\u2185' to '\\u2188'\n@@ -1879,7 +1879,7 @@ mod general_category {\n     }\n \n     pure fn No(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\xb2' to '\\xb3'\n             | '\\xb9'\n             | '\\xbc' to '\\xbe'\n@@ -1927,7 +1927,7 @@ mod general_category {\n     }\n \n     pure fn Pc(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\x5f'\n             | '\\u203f' to '\\u2040'\n             | '\\u2054'\n@@ -1940,7 +1940,7 @@ mod general_category {\n     }\n \n     pure fn Pd(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\x2d'\n             | '\\u058a'\n             | '\\u05be'\n@@ -1962,7 +1962,7 @@ mod general_category {\n     }\n \n     pure fn Pe(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\x29'\n             | '\\x5d'\n             | '\\x7d'\n@@ -2039,7 +2039,7 @@ mod general_category {\n     }\n \n     pure fn Pf(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\xbb'\n             | '\\u2019'\n             | '\\u201d'\n@@ -2056,7 +2056,7 @@ mod general_category {\n     }\n \n     pure fn Pi(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\xab'\n             | '\\u2018'\n             | '\\u201b' to '\\u201c'\n@@ -2074,7 +2074,7 @@ mod general_category {\n     }\n \n     pure fn Po(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\x21' to '\\x23'\n             | '\\x25' to '\\x27'\n             | '\\x2a'\n@@ -2207,7 +2207,7 @@ mod general_category {\n     }\n \n     pure fn Ps(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\x28'\n             | '\\x5b'\n             | '\\x7b'\n@@ -2286,7 +2286,7 @@ mod general_category {\n     }\n \n     pure fn Sc(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\x24'\n             | '\\xa2' to '\\xa5'\n             | '\\u060b'\n@@ -2309,7 +2309,7 @@ mod general_category {\n     }\n \n     pure fn Sk(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\x5e'\n             | '\\x60'\n             | '\\xa8'\n@@ -2343,7 +2343,7 @@ mod general_category {\n     }\n \n     pure fn Sm(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\x2b'\n             | '\\x3c' to '\\x3e'\n             | '\\x7c'\n@@ -2414,7 +2414,7 @@ mod general_category {\n     }\n \n     pure fn So(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\xa6' to '\\xa7'\n             | '\\xa9'\n             | '\\xae'\n@@ -2533,23 +2533,23 @@ mod general_category {\n     }\n \n     pure fn Zl(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\u2028'\n               { true }\n             _ { false }\n         };\n     }\n \n     pure fn Zp(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\u2029'\n               { true }\n             _ { false }\n         };\n     }\n \n     pure fn Zs(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\x20'\n             | '\\xa0'\n             | '\\u1680'\n@@ -2567,7 +2567,7 @@ mod general_category {\n mod derived_property {\n     /// Check if a character has the alphabetic unicode property\n     pure fn Alphabetic(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\x41' to '\\x5a'\n             | '\\x61' to '\\x7a'\n             | '\\xaa'\n@@ -3305,7 +3305,7 @@ mod derived_property {\n     }\n \n     pure fn XID_Continue(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\x30' to '\\x39'\n             | '\\x41' to '\\x5a'\n             | '\\x5f'\n@@ -4176,7 +4176,7 @@ mod derived_property {\n     }\n \n     pure fn XID_Start(c: char) -> bool {\n-        ret alt c {\n+        return alt c {\n               '\\x41' to '\\x5a'\n             | '\\x61' to '\\x7a'\n             | '\\xaa'"}, {"sha": "e56900876fcd166fb0fec4f0bf484f0e0a3968f6", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -44,7 +44,7 @@ unsafe fn bump_box_refcount<T>(+t: @T) { forget(t); }\n unsafe fn transmute<L, G>(-thing: L) -> G {\n     let newthing = reinterpret_cast(thing);\n     forget(thing);\n-    ret newthing;\n+    return newthing;\n }\n \n #[cfg(test)]"}, {"sha": "670df1bd00b4b7110604ea98ad574ebec2b12876", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -191,7 +191,7 @@ pure fn from_fn<T>(n_elts: uint, op: init_op<T>) -> ~[T] {\n     let mut i: uint = 0u;\n     while i < n_elts unsafe { unsafe::set(v, i, op(i)); i += 1u; }\n     unsafe { unsafe::set_len(v, n_elts); }\n-    ret v;\n+    return v;\n }\n \n /**\n@@ -208,7 +208,7 @@ pure fn from_elem<T: copy>(n_elts: uint, t: T) -> ~[T] {\n         while i < n_elts { unsafe::set(v, i, t); i += 1u; }\n         unsafe { unsafe::set_len(v, n_elts); }\n     }\n-    ret v;\n+    return v;\n }\n \n /**\n@@ -234,7 +234,7 @@ pure fn build_sized<A>(size: uint, builder: fn(push: pure fn(+A))) -> ~[A] {\n             <fn(push: pure fn(+A)), fn(push: fn(+A))>\n             (builder)(|+x| push(vec, x));\n     }\n-    ret vec;\n+    return vec;\n }\n \n /**\n@@ -269,7 +269,7 @@ pure fn head<T: copy>(v: &[const T]) -> T { v[0] }\n \n /// Returns a vector containing all but the first element of a slice\n pure fn tail<T: copy>(v: &[const T]) -> ~[T] {\n-    ret slice(v, 1u, len(v));\n+    return slice(v, 1u, len(v));\n }\n \n /**\n@@ -297,7 +297,7 @@ pure fn last<T: copy>(v: &[const T]) -> T {\n  * or `none` if the vector is empty.\n  */\n pure fn last_opt<T: copy>(v: &[const T]) -> option<T> {\n-    if len(v) == 0u { ret none; }\n+    if len(v) == 0u { return none; }\n     some(v[len(v) - 1u])\n }\n \n@@ -309,7 +309,7 @@ pure fn slice<T: copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n     unchecked {\n         for uint::range(start, end) |i| { vec::push(result, v[i]) }\n     }\n-    ret result;\n+    return result;\n }\n \n /// Return a slice that points into another slice.\n@@ -351,7 +351,7 @@ pure fn const_view<T>(v: &[const T], start: uint, end: uint) -> &[const T] {\n /// Split the vector `v` by applying each element against the predicate `f`.\n fn split<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n-    if (ln == 0u) { ret ~[] }\n+    if (ln == 0u) { return ~[] }\n \n     let mut start = 0u;\n     let mut result = ~[];\n@@ -374,7 +374,7 @@ fn split<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n  */\n fn splitn<T: copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n-    if (ln == 0u) { ret ~[] }\n+    if (ln == 0u) { return ~[] }\n \n     let mut start = 0u;\n     let mut count = n;\n@@ -400,7 +400,7 @@ fn splitn<T: copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n  */\n fn rsplit<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n-    if (ln == 0u) { ret ~[] }\n+    if (ln == 0u) { return ~[] }\n \n     let mut end = ln;\n     let mut result = ~[];\n@@ -423,7 +423,7 @@ fn rsplit<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n  */\n fn rsplitn<T: copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n-    if (ln == 0u) { ret ~[] }\n+    if (ln == 0u) { return ~[] }\n \n     let mut end = ln;\n     let mut count = n;\n@@ -564,7 +564,7 @@ pure fn append<T: copy>(+lhs: ~[T], rhs: &[const T]) -> ~[T] {\n     unchecked {\n         push_all(v, rhs);\n     }\n-    ret v;\n+    return v;\n }\n \n #[inline(always)]\n@@ -591,7 +591,7 @@ pure fn append_mut<T: copy>(lhs: &[mut T], rhs: &[const T]) -> ~[mut T] {\n         }\n         i += 1u;\n     }\n-    ret v;\n+    return v;\n }\n \n /**\n@@ -649,7 +649,7 @@ pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> ~[U] {\n     let mut result = ~[];\n     unchecked{reserve(result, len(v));}\n     for each(v) |elem| { unsafe { push(result, f(elem)); } }\n-    ret result;\n+    return result;\n }\n \n fn map_consume<T, U>(+v: ~[T], f: fn(+T) -> U) -> ~[U] {\n@@ -665,7 +665,7 @@ pure fn mapi<T, U>(v: &[T], f: fn(uint, T) -> U) -> ~[U] {\n     let mut result = ~[];\n     unchecked{reserve(result, len(v));}\n     for eachi(v) |i, elem| { unsafe { push(result, f(i, elem)); } }\n-    ret result;\n+    return result;\n }\n \n /**\n@@ -675,7 +675,7 @@ pure fn mapi<T, U>(v: &[T], f: fn(uint, T) -> U) -> ~[U] {\n pure fn flat_map<T, U>(v: &[T], f: fn(T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n     for each(v) |elem| { unchecked{ push_all_move(result, f(elem)); } }\n-    ret result;\n+    return result;\n }\n \n /// Apply a function to each pair of elements and return the results\n@@ -689,7 +689,7 @@ pure fn map2<T: copy, U: copy, V>(v0: &[T], v1: &[U],\n         unsafe { push(u, f(copy v0[i], copy v1[i])) };\n         i += 1u;\n     }\n-    ret u;\n+    return u;\n }\n \n /**\n@@ -707,7 +707,7 @@ pure fn filter_map<T, U: copy>(v: &[T], f: fn(T) -> option<U>)\n           some(result_elem) { unsafe { push(result, result_elem); } }\n         }\n     }\n-    ret result;\n+    return result;\n }\n \n /**\n@@ -722,7 +722,7 @@ pure fn filter<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[T] {\n     for each(v) |elem| {\n         if f(elem) { unsafe { push(result, elem); } }\n     }\n-    ret result;\n+    return result;\n }\n \n /**\n@@ -733,7 +733,7 @@ pure fn filter<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[T] {\n pure fn concat<T: copy>(v: &[~[T]]) -> ~[T] {\n     let mut r = ~[];\n     for each(v) |inner| { unsafe { push_all(r, inner); } }\n-    ret r;\n+    return r;\n }\n \n /// Concatenate a vector of vectors, placing a given separator between each\n@@ -744,7 +744,7 @@ pure fn connect<T: copy>(v: &[~[T]], sep: T) -> ~[T] {\n         if first { first = false; } else { unsafe { push(r, sep); } }\n         unchecked { push_all(r, inner) };\n     }\n-    ret r;\n+    return r;\n }\n \n /// Reduce a vector from left to right\n@@ -753,7 +753,7 @@ pure fn foldl<T: copy, U>(z: T, v: &[U], p: fn(T, U) -> T) -> T {\n     do iter(v) |elt| {\n         accum = p(accum, elt);\n     }\n-    ret accum;\n+    return accum;\n }\n \n /// Reduce a vector from right to left\n@@ -762,7 +762,7 @@ pure fn foldr<T, U: copy>(v: &[T], z: U, p: fn(T, U) -> U) -> U {\n     do riter(v) |elt| {\n         accum = p(elt, accum);\n     }\n-    ret accum;\n+    return accum;\n }\n \n /**\n@@ -771,8 +771,8 @@ pure fn foldr<T, U: copy>(v: &[T], z: U, p: fn(T, U) -> U) -> U {\n  * If the vector contains no elements then false is returned.\n  */\n pure fn any<T>(v: &[T], f: fn(T) -> bool) -> bool {\n-    for each(v) |elem| { if f(elem) { ret true; } }\n-    ret false;\n+    for each(v) |elem| { if f(elem) { return true; } }\n+    return false;\n }\n \n /**\n@@ -786,10 +786,10 @@ pure fn any2<T, U>(v0: &[T], v1: &[U],\n     let v1_len = len(v1);\n     let mut i = 0u;\n     while i < v0_len && i < v1_len {\n-        if f(v0[i], v1[i]) { ret true; };\n+        if f(v0[i], v1[i]) { return true; };\n         i += 1u;\n     }\n-    ret false;\n+    return false;\n }\n \n /**\n@@ -798,8 +798,8 @@ pure fn any2<T, U>(v0: &[T], v1: &[U],\n  * If the vector contains no elements then true is returned.\n  */\n pure fn all<T>(v: &[T], f: fn(T) -> bool) -> bool {\n-    for each(v) |elem| { if !f(elem) { ret false; } }\n-    ret true;\n+    for each(v) |elem| { if !f(elem) { return false; } }\n+    return true;\n }\n \n /**\n@@ -808,8 +808,8 @@ pure fn all<T>(v: &[T], f: fn(T) -> bool) -> bool {\n  * If the vector contains no elements then true is returned.\n  */\n pure fn alli<T>(v: &[T], f: fn(uint, T) -> bool) -> bool {\n-    for eachi(v) |i, elem| { if !f(i, elem) { ret false; } }\n-    ret true;\n+    for eachi(v) |i, elem| { if !f(i, elem) { return false; } }\n+    return true;\n }\n \n /**\n@@ -820,23 +820,23 @@ pure fn alli<T>(v: &[T], f: fn(uint, T) -> bool) -> bool {\n pure fn all2<T, U>(v0: &[T], v1: &[U],\n                    f: fn(T, U) -> bool) -> bool {\n     let v0_len = len(v0);\n-    if v0_len != len(v1) { ret false; }\n+    if v0_len != len(v1) { return false; }\n     let mut i = 0u;\n-    while i < v0_len { if !f(v0[i], v1[i]) { ret false; }; i += 1u; }\n-    ret true;\n+    while i < v0_len { if !f(v0[i], v1[i]) { return false; }; i += 1u; }\n+    return true;\n }\n \n /// Return true if a vector contains an element with the given value\n pure fn contains<T>(v: &[T], x: T) -> bool {\n-    for each(v) |elt| { if x == elt { ret true; } }\n-    ret false;\n+    for each(v) |elt| { if x == elt { return true; } }\n+    return false;\n }\n \n /// Returns the number of elements that are equal to a given value\n pure fn count<T>(v: &[T], x: T) -> uint {\n     let mut cnt = 0u;\n     for each(v) |elt| { if x == elt { cnt += 1u; } }\n-    ret cnt;\n+    return cnt;\n }\n \n /**\n@@ -913,8 +913,8 @@ pure fn position_between<T>(v: &[T], start: uint, end: uint,\n     assert start <= end;\n     assert end <= len(v);\n     let mut i = start;\n-    while i < end { if f(v[i]) { ret some::<uint>(i); } i += 1u; }\n-    ret none;\n+    while i < end { if f(v[i]) { return some::<uint>(i); } i += 1u; }\n+    return none;\n }\n \n /// Find the last index containing a matching value\n@@ -947,10 +947,10 @@ pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n     assert end <= len(v);\n     let mut i = end;\n     while i > start {\n-        if f(v[i - 1u]) { ret some::<uint>(i - 1u); }\n+        if f(v[i - 1u]) { return some::<uint>(i - 1u); }\n         i -= 1u;\n     }\n-    ret none;\n+    return none;\n }\n \n // FIXME: if issue #586 gets implemented, could have a postcondition\n@@ -974,7 +974,7 @@ pure fn unzip<T: copy, U: copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n             vec::push(bs, b);\n         }\n     }\n-    ret (as, bs);\n+    return (as, bs);\n }\n \n /**\n@@ -989,7 +989,7 @@ pure fn zip<T: copy, U: copy>(v: &[const T], u: &[const U]) -> ~[(T, U)] {\n     let mut i = 0u;\n     assert sz == len(u);\n     while i < sz unchecked { vec::push(zipped, (v[i], u[i])); i += 1u; }\n-    ret zipped;\n+    return zipped;\n }\n \n /**\n@@ -1017,12 +1017,12 @@ fn reverse<T>(v: ~[mut T]) {\n pure fn reversed<T: copy>(v: &[const T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n     let mut i = len::<T>(v);\n-    if i == 0u { ret rs; } else { i -= 1u; }\n+    if i == 0u { return rs; } else { i -= 1u; }\n     unchecked {\n         while i != 0u { vec::push(rs, v[i]); i -= 1u; }\n         vec::push(rs, v[0]);\n     }\n-    ret rs;\n+    return rs;\n }\n \n /**\n@@ -1229,7 +1229,7 @@ pure fn windowed<TT: copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n             vec::push(ww, vec::slice(xx, ii, ii+nn));\n         }\n     });\n-    ret ww;\n+    return ww;\n }\n \n /**\n@@ -1541,7 +1541,7 @@ mod unsafe {\n      */\n     #[inline(always)]\n     unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n-        ret ::unsafe::reinterpret_cast(\n+        return ::unsafe::reinterpret_cast(\n             rustrt::vec_from_buf_shared(sys::get_type_desc::<T>(),\n                                         ptr as *(),\n                                         elts as size_t));\n@@ -1572,14 +1572,14 @@ mod unsafe {\n     #[inline(always)]\n     unsafe fn to_ptr<T>(v: ~[const T]) -> *T {\n         let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n-        ret ::unsafe::reinterpret_cast(addr_of((**repr).data));\n+        return ::unsafe::reinterpret_cast(addr_of((**repr).data));\n     }\n \n \n     #[inline(always)]\n     unsafe fn to_ptr_slice<T>(v: &[const T]) -> *T {\n         let repr: **slice_repr = ::unsafe::reinterpret_cast(addr_of(v));\n-        ret ::unsafe::reinterpret_cast(addr_of((**repr).data));\n+        return ::unsafe::reinterpret_cast(addr_of((**repr).data));\n     }\n \n \n@@ -1775,21 +1775,21 @@ impl extensions/&<A:copy> of iter_trait_extensions<A> for &[A] {\n #[cfg(test)]\n mod tests {\n \n-    fn square(n: uint) -> uint { ret n * n; }\n+    fn square(n: uint) -> uint { return n * n; }\n \n-    fn square_ref(&&n: uint) -> uint { ret n * n; }\n+    fn square_ref(&&n: uint) -> uint { return n * n; }\n \n-    pure fn is_three(&&n: uint) -> bool { ret n == 3u; }\n+    pure fn is_three(&&n: uint) -> bool { return n == 3u; }\n \n-    pure fn is_odd(&&n: uint) -> bool { ret n % 2u == 1u; }\n+    pure fn is_odd(&&n: uint) -> bool { return n % 2u == 1u; }\n \n-    pure fn is_equal(&&x: uint, &&y:uint) -> bool { ret x == y; }\n+    pure fn is_equal(&&x: uint, &&y:uint) -> bool { return x == y; }\n \n     fn square_if_odd(&&n: uint) -> option<uint> {\n-        ret if n % 2u == 1u { some(n * n) } else { none };\n+        return if n % 2u == 1u { some(n * n) } else { none };\n     }\n \n-    fn add(&&x: uint, &&y: uint) -> uint { ret x + y; }\n+    fn add(&&x: uint, &&y: uint) -> uint { return x + y; }\n \n     #[test]\n     fn test_unsafe_ptrs() {\n@@ -2015,7 +2015,7 @@ mod tests {\n \n     #[test]\n     fn test_map2() {\n-        fn times(&&x: int, &&y: int) -> int { ret x * y; }\n+        fn times(&&x: int, &&y: int) -> int { return x * y; }\n         let f = times;\n         let v0 = ~[1, 2, 3, 4, 5];\n         let v1 = ~[5, 4, 3, 2, 1];\n@@ -2043,10 +2043,10 @@ mod tests {\n \n         fn halve(&&i: int) -> option<int> {\n             if i % 2 == 0 {\n-                ret option::some::<int>(i / 2);\n-            } else { ret option::none::<int>; }\n+                return option::some::<int>(i / 2);\n+            } else { return option::none::<int>; }\n         }\n-        fn halve_for_sure(&&i: int) -> int { ret i / 2; }\n+        fn halve_for_sure(&&i: int) -> int { return i / 2; }\n         let all_even: ~[int] = ~[0, 2, 8, 6];\n         let all_odd1: ~[int] = ~[1, 7, 3];\n         let all_odd2: ~[int] = ~[];\n@@ -2230,8 +2230,8 @@ mod tests {\n \n     #[test]\n     fn test_position() {\n-        fn less_than_three(&&i: int) -> bool { ret i < 3; }\n-        fn is_eighteen(&&i: int) -> bool { ret i == 18; }\n+        fn less_than_three(&&i: int) -> bool { return i < 3; }\n+        fn is_eighteen(&&i: int) -> bool { return i == 18; }\n \n         assert position(~[], less_than_three) == none;\n "}, {"sha": "b9bc977db318f0c0a6bd84a1cf07cc70f2aa3294", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -20,7 +20,7 @@ fn chunk(size: uint) -> @chunk {\n }\n \n fn arena_with_size(initial_size: uint) -> arena {\n-    ret arena_({mut chunks: @cons(chunk(initial_size), @nil)});\n+    return arena_({mut chunks: @cons(chunk(initial_size), @nil)});\n }\n \n fn arena() -> arena {\n@@ -36,7 +36,7 @@ impl arena for arena {\n         head = chunk(uint::next_power_of_two(new_min_chunk_size + 1u));\n         self.chunks = @cons(head, self.chunks);\n \n-        ret self.alloc_inner(n_bytes, align);\n+        return self.alloc_inner(n_bytes, align);\n     }\n \n     #[inline(always)]\n@@ -48,13 +48,13 @@ impl arena for arena {\n         start = (start + alignm1) & !alignm1;\n         let end = start + n_bytes;\n         if end > vec::capacity(head.data) {\n-            ret self.alloc_grow(n_bytes, align);\n+            return self.alloc_grow(n_bytes, align);\n         }\n \n         unsafe {\n             let p = ptr::offset(vec::unsafe::to_ptr(head.data), start);\n             head.fill = end;\n-            ret unsafe::reinterpret_cast(p);\n+            return unsafe::reinterpret_cast(p);\n         }\n     }\n "}, {"sha": "8ee0253ba40be08bef198ecc8e98b2f45b2074c7", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -100,11 +100,11 @@ impl of from_base64 for ~[u8] {\n                       1u {\n                         vec::push(r, ((n >> 16u) & 0xFFu) as u8);\n                         vec::push(r, ((n >> 8u ) & 0xFFu) as u8);\n-                        ret copy r;\n+                        return copy r;\n                       }\n                       2u {\n                         vec::push(r, ((n >> 10u) & 0xFFu) as u8);\n-                        ret copy r;\n+                        return copy r;\n                       }\n                       _ {\n                         fail ~\"invalid base64 padding\";"}, {"sha": "f27e6c3e266359e2a02abc40a5d063df920fbf34", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -143,7 +143,7 @@ class big_bitv {\n     fn equals(b: &big_bitv) -> bool {\n         let len = b.storage.len();\n         for uint::iterate(0, len) |i| {\n-            if self.storage[i] != b.storage[i] { ret false; }\n+            if self.storage[i] != b.storage[i] { return false; }\n         }\n     }\n }\n@@ -287,7 +287,7 @@ class bitv {\n  */\n     #[inline(always)]\n     fn equal(v1: bitv) -> bool {\n-      if self.nbits != v1.nbits { ret false; }\n+      if self.nbits != v1.nbits { return false; }\n       alt self.rep {\n         small(b) {\n           alt v1.rep {\n@@ -300,7 +300,7 @@ class bitv {\n             big(s1) {\n               s.equals(s1)\n             }\n-            small(_) { ret false; }\n+            small(_) { return false; }\n           }\n         }\n       }\n@@ -354,7 +354,7 @@ class bitv {\n       alt self.rep {\n         small(b) { b.is_true() }\n         _ {\n-          for self.each() |i| { if !i { ret false; } }\n+          for self.each() |i| { if !i { return false; } }\n           true\n         }\n       }\n@@ -375,14 +375,14 @@ class bitv {\n       alt self.rep {\n         small(b) { b.is_false() }\n         big(_) {\n-          for self.each() |i| { if i { ret false; } }\n+          for self.each() |i| { if i { return false; } }\n           true\n         }\n       }\n     }\n \n     fn init_to_vec(i: uint) -> uint {\n-      ret if self.get(i) { 1 } else { 0 };\n+      return if self.get(i) { 1 } else { 0 };\n     }\n \n /**\n@@ -392,7 +392,7 @@ class bitv {\n  */\n     fn to_vec() -> ~[uint] {\n       let sub = |x| self.init_to_vec(x);\n-      ret vec::from_fn::<uint>(self.nbits, sub);\n+      return vec::from_fn::<uint>(self.nbits, sub);\n     }\n \n /**\n@@ -420,7 +420,7 @@ class bitv {\n        while i < self.nbits {\n            let w0 = self.get(i);\n            let w1 = v[i];\n-           if !w0 && w1 != 0u || w0 && w1 == 0u { ret false; }\n+           if !w0 && w1 != 0u || w0 && w1 == 0u { return false; }\n            i = i + 1;\n        }\n        true\n@@ -438,11 +438,11 @@ class bitv {\n \n const uint_bits: uint = 32u + (1u << 32u >> 27u);\n \n-pure fn lor(w0: uint, w1: uint) -> uint { ret w0 | w1; }\n+pure fn lor(w0: uint, w1: uint) -> uint { return w0 | w1; }\n \n-pure fn land(w0: uint, w1: uint) -> uint { ret w0 & w1; }\n+pure fn land(w0: uint, w1: uint) -> uint { return w0 & w1; }\n \n-pure fn right(_w0: uint, w1: uint) -> uint { ret w1; }\n+pure fn right(_w0: uint, w1: uint) -> uint { return w1; }\n \n impl extensions of ops::index<uint,bool> for bitv {\n     pure fn index(&&i: uint) -> bool {"}, {"sha": "b80ec82bcf3b9958f1a7517283d58e6503bea0ef", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -66,7 +66,7 @@ class dtor_res {\n  * * len - The number of elements in the buffer\n  */\n unsafe fn c_vec<T>(base: *mut T, len: uint) -> c_vec<T> {\n-    ret c_vec_({\n+    return c_vec_({\n         base: base,\n         len: len,\n         rsrc: @dtor_res(option::none)\n@@ -86,7 +86,7 @@ unsafe fn c_vec<T>(base: *mut T, len: uint) -> c_vec<T> {\n  */\n unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: fn@())\n   -> c_vec<T> {\n-    ret c_vec_({\n+    return c_vec_({\n         base: base,\n         len: len,\n         rsrc: @dtor_res(option::some(dtor))\n@@ -104,7 +104,7 @@ unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: fn@())\n  */\n fn get<T: copy>(t: c_vec<T>, ofs: uint) -> T {\n     assert ofs < len(t);\n-    ret unsafe { *ptr::mut_offset((*t).base, ofs) };\n+    return unsafe { *ptr::mut_offset((*t).base, ofs) };\n }\n \n /**\n@@ -123,12 +123,12 @@ fn set<T: copy>(t: c_vec<T>, ofs: uint, v: T) {\n \n /// Returns the length of the vector\n fn len<T>(t: c_vec<T>) -> uint {\n-    ret (*t).len;\n+    return (*t).len;\n }\n \n /// Returns a pointer to the first element of the vector\n unsafe fn ptr<T>(t: c_vec<T>) -> *mut T {\n-    ret (*t).base;\n+    return (*t).base;\n }\n \n #[cfg(test)]\n@@ -140,7 +140,7 @@ mod tests {\n \n         assert mem as int != 0;\n \n-        ret unsafe { c_vec_with_dtor(mem as *mut u8, n as uint,\n+        return unsafe { c_vec_with_dtor(mem as *mut u8, n as uint,\n                                      ||free(mem)) };\n     }\n "}, {"sha": "cc2c9dae3d6ae1be930681c90dc74737c214b74e", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -8,19 +8,19 @@ trait fuzzy_eq {\n \n impl fuzzy_eq of fuzzy_eq for float {\n     pure fn fuzzy_eq(&&other: float) -> bool {\n-        ret float::abs(self - other) < fuzzy_epsilon;\n+        return float::abs(self - other) < fuzzy_epsilon;\n     }\n }\n \n impl fuzzy_eq of fuzzy_eq for f32 {\n     pure fn fuzzy_eq(&&other: f32) -> bool {\n-        ret f32::abs(self - other) < (fuzzy_epsilon as f32);\n+        return f32::abs(self - other) < (fuzzy_epsilon as f32);\n     }\n }\n \n impl fuzzy_eq of fuzzy_eq for f64 {\n     pure fn fuzzy_eq(&&other: f64) -> bool {\n-        ret f64::abs(self - other) < (fuzzy_epsilon as f64);\n+        return f64::abs(self - other) < (fuzzy_epsilon as f64);\n     }\n }\n "}, {"sha": "f3feb26ebb612b527d33945b61f03441e2456eaa", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -38,7 +38,7 @@ fn create<T: copy>() -> t<T> {\n             i += 1u;\n         }\n \n-        ret rv;\n+        return rv;\n     }\n     fn get<T: copy>(elts: dvec<cell<T>>, i: uint) -> T {\n         alt elts.get_elt(i) { some(t) { t } _ { fail } }\n@@ -50,7 +50,7 @@ fn create<T: copy>() -> t<T> {\n                     elts: dvec<cell<T>>};\n \n     impl <T: copy> of t<T> for repr<T> {\n-        fn size() -> uint { ret self.nelts; }\n+        fn size() -> uint { return self.nelts; }\n         fn add_front(t: T) {\n             let oldlo: uint = self.lo;\n             if self.lo == 0u {\n@@ -83,7 +83,7 @@ fn create<T: copy>() -> t<T> {\n             self.elts.set_elt(self.lo, none);\n             self.lo = (self.lo + 1u) % self.elts.len();\n             self.nelts -= 1u;\n-            ret t;\n+            return t;\n         }\n         fn pop_back() -> T {\n             if self.hi == 0u {\n@@ -92,13 +92,13 @@ fn create<T: copy>() -> t<T> {\n             let t: T = get(self.elts, self.hi);\n             self.elts.set_elt(self.hi, none);\n             self.nelts -= 1u;\n-            ret t;\n+            return t;\n         }\n-        fn peek_front() -> T { ret get(self.elts, self.lo); }\n-        fn peek_back() -> T { ret get(self.elts, self.hi - 1u); }\n+        fn peek_front() -> T { return get(self.elts, self.lo); }\n+        fn peek_back() -> T { return get(self.elts, self.hi - 1u); }\n         fn get(i: int) -> T {\n             let idx = (self.lo + (i as uint)) % self.elts.len();\n-            ret get(self.elts, idx);\n+            return get(self.elts, idx);\n         }\n     }\n \n@@ -235,48 +235,54 @@ mod tests {\n \n     #[test]\n     fn test() {\n-        fn inteq(&&a: int, &&b: int) -> bool { ret a == b; }\n-        fn intboxeq(&&a: @int, &&b: @int) -> bool { ret a == b; }\n+        fn inteq(&&a: int, &&b: int) -> bool { return a == b; }\n+        fn intboxeq(&&a: @int, &&b: @int) -> bool { return a == b; }\n         fn taggyeq(a: taggy, b: taggy) -> bool {\n             alt a {\n-              one(a1) { alt b { one(b1) { ret a1 == b1; } _ { ret false; } } }\n+              one(a1) {\n+                alt b { one(b1) {return a1 == b1; } _ { return false; } }\n+              }\n               two(a1, a2) {\n                 alt b {\n-                  two(b1, b2) { ret a1 == b1 && a2 == b2; }\n-                  _ { ret false; }\n+                  two(b1, b2) { return a1 == b1 && a2 == b2; }\n+                  _ { return false; }\n                 }\n               }\n               three(a1, a2, a3) {\n                 alt b {\n-                  three(b1, b2, b3) { ret a1 == b1 && a2 == b2 && a3 == b3; }\n-                  _ { ret false; }\n+                  three(b1, b2, b3) {\n+                    return a1 == b1 && a2 == b2 && a3 == b3;\n+                  }\n+                  _ { return false; }\n                 }\n               }\n             }\n         }\n         fn taggypareq<T>(a: taggypar<T>, b: taggypar<T>) -> bool {\n             alt a {\n               onepar::<T>(a1) {\n-                alt b { onepar::<T>(b1) { ret a1 == b1; } _ { ret false; } }\n+                alt b {\n+                  onepar::<T>(b1) { return a1 == b1; } _ { return false; }\n+                }\n               }\n               twopar::<T>(a1, a2) {\n                 alt b {\n-                  twopar::<T>(b1, b2) { ret a1 == b1 && a2 == b2; }\n-                  _ { ret false; }\n+                  twopar::<T>(b1, b2) { return a1 == b1 && a2 == b2; }\n+                  _ { return false; }\n                 }\n               }\n               threepar::<T>(a1, a2, a3) {\n                 alt b {\n                   threepar::<T>(b1, b2, b3) {\n-                    ret a1 == b1 && a2 == b2 && a3 == b3;\n+                    return a1 == b1 && a2 == b2 && a3 == b3;\n                   }\n-                  _ { ret false; }\n+                  _ { return false; }\n                 }\n               }\n             }\n         }\n         fn reccyeq(a: reccy, b: reccy) -> bool {\n-            ret a.x == b.x && a.y == b.y && taggyeq(a.t, b.t);\n+            return a.x == b.x && a.y == b.y && taggyeq(a.t, b.t);\n         }\n         debug!{\"*** test boxes\"};\n         test_boxes(@5, @72, @64, @175);"}, {"sha": "46ccaa2d09694ad4c7abb15889665fef1b02ef74", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -63,19 +63,19 @@ impl extensions of ops::index<uint,doc> for doc {\n fn vuint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n     let a = data[start];\n     if a & 0x80u8 != 0u8 {\n-        ret {val: (a & 0x7fu8) as uint, next: start + 1u};\n+        return {val: (a & 0x7fu8) as uint, next: start + 1u};\n     }\n     if a & 0x40u8 != 0u8 {\n-        ret {val: ((a & 0x3fu8) as uint) << 8u |\n+        return {val: ((a & 0x3fu8) as uint) << 8u |\n                  (data[start + 1u] as uint),\n              next: start + 2u};\n     } else if a & 0x20u8 != 0u8 {\n-        ret {val: ((a & 0x1fu8) as uint) << 16u |\n+        return {val: ((a & 0x1fu8) as uint) << 16u |\n                  (data[start + 1u] as uint) << 8u |\n                  (data[start + 2u] as uint),\n              next: start + 3u};\n     } else if a & 0x10u8 != 0u8 {\n-        ret {val: ((a & 0x0fu8) as uint) << 24u |\n+        return {val: ((a & 0x0fu8) as uint) << 24u |\n                  (data[start + 1u] as uint) << 16u |\n                  (data[start + 2u] as uint) << 8u |\n                  (data[start + 3u] as uint),\n@@ -84,14 +84,14 @@ fn vuint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n }\n \n fn doc(data: @~[u8]) -> doc {\n-    ret {data: data, start: 0u, end: vec::len::<u8>(*data)};\n+    return {data: data, start: 0u, end: vec::len::<u8>(*data)};\n }\n \n fn doc_at(data: @~[u8], start: uint) -> tagged_doc {\n     let elt_tag = vuint_at(*data, start);\n     let elt_size = vuint_at(*data, elt_tag.next);\n     let end = elt_size.next + elt_size.val;\n-    ret {tag: elt_tag.val,\n+    return {tag: elt_tag.val,\n          doc: {data: data, start: elt_size.next, end: end}};\n }\n \n@@ -102,15 +102,19 @@ fn maybe_get_doc(d: doc, tg: uint) -> option<doc> {\n         let elt_size = vuint_at(*d.data, elt_tag.next);\n         pos = elt_size.next + elt_size.val;\n         if elt_tag.val == tg {\n-            ret some::<doc>({data: d.data, start: elt_size.next, end: pos});\n+            return some::<doc>({\n+                data: d.data,\n+                start: elt_size.next,\n+                end: pos\n+            });\n         }\n     }\n-    ret none::<doc>;\n+    return none::<doc>;\n }\n \n fn get_doc(d: doc, tg: uint) -> doc {\n     alt maybe_get_doc(d, tg) {\n-      some(d) { ret d; }\n+      some(d) { return d; }\n       none {\n         error!{\"failed to find block with tag %u\", tg};\n         fail;\n@@ -147,29 +151,29 @@ fn tagged_docs(d: doc, tg: uint, it: fn(doc) -> bool) {\n fn doc_data(d: doc) -> ~[u8] { vec::slice::<u8>(*d.data, d.start, d.end) }\n \n fn with_doc_data<T>(d: doc, f: fn(x: &[u8]) -> T) -> T {\n-    ret f(vec::view(*d.data, d.start, d.end));\n+    return f(vec::view(*d.data, d.start, d.end));\n }\n \n-fn doc_as_str(d: doc) -> ~str { ret str::from_bytes(doc_data(d)); }\n+fn doc_as_str(d: doc) -> ~str { return str::from_bytes(doc_data(d)); }\n \n fn doc_as_u8(d: doc) -> u8 {\n     assert d.end == d.start + 1u;\n-    ret (*d.data)[d.start];\n+    return (*d.data)[d.start];\n }\n \n fn doc_as_u16(d: doc) -> u16 {\n     assert d.end == d.start + 2u;\n-    ret io::u64_from_be_bytes(*d.data, d.start, 2u) as u16;\n+    return io::u64_from_be_bytes(*d.data, d.start, 2u) as u16;\n }\n \n fn doc_as_u32(d: doc) -> u32 {\n     assert d.end == d.start + 4u;\n-    ret io::u64_from_be_bytes(*d.data, d.start, 4u) as u32;\n+    return io::u64_from_be_bytes(*d.data, d.start, 4u) as u32;\n }\n \n fn doc_as_u64(d: doc) -> u64 {\n     assert d.end == d.start + 8u;\n-    ret io::u64_from_be_bytes(*d.data, d.start, 8u);\n+    return io::u64_from_be_bytes(*d.data, d.start, 8u);\n }\n \n fn doc_as_i8(d: doc) -> i8 { doc_as_u8(d) as i8 }\n@@ -205,16 +209,16 @@ fn write_sized_vuint(w: io::writer, n: uint, size: uint) {\n }\n \n fn write_vuint(w: io::writer, n: uint) {\n-    if n < 0x7f_u { write_sized_vuint(w, n, 1u); ret; }\n-    if n < 0x4000_u { write_sized_vuint(w, n, 2u); ret; }\n-    if n < 0x200000_u { write_sized_vuint(w, n, 3u); ret; }\n-    if n < 0x10000000_u { write_sized_vuint(w, n, 4u); ret; }\n+    if n < 0x7f_u { write_sized_vuint(w, n, 1u); return; }\n+    if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n+    if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n+    if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n     fail fmt!{\"vint to write too big: %?\", n};\n }\n \n fn writer(w: io::writer) -> writer {\n     let size_positions: ~[uint] = ~[];\n-    ret writer_({writer: w, mut size_positions: size_positions});\n+    return writer_({writer: w, mut size_positions: size_positions});\n }\n \n // FIXME (#2741): Provide a function to write the standard ebml header.\n@@ -462,7 +466,7 @@ impl deserializer_priv for ebml_deserializer {\n                       r_doc.end, self.parent.end};\n         }\n         self.pos = r_doc.end;\n-        ret r_doc;\n+        return r_doc;\n     }\n \n     fn push_doc<T: copy>(d: ebml::doc, f: fn() -> T) -> T{\n@@ -473,13 +477,13 @@ impl deserializer_priv for ebml_deserializer {\n         let r = f();\n         self.parent = old_parent;\n         self.pos = old_pos;\n-        ret r;\n+        return r;\n     }\n \n     fn _next_uint(exp_tag: ebml_serializer_tag) -> uint {\n         let r = ebml::doc_as_u32(self.next_doc(exp_tag));\n         debug!{\"_next_uint exp_tag=%? result=%?\", exp_tag, r};\n-        ret r as uint;\n+        return r as uint;\n     }\n }\n \n@@ -495,7 +499,7 @@ impl deserializer of serialization::deserializer for ebml_deserializer {\n         if v > (core::uint::max_value as u64) {\n             fail fmt!{\"uint %? too large for this architecture\", v};\n         }\n-        ret v as uint;\n+        return v as uint;\n     }\n \n     fn read_i64() -> i64 { ebml::doc_as_u64(self.next_doc(es_i64)) as i64 }\n@@ -507,7 +511,7 @@ impl deserializer of serialization::deserializer for ebml_deserializer {\n         if v > (int::max_value as i64) || v < (int::min_value as i64) {\n             fail fmt!{\"int %? out of range for this architecture\", v};\n         }\n-        ret v as int;\n+        return v as int;\n     }\n \n     fn read_bool() -> bool { ebml::doc_as_u8(self.next_doc(es_bool)) as bool }"}, {"sha": "ed7d4206436c9f993f1c29e34fc55774560d0c01", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -49,14 +49,14 @@\n  *         };\n  *         if opt_present(matches, \"h\") || opt_present(matches, \"help\") {\n  *             print_usage(program);\n- *             ret;\n+ *             return;\n  *         }\n  *         let output = opt_maybe_str(matches, \"o\");\n  *         let input = if vec::is_not_empty(matches.free) {\n  *             matches.free[0]\n  *         } else {\n  *             print_usage(program);\n- *             ret;\n+ *             return;\n  *         };\n  *         do_work(input, output);\n  *     }\n@@ -94,37 +94,37 @@ enum occur { req, optional, multi, }\n type opt = {name: name, hasarg: hasarg, occur: occur};\n \n fn mkname(nm: ~str) -> name {\n-    ret if str::len(nm) == 1u {\n+    return if str::len(nm) == 1u {\n             short(str::char_at(nm, 0u))\n         } else { long(nm) };\n }\n \n /// Create an option that is required and takes an argument\n fn reqopt(name: ~str) -> opt {\n-    ret {name: mkname(name), hasarg: yes, occur: req};\n+    return {name: mkname(name), hasarg: yes, occur: req};\n }\n \n /// Create an option that is optional and takes an argument\n fn optopt(name: ~str) -> opt {\n-    ret {name: mkname(name), hasarg: yes, occur: optional};\n+    return {name: mkname(name), hasarg: yes, occur: optional};\n }\n \n /// Create an option that is optional and does not take an argument\n fn optflag(name: ~str) -> opt {\n-    ret {name: mkname(name), hasarg: no, occur: optional};\n+    return {name: mkname(name), hasarg: no, occur: optional};\n }\n \n /// Create an option that is optional and takes an optional argument\n fn optflagopt(name: ~str) -> opt {\n-    ret {name: mkname(name), hasarg: maybe, occur: optional};\n+    return {name: mkname(name), hasarg: maybe, occur: optional};\n }\n \n /**\n  * Create an option that is optional, takes an argument, and may occur\n  * multiple times\n  */\n fn optmulti(name: ~str) -> opt {\n-    ret {name: mkname(name), hasarg: yes, occur: multi};\n+    return {name: mkname(name), hasarg: yes, occur: multi};\n }\n \n enum optval { val(~str), given, }\n@@ -136,11 +136,11 @@ enum optval { val(~str), given, }\n type matches = {opts: ~[opt], vals: ~[~[optval]], free: ~[~str]};\n \n fn is_arg(arg: ~str) -> bool {\n-    ret str::len(arg) > 1u && arg[0] == '-' as u8;\n+    return str::len(arg) > 1u && arg[0] == '-' as u8;\n }\n \n fn name_str(nm: name) -> ~str {\n-    ret alt nm { short(ch) { str::from_char(ch) } long(s) { s } };\n+    return alt nm { short(ch) { str::from_char(ch) } long(s) { s } };\n }\n \n fn find_opt(opts: ~[opt], nm: name) -> option<uint> {\n@@ -161,7 +161,7 @@ enum fail_ {\n \n /// Convert a `fail_` enum into an error string\n fn fail_str(f: fail_) -> ~str {\n-    ret alt f {\n+    return alt f {\n           argument_missing(nm) {\n             ~\"Argument to option '\" + nm + ~\"' missing.\"\n           }\n@@ -191,7 +191,7 @@ type result = result::result<matches, fail_>;\n  */\n fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n     let n_opts = vec::len::<opt>(opts);\n-    fn f(_x: uint) -> ~[optval] { ret ~[]; }\n+    fn f(_x: uint) -> ~[optval] { return ~[]; }\n     let vals = vec::to_mut(vec::from_fn(n_opts, f));\n     let mut free: ~[~str] = ~[];\n     let l = vec::len(args);\n@@ -262,12 +262,12 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n                 name_pos += 1u;\n                 let optid = alt find_opt(opts, nm) {\n                   some(id) { id }\n-                  none { ret err(unrecognized_option(name_str(nm))); }\n+                  none { return err(unrecognized_option(name_str(nm))); }\n                 };\n                 alt opts[optid].hasarg {\n                   no {\n                     if !option::is_none::<~str>(i_arg) {\n-                        ret err(unexpected_argument(name_str(nm)));\n+                        return err(unexpected_argument(name_str(nm)));\n                     }\n                     vec::push(vals[optid], given);\n                   }\n@@ -284,7 +284,7 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n                         vec::push(vals[optid],\n                                   val(option::get::<~str>(i_arg)));\n                     } else if i + 1u == l {\n-                        ret err(argument_missing(name_str(nm)));\n+                        return err(argument_missing(name_str(nm)));\n                     } else { i += 1u; vec::push(vals[optid], val(args[i])); }\n                   }\n                 }\n@@ -298,42 +298,42 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n         let occ = opts[i].occur;\n         if occ == req {\n             if n == 0u {\n-                ret err(option_missing(name_str(opts[i].name)));\n+                return err(option_missing(name_str(opts[i].name)));\n             }\n         }\n         if occ != multi {\n             if n > 1u {\n-                ret err(option_duplicated(name_str(opts[i].name)));\n+                return err(option_duplicated(name_str(opts[i].name)));\n             }\n         }\n         i += 1u;\n     }\n-    ret ok({opts: opts, vals: vec::from_mut(vals), free: free});\n+    return ok({opts: opts, vals: vec::from_mut(vals), free: free});\n }\n \n fn opt_vals(m: matches, nm: ~str) -> ~[optval] {\n-    ret alt find_opt(m.opts, mkname(nm)) {\n+    return alt find_opt(m.opts, mkname(nm)) {\n           some(id) { m.vals[id] }\n           none { error!{\"No option '%s' defined\", nm}; fail }\n         };\n }\n \n-fn opt_val(m: matches, nm: ~str) -> optval { ret opt_vals(m, nm)[0]; }\n+fn opt_val(m: matches, nm: ~str) -> optval { return opt_vals(m, nm)[0]; }\n \n /// Returns true if an option was matched\n fn opt_present(m: matches, nm: ~str) -> bool {\n-    ret vec::len::<optval>(opt_vals(m, nm)) > 0u;\n+    return vec::len::<optval>(opt_vals(m, nm)) > 0u;\n }\n \n /// Returns true if any of several options were matched\n fn opts_present(m: matches, names: ~[~str]) -> bool {\n     for vec::each(names) |nm| {\n         alt find_opt(m.opts, mkname(nm)) {\n-          some(_) { ret true; }\n+          some(_) { return true; }\n           _ { }\n         }\n     }\n-    ret false;\n+    return false;\n }\n \n \n@@ -344,7 +344,7 @@ fn opts_present(m: matches, names: ~[~str]) -> bool {\n  * argument\n  */\n fn opt_str(m: matches, nm: ~str) -> ~str {\n-    ret alt opt_val(m, nm) { val(s) { s } _ { fail } };\n+    return alt opt_val(m, nm) { val(s) { s } _ { fail } };\n }\n \n /**\n@@ -356,7 +356,7 @@ fn opt_str(m: matches, nm: ~str) -> ~str {\n fn opts_str(m: matches, names: ~[~str]) -> ~str {\n     for vec::each(names) |nm| {\n         alt opt_val(m, nm) {\n-          val(s) { ret s }\n+          val(s) { return s }\n           _ {  }\n         }\n     }\n@@ -375,14 +375,14 @@ fn opt_strs(m: matches, nm: ~str) -> ~[~str] {\n     for vec::each(opt_vals(m, nm)) |v| {\n         alt v { val(s) { vec::push(acc, s); } _ { } }\n     }\n-    ret acc;\n+    return acc;\n }\n \n /// Returns the string argument supplied to a matching option or none\n fn opt_maybe_str(m: matches, nm: ~str) -> option<~str> {\n     let vals = opt_vals(m, nm);\n-    if vec::len::<optval>(vals) == 0u { ret none::<~str>; }\n-    ret alt vals[0] { val(s) { some::<~str>(s) } _ { none::<~str> } };\n+    if vec::len::<optval>(vals) == 0u { return none::<~str>; }\n+    return alt vals[0] { val(s) { some::<~str>(s) } _ { none::<~str> } };\n }\n \n \n@@ -395,8 +395,8 @@ fn opt_maybe_str(m: matches, nm: ~str) -> option<~str> {\n  */\n fn opt_default(m: matches, nm: ~str, def: ~str) -> option<~str> {\n     let vals = opt_vals(m, nm);\n-    if vec::len::<optval>(vals) == 0u { ret none::<~str>; }\n-    ret alt vals[0] { val(s) { some::<~str>(s) } _ { some::<~str>(def) } }\n+    if vec::len::<optval>(vals) == 0u { return none::<~str>; }\n+    return alt vals[0] { val(s) { some::<~str>(s) } _ { some::<~str>(def) } }\n }\n \n #[cfg(test)]"}, {"sha": "f2c2a616edefdfbb84098847bbb0c5a6431dff9f", "filename": "src/libstd/json.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -68,7 +68,7 @@ fn to_writer(wr: io::writer, j: json) {\n       dict(d) {\n         if d.size() == 0u {\n             wr.write_str(~\"{}\");\n-            ret;\n+            return;\n         }\n \n         wr.write_str(~\"{ \");\n@@ -168,7 +168,7 @@ impl parser for parser {\n     fn parse_value() -> result<json, error> {\n         self.parse_whitespace();\n \n-        if self.eof() { ret self.error(~\"EOF while parsing value\"); }\n+        if self.eof() { return self.error(~\"EOF while parsing value\"); }\n \n         alt self.ch {\n           'n' { self.parse_ident(~\"ull\", null) }\n@@ -210,20 +210,20 @@ impl parser for parser {\n \n         let mut res = alt self.parse_integer() {\n           ok(res) { res }\n-          err(e) { ret err(e); }\n+          err(e) { return err(e); }\n         };\n \n         if self.ch == '.' {\n             alt self.parse_decimal(res) {\n               ok(r) { res = r; }\n-              err(e) { ret err(e); }\n+              err(e) { return err(e); }\n             }\n         }\n \n         if self.ch == 'e' || self.ch == 'E' {\n             alt self.parse_exponent(res) {\n               ok(r) { res = r; }\n-              err(e) { ret err(e); }\n+              err(e) { return err(e); }\n             }\n         }\n \n@@ -239,7 +239,7 @@ impl parser for parser {\n \n             // There can be only one leading '0'.\n             alt self.ch {\n-              '0' to '9' { ret self.error(~\"invalid number\"); }\n+              '0' to '9' { return self.error(~\"invalid number\"); }\n               _ {}\n             }\n           }\n@@ -256,7 +256,7 @@ impl parser for parser {\n                 }\n             }\n           }\n-          _ { ret self.error(~\"invalid number\"); }\n+          _ { return self.error(~\"invalid number\"); }\n         }\n \n         ok(res)\n@@ -268,7 +268,7 @@ impl parser for parser {\n         // Make sure a digit follows the decimal place.\n         alt self.ch {\n           '0' to '9' {}\n-          _ { ret self.error(~\"invalid number\"); }\n+          _ { return self.error(~\"invalid number\"); }\n         }\n \n         let mut res = res;\n@@ -304,7 +304,7 @@ impl parser for parser {\n         // Make sure a digit follows the exponent place.\n         alt self.ch {\n           '0' to '9' {}\n-          _ { ret self.error(~\"invalid number\"); }\n+          _ { return self.error(~\"invalid number\"); }\n         }\n \n         while !self.eof() {\n@@ -356,27 +356,27 @@ impl parser for parser {\n                               n = n * 10u +\n                                   (self.ch as uint) - ('0' as uint);\n                             }\n-                            _ { ret self.error(~\"invalid \\\\u escape\"); }\n+                            _ { return self.error(~\"invalid \\\\u escape\"); }\n                           }\n                           i += 1u;\n                       }\n \n                       // Error out if we didn't parse 4 digits.\n                       if i != 4u {\n-                          ret self.error(~\"invalid \\\\u escape\");\n+                          return self.error(~\"invalid \\\\u escape\");\n                       }\n \n                       str::push_char(res, n as char);\n                   }\n-                  _ { ret self.error(~\"invalid escape\"); }\n+                  _ { return self.error(~\"invalid escape\"); }\n                 }\n                 escape = false;\n             } else if self.ch == '\\\\' {\n                 escape = true;\n             } else {\n                 if self.ch == '\"' {\n                     self.bump();\n-                    ret ok(@res);\n+                    return ok(@res);\n                 }\n                 str::push_char(res, self.ch);\n             }\n@@ -393,24 +393,24 @@ impl parser for parser {\n \n         if self.ch == ']' {\n             self.bump();\n-            ret ok(list(@values));\n+            return ok(list(@values));\n         }\n \n         loop {\n             alt self.parse_value() {\n               ok(v) { vec::push(values, v); }\n-              e { ret e; }\n+              e { return e; }\n             }\n \n             self.parse_whitespace();\n             if self.eof() {\n-                ret self.error(~\"EOF while parsing list\");\n+                return self.error(~\"EOF while parsing list\");\n             }\n \n             alt self.ch {\n               ',' { self.bump(); }\n-              ']' { self.bump(); ret ok(list(@values)); }\n-              _ { ret self.error(~\"expected `,` or `]`\"); }\n+              ']' { self.bump(); return ok(list(@values)); }\n+              _ { return self.error(~\"expected `,` or `]`\"); }\n             }\n         };\n     }\n@@ -423,46 +423,46 @@ impl parser for parser {\n \n         if self.ch == '}' {\n           self.bump();\n-          ret ok(dict(values));\n+          return ok(dict(values));\n         }\n \n         while !self.eof() {\n             self.parse_whitespace();\n \n             if self.ch != '\"' {\n-                ret self.error(~\"key must be a string\");\n+                return self.error(~\"key must be a string\");\n             }\n \n             let key = alt self.parse_str() {\n               ok(key) { key }\n-              err(e) { ret err(e); }\n+              err(e) { return err(e); }\n             };\n \n             self.parse_whitespace();\n \n             if self.ch != ':' {\n                 if self.eof() { break; }\n-                ret self.error(~\"expected `:`\");\n+                return self.error(~\"expected `:`\");\n             }\n             self.bump();\n \n             alt self.parse_value() {\n               ok(value) { values.insert(copy *key, value); }\n-              e { ret e; }\n+              e { return e; }\n             }\n             self.parse_whitespace();\n \n             alt self.ch {\n               ',' { self.bump(); }\n-              '}' { self.bump(); ret ok(dict(values)); }\n+              '}' { self.bump(); return ok(dict(values)); }\n               _ {\n                   if self.eof() { break; }\n-                  ret self.error(~\"expected `,` or `}`\");\n+                  return self.error(~\"expected `,` or `}`\");\n               }\n             }\n         }\n \n-        ret self.error(~\"EOF while parsing object\");\n+        return self.error(~\"EOF while parsing object\");\n     }\n }\n "}, {"sha": "019c9cce63223be21100910eeda2330568de1686", "filename": "src/libstd/list.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -45,20 +45,20 @@ fn find<T: copy>(ls: @list<T>, f: fn(T) -> bool) -> option<T> {\n     loop {\n         ls = alt *ls {\n           cons(hd, tl) {\n-            if f(hd) { ret some(hd); }\n+            if f(hd) { return some(hd); }\n             tl\n           }\n-          nil { ret none; }\n+          nil { return none; }\n         }\n     };\n }\n \n /// Returns true if a list contains an element with the given value\n fn has<T: copy>(ls: @list<T>, elt: T) -> bool {\n     for each(ls) |e| {\n-        if e == elt { ret true; }\n+        if e == elt { return true; }\n     }\n-    ret false;\n+    return false;\n }\n \n /// Returns true if the list is empty\n@@ -71,7 +71,7 @@ pure fn is_empty<T: copy>(ls: @list<T>) -> bool {\n \n /// Returns true if the list is not empty\n pure fn is_not_empty<T: copy>(ls: @list<T>) -> bool {\n-    ret !is_empty(ls);\n+    return !is_empty(ls);\n }\n \n /// Returns the length of a list\n@@ -84,7 +84,7 @@ fn len<T>(ls: @list<T>) -> uint {\n /// Returns all but the first element of a list\n pure fn tail<T: copy>(ls: @list<T>) -> @list<T> {\n     alt *ls {\n-        cons(_, tl) { ret tl; }\n+        cons(_, tl) { return tl; }\n         nil { fail ~\"list empty\" }\n     }\n }\n@@ -97,8 +97,8 @@ pure fn head<T: copy>(ls: @list<T>) -> T {\n /// Appends one list to another\n pure fn append<T: copy>(l: @list<T>, m: @list<T>) -> @list<T> {\n     alt *l {\n-      nil { ret m; }\n-      cons(x, xs) { let rest = append(xs, m); ret @cons(x, rest); }\n+      nil { return m; }\n+      cons(x, xs) { let rest = append(xs, m); return @cons(x, rest); }\n     }\n }\n \n@@ -127,7 +127,7 @@ fn each<T>(l: @list<T>, f: fn(T) -> bool) {\n     loop {\n         cur = alt *cur {\n           cons(hd, tl) {\n-            if !f(hd) { ret; }\n+            if !f(hd) { return; }\n             tl\n           }\n           nil { break; }\n@@ -174,7 +174,7 @@ mod tests {\n \n     #[test]\n     fn test_foldl() {\n-        fn add(&&a: uint, &&b: int) -> uint { ret a + (b as uint); }\n+        fn add(&&a: uint, &&b: int) -> uint { return a + (b as uint); }\n         let l = from_vec(~[0, 1, 2, 3, 4]);\n         let empty = @list::nil::<int>;\n         assert (list::foldl(0u, l, add) == 10u);\n@@ -192,14 +192,14 @@ mod tests {\n \n     #[test]\n     fn test_find_success() {\n-        fn match_(&&i: int) -> bool { ret i == 2; }\n+        fn match_(&&i: int) -> bool { return i == 2; }\n         let l = from_vec(~[0, 1, 2]);\n         assert (list::find(l, match_) == option::some(2));\n     }\n \n     #[test]\n     fn test_find_fail() {\n-        fn match_(&&_i: int) -> bool { ret false; }\n+        fn match_(&&_i: int) -> bool { return false; }\n         let l = from_vec(~[0, 1, 2]);\n         let empty = @list::nil::<int>;\n         assert (list::find(l, match_) == option::none::<int>);"}, {"sha": "eb5c8cc95ab174fda5e9dbb02895c377af820468", "filename": "src/libstd/map.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -124,15 +124,15 @@ mod chained {\n                   absent {\n                     debug!{\"search_tbl: absent, comp %u, hash %u, idx %u\",\n                            comp, h, idx};\n-                    ret not_found;\n+                    return not_found;\n                   }\n                   present(e1) {\n                     comp += 1u;\n                     if e1.hash == h && self.eqer(e1.key, k) {\n                         debug!{\"search_tbl: present, comp %u, \\\n                                 hash %u, idx %u\",\n                                comp, h, idx};\n-                        ret found_after(e0, e1);\n+                        return found_after(e0, e1);\n                     } else {\n                         e0 = e1;\n                     }\n@@ -147,15 +147,15 @@ mod chained {\n               absent {\n                 debug!{\"search_tbl: absent, comp %u, hash %u, idx %u\",\n                        0u, h, idx};\n-                ret not_found;\n+                return not_found;\n               }\n               present(e) {\n                 if e.hash == h && self.eqer(e.key, k) {\n                     debug!{\"search_tbl: present, comp %u, hash %u, idx %u\",\n                            1u, h, idx};\n-                    ret found_first(idx, e);\n+                    return found_first(idx, e);\n                 } else {\n-                    ret self.search_rem(k, h, idx, e);\n+                    return self.search_rem(k, h, idx, e);\n                 }\n               }\n             }\n@@ -182,7 +182,7 @@ mod chained {\n                       absent { break; }\n                       present(entry) {\n                         let next = entry.next;\n-                        if !blk(entry) { ret; }\n+                        if !blk(entry) { return; }\n                         next\n                       }\n                     }\n@@ -224,15 +224,15 @@ mod chained {\n                     self.rehash();\n                 }\n \n-                ret true;\n+                return true;\n               }\n               found_first(_, entry) {\n                 entry.value = v;\n-                ret false;\n+                return false;\n               }\n               found_after(_, entry) {\n                 entry.value = v;\n-                ret false\n+                return false\n               }\n             }\n         }\n@@ -292,7 +292,7 @@ mod chained {\n         fn to_writer(wr: io::writer) {\n             if self.count == 0u {\n                 wr.write_str(\"{}\");\n-                ret;\n+                return;\n             }\n \n             wr.write_str(\"{ \");\n@@ -324,7 +324,7 @@ mod chained {\n \n \n     fn chains<K,V>(nchains: uint) -> ~[mut chain<K,V>] {\n-        ret vec::to_mut(vec::from_elem(nchains, absent));\n+        return vec::to_mut(vec::from_elem(nchains, absent));\n     }\n \n     fn mk<K, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>) -> t<K,V> {\n@@ -353,32 +353,32 @@ fn hashmap<K: const, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>)\n \n /// Construct a hashmap for string keys\n fn str_hash<V: copy>() -> hashmap<~str, V> {\n-    ret hashmap(str::hash, str::eq);\n+    return hashmap(str::hash, str::eq);\n }\n \n /// Construct a hashmap for boxed string keys\n fn box_str_hash<V: copy>() -> hashmap<@~str, V> {\n-    ret hashmap(|x: @~str| str::hash(*x), |x,y| str::eq(*x,*y));\n+    return hashmap(|x: @~str| str::hash(*x), |x,y| str::eq(*x,*y));\n }\n \n /// Construct a hashmap for byte string keys\n fn bytes_hash<V: copy>() -> hashmap<~[u8], V> {\n-    ret hashmap(vec::u8::hash, vec::u8::eq);\n+    return hashmap(vec::u8::hash, vec::u8::eq);\n }\n \n /// Construct a hashmap for int keys\n fn int_hash<V: copy>() -> hashmap<int, V> {\n-    ret hashmap(int::hash, int::eq);\n+    return hashmap(int::hash, int::eq);\n }\n \n /// Construct a hashmap for uint keys\n fn uint_hash<V: copy>() -> hashmap<uint, V> {\n-    ret hashmap(uint::hash, uint::eq);\n+    return hashmap(uint::hash, uint::eq);\n }\n \n /// Convenience function for adding keys to a hashmap with nil type keys\n fn set_add<K: const copy>(set: set<K>, key: K) -> bool {\n-    ret set.insert(key, ());\n+    return set.insert(key, ());\n }\n \n /// Convert a set into a vector.\n@@ -428,7 +428,7 @@ mod tests {\n     #[test]\n     fn test_simple() {\n         debug!{\"*** starting test_simple\"};\n-        fn eq_uint(&&x: uint, &&y: uint) -> bool { ret x == y; }\n+        fn eq_uint(&&x: uint, &&y: uint) -> bool { return x == y; }\n         fn uint_id(&&x: uint) -> uint { x }\n         let hasher_uint: map::hashfn<uint> = uint_id;\n         let eqer_uint: map::eqfn<uint> = eq_uint;\n@@ -501,7 +501,7 @@ mod tests {\n     fn test_growth() {\n         debug!{\"*** starting test_growth\"};\n         let num_to_insert: uint = 64u;\n-        fn eq_uint(&&x: uint, &&y: uint) -> bool { ret x == y; }\n+        fn eq_uint(&&x: uint, &&y: uint) -> bool { return x == y; }\n         fn uint_id(&&x: uint) -> uint { x }\n         debug!{\"uint -> uint\"};\n         let hasher_uint: map::hashfn<uint> = uint_id;\n@@ -574,12 +574,12 @@ mod tests {\n     fn test_removal() {\n         debug!{\"*** starting test_removal\"};\n         let num_to_insert: uint = 64u;\n-        fn eq(&&x: uint, &&y: uint) -> bool { ret x == y; }\n+        fn eq(&&x: uint, &&y: uint) -> bool { return x == y; }\n         fn hash(&&u: uint) -> uint {\n             // This hash function intentionally causes collisions between\n             // consecutive integer pairs.\n \n-            ret u / 2u * 2u;\n+            return u / 2u * 2u;\n         }\n         assert (hash(0u) == hash(1u));\n         assert (hash(2u) == hash(3u));"}, {"sha": "2c22d18440ab9a9817440d977b61efa3660ad05f", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -79,7 +79,7 @@ fn md4(msg: ~[u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n         a += aa; b += bb; c += cc; d += dd;\n         i += 64u;\n     }\n-    ret {a: a, b: b, c: c, d: d};\n+    return {a: a, b: b, c: c, d: d};\n }\n \n fn md4_str(msg: ~[u8]) -> ~str {"}, {"sha": "cb77f72038aa760b6084503f1285d88b71735f81", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -183,7 +183,7 @@ mod v4 {\n             let ip_rep_result = parse_to_ipv4_rep(ip);\n             if result::is_err(ip_rep_result) {\n                 let err_str = result::get_err(ip_rep_result);\n-                ret result::err({err_msg: err_str})\n+                return result::err({err_msg: err_str})\n             }\n             // ipv4_rep.as_u32 is unsafe :/\n             let input_is_inaddr_none =\n@@ -196,11 +196,11 @@ mod v4 {\n             let ref_ip_rep_result = parse_to_ipv4_rep(reformatted_name);\n             if result::is_err(ref_ip_rep_result) {\n                 let err_str = result::get_err(ref_ip_rep_result);\n-                ret result::err({err_msg: err_str})\n+                return result::err({err_msg: err_str})\n             }\n             if result::get(ref_ip_rep_result).as_u32() == INADDR_NONE &&\n                  !input_is_inaddr_none {\n-                ret result::err(\n+                return result::err(\n                     {err_msg: ~\"uv_ip4_name produced invalid result.\"})\n             }\n             else {"}, {"sha": "2cacd9de475a8678b346cbafcd52d37adc61773b", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -779,7 +779,7 @@ impl tcp_socket_buf of io::reader for @tcp_socket_buf {\n                     debug!{\"ERROR sock_buf as io::reader.read err %? %?\",\n                            err_data.err_name, err_data.err_msg};\n \n-                    ret 0;\n+                    return 0;\n                 }\n             }\n             else {\n@@ -1581,7 +1581,7 @@ mod test {\n             }\n         }\n         let ret_val = server_ch.recv();\n-        log(debug, fmt!{\"SERVER: exited and got ret val: '%s'\", ret_val});\n+        log(debug, fmt!{\"SERVER: exited and got return val: '%s'\", ret_val});\n         ret_val\n     }\n "}, {"sha": "5f77e7d414fbe7018014cfc1986d8614db0a6694", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -31,9 +31,9 @@ fn userinfo(-user: ~str, -pass: option<~str>) -> userinfo {\n fn split_char_first(s: ~str, c: char) -> (~str, ~str) {\n     let mut v = str::splitn_char(s, c, 1);\n     if v.len() == 1 {\n-        ret (s, ~\"\");\n+        return (s, ~\"\");\n     } else {\n-        ret (vec::shift(v), vec::pop(v));\n+        return (vec::shift(v), vec::pop(v));\n     }\n }\n \n@@ -44,16 +44,16 @@ fn userinfo_from_str(uinfo: ~str) -> userinfo {\n     } else {\n         option::some(p)\n     };\n-    ret userinfo(user, pass);\n+    return userinfo(user, pass);\n }\n \n fn userinfo_to_str(-userinfo: userinfo) -> ~str {\n     if option::is_some(userinfo.pass) {\n-        ret str::concat(~[copy userinfo.user, ~\":\",\n+        return str::concat(~[copy userinfo.user, ~\":\",\n                           option::unwrap(copy userinfo.pass),\n                           ~\"@\"]);\n     } else {\n-        ret str::concat(~[copy userinfo.user, ~\"@\"]);\n+        return str::concat(~[copy userinfo.user, ~\"@\"]);\n     }\n }\n \n@@ -65,7 +65,7 @@ fn query_from_str(rawquery: ~str) -> query {\n             vec::push(query, (k, v));\n         };\n     }\n-    ret query;\n+    return query;\n }\n \n fn query_to_str(query: query) -> ~str {\n@@ -74,21 +74,21 @@ fn query_to_str(query: query) -> ~str {\n         let (k, v) = kv;\n         strvec += ~[fmt!{\"%s=%s\", k, v}];\n     };\n-    ret str::connect(strvec, ~\"&\");\n+    return str::connect(strvec, ~\"&\");\n }\n \n fn get_scheme(rawurl: ~str) -> option::option<(~str, ~str)> {\n     for str::each_chari(rawurl) |i,c| {\n         if char::is_alphabetic(c) {\n             again;\n         } else if c == ':' && i != 0 {\n-            ret option::some((rawurl.slice(0,i),\n+            return option::some((rawurl.slice(0,i),\n                               rawurl.slice(i+3,str::len(rawurl))));\n         } else {\n-            ret option::none;\n+            return option::none;\n         }\n     };\n-    ret option::none;\n+    return option::none;\n }\n \n /**\n@@ -107,7 +107,7 @@ fn get_scheme(rawurl: ~str) -> option::option<(~str, ~str)> {\n fn from_str(rawurl: ~str) -> result::result<url, ~str> {\n     let mut schm = get_scheme(rawurl);\n     if option::is_none(schm) {\n-        ret result::err(~\"invalid scheme\");\n+        return result::err(~\"invalid scheme\");\n     }\n     let (scheme, rest) = option::unwrap(schm);\n     let (u, rest) = split_char_first(rest, '@');\n@@ -135,7 +135,7 @@ fn from_str(rawurl: ~str) -> result::result<url, ~str> {\n         str::unshift_char(path, '/');\n     }\n \n-    ret result::ok(url(scheme, user, host, path, query, fragment));\n+    return result::ok(url(scheme, user, host, path, query, fragment));\n }\n \n /**\n@@ -170,7 +170,7 @@ fn to_str(url: url) -> ~str {\n         ~\"\"\n     };\n \n-    ret str::concat(~[copy url.scheme,\n+    return str::concat(~[copy url.scheme,\n                       ~\"://\",\n                       user,\n                       copy url.host,"}, {"sha": "8debc45a0e9098501c8b7bd9a42e2e9723e86dd1", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 89, "deletions": 89, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -33,7 +33,7 @@ type rope = node::root;\n \n /// Create an empty rope\n fn empty() -> rope {\n-   ret node::empty;\n+   return node::empty;\n }\n \n /**\n@@ -54,7 +54,7 @@ fn empty() -> rope {\n  * * the function runs in linear time.\n  */\n fn of_str(str: @~str) -> rope {\n-    ret of_substr(str, 0u, str::len(*str));\n+    return of_substr(str, 0u, str::len(*str));\n }\n \n /**\n@@ -80,9 +80,9 @@ fn of_str(str: @~str) -> rope {\n  * * this function fails if `byte_offset` or `byte_len` do not match `str`.\n  */\n fn of_substr(str: @~str, byte_offset: uint, byte_len: uint) -> rope {\n-    if byte_len == 0u { ret node::empty; }\n+    if byte_len == 0u { return node::empty; }\n     if byte_offset + byte_len  > str::len(*str) { fail; }\n-    ret node::content(node::of_substr(str, byte_offset, byte_len));\n+    return node::content(node::of_substr(str, byte_offset, byte_len));\n }\n \n /*\n@@ -97,7 +97,7 @@ Section: Adding things to a rope\n  * * this function executes in near-constant time\n  */\n fn append_char(rope: rope, char: char) -> rope {\n-    ret append_str(rope, @str::from_chars(~[char]));\n+    return append_str(rope, @str::from_chars(~[char]));\n }\n \n /**\n@@ -108,7 +108,7 @@ fn append_char(rope: rope, char: char) -> rope {\n  * * this function executes in near-linear time\n  */\n fn append_str(rope: rope, str: @~str) -> rope {\n-    ret append_rope(rope, of_str(str))\n+    return append_rope(rope, of_str(str))\n }\n \n /**\n@@ -118,7 +118,7 @@ fn append_str(rope: rope, str: @~str) -> rope {\n  * * this function executes in near-constant time\n  */\n fn prepend_char(rope: rope, char: char) -> rope {\n-    ret prepend_str(rope, @str::from_chars(~[char]));\n+    return prepend_str(rope, @str::from_chars(~[char]));\n }\n \n /**\n@@ -128,18 +128,18 @@ fn prepend_char(rope: rope, char: char) -> rope {\n  * * this function executes in near-linear time\n  */\n fn prepend_str(rope: rope, str: @~str) -> rope {\n-    ret append_rope(of_str(str), rope)\n+    return append_rope(of_str(str), rope)\n }\n \n /// Concatenate two ropes\n fn append_rope(left: rope, right: rope) -> rope {\n    alt(left) {\n-     node::empty { ret right; }\n+     node::empty { return right; }\n      node::content(left_content) {\n        alt(right) {\n-         node::empty { ret left; }\n+         node::empty { return left; }\n      node::content(right_content) {\n-           ret node::content(node::concat2(left_content, right_content));\n+           return node::content(node::concat2(left_content, right_content));\n      }\n        }\n      }\n@@ -156,7 +156,7 @@ fn append_rope(left: rope, right: rope) -> rope {\n fn concat(v: ~[rope]) -> rope {\n     //Copy `v` into a mut vector\n     let mut len = vec::len(v);\n-    if len == 0u { ret node::empty; }\n+    if len == 0u { return node::empty; }\n     let ropes = vec::to_mut(vec::from_elem(len, v[0]));\n     for uint::range(1u, len) |i| {\n        ropes[i] = v[i];\n@@ -176,7 +176,7 @@ fn concat(v: ~[rope]) -> rope {\n     }\n \n     //Return final rope\n-    ret ropes[0];\n+    return ropes[0];\n }\n \n \n@@ -198,7 +198,7 @@ Section: Keeping ropes healthy\n  */\n fn bal(rope:rope) -> rope {\n     alt(rope) {\n-      node::empty { ret rope }\n+      node::empty { return rope }\n       node::content(x) {\n         alt(node::bal(x)) {\n           option::none   { rope }\n@@ -227,13 +227,13 @@ Section: Transforming ropes\n  *   valid positions in rope\n  */\n fn sub_chars(rope: rope, char_offset: uint, char_len: uint) -> rope {\n-    if char_len == 0u { ret node::empty; }\n+    if char_len == 0u { return node::empty; }\n     alt(rope) {\n       node::empty { fail }\n       node::content(node) {\n         if char_len > node::char_len(node) { fail }\n         else {\n-            ret node::content(node::sub_chars(node, char_offset, char_len))\n+            return node::content(node::sub_chars(node, char_offset, char_len))\n         }\n       }\n     }\n@@ -253,13 +253,13 @@ fn sub_chars(rope: rope, char_offset: uint, char_len: uint) -> rope {\n  *   valid positions in rope\n  */\n fn sub_bytes(rope: rope, byte_offset: uint, byte_len: uint) -> rope {\n-    if byte_len == 0u { ret node::empty; }\n+    if byte_len == 0u { return node::empty; }\n     alt(rope) {\n       node::empty { fail }\n       node::content(node) {\n         if byte_len > node::byte_len(node) { fail }\n         else {\n-            ret node::content(node::sub_bytes(node, byte_offset, byte_len))\n+            return node::content(node::sub_bytes(node, byte_offset, byte_len))\n         }\n       }\n     }\n@@ -281,11 +281,11 @@ Section: Comparing ropes\n  */\n fn cmp(left: rope, right: rope) -> int {\n     alt((left, right)) {\n-      (node::empty, node::empty) { ret 0; }\n-      (node::empty, _)     { ret -1;}\n-      (_, node::empty)     { ret  1;}\n+      (node::empty, node::empty) { return 0; }\n+      (node::empty, _)     { return -1;}\n+      (_, node::empty)     { return  1;}\n       (node::content(a), node::content(b)) {\n-        ret node::cmp(a, b);\n+        return node::cmp(a, b);\n       }\n     }\n }\n@@ -295,7 +295,7 @@ fn cmp(left: rope, right: rope) -> int {\n  * their structure), `false` otherwise\n  */\n fn eq(left: rope, right: rope) -> bool {\n-    ret cmp(left, right) == 0;\n+    return cmp(left, right) == 0;\n }\n \n /**\n@@ -310,7 +310,7 @@ fn eq(left: rope, right: rope) -> bool {\n  * structure), `false` otherwise\n  */\n fn le(left: rope, right: rope) -> bool {\n-    ret cmp(left, right) <= 0;\n+    return cmp(left, right) <= 0;\n }\n \n /**\n@@ -325,7 +325,7 @@ fn le(left: rope, right: rope) -> bool {\n  * structure), `false` otherwise\n  */\n fn lt(left: rope, right: rope) -> bool {\n-    ret cmp(left, right) < 0;\n+    return cmp(left, right) < 0;\n }\n \n /**\n@@ -340,7 +340,7 @@ fn lt(left: rope, right: rope) -> bool {\n  * structure), `false` otherwise\n  */\n fn ge(left: rope, right: rope) -> bool {\n-    ret cmp(left, right) >= 0;\n+    return cmp(left, right) >= 0;\n }\n \n /**\n@@ -355,7 +355,7 @@ fn ge(left: rope, right: rope) -> bool {\n  * structure), `false` otherwise\n  */\n fn gt(left: rope, right: rope) -> bool {\n-    ret cmp(left, right) > 0;\n+    return cmp(left, right) > 0;\n }\n \n /*\n@@ -384,8 +384,8 @@ Section: Iterating\n  */\n fn loop_chars(rope: rope, it: fn(char) -> bool) -> bool {\n    alt(rope) {\n-      node::empty { ret true }\n-      node::content(x) { ret node::loop_chars(x, it) }\n+      node::empty { return true }\n+      node::content(x) { return node::loop_chars(x, it) }\n    }\n }\n \n@@ -427,32 +427,32 @@ fn iter_chars(rope: rope, it: fn(char)) {\n  */\n fn loop_leaves(rope: rope, it: fn(node::leaf) -> bool) -> bool{\n    alt(rope) {\n-      node::empty { ret true }\n-      node::content(x) {ret node::loop_leaves(x, it)}\n+      node::empty { return true }\n+      node::content(x) {return node::loop_leaves(x, it)}\n    }\n }\n \n mod iterator {\n     mod leaf {\n         fn start(rope: rope) -> node::leaf_iterator::t {\n             alt(rope) {\n-              node::empty     { ret node::leaf_iterator::empty() }\n-              node::content(x) { ret node::leaf_iterator::start(x) }\n+              node::empty     { return node::leaf_iterator::empty() }\n+              node::content(x) { return node::leaf_iterator::start(x) }\n             }\n         }\n         fn next(it: node::leaf_iterator::t) -> option<node::leaf> {\n-            ret node::leaf_iterator::next(it);\n+            return node::leaf_iterator::next(it);\n         }\n     }\n     mod char {\n         fn start(rope: rope) -> node::char_iterator::t {\n             alt(rope) {\n-              node::empty   { ret node::char_iterator::empty() }\n-              node::content(x) { ret node::char_iterator::start(x) }\n+              node::empty   { return node::char_iterator::empty() }\n+              node::content(x) { return node::char_iterator::start(x) }\n             }\n         }\n         fn next(it: node::char_iterator::t) -> option<char> {\n-            ret node::char_iterator::next(it)\n+            return node::char_iterator::next(it)\n         }\n     }\n }\n@@ -474,8 +474,8 @@ mod iterator {\n  */\n fn height(rope: rope) -> uint {\n    alt(rope) {\n-      node::empty    { ret 0u; }\n-      node::content(x) { ret node::height(x); }\n+      node::empty    { return 0u; }\n+      node::content(x) { return node::height(x); }\n    }\n }\n \n@@ -490,8 +490,8 @@ fn height(rope: rope) -> uint {\n  */\n pure fn char_len(rope: rope) -> uint {\n    alt(rope) {\n-     node::empty           { ret 0u; }\n-     node::content(x)       { ret node::char_len(x) }\n+     node::empty           { return 0u; }\n+     node::content(x)       { return node::char_len(x) }\n    }\n }\n \n@@ -504,8 +504,8 @@ pure fn char_len(rope: rope) -> uint {\n  */\n pure fn byte_len(rope: rope) -> uint {\n    alt(rope) {\n-     node::empty           { ret 0u; }\n-     node::content(x)       { ret node::byte_len(x) }\n+     node::empty           { return 0u; }\n+     node::content(x)       { return node::byte_len(x) }\n    }\n }\n \n@@ -528,7 +528,7 @@ pure fn byte_len(rope: rope) -> uint {\n fn char_at(rope: rope, pos: uint) -> char {\n    alt(rope) {\n       node::empty { fail }\n-      node::content(x) { ret node::char_at(x, pos) }\n+      node::content(x) { return node::char_at(x, pos) }\n    }\n }\n \n@@ -628,7 +628,7 @@ mod node {\n      * the length of `str`.\n      */\n     fn of_str(str: @~str) -> @node {\n-        ret of_substr(str, 0u, str::len(*str));\n+        return of_substr(str, 0u, str::len(*str));\n     }\n \n     /**\n@@ -649,7 +649,7 @@ mod node {\n      * valid positions in `str`\n      */\n     fn of_substr(str: @~str, byte_start: uint, byte_len: uint) -> @node {\n-        ret of_substr_unsafer(str, byte_start, byte_len,\n+        return of_substr_unsafer(str, byte_start, byte_len,\n                               str::count_chars(*str, byte_start, byte_len));\n     }\n \n@@ -683,7 +683,7 @@ mod node {\n                 char_len:    char_len,\n                 content:     str});\n         if char_len <= hint_max_leaf_char_len {\n-            ret candidate;\n+            return candidate;\n         } else {\n             //Firstly, split `str` in slices of hint_max_leaf_char_len\n             let mut leaves = uint::div_ceil(char_len, hint_max_leaf_char_len);\n@@ -728,22 +728,22 @@ mod node {\n                 }\n                 leaves = uint::div_ceil(leaves, 2u);\n             }\n-            ret nodes[0u];\n+            return nodes[0u];\n         }\n     }\n \n     pure fn byte_len(node: @node) -> uint {\n         //FIXME (#2744): Could we do this without the pattern-matching?\n         alt(*node) {\n-          leaf(y)  { ret y.byte_len; }\n-          concat(y){ ret y.byte_len; }\n+          leaf(y)  { return y.byte_len; }\n+          concat(y){ return y.byte_len; }\n         }\n     }\n \n     pure fn char_len(node: @node) -> uint {\n         alt(*node) {\n-          leaf(y)   { ret y.char_len; }\n-          concat(y) { ret y.char_len; }\n+          leaf(y)   { return y.char_len; }\n+          concat(y) { return y.char_len; }\n         }\n     }\n \n@@ -796,7 +796,7 @@ mod node {\n             }\n             len = uint::div_ceil(len, 2u);\n         }\n-        ret forest[0];\n+        return forest[0];\n     }\n \n     fn serialize_node(node: @node) -> ~str unsafe {\n@@ -820,7 +820,7 @@ mod node {\n               }\n             }\n         }\n-        ret unsafe::transmute(buf);\n+        return unsafe::transmute(buf);\n     }\n \n     /**\n@@ -832,9 +832,9 @@ mod node {\n      */\n     fn flatten(node: @node) -> @node unsafe {\n         alt(*node) {\n-          leaf(_) { ret node }\n+          leaf(_) { return node }\n           concat(x) {\n-            ret @leaf({\n+            return @leaf({\n                 byte_offset: 0u,\n                 byte_len:    x.byte_len,\n                 char_len:    x.char_len,\n@@ -860,7 +860,7 @@ mod node {\n      *    as `node` bot lower height and/or fragmentation.\n      */\n     fn bal(node: @node) -> option<@node> {\n-        if height(node) < hint_max_node_height { ret option::none; }\n+        if height(node) < hint_max_node_height { return option::none; }\n         //1. Gather all leaves as a forest\n         let mut forest = ~[mut];\n         let it = leaf_iterator::start(node);\n@@ -872,7 +872,7 @@ mod node {\n         }\n         //2. Rebuild tree from forest\n         let root = @*tree_from_forest_destructive(forest);\n-        ret option::some(root);\n+        return option::some(root);\n \n     }\n \n@@ -900,13 +900,13 @@ mod node {\n         let mut byte_offset = byte_offset;\n         loop {\n             if byte_offset == 0u && byte_len == node::byte_len(node) {\n-                ret node;\n+                return node;\n             }\n             alt(*node) {\n               node::leaf(x) {\n                 let char_len =\n                     str::count_chars(*x.content, byte_offset, byte_len);\n-                ret @leaf({byte_offset: byte_offset,\n+                return @leaf({byte_offset: byte_offset,\n                                 byte_len:    byte_len,\n                                 char_len:    char_len,\n                                 content:     x.content});\n@@ -925,7 +925,7 @@ mod node {\n                             sub_bytes(x.left, byte_offset, left_len);\n                         let right_result =\n                             sub_bytes(x.right, 0u, left_len - byte_offset);\n-                        ret concat2(left_result, right_result);\n+                        return concat2(left_result, right_result);\n                     }\n                 } else {\n                     //Case 3: Everything fits in x.right\n@@ -963,19 +963,19 @@ mod node {\n             alt(*node) {\n               node::leaf(x) {\n                 if char_offset == 0u && char_len == x.char_len {\n-                    ret node;\n+                    return node;\n                 }\n                 let byte_offset =\n                     str::count_bytes(*x.content, 0u, char_offset);\n                 let byte_len    =\n                     str::count_bytes(*x.content, byte_offset, char_len);\n-                ret @leaf({byte_offset: byte_offset,\n+                return @leaf({byte_offset: byte_offset,\n                            byte_len:    byte_len,\n                            char_len:    char_len,\n                            content:     x.content});\n               }\n               node::concat(x) {\n-                if char_offset == 0u && char_len == x.char_len {ret node;}\n+                if char_offset == 0u && char_len == x.char_len {return node;}\n                 let left_len : uint = node::char_len(x.left);\n                 if char_offset <= left_len {\n                     if char_offset + char_len <= left_len {\n@@ -989,7 +989,7 @@ mod node {\n                             sub_chars(x.left, char_offset, left_len);\n                         let right_result =\n                             sub_chars(x.right, 0u, left_len - char_offset);\n-                        ret concat2(left_result, right_result);\n+                        return concat2(left_result, right_result);\n                     }\n                 } else {\n                     //Case 3: Everything fits in x.right, tail call\n@@ -1002,7 +1002,7 @@ mod node {\n     }\n \n     fn concat2(left: @node, right: @node) -> @node {\n-        ret @concat({left    : left,\n+        return @concat({left    : left,\n                      right   : right,\n              char_len: char_len(left) + char_len(right),\n                      byte_len: byte_len(left) + byte_len(right),\n@@ -1012,8 +1012,8 @@ mod node {\n \n     fn height(node: @node) -> uint {\n         alt(*node) {\n-          leaf(_)   { ret 0u; }\n-          concat(x) { ret x.height; }\n+          leaf(_)   { return 0u; }\n+          concat(x) { return x.height; }\n         }\n     }\n \n@@ -1037,11 +1037,11 @@ mod node {\n               }\n             }\n         }\n-        ret result;\n+        return result;\n     }\n \n     fn loop_chars(node: @node, it: fn(char) -> bool) -> bool {\n-        ret loop_leaves(node,|leaf| {\n+        return loop_leaves(node,|leaf| {\n             str::all_between(*leaf.content,\n                              leaf.byte_offset,\n                              leaf.byte_len, it)\n@@ -1067,13 +1067,13 @@ mod node {\n         loop {\n             alt(*current) {\n               leaf(x) {\n-                ret it(x);\n+                return it(x);\n               }\n               concat(x) {\n                 if loop_leaves(x.left, it) { //non tail call\n                     current = x.right;       //tail call\n                 } else {\n-                    ret false;\n+                    return false;\n                 }\n               }\n             }\n@@ -1103,7 +1103,7 @@ mod node {\n         loop {\n             alt *node {\n               leaf(x) {\n-                ret str::char_at(*x.content, pos);\n+                return str::char_at(*x.content, pos);\n               }\n               concat({left, right, _}) {\n                 let left_len = char_len(left);\n@@ -1122,19 +1122,19 @@ mod node {\n \n         fn empty() -> t {\n             let stack : ~[mut @node] = ~[mut];\n-            ret {stack: stack, mut stackpos: -1}\n+            return {stack: stack, mut stackpos: -1}\n         }\n \n         fn start(node: @node) -> t {\n             let stack = vec::to_mut(vec::from_elem(height(node)+1u, node));\n-            ret {\n+            return {\n                 stack:             stack,\n                 mut stackpos:  0\n             }\n         }\n \n         fn next(it: t) -> option<leaf> {\n-            if it.stackpos < 0 { ret option::none; }\n+            if it.stackpos < 0 { return option::none; }\n             loop {\n                 let current = it.stack[it.stackpos];\n                 it.stackpos -= 1;\n@@ -1146,7 +1146,7 @@ mod node {\n                     it.stack[it.stackpos] = x.left;\n                   }\n                   leaf(x) {\n-                    ret option::some(x);\n+                    return option::some(x);\n                   }\n                 }\n             };\n@@ -1161,15 +1161,15 @@ mod node {\n         };\n \n         fn start(node: @node) -> t {\n-            ret {\n+            return {\n                 leaf_iterator: leaf_iterator::start(node),\n                 mut leaf:          option::none,\n                 mut leaf_byte_pos: 0u\n             }\n         }\n \n         fn empty() -> t {\n-            ret {\n+            return {\n                 leaf_iterator: leaf_iterator::empty(),\n                 mut leaf:  option::none,\n                 mut leaf_byte_pos: 0u\n@@ -1179,15 +1179,15 @@ mod node {\n         fn next(it: t) -> option<char> {\n             loop {\n                 alt(get_current_or_next_leaf(it)) {\n-                  option::none { ret option::none; }\n+                  option::none { return option::none; }\n                   option::some(_) {\n                     let next_char = get_next_char_in_leaf(it);\n                     alt(next_char) {\n                       option::none {\n                         again;\n                       }\n                       option::some(_) {\n-                        ret next_char;\n+                        return next_char;\n                       }\n                     }\n                   }\n@@ -1197,15 +1197,15 @@ mod node {\n \n         fn get_current_or_next_leaf(it: t) -> option<leaf> {\n             alt(it.leaf) {\n-              option::some(_) { ret it.leaf }\n+              option::some(_) { return it.leaf }\n               option::none {\n                 let next = leaf_iterator::next(it.leaf_iterator);\n                 alt(next) {\n-                  option::none { ret option::none }\n+                  option::none { return option::none }\n                   option::some(_) {\n                     it.leaf          = next;\n                     it.leaf_byte_pos = 0u;\n-                    ret next;\n+                    return next;\n                   }\n                 }\n               }\n@@ -1214,18 +1214,18 @@ mod node {\n \n         fn get_next_char_in_leaf(it: t) -> option<char> {\n             alt copy it.leaf {\n-              option::none { ret option::none }\n+              option::none { return option::none }\n               option::some(aleaf) {\n                 if it.leaf_byte_pos >= aleaf.byte_len {\n                     //We are actually past the end of the leaf\n                     it.leaf = option::none;\n-                    ret option::none\n+                    return option::none\n                 } else {\n                     let {ch, next} =\n                         str::char_range_at(*aleaf.content,\n                                      it.leaf_byte_pos + aleaf.byte_offset);\n                     it.leaf_byte_pos = next - aleaf.byte_offset;\n-                    ret option::some(ch)\n+                    return option::some(ch)\n                 }\n               }\n             }\n@@ -1239,7 +1239,7 @@ mod tests {\n     //Utility function, used for sanity check\n     fn rope_to_string(r: rope) -> ~str {\n         alt(r) {\n-          node::empty { ret ~\"\" }\n+          node::empty { return ~\"\" }\n           node::content(x) {\n             let str = @mut ~\"\";\n             fn aux(str: @mut ~str, node: @node::node) unsafe {\n@@ -1256,7 +1256,7 @@ mod tests {\n                 }\n             }\n             aux(str, x);\n-            ret *str\n+            return *str\n           }\n         }\n     }"}, {"sha": "14410eed636752c2c54a33f0185a8c05dcf8238d", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -155,7 +155,7 @@ fn sha1() -> sha1 {\n         st.msg_block_idx = 0u;\n     }\n     fn circular_shift(bits: u32, word: u32) -> u32 {\n-        ret word << bits | word >> 32u32 - bits;\n+        return word << bits | word >> 32u32 - bits;\n     }\n     fn mk_result(st: sha1state) -> ~[u8] {\n         if !st.computed { pad_msg(st); st.computed = true; }\n@@ -167,7 +167,7 @@ fn sha1() -> sha1 {\n             let d = (hpart & 0xFFu32) as u8;\n             rs = vec::append(rs, ~[a, b, c, d]);\n         }\n-        ret rs;\n+        return rs;\n     }\n \n     /*\n@@ -233,12 +233,12 @@ fn sha1() -> sha1 {\n         }\n         fn input(msg: ~[u8]) { add_input(self, msg); }\n         fn input_str(msg: ~str) { add_input(self, str::bytes(msg)); }\n-        fn result() -> ~[u8] { ret mk_result(self); }\n+        fn result() -> ~[u8] { return mk_result(self); }\n         fn result_str() -> ~str {\n             let r = mk_result(self);\n             let mut s = ~\"\";\n             for vec::each(r) |b| { s += uint::to_str(b as uint, 16u); }\n-            ret s;\n+            return s;\n         }\n     }\n     let st = {\n@@ -252,7 +252,7 @@ fn sha1() -> sha1 {\n     };\n     let sh = st as sha1;\n     sh.reset();\n-    ret sh;\n+    return sh;\n }\n \n #[cfg(test)]\n@@ -266,7 +266,7 @@ mod tests {\n             let mut i = 0;\n             let mut rs = ~\"\";\n             while i < 100000 { str::push_str(rs, ~\"aaaaaaaaaa\"); i += 1; }\n-            ret rs;\n+            return rs;\n         }\n         // Test messages from FIPS 180-1\n "}, {"sha": "825630cf4a4905594c7c3b0b2eff19467552b538", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -18,7 +18,7 @@ enum smallintmap<T:copy> {\n /// Create a smallintmap\n fn mk<T: copy>() -> smallintmap<T> {\n     let v = dvec();\n-    ret smallintmap_(@{v: v});\n+    return smallintmap_(@{v: v});\n }\n \n /**\n@@ -36,8 +36,8 @@ fn insert<T: copy>(self: smallintmap<T>, key: uint, val: T) {\n  * in the map then returns none\n  */\n pure fn find<T: copy>(self: smallintmap<T>, key: uint) -> option<T> {\n-    if key < self.v.len() { ret self.v.get_elt(key); }\n-    ret none::<T>;\n+    if key < self.v.len() { return self.v.get_elt(key); }\n+    return none::<T>;\n }\n \n /**\n@@ -50,13 +50,13 @@ pure fn find<T: copy>(self: smallintmap<T>, key: uint) -> option<T> {\n pure fn get<T: copy>(self: smallintmap<T>, key: uint) -> T {\n     alt find(self, key) {\n       none { error!{\"smallintmap::get(): key not present\"}; fail; }\n-      some(v) { ret v; }\n+      some(v) { return v; }\n     }\n }\n \n /// Returns true if the map contains a value for the specified key\n fn contains_key<T: copy>(self: smallintmap<T>, key: uint) -> bool {\n-    ret !option::is_none(find(self, key));\n+    return !option::is_none(find(self, key));\n }\n \n /// Implements the map::map interface for smallintmap\n@@ -72,10 +72,10 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n     fn insert(+key: uint, +value: V) -> bool {\n         let exists = contains_key(self, key);\n         insert(self, key, value);\n-        ret !exists;\n+        return !exists;\n     }\n     fn remove(&&key: uint) -> option<V> {\n-        if key >= self.v.len() { ret none; }\n+        if key >= self.v.len() { return none; }\n         let old = self.v.get_elt(key);\n         self.v.set_elt(key, none);\n         old\n@@ -105,7 +105,7 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n     fn each_key(it: fn(&&uint) -> bool) {\n         let mut idx = 0u, l = self.v.len();\n         while idx < l {\n-            if self.v.get_elt(idx) != none && !it(idx) { ret; }\n+            if self.v.get_elt(idx) != none && !it(idx) { return; }\n             idx += 1u;\n         }\n     }"}, {"sha": "84aa3c2648270a6b6a2ec8f19afdb83a28f913e8", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -18,21 +18,21 @@ type le<T> = fn(T, T) -> bool;\n fn merge_sort<T: copy>(le: le<T>, v: ~[const T]) -> ~[T] {\n     type slice = (uint, uint);\n \n-    ret merge_sort_(le, v, (0u, len(v)));\n+    return merge_sort_(le, v, (0u, len(v)));\n \n     fn merge_sort_<T: copy>(le: le<T>, v: ~[const T], slice: slice)\n         -> ~[T] {\n         let begin = slice.first();\n         let end = slice.second();\n \n         let v_len = end - begin;\n-        if v_len == 0u { ret ~[]; }\n-        if v_len == 1u { ret ~[v[begin]]; }\n+        if v_len == 0u { return ~[]; }\n+        if v_len == 1u { return ~[v[begin]]; }\n \n         let mid = v_len / 2u + begin;\n         let a = (begin, mid);\n         let b = (mid, end);\n-        ret merge(le, merge_sort_(le, v, a), merge_sort_(le, v, b));\n+        return merge(le, merge_sort_(le, v, a), merge_sort_(le, v, b));\n     }\n \n     fn merge<T: copy>(le: le<T>, a: ~[T], b: ~[T]) -> ~[T] {\n@@ -50,7 +50,7 @@ fn merge_sort<T: copy>(le: le<T>, v: ~[const T]) -> ~[T] {\n         }\n         rs = vec::append(rs, vec::slice(a, a_ix, a_len));\n         rs = vec::append(rs, vec::slice(b, b_ix, b_len));\n-        ret rs;\n+        return rs;\n     }\n }\n \n@@ -68,7 +68,7 @@ fn part<T: copy>(compare_func: le<T>, arr: ~[mut T], left: uint,\n         i += 1u;\n     }\n     arr[storage_index] <-> arr[right];\n-    ret storage_index;\n+    return storage_index;\n }\n \n fn qsort<T: copy>(compare_func: le<T>, arr: ~[mut T], left: uint,\n@@ -91,13 +91,13 @@ fn qsort<T: copy>(compare_func: le<T>, arr: ~[mut T], left: uint,\n  * This is an unstable sort.\n  */\n fn quick_sort<T: copy>(compare_func: le<T>, arr: ~[mut T]) {\n-    if len::<T>(arr) == 0u { ret; }\n+    if len::<T>(arr) == 0u { return; }\n     qsort::<T>(compare_func, arr, 0u, len::<T>(arr) - 1u);\n }\n \n fn qsort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n                   arr: ~[mut T], left: int, right: int) {\n-    if right <= left { ret; }\n+    if right <= left { return; }\n     let v: T = arr[right];\n     let mut i: int = left - 1;\n     let mut j: int = right;\n@@ -154,7 +154,7 @@ fn qsort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n  * This is an unstable sort.\n  */\n fn quick_sort3<T: copy ord eq>(arr: ~[mut T]) {\n-    if len::<T>(arr) == 0u { ret; }\n+    if len::<T>(arr) == 0u { return; }\n     qsort3::<T>(|x, y| x.lt(y), |x, y| x.eq(y), arr, 0,\n                 (len::<T>(arr) as int) - 1);\n }\n@@ -202,7 +202,7 @@ mod test_qsort3 {\n mod test_qsort {\n     fn check_sort(v1: ~[mut int], v2: ~[mut int]) {\n         let len = vec::len::<int>(v1);\n-        fn leual(&&a: int, &&b: int) -> bool { ret a <= b; }\n+        fn leual(&&a: int, &&b: int) -> bool { return a <= b; }\n         let f = leual;\n         quick_sort::<int>(f, v1);\n         let mut i = 0u;\n@@ -264,7 +264,7 @@ mod tests {\n \n     fn check_sort(v1: ~[int], v2: ~[int]) {\n         let len = vec::len::<int>(v1);\n-        fn le(&&a: int, &&b: int) -> bool { ret a <= b; }\n+        fn le(&&a: int, &&b: int) -> bool { return a <= b; }\n         let f = le;\n         let v3 = merge_sort::<int>(f, v1);\n         let mut i = 0u;\n@@ -294,7 +294,7 @@ mod tests {\n \n     #[test]\n     fn test_merge_sort_mutable() {\n-        fn le(&&a: int, &&b: int) -> bool { ret a <= b; }\n+        fn le(&&a: int, &&b: int) -> bool { return a <= b; }\n         let v1 = ~[mut 3, 2, 1];\n         let v2 = merge_sort(le, v1);\n         assert v2 == ~[1, 2, 3];"}, {"sha": "80a075dbe5378f51db11bc5a9368da48c95af57e", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -11,11 +11,11 @@ fn mkdtemp(prefix: ~str, suffix: ~str) -> option<~str> {\n     while (i < 1000u) {\n         let s = prefix + r.gen_str(16u) + suffix;\n         if os::make_dir(s, 0x1c0i32) {  // FIXME: u+rwx (#2349)\n-            ret some(s);\n+            return some(s);\n         }\n         i += 1u;\n     }\n-    ret none;\n+    return none;\n }\n \n #[test]"}, {"sha": "0667acb8dd2fe7659a9e29e00e7226cc79c688ab", "filename": "src/libstd/term.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -35,10 +35,10 @@ fn reset(writer: io::writer) {\n fn color_supported() -> bool {\n     let supported_terms = ~[~\"xterm-color\", ~\"xterm\",\n                            ~\"screen-bce\", ~\"xterm-256color\"];\n-    ret alt os::getenv(~\"TERM\") {\n+    return alt os::getenv(~\"TERM\") {\n           option::some(env) {\n             for vec::each(supported_terms) |term| {\n-                if str::eq(term, env) { ret true; }\n+                if str::eq(term, env) { return true; }\n             }\n             false\n           }\n@@ -56,12 +56,12 @@ fn set_color(writer: io::writer, first_char: u8, color: u8) {\n \n /// Set the foreground color\n fn fg(writer: io::writer, color: u8) {\n-    ret set_color(writer, '3' as u8, color);\n+    return set_color(writer, '3' as u8, color);\n }\n \n /// Set the background color\n fn bg(writer: io::writer, color: u8) {\n-    ret set_color(writer, '4' as u8, color);\n+    return set_color(writer, '4' as u8, color);\n }\n \n // Local Variables:"}, {"sha": "5d503e4c15f52fec524538fb087b85a3b0dd6bed", "filename": "src/libstd/test.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -71,7 +71,7 @@ fn parse_opts(args: ~[~str]) -> opt_res {\n     let matches =\n         alt getopts::getopts(args_, opts) {\n           ok(m) { m }\n-          err(f) { ret either::right(getopts::fail_str(f)) }\n+          err(f) { return either::right(getopts::fail_str(f)) }\n         };\n \n     let filter =\n@@ -85,7 +85,7 @@ fn parse_opts(args: ~[~str]) -> opt_res {\n     let test_opts = {filter: filter, run_ignored: run_ignored,\n                      logfile: logfile};\n \n-    ret either::left(test_opts);\n+    return either::left(test_opts);\n }\n \n enum test_result { tr_ok, tr_failed, tr_ignored, }\n@@ -180,7 +180,7 @@ fn run_tests_console(opts: test_opts,\n     st.out.write_str(fmt!{\". %u passed; %u failed; %u ignored\\n\\n\", st.passed,\n                           st.failed, st.ignored});\n \n-    ret success;\n+    return success;\n \n     fn write_log(out: io::writer, result: test_result, test: test_desc) {\n         out.write_line(fmt!{\"%s %s\",\n@@ -262,7 +262,7 @@ fn should_sort_failures_before_printing_them() {\n     assert apos < bpos;\n }\n \n-fn use_color() -> bool { ret get_concurrency() == 1u; }\n+fn use_color() -> bool { return get_concurrency() == 1u; }\n \n enum testevent {\n     te_filtered(~[test_desc]),\n@@ -346,8 +346,8 @@ fn filter_tests(opts: test_opts,\n         fn filter_fn(test: test_desc, filter_str: ~str) ->\n             option<test_desc> {\n             if str::contains(test.name, filter_str) {\n-                ret option::some(copy test);\n-            } else { ret option::none; }\n+                return option::some(copy test);\n+            } else { return option::none; }\n         }\n \n         let filter = |x| filter_fn(x, filter_str);\n@@ -361,11 +361,11 @@ fn filter_tests(opts: test_opts,\n     } else {\n         fn filter(test: test_desc) -> option<test_desc> {\n             if test.ignore {\n-                ret option::some({name: test.name,\n+                return option::some({name: test.name,\n                                   fn: copy test.fn,\n                                   ignore: false,\n                                   should_fail: test.should_fail});\n-            } else { ret option::none; }\n+            } else { return option::none; }\n         };\n \n         vec::filter_map(filtered, |x| filter(x))\n@@ -380,15 +380,15 @@ fn filter_tests(opts: test_opts,\n         sort::merge_sort(|x,y| lteq(x, y), filtered)\n         };\n \n-    ret filtered;\n+    return filtered;\n }\n \n type test_future = {test: test_desc, wait: fn@() -> test_result};\n \n fn run_test(+test: test_desc, monitor_ch: comm::chan<monitor_msg>) {\n     if test.ignore {\n         comm::send(monitor_ch, (copy test, tr_ignored));\n-        ret;\n+        return;\n     }\n \n     do task::spawn {"}, {"sha": "3ec2975db1837154a8b9d48c7c7b609c3ff6d627", "filename": "src/libstd/time.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -40,7 +40,7 @@ fn get_time() -> timespec {\n     let mut sec = 0i64;\n     let mut nsec = 0i32;\n     rustrt::get_time(sec, nsec);\n-    ret {sec: sec, nsec: nsec};\n+    return {sec: sec, nsec: nsec};\n }\n \n /**\n@@ -58,7 +58,7 @@ fn precise_time_ns() -> u64 {\n  * in seconds since an unspecified epoch.\n  */\n fn precise_time_s() -> float {\n-    ret (precise_time_ns() as float) / 1000000000.;\n+    return (precise_time_ns() as float) / 1000000000.;\n }\n \n fn tzset() {\n@@ -148,11 +148,11 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n         let mut i = pos;\n         for str::each(needle) |ch| {\n             if s[i] != ch {\n-                ret false;\n+                return false;\n             }\n             i += 1u;\n         }\n-        ret true;\n+        return true;\n     }\n \n     fn match_strs(s: ~str, pos: uint, strs: ~[(~str, i32)])\n@@ -163,7 +163,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n             let (needle, value) = strs[i];\n \n             if match_str(s, pos, needle) {\n-                ret some((value, pos + str::len(needle)));\n+                return some((value, pos + str::len(needle)));\n             }\n             i += 1u;\n         }\n@@ -186,7 +186,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n                 value = value * 10_i32 + (ch as i32 - '0' as i32);\n               }\n               ' ' if ws { }\n-              _ { ret none; }\n+              _ { return none; }\n             }\n             i += 1u;\n         }"}, {"sha": "b6dc2bfa579973ee24ecc3651b42cda62b373f19", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -36,7 +36,7 @@ fn insert<K: copy, V: copy>(m: &mut tree_edge<K, V>, k: K, v: V) {\n                               mut value: v,\n                               mut left: none,\n                               mut right: none}));\n-        ret;\n+        return;\n       }\n       some(node) {\n         if k == node.key {"}, {"sha": "31d2e51e160e8ebaeac5782ce156ab90ef7d131e", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -160,12 +160,12 @@ mod icu {\n }\n \n pure fn is_XID_start(c: char) -> bool {\n-    ret icu::libicu::u_hasBinaryProperty(c, icu::UCHAR_XID_START)\n+    return icu::libicu::u_hasBinaryProperty(c, icu::UCHAR_XID_START)\n         == icu::TRUE;\n }\n \n pure fn is_XID_continue(c: char) -> bool {\n-    ret icu::libicu::u_hasBinaryProperty(c, icu::UCHAR_XID_START)\n+    return icu::libicu::u_hasBinaryProperty(c, icu::UCHAR_XID_START)\n         == icu::TRUE;\n }\n \n@@ -175,7 +175,7 @@ Function: is_digit\n Returns true if a character is a digit.\n */\n pure fn is_digit(c: char) -> bool {\n-    ret icu::libicu::u_isdigit(c) == icu::TRUE;\n+    return icu::libicu::u_isdigit(c) == icu::TRUE;\n }\n \n /*\n@@ -184,7 +184,7 @@ Function: is_lower\n Returns true if a character is a lowercase letter.\n */\n pure fn is_lower(c: char) -> bool {\n-    ret icu::libicu::u_islower(c) == icu::TRUE;\n+    return icu::libicu::u_islower(c) == icu::TRUE;\n }\n \n /*\n@@ -193,7 +193,7 @@ Function: is_space\n Returns true if a character is space.\n */\n pure fn is_space(c: char) -> bool {\n-    ret icu::libicu::u_isspace(c) == icu::TRUE;\n+    return icu::libicu::u_isspace(c) == icu::TRUE;\n }\n \n /*\n@@ -202,7 +202,7 @@ Function: is_upper\n Returns true if a character is an uppercase letter.\n */\n pure fn is_upper(c: char) -> bool {\n-    ret icu::libicu::u_isupper(c) == icu::TRUE;\n+    return icu::libicu::u_isupper(c) == icu::TRUE;\n }\n \n #[cfg(test)]"}, {"sha": "2b5beda2e37b87866bac0d53e38a2ae3816ce06f", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -28,7 +28,7 @@ extern mod rustrt {\n  * loop.\n  */\n fn get() -> iotask {\n-    ret get_monitor_task_gl();\n+    return get_monitor_task_gl();\n }\n \n #[doc(hidden)]"}, {"sha": "d7de26228cacbac43aa6a748d36bf90715262977", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -213,7 +213,7 @@ mod test {\n             run_loop(iotask_ch);\n             exit_ch.send(());\n         };\n-        ret comm::recv(iotask_port);\n+        return comm::recv(iotask_port);\n     }\n \n     extern fn lifetime_handle_close(handle: *libc::c_void) unsafe {"}, {"sha": "7b4033d0ff3e311772b9fd52efe1a094280269bd", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -303,15 +303,15 @@ type uv_getaddrinfo_t = {\n \n mod uv_ll_struct_stubgen {\n     fn gen_stub_uv_tcp_t() -> uv_tcp_t {\n-        ret gen_stub_os();\n+        return gen_stub_os();\n         #[cfg(target_os = \"linux\")]\n         #[cfg(target_os = \"macos\")]\n         #[cfg(target_os = \"freebsd\")]\n         fn gen_stub_os() -> uv_tcp_t {\n-            ret gen_stub_arch();\n+            return gen_stub_arch();\n             #[cfg(target_arch=\"x86_64\")]\n             fn gen_stub_arch() -> uv_tcp_t {\n-                ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+                return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                                 close_cb: ptr::null(),\n                                 mut data: ptr::null() },\n                     a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n@@ -336,7 +336,7 @@ mod uv_ll_struct_stubgen {\n             }\n             #[cfg(target_arch=\"x86\")]\n             fn gen_stub_arch() -> uv_tcp_t {\n-                ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+                return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                                 close_cb: ptr::null(),\n                                 mut data: ptr::null() },\n                     a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n@@ -364,7 +364,7 @@ mod uv_ll_struct_stubgen {\n         }\n         #[cfg(windows)]\n         fn gen_stub_os() -> uv_tcp_t {\n-            ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                             close_cb: ptr::null(),\n                             mut data: ptr::null() },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n@@ -385,15 +385,15 @@ mod uv_ll_struct_stubgen {\n     }\n     #[cfg(unix)]\n     fn gen_stub_uv_connect_t() -> uv_connect_t {\n-        ret {\n+        return {\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n             a03: 0 as *u8,\n             a04: 0 as *u8, a05: 0 as *u8\n         };\n     }\n     #[cfg(windows)]\n     fn gen_stub_uv_connect_t() -> uv_connect_t {\n-        ret {\n+        return {\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n             a03: 0 as *u8,\n             a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n@@ -403,10 +403,10 @@ mod uv_ll_struct_stubgen {\n     }\n     #[cfg(unix)]\n     fn gen_stub_uv_async_t() -> uv_async_t {\n-        ret gen_stub_arch();\n+        return gen_stub_arch();\n         #[cfg(target_arch = \"x86_64\")]\n         fn gen_stub_arch() -> uv_async_t {\n-            ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                             close_cb: ptr::null(),\n                             mut data: ptr::null() },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n@@ -421,7 +421,7 @@ mod uv_ll_struct_stubgen {\n         }\n         #[cfg(target_arch = \"x86\")]\n         fn gen_stub_arch() -> uv_async_t {\n-            ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                             close_cb: ptr::null(),\n                             mut data: ptr::null() },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n@@ -438,7 +438,7 @@ mod uv_ll_struct_stubgen {\n     }\n     #[cfg(windows)]\n     fn gen_stub_uv_async_t() -> uv_async_t {\n-        ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+        return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                         close_cb: ptr::null(),\n                         mut data: ptr::null() },\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n@@ -452,10 +452,10 @@ mod uv_ll_struct_stubgen {\n     }\n     #[cfg(unix)]\n     fn gen_stub_uv_timer_t() -> uv_timer_t {\n-        ret gen_stub_arch();\n+        return gen_stub_arch();\n         #[cfg(target_arch = \"x86_64\")]\n         fn gen_stub_arch() -> uv_timer_t {\n-            ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                             close_cb: ptr::null(),\n                             mut data: ptr::null() },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n@@ -470,7 +470,7 @@ mod uv_ll_struct_stubgen {\n         }\n         #[cfg(target_arch = \"x86\")]\n         fn gen_stub_arch() -> uv_timer_t {\n-            ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                             close_cb: ptr::null(),\n                             mut data: ptr::null() },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n@@ -489,7 +489,7 @@ mod uv_ll_struct_stubgen {\n     }\n     #[cfg(windows)]\n     fn gen_stub_uv_timer_t() -> uv_timer_t {\n-        ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+        return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                         close_cb: ptr::null(),\n                         mut data: ptr::null() },\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n@@ -502,10 +502,10 @@ mod uv_ll_struct_stubgen {\n     }\n     #[cfg(unix)]\n     fn gen_stub_uv_write_t() -> uv_write_t {\n-        ret gen_stub_arch();\n+        return gen_stub_arch();\n         #[cfg(target_arch=\"x86_64\")]\n         fn gen_stub_arch() -> uv_write_t {\n-            ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                             close_cb: ptr::null(),\n                             mut data: ptr::null() },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n@@ -519,7 +519,7 @@ mod uv_ll_struct_stubgen {\n         }\n         #[cfg(target_arch=\"x86\")]\n         fn gen_stub_arch() -> uv_write_t {\n-            ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                             close_cb: ptr::null(),\n                             mut data: ptr::null() },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n@@ -534,7 +534,7 @@ mod uv_ll_struct_stubgen {\n     }\n     #[cfg(windows)]\n     fn gen_stub_uv_write_t() -> uv_write_t {\n-        ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+        return { fields: { loop_handle: ptr::null(), type_: 0u32,\n                         close_cb: ptr::null(),\n                         mut data: ptr::null() },\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n@@ -676,15 +676,15 @@ extern mod rustrt {\n }\n \n unsafe fn loop_new() -> *libc::c_void {\n-    ret rustrt::rust_uv_loop_new();\n+    return rustrt::rust_uv_loop_new();\n }\n \n unsafe fn loop_delete(loop_handle: *libc::c_void) {\n     rustrt::rust_uv_loop_delete(loop_handle);\n }\n \n unsafe fn loop_refcount(loop_ptr: *libc::c_void) -> libc::c_int {\n-    ret rustrt::rust_uv_loop_refcount(loop_ptr);\n+    return rustrt::rust_uv_loop_refcount(loop_ptr);\n }\n \n unsafe fn run(loop_handle: *libc::c_void) {\n@@ -697,7 +697,7 @@ unsafe fn close<T>(handle: *T, cb: *u8) {\n \n unsafe fn tcp_init(loop_handle: *libc::c_void, handle: *uv_tcp_t)\n     -> libc::c_int {\n-    ret rustrt::rust_uv_tcp_init(loop_handle, handle);\n+    return rustrt::rust_uv_tcp_init(loop_handle, handle);\n }\n // FIXME ref #2064\n unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n@@ -707,7 +707,7 @@ unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n -> libc::c_int {\n     log(debug, fmt!{\"b4 foreign tcp_connect--addr port: %u cb: %u\",\n                     (*addr_ptr).sin_port as uint, after_connect_cb as uint});\n-    ret rustrt::rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n+    return rustrt::rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n                                     after_connect_cb, addr_ptr);\n }\n // FIXME ref #2064\n@@ -716,72 +716,72 @@ unsafe fn tcp_connect6(connect_ptr: *uv_connect_t,\n                       addr_ptr: *sockaddr_in6,\n                       ++after_connect_cb: *u8)\n -> libc::c_int {\n-    ret rustrt::rust_uv_tcp_connect6(connect_ptr, tcp_handle_ptr,\n+    return rustrt::rust_uv_tcp_connect6(connect_ptr, tcp_handle_ptr,\n                                     after_connect_cb, addr_ptr);\n }\n // FIXME ref #2064\n unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t,\n                    addr_ptr: *sockaddr_in) -> libc::c_int {\n-    ret rustrt::rust_uv_tcp_bind(tcp_server_ptr,\n+    return rustrt::rust_uv_tcp_bind(tcp_server_ptr,\n                                  addr_ptr);\n }\n // FIXME ref #2064\n unsafe fn tcp_bind6(tcp_server_ptr: *uv_tcp_t,\n                    addr_ptr: *sockaddr_in6) -> libc::c_int {\n-    ret rustrt::rust_uv_tcp_bind6(tcp_server_ptr,\n+    return rustrt::rust_uv_tcp_bind6(tcp_server_ptr,\n                                  addr_ptr);\n }\n \n unsafe fn listen<T>(stream: *T, backlog: libc::c_int,\n                  cb: *u8) -> libc::c_int {\n-    ret rustrt::rust_uv_listen(stream as *libc::c_void, backlog, cb);\n+    return rustrt::rust_uv_listen(stream as *libc::c_void, backlog, cb);\n }\n \n unsafe fn accept(server: *libc::c_void, client: *libc::c_void)\n     -> libc::c_int {\n-    ret rustrt::rust_uv_accept(server as *libc::c_void,\n+    return rustrt::rust_uv_accept(server as *libc::c_void,\n                                client as *libc::c_void);\n }\n \n unsafe fn write<T>(req: *uv_write_t, stream: *T,\n          buf_in: *~[uv_buf_t], cb: *u8) -> libc::c_int {\n     let buf_ptr = vec::unsafe::to_ptr(*buf_in);\n     let buf_cnt = vec::len(*buf_in) as i32;\n-    ret rustrt::rust_uv_write(req as *libc::c_void,\n+    return rustrt::rust_uv_write(req as *libc::c_void,\n                               stream as *libc::c_void,\n                               buf_ptr, buf_cnt, cb);\n }\n unsafe fn read_start(stream: *uv_stream_t, on_alloc: *u8,\n                      on_read: *u8) -> libc::c_int {\n-    ret rustrt::rust_uv_read_start(stream as *libc::c_void,\n+    return rustrt::rust_uv_read_start(stream as *libc::c_void,\n                                    on_alloc, on_read);\n }\n \n unsafe fn read_stop(stream: *uv_stream_t) -> libc::c_int {\n-    ret rustrt::rust_uv_read_stop(stream as *libc::c_void);\n+    return rustrt::rust_uv_read_stop(stream as *libc::c_void);\n }\n \n unsafe fn last_error(loop_handle: *libc::c_void) -> uv_err_t {\n-    ret rustrt::rust_uv_last_error(loop_handle);\n+    return rustrt::rust_uv_last_error(loop_handle);\n }\n \n unsafe fn strerror(err: *uv_err_t) -> *libc::c_char {\n-    ret rustrt::rust_uv_strerror(err);\n+    return rustrt::rust_uv_strerror(err);\n }\n unsafe fn err_name(err: *uv_err_t) -> *libc::c_char {\n-    ret rustrt::rust_uv_err_name(err);\n+    return rustrt::rust_uv_err_name(err);\n }\n \n unsafe fn async_init(loop_handle: *libc::c_void,\n                      async_handle: *uv_async_t,\n                      cb: *u8) -> libc::c_int {\n-    ret rustrt::rust_uv_async_init(loop_handle,\n+    return rustrt::rust_uv_async_init(loop_handle,\n                                    async_handle,\n                                    cb);\n }\n \n unsafe fn async_send(async_handle: *uv_async_t) {\n-    ret rustrt::rust_uv_async_send(async_handle);\n+    return rustrt::rust_uv_async_send(async_handle);\n }\n unsafe fn buf_init(++input: *u8, len: uint) -> uv_buf_t {\n     let out_buf = { base: ptr::null(), len: 0 as libc::size_t };\n@@ -800,8 +800,8 @@ unsafe fn buf_init(++input: *u8, len: uint) -> uv_buf_t {\n     log(debug, fmt!{\"buf_init - result %u len %u\",\n                      res_base as uint,\n                      res_len as uint});\n-    ret out_buf;\n-    //ret result;\n+    return out_buf;\n+    //return result;\n }\n unsafe fn ip4_addr(ip: ~str, port: int)\n -> sockaddr_in {\n@@ -860,15 +860,15 @@ unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n \n unsafe fn timer_init(loop_ptr: *libc::c_void,\n                      timer_ptr: *uv_timer_t) -> libc::c_int {\n-    ret rustrt::rust_uv_timer_init(loop_ptr, timer_ptr);\n+    return rustrt::rust_uv_timer_init(loop_ptr, timer_ptr);\n }\n unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: uint,\n                       repeat: uint) -> libc::c_int {\n-    ret rustrt::rust_uv_timer_start(timer_ptr, cb, timeout as libc::c_uint,\n+    return rustrt::rust_uv_timer_start(timer_ptr, cb, timeout as libc::c_uint,\n                                     repeat as libc::c_uint);\n }\n unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> libc::c_int {\n-    ret rustrt::rust_uv_timer_stop(timer_ptr);\n+    return rustrt::rust_uv_timer_stop(timer_ptr);\n }\n unsafe fn getaddrinfo(loop_ptr: *libc::c_void,\n                            handle: *uv_getaddrinfo_t,\n@@ -889,38 +889,38 @@ unsafe fn freeaddrinfo(res: *addrinfo) {\n \n // libuv struct initializers\n unsafe fn tcp_t() -> uv_tcp_t {\n-    ret uv_ll_struct_stubgen::gen_stub_uv_tcp_t();\n+    return uv_ll_struct_stubgen::gen_stub_uv_tcp_t();\n }\n unsafe fn connect_t() -> uv_connect_t {\n-    ret uv_ll_struct_stubgen::gen_stub_uv_connect_t();\n+    return uv_ll_struct_stubgen::gen_stub_uv_connect_t();\n }\n unsafe fn write_t() -> uv_write_t {\n-    ret uv_ll_struct_stubgen::gen_stub_uv_write_t();\n+    return uv_ll_struct_stubgen::gen_stub_uv_write_t();\n }\n unsafe fn async_t() -> uv_async_t {\n-    ret uv_ll_struct_stubgen::gen_stub_uv_async_t();\n+    return uv_ll_struct_stubgen::gen_stub_uv_async_t();\n }\n unsafe fn timer_t() -> uv_timer_t {\n-    ret uv_ll_struct_stubgen::gen_stub_uv_timer_t();\n+    return uv_ll_struct_stubgen::gen_stub_uv_timer_t();\n }\n unsafe fn getaddrinfo_t() -> uv_getaddrinfo_t {\n-    ret uv_ll_struct_stubgen::gen_stub_uv_getaddrinfo_t();\n+    return uv_ll_struct_stubgen::gen_stub_uv_getaddrinfo_t();\n }\n \n // data access helpers\n unsafe fn get_loop_for_uv_handle<T>(handle: *T)\n     -> *libc::c_void {\n-    ret rustrt::rust_uv_get_loop_for_uv_handle(handle as *libc::c_void);\n+    return rustrt::rust_uv_get_loop_for_uv_handle(handle as *libc::c_void);\n }\n unsafe fn get_stream_handle_from_connect_req(connect: *uv_connect_t)\n     -> *uv_stream_t {\n-    ret rustrt::rust_uv_get_stream_handle_from_connect_req(\n+    return rustrt::rust_uv_get_stream_handle_from_connect_req(\n         connect);\n }\n unsafe fn get_stream_handle_from_write_req(\n     write_req: *uv_write_t)\n     -> *uv_stream_t {\n-    ret rustrt::rust_uv_get_stream_handle_from_write_req(\n+    return rustrt::rust_uv_get_stream_handle_from_write_req(\n         write_req);\n }\n unsafe fn get_data_for_uv_loop(loop_ptr: *libc::c_void) -> *libc::c_void {\n@@ -930,30 +930,30 @@ unsafe fn set_data_for_uv_loop(loop_ptr: *libc::c_void, data: *libc::c_void) {\n     rustrt::rust_uv_set_data_for_uv_loop(loop_ptr, data);\n }\n unsafe fn get_data_for_uv_handle<T>(handle: *T) -> *libc::c_void {\n-    ret rustrt::rust_uv_get_data_for_uv_handle(handle as *libc::c_void);\n+    return rustrt::rust_uv_get_data_for_uv_handle(handle as *libc::c_void);\n }\n unsafe fn set_data_for_uv_handle<T, U>(handle: *T,\n                     data: *U) {\n     rustrt::rust_uv_set_data_for_uv_handle(handle as *libc::c_void,\n                                            data as *libc::c_void);\n }\n unsafe fn get_data_for_req<T>(req: *T) -> *libc::c_void {\n-    ret rustrt::rust_uv_get_data_for_req(req as *libc::c_void);\n+    return rustrt::rust_uv_get_data_for_req(req as *libc::c_void);\n }\n unsafe fn set_data_for_req<T, U>(req: *T,\n                     data: *U) {\n     rustrt::rust_uv_set_data_for_req(req as *libc::c_void,\n                                      data as *libc::c_void);\n }\n unsafe fn get_base_from_buf(buf: uv_buf_t) -> *u8 {\n-    ret rustrt::rust_uv_get_base_from_buf(buf);\n+    return rustrt::rust_uv_get_base_from_buf(buf);\n }\n unsafe fn get_len_from_buf(buf: uv_buf_t) -> libc::size_t {\n-    ret rustrt::rust_uv_get_len_from_buf(buf);\n+    return rustrt::rust_uv_get_len_from_buf(buf);\n }\n unsafe fn malloc_buf_base_of(suggested_size: libc::size_t)\n     -> *u8 {\n-    ret rustrt::rust_uv_malloc_buf_base_of(suggested_size);\n+    return rustrt::rust_uv_malloc_buf_base_of(suggested_size);\n }\n unsafe fn free_base_of_buf(buf: uv_buf_t) {\n     rustrt::rust_uv_free_base_of_buf(buf);\n@@ -964,7 +964,7 @@ unsafe fn get_last_err_info(uv_loop: *libc::c_void) -> ~str {\n     let err_ptr = ptr::addr_of(err);\n     let err_name = str::unsafe::from_c_str(err_name(err_ptr));\n     let err_msg = str::unsafe::from_c_str(strerror(err_ptr));\n-    ret fmt!{\"LIBUV ERROR: name: %s msg: %s\",\n+    return fmt!{\"LIBUV ERROR: name: %s msg: %s\",\n                     err_name, err_msg};\n }\n \n@@ -1028,7 +1028,7 @@ mod test {\n                          handle,\n                          char_ptr as uint,\n                          suggested_size as uint});\n-        ret buf_init(char_ptr, suggested_size as uint);\n+        return buf_init(char_ptr, suggested_size as uint);\n     }\n \n     extern fn on_read_cb(stream: *uv_stream_t,\n@@ -1277,7 +1277,7 @@ mod test {\n             let err_msg = get_last_err_info(test_loop);\n             log(debug, fmt!{\"server_connect_cb: non-zero status: %?\",\n                          err_msg});\n-            ret;\n+            return;\n         }\n         let server_data = get_data_for_uv_handle(\n             server_stream_ptr as *libc::c_void) as *tcp_server_data;"}, {"sha": "90330db78a779f6c44514dc386022a03358ff091", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -61,7 +61,7 @@ fn extend(cx: ctx, +elt: ident) -> @path {\n }\n \n fn mk_ast_map_visitor() -> vt {\n-    ret visit::mk_vt(@{\n+    return visit::mk_vt(@{\n         visit_item: map_item,\n         visit_expr: map_expr,\n         visit_fn: map_fn,\n@@ -79,7 +79,7 @@ fn map_crate(diag: span_handler, c: crate) -> map {\n               mut local_id: 0u,\n               diag: diag};\n     visit::visit_crate(c, cx, mk_ast_map_visitor());\n-    ret cx.map;\n+    return cx.map;\n }\n \n // Used for items loaded from external crate that are being inlined into this"}, {"sha": "1ba0beea305cb66bbede2c9019490e2d56619bc7", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -19,7 +19,7 @@ pure fn mk_sp(lo: uint, hi: uint) -> span {\n }\n \n // make this a const, once the compiler supports it\n-pure fn dummy_sp() -> span { ret mk_sp(0u, 0u); }\n+pure fn dummy_sp() -> span { return mk_sp(0u, 0u); }\n \n pure fn path_name(p: @path) -> ~str { path_name_i(p.idents) }\n \n@@ -44,7 +44,7 @@ pure fn stmt_id(s: stmt) -> node_id {\n \n fn variant_def_ids(d: def) -> {enm: def_id, var: def_id} {\n     alt d { def_variant(enum_id, var_id) {\n-            ret {enm: enum_id, var: var_id}; }\n+            return {enm: enum_id, var: var_id}; }\n         _ { fail ~\"non-variant in variant_def_ids\"; } }\n }\n \n@@ -66,40 +66,40 @@ pure fn def_id_of_def(d: def) -> def_id {\n \n pure fn binop_to_str(op: binop) -> ~str {\n     alt op {\n-      add { ret ~\"+\"; }\n-      subtract { ret ~\"-\"; }\n-      mul { ret ~\"*\"; }\n-      div { ret ~\"/\"; }\n-      rem { ret ~\"%\"; }\n-      and { ret ~\"&&\"; }\n-      or { ret ~\"||\"; }\n-      bitxor { ret ~\"^\"; }\n-      bitand { ret ~\"&\"; }\n-      bitor { ret ~\"|\"; }\n-      shl { ret ~\"<<\"; }\n-      shr { ret ~\">>\"; }\n-      eq { ret ~\"==\"; }\n-      lt { ret ~\"<\"; }\n-      le { ret ~\"<=\"; }\n-      ne { ret ~\"!=\"; }\n-      ge { ret ~\">=\"; }\n-      gt { ret ~\">\"; }\n+      add { return ~\"+\"; }\n+      subtract { return ~\"-\"; }\n+      mul { return ~\"*\"; }\n+      div { return ~\"/\"; }\n+      rem { return ~\"%\"; }\n+      and { return ~\"&&\"; }\n+      or { return ~\"||\"; }\n+      bitxor { return ~\"^\"; }\n+      bitand { return ~\"&\"; }\n+      bitor { return ~\"|\"; }\n+      shl { return ~\"<<\"; }\n+      shr { return ~\">>\"; }\n+      eq { return ~\"==\"; }\n+      lt { return ~\"<\"; }\n+      le { return ~\"<=\"; }\n+      ne { return ~\"!=\"; }\n+      ge { return ~\">=\"; }\n+      gt { return ~\">\"; }\n     }\n }\n \n pure fn binop_to_method_name(op: binop) -> option<~str> {\n     alt op {\n-      add { ret some(~\"add\"); }\n-      subtract { ret some(~\"sub\"); }\n-      mul { ret some(~\"mul\"); }\n-      div { ret some(~\"div\"); }\n-      rem { ret some(~\"modulo\"); }\n-      bitxor { ret some(~\"bitxor\"); }\n-      bitand { ret some(~\"bitand\"); }\n-      bitor { ret some(~\"bitor\"); }\n-      shl { ret some(~\"shl\"); }\n-      shr { ret some(~\"shr\"); }\n-      and | or | eq | lt | le | ne | ge | gt { ret none; }\n+      add { return some(~\"add\"); }\n+      subtract { return some(~\"sub\"); }\n+      mul { return some(~\"mul\"); }\n+      div { return some(~\"div\"); }\n+      rem { return some(~\"modulo\"); }\n+      bitxor { return some(~\"bitxor\"); }\n+      bitand { return some(~\"bitand\"); }\n+      bitor { return some(~\"bitor\"); }\n+      shl { return some(~\"shl\"); }\n+      shr { return some(~\"shr\"); }\n+      and | or | eq | lt | le | ne | ge | gt { return none; }\n     }\n }\n \n@@ -117,16 +117,16 @@ pure fn is_shift_binop(b: binop) -> bool {\n \n pure fn unop_to_str(op: unop) -> ~str {\n     alt op {\n-      box(mt) { if mt == m_mutbl { ret ~\"@mut \"; } ret ~\"@\"; }\n-      uniq(mt) { if mt == m_mutbl { ret ~\"~mut \"; } ret ~\"~\"; }\n-      deref { ret ~\"*\"; }\n-      not { ret ~\"!\"; }\n-      neg { ret ~\"-\"; }\n+      box(mt) { if mt == m_mutbl { ~\"@mut \" } else { ~\"@\" } }\n+      uniq(mt) { if mt == m_mutbl { ~\"~mut \" } else { ~\"~\" } }\n+      deref { ~\"*\" }\n+      not { ~\"!\" }\n+      neg { ~\"-\" }\n     }\n }\n \n pure fn is_path(e: @expr) -> bool {\n-    ret alt e.node { expr_path(_) { true } _ { false } };\n+    return alt e.node { expr_path(_) { true } _ { false } };\n }\n \n pure fn int_ty_to_str(t: int_ty) -> ~str {\n@@ -192,20 +192,20 @@ fn is_exported(i: ident, m: _mod) -> bool {\n             for vps.each |vp| {\n                 alt vp.node {\n                   ast::view_path_simple(id, _, _) {\n-                    if id == i { ret true; }\n+                    if id == i { return true; }\n                     alt parent_enum {\n                       some(parent_enum_id) {\n-                        if id == parent_enum_id { ret true; }\n+                        if id == parent_enum_id { return true; }\n                       }\n                       _ {}\n                     }\n                   }\n \n                   ast::view_path_list(path, ids, _) {\n                     if vec::len(path.idents) == 1u {\n-                        if i == path.idents[0] { ret true; }\n+                        if i == path.idents[0] { return true; }\n                         for ids.each |id| {\n-                            if id.node.name == i { ret true; }\n+                            if id.node.name == i { return true; }\n                         }\n                     } else {\n                         fail ~\"export of path-qualified list\";\n@@ -223,40 +223,40 @@ fn is_exported(i: ident, m: _mod) -> bool {\n     // If there are no declared exports then\n     // everything not imported is exported\n     // even if it's local (since it's explicit)\n-    ret !has_explicit_exports && local;\n+    return !has_explicit_exports && local;\n }\n \n pure fn is_call_expr(e: @expr) -> bool {\n     alt e.node { expr_call(_, _, _) { true } _ { false } }\n }\n \n-fn eq_ty(&&a: @ty, &&b: @ty) -> bool { ret box::ptr_eq(a, b); }\n+fn eq_ty(&&a: @ty, &&b: @ty) -> bool { return box::ptr_eq(a, b); }\n \n fn hash_ty(&&t: @ty) -> uint {\n     let res = (t.span.lo << 16u) + t.span.hi;\n-    ret res;\n+    return res;\n }\n \n fn def_eq(a: ast::def_id, b: ast::def_id) -> bool {\n-    ret a.crate == b.crate && a.node == b.node;\n+    return a.crate == b.crate && a.node == b.node;\n }\n \n fn hash_def(d: ast::def_id) -> uint {\n     let mut h = 5381u;\n     h = (h << 5u) + h ^ (d.crate as uint);\n     h = (h << 5u) + h ^ (d.node as uint);\n-    ret h;\n+    return h;\n }\n \n fn new_def_hash<V: copy>() -> std::map::hashmap<ast::def_id, V> {\n     let hasher: std::map::hashfn<ast::def_id> = hash_def;\n     let eqer: std::map::eqfn<ast::def_id> = def_eq;\n-    ret std::map::hashmap::<ast::def_id, V>(hasher, eqer);\n+    return std::map::hashmap::<ast::def_id, V>(hasher, eqer);\n }\n \n fn block_from_expr(e: @expr) -> blk {\n     let blk_ = default_block(~[], option::some::<@expr>(e), e.id);\n-    ret {node: blk_, span: e.span};\n+    return {node: blk_, span: e.span};\n }\n \n fn default_block(+stmts1: ~[@stmt], expr1: option<@expr>, id1: node_id) ->\n@@ -551,7 +551,7 @@ fn compute_id_range(visit_ids_fn: fn(fn@(node_id))) -> id_range {\n         *min = int::min(*min, id);\n         *max = int::max(*max, id + 1);\n     }\n-    ret {min:*min, max:*max};\n+    return {min:*min, max:*max};\n }\n \n fn compute_id_range_for_inlined_item(item: inlined_item) -> id_range {"}, {"sha": "bfaa7fa3bbd7ec3a5c0e69877bce89da5b11995a", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -52,25 +52,25 @@ export require_unique_names;\n fn mk_name_value_item_str(+name: ast::ident, +value: ~str) ->\n     @ast::meta_item {\n     let value_lit = dummy_spanned(ast::lit_str(@value));\n-    ret mk_name_value_item(name, value_lit);\n+    return mk_name_value_item(name, value_lit);\n }\n \n fn mk_name_value_item(+name: ast::ident, +value: ast::lit)\n         -> @ast::meta_item {\n-    ret @dummy_spanned(ast::meta_name_value(name, value));\n+    return @dummy_spanned(ast::meta_name_value(name, value));\n }\n \n fn mk_list_item(+name: ast::ident, +items: ~[@ast::meta_item]) ->\n    @ast::meta_item {\n-    ret @dummy_spanned(ast::meta_list(name, items));\n+    return @dummy_spanned(ast::meta_list(name, items));\n }\n \n fn mk_word_item(+name: ast::ident) -> @ast::meta_item {\n-    ret @dummy_spanned(ast::meta_word(name));\n+    return @dummy_spanned(ast::meta_word(name));\n }\n \n fn mk_attr(item: @ast::meta_item) -> ast::attribute {\n-    ret dummy_spanned({style: ast::attr_inner, value: *item,\n+    return dummy_spanned({style: ast::attr_inner, value: *item,\n                        is_sugared_doc: false});\n }\n \n@@ -81,7 +81,7 @@ fn mk_sugared_doc_attr(text: ~str, lo: uint, hi: uint) -> ast::attribute {\n         value: spanned(lo, hi, ast::meta_name_value(@~\"doc\", lit)),\n         is_sugared_doc: true\n     };\n-    ret spanned(lo, hi, attr);\n+    return spanned(lo, hi, attr);\n }\n \n /* Conversion */\n@@ -92,15 +92,15 @@ fn attr_meta(attr: ast::attribute) -> @ast::meta_item { @attr.node.value }\n fn attr_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n     let mut mitems = ~[];\n     for attrs.each |a| { vec::push(mitems, attr_meta(a)); }\n-    ret mitems;\n+    return mitems;\n }\n \n fn desugar_doc_attr(attr: ast::attribute) -> ast::attribute {\n     if attr.node.is_sugared_doc {\n         let comment = get_meta_item_value_str(@attr.node.value).get();\n         let meta = mk_name_value_item_str(@~\"doc\",\n                                      strip_doc_comment_decoration(*comment));\n-        ret mk_attr(meta);\n+        return mk_attr(meta);\n     } else {\n         attr\n     }\n@@ -178,7 +178,7 @@ fn find_attrs_by_name(attrs: ~[ast::attribute], +name: ~str) ->\n             } else { option::none }\n         }\n     );\n-    ret vec::filter_map(attrs, filter);\n+    return vec::filter_map(attrs, filter);\n }\n \n /// Searcha list of meta items and return only those with a specific name\n@@ -189,7 +189,7 @@ fn find_meta_items_by_name(metas: ~[@ast::meta_item], +name: ~str) ->\n             option::some(m)\n         } else { option::none }\n     };\n-    ret vec::filter_map(metas, filter);\n+    return vec::filter_map(metas, filter);\n }\n \n /**\n@@ -202,14 +202,14 @@ fn contains(haystack: ~[@ast::meta_item], needle: @ast::meta_item) -> bool {\n     for haystack.each |item| {\n         debug!{\"looking in %s\",\n                print::pprust::meta_item_to_str(*item)};\n-        if eq(item, needle) { debug!{\"found it!\"}; ret true; }\n+        if eq(item, needle) { debug!{\"found it!\"}; return true; }\n     }\n     #debug(\"found it not :(\");\n-    ret false;\n+    return false;\n }\n \n fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n-    ret alt a.node {\n+    return alt a.node {\n           ast::meta_word(na) {\n             alt b.node { ast::meta_word(nb) { na == nb } _ { false } }\n           }\n@@ -232,7 +232,7 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n \n fn contains_name(metas: ~[@ast::meta_item], +name: ~str) -> bool {\n     let matches = find_meta_items_by_name(metas, name);\n-    ret vec::len(matches) > 0u;\n+    return vec::len(matches) > 0u;\n }\n \n fn attrs_contains_name(attrs: ~[ast::attribute], +name: ~str) -> bool {\n@@ -243,9 +243,9 @@ fn first_attr_value_str_by_name(attrs: ~[ast::attribute], +name: ~str)\n     -> option<@~str> {\n     let mattrs = find_attrs_by_name(attrs, name);\n     if vec::len(mattrs) > 0u {\n-        ret get_meta_item_value_str(attr_meta(mattrs[0]));\n+        return get_meta_item_value_str(attr_meta(mattrs[0]));\n     }\n-    ret option::none;\n+    return option::none;\n }\n \n fn last_meta_item_by_name(\n@@ -297,19 +297,19 @@ fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n               ast::meta_list(name, _) { /* FIXME (#2543) */ copy name }\n             }\n         }\n-        ret key(ma) <= key(mb);\n+        return key(ma) <= key(mb);\n     }\n \n     // This is sort of stupid here, converting to a vec of mutables and back\n     let v: ~[mut @ast::meta_item] = vec::to_mut(items);\n     std::sort::quick_sort(lteq, v);\n-    ret vec::from_mut(v);\n+    return vec::from_mut(v);\n }\n \n fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ast::ident) ->\n    ~[@ast::meta_item] {\n \n-    ret vec::filter_map(items, |item| {\n+    return vec::filter_map(items, |item| {\n         if get_meta_item_name(item) != name {\n             option::some(/* FIXME (#2543) */ copy item)\n         } else {\n@@ -326,7 +326,7 @@ fn find_linkage_attrs(attrs: ~[ast::attribute]) -> ~[ast::attribute] {\n           _ { debug!{\"ignoring link attribute that has incorrect type\"}; }\n         }\n     }\n-    ret found;\n+    return found;\n }\n \n /**\n@@ -342,7 +342,7 @@ fn find_linkage_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n }\n \n fn foreign_abi(attrs: ~[ast::attribute]) -> either<~str, ast::foreign_abi> {\n-    ret alt attr::first_attr_value_str_by_name(attrs, ~\"abi\") {\n+    return alt attr::first_attr_value_str_by_name(attrs, ~\"abi\") {\n       option::none {\n         either::right(ast::foreign_abi_cdecl)\n       }"}, {"sha": "957424513965ba41aafcbdcf25929dfba578a9e1", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -58,22 +58,22 @@ fn new_filemap_w_substr(+filename: filename, +substr: file_substr,\n                         src: @~str,\n                         start_pos_ch: uint, start_pos_byte: uint)\n    -> filemap {\n-    ret @{name: filename, substr: substr, src: src,\n+    return @{name: filename, substr: substr, src: src,\n           start_pos: {ch: start_pos_ch, byte: start_pos_byte},\n           mut lines: ~[{ch: start_pos_ch, byte: start_pos_byte}]};\n }\n \n fn new_filemap(+filename: filename, src: @~str,\n                start_pos_ch: uint, start_pos_byte: uint)\n     -> filemap {\n-    ret new_filemap_w_substr(filename, fss_none, src,\n+    return new_filemap_w_substr(filename, fss_none, src,\n                              start_pos_ch, start_pos_byte);\n }\n \n fn mk_substr_filename(cm: codemap, sp: span) -> ~str\n {\n     let pos = lookup_char_pos(cm, sp.lo);\n-    ret fmt!{\"<%s:%u:%u>\", pos.file.name, pos.line, pos.col};\n+    return fmt!{\"<%s:%u:%u>\", pos.file.name, pos.line, pos.col};\n }\n \n fn next_line(file: filemap, chpos: uint, byte_pos: uint) {\n@@ -102,22 +102,22 @@ fn lookup_line(map: codemap, pos: uint, lookup: lookup_fn)\n         let m = (a + b) / 2u;\n         if lookup(f.lines[m]) > pos { b = m; } else { a = m; }\n     }\n-    ret {fm: f, line: a};\n+    return {fm: f, line: a};\n }\n \n fn lookup_pos(map: codemap, pos: uint, lookup: lookup_fn) -> loc {\n     let {fm: f, line: a} = lookup_line(map, pos, lookup);\n-    ret {file: f, line: a + 1u, col: pos - lookup(f.lines[a])};\n+    return {file: f, line: a + 1u, col: pos - lookup(f.lines[a])};\n }\n \n fn lookup_char_pos(map: codemap, pos: uint) -> loc {\n-    pure fn lookup(pos: file_pos) -> uint { ret pos.ch; }\n-    ret lookup_pos(map, pos, lookup);\n+    pure fn lookup(pos: file_pos) -> uint { return pos.ch; }\n+    return lookup_pos(map, pos, lookup);\n }\n \n fn lookup_byte_pos(map: codemap, pos: uint) -> loc {\n-    pure fn lookup(pos: file_pos) -> uint { ret pos.byte; }\n-    ret lookup_pos(map, pos, lookup);\n+    pure fn lookup(pos: file_pos) -> uint { return pos.byte; }\n+    return lookup_pos(map, pos, lookup);\n }\n \n fn lookup_char_pos_adj(map: codemap, pos: uint)\n@@ -144,7 +144,7 @@ fn lookup_char_pos_adj(map: codemap, pos: uint)\n }\n \n fn adjust_span(map: codemap, sp: span) -> span {\n-    pure fn lookup(pos: file_pos) -> uint { ret pos.ch; }\n+    pure fn lookup(pos: file_pos) -> uint { return pos.ch; }\n     let line = lookup_line(map, sp.lo, lookup);\n     alt (line.fm.substr) {\n       fss_none {sp}\n@@ -166,22 +166,22 @@ type span = {lo: uint, hi: uint, expn_info: expn_info};\n fn span_to_str_no_adj(sp: span, cm: codemap) -> ~str {\n     let lo = lookup_char_pos(cm, sp.lo);\n     let hi = lookup_char_pos(cm, sp.hi);\n-    ret fmt!{\"%s:%u:%u: %u:%u\", lo.file.name,\n+    return fmt!{\"%s:%u:%u: %u:%u\", lo.file.name,\n              lo.line, lo.col, hi.line, hi.col}\n }\n \n fn span_to_str(sp: span, cm: codemap) -> ~str {\n     let lo = lookup_char_pos_adj(cm, sp.lo);\n     let hi = lookup_char_pos_adj(cm, sp.hi);\n-    ret fmt!{\"%s:%u:%u: %u:%u\", lo.filename,\n+    return fmt!{\"%s:%u:%u: %u:%u\", lo.filename,\n              lo.line, lo.col, hi.line, hi.col}\n }\n \n type file_lines = {file: filemap, lines: ~[uint]};\n \n fn span_to_filename(sp: span, cm: codemap::codemap) -> filename {\n     let lo = lookup_char_pos(cm, sp.lo);\n-    ret /* FIXME (#2543) */ copy lo.file.name;\n+    return /* FIXME (#2543) */ copy lo.file.name;\n }\n \n fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n@@ -191,7 +191,7 @@ fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n     for uint::range(lo.line - 1u, hi.line as uint) |i| {\n         vec::push(lines, i);\n     };\n-    ret @{file: lo.file, lines: lines};\n+    return @{file: lo.file, lines: lines};\n }\n \n fn get_line(fm: filemap, line: int) -> ~str unsafe {\n@@ -205,7 +205,7 @@ fn get_line(fm: filemap, line: int) -> ~str unsafe {\n \n fn lookup_byte_offset(cm: codemap::codemap, chpos: uint)\n     -> {fm: filemap, pos: uint} {\n-    pure fn lookup(pos: file_pos) -> uint { ret pos.ch; }\n+    pure fn lookup(pos: file_pos) -> uint { return pos.ch; }\n     let {fm, line} = lookup_line(cm, chpos, lookup);\n     let line_offset = fm.lines[line].byte - fm.start_pos.byte;\n     let col = chpos - fm.lines[line].ch;\n@@ -217,17 +217,17 @@ fn span_to_snippet(sp: span, cm: codemap::codemap) -> ~str {\n     let begin = lookup_byte_offset(cm, sp.lo);\n     let end = lookup_byte_offset(cm, sp.hi);\n     assert begin.fm == end.fm;\n-    ret str::slice(*begin.fm.src, begin.pos, end.pos);\n+    return str::slice(*begin.fm.src, begin.pos, end.pos);\n }\n \n fn get_snippet(cm: codemap::codemap, fidx: uint, lo: uint, hi: uint) -> ~str\n {\n     let fm = cm.files[fidx];\n-    ret str::slice(*fm.src, lo, hi)\n+    return str::slice(*fm.src, lo, hi)\n }\n \n fn get_filemap(cm: codemap, filename: ~str) -> filemap {\n-    for cm.files.each |fm| { if fm.name == filename { ret fm; } }\n+    for cm.files.each |fm| { if fm.name == filename { return fm; } }\n     //XXjdm the following triggers a mismatched type bug\n     //      (or expected function, found _|_)\n     fail; // (\"asking for \" + filename + \" which we don't know about\");"}, {"sha": "98cf3953a29095d27fae2a7f6735febda33eada9", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -88,7 +88,7 @@ impl codemap_handler of handler for handler_t {\n     fn abort_if_errors() {\n         let s;\n         alt self.err_count {\n-          0u { ret; }\n+          0u { return; }\n           1u { s = ~\"aborting due to previous error\"; }\n           _  { s = fmt!{\"aborting due to %u previous errors\",\n                         self.err_count}; }"}, {"sha": "2947201003fdaead3d88c6a9a1bd91ab3061f94e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -107,7 +107,7 @@ fn syntax_expander_table() -> hashmap<~str, syntax_extension> {\n                             builtin(ext::source_util::expand_mod));\n     syntax_expanders.insert(~\"proto\",\n                             builtin_item_tt(ext::pipes::expand_proto));\n-    ret syntax_expanders;\n+    return syntax_expanders;\n }\n \n \n@@ -148,7 +148,7 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n         fn backtrace() -> expn_info { self.backtrace }\n         fn mod_push(i: ast::ident) { vec::push(self.mod_path, i); }\n         fn mod_pop() { vec::pop(self.mod_path); }\n-        fn mod_path() -> ~[ast::ident] { ret self.mod_path; }\n+        fn mod_path() -> ~[ast::ident] { return self.mod_path; }\n         fn bt_push(ei: codemap::expn_info_) {\n             alt ei {\n               expanded_from({call_site: cs, callie: callie}) {\n@@ -193,7 +193,7 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n             self.parse_sess.span_diagnostic.handler().bug(msg);\n         }\n         fn next_id() -> ast::node_id {\n-            ret parse::next_node_id(self.parse_sess);\n+            return parse::next_node_id(self.parse_sess);\n         }\n     }\n     let imp : ctxt_repr = {\n@@ -202,14 +202,14 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n         mut backtrace: none,\n         mut mod_path: ~[]\n     };\n-    ret imp as ext_ctxt\n+    return imp as ext_ctxt\n }\n \n fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, error: ~str) -> ~str {\n     alt expr.node {\n       ast::expr_lit(l) {\n         alt l.node {\n-          ast::lit_str(s) { ret *s; }\n+          ast::lit_str(s) { return *s; }\n           _ { cx.span_fatal(l.span, error); }\n         }\n       }\n@@ -222,15 +222,15 @@ fn expr_to_ident(cx: ext_ctxt, expr: @ast::expr, error: ~str) -> ast::ident {\n       ast::expr_path(p) {\n         if vec::len(p.types) > 0u || vec::len(p.idents) != 1u {\n             cx.span_fatal(expr.span, error);\n-        } else { ret p.idents[0]; }\n+        } else { return p.idents[0]; }\n       }\n       _ { cx.span_fatal(expr.span, error); }\n     }\n }\n \n fn get_mac_args_no_max(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                        min: uint, name: ~str) -> ~[@ast::expr] {\n-    ret get_mac_args(cx, sp, arg, min, none, name);\n+    return get_mac_args(cx, sp, arg, min, none, name);\n }\n \n fn get_mac_args(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n@@ -250,7 +250,7 @@ fn get_mac_args(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                 cx.span_fatal(sp, fmt!{\"#%s needs at least %u arguments.\",\n                                        name, min});\n               }\n-              _ { ret elts; /* we're good */}\n+              _ { return elts; /* we're good */}\n             }\n           }\n           _ {\n@@ -308,7 +308,7 @@ fn tt_args_to_original_flavor(cx: ext_ctxt, sp: span, arg: ~[ast::token_tree])\n           _ { fail ~\"badly-structured parse result\"; }\n         };\n \n-    ret some(@{id: parse::next_node_id(cx.parse_sess()),\n+    return some(@{id: parse::next_node_id(cx.parse_sess()),\n                callee_id: parse::next_node_id(cx.parse_sess()),\n                node: ast::expr_vec(args, ast::m_imm), span: sp});\n }"}, {"sha": "ab2d93faabeedbe48edfb695bb1e2fa288926e1f", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -3,7 +3,7 @@ import base::ext_ctxt;\n \n fn mk_expr(cx: ext_ctxt, sp: codemap::span, expr: ast::expr_) ->\n     @ast::expr {\n-    ret @{id: cx.next_id(), callee_id: cx.next_id(),\n+    return @{id: cx.next_id(), callee_id: cx.next_id(),\n           node: expr, span: sp};\n }\n \n@@ -13,15 +13,15 @@ fn mk_lit(cx: ext_ctxt, sp: span, lit: ast::lit_) -> @ast::expr {\n }\n fn mk_int(cx: ext_ctxt, sp: span, i: int) -> @ast::expr {\n     let lit = ast::lit_int(i as i64, ast::ty_i);\n-    ret mk_lit(cx, sp, lit);\n+    return mk_lit(cx, sp, lit);\n }\n fn mk_uint(cx: ext_ctxt, sp: span, u: uint) -> @ast::expr {\n     let lit = ast::lit_uint(u as u64, ast::ty_u);\n-    ret mk_lit(cx, sp, lit);\n+    return mk_lit(cx, sp, lit);\n }\n fn mk_u8(cx: ext_ctxt, sp: span, u: u8) -> @ast::expr {\n     let lit = ast::lit_uint(u as u64, ast::ty_u8);\n-    ret mk_lit(cx, sp, lit);\n+    return mk_lit(cx, sp, lit);\n }\n fn mk_binary(cx: ext_ctxt, sp: span, op: ast::binop,\n              lhs: @ast::expr, rhs: @ast::expr)\n@@ -48,7 +48,7 @@ fn mk_access_(cx: ext_ctxt, sp: span, p: @ast::expr, m: ast::ident)\n fn mk_access(cx: ext_ctxt, sp: span, p: ~[ast::ident], m: ast::ident)\n     -> @ast::expr {\n     let pathexpr = mk_path(cx, sp, p);\n-    ret mk_access_(cx, sp, pathexpr, m);\n+    return mk_access_(cx, sp, pathexpr, m);\n }\n fn mk_call_(cx: ext_ctxt, sp: span, fn_expr: @ast::expr,\n             args: ~[@ast::expr]) -> @ast::expr {\n@@ -57,7 +57,7 @@ fn mk_call_(cx: ext_ctxt, sp: span, fn_expr: @ast::expr,\n fn mk_call(cx: ext_ctxt, sp: span, fn_path: ~[ast::ident],\n              args: ~[@ast::expr]) -> @ast::expr {\n     let pathexpr = mk_path(cx, sp, fn_path);\n-    ret mk_call_(cx, sp, pathexpr, args);\n+    return mk_call_(cx, sp, pathexpr, args);\n }\n // e = expr, t = type\n fn mk_base_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr]) ->\n@@ -79,7 +79,7 @@ fn mk_fixed_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr]) ->\n }\n fn mk_base_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n     let lit = ast::lit_str(@s);\n-    ret mk_lit(cx, sp, lit);\n+    return mk_lit(cx, sp, lit);\n }\n fn mk_uniq_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_str(cx, sp, s), ast::vstore_uniq)"}, {"sha": "f5d22e6754c997f40105ece56ec5dc2be4e1c6eb", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -8,7 +8,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n         res += *expr_to_ident(cx, e, ~\"expected an ident\");\n     }\n \n-    ret @{id: cx.next_id(),\n+    return @{id: cx.next_id(),\n           callee_id: cx.next_id(),\n           node: ast::expr_path(@{span: sp, global: false, idents: ~[@res],\n                                  rp: none, types: ~[]}),"}, {"sha": "4aa55e88f16c52071f4ead615a0d4780a4ba3add", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -17,8 +17,8 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n \n     let var = expr_to_str(cx, args[0], ~\"#env requires a string\");\n     alt os::getenv(var) {\n-      option::none { ret mk_uniq_str(cx, sp, ~\"\"); }\n-      option::some(s) { ret mk_uniq_str(cx, sp, s); }\n+      option::none { return mk_uniq_str(cx, sp, ~\"\"); }\n+      option::some(s) { return mk_uniq_str(cx, sp, s); }\n     }\n }\n "}, {"sha": "24cc78e366eca1346557d78adc22cad0217b6f0d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -15,7 +15,7 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n                orig: fn@(expr_, span, ast_fold) -> (expr_, span))\n     -> (expr_, span)\n {\n-    ret alt e {\n+    return alt e {\n       // expr_mac should really be expr_ext or something; it's the\n       // entry-point for all syntax extensions.\n           expr_mac(mac) {\n@@ -159,7 +159,7 @@ fn expand_mod_items(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n         }\n     };\n \n-    ret {items: new_items with module_};\n+    return {items: new_items with module_};\n }\n \n \n@@ -185,9 +185,9 @@ fn expand_item(exts: hashmap<~str, syntax_extension>,\n         if is_mod { cx.mod_push(it.ident); }\n         let ret_val = orig(it, fld);\n         if is_mod { cx.mod_pop(); }\n-        ret ret_val;\n+        return ret_val;\n       }\n-      none { ret none; }\n+      none { return none; }\n     }\n }\n \n@@ -221,7 +221,7 @@ fn expand_item_mac(exts: hashmap<~str, syntax_extension>,\n               }\n             };\n             cx.bt_pop();\n-            ret maybe_it\n+            return maybe_it\n           }\n           _ { cx.span_fatal(it.span,\n                             fmt!{\"%s is not a legal here\", *extname}) }\n@@ -235,7 +235,7 @@ fn expand_item_mac(exts: hashmap<~str, syntax_extension>,\n \n fn new_span(cx: ext_ctxt, sp: span) -> span {\n     /* this discards information in the case of macro-defining macros */\n-    ret {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n+    return {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n }\n \n // FIXME (#2247): this is a terrible kludge to inject some macros into\n@@ -244,7 +244,7 @@ fn new_span(cx: ext_ctxt, sp: span) -> span {\n // compiled part of libcore at very least.\n \n fn core_macros() -> ~str {\n-    ret\n+    return\n ~\"{\n     #macro[[#error[f, ...], log(core::error, #fmt[f, ...])]];\n     #macro[[#warn[f, ...], log(core::warn, #fmt[f, ...])]];\n@@ -275,7 +275,7 @@ fn expand_crate(parse_sess: parse::parse_sess,\n     f.fold_expr(cm);\n \n     let res = @f.fold_crate(*c);\n-    ret res;\n+    return res;\n }\n // Local Variables:\n // mode: rust"}, {"sha": "10820664344f511909be26214abfce40ffcf7ee6", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -27,7 +27,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n         parse_fmt_err_(cx, fmtspan, s)\n     };\n     let pieces = parse_fmt_string(fmt, parse_fmt_err);\n-    ret pieces_to_expr(cx, sp, pieces, args);\n+    return pieces_to_expr(cx, sp, pieces, args);\n }\n \n // FIXME (#2249): A lot of these functions for producing expressions can\n@@ -38,12 +38,12 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n                   pieces: ~[piece], args: ~[@ast::expr])\n    -> @ast::expr {\n     fn make_path_vec(_cx: ext_ctxt, ident: ast::ident) -> ~[ast::ident] {\n-        ret ~[@~\"extfmt\", @~\"rt\", ident];\n+        return ~[@~\"extfmt\", @~\"rt\", ident];\n     }\n     fn make_rt_path_expr(cx: ext_ctxt, sp: span,\n                          ident: ast::ident) -> @ast::expr {\n         let path = make_path_vec(cx, ident);\n-        ret mk_path(cx, sp, path);\n+        return mk_path(cx, sp, path);\n     }\n     // Produces an AST expression that represents a RT::conv record,\n     // which tells the RT::conv* functions how to perform the conversion\n@@ -62,18 +62,18 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n                 tmp_expr = mk_binary(cx, sp, ast::bitor, tmp_expr,\n                                      make_rt_path_expr(cx, sp, @fstr));\n             }\n-            ret tmp_expr;\n+            return tmp_expr;\n         }\n         fn make_count(cx: ext_ctxt, sp: span, cnt: count) -> @ast::expr {\n             alt cnt {\n               count_implied {\n-                ret make_rt_path_expr(cx, sp, @~\"count_implied\");\n+                return make_rt_path_expr(cx, sp, @~\"count_implied\");\n               }\n               count_is(c) {\n                 let count_lit = mk_int(cx, sp, c);\n                 let count_is_path = make_path_vec(cx, @~\"count_is\");\n                 let count_is_args = ~[count_lit];\n-                ret mk_call(cx, sp, count_is_path, count_is_args);\n+                return mk_call(cx, sp, count_is_path, count_is_args);\n               }\n               _ { cx.span_unimpl(sp, ~\"unimplemented #fmt conversion\"); }\n             }\n@@ -91,12 +91,12 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n               ty_octal { rt_type = ~\"ty_octal\"; }\n               _ { rt_type = ~\"ty_default\"; }\n             }\n-            ret make_rt_path_expr(cx, sp, @rt_type);\n+            return make_rt_path_expr(cx, sp, @rt_type);\n         }\n         fn make_conv_rec(cx: ext_ctxt, sp: span, flags_expr: @ast::expr,\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n-            ret mk_rec_e(cx, sp,\n+            return mk_rec_e(cx, sp,\n                          ~[{ident: @~\"flags\", ex: flags_expr},\n                           {ident: @~\"width\", ex: width_expr},\n                           {ident: @~\"precision\", ex: precision_expr},\n@@ -106,7 +106,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         let rt_conv_width = make_count(cx, sp, cnv.width);\n         let rt_conv_precision = make_count(cx, sp, cnv.precision);\n         let rt_conv_ty = make_ty(cx, sp, cnv.ty);\n-        ret make_conv_rec(cx, sp, rt_conv_flags, rt_conv_width,\n+        return make_conv_rec(cx, sp, rt_conv_flags, rt_conv_width,\n                           rt_conv_precision, rt_conv_ty);\n     }\n     fn make_conv_call(cx: ext_ctxt, sp: span, conv_type: ~str, cnv: conv,\n@@ -115,7 +115,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         let path = make_path_vec(cx, @fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n         let args = ~[cnv_expr, arg];\n-        ret mk_call(cx, arg.span, path, args);\n+        return mk_call(cx, arg.span, path, args);\n     }\n \n     fn make_new_conv(cx: ext_ctxt, sp: span, cnv: conv, arg: @ast::expr) ->\n@@ -125,10 +125,10 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         fn is_signed_type(cnv: conv) -> bool {\n             alt cnv.ty {\n               ty_int(s) {\n-                alt s { signed { ret true; } unsigned { ret false; } }\n+                alt s { signed { return true; } unsigned { return false; } }\n               }\n-              ty_float { ret true; }\n-              _ { ret false; }\n+              ty_float { return true; }\n+              _ { return false; }\n             }\n         }\n         let unsupported = ~\"conversion not supported in #fmt string\";\n@@ -168,22 +168,28 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n           _ { cx.span_unimpl(sp, unsupported); }\n         }\n         alt cnv.ty {\n-          ty_str { ret make_conv_call(cx, arg.span, ~\"str\", cnv, arg); }\n+          ty_str { return make_conv_call(cx, arg.span, ~\"str\", cnv, arg); }\n           ty_int(sign) {\n             alt sign {\n-              signed { ret make_conv_call(cx, arg.span, ~\"int\", cnv, arg); }\n+              signed {\n+                return make_conv_call(cx, arg.span, ~\"int\", cnv, arg);\n+              }\n               unsigned {\n-                ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg);\n+                return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg);\n               }\n             }\n           }\n-          ty_bool { ret make_conv_call(cx, arg.span, ~\"bool\", cnv, arg); }\n-          ty_char { ret make_conv_call(cx, arg.span, ~\"char\", cnv, arg); }\n-          ty_hex(_) { ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n-          ty_bits { ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n-          ty_octal { ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n-          ty_float { ret make_conv_call(cx, arg.span, ~\"float\", cnv, arg); }\n-          ty_poly { ret make_conv_call(cx, arg.span, ~\"poly\", cnv, arg); }\n+          ty_bool { return make_conv_call(cx, arg.span, ~\"bool\", cnv, arg); }\n+          ty_char { return make_conv_call(cx, arg.span, ~\"char\", cnv, arg); }\n+          ty_hex(_) {\n+            return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg);\n+          }\n+          ty_bits { return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n+          ty_octal { return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n+          ty_float {\n+            return make_conv_call(cx, arg.span, ~\"float\", cnv, arg);\n+          }\n+          ty_poly { return make_conv_call(cx, arg.span, ~\"poly\", cnv, arg); }\n         }\n     }\n     fn log_conv(c: conv) {\n@@ -275,7 +281,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     }\n \n     let arg_vec = mk_fixed_vec_e(cx, fmt_sp, piece_exprs);\n-    ret mk_call(cx, fmt_sp, ~[@~\"str\", @~\"concat\"], ~[arg_vec]);\n+    return mk_call(cx, fmt_sp, ~[@~\"str\", @~\"concat\"], ~[arg_vec]);\n }\n //\n // Local Variables:"}, {"sha": "06faff9ee1b55cdd3c1fda617a96760decabf1de", "filename": "src/libsyntax/ext/ident_to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fident_to_str.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -6,6 +6,6 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> @ast::expr {\n     let args = get_mac_args(cx,sp,arg,1u,option::some(1u),~\"ident_to_str\");\n \n-    ret mk_uniq_str(cx, sp, *expr_to_ident(cx, args[0u],\n+    return mk_uniq_str(cx, sp, *expr_to_ident(cx, args[0u],\n                                            ~\"expected an ident\"));\n }"}, {"sha": "f84e496be9c13e7d41bcb031ffcebd4e1b9ef7f3", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -11,6 +11,6 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n     );\n \n     //trivial expression\n-    ret @{id: cx.next_id(), callee_id: cx.next_id(),\n+    return @{id: cx.next_id(), callee_id: cx.next_id(),\n           node: ast::expr_rec(~[], option::none), span: sp};\n }"}, {"sha": "ea8c8c04b0ebd9b4eac8c79ed101b22efca78200", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -19,7 +19,7 @@ impl proto_parser of proto_parser for parser {\n                                      {sep: none, trailing_sep_allowed: false},\n                                      |self| self.parse_state(proto));\n \n-        ret proto;\n+        return proto;\n     }\n \n     fn parse_state(proto: protocol) {"}, {"sha": "1805fd9fa35950568d06f5a9abe1593cab364bfa", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -149,7 +149,7 @@ class protocol_ {\n     fn has_ty_params() -> bool {\n         for self.states.each |s| {\n             if s.ty_params.len() > 0 {\n-                ret true;\n+                return true;\n             }\n         }\n         false"}, {"sha": "1c3e0aa518180ea239740d3e2434891afd34152d", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -112,7 +112,7 @@ fn gather_anti_quotes<N: qq_helper>(lo: uint, node: N) -> aq_ctxt\n     do cx.gather.swap |v| {\n         vec::to_mut(std::sort::merge_sort(|a,b| a.lo < b.lo, v))\n     };\n-    ret cx;\n+    return cx;\n }\n \n fn visit_aq<T:qq_helper>(node: T, constr: ~str, &&cx: aq_ctxt, v: vt<aq_ctxt>)\n@@ -155,7 +155,7 @@ fn expand_ast(ecx: ext_ctxt, _sp: span,\n     }\n     let body = get_mac_body(ecx,_sp,body);\n \n-    ret alt what {\n+    return alt what {\n       ~\"crate\" {finish(ecx, body, parse_crate)}\n       ~\"expr\" {finish(ecx, body, parse_expr)}\n       ~\"ty\" {finish(ecx, body, parse_ty)}\n@@ -268,7 +268,7 @@ fn finish<T: qq_helper>\n                                  ~[@~\"syntax\", @~\"ext\", @~\"qquote\",\n                                   @node.get_fold_fn()])]);\n     }\n-    ret rcall;\n+    return rcall;\n }\n \n fn replace<T>(node: T, repls: ~[fragment], ff: fn (ast_fold, T) -> T)\n@@ -280,7 +280,7 @@ fn replace<T>(node: T, repls: ~[fragment], ff: fn (ast_fold, T) -> T)\n                   fold_ty: |a,b,c|replace_ty(repls, a, b, c,\n                                               aft.fold_ty)\n                   with *aft};\n-    ret ff(make_fold(f_pre), node);\n+    return ff(make_fold(f_pre), node);\n }\n fn fold_crate(f: ast_fold, &&n: @ast::crate) -> @ast::crate {\n     @f.fold_crate(*n)"}, {"sha": "b835300d5c715235822f70cdf3aecdd725c3143c", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 43, "deletions": 41, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -13,9 +13,9 @@ export add_new_extension;\n \n fn path_to_ident(pth: @path) -> option<ident> {\n     if vec::len(pth.idents) == 1u && vec::len(pth.types) == 0u {\n-        ret some(pth.idents[0u]);\n+        return some(pth.idents[0u]);\n     }\n-    ret none;\n+    return none;\n }\n \n //a vec of binders might be a little big.\n@@ -94,7 +94,7 @@ fn elts_to_ell(cx: ext_ctxt, elts: ~[@expr]) ->\n         }\n         idx += 1u;\n     }\n-    ret alt res {\n+    return alt res {\n           some(val) { val }\n           none { {pre: elts, rep: none, post: ~[]} }\n         }\n@@ -104,31 +104,31 @@ fn option_flatten_map<T: copy, U: copy>(f: fn@(T) -> option<U>, v: ~[T]) ->\n    option<~[U]> {\n     let mut res = ~[];\n     for v.each |elem| {\n-        alt f(elem) { none { ret none; } some(fv) { vec::push(res, fv); } }\n+        alt f(elem) { none { return none; } some(fv) { vec::push(res, fv); } }\n     }\n-    ret some(res);\n+    return some(res);\n }\n \n fn a_d_map(ad: arb_depth<matchable>, f: selector) -> match_result {\n     alt ad {\n-      leaf(x) { ret f(x); }\n+      leaf(x) { return f(x); }\n       seq(ads, span) {\n         alt option_flatten_map(|x| a_d_map(x, f), *ads) {\n-          none { ret none; }\n-          some(ts) { ret some(seq(@ts, span)); }\n+          none { return none; }\n+          some(ts) { return some(seq(@ts, span)); }\n         }\n       }\n     }\n }\n \n fn compose_sels(s1: selector, s2: selector) -> selector {\n     fn scomp(s1: selector, s2: selector, m: matchable) -> match_result {\n-        ret alt s1(m) {\n+        return alt s1(m) {\n               none { none }\n               some(matches) { a_d_map(matches, s2) }\n             }\n     }\n-    ret { |x| scomp(s1, s2, x) };\n+    return { |x| scomp(s1, s2, x) };\n }\n \n \n@@ -150,9 +150,11 @@ fn pattern_to_selectors(cx: ext_ctxt, e: @expr) -> binders {\n          literal_ast_matchers: dvec()};\n     //this oughta return binders instead, but macro args are a sequence of\n     //expressions, rather than a single expression\n-    fn trivial_selector(m: matchable) -> match_result { ret some(leaf(m)); }\n+    fn trivial_selector(m: matchable) -> match_result {\n+        return some(leaf(m));\n+    }\n     p_t_s_rec(cx, match_expr(e), trivial_selector, res);\n-    ret res;\n+    return res;\n }\n \n \n@@ -165,7 +167,7 @@ fn use_selectors_to_bind(b: binders, e: @expr) -> option<bindings> {\n     let res = box_str_hash::<arb_depth<matchable>>();\n     //need to do this first, to check vec lengths.\n     for b.literal_ast_matchers.each |sel| {\n-        alt sel(match_expr(e)) { none { ret none; } _ { } }\n+        alt sel(match_expr(e)) { none { return none; } _ { } }\n     }\n     let mut never_mind: bool = false;\n     for b.real_binders.each |key, val| {\n@@ -175,18 +177,18 @@ fn use_selectors_to_bind(b: binders, e: @expr) -> option<bindings> {\n         }\n     };\n     //HACK: `ret` doesn't work in `for each`\n-    if never_mind { ret none; }\n-    ret some(res);\n+    if never_mind { return none; }\n+    return some(res);\n }\n \n /* use the bindings on the body to generate the expanded code */\n \n fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n     let idx_path: @mut ~[uint] = @mut ~[];\n-    fn new_id(_old: node_id, cx: ext_ctxt) -> node_id { ret cx.next_id(); }\n+    fn new_id(_old: node_id, cx: ext_ctxt) -> node_id { return cx.next_id(); }\n     fn new_span(cx: ext_ctxt, sp: span) -> span {\n         /* this discards information in the case of macro-defining macros */\n-        ret {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n+        return {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n     }\n     let afp = default_ast_fold();\n     let f_pre =\n@@ -209,7 +211,7 @@ fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n           with *afp};\n     let f = make_fold(f_pre);\n     let result = f.fold_expr(body);\n-    ret result;\n+    return result;\n }\n \n \n@@ -219,25 +221,25 @@ fn follow(m: arb_depth<matchable>, idx_path: @mut ~[uint]) ->\n     let mut res: arb_depth<matchable> = m;\n     for vec::each(*idx_path) |idx| {\n         res = alt res {\n-          leaf(_) { ret res;/* end of the line */ }\n+          leaf(_) { return res;/* end of the line */ }\n           seq(new_ms, _) { new_ms[idx] }\n         }\n     }\n-    ret res;\n+    return res;\n }\n \n fn follow_for_trans(cx: ext_ctxt, mmaybe: option<arb_depth<matchable>>,\n                     idx_path: @mut ~[uint]) -> option<matchable> {\n     alt mmaybe {\n-      none { ret none }\n+      none { return none }\n       some(m) {\n-        ret alt follow(m, idx_path) {\n+        return alt follow(m, idx_path) {\n               seq(_, sp) {\n                 cx.span_fatal(sp,\n                               ~\"syntax matched under ... but not \" +\n                                   ~\"used that way.\")\n               }\n-              leaf(m) { ret some(m) }\n+              leaf(m) { return some(m) }\n             }\n       }\n     }\n@@ -250,7 +252,7 @@ fn free_vars(b: bindings, e: @expr, it: fn(ident)) {\n     fn mark_ident(&&i: ident, _fld: ast_fold, b: bindings,\n                   idents: hashmap<ident, ()>) -> ident {\n         if b.contains_key(i) { idents.insert(i, ()); }\n-        ret i;\n+        return i;\n     }\n     // using fold is a hack: we want visit, but it doesn't hit idents ) :\n     // solve this with macros\n@@ -319,7 +321,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n           }\n         }\n         res = vec::append(res, vec::map(post, recur));\n-        ret res;\n+        return res;\n       }\n     }\n }\n@@ -329,7 +331,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n // substitute, in a position that's required to be an ident\n fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                     &&i: ident, _fld: ast_fold) -> ident {\n-    ret alt follow_for_trans(cx, b.find(i), idx_path) {\n+    return alt follow_for_trans(cx, b.find(i), idx_path) {\n           some(match_ident(a_id)) { a_id.node }\n           some(m) { match_error(cx, m, ~\"an identifier\") }\n           none { i }\n@@ -340,7 +342,7 @@ fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                    p: path, _fld: ast_fold) -> path {\n     // Don't substitute into qualified names.\n-    if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { ret p; }\n+    if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { return p; }\n     alt follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n       some(match_ident(id)) {\n         {span: id.span, global: false, idents: ~[id.node],\n@@ -358,7 +360,7 @@ fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                    orig: fn@(ast::expr_, span, ast_fold)->(ast::expr_, span))\n     -> (ast::expr_, span)\n {\n-    ret alt e {\n+    return alt e {\n           expr_path(p) {\n             // Don't substitute into qualified names.\n             if vec::len(p.types) > 0u || vec::len(p.idents) != 1u {\n@@ -387,7 +389,7 @@ fn transcribe_type(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                    orig: fn@(ast::ty_, span, ast_fold) -> (ast::ty_, span))\n     -> (ast::ty_, span)\n {\n-    ret alt t {\n+    return alt t {\n           ast::ty_path(pth, _) {\n             alt path_to_ident(pth) {\n               some(id) {\n@@ -413,7 +415,7 @@ fn transcribe_block(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                     orig: fn@(blk_, span, ast_fold) -> (blk_, span))\n     -> (blk_, span)\n {\n-    ret alt block_to_ident(blk) {\n+    return alt block_to_ident(blk) {\n           some(id) {\n             alt follow_for_trans(cx, b.find(id), idx_path) {\n               some(match_block(new_blk)) { (new_blk.node, new_blk.span) }\n@@ -474,7 +476,7 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n           _ {\n             fn select(cx: ext_ctxt, m: matchable, pat: @expr) ->\n                match_result {\n-                ret alt m {\n+                return alt m {\n                       match_expr(e) {\n                         if e == pat { some(leaf(match_exact)) } else { none }\n                       }\n@@ -494,7 +496,7 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n \n /* make a match more precise */\n fn specialize_match(m: matchable) -> matchable {\n-    ret alt m {\n+    return alt m {\n           match_expr(e) {\n             alt e.node {\n               expr_path(pth) {\n@@ -515,7 +517,7 @@ fn p_t_s_r_path(cx: ext_ctxt, p: @path, s: selector, b: binders) {\n     alt path_to_ident(p) {\n       some(p_id) {\n         fn select(cx: ext_ctxt, m: matchable) -> match_result {\n-            ret alt m {\n+            return alt m {\n                   match_expr(e) { some(leaf(specialize_match(m))) }\n                   _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n                 }\n@@ -530,8 +532,8 @@ fn p_t_s_r_path(cx: ext_ctxt, p: @path, s: selector, b: binders) {\n }\n \n fn block_to_ident(blk: blk_) -> option<ident> {\n-    if vec::len(blk.stmts) != 0u { ret none; }\n-    ret alt blk.expr {\n+    if vec::len(blk.stmts) != 0u { return none; }\n+    return alt blk.expr {\n           some(expr) {\n             alt expr.node { expr_path(pth) { path_to_ident(pth) } _ { none } }\n           }\n@@ -542,7 +544,7 @@ fn block_to_ident(blk: blk_) -> option<ident> {\n fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, _s: selector, _b: binders) {\n     fn select_pt_1(cx: ext_ctxt, m: matchable,\n                    fn_m: fn(ast::mac) -> match_result) -> match_result {\n-        ret alt m {\n+        return alt m {\n               match_expr(e) {\n                 alt e.node { expr_mac(mac) { fn_m(mac) } _ { none } }\n               }\n@@ -565,7 +567,7 @@ fn p_t_s_r_ellipses(cx: ext_ctxt, repeat_me: @expr, offset: uint, s: selector,\n                     b: binders) {\n     fn select(cx: ext_ctxt, repeat_me: @expr, offset: uint, m: matchable) ->\n        match_result {\n-        ret alt m {\n+        return alt m {\n               match_expr(e) {\n                 alt e.node {\n                   expr_vec(arg_elts, _) {\n@@ -595,7 +597,7 @@ fn p_t_s_r_length(cx: ext_ctxt, len: uint, at_least: bool, s: selector,\n                   b: binders) {\n     fn len_select(_cx: ext_ctxt, m: matchable, at_least: bool, len: uint) ->\n        match_result {\n-        ret alt m {\n+        return alt m {\n               match_expr(e) {\n                 alt e.node {\n                   expr_vec(arg_elts, _) {\n@@ -619,7 +621,7 @@ fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: ~[@expr], _repeat_after: bool,\n     let mut idx: uint = 0u;\n     while idx < vec::len(elts) {\n         fn select(cx: ext_ctxt, m: matchable, idx: uint) -> match_result {\n-            ret alt m {\n+            return alt m {\n                   match_expr(e) {\n                     alt e.node {\n                       expr_vec(arg_elts, _) {\n@@ -709,7 +711,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n \n     let ext = |a,b,c,d, move clauses| generic_extension(a,b,c,d,clauses);\n \n-    ret {ident:\n+    return {ident:\n              alt macro_name {\n                some(id) { id }\n                none {\n@@ -728,7 +730,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n         };\n         for clauses.each |c| {\n             alt use_selectors_to_bind(c.params, arg) {\n-              some(bindings) { ret transcribe(cx, bindings, c.body); }\n+              some(bindings) { return transcribe(cx, bindings, c.body); }\n               none { again; }\n             }\n         }"}, {"sha": "00c1e4ff47aed2ca749ec3eef07efcfbe9d8c8d2", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -18,15 +18,15 @@ fn expand_line(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                _body: ast::mac_body) -> @ast::expr {\n     get_mac_args(cx, sp, arg, 0u, option::some(0u), ~\"line\");\n     let loc = codemap::lookup_char_pos(cx.codemap(), sp.lo);\n-    ret mk_uint(cx, sp, loc.line);\n+    return mk_uint(cx, sp, loc.line);\n }\n \n /* col!{}: expands to the current column number */\n fn expand_col(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n               _body: ast::mac_body) -> @ast::expr {\n     get_mac_args(cx, sp, arg, 0u, option::some(0u), ~\"col\");\n     let loc = codemap::lookup_char_pos(cx.codemap(), sp.lo);\n-    ret mk_uint(cx, sp, loc.col);\n+    return mk_uint(cx, sp, loc.col);\n }\n \n /* file!{}: expands to the current filename */\n@@ -37,19 +37,19 @@ fn expand_file(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n     get_mac_args(cx, sp, arg, 0u, option::some(0u), ~\"file\");\n     let { file: @{ name: filename, _ }, _ } =\n         codemap::lookup_char_pos(cx.codemap(), sp.lo);\n-    ret mk_uniq_str(cx, sp, filename);\n+    return mk_uniq_str(cx, sp, filename);\n }\n \n fn expand_stringify(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                     _body: ast::mac_body) -> @ast::expr {\n     let args = get_mac_args(cx, sp, arg, 1u, option::some(1u), ~\"stringify\");\n-    ret mk_uniq_str(cx, sp, pprust::expr_to_str(args[0]));\n+    return mk_uniq_str(cx, sp, pprust::expr_to_str(args[0]));\n }\n \n fn expand_mod(cx: ext_ctxt, sp: span, arg: ast::mac_arg, _body: ast::mac_body)\n     -> @ast::expr {\n     get_mac_args(cx, sp, arg, 0u, option::some(0u), ~\"file\");\n-    ret mk_uniq_str(cx, sp,\n+    return mk_uniq_str(cx, sp,\n                     str::connect(cx.mod_path().map(|x|*x), ~\"::\"));\n }\n \n@@ -60,7 +60,7 @@ fn expand_include(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n     let p = parse::new_parser_from_file(cx.parse_sess(), cx.cfg(),\n                                         res_rel_file(cx, sp, file),\n                                         parse::parser::SOURCE_FILE);\n-    ret p.parse_expr();\n+    return p.parse_expr();\n }\n \n fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n@@ -77,7 +77,7 @@ fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n       }\n     }\n \n-    ret mk_uniq_str(cx, sp, result::unwrap(res));\n+    return mk_uniq_str(cx, sp, result::unwrap(res));\n }\n \n fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n@@ -91,7 +91,7 @@ fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n         let u8_exprs = vec::map(src, |char: u8| {\n             mk_u8(cx, sp, char)\n         });\n-        ret mk_uniq_vec_e(cx, sp, u8_exprs);\n+        return mk_uniq_vec_e(cx, sp, u8_exprs);\n       }\n       result::err(e) {\n         cx.parse_sess().span_diagnostic.handler().fatal(e)\n@@ -104,9 +104,9 @@ fn res_rel_file(cx: ext_ctxt, sp: codemap::span, +arg: path) -> path {\n     if !path::path_is_absolute(arg) {\n         let cu = codemap::span_to_filename(sp, cx.codemap());\n         let dir = path::dirname(cu);\n-        ret path::connect(dir, arg);\n+        return path::connect(dir, arg);\n     } else {\n-        ret arg;\n+        return arg;\n     }\n }\n "}, {"sha": "6930c09e7ceba874c1e9abd6df0bd94dda9549e3", "filename": "src/libsyntax/ext/tt/earley_parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -129,7 +129,7 @@ fn nameize(p_s: parse_sess, ms: ~[matcher], res: ~[@named_match])\n     }\n     let ret_val = box_str_hash::<@named_match>();\n     for ms.each() |m| { n_rec(p_s, m, res, ret_val) }\n-    ret ret_val;\n+    return ret_val;\n }\n \n enum parse_result {\n@@ -260,13 +260,13 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n         /* error messages here could be improved with links to orig. rules */\n         if tok == EOF {\n             if eof_eis.len() == 1u {\n-                ret success(\n+                return success(\n                     nameize(sess, ms,\n                             vec::map(eof_eis[0u].matches, |dv| dv.pop())));\n             } else if eof_eis.len() > 1u {\n-                ret failure(sp, ~\"Ambiguity: multiple successful parses\");\n+                return failure(sp, ~\"Ambiguity: multiple successful parses\");\n             } else {\n-                ret failure(sp, ~\"Unexpected end of macro invocation\");\n+                return failure(sp, ~\"Unexpected end of macro invocation\");\n             }\n         } else {\n             if (bb_eis.len() > 0u && next_eis.len() > 0u)\n@@ -277,12 +277,12 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                         fmt!{\"%s ('%s')\", *name, *bind}\n                       }\n                       _ { fail; } } }), ~\" or \");\n-                ret failure(sp, fmt!{\n+                return failure(sp, fmt!{\n                     \"Local ambiguity: multiple parsing options: \\\n                      built-in NTs %s or %u other options.\",\n                     nts, next_eis.len()});\n             } else if (bb_eis.len() == 0u && next_eis.len() == 0u) {\n-                ret failure(sp, ~\"No rules expected the token \"\n+                return failure(sp, ~\"No rules expected the token \"\n                             + to_str(*rdr.interner(), tok));\n             } else if (next_eis.len() > 0u) {\n                 /* Now process the next token */"}, {"sha": "3c680640a3198e6dc4176a0452338d16049651a0", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -70,7 +70,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                                                ~[rhs]);\n                     let p = parser(cx.parse_sess(), cx.cfg(),\n                                    trncbr as reader, SOURCE_FILE);\n-                    ret mr_expr(p.parse_expr());\n+                    return mr_expr(p.parse_expr());\n                   }\n                   failure(sp, msg) {\n                     if sp.lo >= best_fail_spot.lo {\n@@ -87,5 +87,8 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n \n     let exp = |cx, sp, arg| generic_extension(cx, sp, arg, lhses, rhses);\n \n-    ret mr_def({ident: name, ext: expr_tt({expander: exp, span: some(sp)})});\n+    return mr_def({\n+        ident: name,\n+        ext: expr_tt({expander: exp, span: some(sp)})\n+    });\n }\n\\ No newline at end of file"}, {"sha": "9fda95c464e8ed08a0c93b11198f325fd2749301", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -56,7 +56,7 @@ fn new_tt_reader(sp_diag: span_handler, itr: @interner<@~str>,\n               mut cur_span: ast_util::mk_sp(0u,0u)\n              };\n     tt_next_token(r); /* get cur_tok and cur_span set up */\n-    ret r;\n+    return r;\n }\n \n pure fn dup_tt_frame(&&f: tt_frame) -> tt_frame {\n@@ -145,7 +145,7 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n             alt r.cur.up {\n               tt_frame_up(none) {\n                 r.cur_tok = EOF;\n-                ret ret_val;\n+                return ret_val;\n               }\n               tt_frame_up(some(tt_f)) {\n                 if r.cur.dotdotdoted {\n@@ -163,7 +163,7 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n             alt r.cur.sep {\n               some(tk) {\n                 r.cur_tok = tk; /* repeat same span, I guess */\n-                ret ret_val;\n+                return ret_val;\n               }\n               none {}\n             }\n@@ -180,7 +180,7 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n           tt_tok(sp, tok) {\n             r.cur_span = sp; r.cur_tok = tok;\n             r.cur.idx += 1u;\n-            ret ret_val;\n+            return ret_val;\n           }\n           tt_seq(sp, tts, sep, zerok) {\n             alt lockstep_iter_size(tt_seq(sp, tts, sep, zerok), r) {\n@@ -204,7 +204,7 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n                     }\n \n                     r.cur.idx += 1u;\n-                    ret tt_next_token(r);\n+                    return tt_next_token(r);\n                 } else {\n                     vec::push(r.repeat_len, len);\n                     vec::push(r.repeat_idx, 0u);\n@@ -223,12 +223,12 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n               matched_nonterminal(nt_ident(sn,b)) {\n                 r.cur_span = sp; r.cur_tok = IDENT(sn,b);\n                 r.cur.idx += 1u;\n-                ret ret_val;\n+                return ret_val;\n               }\n               matched_nonterminal(other_whole_nt) {\n                 r.cur_span = sp; r.cur_tok = INTERPOLATED(other_whole_nt);\n                 r.cur.idx += 1u;\n-                ret ret_val;\n+                return ret_val;\n               }\n               matched_seq(*) {\n                 r.sp_diag.span_fatal("}, {"sha": "ee0512e1b07a8c2fcfee673f7169e45b552951c3", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 54, "deletions": 52, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -79,7 +79,7 @@ type ast_fold_precursor = @{\n \n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n-    ret @{node:\n+    return @{node:\n               alt mi.node {\n                 meta_word(id) { meta_word(fld.fold_ident(id)) }\n                 meta_list(id, mis) {\n@@ -97,21 +97,21 @@ fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n //used in noop_fold_item and noop_fold_crate\n fn fold_attribute_(at: attribute, fld: ast_fold) ->\n    attribute {\n-    ret {node: {style: at.node.style,\n+    return {node: {style: at.node.style,\n                 value: *fold_meta_item_(@at.node.value, fld),\n                 is_sugared_doc: at.node.is_sugared_doc },\n          span: fld.new_span(at.span)};\n }\n //used in noop_fold_foreign_item and noop_fold_fn_decl\n fn fold_arg_(a: arg, fld: ast_fold) -> arg {\n-    ret {mode: a.mode,\n+    return {mode: a.mode,\n          ty: fld.fold_ty(a.ty),\n          ident: fld.fold_ident(a.ident),\n          id: fld.new_id(a.id)};\n }\n //used in noop_fold_expr, and possibly elsewhere in the future\n fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n-    ret {node:\n+    return {node:\n              alt m.node {\n                mac_invoc(pth, arg, body) {\n                  mac_invoc(fld.fold_path(pth),\n@@ -126,7 +126,7 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n }\n \n fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n-    ret {inputs: vec::map(decl.inputs, |x| fold_arg_(x, fld) ),\n+    return {inputs: vec::map(decl.inputs, |x| fold_arg_(x, fld) ),\n          output: fld.fold_ty(decl.output),\n          purity: decl.purity,\n          cf: decl.cf}\n@@ -153,15 +153,17 @@ fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n     let fold_meta_item = |x| fold_meta_item_(x, fld);\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n-    ret {directives: vec::map(c.directives, |x| fld.fold_crate_directive(x)),\n-         module: fld.fold_mod(c.module),\n-         attrs: vec::map(c.attrs, fold_attribute),\n-         config: vec::map(c.config, fold_meta_item)};\n+    return {\n+        directives: vec::map(c.directives, |x| fld.fold_crate_directive(x)),\n+        module: fld.fold_mod(c.module),\n+        attrs: vec::map(c.attrs, fold_attribute),\n+        config: vec::map(c.config, fold_meta_item)\n+    };\n }\n \n fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n    crate_directive_ {\n-    ret alt cd {\n+    return alt cd {\n           cdir_src_mod(id, attrs) {\n             cdir_src_mod(fld.fold_ident(id), /* FIXME (#2543) */ copy attrs)\n           }\n@@ -176,7 +178,7 @@ fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n }\n \n fn noop_fold_view_item(vi: view_item_, _fld: ast_fold) -> view_item_ {\n-    ret /* FIXME (#2543) */ copy vi;\n+    return /* FIXME (#2543) */ copy vi;\n }\n \n \n@@ -185,7 +187,7 @@ fn noop_fold_foreign_item(&&ni: @foreign_item, fld: ast_fold)\n     let fold_arg = |x| fold_arg_(x, fld);\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n-    ret @{ident: fld.fold_ident(ni.ident),\n+    return @{ident: fld.fold_ident(ni.ident),\n           attrs: vec::map(ni.attrs, fold_attribute),\n           node:\n               alt ni.node {\n@@ -204,7 +206,7 @@ fn noop_fold_foreign_item(&&ni: @foreign_item, fld: ast_fold)\n fn noop_fold_item(&&i: @item, fld: ast_fold) -> option<@item> {\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n-    ret some(@{ident: fld.fold_ident(i.ident),\n+    return some(@{ident: fld.fold_ident(i.ident),\n                attrs: vec::map(i.attrs, fold_attribute),\n                id: fld.new_id(i.id),\n                node: fld.fold_item_underscore(i.node),\n@@ -225,7 +227,7 @@ fn noop_fold_class_item(&&ci: @class_member, fld: ast_fold)\n }\n \n fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n-    ret alt i {\n+    return alt i {\n           item_const(t, e) { item_const(fld.fold_ty(t), fld.fold_expr(e)) }\n           item_fn(decl, typms, body) {\n               item_fn(fold_fn_decl(decl, fld),\n@@ -294,7 +296,7 @@ fn fold_trait_ref(&&p: @trait_ref, fld: ast_fold) -> @trait_ref {\n }\n \n fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n-    ret @{ident: fld.fold_ident(m.ident),\n+    return @{ident: fld.fold_ident(m.ident),\n           attrs: /* FIXME (#2543) */ copy m.attrs,\n           tps: fold_ty_params(m.tps, fld),\n           self_ty: m.self_ty,\n@@ -308,29 +310,29 @@ fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n \n \n fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n-    ret {view_items: vec::map(b.view_items, |x| fld.fold_view_item(x)),\n+    return {view_items: vec::map(b.view_items, |x| fld.fold_view_item(x)),\n          stmts: vec::map(b.stmts, |x| fld.fold_stmt(x)),\n          expr: option::map(b.expr, |x| fld.fold_expr(x)),\n          id: fld.new_id(b.id),\n          rules: b.rules};\n }\n \n fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n-    ret alt s {\n+    return alt s {\n       stmt_decl(d, nid) { stmt_decl(fld.fold_decl(d), fld.new_id(nid)) }\n       stmt_expr(e, nid) { stmt_expr(fld.fold_expr(e), fld.new_id(nid)) }\n       stmt_semi(e, nid) { stmt_semi(fld.fold_expr(e), fld.new_id(nid)) }\n     };\n }\n \n fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n-    ret {pats: vec::map(a.pats, |x| fld.fold_pat(x)),\n+    return {pats: vec::map(a.pats, |x| fld.fold_pat(x)),\n          guard: option::map(a.guard, |x| fld.fold_expr(x)),\n          body: fld.fold_block(a.body)};\n }\n \n fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n-    ret alt p {\n+    return alt p {\n           pat_wild { pat_wild }\n           pat_ident(binding_mode, pth, sub) {\n             pat_ident(binding_mode,\n@@ -375,14 +377,14 @@ fn noop_fold_decl(d: decl_, fld: ast_fold) -> decl_ {\n fn wrap<T>(f: fn@(T, ast_fold) -> T)\n     -> fn@(T, span, ast_fold) -> (T, span)\n {\n-    ret fn@(x: T, s: span, fld: ast_fold) -> (T, span) {\n+    return fn@(x: T, s: span, fld: ast_fold) -> (T, span) {\n         (f(x, fld), s)\n     }\n }\n \n fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n     fn fold_field_(field: field, fld: ast_fold) -> field {\n-        ret {node:\n+        return {node:\n                  {mutbl: field.node.mutbl,\n                   ident: fld.fold_ident(field.node.ident),\n                   expr: fld.fold_expr(field.node.expr)},\n@@ -392,7 +394,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n \n     let fold_mac = |x| fold_mac_(x, fld);\n \n-    ret alt e {\n+    return alt e {\n           expr_new(p, i, v) {\n             expr_new(fld.fold_expr(p),\n                      fld.new_id(i),\n@@ -514,18 +516,18 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n \n // ...nor do modules\n fn noop_fold_mod(m: _mod, fld: ast_fold) -> _mod {\n-    ret {view_items: vec::map(m.view_items, |x| fld.fold_view_item(x)),\n+    return {view_items: vec::map(m.view_items, |x| fld.fold_view_item(x)),\n          items: vec::filter_map(m.items, |x| fld.fold_item(x))};\n }\n \n fn noop_fold_foreign_mod(nm: foreign_mod, fld: ast_fold) -> foreign_mod {\n-    ret {view_items: vec::map(nm.view_items, |x| fld.fold_view_item(x)),\n+    return {view_items: vec::map(nm.view_items, |x| fld.fold_view_item(x)),\n          items: vec::map(nm.items, |x| fld.fold_foreign_item(x))}\n }\n \n fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     fn fold_variant_arg_(va: variant_arg, fld: ast_fold) -> variant_arg {\n-        ret {ty: fld.fold_ty(va.ty), id: fld.new_id(va.id)};\n+        return {ty: fld.fold_ty(va.ty), id: fld.new_id(va.id)};\n     }\n     let fold_variant_arg = |x| fold_variant_arg_(x, fld);\n     let args = vec::map(v.args, fold_variant_arg);\n@@ -537,26 +539,26 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n       some(e) {some(fld.fold_expr(e))}\n       none {none}\n     };\n-    ret {name: /* FIXME (#2543) */ copy v.name,\n+    return {name: /* FIXME (#2543) */ copy v.name,\n          attrs: attrs,\n          args: args, id: fld.new_id(v.id),\n          disr_expr: de,\n          vis: v.vis};\n }\n \n fn noop_fold_ident(&&i: ident, _fld: ast_fold) -> ident {\n-    ret /* FIXME (#2543) */ copy i;\n+    return /* FIXME (#2543) */ copy i;\n }\n \n fn noop_fold_path(&&p: path, fld: ast_fold) -> path {\n-    ret {span: fld.new_span(p.span), global: p.global,\n+    return {span: fld.new_span(p.span), global: p.global,\n          idents: vec::map(p.idents, |x| fld.fold_ident(x)),\n          rp: p.rp,\n          types: vec::map(p.types, |x| fld.fold_ty(x))};\n }\n \n fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n-    ret {is_mutbl: l.is_mutbl,\n+    return {is_mutbl: l.is_mutbl,\n          ty: fld.fold_ty(l.ty),\n          pat: fld.fold_pat(l.pat),\n          init:\n@@ -573,15 +575,15 @@ fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n /* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n    value */\n fn noop_map_exprs(f: fn@(&&@expr) -> @expr, es: ~[@expr]) -> ~[@expr] {\n-    ret vec::map(es, f);\n+    return vec::map(es, f);\n }\n \n-fn noop_id(i: node_id) -> node_id { ret i; }\n+fn noop_id(i: node_id) -> node_id { return i; }\n \n-fn noop_span(sp: span) -> span { ret sp; }\n+fn noop_span(sp: span) -> span { return sp; }\n \n fn default_ast_fold() -> ast_fold_precursor {\n-    ret @{fold_crate: wrap(noop_fold_crate),\n+    return @{fold_crate: wrap(noop_fold_crate),\n           fold_crate_directive: wrap(noop_fold_crate_directive),\n           fold_view_item: noop_fold_view_item,\n           fold_foreign_item: noop_fold_foreign_item,\n@@ -611,28 +613,28 @@ impl of ast_fold for ast_fold_precursor {\n     /* naturally, a macro to write these would be nice */\n     fn fold_crate(c: crate) -> crate {\n         let (n, s) = self.fold_crate(c.node, c.span, self as ast_fold);\n-        ret {node: n, span: self.new_span(s)};\n+        return {node: n, span: self.new_span(s)};\n     }\n     fn fold_crate_directive(&&c: @crate_directive) -> @crate_directive {\n         let (n, s) = self.fold_crate_directive(c.node, c.span,\n                                                self as ast_fold);\n-        ret @{node: n,\n+        return @{node: n,\n               span: self.new_span(s)};\n     }\n     fn fold_view_item(&&x: @view_item) ->\n        @view_item {\n-        ret @{node: self.fold_view_item(x.node, self as ast_fold),\n+        return @{node: self.fold_view_item(x.node, self as ast_fold),\n               attrs: vec::map(x.attrs, |a|\n                   fold_attribute_(a, self as ast_fold)),\n               vis: x.vis,\n               span: self.new_span(x.span)};\n     }\n     fn fold_foreign_item(&&x: @foreign_item)\n         -> @foreign_item {\n-        ret self.fold_foreign_item(x, self as ast_fold);\n+        return self.fold_foreign_item(x, self as ast_fold);\n     }\n     fn fold_item(&&i: @item) -> option<@item> {\n-        ret self.fold_item(i, self as ast_fold);\n+        return self.fold_item(i, self as ast_fold);\n     }\n     fn fold_class_item(&&ci: @class_member) -> @class_member {\n         @{node: alt ci.node {\n@@ -647,65 +649,65 @@ impl of ast_fold for ast_fold_precursor {\n     }\n     fn fold_item_underscore(i: item_) ->\n        item_ {\n-        ret self.fold_item_underscore(i, self as ast_fold);\n+        return self.fold_item_underscore(i, self as ast_fold);\n     }\n     fn fold_method(&&x: @method)\n         -> @method {\n-        ret self.fold_method(x, self as ast_fold);\n+        return self.fold_method(x, self as ast_fold);\n     }\n     fn fold_block(x: blk) -> blk {\n         let (n, s) = self.fold_block(x.node, x.span, self as ast_fold);\n-        ret {node: n, span: self.new_span(s)};\n+        return {node: n, span: self.new_span(s)};\n     }\n     fn fold_stmt(&&x: @stmt) -> @stmt {\n         let (n, s) = self.fold_stmt(x.node, x.span, self as ast_fold);\n-        ret @{node: n, span: self.new_span(s)};\n+        return @{node: n, span: self.new_span(s)};\n     }\n     fn fold_arm(x: arm) -> arm {\n-        ret self.fold_arm(x, self as ast_fold);\n+        return self.fold_arm(x, self as ast_fold);\n     }\n     fn fold_pat(&&x: @pat) -> @pat {\n         let (n, s) =  self.fold_pat(x.node, x.span, self as ast_fold);\n-        ret @{id: self.new_id(x.id),\n+        return @{id: self.new_id(x.id),\n               node: n,\n               span: self.new_span(s)};\n     }\n     fn fold_decl(&&x: @decl) -> @decl {\n         let (n, s) = self.fold_decl(x.node, x.span, self as ast_fold);\n-        ret @{node: n, span: self.new_span(s)};\n+        return @{node: n, span: self.new_span(s)};\n     }\n     fn fold_expr(&&x: @expr) -> @expr {\n         let (n, s) = self.fold_expr(x.node, x.span, self as ast_fold);\n-        ret @{id: self.new_id(x.id),\n+        return @{id: self.new_id(x.id),\n               callee_id: self.new_id(x.callee_id),\n               node: n,\n               span: self.new_span(s)};\n     }\n     fn fold_ty(&&x: @ty) -> @ty {\n         let (n, s) = self.fold_ty(x.node, x.span, self as ast_fold);\n-        ret @{id: self.new_id(x.id), node: n, span: self.new_span(s)};\n+        return @{id: self.new_id(x.id), node: n, span: self.new_span(s)};\n     }\n     fn fold_mod(x: _mod) -> _mod {\n-        ret self.fold_mod(x, self as ast_fold);\n+        return self.fold_mod(x, self as ast_fold);\n     }\n     fn fold_foreign_mod(x: foreign_mod) ->\n        foreign_mod {\n-        ret self.fold_foreign_mod(x, self as ast_fold);\n+        return self.fold_foreign_mod(x, self as ast_fold);\n     }\n     fn fold_variant(x: variant) ->\n        variant {\n         let (n, s) = self.fold_variant(x.node, x.span, self as ast_fold);\n-        ret {node: n, span: self.new_span(s)};\n+        return {node: n, span: self.new_span(s)};\n     }\n     fn fold_ident(&&x: ident) -> ident {\n-        ret self.fold_ident(x, self as ast_fold);\n+        return self.fold_ident(x, self as ast_fold);\n     }\n     fn fold_path(&&x: @path) -> @path {\n         @self.fold_path(*x, self as ast_fold)\n     }\n     fn fold_local(&&x: @local) -> @local {\n         let (n, s) = self.fold_local(x.node, x.span, self as ast_fold);\n-        ret @{node: n, span: self.new_span(s)};\n+        return @{node: n, span: self.new_span(s)};\n     }\n     fn map_exprs(f: fn@(&&@expr) -> @expr, e: ~[@expr]) -> ~[@expr] {\n         self.map_exprs(f, e)"}, {"sha": "dad80246bf59f2cb13a2825cb78a04d6e0d8e06d", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -34,7 +34,7 @@ type parse_sess = @{\n \n fn new_parse_sess(demitter: option<emitter>) -> parse_sess {\n     let cm = codemap::new_codemap();\n-    ret @{cm: cm,\n+    return @{cm: cm,\n           mut next_id: 1,\n           span_diagnostic: mk_span_handler(mk_handler(demitter), cm),\n           interner: @interner::mk::<@~str>(|x| str::hash(*x),\n@@ -44,7 +44,7 @@ fn new_parse_sess(demitter: option<emitter>) -> parse_sess {\n \n fn new_parse_sess_special_handler(sh: span_handler, cm: codemap::codemap)\n     -> parse_sess {\n-    ret @{cm: cm,\n+    return @{cm: cm,\n           mut next_id: 1,\n           span_diagnostic: sh,\n           interner: @interner::mk::<@~str>(|x| str::hash(*x),\n@@ -81,7 +81,7 @@ fn parse_crate_from_crate_file(input: ~str, cfg: ast::crate_cfg,\n         cx, cdirs, prefix, option::some(companionmod));\n     let mut hi = p.span.hi;\n     p.expect(token::EOF);\n-    ret @ast_util::respan(ast_util::mk_sp(lo, hi),\n+    return @ast_util::respan(ast_util::mk_sp(lo, hi),\n                           {directives: cdirs,\n                            module: m,\n                            attrs: vec::append(crate_attrs, attrs),\n@@ -95,7 +95,7 @@ fn parse_crate_from_source_file(input: ~str, cfg: ast::crate_cfg,\n     let r = p.parse_crate_mod(cfg);\n     sess.chpos = rdr.chpos;\n     sess.byte_pos = sess.byte_pos + rdr.pos;\n-    ret r;\n+    return r;\n }\n \n fn parse_crate_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n@@ -105,7 +105,7 @@ fn parse_crate_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n     let r = p.parse_crate_mod(cfg);\n     sess.chpos = rdr.chpos;\n     sess.byte_pos = sess.byte_pos + rdr.pos;\n-    ret r;\n+    return r;\n }\n \n fn parse_expr_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n@@ -115,7 +115,7 @@ fn parse_expr_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n     let r = p.parse_expr();\n     sess.chpos = rdr.chpos;\n     sess.byte_pos = sess.byte_pos + rdr.pos;\n-    ret r;\n+    return r;\n }\n \n fn parse_item_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n@@ -127,7 +127,7 @@ fn parse_item_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n     let r = p.parse_item(attrs, vis);\n     sess.chpos = rdr.chpos;\n     sess.byte_pos = sess.byte_pos + rdr.pos;\n-    ret r;\n+    return r;\n }\n \n fn parse_stmt_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n@@ -138,7 +138,7 @@ fn parse_stmt_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n     let r = p.parse_stmt(attrs);\n     sess.chpos = rdr.chpos;\n     sess.byte_pos = sess.byte_pos + rdr.pos;\n-    ret r;\n+    return r;\n }\n \n fn parse_from_source_str<T>(f: fn (p: parser) -> T,\n@@ -155,15 +155,15 @@ fn parse_from_source_str<T>(f: fn (p: parser) -> T,\n     }\n     sess.chpos = rdr.chpos;\n     sess.byte_pos = sess.byte_pos + rdr.pos;\n-    ret r;\n+    return r;\n }\n \n fn next_node_id(sess: parse_sess) -> node_id {\n     let rv = sess.next_id;\n     sess.next_id += 1;\n     // ID 0 is reserved for the crate and doesn't actually exist in the AST\n     assert rv != 0;\n-    ret rv;\n+    return rv;\n }\n \n fn new_parser_etc_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n@@ -175,14 +175,14 @@ fn new_parser_etc_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n     sess.cm.files.push(filemap);\n     let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap,\n                                         sess.interner);\n-    ret (parser(sess, cfg, srdr as reader, ftype), srdr);\n+    return (parser(sess, cfg, srdr as reader, ftype), srdr);\n }\n \n fn new_parser_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n                               +name: ~str, +ss: codemap::file_substr,\n                               source: @~str) -> parser {\n     let (p, _) = new_parser_etc_from_source_str(sess, cfg, name, ss, source);\n-    ret p;\n+    return p;\n }\n \n \n@@ -199,18 +199,18 @@ fn new_parser_etc_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n     sess.cm.files.push(filemap);\n     let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap,\n                                         sess.interner);\n-    ret (parser(sess, cfg, srdr as reader, ftype), srdr);\n+    return (parser(sess, cfg, srdr as reader, ftype), srdr);\n }\n \n fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, +path: ~str,\n                         ftype: parser::file_type) -> parser {\n     let (p, _) = new_parser_etc_from_file(sess, cfg, path, ftype);\n-    ret p;\n+    return p;\n }\n \n fn new_parser_from_tt(sess: parse_sess, cfg: ast::crate_cfg,\n                       tt: ~[ast::token_tree]) -> parser {\n     let trdr = lexer::new_tt_reader(sess.span_diagnostic, sess.interner,\n                                     none, tt);\n-    ret parser(sess, cfg, trdr as reader, parser::SOURCE_FILE)\n+    return parser(sess, cfg, trdr as reader, parser::SOURCE_FILE)\n }"}, {"sha": "265b707899a1495e2b08690819b29d0dd6924f6c", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -36,21 +36,21 @@ impl parser_attr of parser_attr for parser {\n                 self.bump();\n                 let first_attr =\n                     self.parse_attribute_naked(ast::attr_outer, lo);\n-                ret some(left(vec::append(~[first_attr],\n+                return some(left(vec::append(~[first_attr],\n                                           self.parse_outer_attributes())));\n             } else if !(self.look_ahead(1u) == token::LT\n                         || self.look_ahead(1u) == token::LBRACKET\n                         || self.look_ahead(1u) == token::POUND\n                         || expect_item_next) {\n                 self.bump();\n-                ret some(right(self.parse_syntax_ext_naked(lo)));\n-            } else { ret none; }\n+                return some(right(self.parse_syntax_ext_naked(lo)));\n+            } else { return none; }\n         }\n         token::DOC_COMMENT(_) {\n-          ret some(left(self.parse_outer_attributes()));\n+          return some(left(self.parse_outer_attributes()));\n         }\n         _ {\n-          ret none;\n+          return none;\n         }\n       }\n     }\n@@ -80,13 +80,13 @@ impl parser_attr of parser_attr for parser {\n               }\n             }\n         }\n-        ret attrs;\n+        return attrs;\n     }\n \n     fn parse_attribute(style: ast::attr_style) -> ast::attribute {\n         let lo = self.span.lo;\n         self.expect(token::POUND);\n-        ret self.parse_attribute_naked(style, lo);\n+        return self.parse_attribute_naked(style, lo);\n     }\n \n     fn parse_attribute_naked(style: ast::attr_style, lo: uint) ->\n@@ -95,7 +95,7 @@ impl parser_attr of parser_attr for parser {\n         let meta_item = self.parse_meta_item();\n         self.expect(token::RBRACKET);\n         let mut hi = self.span.hi;\n-        ret spanned(lo, hi, {style: style, value: *meta_item,\n+        return spanned(lo, hi, {style: style, value: *meta_item,\n                              is_sugared_doc: false});\n     }\n \n@@ -146,7 +146,7 @@ impl parser_attr of parser_attr for parser {\n               }\n             }\n         }\n-        ret {inner: inner_attrs, next: next_outer_attrs};\n+        return {inner: inner_attrs, next: next_outer_attrs};\n     }\n \n     fn parse_meta_item() -> @ast::meta_item {\n@@ -157,29 +157,29 @@ impl parser_attr of parser_attr for parser {\n             self.bump();\n             let lit = self.parse_lit();\n             let mut hi = self.span.hi;\n-            ret @spanned(lo, hi, ast::meta_name_value(ident, lit));\n+            return @spanned(lo, hi, ast::meta_name_value(ident, lit));\n           }\n           token::LPAREN {\n             let inner_items = self.parse_meta_seq();\n             let mut hi = self.span.hi;\n-            ret @spanned(lo, hi, ast::meta_list(ident, inner_items));\n+            return @spanned(lo, hi, ast::meta_list(ident, inner_items));\n           }\n           _ {\n             let mut hi = self.span.hi;\n-            ret @spanned(lo, hi, ast::meta_word(ident));\n+            return @spanned(lo, hi, ast::meta_word(ident));\n           }\n         }\n     }\n \n     fn parse_meta_seq() -> ~[@ast::meta_item] {\n-        ret self.parse_seq(token::LPAREN, token::RPAREN,\n+        return self.parse_seq(token::LPAREN, token::RPAREN,\n                            seq_sep_trailing_disallowed(token::COMMA),\n                            |p| p.parse_meta_item()).node;\n     }\n \n     fn parse_optional_meta() -> ~[@ast::meta_item] {\n-        alt self.token { token::LPAREN { ret self.parse_meta_seq(); }\n-                         _ { ret ~[]; } }\n+        alt self.token { token::LPAREN { return self.parse_meta_seq(); }\n+                         _ { return ~[]; } }\n     }\n }\n "}, {"sha": "8a5e02163becd23c1c9774506890bdb9c13b694c", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -18,16 +18,16 @@ fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n     alt stmt.node {\n       ast::stmt_decl(d, _) {\n-        ret alt d.node {\n+        return alt d.node {\n               ast::decl_local(_) { true }\n               ast::decl_item(_) { false }\n             }\n       }\n       ast::stmt_expr(e, _) {\n-        ret expr_requires_semi_to_be_stmt(e);\n+        return expr_requires_semi_to_be_stmt(e);\n       }\n       ast::stmt_semi(e, _) {\n-        ret false;\n+        return false;\n       }\n     }\n }"}, {"sha": "7c24f8b1245a1819223a2f05f80b9deb0598429f", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -47,7 +47,7 @@ fn strip_doc_comment_decoration(comment: ~str) -> ~str {\n         while j > i && lines[j - 1u].trim().is_empty() {\n             j -= 1u;\n         }\n-        ret lines.slice(i, j);\n+        return lines.slice(i, j);\n     }\n \n     // drop leftmost columns that contain only values in chars\n@@ -69,7 +69,7 @@ fn strip_doc_comment_decoration(comment: ~str) -> ~str {\n             }\n         }\n \n-        ret do lines.map |line| {\n+        return do lines.map |line| {\n             let chars = str::chars(line);\n             if i > chars.len() {\n                 ~\"\"\n@@ -80,7 +80,7 @@ fn strip_doc_comment_decoration(comment: ~str) -> ~str {\n     }\n \n     if comment.starts_with(~\"//\") {\n-        ret comment.slice(3u, comment.len()).trim();\n+        return comment.slice(3u, comment.len()).trim();\n     }\n \n     if comment.starts_with(~\"/*\") {\n@@ -89,7 +89,7 @@ fn strip_doc_comment_decoration(comment: ~str) -> ~str {\n         let lines = block_trim(lines, ~\"\\t \", none);\n         let lines = block_trim(lines, ~\"*\", some(1u));\n         let lines = block_trim(lines, ~\"\\t \", none);\n-        ret str::connect(lines, ~\"\\n\");\n+        return str::connect(lines, ~\"\\n\");\n     }\n \n     fail ~\"not a doc-comment: \" + comment;\n@@ -102,14 +102,14 @@ fn read_to_eol(rdr: string_reader) -> ~str {\n         bump(rdr);\n     }\n     if rdr.curr == '\\n' { bump(rdr); }\n-    ret val;\n+    return val;\n }\n \n fn read_one_line_comment(rdr: string_reader) -> ~str {\n     let val = read_to_eol(rdr);\n     assert ((val[0] == '/' as u8 && val[1] == '/' as u8) ||\n             (val[0] == '#' as u8 && val[1] == '!' as u8));\n-    ret val;\n+    return val;\n }\n \n fn consume_non_eol_whitespace(rdr: string_reader) {\n@@ -173,8 +173,10 @@ fn read_line_comments(rdr: string_reader, code_to_the_left: bool,\n \n fn all_whitespace(s: ~str, begin: uint, end: uint) -> bool {\n     let mut i: uint = begin;\n-    while i != end { if !is_whitespace(s[i] as char) { ret false; } i += 1u; }\n-    ret true;\n+    while i != end {\n+        if !is_whitespace(s[i] as char) { return false; } i += 1u;\n+    }\n+    return true;\n }\n \n fn trim_whitespace_prefix_and_push_line(&lines: ~[~str],\n@@ -208,7 +210,7 @@ fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n             bump(rdr);\n             bump(rdr);\n         }\n-        ret;\n+        return;\n     }\n \n     let mut curr_line = ~\"/*\";\n@@ -250,7 +252,7 @@ fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n }\n \n fn peeking_at_comment(rdr: string_reader) -> bool {\n-    ret ((rdr.curr == '/' && nextch(rdr) == '/') ||\n+    return ((rdr.curr == '/' && nextch(rdr) == '/') ||\n          (rdr.curr == '/' && nextch(rdr) == '*')) ||\n          (rdr.curr == '#' && nextch(rdr) == '!');\n }\n@@ -314,5 +316,5 @@ fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n         }\n         first_read = false;\n     }\n-    ret {cmnts: comments, lits: literals};\n+    return {cmnts: comments, lits: literals};\n }"}, {"sha": "e0b551f0e45ffcb6b92f3025f4d4b8603f9874ea", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -9,13 +9,13 @@ type seq_sep = {\n };\n \n fn seq_sep_trailing_disallowed(t: token::token) -> seq_sep {\n-    ret {sep: option::some(t), trailing_sep_allowed: false};\n+    return {sep: option::some(t), trailing_sep_allowed: false};\n }\n fn seq_sep_trailing_allowed(t: token::token) -> seq_sep {\n-    ret {sep: option::some(t), trailing_sep_allowed: true};\n+    return {sep: option::some(t), trailing_sep_allowed: true};\n }\n fn seq_sep_none() -> seq_sep {\n-    ret {sep: option::none, trailing_sep_allowed: false};\n+    return {sep: option::none, trailing_sep_allowed: false};\n }\n \n fn token_to_str(reader: reader, ++token: token::token) -> ~str {\n@@ -85,7 +85,7 @@ impl parser_common of parser_common for parser {\n \n     fn parse_ident() -> ast::ident {\n         alt copy self.token {\n-          token::IDENT(i, _) { self.bump(); ret self.get_str(i); }\n+          token::IDENT(i, _) { self.bump(); return self.get_str(i); }\n           token::INTERPOLATED(token::nt_ident(*)) { self.bug(\n               ~\"ident interpolation not converted to real token\"); }\n           _ { self.fatal(~\"expected ident, found `\"\n@@ -98,16 +98,16 @@ impl parser_common of parser_common for parser {\n         let lo = self.span.lo;\n         let ident = self.parse_ident();\n         let hi = self.span.hi;\n-        ret spanned(lo, hi, {name: ident, id: self.get_id()});\n+        return spanned(lo, hi, {name: ident, id: self.get_id()});\n     }\n \n     fn parse_value_ident() -> ast::ident {\n         self.check_restricted_keywords();\n-        ret self.parse_ident();\n+        return self.parse_ident();\n     }\n \n     fn eat(tok: token::token) -> bool {\n-        ret if self.token == tok { self.bump(); true } else { false };\n+        return if self.token == tok { self.bump(); true } else { false };\n     }\n \n     // A sanity check that the word we are asking for is a known keyword\n@@ -217,15 +217,15 @@ impl parser_common of parser_common for parser {\n             vec::push(v, f(self));\n         }\n \n-        ret v;\n+        return v;\n     }\n \n     fn parse_seq_to_gt<T: copy>(sep: option<token::token>,\n                                 f: fn(parser) -> T) -> ~[T] {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n \n-        ret v;\n+        return v;\n     }\n \n     fn parse_seq_lt_gt<T: copy>(sep: option<token::token>,\n@@ -235,14 +235,14 @@ impl parser_common of parser_common for parser {\n         let result = self.parse_seq_to_before_gt::<T>(sep, f);\n         let hi = self.span.hi;\n         self.expect_gt();\n-        ret spanned(lo, hi, result);\n+        return spanned(lo, hi, result);\n     }\n \n     fn parse_seq_to_end<T: copy>(ket: token::token, sep: seq_sep,\n                                  f: fn(parser) -> T) -> ~[T] {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n-        ret val;\n+        return val;\n     }\n \n \n@@ -259,7 +259,7 @@ impl parser_common of parser_common for parser {\n             if sep.trailing_sep_allowed && self.token == ket { break; }\n             vec::push(v, f(self));\n         }\n-        ret v;\n+        return v;\n     }\n \n     fn parse_unspanned_seq<T: copy>(bra: token::token,\n@@ -269,7 +269,7 @@ impl parser_common of parser_common for parser {\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end::<T>(ket, sep, f);\n         self.bump();\n-        ret result;\n+        return result;\n     }\n \n     // NB: Do not use this function unless you actually plan to place the\n@@ -281,6 +281,6 @@ impl parser_common of parser_common for parser {\n         let result = self.parse_seq_to_before_end::<T>(ket, sep, f);\n         let hi = self.span.hi;\n         self.bump();\n-        ret spanned(lo, hi, result);\n+        return spanned(lo, hi, result);\n     }\n }"}, {"sha": "90519c23e5fd0e78bc20b69885c25489269c9215", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -28,7 +28,7 @@ fn eval_crate_directives_to_mod(cx: ctx, cdirs: ~[@ast::crate_directive],\n     let mut view_items: ~[@ast::view_item] = ~[];\n     let mut items: ~[@ast::item] = ~[];\n     eval_crate_directives(cx, cdirs, prefix, view_items, items);\n-    ret ({view_items: vec::append(view_items, cview_items),\n+    return ({view_items: vec::append(view_items, cview_items),\n           items: vec::append(items, citems)},\n          cattrs);\n }\n@@ -47,7 +47,7 @@ fn parse_companion_mod(cx: ctx, prefix: ~str, suffix: option<~str>)\n     -> (~[@ast::view_item], ~[@ast::item], ~[ast::attribute]) {\n \n     fn companion_file(+prefix: ~str, suffix: option<~str>) -> ~str {\n-        ret alt suffix {\n+        return alt suffix {\n           option::some(s) { path::connect(prefix, s) }\n           option::none { prefix }\n         } + ~\".rs\";\n@@ -72,18 +72,18 @@ fn parse_companion_mod(cx: ctx, prefix: ~str, suffix: option<~str>)\n         let m0 = p0.parse_mod_items(token::EOF, inner_attrs.next);\n         cx.sess.chpos = r0.chpos;\n         cx.sess.byte_pos = cx.sess.byte_pos + r0.pos;\n-        ret (m0.view_items, m0.items, inner_attrs.inner);\n+        return (m0.view_items, m0.items, inner_attrs.inner);\n     } else {\n-        ret (~[], ~[], ~[]);\n+        return (~[], ~[], ~[]);\n     }\n }\n \n fn cdir_path_opt(id: ast::ident, attrs: ~[ast::attribute]) -> @~str {\n     alt ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n       some(d) {\n-        ret d;\n+        return d;\n       }\n-      none { ret id; }\n+      none { return id; }\n     }\n }\n "}, {"sha": "a2d7a04a6bfecf8d667e9e91b759624ef8962d62", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 87, "deletions": 85, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -38,7 +38,7 @@ fn new_string_reader(span_diagnostic: span_handler,\n                      itr: @interner<@~str>) -> string_reader {\n     let r = new_low_level_string_reader(span_diagnostic, filemap, itr);\n     string_advance_token(r); /* fill in peek_* */\n-    ret r;\n+    return r;\n }\n \n /* For comments.rs, which hackily pokes into 'pos' and 'curr' */\n@@ -58,7 +58,7 @@ fn new_low_level_string_reader(span_diagnostic: span_handler,\n         r.pos = next.next;\n         r.curr = next.ch;\n     }\n-    ret r;\n+    return r;\n }\n \n fn dup_string_reader(&&r: string_reader) -> string_reader {\n@@ -73,7 +73,7 @@ impl string_reader_as_reader of reader for string_reader {\n     fn next_token() -> {tok: token::token, sp: span} {\n         let ret_val = {tok: self.peek_tok, sp: self.peek_span};\n         string_advance_token(self);\n-        ret ret_val;\n+        return ret_val;\n     }\n     fn fatal(m: ~str) -> ! {\n         self.span_diagnostic.span_fatal(copy self.peek_span, m)\n@@ -112,7 +112,7 @@ fn string_advance_token(&&r: string_reader) {\n     for consume_whitespace_and_comments(r).each |comment| {\n         r.peek_tok = comment.tok;\n         r.peek_span = comment.sp;\n-        ret;\n+        return;\n     }\n \n     if is_eof(r) {\n@@ -128,7 +128,7 @@ fn string_advance_token(&&r: string_reader) {\n fn get_str_from(rdr: string_reader, start: uint) -> ~str unsafe {\n     // I'm pretty skeptical about this subtraction. What if there's a\n     // multi-byte character before the mark?\n-    ret str::slice(*rdr.src, start - 1u, rdr.pos - 1u);\n+    return str::slice(*rdr.src, start - 1u, rdr.pos - 1u);\n }\n \n fn bump(rdr: string_reader) {\n@@ -155,49 +155,51 @@ fn is_eof(rdr: string_reader) -> bool {\n }\n fn nextch(rdr: string_reader) -> char {\n     if rdr.pos < (*rdr.src).len() {\n-        ret str::char_at(*rdr.src, rdr.pos);\n-    } else { ret -1 as char; }\n+        return str::char_at(*rdr.src, rdr.pos);\n+    } else { return -1 as char; }\n }\n \n-fn dec_digit_val(c: char) -> int { ret (c as int) - ('0' as int); }\n+fn dec_digit_val(c: char) -> int { return (c as int) - ('0' as int); }\n \n fn hex_digit_val(c: char) -> int {\n-    if in_range(c, '0', '9') { ret (c as int) - ('0' as int); }\n-    if in_range(c, 'a', 'f') { ret (c as int) - ('a' as int) + 10; }\n-    if in_range(c, 'A', 'F') { ret (c as int) - ('A' as int) + 10; }\n+    if in_range(c, '0', '9') { return (c as int) - ('0' as int); }\n+    if in_range(c, 'a', 'f') { return (c as int) - ('a' as int) + 10; }\n+    if in_range(c, 'A', 'F') { return (c as int) - ('A' as int) + 10; }\n     fail;\n }\n \n-fn bin_digit_value(c: char) -> int { if c == '0' { ret 0; } ret 1; }\n+fn bin_digit_value(c: char) -> int { if c == '0' { return 0; } return 1; }\n \n fn is_whitespace(c: char) -> bool {\n-    ret c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n+    return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n }\n \n-fn may_begin_ident(c: char) -> bool { ret is_alpha(c) || c == '_'; }\n+fn may_begin_ident(c: char) -> bool { return is_alpha(c) || c == '_'; }\n \n-fn in_range(c: char, lo: char, hi: char) -> bool { ret lo <= c && c <= hi; }\n+fn in_range(c: char, lo: char, hi: char) -> bool {\n+    return lo <= c && c <= hi\n+}\n \n fn is_alpha(c: char) -> bool {\n-    ret in_range(c, 'a', 'z') || in_range(c, 'A', 'Z');\n+    return in_range(c, 'a', 'z') || in_range(c, 'A', 'Z');\n }\n \n-fn is_dec_digit(c: char) -> bool { ret in_range(c, '0', '9'); }\n+fn is_dec_digit(c: char) -> bool { return in_range(c, '0', '9'); }\n \n-fn is_alnum(c: char) -> bool { ret is_alpha(c) || is_dec_digit(c); }\n+fn is_alnum(c: char) -> bool { return is_alpha(c) || is_dec_digit(c); }\n \n fn is_hex_digit(c: char) -> bool {\n-    ret in_range(c, '0', '9') || in_range(c, 'a', 'f') ||\n+    return in_range(c, '0', '9') || in_range(c, 'a', 'f') ||\n             in_range(c, 'A', 'F');\n }\n \n-fn is_bin_digit(c: char) -> bool { ret c == '0' || c == '1'; }\n+fn is_bin_digit(c: char) -> bool { return c == '0' || c == '1'; }\n \n // might return a sugared-doc-attr\n fn consume_whitespace_and_comments(rdr: string_reader)\n                                 -> option<{tok: token::token, sp: span}> {\n     while is_whitespace(rdr.curr) { bump(rdr); }\n-    ret consume_any_line_comment(rdr);\n+    return consume_any_line_comment(rdr);\n }\n \n // might return a sugared-doc-attr\n@@ -216,17 +218,17 @@ fn consume_any_line_comment(rdr: string_reader)\n                     str::push_char(acc, rdr.curr);\n                     bump(rdr);\n                 }\n-                ret some({\n+                return some({\n                     tok: token::DOC_COMMENT((*rdr.interner).intern(@acc)),\n                     sp: ast_util::mk_sp(start_chpos, rdr.chpos)\n                 });\n             } else {\n                 while rdr.curr != '\\n' && !is_eof(rdr) { bump(rdr); }\n                 // Restart whitespace munch.\n-                ret consume_whitespace_and_comments(rdr);\n+                return consume_whitespace_and_comments(rdr);\n             }\n           }\n-          '*' { bump(rdr); bump(rdr); ret consume_block_comment(rdr); }\n+          '*' { bump(rdr); bump(rdr); return consume_block_comment(rdr); }\n           _ {}\n         }\n     } else if rdr.curr == '#' {\n@@ -236,11 +238,11 @@ fn consume_any_line_comment(rdr: string_reader)\n             let loc = codemap::lookup_char_pos_adj(cmap, rdr.chpos);\n             if loc.line == 1u && loc.col == 0u {\n                 while rdr.curr != '\\n' && !is_eof(rdr) { bump(rdr); }\n-                ret consume_whitespace_and_comments(rdr);\n+                return consume_whitespace_and_comments(rdr);\n             }\n         }\n     }\n-    ret none;\n+    return none;\n }\n \n // might return a sugared-doc-attr\n@@ -261,7 +263,7 @@ fn consume_block_comment(rdr: string_reader)\n             acc += ~\"*/\";\n             bump(rdr);\n             bump(rdr);\n-            ret some({\n+            return some({\n                 tok: token::DOC_COMMENT((*rdr.interner).intern(@acc)),\n                 sp: ast_util::mk_sp(start_chpos, rdr.chpos)\n             });\n@@ -285,7 +287,7 @@ fn consume_block_comment(rdr: string_reader)\n     }\n     // restart whitespace munch.\n \n-    ret consume_whitespace_and_comments(rdr);\n+    return consume_whitespace_and_comments(rdr);\n }\n \n fn scan_exponent(rdr: string_reader) -> option<~str> {\n@@ -301,9 +303,9 @@ fn scan_exponent(rdr: string_reader) -> option<~str> {\n         }\n         let exponent = scan_digits(rdr, 10u);\n         if str::len(exponent) > 0u {\n-            ret some(rslt + exponent);\n+            return some(rslt + exponent);\n         } else { rdr.fatal(~\"scan_exponent: bad fp literal\"); }\n-    } else { ret none::<~str>; }\n+    } else { return none::<~str>; }\n }\n \n fn scan_digits(rdr: string_reader, radix: uint) -> ~str {\n@@ -316,7 +318,7 @@ fn scan_digits(rdr: string_reader, radix: uint) -> ~str {\n             str::push_char(rslt, c);\n             bump(rdr);\n           }\n-          _ { ret rslt; }\n+          _ { return rslt; }\n         }\n     };\n }\n@@ -370,8 +372,8 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n         }\n         let parsed = option::get(u64::from_str_radix(num_str, base as u64));\n         alt tp {\n-          either::left(t) { ret token::LIT_INT(parsed as i64, t); }\n-          either::right(t) { ret token::LIT_UINT(parsed, t); }\n+          either::left(t) { return token::LIT_INT(parsed as i64, t); }\n+          either::right(t) { return token::LIT_UINT(parsed, t); }\n         }\n     }\n     let mut is_float = false;\n@@ -395,12 +397,12 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n         if c == '3' && n == '2' {\n             bump(rdr);\n             bump(rdr);\n-            ret token::LIT_FLOAT((*rdr.interner).intern(@num_str),\n+            return token::LIT_FLOAT((*rdr.interner).intern(@num_str),\n                                  ast::ty_f32);\n         } else if c == '6' && n == '4' {\n             bump(rdr);\n             bump(rdr);\n-            ret token::LIT_FLOAT((*rdr.interner).intern(@num_str),\n+            return token::LIT_FLOAT((*rdr.interner).intern(@num_str),\n                                  ast::ty_f64);\n             /* FIXME (#2252): if this is out of range for either a\n             32-bit or 64-bit float, it won't be noticed till the\n@@ -410,7 +412,7 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n         }\n     }\n     if is_float {\n-        ret token::LIT_FLOAT((*rdr.interner).intern(@num_str), ast::ty_f);\n+        return token::LIT_FLOAT((*rdr.interner).intern(@num_str), ast::ty_f);\n     } else {\n         if str::len(num_str) == 0u {\n             rdr.fatal(~\"no valid digits found for number\");\n@@ -419,7 +421,7 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n \n         debug!{\"lexing %s as an unsuffixed integer literal\",\n                num_str};\n-        ret token::LIT_INT_UNSUFFIXED(parsed as i64);\n+        return token::LIT_INT_UNSUFFIXED(parsed as i64);\n     }\n }\n \n@@ -435,7 +437,7 @@ fn scan_numeric_escape(rdr: string_reader, n_hex_digits: uint) -> char {\n         accum_int += hex_digit_val(n);\n         i -= 1u;\n     }\n-    ret accum_int as char;\n+    return accum_int as char;\n }\n \n fn next_token_inner(rdr: string_reader) -> token::token {\n@@ -454,21 +456,21 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n             bump(rdr);\n             c = rdr.curr;\n         }\n-        if str::eq(accum_str, ~\"_\") { ret token::UNDERSCORE; }\n+        if str::eq(accum_str, ~\"_\") { return token::UNDERSCORE; }\n         let is_mod_name = c == ':' && nextch(rdr) == ':';\n \n         // FIXME: perform NFKC normalization here. (Issue #2253)\n-        ret token::IDENT((*rdr.interner).intern(@accum_str), is_mod_name);\n+        return token::IDENT((*rdr.interner).intern(@accum_str), is_mod_name);\n     }\n     if is_dec_digit(c) {\n-        ret scan_number(c, rdr);\n+        return scan_number(c, rdr);\n     }\n     fn binop(rdr: string_reader, op: token::binop) -> token::token {\n         bump(rdr);\n         if rdr.curr == '=' {\n             bump(rdr);\n-            ret token::BINOPEQ(op);\n-        } else { ret token::BINOP(op); }\n+            return token::BINOPEQ(op);\n+        } else { return token::BINOP(op); }\n     }\n     alt c {\n \n@@ -477,35 +479,35 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n \n \n       // One-byte tokens.\n-      ';' { bump(rdr); ret token::SEMI; }\n-      ',' { bump(rdr); ret token::COMMA; }\n+      ';' { bump(rdr); return token::SEMI; }\n+      ',' { bump(rdr); return token::COMMA; }\n       '.' {\n         bump(rdr);\n         if rdr.curr == '.' && nextch(rdr) == '.' {\n             bump(rdr);\n             bump(rdr);\n-            ret token::ELLIPSIS;\n+            return token::ELLIPSIS;\n         }\n-        ret token::DOT;\n+        return token::DOT;\n       }\n-      '(' { bump(rdr); ret token::LPAREN; }\n-      ')' { bump(rdr); ret token::RPAREN; }\n-      '{' { bump(rdr); ret token::LBRACE; }\n-      '}' { bump(rdr); ret token::RBRACE; }\n-      '[' { bump(rdr); ret token::LBRACKET; }\n-      ']' { bump(rdr); ret token::RBRACKET; }\n-      '@' { bump(rdr); ret token::AT; }\n-      '#' { bump(rdr); ret token::POUND; }\n-      '~' { bump(rdr); ret token::TILDE; }\n+      '(' { bump(rdr); return token::LPAREN; }\n+      ')' { bump(rdr); return token::RPAREN; }\n+      '{' { bump(rdr); return token::LBRACE; }\n+      '}' { bump(rdr); return token::RBRACE; }\n+      '[' { bump(rdr); return token::LBRACKET; }\n+      ']' { bump(rdr); return token::RBRACKET; }\n+      '@' { bump(rdr); return token::AT; }\n+      '#' { bump(rdr); return token::POUND; }\n+      '~' { bump(rdr); return token::TILDE; }\n       ':' {\n         bump(rdr);\n         if rdr.curr == ':' {\n             bump(rdr);\n-            ret token::MOD_SEP;\n-        } else { ret token::COLON; }\n+            return token::MOD_SEP;\n+        } else { return token::COLON; }\n       }\n \n-      '$' { bump(rdr); ret token::DOLLAR; }\n+      '$' { bump(rdr); return token::DOLLAR; }\n \n \n \n@@ -516,42 +518,42 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n         bump(rdr);\n         if rdr.curr == '=' {\n             bump(rdr);\n-            ret token::EQEQ;\n+            return token::EQEQ;\n         } else if rdr.curr == '>' {\n             bump(rdr);\n-            ret token::FAT_ARROW;\n+            return token::FAT_ARROW;\n         } else {\n-            ret token::EQ;\n+            return token::EQ;\n         }\n       }\n       '!' {\n         bump(rdr);\n         if rdr.curr == '=' {\n             bump(rdr);\n-            ret token::NE;\n-        } else { ret token::NOT; }\n+            return token::NE;\n+        } else { return token::NOT; }\n       }\n       '<' {\n         bump(rdr);\n         alt rdr.curr {\n-          '=' { bump(rdr); ret token::LE; }\n-          '<' { ret binop(rdr, token::SHL); }\n+          '=' { bump(rdr); return token::LE; }\n+          '<' { return binop(rdr, token::SHL); }\n           '-' {\n             bump(rdr);\n             alt rdr.curr {\n-              '>' { bump(rdr); ret token::DARROW; }\n-              _ { ret token::LARROW; }\n+              '>' { bump(rdr); return token::DARROW; }\n+              _ { return token::LARROW; }\n             }\n           }\n-          _ { ret token::LT; }\n+          _ { return token::LT; }\n         }\n       }\n       '>' {\n         bump(rdr);\n         alt rdr.curr {\n-          '=' { bump(rdr); ret token::GE; }\n-          '>' { ret binop(rdr, token::SHR); }\n-          _ { ret token::GT; }\n+          '=' { bump(rdr); return token::GE; }\n+          '>' { return binop(rdr, token::SHR); }\n+          _ { return token::GT; }\n         }\n       }\n       '\\'' {\n@@ -580,7 +582,7 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n             rdr.fatal(~\"unterminated character constant\");\n         }\n         bump(rdr); // advance curr past token\n-        ret token::LIT_INT(c2 as i64, ast::ty_char);\n+        return token::LIT_INT(c2 as i64, ast::ty_char);\n       }\n       '\"' {\n         let n = rdr.chpos;\n@@ -623,33 +625,33 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n             }\n         }\n         bump(rdr);\n-        ret token::LIT_STR((*rdr.interner).intern(@accum_str));\n+        return token::LIT_STR((*rdr.interner).intern(@accum_str));\n       }\n       '-' {\n         if nextch(rdr) == '>' {\n             bump(rdr);\n             bump(rdr);\n-            ret token::RARROW;\n-        } else { ret binop(rdr, token::MINUS); }\n+            return token::RARROW;\n+        } else { return binop(rdr, token::MINUS); }\n       }\n       '&' {\n         if nextch(rdr) == '&' {\n             bump(rdr);\n             bump(rdr);\n-            ret token::ANDAND;\n-        } else { ret binop(rdr, token::AND); }\n+            return token::ANDAND;\n+        } else { return binop(rdr, token::AND); }\n       }\n       '|' {\n         alt nextch(rdr) {\n-          '|' { bump(rdr); bump(rdr); ret token::OROR; }\n-          _ { ret binop(rdr, token::OR); }\n+          '|' { bump(rdr); bump(rdr); return token::OROR; }\n+          _ { return binop(rdr, token::OR); }\n         }\n       }\n-      '+' { ret binop(rdr, token::PLUS); }\n-      '*' { ret binop(rdr, token::STAR); }\n-      '/' { ret binop(rdr, token::SLASH); }\n-      '^' { ret binop(rdr, token::CARET); }\n-      '%' { ret binop(rdr, token::PERCENT); }\n+      '+' { return binop(rdr, token::PLUS); }\n+      '*' { return binop(rdr, token::STAR); }\n+      '/' { return binop(rdr, token::SLASH); }\n+      '^' { return binop(rdr, token::CARET); }\n+      '%' { return binop(rdr, token::PERCENT); }\n       c { rdr.fatal(fmt!{\"unknown start of token: %d\", c as int}); }\n     }\n }"}, {"sha": "4eaf32e99681b0421b7e8eae7451d4d8e2d0a590", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 137, "deletions": 130, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -108,11 +108,11 @@ macro_rules! maybe_whole_expr {\n     {$p:expr} => { alt copy $p.token {\n       INTERPOLATED(token::nt_expr(e)) {\n         $p.bump();\n-        ret pexpr(e);\n+        return pexpr(e);\n       }\n       INTERPOLATED(token::nt_path(pt)) {\n         $p.bump();\n-        ret $p.mk_pexpr($p.span.lo, $p.span.lo,\n+        return $p.mk_pexpr($p.span.lo, $p.span.lo,\n                        expr_path(pt));\n       }\n       _ {}\n@@ -121,7 +121,7 @@ macro_rules! maybe_whole_expr {\n \n macro_rules! maybe_whole {\n     {$p:expr, $constructor:path} => { alt copy $p.token {\n-      INTERPOLATED($constructor(x)) { $p.bump(); ret x; }\n+      INTERPOLATED($constructor(x)) { $p.bump(); return x; }\n       _ {}\n     }}\n }\n@@ -132,7 +132,7 @@ fn dummy() {\n     /* we will need this to bootstrap maybe_whole! */\n     #macro[[#maybe_whole_path[p],\n             alt p.token {\n-                INTERPOLATED(token::nt_path(pt)) { p.bump(); ret pt; }\n+                INTERPOLATED(token::nt_path(pt)) { p.bump(); return pt; }\n                 _ {} }]];\n }\n \n@@ -198,17 +198,17 @@ class parser {\n     }\n     fn buffer_length() -> int {\n         if self.buffer_start <= self.buffer_end {\n-            ret self.buffer_end - self.buffer_start;\n+            return self.buffer_end - self.buffer_start;\n         }\n-        ret (4 - self.buffer_start) + self.buffer_end;\n+        return (4 - self.buffer_start) + self.buffer_end;\n     }\n     fn look_ahead(distance: uint) -> token::token {\n         let dist = distance as int;\n         while self.buffer_length() < dist {\n             self.buffer[self.buffer_end] = self.reader.next_token();\n             self.buffer_end = (self.buffer_end + 1) & 3;\n         }\n-        ret copy self.buffer[(self.buffer_start + dist - 1) & 3].tok;\n+        return copy self.buffer[(self.buffer_start + dist - 1) & 3].tok;\n     }\n     fn fatal(m: ~str) -> ! {\n         self.sess.span_diagnostic.span_fatal(copy self.span, m)\n@@ -255,7 +255,7 @@ class parser {\n              id: p.get_id()}\n         };\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n-        ret {inputs: inputs, output: ret_ty,\n+        return {inputs: inputs, output: ret_ty,\n              purity: purity, cf: ret_style};\n     }\n \n@@ -315,7 +315,7 @@ class parser {\n     fn parse_mt() -> mt {\n         let mutbl = self.parse_mutability();\n         let t = self.parse_ty(false);\n-        ret {ty: t, mutbl: mutbl};\n+        return {ty: t, mutbl: mutbl};\n     }\n \n     fn parse_ty_field() -> ty_field {\n@@ -324,11 +324,13 @@ class parser {\n         let id = self.parse_ident();\n         self.expect(token::COLON);\n         let ty = self.parse_ty(false);\n-        ret spanned(lo, ty.span.hi, {ident: id, mt: {ty: ty, mutbl: mutbl}});\n+        return spanned(lo, ty.span.hi, {\n+            ident: id, mt: {ty: ty, mutbl: mutbl}\n+        });\n     }\n \n     fn parse_ret_ty() -> (ret_style, @ty) {\n-        ret if self.eat(token::RARROW) {\n+        return if self.eat(token::RARROW) {\n             let lo = self.span.lo;\n             if self.eat(token::NOT) {\n                 (noreturn, @{id: self.get_id(),\n@@ -391,7 +393,7 @@ class parser {\n \n         alt self.maybe_parse_dollar_mac() {\n           some(e) {\n-            ret @{id: self.get_id(),\n+            return @{id: self.get_id(),\n                   node: ty_mac(spanned(lo, self.span.hi, e)),\n                   span: mk_sp(lo, self.span.hi)};\n           }\n@@ -457,7 +459,7 @@ class parser {\n         } else { self.fatal(~\"expected type\"); };\n \n         let sp = mk_sp(lo, self.last_span.hi);\n-        ret @{id: self.get_id(),\n+        return @{id: self.get_id(),\n               node: alt self.maybe_parse_fixed_vstore() {\n                 // Consider a fixed vstore suffix (/N or /_)\n                 none { t }\n@@ -596,7 +598,7 @@ class parser {\n             self.bump();\n             self.lit_from_token(tok)\n         };\n-        ret {node: lit, span: mk_sp(lo, self.last_span.hi)};\n+        return {node: lit, span: mk_sp(lo, self.last_span.hi)};\n     }\n \n     fn parse_path_without_tps() -> @path {\n@@ -639,7 +641,7 @@ class parser {\n         let lo = self.span.lo;\n         let path = self.parse_path_without_tps();\n         if colons && !self.eat(token::MOD_SEP) {\n-            ret path;\n+            return path;\n         }\n \n         // Parse the region parameter, if any, which will\n@@ -670,7 +672,7 @@ class parser {\n             }\n         };\n \n-        ret @{span: mk_sp(lo, tps.span.hi),\n+        return @{span: mk_sp(lo, tps.span.hi),\n               rp: rp,\n               types: tps.node with *path};\n     }\n@@ -691,16 +693,16 @@ class parser {\n         let i = self.parse_ident();\n         self.expect(sep);\n         let e = self.parse_expr();\n-        ret spanned(lo, e.span.hi, {mutbl: m, ident: i, expr: e});\n+        return spanned(lo, e.span.hi, {mutbl: m, ident: i, expr: e});\n     }\n \n     fn mk_expr(lo: uint, hi: uint, +node: expr_) -> @expr {\n-        ret @{id: self.get_id(), callee_id: self.get_id(),\n+        return @{id: self.get_id(), callee_id: self.get_id(),\n               node: node, span: mk_sp(lo, hi)};\n     }\n \n     fn mk_mac_expr(lo: uint, hi: uint, m: mac_) -> @expr {\n-        ret @{id: self.get_id(),\n+        return @{id: self.get_id(),\n               callee_id: self.get_id(),\n               node: expr_mac({node: m, span: mk_sp(lo, hi)}),\n               span: mk_sp(lo, hi)};\n@@ -711,12 +713,12 @@ class parser {\n         let lv_lit = @{node: lit_uint(i as u64, ty_u32),\n                        span: span};\n \n-        ret @{id: self.get_id(), callee_id: self.get_id(),\n+        return @{id: self.get_id(), callee_id: self.get_id(),\n               node: expr_lit(lv_lit), span: span};\n     }\n \n     fn mk_pexpr(lo: uint, hi: uint, node: expr_) -> pexpr {\n-        ret pexpr(self.mk_expr(lo, hi, node));\n+        return pexpr(self.mk_expr(lo, hi, node));\n     }\n \n     fn to_expr(e: pexpr) -> @expr {\n@@ -734,7 +736,7 @@ class parser {\n         let mut ex: expr_;\n \n         alt self.maybe_parse_dollar_mac() {\n-          some(x) {ret pexpr(self.mk_mac_expr(lo, self.span.hi, x));}\n+          some(x) {return pexpr(self.mk_mac_expr(lo, self.span.hi, x));}\n           _ {}\n         }\n \n@@ -744,7 +746,7 @@ class parser {\n                 hi = self.span.hi;\n                 self.bump();\n                 let lit = @spanned(lo, hi, lit_nil);\n-                ret self.mk_pexpr(lo, hi, expr_lit(lit));\n+                return self.mk_pexpr(lo, hi, expr_lit(lit));\n             }\n             let mut es = ~[self.parse_expr()];\n             while self.token == token::COMMA {\n@@ -758,37 +760,38 @@ class parser {\n             // This is so that wrappers around parse_bottom_expr()\n             // can tell whether the expression was parenthesized or not,\n             // which affects expr_is_complete().\n-            ret self.mk_pexpr(lo, hi, expr_tup(es));\n+            return self.mk_pexpr(lo, hi, expr_tup(es));\n         } else if self.token == token::LBRACE {\n             if self.looking_at_record_literal() {\n                 ex = self.parse_record_literal();\n                 hi = self.span.hi;\n             } else {\n                 self.bump();\n                 let blk = self.parse_block_tail(lo, default_blk);\n-                ret self.mk_pexpr(blk.span.lo, blk.span.hi, expr_block(blk));\n+                return self.mk_pexpr(blk.span.lo, blk.span.hi,\n+                                     expr_block(blk));\n             }\n         } else if token::is_bar(self.token) {\n-            ret pexpr(self.parse_lambda_expr());\n+            return pexpr(self.parse_lambda_expr());\n         } else if self.eat_keyword(~\"new\") {\n             self.expect(token::LPAREN);\n             let r = self.parse_expr();\n             self.expect(token::RPAREN);\n             let v = self.parse_expr();\n-            ret self.mk_pexpr(lo, self.span.hi,\n+            return self.mk_pexpr(lo, self.span.hi,\n                               expr_new(r, self.get_id(), v));\n         } else if self.eat_keyword(~\"if\") {\n-            ret pexpr(self.parse_if_expr());\n+            return pexpr(self.parse_if_expr());\n         } else if self.eat_keyword(~\"for\") {\n-            ret pexpr(self.parse_sugary_call_expr(~\"for\", expr_loop_body));\n+            return pexpr(self.parse_sugary_call_expr(~\"for\", expr_loop_body));\n         } else if self.eat_keyword(~\"do\") {\n-            ret pexpr(self.parse_sugary_call_expr(~\"do\", expr_do_body));\n+            return pexpr(self.parse_sugary_call_expr(~\"do\", expr_do_body));\n         } else if self.eat_keyword(~\"while\") {\n-            ret pexpr(self.parse_while_expr());\n+            return pexpr(self.parse_while_expr());\n         } else if self.eat_keyword(~\"loop\") {\n-            ret pexpr(self.parse_loop_expr());\n+            return pexpr(self.parse_loop_expr());\n         } else if self.eat_keyword(~\"alt\") || self.eat_keyword(~\"match\") {\n-            ret pexpr(self.parse_alt_expr());\n+            return pexpr(self.parse_alt_expr());\n         } else if self.eat_keyword(~\"fn\") {\n             let proto = self.parse_fn_ty_proto();\n             alt proto {\n@@ -798,11 +801,11 @@ class parser {\n               }\n               _ { /* fallthrough */ }\n             }\n-            ret pexpr(self.parse_fn_expr(proto));\n+            return pexpr(self.parse_fn_expr(proto));\n         } else if self.eat_keyword(~\"unchecked\") {\n-            ret pexpr(self.parse_block_expr(lo, unchecked_blk));\n+            return pexpr(self.parse_block_expr(lo, unchecked_blk));\n         } else if self.eat_keyword(~\"unsafe\") {\n-            ret pexpr(self.parse_block_expr(lo, unsafe_blk));\n+            return pexpr(self.parse_block_expr(lo, unsafe_blk));\n         } else if self.token == token::LBRACKET {\n             self.bump();\n             let mutbl = self.parse_mutability();\n@@ -813,7 +816,7 @@ class parser {\n             ex = expr_vec(es, mutbl);\n         } else if self.token == token::ELLIPSIS {\n             self.bump();\n-            ret pexpr(self.mk_mac_expr(lo, self.span.hi, mac_ellipsis));\n+            return pexpr(self.mk_mac_expr(lo, self.span.hi, mac_ellipsis));\n         } else if self.token == token::POUND {\n             let ex_ext = self.parse_syntax_ext();\n             hi = ex_ext.span.hi;\n@@ -875,7 +878,8 @@ class parser {\n                 };\n                 let hi = self.span.hi;\n \n-                ret pexpr(self.mk_mac_expr(lo, hi, mac_invoc_tt(pth, tts)));\n+                return pexpr(self.mk_mac_expr(\n+                    lo, hi, mac_invoc_tt(pth, tts)));\n             } else if self.token == token::LBRACE {\n                 // This might be a struct literal.\n                 if self.looking_at_record_literal() {\n@@ -895,7 +899,7 @@ class parser {\n                     hi = pth.span.hi;\n                     self.expect(token::RBRACE);\n                     ex = expr_struct(pth, fields);\n-                    ret self.mk_pexpr(lo, hi, ex);\n+                    return self.mk_pexpr(lo, hi, ex);\n                 }\n             }\n \n@@ -923,19 +927,19 @@ class parser {\n           _ { }\n         }\n \n-        ret self.mk_pexpr(lo, hi, ex);\n+        return self.mk_pexpr(lo, hi, ex);\n     }\n \n     fn parse_block_expr(lo: uint, blk_mode: blk_check_mode) -> @expr {\n         self.expect(token::LBRACE);\n         let blk = self.parse_block_tail(lo, blk_mode);\n-        ret self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk));\n+        return self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk));\n     }\n \n     fn parse_syntax_ext() -> @expr {\n         let lo = self.span.lo;\n         self.expect(token::POUND);\n-        ret self.parse_syntax_ext_naked(lo);\n+        return self.parse_syntax_ext_naked(lo);\n     }\n \n     fn parse_syntax_ext_naked(lo: uint) -> @expr {\n@@ -977,7 +981,7 @@ class parser {\n             let hi = self.last_span.lo;\n             b = some({span: mk_sp(lo,hi)});\n         }\n-        ret self.mk_mac_expr(lo, self.span.hi, mac_invoc(pth, e, b));\n+        return self.mk_mac_expr(lo, self.span.hi, mac_invoc(pth, e, b));\n     }\n \n     fn parse_dot_or_call_expr() -> pexpr {\n@@ -986,7 +990,7 @@ class parser {\n     }\n \n     fn permits_call() -> bool {\n-        ret self.restriction != RESTRICT_NO_CALL_EXPRS;\n+        return self.restriction != RESTRICT_NO_CALL_EXPRS;\n     }\n \n     fn parse_dot_or_call_expr_with(e0: pexpr) -> pexpr {\n@@ -1036,26 +1040,26 @@ class parser {\n                 e = self.mk_pexpr(lo, hi, expr_index(self.to_expr(e), ix));\n               }\n \n-              _ { ret e; }\n+              _ { return e; }\n             }\n         }\n-        ret e;\n+        return e;\n     }\n \n     fn parse_sep_and_zerok() -> (option<token::token>, bool) {\n         if self.token == token::BINOP(token::STAR)\n             || self.token == token::BINOP(token::PLUS) {\n             let zerok = self.token == token::BINOP(token::STAR);\n             self.bump();\n-            ret (none, zerok);\n+            return (none, zerok);\n         } else {\n             let sep = self.token;\n             self.bump();\n             if self.token == token::BINOP(token::STAR)\n                 || self.token == token::BINOP(token::PLUS) {\n                 let zerok = self.token == token::BINOP(token::STAR);\n                 self.bump();\n-                ret (some(sep), zerok);\n+                return (some(sep), zerok);\n             } else {\n                 self.fatal(~\"expected `*` or `+`\");\n             }\n@@ -1083,19 +1087,19 @@ class parser {\n                                           seq_sep_none(),\n                                           |p| p.parse_token_tree());\n                     let (s, z) = p.parse_sep_and_zerok();\n-                    ret tt_seq(mk_sp(sp.lo ,p.span.hi), seq.node, s, z);\n+                    return tt_seq(mk_sp(sp.lo ,p.span.hi), seq.node, s, z);\n                 } else {\n-                    ret tt_nonterminal(sp, p.parse_ident());\n+                    return tt_nonterminal(sp, p.parse_ident());\n                 }\n               }\n               _ { /* ok */ }\n             }\n             let res = tt_tok(p.span, p.token);\n             p.bump();\n-            ret res;\n+            return res;\n         }\n \n-        ret alt self.token {\n+        return alt self.token {\n           token::LPAREN | token::LBRACE | token::LBRACKET {\n             let ket = token::flip_delimiter(self.token);\n             tt_delim(vec::append(\n@@ -1112,7 +1116,8 @@ class parser {\n \n     fn parse_matchers() -> ~[matcher] {\n         let name_idx = @mut 0u;\n-        ret self.parse_matcher_subseq(name_idx, token::LBRACE, token::RBRACE);\n+        return self.parse_matcher_subseq(\n+            name_idx, token::LBRACE, token::RBRACE);\n     }\n \n \n@@ -1134,7 +1139,7 @@ class parser {\n \n         self.bump();\n \n-        ret ret_val;\n+        return ret_val;\n     }\n \n     fn parse_matcher(name_idx: @mut uint) -> matcher {\n@@ -1165,7 +1170,7 @@ class parser {\n             m\n         };\n \n-        ret spanned(lo, self.span.hi, m);\n+        return spanned(lo, self.span.hi, m);\n     }\n \n \n@@ -1211,7 +1216,7 @@ class parser {\n                   _ { expr_addr_of(m, e) }\n                 };\n               }\n-              _ { ret self.parse_dot_or_call_expr(); }\n+              _ { return self.parse_dot_or_call_expr(); }\n             }\n           }\n           token::AT {\n@@ -1238,29 +1243,29 @@ class parser {\n               _ { expr_unary(uniq(m), e) }\n             };\n           }\n-          _ { ret self.parse_dot_or_call_expr(); }\n+          _ { return self.parse_dot_or_call_expr(); }\n         }\n-        ret self.mk_pexpr(lo, hi, ex);\n+        return self.mk_pexpr(lo, hi, ex);\n     }\n \n \n     fn parse_binops() -> @expr {\n-        ret self.parse_more_binops(self.parse_prefix_expr(), 0u);\n+        return self.parse_more_binops(self.parse_prefix_expr(), 0u);\n     }\n \n     fn parse_more_binops(plhs: pexpr, min_prec: uint) ->\n         @expr {\n         let lhs = self.to_expr(plhs);\n-        if self.expr_is_complete(plhs) { ret lhs; }\n+        if self.expr_is_complete(plhs) { return lhs; }\n         let peeked = self.token;\n         if peeked == token::BINOP(token::OR) &&\n             (self.restriction == RESTRICT_NO_BAR_OP ||\n              self.restriction == RESTRICT_NO_BAR_OR_DOUBLEBAR_OP) {\n-            ret lhs;\n+            return lhs;\n         }\n         if peeked == token::OROR &&\n             self.restriction == RESTRICT_NO_BAR_OR_DOUBLEBAR_OP {\n-            ret lhs;\n+            return lhs;\n         }\n         let cur_opt   = token_to_binop(peeked);\n         alt cur_opt {\n@@ -1273,7 +1278,7 @@ class parser {\n                 self.get_id(); // see ast_util::op_expr_callee_id\n                 let bin = self.mk_pexpr(lhs.span.lo, rhs.span.hi,\n                                         expr_binary(cur_op, lhs, rhs));\n-                ret self.parse_more_binops(bin, min_prec);\n+                return self.parse_more_binops(bin, min_prec);\n             }\n           }\n           _ {}\n@@ -1282,9 +1287,9 @@ class parser {\n             let rhs = self.parse_ty(true);\n             let _as =\n                 self.mk_pexpr(lhs.span.lo, rhs.span.hi, expr_cast(lhs, rhs));\n-            ret self.parse_more_binops(_as, min_prec);\n+            return self.parse_more_binops(_as, min_prec);\n         }\n-        ret lhs;\n+        return lhs;\n     }\n \n     fn parse_assign_expr() -> @expr {\n@@ -1294,7 +1299,7 @@ class parser {\n           token::EQ {\n             self.bump();\n             let rhs = self.parse_expr();\n-            ret self.mk_expr(lo, rhs.span.hi, expr_assign(lhs, rhs));\n+            return self.mk_expr(lo, rhs.span.hi, expr_assign(lhs, rhs));\n           }\n           token::BINOPEQ(op) {\n             self.bump();\n@@ -1313,21 +1318,22 @@ class parser {\n               token::SHR { aop = shr; }\n             }\n             self.get_id(); // see ast_util::op_expr_callee_id\n-            ret self.mk_expr(lo, rhs.span.hi, expr_assign_op(aop, lhs, rhs));\n+            return self.mk_expr(lo, rhs.span.hi,\n+                                expr_assign_op(aop, lhs, rhs));\n           }\n           token::LARROW {\n             self.bump();\n             let rhs = self.parse_expr();\n-            ret self.mk_expr(lo, rhs.span.hi, expr_move(lhs, rhs));\n+            return self.mk_expr(lo, rhs.span.hi, expr_move(lhs, rhs));\n           }\n           token::DARROW {\n             self.bump();\n             let rhs = self.parse_expr();\n-            ret self.mk_expr(lo, rhs.span.hi, expr_swap(lhs, rhs));\n+            return self.mk_expr(lo, rhs.span.hi, expr_swap(lhs, rhs));\n           }\n           _ {/* fall through */ }\n         }\n-        ret lhs;\n+        return lhs;\n     }\n \n     fn parse_if_expr() -> @expr {\n@@ -1342,7 +1348,7 @@ class parser {\n             hi = elexpr.span.hi;\n         }\n         let q = {cond: cond, then: thn, els: els, lo: lo, hi: hi};\n-        ret self.mk_expr(q.lo, q.hi, expr_if(q.cond, q.then, q.els));\n+        return self.mk_expr(q.lo, q.hi, expr_if(q.cond, q.then, q.els));\n     }\n \n     fn parse_fn_expr(proto: proto) -> @expr {\n@@ -1355,7 +1361,7 @@ class parser {\n                                |p| p.parse_arg_or_capture_item());\n \n         let body = self.parse_block();\n-        ret self.mk_expr(lo, body.span.hi,\n+        return self.mk_expr(lo, body.span.hi,\n                          expr_fn(proto, decl, body, capture_clause));\n     }\n \n@@ -1406,16 +1412,16 @@ class parser {\n                          id: self.get_id(), rules: default_blk};\n         let fakeblock = spanned(body.span.lo, body.span.hi,\n                                 fakeblock);\n-        ret self.mk_expr(lo, body.span.hi,\n+        return self.mk_expr(lo, body.span.hi,\n                          expr_fn_block(decl, fakeblock, captures));\n     }\n \n     fn parse_else_expr() -> @expr {\n         if self.eat_keyword(~\"if\") {\n-            ret self.parse_if_expr();\n+            return self.parse_if_expr();\n         } else {\n             let blk = self.parse_block();\n-            ret self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk));\n+            return self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk));\n         }\n     }\n \n@@ -1464,14 +1470,14 @@ class parser {\n         let cond = self.parse_expr();\n         let body = self.parse_block_no_value();\n         let mut hi = body.span.hi;\n-        ret self.mk_expr(lo, hi, expr_while(cond, body));\n+        return self.mk_expr(lo, hi, expr_while(cond, body));\n     }\n \n     fn parse_loop_expr() -> @expr {\n         let lo = self.last_span.lo;\n         let body = self.parse_block_no_value();\n         let mut hi = body.span.hi;\n-        ret self.mk_expr(lo, hi, expr_loop(body));\n+        return self.mk_expr(lo, hi, expr_loop(body));\n     }\n \n     // For distingishing between record literals and blocks\n@@ -1505,7 +1511,7 @@ class parser {\n             vec::push(fields, self.parse_field(token::COLON));\n         }\n         self.expect(token::RBRACE);\n-        ret expr_rec(fields, base);\n+        return expr_rec(fields, base);\n     }\n \n     fn parse_alt_expr() -> @expr {\n@@ -1547,40 +1553,40 @@ class parser {\n         }\n         let mut hi = self.span.hi;\n         self.bump();\n-        ret self.mk_expr(lo, hi, expr_alt(discriminant, arms, mode));\n+        return self.mk_expr(lo, hi, expr_alt(discriminant, arms, mode));\n     }\n \n     fn parse_expr() -> @expr {\n-        ret self.parse_expr_res(UNRESTRICTED);\n+        return self.parse_expr_res(UNRESTRICTED);\n     }\n \n     fn parse_expr_res(r: restriction) -> @expr {\n         let old = self.restriction;\n         self.restriction = r;\n         let e = self.parse_assign_expr();\n         self.restriction = old;\n-        ret e;\n+        return e;\n     }\n \n     fn parse_initializer() -> option<initializer> {\n         alt self.token {\n           token::EQ {\n             self.bump();\n-            ret some({op: init_assign, expr: self.parse_expr()});\n+            return some({op: init_assign, expr: self.parse_expr()});\n           }\n           token::LARROW {\n             self.bump();\n-            ret some({op: init_move, expr: self.parse_expr()});\n+            return some({op: init_move, expr: self.parse_expr()});\n           }\n           // Now that the the channel is the first argument to receive,\n           // combining it with an initializer doesn't really make sense.\n           // case (token::RECV) {\n           //     self.bump();\n-          //     ret some(rec(op = init_recv,\n+          //     return some(rec(op = init_recv,\n           //                  expr = self.parse_expr()));\n           // }\n           _ {\n-            ret none;\n+            return none;\n           }\n         }\n     }\n@@ -1590,7 +1596,7 @@ class parser {\n         loop {\n             vec::push(pats, self.parse_pat(true));\n             if self.token == token::BINOP(token::OR) { self.bump(); }\n-            else { ret pats; }\n+            else { return pats; }\n         };\n     }\n \n@@ -1779,7 +1785,7 @@ class parser {\n             }\n           }\n         }\n-        ret @{id: self.get_id(), node: pat, span: mk_sp(lo, hi)};\n+        return @{id: self.get_id(), node: pat, span: mk_sp(lo, hi)};\n     }\n \n     fn parse_local(is_mutbl: bool,\n@@ -1791,7 +1797,7 @@ class parser {\n                        span: mk_sp(lo, lo)};\n         if self.eat(token::COLON) { ty = self.parse_ty(false); }\n         let init = if allow_init { self.parse_initializer() } else { none };\n-        ret @spanned(lo, self.last_span.hi,\n+        return @spanned(lo, self.last_span.hi,\n                      {is_mutbl: is_mutbl, ty: ty, pat: pat,\n                       init: init, id: self.get_id()});\n     }\n@@ -1803,7 +1809,7 @@ class parser {\n         while self.eat(token::COMMA) {\n             vec::push(locals, self.parse_local(is_mutbl, true));\n         }\n-        ret @spanned(lo, self.last_span.hi, decl_local(locals));\n+        return @spanned(lo, self.last_span.hi, decl_local(locals));\n     }\n \n     /* assumes \"let\" token has already been consumed */\n@@ -1819,7 +1825,7 @@ class parser {\n         let name = self.parse_ident();\n         self.expect(token::COLON);\n         let ty = self.parse_ty(false);\n-        ret @{node: instance_var(name, ty, is_mutbl, self.get_id(), pr),\n+        return @{node: instance_var(name, ty, is_mutbl, self.get_id(), pr),\n               span: mk_sp(lo, self.last_span.hi)};\n     }\n \n@@ -1836,14 +1842,15 @@ class parser {\n             check_expected_item(self, first_item_attrs);\n             self.expect_keyword(~\"let\");\n             let decl = self.parse_let();\n-            ret @spanned(lo, decl.span.hi, stmt_decl(decl, self.get_id()));\n+            return @spanned(lo, decl.span.hi, stmt_decl(decl, self.get_id()));\n         } else {\n             let mut item_attrs;\n             alt self.parse_outer_attrs_or_ext(first_item_attrs) {\n               none { item_attrs = ~[]; }\n               some(left(attrs)) { item_attrs = attrs; }\n               some(right(ext)) {\n-                ret @spanned(lo, ext.span.hi, stmt_expr(ext, self.get_id()));\n+                return @spanned(lo, ext.span.hi,\n+                                stmt_expr(ext, self.get_id()));\n               }\n             }\n \n@@ -1853,7 +1860,7 @@ class parser {\n               some(i) {\n                 let mut hi = i.span.hi;\n                 let decl = @spanned(lo, hi, decl_item(i));\n-                ret @spanned(lo, hi, stmt_decl(decl, self.get_id()));\n+                return @spanned(lo, hi, stmt_decl(decl, self.get_id()));\n               }\n               none() { /* fallthrough */ }\n             }\n@@ -1862,22 +1869,22 @@ class parser {\n \n             // Remainder are line-expr stmts.\n             let e = self.parse_expr_res(RESTRICT_STMT_EXPR);\n-            ret @spanned(lo, e.span.hi, stmt_expr(e, self.get_id()));\n+            return @spanned(lo, e.span.hi, stmt_expr(e, self.get_id()));\n         }\n     }\n \n     fn expr_is_complete(e: pexpr) -> bool {\n         log(debug, (~\"expr_is_complete\", self.restriction,\n                     print::pprust::expr_to_str(*e),\n                     classify::expr_requires_semi_to_be_stmt(*e)));\n-        ret self.restriction == RESTRICT_STMT_EXPR &&\n+        return self.restriction == RESTRICT_STMT_EXPR &&\n             !classify::expr_requires_semi_to_be_stmt(*e);\n     }\n \n     fn parse_block() -> blk {\n         let (attrs, blk) = self.parse_inner_attrs_and_block(false);\n         assert vec::is_empty(attrs);\n-        ret blk;\n+        return blk;\n     }\n \n     fn parse_inner_attrs_and_block(parse_attrs: bool)\n@@ -1897,25 +1904,25 @@ class parser {\n             self.expect(token::LBRACE);\n             let {inner, next} = maybe_parse_inner_attrs_and_next(self,\n                                                                  parse_attrs);\n-            ret (inner, self.parse_block_tail_(lo, unchecked_blk, next));\n+            return (inner, self.parse_block_tail_(lo, unchecked_blk, next));\n         } else if self.eat_keyword(~\"unsafe\") {\n             self.expect(token::LBRACE);\n             let {inner, next} = maybe_parse_inner_attrs_and_next(self,\n                                                                  parse_attrs);\n-            ret (inner, self.parse_block_tail_(lo, unsafe_blk, next));\n+            return (inner, self.parse_block_tail_(lo, unsafe_blk, next));\n         } else {\n             self.expect(token::LBRACE);\n             let {inner, next} = maybe_parse_inner_attrs_and_next(self,\n                                                                  parse_attrs);\n-            ret (inner, self.parse_block_tail_(lo, default_blk, next));\n+            return (inner, self.parse_block_tail_(lo, default_blk, next));\n         }\n     }\n \n     fn parse_block_no_value() -> blk {\n         // We parse blocks that cannot have a value the same as any other\n         // block; the type checker will make sure that the tail expression (if\n         // any) has unit type.\n-        ret self.parse_block();\n+        return self.parse_block();\n     }\n \n     // Precondition: already parsed the '{' or '#{'\n@@ -1983,7 +1990,7 @@ class parser {\n         self.bump();\n         let bloc = {view_items: view_items, stmts: stmts, expr: expr,\n                     id: self.get_id(), rules: s};\n-        ret spanned(lo, hi, bloc);\n+        return spanned(lo, hi, bloc);\n     }\n \n     fn parse_ty_param() -> ty_param {\n@@ -2003,7 +2010,7 @@ class parser {\n                     push(bounds, bound_trait(self.parse_ty(false))); }\n             }\n         }\n-        ret {ident: ident, id: self.get_id(), bounds: @bounds};\n+        return {ident: ident, id: self.get_id(), bounds: @bounds};\n     }\n \n     fn parse_ty_params() -> ~[ty_param] {\n@@ -2025,7 +2032,7 @@ class parser {\n         let capture_clause = @either::rights(args_or_capture_items);\n \n         let (ret_style, ret_ty) = self.parse_ret_ty();\n-        ret ({inputs: inputs,\n+        return ({inputs: inputs,\n               output: ret_ty,\n               purity: purity,\n               cf: ret_style}, capture_clause);\n@@ -2183,7 +2190,7 @@ class parser {\n         } else {\n             @{id: self.get_id(), node: ty_infer, span: self.span}\n         };\n-        ret ({inputs: either::lefts(inputs_captures),\n+        return ({inputs: either::lefts(inputs_captures),\n               output: output,\n               purity: impure_fn,\n               cf: return_val},\n@@ -2193,13 +2200,13 @@ class parser {\n     fn parse_fn_header() -> {ident: ident, tps: ~[ty_param]} {\n         let id = self.parse_value_ident();\n         let ty_params = self.parse_ty_params();\n-        ret {ident: id, tps: ty_params};\n+        return {ident: id, tps: ty_params};\n     }\n \n     fn mk_item(lo: uint, hi: uint, +ident: ident,\n                +node: item_, vis: visibility,\n                +attrs: ~[attribute]) -> @item {\n-        ret @{ident: ident,\n+        return @{ident: ident,\n               attrs: attrs,\n               id: self.get_id(),\n               node: node,\n@@ -2441,10 +2448,10 @@ class parser {\n                 !self.token_is_pound_or_doc_comment(self.token) {\n             let a_var = self.parse_instance_var(vis);\n             self.expect(token::SEMI);\n-            ret a_var;\n+            return a_var;\n         } else {\n             let m = self.parse_method(vis);\n-            ret @{node: class_method(m), span: m.span};\n+            return @{node: class_method(m), span: m.span};\n         }\n     }\n \n@@ -2475,21 +2482,21 @@ class parser {\n                 vec::push(results, self.parse_single_class_item(private));\n             }\n             self.bump();\n-            ret members(results);\n+            return members(results);\n         }\n \n         let attrs = self.parse_outer_attributes();\n \n         if self.eat_keyword(~\"new\") {\n             // result type is always the type of the class\n-           ret self.parse_ctor(attrs, ty_path(class_name_with_tps,\n+           return self.parse_ctor(attrs, ty_path(class_name_with_tps,\n                                         self.get_id()));\n         }\n         else if self.eat_keyword(~\"drop\") {\n-           ret self.parse_dtor(attrs);\n+           return self.parse_dtor(attrs);\n         }\n         else {\n-           ret members(~[self.parse_single_class_item(public)]);\n+           return members(~[self.parse_single_class_item(public)]);\n         }\n     }\n \n@@ -2529,7 +2536,7 @@ class parser {\n             self.fatal(~\"expected item\");\n         }\n \n-        ret {view_items: view_items, items: items};\n+        return {view_items: view_items, items: items};\n     }\n \n     fn parse_item_const() -> item_info {\n@@ -2558,7 +2565,7 @@ class parser {\n         let (decl, _) = self.parse_fn_decl(purity, |p| p.parse_arg());\n         let mut hi = self.span.hi;\n         self.expect(token::SEMI);\n-        ret @{ident: t.ident,\n+        return @{ident: t.ident,\n               attrs: attrs,\n               node: foreign_item_fn(decl, t.tps),\n               id: self.get_id(),\n@@ -2595,7 +2602,7 @@ class parser {\n             initial_attrs = ~[];\n             vec::push(items, self.parse_foreign_item(attrs));\n         }\n-        ret {view_items: view_items,\n+        return {view_items: view_items,\n              items: items};\n     }\n \n@@ -2616,7 +2623,7 @@ class parser {\n     fn parse_type_decl() -> {lo: uint, ident: ident} {\n         let lo = self.last_span.lo;\n         let id = self.parse_ident();\n-        ret {lo: lo, ident: id};\n+        return {lo: lo, ident: id};\n     }\n \n     fn parse_item_type() -> item_info {\n@@ -2654,7 +2661,7 @@ class parser {\n                          id: self.get_id(),\n                          disr_expr: none,\n                          vis: public});\n-            ret (id, item_enum(~[variant], ty_params), none);\n+            return (id, item_enum(~[variant], ty_params), none);\n         }\n         self.expect(token::LBRACE);\n \n@@ -2787,7 +2794,7 @@ class parser {\n                                       hi: self.span.hi,\n                                       expn_info: none}};\n             (id, item_mac(m), none)\n-        } else { ret none; };\n+        } else { return none; };\n         some(self.mk_item(lo, self.last_span.hi, ident, item_, vis,\n                           alt extra_attrs {\n                               some(as) { vec::append(attrs, as) }\n@@ -2798,7 +2805,7 @@ class parser {\n     fn parse_use() -> view_item_ {\n         let ident = self.parse_ident();\n         let metadata = self.parse_optional_meta();\n-        ret view_item_use(ident, metadata, self.get_id());\n+        return view_item_use(ident, metadata, self.get_id());\n     }\n \n     fn parse_view_path() -> @view_path {\n@@ -2818,7 +2825,7 @@ class parser {\n             }\n             let path = @{span: mk_sp(lo, self.span.hi), global: false,\n                          idents: path, rp: none, types: ~[]};\n-            ret @spanned(lo, self.span.hi,\n+            return @spanned(lo, self.span.hi,\n                          view_path_simple(first_ident, path, self.get_id()));\n           }\n \n@@ -2843,7 +2850,7 @@ class parser {\n                     let path = @{span: mk_sp(lo, self.span.hi),\n                                  global: false, idents: path,\n                                  rp: none, types: ~[]};\n-                    ret @spanned(lo, self.span.hi,\n+                    return @spanned(lo, self.span.hi,\n                                  view_path_list(path, idents, self.get_id()));\n                   }\n \n@@ -2853,7 +2860,7 @@ class parser {\n                     let path = @{span: mk_sp(lo, self.span.hi),\n                                  global: false, idents: path,\n                                  rp: none, types: ~[]};\n-                    ret @spanned(lo, self.span.hi,\n+                    return @spanned(lo, self.span.hi,\n                                  view_path_glob(path, self.get_id()));\n                   }\n \n@@ -2866,7 +2873,7 @@ class parser {\n         let last = path[vec::len(path) - 1u];\n         let path = @{span: mk_sp(lo, self.span.hi), global: false,\n                      idents: path, rp: none, types: ~[]};\n-        ret @spanned(lo, self.span.hi,\n+        return @spanned(lo, self.span.hi,\n                      view_path_simple(last, path, self.get_id()));\n     }\n \n@@ -2876,7 +2883,7 @@ class parser {\n             self.bump();\n             vec::push(vp, self.parse_view_path());\n         }\n-        ret vp;\n+        return vp;\n     }\n \n     fn is_view_item() -> bool {\n@@ -2922,7 +2929,7 @@ class parser {\n         let crate_attrs = self.parse_inner_attrs_and_next();\n         let first_item_outer_attrs = crate_attrs.next;\n         let m = self.parse_mod_items(token::EOF, first_item_outer_attrs);\n-        ret @spanned(lo, self.span.lo,\n+        return @spanned(lo, self.span.lo,\n                      {directives: ~[],\n                       module: m,\n                       attrs: crate_attrs.inner,\n@@ -2968,7 +2975,7 @@ class parser {\n               token::SEMI {\n                 let mut hi = self.span.hi;\n                 self.bump();\n-                ret spanned(lo, hi, cdir_src_mod(id, outer_attrs));\n+                return spanned(lo, hi, cdir_src_mod(id, outer_attrs));\n               }\n               // mod x = \"foo_dir\" { ...directives... }\n               token::LBRACE {\n@@ -2980,15 +2987,15 @@ class parser {\n                                                         next_outer_attr);\n                 let mut hi = self.span.hi;\n                 self.expect(token::RBRACE);\n-                ret spanned(lo, hi,\n+                return spanned(lo, hi,\n                             cdir_dir_mod(id, cdirs, mod_attrs));\n               }\n               _ { self.unexpected(); }\n             }\n         } else if self.is_view_item() {\n             let vi = self.parse_view_item(outer_attrs);\n-            ret spanned(lo, vi.span.hi, cdir_view_item(vi));\n-        } else { ret self.fatal(~\"expected crate directive\"); }\n+            return spanned(lo, vi.span.hi, cdir_view_item(vi));\n+        } else { return self.fatal(~\"expected crate directive\"); }\n     }\n \n     fn parse_crate_directives(term: token::token,\n@@ -3013,7 +3020,7 @@ class parser {\n             vec::push(cdirs, cdir);\n             first_outer_attr = ~[];\n         }\n-        ret cdirs;\n+        return cdirs;\n     }\n }\n //"}, {"sha": "9d3bbef2cd415443f9d93e66d3a0c68eae9c5aa5", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -331,7 +331,7 @@ fn restricted_keyword_table() -> hashmap<~str, ()> {\n         ~\"new\",\n         ~\"owned\",\n         ~\"pure\",\n-        ~\"ref\", ~\"ret\", ~\"return\",\n+        ~\"ref\", ~\"return\",\n         ~\"struct\",\n         ~\"true\", ~\"trait\", ~\"type\",\n         ~\"unchecked\", ~\"unsafe\","}, {"sha": "9228ea2e0d515238ce5759c79dbb9d3172a72a8e", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -63,11 +63,11 @@ enum token { STRING(@~str, int), BREAK(break_t), BEGIN(begin_t), END, EOF, }\n \n fn tok_str(++t: token) -> ~str {\n     alt t {\n-      STRING(s, len) { ret fmt!{\"STR(%s,%d)\", *s, len}; }\n-      BREAK(_) { ret ~\"BREAK\"; }\n-      BEGIN(_) { ret ~\"BEGIN\"; }\n-      END { ret ~\"END\"; }\n-      EOF { ret ~\"EOF\"; }\n+      STRING(s, len) { return fmt!{\"STR(%s,%d)\", *s, len}; }\n+      BREAK(_) { return ~\"BREAK\"; }\n+      BEGIN(_) { return ~\"BEGIN\"; }\n+      END { return ~\"END\"; }\n+      EOF { return ~\"EOF\"; }\n     }\n }\n \n@@ -86,7 +86,7 @@ fn buf_str(toks: ~[mut token], szs: ~[mut int], left: uint, right: uint,\n         i %= n;\n     }\n     s += ~\"]\";\n-    ret s;\n+    return s;\n }\n \n enum print_stack_break { fits, broken(breaks), }\n@@ -333,19 +333,19 @@ impl printer for printer {\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n         } else { self.top += self.buf_len - 1u; self.top %= self.buf_len; }\n-        ret x;\n+        return x;\n     }\n     fn scan_top() -> uint {\n         assert (!self.scan_stack_empty);\n-        ret self.scan_stack[self.top];\n+        return self.scan_stack[self.top];\n     }\n     fn scan_pop_bottom() -> uint {\n         assert (!self.scan_stack_empty);\n         let x = self.scan_stack[self.bottom];\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n         } else { self.bottom += 1u; self.bottom %= self.buf_len; }\n-        ret x;\n+        return x;\n     }\n     fn advance_right() {\n         self.right += 1u;\n@@ -517,10 +517,10 @@ fn space(p: printer) { spaces(p, 1u); }\n fn hardbreak(p: printer) { spaces(p, size_infinity as uint); }\n \n fn hardbreak_tok_offset(off: int) -> token {\n-    ret BREAK({offset: off, blank_space: size_infinity});\n+    return BREAK({offset: off, blank_space: size_infinity});\n }\n \n-fn hardbreak_tok() -> token { ret hardbreak_tok_offset(0); }\n+fn hardbreak_tok() -> token { return hardbreak_tok_offset(0); }\n \n \n //"}, {"sha": "6a2b5c787de0718f7b3b64884a86901703225d22", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -22,7 +22,7 @@ type pp_ann = {pre: fn@(ann_node), post: fn@(ann_node)};\n \n fn no_ann() -> pp_ann {\n     fn ignore(_node: ann_node) { }\n-    ret {pre: ignore, post: ignore};\n+    return {pre: ignore, post: ignore};\n }\n \n type ps =\n@@ -47,7 +47,7 @@ fn end(s: ps) {\n }\n \n fn rust_printer(writer: io::writer) -> ps {\n-    ret @{s: pp::mk_printer(writer, default_columns),\n+    return @{s: pp::mk_printer(writer, default_columns),\n           cm: none::<codemap>,\n           intr: @interner::mk::<@~str>(|x| str::hash(*x),\n                                        |x,y| str::eq(*x, *y)),\n@@ -95,24 +95,26 @@ fn print_crate_(s: ps, &&crate: @ast::crate) {\n     eof(s.s);\n }\n \n-fn ty_to_str(ty: @ast::ty) -> ~str { ret to_str(ty, print_type); }\n+fn ty_to_str(ty: @ast::ty) -> ~str { return to_str(ty, print_type); }\n \n-fn pat_to_str(pat: @ast::pat) -> ~str { ret to_str(pat, print_pat); }\n+fn pat_to_str(pat: @ast::pat) -> ~str { return to_str(pat, print_pat); }\n \n-fn expr_to_str(e: @ast::expr) -> ~str { ret to_str(e, print_expr); }\n+fn expr_to_str(e: @ast::expr) -> ~str { return to_str(e, print_expr); }\n \n-fn stmt_to_str(s: ast::stmt) -> ~str { ret to_str(s, print_stmt); }\n+fn stmt_to_str(s: ast::stmt) -> ~str { return to_str(s, print_stmt); }\n \n-fn item_to_str(i: @ast::item) -> ~str { ret to_str(i, print_item); }\n+fn item_to_str(i: @ast::item) -> ~str { return to_str(i, print_item); }\n \n-fn attr_to_str(i: ast::attribute) -> ~str { ret to_str(i, print_attribute); }\n+fn attr_to_str(i: ast::attribute) -> ~str {\n+    return to_str(i, print_attribute);\n+}\n \n fn typarams_to_str(tps: ~[ast::ty_param]) -> ~str {\n-    ret to_str(tps, print_type_params)\n+    return to_str(tps, print_type_params)\n }\n \n fn path_to_str(&&p: @ast::path) -> ~str {\n-    ret to_str(p, |a,b| print_path(a, b, false));\n+    return to_str(p, |a,b| print_path(a, b, false));\n }\n \n fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n@@ -152,15 +154,15 @@ fn block_to_str(blk: ast::blk) -> ~str {\n }\n \n fn meta_item_to_str(mi: ast::meta_item) -> ~str {\n-    ret to_str(@mi, print_meta_item);\n+    return to_str(@mi, print_meta_item);\n }\n \n fn attribute_to_str(attr: ast::attribute) -> ~str {\n-    ret to_str(attr, print_attribute);\n+    return to_str(attr, print_attribute);\n }\n \n fn variant_to_str(var: ast::variant) -> ~str {\n-    ret to_str(var, print_variant);\n+    return to_str(var, print_variant);\n }\n \n #[test]\n@@ -228,14 +230,14 @@ fn is_end(s: ps) -> bool {\n }\n \n fn is_bol(s: ps) -> bool {\n-    ret s.s.last_token() == pp::EOF ||\n+    return s.s.last_token() == pp::EOF ||\n             s.s.last_token() == pp::hardbreak_tok();\n }\n \n fn in_cbox(s: ps) -> bool {\n     let len = s.boxes.len();\n-    if len == 0u { ret false; }\n-    ret s.boxes[len - 1u] == pp::consistent;\n+    if len == 0u { return false; }\n+    return s.boxes[len - 1u] == pp::consistent;\n }\n \n fn hardbreak_if_not_bol(s: ps) { if !is_bol(s) { hardbreak(s.s); } }\n@@ -294,7 +296,7 @@ fn commasep_cmnt<IN>(s: ps, b: breaks, elts: ~[IN], op: fn(ps, IN),\n }\n \n fn commasep_exprs(s: ps, b: breaks, exprs: ~[@ast::expr]) {\n-    fn expr_span(&&expr: @ast::expr) -> codemap::span { ret expr.span; }\n+    fn expr_span(&&expr: @ast::expr) -> codemap::span { return expr.span; }\n     commasep_cmnt(s, b, exprs, print_expr, expr_span);\n }\n \n@@ -365,7 +367,7 @@ fn print_type_ex(s: ps, &&ty: @ast::ty, print_colons: bool) {\n             print_type(s, f.node.mt.ty);\n             end(s);\n         }\n-        fn get_span(f: ast::ty_field) -> codemap::span { ret f.span; }\n+        fn get_span(f: ast::ty_field) -> codemap::span { return f.span; }\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n         word(s.s, ~\",}\");\n       }\n@@ -805,7 +807,7 @@ fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n     s.ann.post(ann_node);\n }\n \n-// ret and fail, without arguments cannot appear is the discriminant of if,\n+// return and fail, without arguments cannot appear is the discriminant of if,\n // alt, do, & while unambiguously without being parenthesized\n fn print_maybe_parens_discrim(s: ps, e: @ast::expr) {\n     let disambig = alt e.node {\n@@ -909,7 +911,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         print_expr(s, field.node.expr);\n         end(s);\n     }\n-    fn get_span(field: ast::field) -> codemap::span { ret field.span; }\n+    fn get_span(field: ast::field) -> codemap::span { return field.span; }\n \n     maybe_print_comment(s, expr.span.lo);\n     ibox(s, indent_unit);\n@@ -1162,7 +1164,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       ast::expr_break { word(s.s, ~\"break\"); }\n       ast::expr_again { word(s.s, ~\"again\"); }\n       ast::expr_ret(result) {\n-        word(s.s, ~\"ret\");\n+        word(s.s, ~\"return\");\n         alt result {\n           some(expr) { word(s.s, ~\" \"); print_expr(s, expr); }\n           _ { }\n@@ -1339,7 +1341,7 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n             print_pat(s, f.pat);\n             end(s);\n         }\n-        fn get_span(f: ast::field_pat) -> codemap::span { ret f.pat.span; }\n+        fn get_span(f: ast::field_pat) -> codemap::span { return f.pat.span; }\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n         if etc {\n             if vec::len(fields) != 0u { word_space(s, ~\",\"); }\n@@ -1603,10 +1605,10 @@ fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n fn maybe_print_trailing_comment(s: ps, span: codemap::span,\n                                 next_pos: option<uint>) {\n     let mut cm;\n-    alt s.cm { some(ccm) { cm = ccm; } _ { ret; } }\n+    alt s.cm { some(ccm) { cm = ccm; } _ { return; } }\n     alt next_comment(s) {\n       some(cmnt) {\n-        if cmnt.style != comments::trailing { ret; }\n+        if cmnt.style != comments::trailing { return; }\n         let span_line = codemap::lookup_char_pos(cm, span.hi);\n         let comment_line = codemap::lookup_char_pos(cm, cmnt.pos);\n         let mut next = cmnt.pos + 1u;\n@@ -1638,7 +1640,7 @@ fn print_literal(s: ps, &&lit: @ast::lit) {\n     alt next_lit(s, lit.span.lo) {\n       some(ltrl) {\n         word(s.s, ltrl.lit);\n-        ret;\n+        return;\n       }\n       _ {}\n     }\n@@ -1680,20 +1682,20 @@ fn print_literal(s: ps, &&lit: @ast::lit) {\n     }\n }\n \n-fn lit_to_str(l: @ast::lit) -> ~str { ret to_str(l, print_literal); }\n+fn lit_to_str(l: @ast::lit) -> ~str { return to_str(l, print_literal); }\n \n fn next_lit(s: ps, pos: uint) -> option<comments::lit> {\n     alt s.literals {\n       some(lits) {\n         while s.cur_lit < vec::len(lits) {\n             let ltrl = lits[s.cur_lit];\n-            if ltrl.pos > pos { ret none; }\n+            if ltrl.pos > pos { return none; }\n             s.cur_lit += 1u;\n-            if ltrl.pos == pos { ret some(ltrl); }\n+            if ltrl.pos == pos { return some(ltrl); }\n         }\n-        ret none;\n+        return none;\n       }\n-      _ { ret none; }\n+      _ { return none; }\n     }\n }\n \n@@ -1773,10 +1775,10 @@ fn next_comment(s: ps) -> option<comments::cmnt> {\n     alt s.comments {\n       some(cmnts) {\n         if s.cur_cmnt < vec::len(cmnts) {\n-            ret some(cmnts[s.cur_cmnt]);\n-        } else { ret none::<comments::cmnt>; }\n+            return some(cmnts[s.cur_cmnt]);\n+        } else { return none::<comments::cmnt>; }\n       }\n-      _ { ret none::<comments::cmnt>; }\n+      _ { return none::<comments::cmnt>; }\n     }\n }\n \n@@ -1804,7 +1806,7 @@ fn print_purity(s: ps, p: ast::purity) {\n }\n \n fn proto_to_str(p: ast::proto) -> ~str {\n-    ret alt p {\n+    return alt p {\n       ast::proto_bare { ~\"extern fn\" }\n       ast::proto_any { ~\"fn\" }\n       ast::proto_block { ~\"fn&\" }"}, {"sha": "5c2f78bce3b23ced91a0e6f33b9f6f48e9c20659", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -15,7 +15,7 @@ fn mk<T: const copy>(hasher: hashfn<T>, eqer: eqfn<T>) -> interner<T> {\n     let m = map::hashmap::<T, uint>(hasher, eqer);\n     let hi: hash_interner<T> =\n         {map: m, vect: dvec(), hasher: hasher, eqer: eqer};\n-    ret hi as interner::<T>;\n+    return hi as interner::<T>;\n }\n \n /* when traits can extend traits, we should extend index<uint,T> to get [] */\n@@ -28,12 +28,12 @@ trait interner<T: const copy> {\n impl <T: const copy> of interner<T> for hash_interner<T> {\n     fn intern(val: T) -> uint {\n         alt self.map.find(val) {\n-          some(idx) { ret idx; }\n+          some(idx) { return idx; }\n           none {\n             let new_idx = self.vect.len();\n             self.map.insert(val, new_idx);\n             self.vect.push(val);\n-            ret new_idx;\n+            return new_idx;\n           }\n         }\n     }\n@@ -43,5 +43,5 @@ impl <T: const copy> of interner<T> for hash_interner<T> {\n     // where we first check a pred and then rely on it, ceasing to fail is ok.\n     pure fn get(idx: uint) -> T { self.vect.get_elt(idx) }\n \n-    fn len() -> uint { ret self.vect.len(); }\n+    fn len() -> uint { return self.vect.len(); }\n }\n\\ No newline at end of file"}, {"sha": "4cbe13b6d5c1f57cef3cfb680ddd830826473c42", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -64,7 +64,7 @@ type visitor<E> =\n       visit_class_item: fn@(@class_member, E, vt<E>)};\n \n fn default_visitor<E>() -> visitor<E> {\n-    ret @{visit_mod: |a,b,c,d,e|visit_mod::<E>(a, b, c, d, e),\n+    return @{visit_mod: |a,b,c,d,e|visit_mod::<E>(a, b, c, d, e),\n           visit_view_item: |a,b,c|visit_view_item::<E>(a, b, c),\n           visit_foreign_item: |a,b,c|visit_foreign_item::<E>(a, b, c),\n           visit_item: |a,b,c|visit_item::<E>(a, b, c),\n@@ -466,7 +466,7 @@ type simple_visitor =\n fn simple_ignore_ty(_t: @ty) {}\n \n fn default_simple_visitor() -> simple_visitor {\n-    ret @{visit_mod: fn@(_m: _mod, _sp: span, _id: node_id) { },\n+    return @{visit_mod: fn@(_m: _mod, _sp: span, _id: node_id) { },\n           visit_view_item: fn@(_vi: @view_item) { },\n           visit_foreign_item: fn@(_ni: @foreign_item) { },\n           visit_item: fn@(_i: @item) { },\n@@ -574,7 +574,7 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(cm);\n         visit_class_item(cm, e, v);\n     }\n-    ret mk_vt(@{visit_mod: |a,b,c,d,e|v_mod(v.visit_mod, a, b, c, d, e),\n+    return mk_vt(@{visit_mod: |a,b,c,d,e|v_mod(v.visit_mod, a, b, c, d, e),\n                 visit_view_item: |a,b,c|\n                     v_view_item(v.visit_view_item, a, b, c),\n                 visit_foreign_item:"}, {"sha": "706c8ed991e207da103ea41f681be351a8f69d44", "filename": "src/rustc/back/abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fabi.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -66,13 +66,13 @@ const worst_case_glue_call_args: uint = 7u;\n \n const abi_version: uint = 1u;\n \n-fn memcpy_glue_name() -> ~str { ret ~\"rust_memcpy_glue\"; }\n+fn memcpy_glue_name() -> ~str { return ~\"rust_memcpy_glue\"; }\n \n-fn bzero_glue_name() -> ~str { ret ~\"rust_bzero_glue\"; }\n+fn bzero_glue_name() -> ~str { return ~\"rust_bzero_glue\"; }\n \n-fn yield_glue_name() -> ~str { ret ~\"rust_yield_glue\"; }\n+fn yield_glue_name() -> ~str { return ~\"rust_yield_glue\"; }\n \n-fn no_op_type_glue_name() -> ~str { ret ~\"rust_no_op_type_glue\"; }\n+fn no_op_type_glue_name() -> ~str { return ~\"rust_no_op_type_glue\"; }\n //\n // Local Variables:\n // mode: rust"}, {"sha": "7e6c9567b4b28c9799519ff8ba0b7ede4b9b363c", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -51,9 +51,9 @@ mod write {\n     fn is_object_or_assembly_or_exe(ot: output_type) -> bool {\n         if ot == output_type_assembly || ot == output_type_object ||\n                ot == output_type_exe {\n-            ret true;\n+            return true;\n         }\n-        ret false;\n+        return false;\n     }\n \n     // Decides what to call an intermediate file, given the name of the output\n@@ -64,7 +64,7 @@ mod write {\n           some(dot_pos) { str::slice(output_path, 0u, dot_pos) }\n           none { output_path }\n         };\n-        ret stem + ~\".\" + extension;\n+        return stem + ~\".\" + extension;\n     }\n \n     fn run_passes(sess: session, llmod: ModuleRef, output: ~str) {\n@@ -234,7 +234,7 @@ mod write {\n \n             llvm::LLVMDisposeModule(llmod);\n             if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n-            ret;\n+            return;\n         }\n \n         if opts.output_type == output_type_llvm_assembly {\n@@ -334,7 +334,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n                 }\n             } else { vec::push(cmh_items, meta); }\n         }\n-        ret {name: name, vers: vers, cmh_items: cmh_items};\n+        return {name: name, vers: vers, cmh_items: cmh_items};\n     }\n \n     // This calculates CMH as defined above\n@@ -343,11 +343,11 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n                               metas: provided_metas,\n                               dep_hashes: ~[@~str]) -> ~str {\n         fn len_and_str(s: ~str) -> ~str {\n-            ret fmt!{\"%u_%s\", str::len(s), s};\n+            return fmt!{\"%u_%s\", str::len(s), s};\n         }\n \n         fn len_and_str_lit(l: ast::lit) -> ~str {\n-            ret len_and_str(pprust::lit_to_str(@l));\n+            return len_and_str(pprust::lit_to_str(@l));\n         }\n \n         let cmh_items = attr::sort_meta_items(metas.cmh_items);\n@@ -374,18 +374,18 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n             symbol_hasher.input_str(len_and_str(*dh));\n         }\n \n-        ret truncated_hash_result(symbol_hasher);\n+        return truncated_hash_result(symbol_hasher);\n     }\n \n     fn warn_missing(sess: session, name: ~str, default: ~str) {\n-        if !sess.building_library { ret; }\n+        if !sess.building_library { return; }\n         sess.warn(fmt!{\"missing crate link meta `%s`, using `%s` as default\",\n                        name, default});\n     }\n \n     fn crate_meta_name(sess: session, _crate: ast::crate,\n                        output: ~str, metas: provided_metas) -> @~str {\n-        ret alt metas.name {\n+        return alt metas.name {\n               some(v) { v }\n               none {\n                 let name =\n@@ -407,7 +407,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n \n     fn crate_meta_vers(sess: session, _crate: ast::crate,\n                        metas: provided_metas) -> @~str {\n-        ret alt metas.vers {\n+        return alt metas.vers {\n               some(v) { v }\n               none {\n                 let vers = ~\"0.0\";\n@@ -424,7 +424,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n     let extras_hash =\n         crate_meta_extras_hash(symbol_hasher, c, provided_metas, dep_hashes);\n \n-    ret {name: name, vers: vers, extras_hash: extras_hash};\n+    return {name: name, vers: vers, extras_hash: extras_hash};\n }\n \n fn truncated_hash_result(symbol_hasher: hash::streaming) -> ~str unsafe {\n@@ -447,16 +447,16 @@ fn symbol_hash(tcx: ty::ctxt, symbol_hasher: hash::streaming, t: ty::t,\n     let hash = truncated_hash_result(symbol_hasher);\n     // Prefix with _ so that it never blends into adjacent digits\n \n-    ret ~\"_\" + hash;\n+    return ~\"_\" + hash;\n }\n \n fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> ~str {\n     alt ccx.type_hashcodes.find(t) {\n-      some(h) { ret h; }\n+      some(h) { return h; }\n       none {\n         let hash = symbol_hash(ccx.tcx, ccx.symbol_hasher, t, ccx.link_meta);\n         ccx.type_hashcodes.insert(t, hash);\n-        ret hash;\n+        return hash;\n       }\n     }\n }\n@@ -491,10 +491,10 @@ fn sanitize(s: ~str) -> ~str {\n     if result.len() > 0u &&\n         result[0] != '_' as u8 &&\n         ! char::is_XID_start(result[0] as char) {\n-        ret ~\"_\" + result;\n+        return ~\"_\" + result;\n     }\n \n-    ret result;\n+    return result;\n }\n \n fn mangle(ss: path) -> ~str {\n@@ -513,35 +513,35 @@ fn mangle(ss: path) -> ~str {\n }\n \n fn exported_name(path: path, hash: @~str, vers: @~str) -> ~str {\n-    ret mangle(\n+    return mangle(\n         vec::append_one(vec::append_one(path, path_name(hash)),\n                         path_name(vers)));\n }\n \n fn mangle_exported_name(ccx: @crate_ctxt, path: path, t: ty::t) -> ~str {\n     let hash = get_symbol_hash(ccx, t);\n-    ret exported_name(path, @hash, ccx.link_meta.vers);\n+    return exported_name(path, @hash, ccx.link_meta.vers);\n }\n \n fn mangle_internal_name_by_type_only(ccx: @crate_ctxt,\n                                      t: ty::t, name: @~str) ->\n    ~str {\n     let s = @util::ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n-    ret mangle(~[path_name(name), path_name(s), path_name(@hash)]);\n+    return mangle(~[path_name(name), path_name(s), path_name(@hash)]);\n }\n \n fn mangle_internal_name_by_path_and_seq(ccx: @crate_ctxt, path: path,\n                                         flav: @~str) -> ~str {\n-    ret mangle(vec::append_one(path, path_name(@ccx.names(*flav))));\n+    return mangle(vec::append_one(path, path_name(@ccx.names(*flav))));\n }\n \n fn mangle_internal_name_by_path(_ccx: @crate_ctxt, path: path) -> ~str {\n-    ret mangle(path);\n+    return mangle(path);\n }\n \n fn mangle_internal_name_by_seq(ccx: @crate_ctxt, flav: @~str) -> ~str {\n-    ret ccx.names(*flav);\n+    return ccx.names(*flav);\n }\n \n // If the user wants an exe generated we need to invoke\n@@ -558,15 +558,15 @@ fn link_binary(sess: session,\n                 (config.os == session::os_linux ||\n                  config.os == session::os_freebsd) &&\n                 option::is_some(found) && option::get(found) == 0u {\n-                ret str::slice(filename, 3u, str::len(filename));\n-            } else { ret filename; }\n+                return str::slice(filename, 3u, str::len(filename));\n+            } else { return filename; }\n         };\n         fn rmext(filename: ~str) -> ~str {\n             let mut parts = str::split_char(filename, '.');\n             vec::pop(parts);\n-            ret str::connect(parts, ~\".\");\n+            return str::connect(parts, ~\".\");\n         }\n-        ret alt config.os {\n+        return alt config.os {\n               session::os_macos { rmext(rmlib(filename)) }\n               session::os_linux { rmext(rmlib(filename)) }\n               session::os_freebsd { rmext(rmlib(filename)) }"}, {"sha": "d92c5f8379e843a8d63efba5b069736d83358a6b", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -18,7 +18,7 @@ fn get_rpath_flags(sess: session::session, out_filename: ~str) -> ~[~str] {\n \n     // No rpath on windows\n     if os == session::os_win32 {\n-        ret ~[];\n+        return ~[];\n     }\n \n     debug!{\"preparing the RPATH!\"};\n@@ -89,7 +89,7 @@ fn get_rpaths(os: session::os, cwd: path::path, sysroot: path::path,\n \n     // Remove duplicates\n     let rpaths = minimize_rpaths(rpaths);\n-    ret rpaths;\n+    return rpaths;\n }\n \n fn get_rpaths_relative_to_output(os: session::os,\n@@ -148,9 +148,9 @@ fn get_relative_to(abs1: path::path, abs2: path::path) -> path::path {\n     vec::push_all(path, vec::view(split2, start_idx, len2 - 1u));\n \n     if vec::is_not_empty(path) {\n-        ret path::connect_many(path);\n+        return path::connect_many(path);\n     } else {\n-        ret ~\".\";\n+        return ~\".\";\n     }\n }\n \n@@ -192,7 +192,7 @@ fn minimize_rpaths(rpaths: ~[~str]) -> ~[~str] {\n             set.insert(rpath, ());\n         }\n     }\n-    ret minimized;\n+    return minimized;\n }\n \n #[cfg(unix)]"}, {"sha": "0b6b2455ac7be2f1beb6e3e59d9b93838df8ffa6", "filename": "src/rustc/back/upcall.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fupcall.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -36,7 +36,7 @@ fn declare_upcalls(targ_cfg: @session::config,\n         let mut arg_tys: ~[TypeRef] = ~[];\n         for tys.each |t| { vec::push(arg_tys, t); }\n         let fn_ty = T_fn(arg_tys, rv);\n-        ret base::decl_cdecl_fn(llmod, prefix + name, fn_ty);\n+        return base::decl_cdecl_fn(llmod, prefix + name, fn_ty);\n     }\n     fn nothrow(f: ValueRef) -> ValueRef {\n         base::set_no_unwind(f); f\n@@ -47,7 +47,7 @@ fn declare_upcalls(targ_cfg: @session::config,\n     let int_t = T_int(targ_cfg);\n     let size_t = T_size_t(targ_cfg);\n \n-    ret @{_fail: dv(~\"fail\", ~[T_ptr(T_i8()),\n+    return @{_fail: dv(~\"fail\", ~[T_ptr(T_i8()),\n                              T_ptr(T_i8()),\n                              size_t]),\n           trace: dv(~\"trace\", ~[T_ptr(T_i8()),"}, {"sha": "93001f5e06a04cb3a5a32f94ea4ea6ad24ca66ad", "filename": "src/rustc/back/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fx86.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -3,7 +3,7 @@ import session::sess_os_to_meta_os;\n import metadata::loader::meta_section_name;\n \n fn get_target_strs(target_os: session::os) -> target_strs::t {\n-    ret {\n+    return {\n         module_asm: ~\"\",\n \n         meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)),"}, {"sha": "76a63fbf3d93a901fa59a5e6ea4814efe77b7737", "filename": "src/rustc/back/x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fx86_64.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -3,7 +3,7 @@ import session::sess_os_to_meta_os;\n import metadata::loader::meta_section_name;\n \n fn get_target_strs(target_os: session::os) -> target_strs::t {\n-    ret {\n+    return {\n         module_asm: ~\"\",\n \n         meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)),"}, {"sha": "fd4f29a6ad0b688d30e4cd3974daeded83e16e90", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -50,7 +50,7 @@ fn default_configuration(sess: session, argv0: ~str, input: input) ->\n       session::arch_arm { ~\"arm\" }\n     };\n \n-    ret ~[ // Target bindings.\n+    return ~[ // Target bindings.\n          attr::mk_word_item(@os::family()),\n          mk(@~\"target_os\", os::sysname()),\n          mk(@~\"target_family\", os::family()),\n@@ -76,7 +76,7 @@ fn build_configuration(sess: session, argv0: ~str, input: input) ->\n                 ~[attr::mk_word_item(@~\"notest\")]\n             }\n         };\n-    ret vec::append(vec::append(user_cfg, gen_cfg), default_cfg);\n+    return vec::append(vec::append(user_cfg, gen_cfg), default_cfg);\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n@@ -86,7 +86,7 @@ fn parse_cfgspecs(cfgspecs: ~[~str]) -> ast::crate_cfg {\n     // meta_word variant.\n     let mut words = ~[];\n     for cfgspecs.each |s| { vec::push(words, attr::mk_word_item(@s)); }\n-    ret words;\n+    return words;\n }\n \n enum input {\n@@ -111,13 +111,13 @@ fn parse_input(sess: session, cfg: ast::crate_cfg, input: input)\n }\n \n fn time<T>(do_it: bool, what: ~str, thunk: fn() -> T) -> T {\n-    if !do_it { ret thunk(); }\n+    if !do_it { return thunk(); }\n     let start = std::time::precise_time_s();\n     let rv = thunk();\n     let end = std::time::precise_time_s();\n     io::stdout().write_str(fmt!{\"time: %3.3f s\\t%s\\n\",\n                                 end - start, what});\n-    ret rv;\n+    return rv;\n }\n \n enum compile_upto {\n@@ -135,7 +135,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     let time_passes = sess.time_passes();\n     let mut crate = time(time_passes, ~\"parsing\",\n                          ||parse_input(sess, cfg, input) );\n-    if upto == cu_parse { ret {crate: crate, tcx: none}; }\n+    if upto == cu_parse { return {crate: crate, tcx: none}; }\n \n     sess.building_library = session::building_library(\n         sess.opts.crate_type, crate, sess.opts.test);\n@@ -150,7 +150,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n         syntax::ext::expand::expand_crate(sess.parse_sess, sess.opts.cfg,\n                                           crate));\n \n-    if upto == cu_expand { ret {crate: crate, tcx: none}; }\n+    if upto == cu_expand { return {crate: crate, tcx: none}; }\n \n     crate = time(time_passes, ~\"intrinsic injection\", ||\n         front::intrinsic_inject::inject_intrinsic(sess, crate));\n@@ -205,7 +205,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n         middle::check_const::check_crate(sess, crate, ast_map, def_map,\n                                          method_map, ty_cx));\n \n-    if upto == cu_typeck { ret {crate: crate, tcx: some(ty_cx)}; }\n+    if upto == cu_typeck { return {crate: crate, tcx: some(ty_cx)}; }\n \n     time(time_passes, ~\"block-use checking\", ||\n         middle::block_use::check_crate(ty_cx, crate));\n@@ -228,7 +228,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n \n     time(time_passes, ~\"lint checking\", || lint::check_crate(ty_cx, crate));\n \n-    if upto == cu_no_trans { ret {crate: crate, tcx: some(ty_cx)}; }\n+    if upto == cu_no_trans { return {crate: crate, tcx: some(ty_cx)}; }\n     let outputs = option::get(outputs);\n \n     let maps = {mutbl_map: mutbl_map, root_map: root_map,\n@@ -247,13 +247,13 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n         sess.opts.output_type != link::output_type_exe ||\n             sess.opts.static && sess.building_library;\n \n-    if stop_after_codegen { ret {crate: crate, tcx: some(ty_cx)}; }\n+    if stop_after_codegen { return {crate: crate, tcx: some(ty_cx)}; }\n \n     time(time_passes, ~\"linking\", ||\n          link::link_binary(sess, outputs.obj_filename,\n                            outputs.out_filename, link_meta));\n \n-    ret {crate: crate, tcx: some(ty_cx)};\n+    return {crate: crate, tcx: some(ty_cx)};\n }\n \n fn compile_input(sess: session, cfg: ast::crate_cfg, input: input,\n@@ -338,7 +338,7 @@ fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: input,\n }\n \n fn get_os(triple: ~str) -> option<session::os> {\n-    ret if str::contains(triple, ~\"win32\") ||\n+    if str::contains(triple, ~\"win32\") ||\n                str::contains(triple, ~\"mingw32\") {\n             some(session::os_win32)\n         } else if str::contains(triple, ~\"darwin\") {\n@@ -347,11 +347,12 @@ fn get_os(triple: ~str) -> option<session::os> {\n             some(session::os_linux)\n         } else if str::contains(triple, ~\"freebsd\") {\n             some(session::os_freebsd)\n-        } else { none };\n+        } else { none }\n }\n \n fn get_arch(triple: ~str) -> option<session::arch> {\n-    ret if str::contains(triple, ~\"i386\") || str::contains(triple, ~\"i486\") ||\n+    if str::contains(triple, ~\"i386\") ||\n+        str::contains(triple, ~\"i486\") ||\n                str::contains(triple, ~\"i586\") ||\n                str::contains(triple, ~\"i686\") ||\n                str::contains(triple, ~\"i786\") {\n@@ -361,7 +362,7 @@ fn get_arch(triple: ~str) -> option<session::arch> {\n         } else if str::contains(triple, ~\"arm\") ||\n                       str::contains(triple, ~\"xscale\") {\n             some(session::arch_arm)\n-        } else { none };\n+        } else { none }\n }\n \n fn build_target_config(sopts: @session::options,\n@@ -388,7 +389,7 @@ fn build_target_config(sopts: @session::options,\n     let target_cfg: @session::config =\n         @{os: os, arch: arch, target_strs: target_strs, int_type: int_type,\n           uint_type: uint_type, float_type: float_type};\n-    ret target_cfg;\n+    return target_cfg;\n }\n \n fn host_triple() -> ~str {\n@@ -401,7 +402,7 @@ fn host_triple() -> ~str {\n     // be grabbing (at compile time) the target triple that this rustc is\n     // built with and calling that (at runtime) the host triple.\n     let ht = env!{\"CFG_HOST_TRIPLE\"};\n-    ret if ht != ~\"\" {\n+    return if ht != ~\"\" {\n             ht\n         } else {\n             fail ~\"rustc built without CFG_HOST_TRIPLE\"\n@@ -530,7 +531,7 @@ fn build_session_options(matches: getopts::matches,\n           parse_only: parse_only,\n           no_trans: no_trans,\n           debugging_opts: debugging_opts};\n-    ret sopts;\n+    return sopts;\n }\n \n fn build_session(sopts: @session::options,\n@@ -573,22 +574,23 @@ fn build_session_(sopts: @session::options,\n \n fn parse_pretty(sess: session, &&name: ~str) -> pp_mode {\n     if str::eq(name, ~\"normal\") {\n-        ret ppm_normal;\n+        return ppm_normal;\n     } else if str::eq(name, ~\"expanded\") {\n-        ret ppm_expanded;\n+        return ppm_expanded;\n     } else if str::eq(name, ~\"typed\") {\n-        ret ppm_typed;\n+        return ppm_typed;\n     } else if str::eq(name, ~\"expanded,identified\") {\n-        ret ppm_expanded_identified;\n+        return ppm_expanded_identified;\n     } else if str::eq(name, ~\"identified\") {\n-        ret ppm_identified;\n+        return ppm_identified;\n     }\n     sess.fatal(~\"argument to `pretty` must be one of `normal`, `typed`, or \" +\n                    ~\"`identified`\");\n }\n \n fn opts() -> ~[getopts::opt] {\n-    ret ~[optflag(~\"h\"), optflag(~\"help\"), optflag(~\"v\"), optflag(~\"version\"),\n+    return ~[optflag(~\"h\"), optflag(~\"help\"),\n+             optflag(~\"v\"), optflag(~\"version\"),\n           optflag(~\"emit-llvm\"), optflagopt(~\"pretty\"),\n           optflag(~\"ls\"), optflag(~\"parse-only\"), optflag(~\"no-trans\"),\n           optflag(~\"O\"), optopt(~\"opt-level\"), optmulti(~\"L\"), optflag(~\"S\"),\n@@ -699,7 +701,7 @@ fn build_output_filenames(input: input,\n         }\n       }\n     }\n-    ret @{out_filename: out_path,\n+    return @{out_filename: out_path,\n           obj_filename: obj_path};\n }\n "}, {"sha": "14d00c2d547978984ab5092067617a61b9817212", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -121,7 +121,7 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n     let mut args = args;\n     let binary = vec::shift(args);\n \n-    if vec::len(args) == 0u { usage(binary); ret; }\n+    if vec::len(args) == 0u { usage(binary); return; }\n \n     let matches =\n         alt getopts::getopts(args, opts()) {\n@@ -133,24 +133,24 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n \n     if opt_present(matches, ~\"h\") || opt_present(matches, ~\"help\") {\n         usage(binary);\n-        ret;\n+        return;\n     }\n \n     let lint_flags = vec::append(getopts::opt_strs(matches, ~\"W\"),\n                                  getopts::opt_strs(matches, ~\"warn\"));\n     if lint_flags.contains(~\"help\") {\n         describe_warnings();\n-        ret;\n+        return;\n     }\n \n     if getopts::opt_strs(matches, ~\"Z\").contains(~\"help\") {\n         describe_debug_flags();\n-        ret;\n+        return;\n     }\n \n     if opt_present(matches, ~\"v\") || opt_present(matches, ~\"version\") {\n         version(binary);\n-        ret;\n+        return;\n     }\n     let input = alt vec::len(matches.free) {\n       0u { early_error(demitter, ~\"no input filename given\") }\n@@ -176,7 +176,10 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n                                          ~\"normal\"),\n                     |a| parse_pretty(sess, a) );\n     alt pretty {\n-      some::<pp_mode>(ppm) { pretty_print_input(sess, cfg, input, ppm); ret; }\n+      some::<pp_mode>(ppm) {\n+        pretty_print_input(sess, cfg, input, ppm);\n+        return;\n+      }\n       none::<pp_mode> {/* continue */ }\n     }\n     let ls = opt_present(matches, ~\"ls\");\n@@ -189,7 +192,7 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n             early_error(demitter, ~\"can not list metadata for stdin\");\n           }\n         }\n-        ret;\n+        return;\n     }\n \n     compile_input(sess, cfg, input, odir, ofile);"}, {"sha": "e70c97754b97ca93778d8cd8e5b71ec5793ce831", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -168,7 +168,7 @@ impl session for session {\n         self.span_lint_level(level, span, msg);\n     }\n     fn next_node_id() -> ast::node_id {\n-        ret syntax::parse::next_node_id(self.parse_sess);\n+        return syntax::parse::next_node_id(self.parse_sess);\n     }\n     fn diagnostic() -> diagnostic::span_handler {\n         self.span_diagnostic"}, {"sha": "9deaae5ecf17c6493e967c04316cd105562f2973", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -31,7 +31,7 @@ fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n \n     let fold = fold::make_fold(precursor);\n     let res = @fold.fold_crate(*crate);\n-    ret res;\n+    return res;\n }\n \n fn filter_item(cx: ctxt, &&item: @ast::item) ->\n@@ -54,8 +54,10 @@ fn fold_mod(cx: ctxt, m: ast::_mod, fld: fold::ast_fold) ->\n     let filtered_items = vec::filter_map(m.items, item_filter);\n     let view_item_filter = |a| filter_view_item(cx, a);\n     let filtered_view_items = vec::filter_map(m.view_items, view_item_filter);\n-    ret {view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(x)),\n-         items: vec::filter_map(filtered_items, |x| fld.fold_item(x))};\n+    return {\n+        view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(x)),\n+        items: vec::filter_map(filtered_items, |x| fld.fold_item(x))\n+    };\n }\n \n fn filter_foreign_item(cx: ctxt, &&item: @ast::foreign_item) ->\n@@ -72,8 +74,10 @@ fn fold_foreign_mod(cx: ctxt, nm: ast::foreign_mod,\n     let view_item_filter = |a| filter_view_item(cx, a);\n     let filtered_view_items = vec::filter_map(\n         nm.view_items, view_item_filter);\n-    ret {view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(x)),\n-         items: filtered_items};\n+    return {\n+        view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(x)),\n+        items: filtered_items\n+    };\n }\n \n fn filter_stmt(cx: ctxt, &&stmt: @ast::stmt) ->\n@@ -97,23 +101,23 @@ fn fold_block(cx: ctxt, b: ast::blk_, fld: fold::ast_fold) ->\n    ast::blk_ {\n     let filter = |a| filter_stmt(cx, a);\n     let filtered_stmts = vec::filter_map(b.stmts, filter);\n-    ret {view_items: b.view_items,\n+    return {view_items: b.view_items,\n          stmts: vec::map(filtered_stmts, |x| fld.fold_stmt(x)),\n          expr: option::map(b.expr, |x| fld.fold_expr(x)),\n          id: b.id,\n          rules: b.rules};\n }\n \n fn item_in_cfg(cx: ctxt, item: @ast::item) -> bool {\n-    ret cx.in_cfg(item.attrs);\n+    return cx.in_cfg(item.attrs);\n }\n \n fn foreign_item_in_cfg(cx: ctxt, item: @ast::foreign_item) -> bool {\n-    ret cx.in_cfg(item.attrs);\n+    return cx.in_cfg(item.attrs);\n }\n \n fn view_item_in_cfg(cx: ctxt, item: @ast::view_item) -> bool {\n-    ret cx.in_cfg(item.attrs);\n+    return cx.in_cfg(item.attrs);\n }\n \n // Determine if an item should be translated in the current crate\n@@ -134,13 +138,13 @@ fn metas_in_cfg(cfg: ast::crate_cfg, metas: ~[@ast::meta_item]) -> bool {\n         |&&i| attr::get_meta_item_list(i) ));\n \n     let has_cfg_metas = vec::len(cfg_metas) > 0u;\n-    if !has_cfg_metas { ret true; }\n+    if !has_cfg_metas { return true; }\n \n     for cfg_metas.each |cfg_mi| {\n-        if attr::contains(cfg, cfg_mi) { ret true; }\n+        if attr::contains(cfg, cfg_mi) { return true; }\n     }\n \n-    ret false;\n+    return false;\n }\n \n "}, {"sha": "7103c73620627483b9fbee03b7e63da83a7e7719", "filename": "src/rustc/front/core_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fcore_inject.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -23,7 +23,7 @@ fn inject_libcore_ref(sess: session,\n                       crate: @ast::crate) -> @ast::crate {\n \n     fn spanned<T: copy>(x: T) -> @ast::spanned<T> {\n-        ret @{node: x,\n+        return @{node: x,\n             span: dummy_sp()};\n     }\n \n@@ -43,6 +43,6 @@ fn inject_libcore_ref(sess: session,\n \n     let vis = vec::append(~[vi1, vi2], crate.node.module.view_items);\n \n-    ret @{node: {module: { view_items: vis with crate.node.module }\n+    return @{node: {module: { view_items: vis with crate.node.module }\n                  with crate.node} with *crate }\n }"}, {"sha": "34a60fda151a8e40e5372cdeebda477392445a42", "filename": "src/rustc/front/intrinsic_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fintrinsic_inject.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -24,6 +24,6 @@ fn inject_intrinsic(sess: session,\n \n     let items = vec::append(~[item], crate.node.module.items);\n \n-    ret @{node: {module: { items: items with crate.node.module }\n+    return @{node: {module: { items: items with crate.node.module }\n                  with crate.node} with *crate }\n }"}, {"sha": "87011c2ad336dea0372808827e0190e0c234ae2c", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -51,7 +51,7 @@ fn generate_test_harness(sess: session::session,\n \n     let fold = fold::make_fold(precursor);\n     let res = @fold.fold_crate(*crate);\n-    ret res;\n+    return res;\n }\n \n fn strip_test_functions(crate: @ast::crate) -> @ast::crate {\n@@ -82,7 +82,7 @@ fn fold_mod(_cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n \n     let mod_nomain =\n         {view_items: m.view_items, items: vec::filter_map(m.items, nomain)};\n-    ret fold::noop_fold_mod(mod_nomain, fld);\n+    return fold::noop_fold_mod(mod_nomain, fld);\n }\n \n fn fold_crate(cx: test_ctxt, c: ast::crate_, fld: fold::ast_fold) ->\n@@ -91,7 +91,7 @@ fn fold_crate(cx: test_ctxt, c: ast::crate_, fld: fold::ast_fold) ->\n \n     // Add a special __test module to the crate that will contain code\n     // generated for the test harness\n-    ret {module: add_test_module(cx, folded.module) with folded};\n+    return {module: add_test_module(cx, folded.module) with folded};\n }\n \n \n@@ -121,7 +121,7 @@ fn fold_item(cx: test_ctxt, &&i: @ast::item, fld: fold::ast_fold) ->\n \n     let res = fold::noop_fold_item(i, fld);\n     vec::pop(cx.path);\n-    ret res;\n+    return res;\n }\n \n fn is_test_fn(i: @ast::item) -> bool {\n@@ -140,15 +140,15 @@ fn is_test_fn(i: @ast::item) -> bool {\n         }\n     }\n \n-    ret has_test_attr && has_test_signature(i);\n+    return has_test_attr && has_test_signature(i);\n }\n \n fn is_ignored(cx: test_ctxt, i: @ast::item) -> bool {\n     let ignoreattrs = attr::find_attrs_by_name(i.attrs, ~\"ignore\");\n     let ignoreitems = attr::attr_metas(ignoreattrs);\n     let cfg_metas = vec::concat(vec::filter_map(ignoreitems,\n         |&&i| attr::get_meta_item_list(i) ));\n-    ret if vec::is_not_empty(ignoreitems) {\n+    return if vec::is_not_empty(ignoreitems) {\n         config::metas_in_cfg(cx.crate.node.config, cfg_metas)\n     } else {\n         false\n@@ -161,7 +161,7 @@ fn should_fail(i: @ast::item) -> bool {\n \n fn add_test_module(cx: test_ctxt, m: ast::_mod) -> ast::_mod {\n     let testmod = mk_test_module(cx);\n-    ret {items: vec::append_one(m.items, testmod) with m};\n+    return {items: vec::append_one(m.items, testmod) with m};\n }\n \n /*\n@@ -203,11 +203,11 @@ fn mk_test_module(cx: test_ctxt) -> @ast::item {\n \n     debug!{\"Synthetic test module:\\n%s\\n\", pprust::item_to_str(@item)};\n \n-    ret @item;\n+    return @item;\n }\n \n fn nospan<T: copy>(t: T) -> ast::spanned<T> {\n-    ret {node: t, span: dummy_sp()};\n+    return {node: t, span: dummy_sp()};\n }\n \n fn path_node(ids: ~[ast::ident]) -> @ast::path {\n@@ -238,7 +238,7 @@ fn mk_tests(cx: test_ctxt) -> @ast::item {\n          node: item_,\n          vis: ast::public,\n          span: dummy_sp()};\n-    ret @item;\n+    return @item;\n }\n \n fn mk_path(cx: test_ctxt, path: ~[ast::ident]) -> ~[ast::ident] {\n@@ -270,7 +270,7 @@ fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n     let inner_ty = @{id: cx.sess.next_node_id(),\n                      node: ast::ty_vec(vec_mt),\n                      span: dummy_sp()};\n-    ret @{id: cx.sess.next_node_id(),\n+    return @{id: cx.sess.next_node_id(),\n           node: ast::ty_uniq({ty: inner_ty, mutbl: ast::m_imm}),\n           span: dummy_sp()};\n }\n@@ -286,7 +286,7 @@ fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n                        callee_id: cx.sess.next_node_id(),\n                        node: ast::expr_vec(descs, ast::m_imm),\n                        span: dummy_sp()};\n-    ret @{id: cx.sess.next_node_id(),\n+    return @{id: cx.sess.next_node_id(),\n           callee_id: cx.sess.next_node_id(),\n           node: ast::expr_vstore(inner_expr, ast::vstore_uniq),\n           span: dummy_sp()};\n@@ -358,7 +358,7 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n     let desc_rec: ast::expr =\n         {id: cx.sess.next_node_id(), callee_id: cx.sess.next_node_id(),\n          node: desc_rec_, span: span};\n-    ret @desc_rec;\n+    return @desc_rec;\n }\n \n // Produces a bare function that wraps the test function\n@@ -400,7 +400,7 @@ fn mk_test_wrapper(cx: test_ctxt,\n         span: span\n     };\n \n-    ret @wrapper_expr;\n+    return @wrapper_expr;\n }\n \n fn mk_main(cx: test_ctxt) -> @ast::item {\n@@ -451,7 +451,7 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n          node: item_,\n          vis: ast::public,\n          span: dummy_sp()};\n-    ret @item;\n+    return @item;\n }\n \n fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n@@ -497,7 +497,7 @@ fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n         {id: cx.sess.next_node_id(), callee_id: cx.sess.next_node_id(),\n          node: test_main_call_expr_, span: dummy_sp()};\n \n-    ret @test_main_call_expr;\n+    return @test_main_call_expr;\n }\n \n // Local Variables:"}, {"sha": "2a327a25b1141afd9a966ca8ad460f70265755d2", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -995,28 +995,28 @@ fn associate_type(tn: type_names, s: ~str, t: TypeRef) {\n }\n \n fn type_has_name(tn: type_names, t: TypeRef) -> option<~str> {\n-    ret tn.type_names.find(t);\n+    return tn.type_names.find(t);\n }\n \n fn name_has_type(tn: type_names, s: ~str) -> option<TypeRef> {\n-    ret tn.named_types.find(s);\n+    return tn.named_types.find(s);\n }\n \n fn mk_type_names() -> type_names {\n-    fn hash(&&t: TypeRef) -> uint { ret t as uint; }\n-    fn eq(&&a: TypeRef, &&b: TypeRef) -> bool { ret a as uint == b as uint; }\n+    fn hash(&&t: TypeRef) -> uint { return t as uint; }\n+    fn eq(&&a: TypeRef, &&b: TypeRef) -> bool { a as uint == b as uint }\n     @{type_names: std::map::hashmap(hash, eq),\n       named_types: std::map::str_hash()}\n }\n \n fn type_to_str(names: type_names, ty: TypeRef) -> ~str {\n-    ret type_to_str_inner(names, ~[], ty);\n+    return type_to_str_inner(names, ~[], ty);\n }\n \n fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n    ~str {\n     alt type_has_name(names, ty) {\n-      option::some(n) { ret n; }\n+      option::some(n) { return n; }\n       _ {}\n     }\n \n@@ -1032,20 +1032,20 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n             if first { first = false; } else { s += ~\", \"; }\n             s += type_to_str_inner(names, outer, t);\n         }\n-        ret s;\n+        return s;\n     }\n \n     alt kind {\n-      Void { ret ~\"Void\"; }\n-      Half { ret ~\"Half\"; }\n-      Float { ret ~\"Float\"; }\n-      Double { ret ~\"Double\"; }\n-      X86_FP80 { ret ~\"X86_FP80\"; }\n-      FP128 { ret ~\"FP128\"; }\n-      PPC_FP128 { ret ~\"PPC_FP128\"; }\n-      Label { ret ~\"Label\"; }\n+      Void { return ~\"Void\"; }\n+      Half { return ~\"Half\"; }\n+      Float { return ~\"Float\"; }\n+      Double { return ~\"Double\"; }\n+      X86_FP80 { return ~\"X86_FP80\"; }\n+      FP128 { return ~\"FP128\"; }\n+      PPC_FP128 { return ~\"PPC_FP128\"; }\n+      Label { return ~\"Label\"; }\n       Integer {\n-        ret ~\"i\" + int::str(llvm::LLVMGetIntTypeWidth(ty) as int);\n+        return ~\"i\" + int::str(llvm::LLVMGetIntTypeWidth(ty) as int);\n       }\n       Function {\n         let mut s = ~\"fn(\";\n@@ -1058,7 +1058,7 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n         s += tys_str(names, outer, args);\n         s += ~\") -> \";\n         s += type_to_str_inner(names, outer, out_ty);\n-        ret s;\n+        return s;\n       }\n       Struct {\n         let mut s: ~str = ~\"{\";\n@@ -1069,11 +1069,11 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n         }\n         s += tys_str(names, outer, elts);\n         s += ~\"}\";\n-        ret s;\n+        return s;\n       }\n       Array {\n         let el_ty = llvm::LLVMGetElementType(ty);\n-        ret ~\"[\" + type_to_str_inner(names, outer, el_ty) + ~\" x \" +\n+        return ~\"[\" + type_to_str_inner(names, outer, el_ty) + ~\" x \" +\n             uint::str(llvm::LLVMGetArrayLength(ty) as uint) + ~\"]\";\n       }\n       Pointer {\n@@ -1082,7 +1082,7 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n             i += 1u;\n             if tout as int == ty as int {\n                 let n: uint = vec::len::<TypeRef>(outer0) - i;\n-                ret ~\"*\\\\\" + int::str(n as int);\n+                return ~\"*\\\\\" + int::str(n as int);\n             }\n         }\n         let addrstr = {\n@@ -1093,17 +1093,17 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n                 fmt!{\"addrspace(%u)\", addrspace}\n             }\n         };\n-        ret addrstr + ~\"*\" +\n+        return addrstr + ~\"*\" +\n                 type_to_str_inner(names, outer, llvm::LLVMGetElementType(ty));\n       }\n-      Vector { ret ~\"Vector\"; }\n-      Metadata { ret ~\"Metadata\"; }\n-      X86_MMX { ret ~\"X86_MMAX\"; }\n+      Vector { return ~\"Vector\"; }\n+      Metadata { return ~\"Metadata\"; }\n+      X86_MMX { return ~\"X86_MMAX\"; }\n     }\n }\n \n fn float_width(llt: TypeRef) -> uint {\n-    ret alt llvm::LLVMGetTypeKind(llt) as int {\n+    return alt llvm::LLVMGetTypeKind(llt) as int {\n           1 { 32u }\n           2 { 64u }\n           3 { 80u }\n@@ -1116,7 +1116,7 @@ fn fn_ty_param_tys(fn_ty: TypeRef) -> ~[TypeRef] unsafe {\n     let args = vec::from_elem(llvm::LLVMCountParamTypes(fn_ty) as uint,\n                              0 as TypeRef);\n     llvm::LLVMGetParamTypes(fn_ty, vec::unsafe::to_ptr(args));\n-    ret args;\n+    return args;\n }\n \n \n@@ -1133,7 +1133,7 @@ type target_data = {lltd: TargetDataRef, dtor: @target_data_res};\n fn mk_target_data(string_rep: ~str) -> target_data {\n     let lltd =\n         str::as_c_str(string_rep, |buf| llvm::LLVMCreateTargetData(buf) );\n-    ret {lltd: lltd, dtor: @target_data_res(lltd)};\n+    return {lltd: lltd, dtor: @target_data_res(lltd)};\n }\n \n /* Memory-managed interface to pass managers. */\n@@ -1148,7 +1148,7 @@ type pass_manager = {llpm: PassManagerRef, dtor: @pass_manager_res};\n \n fn mk_pass_manager() -> pass_manager {\n     let llpm = llvm::LLVMCreatePassManager();\n-    ret {llpm: llpm, dtor: @pass_manager_res(llpm)};\n+    return {llpm: llpm, dtor: @pass_manager_res(llpm)};\n }\n \n /* Memory-managed interface to object files. */\n@@ -1163,8 +1163,8 @@ type object_file = {llof: ObjectFileRef, dtor: @object_file_res};\n \n fn mk_object_file(llmb: MemoryBufferRef) -> option<object_file> {\n     let llof = llvm::LLVMCreateObjectFile(llmb);\n-    if llof as int == 0 { ret option::none::<object_file>; }\n-    ret option::some({llof: llof, dtor: @object_file_res(llof)});\n+    if llof as int == 0 { return option::none::<object_file>; }\n+    return option::some({llof: llof, dtor: @object_file_res(llof)});\n }\n \n /* Memory-managed interface to section iterators. */\n@@ -1179,7 +1179,7 @@ type section_iter = {llsi: SectionIteratorRef, dtor: @section_iter_res};\n \n fn mk_section_iter(llof: ObjectFileRef) -> section_iter {\n     let llsi = llvm::LLVMGetSections(llof);\n-    ret {llsi: llsi, dtor: @section_iter_res(llsi)};\n+    return {llsi: llsi, dtor: @section_iter_res(llsi)};\n }\n \n //"}, {"sha": "8f97c204611598daaebf0c2e8503f4e57ec6f059", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -127,12 +127,14 @@ enum astencode_tag { // Reserves 0x50 -- 0x6f\n }\n \n // djb's cdb hashes.\n-fn hash_node_id(&&node_id: int) -> uint { ret 177573u ^ (node_id as uint); }\n+fn hash_node_id(&&node_id: int) -> uint {\n+    return 177573u ^ (node_id as uint);\n+}\n \n fn hash_path(&&s: ~str) -> uint {\n     let mut h = 5381u;\n     for str::each(s) |ch| { h = (h << 5u) + h ^ (ch as uint); }\n-    ret h;\n+    return h;\n }\n \n type link_meta = {name: @~str, vers: @~str, extras_hash: ~str};"}, {"sha": "06eb2bea3d2fadc96eefa188cfc9cca50dc334f5", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -116,7 +116,7 @@ fn visit_item(e: env, i: @ast::item) {\n         alt attr::foreign_abi(i.attrs) {\n           either::right(abi) {\n             if abi != ast::foreign_abi_cdecl &&\n-               abi != ast::foreign_abi_stdcall { ret; }\n+               abi != ast::foreign_abi_stdcall { return; }\n           }\n           either::left(msg) { e.diag.span_fatal(i.span, msg); }\n         }\n@@ -177,10 +177,10 @@ fn existing_match(e: env, metas: ~[@ast::meta_item], hash: ~str) ->\n     for e.crate_cache.each |c| {\n         if loader::metadata_matches(*c.metas, metas)\n             && (hash.is_empty() || *c.hash == hash) {\n-            ret some(c.cnum);\n+            return some(c.cnum);\n         }\n     }\n-    ret none;\n+    return none;\n }\n \n fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n@@ -228,10 +228,10 @@ fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n         let cstore = e.cstore;\n         cstore::set_crate_data(cstore, cnum, cmeta);\n         cstore::add_used_crate_file(cstore, cfilename);\n-        ret cnum;\n+        return cnum;\n       }\n       some(cnum) {\n-        ret cnum;\n+        return cnum;\n       }\n     }\n }\n@@ -266,7 +266,7 @@ fn resolve_crate_deps(e: env, cdata: @~[u8]) -> cstore::cnum_map {\n           }\n         }\n     }\n-    ret cnum_map;\n+    return cnum_map;\n }\n \n // Local Variables:"}, {"sha": "9e2b7c174ef85ea9fc7184a1b80c16ec93edf401", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -35,12 +35,12 @@ export maybe_get_item_ast, found_ast, found, found_parent, not_found;\n \n fn get_symbol(cstore: cstore::cstore, def: ast::def_id) -> ~str {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n-    ret decoder::get_symbol(cdata, def.node);\n+    return decoder::get_symbol(cdata, def.node);\n }\n \n fn get_type_param_count(cstore: cstore::cstore, def: ast::def_id) -> uint {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n-    ret decoder::get_type_param_count(cdata, def.node);\n+    return decoder::get_type_param_count(cdata, def.node);\n }\n \n fn lookup_defs(cstore: cstore::cstore, cnum: ast::crate_num,\n@@ -51,7 +51,7 @@ fn lookup_defs(cstore: cstore::cstore, cnum: ast::crate_num,\n         let (c, data, def) = elt;\n         vec::push(result, decoder::lookup_def(c, data, def));\n     }\n-    ret result;\n+    return result;\n }\n \n fn lookup_method_purity(cstore: cstore::cstore, did: ast::def_id)\n@@ -83,7 +83,7 @@ fn resolve_path(cstore: cstore::cstore, cnum: ast::crate_num,\n             }\n         }\n     }\n-    ret result;\n+    return result;\n }\n \n /// Iterates over all the paths in the given crate.\n@@ -125,7 +125,7 @@ fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id)\n     -> ~[ty::variant_info] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    ret decoder::get_enum_variants(cdata, def.node, tcx)\n+    return decoder::get_enum_variants(cdata, def.node, tcx)\n }\n \n fn get_impls_for_mod(cstore: cstore::cstore, def: ast::def_id,\n@@ -147,7 +147,7 @@ fn get_method_names_if_trait(cstore: cstore::cstore, def: ast::def_id)\n                           -> option<@dvec<@~str>> {\n \n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    ret decoder::get_method_names_if_trait(cdata, def.node);\n+    return decoder::get_method_names_if_trait(cdata, def.node);\n }\n \n fn get_item_attrs(cstore: cstore::cstore,\n@@ -173,7 +173,7 @@ fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n fn get_region_param(cstore: metadata::cstore::cstore,\n                     def: ast::def_id) -> bool {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    ret decoder::get_region_param(cdata, def.node);\n+    return decoder::get_region_param(cdata, def.node);\n }\n \n fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n@@ -193,7 +193,7 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n                  class_id, def} );\n     debug!{\"got field data %?\", the_field};\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n-    ret {bounds: @~[], rp: false, ty: ty};\n+    return {bounds: @~[], rp: false, ty: ty};\n }\n \n // Given a def_id for an impl or class, return the traits it implements,"}, {"sha": "dce5a108a03ca103ed6debd9a82952580bafbc2f", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -71,7 +71,7 @@ fn mk_cstore() -> cstore {\n     let meta_cache = map::int_hash::<crate_metadata>();\n     let crate_map = map::int_hash::<ast::crate_num>();\n     let mod_path_map = new_def_hash();\n-    ret private(@{metas: meta_cache,\n+    return private(@{metas: meta_cache,\n                   use_crate_map: crate_map,\n                   mod_path_map: mod_path_map,\n                   mut used_crate_files: ~[],\n@@ -80,17 +80,17 @@ fn mk_cstore() -> cstore {\n }\n \n fn get_crate_data(cstore: cstore, cnum: ast::crate_num) -> crate_metadata {\n-    ret p(cstore).metas.get(cnum);\n+    return p(cstore).metas.get(cnum);\n }\n \n fn get_crate_hash(cstore: cstore, cnum: ast::crate_num) -> @~str {\n     let cdata = get_crate_data(cstore, cnum);\n-    ret decoder::get_crate_hash(cdata.data);\n+    return decoder::get_crate_hash(cdata.data);\n }\n \n fn get_crate_vers(cstore: cstore, cnum: ast::crate_num) -> @~str {\n     let cdata = get_crate_data(cstore, cnum);\n-    ret decoder::get_crate_vers(cdata.data);\n+    return decoder::get_crate_vers(cdata.data);\n }\n \n fn set_crate_data(cstore: cstore, cnum: ast::crate_num,\n@@ -104,7 +104,7 @@ fn set_crate_data(cstore: cstore, cnum: ast::crate_num,\n }\n \n fn have_crate_data(cstore: cstore, cnum: ast::crate_num) -> bool {\n-    ret p(cstore).metas.contains_key(cnum);\n+    return p(cstore).metas.contains_key(cnum);\n }\n \n fn iter_crate_data(cstore: cstore, i: fn(ast::crate_num, crate_metadata)) {\n@@ -118,27 +118,27 @@ fn add_used_crate_file(cstore: cstore, lib: ~str) {\n }\n \n fn get_used_crate_files(cstore: cstore) -> ~[~str] {\n-    ret p(cstore).used_crate_files;\n+    return p(cstore).used_crate_files;\n }\n \n fn add_used_library(cstore: cstore, lib: ~str) -> bool {\n     assert lib != ~\"\";\n \n-    if vec::contains(p(cstore).used_libraries, lib) { ret false; }\n+    if vec::contains(p(cstore).used_libraries, lib) { return false; }\n     vec::push(p(cstore).used_libraries, lib);\n-    ret true;\n+    return true;\n }\n \n fn get_used_libraries(cstore: cstore) -> ~[~str] {\n-    ret p(cstore).used_libraries;\n+    return p(cstore).used_libraries;\n }\n \n fn add_used_link_args(cstore: cstore, args: ~str) {\n     vec::push_all(p(cstore).used_link_args, str::split_char(args, ' '));\n }\n \n fn get_used_link_args(cstore: cstore) -> ~[~str] {\n-    ret p(cstore).used_link_args;\n+    return p(cstore).used_link_args;\n }\n \n fn add_use_stmt_cnum(cstore: cstore, use_id: ast::node_id,\n@@ -164,15 +164,15 @@ fn get_dep_hashes(cstore: cstore) -> ~[@~str] {\n         vec::push(result, {name: @cdata.name, hash: hash});\n     };\n     fn lteq(a: crate_hash, b: crate_hash) -> bool {\n-        ret *a.name <= *b.name;\n+        return *a.name <= *b.name;\n     }\n     let sorted = std::sort::merge_sort(lteq, result);\n     debug!{\"sorted:\"};\n     for sorted.each |x| {\n         debug!{\"  hash[%s]: %s\", *x.name, *x.hash};\n     }\n-    fn mapper(ch: crate_hash) -> @~str { ret ch.hash; }\n-    ret vec::map(sorted, mapper);\n+    fn mapper(ch: crate_hash) -> @~str { return ch.hash; }\n+    return vec::map(sorted, mapper);\n }\n \n fn get_path(cstore: cstore, d: ast::def_id) -> ~[ast::ident] {"}, {"sha": "f8252a04ed09127a62fd389676a9a4fe084f7006", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -75,15 +75,15 @@ fn lookup_hash(d: ebml::doc, eq_fn: fn(x:&[u8]) -> bool, hash: uint) ->\n     for ebml::tagged_docs(bucket, belt) |elt| {\n         let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n         if eq_fn(vec::slice(*elt.data, elt.start + 4u, elt.end)) {\n-            ret some(ebml::doc_at(d.data, pos).doc);\n+            return some(ebml::doc_at(d.data, pos).doc);\n         }\n     };\n     none\n }\n \n fn maybe_find_item(item_id: int, items: ebml::doc) -> option<ebml::doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n-        ret io::u64_from_be_bytes(vec::slice(bytes, 0u, 4u), 0u, 4u) as int\n+        return io::u64_from_be_bytes(vec::slice(bytes, 0u, 4u), 0u, 4u) as int\n             == item_id;\n     }\n     lookup_hash(items,\n@@ -92,7 +92,7 @@ fn maybe_find_item(item_id: int, items: ebml::doc) -> option<ebml::doc> {\n }\n \n fn find_item(item_id: int, items: ebml::doc) -> ebml::doc {\n-    ret option::get(maybe_find_item(item_id, items));\n+    return option::get(maybe_find_item(item_id, items));\n }\n \n // Looks up an item in the given metadata and returns an ebml doc pointing\n@@ -112,20 +112,20 @@ fn item_family(item: ebml::doc) -> char {\n \n fn item_symbol(item: ebml::doc) -> ~str {\n     let sym = ebml::get_doc(item, tag_items_data_item_symbol);\n-    ret str::from_bytes(ebml::doc_data(sym));\n+    return str::from_bytes(ebml::doc_data(sym));\n }\n \n fn item_parent_item(d: ebml::doc) -> option<ast::def_id> {\n     for ebml::tagged_docs(d, tag_items_data_parent_item) |did| {\n-        ret some(ebml::with_doc_data(did, |d| parse_def_id(d)));\n+        return some(ebml::with_doc_data(did, |d| parse_def_id(d)));\n     }\n     none\n }\n \n // XXX: This has nothing to do with classes.\n fn class_member_id(d: ebml::doc, cdata: cmd) -> ast::def_id {\n     let tagdoc = ebml::get_doc(d, tag_def_id);\n-    ret translate_def_id(cdata, ebml::with_doc_data(tagdoc,\n+    return translate_def_id(cdata, ebml::with_doc_data(tagdoc,\n                                                     |d| parse_def_id(d)));\n }\n \n@@ -204,7 +204,7 @@ fn enum_variant_ids(item: ebml::doc, cdata: cmd) -> ~[ast::def_id] {\n         let ext = ebml::with_doc_data(p, |d| parse_def_id(d));\n         vec::push(ids, {crate: cdata.cnum, node: ext.node});\n     };\n-    ret ids;\n+    return ids;\n }\n \n // Given a path and serialized crate metadata, returns the IDs of the\n@@ -215,16 +215,16 @@ fn resolve_path(path: ~[ast::ident], data: @~[u8]) -> ~[ast::def_id] {\n         let data_len = data.len();\n         let s_len = s.len();\n         if data_len != s_len {\n-            ret false;\n+            return false;\n         }\n         let mut i = 0;\n         while i < data_len {\n             if data[i] != s[i] {\n-                ret false;\n+                return false;\n             }\n             i += 1;\n         }\n-        ret true;\n+        return true;\n     }\n     let s = ast_util::path_name_i(path);\n     let md = ebml::doc(data);\n@@ -236,7 +236,7 @@ fn resolve_path(path: ~[ast::ident], data: @~[u8]) -> ~[ast::def_id] {\n         let did_doc = ebml::get_doc(doc, tag_def_id);\n         vec::push(result, ebml::with_doc_data(did_doc, |d| parse_def_id(d)));\n     }\n-    ret result;\n+    return result;\n }\n \n fn item_path(item_doc: ebml::doc) -> ast_map::path {\n@@ -260,7 +260,7 @@ fn item_path(item_doc: ebml::doc) -> ast_map::path {\n         }\n     }\n \n-    ret result;\n+    return result;\n }\n \n fn item_name(item: ebml::doc) -> ast::ident {\n@@ -304,7 +304,7 @@ fn lookup_def(cnum: ast::crate_num, data: @~[u8], did_: ast::def_id) ->\n     let item = lookup_item(did_.node, data);\n     let did = {crate: cnum, node: did_.node};\n     // We treat references to enums as references to types.\n-    ret def_like_to_def(item_to_def_like(item, did, cnum));\n+    return def_like_to_def(item_to_def_like(item, did, cnum));\n }\n \n fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n@@ -316,12 +316,12 @@ fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n         item_ty_param_bounds(item, tcx, cdata)\n     } else { @~[] };\n     let rp = item_ty_region_param(item);\n-    ret {bounds: tp_bounds, rp: rp, ty: t};\n+    return {bounds: tp_bounds, rp: rp, ty: t};\n }\n \n fn get_region_param(cdata: cmd, id: ast::node_id) -> bool {\n     let item = lookup_item(id, cdata.data);\n-    ret item_ty_region_param(item);\n+    return item_ty_region_param(item);\n }\n \n fn get_type_param_count(data: @~[u8], id: ast::node_id) -> uint {\n@@ -382,7 +382,7 @@ fn class_dtor(cdata: cmd, id: ast::node_id) -> option<ast::def_id> {\n }\n \n fn get_symbol(data: @~[u8], id: ast::node_id) -> ~str {\n-    ret item_symbol(lookup_item(id, data));\n+    return item_symbol(lookup_item(id, data));\n }\n \n // Something that a name can resolve to.\n@@ -394,7 +394,7 @@ enum def_like {\n \n fn def_like_to_def(def_like: def_like) -> ast::def {\n     alt def_like {\n-        dl_def(def) { ret def; }\n+        dl_def(def) { return def; }\n         dl_impl(*) { fail ~\"found impl in def_like_to_def\"; }\n         dl_field { fail ~\"found field in def_like_to_def\"; }\n     }\n@@ -445,7 +445,7 @@ fn each_path(cdata: cmd, f: fn(path_entry) -> bool) {\n \n     // If broken, stop here.\n     if broken {\n-        ret;\n+        return;\n     }\n \n     // Next, go through all the paths. We will find items that we didn't know\n@@ -561,7 +561,7 @@ fn get_enum_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n                            id: did, disr_val: disr_val});\n         disr_val += 1;\n     }\n-    ret infos;\n+    return infos;\n }\n \n // NB: These types are duplicated in resolve.rs\n@@ -591,10 +591,10 @@ fn get_self_ty(item: ebml::doc) -> ast::self_ty_ {\n \n     let self_ty_kind = string[0];\n     alt self_ty_kind as char {\n-        'r' => { ret ast::sty_by_ref; }\n-        'v' => { ret ast::sty_value; }\n-        '@' => { ret ast::sty_box(get_mutability(string[1])); }\n-        '~' => { ret ast::sty_uniq(get_mutability(string[1])); }\n+        'r' => { return ast::sty_by_ref; }\n+        'v' => { return ast::sty_value; }\n+        '@' => { return ast::sty_box(get_mutability(string[1])); }\n+        '~' => { return ast::sty_uniq(get_mutability(string[1])); }\n         '&' => {\n             let mutability = get_mutability(string[1]);\n \n@@ -609,7 +609,7 @@ fn get_self_ty(item: ebml::doc) -> ast::self_ty_ {\n                 region = ast::re_named(@region_string);\n             }\n \n-            ret ast::sty_region(@{ id: 0, node: region }, mutability);\n+            return ast::sty_region(@{ id: 0, node: region }, mutability);\n         }\n         _ => {\n             fail fmt!{\"unknown self type code: `%c`\", self_ty_kind as char};\n@@ -698,14 +698,14 @@ fn get_method_names_if_trait(cdata: cmd, node_id: ast::node_id)\n \n     let item = lookup_item(node_id, cdata.data);\n     if item_family(item) != 'I' {\n-        ret none;\n+        return none;\n     }\n \n     let resulting_method_names = @dvec();\n     for ebml::tagged_docs(item, tag_item_trait_method) |method| {\n         (*resulting_method_names).push(item_name(method));\n     }\n-    ret some(resulting_method_names);\n+    return some(resulting_method_names);\n }\n \n fn get_item_attrs(cdata: cmd,\n@@ -769,39 +769,39 @@ fn read_path(d: ebml::doc) -> {path: ~str, pos: uint} {\n     let pos = io::u64_from_be_bytes(desc, 0u, 4u) as uint;\n     let pathbytes = vec::slice::<u8>(desc, 4u, vec::len::<u8>(desc));\n     let path = str::from_bytes(pathbytes);\n-    ret {path: path, pos: pos};\n+    return {path: path, pos: pos};\n }\n \n fn describe_def(items: ebml::doc, id: ast::def_id) -> ~str {\n-    if id.crate != ast::local_crate { ret ~\"external\"; }\n+    if id.crate != ast::local_crate { return ~\"external\"; }\n     let it = alt maybe_find_item(id.node, items) {\n         some(it) { it }\n         none { fail (fmt!{\"describe_def: item not found %?\", id}); }\n     };\n-    ret item_family_to_str(item_family(it));\n+    return item_family_to_str(item_family(it));\n }\n \n fn item_family_to_str(fam: char) -> ~str {\n     alt check fam {\n-      'c' { ret ~\"const\"; }\n-      'f' { ret ~\"fn\"; }\n-      'u' { ret ~\"unsafe fn\"; }\n-      'p' { ret ~\"pure fn\"; }\n-      'F' { ret ~\"foreign fn\"; }\n-      'U' { ret ~\"unsafe foreign fn\"; }\n-      'P' { ret ~\"pure foreign fn\"; }\n-      'y' { ret ~\"type\"; }\n-      'T' { ret ~\"foreign type\"; }\n-      't' { ret ~\"type\"; }\n-      'm' { ret ~\"mod\"; }\n-      'n' { ret ~\"foreign mod\"; }\n-      'v' { ret ~\"enum\"; }\n-      'i' { ret ~\"impl\"; }\n-      'I' { ret ~\"trait\"; }\n-      'C' { ret ~\"class\"; }\n-      'S' { ret ~\"struct\"; }\n-      'g' { ret ~\"public field\"; }\n-      'j' { ret ~\"private field\"; }\n+      'c' { return ~\"const\"; }\n+      'f' { return ~\"fn\"; }\n+      'u' { return ~\"unsafe fn\"; }\n+      'p' { return ~\"pure fn\"; }\n+      'F' { return ~\"foreign fn\"; }\n+      'U' { return ~\"unsafe foreign fn\"; }\n+      'P' { return ~\"pure foreign fn\"; }\n+      'y' { return ~\"type\"; }\n+      'T' { return ~\"foreign type\"; }\n+      't' { return ~\"type\"; }\n+      'm' { return ~\"mod\"; }\n+      'n' { return ~\"foreign mod\"; }\n+      'v' { return ~\"enum\"; }\n+      'i' { return ~\"impl\"; }\n+      'I' { return ~\"trait\"; }\n+      'C' { return ~\"class\"; }\n+      'S' { return ~\"struct\"; }\n+      'g' { return ~\"public field\"; }\n+      'j' { return ~\"private field\"; }\n     }\n }\n \n@@ -827,7 +827,7 @@ fn get_meta_items(md: ebml::doc) -> ~[@ast::meta_item] {\n         let subitems = get_meta_items(meta_item_doc);\n         vec::push(items, attr::mk_list_item(@n, subitems));\n     };\n-    ret items;\n+    return items;\n }\n \n fn get_attributes(md: ebml::doc) -> ~[ast::attribute] {\n@@ -848,7 +848,7 @@ fn get_attributes(md: ebml::doc) -> ~[ast::attribute] {\n       }\n       option::none { }\n     }\n-    ret attrs;\n+    return attrs;\n }\n \n fn list_meta_items(meta_items: ebml::doc, out: io::writer) {\n@@ -868,7 +868,7 @@ fn list_crate_attributes(md: ebml::doc, hash: @~str, out: io::writer) {\n }\n \n fn get_crate_attributes(data: @~[u8]) -> ~[ast::attribute] {\n-    ret get_attributes(ebml::doc(data));\n+    return get_attributes(ebml::doc(data));\n }\n \n type crate_dep = {cnum: ast::crate_num, name: ast::ident,\n@@ -889,7 +889,7 @@ fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n                   hash: @docstr(depdoc, tag_crate_dep_hash)});\n         crate_num += 1;\n     };\n-    ret deps;\n+    return deps;\n }\n \n fn list_crate_deps(data: @~[u8], out: io::writer) {\n@@ -906,12 +906,12 @@ fn list_crate_deps(data: @~[u8], out: io::writer) {\n fn get_crate_hash(data: @~[u8]) -> @~str {\n     let cratedoc = ebml::doc(data);\n     let hashdoc = ebml::get_doc(cratedoc, tag_crate_hash);\n-    ret @str::from_bytes(ebml::doc_data(hashdoc));\n+    return @str::from_bytes(ebml::doc_data(hashdoc));\n }\n \n fn get_crate_vers(data: @~[u8]) -> @~str {\n     let attrs = decoder::get_crate_attributes(data);\n-    ret alt attr::last_meta_item_value_str_by_name(\n+    return alt attr::last_meta_item_value_str_by_name(\n         attr::find_linkage_metas(attrs), ~\"vers\") {\n       some(ver) { ver }\n       none { @~\"0.0\" }\n@@ -968,7 +968,7 @@ fn get_crate_module_paths(bytes: @~[u8]) -> ~[(ast::def_id, ~str)] {\n         // unified later by using the mods map\n         vec::push(res, (did, path));\n     }\n-    ret do vec::filter(res) |x| {\n+    return do vec::filter(res) |x| {\n         let (_, xp) = x;\n         mods.contains_key(xp)\n     }\n@@ -989,11 +989,11 @@ fn list_crate_metadata(bytes: @~[u8], out: io::writer) {\n // crate to the correct local crate number.\n fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n     if did.crate == ast::local_crate {\n-        ret {crate: cdata.cnum, node: did.node};\n+        return {crate: cdata.cnum, node: did.node};\n     }\n \n     alt cdata.cnum_map.find(did.crate) {\n-      option::some(n) { ret {crate: n, node: did.node}; }\n+      option::some(n) { return {crate: n, node: did.node}; }\n       option::none { fail ~\"didn't find a crate in the cnum_map\"; }\n     }\n }"}, {"sha": "6dd4e0142de29b3ad16c6eccab49db1ac58ea425", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -248,7 +248,7 @@ fn encode_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt, crate: @crate)\n     encode_module_item_paths(ebml_w, ecx, crate.node.module, path, index);\n     encode_reexport_paths(ebml_w, ecx, index);\n     ebml_w.end_tag();\n-    ret index;\n+    return index;\n }\n \n fn encode_reexport_paths(ebml_w: ebml::writer,\n@@ -273,7 +273,7 @@ fn encode_family(ebml_w: ebml::writer, c: char) {\n     ebml_w.end_tag();\n }\n \n-fn def_to_str(did: def_id) -> ~str { ret fmt!{\"%d:%d\", did.crate, did.node}; }\n+fn def_to_str(did: def_id) -> ~str { fmt!{\"%d:%d\", did.crate, did.node} }\n \n fn encode_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                             params: ~[ty_param]) {\n@@ -617,7 +617,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                 false\n             }\n         };\n-    if !must_write && !reachable(ecx, item.id) { ret; }\n+    if !must_write && !reachable(ecx, item.id) { return; }\n \n     fn add_to_index_(item: @item, ebml_w: ebml::writer,\n                      index: @mut ~[entry<int>]) {\n@@ -854,7 +854,7 @@ fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                                 nitem: @foreign_item,\n                                 index: @mut ~[entry<int>],\n                                 path: ast_map::path, abi: foreign_abi) {\n-    if !reachable(ecx, nitem.id) { ret; }\n+    if !reachable(ecx, nitem.id) { return; }\n     vec::push(*index, {val: nitem.id, pos: ebml_w.writer.tell()});\n \n     ebml_w.start_tag(tag_items_data_item);\n@@ -922,7 +922,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         with *visit::default_visitor()\n     }));\n     ebml_w.end_tag();\n-    ret *index;\n+    return *index;\n }\n \n \n@@ -941,7 +941,7 @@ fn create_index<T: copy>(index: ~[entry<T>], hash_fn: fn@(T) -> uint) ->\n     for buckets.each |bucket| {\n         vec::push(buckets_frozen, @*bucket);\n     }\n-    ret buckets_frozen;\n+    return buckets_frozen;\n }\n \n fn encode_index<T>(ebml_w: ebml::writer, buckets: ~[@~[entry<T>]],\n@@ -1047,7 +1047,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n         let meta_items = vec::append(~[name_item, vers_item], other_items);\n         let link_item = attr::mk_list_item(@~\"link\", meta_items);\n \n-        ret attr::mk_attr(link_item);\n+        return attr::mk_attr(link_item);\n     }\n \n     let mut attrs: ~[attribute] = ~[];\n@@ -1070,7 +1070,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n \n     if !found_link_attr { vec::push(attrs, synthesize_link_attr(ecx, ~[])); }\n \n-    ret attrs;\n+    return attrs;\n }\n \n fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n@@ -1100,7 +1100,7 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n         }\n \n         // mut -> immutable hack for vec::map\n-        ret vec::slice(deps, 0u, vec::len(deps));\n+        return vec::slice(deps, 0u, vec::len(deps));\n     }\n \n     // We're just going to write a list of crate 'name-hash-version's, with\n@@ -1189,7 +1189,7 @@ fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> ~str {\n                abbrevs: tyencode::ac_no_abbrevs};\n     let buf = io::mem_buffer();\n     tyencode::enc_ty(io::mem_buffer_writer(buf), cx, t);\n-    ret io::mem_buffer_str(buf);\n+    return io::mem_buffer_str(buf);\n }\n \n "}, {"sha": "65dd8a5a3e8fb3b5a7194c7c4ed1de574560bc0d", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -85,7 +85,7 @@ fn search<T: copy>(filesearch: filesearch, pick: pick<T>) -> option<T> {\n         }\n         if option::is_some(rslt) { break; }\n     }\n-    ret rslt;\n+    return rslt;\n }\n \n fn relative_target_lib_path(target_triple: ~str) -> ~[path] {\n@@ -97,7 +97,7 @@ fn make_target_lib_path(sysroot: path,\n     let path = vec::append(~[sysroot],\n                            relative_target_lib_path(target_triple));\n     let path = path::connect_many(path);\n-    ret path;\n+    return path;\n }\n \n fn get_default_sysroot() -> path {"}, {"sha": "c3949acb0af03a36e8c2b3dfd6747a197487ec91", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -38,7 +38,7 @@ type ctxt = {\n \n fn load_library_crate(cx: ctxt) -> {ident: ~str, data: @~[u8]} {\n     alt find_library_crate(cx) {\n-      some(t) { ret t; }\n+      some(t) { return t; }\n       none {\n         cx.diag.span_fatal(\n             cx.span, fmt!{\"can't find crate for `%s`\", *cx.ident});\n@@ -52,12 +52,12 @@ fn find_library_crate(cx: ctxt) -> option<{ident: ~str, data: @~[u8]}> {\n }\n \n fn libname(cx: ctxt) -> {prefix: ~str, suffix: ~str} {\n-    if cx.static { ret {prefix: ~\"lib\", suffix: ~\".rlib\"}; }\n+    if cx.static { return {prefix: ~\"lib\", suffix: ~\".rlib\"}; }\n     alt cx.os {\n-      os_win32 { ret {prefix: ~\"\", suffix: ~\".dll\"}; }\n-      os_macos { ret {prefix: ~\"lib\", suffix: ~\".dylib\"}; }\n-      os_linux { ret {prefix: ~\"lib\", suffix: ~\".so\"}; }\n-      os_freebsd { ret {prefix: ~\"lib\", suffix: ~\".so\"}; }\n+      os_win32 { return {prefix: ~\"\", suffix: ~\".dll\"}; }\n+      os_macos { return {prefix: ~\"lib\", suffix: ~\".dylib\"}; }\n+      os_linux { return {prefix: ~\"lib\", suffix: ~\".so\"}; }\n+      os_freebsd { return {prefix: ~\"lib\", suffix: ~\".so\"}; }\n     }\n }\n \n@@ -143,7 +143,7 @@ fn crate_matches(crate_data: @~[u8], metas: ~[@ast::meta_item],\n     let linkage_metas = attr::find_linkage_metas(attrs);\n     if hash.is_not_empty() {\n         let chash = decoder::get_crate_hash(crate_data);\n-        if *chash != hash { ret false; }\n+        if *chash != hash { return false; }\n     }\n     metadata_matches(linkage_metas, metas)\n }\n@@ -163,21 +163,21 @@ fn metadata_matches(extern_metas: ~[@ast::meta_item],\n         debug!{\"looking for %s\", pprust::meta_item_to_str(*needed)};\n         if !attr::contains(extern_metas, needed) {\n             debug!{\"missing %s\", pprust::meta_item_to_str(*needed)};\n-            ret false;\n+            return false;\n         }\n     }\n-    ret true;\n+    return true;\n }\n \n fn get_metadata_section(os: os,\n                         filename: ~str) -> option<@~[u8]> unsafe {\n     let mb = str::as_c_str(filename, |buf| {\n         llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n                                    });\n-    if mb as int == 0 { ret option::none::<@~[u8]>; }\n+    if mb as int == 0 { return option::none::<@~[u8]>; }\n     let of = alt mk_object_file(mb) {\n         option::some(of) { of }\n-        _ { ret option::none::<@~[u8]>; }\n+        _ { return option::none::<@~[u8]>; }\n     };\n     let si = mk_section_iter(of.llof);\n     while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n@@ -188,12 +188,12 @@ fn get_metadata_section(os: os,\n             let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n             unsafe {\n                 let cvbuf: *u8 = unsafe::reinterpret_cast(cbuf);\n-                ret some(@vec::unsafe::from_buf(cvbuf, csz));\n+                return some(@vec::unsafe::from_buf(cvbuf, csz));\n             }\n         }\n         llvm::LLVMMoveToNextSection(si.llsi);\n     }\n-    ret option::none::<@~[u8]>;\n+    return option::none::<@~[u8]>;\n }\n \n fn meta_section_name(os: os) -> ~str {"}, {"sha": "df7bea1bd0e273f7fb6394d6a104fd3f45416d8e", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -26,18 +26,18 @@ fn peek(st: @pstate) -> char {\n fn next(st: @pstate) -> char {\n     let ch = st.data[st.pos] as char;\n     st.pos = st.pos + 1u;\n-    ret ch;\n+    return ch;\n }\n \n fn next_byte(st: @pstate) -> u8 {\n     let b = st.data[st.pos];\n     st.pos = st.pos + 1u;\n-    ret b;\n+    return b;\n }\n \n fn parse_ident(st: @pstate, last: char) -> ast::ident {\n-    fn is_last(b: char, c: char) -> bool { ret c == b; }\n-    ret parse_ident_(st, |a| is_last(last, a) );\n+    fn is_last(b: char, c: char) -> bool { return c == b; }\n+    return parse_ident_(st, |a| is_last(last, a) );\n }\n \n fn parse_ident_(st: @pstate, is_last: fn@(char) -> bool) ->\n@@ -46,7 +46,7 @@ fn parse_ident_(st: @pstate, is_last: fn@(char) -> bool) ->\n     while !is_last(peek(st)) {\n         rslt += str::from_byte(next_byte(st));\n     }\n-    ret @rslt;\n+    return @rslt;\n }\n \n \n@@ -65,14 +65,14 @@ fn parse_ret_ty(st: @pstate, conv: conv_did) -> (ast::ret_style, ty::t) {\n \n fn parse_path(st: @pstate) -> @ast::path {\n     let mut idents: ~[ast::ident] = ~[];\n-    fn is_last(c: char) -> bool { ret c == '(' || c == ':'; }\n+    fn is_last(c: char) -> bool { return c == '(' || c == ':'; }\n     vec::push(idents, parse_ident_(st, is_last));\n     loop {\n         alt peek(st) {\n           ':' { next(st); next(st); }\n           c {\n             if c == '(' {\n-                ret @{span: ast_util::dummy_sp(),\n+                return @{span: ast_util::dummy_sp(),\n                       global: false, idents: idents,\n                       rp: none, types: ~[]};\n             } else { vec::push(idents, parse_ident_(st, is_last)); }\n@@ -82,7 +82,7 @@ fn parse_path(st: @pstate) -> @ast::path {\n }\n \n fn parse_ty_rust_fn(st: @pstate, conv: conv_did) -> ty::t {\n-    ret ty::mk_fn(st.tcx, parse_ty_fn(st, conv));\n+    return ty::mk_fn(st.tcx, parse_ty_fn(st, conv));\n }\n \n fn parse_proto(c: char) -> ast::proto {\n@@ -103,7 +103,7 @@ fn parse_vstore(st: @pstate) -> ty::vstore {\n     if '0' <= c && c <= '9' {\n         let n = parse_int(st) as uint;\n         assert next(st) == '|';\n-        ret ty::vstore_fixed(n);\n+        return ty::vstore_fixed(n);\n     }\n \n     alt check next(st) {\n@@ -123,7 +123,7 @@ fn parse_substs(st: @pstate, conv: conv_did) -> ty::substs {\n     while peek(st) != ']' { vec::push(params, parse_ty(st, conv)); }\n     st.pos = st.pos + 1u;\n \n-    ret {self_r: self_r,\n+    return {self_r: self_r,\n          self_ty: self_ty,\n          tps: params};\n }\n@@ -178,70 +178,70 @@ fn parse_str(st: @pstate, term: char) -> ~str {\n         result += str::from_byte(next_byte(st));\n     }\n     next(st);\n-    ret result;\n+    return result;\n }\n \n fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n     alt check next(st) {\n-      'n' { ret ty::mk_nil(st.tcx); }\n-      'z' { ret ty::mk_bot(st.tcx); }\n-      'b' { ret ty::mk_bool(st.tcx); }\n-      'i' { ret ty::mk_int(st.tcx); }\n-      'u' { ret ty::mk_uint(st.tcx); }\n-      'l' { ret ty::mk_float(st.tcx); }\n+      'n' { return ty::mk_nil(st.tcx); }\n+      'z' { return ty::mk_bot(st.tcx); }\n+      'b' { return ty::mk_bool(st.tcx); }\n+      'i' { return ty::mk_int(st.tcx); }\n+      'u' { return ty::mk_uint(st.tcx); }\n+      'l' { return ty::mk_float(st.tcx); }\n       'M' {\n         alt check next(st) {\n-          'b' { ret ty::mk_mach_uint(st.tcx, ast::ty_u8); }\n-          'w' { ret ty::mk_mach_uint(st.tcx, ast::ty_u16); }\n-          'l' { ret ty::mk_mach_uint(st.tcx, ast::ty_u32); }\n-          'd' { ret ty::mk_mach_uint(st.tcx, ast::ty_u64); }\n-          'B' { ret ty::mk_mach_int(st.tcx, ast::ty_i8); }\n-          'W' { ret ty::mk_mach_int(st.tcx, ast::ty_i16); }\n-          'L' { ret ty::mk_mach_int(st.tcx, ast::ty_i32); }\n-          'D' { ret ty::mk_mach_int(st.tcx, ast::ty_i64); }\n-          'f' { ret ty::mk_mach_float(st.tcx, ast::ty_f32); }\n-          'F' { ret ty::mk_mach_float(st.tcx, ast::ty_f64); }\n+          'b' { return ty::mk_mach_uint(st.tcx, ast::ty_u8); }\n+          'w' { return ty::mk_mach_uint(st.tcx, ast::ty_u16); }\n+          'l' { return ty::mk_mach_uint(st.tcx, ast::ty_u32); }\n+          'd' { return ty::mk_mach_uint(st.tcx, ast::ty_u64); }\n+          'B' { return ty::mk_mach_int(st.tcx, ast::ty_i8); }\n+          'W' { return ty::mk_mach_int(st.tcx, ast::ty_i16); }\n+          'L' { return ty::mk_mach_int(st.tcx, ast::ty_i32); }\n+          'D' { return ty::mk_mach_int(st.tcx, ast::ty_i64); }\n+          'f' { return ty::mk_mach_float(st.tcx, ast::ty_f32); }\n+          'F' { return ty::mk_mach_float(st.tcx, ast::ty_f64); }\n         }\n       }\n-      'c' { ret ty::mk_char(st.tcx); }\n+      'c' { return ty::mk_char(st.tcx); }\n       't' {\n         assert (next(st) == '[');\n         let def = parse_def(st, conv);\n         let substs = parse_substs(st, conv);\n         assert next(st) == ']';\n-        ret ty::mk_enum(st.tcx, def, substs);\n+        return ty::mk_enum(st.tcx, def, substs);\n       }\n       'x' {\n         assert next(st) == '[';\n         let def = parse_def(st, conv);\n         let substs = parse_substs(st, conv);\n         assert next(st) == ']';\n-        ret ty::mk_trait(st.tcx, def, substs);\n+        return ty::mk_trait(st.tcx, def, substs);\n       }\n       'p' {\n         let did = parse_def(st, conv);\n-        ret ty::mk_param(st.tcx, parse_int(st) as uint, did);\n+        return ty::mk_param(st.tcx, parse_int(st) as uint, did);\n       }\n       's' {\n-        ret ty::mk_self(st.tcx);\n+        return ty::mk_self(st.tcx);\n       }\n-      '@' { ret ty::mk_box(st.tcx, parse_mt(st, conv)); }\n-      '~' { ret ty::mk_uniq(st.tcx, parse_mt(st, conv)); }\n-      '*' { ret ty::mk_ptr(st.tcx, parse_mt(st, conv)); }\n+      '@' { return ty::mk_box(st.tcx, parse_mt(st, conv)); }\n+      '~' { return ty::mk_uniq(st.tcx, parse_mt(st, conv)); }\n+      '*' { return ty::mk_ptr(st.tcx, parse_mt(st, conv)); }\n       '&' {\n         let r = parse_region(st);\n         let mt = parse_mt(st, conv);\n-        ret ty::mk_rptr(st.tcx, r, mt);\n+        return ty::mk_rptr(st.tcx, r, mt);\n       }\n-      'U' { ret ty::mk_unboxed_vec(st.tcx, parse_mt(st, conv)); }\n+      'U' { return ty::mk_unboxed_vec(st.tcx, parse_mt(st, conv)); }\n       'V' {\n         let mt = parse_mt(st, conv);\n         let v = parse_vstore(st);\n-        ret ty::mk_evec(st.tcx, mt, v);\n+        return ty::mk_evec(st.tcx, mt, v);\n       }\n       'v' {\n         let v = parse_vstore(st);\n-        ret ty::mk_estr(st.tcx, v);\n+        return ty::mk_estr(st.tcx, v);\n       }\n       'R' {\n         assert (next(st) == '[');\n@@ -251,42 +251,42 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n             vec::push(fields, {ident: name, mt: parse_mt(st, conv)});\n         }\n         st.pos = st.pos + 1u;\n-        ret ty::mk_rec(st.tcx, fields);\n+        return ty::mk_rec(st.tcx, fields);\n       }\n       'T' {\n         assert (next(st) == '[');\n         let mut params = ~[];\n         while peek(st) != ']' { vec::push(params, parse_ty(st, conv)); }\n         st.pos = st.pos + 1u;\n-        ret ty::mk_tup(st.tcx, params);\n+        return ty::mk_tup(st.tcx, params);\n       }\n       'f' {\n         parse_ty_rust_fn(st, conv)\n       }\n       'X' {\n-        ret ty::mk_var(st.tcx, ty::tv_vid(parse_int(st) as uint));\n+        return ty::mk_var(st.tcx, ty::tv_vid(parse_int(st) as uint));\n       }\n-      'Y' { ret ty::mk_type(st.tcx); }\n+      'Y' { return ty::mk_type(st.tcx); }\n       'C' {\n         let ck = alt check next(st) {\n           '&' { ty::ck_block }\n           '@' { ty::ck_box }\n           '~' { ty::ck_uniq }\n         };\n-        ret ty::mk_opaque_closure_ptr(st.tcx, ck);\n+        return ty::mk_opaque_closure_ptr(st.tcx, ck);\n       }\n       '#' {\n         let pos = parse_hex(st);\n         assert (next(st) == ':');\n         let len = parse_hex(st);\n         assert (next(st) == '#');\n         alt st.tcx.rcache.find({cnum: st.crate, pos: pos, len: len}) {\n-          some(tt) { ret tt; }\n+          some(tt) { return tt; }\n           none {\n             let ps = @{pos: pos with *st};\n             let tt = parse_ty(ps, conv);\n             st.tcx.rcache.insert({cnum: st.crate, pos: pos, len: len}, tt);\n-            ret tt;\n+            return tt;\n           }\n         }\n       }\n@@ -304,7 +304,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n           debug!{\"parsed a def_id %?\", did};\n           let substs = parse_substs(st, conv);\n           assert (next(st) == ']');\n-          ret ty::mk_class(st.tcx, did, substs);\n+          return ty::mk_class(st.tcx, did, substs);\n       }\n       c { error!{\"unexpected char in type string: %c\", c}; fail;}\n     }\n@@ -317,21 +317,21 @@ fn parse_mt(st: @pstate, conv: conv_did) -> ty::mt {\n       '?' { next(st); m = ast::m_const; }\n       _ { m = ast::m_imm; }\n     }\n-    ret {ty: parse_ty(st, conv), mutbl: m};\n+    return {ty: parse_ty(st, conv), mutbl: m};\n }\n \n fn parse_def(st: @pstate, conv: conv_did) -> ast::def_id {\n     let mut def = ~[];\n     while peek(st) != '|' { vec::push(def, next_byte(st)); }\n     st.pos = st.pos + 1u;\n-    ret conv(parse_def_id(def));\n+    return conv(parse_def_id(def));\n }\n \n fn parse_int(st: @pstate) -> int {\n     let mut n = 0;\n     loop {\n         let cur = peek(st);\n-        if cur < '0' || cur > '9' { ret n; }\n+        if cur < '0' || cur > '9' { return n; }\n         st.pos = st.pos + 1u;\n         n *= 10;\n         n += (cur as int) - ('0' as int);\n@@ -342,7 +342,7 @@ fn parse_hex(st: @pstate) -> uint {\n     let mut n = 0u;\n     loop {\n         let cur = peek(st);\n-        if (cur < '0' || cur > '9') && (cur < 'a' || cur > 'f') { ret n; }\n+        if (cur < '0' || cur > '9') && (cur < 'a' || cur > 'f') { return n; }\n         st.pos = st.pos + 1u;\n         n *= 16u;\n         if '0' <= cur && cur <= '9' {\n@@ -378,7 +378,7 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n     }\n     st.pos += 1u; // eat the ']'\n     let (ret_style, ret_ty) = parse_ret_ty(st, conv);\n-    ret {purity: purity, proto: proto, inputs: inputs, output: ret_ty,\n+    return {purity: purity, proto: proto, inputs: inputs, output: ret_ty,\n          ret_style: ret_style};\n }\n \n@@ -405,7 +405,7 @@ fn parse_def_id(buf: &[u8]) -> ast::def_id {\n        none { fail (fmt!{\"internal error: parse_def_id: id expected, but \\\n          found %?\", def_part}); }\n     };\n-    ret {crate: crate_num, node: def_num};\n+    return {crate: crate_num, node: def_num};\n }\n \n fn parse_bounds_data(data: @~[u8], start: uint,"}, {"sha": "02a6b0f826a82a88276088b60da70e70f2551775", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -35,8 +35,8 @@ enum abbrev_ctxt { ac_no_abbrevs, ac_use_abbrevs(hashmap<ty::t, ty_abbrev>), }\n \n fn cx_uses_abbrevs(cx: @ctxt) -> bool {\n     alt cx.abbrevs {\n-      ac_no_abbrevs { ret false; }\n-      ac_use_abbrevs(_) { ret true; }\n+      ac_no_abbrevs { return false; }\n+      ac_use_abbrevs(_) { return true; }\n     }\n }\n \n@@ -56,7 +56,7 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n       }\n       ac_use_abbrevs(abbrevs) {\n         alt abbrevs.find(t) {\n-          some(a) { w.write_str(*a.s); ret; }\n+          some(a) { w.write_str(*a.s); return; }\n           none {\n             let pos = w.tell();\n             alt ty::type_def_id(t) {\n@@ -79,7 +79,7 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n                 let mut n = u;\n                 let mut len = 0u;\n                 while n != 0u { len += 1u; n = n >> 4u; }\n-                ret len;\n+                return len;\n             }\n             let abbrev_len = 3u + estimate_sz(pos) + estimate_sz(len);\n             if abbrev_len < len {\n@@ -89,7 +89,7 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n                 let a = {pos: pos, len: len, s: @s};\n                 abbrevs.insert(t, a);\n             }\n-            ret;\n+            return;\n           }\n         }\n       }"}, {"sha": "8f672d19047a070d6c9fde0d6347ffd763064899", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -147,12 +147,12 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n fn reserve_id_range(sess: session,\n                     from_id_range: ast_util::id_range) -> ast_util::id_range {\n     // Handle the case of an empty range:\n-    if ast_util::empty(from_id_range) { ret from_id_range; }\n+    if ast_util::empty(from_id_range) { return from_id_range; }\n     let cnt = from_id_range.max - from_id_range.min;\n     let to_id_min = sess.parse_sess.next_id;\n     let to_id_max = sess.parse_sess.next_id + cnt;\n     sess.parse_sess.next_id = to_id_max;\n-    ret {min: to_id_min, max: to_id_min};\n+    return {min: to_id_min, max: to_id_min};\n }\n \n impl translation_routines for extended_decode_ctxt {\n@@ -972,7 +972,7 @@ fn test_more() {\n     roundtrip(#ast[item]{\n         fn foo(x: uint, y: uint) -> uint {\n             let z = x + y;\n-            ret z;\n+            return z;\n         }\n     });\n }\n@@ -983,13 +983,13 @@ fn test_simplification() {\n     let item_in = ast::ii_item(#ast[item] {\n         fn new_int_alist<B: copy>() -> alist<int, B> {\n             fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n-            ret {eq_fn: eq_int, mut data: ~[]};\n+            return {eq_fn: eq_int, mut data: ~[]};\n         }\n     });\n     let item_out = simplify_ast(item_in);\n     let item_exp = ast::ii_item(#ast[item] {\n         fn new_int_alist<B: copy>() -> alist<int, B> {\n-            ret {eq_fn: eq_int, mut data: ~[]};\n+            return {eq_fn: eq_int, mut data: ~[]};\n         }\n     });\n     alt (item_out, item_exp) {"}, {"sha": "3f4a32bff8695c4ec95a8deb67da310e6482018f", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -267,7 +267,7 @@ fn check_crate(tcx: ty::ctxt,\n                          make_stat(bccx, bccx.req_pure_paths)});\n     }\n \n-    ret (bccx.root_map, bccx.mutbl_map);\n+    return (bccx.root_map, bccx.mutbl_map);\n \n     fn make_stat(bccx: borrowck_ctxt, stat: uint) -> ~str {\n         let stat_f = stat as float;\n@@ -410,12 +410,12 @@ fn save_and_restore<T:copy,U>(&save_and_restore_t: T, f: fn() -> U) -> U {\n     let old_save_and_restore_t = save_and_restore_t;\n     let u <- f();\n     save_and_restore_t = old_save_and_restore_t;\n-    ret u;\n+    return u;\n }\n \n /// Creates and returns a new root_map\n fn root_map() -> root_map {\n-    ret hashmap(root_map_key_hash, root_map_key_eq);\n+    return hashmap(root_map_key_hash, root_map_key_eq);\n \n     fn root_map_key_eq(k1: root_map_key, k2: root_map_key) -> bool {\n         k1.id == k2.id && k1.derefs == k2.derefs"}, {"sha": "ebcb380b4e999784512e175a812e1061b0b9b106", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -133,12 +133,12 @@ impl public_methods for borrowck_ctxt {\n         alt expr.node {\n           ast::expr_unary(ast::deref, e_base) {\n             if self.method_map.contains_key(expr.id) {\n-                ret self.cat_rvalue(expr, expr_ty);\n+                return self.cat_rvalue(expr, expr_ty);\n             }\n \n             let base_cmt = self.cat_expr(e_base);\n             alt self.cat_deref(expr, base_cmt, 0u, true) {\n-              some(cmt) { ret cmt; }\n+              some(cmt) { return cmt; }\n               none {\n                 tcx.sess.span_bug(\n                     e_base.span,\n@@ -150,7 +150,7 @@ impl public_methods for borrowck_ctxt {\n \n           ast::expr_field(base, f_name, _) {\n             if self.method_map.contains_key(expr.id) {\n-                ret self.cat_method_ref(expr, expr_ty);\n+                return self.cat_method_ref(expr, expr_ty);\n             }\n \n             let base_cmt = self.cat_autoderef(base);\n@@ -159,7 +159,7 @@ impl public_methods for borrowck_ctxt {\n \n           ast::expr_index(base, _) {\n             if self.method_map.contains_key(expr.id) {\n-                ret self.cat_rvalue(expr, expr_ty);\n+                return self.cat_rvalue(expr, expr_ty);\n             }\n \n             self.cat_index(expr, base)\n@@ -183,7 +183,7 @@ impl public_methods for borrowck_ctxt {\n           ast::expr_lit(*) | ast::expr_break | ast::expr_mac(*) |\n           ast::expr_again | ast::expr_rec(*) | ast::expr_struct(*) |\n           ast::expr_unary_move(*) {\n-            ret self.cat_rvalue(expr, expr_ty);\n+            return self.cat_rvalue(expr, expr_ty);\n           }\n         }\n     }\n@@ -297,7 +297,7 @@ impl public_methods for borrowck_ctxt {\n     }\n \n     fn cat_discr(cmt: cmt, alt_id: ast::node_id) -> cmt {\n-        ret @{cat:cat_discr(cmt, alt_id) with *cmt};\n+        return @{cat:cat_discr(cmt, alt_id) with *cmt};\n     }\n \n     /// inherited mutability: used in cases where the mutability of a\n@@ -388,7 +388,7 @@ impl public_methods for borrowck_ctxt {\n           }\n         };\n \n-        ret alt deref_kind(self.tcx, base_cmt.ty) {\n+        return alt deref_kind(self.tcx, base_cmt.ty) {\n           deref_ptr(ptr) {\n             // (a) the contents are loanable if the base is loanable\n             // and this is a *unique* vector\n@@ -461,7 +461,7 @@ impl private_methods for borrowck_ctxt {\n         loop {\n             ctr += 1u;\n             alt self.cat_deref(base, cmt, ctr, false) {\n-              none { ret cmt; }\n+              none { return cmt; }\n               some(cmt1) { cmt = cmt1; }\n             }\n         }\n@@ -476,7 +476,7 @@ fn field_mutbl(tcx: ty::ctxt,\n       ty::ty_rec(fields) {\n         for fields.each |f| {\n             if f.ident == f_name {\n-                ret some(f.mt.mutbl);\n+                return some(f.mt.mutbl);\n             }\n         }\n       }\n@@ -487,12 +487,12 @@ fn field_mutbl(tcx: ty::ctxt,\n                   ast::class_mutable { ast::m_mutbl }\n                   ast::class_immutable { ast::m_imm }\n                 };\n-                ret some(m);\n+                return some(m);\n             }\n         }\n       }\n       _ { }\n     }\n \n-    ret none;\n+    return none;\n }"}, {"sha": "79c562ae5b859c6ca2359a734ed664cae4ab64d2", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -85,7 +85,7 @@ impl methods for check_loan_ctxt {\n     fn purity(scope_id: ast::node_id) -> option<purity_cause> {\n         let default_purity = alt self.declared_purity {\n           // an unsafe declaration overrides all\n-          ast::unsafe_fn { ret none; }\n+          ast::unsafe_fn { return none; }\n \n           // otherwise, remember what was declared as the\n           // default, but we must scan for requirements\n@@ -103,11 +103,11 @@ impl methods for check_loan_ctxt {\n         loop {\n             alt pure_map.find(scope_id) {\n               none {}\n-              some(e) {ret some(pc_cmt(e));}\n+              some(e) {return some(pc_cmt(e));}\n             }\n \n             alt region_map.find(scope_id) {\n-              none { ret default_purity; }\n+              none { return default_purity; }\n               some(next_scope_id) { scope_id = next_scope_id; }\n             }\n         }\n@@ -123,13 +123,13 @@ impl methods for check_loan_ctxt {\n             for req_loan_map.find(scope_id).each |loanss| {\n                 for (*loanss).each |loans| {\n                     for (*loans).each |loan| {\n-                        if !f(loan) { ret; }\n+                        if !f(loan) { return; }\n                     }\n                 }\n             }\n \n             alt region_map.find(scope_id) {\n-              none { ret; }\n+              none { return; }\n               some(next_scope_id) { scope_id = next_scope_id; }\n             }\n         }\n@@ -140,7 +140,7 @@ impl methods for check_loan_ctxt {\n                      f: fn(loan) -> bool) {\n         for self.walk_loans(scope_id) |loan| {\n             if loan.lp == lp {\n-                if !f(loan) { ret; }\n+                if !f(loan) { return; }\n             }\n         }\n     }\n@@ -182,11 +182,14 @@ impl methods for check_loan_ctxt {\n                 let is_fn_arg =\n                     did.crate == ast::local_crate &&\n                     (*self.fn_args).contains(did.node);\n-                if is_fn_arg { ret; } // case (a) above\n+                if is_fn_arg { return; } // case (a) above\n               }\n               ast::expr_fn_block(*) | ast::expr_fn(*) |\n               ast::expr_loop_body(*) | ast::expr_do_body(*) {\n-                if self.is_stack_closure(expr.id) { ret; } // case (b) above\n+                if self.is_stack_closure(expr.id) {\n+                    // case (b) above\n+                    return;\n+                }\n               }\n               _ {}\n             }\n@@ -198,7 +201,7 @@ impl methods for check_loan_ctxt {\n         alt ty::get(callee_ty).struct {\n           ty::ty_fn(fn_ty) {\n             alt fn_ty.purity {\n-              ast::pure_fn { ret; } // case (c) above\n+              ast::pure_fn { return; } // case (c) above\n               ast::impure_fn | ast::unsafe_fn | ast::extern_fn {\n                 self.report_purity_error(\n                     pc, callee_span,\n@@ -207,7 +210,7 @@ impl methods for check_loan_ctxt {\n               }\n             }\n           }\n-          _ { ret; } // case (d) above\n+          _ { return; } // case (d) above\n         }\n     }\n \n@@ -223,7 +226,7 @@ impl methods for check_loan_ctxt {\n     }\n \n     fn is_allowed_pure_arg(expr: @ast::expr) -> bool {\n-        ret alt expr.node {\n+        return alt expr.node {\n           ast::expr_path(_) {\n             let def = self.tcx().def_map.get(expr.id);\n             let did = ast_util::def_id_of_def(def);\n@@ -239,7 +242,7 @@ impl methods for check_loan_ctxt {\n \n     fn check_for_conflicting_loans(scope_id: ast::node_id) {\n         let new_loanss = alt self.req_maps.req_loan_map.find(scope_id) {\n-            none { ret; }\n+            none { return; }\n             some(loanss) { loanss }\n         };\n \n@@ -310,7 +313,7 @@ impl methods for check_loan_ctxt {\n                 self.bccx.span_err(\n                     ex.span,\n                     at.ing_form(self.bccx.cmt_to_str(cmt)));\n-                ret;\n+                return;\n               }\n             }\n         }\n@@ -360,7 +363,7 @@ impl methods for check_loan_ctxt {\n                     loan.cmt.span,\n                     fmt!{\"loan of %s granted here\",\n                          self.bccx.cmt_to_str(loan.cmt)});\n-                ret;\n+                return;\n               }\n             }\n         }\n@@ -428,15 +431,15 @@ impl methods for check_loan_ctxt {\n             self.bccx.span_err(\n                 cmt.span,\n                 fmt!{\"moving out of %s\", self.bccx.cmt_to_str(cmt)});\n-            ret;\n+            return;\n           }\n         }\n \n         self.bccx.add_to_mutbl_map(cmt);\n \n         // check for a conflicting loan:\n         let lp = alt cmt.lp {\n-          none { ret; }\n+          none { return; }\n           some(lp) { lp }\n         };\n         for self.walk_loans_of(cmt.id, lp) |loan| {\n@@ -448,7 +451,7 @@ impl methods for check_loan_ctxt {\n                 loan.cmt.span,\n                 fmt!{\"loan of %s granted here\",\n                      self.bccx.cmt_to_str(loan.cmt)});\n-            ret;\n+            return;\n         }\n     }\n \n@@ -458,14 +461,14 @@ impl methods for check_loan_ctxt {\n     fn check_last_use(expr: @ast::expr) {\n         let cmt = self.bccx.cat_expr(expr);\n         let lp = alt cmt.lp {\n-          none { ret; }\n+          none { return; }\n           some(lp) { lp }\n         };\n         for self.walk_loans_of(cmt.id, lp) |_loan| {\n             debug!{\"Removing last use entry %? due to outstanding loan\",\n                    expr.id};\n             self.bccx.last_use_map.remove(expr.id);\n-            ret;\n+            return;\n         }\n     }\n "}, {"sha": "673cfa379a8bfd86f05db931fd2d0829d44134da", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -55,7 +55,7 @@ fn gather_loans(bccx: borrowck_ctxt, crate: @ast::crate) -> req_maps {\n                            visit_fn: req_loans_in_fn,\n                            with *visit::default_visitor()});\n     visit::visit_crate(*crate, glcx, v);\n-    ret glcx.req_maps;\n+    return glcx.req_maps;\n }\n \n fn req_loans_in_fn(fk: visit::fn_kind,"}, {"sha": "99bdc44eb5d7e407ff002c7b9d6a63a33e6077ed", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -310,7 +310,7 @@ impl private_methods for &preserve_ctxt {\n             // would be sort of pointless to avoid rooting the inner\n             // box by rooting an outer box, as it would just keep more\n             // memory live than necessary, so we set root_ub to none.\n-            ret err({cmt:cmt, code:err_root_not_permitted});\n+            return err({cmt:cmt, code:err_root_not_permitted});\n         }\n \n         let root_region = ty::re_scope(self.root_ub);\n@@ -327,18 +327,18 @@ impl private_methods for &preserve_ctxt {\n                 #debug[\"Elected to root\"];\n                 let rk = {id: base.id, derefs: derefs};\n                 self.bccx.root_map.insert(rk, scope_id);\n-                ret ok(pc_ok);\n+                return ok(pc_ok);\n             } else {\n                 #debug[\"Unable to root\"];\n-                ret err({cmt:cmt,\n+                return err({cmt:cmt,\n                          code:err_out_of_root_scope(root_region,\n                                                     self.scope_region)});\n             }\n           }\n \n           // we won't be able to root long enough\n           _ => {\n-              ret err({cmt:cmt,\n+              return err({cmt:cmt,\n                        code:err_out_of_root_scope(root_region,\n                                                   self.scope_region)});\n           }"}, {"sha": "2a08018ebba3a1bee05d2c17af2e1e522b6a9223", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -121,5 +121,5 @@ fn compute_capture_vars(tcx: ty::ctxt,\n \n     let mut result = ~[];\n     for cap_map.each_value |cap_var| { vec::push(result, cap_var); }\n-    ret result;\n+    return result;\n }"}, {"sha": "3986cb38bbff5833f1cdf8553837815e1224fa7e", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -31,13 +31,13 @@ fn check_expr(tcx: ty::ctxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n        let pat_ty = node_id_to_type(tcx, scrut.id);\n        if type_is_empty(tcx, pat_ty) && arms.is_empty() {\n                // Vacuously exhaustive\n-               ret;\n+               return;\n            }\n        alt ty::get(pat_ty).struct {\n           ty_enum(did, _) {\n               if (*enum_variants(tcx, did)).is_empty() && arms.is_empty() {\n \n-               ret;\n+               return;\n             }\n           }\n           _ { /* We assume only enum types can be uninhabited */ }\n@@ -79,7 +79,7 @@ fn raw_pat(p: @pat) -> @pat {\n fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: ~[@pat]) {\n     assert(pats.is_not_empty());\n     let ext = alt is_useful(tcx, vec::map(pats, |p| ~[p]), ~[wild()]) {\n-      not_useful { ret; } // This is good, wildcard pattern isn't reachable\n+      not_useful { return; } // This is good, wildcard pattern isn't reachable\n       useful_ { none }\n       useful(ty, ctor) {\n         alt ty::get(ty).struct {\n@@ -132,8 +132,8 @@ enum ctor {\n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n-    if m.len() == 0u { ret useful_; }\n-    if m[0].len() == 0u { ret not_useful; }\n+    if m.len() == 0u { return useful_; }\n+    if m[0].len() == 0u { return not_useful; }\n     let real_pat = alt vec::find(m, |r| r[0].id != 0) {\n       some(r) { r[0] } none { v[0] }\n     };\n@@ -160,7 +160,7 @@ fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n                     alt is_useful_specialized(tcx, m, v, variant(va.id),\n                                               va.args.len(), left_ty) {\n                       not_useful {}\n-                      u { ret u; }\n+                      u { return u; }\n                     }\n                 }\n                 not_useful\n@@ -234,9 +234,9 @@ fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> option<ctor> {\n     alt ty::get(left_ty).struct {\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_tup(_) | ty::ty_rec(_) {\n         for m.each |r| {\n-            if !is_wild(tcx, r[0]) { ret none; }\n+            if !is_wild(tcx, r[0]) { return none; }\n         }\n-        ret some(single);\n+        return some(single);\n       }\n       ty::ty_enum(eid, _) {\n         let mut found = ~[];\n@@ -249,7 +249,7 @@ fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> option<ctor> {\n         if found.len() != (*variants).len() {\n             for vec::each(*variants) |v| {\n                 if !found.contains(variant(v.id)) {\n-                    ret some(variant(v.id));\n+                    return some(variant(v.id));\n                 }\n             }\n             fail;\n@@ -346,7 +346,7 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n         let (c_lo, c_hi) = alt check ctor_id {\n           val(v) { (v, v) }\n           range(lo, hi) { (lo, hi) }\n-          single { ret some(vec::tail(r)); }\n+          single { return some(vec::tail(r)); }\n         };\n         let v_lo = eval_const_expr(tcx, lo),\n             v_hi = eval_const_expr(tcx, hi);\n@@ -373,7 +373,7 @@ fn check_local(tcx: ty::ctxt, loc: @local, &&s: (), v: visit::vt<()>) {\n fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n     alt tcx.def_map.find(pat.id) {\n       some(def_variant(enum_id, var_id)) {\n-        if vec::len(*ty::enum_variants(tcx, enum_id)) != 1u { ret true; }\n+        if vec::len(*ty::enum_variants(tcx, enum_id)) != 1u { return true; }\n       }\n       _ {}\n     }\n@@ -386,16 +386,16 @@ fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n       pat_lit(_) | pat_range(_, _) => { true }\n       pat_rec(fields, _) => {\n         for fields.each |it| {\n-            if is_refutable(tcx, it.pat) { ret true; }\n+            if is_refutable(tcx, it.pat) { return true; }\n         }\n         false\n       }\n       pat_tup(elts) => {\n-        for elts.each |elt| { if is_refutable(tcx, elt) { ret true; } }\n+        for elts.each |elt| { if is_refutable(tcx, elt) { return true; } }\n         false\n       }\n       pat_enum(_, some(args)) => {\n-        for args.each |p| { if is_refutable(tcx, p) { ret true; } };\n+        for args.each |p| { if is_refutable(tcx, p) { return true; } };\n         false\n       }\n       pat_enum(_,_) => { false }"}, {"sha": "7f1fd250c9191ef22d5ca6d6d3d233eb3d26a8ab", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -64,7 +64,7 @@ fn check_expr(sess: session, def_map: resolve3::DefMap,\n           expr_unary(deref, _){\n             sess.span_err(e.span,\n                           ~\"disallowed operator in constant expression\");\n-            ret;\n+            return;\n           }\n           expr_lit(@{node: lit_str(_), _}) {\n             sess.span_err(e.span,\n@@ -106,7 +106,7 @@ fn check_expr(sess: session, def_map: resolve3::DefMap,\n           _ {\n             sess.span_err(e.span,\n                           ~\"constant contains unimplemented expression type\");\n-            ret;\n+            return;\n           }\n         }\n     }"}, {"sha": "29d44ede215e069a2e2ba71bb4872f180ccb01b6", "filename": "src/rustc/middle/freevars.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffreevars.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -77,7 +77,7 @@ fn collect_freevars(def_map: resolve3::DefMap, blk: ast::blk)\n     let v = visit::mk_vt(@{visit_item: ignore_item, visit_expr: walk_expr\n                            with *visit::default_visitor()});\n     v.visit_block(blk, 1, v);\n-    ret @*refs;\n+    return @*refs;\n }\n \n // Build a map from every function and for-each body to a set of the\n@@ -100,17 +100,17 @@ fn annotate_freevars(def_map: resolve3::DefMap, crate: @ast::crate) ->\n                                    with *visit::default_simple_visitor()});\n     visit::visit_crate(*crate, (), visitor);\n \n-    ret freevars;\n+    return freevars;\n }\n \n fn get_freevars(tcx: ty::ctxt, fid: ast::node_id) -> freevar_info {\n     alt tcx.freevars.find(fid) {\n       none { fail ~\"get_freevars: \" + int::str(fid) + ~\" has no freevars\"; }\n-      some(d) { ret d; }\n+      some(d) { return d; }\n     }\n }\n fn has_freevars(tcx: ty::ctxt, fid: ast::node_id) -> bool {\n-    ret vec::len(*get_freevars(tcx, fid)) != 0u;\n+    return vec::len(*get_freevars(tcx, fid)) != 0u;\n }\n \n // Local Variables:"}, {"sha": "dd83b01fbe0b871e41ae7aab75584f096f774c01", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -100,7 +100,7 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n                       is_move: bool, var_t: ty::t, sp: span) {\n         // all captured data must be sendable, regardless of whether it is\n         // moved in or copied in.  Note that send implies owned.\n-        if !check_send(cx, var_t, sp) { ret; }\n+        if !check_send(cx, var_t, sp) { return; }\n \n         // copied in data must be copyable, but moved in data can be anything\n         let is_implicit = fv.is_some();\n@@ -115,7 +115,7 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n     fn check_for_box(cx: ctx, id: node_id, fv: option<@freevar_entry>,\n                      is_move: bool, var_t: ty::t, sp: span) {\n         // all captured data must be owned\n-        if !check_owned(cx.tcx, var_t, sp) { ret; }\n+        if !check_owned(cx.tcx, var_t, sp) { return; }\n \n         // copied in data must be copyable, but moved in data can be anything\n         let is_implicit = fv.is_some();\n@@ -498,14 +498,14 @@ fn check_cast_for_escaping_regions(\n     let target_ty = ty::expr_ty(cx.tcx, target);\n     let target_substs = alt ty::get(target_ty).struct {\n       ty::ty_trait(_, substs) => {substs}\n-      _ => { ret; /* not a cast to a trait */ }\n+      _ => { return; /* not a cast to a trait */ }\n     };\n \n     // Check, based on the region associated with the trait, whether it can\n     // possibly escape the enclosing fn item (note that all type parameters\n     // must have been declared on the enclosing fn item):\n     alt target_substs.self_r {\n-      some(ty::re_scope(*)) => { ret; /* case (1) */ }\n+      some(ty::re_scope(*)) => { return; /* case (1) */ }\n       none | some(ty::re_static) | some(ty::re_free(*)) => {}\n       some(ty::re_bound(*)) | some(ty::re_var(*)) => {\n         cx.tcx.sess.span_bug("}, {"sha": "f007774641d2a8581f0e65053b07f74c1852504f", "filename": "src/rustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flang_items.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -119,7 +119,7 @@ class LanguageItemCollector {\n \n     fn match_and_collect_item(item_def_id: def_id, key: ~str, value: ~str) {\n         if !str_eq(key, ~\"lang\") {\n-            ret;    // Didn't match.\n+            return;    // Didn't match.\n         }\n \n         alt self.item_refs.find(value) {"}, {"sha": "ca39157f3bf6aa7b91abdca6c2fc7a907340f1e5", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -481,7 +481,7 @@ fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n     // don't complain about blocks, since they tend to get their modes\n     // specified from the outside\n     alt fk {\n-      visit::fk_fn_block(*) => { ret; }\n+      visit::fk_fn_block(*) => { return; }\n       _ => {}\n     }\n "}, {"sha": "7f18dae0db4c7217ed8f2cc272606defca68ed87", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -149,7 +149,7 @@ fn check_crate(tcx: ty::ctxt,\n                                 last_use_map);\n     visit::visit_crate(*crate, initial_maps, visitor);\n     tcx.sess.abort_if_errors();\n-    ret last_use_map;\n+    return last_use_map;\n }\n \n impl of to_str::to_str for live_node {\n@@ -291,7 +291,7 @@ class ir_maps {\n           vk_local(_, name) | vk_arg(_, name, _) {name}\n           vk_field(name) {@(~\"self.\" + *name)}\n           vk_self {@~\"self\"}\n-          vk_implicit_ret {@~\"<implicit-ret>\"}\n+          vk_implicit_return {@~\"<implicit-ret>\"}\n         }\n     }\n \n@@ -367,7 +367,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     }\n \n     // Special nodes and variables:\n-    // - exit_ln represents the end of the fn, either by ret or fail\n+    // - exit_ln represents the end of the fn, either by return or fail\n     // - implicit_ret_var is a pseudo-variable that represents\n     //   an implicit return\n     let specials = {\n@@ -701,7 +701,7 @@ class liveness {\n \n     fn merge_from_succ(ln: live_node, succ_ln: live_node,\n                        first_merge: bool) -> bool {\n-        if ln == succ_ln { ret false; }\n+        if ln == succ_ln { return false; }\n \n         let mut changed = false;\n         do self.indices2(ln, succ_ln) |idx, succ_idx| {\n@@ -717,16 +717,16 @@ class liveness {\n \n         debug!{\"merge_from_succ(ln=%s, succ=%s, first_merge=%b, changed=%b)\",\n                ln.to_str(), self.ln_str(succ_ln), first_merge, changed};\n-        ret changed;\n+        return changed;\n \n         fn copy_if_invalid(src: live_node, &dst: live_node) -> bool {\n             if src.is_valid() {\n                 if !dst.is_valid() {\n                     dst = src;\n-                    ret true;\n+                    return true;\n                 }\n             }\n-            ret false;\n+            return false;\n         }\n     }\n \n@@ -837,11 +837,11 @@ class liveness {\n     fn propagate_through_stmt(stmt: @stmt, succ: live_node) -> live_node {\n         alt stmt.node {\n           stmt_decl(decl, _) {\n-            ret self.propagate_through_decl(decl, succ);\n+            return self.propagate_through_decl(decl, succ);\n           }\n \n           stmt_expr(expr, _) | stmt_semi(expr, _) {\n-            ret self.propagate_through_expr(expr, succ);\n+            return self.propagate_through_expr(expr, succ);\n           }\n         }\n     }\n@@ -1275,15 +1275,15 @@ class liveness {\n             alt def {\n               def_self(_) {\n                 // Note: the field_map is empty unless we are in a ctor\n-                ret self.ir.field_map.find(fld).map(|var| {\n+                return self.ir.field_map.find(fld).map(|var| {\n                     let ln = self.live_node(expr.id, expr.span);\n                     (ln, var)\n                 });\n               }\n-              _ { ret none; }\n+              _ { return none; }\n             }\n           }\n-          _ { ret none; }\n+          _ { return none; }\n         }\n     }\n \n@@ -1347,7 +1347,7 @@ class liveness {\n         let r <- f();\n         self.break_ln = bl;\n         self.cont_ln = cl;\n-        ret r;\n+        return r;\n     }\n }\n \n@@ -1558,7 +1558,7 @@ impl check_methods for @liveness {\n \n         if self.ir.method_map.contains_key(expr.id) {\n             // actually an rvalue, since this calls a method\n-            ret vt.visit_expr(expr, self, vt);\n+            return vt.visit_expr(expr, self, vt);\n         }\n \n         alt expr.node {\n@@ -1671,20 +1671,20 @@ impl check_methods for @liveness {\n                     move_span,\n                     fmt!{\"illegal move from argument `%s`, which is not \\\n                           copy or move mode\", *name});\n-                ret;\n+                return;\n               }\n               vk_field(name) {\n                 self.tcx.sess.span_err(\n                     move_span,\n                     fmt!{\"illegal move from field `%s`\", *name});\n-                ret;\n+                return;\n               }\n               vk_self {\n                 self.tcx.sess.span_err(\n                     move_span,\n                     ~\"illegal move from self (cannot move out of a field of \\\n                        self)\");\n-                ret;\n+                return;\n               }\n               vk_local(*) | vk_implicit_ret {\n                 self.tcx.sess.span_bug(\n@@ -1790,9 +1790,9 @@ impl check_methods for @liveness {\n                         sp, fmt!{\"unused variable: `%s`\", *name});\n                 }\n             }\n-            ret true;\n+            return true;\n         }\n-        ret false;\n+        return false;\n     }\n \n     fn warn_about_dead_assign(sp: span, ln: live_node, var: variable) {"}, {"sha": "70a432d78c92a37445a64b51939e73fc2245939d", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -18,7 +18,7 @@ fn pat_id_map(dm: resolve3::DefMap, pat: @pat) -> pat_id_map {\n     do pat_bindings(dm, pat) |p_id, _s, n| {\n       map.insert(path_to_ident(n), p_id);\n     };\n-    ret map;\n+    return map;\n }\n \n fn pat_is_variant(dm: resolve3::DefMap, pat: @pat) -> bool {\n@@ -49,5 +49,5 @@ fn pat_bindings(dm: resolve3::DefMap, pat: @pat,\n fn pat_binding_ids(dm: resolve3::DefMap, pat: @pat) -> ~[node_id] {\n     let mut found = ~[];\n     pat_bindings(dm, pat, |b_id, _sp, _pt| vec::push(found, b_id) );\n-    ret found;\n+    return found;\n }"}, {"sha": "ec0ad5cb770bdaf3a4ce9e4d4757993fe99f70fe", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -89,11 +89,11 @@ fn scope_contains(region_map: region_map, superscope: ast::node_id,\n     let mut subscope = subscope;\n     while superscope != subscope {\n         alt region_map.find(subscope) {\n-            none { ret false; }\n+            none { return false; }\n             some(scope) { subscope = scope; }\n         }\n     }\n-    ret true;\n+    return true;\n }\n \n /// Determines whether one region is a subregion of another.  This is\n@@ -129,7 +129,7 @@ fn nearest_common_ancestor(region_map: region_map, scope_a: ast::node_id,\n         let mut scope = scope;\n         loop {\n             alt region_map.find(scope) {\n-                none { ret result; }\n+                none { return result; }\n                 some(superscope) {\n                     vec::push(result, superscope);\n                     scope = superscope;\n@@ -138,7 +138,7 @@ fn nearest_common_ancestor(region_map: region_map, scope_a: ast::node_id,\n         }\n     }\n \n-    if scope_a == scope_b { ret some(scope_a); }\n+    if scope_a == scope_b { return some(scope_a); }\n \n     let a_ancestors = ancestors_of(region_map, scope_a);\n     let b_ancestors = ancestors_of(region_map, scope_b);\n@@ -154,18 +154,18 @@ fn nearest_common_ancestor(region_map: region_map, scope_a: ast::node_id,\n     // then the corresponding scope is a superscope of the other.\n \n     if a_ancestors[a_index] != b_ancestors[b_index] {\n-        ret none;\n+        return none;\n     }\n \n     loop {\n         // Loop invariant: a_ancestors[a_index] == b_ancestors[b_index]\n         // for all indices between a_index and the end of the array\n-        if a_index == 0u { ret some(scope_a); }\n-        if b_index == 0u { ret some(scope_b); }\n+        if a_index == 0u { return some(scope_a); }\n+        if b_index == 0u { return some(scope_b); }\n         a_index -= 1u;\n         b_index -= 1u;\n         if a_ancestors[a_index] != b_ancestors[b_index] {\n-            ret some(a_ancestors[a_index + 1u]);\n+            return some(a_ancestors[a_index + 1u]);\n         }\n     }\n }\n@@ -318,7 +318,7 @@ fn resolve_crate(sess: session, def_map: resolve3::DefMap,\n         with *visit::default_visitor()\n     });\n     visit::visit_crate(*crate, cx, visitor);\n-    ret cx.region_map;\n+    return cx.region_map;\n }\n \n // ___________________________________________________________________________\n@@ -480,7 +480,7 @@ fn determine_rp_in_ty(ty: @ast::ty,\n     // be region-parameterized.  if cx.item_id is zero, then this type\n     // is not a member of a type defn nor is it a constitutent of an\n     // impl etc.  So we can ignore it and its components.\n-    if cx.item_id == 0 { ret; }\n+    if cx.item_id == 0 { return; }\n \n     // if this type directly references a region, either via a\n     // region pointer like &r.ty or a region-parameterized path\n@@ -572,5 +572,5 @@ fn determine_rp_in_crate(sess: session,\n     }\n \n     // return final set\n-    ret cx.region_paramd_items;\n+    return cx.region_paramd_items;\n }"}, {"sha": "ca52c5dcd343a4c5e910dffcef4525b3b7a8d61b", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 122, "deletions": 122, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -231,7 +231,7 @@ enum EnumVariantOrConstResolution {\n type Atom = uint;\n \n fn Atom(n: uint) -> Atom {\n-    ret n;\n+    return n;\n }\n \n class AtomTable {\n@@ -249,25 +249,25 @@ class AtomTable {\n     fn intern(string: @~str) -> Atom {\n         alt self.atoms.find(string) {\n             none { /* fall through */ }\n-            some(atom) { ret atom; }\n+            some(atom) { return atom; }\n         }\n \n         let atom = Atom(self.atom_count);\n         self.atom_count += 1u;\n         self.atoms.insert(string, atom);\n         self.strings.push(string);\n \n-        ret atom;\n+        return atom;\n     }\n \n     fn atom_to_str(atom: Atom) -> @~str {\n-        ret self.strings.get_elt(atom);\n+        return self.strings.get_elt(atom);\n     }\n \n     fn atoms_to_strs(atoms: ~[Atom], f: fn(@~str) -> bool) {\n         for atoms.each |atom| {\n             if !f(self.atom_to_str(atom)) {\n-                ret;\n+                return;\n             }\n         }\n     }\n@@ -287,13 +287,13 @@ class AtomTable {\n         }\n \n         // XXX: Shouldn't copy here. We need string builder functionality.\n-        ret @result;\n+        return @result;\n     }\n }\n \n /// Creates a hash table of atoms.\n fn atom_hashmap<V:copy>() -> hashmap<Atom,V> {\n-    ret hashmap::<Atom,V>(|a| a, |a, b| a == b);\n+    return hashmap::<Atom,V>(|a| a, |a, b| a == b);\n }\n \n /**\n@@ -368,15 +368,15 @@ class ImportResolution {\n \n     fn target_for_namespace(namespace: Namespace) -> option<Target> {\n         alt namespace {\n-            ModuleNS    { ret copy self.module_target; }\n-            TypeNS      { ret copy self.type_target;   }\n-            ValueNS     { ret copy self.value_target;  }\n+            ModuleNS    { return copy self.module_target; }\n+            TypeNS      { return copy self.type_target;   }\n+            ValueNS     { return copy self.value_target;  }\n \n             ImplNS {\n                 if (*self.impl_target).len() > 0u {\n-                    ret some(copy *(*self.impl_target).get_elt(0u));\n+                    return some(copy *(*self.impl_target).get_elt(0u));\n                 }\n-                ret none;\n+                return none;\n             }\n         }\n     }\n@@ -453,7 +453,7 @@ class Module {\n     }\n \n     fn all_imports_resolved() -> bool {\n-        ret self.imports.len() == self.resolved_import_count;\n+        return self.imports.len() == self.resolved_import_count;\n     }\n }\n \n@@ -462,19 +462,19 @@ class Module {\n \n pure fn is_none<T>(x: option<T>) -> bool {\n     alt x {\n-        none { ret true; }\n-        some(_) { ret false; }\n+        none { return true; }\n+        some(_) { return false; }\n     }\n }\n \n fn unused_import_lint_level(session: session) -> level {\n     for session.opts.lint_opts.each |lint_option_pair| {\n         let (lint_type, lint_level) = lint_option_pair;\n         if lint_type == unused_imports {\n-            ret lint_level;\n+            return lint_level;\n         }\n     }\n-    ret allow;\n+    return allow;\n }\n \n // Records the definitions (at most one for each namespace) that a name is\n@@ -518,8 +518,8 @@ class NameBindings {\n     /// Returns the module node if applicable.\n     fn get_module_if_available() -> option<@Module> {\n         alt self.module_def {\n-            NoModuleDef         { ret none;         }\n-            ModuleDef(module_)   { ret some(module_); }\n+            NoModuleDef         { return none;         }\n+            ModuleDef(module_)   { return some(module_); }\n         }\n     }\n \n@@ -534,40 +534,40 @@ class NameBindings {\n                     ~\"get_module called on a node with no module definition!\";\n             }\n             ModuleDef(module_) {\n-                ret module_;\n+                return module_;\n             }\n         }\n     }\n \n     fn defined_in_namespace(namespace: Namespace) -> bool {\n         alt namespace {\n-            ModuleNS    { ret self.module_def != NoModuleDef; }\n-            TypeNS      { ret self.type_def != none;          }\n-            ValueNS     { ret self.value_def != none;         }\n-            ImplNS      { ret self.impl_defs.len() >= 1u;     }\n+            ModuleNS    { return self.module_def != NoModuleDef; }\n+            TypeNS      { return self.type_def != none;          }\n+            ValueNS     { return self.value_def != none;         }\n+            ImplNS      { return self.impl_defs.len() >= 1u;     }\n         }\n     }\n \n     fn def_for_namespace(namespace: Namespace) -> option<def> {\n         alt namespace {\n             TypeNS {\n-                ret self.type_def;\n+                return self.type_def;\n             }\n             ValueNS {\n-                ret self.value_def;\n+                return self.value_def;\n             }\n             ModuleNS {\n                 alt self.module_def {\n                     NoModuleDef {\n-                        ret none;\n+                        return none;\n                     }\n                     ModuleDef(module_) {\n                         alt module_.def_id {\n                             none {\n-                                ret none;\n+                                return none;\n                             }\n                             some(def_id) {\n-                                ret some(def_mod(def_id));\n+                                return some(def_mod(def_id));\n                             }\n                         }\n                     }\n@@ -578,9 +578,9 @@ class NameBindings {\n                 // necessarily the right def.\n \n                 if self.impl_defs.len() == 0u {\n-                    ret none;\n+                    return none;\n                 }\n-                ret some(def_ty(self.impl_defs[0].did));\n+                return some(def_ty(self.impl_defs[0].did));\n             }\n         }\n     }\n@@ -766,7 +766,7 @@ class Resolver {\n                            -> @Module {\n         alt reduced_graph_parent {\n             ModuleReducedGraphParent(module_) {\n-                ret module_;\n+                return module_;\n             }\n         }\n     }\n@@ -802,18 +802,18 @@ class Resolver {\n             none {\n                 let child = @NameBindings();\n                 module_.children.insert(name, child);\n-                ret (child, new_parent);\n+                return (child, new_parent);\n             }\n             some(child) {\n-                ret (child, new_parent);\n+                return (child, new_parent);\n             }\n         }\n     }\n \n     fn block_needs_anonymous_module(block: blk) -> bool {\n         // If the block has view items, we need an anonymous module.\n         if block.node.view_items.len() > 0u {\n-            ret true;\n+            return true;\n         }\n \n         // Check each statement.\n@@ -822,7 +822,7 @@ class Resolver {\n                 stmt_decl(declaration, _) {\n                     alt declaration.node {\n                         decl_item(_) {\n-                            ret true;\n+                            return true;\n                         }\n                         _ {\n                             // Keep searching.\n@@ -838,13 +838,13 @@ class Resolver {\n         // If we found neither view items nor items, we don't need to create\n         // an anonymous module.\n \n-        ret false;\n+        return false;\n     }\n \n     fn get_parent_link(parent: ReducedGraphParent, name: Atom) -> ParentLink {\n         alt parent {\n             ModuleReducedGraphParent(module_) {\n-                ret ModuleParentLink(module_, name);\n+                return ModuleParentLink(module_, name);\n             }\n         }\n     }\n@@ -1483,7 +1483,7 @@ class Resolver {\n                 debug!{\"(building reduced graph for impls in external \\\n                         module) no def ID for `%s`, skipping\",\n                        self.module_to_str(module_)};\n-                ret;\n+                return;\n             }\n             some(_) {\n                 // Continue.\n@@ -1623,7 +1623,7 @@ class Resolver {\n             debug!{\"(resolving imports for module) all imports resolved for \\\n                    %s\",\n                    self.module_to_str(module_)};\n-            ret;\n+            return;\n         }\n \n         let import_count = module_.imports.len();\n@@ -1740,7 +1740,7 @@ class Resolver {\n             }\n         }\n \n-        ret resolution_result;\n+        return resolution_result;\n     }\n \n     fn resolve_single_import(module_: @Module, containing_module: @Module,\n@@ -1757,7 +1757,7 @@ class Resolver {\n         if !self.name_is_exported(containing_module, source) {\n             debug!{\"(resolving single import) name `%s` is unexported\",\n                    *(*self.atom_table).atom_to_str(source)};\n-            ret Failed;\n+            return Failed;\n         }\n \n         // We need to resolve all four namespaces for this to succeed.\n@@ -1813,7 +1813,7 @@ class Resolver {\n                 if containing_module.glob_count > 0u {\n                     debug!{\"(resolving single import) unresolved glob; \\\n                             bailing out\"};\n-                    ret Indeterminate;\n+                    return Indeterminate;\n                 }\n \n                 // Now search the exported imports within the containing\n@@ -1850,11 +1850,11 @@ class Resolver {\n                             alt (*import_resolution).\n                                     target_for_namespace(namespace) {\n                                 none {\n-                                    ret UnboundResult;\n+                                    return UnboundResult;\n                                 }\n                                 some(target) {\n                                     import_resolution.used = true;\n-                                    ret BoundResult(target.target_module,\n+                                    return BoundResult(target.target_module,\n                                                     target.bindings);\n                                 }\n                             }\n@@ -1865,9 +1865,9 @@ class Resolver {\n                                            -> ImplNamespaceResult {\n \n                             if (*import_resolution.impl_target).len() == 0u {\n-                                ret UnboundImplResult;\n+                                return UnboundImplResult;\n                             }\n-                            ret BoundImplResult(import_resolution.\n+                            return BoundImplResult(import_resolution.\n                                                 impl_target);\n                         }\n \n@@ -1896,7 +1896,7 @@ class Resolver {\n                         // The import is unresolved. Bail out.\n                         debug!{\"(resolving single import) unresolved import; \\\n                                 bailing out\"};\n-                        ret Indeterminate;\n+                        return Indeterminate;\n                     }\n                 }\n             }\n@@ -1958,15 +1958,15 @@ class Resolver {\n             If this name wasn't found in any of the four namespaces, it's\n             definitely unresolved\n            */\n-          (none, none, none, v) if v.len() == 0 { ret Failed; }\n+          (none, none, none, v) if v.len() == 0 { return Failed; }\n           _ {}\n         }\n \n         assert import_resolution.outstanding_references >= 1u;\n         import_resolution.outstanding_references -= 1u;\n \n         debug!{\"(resolving single import) successfully resolved import\"};\n-        ret Success(());\n+        return Success(());\n     }\n \n     /**\n@@ -1989,7 +1989,7 @@ class Resolver {\n         if !(*containing_module).all_imports_resolved() {\n             debug!{\"(resolving glob import) target module has unresolved \\\n                     imports; bailing out\"};\n-            ret Indeterminate;\n+            return Indeterminate;\n         }\n \n         assert containing_module.glob_count == 0u;\n@@ -2125,7 +2125,7 @@ class Resolver {\n         }\n \n         debug!{\"(resolving glob import) successfully resolved import\"};\n-        ret Success(());\n+        return Success(());\n     }\n \n     fn resolve_module_path_from_root(module_: @Module,\n@@ -2150,13 +2150,13 @@ class Resolver {\n \n                 Failed {\n                     self.session.span_err(span, ~\"unresolved name\");\n-                    ret Failed;\n+                    return Failed;\n                 }\n                 Indeterminate {\n                     debug!{\"(resolving module path for import) module \\\n                             resolution is indeterminate: %s\",\n                             *(*self.atom_table).atom_to_str(name)};\n-                    ret Indeterminate;\n+                    return Indeterminate;\n                 }\n                 Success(target) {\n                     alt target.bindings.module_def {\n@@ -2166,7 +2166,7 @@ class Resolver {\n                                                   fmt!{\"not a module: %s\",\n                                                        *(*self.atom_table).\n                                                          atom_to_str(name)});\n-                            ret Failed;\n+                            return Failed;\n                         }\n                         ModuleDef(module_) {\n                             search_module = module_;\n@@ -2178,7 +2178,7 @@ class Resolver {\n             index += 1u;\n         }\n \n-        ret Success(search_module);\n+        return Success(search_module);\n     }\n \n     /**\n@@ -2207,19 +2207,19 @@ class Resolver {\n         alt self.resolve_module_in_lexical_scope(module_, first_element) {\n             Failed {\n                 self.session.span_err(span, ~\"unresolved name\");\n-                ret Failed;\n+                return Failed;\n             }\n             Indeterminate {\n                 debug!{\"(resolving module path for import) indeterminate; \\\n                         bailing\"};\n-                ret Indeterminate;\n+                return Indeterminate;\n             }\n             Success(resulting_module) {\n                 search_module = resulting_module;\n             }\n         }\n \n-        ret self.resolve_module_path_from_root(search_module,\n+        return self.resolve_module_path_from_root(search_module,\n                                                module_path,\n                                                1u,\n                                                xray,\n@@ -2244,7 +2244,7 @@ class Resolver {\n             some(name_bindings)\n                     if (*name_bindings).defined_in_namespace(namespace) {\n \n-                ret Success(Target(module_, name_bindings));\n+                return Success(Target(module_, name_bindings));\n             }\n             some(_) | none { /* Not found; continue. */ }\n         }\n@@ -2268,7 +2268,7 @@ class Resolver {\n                     }\n                     some(target) {\n                         import_resolution.used = true;\n-                        ret Success(copy target);\n+                        return Success(copy target);\n                     }\n                 }\n             }\n@@ -2283,7 +2283,7 @@ class Resolver {\n                     // No more parents. This module was unresolved.\n                     debug!{\"(resolving item in lexical scope) unresolved \\\n                             module\"};\n-                    ret Failed;\n+                    return Failed;\n                 }\n                 ModuleParentLink(parent_module_node, _) |\n                 BlockParentLink(parent_module_node, _) {\n@@ -2303,11 +2303,11 @@ class Resolver {\n \n                     debug!{\"(resolving item in lexical scope) indeterminate \\\n                             higher scope; bailing\"};\n-                    ret Indeterminate;\n+                    return Indeterminate;\n                 }\n                 Success(target) {\n                     // We found the module.\n-                    ret Success(copy target);\n+                    return Success(copy target);\n                 }\n             }\n         }\n@@ -2322,28 +2322,28 @@ class Resolver {\n                     NoModuleDef {\n                         error!{\"!!! (resolving module in lexical scope) module\n                                 wasn't actually a module!\"};\n-                        ret Failed;\n+                        return Failed;\n                     }\n                     ModuleDef(module_) {\n-                        ret Success(module_);\n+                        return Success(module_);\n                     }\n                 }\n             }\n             Indeterminate {\n                 debug!{\"(resolving module in lexical scope) indeterminate; \\\n                         bailing\"};\n-                ret Indeterminate;\n+                return Indeterminate;\n             }\n             Failed {\n                 debug!{\"(resolving module in lexical scope) failed to \\\n                         resolve\"};\n-                ret Failed;\n+                return Failed;\n             }\n         }\n     }\n \n     fn name_is_exported(module_: @Module, name: Atom) -> bool {\n-        ret module_.exported_names.size() == 0u ||\n+        return module_.exported_names.size() == 0u ||\n                 module_.exported_names.contains_key(name);\n     }\n \n@@ -2365,7 +2365,7 @@ class Resolver {\n         if xray == NoXray && !self.name_is_exported(module_, name) {\n             debug!{\"(resolving name in module) name `%s` is unexported\",\n                    *(*self.atom_table).atom_to_str(name)};\n-            ret Failed;\n+            return Failed;\n         }\n \n         // First, check the direct children of the module.\n@@ -2374,7 +2374,7 @@ class Resolver {\n                     if (*name_bindings).defined_in_namespace(namespace) {\n \n                 debug!{\"(resolving name in module) found node as child\"};\n-                ret Success(Target(module_, name_bindings));\n+                return Success(Target(module_, name_bindings));\n             }\n             some(_) | none {\n                 // Continue.\n@@ -2386,7 +2386,7 @@ class Resolver {\n \n         if module_.glob_count > 0u {\n             debug!{\"(resolving name in module) module has glob; bailing out\"};\n-            ret Indeterminate;\n+            return Indeterminate;\n         }\n \n         // Otherwise, we check the list of resolved imports.\n@@ -2395,7 +2395,7 @@ class Resolver {\n                 if import_resolution.outstanding_references != 0u {\n                     debug!{\"(resolving name in module) import unresolved; \\\n                             bailing out\"};\n-                    ret Indeterminate;\n+                    return Indeterminate;\n                 }\n \n                 alt (*import_resolution).target_for_namespace(namespace) {\n@@ -2408,7 +2408,7 @@ class Resolver {\n                         debug!{\"(resolving name in module) resolved to \\\n                                 import\"};\n                         import_resolution.used = true;\n-                        ret Success(copy target);\n+                        return Success(copy target);\n                     }\n                 }\n             }\n@@ -2420,7 +2420,7 @@ class Resolver {\n         // We're out of luck.\n         debug!{\"(resolving name in module) failed to resolve %s\",\n                *(*self.atom_table).atom_to_str(name)};\n-        ret Failed;\n+        return Failed;\n     }\n \n     /**\n@@ -2468,7 +2468,7 @@ class Resolver {\n             Indeterminate {\n                 debug!{\"(resolving one-level renaming import) module result \\\n                         is indeterminate; bailing\"};\n-                ret Indeterminate;\n+                return Indeterminate;\n             }\n             Success(name_bindings) {\n                 debug!{\"(resolving one-level renaming import) module result \\\n@@ -2491,7 +2491,7 @@ class Resolver {\n             Indeterminate {\n                 debug!{\"(resolving one-level renaming import) value result \\\n                         is indeterminate; bailing\"};\n-                ret Indeterminate;\n+                return Indeterminate;\n             }\n             Success(name_bindings) {\n                 debug!{\"(resolving one-level renaming import) value result \\\n@@ -2514,7 +2514,7 @@ class Resolver {\n             Indeterminate {\n                 debug!{\"(resolving one-level renaming import) type result is \\\n                         indeterminate; bailing\"};\n-                ret Indeterminate;\n+                return Indeterminate;\n             }\n             Success(name_bindings) {\n                 debug!{\"(resolving one-level renaming import) type result \\\n@@ -2554,7 +2554,7 @@ class Resolver {\n             Indeterminate {\n                 debug!{\"(resolving one-level renaming import) impl result is \\\n                         indeterminate; bailing\"};\n-                ret Indeterminate;\n+                return Indeterminate;\n             }\n             Success(name_bindings) {\n                 debug!{\"(resolving one-level renaming import) impl result \\\n@@ -2569,7 +2569,7 @@ class Resolver {\n \n             self.session.span_err(import_directive.span,\n                                   ~\"unresolved import\");\n-            ret Failed;\n+            return Failed;\n         }\n \n         // Otherwise, proceed and write in the bindings.\n@@ -2605,7 +2605,7 @@ class Resolver {\n         }\n \n         debug!{\"(resolving one-level renaming import) successfully resolved\"};\n-        ret Success(());\n+        return Success(());\n     }\n \n     fn report_unresolved_imports(module_: @Module) {\n@@ -2663,7 +2663,7 @@ class Resolver {\n                 debug!{\"(recording exports for module subtree) not recording \\\n                         exports for `%s`\",\n                        self.module_to_str(module_)};\n-                ret;\n+                return;\n             }\n         }\n \n@@ -2749,7 +2749,7 @@ class Resolver {\n                 debug!{\"(building impl scopes for module subtree) not \\\n                         resolving implementations for `%s`\",\n                        self.module_to_str(module_)};\n-                ret;\n+                return;\n             }\n         }\n \n@@ -2903,7 +2903,7 @@ class Resolver {\n                 is_ty_param = false;\n             }\n             _ {\n-                ret some(def_like);\n+                return some(def_like);\n             }\n         }\n \n@@ -2947,7 +2947,7 @@ class Resolver {\n                                                argument out of scope\");\n                     }\n \n-                    ret none;\n+                    return none;\n                     }\n                   }\n                 }\n@@ -2969,14 +2969,14 @@ class Resolver {\n                                                argument out of scope\");\n                     }\n \n-                    ret none;\n+                    return none;\n                 }\n             }\n \n             rib_index += 1u;\n         }\n \n-        ret some(dl_def(def));\n+        return some(dl_def(def));\n     }\n \n     fn search_ribs(ribs: @dvec<@Rib>, name: Atom, span: span,\n@@ -2992,7 +2992,7 @@ class Resolver {\n             let rib = (*ribs).get_elt(i);\n             alt rib.bindings.find(name) {\n                 some(def_like) {\n-                    ret self.upvarify(ribs, i, def_like, span,\n+                    return self.upvarify(ribs, i, def_like, span,\n                                       allow_capturing_self);\n                 }\n                 none {\n@@ -3001,7 +3001,7 @@ class Resolver {\n             }\n         }\n \n-        ret none;\n+        return none;\n     }\n \n     // XXX: This shouldn't be unsafe!\n@@ -3595,7 +3595,7 @@ class Resolver {\n       };\n     }\n     fn check_consistent_bindings(arm: arm) {\n-      if arm.pats.len() == 0 { ret; }\n+      if arm.pats.len() == 0 { return; }\n       let good = self.num_bindings(arm.pats[0]);\n       for arm.pats.each() |p: @pat| {\n         if self.num_bindings(p) != good {\n@@ -3890,13 +3890,13 @@ class Resolver {\n                               of name bindings with no def?!\";\n                     }\n                     some(def @ def_variant(*)) {\n-                        ret FoundEnumVariant(def);\n+                        return FoundEnumVariant(def);\n                     }\n                     some(def_const(*)) {\n-                        ret FoundConst;\n+                        return FoundConst;\n                     }\n                     some(_) {\n-                        ret EnumVariantOrConstNotFound;\n+                        return EnumVariantOrConstNotFound;\n                     }\n                 }\n             }\n@@ -3906,7 +3906,7 @@ class Resolver {\n             }\n \n             Failed {\n-                ret EnumVariantOrConstNotFound;\n+                return EnumVariantOrConstNotFound;\n             }\n         }\n     }\n@@ -3925,18 +3925,18 @@ class Resolver {\n         }\n \n         if path.global {\n-            ret self.resolve_crate_relative_path(path,\n+            return self.resolve_crate_relative_path(path,\n                                                  self.xray_context,\n                                                  namespace);\n         }\n \n         if path.idents.len() > 1u {\n-            ret self.resolve_module_relative_path(path,\n+            return self.resolve_module_relative_path(path,\n                                                   self.xray_context,\n                                                   namespace);\n         }\n \n-        ret self.resolve_identifier(path.idents.last(),\n+        return self.resolve_identifier(path.idents.last(),\n                                     namespace,\n                                     check_ribs,\n                                     path.span);\n@@ -3953,15 +3953,15 @@ class Resolver {\n                                                       namespace,\n                                                       span) {\n                 some(def) {\n-                    ret some(def);\n+                    return some(def);\n                 }\n                 none {\n                     // Continue.\n                 }\n             }\n         }\n \n-        ret self.resolve_item_by_identifier_in_lexical_scope(identifier,\n+        return self.resolve_item_by_identifier_in_lexical_scope(identifier,\n                                                              namespace);\n     }\n \n@@ -3976,7 +3976,7 @@ class Resolver {\n             debug!{\"(resolving definition of name in module) name `%s` is \\\n                     unexported\",\n                    *(*self.atom_table).atom_to_str(name)};\n-            ret NoNameDefinition;\n+            return NoNameDefinition;\n         }\n \n         // First, search children.\n@@ -3985,7 +3985,7 @@ class Resolver {\n                 alt (*child_name_bindings).def_for_namespace(namespace) {\n                     some(def) {\n                         // Found it. Stop the search here.\n-                        ret ChildNameDefinition(def);\n+                        return ChildNameDefinition(def);\n                     }\n                     none {\n                         // Continue.\n@@ -4006,23 +4006,23 @@ class Resolver {\n                             some(def) {\n                                 // Found it.\n                                 import_resolution.used = true;\n-                                ret ImportNameDefinition(def);\n+                                return ImportNameDefinition(def);\n                             }\n                             none {\n                                 // This can happen with external impls, due to\n                                 // the imperfect way we read the metadata.\n \n-                                ret NoNameDefinition;\n+                                return NoNameDefinition;\n                             }\n                         }\n                     }\n                     none {\n-                        ret NoNameDefinition;\n+                        return NoNameDefinition;\n                     }\n                 }\n             }\n             none {\n-                ret NoNameDefinition;\n+                return NoNameDefinition;\n             }\n         }\n     }\n@@ -4037,7 +4037,7 @@ class Resolver {\n             (*module_path_atoms).push((*self.atom_table).intern(ident));\n         }\n \n-        ret module_path_atoms;\n+        return module_path_atoms;\n     }\n \n     fn resolve_module_relative_path(path: @path,\n@@ -4058,7 +4058,7 @@ class Resolver {\n                                       fmt!{\"use of undeclared module `%s`\",\n                                             *(*self.atom_table).atoms_to_str\n                                               ((*module_path_atoms).get())});\n-                ret none;\n+                return none;\n             }\n \n             Indeterminate {\n@@ -4083,10 +4083,10 @@ class Resolver {\n                                                ((*module_path_atoms).get()),\n                                            *(*self.atom_table).atom_to_str\n                                                (name)});\n-                ret none;\n+                return none;\n             }\n             ChildNameDefinition(def) | ImportNameDefinition(def) {\n-                ret some(def);\n+                return some(def);\n             }\n         }\n     }\n@@ -4112,7 +4112,7 @@ class Resolver {\n                                       fmt!{\"use of undeclared module `::%s`\",\n                                             *(*self.atom_table).atoms_to_str\n                                               ((*module_path_atoms).get())});\n-                ret none;\n+                return none;\n             }\n \n             Indeterminate {\n@@ -4137,10 +4137,10 @@ class Resolver {\n                                                ((*module_path_atoms).get()),\n                                            *(*self.atom_table).atom_to_str\n                                                (name)});\n-                ret none;\n+                return none;\n             }\n             ChildNameDefinition(def) | ImportNameDefinition(def) {\n-                ret some(def);\n+                return some(def);\n             }\n         }\n     }\n@@ -4174,10 +4174,10 @@ class Resolver {\n                         local: %?\",\n                        *(*self.atom_table).atom_to_str(name),\n                        def};\n-                ret some(def);\n+                return some(def);\n             }\n             some(dl_field) | some(dl_impl(_)) | none {\n-                ret none;\n+                return none;\n             }\n         }\n     }\n@@ -4203,15 +4203,15 @@ class Resolver {\n                         debug!{\"(resolving item path in lexical scope) \\\n                                 resolved `%s` to item\",\n                                *(*self.atom_table).atom_to_str(name)};\n-                        ret some(def);\n+                        return some(def);\n                     }\n                 }\n             }\n             Indeterminate {\n                 fail ~\"unexpected indeterminate result\";\n             }\n             Failed {\n-                ret none;\n+                return none;\n             }\n         }\n     }\n@@ -4452,7 +4452,7 @@ class Resolver {\n             }\n         }\n \n-        ret found_traits;\n+        return found_traits;\n     }\n \n     fn add_trait_info_if_containing_method(found_traits: @dvec<def_id>,\n@@ -4494,7 +4494,7 @@ class Resolver {\n \n     fn check_for_unused_imports_if_necessary() {\n         if self.unused_import_lint_level == allow {\n-            ret;\n+            return;\n         }\n \n         let root_module = (*self.graph_root).get_module();\n@@ -4517,7 +4517,7 @@ class Resolver {\n                 debug!{\"(checking for unused imports in module subtree) not \\\n                         checking for unused imports for `%s`\",\n                        self.module_to_str(module_)};\n-                ret;\n+                return;\n             }\n         }\n \n@@ -4590,7 +4590,7 @@ class Resolver {\n         }\n \n         if atoms.len() == 0u {\n-            ret ~\"???\";\n+            return ~\"???\";\n         }\n \n         let mut string = ~\"\";\n@@ -4607,7 +4607,7 @@ class Resolver {\n             i -= 1u;\n         }\n \n-        ret string;\n+        return string;\n     }\n \n     fn dump_module(module_: @Module) {\n@@ -4696,7 +4696,7 @@ fn resolve_crate(session: session, lang_items: LanguageItems, crate: @crate)\n \n     let resolver = @Resolver(session, lang_items, crate);\n     (*resolver).resolve(resolver);\n-    ret {\n+    return {\n         def_map: resolver.def_map,\n         exp_map: resolver.export_map,\n         impl_map: resolver.impl_map,"}, {"sha": "072ec43dbb9151d4662519a2dad4a646adb61316", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -54,17 +54,19 @@ fn trans_opt(bcx: block, o: opt) -> opt_result {\n             let cell = empty_dest_cell();\n             bcx = tvec::trans_estr(bcx, s, ast::vstore_uniq, by_val(cell));\n             add_clean_temp(bcx, *cell, strty);\n-            ret single_result(rslt(bcx, *cell));\n+            return single_result(rslt(bcx, *cell));\n           }\n           _ {\n-            ret single_result(\n+            return single_result(\n                 rslt(bcx, consts::const_expr(ccx, l)));\n           }\n         }\n       }\n-      var(disr_val, _) { ret single_result(rslt(bcx, C_int(ccx, disr_val))); }\n+      var(disr_val, _) {\n+        return single_result(rslt(bcx, C_int(ccx, disr_val)));\n+      }\n       range(l1, l2) {\n-        ret range_result(rslt(bcx, consts::const_expr(ccx, l1)),\n+        return range_result(rslt(bcx, consts::const_expr(ccx, l1)),\n                          rslt(bcx, consts::const_expr(ccx, l2)));\n       }\n     }\n@@ -74,7 +76,7 @@ fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> opt {\n     let vdef = ast_util::variant_def_ids(tcx.def_map.get(pat_id));\n     let variants = ty::enum_variants(tcx, vdef.enm);\n     for vec::each(*variants) |v| {\n-        if vdef.var == v.id { ret var(v.disr_val, vdef); }\n+        if vdef.var == v.id { return var(v.disr_val, vdef); }\n     }\n     core::unreachable();\n }\n@@ -110,11 +112,11 @@ type match_ = ~[match_branch];\n fn has_nested_bindings(m: match_, col: uint) -> bool {\n     for vec::each(m) |br| {\n         alt br.pats[col].node {\n-          ast::pat_ident(_, _, some(_)) { ret true; }\n+          ast::pat_ident(_, _, some(_)) { return true; }\n           _ {}\n         }\n     }\n-    ret false;\n+    return false;\n }\n \n fn expand_nested_bindings(bcx: block, m: match_, col: uint, val: ValueRef)\n@@ -175,7 +177,7 @@ fn enter_match(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef,\n           none { }\n         }\n     }\n-    ret result;\n+    return result;\n }\n \n fn enter_default(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef)\n@@ -275,7 +277,7 @@ fn enter_uniq(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef)\n \n fn get_options(ccx: @crate_ctxt, m: match_, col: uint) -> ~[opt] {\n     fn add_to_set(tcx: ty::ctxt, &&set: dvec<opt>, val: opt) {\n-        if set.any(|l| opt_eq(tcx, l, val)) {ret;}\n+        if set.any(|l| opt_eq(tcx, l, val)) {return;}\n         set.push(val);\n     }\n \n@@ -294,7 +296,7 @@ fn get_options(ccx: @crate_ctxt, m: match_, col: uint) -> ~[opt] {\n             }\n         }\n     }\n-    ret vec::from_mut(dvec::unwrap(found));\n+    return vec::from_mut(dvec::unwrap(found));\n }\n \n fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n@@ -320,7 +322,7 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n         GEP_enum(bcx, blobptr, vdefs_tg, vdefs_var,\n                  enum_ty_substs, i)\n     };\n-    ret {vals: args, bcx: bcx};\n+    return {vals: args, bcx: bcx};\n }\n \n fn collect_record_fields(m: match_, col: uint) -> ~[ast::ident] {\n@@ -337,7 +339,7 @@ fn collect_record_fields(m: match_, col: uint) -> ~[ast::ident] {\n           _ { }\n         }\n     }\n-    ret fields;\n+    return fields;\n }\n \n fn root_pats_as_necessary(bcx: block, m: match_, col: uint, val: ValueRef) {\n@@ -354,31 +356,31 @@ fn root_pats_as_necessary(bcx: block, m: match_, col: uint, val: ValueRef) {\n             let ty = node_id_type(bcx, pat_id);\n             let val = load_if_immediate(bcx, val, ty);\n             root_value(bcx, val, ty, scope_id);\n-            ret; // if we kept going, we'd only be rooting same value again\n+            return; // if we kept going, we'd only be rooting same value again\n           }\n         }\n     }\n }\n \n fn any_box_pat(m: match_, col: uint) -> bool {\n     for vec::each(m) |br| {\n-        alt br.pats[col].node { ast::pat_box(_) { ret true; } _ { } }\n+        alt br.pats[col].node { ast::pat_box(_) { return true; } _ { } }\n     }\n-    ret false;\n+    return false;\n }\n \n fn any_uniq_pat(m: match_, col: uint) -> bool {\n     for vec::each(m) |br| {\n-        alt br.pats[col].node { ast::pat_uniq(_) { ret true; } _ { } }\n+        alt br.pats[col].node { ast::pat_uniq(_) { return true; } _ { } }\n     }\n-    ret false;\n+    return false;\n }\n \n fn any_tup_pat(m: match_, col: uint) -> bool {\n     for vec::each(m) |br| {\n-        alt br.pats[col].node { ast::pat_tup(_) { ret true; } _ { } }\n+        alt br.pats[col].node { ast::pat_tup(_) { return true; } _ { } }\n     }\n-    ret false;\n+    return false;\n }\n \n type exit_node = {bound: bind_map, from: BasicBlockRef, to: BasicBlockRef};\n@@ -403,13 +405,13 @@ fn pick_col(m: match_) -> uint {\n     for vec::each(scores) |score| {\n         // Irrefutable columns always go first, they'd only be duplicated in\n         // the branches.\n-        if score == 0u { ret i; }\n+        if score == 0u { return i; }\n         // If no irrefutable ones are found, we pick the one with the biggest\n         // branching factor.\n         if score > max_score { max_score = score; best_col = i; }\n         i += 1u;\n     }\n-    ret best_col;\n+    return best_col;\n }\n \n fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n@@ -421,7 +423,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n     let _icx = bcx.insn_ctxt(~\"alt::compile_submatch\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx(), dm = tcx.def_map;\n-    if m.len() == 0u { Br(bcx, option::get(chk)()); ret; }\n+    if m.len() == 0u { Br(bcx, option::get(chk)()); return; }\n     if m[0].pats.len() == 0u {\n         let data = m[0].data;\n         alt data.guard {\n@@ -464,7 +466,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n                        to: data.bodycx.llbb});\n         }\n         Br(bcx, data.bodycx.llbb);\n-        ret;\n+        return;\n     }\n \n     let col = pick_col(m);\n@@ -496,7 +498,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n         }\n         compile_submatch(bcx, enter_rec(bcx, dm, m, col, rec_fields, val),\n                          vec::append(rec_vals, vals_left), chk, exits);\n-        ret;\n+        return;\n     }\n \n     if any_tup_pat(m, col) {\n@@ -512,7 +514,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n         }\n         compile_submatch(bcx, enter_tup(bcx, dm, m, col, val, n_tup_elts),\n                          vec::append(tup_vals, vals_left), chk, exits);\n-        ret;\n+        return;\n     }\n \n     // Unbox in case of a box field\n@@ -523,7 +525,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n             GEPi(bcx, box_no_addrspace, ~[0u, abi::box_field_body]);\n         compile_submatch(bcx, enter_box(bcx, dm, m, col, val),\n                          vec::append(~[unboxed], vals_left), chk, exits);\n-        ret;\n+        return;\n     }\n \n     if any_uniq_pat(m, col) {\n@@ -533,7 +535,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n             GEPi(bcx, box_no_addrspace, ~[0u, abi::box_field_body]);\n         compile_submatch(bcx, enter_uniq(bcx, dm, m, col, val),\n                          vec::append(~[unboxed], vals_left), chk, exits);\n-        ret;\n+        return;\n     }\n \n     // Decide what kind of branch we need\n@@ -676,7 +678,7 @@ fn make_phi_bindings(bcx: block, map: ~[exit_node],\n     if !success {\n         Unreachable(bcx);\n     }\n-    ret success;\n+    return success;\n }\n \n // Copies by-value bindings into their homes.\n@@ -746,7 +748,7 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n     let mut bodies = ~[], matches = ~[];\n \n     let {bcx, val, _} = trans_temp_expr(bcx, expr);\n-    if bcx.unreachable { ret bcx; }\n+    if bcx.unreachable { return bcx; }\n \n     for vec::each(arms) |a| {\n         let body = scope_block(bcx, a.body.info(), ~\"case_body\");\n@@ -762,11 +764,11 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n \n     fn mk_fail(bcx: block, sp: span, msg: ~str,\n                    done: @mut option<BasicBlockRef>) -> BasicBlockRef {\n-            alt *done { some(bb) { ret bb; } _ { } }\n+            alt *done { some(bb) { return bb; } _ { } }\n             let fail_cx = sub_block(bcx, ~\"case_fallthrough\");\n             trans_fail(fail_cx, some(sp), msg);\n             *done = some(fail_cx.llbb);\n-            ret fail_cx.llbb;\n+            return fail_cx.llbb;\n     }\n     let t = node_id_type(bcx, expr.id);\n     let mk_fail = alt mode {\n@@ -819,7 +821,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n     // Necessary since bind_irrefutable_pat is called outside trans_alt\n     alt pat.node {\n       ast::pat_ident(_, _,inner) {\n-        if pat_is_variant(bcx.tcx().def_map, pat) { ret bcx; }\n+        if pat_is_variant(bcx.tcx().def_map, pat) { return bcx; }\n         if make_copy {\n             let ty = node_id_type(bcx, pat.id);\n             let llty = type_of::type_of(ccx, ty);\n@@ -873,7 +875,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n       }\n       ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) { }\n     }\n-    ret bcx;\n+    return bcx;\n }\n \n // Local Variables:"}, {"sha": "c864dec860e6e703513a7693229fea5c9714c8f2", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 247, "deletions": 243, "changes": 490, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -74,7 +74,7 @@ fn dest_str(ccx: @crate_ctxt, d: dest) -> ~str {\n }\n \n fn empty_dest_cell() -> @mut ValueRef {\n-    ret @mut llvm::LLVMGetUndef(T_nil());\n+    return @mut llvm::LLVMGetUndef(T_nil());\n }\n \n fn dup_for_join(dest: dest) -> dest {\n@@ -148,7 +148,7 @@ fn join_returns(parent_cx: block, in_cxs: ~[block],\n           _ {}\n         }\n     }\n-    ret out;\n+    return out;\n }\n \n // Used to put an immediate value in a dest.\n@@ -158,7 +158,7 @@ fn store_in_dest(bcx: block, val: ValueRef, dest: dest) -> block {\n       by_val(cell) { *cell = val; }\n       save_in(addr) { Store(bcx, val, addr); }\n     }\n-    ret bcx;\n+    return bcx;\n }\n \n fn get_dest_addr(dest: dest) -> ValueRef {\n@@ -182,11 +182,11 @@ fn decl_fn(llmod: ModuleRef, name: ~str, cc: lib::llvm::CallConv,\n         llvm::LLVMGetOrInsertFunction(llmod, buf, llty)\n     });\n     lib::llvm::SetFunctionCallConv(llfn, cc);\n-    ret llfn;\n+    return llfn;\n }\n \n fn decl_cdecl_fn(llmod: ModuleRef, name: ~str, llty: TypeRef) -> ValueRef {\n-    ret decl_fn(llmod, name, lib::llvm::CCallConv, llty);\n+    return decl_fn(llmod, name, lib::llvm::CCallConv, llty);\n }\n \n \n@@ -196,24 +196,24 @@ fn decl_internal_cdecl_fn(llmod: ModuleRef, name: ~str, llty: TypeRef) ->\n    ValueRef {\n     let llfn = decl_cdecl_fn(llmod, name, llty);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n-    ret llfn;\n+    return llfn;\n }\n \n fn get_extern_fn(externs: hashmap<~str, ValueRef>,\n                  llmod: ModuleRef, name: ~str,\n                  cc: lib::llvm::CallConv, ty: TypeRef) -> ValueRef {\n-    if externs.contains_key(name) { ret externs.get(name); }\n+    if externs.contains_key(name) { return externs.get(name); }\n     let f = decl_fn(llmod, name, cc, ty);\n     externs.insert(name, f);\n-    ret f;\n+    return f;\n }\n \n fn get_extern_const(externs: hashmap<~str, ValueRef>, llmod: ModuleRef,\n                     name: ~str, ty: TypeRef) -> ValueRef {\n-    if externs.contains_key(name) { ret externs.get(name); }\n+    if externs.contains_key(name) { return externs.get(name); }\n     let c = str::as_c_str(name, |buf| llvm::LLVMAddGlobal(llmod, ty, buf));\n     externs.insert(name, c);\n-    ret c;\n+    return c;\n }\n \n fn get_simple_extern_fn(cx: block,\n@@ -225,7 +225,7 @@ fn get_simple_extern_fn(cx: block,\n     let inputs = vec::from_elem(n_args as uint, ccx.int_type);\n     let output = ccx.int_type;\n     let t = T_fn(inputs, output);\n-    ret get_extern_fn(externs, llmod, name, lib::llvm::CCallConv, t);\n+    return get_extern_fn(externs, llmod, name, lib::llvm::CCallConv, t);\n }\n \n fn trans_foreign_call(cx: block, externs: hashmap<~str, ValueRef>,\n@@ -239,7 +239,7 @@ fn trans_foreign_call(cx: block, externs: hashmap<~str, ValueRef>,\n     for vec::each(args) |a| {\n         vec::push(call_args, a);\n     }\n-    ret Call(cx, llforeign, call_args);\n+    return Call(cx, llforeign, call_args);\n }\n \n fn trans_free(cx: block, v: ValueRef) -> block {\n@@ -256,13 +256,13 @@ fn trans_unique_free(cx: block, v: ValueRef) -> block {\n fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let _icx = cx.insn_ctxt(~\"umax\");\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n-    ret Select(cx, cond, b, a);\n+    return Select(cx, cond, b, a);\n }\n \n fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let _icx = cx.insn_ctxt(~\"umin\");\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n-    ret Select(cx, cond, a, b);\n+    return Select(cx, cond, a, b);\n }\n \n fn alloca(cx: block, t: TypeRef) -> ValueRef {\n@@ -275,11 +275,11 @@ fn alloca_zeroed(cx: block, t: TypeRef) -> ValueRef {\n \n fn alloca_maybe_zeroed(cx: block, t: TypeRef, zero: bool) -> ValueRef {\n     let _icx = cx.insn_ctxt(~\"alloca\");\n-    if cx.unreachable { ret llvm::LLVMGetUndef(t); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(t); }\n     let initcx = raw_block(cx.fcx, false, cx.fcx.llstaticallocas);\n     let p = Alloca(initcx, t);\n     if zero { Store(initcx, C_null(t), p); }\n-    ret p;\n+    return p;\n }\n \n fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) -> block {\n@@ -288,13 +288,14 @@ fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) -> block {\n     let ccx = cx.ccx();\n     let llty = type_of(ccx, t);\n     Store(bcx, C_null(llty), llptr);\n-    ret bcx;\n+    return bcx;\n }\n \n fn arrayalloca(cx: block, t: TypeRef, v: ValueRef) -> ValueRef {\n     let _icx = cx.insn_ctxt(~\"arrayalloca\");\n-    if cx.unreachable { ret llvm::LLVMGetUndef(t); }\n-    ret ArrayAlloca(raw_block(cx.fcx, false, cx.fcx.llstaticallocas), t, v);\n+    if cx.unreachable { return llvm::LLVMGetUndef(t); }\n+    return ArrayAlloca(\n+        raw_block(cx.fcx, false, cx.fcx.llstaticallocas), t, v);\n }\n \n // Given a pointer p, returns a pointer sz(p) (i.e., inc'd by sz bytes).\n@@ -376,7 +377,7 @@ fn malloc_raw_dyn(bcx: block, t: ty::t, heap: heap,\n     let rval = alloca_zeroed(bcx, T_ptr(T_i8()));\n     let bcx = trans_rtcall(bcx, rtcall, ~[tydesc, size], save_in(rval));\n     let retval = {bcx: bcx, val: PointerCast(bcx, Load(bcx, rval), llty)};\n-    ret retval;\n+    return retval;\n }\n \n // malloc_raw: expects an unboxed type and returns a pointer to\n@@ -394,7 +395,7 @@ fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef)\n     let {bcx: bcx, val: llbox} = malloc_raw_dyn(bcx, t, heap, size);\n     let non_gc_box = non_gc_box_cast(bcx, llbox);\n     let body = GEPi(bcx, non_gc_box, ~[0u, abi::box_field_body]);\n-    ret {bcx: bcx, box: llbox, body: body};\n+    return {bcx: bcx, box: llbox, body: body};\n }\n \n fn malloc_general(bcx: block, t: ty::t, heap: heap)\n@@ -510,7 +511,7 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n           mut free_glue: none,\n           mut visit_glue: none};\n     log(debug, ~\"--- declare_tydesc \" + ppaux::ty_to_str(ccx.tcx, t));\n-    ret inf;\n+    return inf;\n }\n \n type glue_helper = fn@(block, ValueRef, ty::t);\n@@ -529,7 +530,7 @@ fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n     note_unique_llvm_symbol(ccx, fn_nm);\n     let llfn = decl_cdecl_fn(ccx.llmod, fn_nm, llfnty);\n     set_glue_inlining(llfn, t);\n-    ret llfn;\n+    return llfn;\n }\n \n fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n@@ -551,23 +552,23 @@ fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n     let llval0 = BitCast(bcx, llrawptr0, llty);\n     helper(bcx, llval0, t);\n     finish_fn(fcx, lltop);\n-    ret llfn;\n+    return llfn;\n }\n \n fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n                      helper: glue_helper, name: ~str)\n     -> ValueRef {\n     let _icx = ccx.insn_ctxt(~\"make_generic_glue\");\n     if !ccx.sess.trans_stats() {\n-        ret make_generic_glue_inner(ccx, t, llfn, helper);\n+        return make_generic_glue_inner(ccx, t, llfn, helper);\n     }\n \n     let start = time::get_time();\n     let llval = make_generic_glue_inner(ccx, t, llfn, helper);\n     let end = time::get_time();\n     log_fn_time(ccx, ~\"glue \" + name + ~\" \" + ty_to_short_str(ccx.tcx, t),\n                 start, end);\n-    ret llval;\n+    return llval;\n }\n \n fn emit_tydescs(ccx: @crate_ctxt) {\n@@ -712,7 +713,7 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n       ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) {\n         make_free_glue(bcx, v,\n                        tvec::expand_boxed_vec_ty(bcx.tcx(), t));\n-        ret;\n+        return;\n       }\n       ty::ty_fn(_) {\n         closure::make_fn_glue(bcx, v, t, free_ty)\n@@ -879,13 +880,13 @@ fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n     let f = |a| compare_scalar_values(cx, lhs, rhs, a, op);\n \n     alt ty::get(t).struct {\n-      ty::ty_nil { ret rslt(cx, f(nil_type)); }\n-      ty::ty_bool | ty::ty_ptr(_) { ret rslt(cx, f(unsigned_int)); }\n-      ty::ty_int(_) { ret rslt(cx, f(signed_int)); }\n-      ty::ty_uint(_) { ret rslt(cx, f(unsigned_int)); }\n-      ty::ty_float(_) { ret rslt(cx, f(floating_point)); }\n+      ty::ty_nil { return rslt(cx, f(nil_type)); }\n+      ty::ty_bool | ty::ty_ptr(_) { return rslt(cx, f(unsigned_int)); }\n+      ty::ty_int(_) { return rslt(cx, f(signed_int)); }\n+      ty::ty_uint(_) { return rslt(cx, f(unsigned_int)); }\n+      ty::ty_float(_) { return rslt(cx, f(floating_point)); }\n       ty::ty_type {\n-        ret rslt(trans_fail(cx, none,\n+        return rslt(trans_fail(cx, none,\n                             ~\"attempt to compare values of type type\"),\n                  C_nil());\n       }\n@@ -912,8 +913,8 @@ fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n         // We don't need to do actual comparisons for nil.\n         // () == () holds but () < () does not.\n         alt op {\n-          ast::eq | ast::le | ast::ge { ret C_bool(true); }\n-          ast::ne | ast::lt | ast::gt { ret C_bool(false); }\n+          ast::eq | ast::le | ast::ge { return C_bool(true); }\n+          ast::ne | ast::lt | ast::gt { return C_bool(false); }\n           // refinements would be nice\n           _ { die(); }\n         }\n@@ -928,7 +929,7 @@ fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n           ast::ge { lib::llvm::RealOGE }\n           _ { die(); }\n         };\n-        ret FCmp(cx, cmp, lhs, rhs);\n+        return FCmp(cx, cmp, lhs, rhs);\n       }\n       signed_int {\n         let cmp = alt op {\n@@ -940,7 +941,7 @@ fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n           ast::ge { lib::llvm::IntSGE }\n           _ { die(); }\n         };\n-        ret ICmp(cx, cmp, lhs, rhs);\n+        return ICmp(cx, cmp, lhs, rhs);\n       }\n       unsigned_int {\n         let cmp = alt op {\n@@ -952,7 +953,7 @@ fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n           ast::ge { lib::llvm::IntUGE }\n           _ { die(); }\n         };\n-        ret ICmp(cx, cmp, lhs, rhs);\n+        return ICmp(cx, cmp, lhs, rhs);\n       }\n     }\n }\n@@ -961,7 +962,7 @@ type val_pair_fn = fn@(block, ValueRef, ValueRef) -> block;\n type val_and_ty_fn = fn@(block, ValueRef, ty::t) -> block;\n \n fn load_inbounds(cx: block, p: ValueRef, idxs: ~[uint]) -> ValueRef {\n-    ret Load(cx, GEPi(cx, p, idxs));\n+    return Load(cx, GEPi(cx, p, idxs));\n }\n \n fn store_inbounds(cx: block, v: ValueRef, p: ValueRef,\n@@ -979,7 +980,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                     tps: ~[ty::t], tid: ast::def_id,\n                     f: val_and_ty_fn) -> block {\n         let _icx = cx.insn_ctxt(~\"iter_variant\");\n-        if variant.args.len() == 0u { ret cx; }\n+        if variant.args.len() == 0u { return cx; }\n         let fn_ty = variant.ctor_ty;\n         let ccx = cx.ccx();\n         let mut cx = cx;\n@@ -996,7 +997,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n           }\n           _ { cx.tcx().sess.bug(~\"iter_variant: not a function type\"); }\n         }\n-        ret cx;\n+        return cx;\n     }\n \n     /*\n@@ -1027,7 +1028,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n \n         // Cast the enums to types we can GEP into.\n         if n_variants == 1u {\n-            ret iter_variant(cx, av, variants[0],\n+            return iter_variant(cx, av, variants[0],\n                              substs.tps, tid, f);\n         }\n \n@@ -1056,7 +1057,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                              substs.tps, tid, f);\n             Br(variant_cx, next_cx.llbb);\n         }\n-        ret next_cx;\n+        return next_cx;\n       }\n       ty::ty_class(did, substs) {\n           // Take the drop bit into account\n@@ -1073,7 +1074,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n       }\n       _ { cx.sess().unimpl(~\"type in iter_structural_ty\"); }\n     }\n-    ret cx;\n+    return cx;\n }\n \n fn lazily_emit_all_tydesc_glue(ccx: @crate_ctxt,\n@@ -1154,7 +1155,7 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n fn call_tydesc_glue_full(++cx: block, v: ValueRef, tydesc: ValueRef,\n                          field: uint, static_ti: option<@tydesc_info>) {\n     let _icx = cx.insn_ctxt(~\"call_tydesc_glue_full\");\n-        if cx.unreachable { ret; }\n+        if cx.unreachable { return; }\n \n     let mut static_glue_fn = none;\n     alt static_ti {\n@@ -1196,7 +1197,7 @@ fn call_tydesc_glue(++cx: block, v: ValueRef, t: ty::t, field: uint)\n     let _icx = cx.insn_ctxt(~\"call_tydesc_glue\");\n     let ti = get_tydesc(cx.ccx(), t);\n     call_tydesc_glue_full(cx, v, ti.tydesc, field, some(ti));\n-    ret cx;\n+    return cx;\n }\n \n fn call_cmp_glue(bcx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n@@ -1217,23 +1218,23 @@ fn call_cmp_glue(bcx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n     let llcmpresultptr = alloca(bcx, T_i1());\n     Call(bcx, llfn, ~[llcmpresultptr, lltydesc,\n                       llrawlhsptr, llrawrhsptr, llop]);\n-    ret Load(bcx, llcmpresultptr);\n+    return Load(bcx, llcmpresultptr);\n }\n \n fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     let _icx = cx.insn_ctxt(~\"take_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n-        ret call_tydesc_glue(cx, v, t, abi::tydesc_field_take_glue);\n+        return call_tydesc_glue(cx, v, t, abi::tydesc_field_take_glue);\n     }\n-    ret cx;\n+    return cx;\n }\n \n fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     let _icx = cx.insn_ctxt(~\"drop_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n-        ret call_tydesc_glue(cx, v, t, abi::tydesc_field_drop_glue);\n+        return call_tydesc_glue(cx, v, t, abi::tydesc_field_drop_glue);\n     }\n-    ret cx;\n+    return cx;\n }\n \n fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n@@ -1276,9 +1277,9 @@ fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> result {\n fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     let _icx = cx.insn_ctxt(~\"free_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n-        ret call_tydesc_glue(cx, v, t, abi::tydesc_field_free_glue);\n+        return call_tydesc_glue(cx, v, t, abi::tydesc_field_free_glue);\n     }\n-    ret cx;\n+    return cx;\n }\n \n fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n@@ -1317,10 +1318,10 @@ enum copy_action { INIT, DROP_EXISTING, }\n \n // These are the types that are passed by pointer.\n fn type_is_structural_or_param(t: ty::t) -> bool {\n-    if ty::type_is_structural(t) { ret true; }\n+    if ty::type_is_structural(t) { return true; }\n     alt ty::get(t).struct {\n-      ty::ty_param(*) { ret true; }\n-      _ { ret false; }\n+      ty::ty_param(*) { return true; }\n+      _ { return false; }\n     }\n }\n \n@@ -1348,18 +1349,18 @@ fn copy_val_no_check(bcx: block, action: copy_action, dst: ValueRef,\n     let mut bcx = bcx;\n     if ty::type_is_scalar(t) {\n         Store(bcx, src, dst);\n-        ret bcx;\n+        return bcx;\n     }\n-    if ty::type_is_nil(t) || ty::type_is_bot(t) { ret bcx; }\n+    if ty::type_is_nil(t) || ty::type_is_bot(t) { return bcx; }\n     if ty::type_is_boxed(t) || ty::type_is_unique(t) {\n         if action == DROP_EXISTING { bcx = drop_ty(bcx, dst, t); }\n         Store(bcx, src, dst);\n-        ret take_ty(bcx, dst, t);\n+        return take_ty(bcx, dst, t);\n     }\n     if type_is_structural_or_param(t) {\n         if action == DROP_EXISTING { bcx = drop_ty(bcx, dst, t); }\n         memmove_ty(bcx, dst, src, t);\n-        ret take_ty(bcx, dst, t);\n+        return take_ty(bcx, dst, t);\n     }\n     ccx.sess.bug(~\"unexpected type in trans::copy_val_no_check: \" +\n                      ppaux::ty_to_str(ccx.tcx, t));\n@@ -1381,24 +1382,24 @@ fn move_val(cx: block, action: copy_action, dst: ValueRef,\n     if ty::type_is_scalar(t) {\n         if src.kind == lv_owned { src_val = Load(cx, src_val); }\n         Store(cx, src_val, dst);\n-        ret cx;\n+        return cx;\n     } else if ty::type_is_nil(t) || ty::type_is_bot(t) {\n-        ret cx;\n+        return cx;\n     } else if ty::type_is_boxed(t) || ty::type_is_unique(t) {\n         if src.kind == lv_owned { src_val = Load(cx, src_val); }\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n         Store(cx, src_val, dst);\n-        if src.kind == lv_owned { ret zero_mem(cx, src.val, t); }\n+        if src.kind == lv_owned { return zero_mem(cx, src.val, t); }\n         // If we're here, it must be a temporary.\n         revoke_clean(cx, src_val);\n-        ret cx;\n+        return cx;\n     } else if type_is_structural_or_param(t) {\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n         memmove_ty(cx, dst, src_val, t);\n-        if src.kind == lv_owned { ret zero_mem(cx, src_val, t); }\n+        if src.kind == lv_owned { return zero_mem(cx, src_val, t); }\n         // If we're here, it must be a temporary.\n         revoke_clean(cx, src_val);\n-        ret cx;\n+        return cx;\n     }\n     cx.sess().bug(~\"unexpected type in trans::move_val: \" +\n                   ppaux::ty_to_str(tcx, t));\n@@ -1415,14 +1416,14 @@ fn store_temp_expr(cx: block, action: copy_action, dst: ValueRef,\n                 } else {\n                     src.val\n                 };\n-        ret copy_val(cx, action, dst, v, t);\n+        return copy_val(cx, action, dst, v, t);\n     }\n-    ret move_val(cx, action, dst, src, t);\n+    return move_val(cx, action, dst, src, t);\n }\n \n fn trans_lit(cx: block, e: @ast::expr, lit: ast::lit, dest: dest) -> block {\n     let _icx = cx.insn_ctxt(~\"trans_lit\");\n-    if dest == ignore { ret cx; }\n+    if dest == ignore { return cx; }\n     alt lit.node {\n       ast::lit_str(s) { tvec::trans_estr(cx, s,\n                                          ast::vstore_fixed(none), dest) }\n@@ -1440,7 +1441,7 @@ fn trans_boxed_expr(bcx: block, contents: @ast::expr,\n     add_clean_free(bcx, box, heap);\n     let bcx = trans_expr_save_in(bcx, contents, body);\n     revoke_clean(bcx, box);\n-    ret store_in_dest(bcx, box, dest);\n+    return store_in_dest(bcx, box, dest);\n }\n \n fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n@@ -1450,7 +1451,7 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n     alt bcx.ccx().maps.method_map.find(un_expr.id) {\n       some(mentry) {\n         let fty = node_id_type(bcx, un_expr.callee_id);\n-        ret trans_call_inner(\n+        return trans_call_inner(\n             bcx, un_expr.info(), fty,\n             expr_ty(bcx, un_expr),\n             |bcx| impl::trans_method_callee(bcx, un_expr.callee_id, e,\n@@ -1460,7 +1461,7 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n       _ {}\n     }\n \n-    if dest == ignore { ret trans_expr(bcx, e, ignore); }\n+    if dest == ignore { return trans_expr(bcx, e, ignore); }\n     let e_ty = expr_ty(bcx, e);\n     alt op {\n       ast::not {\n@@ -1496,15 +1497,15 @@ fn trans_addr_of(cx: block, e: @ast::expr, dest: dest) -> block {\n     if (kind == lv_temporary && is_immediate) || kind == lv_owned_imm {\n         val = do_spill(bcx, val, ety);\n     }\n-    ret store_in_dest(bcx, val, dest);\n+    return store_in_dest(bcx, val, dest);\n }\n \n fn trans_compare(cx: block, op: ast::binop, lhs: ValueRef,\n                  _lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t) -> result {\n     let _icx = cx.insn_ctxt(~\"trans_compare\");\n     if ty::type_is_scalar(rhs_t) {\n       let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, op);\n-      ret rslt(rs.bcx, rs.val);\n+      return rslt(rs.bcx, rs.val);\n     }\n \n     // Determine the operation we need.\n@@ -1598,7 +1599,7 @@ fn trans_eager_binop(cx: block, span: span, op: ast::binop, lhs: ValueRef,\n     -> block {\n     let mut cx = cx;\n     let _icx = cx.insn_ctxt(~\"trans_eager_binop\");\n-    if dest == ignore { ret cx; }\n+    if dest == ignore { return cx; }\n     let intype = {\n         if ty::type_is_bot(lhs_t) { rhs_t }\n         else { lhs_t }\n@@ -1662,7 +1663,7 @@ fn trans_eager_binop(cx: block, span: span, op: ast::binop, lhs: ValueRef,\n         cmpr.val\n       }\n     };\n-    ret store_in_dest(cx, val, dest);\n+    return store_in_dest(cx, val, dest);\n }\n \n fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n@@ -1694,15 +1695,15 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n             },\n             arg_exprs(~[src]), save_in(target));\n \n-        ret move_val(bcx, DROP_EXISTING, lhs_res.val,\n+        return move_val(bcx, DROP_EXISTING, lhs_res.val,\n                      {bcx: bcx, val: target, kind: lv_owned},\n                      dty);\n       }\n       _ {}\n     }\n \n     let {bcx, val: rhs_val} = trans_temp_expr(lhs_res.bcx, src);\n-    ret trans_eager_binop(bcx, ex.span,\n+    return trans_eager_binop(bcx, ex.span,\n                           op, Load(bcx, lhs_res.val), t, rhs_val, t,\n                           save_in(lhs_res.val));\n }\n@@ -1784,7 +1785,7 @@ fn autoderef(cx: block, e_id: ast::node_id,\n     // we should have, or we asked to deref as many times as we can\n     assert derefs == max || max == uint::max_value;\n \n-    ret {bcx: cx, val: v1, ty: t1};\n+    return {bcx: cx, val: v1, ty: t1};\n }\n \n // refinement types would obviate the need for this\n@@ -1798,7 +1799,7 @@ fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n             trans_temp_expr(bcx, a)\n         }\n     };\n-    if past_lhs.unreachable { ret past_lhs; }\n+    if past_lhs.unreachable { return past_lhs; }\n     let join = sub_block(bcx, ~\"join\"), before_rhs = sub_block(bcx, ~\"rhs\");\n \n     alt op {\n@@ -1811,11 +1812,11 @@ fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n         }\n     };\n \n-    if past_rhs.unreachable { ret store_in_dest(join, lhs, dest); }\n+    if past_rhs.unreachable { return store_in_dest(join, lhs, dest); }\n     Br(past_rhs, join.llbb);\n     let phi =\n         Phi(join, T_bool(), ~[lhs, rhs], ~[past_lhs.llbb, past_rhs.llbb]);\n-    ret store_in_dest(join, phi, dest);\n+    return store_in_dest(join, phi, dest);\n }\n \n fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n@@ -1825,7 +1826,7 @@ fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n     alt bcx.ccx().maps.method_map.find(ex.id) {\n       some(origin) {\n         let fty = node_id_type(bcx, ex.callee_id);\n-        ret trans_call_inner(\n+        return trans_call_inner(\n             bcx, ex.info(), fty,\n             expr_ty(bcx, ex),\n             |bcx| {\n@@ -1839,16 +1840,16 @@ fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n     // First couple cases are lazy:\n     alt op {\n       ast::and {\n-        ret trans_lazy_binop(bcx, lazy_and, lhs, rhs, dest);\n+        return trans_lazy_binop(bcx, lazy_and, lhs, rhs, dest);\n       }\n       ast::or {\n-        ret trans_lazy_binop(bcx, lazy_or, lhs, rhs, dest);\n+        return trans_lazy_binop(bcx, lazy_or, lhs, rhs, dest);\n       }\n       _ {\n         // Remaining cases are eager:\n         let lhs_res = trans_temp_expr(bcx, lhs);\n         let rhs_res = trans_temp_expr(lhs_res.bcx, rhs);\n-        ret trans_eager_binop(rhs_res.bcx, ex.span,\n+        return trans_eager_binop(rhs_res.bcx, ex.span,\n                               op, lhs_res.val,\n                               expr_ty(bcx, lhs), rhs_res.val,\n                               expr_ty(bcx, rhs), dest);\n@@ -1890,7 +1891,7 @@ fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n       _ { else_cx }\n     };\n     let else_bcx = trans_block_cleanups(else_bcx, else_cx);\n-    ret join_returns(cx,\n+    return join_returns(cx,\n                      ~[then_bcx, else_bcx], ~[then_dest, else_dest], dest);\n }\n \n@@ -1908,7 +1909,7 @@ fn trans_while(cx: block, cond: @ast::expr, body: ast::blk)\n     CondBr(cond_bcx, cond_res.val, body_cx.llbb, next_cx.llbb);\n     let body_end = trans_block(body_cx, body, ignore);\n     cleanup_and_Br(body_end, body_cx, cond_cx.llbb);\n-    ret next_cx;\n+    return next_cx;\n }\n \n fn trans_loop(cx:block, body: ast::blk) -> block {\n@@ -1918,7 +1919,7 @@ fn trans_loop(cx:block, body: ast::blk) -> block {\n     let body_end = trans_block(body_cx, body, ignore);\n     cleanup_and_Br(body_end, body_cx, body_cx.llbb);\n     Br(cx, body_cx.llbb);\n-    ret next_cx;\n+    return next_cx;\n }\n \n enum lval_kind {\n@@ -1943,19 +1944,19 @@ fn null_env_ptr(bcx: block) -> ValueRef {\n }\n \n fn lval_from_local_var(bcx: block, r: local_var_result) -> lval_result {\n-    ret { bcx: bcx, val: r.val, kind: r.kind };\n+    return { bcx: bcx, val: r.val, kind: r.kind };\n }\n \n fn lval_owned(bcx: block, val: ValueRef) -> lval_result {\n-    ret {bcx: bcx, val: val, kind: lv_owned};\n+    return {bcx: bcx, val: val, kind: lv_owned};\n }\n fn lval_temp(bcx: block, val: ValueRef) -> lval_result {\n-    ret {bcx: bcx, val: val, kind: lv_temporary};\n+    return {bcx: bcx, val: val, kind: lv_temporary};\n }\n \n fn lval_no_env(bcx: block, val: ValueRef, kind: lval_kind)\n     -> lval_maybe_callee {\n-    ret {bcx: bcx, val: val, kind: kind, env: is_closure};\n+    return {bcx: bcx, val: val, kind: kind, env: is_closure};\n }\n \n fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n@@ -1964,12 +1965,12 @@ fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     alt ty::get(t).struct {\n       ty::ty_fn(_) {\n         let llty = type_of_fn_from_ty(ccx, t);\n-        ret get_extern_fn(ccx.externs, ccx.llmod, name,\n+        return get_extern_fn(ccx.externs, ccx.llmod, name,\n                           lib::llvm::CCallConv, llty);\n       }\n       _ {\n         let llty = type_of(ccx, t);\n-        ret get_extern_const(ccx.externs, ccx.llmod, name, llty);\n+        return get_extern_const(ccx.externs, ccx.llmod, name, llty);\n       }\n     };\n }\n@@ -2084,7 +2085,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n       some(val) {\n         debug!{\"leaving monomorphic fn %s\",\n                ty::item_path_str(ccx.tcx, fn_id)};\n-        ret {val: val, must_cast: must_cast};\n+        return {val: val, must_cast: must_cast};\n       }\n       none {}\n     }\n@@ -2105,7 +2106,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n       { (pt, i.ident, i.span) }\n       ast_map::node_foreign_item(_, abi, _) {\n         // Foreign externs don't have to be monomorphized.\n-        ret {val: get_item_val(ccx, fn_id.node),\n+        return {val: get_item_val(ccx, fn_id.node),\n              must_cast: true};\n       }\n       ast_map::node_ctor(nm, _, ct, _, pt) { (pt, nm, ct.span) }\n@@ -2330,7 +2331,7 @@ fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n             val = PointerCast(bcx, val, T_ptr(type_of_fn_from_ty(\n                 ccx, node_id_type(bcx, id))));\n         }\n-        ret {bcx: bcx, val: val, kind: lv_owned, env: null_env};\n+        return {bcx: bcx, val: val, kind: lv_owned, env: null_env};\n     }\n \n     let mut val = if fn_id.crate == ast::local_crate {\n@@ -2351,15 +2352,15 @@ fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n           ast::extern_fn {\n             // Extern functions are just opaque pointers\n             let val = PointerCast(bcx, val, T_ptr(T_i8()));\n-            ret lval_no_env(bcx, val, lv_owned_imm);\n+            return lval_no_env(bcx, val, lv_owned_imm);\n           }\n           _ { /* fall through */ }\n         }\n       }\n       _ { /* fall through */ }\n     }\n \n-    ret {bcx: bcx, val: val, kind: lv_owned, env: null_env};\n+    return {bcx: bcx, val: val, kind: lv_owned, env: null_env};\n }\n \n fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n@@ -2375,9 +2376,9 @@ fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n         lib::llvm::SetLinkage(gvar, lib::llvm::ExternalLinkage);\n         llvm::LLVMSetGlobalConstant(gvar, True);\n         ccx.discrims.insert(vid, gvar);\n-        ret gvar;\n+        return gvar;\n       }\n-      some(llval) { ret llval; }\n+      some(llval) { return llval; }\n     }\n }\n \n@@ -2398,23 +2399,23 @@ fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n     alt def {\n       ast::def_upvar(nid, _, _) {\n         assert (cx.fcx.llupvars.contains_key(nid));\n-        ret { val: cx.fcx.llupvars.get(nid), kind: lv_owned };\n+        return { val: cx.fcx.llupvars.get(nid), kind: lv_owned };\n       }\n       ast::def_arg(nid, _) {\n         assert (cx.fcx.llargs.contains_key(nid));\n-        ret take_local(cx.fcx.llargs, nid);\n+        return take_local(cx.fcx.llargs, nid);\n       }\n       ast::def_local(nid, _) | ast::def_binding(nid) {\n         assert (cx.fcx.lllocals.contains_key(nid));\n-        ret take_local(cx.fcx.lllocals, nid);\n+        return take_local(cx.fcx.lllocals, nid);\n       }\n       ast::def_self(sid) {\n         let slf = alt copy cx.fcx.llself {\n           some(s) { cast_self(cx, s) }\n           none { cx.sess().bug(~\"trans_local_var: reference to self \\\n                                  out of context\"); }\n         };\n-        ret {val: slf, kind: lv_owned};\n+        return {val: slf, kind: lv_owned};\n       }\n       _ {\n         cx.sess().unimpl(fmt!{\"unsupported def type in trans_local_def: %?\",\n@@ -2429,7 +2430,7 @@ fn trans_path(cx: block, id: ast::node_id)\n     alt cx.tcx().def_map.find(id) {\n       none { cx.sess().bug(~\"trans_path: unbound node ID\"); }\n       some(df) {\n-          ret trans_var(cx, df, id);\n+          return trans_var(cx, df, id);\n       }\n     }\n }\n@@ -2439,12 +2440,12 @@ fn trans_var(cx: block, def: ast::def, id: ast::node_id)-> lval_maybe_callee {\n     let ccx = cx.ccx();\n     alt def {\n       ast::def_fn(did, _) {\n-        ret lval_static_fn(cx, did, id);\n+        return lval_static_fn(cx, did, id);\n       }\n       ast::def_variant(tid, vid) {\n         if ty::enum_variant_with_id(ccx.tcx, tid, vid).args.len() > 0u {\n             // N-ary variant.\n-            ret lval_static_fn(cx, vid, id);\n+            return lval_static_fn(cx, vid, id);\n         } else {\n             // Nullary variant.\n             let enum_ty = node_id_type(cx, id);\n@@ -2453,22 +2454,22 @@ fn trans_var(cx: block, def: ast::def, id: ast::node_id)-> lval_maybe_callee {\n             let lldiscrim_gv = lookup_discriminant(ccx, vid);\n             let lldiscrim = Load(cx, lldiscrim_gv);\n             Store(cx, lldiscrim, lldiscrimptr);\n-            ret lval_no_env(cx, llenumptr, lv_temporary);\n+            return lval_no_env(cx, llenumptr, lv_temporary);\n         }\n       }\n       ast::def_const(did) {\n         if did.crate == ast::local_crate {\n-            ret lval_no_env(cx, get_item_val(ccx, did.node), lv_owned);\n+            return lval_no_env(cx, get_item_val(ccx, did.node), lv_owned);\n         } else {\n             let tp = node_id_type(cx, id);\n             let val = trans_external_path(ccx, did, tp);\n-            ret lval_no_env(cx, load_if_immediate(cx, val, tp),\n+            return lval_no_env(cx, load_if_immediate(cx, val, tp),\n                             lv_owned_imm);\n         }\n       }\n       _ {\n         let loc = trans_local_var(cx, def);\n-        ret lval_no_env(cx, loc.val, loc.kind);\n+        return lval_no_env(cx, loc.val, loc.kind);\n       }\n     }\n }\n@@ -2514,7 +2515,7 @@ fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n     }\n     else { GEPi(bcx, val, ~[0u, ix]) };\n \n-    ret {bcx: bcx, val: val, kind: lv_owned};\n+    return {bcx: bcx, val: val, kind: lv_owned};\n }\n \n \n@@ -2564,7 +2565,7 @@ fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n         trans_fail(bcx, some(ex.span), ~\"bounds check\")\n     };\n     let elt = InBoundsGEP(bcx, base, ~[ix_val]);\n-    ret lval_owned(bcx, PointerCast(bcx, elt, T_ptr(llunitty)));\n+    return lval_owned(bcx, PointerCast(bcx, elt, T_ptr(llunitty)));\n }\n \n fn expr_is_borrowed(bcx: block, e: @ast::expr) -> bool {\n@@ -2579,13 +2580,13 @@ fn expr_is_lval(bcx: block, e: @ast::expr) -> bool {\n fn trans_callee(bcx: block, e: @ast::expr) -> lval_maybe_callee {\n     let _icx = bcx.insn_ctxt(~\"trans_callee\");\n     alt e.node {\n-      ast::expr_path(path) { ret trans_path(bcx, e.id); }\n+      ast::expr_path(path) { return trans_path(bcx, e.id); }\n       ast::expr_field(base, _, _) {\n         // Lval means this is a record field, so not a method\n         if !expr_is_lval(bcx, e) {\n             alt bcx.ccx().maps.method_map.find(e.id) {\n               some(origin) { // An impl method\n-                ret impl::trans_method_callee(bcx, e.id, base, origin);\n+                return impl::trans_method_callee(bcx, e.id, base, origin);\n               }\n               _ {\n                 bcx.ccx().sess.span_bug(e.span, ~\"trans_callee: weird expr\");\n@@ -2596,15 +2597,15 @@ fn trans_callee(bcx: block, e: @ast::expr) -> lval_maybe_callee {\n       _ {}\n     }\n     let lv = trans_temp_lval(bcx, e);\n-    ret lval_no_env(lv.bcx, lv.val, lv.kind);\n+    return lval_no_env(lv.bcx, lv.val, lv.kind);\n }\n \n // Use this when you know you are compiling an lval.\n // The additional bool returned indicates whether it's mem (that is\n // represented as an alloca or heap, hence needs a 'load' to be used as an\n // immediate).\n fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n-    ret alt cx.ccx().maps.root_map.find({id:e.id, derefs:0u}) {\n+    return alt cx.ccx().maps.root_map.find({id:e.id, derefs:0u}) {\n       // No need to root this lvalue.\n       none { unrooted(cx, e) }\n \n@@ -2632,13 +2633,13 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n         alt e.node {\n           ast::expr_path(_) {\n             let v = trans_path(cx, e.id);\n-            ret lval_maybe_callee_to_lval(v, e.span);\n+            return lval_maybe_callee_to_lval(v, e.span);\n           }\n           ast::expr_field(base, ident, _) {\n-            ret trans_rec_field(cx, base, ident);\n+            return trans_rec_field(cx, base, ident);\n           }\n           ast::expr_index(base, idx) {\n-            ret trans_index(cx, e, base, idx);\n+            return trans_index(cx, e, base, idx);\n           }\n           ast::expr_unary(ast::deref, base) {\n             let ccx = cx.ccx();\n@@ -2660,7 +2661,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n               }\n               ty::ty_ptr(_) | ty::ty_rptr(_,_) { sub.val }\n             };\n-            ret lval_owned(sub.bcx, val);\n+            return lval_owned(sub.bcx, val);\n           }\n           _ { cx.sess().span_bug(e.span, ~\"non-lval in trans_lval\"); }\n         }\n@@ -2703,7 +2704,7 @@ fn int_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n     let _icx = bcx.insn_ctxt(~\"int_cast\");\n     let srcsz = llvm::LLVMGetIntTypeWidth(llsrctype);\n     let dstsz = llvm::LLVMGetIntTypeWidth(lldsttype);\n-    ret if dstsz == srcsz {\n+    return if dstsz == srcsz {\n         BitCast(bcx, llsrc, lldsttype)\n     } else if srcsz > dstsz {\n         TruncOrBitCast(bcx, llsrc, lldsttype)\n@@ -2717,7 +2718,7 @@ fn float_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n     let _icx = bcx.insn_ctxt(~\"float_cast\");\n     let srcsz = lib::llvm::float_width(llsrctype);\n     let dstsz = lib::llvm::float_width(lldsttype);\n-    ret if dstsz > srcsz {\n+    return if dstsz > srcsz {\n         FPExt(bcx, llsrc, lldsttype)\n     } else if srcsz > dstsz {\n         FPTrunc(bcx, llsrc, lldsttype)\n@@ -2746,7 +2747,7 @@ fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n     let ccx = cx.ccx();\n     let t_out = node_id_type(cx, id);\n     alt ty::get(t_out).struct {\n-      ty::ty_trait(_, _) { ret impl::trans_cast(cx, e, id, dest); }\n+      ty::ty_trait(_, _) { return impl::trans_cast(cx, e, id, dest); }\n       _ {}\n     }\n     let e_res = trans_temp_expr(cx, e);\n@@ -2801,7 +2802,7 @@ fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n           }\n           _ { ccx.sess.bug(~\"translating unsupported cast.\") }\n         };\n-    ret store_in_dest(e_res.bcx, newval, dest);\n+    return store_in_dest(e_res.bcx, newval, dest);\n }\n \n fn trans_loop_body(bcx: block, e: @ast::expr, ret_flag: option<ValueRef>,\n@@ -2923,7 +2924,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n     }\n \n     debug!{\"--- trans_arg_expr passing %s\", val_str(bcx.ccx().tn, val)};\n-    ret rslt(bcx, val);\n+    return rslt(bcx, val);\n }\n \n // when invoking a method, an argument of type @T or ~T can be implicltly\n@@ -2939,15 +2940,15 @@ fn adapt_borrowed_value(lv: lval_result,\n                                          ty: ty::t} {\n     let bcx = lv.bcx;\n     if !expr_is_borrowed(bcx, e) {\n-        ret {lv:lv, ty:e_ty};\n+        return {lv:lv, ty:e_ty};\n     }\n \n     alt ty::get(e_ty).struct {\n       ty::ty_uniq(mt) | ty::ty_box(mt) {\n         let box_ptr = load_value_from_lval_result(lv, e_ty);\n         let body_ptr = GEPi(bcx, box_ptr, ~[0u, abi::box_field_body]);\n         let rptr_ty = ty::mk_rptr(bcx.tcx(), ty::re_static, mt);\n-        ret {lv: lval_temp(bcx, body_ptr), ty: rptr_ty};\n+        return {lv: lval_temp(bcx, body_ptr), ty: rptr_ty};\n       }\n \n       ty::ty_estr(_) | ty::ty_evec(_, _) {\n@@ -2977,7 +2978,7 @@ fn adapt_borrowed_value(lv: lval_result,\n                                    {ty: unit_ty, mutbl: ast::m_imm},\n                                    ty::vstore_slice(ty::re_static));\n \n-        ret {lv: lval_temp(bcx, p), ty: slice_ty};\n+        return {lv: lval_temp(bcx, p), ty: slice_ty};\n       }\n \n       _ {\n@@ -3056,7 +3057,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n         revoke_clean(bcx, c)\n     }\n \n-    ret {bcx: bcx,\n+    return {bcx: bcx,\n          args: llargs,\n          retslot: llretslot};\n }\n@@ -3180,31 +3181,31 @@ fn trans_call_inner(\n \n fn invoke(bcx: block, llfn: ValueRef, llargs: ~[ValueRef]) -> block {\n     let _icx = bcx.insn_ctxt(~\"invoke_\");\n-    if bcx.unreachable { ret bcx; }\n+    if bcx.unreachable { return bcx; }\n     if need_invoke(bcx) {\n         log(debug, ~\"invoking\");\n         let normal_bcx = sub_block(bcx, ~\"normal return\");\n         Invoke(bcx, llfn, llargs, normal_bcx.llbb, get_landing_pad(bcx));\n-        ret normal_bcx;\n+        return normal_bcx;\n     } else {\n         log(debug, ~\"calling\");\n         Call(bcx, llfn, llargs);\n-        ret bcx;\n+        return bcx;\n     }\n }\n \n fn need_invoke(bcx: block) -> bool {\n     if (bcx.ccx().sess.opts.debugging_opts & session::no_landing_pads != 0) {\n-        ret false;\n+        return false;\n     }\n \n     // Avoid using invoke if we are already inside a landing pad.\n     if bcx.is_lpad {\n-        ret false;\n+        return false;\n     }\n \n     if have_cached_lpad(bcx) {\n-        ret true;\n+        return true;\n     }\n \n     // Walk the scopes to look for cleanups\n@@ -3216,7 +3217,7 @@ fn need_invoke(bcx: block) -> bool {\n                 alt cleanup {\n                   clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) {\n                     if cleanup_type == normal_exit_and_unwind {\n-                        ret true;\n+                        return true;\n                     }\n                   }\n                 }\n@@ -3226,7 +3227,7 @@ fn need_invoke(bcx: block) -> bool {\n         }\n         cur = alt cur.parent {\n           some(next) { next }\n-          none { ret false; }\n+          none { return false; }\n         }\n     }\n }\n@@ -3239,7 +3240,7 @@ fn have_cached_lpad(bcx: block) -> bool {\n           none { res = false; }\n         }\n     }\n-    ret res;\n+    return res;\n }\n \n fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n@@ -3248,7 +3249,7 @@ fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n         alt bcx.kind {\n           block_scope(inf) {\n             if inf.cleanups.len() > 0u || is_none(bcx.parent) {\n-                f(inf); ret;\n+                f(inf); return;\n             }\n           }\n           _ {}\n@@ -3271,7 +3272,8 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n           }\n         }\n     }\n-    alt cached { some(b) { ret b; } none {} } // Can't return from block above\n+    // Can't return from block above\n+    alt cached { some(b) { return b; } none {} }\n     // The landing pad return type (the type being propagated). Not sure what\n     // this represents but it's determined by the personality function and\n     // this is what the EH proposal example uses.\n@@ -3303,7 +3305,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n \n     // Unwind all parent scopes, and finish with a Resume instr\n     cleanup_and_leave(pad_bcx, none, none);\n-    ret pad_bcx.llbb;\n+    return pad_bcx.llbb;\n }\n \n fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: dest) -> block {\n@@ -3312,7 +3314,7 @@ fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: dest) -> block {\n     let addr = alt dest {\n       ignore {\n         for vec::each(elts) |ex| { bcx = trans_expr(bcx, ex, ignore); }\n-        ret bcx;\n+        return bcx;\n       }\n       save_in(pos) { pos }\n       _ { bcx.tcx().sess.bug(~\"trans_tup: weird dest\"); }\n@@ -3326,7 +3328,7 @@ fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: dest) -> block {\n         vec::push(temp_cleanups, dst);\n     }\n     for vec::each(temp_cleanups) |cleanup| { revoke_clean(bcx, cleanup); }\n-    ret bcx;\n+    return bcx;\n }\n \n fn trans_rec(bcx: block, fields: ~[ast::field],\n@@ -3340,7 +3342,7 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n         for vec::each(fields) |fld| {\n             bcx = trans_expr(bcx, fld.node.expr, ignore);\n         }\n-        ret bcx;\n+        return bcx;\n       }\n       save_in(pos) { pos }\n     };\n@@ -3377,7 +3379,7 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n     // Now revoke the cleanups as we pass responsibility for the data\n     // structure on to the caller\n     for temp_cleanups.each |cleanup| { revoke_clean(bcx, cleanup); }\n-    ret bcx;\n+    return bcx;\n }\n \n fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n@@ -3399,7 +3401,7 @@ fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n                                            field.node.expr,\n                                            ignore);\n             }\n-            ret block_context;\n+            return block_context;\n         }\n         save_in(destination_address) => {\n             dest_address = destination_address;\n@@ -3470,7 +3472,7 @@ fn trans_expr_save_in(bcx: block, e: @ast::expr, dest: ValueRef)\n     -> block {\n     let t = expr_ty(bcx, e);\n     let do_ignore = ty::type_is_bot(t) || ty::type_is_nil(t);\n-    ret trans_expr(bcx, e, if do_ignore { ignore } else { save_in(dest) });\n+    return trans_expr(bcx, e, if do_ignore { ignore } else { save_in(dest) });\n }\n \n // Call this to compile an expression that you need as an intermediate value,\n@@ -3482,22 +3484,22 @@ fn trans_temp_lval(bcx: block, e: @ast::expr) -> lval_result {\n     let _icx = bcx.insn_ctxt(~\"trans_temp_lval\");\n     let mut bcx = bcx;\n     if expr_is_lval(bcx, e) {\n-        ret trans_lval(bcx, e);\n+        return trans_lval(bcx, e);\n     } else {\n         let ty = expr_ty(bcx, e);\n         if ty::type_is_nil(ty) || ty::type_is_bot(ty) {\n             bcx = trans_expr(bcx, e, ignore);\n-            ret {bcx: bcx, val: C_nil(), kind: lv_temporary};\n+            return {bcx: bcx, val: C_nil(), kind: lv_temporary};\n         } else if ty::type_is_immediate(ty) {\n             let cell = empty_dest_cell();\n             bcx = trans_expr(bcx, e, by_val(cell));\n             add_clean_temp(bcx, *cell, ty);\n-            ret {bcx: bcx, val: *cell, kind: lv_temporary};\n+            return {bcx: bcx, val: *cell, kind: lv_temporary};\n         } else {\n             let scratch = alloc_ty(bcx, ty);\n             let bcx = trans_expr_save_in(bcx, e, scratch);\n             add_clean_temp(bcx, scratch, ty);\n-            ret {bcx: bcx, val: scratch, kind: lv_temporary};\n+            return {bcx: bcx, val: scratch, kind: lv_temporary};\n         }\n     }\n }\n@@ -3546,7 +3548,7 @@ fn add_root_cleanup(bcx: block, scope_id: ast::node_id,\n         let mut bcx_sid = bcx;\n         loop {\n             bcx_sid = alt bcx_sid.node_info {\n-              some({id, _}) if id == scope_id { ret bcx_sid; }\n+              some({id, _}) if id == scope_id { return bcx_sid; }\n               _ {\n                 alt bcx_sid.parent {\n                   none {\n@@ -3570,10 +3572,10 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n     debuginfo::update_source_pos(bcx, e.span);\n \n     if expr_is_lval(bcx, e) {\n-        ret lval_to_dps(bcx, e, dest);\n+        return lval_to_dps(bcx, e, dest);\n     }\n \n-    ret alt bcx.ccx().maps.root_map.find({id:e.id, derefs:0u}) {\n+    return alt bcx.ccx().maps.root_map.find({id:e.id, derefs:0u}) {\n       none { unrooted(bcx, e, dest) }\n       some(scope_id) {\n         debug!{\"expression %d found in root map with scope %d\",\n@@ -3599,39 +3601,41 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n         let tcx = bcx.tcx();\n         alt e.node {\n           ast::expr_if(cond, thn, els) {\n-            ret trans_if(bcx, cond, thn, els, dest);\n+            return trans_if(bcx, cond, thn, els, dest);\n           }\n           ast::expr_alt(expr, arms, mode) {\n-            ret alt::trans_alt(bcx, e, expr, arms, mode, dest);\n+            return alt::trans_alt(bcx, e, expr, arms, mode, dest);\n           }\n           ast::expr_block(blk) {\n-            ret do with_scope(bcx, blk.info(), ~\"block-expr body\") |bcx| {\n+            return do with_scope(bcx, blk.info(), ~\"block-expr body\") |bcx| {\n                 trans_block(bcx, blk, dest)\n             };\n           }\n           ast::expr_rec(args, base) {\n-            ret trans_rec(bcx, args, base, e.id, dest);\n+            return trans_rec(bcx, args, base, e.id, dest);\n           }\n           ast::expr_struct(_, fields) {\n-            ret trans_struct(bcx, e.span, fields, e.id, dest);\n+            return trans_struct(bcx, e.span, fields, e.id, dest);\n           }\n-          ast::expr_tup(args) { ret trans_tup(bcx, args, dest); }\n-          ast::expr_vstore(e, v) { ret tvec::trans_vstore(bcx, e, v, dest); }\n-          ast::expr_lit(lit) { ret trans_lit(bcx, e, *lit, dest); }\n+          ast::expr_tup(args) { return trans_tup(bcx, args, dest); }\n+          ast::expr_vstore(e, v) {\n+            return tvec::trans_vstore(bcx, e, v, dest);\n+          }\n+          ast::expr_lit(lit) { return trans_lit(bcx, e, *lit, dest); }\n           ast::expr_vec(args, _) {\n-            ret tvec::trans_evec(bcx, args, ast::vstore_fixed(none),\n+            return tvec::trans_evec(bcx, args, ast::vstore_fixed(none),\n                                  e.id, dest);\n           }\n           ast::expr_binary(op, lhs, rhs) {\n-            ret trans_binary(bcx, op, lhs, rhs, dest, e);\n+            return trans_binary(bcx, op, lhs, rhs, dest, e);\n           }\n           ast::expr_unary(op, x) {\n             assert op != ast::deref; // lvals are handled above\n-            ret trans_unary(bcx, op, x, e, dest);\n+            return trans_unary(bcx, op, x, e, dest);\n           }\n-          ast::expr_addr_of(_, x) { ret trans_addr_of(bcx, x, dest); }\n+          ast::expr_addr_of(_, x) { return trans_addr_of(bcx, x, dest); }\n           ast::expr_fn(proto, decl, body, cap_clause) {\n-            ret closure::trans_expr_fn(bcx, proto, decl, body, e.id,\n+            return closure::trans_expr_fn(bcx, proto, decl, body, e.id,\n                                        cap_clause, none, dest);\n           }\n           ast::expr_fn_block(decl, body, cap_clause) {\n@@ -3640,41 +3644,41 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n                 debug!{\"translating fn_block %s with type %s\",\n                        expr_to_str(e),\n                        ppaux::ty_to_str(tcx, expr_ty(bcx, e))};\n-                ret closure::trans_expr_fn(bcx, proto, decl, body,\n+                return closure::trans_expr_fn(bcx, proto, decl, body,\n                                            e.id, cap_clause, none, dest);\n               }\n             }\n           }\n           ast::expr_loop_body(blk) {\n-            ret trans_loop_body(bcx, e, none, dest);\n+            return trans_loop_body(bcx, e, none, dest);\n           }\n           ast::expr_do_body(blk) {\n-            ret trans_expr(bcx, blk, dest);\n+            return trans_expr(bcx, blk, dest);\n           }\n           ast::expr_copy(a) | ast::expr_unary_move(a) {\n             if !expr_is_lval(bcx, a) {\n-                ret trans_expr(bcx, a, dest);\n+                return trans_expr(bcx, a, dest);\n             }\n-            else { ret lval_to_dps(bcx, a, dest); }\n+            else { return lval_to_dps(bcx, a, dest); }\n           }\n-          ast::expr_cast(val, _) { ret trans_cast(bcx, val, e.id, dest); }\n+          ast::expr_cast(val, _) { return trans_cast(bcx, val, e.id, dest); }\n           ast::expr_call(f, args, _) {\n-            ret trans_call(bcx, e, f, arg_exprs(args), e.id, dest);\n+            return trans_call(bcx, e, f, arg_exprs(args), e.id, dest);\n           }\n           ast::expr_field(base, _, _) {\n-            if dest == ignore { ret trans_expr(bcx, base, ignore); }\n+            if dest == ignore { return trans_expr(bcx, base, ignore); }\n             let callee = trans_callee(bcx, e), ty = expr_ty(bcx, e);\n             let lv = lval_maybe_callee_to_lval(callee, e.span);\n             revoke_clean(lv.bcx, lv.val);\n             memmove_ty(lv.bcx, get_dest_addr(dest), lv.val, ty);\n-            ret lv.bcx;\n+            return lv.bcx;\n           }\n           ast::expr_index(base, idx) {\n             // If it is here, it's not an lval, so this is a user-defined\n             // index op\n             let origin = bcx.ccx().maps.method_map.get(e.id);\n             let fty = node_id_type(bcx, e.callee_id);\n-            ret trans_call_inner(\n+            return trans_call_inner(\n                 bcx, e.info(), fty,\n                 expr_ty(bcx, e),\n                 |bcx| impl::trans_method_callee(bcx, e.callee_id, base,\n@@ -3685,35 +3689,35 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n           // These return nothing\n           ast::expr_break {\n             assert dest == ignore;\n-            ret trans_break(bcx);\n+            return trans_break(bcx);\n           }\n           ast::expr_again {\n             assert dest == ignore;\n-            ret trans_cont(bcx);\n+            return trans_cont(bcx);\n           }\n           ast::expr_ret(ex) {\n             assert dest == ignore;\n-            ret trans_ret(bcx, ex);\n+            return trans_ret(bcx, ex);\n           }\n           ast::expr_fail(expr) {\n             assert dest == ignore;\n-            ret trans_fail_expr(bcx, some(e.span), expr);\n+            return trans_fail_expr(bcx, some(e.span), expr);\n           }\n           ast::expr_log(_, lvl, a) {\n             assert dest == ignore;\n-            ret trans_log(e, lvl, bcx, a);\n+            return trans_log(e, lvl, bcx, a);\n           }\n           ast::expr_assert(a) {\n             assert dest == ignore;\n-            ret trans_check_expr(bcx, e, a, ~\"Assertion\");\n+            return trans_check_expr(bcx, e, a, ~\"Assertion\");\n           }\n           ast::expr_while(cond, body) {\n             assert dest == ignore;\n-            ret trans_while(bcx, cond, body);\n+            return trans_while(bcx, cond, body);\n           }\n           ast::expr_loop(body) {\n             assert dest == ignore;\n-            ret trans_loop(bcx, body);\n+            return trans_loop(bcx, body);\n           }\n           ast::expr_assign(dst, src) {\n             assert dest == ignore;\n@@ -3722,7 +3726,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             assert kind == lv_owned;\n             let is_last_use =\n                 bcx.ccx().maps.last_use_map.contains_key(src.id);\n-            ret store_temp_expr(bcx, DROP_EXISTING, addr, src_r,\n+            return store_temp_expr(bcx, DROP_EXISTING, addr, src_r,\n                                 expr_ty(bcx, src), is_last_use);\n           }\n           ast::expr_move(dst, src) {\n@@ -3731,7 +3735,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             let src_r = trans_temp_lval(bcx, src);\n             let {bcx, val: addr, kind} = trans_lval(src_r.bcx, dst);\n             assert kind == lv_owned;\n-            ret move_val(bcx, DROP_EXISTING, addr, src_r,\n+            return move_val(bcx, DROP_EXISTING, addr, src_r,\n                          expr_ty(bcx, src));\n           }\n           ast::expr_swap(dst, src) {\n@@ -3744,12 +3748,12 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             // Swap through a temporary.\n             let bcx = move_val(rhs_res.bcx, INIT, tmp_alloc, lhs_res, t);\n             let bcx = move_val(bcx, INIT, lhs_res.val, rhs_res, t);\n-            ret move_val(bcx, INIT, rhs_res.val,\n+            return move_val(bcx, INIT, rhs_res.val,\n                          lval_owned(bcx, tmp_alloc), t);\n           }\n           ast::expr_assign_op(op, dst, src) {\n             assert dest == ignore;\n-            ret trans_assign_op(bcx, e, op, dst, src);\n+            return trans_assign_op(bcx, e, op, dst, src);\n           }\n           ast::expr_new(pool, alloc_id, val) {\n             // First, call pool->alloc(tydesc) to get back a void*.\n@@ -3832,16 +3836,16 @@ fn lval_result_to_dps(lv: lval_result, ty: ty::t,\n       }\n       ignore {}\n     }\n-    ret bcx;\n+    return bcx;\n }\n \n fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_is_bot(t) {\n-        ret C_null(T_ptr(T_i8()));\n+        return C_null(T_ptr(T_i8()));\n     }\n     let llptr = alloc_ty(bcx, t);\n     Store(bcx, v, llptr);\n-    ret llptr;\n+    return llptr;\n }\n \n // Since this function does *not* root, it is the caller's responsibility to\n@@ -3852,27 +3856,27 @@ fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n fn do_spill_noroot(++cx: block, v: ValueRef) -> ValueRef {\n     let llptr = alloca(cx, val_ty(v));\n     Store(cx, v, llptr);\n-    ret llptr;\n+    return llptr;\n }\n \n fn spill_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = cx.insn_ctxt(~\"spill_if_immediate\");\n-    if ty::type_is_immediate(t) { ret do_spill(cx, v, t); }\n-    ret v;\n+    if ty::type_is_immediate(t) { return do_spill(cx, v, t); }\n+    return v;\n }\n \n fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = cx.insn_ctxt(~\"load_if_immediate\");\n-    if ty::type_is_immediate(t) { ret Load(cx, v); }\n-    ret v;\n+    if ty::type_is_immediate(t) { return Load(cx, v); }\n+    return v;\n }\n \n fn trans_log(log_ex: @ast::expr, lvl: @ast::expr,\n              bcx: block, e: @ast::expr) -> block {\n     let _icx = bcx.insn_ctxt(~\"trans_log\");\n     let ccx = bcx.ccx();\n     if ty::type_is_bot(expr_ty(bcx, lvl)) {\n-       ret trans_expr(bcx, lvl, ignore);\n+       return trans_expr(bcx, lvl, ignore);\n     }\n \n     let modpath = vec::append(\n@@ -3946,21 +3950,21 @@ fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n         if ty::type_is_str(e_ty) {\n             let body = tvec::get_bodyptr(bcx, expr_res.val);\n             let data = tvec::get_dataptr(bcx, body);\n-            ret trans_fail_value(bcx, sp_opt, data);\n+            return trans_fail_value(bcx, sp_opt, data);\n         } else if bcx.unreachable || ty::type_is_bot(e_ty) {\n-            ret bcx;\n+            return bcx;\n         } else {\n             bcx.sess().span_bug(\n                 expr.span, ~\"fail called with unsupported type \" +\n                 ppaux::ty_to_str(tcx, e_ty));\n         }\n       }\n-      _ { ret trans_fail(bcx, sp_opt, ~\"explicit failure\"); }\n+      _ { return trans_fail(bcx, sp_opt, ~\"explicit failure\"); }\n     }\n }\n \n fn trans_trace(bcx: block, sp_opt: option<span>, trace_str: ~str) {\n-    if !bcx.sess().trace() { ret; }\n+    if !bcx.sess().trace() { return; }\n     let _icx = bcx.insn_ctxt(~\"trans_trace\");\n     add_comment(bcx, trace_str);\n     let V_trace_str = C_cstr(bcx.ccx(), trace_str);\n@@ -3987,7 +3991,7 @@ fn trans_fail(bcx: block, sp_opt: option<span>, fail_str: ~str) ->\n     block {\n     let _icx = bcx.insn_ctxt(~\"trans_fail\");\n     let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n-    ret trans_fail_value(bcx, sp_opt, V_fail_str);\n+    return trans_fail_value(bcx, sp_opt, V_fail_str);\n }\n \n fn trans_fail_value(bcx: block, sp_opt: option<span>,\n@@ -4011,7 +4015,7 @@ fn trans_fail_value(bcx: block, sp_opt: option<span>,\n     let args = ~[V_str, V_filename, C_int(ccx, V_line)];\n     let bcx = trans_rtcall(bcx, ~\"fail\", args, ignore);\n     Unreachable(bcx);\n-    ret bcx;\n+    return bcx;\n }\n \n fn trans_rtcall(bcx: block, name: ~str, args: ~[ValueRef], dest: dest)\n@@ -4023,7 +4027,7 @@ fn trans_rtcall(bcx: block, name: ~str, args: ~[ValueRef], dest: dest)\n         csearch::get_type(bcx.ccx().tcx, did).ty\n     };\n     let rty = ty::ty_fn_ret(fty);\n-    ret trans_call_inner(\n+    return trans_call_inner(\n         bcx, none, fty, rty,\n         |bcx| lval_static_fn_inner(bcx, did, 0, ~[], none),\n         arg_vals(args), dest);\n@@ -4054,21 +4058,21 @@ fn trans_break_cont(bcx: block, to_end: bool)\n             Store(bcx, C_bool(!to_end), bcx.fcx.llretptr);\n             cleanup_and_leave(bcx, none, some(bcx.fcx.llreturn));\n             Unreachable(bcx);\n-            ret bcx;\n+            return bcx;\n           }\n         };\n     }\n     cleanup_and_Br(bcx, unwind, target.llbb);\n     Unreachable(bcx);\n-    ret bcx;\n+    return bcx;\n }\n \n fn trans_break(cx: block) -> block {\n-    ret trans_break_cont(cx, true);\n+    return trans_break_cont(cx, true);\n }\n \n fn trans_cont(cx: block) -> block {\n-    ret trans_break_cont(cx, false);\n+    return trans_break_cont(cx, false);\n }\n \n fn trans_ret(bcx: block, e: option<@ast::expr>) -> block {\n@@ -4097,7 +4101,7 @@ fn trans_ret(bcx: block, e: option<@ast::expr>) -> block {\n     }\n     cleanup_and_leave(bcx, none, some(bcx.fcx.llreturn));\n     Unreachable(bcx);\n-    ret bcx;\n+    return bcx;\n }\n \n fn build_return(bcx: block) {\n@@ -4130,7 +4134,7 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n     }\n     // Make a note to drop this slot on the way out.\n     add_clean(bcx, llptr, ty);\n-    ret alt::bind_irrefutable_pat(bcx, local.node.pat, llptr, false);\n+    return alt::bind_irrefutable_pat(bcx, local.node.pat, llptr, false);\n }\n \n fn trans_stmt(cx: block, s: ast::stmt) -> block {\n@@ -4163,7 +4167,7 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n       }\n     }\n \n-    ret bcx;\n+    return bcx;\n }\n \n // You probably don't want to use this one. See the\n@@ -4182,7 +4186,7 @@ fn new_block(cx: fn_ctxt, parent: option<block>, +kind: block_kind,\n     do option::iter(parent) |cx| {\n         if cx.unreachable { Unreachable(bcx); }\n     };\n-    ret bcx;\n+    return bcx;\n }\n \n fn simple_block_scope() -> block_kind {\n@@ -4192,20 +4196,20 @@ fn simple_block_scope() -> block_kind {\n \n // Use this when you're at the top block of a function or the like.\n fn top_scope_block(fcx: fn_ctxt, opt_node_info: option<node_info>) -> block {\n-    ret new_block(fcx, none, simple_block_scope(), false,\n+    return new_block(fcx, none, simple_block_scope(), false,\n                   ~\"function top level\", opt_node_info);\n }\n \n fn scope_block(bcx: block,\n                opt_node_info: option<node_info>,\n                n: ~str) -> block {\n-    ret new_block(bcx.fcx, some(bcx), simple_block_scope(), bcx.is_lpad,\n+    return new_block(bcx.fcx, some(bcx), simple_block_scope(), bcx.is_lpad,\n                   n, opt_node_info);\n }\n \n fn loop_scope_block(bcx: block, loop_break: block, n: ~str,\n                     opt_node_info: option<node_info>) -> block {\n-    ret new_block(bcx.fcx, some(bcx), block_scope({\n+    return new_block(bcx.fcx, some(bcx), block_scope({\n         loop_break: some(loop_break),\n         mut cleanups: ~[],\n         mut cleanup_paths: ~[],\n@@ -4242,7 +4246,7 @@ fn trans_block_cleanups(bcx: block, cleanup_cx: block) -> block {\n fn trans_block_cleanups_(bcx: block, cleanup_cx: block, is_lpad: bool) ->\n    block {\n     let _icx = bcx.insn_ctxt(~\"trans_block_cleanups\");\n-    if bcx.unreachable { ret bcx; }\n+    if bcx.unreachable { return bcx; }\n     let mut bcx = bcx;\n     alt check cleanup_cx.kind {\n       block_scope({cleanups, _}) {\n@@ -4260,7 +4264,7 @@ fn trans_block_cleanups_(bcx: block, cleanup_cx: block, is_lpad: bool) ->\n         }\n       }\n     }\n-    ret bcx;\n+    return bcx;\n }\n \n // In the last argument, some(block) mean jump to this block, and none means\n@@ -4285,7 +4289,7 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n             for vec::find(inf.cleanup_paths,\n                           |cp| cp.target == leave).each |cp| {\n                 Br(bcx, cp.dest);\n-                ret;\n+                return;\n             }\n             let sub_cx = sub_block(bcx, ~\"cleanup\");\n             Br(bcx, sub_cx.llbb);\n@@ -4373,7 +4377,7 @@ fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n     if ty::type_has_params(t) { log(error, ppaux::ty_to_str(ccx.tcx, t)); }\n     assert !ty::type_has_params(t);\n     let val = alloca(bcx, llty);\n-    ret val;\n+    return val;\n }\n \n fn alloc_local(cx: block, local: @ast::local) -> block {\n@@ -4392,7 +4396,7 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n         }\n     }\n     cx.fcx.lllocals.insert(local.node.id, local_mem(val));\n-    ret cx;\n+    return cx;\n }\n \n fn trans_block(bcx: block, b: ast::blk, dest: dest)\n@@ -4412,7 +4416,7 @@ fn trans_block(bcx: block, b: ast::blk, dest: dest)\n       }\n       _ { assert dest == ignore || bcx.unreachable; }\n     }\n-    ret bcx;\n+    return bcx;\n }\n \n // Creates the standard set of basic blocks for a function\n@@ -4438,7 +4442,7 @@ fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n                     param_substs: option<param_substs>,\n                     sp: option<span>) -> fn_ctxt {\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n-    ret @{llfn: llfndecl,\n+    return @{llfn: llfndecl,\n           llenv: llvm::LLVMGetParam(llfndecl, 1u as c_uint),\n           llretptr: llvm::LLVMGetParam(llfndecl, 0u as c_uint),\n           mut llstaticallocas: llbbs.sa,\n@@ -4459,7 +4463,7 @@ fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n \n fn new_fn_ctxt(ccx: @crate_ctxt, path: path, llfndecl: ValueRef,\n                sp: option<span>) -> fn_ctxt {\n-    ret new_fn_ctxt_w_id(ccx, path, llfndecl, -1, none, sp);\n+    return new_fn_ctxt_w_id(ccx, path, llfndecl, -1, none, sp);\n }\n \n // NB: must keep 4 fns in sync:\n@@ -4534,7 +4538,7 @@ fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: ~[ast::arg],\n         }\n         arg_n += 1u;\n     }\n-    ret bcx;\n+    return bcx;\n }\n \n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n@@ -4886,7 +4890,7 @@ fn trans_mod(ccx: @crate_ctxt, m: ast::_mod) {\n \n fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the pair.\n-    ret struct_elt(llpairty, 0u);\n+    return struct_elt(llpairty, 0u);\n }\n \n fn register_fn(ccx: @crate_ctxt, sp: span, path: path,\n@@ -4965,14 +4969,14 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n \n         finish_fn(fcx, lltop);\n \n-        ret llfdecl;\n+        return llfdecl;\n     }\n \n     fn create_entry_fn(ccx: @crate_ctxt, rust_main: ValueRef) {\n         #[cfg(windows)]\n-        fn main_name() -> ~str { ret ~\"WinMain@16\"; }\n+        fn main_name() -> ~str { return ~\"WinMain@16\"; }\n         #[cfg(unix)]\n-        fn main_name() -> ~str { ret ~\"main\"; }\n+        fn main_name() -> ~str { return ~\"main\"; }\n         let llfty = T_fn(~[ccx.int_type, ccx.int_type], ccx.int_type);\n         let llfn = decl_cdecl_fn(ccx.llmod, main_name(), llfty);\n         let llbb = str::as_c_str(~\"top\", |buf| {\n@@ -5002,7 +5006,7 @@ fn create_real_fn_pair(cx: block, llfnty: TypeRef, llfn: ValueRef,\n                        llenvptr: ValueRef) -> ValueRef {\n     let pair = alloca(cx, T_fn_pair(cx.ccx(), llfnty));\n     fill_fn_pair(cx, pair, llfn, llenvptr);\n-    ret pair;\n+    return pair;\n }\n \n fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n@@ -5191,11 +5195,11 @@ fn trans_constants(ccx: @crate_ctxt, crate: @ast::crate) {\n \n fn vp2i(cx: block, v: ValueRef) -> ValueRef {\n     let ccx = cx.ccx();\n-    ret PtrToInt(cx, v, ccx.int_type);\n+    return PtrToInt(cx, v, ccx.int_type);\n }\n \n fn p2i(ccx: @crate_ctxt, v: ValueRef) -> ValueRef {\n-    ret llvm::LLVMConstPtrToInt(v, ccx.int_type);\n+    return llvm::LLVMConstPtrToInt(v, ccx.int_type);\n }\n \n fn declare_intrinsics(llmod: ModuleRef) -> hashmap<~str, ValueRef> {\n@@ -5243,7 +5247,7 @@ fn declare_intrinsics(llmod: ModuleRef) -> hashmap<~str, ValueRef> {\n     intrinsics.insert(~\"llvm.memset.p0i8.i64\", memset64);\n     intrinsics.insert(~\"llvm.trap\", trap);\n     intrinsics.insert(~\"llvm.frameaddress\", frameaddress);\n-    ret intrinsics;\n+    return intrinsics;\n }\n \n fn declare_dbg_intrinsics(llmod: ModuleRef,\n@@ -5360,7 +5364,7 @@ fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n     let term = C_struct(~[C_int(ccx, 0), C_int(ccx, 0)]);\n     vec::push(elts, term);\n     llvm::LLVMSetInitializer(map, C_array(elttype, elts));\n-    ret map;\n+    return map;\n }\n \n \n@@ -5381,7 +5385,7 @@ fn decl_crate_map(sess: session::session, mapmeta: link_meta,\n         llvm::LLVMAddGlobal(llmod, maptype, buf)\n     });\n     lib::llvm::SetLinkage(map, lib::llvm::ExternalLinkage);\n-    ret map;\n+    return map;\n }\n \n fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n@@ -5411,7 +5415,7 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n     let encode_inlined_item =\n         |a,b,c,d| astencode::encode_inlined_item(a, b, c, d, cx.maps);\n \n-    ret {\n+    return {\n         diag: cx.sess.diagnostic(),\n         tcx: cx.tcx,\n         reachable: cx.reachable,\n@@ -5437,7 +5441,7 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n                 vec::push(reexports, (path, def.id));\n             }\n         }\n-        ret reexports;\n+        return reexports;\n     }\n \n     fn impl_map(cx: @crate_ctxt,\n@@ -5446,12 +5450,12 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n         for list::each(cx.maps.impl_map.get(id)) |impls| {\n             vec::push_all(result, (*impls).map(|i| (i.ident, i.did)));\n         }\n-        ret result;\n+        return result;\n     }\n }\n \n fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n-    if !cx.sess.building_library { ret; }\n+    if !cx.sess.building_library { return; }\n     let encode_parms = crate_ctxt_to_encode_parms(cx);\n     let llmeta = C_bytes(encoder::encode_metadata(encode_parms, crate));\n     let llconst = C_struct(~[llmeta]);\n@@ -5631,7 +5635,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n             io::println(fmt!{\"%-7u %s\", v, k});\n         }\n     }\n-    ret (llmod, link_meta);\n+    return (llmod, link_meta);\n }\n //\n // Local Variables:"}, {"sha": "d664d11d1e4d5073ae906498f14ac84076d4063a", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 176, "deletions": 175, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -12,7 +12,7 @@ import driver::session::session;\n fn B(cx: block) -> BuilderRef {\n     let b = cx.fcx.ccx.builder.B;\n     llvm::LLVMPositionBuilderAtEnd(b, cx.llbb);\n-    ret b;\n+    return b;\n }\n \n fn count_insn(cx: block, category: ~str) {\n@@ -60,27 +60,27 @@ fn count_insn(cx: block, category: ~str) {\n // terminated, we're saying that trying to add any further statements in the\n // block is an error. On the other hand, if something is unreachable, that\n // means that the block was terminated in some way that we don't want to check\n-// for (fail/break/ret statements, call to diverging functions, etc), and\n+// for (fail/break/return statements, call to diverging functions, etc), and\n // further instructions to the block should simply be ignored.\n \n fn RetVoid(cx: block) {\n-    if cx.unreachable { ret; }\n+    if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n     count_insn(cx, ~\"retvoid\");\n     llvm::LLVMBuildRetVoid(B(cx));\n }\n \n fn Ret(cx: block, V: ValueRef) {\n-    if cx.unreachable { ret; }\n+    if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n     count_insn(cx, ~\"ret\");\n     llvm::LLVMBuildRet(B(cx), V);\n }\n \n fn AggregateRet(cx: block, RetVals: ~[ValueRef]) {\n-    if cx.unreachable { ret; }\n+    if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n     unsafe {\n@@ -90,7 +90,7 @@ fn AggregateRet(cx: block, RetVals: ~[ValueRef]) {\n }\n \n fn Br(cx: block, Dest: BasicBlockRef) {\n-    if cx.unreachable { ret; }\n+    if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n     count_insn(cx, ~\"br\");\n@@ -99,7 +99,7 @@ fn Br(cx: block, Dest: BasicBlockRef) {\n \n fn CondBr(cx: block, If: ValueRef, Then: BasicBlockRef,\n           Else: BasicBlockRef) {\n-    if cx.unreachable { ret; }\n+    if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n     count_insn(cx, ~\"condbr\");\n@@ -108,19 +108,19 @@ fn CondBr(cx: block, If: ValueRef, Then: BasicBlockRef,\n \n fn Switch(cx: block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n     -> ValueRef {\n-    if cx.unreachable { ret _Undef(V); }\n+    if cx.unreachable { return _Undef(V); }\n     assert !cx.terminated;\n     cx.terminated = true;\n-    ret llvm::LLVMBuildSwitch(B(cx), V, Else, NumCases as c_uint);\n+    return llvm::LLVMBuildSwitch(B(cx), V, Else, NumCases as c_uint);\n }\n \n fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n-    if llvm::LLVMIsUndef(S) == lib::llvm::True { ret; }\n+    if llvm::LLVMIsUndef(S) == lib::llvm::True { return; }\n     llvm::LLVMAddCase(S, OnVal, Dest);\n }\n \n fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n-    if cx.unreachable { ret; }\n+    if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n     count_insn(cx, ~\"indirectbr\");\n@@ -131,12 +131,12 @@ fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n // lot more efficient) than doing str::as_c_str(\"\", ...) every time.\n fn noname() -> *libc::c_char unsafe {\n     const cnull: uint = 0u;\n-    ret unsafe::reinterpret_cast(ptr::addr_of(cnull));\n+    return unsafe::reinterpret_cast(ptr::addr_of(cnull));\n }\n \n fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n           Then: BasicBlockRef, Catch: BasicBlockRef) {\n-    if cx.unreachable { ret; }\n+    if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n     debug!{\"Invoke(%s with arguments (%s))\",\n@@ -153,7 +153,7 @@ fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n \n fn FastInvoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n               Then: BasicBlockRef, Catch: BasicBlockRef) {\n-    if cx.unreachable { ret; }\n+    if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n     unsafe {\n@@ -166,7 +166,7 @@ fn FastInvoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n }\n \n fn Unreachable(cx: block) {\n-    if cx.unreachable { ret; }\n+    if cx.unreachable { return; }\n     cx.unreachable = true;\n     if !cx.terminated {\n         count_insn(cx, ~\"unreachable\");\n@@ -175,223 +175,223 @@ fn Unreachable(cx: block) {\n }\n \n fn _Undef(val: ValueRef) -> ValueRef {\n-    ret llvm::LLVMGetUndef(val_ty(val));\n+    return llvm::LLVMGetUndef(val_ty(val));\n }\n \n /* Arithmetic */\n fn Add(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"add\");\n-    ret llvm::LLVMBuildAdd(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildAdd(B(cx), LHS, RHS, noname());\n }\n \n fn NSWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"nswadd\");\n-    ret llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, noname());\n }\n \n fn NUWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"nuwadd\");\n-    ret llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, noname());\n }\n \n fn FAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"fadd\");\n-    ret llvm::LLVMBuildFAdd(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildFAdd(B(cx), LHS, RHS, noname());\n }\n \n fn Sub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"sub\");\n-    ret llvm::LLVMBuildSub(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildSub(B(cx), LHS, RHS, noname());\n }\n \n fn NSWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"nwsub\");\n-    ret llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, noname());\n }\n \n fn NUWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"nuwsub\");\n-    ret llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, noname());\n }\n \n fn FSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"sub\");\n-    ret llvm::LLVMBuildFSub(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildFSub(B(cx), LHS, RHS, noname());\n }\n \n fn Mul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"mul\");\n-    ret llvm::LLVMBuildMul(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildMul(B(cx), LHS, RHS, noname());\n }\n \n fn NSWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"nswmul\");\n-    ret llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, noname());\n }\n \n fn NUWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"nuwmul\");\n-    ret llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, noname());\n }\n \n fn FMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"fmul\");\n-    ret llvm::LLVMBuildFMul(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildFMul(B(cx), LHS, RHS, noname());\n }\n \n fn UDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"udiv\");\n-    ret llvm::LLVMBuildUDiv(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildUDiv(B(cx), LHS, RHS, noname());\n }\n \n fn SDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"sdiv\");\n-    ret llvm::LLVMBuildSDiv(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildSDiv(B(cx), LHS, RHS, noname());\n }\n \n fn ExactSDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"extractsdiv\");\n-    ret llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, noname());\n }\n \n fn FDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"fdiv\");\n-    ret llvm::LLVMBuildFDiv(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildFDiv(B(cx), LHS, RHS, noname());\n }\n \n fn URem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"urem\");\n-    ret llvm::LLVMBuildURem(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildURem(B(cx), LHS, RHS, noname());\n }\n \n fn SRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"srem\");\n-    ret llvm::LLVMBuildSRem(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildSRem(B(cx), LHS, RHS, noname());\n }\n \n fn FRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"frem\");\n-    ret llvm::LLVMBuildFRem(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildFRem(B(cx), LHS, RHS, noname());\n }\n \n fn Shl(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"shl\");\n-    ret llvm::LLVMBuildShl(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildShl(B(cx), LHS, RHS, noname());\n }\n \n fn LShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"lshr\");\n-    ret llvm::LLVMBuildLShr(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildLShr(B(cx), LHS, RHS, noname());\n }\n \n fn AShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"ashr\");\n-    ret llvm::LLVMBuildAShr(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildAShr(B(cx), LHS, RHS, noname());\n }\n \n fn And(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"and\");\n-    ret llvm::LLVMBuildAnd(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildAnd(B(cx), LHS, RHS, noname());\n }\n \n fn Or(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"or\");\n-    ret llvm::LLVMBuildOr(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildOr(B(cx), LHS, RHS, noname());\n }\n \n fn Xor(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"xor\");\n-    ret llvm::LLVMBuildXor(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildXor(B(cx), LHS, RHS, noname());\n }\n \n fn BinOp(cx: block, Op: Opcode, LHS: ValueRef, RHS: ValueRef) ->\n    ValueRef {\n-    if cx.unreachable { ret _Undef(LHS); }\n+    if cx.unreachable { return _Undef(LHS); }\n     count_insn(cx, ~\"binop\");\n-    ret llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, noname());\n+    return llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, noname());\n }\n \n fn Neg(cx: block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(V); }\n+    if cx.unreachable { return _Undef(V); }\n     count_insn(cx, ~\"neg\");\n-    ret llvm::LLVMBuildNeg(B(cx), V, noname());\n+    return llvm::LLVMBuildNeg(B(cx), V, noname());\n }\n \n fn NSWNeg(cx: block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(V); }\n+    if cx.unreachable { return _Undef(V); }\n     count_insn(cx, ~\"nswneg\");\n-    ret llvm::LLVMBuildNSWNeg(B(cx), V, noname());\n+    return llvm::LLVMBuildNSWNeg(B(cx), V, noname());\n }\n \n fn NUWNeg(cx: block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(V); }\n+    if cx.unreachable { return _Undef(V); }\n     count_insn(cx, ~\"nuwneg\");\n-    ret llvm::LLVMBuildNUWNeg(B(cx), V, noname());\n+    return llvm::LLVMBuildNUWNeg(B(cx), V, noname());\n }\n fn FNeg(cx: block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(V); }\n+    if cx.unreachable { return _Undef(V); }\n     count_insn(cx, ~\"fneg\");\n-    ret llvm::LLVMBuildFNeg(B(cx), V, noname());\n+    return llvm::LLVMBuildFNeg(B(cx), V, noname());\n }\n \n fn Not(cx: block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret _Undef(V); }\n+    if cx.unreachable { return _Undef(V); }\n     count_insn(cx, ~\"not\");\n-    ret llvm::LLVMBuildNot(B(cx), V, noname());\n+    return llvm::LLVMBuildNot(B(cx), V, noname());\n }\n \n /* Memory */\n fn Malloc(cx: block, Ty: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n     count_insn(cx, ~\"malloc\");\n-    ret llvm::LLVMBuildMalloc(B(cx), Ty, noname());\n+    return llvm::LLVMBuildMalloc(B(cx), Ty, noname());\n }\n \n fn ArrayMalloc(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n     count_insn(cx, ~\"arraymalloc\");\n-    ret llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, noname());\n+    return llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, noname());\n }\n \n fn Alloca(cx: block, Ty: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(Ty)); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(Ty)); }\n     count_insn(cx, ~\"alloca\");\n-    ret llvm::LLVMBuildAlloca(B(cx), Ty, noname());\n+    return llvm::LLVMBuildAlloca(B(cx), Ty, noname());\n }\n \n fn ArrayAlloca(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(Ty)); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(Ty)); }\n     count_insn(cx, ~\"arrayalloca\");\n-    ret llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, noname());\n+    return llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, noname());\n }\n \n fn Free(cx: block, PointerVal: ValueRef) {\n-    if cx.unreachable { ret; }\n+    if cx.unreachable { return; }\n     count_insn(cx, ~\"free\");\n     llvm::LLVMBuildFree(B(cx), PointerVal);\n }\n@@ -402,14 +402,14 @@ fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n         let ty = val_ty(PointerVal);\n         let eltty = if llvm::LLVMGetTypeKind(ty) == lib::llvm::Array {\n             llvm::LLVMGetElementType(ty) } else { ccx.int_type };\n-        ret llvm::LLVMGetUndef(eltty);\n+        return llvm::LLVMGetUndef(eltty);\n     }\n     count_insn(cx, ~\"load\");\n-    ret llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n+    return llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n }\n \n fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n-    if cx.unreachable { ret; }\n+    if cx.unreachable { return; }\n     debug!{\"Store %s -> %s\",\n            val_str(cx.ccx().tn, Val),\n            val_str(cx.ccx().tn, Ptr)};\n@@ -418,10 +418,10 @@ fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n }\n \n fn GEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n     count_insn(cx, ~\"gep\");\n-    ret llvm::LLVMBuildGEP(B(cx), Pointer, vec::unsafe::to_ptr(Indices),\n+    return llvm::LLVMBuildGEP(B(cx), Pointer, vec::unsafe::to_ptr(Indices),\n                                Indices.len() as c_uint, noname());\n     }\n }\n@@ -432,197 +432,197 @@ fn GEPi(cx: block, base: ValueRef, ixs: ~[uint]) -> ValueRef {\n     let mut v: ~[ValueRef] = ~[];\n     for vec::each(ixs) |i| { vec::push(v, C_i32(i as i32)); }\n     count_insn(cx, ~\"gepi\");\n-    ret InBoundsGEP(cx, base, v);\n+    return InBoundsGEP(cx, base, v);\n }\n \n fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) ->\n    ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n         count_insn(cx, ~\"inboundsgep\");\n-    ret llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n+    return llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n                                        vec::unsafe::to_ptr(Indices),\n                                        Indices.len() as c_uint,\n                                        noname());\n     }\n }\n \n fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     count_insn(cx, ~\"structgep\");\n-    ret llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx as c_uint, noname());\n+    return llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx as c_uint, noname());\n }\n \n fn GlobalString(cx: block, _Str: *libc::c_char) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n     count_insn(cx, ~\"globalstring\");\n-    ret llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n+    return llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n }\n \n fn GlobalStringPtr(cx: block, _Str: *libc::c_char) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n     count_insn(cx, ~\"globalstringptr\");\n-    ret llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n+    return llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n }\n \n /* Casts */\n fn Trunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"trunc\");\n-    ret llvm::LLVMBuildTrunc(B(cx), Val, DestTy, noname());\n+    return llvm::LLVMBuildTrunc(B(cx), Val, DestTy, noname());\n }\n \n fn ZExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"zext\");\n-    ret llvm::LLVMBuildZExt(B(cx), Val, DestTy, noname());\n+    return llvm::LLVMBuildZExt(B(cx), Val, DestTy, noname());\n }\n \n fn SExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"sext\");\n-    ret llvm::LLVMBuildSExt(B(cx), Val, DestTy, noname());\n+    return llvm::LLVMBuildSExt(B(cx), Val, DestTy, noname());\n }\n \n fn FPToUI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"fptoui\");\n-    ret llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, noname());\n+    return llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, noname());\n }\n \n fn FPToSI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"fptosi\");\n-    ret llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, noname());\n+    return llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, noname());\n }\n \n fn UIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"uitofp\");\n-    ret llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, noname());\n+    return llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, noname());\n }\n \n fn SIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"sitofp\");\n-    ret llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, noname());\n+    return llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, noname());\n }\n \n fn FPTrunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"fptrunc\");\n-    ret llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, noname());\n+    return llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, noname());\n }\n \n fn FPExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"fpext\");\n-    ret llvm::LLVMBuildFPExt(B(cx), Val, DestTy, noname());\n+    return llvm::LLVMBuildFPExt(B(cx), Val, DestTy, noname());\n }\n \n fn PtrToInt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"ptrtoint\");\n-    ret llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, noname());\n+    return llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, noname());\n }\n \n fn IntToPtr(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"inttoptr\");\n-    ret llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, noname());\n+    return llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, noname());\n }\n \n fn BitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"bitcast\");\n-    ret llvm::LLVMBuildBitCast(B(cx), Val, DestTy, noname());\n+    return llvm::LLVMBuildBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn ZExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"zextorbitcast\");\n-    ret llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, noname());\n+    return llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn SExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"sextorbitcast\");\n-    ret llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, noname());\n+    return llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn TruncOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"truncorbitcast\");\n-    ret llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, noname());\n+    return llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn Cast(cx: block, Op: Opcode, Val: ValueRef, DestTy: TypeRef,\n         _Name: *u8) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"cast\");\n-    ret llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, noname());\n+    return llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, noname());\n }\n \n fn PointerCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"pointercast\");\n-    ret llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, noname());\n+    return llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, noname());\n }\n \n fn IntCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"intcast\");\n-    ret llvm::LLVMBuildIntCast(B(cx), Val, DestTy, noname());\n+    return llvm::LLVMBuildIntCast(B(cx), Val, DestTy, noname());\n }\n \n fn FPCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n     count_insn(cx, ~\"fpcast\");\n-    ret llvm::LLVMBuildFPCast(B(cx), Val, DestTy, noname());\n+    return llvm::LLVMBuildFPCast(B(cx), Val, DestTy, noname());\n }\n \n \n /* Comparisons */\n fn ICmp(cx: block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n     -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n     count_insn(cx, ~\"icmp\");\n-    ret llvm::LLVMBuildICmp(B(cx), Op as c_uint, LHS, RHS, noname());\n+    return llvm::LLVMBuildICmp(B(cx), Op as c_uint, LHS, RHS, noname());\n }\n \n fn FCmp(cx: block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n     -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n     count_insn(cx, ~\"fcmp\");\n-    ret llvm::LLVMBuildFCmp(B(cx), Op as c_uint, LHS, RHS, noname());\n+    return llvm::LLVMBuildFCmp(B(cx), Op as c_uint, LHS, RHS, noname());\n }\n \n /* Miscellaneous instructions */\n fn EmptyPhi(cx: block, Ty: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n     count_insn(cx, ~\"emptyphi\");\n-    ret llvm::LLVMBuildPhi(B(cx), Ty, noname());\n+    return llvm::LLVMBuildPhi(B(cx), Ty, noname());\n }\n \n fn Phi(cx: block, Ty: TypeRef, vals: ~[ValueRef], bbs: ~[BasicBlockRef])\n    -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n     assert vals.len() == bbs.len();\n     let phi = EmptyPhi(cx, Ty);\n     unsafe {\n         count_insn(cx, ~\"addincoming\");\n         llvm::LLVMAddIncoming(phi, vec::unsafe::to_ptr(vals),\n                               vec::unsafe::to_ptr(bbs),\n                               vals.len() as c_uint);\n-        ret phi;\n+        return phi;\n     }\n }\n \n fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n-    if llvm::LLVMIsUndef(phi) == lib::llvm::True { ret; }\n+    if llvm::LLVMIsUndef(phi) == lib::llvm::True { return; }\n     unsafe {\n         let valptr = unsafe::reinterpret_cast(ptr::addr_of(val));\n         let bbptr = unsafe::reinterpret_cast(ptr::addr_of(bb));\n@@ -636,7 +636,7 @@ fn _UndefReturn(cx: block, Fn: ValueRef) -> ValueRef {\n     let retty = if llvm::LLVMGetTypeKind(ty) == lib::llvm::Integer {\n         llvm::LLVMGetReturnType(ty) } else { ccx.int_type };\n         count_insn(cx, ~\"\");\n-    ret llvm::LLVMGetUndef(retty);\n+    return llvm::LLVMGetUndef(retty);\n }\n \n fn add_span_comment(bcx: block, sp: span, text: ~str) {\n@@ -666,111 +666,112 @@ fn add_comment(bcx: block, text: ~str) {\n }\n \n fn Call(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n-    if cx.unreachable { ret _UndefReturn(cx, Fn); }\n+    if cx.unreachable { return _UndefReturn(cx, Fn); }\n     unsafe {\n         count_insn(cx, ~\"call\");\n \n         debug!{\"Call(Fn=%s, Args=%?)\",\n                val_str(cx.ccx().tn, Fn),\n                Args.map(|arg| val_str(cx.ccx().tn, arg))};\n \n-        ret llvm::LLVMBuildCall(B(cx), Fn, vec::unsafe::to_ptr(Args),\n+        return llvm::LLVMBuildCall(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                                 Args.len() as c_uint, noname());\n     }\n }\n \n fn FastCall(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n-    if cx.unreachable { ret _UndefReturn(cx, Fn); }\n+    if cx.unreachable { return _UndefReturn(cx, Fn); }\n     unsafe {\n         count_insn(cx, ~\"fastcall\");\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                                     Args.len() as c_uint, noname());\n         lib::llvm::SetInstructionCallConv(v, lib::llvm::FastCallConv);\n-        ret v;\n+        return v;\n     }\n }\n \n fn CallWithConv(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n                 Conv: CallConv) -> ValueRef {\n-    if cx.unreachable { ret _UndefReturn(cx, Fn); }\n+    if cx.unreachable { return _UndefReturn(cx, Fn); }\n     unsafe {\n         count_insn(cx, ~\"callwithconv\");\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                                     Args.len() as c_uint, noname());\n         lib::llvm::SetInstructionCallConv(v, Conv);\n-        ret v;\n+        return v;\n     }\n }\n \n fn Select(cx: block, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n    ValueRef {\n-    if cx.unreachable { ret _Undef(Then); }\n+    if cx.unreachable { return _Undef(Then); }\n     count_insn(cx, ~\"select\");\n-    ret llvm::LLVMBuildSelect(B(cx), If, Then, Else, noname());\n+    return llvm::LLVMBuildSelect(B(cx), If, Then, Else, noname());\n }\n \n fn VAArg(cx: block, list: ValueRef, Ty: TypeRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n     count_insn(cx, ~\"vaarg\");\n-    ret llvm::LLVMBuildVAArg(B(cx), list, Ty, noname());\n+    return llvm::LLVMBuildVAArg(B(cx), list, Ty, noname());\n }\n \n fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) ->\n    ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(T_nil()); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n     count_insn(cx, ~\"extractelement\");\n-    ret llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, noname());\n+    return llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, noname());\n }\n \n fn InsertElement(cx: block, VecVal: ValueRef, EltVal: ValueRef,\n                  Index: ValueRef) {\n-    if cx.unreachable { ret; }\n+    if cx.unreachable { return; }\n     count_insn(cx, ~\"insertelement\");\n     llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, noname());\n }\n \n fn ShuffleVector(cx: block, V1: ValueRef, V2: ValueRef,\n                  Mask: ValueRef) {\n-    if cx.unreachable { ret; }\n+    if cx.unreachable { return; }\n     count_insn(cx, ~\"shufflevector\");\n     llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname());\n }\n \n fn ExtractValue(cx: block, AggVal: ValueRef, Index: uint) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(T_nil()); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n     count_insn(cx, ~\"extractvalue\");\n-    ret llvm::LLVMBuildExtractValue(B(cx), AggVal, Index as c_uint, noname());\n+    return llvm::LLVMBuildExtractValue(\n+        B(cx), AggVal, Index as c_uint, noname());\n }\n \n fn InsertValue(cx: block, AggVal: ValueRef, EltVal: ValueRef,\n                Index: uint) {\n-    if cx.unreachable { ret; }\n+    if cx.unreachable { return; }\n     count_insn(cx, ~\"insertvalue\");\n     llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index as c_uint,\n                                noname());\n }\n \n fn IsNull(cx: block, Val: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n     count_insn(cx, ~\"isnull\");\n-    ret llvm::LLVMBuildIsNull(B(cx), Val, noname());\n+    return llvm::LLVMBuildIsNull(B(cx), Val, noname());\n }\n \n fn IsNotNull(cx: block, Val: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n     count_insn(cx, ~\"isnotnull\");\n-    ret llvm::LLVMBuildIsNotNull(B(cx), Val, noname());\n+    return llvm::LLVMBuildIsNotNull(B(cx), Val, noname());\n }\n \n fn PtrDiff(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let ccx = cx.fcx.ccx;\n-    if cx.unreachable { ret llvm::LLVMGetUndef(ccx.int_type); }\n+    if cx.unreachable { return llvm::LLVMGetUndef(ccx.int_type); }\n     count_insn(cx, ~\"ptrdiff\");\n-    ret llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n+    return llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n }\n \n fn Trap(cx: block) {\n-    if cx.unreachable { ret; }\n+    if cx.unreachable { return; }\n     let b = B(cx);\n     let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(b);\n     let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n@@ -791,7 +792,7 @@ fn LandingPad(cx: block, Ty: TypeRef, PersFn: ValueRef,\n               NumClauses: uint) -> ValueRef {\n     assert !cx.terminated && !cx.unreachable;\n     count_insn(cx, ~\"landingpad\");\n-    ret llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn,\n+    return llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn,\n                                   NumClauses as c_uint, noname());\n }\n \n@@ -804,7 +805,7 @@ fn Resume(cx: block, Exn: ValueRef) -> ValueRef {\n     assert (!cx.terminated);\n     cx.terminated = true;\n     count_insn(cx, ~\"resume\");\n-    ret llvm::LLVMBuildResume(B(cx), Exn);\n+    return llvm::LLVMBuildResume(B(cx), Exn);\n }\n \n // Atomic Operations"}, {"sha": "804ee5ba83c135d99f83685ba7ac16b8b7376b72", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -113,7 +113,7 @@ fn ev_to_str(ccx: @crate_ctxt, ev: environment_value) -> ~str {\n \n fn mk_tuplified_uniq_cbox_ty(tcx: ty::ctxt, cdata_ty: ty::t) -> ty::t {\n     let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n-    ret ty::mk_imm_uniq(tcx, cbox_ty);\n+    return ty::mk_imm_uniq(tcx, cbox_ty);\n }\n \n // Given a closure ty, emits a corresponding tuple ty\n@@ -132,7 +132,7 @@ fn mk_closure_tys(tcx: ty::ctxt,\n     }\n     let cdata_ty = ty::mk_tup(tcx, bound_tys);\n     debug!{\"cdata_ty=%s\", ty_to_str(tcx, cdata_ty)};\n-    ret cdata_ty;\n+    return cdata_ty;\n }\n \n fn allocate_cbox(bcx: block,\n@@ -168,7 +168,7 @@ fn allocate_cbox(bcx: block,\n       }\n     };\n \n-    ret {bcx: bcx, val: val};\n+    return {bcx: bcx, val: val};\n }\n \n type closure_result = {\n@@ -247,7 +247,7 @@ fn store_environment(bcx: block,\n     }\n     for vec::each(temp_cleanups) |cleanup| { revoke_clean(bcx, cleanup); }\n \n-    ret {llbox: llbox, cdata_ty: cdata_ty, bcx: bcx};\n+    return {llbox: llbox, cdata_ty: cdata_ty, bcx: bcx};\n }\n \n // Given a context and a list of upvars, build a closure. This just\n@@ -307,7 +307,7 @@ fn build_closure(bcx0: block,\n         vec::push(env_vals,\n                   env_ref(nil_ret, ty::mk_nil_ptr(tcx), lv_owned));\n     }\n-    ret store_environment(bcx, env_vals, ck);\n+    return store_environment(bcx, env_vals, ck);\n }\n \n // Given an enclosing block context, a new function context, a closure type,\n@@ -361,7 +361,7 @@ fn trans_expr_fn(bcx: block,\n                  is_loop_body: option<option<ValueRef>>,\n                  dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(~\"closure::trans_expr_fn\");\n-    if dest == ignore { ret bcx; }\n+    if dest == ignore { return bcx; }\n     let ccx = bcx.ccx();\n     let fty = node_id_type(bcx, id);\n     let llfnty = type_of_fn_from_ty(ccx, fty);\n@@ -399,7 +399,7 @@ fn trans_expr_fn(bcx: block,\n     };\n     fill_fn_pair(bcx, get_dest_addr(dest), llfn, closure);\n \n-    ret bcx;\n+    return bcx;\n }\n \n fn make_fn_glue(\n@@ -421,7 +421,7 @@ fn make_fn_glue(\n         }\n     };\n \n-    ret alt ty::get(t).struct {\n+    return alt ty::get(t).struct {\n       ty::ty_fn({proto: ast::proto_bare, _}) |\n       ty::ty_fn({proto: ast::proto_block, _}) |\n       ty::ty_fn({proto: ast::proto_any, _}) { bcx }\n@@ -439,8 +439,11 @@ fn make_opaque_cbox_take_glue(\n     // Easy cases:\n     let _icx = bcx.insn_ctxt(~\"closure::make_opaque_cbox_take_glue\");\n     alt ck {\n-      ty::ck_block { ret bcx; }\n-      ty::ck_box { incr_refcnt_of_boxed(bcx, Load(bcx, cboxptr)); ret bcx; }\n+      ty::ck_block { return bcx; }\n+      ty::ck_box {\n+        incr_refcnt_of_boxed(bcx, Load(bcx, cboxptr));\n+        return bcx;\n+      }\n       ty::ck_uniq { /* hard case: */ }\n     }\n \n@@ -507,7 +510,7 @@ fn make_opaque_cbox_free_glue(\n     -> block {\n     let _icx = bcx.insn_ctxt(~\"closure::make_opaque_cbox_free_glue\");\n     alt ck {\n-      ty::ck_block { ret bcx; }\n+      ty::ck_block { return bcx; }\n       ty::ck_box | ty::ck_uniq { /* hard cases: */ }\n     }\n \n@@ -537,3 +540,4 @@ fn make_opaque_cbox_free_glue(\n         }\n     }\n }\n+"}, {"sha": "ed977ec3bfb5e1b312b5952ec195504cd7499edb", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 87, "deletions": 85, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -24,7 +24,7 @@ import util::ppaux::ty_to_str;\n type namegen = fn@(~str) -> ~str;\n fn new_namegen() -> namegen {\n     let i = @mut 0;\n-    ret fn@(prefix: ~str) -> ~str { *i += 1; prefix + int::str(*i) };\n+    return fn@(prefix: ~str) -> ~str { *i += 1; prefix + int::str(*i) };\n }\n \n type tydesc_info =\n@@ -247,7 +247,7 @@ fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n }\n \n fn add_clean(cx: block, val: ValueRef, ty: ty::t) {\n-    if !ty::type_needs_drop(cx.tcx(), ty) { ret; }\n+    if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n     debug!{\"add_clean(%s, %s, %s)\",\n            cx.to_str(), val_str(cx.ccx().tn, val),\n            ty_to_str(cx.ccx().tcx, ty)};\n@@ -259,17 +259,17 @@ fn add_clean(cx: block, val: ValueRef, ty: ty::t) {\n     }\n }\n fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n-    if !ty::type_needs_drop(cx.tcx(), ty) { ret; }\n+    if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n     debug!{\"add_clean_temp(%s, %s, %s)\",\n            cx.to_str(), val_str(cx.ccx().tn, val),\n            ty_to_str(cx.ccx().tcx, ty)};\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     fn do_drop(bcx: block, val: ValueRef, ty: ty::t) ->\n        block {\n         if ty::type_is_immediate(ty) {\n-            ret base::drop_ty_immediate(bcx, val, ty);\n+            return base::drop_ty_immediate(bcx, val, ty);\n         } else {\n-            ret base::drop_ty(bcx, val, ty);\n+            return base::drop_ty(bcx, val, ty);\n         }\n     }\n     do in_scope_cx(cx) |info| {\n@@ -279,7 +279,7 @@ fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n     }\n }\n fn add_clean_temp_mem(cx: block, val: ValueRef, ty: ty::t) {\n-    if !ty::type_needs_drop(cx.tcx(), ty) { ret; }\n+    if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n     debug!{\"add_clean_temp_mem(%s, %s, %s)\",\n            cx.to_str(), val_str(cx.ccx().tn, val),\n            ty_to_str(cx.ccx().tcx, ty)};\n@@ -429,27 +429,29 @@ fn rslt(bcx: block, val: ValueRef) -> result {\n }\n \n fn ty_str(tn: type_names, t: TypeRef) -> ~str {\n-    ret lib::llvm::type_to_str(tn, t);\n+    return lib::llvm::type_to_str(tn, t);\n }\n \n-fn val_ty(v: ValueRef) -> TypeRef { ret llvm::LLVMTypeOf(v); }\n+fn val_ty(v: ValueRef) -> TypeRef { return llvm::LLVMTypeOf(v); }\n \n-fn val_str(tn: type_names, v: ValueRef) -> ~str { ret ty_str(tn, val_ty(v)); }\n+fn val_str(tn: type_names, v: ValueRef) -> ~str {\n+    return ty_str(tn, val_ty(v));\n+}\n \n // Returns the nth element of the given LLVM structure type.\n fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef unsafe {\n     let elt_count = llvm::LLVMCountStructElementTypes(llstructty) as uint;\n     assert (n < elt_count);\n     let elt_tys = vec::from_elem(elt_count, T_nil());\n     llvm::LLVMGetStructElementTypes(llstructty, to_ptr(elt_tys));\n-    ret llvm::LLVMGetElementType(elt_tys[n]);\n+    return llvm::LLVMGetElementType(elt_tys[n]);\n }\n \n fn in_scope_cx(cx: block, f: fn(scope_info)) {\n     let mut cur = cx;\n     loop {\n         alt cur.kind {\n-          block_scope(inf) { f(inf); ret; }\n+          block_scope(inf) { f(inf); return; }\n           _ {}\n         }\n         cur = block_parent(cur);\n@@ -502,35 +504,35 @@ fn T_void() -> TypeRef {\n     // of 10 nil values will have 10-bit size -- but it doesn't seem like we\n     // have any other options until it's fixed upstream.\n \n-    ret llvm::LLVMVoidType();\n+    return llvm::LLVMVoidType();\n }\n \n fn T_nil() -> TypeRef {\n     // NB: See above in T_void().\n \n-    ret llvm::LLVMInt1Type();\n+    return llvm::LLVMInt1Type();\n }\n \n-fn T_metadata() -> TypeRef { ret llvm::LLVMMetadataType(); }\n+fn T_metadata() -> TypeRef { return llvm::LLVMMetadataType(); }\n \n-fn T_i1() -> TypeRef { ret llvm::LLVMInt1Type(); }\n+fn T_i1() -> TypeRef { return llvm::LLVMInt1Type(); }\n \n-fn T_i8() -> TypeRef { ret llvm::LLVMInt8Type(); }\n+fn T_i8() -> TypeRef { return llvm::LLVMInt8Type(); }\n \n-fn T_i16() -> TypeRef { ret llvm::LLVMInt16Type(); }\n+fn T_i16() -> TypeRef { return llvm::LLVMInt16Type(); }\n \n-fn T_i32() -> TypeRef { ret llvm::LLVMInt32Type(); }\n+fn T_i32() -> TypeRef { return llvm::LLVMInt32Type(); }\n \n-fn T_i64() -> TypeRef { ret llvm::LLVMInt64Type(); }\n+fn T_i64() -> TypeRef { return llvm::LLVMInt64Type(); }\n \n-fn T_f32() -> TypeRef { ret llvm::LLVMFloatType(); }\n+fn T_f32() -> TypeRef { return llvm::LLVMFloatType(); }\n \n-fn T_f64() -> TypeRef { ret llvm::LLVMDoubleType(); }\n+fn T_f64() -> TypeRef { return llvm::LLVMDoubleType(); }\n \n-fn T_bool() -> TypeRef { ret T_i1(); }\n+fn T_bool() -> TypeRef { return T_i1(); }\n \n fn T_int(targ_cfg: @session::config) -> TypeRef {\n-    ret alt targ_cfg.arch {\n+    return alt targ_cfg.arch {\n       session::arch_x86 { T_i32() }\n       session::arch_x86_64 { T_i64() }\n       session::arch_arm { T_i32() }\n@@ -567,48 +569,48 @@ fn T_float_ty(cx: @crate_ctxt, t: ast::float_ty) -> TypeRef {\n }\n \n fn T_float(targ_cfg: @session::config) -> TypeRef {\n-    ret alt targ_cfg.arch {\n+    return alt targ_cfg.arch {\n       session::arch_x86 { T_f64() }\n       session::arch_x86_64 { T_f64() }\n       session::arch_arm { T_f64() }\n     };\n }\n \n-fn T_char() -> TypeRef { ret T_i32(); }\n+fn T_char() -> TypeRef { return T_i32(); }\n \n fn T_size_t(targ_cfg: @session::config) -> TypeRef {\n-    ret T_int(targ_cfg);\n+    return T_int(targ_cfg);\n }\n \n fn T_fn(inputs: ~[TypeRef], output: TypeRef) -> TypeRef unsafe {\n-    ret llvm::LLVMFunctionType(output, to_ptr(inputs),\n+    return llvm::LLVMFunctionType(output, to_ptr(inputs),\n                                inputs.len() as c_uint,\n                                False);\n }\n \n fn T_fn_pair(cx: @crate_ctxt, tfn: TypeRef) -> TypeRef {\n-    ret T_struct(~[T_ptr(tfn), T_opaque_cbox_ptr(cx)]);\n+    return T_struct(~[T_ptr(tfn), T_opaque_cbox_ptr(cx)]);\n }\n \n fn T_ptr(t: TypeRef) -> TypeRef {\n-    ret llvm::LLVMPointerType(t, 0u as c_uint);\n+    return llvm::LLVMPointerType(t, 0u as c_uint);\n }\n \n fn T_struct(elts: ~[TypeRef]) -> TypeRef unsafe {\n-    ret llvm::LLVMStructType(to_ptr(elts), elts.len() as c_uint, False);\n+    return llvm::LLVMStructType(to_ptr(elts), elts.len() as c_uint, False);\n }\n \n fn T_named_struct(name: ~str) -> TypeRef {\n     let c = llvm::LLVMGetGlobalContext();\n-    ret str::as_c_str(name, |buf| llvm::LLVMStructCreateNamed(c, buf));\n+    return str::as_c_str(name, |buf| llvm::LLVMStructCreateNamed(c, buf));\n }\n \n fn set_struct_body(t: TypeRef, elts: ~[TypeRef]) unsafe {\n     llvm::LLVMStructSetBody(t, to_ptr(elts),\n                             elts.len() as c_uint, False);\n }\n \n-fn T_empty_struct() -> TypeRef { ret T_struct(~[]); }\n+fn T_empty_struct() -> TypeRef { return T_struct(~[]); }\n \n // A vtable is, in reality, a vtable pointer followed by zero or more pointers\n // to tydescs and other vtables that it closes over. But the types and number\n@@ -635,7 +637,7 @@ fn T_task(targ_cfg: @session::config) -> TypeRef {\n         ~[t_int, t_int, t_int, t_int,\n          t_int, t_int, t_int, t_int];\n     set_struct_body(t, elems);\n-    ret t;\n+    return t;\n }\n \n fn T_tydesc_field(cx: @crate_ctxt, field: uint) -> TypeRef unsafe {\n@@ -647,15 +649,15 @@ fn T_tydesc_field(cx: @crate_ctxt, field: uint) -> TypeRef unsafe {\n     llvm::LLVMGetStructElementTypes(cx.tydesc_type,\n                                     to_ptr::<TypeRef>(tydesc_elts));\n     let t = llvm::LLVMGetElementType(tydesc_elts[field]);\n-    ret t;\n+    return t;\n }\n \n fn T_glue_fn(cx: @crate_ctxt) -> TypeRef {\n     let s = ~\"glue_fn\";\n-    alt name_has_type(cx.tn, s) { some(t) { ret t; } _ {} }\n+    alt name_has_type(cx.tn, s) { some(t) { return t; } _ {} }\n     let t = T_tydesc_field(cx, abi::tydesc_field_drop_glue);\n     associate_type(cx.tn, s, t);\n-    ret t;\n+    return t;\n }\n \n fn T_tydesc(targ_cfg: @session::config) -> TypeRef {\n@@ -672,178 +674,178 @@ fn T_tydesc(targ_cfg: @session::config) -> TypeRef {\n           glue_fn_ty, glue_fn_ty, glue_fn_ty, glue_fn_ty,\n           T_ptr(T_i8()), T_ptr(T_i8())];\n     set_struct_body(tydesc, elems);\n-    ret tydesc;\n+    return tydesc;\n }\n \n fn T_array(t: TypeRef, n: uint) -> TypeRef {\n-    ret llvm::LLVMArrayType(t, n as c_uint);\n+    return llvm::LLVMArrayType(t, n as c_uint);\n }\n \n // Interior vector.\n fn T_vec2(targ_cfg: @session::config, t: TypeRef) -> TypeRef {\n-    ret T_struct(~[T_int(targ_cfg), // fill\n+    return T_struct(~[T_int(targ_cfg), // fill\n                   T_int(targ_cfg), // alloc\n                   T_array(t, 0u)]); // elements\n }\n \n fn T_vec(ccx: @crate_ctxt, t: TypeRef) -> TypeRef {\n-    ret T_vec2(ccx.sess.targ_cfg, t);\n+    return T_vec2(ccx.sess.targ_cfg, t);\n }\n \n // Note that the size of this one is in bytes.\n fn T_opaque_vec(targ_cfg: @session::config) -> TypeRef {\n-    ret T_vec2(targ_cfg, T_i8());\n+    return T_vec2(targ_cfg, T_i8());\n }\n \n // Let T be the content of a box @T.  tuplify_box_ty(t) returns the\n // representation of @T as a tuple (i.e., the ty::t version of what T_box()\n // returns).\n fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     let ptr = ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx), mutbl: ast::m_imm});\n-    ret ty::mk_tup(tcx, ~[ty::mk_uint(tcx), ty::mk_type(tcx),\n+    return ty::mk_tup(tcx, ~[ty::mk_uint(tcx), ty::mk_type(tcx),\n                          ptr, ptr,\n                          t]);\n }\n \n fn T_box_header_fields(cx: @crate_ctxt) -> ~[TypeRef] {\n     let ptr = T_ptr(T_i8());\n-    ret ~[cx.int_type, T_ptr(cx.tydesc_type), ptr, ptr];\n+    return ~[cx.int_type, T_ptr(cx.tydesc_type), ptr, ptr];\n }\n \n fn T_box_header(cx: @crate_ctxt) -> TypeRef {\n-    ret T_struct(T_box_header_fields(cx));\n+    return T_struct(T_box_header_fields(cx));\n }\n \n fn T_box(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n-    ret T_struct(vec::append(T_box_header_fields(cx), ~[t]));\n+    return T_struct(vec::append(T_box_header_fields(cx), ~[t]));\n }\n \n fn T_box_ptr(t: TypeRef) -> TypeRef {\n     const box_addrspace: uint = 1u;\n-    ret llvm::LLVMPointerType(t, box_addrspace as c_uint);\n+    return llvm::LLVMPointerType(t, box_addrspace as c_uint);\n }\n \n fn T_opaque_box(cx: @crate_ctxt) -> TypeRef {\n-    ret T_box(cx, T_i8());\n+    return T_box(cx, T_i8());\n }\n \n fn T_opaque_box_ptr(cx: @crate_ctxt) -> TypeRef {\n-    ret T_box_ptr(T_opaque_box(cx));\n+    return T_box_ptr(T_opaque_box(cx));\n }\n \n fn T_unique(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n-    ret T_struct(vec::append(T_box_header_fields(cx), ~[t]));\n+    return T_struct(vec::append(T_box_header_fields(cx), ~[t]));\n }\n \n fn T_unique_ptr(t: TypeRef) -> TypeRef {\n     const unique_addrspace: uint = 1u;\n-    ret llvm::LLVMPointerType(t, unique_addrspace as c_uint);\n+    return llvm::LLVMPointerType(t, unique_addrspace as c_uint);\n }\n \n fn T_port(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n-    ret T_struct(~[cx.int_type]); // Refcount\n+    return T_struct(~[cx.int_type]); // Refcount\n \n }\n \n fn T_chan(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n-    ret T_struct(~[cx.int_type]); // Refcount\n+    return T_struct(~[cx.int_type]); // Refcount\n \n }\n \n-fn T_taskptr(cx: @crate_ctxt) -> TypeRef { ret T_ptr(cx.task_type); }\n+fn T_taskptr(cx: @crate_ctxt) -> TypeRef { return T_ptr(cx.task_type); }\n \n \n // This type must never be used directly; it must always be cast away.\n fn T_typaram(tn: type_names) -> TypeRef {\n     let s = ~\"typaram\";\n-    alt name_has_type(tn, s) { some(t) { ret t; } _ {} }\n+    alt name_has_type(tn, s) { some(t) { return t; } _ {} }\n     let t = T_i8();\n     associate_type(tn, s, t);\n-    ret t;\n+    return t;\n }\n \n-fn T_typaram_ptr(tn: type_names) -> TypeRef { ret T_ptr(T_typaram(tn)); }\n+fn T_typaram_ptr(tn: type_names) -> TypeRef { return T_ptr(T_typaram(tn)); }\n \n fn T_opaque_cbox_ptr(cx: @crate_ctxt) -> TypeRef {\n     // closures look like boxes (even when they are fn~ or fn&)\n     // see trans_closure.rs\n-    ret T_opaque_box_ptr(cx);\n+    return T_opaque_box_ptr(cx);\n }\n \n fn T_enum_discrim(cx: @crate_ctxt) -> TypeRef {\n-    ret cx.int_type;\n+    return cx.int_type;\n }\n \n fn T_opaque_enum(cx: @crate_ctxt) -> TypeRef {\n     let s = ~\"opaque_enum\";\n-    alt name_has_type(cx.tn, s) { some(t) { ret t; } _ {} }\n+    alt name_has_type(cx.tn, s) { some(t) { return t; } _ {} }\n     let t = T_struct(~[T_enum_discrim(cx), T_i8()]);\n     associate_type(cx.tn, s, t);\n-    ret t;\n+    return t;\n }\n \n fn T_opaque_enum_ptr(cx: @crate_ctxt) -> TypeRef {\n-    ret T_ptr(T_opaque_enum(cx));\n+    return T_ptr(T_opaque_enum(cx));\n }\n \n fn T_captured_tydescs(cx: @crate_ctxt, n: uint) -> TypeRef {\n-    ret T_struct(vec::from_elem::<TypeRef>(n, T_ptr(cx.tydesc_type)));\n+    return T_struct(vec::from_elem::<TypeRef>(n, T_ptr(cx.tydesc_type)));\n }\n \n fn T_opaque_trait(cx: @crate_ctxt) -> TypeRef {\n     T_struct(~[T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)])\n }\n \n-fn T_opaque_port_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n+fn T_opaque_port_ptr() -> TypeRef { return T_ptr(T_i8()); }\n \n-fn T_opaque_chan_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n+fn T_opaque_chan_ptr() -> TypeRef { return T_ptr(T_i8()); }\n \n \n // LLVM constant constructors.\n-fn C_null(t: TypeRef) -> ValueRef { ret llvm::LLVMConstNull(t); }\n+fn C_null(t: TypeRef) -> ValueRef { return llvm::LLVMConstNull(t); }\n \n fn C_integral(t: TypeRef, u: u64, sign_extend: Bool) -> ValueRef {\n-    ret llvm::LLVMConstInt(t, u, sign_extend);\n+    return llvm::LLVMConstInt(t, u, sign_extend);\n }\n \n fn C_floating(s: ~str, t: TypeRef) -> ValueRef {\n-    ret str::as_c_str(s, |buf| llvm::LLVMConstRealOfString(t, buf));\n+    return str::as_c_str(s, |buf| llvm::LLVMConstRealOfString(t, buf));\n }\n \n fn C_nil() -> ValueRef {\n     // NB: See comment above in T_void().\n \n-    ret C_integral(T_i1(), 0u64, False);\n+    return C_integral(T_i1(), 0u64, False);\n }\n \n fn C_bool(b: bool) -> ValueRef {\n     C_integral(T_bool(), if b { 1u64 } else { 0u64 }, False)\n }\n \n fn C_i32(i: i32) -> ValueRef {\n-    ret C_integral(T_i32(), i as u64, True);\n+    return C_integral(T_i32(), i as u64, True);\n }\n \n fn C_i64(i: i64) -> ValueRef {\n-    ret C_integral(T_i64(), i as u64, True);\n+    return C_integral(T_i64(), i as u64, True);\n }\n \n fn C_int(cx: @crate_ctxt, i: int) -> ValueRef {\n-    ret C_integral(cx.int_type, i as u64, True);\n+    return C_integral(cx.int_type, i as u64, True);\n }\n \n fn C_uint(cx: @crate_ctxt, i: uint) -> ValueRef {\n-    ret C_integral(cx.int_type, i as u64, False);\n+    return C_integral(cx.int_type, i as u64, False);\n }\n \n-fn C_u8(i: uint) -> ValueRef { ret C_integral(T_i8(), i as u64, False); }\n+fn C_u8(i: uint) -> ValueRef { return C_integral(T_i8(), i as u64, False); }\n \n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n fn C_cstr(cx: @crate_ctxt, s: ~str) -> ValueRef {\n     alt cx.const_cstr_cache.find(s) {\n-      some(llval) { ret llval; }\n+      some(llval) { return llval; }\n       none { }\n     }\n \n@@ -859,7 +861,7 @@ fn C_cstr(cx: @crate_ctxt, s: ~str) -> ValueRef {\n \n     cx.const_cstr_cache.insert(s, g);\n \n-    ret g;\n+    return g;\n }\n \n fn C_estr_slice(cx: @crate_ctxt, s: ~str) -> ValueRef {\n@@ -869,7 +871,7 @@ fn C_estr_slice(cx: @crate_ctxt, s: ~str) -> ValueRef {\n \n // Returns a Plain Old LLVM String:\n fn C_postr(s: ~str) -> ValueRef {\n-    ret do str::as_c_str(s) |buf| {\n+    return do str::as_c_str(s) |buf| {\n         llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n     };\n }\n@@ -878,27 +880,27 @@ fn C_zero_byte_arr(size: uint) -> ValueRef unsafe {\n     let mut i = 0u;\n     let mut elts: ~[ValueRef] = ~[];\n     while i < size { vec::push(elts, C_u8(0u)); i += 1u; }\n-    ret llvm::LLVMConstArray(T_i8(), vec::unsafe::to_ptr(elts),\n+    return llvm::LLVMConstArray(T_i8(), vec::unsafe::to_ptr(elts),\n                              elts.len() as c_uint);\n }\n \n fn C_struct(elts: ~[ValueRef]) -> ValueRef unsafe {\n-    ret llvm::LLVMConstStruct(vec::unsafe::to_ptr(elts),\n+    return llvm::LLVMConstStruct(vec::unsafe::to_ptr(elts),\n                               elts.len() as c_uint, False);\n }\n \n fn C_named_struct(T: TypeRef, elts: ~[ValueRef]) -> ValueRef unsafe {\n-    ret llvm::LLVMConstNamedStruct(T, vec::unsafe::to_ptr(elts),\n+    return llvm::LLVMConstNamedStruct(T, vec::unsafe::to_ptr(elts),\n                                    elts.len() as c_uint);\n }\n \n fn C_array(ty: TypeRef, elts: ~[ValueRef]) -> ValueRef unsafe {\n-    ret llvm::LLVMConstArray(ty, vec::unsafe::to_ptr(elts),\n+    return llvm::LLVMConstArray(ty, vec::unsafe::to_ptr(elts),\n                              elts.len() as c_uint);\n }\n \n fn C_bytes(bytes: ~[u8]) -> ValueRef unsafe {\n-    ret llvm::LLVMConstString(\n+    return llvm::LLVMConstString(\n         unsafe::reinterpret_cast(vec::unsafe::to_ptr(bytes)),\n         bytes.len() as c_uint, False);\n }\n@@ -911,7 +913,7 @@ fn C_shape(ccx: @crate_ctxt, bytes: ~[u8]) -> ValueRef {\n     llvm::LLVMSetInitializer(llglobal, llshape);\n     llvm::LLVMSetGlobalConstant(llglobal, True);\n     lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n-    ret llvm::LLVMConstPointerCast(llglobal, T_ptr(T_i8()));\n+    return llvm::LLVMConstPointerCast(llglobal, T_ptr(T_i8()));\n }\n \n fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n@@ -945,18 +947,18 @@ fn hash_mono_id(&&mi: mono_id) -> uint {\n \n fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n-    ret build::Select(cx, cond, b, a);\n+    return build::Select(cx, cond, b, a);\n }\n \n fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n-    ret build::Select(cx, cond, a, b);\n+    return build::Select(cx, cond, a, b);\n }\n \n fn align_to(cx: block, off: ValueRef, align: ValueRef) -> ValueRef {\n     let mask = build::Sub(cx, align, C_int(cx.ccx(), 1));\n     let bumped = build::Add(cx, off, mask);\n-    ret build::And(cx, bumped, build::Not(cx, mask));\n+    return build::And(cx, bumped, build::Not(cx, mask));\n }\n \n fn path_str(p: path) -> ~str {"}, {"sha": "aeb8c8ce74af3054e408dbf1aee4db3367c66090", "filename": "src/rustc/middle/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -51,7 +51,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n         let ty = ty::expr_ty(cx.tcx, e1);\n         let is_float = ty::type_is_fp(ty);\n         let signed = ty::type_is_signed(ty);\n-        ret alt b {\n+        return alt b {\n           ast::add    {\n             if is_float { llvm::LLVMConstFAdd(te1, te2) }\n             else        { llvm::LLVMConstAdd(te1, te2) }\n@@ -96,7 +96,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n         let te = const_expr(cx, e);\n         let ty = ty::expr_ty(cx.tcx, e);\n         let is_float = ty::type_is_fp(ty);\n-        ret alt u {\n+        return alt u {\n           ast::box(_)  |\n           ast::uniq(_) |\n           ast::deref   { cx.sess.span_bug(e.span,"}, {"sha": "1f1da98b528510e29f478d0d575336d482c7cc71", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -130,7 +130,7 @@ enum debug_metadata {\n \n fn cast_safely<T: copy, U>(val: T) -> U unsafe {\n     let val2 = val;\n-    ret unsafe::transmute(val2);\n+    return unsafe::transmute(val2);\n }\n \n fn md_from_metadata<T>(val: debug_metadata) -> T unsafe {\n@@ -153,11 +153,11 @@ fn cached_metadata<T: copy>(cache: metadata_cache, mdtag: int,\n         for items.each |item| {\n             let md: T = md_from_metadata::<T>(item);\n             if eq(md) {\n-                ret option::some(md);\n+                return option::some(md);\n             }\n         }\n     }\n-    ret option::none;\n+    return option::none;\n }\n \n fn create_compile_unit(cx: @crate_ctxt)\n@@ -167,7 +167,7 @@ fn create_compile_unit(cx: @crate_ctxt)\n     let tg = CompileUnitTag;\n     alt cached_metadata::<@metadata<compile_unit_md>>(cache, tg,\n                         |md| md.data.name == crate_name) {\n-      option::some(md) { ret md; }\n+      option::some(md) { return md; }\n       option::none {}\n     }\n \n@@ -189,7 +189,7 @@ fn create_compile_unit(cx: @crate_ctxt)\n     let mdval = @{node: unit_node, data: {name: crate_name}};\n     update_cache(cache, tg, compile_unit_metadata(mdval));\n \n-    ret mdval;\n+    return mdval;\n }\n \n fn get_cache(cx: @crate_ctxt) -> metadata_cache {\n@@ -210,7 +210,7 @@ fn create_file(cx: @crate_ctxt, full_path: ~str) -> @metadata<file_md> {\n     let tg = FileDescriptorTag;\n     alt cached_metadata::<@metadata<file_md>>(\n         cache, tg, |md| md.data.path == full_path) {\n-        option::some(md) { ret md; }\n+        option::some(md) { return md; }\n         option::none {}\n     }\n \n@@ -224,7 +224,7 @@ fn create_file(cx: @crate_ctxt, full_path: ~str) -> @metadata<file_md> {\n     let val = llmdnode(file_md);\n     let mdval = @{node: val, data: {path: full_path}};\n     update_cache(cache, tg, file_metadata(mdval));\n-    ret mdval;\n+    return mdval;\n }\n \n fn line_from_span(cm: codemap::codemap, sp: span) -> uint {\n@@ -249,7 +249,7 @@ fn create_block(cx: block) -> @metadata<block_md> {\n     /*alt cached_metadata::<@metadata<block_md>>(\n         cache, tg,\n         {|md| start == md.data.start && end == md.data.end}) {\n-      option::some(md) { ret md; }\n+      option::some(md) { return md; }\n       option::none {}\n     }*/\n \n@@ -272,7 +272,7 @@ fn create_block(cx: block) -> @metadata<block_md> {\n     let val = llmdnode(lldata);\n     let mdval = @{node: val, data: {start: start, end: end}};\n     //update_cache(cache, tg, block_metadata(mdval));\n-    ret mdval;\n+    return mdval;\n }\n \n fn size_and_align_of(cx: @crate_ctxt, t: ty::t) -> (int, int) {\n@@ -287,7 +287,7 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: ast::prim_ty, span: span)\n     let tg = BasicTypeDescriptorTag;\n     alt cached_metadata::<@metadata<tydesc_md>>(\n         cache, tg, |md| ty::type_id(t) == md.data.hash) {\n-      option::some(md) { ret md; }\n+      option::some(md) { return md; }\n       option::none {}\n     }\n \n@@ -333,7 +333,7 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: ast::prim_ty, span: span)\n     let mdval = @{node: llnode, data: {hash: ty::type_id(t)}};\n     update_cache(cache, tg, tydesc_metadata(mdval));\n     add_named_metadata(cx, ~\"llvm.dbg.ty\", llnode);\n-    ret mdval;\n+    return mdval;\n }\n \n fn create_pointer_type(cx: @crate_ctxt, t: ty::t, span: span,\n@@ -343,7 +343,7 @@ fn create_pointer_type(cx: @crate_ctxt, t: ty::t, span: span,\n     /*let cache = cx.llmetadata;\n     alt cached_metadata::<@metadata<tydesc_md>>(\n         cache, tg, {|md| ty::hash_ty(t) == ty::hash_ty(md.data.hash)}) {\n-      option::some(md) { ret md; }\n+      option::some(md) { return md; }\n       option::none {}\n     }*/\n     let (size, align) = size_and_align_of(cx, t);\n@@ -355,7 +355,7 @@ fn create_pointer_type(cx: @crate_ctxt, t: ty::t, span: span,\n     let mdval = @{node: llnode, data: {hash: ty::type_id(t)}};\n     //update_cache(cache, tg, tydesc_metadata(mdval));\n     add_named_metadata(cx, ~\"llvm.dbg.ty\", llnode);\n-    ret mdval;\n+    return mdval;\n }\n \n type struct_ctxt = {\n@@ -368,7 +368,7 @@ type struct_ctxt = {\n };\n \n fn finish_structure(cx: @struct_ctxt) -> ValueRef {\n-    ret create_composite_type(StructureTypeTag, cx.name, cx.file, cx.line,\n+    return create_composite_type(StructureTypeTag, cx.name, cx.file, cx.line,\n                               cx.total_size, cx.align, 0, option::none,\n                               option::some(cx.members));\n }\n@@ -382,7 +382,7 @@ fn create_structure(file: @metadata<file_md>, name: ~str, line: int)\n                mut total_size: 0,\n                align: 64 //XXX different alignment per arch?\n               };\n-    ret cx;\n+    return cx;\n }\n \n fn create_derived_type(type_tag: int, file: ValueRef, name: ~str, line: int,\n@@ -398,7 +398,7 @@ fn create_derived_type(type_tag: int, file: ValueRef, name: ~str, line: int,\n                   lli64(offset),\n                   lli32(0),\n                   ty];\n-    ret llmdnode(lldata);\n+    return llmdnode(lldata);\n }\n \n fn add_member(cx: @struct_ctxt, name: ~str, line: int, size: int, align: int,\n@@ -426,7 +426,7 @@ fn create_record(cx: @crate_ctxt, t: ty::t, fields: ~[ast::ty_field],\n                    size as int, align as int, ty_md.node);\n     }\n     let mdval = @{node: finish_structure(scx), data:{hash: ty::type_id(t)}};\n-    ret mdval;\n+    return mdval;\n }\n \n fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n@@ -436,7 +436,7 @@ fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n     /*let cache = cx.llmetadata;\n     alt cached_metadata::<@metadata<tydesc_md>>(\n         cache, tg, {|md| ty::hash_ty(outer) == ty::hash_ty(md.data.hash)}) {\n-      option::some(md) { ret md; }\n+      option::some(md) { return md; }\n       option::none {}\n     }*/\n     let fname = filename_from_span(cx, span);\n@@ -455,7 +455,7 @@ fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n     let mdval = @{node: llnode, data: {hash: ty::type_id(outer)}};\n     //update_cache(cache, tg, tydesc_metadata(mdval));\n     add_named_metadata(cx, ~\"llvm.dbg.ty\", llnode);\n-    ret mdval;\n+    return mdval;\n }\n \n fn create_composite_type(type_tag: int, name: ~str, file: ValueRef, line: int,\n@@ -485,7 +485,7 @@ fn create_composite_type(type_tag: int, name: ~str, file: ValueRef, line: int,\n                   lli32(0),  // runtime language\n                   llnull()\n                  ];\n-    ret llmdnode(lldata);\n+    return llmdnode(lldata);\n }\n \n fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n@@ -510,15 +510,15 @@ fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n     add_member(scx, ~\"data\", 0, 0, // clang says the size should be 0\n                sys::min_align_of::<u8>() as int, data_ptr);\n     let llnode = finish_structure(scx);\n-    ret @{node: llnode, data: {hash: ty::type_id(vec_t)}};\n+    return @{node: llnode, data: {hash: ty::type_id(vec_t)}};\n }\n \n fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n     -> @metadata<tydesc_md> {\n     /*let cache = get_cache(cx);\n     alt cached_metadata::<@metadata<tydesc_md>>(\n         cache, tg, {|md| t == md.data.hash}) {\n-      option::some(md) { ret md; }\n+      option::some(md) { return md; }\n       option::none {}\n     }*/\n \n@@ -563,7 +563,7 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n             cx.sess.span_bug(span, \"t_to_ty: Can't handle this type\");\n           }\n         };\n-        ret @{node: ty, span: span};\n+        return @{node: ty, span: span};\n     }\n \n     alt ty.node {\n@@ -574,7 +574,7 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n         };\n         let md = create_ty(cx, inner_t, mt.ty);\n         let box = create_boxed_type(cx, t, inner_t, ty.span, md);\n-        ret create_pointer_type(cx, t, ty.span, box);\n+        return create_pointer_type(cx, t, ty.span, box);\n       }\n \n       ast::ty_uniq(mt) {\n@@ -584,29 +584,29 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n           _ { cx.sess.span_bug(ty.span, \"t_to_ty was incoherent\"); }\n         };\n         let md = create_ty(cx, inner_t, mt.ty);\n-        ret create_pointer_type(cx, t, ty.span, md);\n+        return create_pointer_type(cx, t, ty.span, md);\n       }\n \n       ast::ty_infer {\n         let inferred = t_to_ty(cx, t, ty.span);\n-        ret create_ty(cx, t, inferred);\n+        return create_ty(cx, t, inferred);\n       }\n \n       ast::ty_rec(fields) {\n-        ret create_record(cx, t, fields, ty.span);\n+        return create_record(cx, t, fields, ty.span);\n       }\n \n       ast::ty_vec(mt) {\n         let inner_t = ty::sequence_element_type(cx.tcx, t);\n         let inner_ast_t = t_to_ty(cx, inner_t, mt.ty.span);\n         let v = create_vec(cx, t, inner_t, ty.span, inner_ast_t);\n-        ret create_pointer_type(cx, t, ty.span, v);\n+        return create_pointer_type(cx, t, ty.span, v);\n       }\n \n       ast::ty_path(_, id) {\n         alt cx.tcx.def_map.get(id) {\n           ast::def_prim_ty(pty) {\n-            ret create_basic_type(cx, t, pty, ty.span);\n+            return create_basic_type(cx, t, pty, ty.span);\n           }\n           _ {}\n         }\n@@ -631,7 +631,7 @@ fn create_var(type_tag: int, context: ValueRef, name: ~str, file: ValueRef,\n                   ret_ty,\n                   lli32(0)\n                  ];\n-    ret llmdnode(lldata);\n+    return llmdnode(lldata);\n }\n \n fn create_local_var(bcx: block, local: @ast::local)\n@@ -641,7 +641,7 @@ fn create_local_var(bcx: block, local: @ast::local)\n     let tg = AutoVariableTag;\n     alt cached_metadata::<@metadata<local_var_md>>(\n         cache, tg, |md| md.data.id == local.node.id) {\n-      option::some(md) { ret md; }\n+      option::some(md) { return md; }\n       option::none {}\n     }\n \n@@ -681,7 +681,7 @@ fn create_local_var(bcx: block, local: @ast::local)\n     let declargs = ~[llmdnode(~[llptr]), mdnode];\n     trans::build::Call(bcx, cx.intrinsics.get(~\"llvm.dbg.declare\"),\n                        declargs);\n-    ret mdval;\n+    return mdval;\n }\n \n fn create_arg(bcx: block, arg: ast::arg, sp: span)\n@@ -691,7 +691,7 @@ fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     let tg = ArgVariableTag;\n     alt cached_metadata::<@metadata<argument_md>>(\n         cache, ArgVariableTag, |md| md.data.id == arg.id) {\n-      option::some(md) { ret md; }\n+      option::some(md) { return md; }\n       option::none {}\n     }\n \n@@ -712,12 +712,12 @@ fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     let declargs = ~[llmdnode(~[llptr]), mdnode];\n     trans::build::Call(bcx, cx.intrinsics.get(~\"llvm.dbg.declare\"),\n                        declargs);\n-    ret mdval;\n+    return mdval;\n }\n \n fn update_source_pos(cx: block, s: span) {\n     if !cx.sess().opts.debuginfo {\n-        ret;\n+        return;\n     }\n     let cm = cx.sess().codemap;\n     let blockmd = create_block(cx);\n@@ -779,7 +779,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let cache = get_cache(cx);\n     alt cached_metadata::<@metadata<subprogram_md>>(\n         cache, SubprogramTag, |md| md.data.id == id) {\n-      option::some(md) { ret md; }\n+      option::some(md) { return md; }\n       option::none {}\n     }\n \n@@ -824,5 +824,5 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let mdval = @{node: val, data: {id: id}};\n     update_cache(cache, SubprogramTag, subprogram_metadata(mdval));\n \n-    ret mdval;\n+    return mdval;\n }"}, {"sha": "129e737bb29fe3938b7a415fe84e04107958dc2c", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -38,7 +38,7 @@ enum x86_64_reg_class {\n }\n \n fn is_sse(++c: x86_64_reg_class) -> bool {\n-    ret alt c {\n+    return alt c {\n         sse_fs_class | sse_fv_class |\n         sse_ds_class | sse_dv_class { true }\n         _ { false }\n@@ -47,7 +47,7 @@ fn is_sse(++c: x86_64_reg_class) -> bool {\n \n fn is_ymm(cls: ~[x86_64_reg_class]) -> bool {\n     let len = vec::len(cls);\n-    ret (len > 2u &&\n+    return (len > 2u &&\n          is_sse(cls[0]) &&\n          cls[1] == sseup_class &&\n          cls[2] == sseup_class) ||\n@@ -60,7 +60,7 @@ fn is_ymm(cls: ~[x86_64_reg_class]) -> bool {\n fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     fn align(off: uint, ty: TypeRef) -> uint {\n         let a = ty_align(ty);\n-        ret (off + a - 1u) / a * a;\n+        return (off + a - 1u) / a * a;\n     }\n \n     fn struct_tys(ty: TypeRef) -> ~[TypeRef] {\n@@ -69,11 +69,11 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n         do vec::as_buf(elts) |buf, _len| {\n             llvm::LLVMGetStructElementTypes(ty, buf);\n         }\n-        ret elts;\n+        return elts;\n     }\n \n     fn ty_align(ty: TypeRef) -> uint {\n-        ret alt llvm::LLVMGetTypeKind(ty) as int {\n+        return alt llvm::LLVMGetTypeKind(ty) as int {\n             8 /* integer */ {\n                 ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7u) / 8u\n             }\n@@ -96,7 +96,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     }\n \n     fn ty_size(ty: TypeRef) -> uint {\n-        ret alt llvm::LLVMGetTypeKind(ty) as int {\n+        return alt llvm::LLVMGetTypeKind(ty) as int {\n             8 /* integer */ {\n                 ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7u) / 8u\n             }\n@@ -130,11 +130,11 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n              i: uint,\n              newv: x86_64_reg_class) {\n         if cls[i] == newv {\n-            ret;\n+            return;\n         } else if cls[i] == no_class {\n             cls[i] = newv;\n         } else if newv == no_class {\n-            ret;\n+            return;\n         } else if cls[i] == memory_class || newv == memory_class {\n             cls[i] = memory_class;\n         } else if cls[i] == integer_class || newv == integer_class {\n@@ -180,7 +180,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n                 unify(cls, ix + i, memory_class);\n                 i += 1u;\n             }\n-            ret;\n+            return;\n         }\n \n         alt llvm::LLVMGetTypeKind(ty) as int {\n@@ -229,25 +229,25 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n                 while i < e {\n                     if cls[i] != sseup_class {\n                         all_mem(cls);\n-                        ret;\n+                        return;\n                     }\n                     i += 1u;\n                 }\n             } else {\n                 all_mem(cls);\n-                ret\n+                return\n             }\n         } else {\n             while i < e {\n                 if cls[i] == memory_class {\n                     all_mem(cls);\n-                    ret;\n+                    return;\n                 }\n                 if cls[i] == x87up_class {\n                     // for darwin\n                     // cls[i] = sse_ds_class;\n                     all_mem(cls);\n-                    ret;\n+                    return;\n                 }\n                 if cls[i] == sseup_class {\n                     cls[i] = sse_int_class;\n@@ -268,11 +268,11 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     let cls = vec::to_mut(vec::from_elem(words, no_class));\n     if words > 4u {\n         all_mem(cls);\n-        ret vec::from_mut(cls);\n+        return vec::from_mut(cls);\n     }\n     classify(ty, cls, 0u, 0u);\n     fixup(ty, cls);\n-    ret vec::from_mut(cls);\n+    return vec::from_mut(cls);\n }\n \n fn llreg_ty(cls: ~[x86_64_reg_class]) -> TypeRef {\n@@ -284,7 +284,7 @@ fn llreg_ty(cls: ~[x86_64_reg_class]) -> TypeRef {\n             }\n             len += 1u;\n         }\n-        ret len;\n+        return len;\n     }\n \n     let mut tys = ~[];\n@@ -315,7 +315,7 @@ fn llreg_ty(cls: ~[x86_64_reg_class]) -> TypeRef {\n         }\n         i += 1u;\n     }\n-    ret T_struct(tys);\n+    return T_struct(tys);\n }\n \n type x86_64_llty = {\n@@ -334,7 +334,7 @@ fn x86_64_tys(atys: ~[TypeRef],\n               rty: TypeRef,\n               ret_def: bool) -> x86_64_tys {\n     fn is_reg_ty(ty: TypeRef) -> bool {\n-        ret alt llvm::LLVMGetTypeKind(ty) as int {\n+        return alt llvm::LLVMGetTypeKind(ty) as int {\n             8 /* integer */ |\n             12 /* pointer */ |\n             2 /* float */ |\n@@ -344,13 +344,13 @@ fn x86_64_tys(atys: ~[TypeRef],\n     }\n \n     fn is_pass_byval(cls: ~[x86_64_reg_class]) -> bool {\n-        ret cls[0] == memory_class ||\n+        return cls[0] == memory_class ||\n             cls[0] == x87_class ||\n             cls[0] == complex_x87_class;\n     }\n \n     fn is_ret_bysret(cls: ~[x86_64_reg_class]) -> bool {\n-        ret cls[0] == memory_class;\n+        return cls[0] == memory_class;\n     }\n \n     fn x86_64_ty(ty: TypeRef,\n@@ -369,7 +369,7 @@ fn x86_64_tys(atys: ~[TypeRef],\n                 llty = llreg_ty(cls);\n             }\n         }\n-        ret ({ cast: cast, ty: llty }, ty_attr);\n+        return ({ cast: cast, ty: llty }, ty_attr);\n     }\n \n     let mut arg_tys = ~[];\n@@ -393,7 +393,7 @@ fn x86_64_tys(atys: ~[TypeRef],\n                    ty: T_void()\n                  };\n     }\n-    ret {\n+    return {\n         arg_tys: arg_tys,\n         ret_ty: ret_ty,\n         attrs: attrs,\n@@ -417,13 +417,13 @@ fn decl_x86_64_fn(tys: x86_64_tys,\n             _ {}\n         }\n     }\n-    ret llfn;\n+    return llfn;\n }\n \n fn link_name(i: @ast::foreign_item) -> ~str {\n     alt attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n-      none { ret *i.ident; }\n-      option::some(ln) { ret *ln; }\n+      none { return *i.ident; }\n+      option::some(ln) { return *ln; }\n     }\n }\n \n@@ -458,7 +458,7 @@ fn c_stack_tys(ccx: @crate_ctxt,\n     } else {\n         option::none\n     };\n-    ret @{\n+    return @{\n         arg_tys: llargtys,\n         ret_ty: llretty,\n         ret_def: ret_def,\n@@ -501,7 +501,7 @@ fn build_shim_fn_(ccx: @crate_ctxt,\n     build_return(bcx);\n     finish_fn(fcx, lltop);\n \n-    ret llshimfn;\n+    return llshimfn;\n }\n \n type wrap_arg_builder = fn(bcx: block, tys: @c_stack_tys,\n@@ -631,7 +631,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n                     }\n                 }\n             }\n-            ret llargvals;\n+            return llargvals;\n         }\n \n         fn build_ret(bcx: block, tys: @c_stack_tys,\n@@ -650,7 +650,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n                         }\n                     }\n                     if x86_64.sret || !tys.ret_def {\n-                        ret;\n+                        return;\n                     }\n                     let n = vec::len(tys.arg_tys);\n                     let llretptr = GEPi(bcx, llargbundle, ~[0u, n]);\n@@ -681,7 +681,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n         let llbasefn = base_fn(ccx, lname, tys, cc);\n         // Name the shim function\n         let shim_name = lname + ~\"__c_stack_shim\";\n-        ret build_shim_fn_(ccx, shim_name, llbasefn, tys, cc,\n+        return build_shim_fn_(ccx, shim_name, llbasefn, tys, cc,\n                            build_args, build_ret);\n     }\n \n@@ -734,7 +734,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n             let _icx = bcx.insn_ctxt(~\"foreign::wrap::build_args\");\n             let mut i = 0u;\n             let n = vec::len(tys.arg_tys);\n-            let implicit_args = first_real_arg; // ret + env\n+            let implicit_args = first_real_arg; // return + env\n             while i < n {\n                 let llargval = get_param(llwrapfn, i + implicit_args);\n                 store_inbounds(bcx, llargval, llargbundle, ~[0u, i]);\n@@ -1005,7 +1005,7 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n         let llty = type_of_fn_from_ty(ccx, t);\n         let llfndecl = decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n         trans_fn(ccx, path, decl, body, llfndecl, no_self, none, id);\n-        ret llfndecl;\n+        return llfndecl;\n     }\n \n     fn build_shim_fn(ccx: @crate_ctxt, path: ast_map::path,\n@@ -1028,7 +1028,7 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                 vec::push(llargvals, llargval);\n                 i += 1u;\n             }\n-            ret llargvals;\n+            return llargvals;\n         }\n \n         fn build_ret(_bcx: block, _tys: @c_stack_tys,\n@@ -1040,7 +1040,7 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n         let shim_name = link::mangle_internal_name_by_path(\n             ccx, vec::append_one(path,\n                                  ast_map::path_name(@~\"__rust_stack_shim\")));\n-        ret build_shim_fn_(ccx, shim_name, llrustfn, tys,\n+        return build_shim_fn_(ccx, shim_name, llrustfn, tys,\n                            lib::llvm::CCallConv,\n                            build_args, build_ret);\n     }\n@@ -1111,7 +1111,7 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                 option::some(x86_64) {\n                     if x86_64.sret || !tys.ret_def {\n                         RetVoid(bcx);\n-                        ret;\n+                        return;\n                     }\n                     let n = vec::len(tys.arg_tys);\n                     let llretval = load_inbounds(bcx, llargbundle, ~[0u, n]);\n@@ -1153,7 +1153,7 @@ fn register_foreign_fn(ccx: @crate_ctxt, sp: span,\n     let _icx = ccx.insn_ctxt(~\"foreign::register_foreign_fn\");\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n     let (llargtys, llretty, ret_ty) = c_arg_and_ret_lltys(ccx, node_id);\n-    ret if ccx.sess.targ_cfg.arch == arch_x86_64 {\n+    return if ccx.sess.targ_cfg.arch == arch_x86_64 {\n         let ret_def = !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty);\n         let x86_64 = x86_64_tys(llargtys, llretty, ret_def);\n         do decl_x86_64_fn(x86_64) |fnty| {"}, {"sha": "6f254f867f61c7a0fee9a0d824e9ad820b7ef829", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -18,7 +18,7 @@ import std::map::hashmap;\n fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n               methods: ~[@ast::method], tps: ~[ast::ty_param]) {\n     let _icx = ccx.insn_ctxt(~\"impl::trans_impl\");\n-    if tps.len() > 0u { ret; }\n+    if tps.len() > 0u { return; }\n     let sub_path = vec::append_one(path, path_name(name));\n     for vec::each(methods) |m| {\n         if m.tps.len() == 0u {\n@@ -45,7 +45,7 @@ fn trans_self_arg(bcx: block, base: @ast::expr, derefs: uint) -> result {\n     // other arguments failing:\n     assert temp_cleanups == ~[];\n \n-    ret result;\n+    return result;\n }\n \n fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n@@ -285,7 +285,7 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)\n     -> block {\n     let _icx = bcx.insn_ctxt(~\"impl::trans_cast\");\n-    if dest == ignore { ret trans_expr(bcx, val, ignore); }\n+    if dest == ignore { return trans_expr(bcx, val, ignore); }\n     let ccx = bcx.ccx();\n     let v_ty = expr_ty(bcx, val);\n     let {bcx: bcx, box: llbox, body: body} = malloc_boxed(bcx, v_ty);"}, {"sha": "a1db7e7b4bde8236a9e35ce88729224a02f89c34", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -59,9 +59,9 @@ fn traverse_export(cx: ctx, exp_id: node_id) {\n }\n \n fn traverse_def_id(cx: ctx, did: def_id) {\n-    if did.crate != local_crate { ret; }\n+    if did.crate != local_crate { return; }\n     let n = alt cx.tcx.items.find(did.node) {\n-        none { ret; } // This can happen for self, for example\n+        none { return; } // This can happen for self, for example\n         some(n) { n }\n     };\n     alt n {\n@@ -85,7 +85,7 @@ fn traverse_public_mod(cx: ctx, m: _mod) {\n }\n \n fn traverse_public_item(cx: ctx, item: @item) {\n-    if cx.rmap.contains_key(item.id) { ret; }\n+    if cx.rmap.contains_key(item.id) { return; }\n     cx.rmap.insert(item.id, ());\n     alt item.node {\n       item_mod(m) { traverse_public_mod(cx, m); }\n@@ -151,7 +151,7 @@ fn mk_ty_visitor() -> visit::vt<ctx> {\n }\n \n fn traverse_ty(ty: @ty, cx: ctx, v: visit::vt<ctx>) {\n-    if cx.rmap.contains_key(ty.id) { ret; }\n+    if cx.rmap.contains_key(ty.id) { return; }\n     cx.rmap.insert(ty.id, ());\n \n     alt ty.node {"}, {"sha": "5b833a9153887b89b2b6662cd794d2d079f01b3a", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -37,7 +37,7 @@ impl methods for reflector {\n         let tr = type_of::type_of(self.bcx.ccx(), t);\n         let s = shape::llsize_of_real(self.bcx.ccx(), tr);\n         let a = shape::llalign_of_min(self.bcx.ccx(), tr);\n-        ret ~[self.c_uint(s),\n+        return ~[self.c_uint(s),\n              self.c_uint(a)];\n     }\n \n@@ -306,5 +306,5 @@ fn emit_calls_to_trait_visit_ty(bcx: block, t: ty::t,\n     });\n     r.visit_ty(t);\n     Br(r.bcx, final.llbb);\n-    ret final;\n+    return final;\n }"}, {"sha": "33c2323b290403c97da7df8befe1f96d43b98d81", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -43,7 +43,7 @@ fn hash_nominal_id(&&ri: nominal_id) -> uint {\n         h *= 33u;\n         h += ty::type_id(t);\n     }\n-    ret h;\n+    return h;\n }\n \n fn eq_nominal_id(&&mi: nominal_id, &&ni: nominal_id) -> bool {\n@@ -57,7 +57,7 @@ fn eq_nominal_id(&&mi: nominal_id, &&ni: nominal_id) -> bool {\n }\n \n fn new_nominal_id_hash<T: copy>() -> hashmap<nominal_id, T> {\n-    ret hashmap(hash_nominal_id, eq_nominal_id);\n+    return hashmap(hash_nominal_id, eq_nominal_id);\n }\n \n type enum_data = {did: ast::def_id, substs: ty::substs};\n@@ -113,7 +113,7 @@ fn mk_global(ccx: @crate_ctxt, name: ~str, llval: ValueRef, internal: bool) ->\n         lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n     }\n \n-    ret llglobal;\n+    return llglobal;\n }\n \n \n@@ -124,7 +124,7 @@ fn mk_global(ccx: @crate_ctxt, name: ~str, llval: ValueRef, internal: bool) ->\n fn round_up(size: u16, align: u8) -> u16 {\n     assert (align >= 1u8);\n     let alignment = align as u16;\n-    ret size - 1u16 + alignment & !(alignment - 1u16);\n+    return size - 1u16 + alignment & !(alignment - 1u16);\n }\n \n type size_align = {size: u16, align: u8};\n@@ -149,39 +149,39 @@ fn enum_kind(ccx: @crate_ctxt, did: ast::def_id) -> enum_kind {\n \n // Returns the code corresponding to the pointer size on this architecture.\n fn s_int(tcx: ty_ctxt) -> u8 {\n-    ret alt tcx.sess.targ_cfg.arch {\n+    return alt tcx.sess.targ_cfg.arch {\n         session::arch_x86 { shape_i32 }\n         session::arch_x86_64 { shape_i64 }\n         session::arch_arm { shape_i32 }\n     };\n }\n \n fn s_uint(tcx: ty_ctxt) -> u8 {\n-    ret alt tcx.sess.targ_cfg.arch {\n+    return alt tcx.sess.targ_cfg.arch {\n         session::arch_x86 { shape_u32 }\n         session::arch_x86_64 { shape_u64 }\n         session::arch_arm { shape_u32 }\n     };\n }\n \n fn s_float(tcx: ty_ctxt) -> u8 {\n-    ret alt tcx.sess.targ_cfg.arch {\n+    return alt tcx.sess.targ_cfg.arch {\n         session::arch_x86 { shape_f64 }\n         session::arch_x86_64 { shape_f64 }\n         session::arch_arm { shape_f64 }\n     };\n }\n \n fn s_variant_enum_t(tcx: ty_ctxt) -> u8 {\n-    ret s_int(tcx);\n+    return s_int(tcx);\n }\n \n fn s_tydesc(_tcx: ty_ctxt) -> u8 {\n-    ret shape_tydesc;\n+    return shape_tydesc;\n }\n \n fn s_send_tydesc(_tcx: ty_ctxt) -> u8 {\n-    ret shape_send_tydesc;\n+    return shape_send_tydesc;\n }\n \n fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n@@ -190,7 +190,7 @@ fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n         lib::llvm::llvm::LLVMAddGlobal(llmod, llshapetablesty, buf)\n     });\n \n-    ret {mut next_tag_id: 0u16,\n+    return {mut next_tag_id: 0u16,\n          pad: 0u16,\n          tag_id_to_index: new_nominal_id_hash(),\n          tag_order: dvec(),\n@@ -367,7 +367,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info) -> ~[u8] {\n     let mut s = ~[];\n     for vec::each(v.args) |t| { s += shape_of(ccx, t); }\n-    ret s;\n+    return s;\n }\n \n fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n@@ -456,7 +456,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     header += data;\n     header += lv_table;\n \n-    ret mk_global(ccx, ~\"tag_shapes\", C_bytes(header), true);\n+    return mk_global(ccx, ~\"tag_shapes\", C_bytes(header), true);\n \n /* tjc: Not annotating FIXMEs in this module because of #1498 */\n     fn largest_variants(ccx: @crate_ctxt,\n@@ -530,7 +530,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n             if candidates[i] { vec::push(result, i); }\n             i += 1u;\n         }\n-        ret result;\n+        return result;\n     }\n \n     fn compute_static_enum_size(ccx: @crate_ctxt, largest_variants: ~[uint],\n@@ -563,7 +563,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n             if max_align < align { max_align = align; }\n         }\n \n-        ret {size: max_size, align: max_align};\n+        return {size: max_size, align: max_align};\n     }\n }\n \n@@ -577,7 +577,7 @@ fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n             dtors += ~[trans::base::get_res_dtor(ccx, ri.did, id, ri.tps)];\n         }\n     }\n-    ret mk_global(ccx, ~\"resource_shapes\", C_struct(dtors), true);\n+    return mk_global(ccx, ~\"resource_shapes\", C_struct(dtors), true);\n }\n \n fn gen_shape_tables(ccx: @crate_ctxt) {\n@@ -614,13 +614,13 @@ type tag_metrics = {\n \n // Returns the number of bytes clobbered by a Store to this type.\n fn llsize_of_store(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    ret llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n+    return llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n }\n \n // Returns the number of bytes between successive elements of type T in an\n // array of T. This is the \"ABI\" size. It includes any ABI-mandated padding.\n fn llsize_of_alloc(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    ret llvm::LLVMABISizeOfType(cx.td.lltd, t) as uint;\n+    return llvm::LLVMABISizeOfType(cx.td.lltd, t) as uint;\n }\n \n // Returns, as near as we can figure, the \"real\" size of a type. As in, the\n@@ -644,7 +644,7 @@ fn llsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n // (i.e. including alignment-padding), but goodness knows which alignment it\n // winds up using. Probably the ABI one? Not recommended.\n fn llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n-    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t), cx.int_type,\n+    return llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t), cx.int_type,\n                                False);\n }\n \n@@ -653,22 +653,22 @@ fn llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n // packing the type into structs. This will be used for things like\n // allocations inside a stack frame, which LLVM has a free hand in.\n fn llalign_of_pref(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    ret llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t) as uint;\n+    return llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t) as uint;\n }\n \n // Returns the minimum alignment of a type required by the plattform.\n // This is the alignment that will be used for struct fields, arrays,\n // and similar ABI-mandated things.\n fn llalign_of_min(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    ret llvm::LLVMABIAlignmentOfType(cx.td.lltd, t) as uint;\n+    return llvm::LLVMABIAlignmentOfType(cx.td.lltd, t) as uint;\n }\n \n // Returns the \"default\" alignment of t, which is calculated by casting\n // null to a record containing a single-bit followed by a t value, then\n // doing gep(0,1) to get at the trailing (and presumably padded) t cell.\n fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n-    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMAlignOf(t), cx.int_type,\n-                               False);\n+    return llvm::LLVMConstIntCast(\n+        lib::llvm::llvm::LLVMAlignOf(t), cx.int_type, False);\n }\n \n // Computes the static size of a enum, without using mk_tup(), which is\n@@ -678,7 +678,7 @@ fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n \n // Computes the size of the data part of an enum.\n fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n-    if cx.enum_sizes.contains_key(t) { ret cx.enum_sizes.get(t); }\n+    if cx.enum_sizes.contains_key(t) { return cx.enum_sizes.get(t); }\n     alt ty::get(t).struct {\n       ty::ty_enum(tid, substs) {\n         // Compute max(variant sizes).\n@@ -695,7 +695,7 @@ fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n             if max_size < this_size { max_size = this_size; }\n         }\n         cx.enum_sizes.insert(t, max_size);\n-        ret max_size;\n+        return max_size;\n       }\n       _ { cx.sess.bug(~\"static_size_of_enum called on non-enum\"); }\n     }"}, {"sha": "213117f15f4d7070d9928c775d7b70f6b49350cf", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -57,7 +57,7 @@ fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(~\"tvec::pointer_add\");\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, T_ptr(T_i8()));\n-    ret PointerCast(bcx, InBoundsGEP(bcx, bptr, ~[bytes]), old_ty);\n+    return PointerCast(bcx, InBoundsGEP(bcx, bptr, ~[bytes]), old_ty);\n }\n \n fn alloc_raw(bcx: block, unit_ty: ty::t,\n@@ -72,7 +72,7 @@ fn alloc_raw(bcx: block, unit_ty: ty::t,\n         base::malloc_general_dyn(bcx, vecbodyty, heap, vecsize);\n     Store(bcx, fill, GEPi(bcx, body, ~[0u, abi::vec_elt_fill]));\n     Store(bcx, alloc, GEPi(bcx, body, ~[0u, abi::vec_elt_alloc]));\n-    ret {bcx: bcx, val: box};\n+    return {bcx: bcx, val: box};\n }\n fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n                   fill: ValueRef, alloc: ValueRef) -> result {\n@@ -89,7 +89,7 @@ fn alloc_vec(bcx: block, unit_ty: ty::t, elts: uint, heap: heap) -> result {\n     let alloc = if elts < 4u { Mul(bcx, C_int(ccx, 4), unit_sz) }\n                 else { fill };\n     let {bcx: bcx, val: vptr} = alloc_raw(bcx, unit_ty, fill, alloc, heap);\n-    ret {bcx: bcx, val: vptr};\n+    return {bcx: bcx, val: vptr};\n }\n \n fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n@@ -106,7 +106,7 @@ fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n     let bcx = if ty::type_needs_drop(bcx.tcx(), unit_ty) {\n         iter_vec_raw(bcx, new_data_ptr, vec_ty, fill, base::take_ty)\n     } else { bcx };\n-    ret rslt(bcx, newptr);\n+    return rslt(bcx, newptr);\n }\n \n fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n@@ -127,7 +127,7 @@ fn trans_evec(bcx: block, args: ~[@ast::expr],\n         for vec::each(args) |arg| {\n             bcx = base::trans_expr(bcx, arg, base::ignore);\n         }\n-        ret bcx;\n+        return bcx;\n     }\n \n     let vec_ty = node_id_type(bcx, id);\n@@ -205,13 +205,13 @@ fn trans_evec(bcx: block, args: ~[@ast::expr],\n     alt vst {\n       ast::vstore_fixed(_) {\n         // We wrote into the destination in the fixed case.\n-        ret bcx;\n+        return bcx;\n       }\n       ast::vstore_slice(_) {\n-        ret base::store_in_dest(bcx, Load(bcx, val), dest);\n+        return base::store_in_dest(bcx, Load(bcx, val), dest);\n       }\n       _ {\n-        ret base::store_in_dest(bcx, val, dest);\n+        return base::store_in_dest(bcx, val, dest);\n       }\n     }\n }\n@@ -220,10 +220,10 @@ fn trans_vstore(bcx: block, e: @ast::expr,\n                 v: ast::vstore, dest: dest) -> block {\n     alt e.node {\n       ast::expr_lit(@{node: ast::lit_str(s), span: _}) {\n-        ret trans_estr(bcx, s, v, dest);\n+        return trans_estr(bcx, s, v, dest);\n       }\n       ast::expr_vec(es, mutbl) {\n-        ret trans_evec(bcx, es, v, e.id, dest);\n+        return trans_evec(bcx, es, v, e.id, dest);\n       }\n       _ {\n         bcx.sess().span_bug(e.span, ~\"vstore on non-sequence type\");\n@@ -269,7 +269,7 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n fn trans_estr(bcx: block, s: @~str, vstore: ast::vstore,\n               dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(~\"tvec::trans_estr\");\n-    if dest == base::ignore { ret bcx; }\n+    if dest == base::ignore { return bcx; }\n     let ccx = bcx.ccx();\n \n     let c = alt vstore {\n@@ -338,7 +338,7 @@ fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n                                            ~[C_int(bcx.ccx(), 1)]),\n                      body_cx.llbb);\n     Br(body_cx, header_cx.llbb);\n-    ret next_cx;\n+    return next_cx;\n \n }\n \n@@ -354,7 +354,7 @@ fn iter_vec_unboxed(bcx: block, body_ptr: ValueRef, vec_ty: ty::t,\n     let _icx = bcx.insn_ctxt(~\"tvec::iter_vec_unboxed\");\n     let fill = get_fill(bcx, body_ptr);\n     let dataptr = get_dataptr(bcx, body_ptr);\n-    ret iter_vec_raw(bcx, dataptr, vec_ty, fill, f);\n+    return iter_vec_raw(bcx, dataptr, vec_ty, fill, f);\n }\n \n //"}, {"sha": "79cd20bb36e2d38f39abd82a72eeb5f589d691f9", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -36,7 +36,7 @@ fn type_of_fn(cx: @crate_ctxt, inputs: ~[ty::arg],\n \n     // ... then explicit args.\n     vec::push_all(atys, type_of_explicit_args(cx, inputs));\n-    ret T_fn(atys, llvm::LLVMVoidType());\n+    return T_fn(atys, llvm::LLVMVoidType());\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n@@ -69,7 +69,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     debug!{\"type_of %?: %?\", t, ty::get(t)};\n \n     // Check the cache.\n-    if cx.lltypes.contains_key(t) { ret cx.lltypes.get(t); }\n+    if cx.lltypes.contains_key(t) { return cx.lltypes.get(t); }\n \n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain\n@@ -188,7 +188,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         }\n     };\n \n-    ret llty;\n+    return llty;\n }\n \n // This should only be called from type_of, above, because it\n@@ -221,7 +221,7 @@ fn type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     };\n \n     common::set_struct_body(named_llty, lltys);\n-    ret named_llty;\n+    return named_llty;\n }\n \n fn llvm_type_name(cx: @crate_ctxt, t: ty::t) -> ~str {\n@@ -233,7 +233,7 @@ fn llvm_type_name(cx: @crate_ctxt, t: ty::t) -> ~str {\n         (~\"class\", did, substs.tps)\n       }\n     };\n-    ret fmt!{\n+    return fmt!{\n         \"%s %s[#%d]\",\n         name,\n         util::ppaux::parameterized("}, {"sha": "486ea2da835ebea26c70b42c7122e46e1f26e6f9", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -36,7 +36,7 @@ type ctx = {ccx: @crate_ctxt,\n fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     -> ~[type_uses] {\n     alt ccx.type_use_cache.find(fn_id) {\n-      some(uses) { ret uses; }\n+      some(uses) { return uses; }\n       none {}\n     }\n     let fn_id_loc = if fn_id.crate == local_crate { fn_id }\n@@ -57,7 +57,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     if fn_id_loc.crate != local_crate {\n         let uses = vec::from_mut(copy cx.uses);\n         ccx.type_use_cache.insert(fn_id, uses);\n-        ret uses;\n+        return uses;\n     }\n     let map_node = alt ccx.tcx.items.find(fn_id_loc.node) {\n         some(x) { x }"}, {"sha": "e51d4e4d4547b54485f2a66712a4a3e48b93a272", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -28,7 +28,7 @@ fn content_ty(t: ty::t) -> ty::t {\n fn autoderef(bcx: block, v: ValueRef, t: ty::t) -> {v: ValueRef, t: ty::t} {\n     let content_ty = content_ty(t);\n     let v = opaque_box_body(bcx, content_ty, v);\n-    ret {v: v, t: content_ty};\n+    return {v: v, t: content_ty};\n }\n \n fn duplicate(bcx: block, v: ValueRef, t: ty::t) -> result {\n@@ -52,5 +52,5 @@ fn duplicate(bcx: block, v: ValueRef, t: ty::t) -> result {\n     let td = Load(bcx, src_tydesc_ptr);\n     Store(bcx, td, dst_tydesc_ptr);\n \n-    ret rslt(bcx, dst_box);\n+    return rslt(bcx, dst_box);\n }"}, {"sha": "cbd255341f5fe19a94013f5a02b9500e054ffc53", "filename": "src/rustc/middle/tstate/ann.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32", "patch": "@@ -41,14 +41,18 @@ type pre_and_post_state = {prestate: prestate, poststate: poststate};\n \n type ts_ann = {conditions: pre_and_post, states: pre_and_post_state};\n \n-fn true_precond(num_vars: uint) -> precond { ret create_tritv(num_vars); }\n+fn true_precond(num_vars: uint) -> precond { return create_tritv(num_vars); }\n \n-fn true_postcond(num_vars: uint) -> postcond { ret true_precond(num_vars); }\n+fn true_postcond(num_vars: uint) -> postcond {\n+    return true_precond(num_vars);\n+}\n \n-fn empty_prestate(num_vars: uint) -> prestate { ret true_precond(num_vars); }\n+fn empty_prestate(num_vars: uint) -> prestate {\n+    return true_precond(num_vars);\n+}\n \n fn empty_poststate(num_vars: uint) -> poststate {\n-    ret true_precond(num_vars);\n+    return true_precond(num_vars);\n }\n \n fn false_postcond(num_vars: uint) -> postcond {\n@@ -58,23 +62,23 @@ fn false_postcond(num_vars: uint) -> postcond {\n }\n \n fn empty_pre_post(num_vars: uint) -> pre_and_post {\n-    ret {precondition: empty_prestate(num_vars),\n+    return {precondition: empty_prestate(num_vars),\n          postcondition: empty_poststate(num_vars)};\n }\n \n fn empty_states(num_vars: uint) -> pre_and_post_state {\n-    ret {prestate: true_precond(num_vars),\n+    return {prestate: true_precond(num_vars),\n          poststate: true_postcond(num_vars)};\n }\n \n fn empty_ann(num_vars: uint) -> ts_ann {\n-    ret {conditions: empty_pre_post(num_vars),\n+    return {conditions: empty_pre_post(num_vars),\n          states: empty_states(num_vars)};\n }\n \n-fn get_pre(&&p: pre_and_post) -> precond { ret p.precondition; }\n+fn get_pre(&&p: pre_and_post) -> precond { return p.precondition; }\n \n-fn get_post(&&p: pre_and_post) -> postcond { ret p.postcondition; }\n+fn get_post(&&p: pre_and_post) -> postcond { return p.postcondition; }\n \n fn difference(p1: precond, p2: precond) -> bool { p1.difference(p2) }\n \n@@ -86,7 +90,7 @@ fn pps_len(p: pre_and_post) -> uint {\n     // gratuitous check\n \n     assert (p.precondition.nbits == p.postcondition.nbits);\n-    ret p.precondition.nbits;\n+    return p.precondition.nbits;\n }\n \n fn require(i: uint, p: pre_and_post) {\n@@ -102,54 +106,54 @@ fn require_and_preserve(i: uint, p: pre_and_post) {\n \n fn set_in_postcond(i: uint, p: pre_and_post) -> bool {\n     // sets the ith bit in p's post\n-    ret set_in_postcond_(i, p.postcondition);\n+    return set_in_postcond_(i, p.postcondition);\n }\n \n fn set_in_postcond_(i: uint, p: postcond) -> bool {\n     let was_set = p.get(i);\n     p.set(i, ttrue);\n-    ret was_set != ttrue;\n+    return was_set != ttrue;\n }\n \n fn set_in_poststate(i: uint, s: pre_and_post_state) -> bool {\n     // sets the ith bit in p's post\n-    ret set_in_poststate_(i, s.poststate);\n+    return set_in_poststate_(i, s.poststate);\n }\n \n fn set_in_poststate_(i: uint, p: poststate) -> bool {\n     let was_set = p.get(i);\n     p.set(i, ttrue);\n-    ret was_set != ttrue;\n+    return was_set != ttrue;\n \n }\n \n fn clear_in_poststate(i: uint, s: pre_and_post_state) -> bool {\n     // sets the ith bit in p's post\n-    ret clear_in_poststate_(i, s.poststate);\n+    return clear_in_poststate_(i, s.poststate);\n }\n \n fn clear_in_poststate_(i: uint, s: poststate) -> bool {\n     let was_set = s.get(i);\n     s.set(i, tfalse);\n-    ret was_set != tfalse;\n+    return was_set != tfalse;\n }\n \n fn clear_in_prestate(i: uint, s: pre_and_post_state) -> bool {\n     // sets the ith bit in p's pre\n-    ret clear_in_prestate_(i, s.prestate);\n+    return clear_in_prestate_(i, s.prestate);\n }\n \n fn clear_in_prestate_(i: uint, s: prestate) -> bool {\n     let was_set = s.get(i);\n     s.set(i, tfalse);\n-    ret was_set != tfalse;\n+    return was_set != tfalse;\n }\n \n fn clear_in_postcond(i: uint, s: pre_and_post) -> bool {\n     // sets the ith bit in p's post\n     let was_set = s.postcondition.get(i);\n     s.postcondition.set(i, tfalse);\n-    ret was_set != tfalse;\n+    return was_set != tfalse;\n }\n \n // Sets all the bits in a's precondition to equal the\n@@ -195,12 +199,12 @@ fn extend_poststate(p: poststate, newv: poststate) -> bool {\n fn relax_prestate(i: uint, p: prestate) -> bool {\n     let was_set = p.get(i);\n     p.set(i, dont_care);\n-    ret was_set != dont_care;\n+    return was_set != dont_care;\n }\n \n // Clears the given bit in p\n fn relax_poststate(i: uint, p: poststate) -> bool {\n-    ret relax_prestate(i, p);\n+    return relax_prestate(i, p);\n }\n \n // Clears the given bit in p\n@@ -212,14 +216,14 @@ fn clear(p: precond) { p.clear(); }\n // Sets all the bits in p to true\n fn set(p: precond) { p.set_all(); }\n \n-fn ann_precond(a: ts_ann) -> precond { ret a.conditions.precondition; }\n+fn ann_precond(a: ts_ann) -> precond { return a.conditions.precondition; }\n \n-fn ann_prestate(a: ts_ann) -> prestate { ret a.states.prestate; }\n+fn ann_prestate(a: ts_ann) -> prestate { return a.states.prestate; }\n \n-fn ann_poststate(a: ts_ann) -> poststate { ret a.states.poststate; }\n+fn ann_poststate(a: ts_ann) -> poststate { return a.states.poststate; }\n \n fn pp_clone(p: pre_and_post) -> pre_and_post {\n-    ret {precondition: clone(p.precondition),\n+    return {precondition: clone(p.precondition),\n          postcondition: clone(p.postcondition)};\n }\n "}, {"sha": "aa249fc360449463b302472abead06f3da03fe0e", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "c6f46ba388858e9d4404f7c298473b373eeb072e", "filename": "src/rustc/middle/tstate/collect_locals.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "9315e69d2891041279e4c191a3c8b0e3e92f0332", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "b134f3b71af49873a5970c82f974cacdf6b0c772", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 49, "deletions": 46, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "ee2cf2d7a14c4be09feb7589ffaeefef7151494d", "filename": "src/rustc/middle/tstate/tritv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "ff52e34fdad748e6e3c8b6b7b68adb1789cbc85f", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 115, "deletions": 111, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "adc47d5fad4585fe0944c8f97929457bb669112a", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "632a29ba8e8738c1fa8d43ea626b6d475dee392d", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "862bf2cfaa427ae8a49afb9a22edfe02d70bb236", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "b0106f44cfc32ebc1968c761f6ea6f91b19baa3f", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "efd2756a607c168c856b28fe7ab3304da9f6fda4", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "6e9293dd8e9dd14649bab05322ee82ef5891198b", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "a2bfc9c3ffaf757a079d4f39915edb045d9b5282", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "a4b8bf021e1358088495d13556d02048747f0866", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "726cc2a7c70d4501ef9a43269634044287c94d83", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "4de713030d9a992449f512efc0e216d79857fef5", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "aab71d1b72bb8b54de25edd430d8c68f7b57e5b6", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "b1ad11327a7a4d2a9109e38dc9d888a8674bd08c", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "ff4baccc42eeff5cbc7f126130792c748b9dd38b", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "7fb7d4c83cb9ffc28573393aabae8aad9f8f7037", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "cd931578c32cb40723dc6bec0f05fb05d139141c", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "5300ebe1a3b5953fd13106181921ebaec41a06ce", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "37a76f936d293a1f314f4b8d1632ee43b75c2ab7", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "7280786db7eaa1b14cf76cfc9d639b39d418eed8", "filename": "src/rustdoc/markdown_index_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_index_pass.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "9337f531a31b82622193b8008774b8dea13668e2", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "08e39ba53dad01734cfa9c8ead5b02801fc75632", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "eed559367d31ad3b13c814dc45f237b33cd42a89", "filename": "src/rustdoc/page_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpage_pass.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "b6d225df98e6a8efb05f410b6bf31b6aea529261", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "417719668813f40dbbd48dc6f9af0c4179b3a7be", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "be2c982799b9cbde71a0c5ef714d56eb853b4ff6", "filename": "src/test/auxiliary/cci_class_4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "36642db378f156bba53dd1e341a285a482cf6f61", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "31ee535fcab3a56d586ce025d4190669ad414d0a", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "007ef3bcc43983b9bfa8c623e81847b1d9b9c591", "filename": "src/test/auxiliary/test_comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftest_comm.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "b32047755ee045431526fae4860aa0bd86d02d6b", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "d950abb99be0af0132a1f1ebd56dfee5a760faa2", "filename": "src/test/bench/core-vec-append.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-vec-append.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "497f964b18ab339a55883895b849548aaabcbfd1", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "291e7c2dba51639d598ab994e40dc177a8fb23ca", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "aadf892901589980ddc2931a75c1303721219429", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "8882b5ae7c766f497cc99c2cb20205b8375c0ef3", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "e5eab3b78f47a8d3dbfa6f7ddca0de632abaec8c", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "a1cb893389357d572d703b1b25a797629c34b924", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "4e8cfff4ad2e7af410b97e0535d2c2b5e9c1911a", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "d02fe7770c5d29278bf0d894894f6d43b50f5f24", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "d5beee9ff08bd101c741d4656140d3ca8b7a84bb", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "0082bc6ad03c60caa2a2792ab29423884847ff47", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "2d2f9377820df2b29a220237fb53398efb502f03", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "36df950a2b76f0a5a1b1fad387e8bb7647140e4f", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "fc22b99f59c9242c9cf9de92f33d2e1cfb7b44f4", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "8192143faa2f672fe122a7d55f27a81d5af9a9ff", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "01b949e312cc1ebaffd256e3f010ec38408ce14e", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "fab48c0d55902fec60bef850f09ccf65babc1173", "filename": "src/test/compile-fail/bad-bang-ann-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-3.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "73152fba0edc4ffcb0524abef7df16c6c8064013", "filename": "src/test/compile-fail/block-arg-used-as-lambda-with-illegal-cap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fblock-arg-used-as-lambda-with-illegal-cap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fblock-arg-used-as-lambda-with-illegal-cap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-arg-used-as-lambda-with-illegal-cap.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "f407d3626037ea94a50878beafe30f96768fa64a", "filename": "src/test/compile-fail/block-coerce-no.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "964ea5c77500c9a0a56a407011e754885608bc2a", "filename": "src/test/compile-fail/block-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fblock-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fblock-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-copy.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "71bba89fb77df92c806577e657643897855b3a31", "filename": "src/test/compile-fail/borrowck-move-from-unsafe-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fborrowck-move-from-unsafe-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fborrowck-move-from-unsafe-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-from-unsafe-ptr.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "da394fbf37206ce49df5f3af7a30743f043d0508", "filename": "src/test/compile-fail/borrowck-mut-vec-as-imm-slice-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "f7863013898fc990bb3125a373a446027cfbac9b", "filename": "src/test/compile-fail/cap-clause-illegal-cap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fcap-clause-illegal-cap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fcap-clause-illegal-cap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-illegal-cap.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "053e2f5ca7fac21bdf361e4cb0179481e4b6f8d3", "filename": "src/test/compile-fail/capture1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fcapture1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fcapture1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcapture1.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "159e881ee8a1b3a64212443021643ddb759cf481", "filename": "src/test/compile-fail/class-cast-to-iface.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-iface.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "4ad79f570aed6cefa6e800dc1330fa12ceb83997", "filename": "src/test/compile-fail/constrained-type-missing-check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fconstrained-type-missing-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fconstrained-type-missing-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconstrained-type-missing-check.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "2f46bd2d4735d5e5247400b6c534728a84b08656", "filename": "src/test/compile-fail/dead-code-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "697a135d0cc956d3f1d499588262fa23cef0ef74", "filename": "src/test/compile-fail/for-loop-decl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "12125422a948c7215f216fb5d869b0321095c761", "filename": "src/test/compile-fail/fully-qualified-type-name2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name2.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "8c4f976f1b3cca2adb537b2ada0ef4c171018904", "filename": "src/test/compile-fail/fully-qualified-type-name3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name3.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "00eb743422472cab9318dd7044dddc471a659173", "filename": "src/test/compile-fail/fully-qualified-type-name4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name4.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "736634c13e869dff9ff96dcc718d95ec565e4ec6", "filename": "src/test/compile-fail/iface-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fiface-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fiface-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fiface-cast.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "a3be8b17604fca95e558d8ab659eb7af7ce353aa", "filename": "src/test/compile-fail/import-glob-circular.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "d6ab1e44211d04eb9db9d4ea710b10287b1be988", "filename": "src/test/compile-fail/issue-1193.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fissue-1193.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fissue-1193.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1193.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "1da1289f18ea8136da37fe9449a51c68e83db959", "filename": "src/test/compile-fail/issue-1448-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fissue-1448-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fissue-1448-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1448-1.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "7234ca9e9e166f47e3837d2ff53805a3bd0a738e", "filename": "src/test/compile-fail/issue-2150.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "82aeb1c8da2b2fa1817e6ffe87a06acc2a13bf18", "filename": "src/test/compile-fail/issue-3021-d.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "ebf3b5e986eb5b8b7d0ffb01997a0d331f7da8b9", "filename": "src/test/compile-fail/issue-897-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fissue-897-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fissue-897-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-897-2.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "f53d880d10b81d0c565da119fa5f281dbcff5d95", "filename": "src/test/compile-fail/issue-897.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fissue-897.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fissue-897.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-897.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "7eff11daea182a9ffece69476aa90ead28f2b796", "filename": "src/test/compile-fail/lambda-mutate-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "15b9bcd846974a0b34550dc026b3b80c00a41a2a", "filename": "src/test/compile-fail/lambda-mutate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Flambda-mutate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Flambda-mutate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flambda-mutate.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "029d0aef9daed9ef9f0c806d36f1513a77e3fd8c", "filename": "src/test/compile-fail/liveness-break-uninit-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit-2.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "3729d2e8b22f683d882e72828ff888568ddc7242", "filename": "src/test/compile-fail/liveness-break-uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "84d0ccd641e9a95c943f04662ef550adcf5e5671", "filename": "src/test/compile-fail/liveness-forgot-ret.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fliveness-forgot-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fliveness-forgot-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-forgot-ret.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "59bbe0e14c86c67d5261f249551dfaca1a95914a", "filename": "src/test/compile-fail/liveness-init-in-called-fn-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-called-fn-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-called-fn-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-called-fn-expr.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "ebd128905d85ad8d035a0f5906cfc90274a31608", "filename": "src/test/compile-fail/liveness-init-in-fn-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-fn-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-fn-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-fn-expr.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "8cb365afbf6fb11bc35edeb0566a82c84412bf51", "filename": "src/test/compile-fail/liveness-missing-ret2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "c993ddd24b78c3d979fdcdef0c88f1655cb11d40", "filename": "src/test/compile-fail/liveness-return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fliveness-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fliveness-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-return.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "cfa555b1e352e165f81cd08593f16db12c86b6fd", "filename": "src/test/compile-fail/liveness-while.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fliveness-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fliveness-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-while.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "6f9b74a4ad7f9519a0866f3ff7b285cac9ec1a0f", "filename": "src/test/compile-fail/loop-does-not-diverge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Floop-does-not-diverge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Floop-does-not-diverge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Floop-does-not-diverge.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "c2c3d0127c523f3d1dd82b0981b5d954bf0c81b7", "filename": "src/test/compile-fail/macro-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "54d4d8e4817af8bf7efc68bed90aa5ef64337705", "filename": "src/test/compile-fail/nested-ty-params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fnested-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fnested-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnested-ty-params.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "3e9648e19c95ce2ec2029ea3a3d1531d65743ea4", "filename": "src/test/compile-fail/pattern-tyvar-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "bcc23d3c0d9c7859762c3d1aec5fbef4559905c7", "filename": "src/test/compile-fail/pure-loop-body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fpure-loop-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fpure-loop-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-loop-body.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "e795c5b86865559105622d24129857c3d145b559", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "02780c70ed8aafdfe29424c9aada32586ad0e248", "filename": "src/test/compile-fail/regions-creating-enums.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "98b9797df62b0fe66f26c5239dbceee58c0de614", "filename": "src/test/compile-fail/regions-iface-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fregions-iface-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fregions-iface-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-iface-2.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "a0be6c901771619f87ea9dfe369f78364e9486a2", "filename": "src/test/compile-fail/regions-iface-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fregions-iface-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fregions-iface-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-iface-3.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "dd2968504ee4f156071ca02f8bec08a0d4dc847b", "filename": "src/test/compile-fail/regions-infer-borrow-scope-too-big.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "04c5145cbf2ef05ccb966c0c4555bd1a6a7b16c8", "filename": "src/test/compile-fail/regions-nested-fns-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "9d9116d10b259159754ac4aaf2de244322c69ab1", "filename": "src/test/compile-fail/regions-nested-fns.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "b764fdbff9da4d31b55bb5c907b8f78176a2ed69", "filename": "src/test/compile-fail/regions-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fregions-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fregions-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "7b996cf4735d523d4a333e4d4acd5cbd2d805ae7", "filename": "src/test/compile-fail/regions-scoping.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "ad9fcef4f5205651521fbbfeae387fa859f571c2", "filename": "src/test/compile-fail/ret-non-nil.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "081c400d71d180d80a23634eb14037d39e3fb67a", "filename": "src/test/compile-fail/sendfn-is-not-a-lambda.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fsendfn-is-not-a-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fsendfn-is-not-a-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsendfn-is-not-a-lambda.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "844fa8b285ec9188d6ac982466fbc83a730e3b72", "filename": "src/test/compile-fail/tail-typeck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Ftail-typeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Ftail-typeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftail-typeck.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "93ad8a72ac3ff023c595849f06f6c4908b59007c", "filename": "src/test/compile-fail/tps-invariant-iface.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Ftps-invariant-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Ftps-invariant-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftps-invariant-iface.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "98670900da5b989eb64da86e73b17d9b616a78ca", "filename": "src/test/compile-fail/unsafe-fn-assign-deref-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "a6ce6e2033a79cd5ed65ac92ae1a3c7ab5026bd0", "filename": "src/test/compile-fail/unsafe-fn-autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Funsafe-fn-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Funsafe-fn-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-autoderef.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "08df19de65862e8612c15f1a205d64a70169be94", "filename": "src/test/compile-fail/unsafe-fn-called-from-safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Funsafe-fn-called-from-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Funsafe-fn-called-from-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-called-from-safe.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "affa1dc7ac48e118cc064141c9f45d05b8942452", "filename": "src/test/compile-fail/unsafe-fn-deref-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Funsafe-fn-deref-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Funsafe-fn-deref-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-deref-ptr.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "f71f36f3f607c936b1889fce6a52fb281f016a46", "filename": "src/test/compile-fail/unsafe-fn-used-as-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Funsafe-fn-used-as-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Funsafe-fn-used-as-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-used-as-value.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "be716bf8804f98211de8320596260dd88ffd21ee", "filename": "src/test/compile-fail/unused-imports-warn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Funused-imports-warn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Funused-imports-warn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-imports-warn.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "afbb57f58782e7046ad501d77591ebbd648bea00", "filename": "src/test/compile-fail/vec-concat-bug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "9db0a582c34e1bea00bfdf5e1767f343c821d441", "filename": "src/test/compile-fail/wrong-ret-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fwrong-ret-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fcompile-fail%2Fwrong-ret-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwrong-ret-type.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "3ef46a721aeb8526aba26b3278f7ad6d9654c268", "filename": "src/test/pretty/blank-lines.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fpretty%2Fblank-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fpretty%2Fblank-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblank-lines.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "ea4563a579c2b4789d69d1fdb514f2082eaf8a5e", "filename": "src/test/pretty/block-arg-disambig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fpretty%2Fblock-arg-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fpretty%2Fblock-arg-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-arg-disambig.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "61323152af10720d7c4bf5284ef4f2aa3dabe077", "filename": "src/test/pretty/disamb-stmt-expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "5a1d410bec1c1dc72124c3c368cd9afd4198a20f", "filename": "src/test/run-fail/expr-alt-fail-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-fail%2Fexpr-alt-fail-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-fail%2Fexpr-alt-fail-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexpr-alt-fail-fn.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "31989707f4fcea38085f502b0ea1bd757262b071", "filename": "src/test/run-fail/expr-if-fail-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-fail%2Fexpr-if-fail-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-fail%2Fexpr-if-fail-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexpr-if-fail-fn.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "e6f109745ae617bca66adda64efb9996d765dca3", "filename": "src/test/run-fail/if-check-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-fail%2Fif-check-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-fail%2Fif-check-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fif-check-fail.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "ea25bb765452bef821e8450cd37b5b8da02dd1f9", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "85bceea0ca254b16693eddb7414a883fcbbaf60d", "filename": "src/test/run-fail/zip-different-lengths.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "5d7a11ca0d8fe6c368305764262a39bbd6b05cb9", "filename": "src/test/run-pass-fulldeps/issue-1926.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "699ee7ada703670cee32f68b5a339404afb94ab0", "filename": "src/test/run-pass/alias-uninit-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "2a1599cd074267ca6d54915190f2606736bd4df1", "filename": "src/test/run-pass/alloca-from-derived-tydesc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "341fcdc38d51b11dc48e8e1308c00649cf97e36b", "filename": "src/test/run-pass/alt-bot-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Falt-bot-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Falt-bot-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-bot-2.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "2ba2fedb386a87ccc6c32523d5998f76faee5534", "filename": "src/test/run-pass/alt-join.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-join.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "aba7336a23b6b9fa2b8212f220dc87fe495ffb23", "filename": "src/test/run-pass/alt-pattern-lit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "f58eb29edb295246c734c5acb86584229fc25d91", "filename": "src/test/run-pass/alt-tag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Falt-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Falt-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-tag.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "74a7e36a6e62bf6d5c5131e22d17e6b3c2122595", "filename": "src/test/run-pass/alt-with-ret-arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "1d1ae9c785fedc2c417ce86b06f48cbe8dc911e1", "filename": "src/test/run-pass/argument-passing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargument-passing.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "e8d8a3821d17a3ff0046e35324a28f088fd7bc40", "filename": "src/test/run-pass/artificial-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Fartificial-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Fartificial-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fartificial-block.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "b5a3fd8af61234d326db736329a9f37f2f0d71bd", "filename": "src/test/run-pass/assignability-iface.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Fassignability-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Fassignability-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-iface.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}, {"sha": "522ead87c738b1a6725ec01bb45b9d39051e99e0", "filename": "src/test/run-pass/auto-instantiate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b355936b4da0831f47afe8f251daee503c8caa32/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs?ref=b355936b4da0831f47afe8f251daee503c8caa32"}]}