{"sha": "7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "node_id": "C_kwDOAAsO6NoAKDdiM2JkNTZlZDk5ZDUwMzFmNTdiMWFhZjgxNDExN2IyYTdjZTljODQ", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-03-15T14:41:48Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-03-15T14:41:48Z"}, "message": "Merge commit 'dec0daa8f6d0a0e1c702f169abb6bf3eee198c67' into sync_cg_clif-2023-03-15", "tree": {"sha": "88e4d7dd16d168ae7700eb2433827d30cbe898bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88e4d7dd16d168ae7700eb2433827d30cbe898bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "html_url": "https://github.com/rust-lang/rust/commit/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c122a8926274dc6bdedcbef7974539f05af627a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c122a8926274dc6bdedcbef7974539f05af627a", "html_url": "https://github.com/rust-lang/rust/commit/2c122a8926274dc6bdedcbef7974539f05af627a"}], "stats": {"total": 1665, "additions": 873, "deletions": 792}, "files": [{"sha": "5f5510a579654afa30a0260b128800fd0018ad61", "filename": ".github/workflows/abi-cafe.yml", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/.github%2Fworkflows%2Fabi-cafe.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/.github%2Fworkflows%2Fabi-cafe.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fabi-cafe.yml?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -0,0 +1,64 @@\n+name: Abi-cafe\n+\n+on:\n+  - push\n+\n+jobs:\n+  abi_cafe:\n+    runs-on: ${{ matrix.os }}\n+    timeout-minutes: 60\n+    concurrency:\n+      group: ${{ github.workflow }}-${{ github.ref }}-${{ matrix.os }}-${{ matrix.env.TARGET_TRIPLE }}\n+      cancel-in-progress: true\n+\n+    defaults:\n+      run:\n+        shell: bash\n+\n+    strategy:\n+      fail-fast: true\n+      matrix:\n+        include:\n+          - os: ubuntu-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-unknown-linux-gnu\n+          - os: macos-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-apple-darwin\n+          - os: windows-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-msvc\n+          - os: windows-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-gnu\n+\n+    steps:\n+    - uses: actions/checkout@v3\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v3\n+      with:\n+        path: build/cg_clif\n+        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+\n+    - name: Set MinGW as the default toolchain\n+      if: matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n+      run: rustup set default-host x86_64-pc-windows-gnu\n+\n+    - name: Use sparse cargo registry\n+      run: |\n+        cat >> ~/.cargo/config.toml <<EOF\n+        [unstable]\n+        sparse-registry = true\n+        EOF\n+\n+    - name: Prepare dependencies\n+      run: ./y.rs prepare\n+\n+    - name: Build\n+      run: ./y.rs build --sysroot none\n+\n+    - name: Test abi-cafe\n+      env:\n+        TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n+      run: ./y.rs abi-cafe"}, {"sha": "98b34c65dea591284f9d30e7fb7c541891578fd3", "filename": ".github/workflows/main.yml", "status": "modified", "additions": 1, "deletions": 58, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fmain.yml?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -22,7 +22,7 @@ jobs:\n         rustfmt --check build_system/mod.rs\n \n \n-  build:\n+  test:\n     runs-on: ${{ matrix.os }}\n     timeout-minutes: 60\n \n@@ -114,63 +114,6 @@ jobs:\n       run: ./y.rs test\n \n \n-  abi_cafe:\n-    runs-on: ${{ matrix.os }}\n-    timeout-minutes: 60\n-\n-    defaults:\n-      run:\n-        shell: bash\n-\n-    strategy:\n-      fail-fast: true\n-      matrix:\n-        include:\n-          - os: ubuntu-latest\n-            env:\n-              TARGET_TRIPLE: x86_64-unknown-linux-gnu\n-          - os: macos-latest\n-            env:\n-              TARGET_TRIPLE: x86_64-apple-darwin\n-          - os: windows-latest\n-            env:\n-              TARGET_TRIPLE: x86_64-pc-windows-msvc\n-          - os: windows-latest\n-            env:\n-              TARGET_TRIPLE: x86_64-pc-windows-gnu\n-\n-    steps:\n-    - uses: actions/checkout@v3\n-\n-    - name: Cache cargo target dir\n-      uses: actions/cache@v3\n-      with:\n-        path: build/cg_clif\n-        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n-\n-    - name: Set MinGW as the default toolchain\n-      if: matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n-      run: rustup set default-host x86_64-pc-windows-gnu\n-\n-    - name: Use sparse cargo registry\n-      run: |\n-        cat >> ~/.cargo/config.toml <<EOF\n-        [unstable]\n-        sparse-registry = true\n-        EOF\n-\n-    - name: Prepare dependencies\n-      run: ./y.rs prepare\n-\n-    - name: Build\n-      run: ./y.rs build --sysroot none\n-\n-    - name: Test abi-cafe\n-      env:\n-        TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n-      run: ./y.rs abi-cafe\n-\n-\n   bench:\n     runs-on: ubuntu-latest\n     timeout-minutes: 60"}, {"sha": "e5d10a937ae2497a7deb53af1554123c846cce8e", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -14,3 +14,4 @@ perf.data.old\n /dist\n /rust\n /download\n+/git-fixed-subtree.sh"}, {"sha": "157ef4bf3892ecb9ddaba4e22cedad0baf3f9a4b", "filename": "Cargo.lock", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -57,18 +57,18 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.92.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2f3d54eab028f5805ae3b26fd60eca3f3a9cfb76b989d9bab173be3f61356cc3\"\n+checksum = \"a7379abaacee0f14abf3204a7606118f0465785252169d186337bcb75030815a\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.92.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2be1d5f2c3cca1efb691844bc1988b89c77291f13f778499a3f3c0cf49c0ed61\"\n+checksum = \"9489fa336927df749631f1008007ced2871068544f40a202ce6d93fbf2366a7b\"\n dependencies = [\n  \"arrayvec\",\n  \"bumpalo\",\n@@ -87,30 +87,30 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.92.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f9b1b1089750ce4005893af7ee00bb08a2cf1c9779999c0f7164cbc8ad2e0d2\"\n+checksum = \"05bbb67da91ec721ed57cef2f7c5ef7728e1cd9bde9ffd3ef8601022e73e3239\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.92.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cc5fbaec51de47297fd7304986fd53c8c0030abbe69728a60d72e1c63559318d\"\n+checksum = \"418ecb2f36032f6665dc1a5e2060a143dbab41d83b784882e97710e890a7a16d\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.92.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dab984c94593f876090fae92e984bdcc74d9b1acf740ab5f79036001c65cba13\"\n+checksum = \"7cf583f7b093f291005f9fb1323e2c37f6ee4c7909e39ce016b2e8360d461705\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.92.0\"\n+version = \"0.93.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6e0cb3102d21a2fe5f3210af608748ddd0cd09825ac12d42dc56ed5ed8725fe0\"\n+checksum = \"7d361ed0373cf5f086b49c499aa72227b646a64f899f32e34312f97c0fadff75\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -120,15 +120,15 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-isle\"\n-version = \"0.92.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"72101dd1f441d629735143c41e00b3428f9267738176983ef588ff43382af0a0\"\n+checksum = \"649782a39ce99798dd6b4029e2bb318a2fbeaade1b4fa25330763c10c65bc358\"\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.92.0\"\n+version = \"0.93.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6557f8ce44d498777f2495aa58d9692a4a37d6f84aa445750d666cef770b6a5c\"\n+checksum = \"9c9909222db472fcc98d9e4e7192fa9d064dac63a3fa657df8c6daae86fb2604\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -145,19 +145,19 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.92.0\"\n+version = \"0.93.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"88807e1c0c47ec02fe433333ccbe56b480425418b1470e333205e11650697d72\"\n+checksum = \"68689b83e52e605ba48652882d3fccc2e2e136abf139eb64ae667888ba0d52f8\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n ]\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.92.0\"\n+version = \"0.93.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c22b0d9fcbe3fc5a1af9e7021b44ce42b930bcefac446ce22e02e8f9a0d67120\"\n+checksum = \"f98e4e99a353703475d5acb402b9c13482d41d8a4008b352559bd560afb90363\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -166,9 +166,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.92.0\"\n+version = \"0.93.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"341375758d7c3fedc0b5315f552e6f0feac46baf87c450a15e9455ef47c2b261\"\n+checksum = \"b7a006ce1d8dd11df67567d8673e5920f3a56441812aed52a007ffce8f1b20e9\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -333,6 +333,7 @@ dependencies = [\n  \"cranelift-frontend\",\n  \"cranelift-jit\",\n  \"cranelift-module\",\n+ \"cranelift-native\",\n  \"cranelift-object\",\n  \"gimli\",\n  \"indexmap\",\n@@ -381,9 +382,9 @@ checksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n \n [[package]]\n name = \"wasmtime-jit-icache-coherence\"\n-version = \"5.0.0\"\n+version = \"6.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"08fcba5ebd96da2a9f0747ab6337fe9788adfb3f63fa2c180520d665562d257e\"\n+checksum = \"ec1fd0f0dd79e7cc0f55b102e320d7c77ab76cd272008a8fd98e25b5777e2636\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\","}, {"sha": "0e64fba6bec8db017c3b5f85d2918404a4fc96d1", "filename": "Cargo.toml", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -15,14 +15,12 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { version = \"0.92\", features = [\"unwind\", \"all-arch\"] }\n-cranelift-frontend = { version = \"0.92\" }\n-cranelift-module = { version = \"0.92\" }\n-# NOTE vendored as src/cranelift_native.rs\n-# FIXME revert back to the external crate with Cranelift 0.93\n-#cranelift-native = { version = \"0.92\" }\n-cranelift-jit = { version = \"0.92\", optional = true }\n-cranelift-object = { version = \"0.92\" }\n+cranelift-codegen = { version = \"0.93\", features = [\"unwind\", \"all-arch\"] }\n+cranelift-frontend = { version = \"0.93\" }\n+cranelift-module = { version = \"0.93\" }\n+cranelift-native = { version = \"0.93\" }\n+cranelift-jit = { version = \"0.93\", optional = true }\n+cranelift-object = { version = \"0.93\" }\n target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }"}, {"sha": "f21507629911ad01d0864bd1f169fe548ba4109e", "filename": "build_sysroot/Cargo.lock", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/build_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/build_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2FCargo.lock?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -50,9 +50,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.86\"\n+version = \"0.1.89\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5dae98c88e576098d7ab13ebcb40cc43e5114b2beafe61a87cda9200649ff205\"\n+checksum = \"9fc9c2080d347a2c316518840ac9194644a9993dfa1e9778ef38979a339f5d8b\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -117,21 +117,20 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.2.6\"\n+version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ee512640fe35acbfb4bb779db6f0d80704c2cacfa2e39b601ef3e3f47d1ae4c7\"\n+checksum = \"fed44880c466736ef9a5c5b5facefb5ed0785676d0c02d612db14e54f0d84286\"\n dependencies = [\n  \"compiler_builtins\",\n- \"libc\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.139\"\n+version = \"0.2.140\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"201de327520df007757c1f0adce6e827fe8562fbc28bfd9c15571c66ca1f5f79\"\n+checksum = \"99227334921fae1a979cf0bfdfcc6b3e5ce376ef57e16fb6fb3ea2ed6095f80c\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -282,10 +281,8 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n- \"cfg-if\",\n  \"core\",\n  \"getopts\",\n- \"libc\",\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"proc_macro\","}, {"sha": "8219e6b6ccf3bca19d613a2b7331639a30a8d7e1", "filename": "build_sysroot/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/build_sysroot%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/build_sysroot%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2FCargo.toml?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -8,7 +8,7 @@ alloc = { path = \"./sysroot_src/library/alloc\" }\n std = { path = \"./sysroot_src/library/std\", features = [\"panic_unwind\", \"backtrace\"] }\n test = { path = \"./sysroot_src/library/test\" }\n \n-compiler_builtins = { version = \"0.1.39\", default-features = false, features = [\"no-asm\"] }\n+compiler_builtins = { version = \"0.1.87\", default-features = false, features = [\"no-asm\"] }\n \n [patch.crates-io]\n rustc-std-workspace-core = { path = \"./sysroot_src/library/rustc-std-workspace-core\" }"}, {"sha": "76b602fe7196326f9949430b549669862e9a0766", "filename": "build_system/build_sysroot.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/build_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/build_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fbuild_sysroot.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -46,13 +46,15 @@ pub(crate) fn build_sysroot(\n         let wrapper_name = wrapper_base_name.replace(\"____\", wrapper);\n \n         let mut build_cargo_wrapper_cmd = Command::new(&bootstrap_host_compiler.rustc);\n+        let wrapper_path = DIST_DIR.to_path(dirs).join(&wrapper_name);\n         build_cargo_wrapper_cmd\n             .env(\"TOOLCHAIN_NAME\", toolchain_name.clone())\n             .arg(RelPath::SCRIPTS.to_path(dirs).join(&format!(\"{wrapper}.rs\")))\n             .arg(\"-o\")\n-            .arg(DIST_DIR.to_path(dirs).join(wrapper_name))\n+            .arg(&wrapper_path)\n             .arg(\"-Cstrip=debuginfo\");\n         spawn_and_wait(build_cargo_wrapper_cmd);\n+        try_hard_link(wrapper_path, BIN_DIR.to_path(dirs).join(wrapper_name));\n     }\n \n     let host = build_sysroot_for_triple(\n@@ -247,6 +249,7 @@ fn build_clif_sysroot_for_triple(\n     if channel == \"release\" {\n         build_cmd.arg(\"--release\");\n     }\n+    build_cmd.arg(\"--locked\");\n     build_cmd.env(\"__CARGO_DEFAULT_LIB_METADATA\", \"cg_clif\");\n     if compiler.triple.contains(\"apple\") {\n         build_cmd.env(\"CARGO_PROFILE_RELEASE_SPLIT_DEBUGINFO\", \"packed\");"}, {"sha": "6769e42d44b94181f427210c803616f2e2b8f31e", "filename": "build_system/prepare.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/build_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/build_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fprepare.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -6,15 +6,18 @@ use std::process::Command;\n use super::build_sysroot::{BUILD_SYSROOT, ORIG_BUILD_SYSROOT, SYSROOT_RUSTC_VERSION, SYSROOT_SRC};\n use super::path::{Dirs, RelPath};\n use super::rustc_info::{get_default_sysroot, get_rustc_version};\n+use super::tests::LIBCORE_TESTS_SRC;\n use super::utils::{copy_dir_recursively, git_command, retry_spawn_and_wait, spawn_and_wait};\n \n pub(crate) fn prepare(dirs: &Dirs) {\n     RelPath::DOWNLOAD.ensure_fresh(dirs);\n \n     spawn_and_wait(super::build_backend::CG_CLIF.fetch(\"cargo\", \"rustc\", dirs));\n \n-    prepare_sysroot(dirs);\n+    prepare_stdlib(dirs);\n     spawn_and_wait(super::build_sysroot::STANDARD_LIBRARY.fetch(\"cargo\", \"rustc\", dirs));\n+\n+    prepare_coretests(dirs);\n     spawn_and_wait(super::tests::LIBCORE_TESTS.fetch(\"cargo\", \"rustc\", dirs));\n \n     super::tests::RAND_REPO.fetch(dirs);\n@@ -25,11 +28,11 @@ pub(crate) fn prepare(dirs: &Dirs) {\n     spawn_and_wait(super::tests::PORTABLE_SIMD.fetch(\"cargo\", \"rustc\", dirs));\n }\n \n-fn prepare_sysroot(dirs: &Dirs) {\n+fn prepare_stdlib(dirs: &Dirs) {\n     let sysroot_src_orig = get_default_sysroot(Path::new(\"rustc\")).join(\"lib/rustlib/src/rust\");\n     assert!(sysroot_src_orig.exists());\n \n-    eprintln!(\"[COPY] sysroot src\");\n+    eprintln!(\"[COPY] stdlib src\");\n \n     // FIXME ensure builds error out or update the copy if any of the files copied here change\n     BUILD_SYSROOT.ensure_fresh(dirs);\n@@ -47,7 +50,25 @@ fn prepare_sysroot(dirs: &Dirs) {\n     eprintln!(\"[GIT] init\");\n     init_git_repo(&SYSROOT_SRC.to_path(dirs));\n \n-    apply_patches(dirs, \"sysroot\", &SYSROOT_SRC.to_path(dirs));\n+    apply_patches(dirs, \"stdlib\", &SYSROOT_SRC.to_path(dirs));\n+}\n+\n+fn prepare_coretests(dirs: &Dirs) {\n+    let sysroot_src_orig = get_default_sysroot(Path::new(\"rustc\")).join(\"lib/rustlib/src/rust\");\n+    assert!(sysroot_src_orig.exists());\n+\n+    eprintln!(\"[COPY] coretests src\");\n+\n+    fs::create_dir_all(LIBCORE_TESTS_SRC.to_path(dirs)).unwrap();\n+    copy_dir_recursively(\n+        &sysroot_src_orig.join(\"library/core/tests\"),\n+        &LIBCORE_TESTS_SRC.to_path(dirs),\n+    );\n+\n+    eprintln!(\"[GIT] init\");\n+    init_git_repo(&LIBCORE_TESTS_SRC.to_path(dirs));\n+\n+    apply_patches(dirs, \"coretests\", &LIBCORE_TESTS_SRC.to_path(dirs));\n }\n \n pub(crate) struct GitRepo {"}, {"sha": "261948a6971375f534935991d7f27d27e1209639", "filename": "build_system/tests.rs", "status": "modified", "additions": 15, "deletions": 36, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/build_system%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/build_system%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Ftests.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -1,4 +1,4 @@\n-use super::build_sysroot::{self, SYSROOT_SRC};\n+use super::build_sysroot;\n use super::config;\n use super::path::{Dirs, RelPath};\n use super::prepare::GitRepo;\n@@ -94,40 +94,42 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n     TestCase::build_bin_and_run(\"aot.issue-72793\", \"example/issue-72793.rs\", &[]),\n ];\n \n+// FIXME(rust-random/rand#1293): Newer rand versions fail to test on Windows. Update once this is\n+// fixed.\n pub(crate) static RAND_REPO: GitRepo =\n-    GitRepo::github(\"rust-random\", \"rand\", \"0f933f9c7176e53b2a3c7952ded484e1783f0bf1\", \"rand\");\n+    GitRepo::github(\"rust-random\", \"rand\", \"50b9a447410860af8d6db9a208c3576886955874\", \"rand\");\n \n pub(crate) static RAND: CargoProject = CargoProject::new(&RAND_REPO.source_dir(), \"rand\");\n \n pub(crate) static REGEX_REPO: GitRepo =\n-    GitRepo::github(\"rust-lang\", \"regex\", \"341f207c1071f7290e3f228c710817c280c8dca1\", \"regex\");\n+    GitRepo::github(\"rust-lang\", \"regex\", \"a9b2e02352db92ce1f6e5b7ecd41b8bbffbe161a\", \"regex\");\n \n pub(crate) static REGEX: CargoProject = CargoProject::new(&REGEX_REPO.source_dir(), \"regex\");\n \n pub(crate) static PORTABLE_SIMD_REPO: GitRepo = GitRepo::github(\n     \"rust-lang\",\n     \"portable-simd\",\n-    \"582239ac3b32007613df04d7ffa78dc30f4c5645\",\n+    \"9bd30e77b3a3c699af102ebb3df0f6110f8aa02e\",\n     \"portable-simd\",\n );\n \n pub(crate) static PORTABLE_SIMD: CargoProject =\n     CargoProject::new(&PORTABLE_SIMD_REPO.source_dir(), \"portable_simd\");\n \n-pub(crate) static LIBCORE_TESTS: CargoProject =\n-    CargoProject::new(&SYSROOT_SRC.join(\"library/core/tests\"), \"core_tests\");\n+pub(crate) static LIBCORE_TESTS_SRC: RelPath = RelPath::DOWNLOAD.join(\"coretests_src\");\n+\n+pub(crate) static LIBCORE_TESTS: CargoProject = CargoProject::new(&LIBCORE_TESTS_SRC, \"core_tests\");\n \n const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n     TestCase::custom(\"test.rust-random/rand\", &|runner| {\n         RAND.clean(&runner.dirs);\n \n         if runner.is_native {\n-            eprintln!(\"[TEST] rust-random/rand\");\n             let mut test_cmd = RAND.test(&runner.target_compiler, &runner.dirs);\n-            test_cmd.arg(\"--workspace\");\n+            test_cmd.arg(\"--workspace\").arg(\"--\").arg(\"-q\");\n             spawn_and_wait(test_cmd);\n         } else {\n-            eprintln!(\"[AOT] rust-random/rand\");\n+            eprintln!(\"Cross-Compiling: Not running tests\");\n             let mut build_cmd = RAND.build(&runner.target_compiler, &runner.dirs);\n             build_cmd.arg(\"--workspace\").arg(\"--tests\");\n             spawn_and_wait(build_cmd);\n@@ -137,7 +139,9 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n         LIBCORE_TESTS.clean(&runner.dirs);\n \n         if runner.is_native {\n-            spawn_and_wait(LIBCORE_TESTS.test(&runner.target_compiler, &runner.dirs));\n+            let mut test_cmd = LIBCORE_TESTS.test(&runner.target_compiler, &runner.dirs);\n+            test_cmd.arg(\"--\").arg(\"-q\");\n+            spawn_and_wait(test_cmd);\n         } else {\n             eprintln!(\"Cross-Compiling: Not running tests\");\n             let mut build_cmd = LIBCORE_TESTS.build(&runner.target_compiler, &runner.dirs);\n@@ -148,18 +152,13 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n     TestCase::custom(\"test.regex-shootout-regex-dna\", &|runner| {\n         REGEX.clean(&runner.dirs);\n \n-        // newer aho_corasick versions throw a deprecation warning\n-        let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.target_compiler.rustflags);\n-\n         let mut build_cmd = REGEX.build(&runner.target_compiler, &runner.dirs);\n         build_cmd.arg(\"--example\").arg(\"shootout-regex-dna\");\n-        build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n         spawn_and_wait(build_cmd);\n \n         if runner.is_native {\n             let mut run_cmd = REGEX.run(&runner.target_compiler, &runner.dirs);\n             run_cmd.arg(\"--example\").arg(\"shootout-regex-dna\");\n-            run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n \n             let input = fs::read_to_string(\n                 REGEX.source_dir(&runner.dirs).join(\"examples\").join(\"regexdna-input.txt\"),\n@@ -171,13 +170,6 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n             .unwrap();\n \n             let output = spawn_and_wait_with_input(run_cmd, input);\n-            // Make sure `[codegen mono items] start` doesn't poison the diff\n-            let output = output\n-                .lines()\n-                .filter(|line| !line.contains(\"codegen mono items\"))\n-                .chain(Some(\"\")) // This just adds the trailing newline\n-                .collect::<Vec<&str>>()\n-                .join(\"\\r\\n\");\n \n             let output_matches = expected.lines().eq(output.lines());\n             if !output_matches {\n@@ -192,27 +184,14 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n     TestCase::custom(\"test.regex\", &|runner| {\n         REGEX.clean(&runner.dirs);\n \n-        // newer aho_corasick versions throw a deprecation warning\n-        let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.target_compiler.rustflags);\n-\n         if runner.is_native {\n             let mut run_cmd = REGEX.test(&runner.target_compiler, &runner.dirs);\n-            run_cmd.args([\n-                \"--tests\",\n-                \"--\",\n-                \"--exclude-should-panic\",\n-                \"--test-threads\",\n-                \"1\",\n-                \"-Zunstable-options\",\n-                \"-q\",\n-            ]);\n-            run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n+            run_cmd.args([\"--workspace\", \"--\", \"-q\"]);\n             spawn_and_wait(run_cmd);\n         } else {\n             eprintln!(\"Cross-Compiling: Not running tests\");\n             let mut build_cmd = REGEX.build(&runner.target_compiler, &runner.dirs);\n             build_cmd.arg(\"--tests\");\n-            build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n             spawn_and_wait(build_cmd);\n         }\n     }),"}, {"sha": "73b83b89f6d91ea3358c15a5e8cc49354ac62d4a", "filename": "example/mini_core.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/example%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/example%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -518,6 +518,17 @@ pub struct Box<T: ?Sized>(Unique<T>, ());\n \n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n \n+impl<T> Box<T> {\n+    pub fn new(val: T) -> Box<T> {\n+        unsafe {\n+            let size = intrinsics::size_of::<T>();\n+            let ptr = libc::malloc(size);\n+            intrinsics::copy(&val as *const T as *const u8, ptr, size);\n+            Box(Unique { pointer: NonNull(ptr as *const T), _marker: PhantomData }, ())\n+        }\n+    }\n+}\n+\n impl<T: ?Sized> Drop for Box<T> {\n     fn drop(&mut self) {\n         // drop is currently performed by compiler."}, {"sha": "6ad3268e70dd229278b33c6b7e66e2697ace038e", "filename": "example/mini_core_hello_world.rs", "status": "modified", "additions": 300, "deletions": 81, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/example%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/example%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core_hello_world.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -1,16 +1,16 @@\n-#![feature(no_core, lang_items, never_type, linkage, extern_types, thread_local)]\n+#![feature(no_core, lang_items, never_type, linkage, extern_types, thread_local, repr_simd)]\n #![no_core]\n #![allow(dead_code, non_camel_case_types)]\n \n extern crate mini_core;\n \n-use mini_core::*;\n use mini_core::libc::*;\n+use mini_core::*;\n \n macro_rules! assert {\n     ($e:expr) => {\n         if !$e {\n-            panic(stringify!(! $e));\n+            panic(stringify!(!$e));\n         }\n     };\n }\n@@ -20,7 +20,7 @@ macro_rules! assert_eq {\n         if $l != $r {\n             panic(stringify!($l != $r));\n         }\n-    }\n+    };\n }\n \n #[lang = \"termination\"]\n@@ -96,9 +96,15 @@ fn start<T: Termination + 'static>(\n     _sigpipe: u8,\n ) -> isize {\n     if argc == 3 {\n-        unsafe { puts(*argv as *const i8); }\n-        unsafe { puts(*((argv as usize + intrinsics::size_of::<*const u8>()) as *const *const i8)); }\n-        unsafe { puts(*((argv as usize + 2 * intrinsics::size_of::<*const u8>()) as *const *const i8)); }\n+        unsafe {\n+            puts(*argv as *const i8);\n+        }\n+        unsafe {\n+            puts(*((argv as usize + intrinsics::size_of::<*const u8>()) as *const *const i8));\n+        }\n+        unsafe {\n+            puts(*((argv as usize + 2 * intrinsics::size_of::<*const u8>()) as *const *const i8));\n+        }\n     }\n \n     main().report() as isize\n@@ -107,7 +113,6 @@ fn start<T: Termination + 'static>(\n static mut NUM: u8 = 6 * 7;\n static NUM_REF: &'static u8 = unsafe { &NUM };\n \n-\n unsafe fn zeroed<T>() -> T {\n     let mut uninit = MaybeUninit { uninit: () };\n     intrinsics::write_bytes(&mut uninit.value.value as *mut T, 0, 1);\n@@ -144,10 +149,7 @@ extern \"C\" fn bool_struct_in_11(_arg0: bool_11) {}\n \n #[allow(unreachable_code)] // FIXME false positive\n fn main() {\n-    take_unique(Unique {\n-        pointer: unsafe { NonNull(1 as *mut ()) },\n-        _marker: PhantomData,\n-    });\n+    take_unique(Unique { pointer: unsafe { NonNull(1 as *mut ()) }, _marker: PhantomData });\n     take_f32(0.1);\n \n     call_return_u128_pair();\n@@ -202,17 +204,17 @@ fn main() {\n         assert_eq!(intrinsics::size_of_val(&0u32) as u8, 4);\n \n         assert_eq!(intrinsics::min_align_of::<u16>() as u8, 2);\n-        assert_eq!(intrinsics::min_align_of_val(&a) as u8, intrinsics::min_align_of::<&str>() as u8);\n+        assert_eq!(\n+            intrinsics::min_align_of_val(&a) as u8,\n+            intrinsics::min_align_of::<&str>() as u8\n+        );\n \n         assert!(!intrinsics::needs_drop::<u8>());\n         assert!(!intrinsics::needs_drop::<[u8]>());\n         assert!(intrinsics::needs_drop::<NoisyDrop>());\n         assert!(intrinsics::needs_drop::<NoisyDropUnsized>());\n \n-        Unique {\n-            pointer: NonNull(1 as *mut &str),\n-            _marker: PhantomData,\n-        } as Unique<dyn SomeTrait>;\n+        Unique { pointer: NonNull(1 as *mut &str), _marker: PhantomData } as Unique<dyn SomeTrait>;\n \n         struct MyDst<T: ?Sized>(T);\n \n@@ -238,19 +240,17 @@ fn main() {\n         }\n     }\n \n-    let _ = Box::new(NoisyDrop {\n-        text: \"Boxed outer got dropped!\\0\",\n-        inner: NoisyDropInner,\n-    }) as Box<dyn SomeTrait>;\n+    let _ = Box::new(NoisyDrop { text: \"Boxed outer got dropped!\\0\", inner: NoisyDropInner })\n+        as Box<dyn SomeTrait>;\n \n     const FUNC_REF: Option<fn()> = Some(main);\n     match FUNC_REF {\n-        Some(_) => {},\n+        Some(_) => {}\n         None => assert!(false),\n     }\n \n     match Ordering::Less {\n-        Ordering::Less => {},\n+        Ordering::Less => {}\n         _ => assert!(false),\n     }\n \n@@ -266,19 +266,21 @@ fn main() {\n \n     #[cfg(not(any(jit, windows)))]\n     {\n-        extern {\n+        extern \"C\" {\n             #[linkage = \"extern_weak\"]\n             static ABC: *const u8;\n         }\n \n         {\n-            extern {\n+            extern \"C\" {\n                 #[linkage = \"extern_weak\"]\n                 static ABC: *const u8;\n             }\n         }\n \n-        unsafe { assert_eq!(ABC as usize, 0); }\n+        unsafe {\n+            assert_eq!(ABC as usize, 0);\n+        }\n     }\n \n     &mut (|| Some(0 as *const ())) as &mut dyn FnMut() -> Option<*const ()>;\n@@ -339,7 +341,13 @@ fn main() {\n \n         assert_eq!(unsafe { intrinsics::size_of_val(x) }, 0);\n         assert_eq!(unsafe { intrinsics::min_align_of_val(x) }, 1);\n-}\n+    }\n+\n+    #[repr(simd)]\n+    struct V([f64; 2]);\n+\n+    let f = V([0.0, 1.0]);\n+    let _a = f.0[0];\n }\n \n #[cfg(all(not(jit), target_arch = \"x86_64\", any(target_os = \"linux\", target_os = \"darwin\")))]\n@@ -392,13 +400,10 @@ extern \"C\" {\n         native: *mut pthread_t,\n         attr: *const pthread_attr_t,\n         f: extern \"C\" fn(_: *mut c_void) -> *mut c_void,\n-        value: *mut c_void\n+        value: *mut c_void,\n     ) -> c_int;\n \n-    fn pthread_join(\n-        native: pthread_t,\n-        value: *mut *mut c_void\n-    ) -> c_int;\n+    fn pthread_join(native: pthread_t, value: *mut *mut c_void) -> c_int;\n }\n \n type DWORD = u32;\n@@ -410,18 +415,15 @@ type HANDLE = *mut c_void;\n #[link(name = \"msvcrt\")]\n #[cfg(windows)]\n extern \"C\" {\n-    fn WaitForSingleObject(\n-        hHandle: LPVOID,\n-        dwMilliseconds: DWORD\n-    ) -> DWORD;\n+    fn WaitForSingleObject(hHandle: LPVOID, dwMilliseconds: DWORD) -> DWORD;\n \n     fn CreateThread(\n         lpThreadAttributes: LPVOID, // Technically LPSECURITY_ATTRIBUTES, but we don't use it anyway\n         dwStackSize: usize,\n         lpStartAddress: extern \"C\" fn(_: *mut c_void) -> *mut c_void,\n         lpParameter: LPVOID,\n         dwCreationFlags: DWORD,\n-        lpThreadId: LPDWORD\n+        lpThreadId: LPDWORD,\n     ) -> HANDLE;\n }\n \n@@ -447,9 +449,7 @@ impl Thread {\n                 assert!(false);\n             }\n \n-            Thread {\n-                handle: thread,\n-            }\n+            Thread { handle: thread }\n         }\n \n         #[cfg(windows)]\n@@ -460,13 +460,10 @@ impl Thread {\n                 assert!(false);\n             }\n \n-            Thread {\n-                handle,\n-            }\n+            Thread { handle }\n         }\n     }\n \n-\n     unsafe fn join(self) {\n         #[cfg(unix)]\n         {\n@@ -483,16 +480,15 @@ impl Thread {\n     }\n }\n \n-\n-\n-\n #[thread_local]\n #[cfg(not(jit))]\n static mut TLS: u8 = 42;\n \n #[cfg(not(jit))]\n extern \"C\" fn mutate_tls(_: *mut c_void) -> *mut c_void {\n-    unsafe { TLS = 0; }\n+    unsafe {\n+        TLS = 0;\n+    }\n     0 as *mut c_void\n }\n \n@@ -531,44 +527,267 @@ pub enum E1 {\n pub enum E2<X> {\n     V1 { f: bool },\n \n-    /*_00*/ _01(X), _02(X), _03(X), _04(X), _05(X), _06(X), _07(X),\n-    _08(X), _09(X), _0A(X), _0B(X), _0C(X), _0D(X), _0E(X), _0F(X),\n-    _10(X), _11(X), _12(X), _13(X), _14(X), _15(X), _16(X), _17(X),\n-    _18(X), _19(X), _1A(X), _1B(X), _1C(X), _1D(X), _1E(X), _1F(X),\n-    _20(X), _21(X), _22(X), _23(X), _24(X), _25(X), _26(X), _27(X),\n-    _28(X), _29(X), _2A(X), _2B(X), _2C(X), _2D(X), _2E(X), _2F(X),\n-    _30(X), _31(X), _32(X), _33(X), _34(X), _35(X), _36(X), _37(X),\n-    _38(X), _39(X), _3A(X), _3B(X), _3C(X), _3D(X), _3E(X), _3F(X),\n-    _40(X), _41(X), _42(X), _43(X), _44(X), _45(X), _46(X), _47(X),\n-    _48(X), _49(X), _4A(X), _4B(X), _4C(X), _4D(X), _4E(X), _4F(X),\n-    _50(X), _51(X), _52(X), _53(X), _54(X), _55(X), _56(X), _57(X),\n-    _58(X), _59(X), _5A(X), _5B(X), _5C(X), _5D(X), _5E(X), _5F(X),\n-    _60(X), _61(X), _62(X), _63(X), _64(X), _65(X), _66(X), _67(X),\n-    _68(X), _69(X), _6A(X), _6B(X), _6C(X), _6D(X), _6E(X), _6F(X),\n-    _70(X), _71(X), _72(X), _73(X), _74(X), _75(X), _76(X), _77(X),\n-    _78(X), _79(X), _7A(X), _7B(X), _7C(X), _7D(X), _7E(X), _7F(X),\n-    _80(X), _81(X), _82(X), _83(X), _84(X), _85(X), _86(X), _87(X),\n-    _88(X), _89(X), _8A(X), _8B(X), _8C(X), _8D(X), _8E(X), _8F(X),\n-    _90(X), _91(X), _92(X), _93(X), _94(X), _95(X), _96(X), _97(X),\n-    _98(X), _99(X), _9A(X), _9B(X), _9C(X), _9D(X), _9E(X), _9F(X),\n-    _A0(X), _A1(X), _A2(X), _A3(X), _A4(X), _A5(X), _A6(X), _A7(X),\n-    _A8(X), _A9(X), _AA(X), _AB(X), _AC(X), _AD(X), _AE(X), _AF(X),\n-    _B0(X), _B1(X), _B2(X), _B3(X), _B4(X), _B5(X), _B6(X), _B7(X),\n-    _B8(X), _B9(X), _BA(X), _BB(X), _BC(X), _BD(X), _BE(X), _BF(X),\n-    _C0(X), _C1(X), _C2(X), _C3(X), _C4(X), _C5(X), _C6(X), _C7(X),\n-    _C8(X), _C9(X), _CA(X), _CB(X), _CC(X), _CD(X), _CE(X), _CF(X),\n-    _D0(X), _D1(X), _D2(X), _D3(X), _D4(X), _D5(X), _D6(X), _D7(X),\n-    _D8(X), _D9(X), _DA(X), _DB(X), _DC(X), _DD(X), _DE(X), _DF(X),\n-    _E0(X), _E1(X), _E2(X), _E3(X), _E4(X), _E5(X), _E6(X), _E7(X),\n-    _E8(X), _E9(X), _EA(X), _EB(X), _EC(X), _ED(X), _EE(X), _EF(X),\n-    _F0(X), _F1(X), _F2(X), _F3(X), _F4(X), _F5(X), _F6(X), _F7(X),\n-    _F8(X), _F9(X), _FA(X), _FB(X), _FC(X), _FD(X), _FE(X), _FF(X),\n+    /*_00*/ _01(X),\n+    _02(X),\n+    _03(X),\n+    _04(X),\n+    _05(X),\n+    _06(X),\n+    _07(X),\n+    _08(X),\n+    _09(X),\n+    _0A(X),\n+    _0B(X),\n+    _0C(X),\n+    _0D(X),\n+    _0E(X),\n+    _0F(X),\n+    _10(X),\n+    _11(X),\n+    _12(X),\n+    _13(X),\n+    _14(X),\n+    _15(X),\n+    _16(X),\n+    _17(X),\n+    _18(X),\n+    _19(X),\n+    _1A(X),\n+    _1B(X),\n+    _1C(X),\n+    _1D(X),\n+    _1E(X),\n+    _1F(X),\n+    _20(X),\n+    _21(X),\n+    _22(X),\n+    _23(X),\n+    _24(X),\n+    _25(X),\n+    _26(X),\n+    _27(X),\n+    _28(X),\n+    _29(X),\n+    _2A(X),\n+    _2B(X),\n+    _2C(X),\n+    _2D(X),\n+    _2E(X),\n+    _2F(X),\n+    _30(X),\n+    _31(X),\n+    _32(X),\n+    _33(X),\n+    _34(X),\n+    _35(X),\n+    _36(X),\n+    _37(X),\n+    _38(X),\n+    _39(X),\n+    _3A(X),\n+    _3B(X),\n+    _3C(X),\n+    _3D(X),\n+    _3E(X),\n+    _3F(X),\n+    _40(X),\n+    _41(X),\n+    _42(X),\n+    _43(X),\n+    _44(X),\n+    _45(X),\n+    _46(X),\n+    _47(X),\n+    _48(X),\n+    _49(X),\n+    _4A(X),\n+    _4B(X),\n+    _4C(X),\n+    _4D(X),\n+    _4E(X),\n+    _4F(X),\n+    _50(X),\n+    _51(X),\n+    _52(X),\n+    _53(X),\n+    _54(X),\n+    _55(X),\n+    _56(X),\n+    _57(X),\n+    _58(X),\n+    _59(X),\n+    _5A(X),\n+    _5B(X),\n+    _5C(X),\n+    _5D(X),\n+    _5E(X),\n+    _5F(X),\n+    _60(X),\n+    _61(X),\n+    _62(X),\n+    _63(X),\n+    _64(X),\n+    _65(X),\n+    _66(X),\n+    _67(X),\n+    _68(X),\n+    _69(X),\n+    _6A(X),\n+    _6B(X),\n+    _6C(X),\n+    _6D(X),\n+    _6E(X),\n+    _6F(X),\n+    _70(X),\n+    _71(X),\n+    _72(X),\n+    _73(X),\n+    _74(X),\n+    _75(X),\n+    _76(X),\n+    _77(X),\n+    _78(X),\n+    _79(X),\n+    _7A(X),\n+    _7B(X),\n+    _7C(X),\n+    _7D(X),\n+    _7E(X),\n+    _7F(X),\n+    _80(X),\n+    _81(X),\n+    _82(X),\n+    _83(X),\n+    _84(X),\n+    _85(X),\n+    _86(X),\n+    _87(X),\n+    _88(X),\n+    _89(X),\n+    _8A(X),\n+    _8B(X),\n+    _8C(X),\n+    _8D(X),\n+    _8E(X),\n+    _8F(X),\n+    _90(X),\n+    _91(X),\n+    _92(X),\n+    _93(X),\n+    _94(X),\n+    _95(X),\n+    _96(X),\n+    _97(X),\n+    _98(X),\n+    _99(X),\n+    _9A(X),\n+    _9B(X),\n+    _9C(X),\n+    _9D(X),\n+    _9E(X),\n+    _9F(X),\n+    _A0(X),\n+    _A1(X),\n+    _A2(X),\n+    _A3(X),\n+    _A4(X),\n+    _A5(X),\n+    _A6(X),\n+    _A7(X),\n+    _A8(X),\n+    _A9(X),\n+    _AA(X),\n+    _AB(X),\n+    _AC(X),\n+    _AD(X),\n+    _AE(X),\n+    _AF(X),\n+    _B0(X),\n+    _B1(X),\n+    _B2(X),\n+    _B3(X),\n+    _B4(X),\n+    _B5(X),\n+    _B6(X),\n+    _B7(X),\n+    _B8(X),\n+    _B9(X),\n+    _BA(X),\n+    _BB(X),\n+    _BC(X),\n+    _BD(X),\n+    _BE(X),\n+    _BF(X),\n+    _C0(X),\n+    _C1(X),\n+    _C2(X),\n+    _C3(X),\n+    _C4(X),\n+    _C5(X),\n+    _C6(X),\n+    _C7(X),\n+    _C8(X),\n+    _C9(X),\n+    _CA(X),\n+    _CB(X),\n+    _CC(X),\n+    _CD(X),\n+    _CE(X),\n+    _CF(X),\n+    _D0(X),\n+    _D1(X),\n+    _D2(X),\n+    _D3(X),\n+    _D4(X),\n+    _D5(X),\n+    _D6(X),\n+    _D7(X),\n+    _D8(X),\n+    _D9(X),\n+    _DA(X),\n+    _DB(X),\n+    _DC(X),\n+    _DD(X),\n+    _DE(X),\n+    _DF(X),\n+    _E0(X),\n+    _E1(X),\n+    _E2(X),\n+    _E3(X),\n+    _E4(X),\n+    _E5(X),\n+    _E6(X),\n+    _E7(X),\n+    _E8(X),\n+    _E9(X),\n+    _EA(X),\n+    _EB(X),\n+    _EC(X),\n+    _ED(X),\n+    _EE(X),\n+    _EF(X),\n+    _F0(X),\n+    _F1(X),\n+    _F2(X),\n+    _F3(X),\n+    _F4(X),\n+    _F5(X),\n+    _F6(X),\n+    _F7(X),\n+    _F8(X),\n+    _F9(X),\n+    _FA(X),\n+    _FB(X),\n+    _FC(X),\n+    _FD(X),\n+    _FE(X),\n+    _FF(X),\n \n     V3,\n     V4,\n }\n \n-fn check_niche_behavior () {\n+fn check_niche_behavior() {\n     if let E1::V2 { .. } = (E1::V1 { f: true }) {\n         intrinsics::abort();\n     }"}, {"sha": "e34b35d5c4a8c481253e4b51764fdaaf72babc79", "filename": "example/std_example.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -58,8 +58,9 @@ fn main() {\n     assert_eq!(0b0000000000000000000000000010000000000000000000000000000000000000_0000000000000000000000000000000000001000000000000000000010000000u128.trailing_zeros(), 7);\n     assert_eq!(core::intrinsics::saturating_sub(0, -170141183460469231731687303715884105728i128), 170141183460469231731687303715884105727i128);\n \n-    let _d = 0i128.checked_div(2i128);\n-    let _d = 0u128.checked_div(2u128);\n+    std::hint::black_box(std::hint::black_box(7571400400375753350092698930310845914i128) * 10);\n+    assert!(0i128.checked_div(2i128).is_some());\n+    assert!(0u128.checked_div(2u128).is_some());\n     assert_eq!(1u128 + 2, 3);\n \n     assert_eq!(0b100010000000000000000000000000000u128 >> 10, 0b10001000000000000000000u128);"}, {"sha": "eb452c5cd377268b031cee0a3890c3b625333ef5", "filename": "patches/0003-rand-Disable-rand-tests-on-mingw.patch", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/patches%2F0003-rand-Disable-rand-tests-on-mingw.patch", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/patches%2F0003-rand-Disable-rand-tests-on-mingw.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0003-rand-Disable-rand-tests-on-mingw.patch?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -19,8 +19,8 @@ index 217899e..9cedeb7 100644\n +    // This is broken on x86_64-pc-windows-gnu presumably due to a broken powf implementation\n +    #[cfg_attr(all(target_os = \"windows\", target_env = \"gnu\"), ignore)]\n      fn value_stability() {\n-         fn test_samples<F: Float + core::fmt::Debug, D: Distribution<F>>(\n-             distr: D, zero: F, expected: &[F],\n+         fn test_samples<F: Float + Debug + Display + LowerExp, D: Distribution<F>>(\n+             distr: D, thresh: F, expected: &[F],\n diff --git a/rand_distr/tests/value_stability.rs b/rand_distr/tests/value_stability.rs\n index 192ba74..0101ace 100644\n --- a/rand_distr/tests/value_stability.rs"}, {"sha": "6afa5c71fe51fa8cb16c78ff116d07292e35acef", "filename": "patches/0022-coretests-Disable-not-compiling-tests.patch", "status": "renamed", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/patches%2F0022-coretests-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/patches%2F0022-coretests-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0022-coretests-Disable-not-compiling-tests.patch?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -13,14 +13,14 @@ Subject: [PATCH] [core] Disable not compiling tests\n  6 files changed, 16 insertions(+), 1 deletion(-)\n  create mode 100644 library/core/tests/Cargo.toml\n \n-diff --git a/library/core/tests/Cargo.toml b/library/core/tests/Cargo.toml\n+diff --git a/Cargo.toml b/Cargo.toml\n new file mode 100644\n index 0000000..46fd999\n --- /dev/null\n-+++ b/library/core/tests/Cargo.toml\n++++ b/Cargo.toml\n @@ -0,0 +1,12 @@\n +[package]\n-+name = \"core\"\n++name = \"coretests\"\n +version = \"0.0.0\"\n +edition = \"2021\"\n +\n@@ -31,5 +31,14 @@ index 0000000..46fd999\n +[dependencies]\n +rand = { version = \"0.8.5\", default-features = false }\n +rand_xorshift = { version = \"0.3.0\", default-features = false }\n+diff --git a/lib.rs b/lib.rs\n+index 42a26ae..5ac1042 100644\n+--- a/lib.rs\n++++ b/lib.rs\n+@@ -1,3 +1,4 @@\n++#![cfg(test)]\n+ #![feature(alloc_layout_extra)]\n+ #![feature(array_chunks)]\n+ #![feature(array_methods)]\n --\n 2.21.0 (Apple Git-122)", "previous_filename": "patches/0022-sysroot-Disable-not-compiling-tests.patch"}, {"sha": "f2cb82751f0821ff857fe2ae0f229d5aca450501", "filename": "patches/0023-coretests-Ignore-failing-tests.patch", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/patches%2F0023-coretests-Ignore-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/patches%2F0023-coretests-Ignore-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0023-coretests-Ignore-failing-tests.patch?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -10,10 +10,10 @@ Subject: [PATCH] [core] Ignore failing tests\n  library/core/tests/time.rs       |  1 +\n  4 files changed, 18 insertions(+), 2 deletions(-)\n \n-diff --git a/library/core/tests/array.rs b/library/core/tests/array.rs\n+diff --git a/array.rs b/array.rs\n index 4bc44e9..8e3c7a4 100644\n---- a/library/core/tests/array.rs\n-+++ b/library/core/tests/array.rs\n+--- a/array.rs\n++++ b/array.rs\n @@ -242,6 +242,7 @@ fn iterator_drops() {\n      assert_eq!(i.get(), 5);\n  }\n@@ -46,10 +46,10 @@ index 4bc44e9..8e3c7a4 100644\n  \n  #[test]\n  fn cell_allows_array_cycle() {\n-diff --git a/library/core/tests/atomic.rs b/library/core/tests/atomic.rs\n+diff --git a/atomic.rs b/atomic.rs\n index 13b12db..96fe4b9 100644\n---- a/library/core/tests/atomic.rs\n-+++ b/library/core/tests/atomic.rs\n+--- a/atomic.rs\n++++ b/atomic.rs\n @@ -185,6 +185,7 @@ fn ptr_bitops() {\n  }\n  ", "previous_filename": "patches/0023-sysroot-Ignore-failing-tests.patch"}, {"sha": "1d5479beddee915871f801c0892a4c2c25baf73d", "filename": "patches/0027-coretests-128bit-atomic-operations.patch", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/patches%2F0027-coretests-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/patches%2F0027-coretests-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0027-coretests-128bit-atomic-operations.patch?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -0,0 +1,30 @@\n+From ad7ffe71baba46865f2e65266ab025920dfdc20b Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Thu, 18 Feb 2021 18:45:28 +0100\n+Subject: [PATCH] Disable 128bit atomic operations\n+\n+Cranelift doesn't support them yet\n+---\n+ library/core/src/panic/unwind_safe.rs |  6 -----\n+ library/core/src/sync/atomic.rs       | 38 ---------------------------\n+ library/core/tests/atomic.rs          |  4 ---\n+ 4 files changed, 4 insertions(+), 50 deletions(-)\n+\n+diff --git a/atomic.rs b/atomic.rs\n+index b735957..ea728b6 100644\n+--- a/atomic.rs\n++++ b/atomic.rs\n+@@ -185,10 +185,6 @@ fn atomic_alignment() {\n+     assert_eq!(align_of::<AtomicU64>(), size_of::<AtomicU64>());\n+     #[cfg(target_has_atomic = \"64\")]\n+     assert_eq!(align_of::<AtomicI64>(), size_of::<AtomicI64>());\n+-    #[cfg(target_has_atomic = \"128\")]\n+-    assert_eq!(align_of::<AtomicU128>(), size_of::<AtomicU128>());\n+-    #[cfg(target_has_atomic = \"128\")]\n+-    assert_eq!(align_of::<AtomicI128>(), size_of::<AtomicI128>());\n+     #[cfg(target_has_atomic = \"ptr\")]\n+     assert_eq!(align_of::<AtomicUsize>(), size_of::<AtomicUsize>());\n+     #[cfg(target_has_atomic = \"ptr\")]\n+--\n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "45f73f36b93171ddd2b32b2571666fd25674ced6", "filename": "patches/0027-stdlib-128bit-atomic-operations.patch", "status": "renamed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/patches%2F0027-stdlib-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/patches%2F0027-stdlib-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0027-stdlib-128bit-atomic-operations.patch?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -85,21 +85,6 @@ index d9de37e..8293fce 100644\n  \n  macro_rules! atomic_int_ptr_sized {\n      ( $($target_pointer_width:literal $align:literal)* ) => { $(\n-diff --git a/library/core/tests/atomic.rs b/library/core/tests/atomic.rs\n-index b735957..ea728b6 100644\n---- a/library/core/tests/atomic.rs\n-+++ b/library/core/tests/atomic.rs\n-@@ -185,10 +185,6 @@ fn atomic_alignment() {\n-     assert_eq!(align_of::<AtomicU64>(), size_of::<AtomicU64>());\n-     #[cfg(target_has_atomic = \"64\")]\n-     assert_eq!(align_of::<AtomicI64>(), size_of::<AtomicI64>());\n--    #[cfg(target_has_atomic = \"128\")]\n--    assert_eq!(align_of::<AtomicU128>(), size_of::<AtomicU128>());\n--    #[cfg(target_has_atomic = \"128\")]\n--    assert_eq!(align_of::<AtomicI128>(), size_of::<AtomicI128>());\n-     #[cfg(target_has_atomic = \"ptr\")]\n-     assert_eq!(align_of::<AtomicUsize>(), size_of::<AtomicUsize>());\n-     #[cfg(target_has_atomic = \"ptr\")]\n --\n 2.26.2.7.g19db9cfb68\n ", "previous_filename": "patches/0027-sysroot-128bit-atomic-operations.patch"}, {"sha": "440177018f428e66a124963332c13a9f328e3c9c", "filename": "patches/0028-coretests-Disable-long-running-tests.patch", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/patches%2F0028-coretests-Disable-long-running-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/patches%2F0028-coretests-Disable-long-running-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0028-coretests-Disable-long-running-tests.patch?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -7,10 +7,10 @@ Subject: [PATCH] Disable long running tests\n  library/core/tests/slice.rs | 2 ++\n  1 file changed, 2 insertions(+)\n \n-diff --git a/library/core/tests/slice.rs b/library/core/tests/slice.rs\n+diff --git a/slice.rs b/slice.rs\n index 8402833..84592e0 100644\n---- a/library/core/tests/slice.rs\n-+++ b/library/core/tests/slice.rs\n+--- a/slice.rs\n++++ b/slice.rs\n @@ -1809,6 +1809,7 @@ fn sort_unstable() {\n      assert!(v == [0xDEADBEEF]);\n  }", "previous_filename": "patches/0028-sysroot-Disable-long-running-tests.patch"}, {"sha": "2236a6ca15521cf1deb6ee9bb69bf07f92c346df", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2023-02-06\"\n+channel = \"nightly-2023-03-15\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "939a1f1ca59001a39feb12e643716b45cf704c5c", "filename": "scripts/cargo-clif.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/scripts%2Fcargo-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/scripts%2Fcargo-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Fcargo-clif.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -1,11 +1,14 @@\n use std::env;\n #[cfg(unix)]\n use std::os::unix::process::CommandExt;\n-use std::path::PathBuf;\n use std::process::Command;\n \n fn main() {\n-    let sysroot = PathBuf::from(env::current_exe().unwrap().parent().unwrap());\n+    let current_exe = env::current_exe().unwrap();\n+    let mut sysroot = current_exe.parent().unwrap();\n+    if sysroot.file_name().unwrap().to_str().unwrap() == \"bin\" {\n+        sysroot = sysroot.parent().unwrap();\n+    }\n \n     let mut rustflags = String::new();\n     rustflags.push_str(\" -Cpanic=abort -Zpanic-abort-tests -Zcodegen-backend=\");"}, {"sha": "b9bba7f2e084c8d50a43d5e1a760ee5bdb62b65c", "filename": "scripts/rustc-clif.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/scripts%2Frustc-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/scripts%2Frustc-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Frustc-clif.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -2,11 +2,14 @@ use std::env;\n use std::ffi::OsString;\n #[cfg(unix)]\n use std::os::unix::process::CommandExt;\n-use std::path::PathBuf;\n use std::process::Command;\n \n fn main() {\n-    let sysroot = PathBuf::from(env::current_exe().unwrap().parent().unwrap());\n+    let current_exe = env::current_exe().unwrap();\n+    let mut sysroot = current_exe.parent().unwrap();\n+    if sysroot.file_name().unwrap().to_str().unwrap() == \"bin\" {\n+        sysroot = sysroot.parent().unwrap();\n+    }\n \n     let cg_clif_dylib_path = sysroot.join(if cfg!(windows) { \"bin\" } else { \"lib\" }).join(\n         env::consts::DLL_PREFIX.to_string() + \"rustc_codegen_cranelift\" + env::consts::DLL_SUFFIX,"}, {"sha": "167631eaf7ee49d5a8121760a9d686a71aa9186c", "filename": "scripts/rustdoc-clif.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/scripts%2Frustdoc-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/scripts%2Frustdoc-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Frustdoc-clif.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -2,11 +2,14 @@ use std::env;\n use std::ffi::OsString;\n #[cfg(unix)]\n use std::os::unix::process::CommandExt;\n-use std::path::PathBuf;\n use std::process::Command;\n \n fn main() {\n-    let sysroot = PathBuf::from(env::current_exe().unwrap().parent().unwrap());\n+    let current_exe = env::current_exe().unwrap();\n+    let mut sysroot = current_exe.parent().unwrap();\n+    if sysroot.file_name().unwrap().to_str().unwrap() == \"bin\" {\n+        sysroot = sysroot.parent().unwrap();\n+    }\n \n     let cg_clif_dylib_path = sysroot.join(if cfg!(windows) { \"bin\" } else { \"lib\" }).join(\n         env::consts::DLL_PREFIX.to_string() + \"rustc_codegen_cranelift\" + env::consts::DLL_SUFFIX,"}, {"sha": "3cbeb6375de109011fb29e3847f40173b188cae2", "filename": "scripts/rustup.sh", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/scripts%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/scripts%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Frustup.sh?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -2,10 +2,24 @@\n \n set -e\n \n+TOOLCHAIN=${TOOLCHAIN:-$(date +%Y-%m-%d)}\n+\n+function check_git_fixed_subtree() {\n+    if [[ ! -e ./git-fixed-subtree.sh ]]; then\n+        echo \"Missing git-fixed-subtree.sh. Please run the following commands to download it:\"\n+        echo \"curl --proto '=https' --tlsv1.2 -sSf https://raw.githubusercontent.com/bjorn3/git/tqc-subtree-portable/contrib/subtree/git-subtree.sh -o git-fixed-subtree.sh\"\n+        echo \"chmod u+x git-fixed-subtree.sh\"\n+        exit 1\n+    fi\n+    if [[ ! -x ./git-fixed-subtree.sh ]]; then\n+        echo \"git-fixed-subtree.sh is not executable. Please run the following command to make it executable:\"\n+        echo \"chmod u+x git-fixed-subtree.sh\"\n+        exit 1\n+    fi\n+}\n+\n case $1 in\n     \"prepare\")\n-        TOOLCHAIN=$(date +%Y-%m-%d)\n-\n         echo \"=> Installing new nightly\"\n         rustup toolchain install --profile minimal \"nightly-${TOOLCHAIN}\" # Sanity check to see if the nightly exists\n         sed -i \"s/\\\"nightly-.*\\\"/\\\"nightly-${TOOLCHAIN}\\\"/\" rust-toolchain\n@@ -27,28 +41,35 @@ case $1 in\n         git commit -m \"Rustup to $(rustc -V)\"\n         ;;\n     \"push\")\n+        check_git_fixed_subtree\n+\n         cg_clif=$(pwd)\n         pushd ../rust\n         git pull origin master\n         branch=sync_cg_clif-$(date +%Y-%m-%d)\n         git checkout -b \"$branch\"\n-        git subtree pull --prefix=compiler/rustc_codegen_cranelift/ https://github.com/bjorn3/rustc_codegen_cranelift.git master\n+        \"$cg_clif/git-fixed-subtree.sh\" pull --prefix=compiler/rustc_codegen_cranelift/ https://github.com/bjorn3/rustc_codegen_cranelift.git master\n         git push -u my \"$branch\"\n \n         # immediately merge the merge commit into cg_clif to prevent merge conflicts when syncing\n         # from rust-lang/rust later\n-        git subtree push --prefix=compiler/rustc_codegen_cranelift/ \"$cg_clif\" sync_from_rust\n+        \"$cg_clif/git-fixed-subtree.sh\" push --prefix=compiler/rustc_codegen_cranelift/ \"$cg_clif\" sync_from_rust\n         popd\n         git merge sync_from_rust\n \t;;\n     \"pull\")\n+        check_git_fixed_subtree\n+\n+        RUST_VERS=$(curl \"https://static.rust-lang.org/dist/$TOOLCHAIN/channel-rust-nightly-git-commit-hash.txt\")\n+        echo \"Pulling $RUST_VERS ($TOOLCHAIN)\"\n+\n         cg_clif=$(pwd)\n         pushd ../rust\n-        git pull origin master\n-        rust_vers=\"$(git rev-parse HEAD)\"\n-        git subtree push --prefix=compiler/rustc_codegen_cranelift/ \"$cg_clif\" sync_from_rust\n+        git fetch origin master\n+        git checkout \"$RUST_VERS\"\n+        \"$cg_clif/git-fixed-subtree.sh\" push --prefix=compiler/rustc_codegen_cranelift/ \"$cg_clif\" sync_from_rust\n         popd\n-        git merge sync_from_rust -m \"Sync from rust $rust_vers\"\n+        git merge sync_from_rust -m \"Sync from rust $RUST_VERS\"\n         git branch -d sync_from_rust\n         ;;\n     *)"}, {"sha": "abb09775d213511041756911473c75632643ef2a", "filename": "scripts/setup_rust_fork.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/scripts%2Fsetup_rust_fork.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/scripts%2Fsetup_rust_fork.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Fsetup_rust_fork.sh?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -10,7 +10,7 @@ git fetch\n git checkout -- .\n git checkout \"$(rustc -V | cut -d' ' -f3 | tr -d '(')\"\n \n-git -c user.name=Dummy -c user.email=dummy@example.com am ../patches/*-sysroot-*.patch\n+git -c user.name=Dummy -c user.email=dummy@example.com am ../patches/*-stdlib-*.patch\n \n git apply - <<EOF\n diff --git a/library/alloc/Cargo.toml b/library/alloc/Cargo.toml\n@@ -36,7 +36,7 @@ changelog-seen = 2\n ninja = false\n \n [build]\n-rustc = \"$(pwd)/../dist/rustc-clif\"\n+rustc = \"$(pwd)/../dist/bin/rustc-clif\"\n cargo = \"$(rustup which cargo)\"\n full-bootstrap = true\n local-rebuild = true"}, {"sha": "20dcb4cf34d2f8a4e6d2c61f08fda116fa85ce90", "filename": "scripts/test_rustc_tests.sh", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/scripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/scripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Ftest_rustc_tests.sh?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -21,6 +21,7 @@ done\n \n git checkout -- tests/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n git checkout -- tests/ui/proc-macro/pretty-print-hack/\n+rm tests/ui/parser/unclosed-delimiter-in-dep.rs # submodule contains //~ERROR\n \n # missing features\n # ================\n@@ -80,6 +81,7 @@ rm tests/ui/layout/valid_range_oob.rs # different ICE message\n \n rm tests/ui/consts/issue-miri-1910.rs # different error message\n rm tests/ui/consts/offset_ub.rs # same\n+rm tests/ui/consts/const-eval/ub-slice-get-unchecked.rs # same\n rm tests/ui/intrinsics/panic-uninitialized-zeroed.rs # same\n rm tests/ui/lint/lint-const-item-mutation.rs # same\n rm tests/ui/pattern/usefulness/doc-hidden-non-exhaustive.rs # same\n@@ -110,12 +112,9 @@ rm tests/incremental/spike-neg2.rs # same\n \n rm tests/ui/simd/intrinsic/generic-reduction-pass.rs # simd_reduce_add_unordered doesn't accept an accumulator for integer vectors\n \n-rm tests/ui/simd/intrinsic/generic-as.rs # crash when accessing vector type filed (#1318)\n+rm tests/ui/simd/intrinsic/generic-as.rs # crash when accessing vector type field (#1318)\n rm tests/ui/simd/simd-bitmask.rs # crash\n \n-rm tests/ui/dyn-star/dyn-star-to-dyn.rs\n-rm tests/ui/dyn-star/dispatch-on-pin-mut.rs\n-\n # bugs in the test suite\n # ======================\n rm tests/ui/backtrace.rs # TODO warning"}, {"sha": "3bc64c44524ed9c3e76e21df025d6a91541944ab", "filename": "src/abi/mod.rs", "status": "modified", "additions": 56, "deletions": 42, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -4,6 +4,8 @@ mod comments;\n mod pass_mode;\n mod returning;\n \n+use std::borrow::Cow;\n+\n use cranelift_module::ModuleError;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::layout::FnAbiOf;\n@@ -25,7 +27,7 @@ fn clif_sig_from_fn_abi<'tcx>(\n ) -> Signature {\n     let call_conv = conv_to_call_conv(tcx.sess, fn_abi.conv, default_call_conv);\n \n-    let inputs = fn_abi.args.iter().map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter()).flatten();\n+    let inputs = fn_abi.args.iter().flat_map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter());\n \n     let (return_ptr, returns) = fn_abi.ret.get_abi_return(tcx);\n     // Sometimes the first param is an pointer to the place where the return value needs to be stored.\n@@ -116,7 +118,52 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         params: Vec<AbiParam>,\n         returns: Vec<AbiParam>,\n         args: &[Value],\n-    ) -> &[Value] {\n+    ) -> Cow<'_, [Value]> {\n+        if self.tcx.sess.target.is_like_windows {\n+            let (mut params, mut args): (Vec<_>, Vec<_>) =\n+                params\n+                    .into_iter()\n+                    .zip(args)\n+                    .map(|(param, &arg)| {\n+                        if param.value_type == types::I128 {\n+                            let arg_ptr = Pointer::stack_slot(self.bcx.create_sized_stack_slot(\n+                                StackSlotData { kind: StackSlotKind::ExplicitSlot, size: 16 },\n+                            ));\n+                            arg_ptr.store(self, arg, MemFlags::trusted());\n+                            (AbiParam::new(self.pointer_type), arg_ptr.get_addr(self))\n+                        } else {\n+                            (param, arg)\n+                        }\n+                    })\n+                    .unzip();\n+\n+            let indirect_ret_val = returns.len() == 1 && returns[0].value_type == types::I128;\n+\n+            if indirect_ret_val {\n+                params.insert(0, AbiParam::new(self.pointer_type));\n+                let ret_ptr =\n+                    Pointer::stack_slot(self.bcx.create_sized_stack_slot(StackSlotData {\n+                        kind: StackSlotKind::ExplicitSlot,\n+                        size: 16,\n+                    }));\n+                args.insert(0, ret_ptr.get_addr(self));\n+                self.lib_call_unadjusted(name, params, vec![], &args);\n+                return Cow::Owned(vec![ret_ptr.load(self, types::I128, MemFlags::trusted())]);\n+            } else {\n+                return self.lib_call_unadjusted(name, params, returns, &args);\n+            }\n+        }\n+\n+        self.lib_call_unadjusted(name, params, returns, args)\n+    }\n+\n+    pub(crate) fn lib_call_unadjusted(\n+        &mut self,\n+        name: &str,\n+        params: Vec<AbiParam>,\n+        returns: Vec<AbiParam>,\n+        args: &[Value],\n+    ) -> Cow<'_, [Value]> {\n         let sig = Signature { params, returns, call_conv: self.target_config.default_call_conv };\n         let func_id = self.module.declare_function(name, Linkage::Import, &sig).unwrap();\n         let func_ref = self.module.declare_func_in_func(func_id, &mut self.bcx.func);\n@@ -125,41 +172,11 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         }\n         let call_inst = self.bcx.ins().call(func_ref, args);\n         if self.clif_comments.enabled() {\n-            self.add_comment(call_inst, format!(\"easy_call {}\", name));\n+            self.add_comment(call_inst, format!(\"lib_call {}\", name));\n         }\n         let results = self.bcx.inst_results(call_inst);\n         assert!(results.len() <= 2, \"{}\", results.len());\n-        results\n-    }\n-\n-    pub(crate) fn easy_call(\n-        &mut self,\n-        name: &str,\n-        args: &[CValue<'tcx>],\n-        return_ty: Ty<'tcx>,\n-    ) -> CValue<'tcx> {\n-        let (input_tys, args): (Vec<_>, Vec<_>) = args\n-            .iter()\n-            .map(|arg| {\n-                (AbiParam::new(self.clif_type(arg.layout().ty).unwrap()), arg.load_scalar(self))\n-            })\n-            .unzip();\n-        let return_layout = self.layout_of(return_ty);\n-        let return_tys = if let ty::Tuple(tup) = return_ty.kind() {\n-            tup.iter().map(|ty| AbiParam::new(self.clif_type(ty).unwrap())).collect()\n-        } else {\n-            vec![AbiParam::new(self.clif_type(return_ty).unwrap())]\n-        };\n-        let ret_vals = self.lib_call(name, input_tys, return_tys, &args);\n-        match *ret_vals {\n-            [] => CValue::by_ref(\n-                Pointer::const_addr(self, i64::from(self.pointer_type.bytes())),\n-                return_layout,\n-            ),\n-            [val] => CValue::by_val(val, return_layout),\n-            [val, extra] => CValue::by_val_pair(val, extra, return_layout),\n-            _ => unreachable!(),\n-        }\n+        Cow::Borrowed(results)\n     }\n }\n \n@@ -275,10 +292,6 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n     self::comments::add_locals_header_comment(fx);\n \n     for (local, arg_kind, ty) in func_params {\n-        let layout = fx.layout_of(ty);\n-\n-        let is_ssa = ssa_analyzed[local] == crate::analyze::SsaKind::Ssa;\n-\n         // While this is normally an optimization to prevent an unnecessary copy when an argument is\n         // not mutated by the current function, this is necessary to support unsized arguments.\n         if let ArgKind::Normal(Some(val)) = arg_kind {\n@@ -300,6 +313,8 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n             }\n         }\n \n+        let layout = fx.layout_of(ty);\n+        let is_ssa = ssa_analyzed[local].is_ssa(fx, ty);\n         let place = make_local_place(fx, local, layout, is_ssa);\n         assert_eq!(fx.local_map.push(place), local);\n \n@@ -323,7 +338,7 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n         let ty = fx.monomorphize(fx.mir.local_decls[local].ty);\n         let layout = fx.layout_of(ty);\n \n-        let is_ssa = ssa_analyzed[local] == crate::analyze::SsaKind::Ssa;\n+        let is_ssa = ssa_analyzed[local].is_ssa(fx, ty);\n \n         let place = make_local_place(fx, local, layout, is_ssa);\n         assert_eq!(fx.local_map.push(place), local);\n@@ -515,10 +530,9 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 args.into_iter()\n                     .enumerate()\n                     .skip(if first_arg_override.is_some() { 1 } else { 0 })\n-                    .map(|(i, arg)| {\n+                    .flat_map(|(i, arg)| {\n                         adjust_arg_for_abi(fx, arg.value, &fn_abi.args[i], arg.is_owned).into_iter()\n-                    })\n-                    .flatten(),\n+                    }),\n             )\n             .collect::<Vec<Value>>();\n "}, {"sha": "6d3e8eda276a4e29127a9ac988fa35ba0105cd73", "filename": "src/abi/returning.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -14,7 +14,8 @@ pub(super) fn codegen_return_param<'tcx>(\n ) -> CPlace<'tcx> {\n     let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n         PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(..) => {\n-            let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n+            let is_ssa =\n+                ssa_analyzed[RETURN_PLACE].is_ssa(fx, fx.fn_abi.as_ref().unwrap().ret.layout.ty);\n             (\n                 super::make_local_place(\n                     fx,"}, {"sha": "54d5c1c2ae9e9169f7c841e0d8bc5fa675d4573c", "filename": "src/analyze.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fanalyze.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -4,34 +4,30 @@ use crate::prelude::*;\n \n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::StatementKind::*;\n+use rustc_middle::ty::Ty;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub(crate) enum SsaKind {\n     NotSsa,\n-    Ssa,\n+    MaybeSsa,\n+}\n+\n+impl SsaKind {\n+    pub(crate) fn is_ssa<'tcx>(self, fx: &FunctionCx<'_, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+        self == SsaKind::MaybeSsa && (fx.clif_type(ty).is_some() || fx.clif_pair_type(ty).is_some())\n+    }\n }\n \n pub(crate) fn analyze(fx: &FunctionCx<'_, '_, '_>) -> IndexVec<Local, SsaKind> {\n-    let mut flag_map = fx\n-        .mir\n-        .local_decls\n-        .iter()\n-        .map(|local_decl| {\n-            let ty = fx.monomorphize(local_decl.ty);\n-            if fx.clif_type(ty).is_some() || fx.clif_pair_type(ty).is_some() {\n-                SsaKind::Ssa\n-            } else {\n-                SsaKind::NotSsa\n-            }\n-        })\n-        .collect::<IndexVec<Local, SsaKind>>();\n+    let mut flag_map =\n+        fx.mir.local_decls.iter().map(|_| SsaKind::MaybeSsa).collect::<IndexVec<Local, SsaKind>>();\n \n     for bb in fx.mir.basic_blocks.iter() {\n         for stmt in bb.statements.iter() {\n             match &stmt.kind {\n                 Assign(place_and_rval) => match &place_and_rval.1 {\n                     Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n-                        not_ssa(&mut flag_map, place.local)\n+                        flag_map[place.local] = SsaKind::NotSsa;\n                     }\n                     _ => {}\n                 },\n@@ -42,7 +38,3 @@ pub(crate) fn analyze(fx: &FunctionCx<'_, '_, '_>) -> IndexVec<Local, SsaKind> {\n \n     flag_map\n }\n-\n-fn not_ssa(flag_map: &mut IndexVec<Local, SsaKind>, local: Local) {\n-    flag_map[local] = SsaKind::NotSsa;\n-}"}, {"sha": "d0af3729b237c1cf93e927281b4159680a0aa33c", "filename": "src/base.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -192,7 +192,7 @@ pub(crate) fn compile_fn(\n                         let pass_times = cranelift_codegen::timing::take_current();\n                         // Replace newlines with | as measureme doesn't allow control characters like\n                         // newlines inside strings.\n-                        recorder.record_arg(format!(\"{}\", pass_times).replace(\"\\n\", \" | \"));\n+                        recorder.record_arg(format!(\"{}\", pass_times).replace('\\n', \" | \"));\n                         recording_args = true;\n                     },\n                 )\n@@ -365,11 +365,10 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                 fx.bcx.set_cold_block(failure);\n \n                 if *expected {\n-                    fx.bcx.ins().brz(cond, failure, &[]);\n+                    fx.bcx.ins().brif(cond, target, &[], failure, &[]);\n                 } else {\n-                    fx.bcx.ins().brnz(cond, failure, &[]);\n+                    fx.bcx.ins().brif(cond, failure, &[], target, &[]);\n                 };\n-                fx.bcx.ins().jump(target, &[]);\n \n                 fx.bcx.switch_to_block(failure);\n                 fx.bcx.ins().nop();\n@@ -425,11 +424,9 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                         }\n                     } else {\n                         if test_zero {\n-                            fx.bcx.ins().brz(discr, then_block, &[]);\n-                            fx.bcx.ins().jump(else_block, &[]);\n+                            fx.bcx.ins().brif(discr, else_block, &[], then_block, &[]);\n                         } else {\n-                            fx.bcx.ins().brnz(discr, then_block, &[]);\n-                            fx.bcx.ins().jump(else_block, &[]);\n+                            fx.bcx.ins().brif(discr, then_block, &[], else_block, &[]);\n                         }\n                     }\n                 } else {\n@@ -750,8 +747,7 @@ fn codegen_stmt<'tcx>(\n \n                         fx.bcx.switch_to_block(loop_block);\n                         let done = fx.bcx.ins().icmp_imm(IntCC::Equal, index, times as i64);\n-                        fx.bcx.ins().brnz(done, done_block, &[]);\n-                        fx.bcx.ins().jump(loop_block2, &[]);\n+                        fx.bcx.ins().brif(done, done_block, &[], loop_block2, &[]);\n \n                         fx.bcx.switch_to_block(loop_block2);\n                         let to = lval.place_index(fx, index);\n@@ -997,7 +993,7 @@ fn codegen_panic_inner<'tcx>(\n     let symbol_name = fx.tcx.symbol_name(instance).name;\n \n     fx.lib_call(\n-        &*symbol_name,\n+        symbol_name,\n         args.iter().map(|&arg| AbiParam::new(fx.bcx.func.dfg.value_type(arg))).collect(),\n         vec![],\n         args,"}, {"sha": "032d1151041dbb45b28442075d464a7edae1bb6f", "filename": "src/cast.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -64,17 +64,12 @@ pub(crate) fn clif_int_or_float_cast(\n                 },\n             );\n \n-            let from_rust_ty = if from_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n-\n-            let to_rust_ty = match to_ty {\n-                types::F32 => fx.tcx.types.f32,\n-                types::F64 => fx.tcx.types.f64,\n-                _ => unreachable!(),\n-            };\n-\n-            return fx\n-                .easy_call(&name, &[CValue::by_val(from, fx.layout_of(from_rust_ty))], to_rust_ty)\n-                .load_scalar(fx);\n+            return fx.lib_call(\n+                &name,\n+                vec![AbiParam::new(types::I128)],\n+                vec![AbiParam::new(to_ty)],\n+                &[from],\n+            )[0];\n         }\n \n         // int-like -> float\n@@ -101,16 +96,29 @@ pub(crate) fn clif_int_or_float_cast(\n                 },\n             );\n \n-            let from_rust_ty = match from_ty {\n-                types::F32 => fx.tcx.types.f32,\n-                types::F64 => fx.tcx.types.f64,\n-                _ => unreachable!(),\n-            };\n-\n-            let to_rust_ty = if to_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n-\n-            fx.easy_call(&name, &[CValue::by_val(from, fx.layout_of(from_rust_ty))], to_rust_ty)\n-                .load_scalar(fx)\n+            if fx.tcx.sess.target.is_like_windows {\n+                let ret = fx.lib_call(\n+                    &name,\n+                    vec![AbiParam::new(from_ty)],\n+                    vec![AbiParam::new(types::I64X2)],\n+                    &[from],\n+                )[0];\n+                // FIXME use bitcast instead of store to get from i64x2 to i128\n+                let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n+                    kind: StackSlotKind::ExplicitSlot,\n+                    size: 16,\n+                });\n+                let ret_ptr = Pointer::stack_slot(stack_slot);\n+                ret_ptr.store(fx, ret, MemFlags::trusted());\n+                ret_ptr.load(fx, types::I128, MemFlags::trusted())\n+            } else {\n+                fx.lib_call(\n+                    &name,\n+                    vec![AbiParam::new(from_ty)],\n+                    vec![AbiParam::new(types::I128)],\n+                    &[from],\n+                )[0]\n+            }\n         } else if to_ty == types::I8 || to_ty == types::I16 {\n             // FIXME implement fcvt_to_*int_sat.i8/i16\n             let val = if to_signed {"}, {"sha": "f674ce776a68697da60a5de8e30413bc373e38df", "filename": "src/codegen_i128.rs", "status": "modified", "additions": 28, "deletions": 57, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -29,39 +29,24 @@ pub(crate) fn maybe_codegen<'tcx>(\n         BinOp::Add | BinOp::Sub if !checked => None,\n         BinOp::Mul if !checked || is_signed => {\n             if !checked {\n-                let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n-                if fx.tcx.sess.target.is_like_windows {\n-                    let ret_place = CPlace::new_stack_slot(fx, lhs.layout());\n-                    let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n-                    let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n-                    assert!(lhs_extra.is_none());\n-                    assert!(rhs_extra.is_none());\n-                    let args = [\n-                        ret_place.to_ptr().get_addr(fx),\n-                        lhs_ptr.get_addr(fx),\n-                        rhs_ptr.get_addr(fx),\n-                    ];\n-                    fx.lib_call(\n-                        \"__multi3\",\n-                        vec![\n-                            AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n-                            AbiParam::new(fx.pointer_type),\n-                            AbiParam::new(fx.pointer_type),\n-                        ],\n-                        vec![],\n-                        &args,\n-                    );\n-                    Some(ret_place.to_cvalue(fx))\n-                } else {\n-                    Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n-                }\n+                let args = [lhs.load_scalar(fx), rhs.load_scalar(fx)];\n+                let ret_val = fx.lib_call(\n+                    \"__multi3\",\n+                    vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n+                    vec![AbiParam::new(types::I128)],\n+                    &args,\n+                )[0];\n+                Some(CValue::by_val(\n+                    ret_val,\n+                    fx.layout_of(if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 }),\n+                ))\n             } else {\n                 let out_ty = fx.tcx.mk_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n                 let oflow = CPlace::new_stack_slot(fx, fx.layout_of(fx.tcx.types.i32));\n                 let lhs = lhs.load_scalar(fx);\n                 let rhs = rhs.load_scalar(fx);\n                 let oflow_ptr = oflow.to_ptr().get_addr(fx);\n-                let res = fx.lib_call(\n+                let res = fx.lib_call_unadjusted(\n                     \"__muloti4\",\n                     vec![\n                         AbiParam::new(types::I128),\n@@ -80,29 +65,12 @@ pub(crate) fn maybe_codegen<'tcx>(\n             assert!(checked);\n             let out_ty = fx.tcx.mk_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n             let out_place = CPlace::new_stack_slot(fx, fx.layout_of(out_ty));\n-            let (param_types, args) = if fx.tcx.sess.target.is_like_windows {\n-                let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n-                let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n-                assert!(lhs_extra.is_none());\n-                assert!(rhs_extra.is_none());\n-                (\n-                    vec![\n-                        AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n-                        AbiParam::new(fx.pointer_type),\n-                        AbiParam::new(fx.pointer_type),\n-                    ],\n-                    [out_place.to_ptr().get_addr(fx), lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)],\n-                )\n-            } else {\n-                (\n-                    vec![\n-                        AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n-                        AbiParam::new(types::I128),\n-                        AbiParam::new(types::I128),\n-                    ],\n-                    [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)],\n-                )\n-            };\n+            let param_types = vec![\n+                AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n+                AbiParam::new(types::I128),\n+                AbiParam::new(types::I128),\n+            ];\n+            let args = [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)];\n             let name = match (bin_op, is_signed) {\n                 (BinOp::Add, false) => \"__rust_u128_addo\",\n                 (BinOp::Add, true) => \"__rust_i128_addo\",\n@@ -125,14 +93,10 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 _ => unreachable!(),\n             };\n             if fx.tcx.sess.target.is_like_windows {\n-                let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n-                let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n-                assert!(lhs_extra.is_none());\n-                assert!(rhs_extra.is_none());\n-                let args = [lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)];\n+                let args = [lhs.load_scalar(fx), rhs.load_scalar(fx)];\n                 let ret = fx.lib_call(\n                     name,\n-                    vec![AbiParam::new(fx.pointer_type), AbiParam::new(fx.pointer_type)],\n+                    vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n                     vec![AbiParam::new(types::I64X2)],\n                     &args,\n                 )[0];\n@@ -141,7 +105,14 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 ret_place.to_ptr().store(fx, ret, MemFlags::trusted());\n                 Some(ret_place.to_cvalue(fx))\n             } else {\n-                Some(fx.easy_call(name, &[lhs, rhs], lhs.layout().ty))\n+                let args = [lhs.load_scalar(fx), rhs.load_scalar(fx)];\n+                let ret_val = fx.lib_call(\n+                    name,\n+                    vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n+                    vec![AbiParam::new(types::I128)],\n+                    &args,\n+                )[0];\n+                Some(CValue::by_val(ret_val, lhs.layout()))\n             }\n         }\n         BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => {"}, {"sha": "d39bf700035f97e0a4ddc79c554ae3ac7f5c7656", "filename": "src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -75,7 +75,7 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n         ty::Adt(adt_def, _) if adt_def.repr().simd() => {\n             let (element, count) = match &tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().abi\n             {\n-                Abi::Vector { element, count } => (element.clone(), *count),\n+                Abi::Vector { element, count } => (*element, *count),\n                 _ => unreachable!(),\n             };\n "}, {"sha": "f3b963200a0fb022f34bc48a2307b9c114830ace", "filename": "src/compiler_builtins.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fcompiler_builtins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fcompiler_builtins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiler_builtins.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -39,6 +39,7 @@ builtin_functions! {\n \n     // integers\n     fn __multi3(a: i128, b: i128) -> i128;\n+    fn __muloti4(n: i128, d: i128, oflow: &mut i32) -> i128;\n     fn __udivti3(n: u128, d: u128) -> u128;\n     fn __divti3(n: i128, d: i128) -> i128;\n     fn __umodti3(n: u128, d: u128) -> u128;"}, {"sha": "203219a8a754a6dbc6e548112d876324a750970d", "filename": "src/concurrency_limiter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fconcurrency_limiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fconcurrency_limiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency_limiter.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -32,7 +32,7 @@ impl ConcurrencyLimiter {\n         ConcurrencyLimiter {\n             helper_thread: Some(helper_thread),\n             state,\n-            available_token_condvar: Arc::new(Condvar::new()),\n+            available_token_condvar,\n             finished: false,\n         }\n     }"}, {"sha": "31278f810e911b3d5cc11a512643fd762979559e", "filename": "src/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -290,7 +290,7 @@ fn data_id_for_static(\n         };\n \n         let data_id = match module.declare_data(\n-            &*symbol_name,\n+            symbol_name,\n             linkage,\n             is_mutable,\n             attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n@@ -338,7 +338,7 @@ fn data_id_for_static(\n     };\n \n     let data_id = match module.declare_data(\n-        &*symbol_name,\n+        symbol_name,\n         linkage,\n         is_mutable,\n         attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),"}, {"sha": "6c4efca442448a700d77e946edb926ab02e8ced9", "filename": "src/cranelift_native.rs", "status": "removed", "additions": 0, "deletions": 248, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/2c122a8926274dc6bdedcbef7974539f05af627a/src%2Fcranelift_native.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c122a8926274dc6bdedcbef7974539f05af627a/src%2Fcranelift_native.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcranelift_native.rs?ref=2c122a8926274dc6bdedcbef7974539f05af627a", "patch": "@@ -1,248 +0,0 @@\n-// Vendored from https://github.com/bytecodealliance/wasmtime/blob/b58a197d33f044193c3d608010f5e6ec394ac07e/cranelift/native/src/lib.rs\n-// which is licensed as\n-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n-// unlike rustc_codegen_cranelift itself. Also applies a small change to remove #![cfg_attr] that\n-// rust's CI complains about and to fix formatting to match rustc.\n-// FIXME revert back to the external crate with Cranelift 0.93\n-#![allow(warnings)]\n-\n-//! Performs autodetection of the host for the purposes of running\n-//! Cranelift to generate code to run on the same machine.\n-\n-#![deny(missing_docs, trivial_numeric_casts, unused_extern_crates, unstable_features)]\n-#![warn(unused_import_braces)]\n-\n-use cranelift_codegen::isa;\n-use target_lexicon::Triple;\n-\n-/// Return an `isa` builder configured for the current host\n-/// machine, or `Err(())` if the host machine is not supported\n-/// in the current configuration.\n-pub fn builder() -> Result<isa::Builder, &'static str> {\n-    builder_with_options(true)\n-}\n-\n-/// Return an `isa` builder configured for the current host\n-/// machine, or `Err(())` if the host machine is not supported\n-/// in the current configuration.\n-///\n-/// Selects the given backend variant specifically; this is\n-/// useful when more than oen backend exists for a given target\n-/// (e.g., on x86-64).\n-pub fn builder_with_options(infer_native_flags: bool) -> Result<isa::Builder, &'static str> {\n-    let mut isa_builder = isa::lookup(Triple::host()).map_err(|err| match err {\n-        isa::LookupError::SupportDisabled => \"support for architecture disabled at compile time\",\n-        isa::LookupError::Unsupported => \"unsupported architecture\",\n-    })?;\n-\n-    #[cfg(target_arch = \"x86_64\")]\n-    {\n-        use cranelift_codegen::settings::Configurable;\n-\n-        if !std::is_x86_feature_detected!(\"sse2\") {\n-            return Err(\"x86 support requires SSE2\");\n-        }\n-\n-        if !infer_native_flags {\n-            return Ok(isa_builder);\n-        }\n-\n-        // These are temporarily enabled by default (see #3810 for\n-        // more) so that a default-constructed `Flags` can work with\n-        // default Wasmtime features. Otherwise, the user must\n-        // explicitly use native flags or turn these on when on x86-64\n-        // platforms to avoid a configuration panic. In order for the\n-        // \"enable if detected\" logic below to work, we must turn them\n-        // *off* (differing from the default) and then re-enable below\n-        // if present.\n-        isa_builder.set(\"has_sse3\", \"false\").unwrap();\n-        isa_builder.set(\"has_ssse3\", \"false\").unwrap();\n-        isa_builder.set(\"has_sse41\", \"false\").unwrap();\n-        isa_builder.set(\"has_sse42\", \"false\").unwrap();\n-\n-        if std::is_x86_feature_detected!(\"sse3\") {\n-            isa_builder.enable(\"has_sse3\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"ssse3\") {\n-            isa_builder.enable(\"has_ssse3\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"sse4.1\") {\n-            isa_builder.enable(\"has_sse41\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"sse4.2\") {\n-            isa_builder.enable(\"has_sse42\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"popcnt\") {\n-            isa_builder.enable(\"has_popcnt\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx\") {\n-            isa_builder.enable(\"has_avx\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx2\") {\n-            isa_builder.enable(\"has_avx2\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"fma\") {\n-            isa_builder.enable(\"has_fma\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"bmi1\") {\n-            isa_builder.enable(\"has_bmi1\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"bmi2\") {\n-            isa_builder.enable(\"has_bmi2\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx512bitalg\") {\n-            isa_builder.enable(\"has_avx512bitalg\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx512dq\") {\n-            isa_builder.enable(\"has_avx512dq\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx512f\") {\n-            isa_builder.enable(\"has_avx512f\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx512vl\") {\n-            isa_builder.enable(\"has_avx512vl\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx512vbmi\") {\n-            isa_builder.enable(\"has_avx512vbmi\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"lzcnt\") {\n-            isa_builder.enable(\"has_lzcnt\").unwrap();\n-        }\n-    }\n-\n-    #[cfg(target_arch = \"aarch64\")]\n-    {\n-        use cranelift_codegen::settings::Configurable;\n-\n-        if !infer_native_flags {\n-            return Ok(isa_builder);\n-        }\n-\n-        if std::arch::is_aarch64_feature_detected!(\"lse\") {\n-            isa_builder.enable(\"has_lse\").unwrap();\n-        }\n-\n-        if std::arch::is_aarch64_feature_detected!(\"paca\") {\n-            isa_builder.enable(\"has_pauth\").unwrap();\n-        }\n-\n-        if cfg!(target_os = \"macos\") {\n-            // Pointer authentication is always available on Apple Silicon.\n-            isa_builder.enable(\"sign_return_address\").unwrap();\n-            // macOS enforces the use of the B key for return addresses.\n-            isa_builder.enable(\"sign_return_address_with_bkey\").unwrap();\n-        }\n-    }\n-\n-    // There is no is_s390x_feature_detected macro yet, so for now\n-    // we use getauxval from the libc crate directly.\n-    #[cfg(all(target_arch = \"s390x\", target_os = \"linux\"))]\n-    {\n-        use cranelift_codegen::settings::Configurable;\n-\n-        if !infer_native_flags {\n-            return Ok(isa_builder);\n-        }\n-\n-        let v = unsafe { libc::getauxval(libc::AT_HWCAP) };\n-        const HWCAP_S390X_VXRS_EXT2: libc::c_ulong = 32768;\n-        if (v & HWCAP_S390X_VXRS_EXT2) != 0 {\n-            isa_builder.enable(\"has_vxrs_ext2\").unwrap();\n-            // There is no separate HWCAP bit for mie2, so assume\n-            // that any machine with vxrs_ext2 also has mie2.\n-            isa_builder.enable(\"has_mie2\").unwrap();\n-        }\n-    }\n-\n-    // `is_riscv_feature_detected` is nightly only for now, use\n-    // getauxval from the libc crate directly as a temporary measure.\n-    #[cfg(all(target_arch = \"riscv64\", target_os = \"linux\"))]\n-    {\n-        use cranelift_codegen::settings::Configurable;\n-\n-        if !infer_native_flags {\n-            return Ok(isa_builder);\n-        }\n-\n-        let v = unsafe { libc::getauxval(libc::AT_HWCAP) };\n-\n-        const HWCAP_RISCV_EXT_A: libc::c_ulong = 1 << (b'a' - b'a');\n-        const HWCAP_RISCV_EXT_C: libc::c_ulong = 1 << (b'c' - b'a');\n-        const HWCAP_RISCV_EXT_D: libc::c_ulong = 1 << (b'd' - b'a');\n-        const HWCAP_RISCV_EXT_F: libc::c_ulong = 1 << (b'f' - b'a');\n-        const HWCAP_RISCV_EXT_M: libc::c_ulong = 1 << (b'm' - b'a');\n-        const HWCAP_RISCV_EXT_V: libc::c_ulong = 1 << (b'v' - b'a');\n-\n-        if (v & HWCAP_RISCV_EXT_A) != 0 {\n-            isa_builder.enable(\"has_a\").unwrap();\n-        }\n-\n-        if (v & HWCAP_RISCV_EXT_C) != 0 {\n-            isa_builder.enable(\"has_c\").unwrap();\n-        }\n-\n-        if (v & HWCAP_RISCV_EXT_D) != 0 {\n-            isa_builder.enable(\"has_d\").unwrap();\n-        }\n-\n-        if (v & HWCAP_RISCV_EXT_F) != 0 {\n-            isa_builder.enable(\"has_f\").unwrap();\n-\n-            // TODO: There doesn't seem to be a bit associated with this extension\n-            // rust enables it with the `f` extension:\n-            // https://github.com/rust-lang/stdarch/blob/790411f93c4b5eada3c23abb4c9a063fb0b24d99/crates/std_detect/src/detect/os/linux/riscv.rs#L43\n-            isa_builder.enable(\"has_zicsr\").unwrap();\n-        }\n-\n-        if (v & HWCAP_RISCV_EXT_M) != 0 {\n-            isa_builder.enable(\"has_m\").unwrap();\n-        }\n-\n-        if (v & HWCAP_RISCV_EXT_V) != 0 {\n-            isa_builder.enable(\"has_v\").unwrap();\n-        }\n-\n-        // TODO: ZiFencei does not have a bit associated with it\n-        // TODO: Zbkb does not have a bit associated with it\n-    }\n-\n-    // squelch warnings about unused mut/variables on some platforms.\n-    drop(&mut isa_builder);\n-    drop(infer_native_flags);\n-\n-    Ok(isa_builder)\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::builder;\n-    use cranelift_codegen::isa::CallConv;\n-    use cranelift_codegen::settings;\n-\n-    #[test]\n-    fn test() {\n-        if let Ok(isa_builder) = builder() {\n-            let flag_builder = settings::builder();\n-            let isa = isa_builder.finish(settings::Flags::new(flag_builder)).unwrap();\n-\n-            if cfg!(all(target_os = \"macos\", target_arch = \"aarch64\")) {\n-                assert_eq!(isa.default_call_conv(), CallConv::AppleAarch64);\n-            } else if cfg!(any(unix, target_os = \"nebulet\")) {\n-                assert_eq!(isa.default_call_conv(), CallConv::SystemV);\n-            } else if cfg!(windows) {\n-                assert_eq!(isa.default_call_conv(), CallConv::WindowsFastcall);\n-            }\n-\n-            if cfg!(target_pointer_width = \"64\") {\n-                assert_eq!(isa.pointer_bits(), 64);\n-            } else if cfg!(target_pointer_width = \"32\") {\n-                assert_eq!(isa.pointer_bits(), 32);\n-            } else if cfg!(target_pointer_width = \"16\") {\n-                assert_eq!(isa.pointer_bits(), 16);\n-            }\n-        }\n-    }\n-}\n-\n-/// Version number of this crate.\n-pub const VERSION: &str = env!(\"CARGO_PKG_VERSION\");"}, {"sha": "c4a5627e662f1d06907855640591c6cb985153c2", "filename": "src/debuginfo/emit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Femit.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -113,7 +113,7 @@ impl Writer for WriterRelocate {\n                     offset: offset as u32,\n                     size,\n                     name: DebugRelocName::Symbol(symbol),\n-                    addend: addend as i64,\n+                    addend,\n                     kind: object::RelocationKind::Absolute,\n                 });\n                 self.write_udata(0, size)"}, {"sha": "3e2e2af968860978c8655162c58660d31d40dcf0", "filename": "src/driver/aot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Faot.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -377,7 +377,7 @@ pub(crate) fn run_aot(\n     };\n \n     if tcx.dep_graph.is_fully_enabled() {\n-        for cgu in &*cgus {\n+        for cgu in cgus {\n             tcx.ensure().codegen_unit(cgu.name());\n         }\n     }\n@@ -417,7 +417,7 @@ pub(crate) fn run_aot(\n                     CguReuse::PreLto => unreachable!(),\n                     CguReuse::PostLto => {\n                         concurrency_limiter.job_already_done();\n-                        OngoingModuleCodegen::Sync(reuse_workproduct_for_cgu(tcx, &*cgu))\n+                        OngoingModuleCodegen::Sync(reuse_workproduct_for_cgu(tcx, cgu))\n                     }\n                 }\n             })"}, {"sha": "f6a48e3257bc246f8731b40fc9142f54c65fb585", "filename": "src/driver/jit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fjit.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -311,7 +311,11 @@ fn dep_symbol_lookup_fn(\n         .find(|(crate_type, _data)| *crate_type == rustc_session::config::CrateType::Executable)\n         .unwrap()\n         .1;\n-    for &cnum in &crate_info.used_crates {\n+    // `used_crates` is in reverse postorder in terms of dependencies. Reverse the order here to\n+    // get a postorder which ensures that all dependencies of a dylib are loaded before the dylib\n+    // itself. This helps the dynamic linker to find dylibs not in the regular dynamic library\n+    // search path.\n+    for &cnum in crate_info.used_crates.iter().rev() {\n         let src = &crate_info.used_crate_source[&cnum];\n         match data[cnum.as_usize() - 1] {\n             Linkage::NotLinked | Linkage::IncludedFromDylib => {}"}, {"sha": "a74f8ffa23d43546acd606b4af8fdb356a8d5d51", "filename": "src/global_asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fglobal_asm.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -125,7 +125,7 @@ pub(crate) fn compile_global_asm(\n     let output_object_file = config.output_filenames.temp_path(OutputType::Object, Some(cgu_name));\n \n     // Assemble `global_asm`\n-    let global_asm_object_file = add_file_stem_postfix(output_object_file.clone(), \".asm\");\n+    let global_asm_object_file = add_file_stem_postfix(output_object_file, \".asm\");\n     let mut child = Command::new(&config.assembler)\n         .arg(\"-o\")\n         .arg(&global_asm_object_file)"}, {"sha": "3ba530c040f7f9236df19902f083896f6074dcc8", "filename": "src/inline_asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -242,7 +242,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                 }\n             }\n             InlineAsmOperand::Const { ref value } => {\n-                let (const_value, ty) = crate::constant::eval_mir_constant(fx, &*value)\n+                let (const_value, ty) = crate::constant::eval_mir_constant(fx, value)\n                     .unwrap_or_else(|| span_bug!(span, \"asm const cannot be resolved\"));\n                 let value = rustc_codegen_ssa::common::asm_const_to_str(\n                     fx.tcx,\n@@ -334,13 +334,13 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n             }\n             CInlineAsmOperand::Out { reg: _, late: _, place } => {\n                 if let Some(place) = place {\n-                    outputs.push((asm_gen.stack_slots_output[i].unwrap(), place.clone()));\n+                    outputs.push((asm_gen.stack_slots_output[i].unwrap(), *place));\n                 }\n             }\n             CInlineAsmOperand::InOut { reg: _, _late: _, in_value, out_place } => {\n                 inputs.push((asm_gen.stack_slots_input[i].unwrap(), in_value.load_scalar(fx)));\n                 if let Some(out_place) = out_place {\n-                    outputs.push((asm_gen.stack_slots_output[i].unwrap(), out_place.clone()));\n+                    outputs.push((asm_gen.stack_slots_output[i].unwrap(), *out_place));\n                 }\n             }\n             CInlineAsmOperand::Const { value: _ } | CInlineAsmOperand::Symbol { symbol: _ } => {}"}, {"sha": "fe48cac4faf1a14001cfac2e53a13c252bd94db7", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 78, "deletions": 77, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -23,7 +23,7 @@ pub(crate) use llvm::codegen_llvm_intrinsic_call;\n \n use rustc_middle::ty;\n use rustc_middle::ty::layout::{HasParamEnv, ValidityRequirement};\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n+use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n@@ -252,45 +252,45 @@ fn codegen_float_intrinsic_call<'tcx>(\n     args: &[mir::Operand<'tcx>],\n     ret: CPlace<'tcx>,\n ) -> bool {\n-    let (name, arg_count, ty) = match intrinsic {\n-        sym::expf32 => (\"expf\", 1, fx.tcx.types.f32),\n-        sym::expf64 => (\"exp\", 1, fx.tcx.types.f64),\n-        sym::exp2f32 => (\"exp2f\", 1, fx.tcx.types.f32),\n-        sym::exp2f64 => (\"exp2\", 1, fx.tcx.types.f64),\n-        sym::sqrtf32 => (\"sqrtf\", 1, fx.tcx.types.f32),\n-        sym::sqrtf64 => (\"sqrt\", 1, fx.tcx.types.f64),\n-        sym::powif32 => (\"__powisf2\", 2, fx.tcx.types.f32), // compiler-builtins\n-        sym::powif64 => (\"__powidf2\", 2, fx.tcx.types.f64), // compiler-builtins\n-        sym::powf32 => (\"powf\", 2, fx.tcx.types.f32),\n-        sym::powf64 => (\"pow\", 2, fx.tcx.types.f64),\n-        sym::logf32 => (\"logf\", 1, fx.tcx.types.f32),\n-        sym::logf64 => (\"log\", 1, fx.tcx.types.f64),\n-        sym::log2f32 => (\"log2f\", 1, fx.tcx.types.f32),\n-        sym::log2f64 => (\"log2\", 1, fx.tcx.types.f64),\n-        sym::log10f32 => (\"log10f\", 1, fx.tcx.types.f32),\n-        sym::log10f64 => (\"log10\", 1, fx.tcx.types.f64),\n-        sym::fabsf32 => (\"fabsf\", 1, fx.tcx.types.f32),\n-        sym::fabsf64 => (\"fabs\", 1, fx.tcx.types.f64),\n-        sym::fmaf32 => (\"fmaf\", 3, fx.tcx.types.f32),\n-        sym::fmaf64 => (\"fma\", 3, fx.tcx.types.f64),\n-        sym::copysignf32 => (\"copysignf\", 2, fx.tcx.types.f32),\n-        sym::copysignf64 => (\"copysign\", 2, fx.tcx.types.f64),\n-        sym::floorf32 => (\"floorf\", 1, fx.tcx.types.f32),\n-        sym::floorf64 => (\"floor\", 1, fx.tcx.types.f64),\n-        sym::ceilf32 => (\"ceilf\", 1, fx.tcx.types.f32),\n-        sym::ceilf64 => (\"ceil\", 1, fx.tcx.types.f64),\n-        sym::truncf32 => (\"truncf\", 1, fx.tcx.types.f32),\n-        sym::truncf64 => (\"trunc\", 1, fx.tcx.types.f64),\n-        sym::rintf32 => (\"rintf\", 1, fx.tcx.types.f32),\n-        sym::rintf64 => (\"rint\", 1, fx.tcx.types.f64),\n-        sym::roundf32 => (\"roundf\", 1, fx.tcx.types.f32),\n-        sym::roundf64 => (\"round\", 1, fx.tcx.types.f64),\n-        sym::roundevenf32 => (\"roundevenf\", 1, fx.tcx.types.f32),\n-        sym::roundevenf64 => (\"roundeven\", 1, fx.tcx.types.f64),\n-        sym::sinf32 => (\"sinf\", 1, fx.tcx.types.f32),\n-        sym::sinf64 => (\"sin\", 1, fx.tcx.types.f64),\n-        sym::cosf32 => (\"cosf\", 1, fx.tcx.types.f32),\n-        sym::cosf64 => (\"cos\", 1, fx.tcx.types.f64),\n+    let (name, arg_count, ty, clif_ty) = match intrinsic {\n+        sym::expf32 => (\"expf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::expf64 => (\"exp\", 1, fx.tcx.types.f64, types::F64),\n+        sym::exp2f32 => (\"exp2f\", 1, fx.tcx.types.f32, types::F32),\n+        sym::exp2f64 => (\"exp2\", 1, fx.tcx.types.f64, types::F64),\n+        sym::sqrtf32 => (\"sqrtf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::sqrtf64 => (\"sqrt\", 1, fx.tcx.types.f64, types::F64),\n+        sym::powif32 => (\"__powisf2\", 2, fx.tcx.types.f32, types::F32), // compiler-builtins\n+        sym::powif64 => (\"__powidf2\", 2, fx.tcx.types.f64, types::F64), // compiler-builtins\n+        sym::powf32 => (\"powf\", 2, fx.tcx.types.f32, types::F32),\n+        sym::powf64 => (\"pow\", 2, fx.tcx.types.f64, types::F64),\n+        sym::logf32 => (\"logf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::logf64 => (\"log\", 1, fx.tcx.types.f64, types::F64),\n+        sym::log2f32 => (\"log2f\", 1, fx.tcx.types.f32, types::F32),\n+        sym::log2f64 => (\"log2\", 1, fx.tcx.types.f64, types::F64),\n+        sym::log10f32 => (\"log10f\", 1, fx.tcx.types.f32, types::F32),\n+        sym::log10f64 => (\"log10\", 1, fx.tcx.types.f64, types::F64),\n+        sym::fabsf32 => (\"fabsf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::fabsf64 => (\"fabs\", 1, fx.tcx.types.f64, types::F64),\n+        sym::fmaf32 => (\"fmaf\", 3, fx.tcx.types.f32, types::F32),\n+        sym::fmaf64 => (\"fma\", 3, fx.tcx.types.f64, types::F64),\n+        sym::copysignf32 => (\"copysignf\", 2, fx.tcx.types.f32, types::F32),\n+        sym::copysignf64 => (\"copysign\", 2, fx.tcx.types.f64, types::F64),\n+        sym::floorf32 => (\"floorf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::floorf64 => (\"floor\", 1, fx.tcx.types.f64, types::F64),\n+        sym::ceilf32 => (\"ceilf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::ceilf64 => (\"ceil\", 1, fx.tcx.types.f64, types::F64),\n+        sym::truncf32 => (\"truncf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::truncf64 => (\"trunc\", 1, fx.tcx.types.f64, types::F64),\n+        sym::rintf32 => (\"rintf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::rintf64 => (\"rint\", 1, fx.tcx.types.f64, types::F64),\n+        sym::roundf32 => (\"roundf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::roundf64 => (\"round\", 1, fx.tcx.types.f64, types::F64),\n+        sym::roundevenf32 => (\"roundevenf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::roundevenf64 => (\"roundeven\", 1, fx.tcx.types.f64, types::F64),\n+        sym::sinf32 => (\"sinf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::sinf64 => (\"sin\", 1, fx.tcx.types.f64, types::F64),\n+        sym::cosf32 => (\"cosf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::cosf64 => (\"cos\", 1, fx.tcx.types.f64, types::F64),\n         _ => return false,\n     };\n \n@@ -301,15 +301,19 @@ fn codegen_float_intrinsic_call<'tcx>(\n     let (a, b, c);\n     let args = match args {\n         [x] => {\n-            a = [codegen_operand(fx, x)];\n+            a = [codegen_operand(fx, x).load_scalar(fx)];\n             &a as &[_]\n         }\n         [x, y] => {\n-            b = [codegen_operand(fx, x), codegen_operand(fx, y)];\n+            b = [codegen_operand(fx, x).load_scalar(fx), codegen_operand(fx, y).load_scalar(fx)];\n             &b\n         }\n         [x, y, z] => {\n-            c = [codegen_operand(fx, x), codegen_operand(fx, y), codegen_operand(fx, z)];\n+            c = [\n+                codegen_operand(fx, x).load_scalar(fx),\n+                codegen_operand(fx, y).load_scalar(fx),\n+                codegen_operand(fx, z).load_scalar(fx),\n+            ];\n             &c\n         }\n         _ => unreachable!(),\n@@ -318,15 +322,10 @@ fn codegen_float_intrinsic_call<'tcx>(\n     let layout = fx.layout_of(ty);\n     let res = match intrinsic {\n         sym::fmaf32 | sym::fmaf64 => {\n-            let a = args[0].load_scalar(fx);\n-            let b = args[1].load_scalar(fx);\n-            let c = args[2].load_scalar(fx);\n-            CValue::by_val(fx.bcx.ins().fma(a, b, c), layout)\n+            CValue::by_val(fx.bcx.ins().fma(args[0], args[1], args[2]), layout)\n         }\n         sym::copysignf32 | sym::copysignf64 => {\n-            let a = args[0].load_scalar(fx);\n-            let b = args[1].load_scalar(fx);\n-            CValue::by_val(fx.bcx.ins().fcopysign(a, b), layout)\n+            CValue::by_val(fx.bcx.ins().fcopysign(args[0], args[1]), layout)\n         }\n         sym::fabsf32\n         | sym::fabsf64\n@@ -336,21 +335,29 @@ fn codegen_float_intrinsic_call<'tcx>(\n         | sym::ceilf64\n         | sym::truncf32\n         | sym::truncf64 => {\n-            let a = args[0].load_scalar(fx);\n-\n             let val = match intrinsic {\n-                sym::fabsf32 | sym::fabsf64 => fx.bcx.ins().fabs(a),\n-                sym::floorf32 | sym::floorf64 => fx.bcx.ins().floor(a),\n-                sym::ceilf32 | sym::ceilf64 => fx.bcx.ins().ceil(a),\n-                sym::truncf32 | sym::truncf64 => fx.bcx.ins().trunc(a),\n+                sym::fabsf32 | sym::fabsf64 => fx.bcx.ins().fabs(args[0]),\n+                sym::floorf32 | sym::floorf64 => fx.bcx.ins().floor(args[0]),\n+                sym::ceilf32 | sym::ceilf64 => fx.bcx.ins().ceil(args[0]),\n+                sym::truncf32 | sym::truncf64 => fx.bcx.ins().trunc(args[0]),\n                 _ => unreachable!(),\n             };\n \n             CValue::by_val(val, layout)\n         }\n+\n         // These intrinsics aren't supported natively by Cranelift.\n         // Lower them to a libcall.\n-        _ => fx.easy_call(name, &args, ty),\n+        sym::powif32 | sym::powif64 => {\n+            let input_tys: Vec<_> = vec![AbiParam::new(clif_ty), AbiParam::new(types::I32)];\n+            let ret_val = fx.lib_call(name, input_tys, vec![AbiParam::new(clif_ty)], &args)[0];\n+            CValue::by_val(ret_val, fx.layout_of(ty))\n+        }\n+        _ => {\n+            let input_tys: Vec<_> = args.iter().map(|_| AbiParam::new(clif_ty)).collect();\n+            let ret_val = fx.lib_call(name, input_tys, vec![AbiParam::new(clif_ty)], &args)[0];\n+            CValue::by_val(ret_val, fx.layout_of(ty))\n+        }\n     };\n \n     ret.write_cvalue(fx, res);\n@@ -385,7 +392,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n \n             fx.bcx.ins().debugtrap();\n         }\n-        sym::copy | sym::copy_nonoverlapping => {\n+        sym::copy => {\n             intrinsic_args!(fx, args => (src, dst, count); intrinsic);\n             let src = src.load_scalar(fx);\n             let dst = dst.load_scalar(fx);\n@@ -397,13 +404,8 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             let byte_amount =\n                 if elem_size != 1 { fx.bcx.ins().imul_imm(count, elem_size as i64) } else { count };\n \n-            if intrinsic == sym::copy_nonoverlapping {\n-                // FIXME emit_small_memcpy\n-                fx.bcx.call_memcpy(fx.target_config, dst, src, byte_amount);\n-            } else {\n-                // FIXME emit_small_memmove\n-                fx.bcx.call_memmove(fx.target_config, dst, src, byte_amount);\n-            }\n+            // FIXME emit_small_memmove\n+            fx.bcx.call_memmove(fx.target_config, dst, src, byte_amount);\n         }\n         sym::volatile_copy_memory | sym::volatile_copy_nonoverlapping_memory => {\n             // NOTE: the volatile variants have src and dst swapped\n@@ -643,26 +645,25 @@ fn codegen_regular_intrinsic_call<'tcx>(\n \n                 if do_panic {\n                     let layout = fx.layout_of(ty);\n-\n-                    with_no_trimmed_paths!({\n-                        crate::base::codegen_panic_nounwind(\n-                            fx,\n-                            &if layout.abi.is_uninhabited() {\n-                                format!(\"attempted to instantiate uninhabited type `{}`\", layout.ty)\n-                            } else if requirement == ValidityRequirement::Zero {\n+                    let msg_str = with_no_visible_paths!({\n+                        with_no_trimmed_paths!({\n+                            if layout.abi.is_uninhabited() {\n+                                // Use this error even for the other intrinsics as it is more precise.\n+                                format!(\"attempted to instantiate uninhabited type `{}`\", ty)\n+                            } else if intrinsic == sym::assert_zero_valid {\n                                 format!(\n                                     \"attempted to zero-initialize type `{}`, which is invalid\",\n-                                    layout.ty\n+                                    ty\n                                 )\n                             } else {\n                                 format!(\n                                     \"attempted to leave type `{}` uninitialized, which is invalid\",\n-                                    layout.ty\n+                                    ty\n                                 )\n-                            },\n-                            source_info,\n-                        )\n+                            }\n+                        })\n                     });\n+                    crate::base::codegen_panic_nounwind(fx, &msg_str, source_info);\n                     return;\n                 }\n             }"}, {"sha": "034b4e8072cc588787b76fcfc5add316217c747f", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -279,9 +279,8 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 fx.tcx.sess.span_warn(span, \"Index argument for `simd_extract` is not a constant\");\n                 let trap_block = fx.bcx.create_block();\n                 let true_ = fx.bcx.ins().iconst(types::I8, 1);\n-                fx.bcx.ins().brnz(true_, trap_block, &[]);\n                 let ret_block = fx.get_block(target);\n-                fx.bcx.ins().jump(ret_block, &[]);\n+                fx.bcx.ins().brif(true_, trap_block, &[], ret_block, &[]);\n                 fx.bcx.switch_to_block(trap_block);\n                 crate::trap::trap_unimplemented(\n                     fx,\n@@ -825,8 +824,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 let next = fx.bcx.create_block();\n                 let res_lane = fx.bcx.append_block_param(next, lane_clif_ty);\n \n-                fx.bcx.ins().brnz(mask_lane, if_enabled, &[]);\n-                fx.bcx.ins().jump(if_disabled, &[]);\n+                fx.bcx.ins().brif(mask_lane, if_enabled, &[], if_disabled, &[]);\n                 fx.bcx.seal_block(if_enabled);\n                 fx.bcx.seal_block(if_disabled);\n \n@@ -864,8 +862,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 let if_enabled = fx.bcx.create_block();\n                 let next = fx.bcx.create_block();\n \n-                fx.bcx.ins().brnz(mask_lane, if_enabled, &[]);\n-                fx.bcx.ins().jump(next, &[]);\n+                fx.bcx.ins().brif(mask_lane, if_enabled, &[], next, &[]);\n                 fx.bcx.seal_block(if_enabled);\n \n                 fx.bcx.switch_to_block(if_enabled);"}, {"sha": "bed79859f51ffbb19003aade8a14ae8e2339209a", "filename": "src/lib.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -57,8 +57,6 @@ mod compiler_builtins;\n mod concurrency_limiter;\n mod config;\n mod constant;\n-// FIXME revert back to the external crate with Cranelift 0.93\n-mod cranelift_native;\n mod debuginfo;\n mod discriminant;\n mod driver;\n@@ -251,7 +249,7 @@ fn target_triple(sess: &Session) -> target_lexicon::Triple {\n     }\n }\n \n-fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::TargetIsa + 'static> {\n+fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Arc<dyn isa::TargetIsa + 'static> {\n     use target_lexicon::BinaryFormat;\n \n     let target_triple = crate::target_triple(sess);\n@@ -285,14 +283,17 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::Tar\n         }\n     }\n \n-    if let target_lexicon::Architecture::Aarch64(_) | target_lexicon::Architecture::X86_64 =\n-        target_triple.architecture\n+    if let target_lexicon::Architecture::Aarch64(_)\n+    | target_lexicon::Architecture::Riscv64(_)\n+    | target_lexicon::Architecture::X86_64 = target_triple.architecture\n     {\n-        // Windows depends on stack probes to grow the committed part of the stack\n+        // Windows depends on stack probes to grow the committed part of the stack.\n+        // On other platforms it helps prevents stack smashing.\n         flags_builder.enable(\"enable_probestack\").unwrap();\n         flags_builder.set(\"probestack_strategy\", \"inline\").unwrap();\n     } else {\n-        // __cranelift_probestack is not provided and inline stack probes are only supported on AArch64 and x86_64\n+        // __cranelift_probestack is not provided and inline stack probes are only supported on\n+        // AArch64, Riscv64 and x86_64.\n         flags_builder.set(\"enable_probestack\", \"false\").unwrap();\n     }\n "}, {"sha": "205411e8c27be3ab312331bb57158e3479b07736", "filename": "src/main_shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain_shim.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -28,7 +28,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n \n     if main_def_id.is_local() {\n         let instance = Instance::mono(tcx, main_def_id).polymorphize(tcx);\n-        if !is_jit && module.get_name(&*tcx.symbol_name(instance).name).is_none() {\n+        if !is_jit && module.get_name(tcx.symbol_name(instance).name).is_none() {\n             return;\n         }\n     } else if !is_primary_cgu {"}, {"sha": "462742387a9ec77dc69fd2093685d50593f024f6", "filename": "src/num.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -347,12 +347,20 @@ pub(crate) fn codegen_float_binop<'tcx>(\n         BinOp::Mul => b.fmul(lhs, rhs),\n         BinOp::Div => b.fdiv(lhs, rhs),\n         BinOp::Rem => {\n-            let name = match in_lhs.layout().ty.kind() {\n-                ty::Float(FloatTy::F32) => \"fmodf\",\n-                ty::Float(FloatTy::F64) => \"fmod\",\n+            let (name, ty) = match in_lhs.layout().ty.kind() {\n+                ty::Float(FloatTy::F32) => (\"fmodf\", types::F32),\n+                ty::Float(FloatTy::F64) => (\"fmod\", types::F64),\n                 _ => bug!(),\n             };\n-            return fx.easy_call(name, &[in_lhs, in_rhs], in_lhs.layout().ty);\n+\n+            let ret_val = fx.lib_call(\n+                name,\n+                vec![AbiParam::new(ty), AbiParam::new(ty)],\n+                vec![AbiParam::new(ty)],\n+                &[lhs, rhs],\n+            )[0];\n+\n+            return CValue::by_val(ret_val, in_lhs.layout());\n         }\n         BinOp::Eq | BinOp::Lt | BinOp::Le | BinOp::Ne | BinOp::Ge | BinOp::Gt => {\n             let fltcc = match bin_op {"}, {"sha": "b60e56720ed5ed7c1f9cbe989c98dc9e10a608ce", "filename": "src/pointer.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpointer.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -30,11 +30,6 @@ impl Pointer {\n         Pointer { base: PointerBase::Stack(stack_slot), offset: Offset32::new(0) }\n     }\n \n-    pub(crate) fn const_addr(fx: &mut FunctionCx<'_, '_, '_>, addr: i64) -> Self {\n-        let addr = fx.bcx.ins().iconst(fx.pointer_type, addr);\n-        Pointer { base: PointerBase::Addr(addr), offset: Offset32::new(0) }\n-    }\n-\n     pub(crate) fn dangling(align: Align) -> Self {\n         Pointer { base: PointerBase::Dangling(align), offset: Offset32::new(0) }\n     }"}, {"sha": "e0a081c9d498bb41207ebf3c93aaa2ec060e6332", "filename": "src/pretty_clif.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpretty_clif.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -245,7 +245,7 @@ pub(crate) fn write_clif_file(\n         for flag in isa.flags().iter() {\n             writeln!(file, \"set {}\", flag)?;\n         }\n-        write!(file, \"target {}\", isa.triple().architecture.to_string())?;\n+        write!(file, \"target {}\", isa.triple().architecture)?;\n         for isa_flag in isa.isa_flags().iter() {\n             write!(file, \" {}\", isa_flag)?;\n         }"}, {"sha": "ecf187a0b0fe6f4b903054860997c7bd449331e9", "filename": "src/unsize.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funsize.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -28,9 +28,7 @@ pub(crate) fn unsized_info<'tcx>(\n         (\n             &ty::Dynamic(ref data_a, _, src_dyn_kind),\n             &ty::Dynamic(ref data_b, _, target_dyn_kind),\n-        ) => {\n-            assert_eq!(src_dyn_kind, target_dyn_kind);\n-\n+        ) if src_dyn_kind == target_dyn_kind => {\n             let old_info =\n                 old_info.expect(\"unsized_info: missing old info for trait upcasting coercion\");\n             if data_a.principal_def_id() == data_b.principal_def_id() {\n@@ -55,7 +53,7 @@ pub(crate) fn unsized_info<'tcx>(\n                 old_info\n             }\n         }\n-        (_, &ty::Dynamic(ref data, ..)) => crate::vtable::get_vtable(fx, source, data.principal()),\n+        (_, ty::Dynamic(data, ..)) => crate::vtable::get_vtable(fx, source, data.principal()),\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }"}, {"sha": "58e0a498292d4498637b447f58f54ff50fc82adb", "filename": "src/value_and_place.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -3,6 +3,7 @@\n use crate::prelude::*;\n \n use cranelift_codegen::ir::immediates::Offset32;\n+use cranelift_codegen::ir::{InstructionData, Opcode};\n \n fn codegen_field<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n@@ -457,13 +458,15 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n+    #[track_caller]\n     pub(crate) fn to_ptr(self) -> Pointer {\n         match self.to_ptr_maybe_unsized() {\n             (ptr, None) => ptr,\n             (_, Some(_)) => bug!(\"Expected sized cplace, found {:?}\", self),\n         }\n     }\n \n+    #[track_caller]\n     pub(crate) fn to_ptr_maybe_unsized(self) -> (Pointer, Option<Value>) {\n         match self.inner {\n             CPlaceInner::Addr(ptr, extra) => (ptr, extra),\n@@ -787,7 +790,36 @@ impl<'tcx> CPlace<'tcx> {\n         index: Value,\n     ) -> CPlace<'tcx> {\n         let (elem_layout, ptr) = match self.layout().ty.kind() {\n-            ty::Array(elem_ty, _) => (fx.layout_of(*elem_ty), self.to_ptr()),\n+            ty::Array(elem_ty, _) => {\n+                let elem_layout = fx.layout_of(*elem_ty);\n+                match self.inner {\n+                    CPlaceInner::Var(local, var) => {\n+                        // This is a hack to handle `vector_val.0[1]`. It doesn't allow dynamic\n+                        // indexing.\n+                        let lane_idx = match fx.bcx.func.dfg.insts\n+                            [fx.bcx.func.dfg.value_def(index).unwrap_inst()]\n+                        {\n+                            InstructionData::UnaryImm { opcode: Opcode::Iconst, imm } => imm,\n+                            _ => bug!(\n+                                \"Dynamic indexing into a vector type is not supported: {self:?}[{index}]\"\n+                            ),\n+                        };\n+                        return CPlace {\n+                            inner: CPlaceInner::VarLane(\n+                                local,\n+                                var,\n+                                lane_idx.bits().try_into().unwrap(),\n+                            ),\n+                            layout: elem_layout,\n+                        };\n+                    }\n+                    CPlaceInner::Addr(addr, None) => (elem_layout, addr),\n+                    CPlaceInner::Addr(_, Some(_))\n+                    | CPlaceInner::VarPair(_, _, _)\n+                    | CPlaceInner::VarLane(_, _, _) => bug!(\"Can't index into {self:?}\"),\n+                }\n+                // FIXME use VarLane in case of Var with simd type\n+            }\n             ty::Slice(elem_ty) => (fx.layout_of(*elem_ty), self.to_ptr_maybe_unsized().0),\n             _ => bug!(\"place_index({:?})\", self.layout().ty),\n         };"}, {"sha": "b7bfd8fd395264352a56413706579ffac91a393b", "filename": "src/vtable.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=7b3bd56ed99d5031f57b1aaf814117b2a7ce9c84", "patch": "@@ -43,10 +43,29 @@ pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -\n \n pub(crate) fn get_ptr_and_method_ref<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    arg: CValue<'tcx>,\n+    mut arg: CValue<'tcx>,\n     idx: usize,\n ) -> (Pointer, Value) {\n     let (ptr, vtable) = 'block: {\n+        if let Abi::Scalar(_) = arg.layout().abi {\n+            'descend_newtypes: while !arg.layout().ty.is_unsafe_ptr()\n+                && !arg.layout().ty.is_region_ptr()\n+            {\n+                for i in 0..arg.layout().fields.count() {\n+                    let field = arg.value_field(fx, mir::Field::new(i));\n+                    if !field.layout().is_zst() {\n+                        // we found the one non-zero-sized field that is allowed\n+                        // now find *its* non-zero-sized field, or stop if it's a\n+                        // pointer\n+                        arg = field;\n+                        continue 'descend_newtypes;\n+                    }\n+                }\n+\n+                bug!(\"receiver has no non-zero-sized fields {:?}\", arg);\n+            }\n+        }\n+\n         if let ty::Ref(_, ty, _) = arg.layout().ty.kind() {\n             if ty.is_dyn_star() {\n                 let inner_layout = fx.layout_of(arg.layout().ty.builtin_deref(true).unwrap().ty);"}]}