{"sha": "4492c029eff7b42e91e759576ab0c7ca88f873dc", "node_id": "C_kwDOAAsO6NoAKDQ0OTJjMDI5ZWZmN2I0MmU5MWU3NTk1NzZhYjBjN2NhODhmODczZGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-04T17:36:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-04T17:36:44Z"}, "message": "Auto merge of #2641 - DrMeepster:init_once_acquire, r=RalfJung\n\nInitOnce: synchronize with completion when already complete\n\nThe completion of an InitOnce happens-before the threads waiting on it wake up. However, this is not the case for threads that call `InitOnceBeginInitialize` after the completion, leading to data races and outdated weak memory loads as observed in the CI for  #2638. This PR fixes this.", "tree": {"sha": "a94783f1d3d65ad06960b1418ca3d141efcb0f90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a94783f1d3d65ad06960b1418ca3d141efcb0f90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4492c029eff7b42e91e759576ab0c7ca88f873dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4492c029eff7b42e91e759576ab0c7ca88f873dc", "html_url": "https://github.com/rust-lang/rust/commit/4492c029eff7b42e91e759576ab0c7ca88f873dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4492c029eff7b42e91e759576ab0c7ca88f873dc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d9157e333624ed748564fecbcc528f03210850f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d9157e333624ed748564fecbcc528f03210850f", "html_url": "https://github.com/rust-lang/rust/commit/9d9157e333624ed748564fecbcc528f03210850f"}, {"sha": "cb6f7a6a84e3e808fa95a1206843a96f8b9ff44d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb6f7a6a84e3e808fa95a1206843a96f8b9ff44d", "html_url": "https://github.com/rust-lang/rust/commit/cb6f7a6a84e3e808fa95a1206843a96f8b9ff44d"}], "stats": {"total": 130, "additions": 97, "deletions": 33}, "files": [{"sha": "eb42cdf80abbeb5de883a9dc009948fc5777f2df", "filename": "src/tools/miri/src/concurrency/init_once.rs", "status": "modified", "additions": 55, "deletions": 31, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4492c029eff7b42e91e759576ab0c7ca88f873dc/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4492c029eff7b42e91e759576ab0c7ca88f873dc/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs?ref=4492c029eff7b42e91e759576ab0c7ca88f873dc", "patch": "@@ -3,7 +3,7 @@ use std::num::NonZeroU32;\n \n use rustc_index::vec::Idx;\n \n-use super::sync::EvalContextExtPriv;\n+use super::sync::EvalContextExtPriv as _;\n use super::thread::MachineCallback;\n use super::vector_clock::VClock;\n use crate::*;\n@@ -52,6 +52,43 @@ impl<'mir, 'tcx> VisitTags for InitOnce<'mir, 'tcx> {\n     }\n }\n \n+impl<'mir, 'tcx: 'mir> EvalContextExtPriv<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Synchronize with the previous initialization attempt of an InitOnce.\n+    #[inline]\n+    fn init_once_observe_attempt(&mut self, id: InitOnceId) {\n+        let this = self.eval_context_mut();\n+        let current_thread = this.get_active_thread();\n+\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.validate_lock_acquire(\n+                &this.machine.threads.sync.init_onces[id].data_race,\n+                current_thread,\n+            );\n+        }\n+    }\n+\n+    #[inline]\n+    fn init_once_wake_waiter(\n+        &mut self,\n+        id: InitOnceId,\n+        waiter: InitOnceWaiter<'mir, 'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let current_thread = this.get_active_thread();\n+\n+        this.unblock_thread(waiter.thread);\n+\n+        // Call callback, with the woken-up thread as `current`.\n+        this.set_active_thread(waiter.thread);\n+        this.init_once_observe_attempt(id);\n+        waiter.callback.call(this)?;\n+        this.set_active_thread(current_thread);\n+\n+        Ok(())\n+    }\n+}\n+\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn init_once_get_or_create_id(\n@@ -141,20 +178,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Wake up everyone.\n         // need to take the queue to avoid having `this` be borrowed multiple times\n         for waiter in std::mem::take(&mut init_once.waiters) {\n-            // End of the wait happens-before woken-up thread.\n-            if let Some(data_race) = &this.machine.data_race {\n-                data_race.validate_lock_acquire(\n-                    &this.machine.threads.sync.init_onces[id].data_race,\n-                    waiter.thread,\n-                );\n-            }\n-\n-            this.unblock_thread(waiter.thread);\n-\n-            // Call callback, with the woken-up thread as `current`.\n-            this.set_active_thread(waiter.thread);\n-            waiter.callback.call(this)?;\n-            this.set_active_thread(current_thread);\n+            this.init_once_wake_waiter(id, waiter)?;\n         }\n \n         Ok(())\n@@ -172,33 +196,33 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         );\n \n         // Each complete happens-before the end of the wait\n-        // FIXME: should this really induce synchronization? If we think of it as a lock, then yes,\n-        // but the docs don't talk about such details.\n         if let Some(data_race) = &this.machine.data_race {\n             data_race.validate_lock_release(&mut init_once.data_race, current_thread);\n         }\n \n         // Wake up one waiting thread, so they can go ahead and try to init this.\n         if let Some(waiter) = init_once.waiters.pop_front() {\n-            // End of the wait happens-before woken-up thread.\n-            if let Some(data_race) = &this.machine.data_race {\n-                data_race.validate_lock_acquire(\n-                    &this.machine.threads.sync.init_onces[id].data_race,\n-                    waiter.thread,\n-                );\n-            }\n-\n-            this.unblock_thread(waiter.thread);\n-\n-            // Call callback, with the woken-up thread as `current`.\n-            this.set_active_thread(waiter.thread);\n-            waiter.callback.call(this)?;\n-            this.set_active_thread(current_thread);\n+            this.init_once_wake_waiter(id, waiter)?;\n         } else {\n             // Nobody there to take this, so go back to 'uninit'\n             init_once.status = InitOnceStatus::Uninitialized;\n         }\n \n         Ok(())\n     }\n+\n+    /// Synchronize with the previous completion of an InitOnce.\n+    /// Must only be called after checking that it is complete.\n+    #[inline]\n+    fn init_once_observe_completed(&mut self, id: InitOnceId) {\n+        let this = self.eval_context_mut();\n+\n+        assert_eq!(\n+            this.init_once_status(id),\n+            InitOnceStatus::Complete,\n+            \"observing the completion of incomplete init once\"\n+        );\n+\n+        this.init_once_observe_attempt(id);\n+    }\n }"}, {"sha": "098804626f2f956f9e5f574fe64f675cdf18320c", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4492c029eff7b42e91e759576ab0c7ca88f873dc/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4492c029eff7b42e91e759576ab0c7ca88f873dc/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=4492c029eff7b42e91e759576ab0c7ca88f873dc", "patch": "@@ -177,8 +177,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     Box::new(Callback { init_once_id: id, pending_place }),\n                 )\n             }\n-            InitOnceStatus::Complete =>\n-                this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &pending_place)?,\n+            InitOnceStatus::Complete => {\n+                this.init_once_observe_completed(id);\n+                this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &pending_place)?;\n+            }\n         }\n \n         // This always succeeds (even if the thread is blocked, we will succeed if we ever unblock)."}, {"sha": "4eb88379620597dd28a36ef8ddfb60571b534a03", "filename": "src/tools/miri/tests/pass/concurrency/windows_init_once.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4492c029eff7b42e91e759576ab0c7ca88f873dc/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4492c029eff7b42e91e759576ab0c7ca88f873dc/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.rs?ref=4492c029eff7b42e91e759576ab0c7ca88f873dc", "patch": "@@ -131,8 +131,46 @@ fn retry_on_fail() {\n     waiter2.join().unwrap();\n }\n \n+fn no_data_race_after_complete() {\n+    let mut init_once = null_mut();\n+    let mut pending = 0;\n+\n+    unsafe {\n+        assert_eq!(InitOnceBeginInitialize(&mut init_once, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, TRUE);\n+    }\n+\n+    let init_once_ptr = SendPtr(&mut init_once);\n+\n+    let mut place = 0;\n+    let place_ptr = SendPtr(&mut place);\n+\n+    let reader = thread::spawn(move || unsafe {\n+        let mut pending = 0;\n+\n+        // this doesn't block because reader only executes after `InitOnceComplete` is called\n+        assert_eq!(InitOnceBeginInitialize(init_once_ptr.0, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, FALSE);\n+        // this should not data race\n+        place_ptr.0.read()\n+    });\n+\n+    unsafe {\n+        // this should not data race\n+        place_ptr.0.write(1);\n+    }\n+\n+    unsafe {\n+        assert_eq!(InitOnceComplete(init_once_ptr.0, 0, null_mut()), TRUE);\n+    }\n+\n+    // run reader (without preemption, it has not taken a step yet)\n+    assert_eq!(reader.join().unwrap(), 1);\n+}\n+\n fn main() {\n     single_thread();\n     block_until_complete();\n     retry_on_fail();\n+    no_data_race_after_complete();\n }"}]}