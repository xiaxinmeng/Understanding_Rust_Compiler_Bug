{"sha": "f5f496efd086ae763075295eac8aae757909f29c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1ZjQ5NmVmZDA4NmFlNzYzMDc1Mjk1ZWFjOGFhZTc1NzkwOWYyOWM=", "commit": {"author": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2018-10-30T13:47:54Z"}, "committer": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2018-11-02T19:25:34Z"}, "message": "parse command-line into a central Options struct", "tree": {"sha": "364637f65b2281af2a8b518057f972d85755eeb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/364637f65b2281af2a8b518057f972d85755eeb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5f496efd086ae763075295eac8aae757909f29c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5f496efd086ae763075295eac8aae757909f29c", "html_url": "https://github.com/rust-lang/rust/commit/f5f496efd086ae763075295eac8aae757909f29c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5f496efd086ae763075295eac8aae757909f29c/comments", "author": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e53a5ffd6b1c28903b4ad9a4c433fd554802cd9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e53a5ffd6b1c28903b4ad9a4c433fd554802cd9c", "html_url": "https://github.com/rust-lang/rust/commit/e53a5ffd6b1c28903b4ad9a4c433fd554802cd9c"}], "stats": {"total": 828, "additions": 528, "deletions": 300}, "files": [{"sha": "4a9b3574cd85e90408cf5e7d7e5b6653eca83607", "filename": "src/librustdoc/config.rs", "status": "added", "additions": 488, "deletions": 0, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/f5f496efd086ae763075295eac8aae757909f29c/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f496efd086ae763075295eac8aae757909f29c/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=f5f496efd086ae763075295eac8aae757909f29c", "patch": "@@ -0,0 +1,488 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::{BTreeMap, BTreeSet};\n+use std::path::PathBuf;\n+\n+use errors;\n+use errors::emitter::ColorConfig;\n+use getopts;\n+use rustc::lint::Level;\n+use rustc::session::early_error;\n+use rustc::session::config::{CodegenOptions, DebuggingOptions, ErrorOutputType, Externs};\n+use rustc::session::config::{nightly_options, build_codegen_options, build_debugging_options,\n+                             get_cmd_lint_options};\n+use rustc::session::search_paths::SearchPaths;\n+use rustc_driver;\n+use rustc_target::spec::TargetTriple;\n+use syntax::edition::Edition;\n+\n+use core::new_handler;\n+use externalfiles::ExternalHtml;\n+use html;\n+use html::markdown::IdMap;\n+use opts;\n+use passes::{self, DefaultPassOption};\n+use theme;\n+\n+pub struct Options {\n+    // Basic options / Options passed directly to rustc\n+\n+    /// The crate root or Markdown file to load.\n+    pub input: PathBuf,\n+    /// Output directory to generate docs into. Defaults to `doc`.\n+    pub output: PathBuf,\n+    /// The name of the crate being documented.\n+    pub crate_name: Option<String>,\n+    /// How to format errors and warnings.\n+    pub error_format: ErrorOutputType,\n+    /// Library search paths to hand to the compiler.\n+    pub libs: SearchPaths,\n+    /// The list of external crates to link against.\n+    pub externs: Externs,\n+    /// List of `cfg` flags to hand to the compiler. Always includes `rustdoc`.\n+    pub cfgs: Vec<String>,\n+    /// Codegen options to hand to the compiler.\n+    pub codegen_options: CodegenOptions,\n+    /// Debugging (`-Z`) options to pass to the compiler.\n+    pub debugging_options: DebuggingOptions,\n+    /// The target used to compile the crate against.\n+    pub target: Option<TargetTriple>,\n+    /// Edition used when reading the crate. Defaults to \"2015\". Also used by default when\n+    /// compiling doctests from the crate.\n+    pub edition: Edition,\n+    /// The path to the sysroot. Used during the compilation process.\n+    pub maybe_sysroot: Option<PathBuf>,\n+    /// Linker to use when building doctests.\n+    pub linker: Option<PathBuf>,\n+    /// Lint information passed over the command-line.\n+    pub lint_opts: Vec<(String, Level)>,\n+    /// Whether to ask rustc to describe the lints it knows. Practically speaking, this will not be\n+    /// used, since we abort if we have no input file, but it's included for completeness.\n+    pub describe_lints: bool,\n+    /// What level to cap lints at.\n+    pub lint_cap: Option<Level>,\n+\n+    // Options specific to running doctests\n+\n+    /// Whether we should run doctests instead of generating docs.\n+    pub should_test: bool,\n+    /// List of arguments to pass to the test harness, if running tests.\n+    pub test_args: Vec<String>,\n+\n+    // Options that affect the documentation process\n+\n+    /// The selected default set of passes to use.\n+    ///\n+    /// Be aware: This option can come both from the CLI and from crate attributes!\n+    pub default_passes: DefaultPassOption,\n+    /// Any passes manually selected by the user.\n+    ///\n+    /// Be aware: This option can come both from the CLI and from crate attributes!\n+    pub manual_passes: Vec<String>,\n+    /// Whether to display warnings during doc generation or while gathering doctests. By default,\n+    /// all non-rustdoc-specific lints are allowed when generating docs.\n+    pub display_warnings: bool,\n+    /// A pre-populated `IdMap` with the default headings and any headings added by Markdown files\n+    /// processed by `external_html`.\n+    pub id_map: IdMap,\n+\n+    // Options that alter generated documentation pages\n+\n+    /// External files to insert into generated pages.\n+    pub external_html: ExternalHtml,\n+    /// If present, playground URL to use in the \"Run\" button added to code samples.\n+    ///\n+    /// Be aware: This option can come both from the CLI and from crate attributes!\n+    pub playground_url: Option<String>,\n+    /// Crate version to note on the sidebar of generated docs.\n+    pub crate_version: Option<String>,\n+    /// Whether to sort modules alphabetically on a module page instead of using declaration order.\n+    /// `true` by default.\n+    ///\n+    /// FIXME(misdreavus): the flag name is `--sort-modules-by-appearance` but the meaning is\n+    /// inverted once read\n+    pub sort_modules_alphabetically: bool,\n+    /// List of themes to extend the docs with. Original argument name is included to assist in\n+    /// displaying errors if it fails a theme check.\n+    pub themes: Vec<PathBuf>,\n+    /// If present, CSS file that contains rules to add to the default CSS.\n+    pub extension_css: Option<PathBuf>,\n+    /// A map of crate names to the URL to use instead of querying the crate's `html_root_url`.\n+    pub extern_html_root_urls: BTreeMap<String, String>,\n+    /// If present, suffix added to CSS/JavaScript files when referencing them in generated pages.\n+    pub resource_suffix: String,\n+    /// Whether to run the static CSS/JavaScript through a minifier when outputting them. `true` by\n+    /// default.\n+    ///\n+    /// FIXME(misdreavus): the flag name is `--disable-minification` but the meaning is inverted\n+    /// once read\n+    pub enable_minification: bool,\n+    /// Whether to create an index page in the root of the output directory. If this is true but\n+    /// `enable_index_page` is None, generate a static listing of crates instead.\n+    pub enable_index_page: bool,\n+    /// A file to use as the index page at the root of the output directory. Overrides\n+    /// `enable_index_page` to be true if set.\n+    pub index_page: Option<PathBuf>,\n+\n+    // Options specific to reading standalone Markdown files\n+\n+    /// Whether to generate a table of contents on the output file when reading a standalone\n+    /// Markdown file.\n+    pub markdown_no_toc: bool,\n+    /// Additional CSS files to link in pages generated from standlone Markdown files.\n+    pub markdown_css: Vec<String>,\n+    /// If present, playground URL to use in the \"Run\" button added to code samples generated from\n+    /// standalone Markdown files. If not present, `playground_url` is used.\n+    pub markdown_playground_url: Option<String>,\n+}\n+\n+impl Options {\n+    /// Parses the given command-line for options. If an error message or other early-return has\n+    /// been printed, returns `Err` with the exit code.\n+    pub fn from_matches(matches: &getopts::Matches) -> Result<Options, isize> {\n+        // Check for unstable options.\n+        nightly_options::check_nightly_options(&matches, &opts());\n+\n+        if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n+            ::usage(\"rustdoc\");\n+            return Err(0);\n+        } else if matches.opt_present(\"version\") {\n+            rustc_driver::version(\"rustdoc\", &matches);\n+            return Err(0);\n+        }\n+\n+        if matches.opt_strs(\"passes\") == [\"list\"] {\n+            println!(\"Available passes for running rustdoc:\");\n+            for pass in passes::PASSES {\n+                println!(\"{:>20} - {}\", pass.name(), pass.description());\n+            }\n+            println!(\"\\nDefault passes for rustdoc:\");\n+            for &name in passes::DEFAULT_PASSES {\n+                println!(\"{:>20}\", name);\n+            }\n+            println!(\"\\nPasses run with `--document-private-items`:\");\n+            for &name in passes::DEFAULT_PRIVATE_PASSES {\n+                println!(\"{:>20}\", name);\n+            }\n+            return Err(0);\n+        }\n+\n+        let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n+            Some(\"auto\") => ColorConfig::Auto,\n+            Some(\"always\") => ColorConfig::Always,\n+            Some(\"never\") => ColorConfig::Never,\n+            None => ColorConfig::Auto,\n+            Some(arg) => {\n+                early_error(ErrorOutputType::default(),\n+                            &format!(\"argument for --color must be `auto`, `always` or `never` \\\n+                                      (instead was `{}`)\", arg));\n+            }\n+        };\n+        let error_format = match matches.opt_str(\"error-format\").as_ref().map(|s| &s[..]) {\n+            Some(\"human\") => ErrorOutputType::HumanReadable(color),\n+            Some(\"json\") => ErrorOutputType::Json(false),\n+            Some(\"pretty-json\") => ErrorOutputType::Json(true),\n+            Some(\"short\") => ErrorOutputType::Short(color),\n+            None => ErrorOutputType::HumanReadable(color),\n+            Some(arg) => {\n+                early_error(ErrorOutputType::default(),\n+                            &format!(\"argument for --error-format must be `human`, `json` or \\\n+                                      `short` (instead was `{}`)\", arg));\n+            }\n+        };\n+\n+        let codegen_options = build_codegen_options(matches, error_format);\n+        let debugging_options = build_debugging_options(matches, error_format);\n+\n+        let diag = new_handler(error_format,\n+                               None,\n+                               debugging_options.treat_err_as_bug,\n+                               debugging_options.ui_testing);\n+\n+        // check for deprecated options\n+        check_deprecated_options(&matches, &diag);\n+\n+        let to_check = matches.opt_strs(\"theme-checker\");\n+        if !to_check.is_empty() {\n+            let paths = theme::load_css_paths(include_bytes!(\"html/static/themes/light.css\"));\n+            let mut errors = 0;\n+\n+            println!(\"rustdoc: [theme-checker] Starting tests!\");\n+            for theme_file in to_check.iter() {\n+                print!(\" - Checking \\\"{}\\\"...\", theme_file);\n+                let (success, differences) = theme::test_theme_against(theme_file, &paths, &diag);\n+                if !differences.is_empty() || !success {\n+                    println!(\" FAILED\");\n+                    errors += 1;\n+                    if !differences.is_empty() {\n+                        println!(\"{}\", differences.join(\"\\n\"));\n+                    }\n+                } else {\n+                    println!(\" OK\");\n+                }\n+            }\n+            if errors != 0 {\n+                return Err(1);\n+            }\n+            return Err(0);\n+        }\n+\n+        if matches.free.is_empty() {\n+            diag.struct_err(\"missing file operand\").emit();\n+            return Err(1);\n+        }\n+        if matches.free.len() > 1 {\n+            diag.struct_err(\"too many file operands\").emit();\n+            return Err(1);\n+        }\n+        let input = PathBuf::from(&matches.free[0]);\n+\n+        let mut libs = SearchPaths::new();\n+        for s in &matches.opt_strs(\"L\") {\n+            libs.add_path(s, error_format);\n+        }\n+        let externs = match parse_externs(&matches) {\n+            Ok(ex) => ex,\n+            Err(err) => {\n+                diag.struct_err(&err).emit();\n+                return Err(1);\n+            }\n+        };\n+        let extern_html_root_urls = match parse_extern_html_roots(&matches) {\n+            Ok(ex) => ex,\n+            Err(err) => {\n+                diag.struct_err(err).emit();\n+                return Err(1);\n+            }\n+        };\n+\n+        let test_args = matches.opt_strs(\"test-args\");\n+        let test_args: Vec<String> = test_args.iter()\n+                                              .flat_map(|s| s.split_whitespace())\n+                                              .map(|s| s.to_string())\n+                                              .collect();\n+\n+        let should_test = matches.opt_present(\"test\");\n+\n+        let output = matches.opt_str(\"o\")\n+                            .map(|s| PathBuf::from(&s))\n+                            .unwrap_or_else(|| PathBuf::from(\"doc\"));\n+        let mut cfgs = matches.opt_strs(\"cfg\");\n+        cfgs.push(\"rustdoc\".to_string());\n+\n+        let extension_css = matches.opt_str(\"e\").map(|s| PathBuf::from(&s));\n+\n+        if let Some(ref p) = extension_css {\n+            if !p.is_file() {\n+                diag.struct_err(\"option --extend-css argument must be a file\").emit();\n+                return Err(1);\n+            }\n+        }\n+\n+        let mut themes = Vec::new();\n+        if matches.opt_present(\"themes\") {\n+            let paths = theme::load_css_paths(include_bytes!(\"html/static/themes/light.css\"));\n+\n+            for (theme_file, theme_s) in matches.opt_strs(\"themes\")\n+                                                .iter()\n+                                                .map(|s| (PathBuf::from(&s), s.to_owned())) {\n+                if !theme_file.is_file() {\n+                    diag.struct_err(\"option --themes arguments must all be files\").emit();\n+                    return Err(1);\n+                }\n+                let (success, ret) = theme::test_theme_against(&theme_file, &paths, &diag);\n+                if !success || !ret.is_empty() {\n+                    diag.struct_err(&format!(\"invalid theme: \\\"{}\\\"\", theme_s))\n+                        .help(\"check what's wrong with the --theme-checker option\")\n+                        .emit();\n+                    return Err(1);\n+                }\n+                themes.push(theme_file);\n+            }\n+        }\n+\n+        let mut id_map = html::markdown::IdMap::new();\n+        id_map.populate(html::render::initial_ids());\n+        let external_html = match ExternalHtml::load(\n+                &matches.opt_strs(\"html-in-header\"),\n+                &matches.opt_strs(\"html-before-content\"),\n+                &matches.opt_strs(\"html-after-content\"),\n+                &matches.opt_strs(\"markdown-before-content\"),\n+                &matches.opt_strs(\"markdown-after-content\"), &diag, &mut id_map) {\n+            Some(eh) => eh,\n+            None => return Err(3),\n+        };\n+\n+        let edition = matches.opt_str(\"edition\").unwrap_or(\"2015\".to_string());\n+        let edition = match edition.parse() {\n+            Ok(e) => e,\n+            Err(_) => {\n+                diag.struct_err(\"could not parse edition\").emit();\n+                return Err(1);\n+            }\n+        };\n+\n+        match matches.opt_str(\"w\").as_ref().map(|s| &**s) {\n+            Some(\"html\") | None => {}\n+            Some(s) => {\n+                diag.struct_err(&format!(\"unknown output format: {}\", s)).emit();\n+                return Err(1);\n+            }\n+        }\n+\n+        let index_page = matches.opt_str(\"index-page\").map(|s| PathBuf::from(&s));\n+        if let Some(ref index_page) = index_page {\n+            if !index_page.is_file() {\n+                diag.struct_err(\"option `--index-page` argument must be a file\").emit();\n+                return Err(1);\n+            }\n+        }\n+\n+        let target = matches.opt_str(\"target\").map(|target| {\n+            if target.ends_with(\".json\") {\n+                TargetTriple::TargetPath(PathBuf::from(target))\n+            } else {\n+                TargetTriple::TargetTriple(target)\n+            }\n+        });\n+\n+        let default_passes = if matches.opt_present(\"no-defaults\") {\n+            passes::DefaultPassOption::None\n+        } else if matches.opt_present(\"document-private-items\") {\n+            passes::DefaultPassOption::Private\n+        } else {\n+            passes::DefaultPassOption::Default\n+        };\n+        let manual_passes = matches.opt_strs(\"passes\");\n+\n+        let crate_name = matches.opt_str(\"crate-name\");\n+        let playground_url = matches.opt_str(\"playground-url\");\n+        let maybe_sysroot = matches.opt_str(\"sysroot\").map(PathBuf::from);\n+        let display_warnings = matches.opt_present(\"display-warnings\");\n+        let linker = matches.opt_str(\"linker\").map(PathBuf::from);\n+        let sort_modules_alphabetically = !matches.opt_present(\"sort-modules-by-appearance\");\n+        let resource_suffix = matches.opt_str(\"resource-suffix\").unwrap_or_default();\n+        let enable_minification = !matches.opt_present(\"disable-minification\");\n+        let markdown_no_toc = matches.opt_present(\"markdown-no-toc\");\n+        let markdown_css = matches.opt_strs(\"markdown-css\");\n+        let markdown_playground_url = matches.opt_str(\"markdown-playground-url\");\n+        let crate_version = matches.opt_str(\"crate-version\");\n+        let enable_index_page = matches.opt_present(\"enable-index-page\") || index_page.is_some();\n+\n+        let (lint_opts, describe_lints, lint_cap) = get_cmd_lint_options(matches, error_format);\n+\n+        Ok(Options {\n+            input,\n+            output,\n+            crate_name,\n+            error_format,\n+            libs,\n+            externs,\n+            cfgs,\n+            codegen_options,\n+            debugging_options,\n+            target,\n+            edition,\n+            maybe_sysroot,\n+            linker,\n+            lint_opts,\n+            describe_lints,\n+            lint_cap,\n+            should_test,\n+            test_args,\n+            default_passes,\n+            manual_passes,\n+            display_warnings,\n+            id_map,\n+            external_html,\n+            playground_url,\n+            crate_version,\n+            sort_modules_alphabetically,\n+            themes,\n+            extension_css,\n+            extern_html_root_urls,\n+            resource_suffix,\n+            enable_minification,\n+            enable_index_page,\n+            index_page,\n+            markdown_no_toc,\n+            markdown_css,\n+            markdown_playground_url,\n+        })\n+    }\n+\n+    /// Returns whether the file given as `self.input` is a Markdown file.\n+    pub fn markdown_input(&self) -> bool {\n+        self.input.extension()\n+            .map_or(false, |e| e == \"md\" || e == \"markdown\")\n+    }\n+}\n+\n+/// Prints deprecation warnings for deprecated options\n+fn check_deprecated_options(matches: &getopts::Matches, diag: &errors::Handler) {\n+    let deprecated_flags = [\n+       \"input-format\",\n+       \"output-format\",\n+       \"no-defaults\",\n+       \"passes\",\n+    ];\n+\n+    for flag in deprecated_flags.into_iter() {\n+        if matches.opt_present(flag) {\n+            let mut err = diag.struct_warn(&format!(\"the '{}' flag is considered deprecated\",\n+                                                    flag));\n+            err.warn(\"please see https://github.com/rust-lang/rust/issues/44136\");\n+\n+            if *flag == \"no-defaults\" {\n+                err.help(\"you may want to use --document-private-items\");\n+            }\n+\n+            err.emit();\n+        }\n+    }\n+}\n+\n+/// Extracts `--extern-html-root-url` arguments from `matches` and returns a map of crate names to\n+/// the given URLs. If an `--extern-html-root-url` argument was ill-formed, returns an error\n+/// describing the issue.\n+fn parse_extern_html_roots(matches: &getopts::Matches)\n+    -> Result<BTreeMap<String, String>, &'static str>\n+{\n+    let mut externs = BTreeMap::new();\n+    for arg in &matches.opt_strs(\"extern-html-root-url\") {\n+        let mut parts = arg.splitn(2, '=');\n+        let name = parts.next().ok_or(\"--extern-html-root-url must not be empty\")?;\n+        let url = parts.next().ok_or(\"--extern-html-root-url must be of the form name=url\")?;\n+        externs.insert(name.to_string(), url.to_string());\n+    }\n+\n+    Ok(externs)\n+}\n+\n+/// Extracts `--extern CRATE=PATH` arguments from `matches` and\n+/// returns a map mapping crate names to their paths or else an\n+/// error message.\n+// FIXME(eddyb) This shouldn't be duplicated with `rustc::session`.\n+fn parse_externs(matches: &getopts::Matches) -> Result<Externs, String> {\n+    let mut externs: BTreeMap<_, BTreeSet<_>> = BTreeMap::new();\n+    for arg in &matches.opt_strs(\"extern\") {\n+        let mut parts = arg.splitn(2, '=');\n+        let name = parts.next().ok_or(\"--extern value must not be empty\".to_string())?;\n+        let location = parts.next().map(|s| s.to_string());\n+        if location.is_none() && !nightly_options::is_unstable_enabled(matches) {\n+            return Err(\"the `-Z unstable-options` flag must also be passed to \\\n+                        enable `--extern crate_name` without `=path`\".to_string());\n+        }\n+        let name = name.to_string();\n+        externs.entry(name).or_default().insert(location);\n+    }\n+    Ok(Externs::new(externs))\n+}"}, {"sha": "a9ed5386f61d8954daf25049b5bb771d1236ce01", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 38, "deletions": 298, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/f5f496efd086ae763075295eac8aae757909f29c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f496efd086ae763075295eac8aae757909f29c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=f5f496efd086ae763075295eac8aae757909f29c", "patch": "@@ -53,29 +53,25 @@ extern crate parking_lot;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n-use errors::ColorConfig;\n-\n-use std::collections::{BTreeMap, BTreeSet};\n use std::default::Default;\n use std::env;\n use std::panic;\n-use std::path::{Path, PathBuf};\n+use std::path::PathBuf;\n use std::process;\n use std::sync::mpsc::channel;\n \n use syntax::edition::Edition;\n-use externalfiles::ExternalHtml;\n use rustc::session::{early_warn, early_error};\n use rustc::session::search_paths::SearchPaths;\n use rustc::session::config::{ErrorOutputType, RustcOptGroup, Externs, CodegenOptions};\n-use rustc::session::config::{nightly_options, build_codegen_options};\n use rustc_target::spec::TargetTriple;\n use rustc::session::config::get_cmd_lint_options;\n \n #[macro_use]\n mod externalfiles;\n \n mod clean;\n+mod config;\n mod core;\n mod doctree;\n mod fold;\n@@ -367,250 +363,55 @@ fn main_args(args: &[String]) -> isize {\n             early_error(ErrorOutputType::default(), &err.to_string());\n         }\n     };\n-    // Check for unstable options.\n-    nightly_options::check_nightly_options(&matches, &opts());\n-\n-    if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n-        usage(\"rustdoc\");\n-        return 0;\n-    } else if matches.opt_present(\"version\") {\n-        rustc_driver::version(\"rustdoc\", &matches);\n-        return 0;\n-    }\n-\n-    if matches.opt_strs(\"passes\") == [\"list\"] {\n-        println!(\"Available passes for running rustdoc:\");\n-        for pass in passes::PASSES {\n-            println!(\"{:>20} - {}\", pass.name(), pass.description());\n-        }\n-        println!(\"\\nDefault passes for rustdoc:\");\n-        for &name in passes::DEFAULT_PASSES {\n-            println!(\"{:>20}\", name);\n-        }\n-        println!(\"\\nPasses run with `--document-private-items`:\");\n-        for &name in passes::DEFAULT_PRIVATE_PASSES {\n-            println!(\"{:>20}\", name);\n-        }\n-        return 0;\n-    }\n-\n-    let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n-        Some(\"auto\") => ColorConfig::Auto,\n-        Some(\"always\") => ColorConfig::Always,\n-        Some(\"never\") => ColorConfig::Never,\n-        None => ColorConfig::Auto,\n-        Some(arg) => {\n-            early_error(ErrorOutputType::default(),\n-                        &format!(\"argument for --color must be `auto`, `always` or `never` \\\n-                                  (instead was `{}`)\", arg));\n-        }\n-    };\n-    let error_format = match matches.opt_str(\"error-format\").as_ref().map(|s| &s[..]) {\n-        Some(\"human\") => ErrorOutputType::HumanReadable(color),\n-        Some(\"json\") => ErrorOutputType::Json(false),\n-        Some(\"pretty-json\") => ErrorOutputType::Json(true),\n-        Some(\"short\") => ErrorOutputType::Short(color),\n-        None => ErrorOutputType::HumanReadable(color),\n-        Some(arg) => {\n-            early_error(ErrorOutputType::default(),\n-                        &format!(\"argument for --error-format must be `human`, `json` or \\\n-                                  `short` (instead was `{}`)\", arg));\n-        }\n+    let options = match config::Options::from_matches(&matches) {\n+        Ok(opts) => opts,\n+        Err(code) => return code,\n     };\n-    let treat_err_as_bug = matches.opt_strs(\"Z\").iter().any(|x| {\n-        *x == \"treat-err-as-bug\"\n-    });\n-    let ui_testing = matches.opt_strs(\"Z\").iter().any(|x| {\n-        *x == \"ui-testing\"\n-    });\n-\n-    let diag = core::new_handler(error_format, None, treat_err_as_bug, ui_testing);\n-\n-    // check for deprecated options\n-    check_deprecated_options(&matches, &diag);\n-\n-    let to_check = matches.opt_strs(\"theme-checker\");\n-    if !to_check.is_empty() {\n-        let paths = theme::load_css_paths(include_bytes!(\"html/static/themes/light.css\"));\n-        let mut errors = 0;\n-\n-        println!(\"rustdoc: [theme-checker] Starting tests!\");\n-        for theme_file in to_check.iter() {\n-            print!(\" - Checking \\\"{}\\\"...\", theme_file);\n-            let (success, differences) = theme::test_theme_against(theme_file, &paths, &diag);\n-            if !differences.is_empty() || !success {\n-                println!(\" FAILED\");\n-                errors += 1;\n-                if !differences.is_empty() {\n-                    println!(\"{}\", differences.join(\"\\n\"));\n-                }\n-            } else {\n-                println!(\" OK\");\n-            }\n-        }\n-        if errors != 0 {\n-            return 1;\n-        }\n-        return 0;\n-    }\n-\n-    if matches.free.is_empty() {\n-        diag.struct_err(\"missing file operand\").emit();\n-        return 1;\n-    }\n-    if matches.free.len() > 1 {\n-        diag.struct_err(\"too many file operands\").emit();\n-        return 1;\n-    }\n-    let input = matches.free[0].clone();\n-\n-    let mut libs = SearchPaths::new();\n-    for s in &matches.opt_strs(\"L\") {\n-        libs.add_path(s, error_format);\n-    }\n-    let externs = match parse_externs(&matches) {\n-        Ok(ex) => ex,\n-        Err(err) => {\n-            diag.struct_err(&err).emit();\n-            return 1;\n-        }\n-    };\n-    let extern_urls = match parse_extern_html_roots(&matches) {\n-        Ok(ex) => ex,\n-        Err(err) => {\n-            diag.struct_err(err).emit();\n-            return 1;\n-        }\n-    };\n-\n-    let test_args = matches.opt_strs(\"test-args\");\n-    let test_args: Vec<String> = test_args.iter()\n-                                          .flat_map(|s| s.split_whitespace())\n-                                          .map(|s| s.to_string())\n-                                          .collect();\n \n-    let should_test = matches.opt_present(\"test\");\n-    let markdown_input = Path::new(&input).extension()\n-        .map_or(false, |e| e == \"md\" || e == \"markdown\");\n+    let diag = core::new_handler(options.error_format,\n+                                 None,\n+                                 options.debugging_options.treat_err_as_bug,\n+                                 options.debugging_options.ui_testing);\n \n-    let output = matches.opt_str(\"o\").map(|s| PathBuf::from(&s));\n-    let css_file_extension = matches.opt_str(\"e\").map(|s| PathBuf::from(&s));\n-    let mut cfgs = matches.opt_strs(\"cfg\");\n-    cfgs.push(\"rustdoc\".to_string());\n-\n-    if let Some(ref p) = css_file_extension {\n-        if !p.is_file() {\n-            diag.struct_err(\"option --extend-css argument must be a file\").emit();\n-            return 1;\n-        }\n-    }\n-\n-    let mut themes = Vec::new();\n-    if matches.opt_present(\"themes\") {\n-        let paths = theme::load_css_paths(include_bytes!(\"html/static/themes/light.css\"));\n-\n-        for (theme_file, theme_s) in matches.opt_strs(\"themes\")\n-                                            .iter()\n-                                            .map(|s| (PathBuf::from(&s), s.to_owned())) {\n-            if !theme_file.is_file() {\n-                diag.struct_err(\"option --themes arguments must all be files\").emit();\n-                return 1;\n-            }\n-            let (success, ret) = theme::test_theme_against(&theme_file, &paths, &diag);\n-            if !success || !ret.is_empty() {\n-                diag.struct_err(&format!(\"invalid theme: \\\"{}\\\"\", theme_s))\n-                    .help(\"check what's wrong with the --theme-checker option\")\n-                    .emit();\n-                return 1;\n-            }\n-            themes.push(theme_file);\n-        }\n-    }\n-\n-    let mut id_map = html::markdown::IdMap::new();\n-    id_map.populate(html::render::initial_ids());\n-    let external_html = match ExternalHtml::load(\n-            &matches.opt_strs(\"html-in-header\"),\n-            &matches.opt_strs(\"html-before-content\"),\n-            &matches.opt_strs(\"html-after-content\"),\n-            &matches.opt_strs(\"markdown-before-content\"),\n-            &matches.opt_strs(\"markdown-after-content\"), &diag, &mut id_map) {\n-        Some(eh) => eh,\n-        None => return 3,\n-    };\n-    let crate_name = matches.opt_str(\"crate-name\");\n-    let playground_url = matches.opt_str(\"playground-url\");\n-    let maybe_sysroot = matches.opt_str(\"sysroot\").map(PathBuf::from);\n-    let display_warnings = matches.opt_present(\"display-warnings\");\n-    let linker = matches.opt_str(\"linker\").map(PathBuf::from);\n-    let sort_modules_alphabetically = !matches.opt_present(\"sort-modules-by-appearance\");\n-    let resource_suffix = matches.opt_str(\"resource-suffix\");\n-    let index_page = matches.opt_str(\"index-page\").map(|s| PathBuf::from(&s));\n-    let enable_index_page = matches.opt_present(\"enable-index-page\") || index_page.is_some();\n-    let enable_minification = !matches.opt_present(\"disable-minification\");\n-\n-    let edition = matches.opt_str(\"edition\").unwrap_or(\"2015\".to_string());\n-    let edition = match edition.parse() {\n-        Ok(e) => e,\n-        Err(_) => {\n-            diag.struct_err(\"could not parse edition\").emit();\n-            return 1;\n-        }\n-    };\n-    if let Some(ref index_page) = index_page {\n-        if !index_page.is_file() {\n-            diag.struct_err(\"option `--index-page` argument must be a file\").emit();\n-            return 1;\n-        }\n-    }\n-\n-    let cg = build_codegen_options(&matches, ErrorOutputType::default());\n-\n-    match (should_test, markdown_input) {\n+    match (options.should_test, options.markdown_input()) {\n         (true, true) => {\n-            return markdown::test(&input, cfgs, libs, externs, test_args, maybe_sysroot,\n-                                  display_warnings, linker, edition, cg, &diag)\n+            return markdown::test(&options.input, options.cfgs, options.libs, options.externs,\n+                                  options.test_args, options.maybe_sysroot,\n+                                  options.display_warnings, options.linker, options.edition,\n+                                  options.codegen_options, &diag)\n         }\n         (true, false) => {\n-            return test::run(Path::new(&input), cfgs, libs, externs, test_args, crate_name,\n-                             maybe_sysroot, display_warnings, linker, edition, cg)\n+            return test::run(&options.input, options.cfgs, options.libs, options.externs,\n+                             options.test_args, options.crate_name, options.maybe_sysroot,\n+                             options.display_warnings, options.linker, options.edition,\n+                             options.codegen_options)\n         }\n-        (false, true) => return markdown::render(Path::new(&input),\n-                                                 output.unwrap_or(PathBuf::from(\"doc\")),\n-                                                 &matches, &external_html,\n-                                                 !matches.opt_present(\"markdown-no-toc\"), &diag),\n+        (false, true) => return markdown::render(&options.input, options.output,\n+                                                 &matches,\n+                                                 &options.external_html,\n+                                                 !options.markdown_no_toc, &diag),\n         (false, false) => {}\n     }\n \n-    let output_format = matches.opt_str(\"w\");\n-\n-    let res = acquire_input(PathBuf::from(input), externs, edition, cg, matches, error_format,\n+    let res = acquire_input(options.input.clone(), options.externs.clone(), options.edition,\n+                            options.codegen_options.clone(), matches, options.error_format,\n                             move |out, matches| {\n         let Output { krate, passes, renderinfo } = out;\n-        let diag = core::new_handler(error_format, None, treat_err_as_bug, ui_testing);\n         info!(\"going to format\");\n-        match output_format.as_ref().map(|s| &**s) {\n-            Some(\"html\") | None => {\n-                html::render::run(krate, extern_urls, &external_html, playground_url,\n-                                  output.unwrap_or(PathBuf::from(\"doc\")),\n-                                  resource_suffix.unwrap_or(String::new()),\n-                                  passes.into_iter().collect(),\n-                                  css_file_extension,\n-                                  renderinfo,\n-                                  sort_modules_alphabetically,\n-                                  themes,\n-                                  enable_minification, id_map,\n-                                  enable_index_page, index_page,\n-                                  &matches,\n-                                  &diag)\n-                    .expect(\"failed to generate documentation\");\n-                0\n-            }\n-            Some(s) => {\n-                diag.struct_err(&format!(\"unknown output format: {}\", s)).emit();\n-                1\n-            }\n-        }\n+        html::render::run(krate, options.extern_html_root_urls, &options.external_html, options.playground_url,\n+                          options.output,\n+                          options.resource_suffix,\n+                          passes.into_iter().collect(),\n+                          options.extension_css,\n+                          renderinfo,\n+                          options.sort_modules_alphabetically,\n+                          options.themes,\n+                          options.enable_minification, options.id_map,\n+                          options.enable_index_page, options.index_page,\n+                          &matches,\n+                          &diag)\n+            .expect(\"failed to generate documentation\");\n+        0\n     });\n     res.unwrap_or_else(|s| {\n         diag.struct_err(&format!(\"input error: {}\", s)).emit();\n@@ -636,43 +437,6 @@ where R: 'static + Send, F: 'static + Send + FnOnce(Output, &getopts::Matches) -\n     }\n }\n \n-/// Extracts `--extern CRATE=PATH` arguments from `matches` and\n-/// returns a map mapping crate names to their paths or else an\n-/// error message.\n-// FIXME(eddyb) This shouldn't be duplicated with `rustc::session`.\n-fn parse_externs(matches: &getopts::Matches) -> Result<Externs, String> {\n-    let mut externs: BTreeMap<_, BTreeSet<_>> = BTreeMap::new();\n-    for arg in &matches.opt_strs(\"extern\") {\n-        let mut parts = arg.splitn(2, '=');\n-        let name = parts.next().ok_or(\"--extern value must not be empty\".to_string())?;\n-        let location = parts.next().map(|s| s.to_string());\n-        if location.is_none() && !nightly_options::is_unstable_enabled(matches) {\n-            return Err(\"the `-Z unstable-options` flag must also be passed to \\\n-                        enable `--extern crate_name` without `=path`\".to_string());\n-        }\n-        let name = name.to_string();\n-        externs.entry(name).or_default().insert(location);\n-    }\n-    Ok(Externs::new(externs))\n-}\n-\n-/// Extracts `--extern-html-root-url` arguments from `matches` and returns a map of crate names to\n-/// the given URLs. If an `--extern-html-root-url` argument was ill-formed, returns an error\n-/// describing the issue.\n-fn parse_extern_html_roots(matches: &getopts::Matches)\n-    -> Result<BTreeMap<String, String>, &'static str>\n-{\n-    let mut externs = BTreeMap::new();\n-    for arg in &matches.opt_strs(\"extern-html-root-url\") {\n-        let mut parts = arg.splitn(2, '=');\n-        let name = parts.next().ok_or(\"--extern-html-root-url must not be empty\")?;\n-        let url = parts.next().ok_or(\"--extern-html-root-url must be of the form name=url\")?;\n-        externs.insert(name.to_string(), url.to_string());\n-    }\n-\n-    Ok(externs)\n-}\n-\n /// Interprets the input file as a rust source file, passing it through the\n /// compiler all the way through the analysis passes. The rustdoc output is then\n /// generated from the cleaned AST of the crate.\n@@ -792,27 +556,3 @@ where R: 'static + Send,\n         Err(_) => panic::resume_unwind(Box::new(errors::FatalErrorMarker)),\n     }\n }\n-\n-/// Prints deprecation warnings for deprecated options\n-fn check_deprecated_options(matches: &getopts::Matches, diag: &errors::Handler) {\n-    let deprecated_flags = [\n-       \"input-format\",\n-       \"output-format\",\n-       \"no-defaults\",\n-       \"passes\",\n-    ];\n-\n-    for flag in deprecated_flags.into_iter() {\n-        if matches.opt_present(flag) {\n-            let mut err = diag.struct_warn(&format!(\"the '{}' flag is considered deprecated\",\n-                                                    flag));\n-            err.warn(\"please see https://github.com/rust-lang/rust/issues/44136\");\n-\n-            if *flag == \"no-defaults\" {\n-                err.help(\"you may want to use --document-private-items\");\n-            }\n-\n-            err.emit();\n-        }\n-    }\n-}"}, {"sha": "d8243bb35864dac265b1501e0183e527d9f7e93e", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5f496efd086ae763075295eac8aae757909f29c/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f496efd086ae763075295eac8aae757909f29c/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=f5f496efd086ae763075295eac8aae757909f29c", "patch": "@@ -140,7 +140,7 @@ pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n }\n \n /// Run any tests/code examples in the markdown file `input`.\n-pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n+pub fn test(input: &Path, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n             mut test_args: Vec<String>, maybe_sysroot: Option<PathBuf>,\n             display_warnings: bool, linker: Option<PathBuf>, edition: Edition,\n             cg: CodegenOptions, diag: &errors::Handler) -> isize {\n@@ -153,7 +153,7 @@ pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n     let mut opts = TestOptions::default();\n     opts.no_crate_inject = true;\n     opts.display_warnings = display_warnings;\n-    let mut collector = Collector::new(input.to_owned(), cfgs, libs, cg, externs,\n+    let mut collector = Collector::new(input.display().to_string(), cfgs, libs, cg, externs,\n                                        true, opts, maybe_sysroot, None,\n                                        Some(PathBuf::from(input)),\n                                        linker, edition);"}]}