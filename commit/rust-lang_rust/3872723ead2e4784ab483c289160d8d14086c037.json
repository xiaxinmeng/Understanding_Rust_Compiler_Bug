{"sha": "3872723ead2e4784ab483c289160d8d14086c037", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NzI3MjNlYWQyZTQ3ODRhYjQ4M2MyODkxNjBkOGQxNDA4NmMwMzc=", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-06-23T21:19:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-23T21:19:08Z"}, "message": "Merge pull request #138 from rust-lang/feature/various-fns\n\nAdd various fns\r\n- Sum/Product traits\r\n- recip/to_degrees/to_radians/min/max/clamp/signum/copysign; rust-lang/stdsimd#14\r\n- mul_add: rust-lang/stdsimd#14, fixes rust-lang/stdsimd#102", "tree": {"sha": "34713f84d85d95fafa9044b6648103fb59572525", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34713f84d85d95fafa9044b6648103fb59572525"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3872723ead2e4784ab483c289160d8d14086c037", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg06VMCRBK7hj4Ov3rIwAAtvQIADojDs4gKR806hK/IiujCLML\nAVWc8Of92eSGHJUHf/bonx3BGB79TypuGx5ZY9zI/QQ+qP/VW4/0/R6Fpo1UyL4p\nNin+bZ6VEZppvGqed0KKwlbGz1TzxGiJLgQllQgQHU7GTqbX6dXkyS8j6tOECn4u\n+jfSzM5wM8WBKr+3iljDjoFjGZBDAvd3zOEKFk/oOVpB2yWHt8SHW1HA7z89M5/k\nsfTW74zui06zUW4MTv1dVyUXjDi2XihyQfTrFjt+aiw/WscIR8oFRl5zWID+ECFg\nztSM0Sl/ep5FB9EHaPcxeDChIOpjocsvQYBzhxgiNx/YDIOjDt43ImQMWYaaDc8=\n=XyO6\n-----END PGP SIGNATURE-----\n", "payload": "tree 34713f84d85d95fafa9044b6648103fb59572525\nparent 15b4e280049a2b495635027ebfcb3b6930fbc12a\nparent b0a9fe5d07674fc20ab3dc26f9c3c9c1302d54e8\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1624483148 -0700\ncommitter GitHub <noreply@github.com> 1624483148 -0700\n\nMerge pull request #138 from rust-lang/feature/various-fns\n\nAdd various fns\r\n- Sum/Product traits\r\n- recip/to_degrees/to_radians/min/max/clamp/signum/copysign; rust-lang/stdsimd#14\r\n- mul_add: rust-lang/stdsimd#14, fixes rust-lang/stdsimd#102"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3872723ead2e4784ab483c289160d8d14086c037", "html_url": "https://github.com/rust-lang/rust/commit/3872723ead2e4784ab483c289160d8d14086c037", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3872723ead2e4784ab483c289160d8d14086c037/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15b4e280049a2b495635027ebfcb3b6930fbc12a", "url": "https://api.github.com/repos/rust-lang/rust/commits/15b4e280049a2b495635027ebfcb3b6930fbc12a", "html_url": "https://github.com/rust-lang/rust/commit/15b4e280049a2b495635027ebfcb3b6930fbc12a"}, {"sha": "b0a9fe5d07674fc20ab3dc26f9c3c9c1302d54e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0a9fe5d07674fc20ab3dc26f9c3c9c1302d54e8", "html_url": "https://github.com/rust-lang/rust/commit/b0a9fe5d07674fc20ab3dc26f9c3c9c1302d54e8"}], "stats": {"total": 354, "additions": 353, "deletions": 1}, "files": [{"sha": "3983beb82ecfa9a2e67f9d516d566aa6da62a12a", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3872723ead2e4784ab483c289160d8d14086c037/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3872723ead2e4784ab483c289160d8d14086c037/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=3872723ead2e4784ab483c289160d8d14086c037", "patch": "@@ -49,6 +49,9 @@ extern \"platform-intrinsic\" {\n     /// fsqrt\n     pub(crate) fn simd_fsqrt<T>(x: T) -> T;\n \n+    /// fma\n+    pub(crate) fn simd_fma<T>(x: T, y: T, z: T) -> T;\n+\n     pub(crate) fn simd_eq<T, U>(x: T, y: T) -> U;\n     pub(crate) fn simd_ne<T, U>(x: T, y: T) -> U;\n     pub(crate) fn simd_lt<T, U>(x: T, y: T) -> U;"}, {"sha": "c1c4c645db6b16204e49332e706d99fbcac584a8", "filename": "crates/core_simd/src/iter.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3872723ead2e4784ab483c289160d8d14086c037/crates%2Fcore_simd%2Fsrc%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3872723ead2e4784ab483c289160d8d14086c037/crates%2Fcore_simd%2Fsrc%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fiter.rs?ref=3872723ead2e4784ab483c289160d8d14086c037", "patch": "@@ -0,0 +1,52 @@\n+macro_rules! impl_traits {\n+    { $type:ident } => {\n+        impl<const LANES: usize> core::iter::Sum<Self> for crate::$type<LANES>\n+        where\n+            Self: crate::LanesAtMost32,\n+        {\n+            fn sum<I: core::iter::Iterator<Item = Self>>(iter: I) -> Self {\n+                iter.fold(Default::default(), core::ops::Add::add)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::iter::Product<Self> for crate::$type<LANES>\n+        where\n+            Self: crate::LanesAtMost32,\n+        {\n+            fn product<I: core::iter::Iterator<Item = Self>>(iter: I) -> Self {\n+                iter.fold(Default::default(), core::ops::Mul::mul)\n+            }\n+        }\n+\n+        impl<'a, const LANES: usize> core::iter::Sum<&'a Self> for crate::$type<LANES>\n+        where\n+            Self: crate::LanesAtMost32,\n+        {\n+            fn sum<I: core::iter::Iterator<Item = &'a Self>>(iter: I) -> Self {\n+                iter.fold(Default::default(), core::ops::Add::add)\n+            }\n+        }\n+\n+        impl<'a, const LANES: usize> core::iter::Product<&'a Self> for crate::$type<LANES>\n+        where\n+            Self: crate::LanesAtMost32,\n+        {\n+            fn product<I: core::iter::Iterator<Item = &'a Self>>(iter: I) -> Self {\n+                iter.fold(Default::default(), core::ops::Mul::mul)\n+            }\n+        }\n+    }\n+}\n+\n+impl_traits! { SimdF32 }\n+impl_traits! { SimdF64 }\n+impl_traits! { SimdU8 }\n+impl_traits! { SimdU16 }\n+impl_traits! { SimdU32 }\n+impl_traits! { SimdU64 }\n+impl_traits! { SimdUsize }\n+impl_traits! { SimdI8 }\n+impl_traits! { SimdI16 }\n+impl_traits! { SimdI32 }\n+impl_traits! { SimdI64 }\n+impl_traits! { SimdIsize }"}, {"sha": "5b74d1d574a6e26209906faa0aeb63bad9c4e7e2", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3872723ead2e4784ab483c289160d8d14086c037/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3872723ead2e4784ab483c289160d8d14086c037/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=3872723ead2e4784ab483c289160d8d14086c037", "patch": "@@ -22,6 +22,7 @@ pub use to_bytes::ToBytes;\n mod comparisons;\n mod fmt;\n mod intrinsics;\n+mod iter;\n mod ops;\n mod round;\n "}, {"sha": "4656eb3f37943d6351ed24ac14ad23d51b0bb237", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 93, "deletions": 1, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3872723ead2e4784ab483c289160d8d14086c037/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3872723ead2e4784ab483c289160d8d14086c037/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=3872723ead2e4784ab483c289160d8d14086c037", "patch": "@@ -4,7 +4,7 @@\n /// `$lanes` of float `$type`, which uses `$bits_ty` as its binary\n /// representation. Called from `define_float_vector!`.\n macro_rules! impl_float_vector {\n-    { $name:ident, $type:ty, $bits_ty:ident, $mask_ty:ident, $mask_impl_ty:ident } => {\n+    { $name:ident, $type:ident, $bits_ty:ident, $mask_ty:ident, $mask_impl_ty:ident } => {\n         impl_vector! { $name, $type }\n         impl_float_reductions! { $name, $type }\n \n@@ -36,13 +36,44 @@ macro_rules! impl_float_vector {\n                 unsafe { crate::intrinsics::simd_fabs(self) }\n             }\n \n+            /// Fused multiply-add.  Computes `(self * a) + b` with only one rounding error,\n+            /// yielding a more accurate result than an unfused multiply-add.\n+            ///\n+            /// Using `mul_add` *may* be more performant than an unfused multiply-add if the target\n+            /// architecture has a dedicated `fma` CPU instruction.  However, this is not always\n+            /// true, and will be heavily dependent on designing algorithms with specific target\n+            /// hardware in mind.\n+            #[inline]\n+            pub fn mul_add(self, a: Self, b: Self) -> Self {\n+                unsafe { crate::intrinsics::simd_fma(self, a, b) }\n+            }\n+\n             /// Produces a vector where every lane has the square root value\n             /// of the equivalently-indexed lane in `self`\n             #[inline]\n             #[cfg(feature = \"std\")]\n             pub fn sqrt(self) -> Self {\n                 unsafe { crate::intrinsics::simd_fsqrt(self) }\n             }\n+\n+            /// Takes the reciprocal (inverse) of each lane, `1/x`.\n+            #[inline]\n+            pub fn recip(self) -> Self {\n+                Self::splat(1.0) / self\n+            }\n+\n+            /// Converts each lane from radians to degrees.\n+            #[inline]\n+            pub fn to_degrees(self) -> Self {\n+                // to_degrees uses a special constant for better precision, so extract that constant\n+                self * Self::splat($type::to_degrees(1.))\n+            }\n+\n+            /// Converts each lane from degrees to radians.\n+            #[inline]\n+            pub fn to_radians(self) -> Self {\n+                self * Self::splat($type::to_radians(1.))\n+            }\n         }\n \n         impl<const LANES: usize> $name<LANES>\n@@ -97,6 +128,67 @@ macro_rules! impl_float_vector {\n             pub fn is_normal(self) -> crate::$mask_ty<LANES> {\n                 !(self.abs().lanes_eq(Self::splat(0.0)) | self.is_nan() | self.is_subnormal() | self.is_infinite())\n             }\n+\n+            /// Replaces each lane with a number that represents its sign.\n+            ///\n+            /// * `1.0` if the number is positive, `+0.0`, or `INFINITY`\n+            /// * `-1.0` if the number is negative, `-0.0`, or `NEG_INFINITY`\n+            /// * `NAN` if the number is `NAN`\n+            #[inline]\n+            pub fn signum(self) -> Self {\n+                self.is_nan().select(Self::splat($type::NAN), Self::splat(1.0).copysign(self))\n+            }\n+\n+            /// Returns each lane with the magnitude of `self` and the sign of `sign`.\n+            ///\n+            /// If any lane is a `NAN`, then a `NAN` with the sign of `sign` is returned.\n+            #[inline]\n+            pub fn copysign(self, sign: Self) -> Self {\n+                let sign_bit = sign.to_bits() & Self::splat(-0.).to_bits();\n+                let magnitude = self.to_bits() & !Self::splat(-0.).to_bits();\n+                Self::from_bits(sign_bit | magnitude)\n+            }\n+\n+            /// Returns the minimum of each lane.\n+            ///\n+            /// If one of the values is `NAN`, then the other value is returned.\n+            #[inline]\n+            pub fn min(self, other: Self) -> Self {\n+                // TODO consider using an intrinsic\n+                self.is_nan().select(\n+                    other,\n+                    self.lanes_ge(other).select(other, self)\n+                )\n+            }\n+\n+            /// Returns the maximum of each lane.\n+            ///\n+            /// If one of the values is `NAN`, then the other value is returned.\n+            #[inline]\n+            pub fn max(self, other: Self) -> Self {\n+                // TODO consider using an intrinsic\n+                self.is_nan().select(\n+                    other,\n+                    self.lanes_le(other).select(other, self)\n+                )\n+            }\n+\n+            /// Restrict each lane to a certain interval unless it is NaN.\n+            /// \n+            /// For each lane in `self`, returns the corresponding lane in `max` if the lane is\n+            /// greater than `max`, and the corresponding lane in `min` if the lane is less\n+            /// than `min`.  Otherwise returns the lane in `self`.\n+            #[inline]\n+            pub fn clamp(self, min: Self, max: Self) -> Self {\n+                assert!(\n+                    min.lanes_le(max).all(),\n+                    \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+                );\n+                let mut x = self;\n+                x = x.lanes_lt(min).select(min, x);\n+                x = x.lanes_gt(max).select(max, x);\n+                x\n+            }\n         }\n     };\n }"}, {"sha": "dd7b2225dbd720936f6af349eb480d39469d6ccf", "filename": "crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3872723ead2e4784ab483c289160d8d14086c037/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3872723ead2e4784ab483c289160d8d14086c037/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=3872723ead2e4784ab483c289160d8d14086c037", "patch": "@@ -33,14 +33,28 @@ macro_rules! impl_integer_vector {\n             crate::$mask_ty<LANES>: crate::Mask,\n         {\n             /// Returns true for each positive lane and false if it is zero or negative.\n+            #[inline]\n             pub fn is_positive(self) -> crate::$mask_ty<LANES> {\n                 self.lanes_gt(Self::splat(0))\n             }\n \n             /// Returns true for each negative lane and false if it is zero or positive.\n+            #[inline]\n             pub fn is_negative(self) -> crate::$mask_ty<LANES> {\n                 self.lanes_lt(Self::splat(0))\n             }\n+\n+            /// Returns numbers representing the sign of each lane.\n+            /// * `0` if the number is zero\n+            /// * `1` if the number is positive\n+            /// * `-1` if the number is negative\n+            #[inline]\n+            pub fn signum(self) -> Self {\n+                self.is_positive().select(\n+                    Self::splat(1),\n+                    self.is_negative().select(Self::splat(-1), Self::splat(0))\n+                )\n+            }\n         }\n     }\n }"}, {"sha": "cb39e7377054bf24e0bdebf40b2c4a9fca0fadda", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/3872723ead2e4784ab483c289160d8d14086c037/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3872723ead2e4784ab483c289160d8d14086c037/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=3872723ead2e4784ab483c289160d8d14086c037", "patch": "@@ -247,6 +247,15 @@ macro_rules! impl_signed_tests {\n                         &|_| true,\n                     );\n                 }\n+\n+                fn signum<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::signum,\n+                        &Scalar::signum,\n+                        &|_| true,\n+                    )\n+                }\n+\n             }\n \n             test_helpers::test_lanes_panic! {\n@@ -426,13 +435,132 @@ macro_rules! impl_float_tests {\n                     )\n                 }\n \n+                fn mul_add<const LANES: usize>() {\n+                    test_helpers::test_ternary_elementwise(\n+                        &Vector::<LANES>::mul_add,\n+                        &Scalar::mul_add,\n+                        &|_, _, _| true,\n+                    )\n+                }\n+\n                 fn sqrt<const LANES: usize>() {\n                     test_helpers::test_unary_elementwise(\n                         &Vector::<LANES>::sqrt,\n                         &Scalar::sqrt,\n                         &|_| true,\n                     )\n                 }\n+\n+                fn recip<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::recip,\n+                        &Scalar::recip,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn to_degrees<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::to_degrees,\n+                        &Scalar::to_degrees,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn to_radians<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::to_radians,\n+                        &Scalar::to_radians,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn signum<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::signum,\n+                        &Scalar::signum,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn copysign<const LANES: usize>() {\n+                    test_helpers::test_binary_elementwise(\n+                        &Vector::<LANES>::copysign,\n+                        &Scalar::copysign,\n+                        &|_, _| true,\n+                    )\n+                }\n+\n+                fn min<const LANES: usize>() {\n+                    // Regular conditions (both values aren't zero)\n+                    test_helpers::test_binary_elementwise(\n+                        &Vector::<LANES>::min,\n+                        &Scalar::min,\n+                        // Reject the case where both values are zero with different signs\n+                        &|a, b| {\n+                            for (a, b) in a.iter().zip(b.iter()) {\n+                                if *a == 0. && *b == 0. && a.signum() != b.signum() {\n+                                    return false;\n+                                }\n+                            }\n+                            true\n+                        }\n+                    );\n+\n+                    // Special case where both values are zero\n+                    let p_zero = Vector::<LANES>::splat(0.);\n+                    let n_zero = Vector::<LANES>::splat(-0.);\n+                    assert!(p_zero.min(n_zero).to_array().iter().all(|x| *x == 0.));\n+                    assert!(n_zero.min(p_zero).to_array().iter().all(|x| *x == 0.));\n+                }\n+\n+                fn max<const LANES: usize>() {\n+                    // Regular conditions (both values aren't zero)\n+                    test_helpers::test_binary_elementwise(\n+                        &Vector::<LANES>::max,\n+                        &Scalar::max,\n+                        // Reject the case where both values are zero with different signs\n+                        &|a, b| {\n+                            for (a, b) in a.iter().zip(b.iter()) {\n+                                if *a == 0. && *b == 0. && a.signum() != b.signum() {\n+                                    return false;\n+                                }\n+                            }\n+                            true\n+                        }\n+                    );\n+\n+                    // Special case where both values are zero\n+                    let p_zero = Vector::<LANES>::splat(0.);\n+                    let n_zero = Vector::<LANES>::splat(-0.);\n+                    assert!(p_zero.max(n_zero).to_array().iter().all(|x| *x == 0.));\n+                    assert!(n_zero.max(p_zero).to_array().iter().all(|x| *x == 0.));\n+                }\n+\n+                fn clamp<const LANES: usize>() {\n+                    test_helpers::test_3(&|value: [Scalar; LANES], mut min: [Scalar; LANES], mut max: [Scalar; LANES]| {\n+                        for (min, max) in min.iter_mut().zip(max.iter_mut()) {\n+                            if max < min {\n+                                core::mem::swap(min, max);\n+                            }\n+                            if min.is_nan() {\n+                                *min = Scalar::NEG_INFINITY;\n+                            }\n+                            if max.is_nan() {\n+                                *max = Scalar::INFINITY;\n+                            }\n+                        }\n+\n+                        let mut result_scalar = [Scalar::default(); LANES];\n+                        for i in 0..LANES {\n+                            result_scalar[i] = value[i].clamp(min[i], max[i]);\n+                        }\n+                        let result_vector = Vector::from_array(value).clamp(min.into(), max.into()).to_array();\n+                        test_helpers::prop_assert_biteq!(result_scalar, result_vector);\n+                        Ok(())\n+                    })\n+                }\n+\n                 fn horizontal_sum<const LANES: usize>() {\n                     test_helpers::test_1(&|x| {\n                         test_helpers::prop_assert_biteq! ("}, {"sha": "4f2380b8e5ba3aec14c6cb88067d054b4bad2e44", "filename": "crates/test_helpers/src/lib.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3872723ead2e4784ab483c289160d8d14086c037/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3872723ead2e4784ab483c289160d8d14086c037/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=3872723ead2e4784ab483c289160d8d14086c037", "patch": "@@ -97,6 +97,27 @@ pub fn test_2<A: core::fmt::Debug + DefaultStrategy, B: core::fmt::Debug + Defau\n         .unwrap();\n }\n \n+/// Test a function that takes two values.\n+pub fn test_3<\n+    A: core::fmt::Debug + DefaultStrategy,\n+    B: core::fmt::Debug + DefaultStrategy,\n+    C: core::fmt::Debug + DefaultStrategy,\n+>(\n+    f: &dyn Fn(A, B, C) -> proptest::test_runner::TestCaseResult,\n+) {\n+    let mut runner = proptest::test_runner::TestRunner::default();\n+    runner\n+        .run(\n+            &(\n+                A::default_strategy(),\n+                B::default_strategy(),\n+                C::default_strategy(),\n+            ),\n+            |(a, b, c)| f(a, b, c),\n+        )\n+        .unwrap();\n+}\n+\n /// Test a unary vector function against a unary scalar function, applied elementwise.\n #[inline(never)]\n pub fn test_unary_elementwise<Scalar, ScalarResult, Vector, VectorResult, const LANES: usize>(\n@@ -257,6 +278,47 @@ pub fn test_binary_scalar_lhs_elementwise<\n     });\n }\n \n+/// Test a ternary vector function against a ternary scalar function, applied elementwise.\n+#[inline(never)]\n+pub fn test_ternary_elementwise<\n+    Scalar1,\n+    Scalar2,\n+    Scalar3,\n+    ScalarResult,\n+    Vector1,\n+    Vector2,\n+    Vector3,\n+    VectorResult,\n+    const LANES: usize,\n+>(\n+    fv: &dyn Fn(Vector1, Vector2, Vector3) -> VectorResult,\n+    fs: &dyn Fn(Scalar1, Scalar2, Scalar3) -> ScalarResult,\n+    check: &dyn Fn([Scalar1; LANES], [Scalar2; LANES], [Scalar3; LANES]) -> bool,\n+) where\n+    Scalar1: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Scalar2: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Scalar3: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Vector1: Into<[Scalar1; LANES]> + From<[Scalar1; LANES]> + Copy,\n+    Vector2: Into<[Scalar2; LANES]> + From<[Scalar2; LANES]> + Copy,\n+    Vector3: Into<[Scalar3; LANES]> + From<[Scalar3; LANES]> + Copy,\n+    VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n+{\n+    test_3(&|x: [Scalar1; LANES], y: [Scalar2; LANES], z: [Scalar3; LANES]| {\n+        proptest::prop_assume!(check(x, y, z));\n+        let result_1: [ScalarResult; LANES] = fv(x.into(), y.into(), z.into()).into();\n+        let result_2: [ScalarResult; LANES] = {\n+            let mut result = [ScalarResult::default(); LANES];\n+            for ((i1, (i2, i3)), o) in x.iter().zip(y.iter().zip(z.iter())).zip(result.iter_mut()) {\n+                *o = fs(*i1, *i2, *i3);\n+            }\n+            result\n+        };\n+        crate::prop_assert_biteq!(result_1, result_2);\n+        Ok(())\n+    });\n+}\n+\n /// Expand a const-generic test into separate tests for each possible lane count.\n #[macro_export]\n macro_rules! test_lanes {"}]}