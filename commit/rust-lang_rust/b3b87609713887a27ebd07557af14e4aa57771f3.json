{"sha": "b3b87609713887a27ebd07557af14e4aa57771f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzYjg3NjA5NzEzODg3YTI3ZWJkMDc1NTdhZjE0ZTRhYTU3NzcxZjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-27T16:50:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-27T16:50:41Z"}, "message": "Auto merge of #55385 - davidtwco:issue-55288, r=oli-obk\n\nNLL: cast causes failure to promote to static\n\nFixes #55288. See commit messages for more details.\n\nr? @oli-obk\ncc @nikomatsakis\ncc @pnkfelix\ncc @RalfJung", "tree": {"sha": "85c4d91acf9ca9f5cee3a55900de45e3354b25ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85c4d91acf9ca9f5cee3a55900de45e3354b25ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3b87609713887a27ebd07557af14e4aa57771f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3b87609713887a27ebd07557af14e4aa57771f3", "html_url": "https://github.com/rust-lang/rust/commit/b3b87609713887a27ebd07557af14e4aa57771f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3b87609713887a27ebd07557af14e4aa57771f3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f32f1113c93fe84f252293ae4af86be1ceae4a84", "url": "https://api.github.com/repos/rust-lang/rust/commits/f32f1113c93fe84f252293ae4af86be1ceae4a84", "html_url": "https://github.com/rust-lang/rust/commit/f32f1113c93fe84f252293ae4af86be1ceae4a84"}, {"sha": "6208bd8e03996e700950451e7614a6feb0163acb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6208bd8e03996e700950451e7614a6feb0163acb", "html_url": "https://github.com/rust-lang/rust/commit/6208bd8e03996e700950451e7614a6feb0163acb"}], "stats": {"total": 550, "additions": 356, "deletions": 194}, "files": [{"sha": "caa627441ceb6107b5caacb8092004c42466deea", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 191, "deletions": 99, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=b3b87609713887a27ebd07557af14e4aa57771f3", "patch": "@@ -364,33 +364,54 @@ macro_rules! make_mir_visitor {\n                         self.visit_assign(block, place, rvalue, location);\n                     }\n                     StatementKind::FakeRead(_, ref $($mutability)* place) => {\n-                        self.visit_place(place,\n-                                         PlaceContext::Inspect,\n-                                         location);\n+                        self.visit_place(\n+                            place,\n+                            PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect),\n+                            location\n+                        );\n                     }\n                     StatementKind::EndRegion(_) => {}\n                     StatementKind::Validate(_, ref $($mutability)* places) => {\n                         for operand in places {\n-                            self.visit_place(& $($mutability)* operand.place,\n-                                              PlaceContext::Validate, location);\n+                            self.visit_place(\n+                                & $($mutability)* operand.place,\n+                                PlaceContext::NonUse(NonUseContext::Validate),\n+                                location\n+                            );\n                             self.visit_ty(& $($mutability)* operand.ty,\n                                           TyContext::Location(location));\n                         }\n                     }\n                     StatementKind::SetDiscriminant{ ref $($mutability)* place, .. } => {\n-                        self.visit_place(place, PlaceContext::Store, location);\n+                        self.visit_place(\n+                            place,\n+                            PlaceContext::MutatingUse(MutatingUseContext::Store),\n+                            location\n+                        );\n                     }\n                     StatementKind::StorageLive(ref $($mutability)* local) => {\n-                        self.visit_local(local, PlaceContext::StorageLive, location);\n+                        self.visit_local(\n+                            local,\n+                            PlaceContext::NonUse(NonUseContext::StorageLive),\n+                            location\n+                        );\n                     }\n                     StatementKind::StorageDead(ref $($mutability)* local) => {\n-                        self.visit_local(local, PlaceContext::StorageDead, location);\n+                        self.visit_local(\n+                            local,\n+                            PlaceContext::NonUse(NonUseContext::StorageDead),\n+                            location\n+                        );\n                     }\n                     StatementKind::InlineAsm { ref $($mutability)* outputs,\n                                                ref $($mutability)* inputs,\n                                                asm: _ } => {\n                         for output in & $($mutability)* outputs[..] {\n-                            self.visit_place(output, PlaceContext::AsmOutput, location);\n+                            self.visit_place(\n+                                output,\n+                                PlaceContext::MutatingUse(MutatingUseContext::AsmOutput),\n+                                location\n+                            );\n                         }\n                         for input in & $($mutability)* inputs[..] {\n                             self.visit_operand(input, location);\n@@ -412,7 +433,11 @@ macro_rules! make_mir_visitor {\n                             place: &$($mutability)* Place<'tcx>,\n                             rvalue: &$($mutability)* Rvalue<'tcx>,\n                             location: Location) {\n-                self.visit_place(place, PlaceContext::Store, location);\n+                self.visit_place(\n+                    place,\n+                    PlaceContext::MutatingUse(MutatingUseContext::Store),\n+                    location\n+                );\n                 self.visit_rvalue(rvalue, location);\n             }\n \n@@ -459,7 +484,11 @@ macro_rules! make_mir_visitor {\n                     TerminatorKind::Drop { ref $($mutability)* location,\n                                            target,\n                                            unwind } => {\n-                        self.visit_place(location, PlaceContext::Drop, source_location);\n+                        self.visit_place(\n+                            location,\n+                            PlaceContext::MutatingUse(MutatingUseContext::Drop),\n+                            source_location\n+                        );\n                         self.visit_branch(block, target);\n                         unwind.map(|t| self.visit_branch(block, t));\n                     }\n@@ -468,7 +497,11 @@ macro_rules! make_mir_visitor {\n                                                      ref $($mutability)* value,\n                                                      target,\n                                                      unwind } => {\n-                        self.visit_place(location, PlaceContext::Drop, source_location);\n+                        self.visit_place(\n+                            location,\n+                            PlaceContext::MutatingUse(MutatingUseContext::Drop),\n+                            source_location\n+                        );\n                         self.visit_operand(value, source_location);\n                         self.visit_branch(block, target);\n                         unwind.map(|t| self.visit_branch(block, t));\n@@ -484,7 +517,11 @@ macro_rules! make_mir_visitor {\n                             self.visit_operand(arg, source_location);\n                         }\n                         if let Some((ref $($mutability)* destination, target)) = *destination {\n-                            self.visit_place(destination, PlaceContext::Call, source_location);\n+                            self.visit_place(\n+                                destination,\n+                                PlaceContext::MutatingUse(MutatingUseContext::Call),\n+                                source_location\n+                            );\n                             self.visit_branch(block, target);\n                         }\n                         cleanup.map(|t| self.visit_branch(block, t));\n@@ -552,14 +589,28 @@ macro_rules! make_mir_visitor {\n \n                     Rvalue::Ref(ref $($mutability)* r, bk, ref $($mutability)* path) => {\n                         self.visit_region(r, location);\n-                        self.visit_place(path, PlaceContext::Borrow {\n-                            region: *r,\n-                            kind: bk\n-                        }, location);\n+                        let ctx = match bk {\n+                            BorrowKind::Shared => PlaceContext::NonMutatingUse(\n+                                NonMutatingUseContext::SharedBorrow(*r)\n+                            ),\n+                            BorrowKind::Shallow => PlaceContext::NonMutatingUse(\n+                                NonMutatingUseContext::ShallowBorrow(*r)\n+                            ),\n+                            BorrowKind::Unique => PlaceContext::NonMutatingUse(\n+                                NonMutatingUseContext::UniqueBorrow(*r)\n+                            ),\n+                            BorrowKind::Mut { .. } =>\n+                                PlaceContext::MutatingUse(MutatingUseContext::Borrow(*r)),\n+                        };\n+                        self.visit_place(path, ctx, location);\n                     }\n \n                     Rvalue::Len(ref $($mutability)* path) => {\n-                        self.visit_place(path, PlaceContext::Inspect, location);\n+                        self.visit_place(\n+                            path,\n+                            PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect),\n+                            location\n+                        );\n                     }\n \n                     Rvalue::Cast(_cast_kind,\n@@ -584,7 +635,11 @@ macro_rules! make_mir_visitor {\n                     }\n \n                     Rvalue::Discriminant(ref $($mutability)* place) => {\n-                        self.visit_place(place, PlaceContext::Inspect, location);\n+                        self.visit_place(\n+                            place,\n+                            PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect),\n+                            location\n+                        );\n                     }\n \n                     Rvalue::NullaryOp(_op, ref $($mutability)* ty) => {\n@@ -632,10 +687,18 @@ macro_rules! make_mir_visitor {\n                              location: Location) {\n                 match *operand {\n                     Operand::Copy(ref $($mutability)* place) => {\n-                        self.visit_place(place, PlaceContext::Copy, location);\n+                        self.visit_place(\n+                            place,\n+                            PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n+                            location\n+                        );\n                     }\n                     Operand::Move(ref $($mutability)* place) => {\n-                        self.visit_place(place, PlaceContext::Move, location);\n+                        self.visit_place(\n+                            place,\n+                            PlaceContext::NonMutatingUse(NonMutatingUseContext::Move),\n+                            location\n+                        );\n                     }\n                     Operand::Constant(ref $($mutability)* constant) => {\n                         self.visit_constant(constant, location);\n@@ -648,7 +711,11 @@ macro_rules! make_mir_visitor {\n                                      _variance: & $($mutability)* ty::Variance,\n                                      user_ty: & $($mutability)* UserTypeProjection<'tcx>,\n                                      location: Location) {\n-                self.visit_place(place, PlaceContext::Validate, location);\n+                self.visit_place(\n+                    place,\n+                    PlaceContext::NonUse(NonUseContext::AscribeUserTy),\n+                    location\n+                );\n                 self.visit_user_type_projection(user_ty);\n             }\n \n@@ -693,9 +760,9 @@ macro_rules! make_mir_visitor {\n                     ref $($mutability)* elem,\n                 } = *proj;\n                 let context = if context.is_mutating_use() {\n-                    PlaceContext::Projection(Mutability::Mut)\n+                    PlaceContext::MutatingUse(MutatingUseContext::Projection)\n                 } else {\n-                    PlaceContext::Projection(Mutability::Not)\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n                 };\n                 self.visit_place(base, context, location);\n                 self.visit_projection_elem(elem, location);\n@@ -713,7 +780,11 @@ macro_rules! make_mir_visitor {\n                         self.visit_ty(ty, TyContext::Location(location));\n                     }\n                     ProjectionElem::Index(ref $($mutability)* local) => {\n-                        self.visit_local(local, PlaceContext::Copy, location);\n+                        self.visit_local(\n+                            local,\n+                            PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n+                            location\n+                        );\n                     }\n                     ProjectionElem::ConstantIndex { offset: _,\n                                                     min_length: _,\n@@ -896,125 +967,146 @@ pub enum TyContext {\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum PlaceContext<'tcx> {\n-    // Appears as LHS of an assignment\n-    Store,\n+pub enum NonMutatingUseContext<'tcx> {\n+    /// Being inspected in some way, like loading a len.\n+    Inspect,\n+    /// Consumed as part of an operand.\n+    Copy,\n+    /// Consumed as part of an operand.\n+    Move,\n+    /// Shared borrow.\n+    SharedBorrow(Region<'tcx>),\n+    /// Shallow borrow.\n+    ShallowBorrow(Region<'tcx>),\n+    /// Unique borrow.\n+    UniqueBorrow(Region<'tcx>),\n+    /// Used as base for another place, e.g. `x` in `x.y`. Will not mutate the place.\n+    /// For example, the projection `x.y` is not marked as a mutation in these cases:\n+    ///\n+    ///     z = x.y;\n+    ///     f(&x.y);\n+    ///\n+    Projection,\n+}\n \n-    // Can often be treated as a Store, but needs to be separate because\n-    // ASM is allowed to read outputs as well, so a Store-AsmOutput sequence\n-    // cannot be simplified the way a Store-Store can be.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum MutatingUseContext<'tcx> {\n+    /// Appears as LHS of an assignment.\n+    Store,\n+    /// Can often be treated as a `Store`, but needs to be separate because\n+    /// ASM is allowed to read outputs as well, so a `Store`-`AsmOutput` sequence\n+    /// cannot be simplified the way a `Store`-`Store` can be.\n     AsmOutput,\n-\n-    // Dest of a call\n+    /// Destination of a call.\n     Call,\n-\n-    // Being dropped\n+    /// Being dropped.\n     Drop,\n+    /// Mutable borrow.\n+    Borrow(Region<'tcx>),\n+    /// Used as base for another place, e.g. `x` in `x.y`. Could potentially mutate the place.\n+    /// For example, the projection `x.y` is marked as a mutation in these cases:\n+    ///\n+    ///     x.y = ...;\n+    ///     f(&mut x.y);\n+    ///\n+    Projection,\n+}\n \n-    // Being inspected in some way, like loading a len\n-    Inspect,\n-\n-    // Being borrowed\n-    Borrow { region: Region<'tcx>, kind: BorrowKind },\n-\n-    // Used as base for another place, e.g. `x` in `x.y`.\n-    //\n-    // The `Mutability` argument specifies whether the projection is being performed in order to\n-    // (potentially) mutate the place. For example, the projection `x.y` is marked as a mutation\n-    // in these cases:\n-    //\n-    //     x.y = ...;\n-    //     f(&mut x.y);\n-    //\n-    // But not in these cases:\n-    //\n-    //     z = x.y;\n-    //     f(&x.y);\n-    Projection(Mutability),\n-\n-    // Consumed as part of an operand\n-    Copy,\n-    Move,\n-\n-    // Starting and ending a storage live range\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum NonUseContext {\n+    /// Starting a storage live range.\n     StorageLive,\n+    /// Ending a storage live range.\n     StorageDead,\n-\n-    // Validation command\n+    /// User type annotation assertions for NLL.\n+    AscribeUserTy,\n+    /// Validation command.\n     Validate,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum PlaceContext<'tcx> {\n+    NonMutatingUse(NonMutatingUseContext<'tcx>),\n+    MutatingUse(MutatingUseContext<'tcx>),\n+    NonUse(NonUseContext),\n+}\n+\n impl<'tcx> PlaceContext<'tcx> {\n-    /// Returns true if this place context represents a drop.\n+    /// Returns `true` if this place context represents a drop.\n     pub fn is_drop(&self) -> bool {\n         match *self {\n-            PlaceContext::Drop => true,\n+            PlaceContext::MutatingUse(MutatingUseContext::Drop) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns `true` if this place context represents a borrow.\n+    pub fn is_borrow(&self) -> bool {\n+        match *self {\n+            PlaceContext::NonMutatingUse(NonMutatingUseContext::SharedBorrow(..)) |\n+            PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow(..)) |\n+            PlaceContext::NonMutatingUse(NonMutatingUseContext::UniqueBorrow(..)) |\n+            PlaceContext::MutatingUse(MutatingUseContext::Borrow(..)) => true,\n             _ => false,\n         }\n     }\n \n-    /// Returns true if this place context represents a storage live or storage dead marker.\n+    /// Returns `true` if this place context represents a storage live or storage dead marker.\n     pub fn is_storage_marker(&self) -> bool {\n         match *self {\n-            PlaceContext::StorageLive | PlaceContext::StorageDead => true,\n+            PlaceContext::NonUse(NonUseContext::StorageLive) |\n+            PlaceContext::NonUse(NonUseContext::StorageDead) => true,\n             _ => false,\n         }\n     }\n \n-    /// Returns true if this place context represents a storage live marker.\n+    /// Returns `true` if this place context represents a storage live marker.\n     pub fn is_storage_live_marker(&self) -> bool {\n         match *self {\n-            PlaceContext::StorageLive => true,\n+            PlaceContext::NonUse(NonUseContext::StorageLive) => true,\n             _ => false,\n         }\n     }\n \n-    /// Returns true if this place context represents a storage dead marker.\n+    /// Returns `true` if this place context represents a storage dead marker.\n     pub fn is_storage_dead_marker(&self) -> bool {\n         match *self {\n-            PlaceContext::StorageDead => true,\n+            PlaceContext::NonUse(NonUseContext::StorageDead) => true,\n             _ => false,\n         }\n     }\n \n-    /// Returns true if this place context represents a use that potentially changes the value.\n+    /// Returns `true` if this place context represents a use that potentially changes the value.\n     pub fn is_mutating_use(&self) -> bool {\n         match *self {\n-            PlaceContext::Store | PlaceContext::AsmOutput | PlaceContext::Call |\n-            PlaceContext::Borrow { kind: BorrowKind::Mut { .. }, .. } |\n-            PlaceContext::Projection(Mutability::Mut) |\n-            PlaceContext::Drop => true,\n-\n-            PlaceContext::Inspect |\n-            PlaceContext::Borrow { kind: BorrowKind::Shared, .. } |\n-            PlaceContext::Borrow { kind: BorrowKind::Shallow, .. } |\n-            PlaceContext::Borrow { kind: BorrowKind::Unique, .. } |\n-            PlaceContext::Projection(Mutability::Not) |\n-            PlaceContext::Copy | PlaceContext::Move |\n-            PlaceContext::StorageLive | PlaceContext::StorageDead |\n-            PlaceContext::Validate => false,\n+            PlaceContext::MutatingUse(..) => true,\n+            _ => false,\n         }\n     }\n \n-    /// Returns true if this place context represents a use that does not change the value.\n+    /// Returns `true` if this place context represents a use that does not change the value.\n     pub fn is_nonmutating_use(&self) -> bool {\n         match *self {\n-            PlaceContext::Inspect |\n-            PlaceContext::Borrow { kind: BorrowKind::Shared, .. } |\n-            PlaceContext::Borrow { kind: BorrowKind::Shallow, .. } |\n-            PlaceContext::Borrow { kind: BorrowKind::Unique, .. } |\n-            PlaceContext::Projection(Mutability::Not) |\n-            PlaceContext::Copy | PlaceContext::Move => true,\n-\n-            PlaceContext::Borrow { kind: BorrowKind::Mut { .. }, .. } | PlaceContext::Store |\n-            PlaceContext::AsmOutput |\n-            PlaceContext::Call | PlaceContext::Projection(Mutability::Mut) |\n-            PlaceContext::Drop | PlaceContext::StorageLive | PlaceContext::StorageDead |\n-            PlaceContext::Validate => false,\n+            PlaceContext::NonMutatingUse(..) => true,\n+            _ => false,\n         }\n     }\n \n+    /// Returns `true` if this place context represents a use.\n     pub fn is_use(&self) -> bool {\n-        self.is_mutating_use() || self.is_nonmutating_use()\n+        match *self {\n+            PlaceContext::NonUse(..) => false,\n+            _ => true,\n+        }\n+    }\n+\n+    /// Returns `true` if this place context represents an assignment statement.\n+    pub fn is_place_assignment(&self) -> bool {\n+        match *self {\n+            PlaceContext::MutatingUse(MutatingUseContext::Store) |\n+            PlaceContext::MutatingUse(MutatingUseContext::Call) |\n+            PlaceContext::MutatingUse(MutatingUseContext::AsmOutput) => true,\n+            _ => false,\n+        }\n     }\n }"}, {"sha": "a63cbe70df611a0983ea38bf741a2ad916412387", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=b3b87609713887a27ebd07557af14e4aa57771f3", "patch": "@@ -15,7 +15,7 @@ use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::mir::{self, Location, TerminatorKind};\n-use rustc::mir::visit::{Visitor, PlaceContext};\n+use rustc::mir::visit::{Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::traversal;\n use rustc::ty;\n use rustc::ty::layout::LayoutOf;\n@@ -116,7 +116,11 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n                 self.not_ssa(index);\n             }\n         } else {\n-            self.visit_place(place, PlaceContext::Store, location);\n+            self.visit_place(\n+                place,\n+                PlaceContext::MutatingUse(MutatingUseContext::Store),\n+                location\n+            );\n         }\n \n         self.visit_rvalue(rvalue, location);\n@@ -142,7 +146,11 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n                 // is not guaranteed to be statically dominated by the\n                 // definition of x, so x must always be in an alloca.\n                 if let mir::Operand::Move(ref place) = args[0] {\n-                    self.visit_place(place, PlaceContext::Drop, location);\n+                    self.visit_place(\n+                        place,\n+                        PlaceContext::MutatingUse(MutatingUseContext::Drop),\n+                        location\n+                    );\n                 }\n             }\n         }\n@@ -160,7 +168,8 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n         if let mir::Place::Projection(ref proj) = *place {\n             // Allow uses of projections that are ZSTs or from scalar fields.\n             let is_consume = match context {\n-                PlaceContext::Copy | PlaceContext::Move => true,\n+                PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n+                PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) => true,\n                 _ => false\n             };\n             if is_consume {\n@@ -190,7 +199,11 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n \n             // A deref projection only reads the pointer, never needs the place.\n             if let mir::ProjectionElem::Deref = proj.elem {\n-                return self.visit_place(&proj.base, PlaceContext::Copy, location);\n+                return self.visit_place(\n+                    &proj.base,\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n+                    location\n+                );\n             }\n         }\n \n@@ -202,16 +215,14 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n                    context: PlaceContext<'tcx>,\n                    location: Location) {\n         match context {\n-            PlaceContext::Call => {\n+            PlaceContext::MutatingUse(MutatingUseContext::Call) => {\n                 self.assign(local, location);\n             }\n \n-            PlaceContext::StorageLive |\n-            PlaceContext::StorageDead |\n-            PlaceContext::Validate => {}\n+            PlaceContext::NonUse(_) => {}\n \n-            PlaceContext::Copy |\n-            PlaceContext::Move => {\n+            PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n+            PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) => {\n                 // Reads from uninitialized variables (e.g. in dead code, after\n                 // optimizations) require locals to be in (uninitialized) memory.\n                 // NB: there can be uninitialized reads of a local visited after\n@@ -227,15 +238,19 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n                 }\n             }\n \n-            PlaceContext::Inspect |\n-            PlaceContext::Store |\n-            PlaceContext::AsmOutput |\n-            PlaceContext::Borrow { .. } |\n-            PlaceContext::Projection(..) => {\n+            PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect) |\n+            PlaceContext::MutatingUse(MutatingUseContext::Store) |\n+            PlaceContext::MutatingUse(MutatingUseContext::AsmOutput) |\n+            PlaceContext::MutatingUse(MutatingUseContext::Borrow(..)) |\n+            PlaceContext::MutatingUse(MutatingUseContext::Projection) |\n+            PlaceContext::NonMutatingUse(NonMutatingUseContext::SharedBorrow(..)) |\n+            PlaceContext::NonMutatingUse(NonMutatingUseContext::UniqueBorrow(..)) |\n+            PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow(..)) |\n+            PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection) => {\n                 self.not_ssa(local);\n             }\n \n-            PlaceContext::Drop => {\n+            PlaceContext::MutatingUse(MutatingUseContext::Drop) => {\n                 let ty = mir::Place::Local(local).ty(self.fx.mir, self.fx.cx.tcx);\n                 let ty = self.fx.monomorphize(&ty.to_ty(self.fx.cx.tcx));\n "}, {"sha": "db56ce4627410408318632f98e3ee53ac4ce9279", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=b3b87609713887a27ebd07557af14e4aa57771f3", "patch": "@@ -12,7 +12,9 @@ use borrow_check::place_ext::PlaceExt;\n use dataflow::indexes::BorrowIndex;\n use dataflow::move_paths::MoveData;\n use rustc::mir::traversal;\n-use rustc::mir::visit::{PlaceContext, Visitor};\n+use rustc::mir::visit::{\n+    PlaceContext, Visitor, NonUseContext, MutatingUseContext, NonMutatingUseContext\n+};\n use rustc::mir::{self, Location, Mir, Place, Local};\n use rustc::ty::{Region, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n@@ -116,7 +118,7 @@ impl LocalsStateAtExit {\n \n         impl<'tcx> Visitor<'tcx> for HasStorageDead {\n             fn visit_local(&mut self, local: &Local, ctx: PlaceContext<'tcx>, _: Location) {\n-                if ctx == PlaceContext::StorageDead {\n+                if ctx == PlaceContext::NonUse(NonUseContext::StorageDead) {\n                     self.0.insert(*local);\n                 }\n             }\n@@ -266,7 +268,9 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n \n                 // Watch out: the use of TMP in the borrow itself\n                 // doesn't count as an activation. =)\n-                if borrow_data.reserve_location == location && context == PlaceContext::Store {\n+                if borrow_data.reserve_location == location &&\n+                    context == PlaceContext::MutatingUse(MutatingUseContext::Store)\n+                {\n                     return;\n                 }\n \n@@ -287,10 +291,9 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n                 borrow_data.activation_location = match context {\n                     // The use of TMP in a shared borrow does not\n                     // count as an actual activation.\n-                    PlaceContext::Borrow { kind: mir::BorrowKind::Shared, .. }\n-                    | PlaceContext::Borrow { kind: mir::BorrowKind::Shallow, .. } => {\n-                        TwoPhaseActivation::NotActivated\n-                    }\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::SharedBorrow(..)) |\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow(..)) =>\n+                        TwoPhaseActivation::NotActivated,\n                     _ => {\n                         // Double check: This borrow is indeed a two-phase borrow (that is,\n                         // we are 'transitioning' from `NotActivated` to `ActivatedAt`) and"}, {"sha": "3098acffa23dc0f0138616a2c6f1898880b2f0fe", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=b3b87609713887a27ebd07557af14e4aa57771f3", "patch": "@@ -35,7 +35,7 @@ use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n use rustc::mir::tcx::PlaceTy;\n-use rustc::mir::visit::{PlaceContext, Visitor};\n+use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::*;\n use rustc::traits::query::type_op;\n use rustc::traits::query::type_op::custom::CustomTypeOp;\n@@ -472,9 +472,9 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             }\n             Place::Projection(ref proj) => {\n                 let base_context = if context.is_mutating_use() {\n-                    PlaceContext::Projection(Mutability::Mut)\n+                    PlaceContext::MutatingUse(MutatingUseContext::Projection)\n                 } else {\n-                    PlaceContext::Projection(Mutability::Not)\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n                 };\n                 let base_ty = self.sanitize_place(&proj.base, location, base_context);\n                 if let PlaceTy::Ty { ty } = base_ty {\n@@ -488,7 +488,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 self.sanitize_projection(base_ty, &proj.elem, place, location)\n             }\n         };\n-        if let PlaceContext::Copy = context {\n+        if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n             let tcx = self.tcx();\n             let trait_ref = ty::TraitRef {\n                 def_id: tcx.lang_items().copy_trait().unwrap(),"}, {"sha": "dad87ed65a7d41dce53b003a4265773651b6801c", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=b3b87609713887a27ebd07557af14e4aa57771f3", "patch": "@@ -14,7 +14,6 @@ use rustc::mir::{Local, Location, Place};\n use rustc_data_structures::fx::FxHashSet;\n \n use borrow_check::MirBorrowckCtxt;\n-use util::collect_writes::is_place_assignment;\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Walks the MIR looking for assignments to a set of locals, as part of the unused mutable\n@@ -46,7 +45,7 @@ impl<'visit, 'cx, 'gcx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'c\n             return;\n         }\n \n-        if is_place_assignment(&place_context) {\n+        if place_context.is_place_assignment() {\n             // Propagate the Local assigned at this Location as a used mutable local variable\n             for moi in &self.mbcx.move_data.loc_map[location] {\n                 let mpi = &self.mbcx.move_data.moves[*moi].path;"}, {"sha": "edd15c39fed3e03ab4ab68d0040058cdf3180e2d", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=b3b87609713887a27ebd07557af14e4aa57771f3", "patch": "@@ -19,7 +19,7 @@ use rustc::hir::Node;\n use rustc::hir::def_id::DefId;\n use rustc::lint::builtin::{SAFE_EXTERN_STATICS, SAFE_PACKED_BORROWS, UNUSED_UNSAFE};\n use rustc::mir::*;\n-use rustc::mir::visit::{PlaceContext, Visitor};\n+use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext};\n \n use syntax::ast;\n use syntax::symbol::Symbol;\n@@ -152,7 +152,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     place: &Place<'tcx>,\n                     context: PlaceContext<'tcx>,\n                     location: Location) {\n-        if let PlaceContext::Borrow { .. } = context {\n+        if context.is_borrow() {\n             if util::is_disaligned(self.tcx, self.mir, self.param_env, place) {\n                 let source_info = self.source_info;\n                 let lint_root =\n@@ -193,9 +193,11 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     }\n                     ty::Adt(adt, _) => {\n                         if adt.is_union() {\n-                            if context == PlaceContext::Store ||\n-                                context == PlaceContext::AsmOutput ||\n-                                context == PlaceContext::Drop\n+                            if context == PlaceContext::MutatingUse(MutatingUseContext::Store) ||\n+                                context == PlaceContext::MutatingUse(MutatingUseContext::Drop) ||\n+                                context == PlaceContext::MutatingUse(\n+                                    MutatingUseContext::AsmOutput\n+                                )\n                             {\n                                 let elem_ty = match elem {\n                                     &ProjectionElem::Field(_, ty) => ty,"}, {"sha": "052c6032dec0945f7703499d5220c68cd269b8a6", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=b3b87609713887a27ebd07557af14e4aa57771f3", "patch": "@@ -16,7 +16,7 @@ use rustc::hir::def::Def;\n use rustc::mir::{Constant, Location, Place, Mir, Operand, Rvalue, Local};\n use rustc::mir::{NullOp, UnOp, StatementKind, Statement, BasicBlock, LocalKind};\n use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionElem};\n-use rustc::mir::visit::{Visitor, PlaceContext};\n+use rustc::mir::visit::{Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::interpret::{\n     ConstEvalErr, EvalErrorKind, Scalar, GlobalId, EvalResult,\n };\n@@ -533,17 +533,18 @@ impl<'tcx> Visitor<'tcx> for CanConstProp {\n             // Constants must have at most one write\n             // FIXME(oli-obk): we could be more powerful here, if the multiple writes\n             // only occur in independent execution paths\n-            Store => if self.found_assignment[local] {\n+            MutatingUse(MutatingUseContext::Store) => if self.found_assignment[local] {\n                 self.can_const_prop[local] = false;\n             } else {\n                 self.found_assignment[local] = true\n             },\n             // Reading constants is allowed an arbitrary number of times\n-            Copy | Move |\n-            StorageDead | StorageLive |\n-            Validate |\n-            Projection(_) |\n-            Inspect => {},\n+            NonMutatingUse(NonMutatingUseContext::Copy) |\n+            NonMutatingUse(NonMutatingUseContext::Move) |\n+            NonMutatingUse(NonMutatingUseContext::Inspect) |\n+            NonMutatingUse(NonMutatingUseContext::Projection) |\n+            MutatingUse(MutatingUseContext::Projection) |\n+            NonUse(_) => {},\n             _ => self.can_const_prop[local] = false,\n         }\n     }"}, {"sha": "e79da88a2464bf7d75d0b6815bd52bc4f316065a", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=b3b87609713887a27ebd07557af14e4aa57771f3", "patch": "@@ -23,7 +23,7 @@\n //! move analysis runs after promotion on broken MIR.\n \n use rustc::mir::*;\n-use rustc::mir::visit::{PlaceContext, MutVisitor, Visitor};\n+use rustc::mir::visit::{PlaceContext, MutatingUseContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n use rustc::ty::TyCtxt;\n use syntax_pos::Span;\n@@ -53,6 +53,7 @@ pub enum TempState {\n \n impl TempState {\n     pub fn is_promotable(&self) -> bool {\n+        debug!(\"is_promotable: self={:?}\", self);\n         if let TempState::Defined { uses, .. } = *self {\n             uses > 0\n         } else {\n@@ -88,24 +89,30 @@ impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n                    &index: &Local,\n                    context: PlaceContext<'tcx>,\n                    location: Location) {\n+        debug!(\"visit_local: index={:?} context={:?} location={:?}\", index, context, location);\n         // We're only interested in temporaries\n         if self.mir.local_kind(index) != LocalKind::Temp {\n             return;\n         }\n \n         // Ignore drops, if the temp gets promoted,\n         // then it's constant and thus drop is noop.\n-        // Storage live ranges are also irrelevant.\n-        if context.is_drop() || context.is_storage_marker() {\n+        // Non-uses are also irrelevent.\n+        if context.is_drop() || !context.is_use() {\n+            debug!(\n+                \"visit_local: context.is_drop={:?} context.is_use={:?}\",\n+                context.is_drop(), context.is_use(),\n+            );\n             return;\n         }\n \n         let temp = &mut self.temps[index];\n+        debug!(\"visit_local: temp={:?}\", temp);\n         if *temp == TempState::Undefined {\n             match context {\n-                PlaceContext::Store |\n-                PlaceContext::AsmOutput |\n-                PlaceContext::Call => {\n+                PlaceContext::MutatingUse(MutatingUseContext::Store) |\n+                PlaceContext::MutatingUse(MutatingUseContext::AsmOutput) |\n+                PlaceContext::MutatingUse(MutatingUseContext::Call) => {\n                     *temp = TempState::Defined {\n                         location,\n                         uses: 0\n@@ -117,10 +124,8 @@ impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n         } else if let TempState::Defined { ref mut uses, .. } = *temp {\n             // We always allow borrows, even mutable ones, as we need\n             // to promote mutable borrows of some ZSTs e.g. `&mut []`.\n-            let allowed_use = match context {\n-                PlaceContext::Borrow {..} => true,\n-                _ => context.is_nonmutating_use()\n-            };\n+            let allowed_use = context.is_borrow() || context.is_nonmutating_use();\n+            debug!(\"visit_local: allowed_use={:?}\", allowed_use);\n             if allowed_use {\n                 *uses += 1;\n                 return;"}, {"sha": "a232176eacc8fd8a814a520f422601f2537ba8bd", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=b3b87609713887a27ebd07557af14e4aa57771f3", "patch": "@@ -26,7 +26,7 @@ use rustc::ty::cast::CastTy;\n use rustc::ty::query::Providers;\n use rustc::mir::*;\n use rustc::mir::traversal::ReversePostorder;\n-use rustc::mir::visit::{PlaceContext, Visitor};\n+use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::middle::lang_items;\n use rustc_target::spec::abi::Abi;\n use syntax::ast::LitKind;\n@@ -84,7 +84,7 @@ impl<'a, 'tcx> Qualif {\n }\n \n /// What kind of item we are in.\n-#[derive(Copy, Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum Mode {\n     Const,\n     Static,\n@@ -271,7 +271,11 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             // This must be an explicit assignment.\n             _ => {\n                 // Catch more errors in the destination.\n-                self.visit_place(dest, PlaceContext::Store, location);\n+                self.visit_place(\n+                    dest,\n+                    PlaceContext::MutatingUse(MutatingUseContext::Store),\n+                    location\n+                );\n                 self.statement_like();\n             }\n         }\n@@ -383,6 +387,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n         // Collect all the temps we need to promote.\n         let mut promoted_temps = BitSet::new_empty(self.temp_promotion_state.len());\n \n+        debug!(\"qualify_const: promotion_candidates={:?}\", self.promotion_candidates);\n         for candidate in &self.promotion_candidates {\n             match *candidate {\n                 Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n@@ -414,6 +419,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                    &local: &Local,\n                    _: PlaceContext<'tcx>,\n                    _: Location) {\n+        debug!(\"visit_local: local={:?}\", local);\n         let kind = self.mir.local_kind(local);\n         match kind {\n             LocalKind::ReturnPointer => {\n@@ -435,6 +441,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n \n                 if !self.temp_promotion_state[local].is_promotable() {\n+                    debug!(\"visit_local: (not promotable) local={:?}\", local);\n                     self.add(Qualif::NOT_PROMOTABLE);\n                 }\n \n@@ -451,6 +458,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     place: &Place<'tcx>,\n                     context: PlaceContext<'tcx>,\n                     location: Location) {\n+        debug!(\"visit_place: place={:?} context={:?} location={:?}\", place, context, location);\n         match *place {\n             Place::Local(ref local) => self.visit_local(local, context, location),\n             Place::Promoted(_) => bug!(\"promoting already promoted MIR\"),\n@@ -557,6 +565,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n     }\n \n     fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n+        debug!(\"visit_operand: operand={:?} location={:?}\", operand, location);\n         self.super_operand(operand, location);\n \n         match *operand {\n@@ -591,6 +600,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n     }\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        debug!(\"visit_rvalue: rvalue={:?} location={:?}\", rvalue, location);\n         // Recurse through operands and places.\n         if let Rvalue::Ref(region, kind, ref place) = *rvalue {\n             let mut is_reborrow = false;\n@@ -604,10 +614,17 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             }\n \n             if is_reborrow {\n-                self.super_place(place, PlaceContext::Borrow {\n-                    region,\n-                    kind\n-                }, location);\n+                let ctx = match kind {\n+                    BorrowKind::Shared =>\n+                        PlaceContext::NonMutatingUse(NonMutatingUseContext::SharedBorrow(region)),\n+                    BorrowKind::Shallow =>\n+                        PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow(region)),\n+                    BorrowKind::Unique =>\n+                        PlaceContext::NonMutatingUse(NonMutatingUseContext::UniqueBorrow(region)),\n+                    BorrowKind::Mut { .. } =>\n+                        PlaceContext::MutatingUse(MutatingUseContext::Borrow(region)),\n+                };\n+                self.super_place(place, ctx, location);\n             } else {\n                 self.super_rvalue(rvalue, location);\n             }\n@@ -696,6 +713,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     }\n                 }\n \n+                debug!(\"visit_rvalue: forbidden_mut={:?}\", forbidden_mut);\n                 if forbidden_mut {\n                     self.add(Qualif::NOT_CONST);\n                 } else {\n@@ -709,15 +727,19 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                         }\n                         place = &proj.base;\n                     }\n+                    debug!(\"visit_rvalue: place={:?}\", place);\n                     if let Place::Local(local) = *place {\n                         if self.mir.local_kind(local) == LocalKind::Temp {\n+                            debug!(\"visit_rvalue: local={:?}\", local);\n                             if let Some(qualif) = self.local_qualif[local] {\n                                 // `forbidden_mut` is false, so we can safely ignore\n                                 // `MUTABLE_INTERIOR` from the local's qualifications.\n                                 // This allows borrowing fields which don't have\n                                 // `MUTABLE_INTERIOR`, from a type that does, e.g.:\n                                 // `let _: &'static _ = &(Cell::new(1), 2).1;`\n+                                debug!(\"visit_rvalue: qualif={:?}\", qualif);\n                                 if (qualif - Qualif::MUTABLE_INTERIOR).is_empty() {\n+                                    debug!(\"visit_rvalue: candidate={:?}\", candidate);\n                                     self.promotion_candidates.push(candidate);\n                                 }\n                             }\n@@ -815,6 +837,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                              bb: BasicBlock,\n                              kind: &TerminatorKind<'tcx>,\n                              location: Location) {\n+        debug!(\"visit_terminator_kind: bb={:?} kind={:?} location={:?}\", bb, kind, location);\n         if let TerminatorKind::Call { ref func, ref args, ref destination, .. } = *kind {\n             self.visit_operand(func, location);\n \n@@ -972,6 +995,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     let candidate = Candidate::Argument { bb, index: i };\n                     if is_shuffle && i == 2 {\n                         if this.qualif.is_empty() {\n+                            debug!(\"visit_terminator_kind: candidate={:?}\", candidate);\n                             this.promotion_candidates.push(candidate);\n                         } else {\n                             span_err!(this.tcx.sess, this.span, E0526,\n@@ -998,6 +1022,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     // We can error out with a hard error if the argument is not\n                     // constant here.\n                     if (this.qualif - Qualif::NOT_PROMOTABLE).is_empty() {\n+                        debug!(\"visit_terminator_kind: candidate={:?}\", candidate);\n                         this.promotion_candidates.push(candidate);\n                     } else {\n                         this.tcx.sess.span_err(this.span,\n@@ -1075,6 +1100,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     dest: &Place<'tcx>,\n                     rvalue: &Rvalue<'tcx>,\n                     location: Location) {\n+        debug!(\"visit_assign: dest={:?} rvalue={:?} location={:?}\", dest, rvalue, location);\n         self.visit_rvalue(rvalue, location);\n \n         // Check the allowed const fn argument forms.\n@@ -1123,10 +1149,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n     }\n \n     fn visit_source_info(&mut self, source_info: &SourceInfo) {\n+        debug!(\"visit_source_info: source_info={:?}\", source_info);\n         self.span = source_info.span;\n     }\n \n     fn visit_statement(&mut self, bb: BasicBlock, statement: &Statement<'tcx>, location: Location) {\n+        debug!(\"visit_statement: bb={:?} statement={:?} location={:?}\", bb, statement, location);\n         self.nest(|this| {\n             this.visit_source_info(&statement.source_info);\n             match statement.kind {\n@@ -1150,6 +1178,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                         bb: BasicBlock,\n                         terminator: &Terminator<'tcx>,\n                         location: Location) {\n+        debug!(\"visit_terminator: bb={:?} terminator={:?} location={:?}\", bb, terminator, location);\n         self.nest(|this| this.super_terminator(bb, terminator, location));\n     }\n }\n@@ -1216,6 +1245,7 @@ impl MirPass for QualifyAndPromoteConstants {\n             hir::BodyOwnerKind::Static(hir::MutMutable) => Mode::StaticMut,\n         };\n \n+        debug!(\"run_pass: mode={:?}\", mode);\n         if mode == Mode::Fn || mode == Mode::ConstFn {\n             // This is ugly because Qualifier holds onto mir,\n             // which can't be mutated until its scope ends.\n@@ -1258,6 +1288,7 @@ impl MirPass for QualifyAndPromoteConstants {\n             // In `const` and `static` everything without `StorageDead`\n             // is `'static`, we don't have to create promoted MIR fragments,\n             // just remove `Drop` and `StorageDead` on \"promoted\" locals.\n+            debug!(\"run_pass: promoted_temps={:?}\", promoted_temps);\n             for block in mir.basic_blocks_mut() {\n                 block.statements.retain(|statement| {\n                     match statement.kind {"}, {"sha": "c20d40af50151eba8fc0207eb2bcc84a3ba4873a", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=b3b87609713887a27ebd07557af14e4aa57771f3", "patch": "@@ -331,8 +331,10 @@ struct DeclMarker {\n \n impl<'tcx> Visitor<'tcx> for DeclMarker {\n     fn visit_local(&mut self, local: &Local, ctx: PlaceContext<'tcx>, _: Location) {\n-        // ignore these altogether, they get removed along with their otherwise unused decls.\n-        if ctx != PlaceContext::StorageLive && ctx != PlaceContext::StorageDead {\n+        // Ignore storage markers altogether, they get removed along with their otherwise unused\n+        // decls.\n+        // FIXME: Extend this to all non-uses.\n+        if !ctx.is_storage_marker() {\n             self.locals.insert(*local);\n         }\n     }"}, {"sha": "949b8f74f71e92f8596bee0e2271f2f9bcb8d888", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=b3b87609713887a27ebd07557af14e4aa57771f3", "patch": "@@ -39,7 +39,7 @@\n use rustc::ty;\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n-use rustc::mir::visit::{Visitor, PlaceContext};\n+use rustc::mir::visit::{Visitor, PlaceContext, NonUseContext};\n use transform::{MirPass, MirSource};\n use util::patch::MirPatch;\n use rustc_data_structures::indexed_vec::{IndexVec};\n@@ -316,8 +316,8 @@ impl<'tcx> Visitor<'tcx> for RestoreDataCollector {\n                    location: Location) {\n         let local_use = &mut self.locals_use[*local];\n         match context {\n-            PlaceContext::StorageLive => local_use.alive = Some(location),\n-            PlaceContext::StorageDead => local_use.dead = Some(location),\n+            PlaceContext::NonUse(NonUseContext::StorageLive) => local_use.alive = Some(location),\n+            PlaceContext::NonUse(NonUseContext::StorageDead) => local_use.dead = Some(location),\n             _ => {\n                 local_use.use_count += 1;\n                 if local_use.first_use.is_none() {"}, {"sha": "3e1d0852deedfa997c32a3d8ec23b31632f0c59c", "filename": "src/librustc_mir/util/collect_writes.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Futil%2Fcollect_writes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Futil%2Fcollect_writes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fcollect_writes.rs?ref=b3b87609713887a27ebd07557af14e4aa57771f3", "patch": "@@ -43,24 +43,8 @@ impl<'tcx> Visitor<'tcx> for FindLocalAssignmentVisitor {\n             return;\n         }\n \n-        if is_place_assignment(&place_context) {\n+        if place_context.is_place_assignment() {\n             self.locations.push(location);\n         }\n     }\n }\n-\n-/// Returns true if this place context represents an assignment statement\n-crate fn is_place_assignment(place_context: &PlaceContext) -> bool {\n-    match *place_context {\n-        PlaceContext::Store | PlaceContext::Call | PlaceContext::AsmOutput => true,\n-        PlaceContext::Drop\n-        | PlaceContext::Inspect\n-        | PlaceContext::Borrow { .. }\n-        | PlaceContext::Projection(..)\n-        | PlaceContext::Copy\n-        | PlaceContext::Move\n-        | PlaceContext::StorageLive\n-        | PlaceContext::StorageDead\n-        | PlaceContext::Validate => false,\n-    }\n-}"}, {"sha": "d16094e8238deba487d4b1d67e0d14d8ecb8e8ae", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=b3b87609713887a27ebd07557af14e4aa57771f3", "patch": "@@ -33,7 +33,9 @@\n //! generator yield points, all pre-existing references are invalidated, so this\n //! doesn't matter).\n \n-use rustc::mir::visit::{PlaceContext, Visitor};\n+use rustc::mir::visit::{\n+    PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext, NonUseContext,\n+};\n use rustc::mir::Local;\n use rustc::mir::*;\n use rustc::ty::{item_path, TyCtxt};\n@@ -161,23 +163,23 @@ pub fn categorize<'tcx>(context: PlaceContext<'tcx>) -> Option<DefUse> {\n         ///////////////////////////////////////////////////////////////////////////\n         // DEFS\n \n-        PlaceContext::Store |\n+        PlaceContext::MutatingUse(MutatingUseContext::Store) |\n \n         // This is potentially both a def and a use...\n-        PlaceContext::AsmOutput |\n+        PlaceContext::MutatingUse(MutatingUseContext::AsmOutput) |\n \n         // We let Call define the result in both the success and\n         // unwind cases. This is not really correct, however it\n         // does not seem to be observable due to the way that we\n         // generate MIR. To do things properly, we would apply\n         // the def in call only to the input from the success\n         // path and not the unwind path. -nmatsakis\n-        PlaceContext::Call |\n+        PlaceContext::MutatingUse(MutatingUseContext::Call) |\n \n         // Storage live and storage dead aren't proper defines, but we can ignore\n         // values that come before them.\n-        PlaceContext::StorageLive |\n-        PlaceContext::StorageDead => Some(DefUse::Def),\n+        PlaceContext::NonUse(NonUseContext::StorageLive) |\n+        PlaceContext::NonUse(NonUseContext::StorageDead) => Some(DefUse::Def),\n \n         ///////////////////////////////////////////////////////////////////////////\n         // REGULAR USES\n@@ -186,18 +188,23 @@ pub fn categorize<'tcx>(context: PlaceContext<'tcx>) -> Option<DefUse> {\n         // purposes of NLL, these are special in that **all** the\n         // lifetimes appearing in the variable must be live for each regular use.\n \n-        PlaceContext::Projection(..) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection) |\n+        PlaceContext::MutatingUse(MutatingUseContext::Projection) |\n \n         // Borrows only consider their local used at the point of the borrow.\n         // This won't affect the results since we use this analysis for generators\n         // and we only care about the result at suspension points. Borrows cannot\n         // cross suspension points so this behavior is unproblematic.\n-        PlaceContext::Borrow { .. } |\n-\n-        PlaceContext::Inspect |\n-        PlaceContext::Copy |\n-        PlaceContext::Move |\n-        PlaceContext::Validate =>\n+        PlaceContext::MutatingUse(MutatingUseContext::Borrow(..)) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::SharedBorrow(..)) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow(..)) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::UniqueBorrow(..)) |\n+\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) |\n+        PlaceContext::NonUse(NonUseContext::AscribeUserTy) |\n+        PlaceContext::NonUse(NonUseContext::Validate) =>\n             Some(DefUse::Use),\n \n         ///////////////////////////////////////////////////////////////////////////\n@@ -208,7 +215,7 @@ pub fn categorize<'tcx>(context: PlaceContext<'tcx>) -> Option<DefUse> {\n         // uses in drop are special because `#[may_dangle]`\n         // attributes can affect whether lifetimes must be live.\n \n-        PlaceContext::Drop =>\n+        PlaceContext::MutatingUse(MutatingUseContext::Drop) =>\n             Some(DefUse::Drop),\n     }\n }"}, {"sha": "c0f10ee607cf2fe386dd42fdb9adedff48bdcf36", "filename": "src/test/ui/nll/issue-55288.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Ftest%2Fui%2Fnll%2Fissue-55288.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b87609713887a27ebd07557af14e4aa57771f3/src%2Ftest%2Fui%2Fnll%2Fissue-55288.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-55288.rs?ref=b3b87609713887a27ebd07557af14e4aa57771f3", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+\n+// run-pass\n+\n+struct Slice(&'static [&'static [u8]]);\n+\n+static MAP: Slice = Slice(&[\n+    b\"CloseEvent\" as &'static [u8],\n+]);\n+\n+fn main() {}"}]}