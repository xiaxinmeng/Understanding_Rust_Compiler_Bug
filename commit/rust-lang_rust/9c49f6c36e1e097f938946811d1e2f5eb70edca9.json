{"sha": "9c49f6c36e1e097f938946811d1e2f5eb70edca9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNDlmNmMzNmUxZTA5N2Y5Mzg5NDY4MTFkMWUyZjVlYjcwZWRjYTk=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-04T18:07:09Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-04T18:07:09Z"}, "message": "Merge #1216\n\n1216: Basic Chalk integration r=matklad a=flodiebold\n\nThis replaces the ad-hoc `implements` check by Chalk. It doesn't yet any new functionality (e.g. where clauses aren't passed to Chalk yet). The tests that exist actually work, but it needs some refactoring, currently crashes when running analysis on the RA repo, and depends on rust-lang/chalk#216 which isn't merged yet :smile: \r\n\r\nThe main work here is converting stuff back and forth and providing Chalk with the information it needs, and the canonicalization logic. Since canonicalization depends a lot on the inference table, I don't think we can currently reuse the logic from Chalk, so we need to implement it ourselves; it's not actually that complicated anyway ;) I realized that we need a `Ty::Bound` variant separate from `Ty::Param` -- these are two different things, and I think type parameters inside a function actually need to be represented in Chalk as `Placeholder` types.\r\n\r\n~~Currently this crashes in the 'real' world because we don't yet do canonicalization when filtering method candidates. Proper canonicalization needs the inference table (to collapse different inference variables that have already been unified), but we need to be able to call the method candidate selection from the completion code... So I'm currently thinking how to best handle that :smile:~~\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "544bfd290a08475b1d5250bcc5e0717779b53758", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/544bfd290a08475b1d5250bcc5e0717779b53758"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c49f6c36e1e097f938946811d1e2f5eb70edca9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c49f6c36e1e097f938946811d1e2f5eb70edca9", "html_url": "https://github.com/rust-lang/rust/commit/9c49f6c36e1e097f938946811d1e2f5eb70edca9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c49f6c36e1e097f938946811d1e2f5eb70edca9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "b6ffb1d2a3bcc94e41c95c7a086117e11ce487e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6ffb1d2a3bcc94e41c95c7a086117e11ce487e5", "html_url": "https://github.com/rust-lang/rust/commit/b6ffb1d2a3bcc94e41c95c7a086117e11ce487e5"}, {"sha": "a4eb1a546c7623f65823c5e249cd3c6d8c90fd8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4eb1a546c7623f65823c5e249cd3c6d8c90fd8c", "html_url": "https://github.com/rust-lang/rust/commit/a4eb1a546c7623f65823c5e249cd3c6d8c90fd8c"}], "stats": {"total": 1307, "additions": 1027, "deletions": 280}, "files": [{"sha": "98c349dec41c1d3804935b7d4f8db6a4b7190557", "filename": "Cargo.lock", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/9c49f6c36e1e097f938946811d1e2f5eb70edca9/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9c49f6c36e1e097f938946811d1e2f5eb70edca9/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9c49f6c36e1e097f938946811d1e2f5eb70edca9", "patch": "@@ -143,6 +143,61 @@ name = \"cfg-if\"\n version = \"0.1.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"chalk-engine\"\n+version = \"0.9.0\"\n+source = \"git+https://github.com/rust-lang/chalk.git#17fb07e43b23d721f9c1adba289eac71b25f38ef\"\n+dependencies = [\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git)\",\n+ \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"stacker 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"chalk-ir\"\n+version = \"0.1.0\"\n+source = \"git+https://github.com/rust-lang/chalk.git#17fb07e43b23d721f9c1adba289eac71b25f38ef\"\n+dependencies = [\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git)\",\n+ \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"chalk-macros\"\n+version = \"0.1.1\"\n+source = \"git+https://github.com/rust-lang/chalk.git#17fb07e43b23d721f9c1adba289eac71b25f38ef\"\n+dependencies = [\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"chalk-rust-ir\"\n+version = \"0.1.0\"\n+source = \"git+https://github.com/rust-lang/chalk.git#17fb07e43b23d721f9c1adba289eac71b25f38ef\"\n+dependencies = [\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git)\",\n+]\n+\n+[[package]]\n+name = \"chalk-solve\"\n+version = \"0.1.0\"\n+source = \"git+https://github.com/rust-lang/chalk.git#17fb07e43b23d721f9c1adba289eac71b25f38ef\"\n+dependencies = [\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git)\",\n+ \"derive-new 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ena 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.7.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"petgraph 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"chrono\"\n version = \"0.4.6\"\n@@ -306,6 +361,14 @@ name = \"either\"\n version = \"1.5.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"ena\"\n+version = \"0.10.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"ena\"\n version = \"0.11.0\"\n@@ -362,6 +425,11 @@ dependencies = [\n  \"redox_syscall 0.1.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"fixedbitset\"\n+version = \"0.1.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"flexi_logger\"\n version = \"0.11.4\"\n@@ -540,6 +608,14 @@ dependencies = [\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"itertools\"\n+version = \"0.7.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"either 1.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"itertools\"\n version = \"0.8.0\"\n@@ -595,6 +671,11 @@ dependencies = [\n  \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"lalrpop-intern\"\n+version = \"0.15.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"lazy_static\"\n version = \"1.3.0\"\n@@ -789,6 +870,11 @@ name = \"opaque-debug\"\n version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"ordermap\"\n+version = \"0.3.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"owning_ref\"\n version = \"0.4.0\"\n@@ -862,6 +948,15 @@ dependencies = [\n  \"sha-1 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"petgraph\"\n+version = \"0.4.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"fixedbitset 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ordermap 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"proc-macro2\"\n version = \"0.4.28\"\n@@ -979,6 +1074,9 @@ name = \"ra_hir\"\n version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git)\",\n+ \"chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git)\",\n  \"ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flexi_logger 0.11.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"insta 0.7.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1498,6 +1596,17 @@ name = \"stable_deref_trait\"\n version = \"1.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"stacker\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"strsim\"\n version = \"0.8.0\"\n@@ -1888,6 +1997,11 @@ dependencies = [\n \"checksum cargo_metadata 0.7.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"178d62b240c34223f265a4c1e275e37d62da163d421fc8d7f7e3ee340f803c57\"\n \"checksum cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5e5f3fee5eeb60324c2781f1e41286bdee933850fff9b3c672587fed5ec58c83\"\n \"checksum cfg-if 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"11d43355396e872eefb45ce6342e4374ed7bc2b3a502d1b28e36d6e23c05d1f4\"\n+\"checksum chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git)\" = \"<none>\"\n+\"checksum chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git)\" = \"<none>\"\n+\"checksum chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git)\" = \"<none>\"\n+\"checksum chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git)\" = \"<none>\"\n+\"checksum chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git)\" = \"<none>\"\n \"checksum chrono 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"45912881121cb26fad7c38c17ba7daa18764771836b34fab7d3fbd93ed633878\"\n \"checksum ci_info 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e5e881307a989a3a5e20d52a32cc05950e3c2178cccfcc9428271a6cde09f902\"\n \"checksum clap 2.33.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5067f5bb2d80ef5d68b4c87db81601f0b75bca627bc2ef76b141d7b846a3c6d9\"\n@@ -1907,13 +2021,15 @@ dependencies = [\n \"checksum drop_bomb 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"69b26e475fd29098530e709294e94e661974c851aed42512793f120fed4e199f\"\n \"checksum dtoa 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6d301140eb411af13d3115f9a562c85cc6b541ade9dfa314132244aaee7489dd\"\n \"checksum either 1.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5527cfe0d098f36e3f8839852688e63c8fff1c90b2b405aef730615f9a7bcf7b\"\n+\"checksum ena 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"25b4e5febb25f08c49f1b07dc33a182729a6b21edfb562b5aef95f78e0dbe5bb\"\n \"checksum ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f56c93cc076508c549d9bb747f79aa9b4eb098be7b8cad8830c3137ef52d1e00\"\n \"checksum encode_unicode 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"90b2c9496c001e8cb61827acdefad780795c42264c137744cae6f7d9e3450abd\"\n \"checksum error-chain 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07e791d3be96241c77c43846b665ef1384606da2cd2a48730abe606a12906e02\"\n \"checksum failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"795bd83d3abeb9220f257e597aa0080a508b27533824adf336529648f6abf7e2\"\n \"checksum failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ea1063915fd7ef4309e222a5a07cf9c319fb9c7836b1f89b85458672dbb127e1\"\n \"checksum fake-simd 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed\"\n \"checksum filetime 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f8c63033fcba1f51ef744505b3cad42510432b904c062afa67ad7ece008429d\"\n+\"checksum fixedbitset 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"86d4de0081402f5e88cdac65c8dcdcc73118c1a7a465e2a05f0da05843a8ea33\"\n \"checksum flexi_logger 0.11.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"73de04baa435682b03677bb28f7b3e9d72b0489a551da5ba413c9b29f7979a19\"\n \"checksum fs_extra 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5f2a4a2034423744d2cc7ca2068453168dcdb82c438419e639a26bd87839c674\"\n \"checksum fsevent 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c4bbbf71584aeed076100b5665ac14e3d85eeb31fdbb45fbd41ef9a682b5ec05\"\n@@ -1934,13 +2050,15 @@ dependencies = [\n \"checksum inotify-sys 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e74a1aa87c59aeff6ef2cc2fa62d41bc43f54952f55652656b18a02fd5e356c0\"\n \"checksum insta 0.7.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"03e7d88a87d342ce8bd698516151be43e6eb2e84b683db528696cb4a382f734a\"\n \"checksum iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dbe6e417e7d0975db6512b90796e8ce223145ac4e33c377e4a42882a0e88bb08\"\n+\"checksum itertools 0.7.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0d47946d458e94a1b7bcabbf6521ea7c037062c81f534615abcad76e84d4970d\"\n \"checksum itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5b8467d9c1cebe26feb08c640139247fac215782d35371ade9a2136ed6085358\"\n \"checksum itoa 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1306f3464951f30e30d12373d31c79fbd52d236e5e896fd92f96ec7babbbe60b\"\n \"checksum jemalloc-ctl 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4e93b0f37e7d735c6b610176d5b1bde8e1621ff3f6f7ac23cdfa4e7f7d0111b5\"\n \"checksum jemalloc-sys 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bfc62c8e50e381768ce8ee0428ee53741929f7ebd73e4d83f669bcf7693e00ae\"\n \"checksum jemallocator 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9f0cd42ac65f758063fea55126b0148b1ce0a6354ff78e07a4d6806bc65c4ab3\"\n \"checksum join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4dc7a5290e8c2606ce2be49f456d50f69173cb96d1541e4f66e34ac8b331a98f\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n+\"checksum lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cc4fd87be4a815fd373e02773983940f0d75fb26fde8c098e9e45f7af03154c0\"\n \"checksum lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bc5729f27f159ddd61f4df6228e827e86643d4d3e7c32183cb30a1c08f604a14\"\n \"checksum lazycell 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \"checksum libc 0.2.51 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bedcc7a809076656486ffe045abeeac163da1b558e963a31e29fbfbeba916917\"\n@@ -1965,6 +2083,7 @@ dependencies = [\n \"checksum number_prefix 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dbf9993e59c894e3c08aa1c2712914e9e6bf1fcbfc6bef283e2183df345a4fee\"\n \"checksum numtoa 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b8f8bdf33df195859076e54ab11ee78a1b208382d3a26ec40d142ffc1ecc49ef\"\n \"checksum opaque-debug 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"93f5bb2e8e8dec81642920ccff6b61f1eb94fa3020c5a325c9851ff604152409\"\n+\"checksum ordermap 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a86ed3f5f244b372d6b1a00b72ef7f8876d0bc6a78a4c9985c53614041512063\"\n \"checksum owning_ref 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49a4b8ea2179e6a2e27411d3bca09ca6dd630821cf6894c6c7c8467a8ee7ef13\"\n \"checksum parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab41b4aed082705d1056416ae4468b6ea99d52599ecf3169b00088d43113e337\"\n \"checksum parking_lot_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"94c8c7923936b28d546dfd14d4472eaf34c99b14e1c973a32b3e6d4eb04298c9\"\n@@ -1973,6 +2092,7 @@ dependencies = [\n \"checksum pest_derive 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"833d1ae558dc601e9a60366421196a8d94bc0ac980476d0b67e1d0988d72b2d0\"\n \"checksum pest_generator 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"63120576c4efd69615b5537d3d052257328a4ca82876771d6944424ccfd9f646\"\n \"checksum pest_meta 2.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f249ea6de7c7b7aba92b4ff4376a994c6dbd98fd2166c89d5c4947397ecb574d\"\n+\"checksum petgraph 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9c3659d1ee90221741f65dd128d9998311b0e40c5d3c23a62445938214abce4f\"\n \"checksum proc-macro2 0.4.28 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ba92c84f814b3f9a44c5cfca7d2ad77fa10710867d2bbb1b3d175ab5f47daa12\"\n \"checksum proptest 0.9.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"24f5844db2f839e97e3021980975f6ebf8691d9b9b2ca67ed3feb38dc3edb52c\"\n \"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n@@ -2019,6 +2139,7 @@ dependencies = [\n \"checksum smallvec 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c4488ae950c49d403731982257768f48fada354a5203fe81f9bb6f43ca9002be\"\n \"checksum smol_str 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d077b3367211e9c6e2e012fb804c444e0d80ab5a51ae4137739b58e6446dcaef\"\n \"checksum stable_deref_trait 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dba1a27d3efae4351c8051072d619e3ade2820635c3958d826bfea39d59b54c8\"\n+\"checksum stacker 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fb79482f57cf598af52094ec4cc3b3c42499d3ce5bd426f2ac41515b7e57404b\"\n \"checksum strsim 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8ea5119cdb4c55b55d432abb513a0429384878c15dde60cc77b1c99de1a95a6a\"\n \"checksum superslice 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab16ced94dbd8a46c82fd81e3ed9a8727dac2977ea869d217bcc4ea1f122e81f\"\n \"checksum syn 0.15.32 (registry+https://github.com/rust-lang/crates.io-index)\" = \"846620ec526c1599c070eff393bfeeeb88a93afa2513fc3b49f1fea84cf7b0ed\""}, {"sha": "68ffcb2e975542a0bc73738b790305fa98a71c0e", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=9c49f6c36e1e097f938946811d1e2f5eb70edca9", "patch": "@@ -19,7 +19,11 @@ ra_db = { path = \"../ra_db\" }\n mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n test_utils = { path = \"../test_utils\" }\n-ra_prof = {path = \"../ra_prof\" }\n+ra_prof = { path = \"../ra_prof\" }\n+\n+chalk-solve = { git = \"https://github.com/rust-lang/chalk.git\" }\n+chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\" }\n+chalk-ir = { git = \"https://github.com/rust-lang/chalk.git\" }\n \n [dev-dependencies]\n flexi_logger = \"0.11.0\""}, {"sha": "9dcae50a5507391ef34f3299694011f16a393414", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=9c49f6c36e1e097f938946811d1e2f5eb70edca9", "patch": "@@ -9,7 +9,7 @@ use crate::{\n     type_ref::TypeRef,\n     nameres::{ModuleScope, Namespace, ImportId, CrateModuleId},\n     expr::{Body, BodySourceMap},\n-    ty::InferenceResult,\n+    ty::{ TraitRef, InferenceResult},\n     adt::{EnumVariantId, StructFieldId, VariantDef},\n     generics::HasGenericParams,\n     docs::{Documentation, Docs, docs_from_ast},\n@@ -696,6 +696,10 @@ impl Trait {\n         db.trait_data(self)\n     }\n \n+    pub fn trait_ref(self, db: &impl HirDatabase) -> TraitRef {\n+        TraitRef::for_trait(db, self)\n+    }\n+\n     pub(crate) fn resolver(&self, db: &impl DefDatabase) -> Resolver {\n         let r = self.module(db).resolver(db);\n         // add generic params, if present"}, {"sha": "8aaf0375a15e62b8ba41a7099c2c9b3b9952ae16", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=9c49f6c36e1e097f938946811d1e2f5eb70edca9", "patch": "@@ -1,4 +1,4 @@\n-use std::sync::Arc;\n+use std::sync::{Arc, Mutex};\n \n use ra_syntax::{SyntaxNode, TreeArc, SourceFile, SmolStr, ast};\n use ra_db::{SourceDatabase, salsa};\n@@ -8,16 +8,16 @@ use crate::{\n     Function, FnSignature, ExprScopes, TypeAlias,\n     Struct, Enum, StructField,\n     Const, ConstSignature, Static,\n-    DefWithBody,\n+    DefWithBody, Trait,\n+    ids,\n     nameres::{Namespace, ImportSourceMap, RawItems, CrateDefMap},\n-    ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef, CallableDef, FnSig},\n+    ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef, CallableDef, FnSig, TypeCtor},\n     adt::{StructData, EnumData},\n-    impl_block::{ModuleImplBlocks, ImplSourceMap},\n+    impl_block::{ModuleImplBlocks, ImplSourceMap, ImplBlock},\n     generics::{GenericParams, GenericDef},\n     type_ref::TypeRef,\n-    traits::TraitData, Trait, ty::TraitRef,\n+    traits::TraitData,\n     lang_item::{LangItems, LangItemTarget},\n-    ids\n };\n \n #[salsa::query_group(DefDatabaseStorage)]\n@@ -39,6 +39,12 @@ pub trait DefDatabase: SourceDatabase {\n     #[salsa::interned]\n     fn intern_type_alias(&self, loc: ids::ItemLoc<ast::TypeAliasDef>) -> ids::TypeAliasId;\n \n+    // Interned IDs for Chalk integration\n+    #[salsa::interned]\n+    fn intern_type_ctor(&self, type_ctor: TypeCtor) -> ids::TypeCtorId;\n+    #[salsa::interned]\n+    fn intern_impl_block(&self, impl_block: ImplBlock) -> ids::GlobalImplId;\n+\n     #[salsa::invoke(crate::ids::macro_def_query)]\n     fn macro_def(&self, macro_id: MacroDefId) -> Option<Arc<mbe::MacroRules>>;\n \n@@ -144,8 +150,17 @@ pub trait HirDatabase: DefDatabase {\n     #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]\n     fn impls_in_crate(&self, krate: Crate) -> Arc<CrateImplBlocks>;\n \n-    #[salsa::invoke(crate::ty::traits::implements)]\n-    fn implements(&self, trait_ref: TraitRef) -> Option<crate::ty::traits::Solution>;\n+    #[salsa::invoke(crate::ty::traits::impls_for_trait)]\n+    fn impls_for_trait(&self, krate: Crate, trait_: Trait) -> Arc<[ImplBlock]>;\n+\n+    /// This provides the Chalk trait solver instance. Because Chalk always\n+    /// works from a specific crate, this query is keyed on the crate; and\n+    /// because Chalk does its own internal caching, the solver is wrapped in a\n+    /// Mutex and the query is marked volatile, to make sure the cached state is\n+    /// thrown away when input facts change.\n+    #[salsa::invoke(crate::ty::traits::solver)]\n+    #[salsa::volatile]\n+    fn solver(&self, krate: Crate) -> Arc<Mutex<crate::ty::traits::Solver>>;\n }\n \n #[test]"}, {"sha": "2e52c587111110690930ba0189af93b96954bfea", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=9c49f6c36e1e097f938946811d1e2f5eb70edca9", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::ast::{self, NameOwner, TypeParamsOwner, TypeBoundsOwner};\n \n use crate::{\n     db::DefDatabase,\n-    Name, AsName, Function, Struct, Enum, Trait, TypeAlias, ImplBlock, Container, path::Path, type_ref::TypeRef\n+    Name, AsName, Function, Struct, Enum, Trait, TypeAlias, ImplBlock, Container, path::Path, type_ref::TypeRef, AdtDef\n };\n \n /// Data about a generic parameter (to a function, struct, impl, ...).\n@@ -157,6 +157,15 @@ impl From<Container> for GenericDef {\n     }\n }\n \n+impl From<crate::adt::AdtDef> for GenericDef {\n+    fn from(adt: crate::adt::AdtDef) -> Self {\n+        match adt {\n+            AdtDef::Struct(s) => s.into(),\n+            AdtDef::Enum(e) => e.into(),\n+        }\n+    }\n+}\n+\n pub trait HasGenericParams {\n     fn generic_params(self, db: &impl DefDatabase) -> Arc<GenericParams>;\n }"}, {"sha": "ff4a81e59bf4ae70ac000b4cbf6a8ccd3a7b7beb", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=9c49f6c36e1e097f938946811d1e2f5eb70edca9", "patch": "@@ -354,3 +354,15 @@ impl MacroCallId {\n         )\n     }\n }\n+\n+/// This exists just for Chalk, because Chalk just has a single `StructId` where\n+/// we have different kinds of ADTs, primitive types and special type\n+/// constructors like tuples and function pointers.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct TypeCtorId(salsa::InternId);\n+impl_intern_key!(TypeCtorId);\n+\n+/// This exists just for Chalk, because our ImplIds are only unique per module.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct GlobalImplId(salsa::InternId);\n+impl_intern_key!(GlobalImplId);"}, {"sha": "707556ef8428981c58f0df2a3d1de0ffaea8b2d4", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=9c49f6c36e1e097f938946811d1e2f5eb70edca9", "patch": "@@ -6,7 +6,7 @@ use ra_syntax::ast;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    ModuleDef,\n+    ModuleDef, Trait,\n     code_model_api::Crate,\n     MacroCallId,\n     MacroCallLoc,\n@@ -18,7 +18,6 @@ use crate::{\n     expr::{scope::{ExprScopes, ScopeId}, PatId},\n     impl_block::ImplBlock,\n     path::Path,\n-    Trait,\n };\n \n #[derive(Debug, Clone, Default)]"}, {"sha": "2ec1a769284595638a666b01b8116bf08ae608bb", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=9c49f6c36e1e097f938946811d1e2f5eb70edca9", "patch": "@@ -350,7 +350,16 @@ impl SourceAnalyzer {\n         name: Option<&Name>,\n         callback: impl FnMut(&Ty, Function) -> Option<T>,\n     ) -> Option<T> {\n-        ty.iterate_method_candidates(db, &self.resolver, name, callback)\n+        // There should be no inference vars in types passed here\n+        // FIXME check that?\n+        let canonical = crate::ty::Canonical { value: ty, num_vars: 0 };\n+        crate::ty::method_resolution::iterate_method_candidates(\n+            &canonical,\n+            db,\n+            &self.resolver,\n+            name,\n+            callback,\n+        )\n     }\n \n     #[cfg(test)]"}, {"sha": "f4eee835f27b815ded1cd7c6c3672f03edd60956", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 84, "deletions": 28, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=9c49f6c36e1e097f938946811d1e2f5eb70edca9", "patch": "@@ -13,9 +13,10 @@ mod infer;\n pub(crate) mod display;\n \n use std::sync::Arc;\n+use std::ops::Deref;\n use std::{fmt, mem};\n \n-use crate::{Name, AdtDef, type_ref::Mutability, db::HirDatabase, Trait};\n+use crate::{Name, AdtDef, type_ref::Mutability, db::HirDatabase, Trait, GenericParams};\n use display::{HirDisplay, HirFormatter};\n \n pub(crate) use lower::{TypableDef, type_for_def, type_for_field, callable_item_sig};\n@@ -81,13 +82,13 @@ pub enum TypeCtor {\n     /// fn foo() -> i32 { 1 }\n     /// let bar: fn() -> i32 = foo;\n     /// ```\n-    FnPtr,\n+    FnPtr { num_args: u16 },\n \n     /// The never type `!`.\n     Never,\n \n     /// A tuple type.  For example, `(i32, bool)`.\n-    Tuple,\n+    Tuple { cardinality: u16 },\n }\n \n /// A nominal type with (maybe 0) type parameters. This might be a primitive\n@@ -118,9 +119,14 @@ pub enum Ty {\n         /// surrounding impl, then the current function).\n         idx: u32,\n         /// The name of the parameter, for displaying.\n+        // FIXME get rid of this\n         name: Name,\n     },\n \n+    /// A bound type variable. Only used during trait resolution to represent\n+    /// Chalk variables.\n+    Bound(u32),\n+\n     /// A type variable used during type checking. Not to be confused with a\n     /// type parameter.\n     Infer(InferTy),\n@@ -150,14 +156,6 @@ impl Substs {\n         Substs(self.0.iter().cloned().take(n).collect::<Vec<_>>().into())\n     }\n \n-    pub fn iter(&self) -> impl Iterator<Item = &Ty> {\n-        self.0.iter()\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        self.0.len()\n-    }\n-\n     pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         // Without an Arc::make_mut_slice, we can't avoid the clone here:\n         let mut v: Vec<_> = self.0.iter().cloned().collect();\n@@ -173,6 +171,30 @@ impl Substs {\n         }\n         &self.0[0]\n     }\n+\n+    /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n+    pub fn identity(generic_params: &GenericParams) -> Substs {\n+        Substs(\n+            generic_params\n+                .params_including_parent()\n+                .into_iter()\n+                .map(|p| Ty::Param { idx: p.idx, name: p.name.clone() })\n+                .collect::<Vec<_>>()\n+                .into(),\n+        )\n+    }\n+\n+    /// Return Substs that replace each parameter by a bound variable.\n+    pub fn bound_vars(generic_params: &GenericParams) -> Substs {\n+        Substs(\n+            generic_params\n+                .params_including_parent()\n+                .into_iter()\n+                .map(|p| Ty::Bound(p.idx))\n+                .collect::<Vec<_>>()\n+                .into(),\n+        )\n+    }\n }\n \n impl From<Vec<Ty>> for Substs {\n@@ -181,6 +203,14 @@ impl From<Vec<Ty>> for Substs {\n     }\n }\n \n+impl Deref for Substs {\n+    type Target = [Ty];\n+\n+    fn deref(&self) -> &[Ty] {\n+        &self.0\n+    }\n+}\n+\n /// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n /// Name to be bikeshedded: TraitBound? TraitImplements?\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n@@ -192,10 +222,29 @@ pub struct TraitRef {\n \n impl TraitRef {\n     pub fn self_ty(&self) -> &Ty {\n-        &self.substs.0[0]\n+        &self.substs[0]\n+    }\n+\n+    pub fn subst(mut self, substs: &Substs) -> TraitRef {\n+        self.substs.walk_mut(&mut |ty_mut| {\n+            let ty = mem::replace(ty_mut, Ty::Unknown);\n+            *ty_mut = ty.subst(substs);\n+        });\n+        self\n     }\n }\n \n+/// Basically a claim (currently not validated / checked) that the contained\n+/// type / trait ref contains no inference variables; any inference variables it\n+/// contained have been replaced by bound variables, and `num_vars` tells us how\n+/// many there are. This is used to erase irrelevant differences between types\n+/// before using them in queries.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub(crate) struct Canonical<T> {\n+    pub value: T,\n+    pub num_vars: usize,\n+}\n+\n /// A function signature as seen by type inference: Several parameter types and\n /// one return type.\n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -250,7 +299,7 @@ impl Ty {\n         Ty::Apply(ApplicationTy { ctor, parameters })\n     }\n     pub fn unit() -> Self {\n-        Ty::apply(TypeCtor::Tuple, Substs::empty())\n+        Ty::apply(TypeCtor::Tuple { cardinality: 0 }, Substs::empty())\n     }\n \n     pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n@@ -260,7 +309,7 @@ impl Ty {\n                     t.walk(f);\n                 }\n             }\n-            Ty::Param { .. } | Ty::Infer(_) | Ty::Unknown => {}\n+            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n         f(self);\n     }\n@@ -270,7 +319,7 @@ impl Ty {\n             Ty::Apply(a_ty) => {\n                 a_ty.parameters.walk_mut(f);\n             }\n-            Ty::Param { .. } | Ty::Infer(_) | Ty::Unknown => {}\n+            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n         f(self);\n     }\n@@ -303,7 +352,9 @@ impl Ty {\n \n     pub fn as_tuple(&self) -> Option<&Substs> {\n         match self {\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::Tuple, parameters }) => Some(parameters),\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Tuple { .. }, parameters }) => {\n+                Some(parameters)\n+            }\n             _ => None,\n         }\n     }\n@@ -331,7 +382,7 @@ impl Ty {\n     fn callable_sig(&self, db: &impl HirDatabase) -> Option<FnSig> {\n         match self {\n             Ty::Apply(a_ty) => match a_ty.ctor {\n-                TypeCtor::FnPtr => Some(FnSig::from_fn_ptr_substs(&a_ty.parameters)),\n+                TypeCtor::FnPtr { .. } => Some(FnSig::from_fn_ptr_substs(&a_ty.parameters)),\n                 TypeCtor::FnDef(def) => {\n                     let sig = db.callable_item_signature(def);\n                     Some(sig.subst(&a_ty.parameters))\n@@ -362,16 +413,20 @@ impl Ty {\n     pub fn subst(self, substs: &Substs) -> Ty {\n         self.fold(&mut |ty| match ty {\n             Ty::Param { idx, name } => {\n-                if (idx as usize) < substs.0.len() {\n-                    substs.0[idx as usize].clone()\n-                } else {\n-                    Ty::Param { idx, name }\n-                }\n+                substs.get(idx as usize).cloned().unwrap_or(Ty::Param { idx, name })\n             }\n             ty => ty,\n         })\n     }\n \n+    /// Substitutes `Ty::Bound` vars (as opposed to type parameters).\n+    pub fn subst_bound_vars(self, substs: &Substs) -> Ty {\n+        self.fold(&mut |ty| match ty {\n+            Ty::Bound(idx) => substs.get(idx as usize).cloned().unwrap_or(Ty::Bound(idx)),\n+            ty => ty,\n+        })\n+    }\n+\n     /// Returns the type parameters of this type if it has some (i.e. is an ADT\n     /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n     fn substs(&self) -> Option<Substs> {\n@@ -413,17 +468,17 @@ impl HirDisplay for ApplicationTy {\n                 write!(f, \"&{}{}\", m.as_keyword_for_ref(), t.display(f.db))?;\n             }\n             TypeCtor::Never => write!(f, \"!\")?,\n-            TypeCtor::Tuple => {\n+            TypeCtor::Tuple { .. } => {\n                 let ts = &self.parameters;\n-                if ts.0.len() == 1 {\n-                    write!(f, \"({},)\", ts.0[0].display(f.db))?;\n+                if ts.len() == 1 {\n+                    write!(f, \"({},)\", ts[0].display(f.db))?;\n                 } else {\n                     write!(f, \"(\")?;\n                     f.write_joined(&*ts.0, \", \")?;\n                     write!(f, \")\")?;\n                 }\n             }\n-            TypeCtor::FnPtr => {\n+            TypeCtor::FnPtr { .. } => {\n                 let sig = FnSig::from_fn_ptr_substs(&self.parameters);\n                 write!(f, \"fn(\")?;\n                 f.write_joined(sig.params(), \", \")?;\n@@ -440,7 +495,7 @@ impl HirDisplay for ApplicationTy {\n                     CallableDef::Function(_) => write!(f, \"fn {}\", name)?,\n                     CallableDef::Struct(_) | CallableDef::EnumVariant(_) => write!(f, \"{}\", name)?,\n                 }\n-                if self.parameters.0.len() > 0 {\n+                if self.parameters.len() > 0 {\n                     write!(f, \"<\")?;\n                     f.write_joined(&*self.parameters.0, \", \")?;\n                     write!(f, \">\")?;\n@@ -456,7 +511,7 @@ impl HirDisplay for ApplicationTy {\n                 }\n                 .unwrap_or_else(Name::missing);\n                 write!(f, \"{}\", name)?;\n-                if self.parameters.0.len() > 0 {\n+                if self.parameters.len() > 0 {\n                     write!(f, \"<\")?;\n                     f.write_joined(&*self.parameters.0, \", \")?;\n                     write!(f, \">\")?;\n@@ -472,6 +527,7 @@ impl HirDisplay for Ty {\n         match self {\n             Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n             Ty::Param { name, .. } => write!(f, \"{}\", name)?,\n+            Ty::Bound(idx) => write!(f, \"?{}\", idx)?,\n             Ty::Unknown => write!(f, \"{{unknown}}\")?,\n             Ty::Infer(..) => write!(f, \"_\")?,\n         }"}, {"sha": "edce1afe7f00951dbecc7344bfc5c53e00a768c8", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=9c49f6c36e1e097f938946811d1e2f5eb70edca9", "patch": "@@ -44,9 +44,12 @@ use crate::{\n };\n use super::{\n     Ty, TypableDef, Substs, primitive, op, ApplicationTy, TypeCtor, CallableDef, TraitRef,\n-    traits::{ Solution, Obligation, Guidance},\n+    traits::{Solution, Obligation, Guidance},\n+    method_resolution,\n };\n \n+mod unify;\n+\n /// The entry point of type inference.\n pub fn infer(db: &impl HirDatabase, def: DefWithBody) -> Arc<InferenceResult> {\n     db.check_canceled();\n@@ -321,30 +324,29 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn resolve_obligations_as_possible(&mut self) {\n         let obligations = mem::replace(&mut self.obligations, Vec::new());\n         for obligation in obligations {\n-            // FIXME resolve types in the obligation first\n-            let (solution, var_mapping) = match &obligation {\n+            let (solution, canonicalized) = match &obligation {\n                 Obligation::Trait(tr) => {\n-                    let (tr, var_mapping) = super::traits::canonicalize(tr.clone());\n-                    (self.db.implements(tr), var_mapping)\n+                    let canonicalized = self.canonicalizer().canonicalize_trait_ref(tr.clone());\n+                    (\n+                        super::traits::implements(\n+                            self.db,\n+                            self.resolver.krate().unwrap(),\n+                            canonicalized.value.clone(),\n+                        ),\n+                        canonicalized,\n+                    )\n                 }\n             };\n             match solution {\n                 Some(Solution::Unique(substs)) => {\n-                    for (i, subst) in substs.0.iter().enumerate() {\n-                        let uncanonical = var_mapping[i];\n-                        // FIXME the subst may contain type variables, which would need to be mapped back as well\n-                        self.unify(&Ty::Infer(InferTy::TypeVar(uncanonical)), subst);\n-                    }\n+                    canonicalized.apply_solution(self, substs.0);\n                 }\n                 Some(Solution::Ambig(Guidance::Definite(substs))) => {\n-                    for (i, subst) in substs.0.iter().enumerate() {\n-                        let uncanonical = var_mapping[i];\n-                        // FIXME the subst may contain type variables, which would need to be mapped back as well\n-                        self.unify(&Ty::Infer(InferTy::TypeVar(uncanonical)), subst);\n-                    }\n+                    canonicalized.apply_solution(self, substs.0);\n                     self.obligations.push(obligation);\n                 }\n                 Some(_) => {\n+                    // FIXME use this when trying to resolve everything at the end\n                     self.obligations.push(obligation);\n                 }\n                 None => {\n@@ -737,14 +739,14 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 };\n                 let expectations_iter = expectations.iter().chain(repeat(&Ty::Unknown));\n \n-                let inner_tys = args\n+                let inner_tys: Substs = args\n                     .iter()\n                     .zip(expectations_iter)\n                     .map(|(&pat, ty)| self.infer_pat(pat, ty, default_bm))\n                     .collect::<Vec<_>>()\n                     .into();\n \n-                Ty::apply(TypeCtor::Tuple, Substs(inner_tys))\n+                Ty::apply(TypeCtor::Tuple { cardinality: inner_tys.len() as u16 }, inner_tys)\n             }\n             Pat::Ref { pat, mutability } => {\n                 let expectation = match expected.as_reference() {\n@@ -877,9 +879,16 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         generic_args: Option<&GenericArgs>,\n     ) -> Ty {\n         let receiver_ty = self.infer_expr(receiver, &Expectation::none());\n-        let resolved = receiver_ty.clone().lookup_method(self.db, method_name, &self.resolver);\n+        let canonicalized_receiver = self.canonicalizer().canonicalize_ty(receiver_ty.clone());\n+        let resolved = method_resolution::lookup_method(\n+            &canonicalized_receiver.value,\n+            self.db,\n+            method_name,\n+            &self.resolver,\n+        );\n         let (derefed_receiver_ty, method_ty, def_generics) = match resolved {\n             Some((ty, func)) => {\n+                let ty = canonicalized_receiver.decanonicalize_ty(ty);\n                 self.write_method_resolution(tgt_expr, func);\n                 (\n                     ty,\n@@ -1064,7 +1073,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     .autoderef(self.db)\n                     .find_map(|derefed_ty| match derefed_ty {\n                         Ty::Apply(a_ty) => match a_ty.ctor {\n-                            TypeCtor::Tuple => {\n+                            TypeCtor::Tuple { .. } => {\n                                 let i = name.to_string().parse::<usize>().ok();\n                                 i.and_then(|i| a_ty.parameters.0.get(i).cloned())\n                             }\n@@ -1175,7 +1184,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     ty_vec.push(self.infer_expr(*arg, &Expectation::none()));\n                 }\n \n-                Ty::apply(TypeCtor::Tuple, Substs(ty_vec.into()))\n+                Ty::apply(\n+                    TypeCtor::Tuple { cardinality: ty_vec.len() as u16 },\n+                    Substs(ty_vec.into()),\n+                )\n             }\n             Expr::Array(array) => {\n                 let elem_ty = match &expected.ty {"}, {"sha": "8ca7e957d336be46e4f3323b467329107f9c783b", "filename": "crates/ra_hir/src/ty/infer/unify.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs?ref=9c49f6c36e1e097f938946811d1e2f5eb70edca9", "patch": "@@ -0,0 +1,122 @@\n+//! Unification and canonicalization logic.\n+\n+use crate::db::HirDatabase;\n+use crate::ty::{Ty, Canonical, TraitRef, InferTy};\n+use super::InferenceContext;\n+\n+impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n+    pub(super) fn canonicalizer<'b>(&'b mut self) -> Canonicalizer<'a, 'b, D>\n+    where\n+        'a: 'b,\n+    {\n+        Canonicalizer { ctx: self, free_vars: Vec::new(), var_stack: Vec::new() }\n+    }\n+}\n+\n+pub(super) struct Canonicalizer<'a, 'b, D: HirDatabase>\n+where\n+    'a: 'b,\n+{\n+    ctx: &'b mut InferenceContext<'a, D>,\n+    free_vars: Vec<InferTy>,\n+    /// A stack of type variables that is used to detect recursive types (which\n+    /// are an error, but we need to protect against them to avoid stack\n+    /// overflows).\n+    var_stack: Vec<super::TypeVarId>,\n+}\n+\n+pub(super) struct Canonicalized<T> {\n+    pub value: Canonical<T>,\n+    free_vars: Vec<InferTy>,\n+}\n+\n+impl<'a, 'b, D: HirDatabase> Canonicalizer<'a, 'b, D>\n+where\n+    'a: 'b,\n+{\n+    fn add(&mut self, free_var: InferTy) -> usize {\n+        self.free_vars.iter().position(|&v| v == free_var).unwrap_or_else(|| {\n+            let next_index = self.free_vars.len();\n+            self.free_vars.push(free_var);\n+            next_index\n+        })\n+    }\n+\n+    fn do_canonicalize_ty(&mut self, ty: Ty) -> Ty {\n+        ty.fold(&mut |ty| match ty {\n+            Ty::Infer(tv) => {\n+                let inner = tv.to_inner();\n+                if self.var_stack.contains(&inner) {\n+                    // recursive type\n+                    return tv.fallback_value();\n+                }\n+                if let Some(known_ty) = self.ctx.var_unification_table.probe_value(inner).known() {\n+                    self.var_stack.push(inner);\n+                    let result = self.do_canonicalize_ty(known_ty.clone());\n+                    self.var_stack.pop();\n+                    result\n+                } else {\n+                    let free_var = InferTy::TypeVar(self.ctx.var_unification_table.find(inner));\n+                    let position = self.add(free_var);\n+                    Ty::Bound(position as u32)\n+                }\n+            }\n+            _ => ty,\n+        })\n+    }\n+\n+    fn do_canonicalize_trait_ref(&mut self, trait_ref: TraitRef) -> TraitRef {\n+        let substs = trait_ref\n+            .substs\n+            .iter()\n+            .map(|ty| self.do_canonicalize_ty(ty.clone()))\n+            .collect::<Vec<_>>();\n+        TraitRef { trait_: trait_ref.trait_, substs: substs.into() }\n+    }\n+\n+    fn into_canonicalized<T>(self, result: T) -> Canonicalized<T> {\n+        Canonicalized {\n+            value: Canonical { value: result, num_vars: self.free_vars.len() },\n+            free_vars: self.free_vars,\n+        }\n+    }\n+\n+    pub fn canonicalize_ty(mut self, ty: Ty) -> Canonicalized<Ty> {\n+        let result = self.do_canonicalize_ty(ty);\n+        self.into_canonicalized(result)\n+    }\n+\n+    pub fn canonicalize_trait_ref(mut self, trait_ref: TraitRef) -> Canonicalized<TraitRef> {\n+        let result = self.do_canonicalize_trait_ref(trait_ref);\n+        self.into_canonicalized(result)\n+    }\n+}\n+\n+impl<T> Canonicalized<T> {\n+    pub fn decanonicalize_ty(&self, ty: Ty) -> Ty {\n+        ty.fold(&mut |ty| match ty {\n+            Ty::Bound(idx) => {\n+                if (idx as usize) < self.free_vars.len() {\n+                    Ty::Infer(self.free_vars[idx as usize].clone())\n+                } else {\n+                    Ty::Bound(idx)\n+                }\n+            }\n+            ty => ty,\n+        })\n+    }\n+\n+    pub fn apply_solution(\n+        &self,\n+        ctx: &mut InferenceContext<'_, impl HirDatabase>,\n+        solution: Canonical<Vec<Ty>>,\n+    ) {\n+        // the solution may contain new variables, which we need to convert to new inference vars\n+        let new_vars =\n+            (0..solution.num_vars).map(|_| ctx.new_type_var()).collect::<Vec<_>>().into();\n+        for (i, ty) in solution.value.into_iter().enumerate() {\n+            let var = self.free_vars[i].clone();\n+            ctx.unify(&Ty::Infer(var), &ty.subst_bound_vars(&new_vars));\n+        }\n+    }\n+}"}, {"sha": "8bab7e54b89e0a97a8a4909c027d481da743b743", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=9c49f6c36e1e097f938946811d1e2f5eb70edca9", "patch": "@@ -29,7 +29,10 @@ impl Ty {\n             TypeRef::Tuple(inner) => {\n                 let inner_tys =\n                     inner.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect::<Vec<_>>();\n-                Ty::apply(TypeCtor::Tuple, Substs(inner_tys.into()))\n+                Ty::apply(\n+                    TypeCtor::Tuple { cardinality: inner_tys.len() as u16 },\n+                    Substs(inner_tys.into()),\n+                )\n             }\n             TypeRef::Path(path) => Ty::from_hir_path(db, resolver, path),\n             TypeRef::RawPtr(inner, mutability) => {\n@@ -53,7 +56,7 @@ impl Ty {\n                 let inner_tys =\n                     params.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect::<Vec<_>>();\n                 let sig = Substs(inner_tys.into());\n-                Ty::apply(TypeCtor::FnPtr, sig)\n+                Ty::apply(TypeCtor::FnPtr { num_args: sig.len() as u16 - 1 }, sig)\n             }\n             TypeRef::Error => Ty::Unknown,\n         }\n@@ -238,6 +241,11 @@ impl TraitRef {\n         let segment = path.segments.last().expect(\"path should have at least one segment\");\n         substs_from_path_segment(db, resolver, segment, &resolved.generic_params(db), true)\n     }\n+\n+    pub(crate) fn for_trait(db: &impl HirDatabase, trait_: Trait) -> TraitRef {\n+        let substs = Substs::identity(&trait_.generic_params(db));\n+        TraitRef { trait_, substs }\n+    }\n }\n \n /// Build the declared type of an item. This depends on the namespace; e.g. for\n@@ -299,7 +307,7 @@ fn fn_sig_for_fn(db: &impl HirDatabase, def: Function) -> FnSig {\n /// function body.\n fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n     let generics = def.generic_params(db);\n-    let substs = make_substs(&generics);\n+    let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n \n@@ -341,7 +349,7 @@ fn type_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> Ty {\n         return type_for_struct(db, def); // Unit struct\n     }\n     let generics = def.generic_params(db);\n-    let substs = make_substs(&generics);\n+    let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n \n@@ -357,7 +365,7 @@ fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant)\n         .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n         .collect::<Vec<_>>();\n     let generics = def.parent_enum(db).generic_params(db);\n-    let substs = make_substs(&generics);\n+    let substs = Substs::identity(&generics);\n     let ret = type_for_enum(db, def.parent_enum(db)).subst(&substs);\n     FnSig::from_params_and_return(params, ret)\n }\n@@ -369,36 +377,25 @@ fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant) ->\n         return type_for_enum(db, def.parent_enum(db)); // Unit variant\n     }\n     let generics = def.parent_enum(db).generic_params(db);\n-    let substs = make_substs(&generics);\n+    let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n \n-fn make_substs(generics: &GenericParams) -> Substs {\n-    Substs(\n-        generics\n-            .params_including_parent()\n-            .into_iter()\n-            .map(|p| Ty::Param { idx: p.idx, name: p.name.clone() })\n-            .collect::<Vec<_>>()\n-            .into(),\n-    )\n-}\n-\n fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n     let generics = s.generic_params(db);\n-    Ty::apply(TypeCtor::Adt(s.into()), make_substs(&generics))\n+    Ty::apply(TypeCtor::Adt(s.into()), Substs::identity(&generics))\n }\n \n fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Ty {\n     let generics = s.generic_params(db);\n-    Ty::apply(TypeCtor::Adt(s.into()), make_substs(&generics))\n+    Ty::apply(TypeCtor::Adt(s.into()), Substs::identity(&generics))\n }\n \n fn type_for_type_alias(db: &impl HirDatabase, t: TypeAlias) -> Ty {\n     let generics = t.generic_params(db);\n     let resolver = t.resolver(db);\n     let type_ref = t.type_ref(db);\n-    let substs = make_substs(&generics);\n+    let substs = Substs::identity(&generics);\n     let inner = Ty::from_hir(db, &resolver, &type_ref);\n     inner.subst(&substs)\n }"}, {"sha": "607e9ba79332ed27ca916e09b75d71148b381c75", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 116, "deletions": 107, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=9c49f6c36e1e097f938946811d1e2f5eb70edca9", "patch": "@@ -16,7 +16,7 @@ use crate::{\n     generics::HasGenericParams,\n     ty::primitive::{UncertainIntTy, UncertainFloatTy}\n };\n-use super::{TraitRef, Substs};\n+use super::{TraitRef, Canonical};\n \n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -130,124 +130,122 @@ fn def_crate(db: &impl HirDatabase, cur_crate: Crate, ty: &Ty) -> Option<Crate>\n     }\n }\n \n-impl Ty {\n-    /// Look up the method with the given name, returning the actual autoderefed\n-    /// receiver type (but without autoref applied yet).\n-    pub(crate) fn lookup_method(\n-        self,\n-        db: &impl HirDatabase,\n-        name: &Name,\n-        resolver: &Resolver,\n-    ) -> Option<(Ty, Function)> {\n-        self.iterate_method_candidates(db, resolver, Some(name), |ty, f| Some((ty.clone(), f)))\n-    }\n+/// Look up the method with the given name, returning the actual autoderefed\n+/// receiver type (but without autoref applied yet).\n+pub(crate) fn lookup_method(\n+    ty: &Canonical<Ty>,\n+    db: &impl HirDatabase,\n+    name: &Name,\n+    resolver: &Resolver,\n+) -> Option<(Ty, Function)> {\n+    iterate_method_candidates(ty, db, resolver, Some(name), |ty, f| Some((ty.clone(), f)))\n+}\n \n-    // This would be nicer if it just returned an iterator, but that runs into\n-    // lifetime problems, because we need to borrow temp `CrateImplBlocks`.\n-    pub(crate) fn iterate_method_candidates<T>(\n-        self,\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n-        name: Option<&Name>,\n-        mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n-    ) -> Option<T> {\n-        // For method calls, rust first does any number of autoderef, and then one\n-        // autoref (i.e. when the method takes &self or &mut self). We just ignore\n-        // the autoref currently -- when we find a method matching the given name,\n-        // we assume it fits.\n+// This would be nicer if it just returned an iterator, but that runs into\n+// lifetime problems, because we need to borrow temp `CrateImplBlocks`.\n+pub(crate) fn iterate_method_candidates<T>(\n+    ty: &Canonical<Ty>,\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    name: Option<&Name>,\n+    mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n+) -> Option<T> {\n+    // For method calls, rust first does any number of autoderef, and then one\n+    // autoref (i.e. when the method takes &self or &mut self). We just ignore\n+    // the autoref currently -- when we find a method matching the given name,\n+    // we assume it fits.\n \n-        // Also note that when we've got a receiver like &S, even if the method we\n-        // find in the end takes &self, we still do the autoderef step (just as\n-        // rustc does an autoderef and then autoref again).\n+    // Also note that when we've got a receiver like &S, even if the method we\n+    // find in the end takes &self, we still do the autoderef step (just as\n+    // rustc does an autoderef and then autoref again).\n \n-        let krate = resolver.krate()?;\n-        for derefed_ty in self.autoderef(db) {\n-            if let Some(result) =\n-                derefed_ty.iterate_inherent_methods(db, name, krate, &mut callback)\n-            {\n-                return Some(result);\n-            }\n-            if let Some(result) =\n-                derefed_ty.iterate_trait_method_candidates(db, resolver, name, &mut callback)\n-            {\n-                return Some(result);\n-            }\n+    let krate = resolver.krate()?;\n+    for derefed_ty in ty.value.clone().autoderef(db) {\n+        let derefed_ty = Canonical { value: derefed_ty, num_vars: ty.num_vars };\n+        if let Some(result) = iterate_inherent_methods(&derefed_ty, db, name, krate, &mut callback)\n+        {\n+            return Some(result);\n+        }\n+        if let Some(result) =\n+            iterate_trait_method_candidates(&derefed_ty, db, resolver, name, &mut callback)\n+        {\n+            return Some(result);\n         }\n-        None\n     }\n+    None\n+}\n \n-    fn iterate_trait_method_candidates<T>(\n-        &self,\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n-        name: Option<&Name>,\n-        mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n-    ) -> Option<T> {\n-        'traits: for t in resolver.traits_in_scope() {\n-            let data = t.trait_data(db);\n-            // we'll be lazy about checking whether the type implements the\n-            // trait, but if we find out it doesn't, we'll skip the rest of the\n-            // iteration\n-            let mut known_implemented = false;\n-            for item in data.items() {\n-                match item {\n-                    &TraitItem::Function(m) => {\n-                        let sig = m.signature(db);\n-                        if name.map_or(true, |name| sig.name() == name) && sig.has_self_param() {\n-                            if !known_implemented {\n-                                let trait_ref = TraitRef {\n-                                    trait_: t,\n-                                    substs: fresh_substs_for_trait(db, t, self.clone()),\n-                                };\n-                                let (trait_ref, _) = super::traits::canonicalize(trait_ref);\n-                                if db.implements(trait_ref).is_none() {\n-                                    continue 'traits;\n-                                }\n-                            }\n-                            known_implemented = true;\n-                            if let Some(result) = callback(self, m) {\n-                                return Some(result);\n+fn iterate_trait_method_candidates<T>(\n+    ty: &Canonical<Ty>,\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    name: Option<&Name>,\n+    mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n+) -> Option<T> {\n+    let krate = resolver.krate()?;\n+    'traits: for t in resolver.traits_in_scope() {\n+        let data = t.trait_data(db);\n+        // we'll be lazy about checking whether the type implements the\n+        // trait, but if we find out it doesn't, we'll skip the rest of the\n+        // iteration\n+        let mut known_implemented = false;\n+        for item in data.items() {\n+            match item {\n+                &TraitItem::Function(m) => {\n+                    let sig = m.signature(db);\n+                    if name.map_or(true, |name| sig.name() == name) && sig.has_self_param() {\n+                        if !known_implemented {\n+                            let trait_ref = canonical_trait_ref(db, t, ty.clone());\n+                            // FIXME cache this implements check (without solution) in a query?\n+                            if super::traits::implements(db, krate, trait_ref).is_none() {\n+                                continue 'traits;\n                             }\n                         }\n+                        known_implemented = true;\n+                        if let Some(result) = callback(&ty.value, m) {\n+                            return Some(result);\n+                        }\n                     }\n-                    _ => {}\n                 }\n+                _ => {}\n             }\n         }\n-        None\n     }\n+    None\n+}\n \n-    fn iterate_inherent_methods<T>(\n-        &self,\n-        db: &impl HirDatabase,\n-        name: Option<&Name>,\n-        krate: Crate,\n-        mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n-    ) -> Option<T> {\n-        let krate = match def_crate(db, krate, self) {\n-            Some(krate) => krate,\n-            None => return None,\n-        };\n-        let impls = db.impls_in_crate(krate);\n+fn iterate_inherent_methods<T>(\n+    ty: &Canonical<Ty>,\n+    db: &impl HirDatabase,\n+    name: Option<&Name>,\n+    krate: Crate,\n+    mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n+) -> Option<T> {\n+    let krate = match def_crate(db, krate, &ty.value) {\n+        Some(krate) => krate,\n+        None => return None,\n+    };\n+    let impls = db.impls_in_crate(krate);\n \n-        for impl_block in impls.lookup_impl_blocks(self) {\n-            for item in impl_block.items(db) {\n-                match item {\n-                    ImplItem::Method(f) => {\n-                        let sig = f.signature(db);\n-                        if name.map_or(true, |name| sig.name() == name) && sig.has_self_param() {\n-                            if let Some(result) = callback(self, f) {\n-                                return Some(result);\n-                            }\n+    for impl_block in impls.lookup_impl_blocks(&ty.value) {\n+        for item in impl_block.items(db) {\n+            match item {\n+                ImplItem::Method(f) => {\n+                    let sig = f.signature(db);\n+                    if name.map_or(true, |name| sig.name() == name) && sig.has_self_param() {\n+                        if let Some(result) = callback(&ty.value, f) {\n+                            return Some(result);\n                         }\n                     }\n-                    _ => {}\n                 }\n+                _ => {}\n             }\n         }\n-        None\n     }\n+    None\n+}\n \n+impl Ty {\n     // This would be nicer if it just returned an iterator, but that runs into\n     // lifetime problems, because we need to borrow temp `CrateImplBlocks`.\n     pub fn iterate_impl_items<T>(\n@@ -271,15 +269,26 @@ impl Ty {\n }\n \n /// This creates Substs for a trait with the given Self type and type variables\n-/// for all other parameters. This is kind of a hack since these aren't 'real'\n-/// type variables; the resulting trait reference is just used for the\n-/// preliminary method candidate check.\n-fn fresh_substs_for_trait(db: &impl HirDatabase, tr: Trait, self_ty: Ty) -> Substs {\n+/// for all other parameters, to query Chalk with it.\n+fn canonical_trait_ref(\n+    db: &impl HirDatabase,\n+    trait_: Trait,\n+    self_ty: Canonical<Ty>,\n+) -> Canonical<TraitRef> {\n     let mut substs = Vec::new();\n-    let generics = tr.generic_params(db);\n-    substs.push(self_ty);\n-    substs.extend(generics.params_including_parent().into_iter().skip(1).enumerate().map(\n-        |(i, _p)| Ty::Infer(super::infer::InferTy::TypeVar(super::infer::TypeVarId(i as u32))),\n-    ));\n-    substs.into()\n+    let generics = trait_.generic_params(db);\n+    let num_vars = self_ty.num_vars;\n+    substs.push(self_ty.value);\n+    substs.extend(\n+        generics\n+            .params_including_parent()\n+            .into_iter()\n+            .skip(1)\n+            .enumerate()\n+            .map(|(i, _p)| Ty::Bound((i + num_vars) as u32)),\n+    );\n+    Canonical {\n+        num_vars: substs.len() - 1 + self_ty.num_vars,\n+        value: TraitRef { trait_, substs: substs.into() },\n+    }\n }"}, {"sha": "0aecde37c4de48c4b9911db70c7f398768087e92", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=9c49f6c36e1e097f938946811d1e2f5eb70edca9", "patch": "@@ -2140,7 +2140,7 @@ fn test() {\n [102; 127) '{     ...d(); }': ()\n [108; 109) 'S': S<u32>(T) -> S<T>\n [108; 115) 'S(1u32)': S<u32>\n-[108; 124) 'S(1u32...thod()': {unknown}\n+[108; 124) 'S(1u32...thod()': u32\n [110; 114) '1u32': u32\"###\n     );\n }"}, {"sha": "a1ed0c028206f7c2d68c92f5e6cd2e6585f16dcc", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 134, "deletions": 89, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=9c49f6c36e1e097f938946811d1e2f5eb70edca9", "patch": "@@ -1,115 +1,160 @@\n-//! Stuff that will probably mostly replaced by Chalk.\n-use std::collections::HashMap;\n+//! Trait solving using Chalk.\n+use std::sync::{Arc, Mutex};\n \n-use crate::{db::HirDatabase, generics::HasGenericParams};\n-use super::{TraitRef, Substs, infer::{TypeVarId, InferTy}, Ty};\n+use log::debug;\n+use chalk_ir::cast::Cast;\n \n-// Copied (and simplified) from Chalk\n+use crate::{Crate, Trait, db::HirDatabase, ImplBlock};\n+use super::{TraitRef, Ty, Canonical};\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n-/// A (possible) solution for a proposed goal. Usually packaged in a `Result`,\n-/// where `Err` represents definite *failure* to prove a goal.\n-pub enum Solution {\n-    /// The goal indeed holds, and there is a unique value for all existential\n-    /// variables.\n-    Unique(Substs),\n+use self::chalk::{ToChalk, from_chalk};\n \n-    /// The goal may be provable in multiple ways, but regardless we may have some guidance\n-    /// for type inference.\n-    Ambig(Guidance),\n+mod chalk;\n+\n+pub(crate) type Solver = chalk_solve::Solver;\n+\n+#[derive(Debug, Copy, Clone)]\n+struct ChalkContext<'a, DB> {\n+    db: &'a DB,\n+    krate: Crate,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n-/// When a goal holds ambiguously (e.g., because there are multiple possible\n-/// solutions), we issue a set of *guidance* back to type inference.\n-pub enum Guidance {\n-    /// The existential variables *must* have the given values if the goal is\n-    /// ever to hold, but that alone isn't enough to guarantee the goal will\n-    /// actually hold.\n-    Definite(Substs),\n+pub(crate) fn solver(_db: &impl HirDatabase, _krate: Crate) -> Arc<Mutex<Solver>> {\n+    // krate parameter is just so we cache a unique solver per crate\n+    let solver_choice = chalk_solve::SolverChoice::SLG { max_size: 10 };\n+    Arc::new(Mutex::new(solver_choice.into_solver()))\n+}\n \n-    /// There are multiple plausible values for the existentials, but the ones\n-    /// here are suggested as the preferred choice heuristically. These should\n-    /// be used for inference fallback only.\n-    Suggested(Substs),\n+/// Collects impls for the given trait in the whole dependency tree of `krate`.\n+pub(crate) fn impls_for_trait(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+    trait_: Trait,\n+) -> Arc<[ImplBlock]> {\n+    let mut impls = Vec::new();\n+    // We call the query recursively here. On the one hand, this means we can\n+    // reuse results from queries for different crates; on the other hand, this\n+    // will only ever get called for a few crates near the root of the tree (the\n+    // ones the user is editing), so this may actually be a waste of memory. I'm\n+    // doing it like this mainly for simplicity for now.\n+    for dep in krate.dependencies(db) {\n+        impls.extend(db.impls_for_trait(dep.krate, trait_).iter());\n+    }\n+    let crate_impl_blocks = db.impls_in_crate(krate);\n+    impls.extend(crate_impl_blocks.lookup_impl_blocks_for_trait(&trait_));\n+    impls.into()\n+}\n \n-    /// There's no useful information to feed back to type inference\n-    Unknown,\n+fn solve(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+    goal: &chalk_ir::UCanonical<chalk_ir::InEnvironment<chalk_ir::Goal>>,\n+) -> Option<chalk_solve::Solution> {\n+    let context = ChalkContext { db, krate };\n+    let solver = db.solver(krate);\n+    let solution = solver.lock().unwrap().solve(&context, goal);\n+    debug!(\"solve({:?}) => {:?}\", goal, solution);\n+    solution\n }\n \n /// Something that needs to be proven (by Chalk) during type checking, e.g. that\n /// a certain type implements a certain trait. Proving the Obligation might\n /// result in additional information about inference variables.\n-///\n-/// This might be handled by Chalk when we integrate it?\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum Obligation {\n     /// Prove that a certain type implements a trait (the type is the `Self` type\n     /// parameter to the `TraitRef`).\n     Trait(TraitRef),\n }\n \n-/// Rudimentary check whether an impl exists for a given type and trait; this\n-/// will actually be done by chalk.\n-pub(crate) fn implements(db: &impl HirDatabase, trait_ref: TraitRef) -> Option<Solution> {\n-    // FIXME use all trait impls in the whole crate graph\n-    let krate = trait_ref.trait_.module(db).krate(db);\n-    let krate = match krate {\n-        Some(krate) => krate,\n-        None => return None,\n-    };\n-    let crate_impl_blocks = db.impls_in_crate(krate);\n-    let mut impl_blocks = crate_impl_blocks\n-        .lookup_impl_blocks_for_trait(&trait_ref.trait_)\n-        // we don't handle where clauses at all, waiting for Chalk for that\n-        .filter(|impl_block| impl_block.generic_params(db).where_predicates.is_empty());\n-    impl_blocks\n-        .find_map(|impl_block| unify_trait_refs(&trait_ref, &impl_block.target_trait_ref(db)?))\n+/// Check using Chalk whether trait is implemented for given parameters including `Self` type.\n+pub(crate) fn implements(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+    trait_ref: Canonical<TraitRef>,\n+) -> Option<Solution> {\n+    let goal: chalk_ir::Goal = trait_ref.value.to_chalk(db).cast();\n+    debug!(\"goal: {:?}\", goal);\n+    let env = chalk_ir::Environment::new();\n+    let in_env = chalk_ir::InEnvironment::new(&env, goal);\n+    let parameter = chalk_ir::ParameterKind::Ty(chalk_ir::UniverseIndex::ROOT);\n+    let canonical =\n+        chalk_ir::Canonical { value: in_env, binders: vec![parameter; trait_ref.num_vars] };\n+    // We currently don't deal with universes (I think / hope they're not yet\n+    // relevant for our use cases?)\n+    let u_canonical = chalk_ir::UCanonical { canonical, universes: 1 };\n+    let solution = solve(db, krate, &u_canonical);\n+    solution.map(|solution| solution_from_chalk(db, solution))\n }\n \n-pub(super) fn canonicalize(trait_ref: TraitRef) -> (TraitRef, Vec<TypeVarId>) {\n-    let mut canonical = HashMap::new(); // mapping uncanonical -> canonical\n-    let mut uncanonical = Vec::new(); // mapping canonical -> uncanonical (which is dense)\n-    let mut substs = trait_ref.substs.0.to_vec();\n-    for ty in &mut substs {\n-        ty.walk_mut(&mut |ty| match ty {\n-            Ty::Infer(InferTy::TypeVar(tv)) => {\n-                let tv: &mut TypeVarId = tv;\n-                *tv = *canonical.entry(*tv).or_insert_with(|| {\n-                    let i = uncanonical.len();\n-                    uncanonical.push(*tv);\n-                    TypeVarId(i as u32)\n-                });\n-            }\n-            _ => {}\n-        });\n+fn solution_from_chalk(db: &impl HirDatabase, solution: chalk_solve::Solution) -> Solution {\n+    let convert_subst = |subst: chalk_ir::Canonical<chalk_ir::Substitution>| {\n+        let value = subst\n+            .value\n+            .parameters\n+            .into_iter()\n+            .map(|p| {\n+                let ty = match p {\n+                    chalk_ir::Parameter(chalk_ir::ParameterKind::Ty(ty)) => from_chalk(db, ty),\n+                    chalk_ir::Parameter(chalk_ir::ParameterKind::Lifetime(_)) => unimplemented!(),\n+                };\n+                ty\n+            })\n+            .collect();\n+        let result = Canonical { value, num_vars: subst.binders.len() };\n+        SolutionVariables(result)\n+    };\n+    match solution {\n+        chalk_solve::Solution::Unique(constr_subst) => {\n+            let subst = chalk_ir::Canonical {\n+                value: constr_subst.value.subst,\n+                binders: constr_subst.binders,\n+            };\n+            Solution::Unique(convert_subst(subst))\n+        }\n+        chalk_solve::Solution::Ambig(chalk_solve::Guidance::Definite(subst)) => {\n+            Solution::Ambig(Guidance::Definite(convert_subst(subst)))\n+        }\n+        chalk_solve::Solution::Ambig(chalk_solve::Guidance::Suggested(subst)) => {\n+            Solution::Ambig(Guidance::Suggested(convert_subst(subst)))\n+        }\n+        chalk_solve::Solution::Ambig(chalk_solve::Guidance::Unknown) => {\n+            Solution::Ambig(Guidance::Unknown)\n+        }\n     }\n-    (TraitRef { substs: substs.into(), ..trait_ref }, uncanonical)\n }\n \n-fn unify_trait_refs(tr1: &TraitRef, tr2: &TraitRef) -> Option<Solution> {\n-    if tr1.trait_ != tr2.trait_ {\n-        return None;\n-    }\n-    let mut solution_substs = Vec::new();\n-    for (t1, t2) in tr1.substs.0.iter().zip(tr2.substs.0.iter()) {\n-        // this is very bad / hacky 'unification' logic, just enough to make the simple tests pass\n-        match (t1, t2) {\n-            (_, Ty::Infer(InferTy::TypeVar(_))) | (_, Ty::Unknown) | (_, Ty::Param { .. }) => {\n-                // type variable (or similar) in the impl, we just assume it works\n-            }\n-            (Ty::Infer(InferTy::TypeVar(v1)), _) => {\n-                // type variable in the query and fixed type in the impl, record its value\n-                solution_substs.resize_with(v1.0 as usize + 1, || Ty::Unknown);\n-                solution_substs[v1.0 as usize] = t2.clone();\n-            }\n-            _ => {\n-                // check that they're equal (actually we'd have to recurse etc.)\n-                if t1 != t2 {\n-                    return None;\n-                }\n-            }\n-        }\n-    }\n-    Some(Solution::Unique(solution_substs.into()))\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) struct SolutionVariables(pub Canonical<Vec<Ty>>);\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+/// A (possible) solution for a proposed goal.\n+pub(crate) enum Solution {\n+    /// The goal indeed holds, and there is a unique value for all existential\n+    /// variables.\n+    Unique(SolutionVariables),\n+\n+    /// The goal may be provable in multiple ways, but regardless we may have some guidance\n+    /// for type inference. In this case, we don't return any lifetime\n+    /// constraints, since we have not \"committed\" to any particular solution\n+    /// yet.\n+    Ambig(Guidance),\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+/// When a goal holds ambiguously (e.g., because there are multiple possible\n+/// solutions), we issue a set of *guidance* back to type inference.\n+pub(crate) enum Guidance {\n+    /// The existential variables *must* have the given values if the goal is\n+    /// ever to hold, but that alone isn't enough to guarantee the goal will\n+    /// actually hold.\n+    Definite(SolutionVariables),\n+\n+    /// There are multiple plausible values for the existentials, but the ones\n+    /// here are suggested as the preferred choice heuristically. These should\n+    /// be used for inference fallback only.\n+    Suggested(SolutionVariables),\n+\n+    /// There's no useful information to feed back to type inference\n+    Unknown,\n }"}, {"sha": "8b77d21b4a39999502356bf00489863a71d18bf5", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=9c49f6c36e1e097f938946811d1e2f5eb70edca9", "patch": "@@ -0,0 +1,333 @@\n+//! Conversion code from/to Chalk.\n+use std::sync::Arc;\n+\n+use log::debug;\n+\n+use chalk_ir::{TypeId, ImplId, TypeKindId, ProjectionTy, Parameter, Identifier, cast::Cast, PlaceholderIndex, UniverseIndex, TypeName};\n+use chalk_rust_ir::{AssociatedTyDatum, TraitDatum, StructDatum, ImplDatum};\n+\n+use ra_db::salsa::{InternId, InternKey};\n+\n+use crate::{\n+    Trait, HasGenericParams, ImplBlock,\n+    db::HirDatabase,\n+    ty::{TraitRef, Ty, ApplicationTy, TypeCtor, Substs},\n+};\n+use super::ChalkContext;\n+\n+pub(super) trait ToChalk {\n+    type Chalk;\n+    fn to_chalk(self, db: &impl HirDatabase) -> Self::Chalk;\n+    fn from_chalk(db: &impl HirDatabase, chalk: Self::Chalk) -> Self;\n+}\n+\n+pub(super) fn from_chalk<T, ChalkT>(db: &impl HirDatabase, chalk: ChalkT) -> T\n+where\n+    T: ToChalk<Chalk = ChalkT>,\n+{\n+    T::from_chalk(db, chalk)\n+}\n+\n+impl ToChalk for Ty {\n+    type Chalk = chalk_ir::Ty;\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Ty {\n+        match self {\n+            Ty::Apply(apply_ty) => {\n+                let struct_id = apply_ty.ctor.to_chalk(db);\n+                let name = TypeName::TypeKindId(struct_id.into());\n+                let parameters = apply_ty.parameters.to_chalk(db);\n+                chalk_ir::ApplicationTy { name, parameters }.cast()\n+            }\n+            Ty::Param { idx, .. } => {\n+                PlaceholderIndex { ui: UniverseIndex::ROOT, idx: idx as usize }.to_ty()\n+            }\n+            Ty::Bound(idx) => chalk_ir::Ty::BoundVar(idx as usize),\n+            Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n+            // FIXME this is clearly incorrect, but probably not too incorrect\n+            // and I'm not sure what to actually do with Ty::Unknown\n+            Ty::Unknown => PlaceholderIndex { ui: UniverseIndex::ROOT, idx: 0 }.to_ty(),\n+        }\n+    }\n+    fn from_chalk(db: &impl HirDatabase, chalk: chalk_ir::Ty) -> Self {\n+        match chalk {\n+            chalk_ir::Ty::Apply(apply_ty) => {\n+                match apply_ty.name {\n+                    TypeName::TypeKindId(TypeKindId::StructId(struct_id)) => {\n+                        let ctor = from_chalk(db, struct_id);\n+                        let parameters = from_chalk(db, apply_ty.parameters);\n+                        Ty::Apply(ApplicationTy { ctor, parameters })\n+                    }\n+                    // FIXME handle TypeKindId::Trait/Type here\n+                    TypeName::TypeKindId(_) => unimplemented!(),\n+                    TypeName::AssociatedType(_) => unimplemented!(),\n+                    TypeName::Placeholder(idx) => {\n+                        assert_eq!(idx.ui, UniverseIndex::ROOT);\n+                        Ty::Param { idx: idx.idx as u32, name: crate::Name::missing() }\n+                    }\n+                }\n+            }\n+            chalk_ir::Ty::Projection(_) => unimplemented!(),\n+            chalk_ir::Ty::UnselectedProjection(_) => unimplemented!(),\n+            chalk_ir::Ty::ForAll(_) => unimplemented!(),\n+            chalk_ir::Ty::BoundVar(idx) => Ty::Bound(idx as u32),\n+            chalk_ir::Ty::InferenceVar(_iv) => panic!(\"unexpected chalk infer ty\"),\n+        }\n+    }\n+}\n+\n+impl ToChalk for Substs {\n+    type Chalk = Vec<chalk_ir::Parameter>;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> Vec<Parameter> {\n+        self.iter().map(|ty| ty.clone().to_chalk(db).cast()).collect()\n+    }\n+\n+    fn from_chalk(db: &impl HirDatabase, parameters: Vec<chalk_ir::Parameter>) -> Substs {\n+        parameters\n+            .into_iter()\n+            .map(|p| match p {\n+                chalk_ir::Parameter(chalk_ir::ParameterKind::Ty(ty)) => from_chalk(db, ty),\n+                chalk_ir::Parameter(chalk_ir::ParameterKind::Lifetime(_)) => unimplemented!(),\n+            })\n+            .collect::<Vec<_>>()\n+            .into()\n+    }\n+}\n+\n+impl ToChalk for TraitRef {\n+    type Chalk = chalk_ir::TraitRef;\n+\n+    fn to_chalk(self: TraitRef, db: &impl HirDatabase) -> chalk_ir::TraitRef {\n+        let trait_id = self.trait_.to_chalk(db);\n+        let parameters = self.substs.to_chalk(db);\n+        chalk_ir::TraitRef { trait_id, parameters }\n+    }\n+\n+    fn from_chalk(db: &impl HirDatabase, trait_ref: chalk_ir::TraitRef) -> Self {\n+        let trait_ = from_chalk(db, trait_ref.trait_id);\n+        let substs = from_chalk(db, trait_ref.parameters);\n+        TraitRef { trait_, substs }\n+    }\n+}\n+\n+impl ToChalk for Trait {\n+    type Chalk = chalk_ir::TraitId;\n+\n+    fn to_chalk(self, _db: &impl HirDatabase) -> chalk_ir::TraitId {\n+        self.id.into()\n+    }\n+\n+    fn from_chalk(_db: &impl HirDatabase, trait_id: chalk_ir::TraitId) -> Trait {\n+        Trait { id: trait_id.into() }\n+    }\n+}\n+\n+impl ToChalk for TypeCtor {\n+    type Chalk = chalk_ir::StructId;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::StructId {\n+        db.intern_type_ctor(self).into()\n+    }\n+\n+    fn from_chalk(db: &impl HirDatabase, struct_id: chalk_ir::StructId) -> TypeCtor {\n+        db.lookup_intern_type_ctor(struct_id.into())\n+    }\n+}\n+\n+impl ToChalk for ImplBlock {\n+    type Chalk = chalk_ir::ImplId;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::ImplId {\n+        db.intern_impl_block(self).into()\n+    }\n+\n+    fn from_chalk(db: &impl HirDatabase, impl_id: chalk_ir::ImplId) -> ImplBlock {\n+        db.lookup_intern_impl_block(impl_id.into())\n+    }\n+}\n+\n+fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T> {\n+    chalk_ir::Binders {\n+        value,\n+        binders: std::iter::repeat(chalk_ir::ParameterKind::Ty(())).take(num_vars).collect(),\n+    }\n+}\n+\n+impl<'a, DB> chalk_solve::RustIrDatabase for ChalkContext<'a, DB>\n+where\n+    DB: HirDatabase,\n+{\n+    fn associated_ty_data(&self, _ty: TypeId) -> Arc<AssociatedTyDatum> {\n+        unimplemented!()\n+    }\n+    fn trait_datum(&self, trait_id: chalk_ir::TraitId) -> Arc<TraitDatum> {\n+        debug!(\"trait_datum {:?}\", trait_id);\n+        let trait_: Trait = from_chalk(self.db, trait_id);\n+        let generic_params = trait_.generic_params(self.db);\n+        let bound_vars = Substs::bound_vars(&generic_params);\n+        let trait_ref = trait_.trait_ref(self.db).subst(&bound_vars).to_chalk(self.db);\n+        let flags = chalk_rust_ir::TraitFlags {\n+            // FIXME set these flags correctly\n+            auto: false,\n+            marker: false,\n+            upstream: trait_.module(self.db).krate(self.db) != Some(self.krate),\n+            fundamental: false,\n+        };\n+        let where_clauses = Vec::new(); // FIXME add where clauses\n+        let associated_ty_ids = Vec::new(); // FIXME add associated tys\n+        let trait_datum_bound =\n+            chalk_rust_ir::TraitDatumBound { trait_ref, where_clauses, flags, associated_ty_ids };\n+        let trait_datum = TraitDatum { binders: make_binders(trait_datum_bound, bound_vars.len()) };\n+        Arc::new(trait_datum)\n+    }\n+    fn struct_datum(&self, struct_id: chalk_ir::StructId) -> Arc<StructDatum> {\n+        debug!(\"struct_datum {:?}\", struct_id);\n+        let type_ctor = from_chalk(self.db, struct_id);\n+        // FIXME might be nicer if we can create a fake GenericParams for the TypeCtor\n+        // FIXME extract this to a method on Ty\n+        let (num_params, upstream) = match type_ctor {\n+            TypeCtor::Bool\n+            | TypeCtor::Char\n+            | TypeCtor::Int(_)\n+            | TypeCtor::Float(_)\n+            | TypeCtor::Never\n+            | TypeCtor::Str => (0, true),\n+            TypeCtor::Slice | TypeCtor::Array | TypeCtor::RawPtr(_) | TypeCtor::Ref(_) => (1, true),\n+            TypeCtor::FnPtr { num_args } => (num_args as usize + 1, true),\n+            TypeCtor::Tuple { cardinality } => (cardinality as usize, true),\n+            TypeCtor::FnDef(_) => unimplemented!(),\n+            TypeCtor::Adt(adt) => {\n+                let generic_params = adt.generic_params(self.db);\n+                (\n+                    generic_params.count_params_including_parent(),\n+                    adt.krate(self.db) != Some(self.krate),\n+                )\n+            }\n+        };\n+        let flags = chalk_rust_ir::StructFlags {\n+            upstream,\n+            // FIXME set fundamental flag correctly\n+            fundamental: false,\n+        };\n+        let where_clauses = Vec::new(); // FIXME add where clauses\n+        let self_ty = chalk_ir::ApplicationTy {\n+            name: TypeName::TypeKindId(type_ctor.to_chalk(self.db).into()),\n+            parameters: (0..num_params).map(|i| chalk_ir::Ty::BoundVar(i).cast()).collect(),\n+        };\n+        let struct_datum_bound = chalk_rust_ir::StructDatumBound {\n+            self_ty,\n+            fields: Vec::new(), // FIXME add fields (only relevant for auto traits)\n+            where_clauses,\n+            flags,\n+        };\n+        let struct_datum = StructDatum { binders: make_binders(struct_datum_bound, num_params) };\n+        Arc::new(struct_datum)\n+    }\n+    fn impl_datum(&self, impl_id: ImplId) -> Arc<ImplDatum> {\n+        debug!(\"impl_datum {:?}\", impl_id);\n+        let impl_block: ImplBlock = from_chalk(self.db, impl_id);\n+        let generic_params = impl_block.generic_params(self.db);\n+        let bound_vars = Substs::bound_vars(&generic_params);\n+        let trait_ref = impl_block\n+            .target_trait_ref(self.db)\n+            .expect(\"FIXME handle unresolved impl block trait ref\")\n+            .subst(&bound_vars);\n+        let impl_type = if impl_block.module().krate(self.db) == Some(self.krate) {\n+            chalk_rust_ir::ImplType::Local\n+        } else {\n+            chalk_rust_ir::ImplType::External\n+        };\n+        let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n+            // FIXME handle negative impls (impl !Sync for Foo)\n+            trait_ref: chalk_rust_ir::PolarizedTraitRef::Positive(trait_ref.to_chalk(self.db)),\n+            where_clauses: Vec::new(),        // FIXME add where clauses\n+            associated_ty_values: Vec::new(), // FIXME add associated type values\n+            impl_type,\n+        };\n+        let impl_datum = ImplDatum { binders: make_binders(impl_datum_bound, bound_vars.len()) };\n+        Arc::new(impl_datum)\n+    }\n+    fn impls_for_trait(&self, trait_id: chalk_ir::TraitId) -> Vec<ImplId> {\n+        debug!(\"impls_for_trait {:?}\", trait_id);\n+        let trait_ = from_chalk(self.db, trait_id);\n+        self.db\n+            .impls_for_trait(self.krate, trait_)\n+            .iter()\n+            // FIXME temporary hack -- as long as we're not lowering where clauses\n+            // correctly, ignore impls with them completely so as to not treat\n+            // impl<T> Trait for T where T: ... as a blanket impl on all types\n+            .filter(|impl_block| impl_block.generic_params(self.db).where_predicates.is_empty())\n+            .map(|impl_block| impl_block.to_chalk(self.db))\n+            .collect()\n+    }\n+    fn impl_provided_for(\n+        &self,\n+        auto_trait_id: chalk_ir::TraitId,\n+        struct_id: chalk_ir::StructId,\n+    ) -> bool {\n+        debug!(\"impl_provided_for {:?}, {:?}\", auto_trait_id, struct_id);\n+        false // FIXME\n+    }\n+    fn type_name(&self, _id: TypeKindId) -> Identifier {\n+        unimplemented!()\n+    }\n+    fn split_projection<'p>(\n+        &self,\n+        projection: &'p ProjectionTy,\n+    ) -> (Arc<AssociatedTyDatum>, &'p [Parameter], &'p [Parameter]) {\n+        debug!(\"split_projection {:?}\", projection);\n+        unimplemented!()\n+    }\n+    fn custom_clauses(&self) -> Vec<chalk_ir::ProgramClause> {\n+        debug!(\"custom_clauses\");\n+        vec![]\n+    }\n+    fn all_structs(&self) -> Vec<chalk_ir::StructId> {\n+        debug!(\"all_structs\");\n+        // FIXME\n+        vec![]\n+    }\n+}\n+\n+fn id_from_chalk<T: InternKey>(chalk_id: chalk_ir::RawId) -> T {\n+    T::from_intern_id(InternId::from(chalk_id.index))\n+}\n+fn id_to_chalk<T: InternKey>(salsa_id: T) -> chalk_ir::RawId {\n+    chalk_ir::RawId { index: salsa_id.as_intern_id().as_u32() }\n+}\n+\n+impl From<chalk_ir::TraitId> for crate::ids::TraitId {\n+    fn from(trait_id: chalk_ir::TraitId) -> Self {\n+        id_from_chalk(trait_id.0)\n+    }\n+}\n+\n+impl From<crate::ids::TraitId> for chalk_ir::TraitId {\n+    fn from(trait_id: crate::ids::TraitId) -> Self {\n+        chalk_ir::TraitId(id_to_chalk(trait_id))\n+    }\n+}\n+\n+impl From<chalk_ir::StructId> for crate::ids::TypeCtorId {\n+    fn from(struct_id: chalk_ir::StructId) -> Self {\n+        id_from_chalk(struct_id.0)\n+    }\n+}\n+\n+impl From<crate::ids::TypeCtorId> for chalk_ir::StructId {\n+    fn from(type_ctor_id: crate::ids::TypeCtorId) -> Self {\n+        chalk_ir::StructId(id_to_chalk(type_ctor_id))\n+    }\n+}\n+\n+impl From<chalk_ir::ImplId> for crate::ids::GlobalImplId {\n+    fn from(impl_id: chalk_ir::ImplId) -> Self {\n+        id_from_chalk(impl_id.0)\n+    }\n+}\n+\n+impl From<crate::ids::GlobalImplId> for chalk_ir::ImplId {\n+    fn from(impl_id: crate::ids::GlobalImplId) -> Self {\n+        chalk_ir::ImplId(id_to_chalk(impl_id))\n+    }\n+}"}, {"sha": "2e808469915c76e344c71de9ea970383f0769a1e", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c49f6c36e1e097f938946811d1e2f5eb70edca9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=9c49f6c36e1e097f938946811d1e2f5eb70edca9", "patch": "@@ -24,7 +24,7 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n                     }\n                 }\n                 // FIXME unions\n-                TypeCtor::Tuple => {\n+                TypeCtor::Tuple { .. } => {\n                     for (i, ty) in a_ty.parameters.iter().enumerate() {\n                         acc.add_pos_field(ctx, i, ty);\n                     }"}]}