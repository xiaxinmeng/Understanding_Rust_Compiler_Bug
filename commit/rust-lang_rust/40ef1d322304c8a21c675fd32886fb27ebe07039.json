{"sha": "40ef1d322304c8a21c675fd32886fb27ebe07039", "node_id": "C_kwDOAAsO6NoAKDQwZWYxZDMyMjMwNGM4YTIxYzY3NWZkMzI4ODZmYjI3ZWJlMDcwMzk", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-10-09T16:29:39Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-12-19T00:07:14Z"}, "message": "Re-introduce concept of projection cache 'completion'\n\nInstead of clearing out the cache entirely, we store\nthe intermediate evaluation result into the cache entry.\nThis accomplishes several things:\n\n* We avoid the performance hit associated with re-evaluating\n  the sub-obligations\n* We avoid causing issues with incremental compilation, since\n  the final evaluation result is always the same\n* We avoid affecting other uses of the same `InferCtxt` which\n  might care about 'side effects' from processing the sub-obligations\n  (e,g. region constraints). Only code that is specifically aware\n   of the new 'complete' code is affected", "tree": {"sha": "5de99867c9d6f072ce6b4896aca2613daf6362f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5de99867c9d6f072ce6b4896aca2613daf6362f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40ef1d322304c8a21c675fd32886fb27ebe07039", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmG+d7IACgkQtAh+UQ6Y\nsWQ9tg/9G07fEjSbJ9eeMMxft7d8xqEvUpnLQP6U1ohfbnKrJ1Qo48qpaQSpFK5/\npg4q5yimancGeU4JkyNfH32NzLGuvBRm/6RjKDsW9MGqWM5gxID9JGoN3z4KgQvn\n0cKGfMXu7wIuYFczEKUyLNjF6EGCZdaoA9oRr274gOZJztmhr8gco98aiJzZ+IZl\njnk34q9PSt9BfNvsoB1Wsys1IOlXZudJlAUd8FK9RHokJB8Ew84CSzZcw7DNX1R4\nA5K7ZqMq8qc0l7SxoB9Kl8vTZZIGI499JaLPNqhlkEJANyzau1qtF6J2lHWmsuoW\neGKPvZ+KplmjIEOmMcYQyFZEtaVOtDF5xYmx2SuCeivMor92wwk1HhlGR8QaFiDJ\nEC2krkwLq7Vx48mpGZJ8mnywOaCAeFrQ4zxe1gSaFxs0Y8IwsrfdG+Il6Gp9KDnq\nCUyM22t3CS45BcaMZ86TVWS3coxHy3v+0vRtm5bhZHEQ0XoUth9MazjBaADEW5YX\nH/ZEfdkUX5hJiauJpNbk+wyazGvajcLhF5Fb3GuUUm8A4RBbVgbP3CsuNVXbWa1T\nvb6zVTT3N4RWaDle8R5DhGVZg4hvklto6ZpFoHxB7XIfZKaM2RhqHV0RspyXISSu\njpcT8Pg4xSL0SF2qIaNfiXRPL+3xl4eO7Iive5QJckej7aBG19k=\n=Agc7\n-----END PGP SIGNATURE-----", "payload": "tree 5de99867c9d6f072ce6b4896aca2613daf6362f5\nparent 91a0600a5c22b9d159e3c57526af83e71d1120f8\nauthor Aaron Hill <aa1ronham@gmail.com> 1633796979 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1639872434 -0500\n\nRe-introduce concept of projection cache 'completion'\n\nInstead of clearing out the cache entirely, we store\nthe intermediate evaluation result into the cache entry.\nThis accomplishes several things:\n\n* We avoid the performance hit associated with re-evaluating\n  the sub-obligations\n* We avoid causing issues with incremental compilation, since\n  the final evaluation result is always the same\n* We avoid affecting other uses of the same `InferCtxt` which\n  might care about 'side effects' from processing the sub-obligations\n  (e,g. region constraints). Only code that is specifically aware\n   of the new 'complete' code is affected\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40ef1d322304c8a21c675fd32886fb27ebe07039", "html_url": "https://github.com/rust-lang/rust/commit/40ef1d322304c8a21c675fd32886fb27ebe07039", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40ef1d322304c8a21c675fd32886fb27ebe07039/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91a0600a5c22b9d159e3c57526af83e71d1120f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/91a0600a5c22b9d159e3c57526af83e71d1120f8", "html_url": "https://github.com/rust-lang/rust/commit/91a0600a5c22b9d159e3c57526af83e71d1120f8"}], "stats": {"total": 144, "additions": 138, "deletions": 6}, "files": [{"sha": "9fc0b978c736b1533ae4efe16a68ace8b909380b", "filename": "compiler/rustc_infer/src/traits/project.rs", "status": "modified", "additions": 69, "deletions": 3, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/40ef1d322304c8a21c675fd32886fb27ebe07039/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40ef1d322304c8a21c675fd32886fb27ebe07039/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs?ref=40ef1d322304c8a21c675fd32886fb27ebe07039", "patch": "@@ -10,7 +10,7 @@ use rustc_data_structures::{\n };\n use rustc_middle::ty::{self, Ty};\n \n-pub use rustc_middle::traits::Reveal;\n+pub use rustc_middle::traits::{EvaluationResult, Reveal};\n \n pub(crate) type UndoLog<'tcx> =\n     snapshot_map::UndoLog<ProjectionCacheKey<'tcx>, ProjectionCacheEntry<'tcx>>;\n@@ -92,7 +92,42 @@ pub enum ProjectionCacheEntry<'tcx> {\n     Ambiguous,\n     Recur,\n     Error,\n-    NormalizedTy(NormalizedTy<'tcx>),\n+    NormalizedTy {\n+        ty: NormalizedTy<'tcx>,\n+        /// If we were able to successfully evaluate the\n+        /// corresponding cache entry key during predicate\n+        /// evaluation, then this field stores the final\n+        /// result obtained from evaluating all of the projection\n+        /// sub-obligations. During evaluation, we will skip\n+        /// evaluating the cached sub-obligations in `ty`\n+        /// if this field is set. Evaluation only\n+        /// cares about the final result, so we don't\n+        /// care about any region constraint side-effects\n+        /// produced by evaluating the sub-boligations.\n+        ///\n+        /// Additionally, we will clear out the sub-obligations\n+        /// entirely if we ever evaluate the cache entry (along\n+        /// with all its sub obligations) to `EvaluatedToOk`.\n+        /// This affects all users of the cache, not just evaluation.\n+        /// Since a result of `EvaluatedToOk` means that there were\n+        /// no region obligations that need to be tracked, it's\n+        /// fine to forget about the sub-obligations - they\n+        /// don't provide any additional information. However,\n+        /// we do *not* discard any obligations when we see\n+        /// `EvaluatedToOkModuloRegions` - we don't know\n+        /// which sub-obligations may introduce region constraints,\n+        /// so we keep them all to be safe.\n+        ///\n+        /// When we are not performing evaluation\n+        /// (e.g. in `FulfillmentContext`), we ignore this field,\n+        /// and always re-process the cached sub-obligations\n+        /// (which may have been cleared out - see the above\n+        /// paragraph).\n+        /// This ensures that we do not lose any regions\n+        /// constraints that arise from processing the\n+        /// sub-obligations.\n+        complete: Option<EvaluationResult>,\n+    },\n }\n \n impl<'tcx> ProjectionCacheStorage<'tcx> {\n@@ -149,10 +184,41 @@ impl<'tcx> ProjectionCache<'_, 'tcx> {\n             debug!(\"Not overwriting Recur\");\n             return;\n         }\n-        let fresh_key = map.insert(key, ProjectionCacheEntry::NormalizedTy(value));\n+        let fresh_key =\n+            map.insert(key, ProjectionCacheEntry::NormalizedTy { ty: value, complete: None });\n         assert!(!fresh_key, \"never started projecting `{:?}`\", key);\n     }\n \n+    /// Mark the relevant projection cache key as having its derived obligations\n+    /// complete, so they won't have to be re-computed (this is OK to do in a\n+    /// snapshot - if the snapshot is rolled back, the obligations will be\n+    /// marked as incomplete again).\n+    pub fn complete(&mut self, key: ProjectionCacheKey<'tcx>, result: EvaluationResult) {\n+        let mut map = self.map();\n+        match map.get(&key) {\n+            Some(&ProjectionCacheEntry::NormalizedTy { ref ty, complete: _ }) => {\n+                info!(\"ProjectionCacheEntry::complete({:?}) - completing {:?}\", key, ty);\n+                let mut ty = ty.clone();\n+                if result == EvaluationResult::EvaluatedToOk {\n+                    ty.obligations = vec![];\n+                }\n+                map.insert(key, ProjectionCacheEntry::NormalizedTy { ty, complete: Some(result) });\n+            }\n+            ref value => {\n+                // Type inference could \"strand behind\" old cache entries. Leave\n+                // them alone for now.\n+                info!(\"ProjectionCacheEntry::complete({:?}) - ignoring {:?}\", key, value);\n+            }\n+        };\n+    }\n+\n+    pub fn is_complete(&mut self, key: ProjectionCacheKey<'tcx>) -> Option<EvaluationResult> {\n+        self.map().get(&key).and_then(|res| match res {\n+            ProjectionCacheEntry::NormalizedTy { ty: _, complete } => *complete,\n+            _ => None,\n+        })\n+    }\n+\n     /// Indicates that trying to normalize `key` resulted in\n     /// ambiguity. No point in trying it again then until we gain more\n     /// type information (in which case, the \"fully resolved\" key will"}, {"sha": "17e7b481890a90748d14ca83be18853152e5369d", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40ef1d322304c8a21c675fd32886fb27ebe07039/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40ef1d322304c8a21c675fd32886fb27ebe07039/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=40ef1d322304c8a21c675fd32886fb27ebe07039", "patch": "@@ -16,6 +16,7 @@\n #![feature(drain_filter)]\n #![feature(derive_default_enum)]\n #![feature(hash_drain_filter)]\n+#![feature(label_break_value)]\n #![feature(let_else)]\n #![feature(never_type)]\n #![feature(crate_visibility_modifier)]"}, {"sha": "35bb7d6f06cb7f630286cb4c06374a1fb651d0ce", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/40ef1d322304c8a21c675fd32886fb27ebe07039/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40ef1d322304c8a21c675fd32886fb27ebe07039/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=40ef1d322304c8a21c675fd32886fb27ebe07039", "patch": "@@ -4,6 +4,7 @@ use rustc_data_structures::obligation_forest::ProcessResult;\n use rustc_data_structures::obligation_forest::{Error, ForestObligation, Outcome};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n use rustc_errors::ErrorReported;\n+use rustc_infer::traits::ProjectionCacheKey;\n use rustc_infer::traits::{SelectionError, TraitEngine, TraitEngineExt as _, TraitObligation};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n@@ -20,12 +21,14 @@ use super::wf;\n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n+use super::EvaluationResult;\n use super::Unimplemented;\n use super::{FulfillmentError, FulfillmentErrorCode};\n use super::{ObligationCause, PredicateObligation};\n \n use crate::traits::error_reporting::InferCtxtExt as _;\n use crate::traits::project::PolyProjectionObligation;\n+use crate::traits::project::ProjectionCacheKeyExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n \n impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n@@ -709,6 +712,20 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n             // no type variables present, can use evaluation for better caching.\n             // FIXME: consider caching errors too.\n             if self.selcx.infcx().predicate_must_hold_considering_regions(obligation) {\n+                if let Some(key) = ProjectionCacheKey::from_poly_projection_predicate(\n+                    &mut self.selcx,\n+                    project_obligation.predicate,\n+                ) {\n+                    // If `predicate_must_hold_considering_regions` succeeds, then we've\n+                    // evaluated all sub-obligations. We can therefore mark the 'root'\n+                    // obligation as complete, and skip evaluating sub-obligations.\n+                    self.selcx\n+                        .infcx()\n+                        .inner\n+                        .borrow_mut()\n+                        .projection_cache()\n+                        .complete(key, EvaluationResult::EvaluatedToOk);\n+                }\n                 return ProcessResult::Changed(vec![]);\n             } else {\n                 tracing::debug!(\"Does NOT hold: {:?}\", obligation);"}, {"sha": "490e35d34f23128c514d529845d1c7b286fd106b", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40ef1d322304c8a21c675fd32886fb27ebe07039/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40ef1d322304c8a21c675fd32886fb27ebe07039/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=40ef1d322304c8a21c675fd32886fb27ebe07039", "patch": "@@ -889,7 +889,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             debug!(\"recur cache\");\n             return Err(InProgress);\n         }\n-        Err(ProjectionCacheEntry::NormalizedTy(ty)) => {\n+        Err(ProjectionCacheEntry::NormalizedTy { ty, complete: _ }) => {\n             // This is the hottest path in this function.\n             //\n             // If we find the value in the cache, then return it along"}, {"sha": "77b8fc49a15cf5542f94f52a123c1351ff4da627", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/40ef1d322304c8a21c675fd32886fb27ebe07039/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40ef1d322304c8a21c675fd32886fb27ebe07039/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=40ef1d322304c8a21c675fd32886fb27ebe07039", "patch": "@@ -25,6 +25,8 @@ use super::{ObligationCause, PredicateObligation, TraitObligation};\n \n use crate::infer::{InferCtxt, InferOk, TypeFreshener};\n use crate::traits::error_reporting::InferCtxtExt;\n+use crate::traits::project::ProjectionCacheKeyExt;\n+use crate::traits::ProjectionCacheKey;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lrc;\n@@ -550,8 +552,54 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     let project_obligation = obligation.with(data);\n                     match project::poly_project_and_unify_type(self, &project_obligation) {\n                         Ok(Ok(Some(mut subobligations))) => {\n-                            self.add_depth(subobligations.iter_mut(), obligation.recursion_depth);\n-                            self.evaluate_predicates_recursively(previous_stack, subobligations)\n+                            'compute_res: {\n+                                // If we've previously marked this projection as 'complete', thne\n+                                // use the final cached result (either `EvaluatedToOk` or\n+                                // `EvaluatedToOkModuloRegions`), and skip re-evaluating the\n+                                // sub-obligations.\n+                                if let Some(key) =\n+                                    ProjectionCacheKey::from_poly_projection_predicate(self, data)\n+                                {\n+                                    if let Some(cached_res) = self\n+                                        .infcx\n+                                        .inner\n+                                        .borrow_mut()\n+                                        .projection_cache()\n+                                        .is_complete(key)\n+                                    {\n+                                        break 'compute_res Ok(cached_res);\n+                                    }\n+                                }\n+\n+                                self.add_depth(\n+                                    subobligations.iter_mut(),\n+                                    obligation.recursion_depth,\n+                                );\n+                                let res = self.evaluate_predicates_recursively(\n+                                    previous_stack,\n+                                    subobligations,\n+                                );\n+                                if let Ok(res) = res {\n+                                    if res == EvaluatedToOk || res == EvaluatedToOkModuloRegions {\n+                                        if let Some(key) =\n+                                            ProjectionCacheKey::from_poly_projection_predicate(\n+                                                self, data,\n+                                            )\n+                                        {\n+                                            // If the result is something that we can cache, then mark this\n+                                            // entry as 'complete'. This will allow us to skip evaluating the\n+                                            // suboligations at all the next time we evaluate the projection\n+                                            // predicate.\n+                                            self.infcx\n+                                                .inner\n+                                                .borrow_mut()\n+                                                .projection_cache()\n+                                                .complete(key, res);\n+                                        }\n+                                    }\n+                                }\n+                                res\n+                            }\n                         }\n                         Ok(Ok(None)) => Ok(EvaluatedToAmbig),\n                         Ok(Err(project::InProgress)) => Ok(EvaluatedToRecur),"}]}