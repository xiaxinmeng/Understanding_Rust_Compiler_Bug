{"sha": "4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MTdhOTdiYzUxOWQ4Y2Y2NThkYmQyZDA5ZTFkMzRjOGI4ZjFmMjM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-02T15:58:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-02T15:58:47Z"}, "message": "Merge #1749\n\n1749: simplify r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "f6ab78e03a559cde48ff7525cccce6b144da862d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6ab78e03a559cde48ff7525cccce6b144da862d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdbTw3CRBK7hj4Ov3rIwAAdHIIAIz1DO+8gGpnhCi9ZTY7n30c\ntH9M3HrK2YjgVy3Jc4+8sW/gJa9vnrR1DIiyb0PZ7JnSlh7JswVQm9ew0Ad0xDQ4\n7ESqlwdTyb6zrxbmlJYm2MPmSFVsU12dqYVx7VcxrVN/Sih/oSerLCvsvIt8q/54\n7ESWByB2Jua6p8SFnACpgQkj028qhvjy0H7tR+JCCuEgSncw8P8WUnAzX2Db1GRU\n4UUJSAej0DbLq+LPhUN3GJ4HxjWwNqbUazz60QEKgb8bYXw5YY/Vufw+JawXY6rQ\nBTXEvwxc1gF+BDtTHpHUgxor+kx8PsttUSJv6on+qVBWyvVpqsdSCAA60n14edQ=\n=Km1X\n-----END PGP SIGNATURE-----\n", "payload": "tree f6ab78e03a559cde48ff7525cccce6b144da862d\nparent f39f72db57a78b7f92f99377be0e05ec3db6dc98\nparent c89abd42621daff2d652566be4e9e4789599268c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1567439927 +0000\ncommitter GitHub <noreply@github.com> 1567439927 +0000\n\nMerge #1749\n\n1749: simplify r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23", "html_url": "https://github.com/rust-lang/rust/commit/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f39f72db57a78b7f92f99377be0e05ec3db6dc98", "url": "https://api.github.com/repos/rust-lang/rust/commits/f39f72db57a78b7f92f99377be0e05ec3db6dc98", "html_url": "https://github.com/rust-lang/rust/commit/f39f72db57a78b7f92f99377be0e05ec3db6dc98"}, {"sha": "c89abd42621daff2d652566be4e9e4789599268c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c89abd42621daff2d652566be4e9e4789599268c", "html_url": "https://github.com/rust-lang/rust/commit/c89abd42621daff2d652566be4e9e4789599268c"}], "stats": {"total": 477, "additions": 188, "deletions": 289}, "files": [{"sha": "adee0cb4223a3712ce4b1c6c0e84b70424dc6b82", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 45, "deletions": 77, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23", "patch": "@@ -1,7 +1,9 @@\n+//! This module takes a (parsed) definition of `macro_rules` invocation, a\n+//! `tt::TokenTree` representing an argument of macro invocation, and produces a\n+//! `tt::TokenTree` for the result of the expansion.\n+\n+use ra_parser::FragmentKind::*;\n use ra_syntax::SmolStr;\n-/// This module takes a (parsed) definition of `macro_rules` invocation, a\n-/// `tt::TokenTree` representing an argument of macro invocation, and produces a\n-/// `tt::TokenTree` for the result of the expansion.\n use rustc_hash::FxHashMap;\n use tt::TokenId;\n \n@@ -192,81 +194,11 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n             crate::TokenTree::Leaf(leaf) => match leaf {\n                 crate::Leaf::Var(crate::Var { text, kind }) => {\n                     let kind = kind.clone().ok_or(ExpandError::UnexpectedToken)?;\n-                    match kind.as_str() {\n-                        \"ident\" => {\n-                            let ident =\n-                                input.eat_ident().ok_or(ExpandError::UnexpectedToken)?.clone();\n-                            res.inner.insert(\n-                                text.clone(),\n-                                Binding::Simple(tt::Leaf::from(ident).into()),\n-                            );\n-                        }\n-                        \"path\" => {\n-                            let path =\n-                                input.eat_path().ok_or(ExpandError::UnexpectedToken)?.clone();\n-                            res.inner.insert(text.clone(), Binding::Simple(path));\n-                        }\n-                        \"expr\" => {\n-                            let expr =\n-                                input.eat_expr().ok_or(ExpandError::UnexpectedToken)?.clone();\n-                            res.inner.insert(text.clone(), Binding::Simple(expr));\n-                        }\n-                        \"ty\" => {\n-                            let ty = input.eat_ty().ok_or(ExpandError::UnexpectedToken)?.clone();\n-                            res.inner.insert(text.clone(), Binding::Simple(ty));\n-                        }\n-                        \"pat\" => {\n-                            let pat = input.eat_pat().ok_or(ExpandError::UnexpectedToken)?.clone();\n-                            res.inner.insert(text.clone(), Binding::Simple(pat));\n-                        }\n-                        \"stmt\" => {\n-                            let pat = input.eat_stmt().ok_or(ExpandError::UnexpectedToken)?.clone();\n-                            res.inner.insert(text.clone(), Binding::Simple(pat));\n-                        }\n-                        \"block\" => {\n-                            let block =\n-                                input.eat_block().ok_or(ExpandError::UnexpectedToken)?.clone();\n-                            res.inner.insert(text.clone(), Binding::Simple(block));\n-                        }\n-                        \"meta\" => {\n-                            let meta =\n-                                input.eat_meta().ok_or(ExpandError::UnexpectedToken)?.clone();\n-                            res.inner.insert(text.clone(), Binding::Simple(meta));\n-                        }\n-                        \"tt\" => {\n-                            let token = input.eat().ok_or(ExpandError::UnexpectedToken)?.clone();\n-                            res.inner.insert(text.clone(), Binding::Simple(token));\n-                        }\n-                        \"item\" => {\n-                            let item =\n-                                input.eat_item().ok_or(ExpandError::UnexpectedToken)?.clone();\n-                            res.inner.insert(text.clone(), Binding::Simple(item));\n-                        }\n-                        \"lifetime\" => {\n-                            let lifetime =\n-                                input.eat_lifetime().ok_or(ExpandError::UnexpectedToken)?.clone();\n-                            res.inner.insert(text.clone(), Binding::Simple(lifetime));\n+                    match match_meta_var(kind.as_str(), input)? {\n+                        Some(tt) => {\n+                            res.inner.insert(text.clone(), Binding::Simple(tt));\n                         }\n-                        \"literal\" => {\n-                            let literal =\n-                                input.eat_literal().ok_or(ExpandError::UnexpectedToken)?.clone();\n-\n-                            res.inner.insert(\n-                                text.clone(),\n-                                Binding::Simple(tt::Leaf::from(literal).into()),\n-                            );\n-                        }\n-                        \"vis\" => {\n-                            // `vis` is optional\n-                            if let Some(vis) = input.try_eat_vis() {\n-                                let vis = vis.clone();\n-                                res.inner.insert(text.clone(), Binding::Simple(vis));\n-                            } else {\n-                                res.push_optional(&text);\n-                            }\n-                        }\n-\n-                        _ => return Err(ExpandError::UnexpectedToken),\n+                        None => res.push_optional(text),\n                     }\n                 }\n                 crate::Leaf::Punct(punct) => {\n@@ -360,6 +292,42 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n     Ok(res)\n }\n \n+fn match_meta_var(kind: &str, input: &mut TtCursor) -> Result<Option<tt::TokenTree>, ExpandError> {\n+    let fragment = match kind {\n+        \"path\" => Path,\n+        \"expr\" => Expr,\n+        \"ty\" => Type,\n+        \"pat\" => Pattern,\n+        \"stmt\" => Statement,\n+        \"block\" => Block,\n+        \"meta\" => MetaItem,\n+        \"item\" => Item,\n+        _ => {\n+            let binding = match kind {\n+                \"ident\" => {\n+                    let ident = input.eat_ident().ok_or(ExpandError::UnexpectedToken)?.clone();\n+                    tt::Leaf::from(ident).into()\n+                }\n+                \"tt\" => input.eat().ok_or(ExpandError::UnexpectedToken)?.clone(),\n+                \"lifetime\" => input.eat_lifetime().ok_or(ExpandError::UnexpectedToken)?.clone(),\n+                \"literal\" => {\n+                    let literal = input.eat_literal().ok_or(ExpandError::UnexpectedToken)?.clone();\n+                    tt::Leaf::from(literal).into()\n+                }\n+                // `vis` is optional\n+                \"vis\" => match input.try_eat_vis() {\n+                    Some(vis) => vis,\n+                    None => return Ok(None),\n+                },\n+                _ => return Err(ExpandError::UnexpectedToken),\n+            };\n+            return Ok(Some(binding));\n+        }\n+    };\n+    let binding = input.eat_fragment(fragment).ok_or(ExpandError::UnexpectedToken)?;\n+    Ok(Some(binding))\n+}\n+\n #[derive(Debug)]\n struct ExpandCtx<'a> {\n     bindings: &'a Bindings,"}, {"sha": "4440c69ff558faf3452cb3022c2889872149c29c", "filename": "crates/ra_mbe/src/subtree_parser.rs", "status": "modified", "additions": 5, "deletions": 35, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs?ref=4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23", "patch": "@@ -1,6 +1,6 @@\n use crate::subtree_source::SubtreeTokenSource;\n \n-use ra_parser::{TokenSource, TreeSink};\n+use ra_parser::{FragmentKind, TokenSource, TreeSink};\n use ra_syntax::SyntaxKind;\n use tt::buffer::{Cursor, TokenBuffer};\n \n@@ -52,40 +52,10 @@ impl<'a> Parser<'a> {\n         Parser { cur_pos, subtree }\n     }\n \n-    pub fn parse_path(self) -> Option<tt::TokenTree> {\n-        self.parse(ra_parser::parse_path)\n-    }\n-\n-    pub fn parse_expr(self) -> Option<tt::TokenTree> {\n-        self.parse(ra_parser::parse_expr)\n-    }\n-\n-    pub fn parse_ty(self) -> Option<tt::TokenTree> {\n-        self.parse(ra_parser::parse_ty)\n-    }\n-\n-    pub fn parse_pat(self) -> Option<tt::TokenTree> {\n-        self.parse(ra_parser::parse_pat)\n-    }\n-\n-    pub fn parse_stmt(self) -> Option<tt::TokenTree> {\n-        self.parse(|src, sink| ra_parser::parse_stmt(src, sink, false))\n-    }\n-\n-    pub fn parse_block(self) -> Option<tt::TokenTree> {\n-        self.parse(ra_parser::parse_block)\n-    }\n-\n-    pub fn parse_meta(self) -> Option<tt::TokenTree> {\n-        self.parse(ra_parser::parse_meta)\n-    }\n-\n-    pub fn parse_item(self) -> Option<tt::TokenTree> {\n-        self.parse(ra_parser::parse_item)\n-    }\n-\n-    pub fn parse_vis(self) -> Option<tt::TokenTree> {\n-        self.parse(ra_parser::parse_vis)\n+    pub fn parse_fragment(self, fragment_kind: FragmentKind) -> Option<tt::TokenTree> {\n+        self.parse(|token_source, tree_skink| {\n+            ra_parser::parse_fragment(token_source, tree_skink, fragment_kind)\n+        })\n     }\n \n     fn parse<F>(self, f: F) -> Option<tt::TokenTree>"}, {"sha": "a380b1cfd93bca88627ba083f5f7f5cdce1f0e20", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23", "patch": "@@ -1,4 +1,7 @@\n-use ra_parser::{ParseError, TreeSink};\n+use ra_parser::{\n+    FragmentKind::{self, *},\n+    ParseError, TreeSink,\n+};\n use ra_syntax::{\n     ast, AstNode, AstToken, NodeOrToken, Parse, SmolStr, SyntaxKind, SyntaxKind::*, SyntaxNode,\n     SyntaxTreeBuilder, TextRange, TextUnit, T,\n@@ -63,33 +66,50 @@ where\n     Ok(parse)\n }\n \n+fn fragment_to_syntax_node(\n+    tt: &tt::Subtree,\n+    fragment_kind: FragmentKind,\n+) -> Result<Parse<SyntaxNode>, ExpandError> {\n+    let tokens = [tt.clone().into()];\n+    let buffer = TokenBuffer::new(&tokens);\n+    let mut token_source = SubtreeTokenSource::new(&buffer);\n+    let mut tree_sink = TtTreeSink::new(buffer.begin());\n+    ra_parser::parse_fragment(&mut token_source, &mut tree_sink, fragment_kind);\n+    if tree_sink.roots.len() != 1 {\n+        return Err(ExpandError::ConversionError);\n+    }\n+    //FIXME: would be cool to report errors\n+    let parse = tree_sink.inner.finish();\n+    Ok(parse)\n+}\n+\n /// Parses the token tree (result of macro expansion) to an expression\n pub fn token_tree_to_expr(tt: &tt::Subtree) -> Result<Parse<ast::Expr>, ExpandError> {\n-    let parse = token_tree_to_syntax_node(tt, ra_parser::parse_expr)?;\n+    let parse = fragment_to_syntax_node(tt, Expr)?;\n     parse.cast().ok_or_else(|| crate::ExpandError::ConversionError)\n }\n \n /// Parses the token tree (result of macro expansion) to a Pattern\n pub fn token_tree_to_pat(tt: &tt::Subtree) -> Result<Parse<ast::Pat>, ExpandError> {\n-    let parse = token_tree_to_syntax_node(tt, ra_parser::parse_pat)?;\n+    let parse = fragment_to_syntax_node(tt, Pattern)?;\n     parse.cast().ok_or_else(|| crate::ExpandError::ConversionError)\n }\n \n /// Parses the token tree (result of macro expansion) to a Type\n pub fn token_tree_to_ty(tt: &tt::Subtree) -> Result<Parse<ast::TypeRef>, ExpandError> {\n-    let parse = token_tree_to_syntax_node(tt, ra_parser::parse_ty)?;\n+    let parse = fragment_to_syntax_node(tt, Type)?;\n     parse.cast().ok_or_else(|| crate::ExpandError::ConversionError)\n }\n \n /// Parses the token tree (result of macro expansion) as a sequence of stmts\n pub fn token_tree_to_macro_stmts(tt: &tt::Subtree) -> Result<Parse<ast::MacroStmts>, ExpandError> {\n-    let parse = token_tree_to_syntax_node(tt, ra_parser::parse_macro_stmts)?;\n+    let parse = fragment_to_syntax_node(tt, Statements)?;\n     parse.cast().ok_or_else(|| crate::ExpandError::ConversionError)\n }\n \n /// Parses the token tree (result of macro expansion) as a sequence of items\n pub fn token_tree_to_macro_items(tt: &tt::Subtree) -> Result<Parse<ast::MacroItems>, ExpandError> {\n-    let parse = token_tree_to_syntax_node(tt, ra_parser::parse_macro_items)?;\n+    let parse = fragment_to_syntax_node(tt, Items)?;\n     parse.cast().ok_or_else(|| crate::ExpandError::ConversionError)\n }\n "}, {"sha": "a69c006c76baf0368d101b09b224fa0fac47bfcb", "filename": "crates/ra_mbe/src/tt_cursor.rs", "status": "modified", "additions": 6, "deletions": 40, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs?ref=4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23", "patch": "@@ -1,5 +1,6 @@\n-use crate::subtree_parser::Parser;\n-use crate::ParseError;\n+use crate::{subtree_parser::Parser, ParseError};\n+\n+use ra_parser::FragmentKind;\n use smallvec::{smallvec, SmallVec};\n \n #[derive(Debug, Clone)]\n@@ -98,44 +99,9 @@ impl<'a> TtCursor<'a> {\n         })\n     }\n \n-    pub(crate) fn eat_path(&mut self) -> Option<tt::TokenTree> {\n-        let parser = Parser::new(&mut self.pos, self.subtree);\n-        parser.parse_path()\n-    }\n-\n-    pub(crate) fn eat_expr(&mut self) -> Option<tt::TokenTree> {\n-        let parser = Parser::new(&mut self.pos, self.subtree);\n-        parser.parse_expr()\n-    }\n-\n-    pub(crate) fn eat_ty(&mut self) -> Option<tt::TokenTree> {\n-        let parser = Parser::new(&mut self.pos, self.subtree);\n-        parser.parse_ty()\n-    }\n-\n-    pub(crate) fn eat_pat(&mut self) -> Option<tt::TokenTree> {\n-        let parser = Parser::new(&mut self.pos, self.subtree);\n-        parser.parse_pat()\n-    }\n-\n-    pub(crate) fn eat_stmt(&mut self) -> Option<tt::TokenTree> {\n-        let parser = Parser::new(&mut self.pos, self.subtree);\n-        parser.parse_stmt()\n-    }\n-\n-    pub(crate) fn eat_block(&mut self) -> Option<tt::TokenTree> {\n-        let parser = Parser::new(&mut self.pos, self.subtree);\n-        parser.parse_block()\n-    }\n-\n-    pub(crate) fn eat_meta(&mut self) -> Option<tt::TokenTree> {\n-        let parser = Parser::new(&mut self.pos, self.subtree);\n-        parser.parse_meta()\n-    }\n-\n-    pub(crate) fn eat_item(&mut self) -> Option<tt::TokenTree> {\n+    pub(crate) fn eat_fragment(&mut self, fragment_kind: FragmentKind) -> Option<tt::TokenTree> {\n         let parser = Parser::new(&mut self.pos, self.subtree);\n-        parser.parse_item()\n+        parser.parse_fragment(fragment_kind)\n     }\n \n     pub(crate) fn eat_lifetime(&mut self) -> Option<tt::TokenTree> {\n@@ -154,7 +120,7 @@ impl<'a> TtCursor<'a> {\n         let old_pos = self.pos;\n         let parser = Parser::new(&mut self.pos, self.subtree);\n \n-        let res = parser.parse_vis();\n+        let res = parser.parse_fragment(FragmentKind::Visibility);\n         if res.is_none() {\n             self.pos = old_pos;\n         }"}, {"sha": "d0f0dd4ac50eb318770da947316ff8a3ade8490f", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 70, "deletions": 75, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23", "patch": "@@ -49,98 +49,93 @@ pub(crate) fn root(p: &mut Parser) {\n     m.complete(p, SOURCE_FILE);\n }\n \n-pub(crate) fn macro_items(p: &mut Parser) {\n-    let m = p.start();\n-    items::mod_contents(p, false);\n-    m.complete(p, MACRO_ITEMS);\n-}\n+/// Various pieces of syntax that can be parsed by macros by example\n+pub(crate) mod fragments {\n+    use super::*;\n \n-pub(crate) fn macro_stmts(p: &mut Parser) {\n-    let m = p.start();\n-\n-    while !p.at(EOF) {\n-        if p.current() == T![;] {\n-            p.bump();\n-            continue;\n-        }\n+    pub(crate) use super::{\n+        expressions::block, paths::type_path as path, patterns::pattern, types::type_,\n+    };\n \n-        expressions::stmt(p, expressions::StmtWithSemi::Optional);\n+    pub(crate) fn expr(p: &mut Parser) {\n+        let _ = expressions::expr(p);\n     }\n \n-    m.complete(p, MACRO_STMTS);\n-}\n-\n-pub(crate) fn path(p: &mut Parser) {\n-    paths::type_path(p);\n-}\n-\n-pub(crate) fn expr(p: &mut Parser) {\n-    expressions::expr(p);\n-}\n+    pub(crate) fn stmt(p: &mut Parser) {\n+        expressions::stmt(p, expressions::StmtWithSemi::No)\n+    }\n \n-pub(crate) fn type_(p: &mut Parser) {\n-    types::type_(p)\n-}\n+    pub(crate) fn opt_visibility(p: &mut Parser) {\n+        let _ = super::opt_visibility(p);\n+    }\n \n-pub(crate) fn pattern(p: &mut Parser) {\n-    patterns::pattern(p)\n-}\n+    // Parse a meta item , which excluded [], e.g : #[ MetaItem ]\n+    pub(crate) fn meta_item(p: &mut Parser) {\n+        fn is_delimiter(p: &mut Parser) -> bool {\n+            match p.current() {\n+                T!['{'] | T!['('] | T!['['] => true,\n+                _ => false,\n+            }\n+        }\n \n-pub(crate) fn stmt(p: &mut Parser, with_semi: bool) {\n-    let with_semi =\n-        if with_semi { expressions::StmtWithSemi::Yes } else { expressions::StmtWithSemi::No };\n+        if is_delimiter(p) {\n+            items::token_tree(p);\n+            return;\n+        }\n \n-    expressions::stmt(p, with_semi)\n-}\n+        let m = p.start();\n+        while !p.at(EOF) {\n+            if is_delimiter(p) {\n+                items::token_tree(p);\n+                break;\n+            } else {\n+                // https://doc.rust-lang.org/reference/attributes.html\n+                // https://doc.rust-lang.org/reference/paths.html#simple-paths\n+                // The start of an meta must be a simple path\n+                match p.current() {\n+                    IDENT | T![::] | T![super] | T![self] | T![crate] => p.bump(),\n+                    T![=] => {\n+                        p.bump();\n+                        match p.current() {\n+                            c if c.is_literal() => p.bump(),\n+                            T![true] | T![false] => p.bump(),\n+                            _ => {}\n+                        }\n+                        break;\n+                    }\n+                    _ => break,\n+                }\n+            }\n+        }\n \n-pub(crate) fn block(p: &mut Parser) {\n-    expressions::block(p);\n-}\n+        m.complete(p, TOKEN_TREE);\n+    }\n \n-// Parse a meta item , which excluded [], e.g : #[ MetaItem ]\n-pub(crate) fn meta_item(p: &mut Parser) {\n-    fn is_delimiter(p: &mut Parser) -> bool {\n-        match p.current() {\n-            T!['{'] | T!['('] | T!['['] => true,\n-            _ => false,\n-        }\n+    pub(crate) fn item(p: &mut Parser) {\n+        items::item_or_macro(p, true, items::ItemFlavor::Mod)\n     }\n \n-    if is_delimiter(p) {\n-        items::token_tree(p);\n-        return;\n+    pub(crate) fn macro_items(p: &mut Parser) {\n+        let m = p.start();\n+        items::mod_contents(p, false);\n+        m.complete(p, MACRO_ITEMS);\n     }\n \n-    let m = p.start();\n-    while !p.at(EOF) {\n-        if is_delimiter(p) {\n-            items::token_tree(p);\n-            break;\n-        } else {\n-            // https://doc.rust-lang.org/reference/attributes.html\n-            // https://doc.rust-lang.org/reference/paths.html#simple-paths\n-            // The start of an meta must be a simple path\n-            match p.current() {\n-                IDENT | T![::] | T![super] | T![self] | T![crate] => p.bump(),\n-                T![=] => {\n-                    p.bump();\n-                    match p.current() {\n-                        c if c.is_literal() => p.bump(),\n-                        T![true] | T![false] => p.bump(),\n-                        _ => {}\n-                    }\n-                    break;\n-                }\n-                _ => break,\n+    pub(crate) fn macro_stmts(p: &mut Parser) {\n+        let m = p.start();\n+\n+        while !p.at(EOF) {\n+            if p.current() == T![;] {\n+                p.bump();\n+                continue;\n             }\n+\n+            expressions::stmt(p, expressions::StmtWithSemi::Optional);\n         }\n-    }\n \n-    m.complete(p, TOKEN_TREE);\n-}\n+        m.complete(p, MACRO_STMTS);\n+    }\n \n-pub(crate) fn item(p: &mut Parser) {\n-    items::item_or_macro(p, true, items::ItemFlavor::Mod)\n }\n \n pub(crate) fn reparser(\n@@ -180,7 +175,7 @@ impl BlockLike {\n     }\n }\n \n-pub(crate) fn opt_visibility(p: &mut Parser) -> bool {\n+fn opt_visibility(p: &mut Parser) -> bool {\n     match p.current() {\n         T![pub] => {\n             let m = p.start();"}, {"sha": "28c35a67d5f7842dd186d9bfaaa99870b93d3f76", "filename": "crates/ra_parser/src/grammar/paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23", "patch": "@@ -18,7 +18,7 @@ pub(super) fn use_path(p: &mut Parser) {\n     path(p, Mode::Use)\n }\n \n-pub(super) fn type_path(p: &mut Parser) {\n+pub(crate) fn type_path(p: &mut Parser) {\n     path(p, Mode::Type)\n }\n "}, {"sha": "32cde7de671bcde18a60398da75238cff17d9010", "filename": "crates/ra_parser/src/grammar/patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23", "patch": "@@ -4,7 +4,7 @@ pub(super) const PATTERN_FIRST: TokenSet = expressions::LITERAL_FIRST\n     .union(paths::PATH_FIRST)\n     .union(token_set![BOX_KW, REF_KW, MUT_KW, L_PAREN, L_BRACK, AMP, UNDERSCORE, MINUS]);\n \n-pub(super) fn pattern(p: &mut Parser) {\n+pub(crate) fn pattern(p: &mut Parser) {\n     pattern_r(p, PAT_RECOVERY_SET);\n }\n "}, {"sha": "9e321b2a699d09684e7fa00223d0e466453d9856", "filename": "crates/ra_parser/src/grammar/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs?ref=4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23", "patch": "@@ -7,7 +7,7 @@ pub(super) const TYPE_FIRST: TokenSet = paths::PATH_FIRST.union(token_set![\n \n const TYPE_RECOVERY_SET: TokenSet = token_set![R_PAREN, COMMA];\n \n-pub(super) fn type_(p: &mut Parser) {\n+pub(crate) fn type_(p: &mut Parser) {\n     type_with_bounds_cond(p, true);\n }\n "}, {"sha": "45241e56645a6fa0e1f0b522a625c37e7100067c", "filename": "crates/ra_parser/src/lib.rs", "status": "modified", "additions": 33, "deletions": 53, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/crates%2Fra_parser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23/crates%2Fra_parser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Flib.rs?ref=4417a97bc519d8cf658dbd2d09e1d34c8b8f1f23", "patch": "@@ -83,62 +83,42 @@ pub fn parse(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n     parse_from_tokens(token_source, tree_sink, grammar::root);\n }\n \n-/// Parse given tokens into the given sink as a path\n-pub fn parse_path(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::path);\n-}\n-\n-/// Parse given tokens into the given sink as a expression\n-pub fn parse_expr(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::expr);\n-}\n-\n-/// Parse given tokens into the given sink as a ty\n-pub fn parse_ty(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::type_);\n-}\n-\n-/// Parse given tokens into the given sink as a pattern\n-pub fn parse_pat(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::pattern);\n-}\n-\n-/// Parse given tokens into the given sink as a statement\n-pub fn parse_stmt(\n+pub enum FragmentKind {\n+    Path,\n+    Expr,\n+    Statement,\n+    Type,\n+    Pattern,\n+    Item,\n+    Block,\n+    Visibility,\n+    MetaItem,\n+\n+    // These kinds are used when parsing the result of expansion\n+    // FIXME: use separate fragment kinds for macro inputs and outputs?\n+    Items,\n+    Statements,\n+}\n+\n+pub fn parse_fragment(\n     token_source: &mut dyn TokenSource,\n     tree_sink: &mut dyn TreeSink,\n-    with_semi: bool,\n+    fragment_kind: FragmentKind,\n ) {\n-    parse_from_tokens(token_source, tree_sink, |p| grammar::stmt(p, with_semi));\n-}\n-\n-/// Parse given tokens into the given sink as a block\n-pub fn parse_block(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::block);\n-}\n-\n-pub fn parse_meta(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::meta_item);\n-}\n-\n-/// Parse given tokens into the given sink as an item\n-pub fn parse_item(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::item);\n-}\n-\n-/// Parse given tokens into the given sink as an visibility qualifier\n-pub fn parse_vis(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, |p| {\n-        grammar::opt_visibility(p);\n-    });\n-}\n-\n-pub fn parse_macro_items(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::macro_items);\n-}\n-\n-pub fn parse_macro_stmts(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::macro_stmts);\n+    let parser: fn(&'_ mut parser::Parser) = match fragment_kind {\n+        FragmentKind::Path => grammar::fragments::path,\n+        FragmentKind::Expr => grammar::fragments::expr,\n+        FragmentKind::Type => grammar::fragments::type_,\n+        FragmentKind::Pattern => grammar::fragments::pattern,\n+        FragmentKind::Item => grammar::fragments::item,\n+        FragmentKind::Block => grammar::fragments::block,\n+        FragmentKind::Visibility => grammar::fragments::opt_visibility,\n+        FragmentKind::MetaItem => grammar::fragments::meta_item,\n+        FragmentKind::Statement => grammar::fragments::stmt,\n+        FragmentKind::Items => grammar::fragments::macro_items,\n+        FragmentKind::Statements => grammar::fragments::macro_stmts,\n+    };\n+    parse_from_tokens(token_source, tree_sink, parser)\n }\n \n /// A parsing function for a specific braced-block."}]}