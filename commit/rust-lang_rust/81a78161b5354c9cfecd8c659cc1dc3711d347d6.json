{"sha": "81a78161b5354c9cfecd8c659cc1dc3711d347d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxYTc4MTYxYjUzNTRjOWNmZWNkOGM2NTljYzFkYzM3MTFkMzQ3ZDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-19T11:32:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-19T11:32:04Z"}, "message": "auto merge of #8535 : nikomatsakis/rust/issue-3678-wrappers-be-gone-2, r=graydon\n\nLong-standing branch to remove foreign function wrappers altogether. Calls to C functions are done \"in place\" with no stack manipulation; the scheme relies entirely on the correct use of `#[fixed_stack_segment]` to guarantee adequate stack space. A linter is added to detect when `#[fixed_stack_segment]` annotations are missing. An `externfn!` macro is added to make it easier to declare foreign fns and wrappers in one go: this macro may need some refinement, though, for example it might be good to be able to declare a group of foreign fns. I leave that for future work (hopefully somebody else's work :) ).\r\n\r\nFixes #3678.", "tree": {"sha": "be212089ce62d2909018cf36d7c3aa563b886d94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be212089ce62d2909018cf36d7c3aa563b886d94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81a78161b5354c9cfecd8c659cc1dc3711d347d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81a78161b5354c9cfecd8c659cc1dc3711d347d6", "html_url": "https://github.com/rust-lang/rust/commit/81a78161b5354c9cfecd8c659cc1dc3711d347d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81a78161b5354c9cfecd8c659cc1dc3711d347d6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e4f40ec5aee04c0e5386153644255b6beeba095", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e4f40ec5aee04c0e5386153644255b6beeba095", "html_url": "https://github.com/rust-lang/rust/commit/3e4f40ec5aee04c0e5386153644255b6beeba095"}, {"sha": "0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "html_url": "https://github.com/rust-lang/rust/commit/0479d946c83cf9ed90bba5b33820ea4118dd8f9e"}], "stats": {"total": 4181, "additions": 2558, "deletions": 1623}, "files": [{"sha": "278273b16719321c17b5be3445f140ec12e1a5c5", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -19,6 +19,7 @@ extern {\n     fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n }\n \n+#[fixed_stack_segment]\n fn main() {\n     let x = unsafe { snappy_max_compressed_length(100) };\n     println(fmt!(\"max compressed length of a 100 byte buffer: %?\", x));\n@@ -35,6 +36,11 @@ interfaces that aren't thread-safe, and almost any function that takes a pointer\n valid for all possible inputs since the pointer could be dangling, and raw pointers fall outside of\n Rust's safe memory model.\n \n+Finally, the `#[fixed_stack_segment]` annotation that appears on\n+`main()` instructs the Rust compiler that when `main()` executes, it\n+should request a \"very large\" stack segment.  More details on\n+stack management can be found in the following sections.\n+\n When declaring the argument types to a foreign function, the Rust compiler will not check if the\n declaration is correct, so specifying it correctly is part of keeping the binding correct at\n runtime.\n@@ -75,6 +81,8 @@ length is number of elements currently contained, and the capacity is the total\n the allocated memory. The length is less than or equal to the capacity.\n \n ~~~~ {.xfail-test}\n+#[fixed_stack_segment]\n+#[inline(never)]\n pub fn validate_compressed_buffer(src: &[u8]) -> bool {\n     unsafe {\n         snappy_validate_compressed_buffer(vec::raw::to_ptr(src), src.len() as size_t) == 0\n@@ -86,6 +94,36 @@ The `validate_compressed_buffer` wrapper above makes use of an `unsafe` block, b\n guarantee that calling it is safe for all inputs by leaving off `unsafe` from the function\n signature.\n \n+The `validate_compressed_buffer` wrapper is also annotated with two\n+attributes `#[fixed_stack_segment]` and `#[inline(never)]`. The\n+purpose of these attributes is to guarantee that there will be\n+sufficient stack for the C function to execute. This is necessary\n+because Rust, unlike C, does not assume that the stack is allocated in\n+one continuous chunk. Instead, we rely on a *segmented stack* scheme,\n+in which the stack grows and shrinks as necessary.  C code, however,\n+expects one large stack, and so callers of C functions must request a\n+large stack segment to ensure that the C routine will not run off the\n+end of the stack.\n+\n+The compiler includes a lint mode that will report an error if you\n+call a C function without a `#[fixed_stack_segment]` attribute. More\n+details on the lint mode are given in a later section.\n+\n+You may be wondering why we include a `#[inline(never)]` directive.\n+This directive informs the compiler never to inline this function.\n+While not strictly necessary, it is usually a good idea to use an\n+`#[inline(never)]` directive in concert with `#[fixed_stack_segment]`.\n+The reason is that if a fn annotated with `fixed_stack_segment` is\n+inlined, then its caller also inherits the `fixed_stack_segment`\n+annotation. This means that rather than requesting a large stack\n+segment only for the duration of the call into C, the large stack\n+segment would be used for the entire duration of the caller. This is\n+not necessarily *bad* -- it can for example be more efficient,\n+particularly if `validate_compressed_buffer()` is called multiple\n+times in a row -- but it does work against the purpose of the\n+segmented stack scheme, which is to keep stacks small and thus\n+conserve address space.\n+\n The `snappy_compress` and `snappy_uncompress` functions are more complex, since a buffer has to be\n allocated to hold the output too.\n \n@@ -96,6 +134,8 @@ the true length after compression for setting the length.\n \n ~~~~ {.xfail-test}\n pub fn compress(src: &[u8]) -> ~[u8] {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    \n     unsafe {\n         let srclen = src.len() as size_t;\n         let psrc = vec::raw::to_ptr(src);\n@@ -116,6 +156,8 @@ format and `snappy_uncompressed_length` will retrieve the exact buffer size requ\n \n ~~~~ {.xfail-test}\n pub fn uncompress(src: &[u8]) -> Option<~[u8]> {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    \n     unsafe {\n         let srclen = src.len() as size_t;\n         let psrc = vec::raw::to_ptr(src);\n@@ -139,6 +181,99 @@ pub fn uncompress(src: &[u8]) -> Option<~[u8]> {\n For reference, the examples used here are also available as an [library on\n GitHub](https://github.com/thestinger/rust-snappy).\n \n+# Automatic wrappers\n+\n+Sometimes writing Rust wrappers can be quite tedious.  For example, if\n+function does not take any pointer arguments, often there is no need\n+for translating types. In such cases, it is usually still a good idea\n+to have a Rust wrapper so as to manage the segmented stacks, but you\n+can take advantage of the (standard) `externfn!` macro to remove some\n+of the tedium.\n+\n+In the initial section, we showed an extern block that added a call\n+to a specific snappy API:\n+\n+~~~~ {.xfail-test}\n+use std::libc::size_t;\n+\n+#[link_args = \"-lsnappy\"]\n+extern {\n+    fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n+}\n+\n+#[fixed_stack_segment]\n+fn main() {\n+    let x = unsafe { snappy_max_compressed_length(100) };\n+    println(fmt!(\"max compressed length of a 100 byte buffer: %?\", x));\n+}\n+~~~~\n+\n+To avoid the need to create a wrapper fn for `snappy_max_compressed_length()`,\n+and also to avoid the need to think about `#[fixed_stack_segment]`, we\n+could simply use the `externfn!` macro instead, as shown here:\n+\n+~~~~ {.xfail-test}\n+use std::libc::size_t;\n+\n+externfn!(#[link_args = \"-lsnappy\"]\n+          fn snappy_max_compressed_length(source_length: size_t) -> size_t)\n+\n+fn main() {\n+    let x = unsafe { snappy_max_compressed_length(100) };\n+    println(fmt!(\"max compressed length of a 100 byte buffer: %?\", x));\n+}\n+~~~~\n+\n+As you can see from the example, `externfn!` replaces the extern block\n+entirely. After macro expansion, it will create something like this:\n+\n+~~~~ {.xfail-test}\n+use std::libc::size_t;\n+\n+// Automatically generated by\n+//   externfn!(#[link_args = \"-lsnappy\"]\n+//             fn snappy_max_compressed_length(source_length: size_t) -> size_t)\n+unsafe fn snappy_max_compressed_length(source_length: size_t) -> size_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return snappy_max_compressed_length(source_length);\n+    \n+    #[link_args = \"-lsnappy\"]\n+    extern {\n+        fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n+    }\n+}\n+\n+fn main() {\n+    let x = unsafe { snappy_max_compressed_length(100) };\n+    println(fmt!(\"max compressed length of a 100 byte buffer: %?\", x));\n+}\n+~~~~\n+\n+# Segmented stacks and the linter\n+\n+By default, whenever you invoke a non-Rust fn, the `cstack` lint will\n+check that one of the following conditions holds:\n+\n+1. The call occurs inside of a fn that has been annotated with\n+   `#[fixed_stack_segment]`;\n+2. The call occurs inside of an `extern fn`;\n+3. The call occurs within a stack closure created by some other\n+   safe fn.\n+   \n+All of these conditions ensure that you are running on a large stack\n+segmented. However, they are sometimes too strict. If your application\n+will be making many calls into C, it is often beneficial to promote\n+the `#[fixed_stack_segment]` attribute higher up the call chain.  For\n+example, the Rust compiler actually labels main itself as requiring a\n+`#[fixed_stack_segment]`. In such cases, the linter is just an\n+annoyance, because all C calls that occur from within the Rust\n+compiler are made on a large stack. Another situation where this\n+frequently occurs is on a 64-bit architecture, where large stacks are\n+the default. In cases, you can disable the linter by including a\n+`#[allow(cstack)]` directive somewhere, which permits violations of\n+the \"cstack\" rules given above (you can also use `#[warn(cstack)]` to\n+convert the errors into warnings, if you prefer).\n+\n # Destructors\n \n Foreign libraries often hand off ownership of resources to the calling code,\n@@ -161,6 +296,9 @@ pub struct Unique<T> {\n \n impl<T: Send> Unique<T> {\n     pub fn new(value: T) -> Unique<T> {\n+        #[fixed_stack_segment];\n+        #[inline(never)];\n+        \n         unsafe {\n             let ptr = malloc(std::sys::size_of::<T>() as size_t) as *mut T;\n             assert!(!ptr::is_null(ptr));\n@@ -184,6 +322,9 @@ impl<T: Send> Unique<T> {\n #[unsafe_destructor]\n impl<T: Send> Drop for Unique<T> {\n     fn drop(&self) {\n+        #[fixed_stack_segment];\n+        #[inline(never)];\n+        \n         unsafe {\n             let x = intrinsics::init(); // dummy value to swap in\n             // moving the object out is needed to call the destructor"}, {"sha": "9e1504aad2a5625ebda57cb59fd429ff3153f92f", "filename": "src/libextra/c_vec.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibextra%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibextra%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fc_vec.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -155,12 +155,20 @@ mod tests {\n     use std::libc;\n \n     fn malloc(n: size_t) -> CVec<u8> {\n+        #[fixed_stack_segment];\n+        #[inline(never)];\n+\n         unsafe {\n             let mem = libc::malloc(n);\n \n             assert!(mem as int != 0);\n \n-            c_vec_with_dtor(mem as *mut u8, n as uint, || free(mem))\n+            return c_vec_with_dtor(mem as *mut u8, n as uint, || f(mem));\n+        }\n+\n+        fn f(mem: *c_void) {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe { libc::free(mem) }\n         }\n     }\n "}, {"sha": "530885001292c51d77d5b0df33ba1cb21c42d452", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -47,6 +47,8 @@ static TINFL_FLAG_PARSE_ZLIB_HEADER : c_int = 0x1; // parse zlib header and adle\n static TDEFL_WRITE_ZLIB_HEADER : c_int = 0x01000; // write zlib header and adler32 checksum\n \n fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     do bytes.as_imm_buf |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n@@ -73,6 +75,8 @@ pub fn deflate_bytes_zlib(bytes: &[u8]) -> ~[u8] {\n }\n \n fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     do bytes.as_imm_buf |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;"}, {"sha": "db87cf94641bb59290ffb1b3fb598db6426caee7", "filename": "src/libextra/rl.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -19,15 +19,25 @@ use std::str;\n pub mod rustrt {\n     use std::libc::{c_char, c_int};\n \n-    extern {\n-        pub fn linenoise(prompt: *c_char) -> *c_char;\n-        pub fn linenoiseHistoryAdd(line: *c_char) -> c_int;\n-        pub fn linenoiseHistorySetMaxLen(len: c_int) -> c_int;\n-        pub fn linenoiseHistorySave(file: *c_char) -> c_int;\n-        pub fn linenoiseHistoryLoad(file: *c_char) -> c_int;\n-        pub fn linenoiseSetCompletionCallback(callback: *u8);\n-        pub fn linenoiseAddCompletion(completions: *(), line: *c_char);\n+    #[cfg(stage0)]\n+    mod macro_hack {\n+    #[macro_escape];\n+    macro_rules! externfn(\n+        (fn $name:ident ($($arg_name:ident : $arg_ty:ty),*) $(-> $ret_ty:ty),*) => (\n+            extern {\n+                fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),*;\n+            }\n+        )\n+    )\n     }\n+\n+    externfn!(fn linenoise(prompt: *c_char) -> *c_char)\n+    externfn!(fn linenoiseHistoryAdd(line: *c_char) -> c_int)\n+    externfn!(fn linenoiseHistorySetMaxLen(len: c_int) -> c_int)\n+    externfn!(fn linenoiseHistorySave(file: *c_char) -> c_int)\n+    externfn!(fn linenoiseHistoryLoad(file: *c_char) -> c_int)\n+    externfn!(fn linenoiseSetCompletionCallback(callback: *u8))\n+    externfn!(fn linenoiseAddCompletion(completions: *(), line: *c_char))\n }\n \n /// Add a line to history\n@@ -84,7 +94,7 @@ pub unsafe fn complete(cb: CompletionCb) {\n                         rustrt::linenoiseAddCompletion(completions, buf);\n                     }\n                 }\n-}\n+            }\n         }\n     }\n "}, {"sha": "75d00f9ea5999cdf2793c32d89f386bee73fa27f", "filename": "src/libextra/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -188,6 +188,8 @@ fn optgroups() -> ~[getopts::groups::OptGroup] {\n }\n \n fn usage(binary: &str, helpstr: &str) -> ! {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let message = fmt!(\"Usage: %s [OPTIONS] [FILTER]\", binary);\n     println(groups::usage(message, optgroups()));\n     println(\"\");"}, {"sha": "ab35bf2386ca4d89ed9345c7004ff4a2f5ce182f", "filename": "src/libextra/time.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -64,6 +64,8 @@ impl Ord for Timespec {\n  * nanoseconds since 1970-01-01T00:00:00Z.\n  */\n pub fn get_time() -> Timespec {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         let mut sec = 0i64;\n         let mut nsec = 0i32;\n@@ -78,6 +80,8 @@ pub fn get_time() -> Timespec {\n  * in nanoseconds since an unspecified epoch.\n  */\n pub fn precise_time_ns() -> u64 {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         let mut ns = 0u64;\n         rustrt::precise_time_ns(&mut ns);\n@@ -95,6 +99,8 @@ pub fn precise_time_s() -> float {\n }\n \n pub fn tzset() {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         rustrt::rust_tzset();\n     }\n@@ -135,6 +141,8 @@ pub fn empty_tm() -> Tm {\n \n /// Returns the specified time in UTC\n pub fn at_utc(clock: Timespec) -> Tm {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         let Timespec { sec, nsec } = clock;\n         let mut tm = empty_tm();\n@@ -150,6 +158,8 @@ pub fn now_utc() -> Tm {\n \n /// Returns the specified time in the local timezone\n pub fn at(clock: Timespec) -> Tm {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         let Timespec { sec, nsec } = clock;\n         let mut tm = empty_tm();\n@@ -176,6 +186,8 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n impl Tm {\n     /// Convert time to the seconds from January 1, 1970\n     pub fn to_timespec(&self) -> Timespec {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             let sec = match self.tm_gmtoff {\n                 0_i32 => rustrt::rust_timegm(self),"}, {"sha": "d010f7d52d8a82dc05dd2c996f5b7b7c53f82922", "filename": "src/librust/rust.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrust%2Frust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrust%2Frust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -229,6 +229,8 @@ fn usage() {\n }\n \n pub fn main() {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let os_args = os::args();\n \n     if (os_args.len() > 1 && (os_args[1] == ~\"-v\" || os_args[1] == ~\"--version\")) {"}, {"sha": "0ad53c4d49c1a14ed20222222d42d296bf89163b", "filename": "src/librustc/back/upcall.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fupcall.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -16,8 +16,6 @@ use lib::llvm::{ModuleRef, ValueRef};\n \n pub struct Upcalls {\n     trace: ValueRef,\n-    call_shim_on_c_stack: ValueRef,\n-    call_shim_on_rust_stack: ValueRef,\n     rust_personality: ValueRef,\n     reset_stack_limit: ValueRef\n }\n@@ -47,9 +45,6 @@ pub fn declare_upcalls(targ_cfg: @session::config, llmod: ModuleRef) -> @Upcalls\n \n     @Upcalls {\n         trace: upcall!(fn trace(opaque_ptr, opaque_ptr, int_ty) -> Type::void()),\n-        call_shim_on_c_stack: upcall!(fn call_shim_on_c_stack(opaque_ptr, opaque_ptr) -> int_ty),\n-        call_shim_on_rust_stack:\n-            upcall!(fn call_shim_on_rust_stack(opaque_ptr, opaque_ptr) -> int_ty),\n         rust_personality: upcall!(nothrow fn rust_personality -> Type::i32()),\n         reset_stack_limit: upcall!(nothrow fn reset_stack_limit -> Type::void())\n     }"}, {"sha": "cdafb7400e1a294e4e6fd9c3061f56bc64ed2fe7", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -265,6 +265,9 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     time(time_passes, ~\"loop checking\", ||\n          middle::check_loop::check_crate(ty_cx, crate));\n \n+    time(time_passes, ~\"stack checking\", ||\n+         middle::stack_check::stack_check_crate(ty_cx, crate));\n+\n     let middle::moves::MoveMaps {moves_map, moved_variables_set,\n                                  capture_map} =\n         time(time_passes, ~\"compute moves\", ||\n@@ -642,9 +645,13 @@ pub fn build_session_options(binary: @str,\n         }\n         debugging_opts |= this_bit;\n     }\n+\n     if debugging_opts & session::debug_llvm != 0 {\n-        unsafe {\n-            llvm::LLVMSetDebug(1);\n+        set_llvm_debug();\n+\n+        fn set_llvm_debug() {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe { llvm::LLVMSetDebug(1); }\n         }\n     }\n "}, {"sha": "9175c13c8aeebbd2940d143aef154ac4980ff163", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -8,6 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// LLVM wrappers are intended to be called from trans,\n+// which already runs in a #[fixed_stack_segment]\n+#[allow(cstack)];\n+\n use std::c_str::ToCStr;\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ushort};\n@@ -2246,6 +2250,11 @@ impl TypeNames {\n         self.type_to_str_depth(ty, 30)\n     }\n \n+    pub fn types_to_str(&self, tys: &[Type]) -> ~str {\n+        let strs = tys.map(|t| self.type_to_str(*t));\n+        fmt!(\"[%s]\", strs.connect(\",\"))\n+    }\n+\n     pub fn val_to_str(&self, val: ValueRef) -> ~str {\n         unsafe {\n             let ty = Type::from_ref(llvm::LLVMTypeOf(val));"}, {"sha": "880095db2ee1de151d90f41d4bde0efa81aa24e2", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -73,6 +73,7 @@ use syntax::{ast, oldvisit, ast_util, visit};\n #[deriving(Clone, Eq)]\n pub enum lint {\n     ctypes,\n+    cstack,\n     unused_imports,\n     unnecessary_qualification,\n     while_true,\n@@ -146,6 +147,13 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         default: warn\n      }),\n \n+    (\"cstack\",\n+     LintSpec {\n+        lint: cstack,\n+        desc: \"only invoke foreign functions from fixedstacksegment fns\",\n+        default: deny\n+     }),\n+\n     (\"unused_imports\",\n      LintSpec {\n         lint: unused_imports,"}, {"sha": "8837a9461edf4792bf0988af8c28ccc9fa38123e", "filename": "src/librustc/middle/stack_check.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstack_check.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -0,0 +1,159 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Lint mode to detect cases where we call non-Rust fns, which do not\n+have a stack growth check, from locations not annotated to request\n+large stacks.\n+\n+*/\n+\n+use middle::lint;\n+use middle::ty;\n+use syntax::ast;\n+use syntax::ast_map;\n+use syntax::attr;\n+use syntax::codemap::span;\n+use visit = syntax::oldvisit;\n+use util::ppaux::Repr;\n+\n+#[deriving(Clone)]\n+struct Context {\n+    tcx: ty::ctxt,\n+    safe_stack: bool\n+}\n+\n+pub fn stack_check_crate(tcx: ty::ctxt,\n+                         crate: &ast::Crate) {\n+    let new_cx = Context {\n+        tcx: tcx,\n+        safe_stack: false\n+    };\n+    let visitor = visit::mk_vt(@visit::Visitor {\n+        visit_item: stack_check_item,\n+        visit_fn: stack_check_fn,\n+        visit_expr: stack_check_expr,\n+        ..*visit::default_visitor()\n+    });\n+    visit::visit_crate(crate, (new_cx, visitor));\n+}\n+\n+fn stack_check_item(item: @ast::item,\n+                    (in_cx, v): (Context, visit::vt<Context>)) {\n+    match item.node {\n+        ast::item_fn(_, ast::extern_fn, _, _, _) => {\n+            // an extern fn is already being called from C code...\n+            let new_cx = Context {safe_stack: true, ..in_cx};\n+            visit::visit_item(item, (new_cx, v));\n+        }\n+        ast::item_fn(*) => {\n+            let safe_stack = fixed_stack_segment(item.attrs);\n+            let new_cx = Context {safe_stack: safe_stack, ..in_cx};\n+            visit::visit_item(item, (new_cx, v));\n+        }\n+        ast::item_impl(_, _, _, ref methods) => {\n+            // visit_method() would make this nicer\n+            for &method in methods.iter() {\n+                let safe_stack = fixed_stack_segment(method.attrs);\n+                let new_cx = Context {safe_stack: safe_stack, ..in_cx};\n+                visit::visit_method_helper(method, (new_cx, v));\n+            }\n+        }\n+        _ => {\n+            visit::visit_item(item, (in_cx, v));\n+        }\n+    }\n+\n+    fn fixed_stack_segment(attrs: &[ast::Attribute]) -> bool {\n+        attr::contains_name(attrs, \"fixed_stack_segment\")\n+    }\n+}\n+\n+fn stack_check_fn<'a>(fk: &visit::fn_kind,\n+                      decl: &ast::fn_decl,\n+                      body: &ast::Block,\n+                      sp: span,\n+                      id: ast::NodeId,\n+                      (in_cx, v): (Context, visit::vt<Context>)) {\n+    let safe_stack = match *fk {\n+        visit::fk_method(*) | visit::fk_item_fn(*) => {\n+            in_cx.safe_stack // see stack_check_item above\n+        }\n+        visit::fk_anon(*) | visit::fk_fn_block => {\n+            match ty::get(ty::node_id_to_type(in_cx.tcx, id)).sty {\n+                ty::ty_bare_fn(*) |\n+                ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, _}) |\n+                ty::ty_closure(ty::ClosureTy {sigil: ast::ManagedSigil, _}) => {\n+                    false\n+                }\n+                _ => {\n+                    in_cx.safe_stack\n+                }\n+            }\n+        }\n+    };\n+    let new_cx = Context {safe_stack: safe_stack, ..in_cx};\n+    debug!(\"stack_check_fn(safe_stack=%b, id=%?)\", safe_stack, id);\n+    visit::visit_fn(fk, decl, body, sp, id, (new_cx, v));\n+}\n+\n+fn stack_check_expr<'a>(expr: @ast::expr,\n+                        (cx, v): (Context, visit::vt<Context>)) {\n+    debug!(\"stack_check_expr(safe_stack=%b, expr=%s)\",\n+           cx.safe_stack, expr.repr(cx.tcx));\n+    if !cx.safe_stack {\n+        match expr.node {\n+            ast::expr_call(callee, _, _) => {\n+                let callee_ty = ty::expr_ty(cx.tcx, callee);\n+                debug!(\"callee_ty=%s\", callee_ty.repr(cx.tcx));\n+                match ty::get(callee_ty).sty {\n+                    ty::ty_bare_fn(ref fty) => {\n+                        if !fty.abis.is_rust() && !fty.abis.is_intrinsic() {\n+                            call_to_extern_fn(cx, callee);\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+    visit::visit_expr(expr, (cx, v));\n+}\n+\n+fn call_to_extern_fn(cx: Context, callee: @ast::expr) {\n+    // Permit direct calls to extern fns that are annotated with\n+    // #[rust_stack]. This is naturally a horrible pain to achieve.\n+    match callee.node {\n+        ast::expr_path(*) => {\n+            match cx.tcx.def_map.find(&callee.id) {\n+                Some(&ast::def_fn(id, _)) if id.crate == ast::LOCAL_CRATE => {\n+                    match cx.tcx.items.find(&id.node) {\n+                        Some(&ast_map::node_foreign_item(item, _, _, _)) => {\n+                            if attr::contains_name(item.attrs, \"rust_stack\") {\n+                                return;\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    cx.tcx.sess.add_lint(lint::cstack,\n+                         callee.id,\n+                         callee.span,\n+                         fmt!(\"invoking non-Rust fn in fn without \\\n+                              #[fixed_stack_segment]\"));\n+}"}, {"sha": "88fc02ca83c66f34abced2d083e0c9bb0b901a8b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 42, "deletions": 37, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -203,28 +203,28 @@ pub fn decl_internal_cdecl_fn(llmod: ModuleRef, name: &str, ty: Type) -> ValueRe\n     return llfn;\n }\n \n-pub fn get_extern_fn(externs: &mut ExternMap, llmod: ModuleRef, name: @str,\n+pub fn get_extern_fn(externs: &mut ExternMap, llmod: ModuleRef, name: &str,\n                      cc: lib::llvm::CallConv, ty: Type) -> ValueRef {\n-    match externs.find_copy(&name) {\n-        Some(n) => return n,\n+    match externs.find_equiv(&name) {\n+        Some(n) => return *n,\n         None => ()\n     }\n     let f = decl_fn(llmod, name, cc, ty);\n-    externs.insert(name, f);\n+    externs.insert(name.to_owned(), f);\n     return f;\n }\n \n pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n-                        name: @str, ty: Type) -> ValueRef {\n-    match externs.find_copy(&name) {\n-        Some(n) => return n,\n+                        name: &str, ty: Type) -> ValueRef {\n+    match externs.find_equiv(&name) {\n+        Some(n) => return *n,\n         None => ()\n     }\n     unsafe {\n         let c = do name.with_c_str |buf| {\n             llvm::LLVMAddGlobal(llmod, ty.to_ref(), buf)\n         };\n-        externs.insert(name, c);\n+        externs.insert(name.to_owned(), c);\n         return c;\n     }\n }\n@@ -511,7 +511,6 @@ pub fn get_res_dtor(ccx: @mut CrateContext,\n                                      None,\n                                      ty::lookup_item_type(tcx, parent_id).ty);\n         let llty = type_of_dtor(ccx, class_ty);\n-        let name = name.to_managed(); // :-(\n         get_extern_fn(&mut ccx.externs,\n                       ccx.llmod,\n                       name,\n@@ -798,13 +797,13 @@ pub fn fail_if_zero(cx: @mut Block, span: span, divrem: ast::binop,\n     }\n }\n \n-pub fn null_env_ptr(bcx: @mut Block) -> ValueRef {\n-    C_null(Type::opaque_box(bcx.ccx()).ptr_to())\n+pub fn null_env_ptr(ccx: &CrateContext) -> ValueRef {\n+    C_null(Type::opaque_box(ccx).ptr_to())\n }\n \n pub fn trans_external_path(ccx: &mut CrateContext, did: ast::def_id, t: ty::t)\n     -> ValueRef {\n-    let name = csearch::get_symbol(ccx.sess.cstore, did).to_managed(); // Sad\n+    let name = csearch::get_symbol(ccx.sess.cstore, did);\n     match ty::get(t).sty {\n       ty::ty_bare_fn(_) | ty::ty_closure(_) => {\n         let llty = type_of_fn_from_ty(ccx, t);\n@@ -1572,7 +1571,7 @@ pub fn mk_return_basic_block(llfn: ValueRef) -> BasicBlockRef {\n // slot where the return value of the function must go.\n pub fn make_return_pointer(fcx: @mut FunctionContext, output_type: ty::t) -> ValueRef {\n     unsafe {\n-        if !ty::type_is_immediate(fcx.ccx.tcx, output_type) {\n+        if type_of::return_uses_outptr(fcx.ccx.tcx, output_type) {\n             llvm::LLVMGetParam(fcx.llfn, 0)\n         } else {\n             let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n@@ -1612,7 +1611,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n             ty::subst_tps(ccx.tcx, substs.tys, substs.self_ty, output_type)\n         }\n     };\n-    let is_immediate = ty::type_is_immediate(ccx.tcx, substd_output_type);\n+    let uses_outptr = type_of::return_uses_outptr(ccx.tcx, substd_output_type);\n     let fcx = @mut FunctionContext {\n           llfn: llfndecl,\n           llenv: unsafe {\n@@ -1624,7 +1623,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n           llreturn: None,\n           llself: None,\n           personality: None,\n-          has_immediate_return_value: is_immediate,\n+          caller_expects_out_pointer: uses_outptr,\n           llargs: @mut HashMap::new(),\n           lllocals: @mut HashMap::new(),\n           llupvars: @mut HashMap::new(),\n@@ -1647,8 +1646,15 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n         fcx.alloca_insert_pt = Some(llvm::LLVMGetFirstInstruction(entry_bcx.llbb));\n     }\n \n-    if !ty::type_is_nil(substd_output_type) && !(is_immediate && skip_retptr) {\n-        fcx.llretptr = Some(make_return_pointer(fcx, substd_output_type));\n+    if !ty::type_is_voidish(substd_output_type) {\n+        // If the function returns nil/bot, there is no real return\n+        // value, so do not set `llretptr`.\n+        if !skip_retptr || uses_outptr {\n+            // Otherwise, we normally allocate the llretptr, unless we\n+            // have been instructed to skip it for immediate return\n+            // values.\n+            fcx.llretptr = Some(make_return_pointer(fcx, substd_output_type));\n+        }\n     }\n     fcx\n }\n@@ -1796,7 +1802,7 @@ pub fn finish_fn(fcx: @mut FunctionContext, last_bcx: @mut Block) {\n // Builds the return block for a function.\n pub fn build_return_block(fcx: &FunctionContext, ret_cx: @mut Block) {\n     // Return the value if this function immediate; otherwise, return void.\n-    if fcx.llretptr.is_none() || !fcx.has_immediate_return_value {\n+    if fcx.llretptr.is_none() || fcx.caller_expects_out_pointer {\n         return RetVoid(ret_cx);\n     }\n \n@@ -1882,9 +1888,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n     // translation calls that don't have a return value (trans_crate,\n     // trans_mod, trans_item, et cetera) and those that do\n     // (trans_block, trans_expr, et cetera).\n-    if body.expr.is_none() || ty::type_is_bot(block_ty) ||\n-        ty::type_is_nil(block_ty)\n-    {\n+    if body.expr.is_none() || ty::type_is_voidish(block_ty) {\n         bcx = controlflow::trans_block(bcx, body, expr::Ignore);\n     } else {\n         let dest = expr::SaveIn(fcx.llretptr.unwrap());\n@@ -2129,13 +2133,14 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n       ast::item_fn(ref decl, purity, _abis, ref generics, ref body) => {\n         if purity == ast::extern_fn  {\n             let llfndecl = get_item_val(ccx, item.id);\n-            foreign::trans_foreign_fn(ccx,\n-                                      vec::append((*path).clone(),\n-                                                  [path_name(item.ident)]),\n-                                      decl,\n-                                      body,\n-                                      llfndecl,\n-                                      item.id);\n+            foreign::trans_rust_fn_with_foreign_abi(\n+                ccx,\n+                &vec::append((*path).clone(),\n+                             [path_name(item.ident)]),\n+                decl,\n+                body,\n+                llfndecl,\n+                item.id);\n         } else if !generics.is_type_parameterized() {\n             let llfndecl = get_item_val(ccx, item.id);\n             trans_fn(ccx,\n@@ -2196,7 +2201,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n           }\n       },\n       ast::item_foreign_mod(ref foreign_mod) => {\n-        foreign::trans_foreign_mod(ccx, path, foreign_mod);\n+        foreign::trans_foreign_mod(ccx, foreign_mod);\n       }\n       ast::item_struct(struct_def, ref generics) => {\n         if !generics.is_type_parameterized() {\n@@ -2291,16 +2296,15 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n \n     fn create_main(ccx: @mut CrateContext, main_llfn: ValueRef) -> ValueRef {\n         let nt = ty::mk_nil();\n-\n-        let llfty = type_of_fn(ccx, [], nt);\n+        let llfty = type_of_rust_fn(ccx, [], nt);\n         let llfdecl = decl_fn(ccx.llmod, \"_rust_main\",\n                               lib::llvm::CCallConv, llfty);\n \n         let fcx = new_fn_ctxt(ccx, ~[], llfdecl, nt, None);\n \n         // the args vector built in create_entry_fn will need\n         // be updated if this assertion starts to fail.\n-        assert!(fcx.has_immediate_return_value);\n+        assert!(!fcx.caller_expects_out_pointer);\n \n         let bcx = fcx.entry_bcx.unwrap();\n         // Call main.\n@@ -2463,7 +2467,10 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             let llfn = if purity != ast::extern_fn {\n                                 register_fn(ccx, i.span, sym, i.id, ty)\n                             } else {\n-                                foreign::register_foreign_fn(ccx, i.span, sym, i.id)\n+                                foreign::register_rust_fn_with_foreign_abi(ccx,\n+                                                                           i.span,\n+                                                                           sym,\n+                                                                           i.id)\n                             };\n                             set_inline_hint_if_appr(i.attrs, llfn);\n                             llfn\n@@ -2502,16 +2509,14 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                     register_method(ccx, id, pth, m)\n                 }\n \n-                ast_map::node_foreign_item(ni, _, _, pth) => {\n+                ast_map::node_foreign_item(ni, abis, _, pth) => {\n                     let ty = ty::node_id_to_type(ccx.tcx, ni.id);\n                     exprt = true;\n \n                     match ni.node {\n                         ast::foreign_item_fn(*) => {\n                             let path = vec::append((*pth).clone(), [path_name(ni.ident)]);\n-                            let sym = exported_name(ccx, path, ty, ni.attrs);\n-\n-                            register_fn(ccx, ni.span, sym, ni.id, ty)\n+                            foreign::register_foreign_item_fn(ccx, abis, &path, ni)\n                         }\n                         ast::foreign_item_static(*) => {\n                             let ident = token::ident_to_str(&ni.ident);"}, {"sha": "005483a075f8df31145a6fc14e80ba2794fb7e4a", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 35, "deletions": 150, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -8,169 +8,54 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use lib::llvm::{llvm, ValueRef, Attribute, Void};\n-use middle::trans::base::*;\n-use middle::trans::build::*;\n-use middle::trans::common::*;\n-\n-use middle::trans::type_::Type;\n-\n-use std::libc::c_uint;\n+use lib::llvm::Attribute;\n use std::option;\n-\n-pub trait ABIInfo {\n-    fn compute_info(&self, atys: &[Type], rty: Type, ret_def: bool) -> FnType;\n-}\n+use middle::trans::context::CrateContext;\n+use middle::trans::cabi_x86;\n+use middle::trans::cabi_x86_64;\n+use middle::trans::cabi_arm;\n+use middle::trans::cabi_mips;\n+use middle::trans::type_::Type;\n+use syntax::abi::{X86, X86_64, Arm, Mips};\n \n #[deriving(Clone)]\n pub struct LLVMType {\n     cast: bool,\n     ty: Type\n }\n \n+/// Metadata describing how the arguments to a native function\n+/// should be passed in order to respect the native ABI.\n+///\n+/// I will do my best to describe this structure, but these\n+/// comments are reverse-engineered and may be inaccurate. -NDM\n pub struct FnType {\n+    /// The LLVM types of each argument. If the cast flag is true,\n+    /// then the argument should be cast, typically because the\n+    /// official argument type will be an int and the rust type is i8\n+    /// or something like that.\n     arg_tys: ~[LLVMType],\n-    ret_ty: LLVMType,\n-    attrs: ~[option::Option<Attribute>],\n-    sret: bool\n-}\n-\n-impl FnType {\n-    pub fn decl_fn(&self, decl: &fn(fnty: Type) -> ValueRef) -> ValueRef {\n-        let atys = self.arg_tys.iter().map(|t| t.ty).collect::<~[Type]>();\n-        let rty = self.ret_ty.ty;\n-        let fnty = Type::func(atys, &rty);\n-        let llfn = decl(fnty);\n-\n-        for (i, a) in self.attrs.iter().enumerate() {\n-            match *a {\n-                option::Some(attr) => {\n-                    unsafe {\n-                        let llarg = get_param(llfn, i);\n-                        llvm::LLVMAddAttribute(llarg, attr as c_uint);\n-                    }\n-                }\n-                _ => ()\n-            }\n-        }\n-        return llfn;\n-    }\n \n-    pub fn build_shim_args(&self, bcx: @mut Block, arg_tys: &[Type], llargbundle: ValueRef)\n-                           -> ~[ValueRef] {\n-        let mut atys: &[LLVMType] = self.arg_tys;\n-        let mut attrs: &[option::Option<Attribute>] = self.attrs;\n-\n-        let mut llargvals = ~[];\n-        let mut i = 0u;\n-        let n = arg_tys.len();\n-\n-        if self.sret {\n-            let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n-            let llretloc = Load(bcx, llretptr);\n-                llargvals = ~[llretloc];\n-                atys = atys.tail();\n-                attrs = attrs.tail();\n-        }\n-\n-        while i < n {\n-            let llargval = if atys[i].cast {\n-                let arg_ptr = GEPi(bcx, llargbundle, [0u, i]);\n-                let arg_ptr = BitCast(bcx, arg_ptr, atys[i].ty.ptr_to());\n-                Load(bcx, arg_ptr)\n-            } else if attrs[i].is_some() {\n-                GEPi(bcx, llargbundle, [0u, i])\n-            } else {\n-                load_inbounds(bcx, llargbundle, [0u, i])\n-            };\n-            llargvals.push(llargval);\n-            i += 1u;\n-        }\n-\n-        return llargvals;\n-    }\n-\n-    pub fn build_shim_ret(&self, bcx: @mut Block, arg_tys: &[Type], ret_def: bool,\n-                          llargbundle: ValueRef, llretval: ValueRef) {\n-        for (i, a) in self.attrs.iter().enumerate() {\n-            match *a {\n-                option::Some(attr) => {\n-                    unsafe {\n-                        llvm::LLVMAddInstrAttribute(llretval, (i + 1u) as c_uint, attr as c_uint);\n-                    }\n-                }\n-                _ => ()\n-            }\n-        }\n-        if self.sret || !ret_def {\n-            return;\n-        }\n-        let n = arg_tys.len();\n-        // R** llretptr = &args->r;\n-        let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n-        // R* llretloc = *llretptr; /* (args->r) */\n-        let llretloc = Load(bcx, llretptr);\n-        if self.ret_ty.cast {\n-            let tmp_ptr = BitCast(bcx, llretloc, self.ret_ty.ty.ptr_to());\n-            // *args->r = r;\n-            Store(bcx, llretval, tmp_ptr);\n-        } else {\n-            // *args->r = r;\n-            Store(bcx, llretval, llretloc);\n-        };\n-    }\n-\n-    pub fn build_wrap_args(&self, bcx: @mut Block, ret_ty: Type,\n-                           llwrapfn: ValueRef, llargbundle: ValueRef) {\n-        let mut atys: &[LLVMType] = self.arg_tys;\n-        let mut attrs: &[option::Option<Attribute>] = self.attrs;\n-        let mut j = 0u;\n-        let llretptr = if self.sret {\n-            atys = atys.tail();\n-            attrs = attrs.tail();\n-            j = 1u;\n-            get_param(llwrapfn, 0u)\n-        } else if self.ret_ty.cast {\n-            let retptr = alloca(bcx, self.ret_ty.ty, \"\");\n-            BitCast(bcx, retptr, ret_ty.ptr_to())\n-        } else {\n-            alloca(bcx, ret_ty, \"\")\n-        };\n+    /// A list of attributes to be attached to each argument (parallel\n+    /// the `arg_tys` array). If the attribute for a given is Some,\n+    /// then the argument should be passed by reference.\n+    attrs: ~[option::Option<Attribute>],\n \n-        let mut i = 0u;\n-        let n = atys.len();\n-        while i < n {\n-            let mut argval = get_param(llwrapfn, i + j);\n-            if attrs[i].is_some() {\n-                argval = Load(bcx, argval);\n-                store_inbounds(bcx, argval, llargbundle, [0u, i]);\n-            } else if atys[i].cast {\n-                let argptr = GEPi(bcx, llargbundle, [0u, i]);\n-                let argptr = BitCast(bcx, argptr, atys[i].ty.ptr_to());\n-                Store(bcx, argval, argptr);\n-            } else {\n-                store_inbounds(bcx, argval, llargbundle, [0u, i]);\n-            }\n-            i += 1u;\n-        }\n-        store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n-    }\n+    /// LLVM return type.\n+    ret_ty: LLVMType,\n \n-    pub fn build_wrap_ret(&self, bcx: @mut Block, arg_tys: &[Type], llargbundle: ValueRef) {\n-        if self.ret_ty.ty.kind() == Void {\n-            return;\n-        }\n+    /// If true, then an implicit pointer should be added for the result.\n+    sret: bool\n+}\n \n-        if bcx.fcx.llretptr.is_some() {\n-            let llretval = load_inbounds(bcx, llargbundle, [ 0, arg_tys.len() ]);\n-            let llretval = if self.ret_ty.cast {\n-                let retptr = BitCast(bcx, llretval, self.ret_ty.ty.ptr_to());\n-                Load(bcx, retptr)\n-            } else {\n-                Load(bcx, llretval)\n-            };\n-            let llretptr = BitCast(bcx, bcx.fcx.llretptr.unwrap(), self.ret_ty.ty.ptr_to());\n-            Store(bcx, llretval, llretptr);\n-        }\n+pub fn compute_abi_info(ccx: &mut CrateContext,\n+                        atys: &[Type],\n+                        rty: Type,\n+                        ret_def: bool) -> FnType {\n+    match ccx.sess.targ_cfg.arch {\n+        X86 => cabi_x86::compute_abi_info(ccx, atys, rty, ret_def),\n+        X86_64 => cabi_x86_64::compute_abi_info(ccx, atys, rty, ret_def),\n+        Arm => cabi_arm::compute_abi_info(ccx, atys, rty, ret_def),\n+        Mips => cabi_mips::compute_abi_info(ccx, atys, rty, ret_def),\n     }\n }"}, {"sha": "19f0b9b78eb353baa4c4bd3d12ed7bf47ab1017c", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 30, "deletions": 37, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -10,7 +10,8 @@\n \n use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n use lib::llvm::{Attribute, StructRetAttribute};\n-use middle::trans::cabi::{ABIInfo, FnType, LLVMType};\n+use middle::trans::cabi::{FnType, LLVMType};\n+use middle::trans::context::CrateContext;\n \n use middle::trans::type_::Type;\n \n@@ -124,45 +125,37 @@ fn is_reg_ty(ty: Type) -> bool {\n     }\n }\n \n-enum ARM_ABIInfo { ARM_ABIInfo }\n-\n-impl ABIInfo for ARM_ABIInfo {\n-    fn compute_info(&self,\n-                    atys: &[Type],\n-                    rty: Type,\n-                    ret_def: bool) -> FnType {\n-        let mut arg_tys = ~[];\n-        let mut attrs = ~[];\n-        for &aty in atys.iter() {\n-            let (ty, attr) = classify_arg_ty(aty);\n-            arg_tys.push(ty);\n-            attrs.push(attr);\n-        }\n-\n-        let (ret_ty, ret_attr) = if ret_def {\n-            classify_ret_ty(rty)\n-        } else {\n-            (LLVMType { cast: false, ty: Type::void() }, None)\n-        };\n+pub fn compute_abi_info(_ccx: &mut CrateContext,\n+                        atys: &[Type],\n+                        rty: Type,\n+                        ret_def: bool) -> FnType {\n+    let mut arg_tys = ~[];\n+    let mut attrs = ~[];\n+    for &aty in atys.iter() {\n+        let (ty, attr) = classify_arg_ty(aty);\n+        arg_tys.push(ty);\n+        attrs.push(attr);\n+    }\n \n-        let mut ret_ty = ret_ty;\n+    let (ret_ty, ret_attr) = if ret_def {\n+        classify_ret_ty(rty)\n+    } else {\n+        (LLVMType { cast: false, ty: Type::void() }, None)\n+    };\n \n-        let sret = ret_attr.is_some();\n-        if sret {\n-            arg_tys.unshift(ret_ty);\n-            attrs.unshift(ret_attr);\n-            ret_ty = LLVMType { cast: false, ty: Type::void() };\n-        }\n+    let mut ret_ty = ret_ty;\n \n-        return FnType {\n-            arg_tys: arg_tys,\n-            ret_ty: ret_ty,\n-            attrs: attrs,\n-            sret: sret\n-        };\n+    let sret = ret_attr.is_some();\n+    if sret {\n+        arg_tys.unshift(ret_ty);\n+        attrs.unshift(ret_attr);\n+        ret_ty = LLVMType { cast: false, ty: Type::void() };\n     }\n-}\n \n-pub fn abi_info() -> @ABIInfo {\n-    return @ARM_ABIInfo as @ABIInfo;\n+    return FnType {\n+        arg_tys: arg_tys,\n+        ret_ty: ret_ty,\n+        attrs: attrs,\n+        sret: sret\n+    };\n }"}, {"sha": "4577bf11b84de8b7a5c5b78efb22b3d5e7c9ca33", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 33, "deletions": 40, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -14,6 +14,7 @@ use std::num;\n use std::vec;\n use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n use lib::llvm::{Attribute, StructRetAttribute};\n+use middle::trans::context::CrateContext;\n use middle::trans::context::task_llcx;\n use middle::trans::cabi::*;\n \n@@ -170,47 +171,39 @@ fn struct_ty(ty: Type,\n     return Type::struct_(fields, false);\n }\n \n-enum MIPS_ABIInfo { MIPS_ABIInfo }\n-\n-impl ABIInfo for MIPS_ABIInfo {\n-    fn compute_info(&self,\n-                    atys: &[Type],\n-                    rty: Type,\n-                    ret_def: bool) -> FnType {\n-        let (ret_ty, ret_attr) = if ret_def {\n-            classify_ret_ty(rty)\n-        } else {\n-            (LLVMType { cast: false, ty: Type::void() }, None)\n-        };\n-\n-        let mut ret_ty = ret_ty;\n-\n-        let sret = ret_attr.is_some();\n-        let mut arg_tys = ~[];\n-        let mut attrs = ~[];\n-        let mut offset = if sret { 4 } else { 0 };\n-\n-        for aty in atys.iter() {\n-            let (ty, attr) = classify_arg_ty(*aty, &mut offset);\n-            arg_tys.push(ty);\n-            attrs.push(attr);\n-        };\n-\n-        if sret {\n-            arg_tys = vec::append(~[ret_ty], arg_tys);\n-            attrs = vec::append(~[ret_attr], attrs);\n-            ret_ty = LLVMType { cast: false, ty: Type::void() };\n-        }\n+pub fn compute_abi_info(_ccx: &mut CrateContext,\n+                        atys: &[Type],\n+                        rty: Type,\n+                        ret_def: bool) -> FnType {\n+    let (ret_ty, ret_attr) = if ret_def {\n+        classify_ret_ty(rty)\n+    } else {\n+        (LLVMType { cast: false, ty: Type::void() }, None)\n+    };\n+\n+    let mut ret_ty = ret_ty;\n+\n+    let sret = ret_attr.is_some();\n+    let mut arg_tys = ~[];\n+    let mut attrs = ~[];\n+    let mut offset = if sret { 4 } else { 0 };\n \n-        return FnType {\n-            arg_tys: arg_tys,\n-            ret_ty: ret_ty,\n-            attrs: attrs,\n-            sret: sret\n-        };\n+    for aty in atys.iter() {\n+        let (ty, attr) = classify_arg_ty(*aty, &mut offset);\n+        arg_tys.push(ty);\n+        attrs.push(attr);\n+    };\n+\n+    if sret {\n+        arg_tys = vec::append(~[ret_ty], arg_tys);\n+        attrs = vec::append(~[ret_attr], attrs);\n+        ret_ty = LLVMType { cast: false, ty: Type::void() };\n     }\n-}\n \n-pub fn abi_info() -> @ABIInfo {\n-    return @MIPS_ABIInfo as @ABIInfo;\n+    return FnType {\n+        arg_tys: arg_tys,\n+        ret_ty: ret_ty,\n+        attrs: attrs,\n+        sret: sret\n+    };\n }"}, {"sha": "f0af31e795af239c218bcc3c350bf09715939df6", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 70, "deletions": 53, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -14,70 +14,87 @@ use lib::llvm::*;\n use super::cabi::*;\n use super::common::*;\n use super::machine::*;\n-\n use middle::trans::type_::Type;\n \n-struct X86_ABIInfo {\n-    ccx: @mut CrateContext\n-}\n+pub fn compute_abi_info(ccx: &mut CrateContext,\n+                        atys: &[Type],\n+                        rty: Type,\n+                        ret_def: bool) -> FnType {\n+    let mut arg_tys = ~[];\n+    let mut attrs = ~[];\n \n-impl ABIInfo for X86_ABIInfo {\n-    fn compute_info(&self,\n-                    atys: &[Type],\n-                    rty: Type,\n-                    ret_def: bool) -> FnType {\n-        let mut arg_tys = do atys.map |a| {\n-            LLVMType { cast: false, ty: *a }\n-        };\n-        let mut ret_ty = LLVMType {\n+    let ret_ty;\n+    let sret;\n+    if !ret_def {\n+        ret_ty = LLVMType {\n             cast: false,\n-            ty: rty\n+            ty: Type::void(),\n         };\n-        let mut attrs = do atys.map |_| {\n-            None\n-        };\n-\n-        // Rules for returning structs taken from\n+        sret = false;\n+    } else if rty.kind() == Struct {\n+        // Returning a structure. Most often, this will use\n+        // a hidden first argument. On some platforms, though,\n+        // small structs are returned as integers.\n+        //\n+        // Some links:\n         // http://www.angelcode.com/dev/callconv/callconv.html\n         // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n-        let sret = {\n-            let returning_a_struct = rty.kind() == Struct && ret_def;\n-            let big_struct = match self.ccx.sess.targ_cfg.os {\n-                os_win32 | os_macos => llsize_of_alloc(self.ccx, rty) > 8,\n-                _ => true\n-            };\n-            returning_a_struct && big_struct\n+\n+        enum Strategy { RetValue(Type), RetPointer }\n+        let strategy = match ccx.sess.targ_cfg.os {\n+            os_win32 | os_macos => {\n+                match llsize_of_alloc(ccx, rty) {\n+                    1 => RetValue(Type::i8()),\n+                    2 => RetValue(Type::i16()),\n+                    4 => RetValue(Type::i32()),\n+                    8 => RetValue(Type::i64()),\n+                    _ => RetPointer\n+                }\n+            }\n+            _ => {\n+                RetPointer\n+            }\n         };\n \n-        if sret {\n-            let ret_ptr_ty = LLVMType {\n-                cast: false,\n-                ty: ret_ty.ty.ptr_to()\n-            };\n-            arg_tys = ~[ret_ptr_ty] + arg_tys;\n-            attrs = ~[Some(StructRetAttribute)] + attrs;\n-            ret_ty = LLVMType {\n-                cast: false,\n-                ty: Type::void(),\n-            };\n-        } else if !ret_def {\n-            ret_ty = LLVMType {\n-                cast: false,\n-                ty: Type::void()\n-            };\n-        }\n+        match strategy {\n+            RetValue(t) => {\n+                ret_ty = LLVMType {\n+                    cast: true,\n+                    ty: t\n+                };\n+                sret = false;\n+            }\n+            RetPointer => {\n+                arg_tys.push(LLVMType {\n+                    cast: false,\n+                    ty: rty.ptr_to()\n+                });\n+                attrs.push(Some(StructRetAttribute));\n \n-        return FnType {\n-            arg_tys: arg_tys,\n-            ret_ty: ret_ty,\n-            attrs: attrs,\n-            sret: sret\n+                ret_ty = LLVMType {\n+                    cast: false,\n+                    ty: Type::void(),\n+                };\n+                sret = true;\n+            }\n+        }\n+    } else {\n+        ret_ty = LLVMType {\n+            cast: false,\n+            ty: rty\n         };\n+        sret = false;\n+    }\n+\n+    for &a in atys.iter() {\n+        arg_tys.push(LLVMType { cast: false, ty: a });\n+        attrs.push(None);\n     }\n-}\n \n-pub fn abi_info(ccx: @mut CrateContext) -> @ABIInfo {\n-    return @X86_ABIInfo {\n-        ccx: ccx\n-    } as @ABIInfo;\n+    return FnType {\n+        arg_tys: arg_tys,\n+        ret_ty: ret_ty,\n+        attrs: attrs,\n+        sret: sret\n+    };\n }"}, {"sha": "179366878418f0a879d0481a7454925480c613c5", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -15,6 +15,7 @@ use lib::llvm::{llvm, Integer, Pointer, Float, Double};\n use lib::llvm::{Struct, Array, Attribute};\n use lib::llvm::{StructRetAttribute, ByValAttribute};\n use middle::trans::cabi::*;\n+use middle::trans::context::CrateContext;\n \n use middle::trans::type_::Type;\n \n@@ -331,10 +332,10 @@ fn llreg_ty(cls: &[RegClass]) -> Type {\n     return Type::struct_(tys, false);\n }\n \n-fn x86_64_tys(atys: &[Type],\n-              rty: Type,\n-              ret_def: bool) -> FnType {\n-\n+pub fn compute_abi_info(_ccx: &mut CrateContext,\n+                        atys: &[Type],\n+                        rty: Type,\n+                        ret_def: bool) -> FnType {\n     fn x86_64_ty(ty: Type,\n                  is_mem_cls: &fn(cls: &[RegClass]) -> bool,\n                  attr: Attribute) -> (LLVMType, Option<Attribute>) {\n@@ -384,18 +385,3 @@ fn x86_64_tys(atys: &[Type],\n         sret: sret\n     };\n }\n-\n-enum X86_64_ABIInfo { X86_64_ABIInfo }\n-\n-impl ABIInfo for X86_64_ABIInfo {\n-    fn compute_info(&self,\n-                    atys: &[Type],\n-                    rty: Type,\n-                    ret_def: bool) -> FnType {\n-        return x86_64_tys(atys, rty, ret_def);\n-    }\n-}\n-\n-pub fn abi_info() -> @ABIInfo {\n-    return @X86_64_ABIInfo as @ABIInfo;\n-}"}, {"sha": "c4720f5cb35b144e156782518af4286301566783", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 151, "deletions": 83, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -37,6 +37,7 @@ use middle::trans::inline;\n use middle::trans::meth;\n use middle::trans::monomorphize;\n use middle::trans::type_of;\n+use middle::trans::foreign;\n use middle::ty;\n use middle::subst::Subst;\n use middle::typeck;\n@@ -46,6 +47,7 @@ use util::ppaux::Repr;\n use middle::trans::type_::Type;\n \n use syntax::ast;\n+use syntax::abi::AbiSet;\n use syntax::ast_map;\n use syntax::oldvisit;\n \n@@ -240,20 +242,20 @@ pub fn trans_fn_ref_with_vtables(\n         type_params: &[ty::t], // values for fn's ty params\n         vtables: Option<typeck::vtable_res>) // vtables for the call\n      -> FnData {\n-    //!\n-    //\n-    // Translates a reference to a fn/method item, monomorphizing and\n-    // inlining as it goes.\n-    //\n-    // # Parameters\n-    //\n-    // - `bcx`: the current block where the reference to the fn occurs\n-    // - `def_id`: def id of the fn or method item being referenced\n-    // - `ref_id`: node id of the reference to the fn/method, if applicable.\n-    //   This parameter may be zero; but, if so, the resulting value may not\n-    //   have the right type, so it must be cast before being used.\n-    // - `type_params`: values for each of the fn/method's type parameters\n-    // - `vtables`: values for each bound on each of the type parameters\n+    /*!\n+     * Translates a reference to a fn/method item, monomorphizing and\n+     * inlining as it goes.\n+     *\n+     * # Parameters\n+     *\n+     * - `bcx`: the current block where the reference to the fn occurs\n+     * - `def_id`: def id of the fn or method item being referenced\n+     * - `ref_id`: node id of the reference to the fn/method, if applicable.\n+     *   This parameter may be zero; but, if so, the resulting value may not\n+     *   have the right type, so it must be cast before being used.\n+     * - `type_params`: values for each of the fn/method's type parameters\n+     * - `vtables`: values for each bound on each of the type parameters\n+     */\n \n     let _icx = push_ctxt(\"trans_fn_ref_with_vtables\");\n     let ccx = bcx.ccx();\n@@ -386,7 +388,7 @@ pub fn trans_fn_ref_with_vtables(\n     }\n \n     // Find the actual function pointer.\n-    let val = {\n+    let mut val = {\n         if def_id.crate == ast::LOCAL_CRATE {\n             // Internal reference.\n             get_item_val(ccx, def_id.node)\n@@ -396,6 +398,35 @@ pub fn trans_fn_ref_with_vtables(\n         }\n     };\n \n+    // This is subtle and surprising, but sometimes we have to bitcast\n+    // the resulting fn pointer.  The reason has to do with external\n+    // functions.  If you have two crates that both bind the same C\n+    // library, they may not use precisely the same types: for\n+    // example, they will probably each declare their own structs,\n+    // which are distinct types from LLVM's point of view (nominal\n+    // types).\n+    //\n+    // Now, if those two crates are linked into an application, and\n+    // they contain inlined code, you can wind up with a situation\n+    // where both of those functions wind up being loaded into this\n+    // application simultaneously. In that case, the same function\n+    // (from LLVM's point of view) requires two types. But of course\n+    // LLVM won't allow one function to have two types.\n+    //\n+    // What we currently do, therefore, is declare the function with\n+    // one of the two types (whichever happens to come first) and then\n+    // bitcast as needed when the function is referenced to make sure\n+    // it has the type we expect.\n+    //\n+    // This can occur on either a crate-local or crate-external\n+    // reference. It also occurs when testing libcore and in some\n+    // other weird situations. Annoying.\n+    let llty = type_of::type_of_fn_from_ty(ccx, fn_tpt.ty);\n+    let llptrty = llty.ptr_to();\n+    if val_ty(val) != llptrty {\n+        val = BitCast(bcx, val, llptrty);\n+    }\n+\n     return FnData {llfn: val};\n }\n \n@@ -543,16 +574,26 @@ pub fn body_contains_ret(body: &ast::Block) -> bool {\n     *cx\n }\n \n-// See [Note-arg-mode]\n pub fn trans_call_inner(in_cx: @mut Block,\n                         call_info: Option<NodeInfo>,\n-                        fn_expr_ty: ty::t,\n+                        callee_ty: ty::t,\n                         ret_ty: ty::t,\n                         get_callee: &fn(@mut Block) -> Callee,\n                         args: CallArgs,\n                         dest: Option<expr::Dest>,\n                         autoref_arg: AutorefArg)\n                         -> Result {\n+    /*!\n+     * This behemoth of a function translates function calls.\n+     * Unfortunately, in order to generate more efficient LLVM\n+     * output at -O0, it has quite a complex signature (refactoring\n+     * this into two functions seems like a good idea).\n+     *\n+     * In particular, for lang items, it is invoked with a dest of\n+     * None, and\n+     */\n+\n+\n     do base::with_scope_result(in_cx, call_info, \"call\") |cx| {\n         let callee = get_callee(cx);\n         let mut bcx = callee.bcx;\n@@ -580,98 +621,125 @@ pub fn trans_call_inner(in_cx: @mut Block,\n             }\n         };\n \n-        let llretslot = trans_ret_slot(bcx, fn_expr_ty, dest);\n+        let abi = match ty::get(callee_ty).sty {\n+            ty::ty_bare_fn(ref f) => f.abis,\n+            _ => AbiSet::Rust()\n+        };\n+        let is_rust_fn =\n+            abi.is_rust() ||\n+            abi.is_intrinsic();\n+\n+        // Generate a location to store the result. If the user does\n+        // not care about the result, just make a stack slot.\n+        let opt_llretslot = match dest {\n+            None => {\n+                assert!(!type_of::return_uses_outptr(in_cx.tcx(), ret_ty));\n+                None\n+            }\n+            Some(expr::SaveIn(dst)) => Some(dst),\n+            Some(expr::Ignore) => {\n+                if !ty::type_is_voidish(ret_ty) {\n+                    Some(alloc_ty(bcx, ret_ty, \"__llret\"))\n+                } else {\n+                    unsafe {\n+                        Some(llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()))\n+                    }\n+                }\n+            }\n+        };\n \n-        let mut llargs = ~[];\n+        let mut llresult = unsafe {\n+            llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref())\n+        };\n \n-        if !ty::type_is_immediate(bcx.tcx(), ret_ty) {\n-            llargs.push(llretslot);\n-        }\n+        // The code below invokes the function, using either the Rust\n+        // conventions (if it is a rust fn) or the native conventions\n+        // (otherwise).  The important part is that, when all is sad\n+        // and done, either the return value of the function will have been\n+        // written in opt_llretslot (if it is Some) or `llresult` will be\n+        // set appropriately (otherwise).\n+        if is_rust_fn {\n+            let mut llargs = ~[];\n+\n+            // Push the out-pointer if we use an out-pointer for this\n+            // return type, otherwise push \"undef\".\n+            if type_of::return_uses_outptr(in_cx.tcx(), ret_ty) {\n+                llargs.push(opt_llretslot.unwrap());\n+            }\n+\n+            // Push the environment.\n+            llargs.push(llenv);\n \n-        llargs.push(llenv);\n-        bcx = trans_args(bcx, args, fn_expr_ty, autoref_arg, &mut llargs);\n+            // Push the arguments.\n+            bcx = trans_args(bcx, args, callee_ty,\n+                             autoref_arg, &mut llargs);\n \n-        // Now that the arguments have finished evaluating, we need to revoke\n-        // the cleanup for the self argument\n-        match callee.data {\n-            Method(d) => {\n-                for &v in d.temp_cleanup.iter() {\n-                    revoke_clean(bcx, v);\n+            // Now that the arguments have finished evaluating, we\n+            // need to revoke the cleanup for the self argument\n+            match callee.data {\n+                Method(d) => {\n+                    for &v in d.temp_cleanup.iter() {\n+                        revoke_clean(bcx, v);\n+                    }\n                 }\n+                _ => {}\n             }\n-            _ => {}\n-        }\n \n-        // Uncomment this to debug calls.\n-        /*\n-        printfln!(\"calling: %s\", bcx.val_to_str(llfn));\n-        for llarg in llargs.iter() {\n-            printfln!(\"arg: %s\", bcx.val_to_str(*llarg));\n+            // Invoke the actual rust fn and update bcx/llresult.\n+            let (llret, b) = base::invoke(bcx, llfn, llargs);\n+            bcx = b;\n+            llresult = llret;\n+\n+            // If the Rust convention for this type is return via\n+            // the return value, copy it into llretslot.\n+            match opt_llretslot {\n+                Some(llretslot) => {\n+                    if !type_of::return_uses_outptr(bcx.tcx(), ret_ty) &&\n+                        !ty::type_is_voidish(ret_ty)\n+                    {\n+                        Store(bcx, llret, llretslot);\n+                    }\n+                }\n+                None => {}\n+            }\n+        } else {\n+            // Lang items are the only case where dest is None, and\n+            // they are always Rust fns.\n+            assert!(dest.is_some());\n+\n+            let mut llargs = ~[];\n+            bcx = trans_args(bcx, args, callee_ty,\n+                             autoref_arg, &mut llargs);\n+            bcx = foreign::trans_native_call(bcx, callee_ty,\n+                                             llfn, opt_llretslot.unwrap(), llargs);\n         }\n-        io::println(\"---\");\n-        */\n-\n-        // If the block is terminated, then one or more of the args\n-        // has type _|_. Since that means it diverges, the code for\n-        // the call itself is unreachable.\n-        let (llresult, new_bcx) = base::invoke(bcx, llfn, llargs);\n-        bcx = new_bcx;\n \n+        // If the caller doesn't care about the result of this fn call,\n+        // drop the temporary slot we made.\n         match dest {\n-            None => { assert!(ty::type_is_immediate(bcx.tcx(), ret_ty)) }\n+            None => {\n+                assert!(!type_of::return_uses_outptr(bcx.tcx(), ret_ty));\n+            }\n             Some(expr::Ignore) => {\n                 // drop the value if it is not being saved.\n-                if ty::type_needs_drop(bcx.tcx(), ret_ty) {\n-                    if ty::type_is_immediate(bcx.tcx(), ret_ty) {\n-                        let llscratchptr = alloc_ty(bcx, ret_ty, \"__ret\");\n-                        Store(bcx, llresult, llscratchptr);\n-                        bcx = glue::drop_ty(bcx, llscratchptr, ret_ty);\n-                    } else {\n-                        bcx = glue::drop_ty(bcx, llretslot, ret_ty);\n-                    }\n-                }\n-            }\n-            Some(expr::SaveIn(lldest)) => {\n-                // If this is an immediate, store into the result location.\n-                // (If this was not an immediate, the result will already be\n-                // directly written into the output slot.)\n-                if ty::type_is_immediate(bcx.tcx(), ret_ty) {\n-                    Store(bcx, llresult, lldest);\n-                }\n+                bcx = glue::drop_ty(bcx, opt_llretslot.unwrap(), ret_ty);\n             }\n+            Some(expr::SaveIn(_)) => { }\n         }\n \n         if ty::type_is_bot(ret_ty) {\n             Unreachable(bcx);\n         }\n+\n         rslt(bcx, llresult)\n     }\n }\n \n-\n pub enum CallArgs<'self> {\n     ArgExprs(&'self [@ast::expr]),\n     ArgVals(&'self [ValueRef])\n }\n \n-pub fn trans_ret_slot(bcx: @mut Block, fn_ty: ty::t, dest: Option<expr::Dest>)\n-                      -> ValueRef {\n-    let retty = ty::ty_fn_ret(fn_ty);\n-\n-    match dest {\n-        Some(expr::SaveIn(dst)) => dst,\n-        _ => {\n-            if ty::type_is_immediate(bcx.tcx(), retty) {\n-                unsafe {\n-                    llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref())\n-                }\n-            } else {\n-                alloc_ty(bcx, retty, \"__trans_ret_slot\")\n-            }\n-        }\n-    }\n-}\n-\n pub fn trans_args(cx: @mut Block,\n                   args: CallArgs,\n                   fn_ty: ty::t,\n@@ -795,7 +863,7 @@ pub fn trans_arg_expr(bcx: @mut Block,\n \n         if formal_arg_ty != arg_datum.ty {\n             // this could happen due to e.g. subtyping\n-            let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, &formal_arg_ty);\n+            let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n             debug!(\"casting actual type (%s) to match formal (%s)\",\n                    bcx.val_to_str(val), bcx.llty_str(llformal_arg_ty));\n             val = PointerCast(bcx, val, llformal_arg_ty);"}, {"sha": "027696d37f128746950816a78c19672537731df1", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -121,7 +121,7 @@ pub fn BuilderRef_res(B: BuilderRef) -> BuilderRef_res {\n     }\n }\n \n-pub type ExternMap = HashMap<@str, ValueRef>;\n+pub type ExternMap = HashMap<~str, ValueRef>;\n \n // Types used for llself.\n pub struct ValSelfData {\n@@ -197,10 +197,10 @@ pub struct FunctionContext {\n     // outputting the resume instruction.\n     personality: Option<ValueRef>,\n \n-    // True if this function has an immediate return value, false otherwise.\n-    // If this is false, the llretptr will alias the first argument of the\n-    // function.\n-    has_immediate_return_value: bool,\n+    // True if the caller expects this fn to use the out pointer to\n+    // return. Either way, your code should write into llretptr, but if\n+    // this value is false, llretptr will be a local alloca.\n+    caller_expects_out_pointer: bool,\n \n     // Maps arguments to allocas created for them in llallocas.\n     llargs: @mut HashMap<ast::NodeId, ValueRef>,\n@@ -232,20 +232,20 @@ pub struct FunctionContext {\n \n impl FunctionContext {\n     pub fn arg_pos(&self, arg: uint) -> uint {\n-        if self.has_immediate_return_value {\n-            arg + 1u\n-        } else {\n+        if self.caller_expects_out_pointer {\n             arg + 2u\n+        } else {\n+            arg + 1u\n         }\n     }\n \n     pub fn out_arg_pos(&self) -> uint {\n-        assert!(!self.has_immediate_return_value);\n+        assert!(self.caller_expects_out_pointer);\n         0u\n     }\n \n     pub fn env_arg_pos(&self) -> uint {\n-        if !self.has_immediate_return_value {\n+        if self.caller_expects_out_pointer {\n             1u\n         } else {\n             0u"}, {"sha": "1060a06a5cfa9d5a6b9a1511c7df0a65ab8ce014", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -190,12 +190,12 @@ pub fn scratch_datum(bcx: @mut Block, ty: ty::t, name: &str, zero: bool) -> Datu\n \n pub fn appropriate_mode(tcx: ty::ctxt, ty: ty::t) -> DatumMode {\n     /*!\n-    *\n-    * Indicates the \"appropriate\" mode for this value,\n-    * which is either by ref or by value, depending\n-    * on whether type is immediate or not. */\n+     * Indicates the \"appropriate\" mode for this value,\n+     * which is either by ref or by value, depending\n+     * on whether type is immediate or not.\n+     */\n \n-    if ty::type_is_nil(ty) || ty::type_is_bot(ty) {\n+    if ty::type_is_voidish(ty) {\n         ByValue\n     } else if ty::type_is_immediate(tcx, ty) {\n         ByValue\n@@ -271,7 +271,7 @@ impl Datum {\n \n         let _icx = push_ctxt(\"copy_to\");\n \n-        if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n+        if ty::type_is_voidish(self.ty) {\n             return bcx;\n         }\n \n@@ -343,7 +343,7 @@ impl Datum {\n         debug!(\"move_to(self=%s, action=%?, dst=%s)\",\n                self.to_str(bcx.ccx()), action, bcx.val_to_str(dst));\n \n-        if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n+        if ty::type_is_voidish(self.ty) {\n             return bcx;\n         }\n \n@@ -432,7 +432,7 @@ impl Datum {\n          *\n          * Yields the value itself. */\n \n-        if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n+        if ty::type_is_voidish(self.ty) {\n             C_nil()\n         } else {\n             match self.mode {\n@@ -469,7 +469,7 @@ impl Datum {\n         match self.mode {\n             ByRef(_) => self.val,\n             ByValue => {\n-                if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n+                if ty::type_is_voidish(self.ty) {\n                     C_null(type_of::type_of(bcx.ccx(), self.ty).ptr_to())\n                 } else {\n                     let slot = alloc_ty(bcx, self.ty, \"\");"}, {"sha": "2ce8756848fa818b710307d5ece1e98a99d3cd3a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -290,7 +290,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n         assert_eq!(datum.appropriate_mode(tcx), ByValue);\n         Store(bcx, datum.to_appropriate_llval(bcx), llfn);\n         let llenv = GEPi(bcx, scratch.val, [0u, abi::fn_field_box]);\n-        Store(bcx, base::null_env_ptr(bcx), llenv);\n+        Store(bcx, base::null_env_ptr(bcx.ccx()), llenv);\n         DatumBlock {bcx: bcx, datum: scratch}\n     }\n \n@@ -416,7 +416,7 @@ pub fn trans_into(bcx: @mut Block, expr: @ast::expr, dest: Dest) -> @mut Block {\n     debuginfo::update_source_pos(bcx.fcx, expr.id, expr.span);\n \n     let dest = {\n-        if ty::type_is_nil(ty) || ty::type_is_bot(ty) {\n+        if ty::type_is_voidish(ty) {\n             Ignore\n         } else {\n             dest\n@@ -507,7 +507,7 @@ fn trans_to_datum_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n \n         ty::RvalueDpsExpr => {\n             let ty = expr_ty(bcx, expr);\n-            if ty::type_is_nil(ty) || ty::type_is_bot(ty) {\n+            if ty::type_is_voidish(ty) {\n                 bcx = trans_rvalue_dps_unadjusted(bcx, expr, Ignore);\n                 return nil(bcx, ty);\n             } else {"}, {"sha": "5586f1183ef87257539f97f63d1f9ec98f0489cc", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 614, "deletions": 1085, "changes": 1699, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -9,1206 +9,735 @@\n // except according to those terms.\n \n \n-use back::{link, abi};\n-use lib::llvm::{Pointer, ValueRef};\n+use back::{link};\n+use std::libc::c_uint;\n+use lib::llvm::{ValueRef, Attribute, CallConv};\n+use lib::llvm::llvm;\n use lib;\n-use middle::trans::base::*;\n+use middle::trans::machine;\n+use middle::trans::base;\n+use middle::trans::base::push_ctxt;\n use middle::trans::cabi;\n-use middle::trans::cabi_x86;\n-use middle::trans::cabi_x86_64;\n-use middle::trans::cabi_arm;\n-use middle::trans::cabi_mips;\n use middle::trans::build::*;\n-use middle::trans::callee::*;\n+use middle::trans::builder::noname;\n use middle::trans::common::*;\n-use middle::trans::datum::*;\n-use middle::trans::expr::Ignore;\n-use middle::trans::machine::llsize_of;\n-use middle::trans::glue;\n-use middle::trans::machine;\n use middle::trans::type_of::*;\n use middle::trans::type_of;\n use middle::ty;\n use middle::ty::FnSig;\n-use util::ppaux::ty_to_str;\n \n-use std::cell::Cell;\n+use std::uint;\n use std::vec;\n use syntax::codemap::span;\n-use syntax::{ast, ast_util};\n+use syntax::{ast};\n use syntax::{attr, ast_map};\n-use syntax::opt_vec;\n use syntax::parse::token::special_idents;\n-use syntax::parse::token;\n-use syntax::abi::{X86, X86_64, Arm, Mips};\n use syntax::abi::{RustIntrinsic, Rust, Stdcall, Fastcall,\n-                  Cdecl, Aapcs, C};\n+                  Cdecl, Aapcs, C, AbiSet};\n+use util::ppaux::{Repr, UserString};\n use middle::trans::type_::Type;\n \n-fn abi_info(ccx: @mut CrateContext) -> @cabi::ABIInfo {\n-    return match ccx.sess.targ_cfg.arch {\n-        X86 => cabi_x86::abi_info(ccx),\n-        X86_64 => cabi_x86_64::abi_info(),\n-        Arm => cabi_arm::abi_info(),\n-        Mips => cabi_mips::abi_info(),\n-    }\n-}\n-\n-pub fn link_name(ccx: &CrateContext, i: &ast::foreign_item) -> @str {\n-     match attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n-        None => ccx.sess.str_of(i.ident),\n-        Some(ln) => ln,\n-    }\n-}\n+///////////////////////////////////////////////////////////////////////////\n+// Type definitions\n \n-struct ShimTypes {\n+struct ForeignTypes {\n+    /// Rust signature of the function\n     fn_sig: ty::FnSig,\n \n+    /// Adapter object for handling native ABI rules (trust me, you\n+    /// don't want to know)\n+    fn_ty: cabi::FnType,\n+\n     /// LLVM types that will appear on the foreign function\n     llsig: LlvmSignature,\n \n     /// True if there is a return value (not bottom, not unit)\n     ret_def: bool,\n-\n-    /// Type of the struct we will use to shuttle values back and forth.\n-    /// This is always derived from the llsig.\n-    bundle_ty: Type,\n-\n-    /// Type of the shim function itself.\n-    shim_fn_ty: Type,\n-\n-    /// Adapter object for handling native ABI rules (trust me, you\n-    /// don't want to know).\n-    fn_ty: cabi::FnType\n }\n \n struct LlvmSignature {\n+    // LLVM versions of the types of this function's arguments.\n     llarg_tys: ~[Type],\n-    llret_ty: Type,\n-    sret: bool,\n-}\n \n-fn foreign_signature(ccx: &mut CrateContext, fn_sig: &ty::FnSig)\n-                     -> LlvmSignature {\n-    /*!\n-     * The ForeignSignature is the LLVM types of the arguments/return type\n-     * of a function.  Note that these LLVM types are not quite the same\n-     * as the LLVM types would be for a native Rust function because foreign\n-     * functions just plain ignore modes.  They also don't pass aggregate\n-     * values by pointer like we do.\n-     */\n+    // LLVM version of the type that this function returns.  Note that\n+    // this *may not be* the declared return type of the foreign\n+    // function, because the foreign function may opt to return via an\n+    // out pointer.\n+    llret_ty: Type,\n \n-    let llarg_tys = fn_sig.inputs.map(|arg_ty| type_of(ccx, *arg_ty));\n-    let llret_ty = type_of::type_of(ccx, fn_sig.output);\n-    LlvmSignature {\n-        llarg_tys: llarg_tys,\n-        llret_ty: llret_ty,\n-        sret: !ty::type_is_immediate(ccx.tcx, fn_sig.output),\n-    }\n+    // True if *Rust* would use an outpointer for this function.\n+    sret: bool,\n }\n \n-fn shim_types(ccx: @mut CrateContext, id: ast::NodeId) -> ShimTypes {\n-    let fn_sig = match ty::get(ty::node_id_to_type(ccx.tcx, id)).sty {\n-        ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n-        _ => ccx.sess.bug(\"c_arg_and_ret_lltys called on non-function type\")\n-    };\n-    let llsig = foreign_signature(ccx, &fn_sig);\n-    let bundle_ty = Type::struct_(llsig.llarg_tys + &[llsig.llret_ty.ptr_to()], false);\n-    let ret_def = !ty::type_is_bot(fn_sig.output) &&\n-                  !ty::type_is_nil(fn_sig.output);\n-    let fn_ty = abi_info(ccx).compute_info(llsig.llarg_tys, llsig.llret_ty, ret_def);\n-    ShimTypes {\n-        fn_sig: fn_sig,\n-        llsig: llsig,\n-        ret_def: ret_def,\n-        bundle_ty: bundle_ty,\n-        shim_fn_ty: Type::func([bundle_ty.ptr_to()], &Type::void()),\n-        fn_ty: fn_ty\n-    }\n-}\n \n-type shim_arg_builder<'self> =\n-    &'self fn(bcx: @mut Block, tys: &ShimTypes,\n-              llargbundle: ValueRef) -> ~[ValueRef];\n-\n-type shim_ret_builder<'self> =\n-    &'self fn(bcx: @mut Block, tys: &ShimTypes,\n-              llargbundle: ValueRef,\n-              llretval: ValueRef);\n-\n-fn build_shim_fn_(ccx: @mut CrateContext,\n-                  shim_name: &str,\n-                  llbasefn: ValueRef,\n-                  tys: &ShimTypes,\n-                  cc: lib::llvm::CallConv,\n-                  arg_builder: shim_arg_builder,\n-                  ret_builder: shim_ret_builder)\n-               -> ValueRef {\n-    let llshimfn = decl_internal_cdecl_fn(\n-        ccx.llmod, shim_name, tys.shim_fn_ty);\n-\n-    // Declare the body of the shim function:\n-    let fcx = new_fn_ctxt(ccx, ~[], llshimfn, tys.fn_sig.output, None);\n-    let bcx = fcx.entry_bcx.unwrap();\n-\n-    let llargbundle = get_param(llshimfn, 0u);\n-    let llargvals = arg_builder(bcx, tys, llargbundle);\n-\n-    // Create the call itself and store the return value:\n-    let llretval = CallWithConv(bcx, llbasefn, llargvals, cc);\n-\n-    ret_builder(bcx, tys, llargbundle, llretval);\n-\n-    // Don't finish up the function in the usual way, because this doesn't\n-    // follow the normal Rust calling conventions.\n-    let ret_cx = match fcx.llreturn {\n-        Some(llreturn) => raw_block(fcx, false, llreturn),\n-        None => bcx\n-    };\n-    RetVoid(ret_cx);\n-    fcx.cleanup();\n+///////////////////////////////////////////////////////////////////////////\n+// Calls to external functions\n \n-    return llshimfn;\n-}\n+fn llvm_calling_convention(ccx: @mut CrateContext,\n+                           abis: AbiSet)\n+                           -> Option<CallConv> {\n+    let arch = ccx.sess.targ_cfg.arch;\n+    abis.for_arch(arch).map(|abi| {\n+        match *abi {\n+            RustIntrinsic => {\n+                // Intrinsics are emitted by monomorphic fn\n+                ccx.sess.bug(fmt!(\"Asked to register intrinsic fn\"));\n+            }\n \n-type wrap_arg_builder<'self> = &'self fn(bcx: @mut Block,\n-                                         tys: &ShimTypes,\n-                                         llwrapfn: ValueRef,\n-                                         llargbundle: ValueRef);\n-\n-type wrap_ret_builder<'self> = &'self fn(bcx: @mut Block,\n-                                         tys: &ShimTypes,\n-                                         llargbundle: ValueRef);\n-\n-fn build_wrap_fn_(ccx: @mut CrateContext,\n-                  tys: &ShimTypes,\n-                  llshimfn: ValueRef,\n-                  llwrapfn: ValueRef,\n-                  shim_upcall: ValueRef,\n-                  needs_c_return: bool,\n-                  arg_builder: wrap_arg_builder,\n-                  ret_builder: wrap_ret_builder) {\n-    let _icx = push_ctxt(\"foreign::build_wrap_fn_\");\n-    let fcx = new_fn_ctxt(ccx, ~[], llwrapfn, tys.fn_sig.output, None);\n-    let bcx = fcx.entry_bcx.unwrap();\n-\n-    // Patch up the return type if it's not immediate and we're returning via\n-    // the C ABI.\n-    if needs_c_return && !ty::type_is_immediate(ccx.tcx, tys.fn_sig.output) {\n-        let lloutputtype = type_of::type_of(fcx.ccx, tys.fn_sig.output);\n-        fcx.llretptr = Some(alloca(bcx, lloutputtype, \"\"));\n-    }\n+            Rust => {\n+                // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n+                ccx.sess.unimpl(\n+                    fmt!(\"Foreign functions with Rust ABI\"));\n+            }\n \n-    // Allocate the struct and write the arguments into it.\n-    let llargbundle = alloca(bcx, tys.bundle_ty, \"__llargbundle\");\n-    arg_builder(bcx, tys, llwrapfn, llargbundle);\n+            Stdcall => lib::llvm::X86StdcallCallConv,\n+            Fastcall => lib::llvm::X86FastcallCallConv,\n+            C => lib::llvm::CCallConv,\n \n-    // Create call itself.\n-    let llshimfnptr = PointerCast(bcx, llshimfn, Type::i8p());\n-    let llrawargbundle = PointerCast(bcx, llargbundle, Type::i8p());\n-    Call(bcx, shim_upcall, [llrawargbundle, llshimfnptr]);\n-    ret_builder(bcx, tys, llargbundle);\n+            // NOTE These API constants ought to be more specific\n+            Cdecl => lib::llvm::CCallConv,\n+            Aapcs => lib::llvm::CCallConv,\n+        }\n+    })\n+}\n \n-    // Then return according to the C ABI.\n-    let return_context = match fcx.llreturn {\n-        Some(llreturn) => raw_block(fcx, false, llreturn),\n-        None => bcx\n-    };\n \n-    let llfunctiontype = val_ty(llwrapfn);\n-    let llfunctiontype = llfunctiontype.element_type();\n-    let return_type = llfunctiontype.return_type();\n-    if return_type.kind() == ::lib::llvm::Void {\n-        // XXX: This might be wrong if there are any functions for which\n-        // the C ABI specifies a void output pointer and the Rust ABI\n-        // does not.\n-        RetVoid(return_context);\n-    } else {\n-        // Cast if we have to...\n-        // XXX: This is ugly.\n-        let llretptr = BitCast(return_context, fcx.llretptr.unwrap(), return_type.ptr_to());\n-        Ret(return_context, Load(return_context, llretptr));\n-    }\n-    fcx.cleanup();\n-}\n+pub fn register_foreign_item_fn(ccx: @mut CrateContext,\n+                                abis: AbiSet,\n+                                path: &ast_map::path,\n+                                foreign_item: @ast::foreign_item) -> ValueRef {\n+    /*!\n+     * Registers a foreign function found in a library.\n+     * Just adds a LLVM global.\n+     */\n \n-// For each foreign function F, we generate a wrapper function W and a shim\n-// function S that all work together.  The wrapper function W is the function\n-// that other rust code actually invokes.  Its job is to marshall the\n-// arguments into a struct.  It then uses a small bit of assembly to switch\n-// over to the C stack and invoke the shim function.  The shim function S then\n-// unpacks the arguments from the struct and invokes the actual function F\n-// according to its specified calling convention.\n-//\n-// Example: Given a foreign c-stack function F(x: X, y: Y) -> Z,\n-// we generate a wrapper function W that looks like:\n-//\n-//    void W(Z* dest, void *env, X x, Y y) {\n-//        struct { X x; Y y; Z *z; } args = { x, y, z };\n-//        call_on_c_stack_shim(S, &args);\n-//    }\n-//\n-// The shim function S then looks something like:\n-//\n-//     void S(struct { X x; Y y; Z *z; } *args) {\n-//         *args->z = F(args->x, args->y);\n-//     }\n-//\n-// However, if the return type of F is dynamically sized or of aggregate type,\n-// the shim function looks like:\n-//\n-//     void S(struct { X x; Y y; Z *z; } *args) {\n-//         F(args->z, args->x, args->y);\n-//     }\n-//\n-// Note: on i386, the layout of the args struct is generally the same\n-// as the desired layout of the arguments on the C stack.  Therefore,\n-// we could use upcall_alloc_c_stack() to allocate the `args`\n-// structure and switch the stack pointer appropriately to avoid a\n-// round of copies.  (In fact, the shim function itself is\n-// unnecessary). We used to do this, in fact, and will perhaps do so\n-// in the future.\n-pub fn trans_foreign_mod(ccx: @mut CrateContext,\n-                         path: &ast_map::path,\n-                         foreign_mod: &ast::foreign_mod) {\n-    let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n+    debug!(\"register_foreign_item_fn(abis=%s, \\\n+            path=%s, \\\n+            foreign_item.id=%?)\",\n+           abis.repr(ccx.tcx),\n+           path.repr(ccx.tcx),\n+           foreign_item.id);\n \n-    let arch = ccx.sess.targ_cfg.arch;\n-    let abi = match foreign_mod.abis.for_arch(arch) {\n+    let cc = match llvm_calling_convention(ccx, abis) {\n+        Some(cc) => cc,\n         None => {\n+            // FIXME(#8357) We really ought to report a span here\n             ccx.sess.fatal(\n-                fmt!(\"No suitable ABI for target architecture \\\n+                fmt!(\"ABI `%s` has no suitable ABI \\\n+                      for target architecture \\\n                       in module %s\",\n+                     abis.user_string(ccx.tcx),\n                      ast_map::path_to_str(*path,\n                                           ccx.sess.intr())));\n         }\n-\n-        Some(abi) => abi,\n     };\n \n-    for &foreign_item in foreign_mod.items.iter() {\n-        match foreign_item.node {\n-            ast::foreign_item_fn(*) => {\n-                let id = foreign_item.id;\n-                match abi {\n-                    RustIntrinsic => {\n-                        // Intrinsics are emitted by monomorphic fn\n-                    }\n-\n-                    Rust => {\n-                        // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n-                        ccx.sess.unimpl(\n-                            fmt!(\"Foreign functions with Rust ABI\"));\n-                    }\n-\n-                    Stdcall => {\n-                        build_foreign_fn(ccx, id, foreign_item,\n-                                         lib::llvm::X86StdcallCallConv);\n-                    }\n-\n-                    Fastcall => {\n-                        build_foreign_fn(ccx, id, foreign_item,\n-                                         lib::llvm::X86FastcallCallConv);\n-                    }\n-\n-                    Cdecl => {\n-                        // FIXME(#3678) should really be more specific\n-                        build_foreign_fn(ccx, id, foreign_item,\n-                                         lib::llvm::CCallConv);\n-                    }\n-\n-                    Aapcs => {\n-                        // FIXME(#3678) should really be more specific\n-                        build_foreign_fn(ccx, id, foreign_item,\n-                                         lib::llvm::CCallConv);\n-                    }\n-\n-                    C => {\n-                        build_foreign_fn(ccx, id, foreign_item,\n-                                         lib::llvm::CCallConv);\n-                    }\n-                }\n-            }\n-            ast::foreign_item_static(*) => {\n-                let ident = token::ident_to_str(&foreign_item.ident);\n-                ccx.item_symbols.insert(foreign_item.id, /* bad */ident.to_owned());\n-            }\n-        }\n-    }\n+    // Register the function as a C extern fn\n+    let lname = link_name(ccx, foreign_item);\n+    let tys = foreign_types_for_id(ccx, foreign_item.id);\n \n-    fn build_foreign_fn(ccx: @mut CrateContext,\n-                        id: ast::NodeId,\n-                        foreign_item: @ast::foreign_item,\n-                        cc: lib::llvm::CallConv) {\n-        let llwrapfn = get_item_val(ccx, id);\n-        let tys = shim_types(ccx, id);\n-        if attr::contains_name(foreign_item.attrs, \"rust_stack\") {\n-            build_direct_fn(ccx, llwrapfn, foreign_item,\n-                            &tys, cc);\n-        } else if attr::contains_name(foreign_item.attrs, \"fast_ffi\") {\n-            build_fast_ffi_fn(ccx, llwrapfn, foreign_item, &tys, cc);\n-        } else {\n-            let llshimfn = build_shim_fn(ccx, foreign_item, &tys, cc);\n-            build_wrap_fn(ccx, &tys, llshimfn, llwrapfn);\n-        }\n-    }\n+    // Create the LLVM value for the C extern fn\n+    let llfn_ty = lltype_for_fn_from_foreign_types(&tys);\n+    let llfn = base::get_extern_fn(&mut ccx.externs, ccx.llmod,\n+                                   lname, cc, llfn_ty);\n+    add_argument_attributes(&tys, llfn);\n \n-    fn build_shim_fn(ccx: @mut CrateContext,\n-                     foreign_item: &ast::foreign_item,\n-                     tys: &ShimTypes,\n-                     cc: lib::llvm::CallConv)\n-                  -> ValueRef {\n-        /*!\n-         *\n-         * Build S, from comment above:\n-         *\n-         *     void S(struct { X x; Y y; Z *z; } *args) {\n-         *         F(args->z, args->x, args->y);\n-         *     }\n-         */\n-\n-        let _icx = push_ctxt(\"foreign::build_shim_fn\");\n-\n-        fn build_args(bcx: @mut Block, tys: &ShimTypes, llargbundle: ValueRef)\n-                   -> ~[ValueRef] {\n-            let _icx = push_ctxt(\"foreign::shim::build_args\");\n-            tys.fn_ty.build_shim_args(bcx, tys.llsig.llarg_tys, llargbundle)\n-        }\n+    return llfn;\n+}\n \n-        fn build_ret(bcx: @mut Block,\n-                     tys: &ShimTypes,\n-                     llargbundle: ValueRef,\n-                     llretval: ValueRef) {\n-            let _icx = push_ctxt(\"foreign::shim::build_ret\");\n-            tys.fn_ty.build_shim_ret(bcx,\n-                                     tys.llsig.llarg_tys,\n-                                     tys.ret_def,\n-                                     llargbundle,\n-                                     llretval);\n-        }\n+pub fn trans_native_call(bcx: @mut Block,\n+                         callee_ty: ty::t,\n+                         llfn: ValueRef,\n+                         llretptr: ValueRef,\n+                         llargs_rust: &[ValueRef]) -> @mut Block {\n+    /*!\n+     * Prepares a call to a native function. This requires adapting\n+     * from the Rust argument passing rules to the native rules.\n+     *\n+     * # Parameters\n+     *\n+     * - `callee_ty`: Rust type for the function we are calling\n+     * - `llfn`: the function pointer we are calling\n+     * - `llretptr`: where to store the return value of the function\n+     * - `llargs_rust`: a list of the argument values, prepared\n+     *   as they would be if calling a Rust function\n+     */\n \n-        let lname = link_name(ccx, foreign_item);\n-        let llbasefn = base_fn(ccx, lname, tys, cc);\n-        // Name the shim function\n-        let shim_name = fmt!(\"%s__c_stack_shim\", lname);\n-        build_shim_fn_(ccx,\n-                       shim_name,\n-                       llbasefn,\n-                       tys,\n-                       cc,\n-                       build_args,\n-                       build_ret)\n-    }\n+    let ccx = bcx.ccx();\n+    let tcx = bcx.tcx();\n \n-    fn base_fn(ccx: &CrateContext,\n-               lname: &str,\n-               tys: &ShimTypes,\n-               cc: lib::llvm::CallConv)\n-               -> ValueRef {\n-        // Declare the \"prototype\" for the base function F:\n-        do tys.fn_ty.decl_fn |fnty| {\n-            decl_fn(ccx.llmod, lname, cc, fnty)\n-        }\n-    }\n+    debug!(\"trans_native_call(callee_ty=%s, \\\n+            llfn=%s, \\\n+            llretptr=%s)\",\n+           callee_ty.repr(tcx),\n+           ccx.tn.val_to_str(llfn),\n+           ccx.tn.val_to_str(llretptr));\n \n-    // FIXME (#2535): this is very shaky and probably gets ABIs wrong all\n-    // over the place\n-    fn build_direct_fn(ccx: @mut CrateContext,\n-                       decl: ValueRef,\n-                       item: &ast::foreign_item,\n-                       tys: &ShimTypes,\n-                       cc: lib::llvm::CallConv) {\n-        debug!(\"build_direct_fn(%s)\", link_name(ccx, item));\n-\n-        let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n-        let bcx = fcx.entry_bcx.unwrap();\n-        let llbasefn = base_fn(ccx, link_name(ccx, item), tys, cc);\n-        let ty = ty::lookup_item_type(ccx.tcx,\n-                                      ast_util::local_def(item.id)).ty;\n-        let ret_ty = ty::ty_fn_ret(ty);\n-        let args = vec::from_fn(ty::ty_fn_args(ty).len(), |i| {\n-            get_param(decl, fcx.arg_pos(i))\n-        });\n-        let retval = Call(bcx, llbasefn, args);\n-        if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n-            Store(bcx, retval, fcx.llretptr.unwrap());\n+    let (fn_abis, fn_sig) = match ty::get(callee_ty).sty {\n+        ty::ty_bare_fn(ref fn_ty) => (fn_ty.abis, fn_ty.sig.clone()),\n+        _ => ccx.sess.bug(\"trans_native_call called on non-function type\")\n+    };\n+    let llsig = foreign_signature(ccx, &fn_sig);\n+    let ret_def = !ty::type_is_voidish(fn_sig.output);\n+    let fn_type = cabi::compute_abi_info(ccx,\n+                                         llsig.llarg_tys,\n+                                         llsig.llret_ty,\n+                                         ret_def);\n+\n+    let all_arg_tys: &[cabi::LLVMType] = fn_type.arg_tys;\n+    let all_attributes: &[Option<Attribute>] = fn_type.attrs;\n+\n+    let mut llargs_foreign = ~[];\n+\n+    // If the foreign ABI expects return value by pointer, supply the\n+    // pointer that Rust gave us. Sometimes we have to bitcast\n+    // because foreign fns return slightly different (but equivalent)\n+    // views on the same type (e.g., i64 in place of {i32,i32}).\n+    let (arg_tys, attributes) = {\n+        if fn_type.sret {\n+            if all_arg_tys[0].cast {\n+                let llcastedretptr =\n+                    BitCast(bcx, llretptr, all_arg_tys[0].ty.ptr_to());\n+                llargs_foreign.push(llcastedretptr);\n+            } else {\n+                llargs_foreign.push(llretptr);\n+            }\n+            (all_arg_tys.tail(), all_attributes.tail())\n+        } else {\n+            (all_arg_tys, all_attributes)\n         }\n-        finish_fn(fcx, bcx);\n-    }\n+    };\n \n-    // FIXME (#2535): this is very shaky and probably gets ABIs wrong all\n-    // over the place\n-    fn build_fast_ffi_fn(ccx: @mut CrateContext,\n-                         decl: ValueRef,\n-                         item: &ast::foreign_item,\n-                         tys: &ShimTypes,\n-                         cc: lib::llvm::CallConv) {\n-        debug!(\"build_fast_ffi_fn(%s)\", link_name(ccx, item));\n-\n-        let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n-        let bcx = fcx.entry_bcx.unwrap();\n-        let llbasefn = base_fn(ccx, link_name(ccx, item), tys, cc);\n-        set_no_inline(fcx.llfn);\n-        set_fixed_stack_segment(fcx.llfn);\n-        let ty = ty::lookup_item_type(ccx.tcx,\n-                                      ast_util::local_def(item.id)).ty;\n-        let ret_ty = ty::ty_fn_ret(ty);\n-        let args = vec::from_fn(ty::ty_fn_args(ty).len(), |i| {\n-            get_param(decl, fcx.arg_pos(i))\n-        });\n-        let retval = Call(bcx, llbasefn, args);\n-        if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n-            Store(bcx, retval, fcx.llretptr.unwrap());\n-        }\n-        finish_fn(fcx, bcx);\n-    }\n+    for (i, &llarg_rust) in llargs_rust.iter().enumerate() {\n+        let mut llarg_rust = llarg_rust;\n \n-    fn build_wrap_fn(ccx: @mut CrateContext,\n-                     tys: &ShimTypes,\n-                     llshimfn: ValueRef,\n-                     llwrapfn: ValueRef) {\n-        /*!\n-         *\n-         * Build W, from comment above:\n-         *\n-         *     void W(Z* dest, void *env, X x, Y y) {\n-         *         struct { X x; Y y; Z *z; } args = { x, y, z };\n-         *         call_on_c_stack_shim(S, &args);\n-         *     }\n-         *\n-         * One thing we have to be very careful of is to\n-         * account for the Rust modes.\n-         */\n-\n-        let _icx = push_ctxt(\"foreign::build_wrap_fn\");\n-\n-        build_wrap_fn_(ccx,\n-                       tys,\n-                       llshimfn,\n-                       llwrapfn,\n-                       ccx.upcalls.call_shim_on_c_stack,\n-                       false,\n-                       build_args,\n-                       build_ret);\n-\n-        fn build_args(bcx: @mut Block,\n-                      tys: &ShimTypes,\n-                      llwrapfn: ValueRef,\n-                      llargbundle: ValueRef) {\n-            let _icx = push_ctxt(\"foreign::wrap::build_args\");\n-            let ccx = bcx.ccx();\n-            let n = tys.llsig.llarg_tys.len();\n-            for i in range(0u, n) {\n-                let arg_i = bcx.fcx.arg_pos(i);\n-                let mut llargval = get_param(llwrapfn, arg_i);\n-\n-                // In some cases, Rust will pass a pointer which the\n-                // native C type doesn't have.  In that case, just\n-                // load the value from the pointer.\n-                if type_of::arg_is_indirect(ccx, &tys.fn_sig.inputs[i]) {\n-                    llargval = Load(bcx, llargval);\n-                }\n+        // Does Rust pass this argument by pointer?\n+        let rust_indirect = type_of::arg_is_indirect(ccx, fn_sig.inputs[i]);\n \n-                store_inbounds(bcx, llargval, llargbundle, [0u, i]);\n-            }\n+        debug!(\"argument %u, llarg_rust=%s, rust_indirect=%b, arg_ty=%s\",\n+               i,\n+               ccx.tn.val_to_str(llarg_rust),\n+               rust_indirect,\n+               ccx.tn.type_to_str(arg_tys[i].ty));\n \n-            for &retptr in bcx.fcx.llretptr.iter() {\n-                store_inbounds(bcx, retptr, llargbundle, [0u, n]);\n-            }\n+        // Ensure that we always have the Rust value indirectly,\n+        // because it makes bitcasting easier.\n+        if !rust_indirect {\n+            let scratch = base::alloca(bcx, arg_tys[i].ty, \"__arg\");\n+            Store(bcx, llarg_rust, scratch);\n+            llarg_rust = scratch;\n         }\n \n-        fn build_ret(bcx: @mut Block,\n-                     shim_types: &ShimTypes,\n-                     llargbundle: ValueRef) {\n-            let _icx = push_ctxt(\"foreign::wrap::build_ret\");\n-            let arg_count = shim_types.fn_sig.inputs.len();\n-            for &retptr in bcx.fcx.llretptr.iter() {\n-                let llretptr = load_inbounds(bcx, llargbundle, [0, arg_count]);\n-                Store(bcx, Load(bcx, llretptr), retptr);\n-            }\n-        }\n-    }\n-}\n+        debug!(\"llarg_rust=%s (after indirection)\",\n+               ccx.tn.val_to_str(llarg_rust));\n \n-pub fn trans_intrinsic(ccx: @mut CrateContext,\n-                       decl: ValueRef,\n-                       item: &ast::foreign_item,\n-                       path: ast_map::path,\n-                       substs: @param_substs,\n-                       attributes: &[ast::Attribute],\n-                       ref_id: Option<ast::NodeId>) {\n-    debug!(\"trans_intrinsic(item.ident=%s)\", ccx.sess.str_of(item.ident));\n-\n-    fn simple_llvm_intrinsic(bcx: @mut Block, name: &'static str, num_args: uint) {\n-        assert!(num_args <= 4);\n-        let mut args = [0 as ValueRef, ..4];\n-        let first_real_arg = bcx.fcx.arg_pos(0u);\n-        for i in range(0u, num_args) {\n-            args[i] = get_param(bcx.fcx.llfn, first_real_arg + i);\n+        // Check whether we need to do any casting\n+        let foreignarg_ty = arg_tys[i].ty;\n+        if arg_tys[i].cast {\n+            llarg_rust = BitCast(bcx, llarg_rust, foreignarg_ty.ptr_to());\n         }\n-        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        Ret(bcx, Call(bcx, llfn, args.slice(0, num_args)));\n-    }\n-\n-    fn with_overflow_instrinsic(bcx: @mut Block, name: &'static str) {\n-        let first_real_arg = bcx.fcx.arg_pos(0u);\n-        let a = get_param(bcx.fcx.llfn, first_real_arg);\n-        let b = get_param(bcx.fcx.llfn, first_real_arg + 1);\n-        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-\n-        // convert `i1` to a `bool`, and write to the out parameter\n-        let val = Call(bcx, llfn, [a, b]);\n-        let result = ExtractValue(bcx, val, 0);\n-        let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool());\n-        let retptr = get_param(bcx.fcx.llfn, bcx.fcx.out_arg_pos());\n-        let ret = Load(bcx, retptr);\n-        let ret = InsertValue(bcx, ret, result, 0);\n-        let ret = InsertValue(bcx, ret, overflow, 1);\n-        Store(bcx, ret, retptr);\n-        RetVoid(bcx)\n-    }\n \n-    fn memcpy_intrinsic(bcx: @mut Block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n-        let ccx = bcx.ccx();\n-        let lltp_ty = type_of::type_of(ccx, tp_ty);\n-        let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n-        let size = match sizebits {\n-            32 => C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32),\n-            64 => C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64),\n-            _ => ccx.sess.fatal(\"Invalid value for sizebits\")\n-        };\n+        debug!(\"llarg_rust=%s (after casting)\",\n+               ccx.tn.val_to_str(llarg_rust));\n \n-        let decl = bcx.fcx.llfn;\n-        let first_real_arg = bcx.fcx.arg_pos(0u);\n-        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n-        let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n-        let count = get_param(decl, first_real_arg + 2);\n-        let volatile = C_i1(false);\n-        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n-        RetVoid(bcx);\n-    }\n-\n-    fn memset_intrinsic(bcx: @mut Block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n-        let ccx = bcx.ccx();\n-        let lltp_ty = type_of::type_of(ccx, tp_ty);\n-        let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n-        let size = match sizebits {\n-            32 => C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32),\n-            64 => C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64),\n-            _ => ccx.sess.fatal(\"Invalid value for sizebits\")\n+        // Finally, load the value if needed for the foreign ABI\n+        let foreign_indirect = attributes[i].is_some();\n+        let llarg_foreign = if foreign_indirect {\n+            llarg_rust\n+        } else {\n+            Load(bcx, llarg_rust)\n         };\n \n-        let decl = bcx.fcx.llfn;\n-        let first_real_arg = bcx.fcx.arg_pos(0u);\n-        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n-        let val = get_param(decl, first_real_arg + 1);\n-        let count = get_param(decl, first_real_arg + 2);\n-        let volatile = C_i1(false);\n-        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile]);\n-        RetVoid(bcx);\n-    }\n+        debug!(\"argument %u, llarg_foreign=%s\",\n+               i, ccx.tn.val_to_str(llarg_foreign));\n \n-    fn count_zeros_intrinsic(bcx: @mut Block, name: &'static str) {\n-        let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n-        let y = C_i1(false);\n-        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        Ret(bcx, Call(bcx, llfn, [x, y]));\n+        llargs_foreign.push(llarg_foreign);\n     }\n \n-    let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n-\n-    let fcx = new_fn_ctxt_w_id(ccx,\n-                               path,\n-                               decl,\n-                               item.id,\n-                               output_type,\n-                               true,\n-                               Some(substs),\n-                               None,\n-                               Some(item.span));\n-\n-    set_always_inline(fcx.llfn);\n+    let cc = match llvm_calling_convention(ccx, fn_abis) {\n+        Some(cc) => cc,\n+        None => {\n+            // FIXME(#8357) We really ought to report a span here\n+            ccx.sess.fatal(\n+                fmt!(\"ABI string `%s` has no suitable ABI \\\n+                      for target architecture\",\n+                     fn_abis.user_string(ccx.tcx)));\n+        }\n+    };\n \n-    // Set the fixed stack segment flag if necessary.\n-    if attr::contains_name(attributes, \"fixed_stack_segment\") {\n-        set_fixed_stack_segment(fcx.llfn);\n-    }\n+    let llforeign_retval = CallWithConv(bcx, llfn, llargs_foreign, cc);\n \n-    let mut bcx = fcx.entry_bcx.unwrap();\n-    let first_real_arg = fcx.arg_pos(0u);\n+    // If the function we just called does not use an outpointer,\n+    // store the result into the rust outpointer. Cast the outpointer\n+    // type to match because some ABIs will use a different type than\n+    // the Rust type. e.g., a {u32,u32} struct could be returned as\n+    // u64.\n+    if ret_def && !fn_type.sret {\n+        let llrust_ret_ty = llsig.llret_ty;\n+        let llforeign_ret_ty = fn_type.ret_ty.ty;\n \n-    let nm = ccx.sess.str_of(item.ident);\n-    let name = nm.as_slice();\n+        debug!(\"llretptr=%s\", ccx.tn.val_to_str(llretptr));\n+        debug!(\"llforeign_retval=%s\", ccx.tn.val_to_str(llforeign_retval));\n+        debug!(\"llrust_ret_ty=%s\", ccx.tn.type_to_str(llrust_ret_ty));\n+        debug!(\"llforeign_ret_ty=%s\", ccx.tn.type_to_str(llforeign_ret_ty));\n \n-    // This requires that atomic intrinsics follow a specific naming pattern:\n-    // \"atomic_<operation>[_<ordering>], and no ordering means SeqCst\n-    if name.starts_with(\"atomic_\") {\n-        let split : ~[&str] = name.split_iter('_').collect();\n-        assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n-        let order = if split.len() == 2 {\n-            lib::llvm::SequentiallyConsistent\n+        if llrust_ret_ty == llforeign_ret_ty {\n+            Store(bcx, llforeign_retval, llretptr);\n         } else {\n-            match split[2] {\n-                \"relaxed\" => lib::llvm::Monotonic,\n-                \"acq\"     => lib::llvm::Acquire,\n-                \"rel\"     => lib::llvm::Release,\n-                \"acqrel\"  => lib::llvm::AcquireRelease,\n-                _ => ccx.sess.fatal(\"Unknown ordering in atomic intrinsic\")\n-            }\n-        };\n-\n-        match split[1] {\n-            \"cxchg\" => {\n-                let old = AtomicCmpXchg(bcx, get_param(decl, first_real_arg),\n-                                        get_param(decl, first_real_arg + 1u),\n-                                        get_param(decl, first_real_arg + 2u),\n-                                        order);\n-                Ret(bcx, old);\n-            }\n-            \"load\" => {\n-                let old = AtomicLoad(bcx, get_param(decl, first_real_arg),\n-                                     order);\n-                Ret(bcx, old);\n-            }\n-            \"store\" => {\n-                AtomicStore(bcx, get_param(decl, first_real_arg + 1u),\n-                            get_param(decl, first_real_arg),\n-                            order);\n-                RetVoid(bcx);\n-            }\n-            \"fence\" => {\n-                AtomicFence(bcx, order);\n-                RetVoid(bcx);\n-            }\n-            op => {\n-                // These are all AtomicRMW ops\n-                let atom_op = match op {\n-                    \"xchg\"  => lib::llvm::Xchg,\n-                    \"xadd\"  => lib::llvm::Add,\n-                    \"xsub\"  => lib::llvm::Sub,\n-                    \"and\"   => lib::llvm::And,\n-                    \"nand\"  => lib::llvm::Nand,\n-                    \"or\"    => lib::llvm::Or,\n-                    \"xor\"   => lib::llvm::Xor,\n-                    \"max\"   => lib::llvm::Max,\n-                    \"min\"   => lib::llvm::Min,\n-                    \"umax\"  => lib::llvm::UMax,\n-                    \"umin\"  => lib::llvm::UMin,\n-                    _ => ccx.sess.fatal(\"Unknown atomic operation\")\n-                };\n-\n-                let old = AtomicRMW(bcx, atom_op, get_param(decl, first_real_arg),\n-                                    get_param(decl, first_real_arg + 1u),\n-                                    order);\n-                Ret(bcx, old);\n-            }\n+            // The actual return type is a struct, but the ABI\n+            // adaptation code has cast it into some scalar type.  The\n+            // code that follows is the only reliable way I have\n+            // found to do a transform like i64 -> {i32,i32}.\n+            // Basically we dump the data onto the stack then memcpy it.\n+            //\n+            // Other approaches I tried:\n+            // - Casting rust ret pointer to the foreign type and using Store\n+            //   is (a) unsafe if size of foreign type > size of rust type and\n+            //   (b) runs afoul of strict aliasing rules, yielding invalid\n+            //   assembly under -O (specifically, the store gets removed).\n+            // - Truncating foreign type to correct integral type and then\n+            //   bitcasting to the struct type yields invalid cast errors.\n+            let llscratch = base::alloca(bcx, llforeign_ret_ty, \"__cast\");\n+            Store(bcx, llforeign_retval, llscratch);\n+            let llscratch_i8 = BitCast(bcx, llscratch, Type::i8().ptr_to());\n+            let llretptr_i8 = BitCast(bcx, llretptr, Type::i8().ptr_to());\n+            let llrust_size = machine::llsize_of_store(ccx, llrust_ret_ty);\n+            let llforeign_align = machine::llalign_of_min(ccx, llforeign_ret_ty);\n+            let llrust_align = machine::llalign_of_min(ccx, llrust_ret_ty);\n+            let llalign = uint::min(llforeign_align, llrust_align);\n+            debug!(\"llrust_size=%?\", llrust_size);\n+            base::call_memcpy(bcx, llretptr_i8, llscratch_i8,\n+                              C_uint(ccx, llrust_size), llalign as u32);\n         }\n-\n-        fcx.cleanup();\n-        return;\n     }\n \n-    match name {\n-        \"size_of\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            Ret(bcx, C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty)));\n-        }\n-        \"move_val\" => {\n-            // Create a datum reflecting the value being moved.\n-            // Use `appropriate_mode` so that the datum is by ref\n-            // if the value is non-immediate. Note that, with\n-            // intrinsics, there are no argument cleanups to\n-            // concern ourselves with.\n-            let tp_ty = substs.tys[0];\n-            let mode = appropriate_mode(ccx.tcx, tp_ty);\n-            let src = Datum {val: get_param(decl, first_real_arg + 1u),\n-                             ty: tp_ty, mode: mode};\n-            bcx = src.move_to(bcx, DROP_EXISTING,\n-                              get_param(decl, first_real_arg));\n-            RetVoid(bcx);\n-        }\n-        \"move_val_init\" => {\n-            // See comments for `\"move_val\"`.\n-            let tp_ty = substs.tys[0];\n-            let mode = appropriate_mode(ccx.tcx, tp_ty);\n-            let src = Datum {val: get_param(decl, first_real_arg + 1u),\n-                             ty: tp_ty, mode: mode};\n-            bcx = src.move_to(bcx, INIT, get_param(decl, first_real_arg));\n-            RetVoid(bcx);\n-        }\n-        \"min_align_of\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            Ret(bcx, C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty)));\n-        }\n-        \"pref_align_of\"=> {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            Ret(bcx, C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty)));\n-        }\n-        \"get_tydesc\" => {\n-            let tp_ty = substs.tys[0];\n-            let static_ti = get_tydesc(ccx, tp_ty);\n-            glue::lazily_emit_all_tydesc_glue(ccx, static_ti);\n-\n-            // FIXME (#3730): ideally this shouldn't need a cast,\n-            // but there's a circularity between translating rust types to llvm\n-            // types and having a tydesc type available. So I can't directly access\n-            // the llvm type of intrinsic::TyDesc struct.\n-            let userland_tydesc_ty = type_of::type_of(ccx, output_type);\n-            let td = PointerCast(bcx, static_ti.tydesc, userland_tydesc_ty);\n-            Ret(bcx, td);\n-        }\n-        \"init\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            match bcx.fcx.llretptr {\n-                Some(ptr) => { Store(bcx, C_null(lltp_ty), ptr); RetVoid(bcx); }\n-                None if ty::type_is_nil(tp_ty) => RetVoid(bcx),\n-                None => Ret(bcx, C_null(lltp_ty)),\n-            }\n-        }\n-        \"uninit\" => {\n-            // Do nothing, this is effectively a no-op\n-            let retty = substs.tys[0];\n-            if ty::type_is_immediate(ccx.tcx, retty) && !ty::type_is_nil(retty) {\n-                unsafe {\n-                    Ret(bcx, lib::llvm::llvm::LLVMGetUndef(type_of(ccx, retty).to_ref()));\n-                }\n-            } else {\n-                RetVoid(bcx)\n-            }\n-        }\n-        \"forget\" => {\n-            RetVoid(bcx);\n-        }\n-        \"transmute\" => {\n-            let (in_type, out_type) = (substs.tys[0], substs.tys[1]);\n-            let llintype = type_of::type_of(ccx, in_type);\n-            let llouttype = type_of::type_of(ccx, out_type);\n-\n-            let in_type_size = machine::llbitsize_of_real(ccx, llintype);\n-            let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n-            if in_type_size != out_type_size {\n-                let sp = match ccx.tcx.items.get_copy(&ref_id.unwrap()) {\n-                    ast_map::node_expr(e) => e.span,\n-                    _ => fail!(\"transmute has non-expr arg\"),\n-                };\n-                let pluralize = |n| if 1u == n { \"\" } else { \"s\" };\n-                ccx.sess.span_fatal(sp,\n-                                    fmt!(\"transmute called on types with \\\n-                                          different sizes: %s (%u bit%s) to \\\n-                                          %s (%u bit%s)\",\n-                                         ty_to_str(ccx.tcx, in_type),\n-                                         in_type_size,\n-                                         pluralize(in_type_size),\n-                                         ty_to_str(ccx.tcx, out_type),\n-                                         out_type_size,\n-                                         pluralize(out_type_size)));\n-            }\n+    return bcx;\n+}\n \n-            if !ty::type_is_nil(out_type) {\n-                let llsrcval = get_param(decl, first_real_arg);\n-                if ty::type_is_immediate(ccx.tcx, in_type) {\n-                    match fcx.llretptr {\n-                        Some(llretptr) => {\n-                            Store(bcx, llsrcval, PointerCast(bcx, llretptr, llintype.ptr_to()));\n-                            RetVoid(bcx);\n-                        }\n-                        None => match (llintype.kind(), llouttype.kind()) {\n-                            (Pointer, other) | (other, Pointer) if other != Pointer => {\n-                                let tmp = Alloca(bcx, llouttype, \"\");\n-                                Store(bcx, llsrcval, PointerCast(bcx, tmp, llintype.ptr_to()));\n-                                Ret(bcx, Load(bcx, tmp));\n-                            }\n-                            _ => Ret(bcx, BitCast(bcx, llsrcval, llouttype))\n-                        }\n-                    }\n-                } else if ty::type_is_immediate(ccx.tcx, out_type) {\n-                    let llsrcptr = PointerCast(bcx, llsrcval, llouttype.ptr_to());\n-                    Ret(bcx, Load(bcx, llsrcptr));\n-                } else {\n-                    // NB: Do not use a Load and Store here. This causes massive\n-                    // code bloat when `transmute` is used on large structural\n-                    // types.\n-                    let lldestptr = fcx.llretptr.unwrap();\n-                    let lldestptr = PointerCast(bcx, lldestptr, Type::i8p());\n-                    let llsrcptr = PointerCast(bcx, llsrcval, Type::i8p());\n-\n-                    let llsize = llsize_of(ccx, llintype);\n-                    call_memcpy(bcx, lldestptr, llsrcptr, llsize, 1);\n-                    RetVoid(bcx);\n-                };\n-            } else {\n-                RetVoid(bcx);\n-            }\n-        }\n-        \"needs_drop\" => {\n-            let tp_ty = substs.tys[0];\n-            Ret(bcx, C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)));\n-        }\n-        \"contains_managed\" => {\n-            let tp_ty = substs.tys[0];\n-            Ret(bcx, C_bool(ty::type_contents(ccx.tcx, tp_ty).contains_managed()));\n-        }\n-        \"visit_tydesc\" => {\n-            let td = get_param(decl, first_real_arg);\n-            let visitor = get_param(decl, first_real_arg + 1u);\n-            let td = PointerCast(bcx, td, ccx.tydesc_type.ptr_to());\n-            glue::call_tydesc_glue_full(bcx, visitor, td,\n-                                        abi::tydesc_field_visit_glue, None);\n-            RetVoid(bcx);\n-        }\n-        \"frame_address\" => {\n-            let frameaddress = ccx.intrinsics.get_copy(& &\"llvm.frameaddress\");\n-            let frameaddress_val = Call(bcx, frameaddress, [C_i32(0i32)]);\n-            let star_u8 = ty::mk_imm_ptr(\n-                bcx.tcx(),\n-                ty::mk_mach_uint(ast::ty_u8));\n-            let fty = ty::mk_closure(bcx.tcx(), ty::ClosureTy {\n-                purity: ast::impure_fn,\n-                sigil: ast::BorrowedSigil,\n-                onceness: ast::Many,\n-                region: ty::re_bound(ty::br_anon(0)),\n-                bounds: ty::EmptyBuiltinBounds(),\n-                sig: FnSig {\n-                    bound_lifetime_names: opt_vec::Empty,\n-                    inputs: ~[ star_u8 ],\n-                    output: ty::mk_nil()\n-                }\n-            });\n-            let datum = Datum {val: get_param(decl, first_real_arg),\n-                               mode: ByRef(ZeroMem), ty: fty};\n-            let arg_vals = ~[frameaddress_val];\n-            bcx = trans_call_inner(\n-                bcx, None, fty, ty::mk_nil(),\n-                |bcx| Callee {bcx: bcx, data: Closure(datum)},\n-                ArgVals(arg_vals), Some(Ignore), DontAutorefArg).bcx;\n-            RetVoid(bcx);\n-        }\n-        \"morestack_addr\" => {\n-            // XXX This is a hack to grab the address of this particular\n-            // native function. There should be a general in-language\n-            // way to do this\n-            let llfty = type_of_fn(bcx.ccx(), [], ty::mk_nil());\n-            let morestack_addr = decl_cdecl_fn(\n-                bcx.ccx().llmod, \"__morestack\", llfty);\n-            let morestack_addr = PointerCast(bcx, morestack_addr, Type::nil().ptr_to());\n-            Ret(bcx, morestack_addr);\n-        }\n-        \"offset\" => {\n-            let ptr = get_param(decl, first_real_arg);\n-            let offset = get_param(decl, first_real_arg + 1);\n-            Ret(bcx, GEP(bcx, ptr, [offset]));\n-        }\n-        \"offset_inbounds\" => {\n-            let ptr = get_param(decl, first_real_arg);\n-            let offset = get_param(decl, first_real_arg + 1);\n-            Ret(bcx, InBoundsGEP(bcx, ptr, [offset]));\n-        }\n-        \"memcpy32\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i32\", substs.tys[0], 32),\n-        \"memcpy64\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i64\", substs.tys[0], 64),\n-        \"memmove32\" => memcpy_intrinsic(bcx, \"llvm.memmove.p0i8.p0i8.i32\", substs.tys[0], 32),\n-        \"memmove64\" => memcpy_intrinsic(bcx, \"llvm.memmove.p0i8.p0i8.i64\", substs.tys[0], 64),\n-        \"memset32\" => memset_intrinsic(bcx, \"llvm.memset.p0i8.i32\", substs.tys[0], 32),\n-        \"memset64\" => memset_intrinsic(bcx, \"llvm.memset.p0i8.i64\", substs.tys[0], 64),\n-        \"sqrtf32\" => simple_llvm_intrinsic(bcx, \"llvm.sqrt.f32\", 1),\n-        \"sqrtf64\" => simple_llvm_intrinsic(bcx, \"llvm.sqrt.f64\", 1),\n-        \"powif32\" => simple_llvm_intrinsic(bcx, \"llvm.powi.f32\", 2),\n-        \"powif64\" => simple_llvm_intrinsic(bcx, \"llvm.powi.f64\", 2),\n-        \"sinf32\" => simple_llvm_intrinsic(bcx, \"llvm.sin.f32\", 1),\n-        \"sinf64\" => simple_llvm_intrinsic(bcx, \"llvm.sin.f64\", 1),\n-        \"cosf32\" => simple_llvm_intrinsic(bcx, \"llvm.cos.f32\", 1),\n-        \"cosf64\" => simple_llvm_intrinsic(bcx, \"llvm.cos.f64\", 1),\n-        \"powf32\" => simple_llvm_intrinsic(bcx, \"llvm.pow.f32\", 2),\n-        \"powf64\" => simple_llvm_intrinsic(bcx, \"llvm.pow.f64\", 2),\n-        \"expf32\" => simple_llvm_intrinsic(bcx, \"llvm.exp.f32\", 1),\n-        \"expf64\" => simple_llvm_intrinsic(bcx, \"llvm.exp.f64\", 1),\n-        \"exp2f32\" => simple_llvm_intrinsic(bcx, \"llvm.exp2.f32\", 1),\n-        \"exp2f64\" => simple_llvm_intrinsic(bcx, \"llvm.exp2.f64\", 1),\n-        \"logf32\" => simple_llvm_intrinsic(bcx, \"llvm.log.f32\", 1),\n-        \"logf64\" => simple_llvm_intrinsic(bcx, \"llvm.log.f64\", 1),\n-        \"log10f32\" => simple_llvm_intrinsic(bcx, \"llvm.log10.f32\", 1),\n-        \"log10f64\" => simple_llvm_intrinsic(bcx, \"llvm.log10.f64\", 1),\n-        \"log2f32\" => simple_llvm_intrinsic(bcx, \"llvm.log2.f32\", 1),\n-        \"log2f64\" => simple_llvm_intrinsic(bcx, \"llvm.log2.f64\", 1),\n-        \"fmaf32\" => simple_llvm_intrinsic(bcx, \"llvm.fma.f32\", 3),\n-        \"fmaf64\" => simple_llvm_intrinsic(bcx, \"llvm.fma.f64\", 3),\n-        \"fabsf32\" => simple_llvm_intrinsic(bcx, \"llvm.fabs.f32\", 1),\n-        \"fabsf64\" => simple_llvm_intrinsic(bcx, \"llvm.fabs.f64\", 1),\n-        \"floorf32\" => simple_llvm_intrinsic(bcx, \"llvm.floor.f32\", 1),\n-        \"floorf64\" => simple_llvm_intrinsic(bcx, \"llvm.floor.f64\", 1),\n-        \"ceilf32\" => simple_llvm_intrinsic(bcx, \"llvm.ceil.f32\", 1),\n-        \"ceilf64\" => simple_llvm_intrinsic(bcx, \"llvm.ceil.f64\", 1),\n-        \"truncf32\" => simple_llvm_intrinsic(bcx, \"llvm.trunc.f32\", 1),\n-        \"truncf64\" => simple_llvm_intrinsic(bcx, \"llvm.trunc.f64\", 1),\n-        \"ctpop8\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i8\", 1),\n-        \"ctpop16\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i16\", 1),\n-        \"ctpop32\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i32\", 1),\n-        \"ctpop64\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i64\", 1),\n-        \"ctlz8\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\"),\n-        \"ctlz16\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\"),\n-        \"ctlz32\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i32\"),\n-        \"ctlz64\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i64\"),\n-        \"cttz8\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i8\"),\n-        \"cttz16\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i16\"),\n-        \"cttz32\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i32\"),\n-        \"cttz64\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i64\"),\n-        \"bswap16\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i16\", 1),\n-        \"bswap32\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i32\", 1),\n-        \"bswap64\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i64\", 1),\n-\n-        \"i8_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i8\"),\n-        \"i16_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i16\"),\n-        \"i32_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i32\"),\n-        \"i64_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i64\"),\n-\n-        \"u8_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i8\"),\n-        \"u16_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i16\"),\n-        \"u32_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i32\"),\n-        \"u64_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i64\"),\n-\n-        \"i8_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i8\"),\n-        \"i16_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i16\"),\n-        \"i32_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i32\"),\n-        \"i64_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i64\"),\n-\n-        \"u8_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i8\"),\n-        \"u16_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i16\"),\n-        \"u32_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i32\"),\n-        \"u64_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i64\"),\n-\n-        \"i8_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i8\"),\n-        \"i16_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i16\"),\n-        \"i32_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i32\"),\n-        \"i64_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i64\"),\n-\n-        \"u8_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i8\"),\n-        \"u16_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i16\"),\n-        \"u32_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i32\"),\n-        \"u64_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i64\"),\n-\n-        _ => {\n-            // Could we make this an enum rather than a string? does it get\n-            // checked earlier?\n-            ccx.sess.span_bug(item.span, \"unknown intrinsic\");\n-        }\n+pub fn trans_foreign_mod(ccx: @mut CrateContext,\n+                         foreign_mod: &ast::foreign_mod) {\n+    let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n+    for &foreign_item in foreign_mod.items.iter() {\n+        let lname = link_name(ccx, foreign_item);\n+        ccx.item_symbols.insert(foreign_item.id, lname.to_owned());\n     }\n-    fcx.cleanup();\n }\n \n-/**\n- * Translates a \"crust\" fn, meaning a Rust fn that can be called\n- * from C code.  In this case, we have to perform some adaptation\n- * to (1) switch back to the Rust stack and (2) adapt the C calling\n- * convention to our own.\n- *\n- * Example: Given a crust fn F(x: X, y: Y) -> Z, we generate a\n- * Rust function R as normal:\n- *\n- *    void R(Z* dest, void *env, X x, Y y) {...}\n- *\n- * and then we generate a wrapper function W that looks like:\n- *\n- *    Z W(X x, Y y) {\n- *        struct { X x; Y y; Z *z; } args = { x, y, z };\n- *        call_on_c_stack_shim(S, &args);\n- *    }\n- *\n- * Note that the wrapper follows the foreign (typically \"C\") ABI.\n- * The wrapper is the actual \"value\" of the foreign fn.  Finally,\n- * we generate a shim function S that looks like:\n- *\n- *     void S(struct { X x; Y y; Z *z; } *args) {\n- *         R(args->z, NULL, args->x, args->y);\n- *     }\n- */\n-pub fn trans_foreign_fn(ccx: @mut CrateContext,\n-                        path: ast_map::path,\n-                        decl: &ast::fn_decl,\n-                        body: &ast::Block,\n-                        llwrapfn: ValueRef,\n-                        id: ast::NodeId) {\n+///////////////////////////////////////////////////////////////////////////\n+// Rust functions with foreign ABIs\n+//\n+// These are normal Rust functions defined with foreign ABIs.  For\n+// now, and perhaps forever, we translate these using a \"layer of\n+// indirection\". That is, given a Rust declaration like:\n+//\n+//     extern \"C\" fn foo(i: u32) -> u32 { ... }\n+//\n+// we will generate a function like:\n+//\n+//     S foo(T i) {\n+//         S r;\n+//         foo0(&r, NULL, i);\n+//         return r;\n+//     }\n+//\n+//     #[inline_always]\n+//     void foo0(uint32_t *r, void *env, uint32_t i) { ... }\n+//\n+// Here the (internal) `foo0` function follows the Rust ABI as normal,\n+// where the `foo` function follows the C ABI. We rely on LLVM to\n+// inline the one into the other. Of course we could just generate the\n+// correct code in the first place, but this is much simpler.\n+\n+pub fn register_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n+                                         sp: span,\n+                                         sym: ~str,\n+                                         node_id: ast::NodeId)\n+                                         -> ValueRef {\n+    let _icx = push_ctxt(\"foreign::register_foreign_fn\");\n+\n+    let tys = foreign_types_for_id(ccx, node_id);\n+    let llfn_ty = lltype_for_fn_from_foreign_types(&tys);\n+    let llfn = base::register_fn_llvmty(ccx,\n+                                        sp,\n+                                        sym,\n+                                        node_id,\n+                                        lib::llvm::CCallConv,\n+                                        llfn_ty);\n+    add_argument_attributes(&tys, llfn);\n+    debug!(\"register_rust_fn_with_foreign_abi(node_id=%?, llfn_ty=%s, llfn=%s)\",\n+           node_id, ccx.tn.type_to_str(llfn_ty), ccx.tn.val_to_str(llfn));\n+    llfn\n+}\n+\n+pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n+                                      path: &ast_map::path,\n+                                      decl: &ast::fn_decl,\n+                                      body: &ast::Block,\n+                                      llwrapfn: ValueRef,\n+                                      id: ast::NodeId) {\n     let _icx = push_ctxt(\"foreign::build_foreign_fn\");\n+    let tys = foreign_types_for_id(ccx, id);\n+\n+    unsafe { // unsafe because we call LLVM operations\n+        // Build up the Rust function (`foo0` above).\n+        let llrustfn = build_rust_fn(ccx, path, decl, body, id);\n+\n+        // Build up the foreign wrapper (`foo` above).\n+        return build_wrap_fn(ccx, llrustfn, llwrapfn, &tys);\n+    }\n \n     fn build_rust_fn(ccx: @mut CrateContext,\n                      path: &ast_map::path,\n                      decl: &ast::fn_decl,\n                      body: &ast::Block,\n                      id: ast::NodeId)\n-                  -> ValueRef {\n+                     -> ValueRef {\n         let _icx = push_ctxt(\"foreign::foreign::build_rust_fn\");\n-        let t = ty::node_id_to_type(ccx.tcx, id);\n-        // XXX: Bad copy.\n+        let tcx = ccx.tcx;\n+        let t = ty::node_id_to_type(tcx, id);\n         let ps = link::mangle_internal_name_by_path(\n-                            ccx,\n-                            vec::append_one((*path).clone(),\n-                                            ast_map::path_name(\n-                                            special_idents::clownshoe_abi)));\n+            ccx, vec::append_one((*path).clone(), ast_map::path_name(\n+                special_idents::clownshoe_abi\n+            )));\n         let llty = type_of_fn_from_ty(ccx, t);\n-        let llfndecl = decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n-        trans_fn(ccx,\n-                 (*path).clone(),\n-                 decl,\n-                 body,\n-                 llfndecl,\n-                 no_self,\n-                 None,\n-                 id,\n-                 []);\n+        let llfndecl = base::decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n+        base::trans_fn(ccx,\n+                       (*path).clone(),\n+                       decl,\n+                       body,\n+                       llfndecl,\n+                       base::no_self,\n+                       None,\n+                       id,\n+                       []);\n         return llfndecl;\n     }\n \n-    fn build_shim_fn(ccx: @mut CrateContext,\n-                     path: ast_map::path,\n-                     llrustfn: ValueRef,\n-                     tys: &ShimTypes)\n-                     -> ValueRef {\n-        /*!\n-         *\n-         * Generate the shim S:\n-         *\n-         *     void S(struct { X x; Y y; Z *z; } *args) {\n-         *         R(args->z, NULL, &args->x, args->y);\n-         *     }\n-         *\n-         * One complication is that we must adapt to the Rust\n-         * calling convention, which introduces indirection\n-         * in some cases.  To demonstrate this, I wrote one of the\n-         * entries above as `&args->x`, because presumably `X` is\n-         * one of those types that is passed by pointer in Rust.\n-         */\n-\n-        let _icx = push_ctxt(\"foreign::foreign::build_shim_fn\");\n-\n-        fn build_args(bcx: @mut Block, tys: &ShimTypes, llargbundle: ValueRef)\n-                      -> ~[ValueRef] {\n-            let _icx = push_ctxt(\"foreign::extern::shim::build_args\");\n-            let ccx = bcx.ccx();\n-            let mut llargvals = ~[];\n-            let mut i = 0u;\n-            let n = tys.fn_sig.inputs.len();\n-\n-            if !ty::type_is_immediate(bcx.tcx(), tys.fn_sig.output) {\n-                let llretptr = load_inbounds(bcx, llargbundle, [0u, n]);\n-                llargvals.push(llretptr);\n+    unsafe fn build_wrap_fn(ccx: @mut CrateContext,\n+                            llrustfn: ValueRef,\n+                            llwrapfn: ValueRef,\n+                            tys: &ForeignTypes) {\n+        let _icx = push_ctxt(\n+            \"foreign::trans_rust_fn_with_foreign_abi::build_wrap_fn\");\n+        let tcx = ccx.tcx;\n+\n+        debug!(\"build_wrap_fn(llrustfn=%s, llwrapfn=%s)\",\n+               ccx.tn.val_to_str(llrustfn),\n+               ccx.tn.val_to_str(llwrapfn));\n+\n+        // Avoid all the Rust generation stuff and just generate raw\n+        // LLVM here.\n+        //\n+        // We want to generate code like this:\n+        //\n+        //     S foo(T i) {\n+        //         S r;\n+        //         foo0(&r, NULL, i);\n+        //         return r;\n+        //     }\n+\n+        let the_block =\n+            \"the block\".to_c_str().with_ref(\n+                |s| llvm::LLVMAppendBasicBlockInContext(ccx.llcx, llwrapfn, s));\n+\n+        let builder = ccx.builder.B;\n+        llvm::LLVMPositionBuilderAtEnd(builder, the_block);\n+\n+        // Array for the arguments we will pass to the rust function.\n+        let mut llrust_args = ~[];\n+        let mut next_foreign_arg_counter: c_uint = 0;\n+        let next_foreign_arg: &fn() -> c_uint = {\n+            || {\n+                next_foreign_arg_counter += 1;\n+                next_foreign_arg_counter - 1\n             }\n+        };\n \n-            let llenvptr = C_null(Type::opaque_box(bcx.ccx()).ptr_to());\n-            llargvals.push(llenvptr);\n-            while i < n {\n-                // Get a pointer to the argument:\n-                let mut llargval = GEPi(bcx, llargbundle, [0u, i]);\n+        // If there is an out pointer on the foreign function\n+        let foreign_outptr = {\n+            if tys.fn_ty.sret {\n+                Some(llvm::LLVMGetParam(llwrapfn, next_foreign_arg()))\n+            } else {\n+                None\n+            }\n+        };\n \n-                if !type_of::arg_is_indirect(ccx, &tys.fn_sig.inputs[i]) {\n-                    // If Rust would pass this by value, load the value.\n-                    llargval = Load(bcx, llargval);\n+        // Push Rust return pointer, using null if it will be unused.\n+        let rust_uses_outptr =\n+            type_of::return_uses_outptr(tcx, tys.fn_sig.output);\n+        let return_alloca: Option<ValueRef>;\n+        let llrust_ret_ty = tys.llsig.llret_ty;\n+        let llrust_retptr_ty = llrust_ret_ty.ptr_to();\n+        if rust_uses_outptr {\n+            // Rust expects to use an outpointer. If the foreign fn\n+            // also uses an outpointer, we can reuse it, but the types\n+            // may vary, so cast first to the Rust type. If the\n+            // foriegn fn does NOT use an outpointer, we will have to\n+            // alloca some scratch space on the stack.\n+            match foreign_outptr {\n+                Some(llforeign_outptr) => {\n+                    debug!(\"out pointer, foreign=%s\",\n+                           ccx.tn.val_to_str(llforeign_outptr));\n+                    let llrust_retptr =\n+                        llvm::LLVMBuildBitCast(builder,\n+                                               llforeign_outptr,\n+                                               llrust_ret_ty.ptr_to().to_ref(),\n+                                               noname());\n+                    debug!(\"out pointer, foreign=%s (casted)\",\n+                           ccx.tn.val_to_str(llrust_retptr));\n+                    llrust_args.push(llrust_retptr);\n+                    return_alloca = None;\n                 }\n \n-                llargvals.push(llargval);\n-                i += 1u;\n+                None => {\n+                    let slot = {\n+                        \"return_alloca\".to_c_str().with_ref(\n+                            |s| llvm::LLVMBuildAlloca(builder,\n+                                                      llrust_ret_ty.to_ref(),\n+                                                      s))\n+                    };\n+                    debug!(\"out pointer, \\\n+                            allocad=%s, \\\n+                            llrust_ret_ty=%s, \\\n+                            return_ty=%s\",\n+                           ccx.tn.val_to_str(slot),\n+                           ccx.tn.type_to_str(llrust_ret_ty),\n+                           tys.fn_sig.output.repr(tcx));\n+                    llrust_args.push(slot);\n+                    return_alloca = Some(slot);\n+                }\n+            }\n+        } else {\n+            // Rust does not expect an outpointer. If the foreign fn\n+            // does use an outpointer, then we will do a store of the\n+            // value that the Rust fn returns.\n+            return_alloca = None;\n+        };\n+\n+        // Push an (null) env pointer\n+        let env_pointer = base::null_env_ptr(ccx);\n+        debug!(\"env pointer=%s\", ccx.tn.val_to_str(env_pointer));\n+        llrust_args.push(env_pointer);\n+\n+        // Build up the arguments to the call to the rust function.\n+        // Careful to adapt for cases where the native convention uses\n+        // a pointer and Rust does not or vice versa.\n+        for i in range(0, tys.fn_sig.inputs.len()) {\n+            let rust_ty = tys.fn_sig.inputs[i];\n+            let llrust_ty = tys.llsig.llarg_tys[i];\n+            let foreign_index = next_foreign_arg();\n+            let rust_indirect = type_of::arg_is_indirect(ccx, rust_ty);\n+            let foreign_indirect = tys.fn_ty.attrs[foreign_index].is_some();\n+            let mut llforeign_arg = llvm::LLVMGetParam(llwrapfn, foreign_index);\n+\n+            debug!(\"llforeign_arg #%u: %s\",\n+                   i, ccx.tn.val_to_str(llforeign_arg));\n+            debug!(\"rust_indirect = %b, foreign_indirect = %b\",\n+                   rust_indirect, foreign_indirect);\n+\n+            // Ensure that the foreign argument is indirect (by\n+            // pointer).  It makes adapting types easier, since we can\n+            // always just bitcast pointers.\n+            if !foreign_indirect {\n+                let lltemp =\n+                    llvm::LLVMBuildAlloca(\n+                        builder, val_ty(llforeign_arg).to_ref(), noname());\n+                llvm::LLVMBuildStore(\n+                    builder, llforeign_arg, lltemp);\n+                llforeign_arg = lltemp;\n+            }\n+\n+            // If the types in the ABI and the Rust types don't match,\n+            // bitcast the llforeign_arg pointer so it matches the types\n+            // Rust expects.\n+            if tys.fn_ty.arg_tys[foreign_index].cast {\n+                assert!(!foreign_indirect);\n+                llforeign_arg = llvm::LLVMBuildBitCast(\n+                    builder, llforeign_arg,\n+                    llrust_ty.ptr_to().to_ref(), noname());\n             }\n-            return llargvals;\n-        }\n \n-        fn build_ret(bcx: @mut Block,\n-                     shim_types: &ShimTypes,\n-                     llargbundle: ValueRef,\n-                     llretval: ValueRef) {\n-            if bcx.fcx.llretptr.is_some() &&\n-                ty::type_is_immediate(bcx.tcx(), shim_types.fn_sig.output) {\n-                // Write the value into the argument bundle.\n-                let arg_count = shim_types.fn_sig.inputs.len();\n-                let llretptr = load_inbounds(bcx,\n-                                             llargbundle,\n-                                             [0, arg_count]);\n-                Store(bcx, llretval, llretptr);\n+            let llrust_arg = if rust_indirect {\n+                llforeign_arg\n             } else {\n-                // NB: The return pointer in the Rust ABI function is wired\n-                // directly into the return slot in the shim struct.\n+                llvm::LLVMBuildLoad(builder, llforeign_arg, noname())\n+            };\n+\n+            debug!(\"llrust_arg #%u: %s\",\n+                   i, ccx.tn.val_to_str(llrust_arg));\n+            llrust_args.push(llrust_arg);\n+        }\n+\n+        // Perform the call itself\n+        let llrust_ret_val = do llrust_args.as_imm_buf |ptr, len| {\n+            debug!(\"calling llrustfn = %s\", ccx.tn.val_to_str(llrustfn));\n+            llvm::LLVMBuildCall(builder, llrustfn, ptr,\n+                                len as c_uint, noname())\n+        };\n+\n+        // Get the return value where the foreign fn expects it.\n+        let llforeign_ret_ty = tys.fn_ty.ret_ty.ty;\n+        match foreign_outptr {\n+            None if !tys.ret_def => {\n+                // Function returns `()` or `bot`, which in Rust is the LLVM\n+                // type \"{}\" but in foreign ABIs is \"Void\".\n+                llvm::LLVMBuildRetVoid(builder);\n+            }\n+\n+            None if rust_uses_outptr => {\n+                // Rust uses an outpointer, but the foreign ABI does not. Load.\n+                let llrust_outptr = return_alloca.unwrap();\n+                let llforeign_outptr_casted =\n+                    llvm::LLVMBuildBitCast(builder,\n+                                           llrust_outptr,\n+                                           llforeign_ret_ty.ptr_to().to_ref(),\n+                                           noname());\n+                let llforeign_retval =\n+                    llvm::LLVMBuildLoad(builder, llforeign_outptr_casted, noname());\n+                llvm::LLVMBuildRet(builder, llforeign_retval);\n+            }\n+\n+            None if llforeign_ret_ty != llrust_ret_ty => {\n+                // Neither ABI uses an outpointer, but the types don't\n+                // quite match. Must cast. Probably we should try and\n+                // examine the types and use a concrete llvm cast, but\n+                // right now we just use a temp memory location and\n+                // bitcast the pointer, which is the same thing the\n+                // old wrappers used to do.\n+                let lltemp =\n+                    llvm::LLVMBuildAlloca(\n+                        builder, llforeign_ret_ty.to_ref(), noname());\n+                let lltemp_casted =\n+                    llvm::LLVMBuildBitCast(builder,\n+                                           lltemp,\n+                                           llrust_ret_ty.ptr_to().to_ref(),\n+                                           noname());\n+                llvm::LLVMBuildStore(\n+                    builder, llrust_ret_val, lltemp_casted);\n+                let llforeign_retval =\n+                    llvm::LLVMBuildLoad(builder, lltemp, noname());\n+                llvm::LLVMBuildRet(builder, llforeign_retval);\n+            }\n+\n+            None => {\n+                // Neither ABI uses an outpointer, and the types\n+                // match. Easy peasy.\n+                llvm::LLVMBuildRet(builder, llrust_ret_val);\n+            }\n+\n+            Some(llforeign_outptr) if !rust_uses_outptr => {\n+                // Foreign ABI requires an out pointer, but Rust doesn't.\n+                // Store Rust return value.\n+                let llforeign_outptr_casted =\n+                    llvm::LLVMBuildBitCast(builder,\n+                                           llforeign_outptr,\n+                                           llrust_retptr_ty.to_ref(),\n+                                           noname());\n+                llvm::LLVMBuildStore(\n+                    builder, llrust_ret_val, llforeign_outptr_casted);\n+                llvm::LLVMBuildRetVoid(builder);\n+            }\n+\n+            Some(_) => {\n+                // Both ABIs use outpointers. Easy peasy.\n+                llvm::LLVMBuildRetVoid(builder);\n             }\n         }\n+    }\n+}\n \n-        let shim_name = link::mangle_internal_name_by_path(\n-            ccx,\n-            vec::append_one(path, ast_map::path_name(\n-                special_idents::clownshoe_stack_shim\n-            )));\n-        build_shim_fn_(ccx,\n-                       shim_name,\n-                       llrustfn,\n-                       tys,\n-                       lib::llvm::CCallConv,\n-                       build_args,\n-                       build_ret)\n+///////////////////////////////////////////////////////////////////////////\n+// General ABI Support\n+//\n+// This code is kind of a confused mess and needs to be reworked given\n+// the massive simplifications that have occurred.\n+\n+pub fn link_name(ccx: &CrateContext, i: @ast::foreign_item) -> @str {\n+     match attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n+        None => ccx.sess.str_of(i.ident),\n+        Some(ln) => ln,\n     }\n+}\n \n-    fn build_wrap_fn(ccx: @mut CrateContext,\n-                     llshimfn: ValueRef,\n-                     llwrapfn: ValueRef,\n-                     tys: &ShimTypes) {\n-        /*!\n-         *\n-         * Generate the wrapper W:\n-         *\n-         *    Z W(X x, Y y) {\n-         *        struct { X x; Y y; Z *z; } args = { x, y, z };\n-         *        call_on_c_stack_shim(S, &args);\n-         *    }\n-         */\n-\n-        let _icx = push_ctxt(\"foreign::foreign::build_wrap_fn\");\n-\n-        build_wrap_fn_(ccx,\n-                       tys,\n-                       llshimfn,\n-                       llwrapfn,\n-                       ccx.upcalls.call_shim_on_rust_stack,\n-                       true,\n-                       build_args,\n-                       build_ret);\n-\n-        fn build_args(bcx: @mut Block,\n-                      tys: &ShimTypes,\n-                      llwrapfn: ValueRef,\n-                      llargbundle: ValueRef) {\n-            let _icx = push_ctxt(\"foreign::foreign::wrap::build_args\");\n-            tys.fn_ty.build_wrap_args(bcx,\n-                                      tys.llsig.llret_ty,\n-                                      llwrapfn,\n-                                      llargbundle);\n-        }\n+fn foreign_signature(ccx: &mut CrateContext, fn_sig: &ty::FnSig)\n+                     -> LlvmSignature {\n+    /*!\n+     * The ForeignSignature is the LLVM types of the arguments/return type\n+     * of a function.  Note that these LLVM types are not quite the same\n+     * as the LLVM types would be for a native Rust function because foreign\n+     * functions just plain ignore modes.  They also don't pass aggregate\n+     * values by pointer like we do.\n+     */\n \n-        fn build_ret(bcx: @mut Block, tys: &ShimTypes, llargbundle: ValueRef) {\n-            let _icx = push_ctxt(\"foreign::foreign::wrap::build_ret\");\n-            tys.fn_ty.build_wrap_ret(bcx, tys.llsig.llarg_tys, llargbundle);\n-        }\n+    let llarg_tys = fn_sig.inputs.map(|&arg| type_of(ccx, arg));\n+    let llret_ty = type_of::type_of(ccx, fn_sig.output);\n+    LlvmSignature {\n+        llarg_tys: llarg_tys,\n+        llret_ty: llret_ty,\n+        sret: type_of::return_uses_outptr(ccx.tcx, fn_sig.output),\n     }\n+}\n \n-    let tys = shim_types(ccx, id);\n-    // The internal Rust ABI function - runs on the Rust stack\n-    // XXX: Bad copy.\n-    let llrustfn = build_rust_fn(ccx, &path, decl, body, id);\n-    // The internal shim function - runs on the Rust stack\n-    let llshimfn = build_shim_fn(ccx, path, llrustfn, &tys);\n-    // The foreign C function - runs on the C stack\n-    build_wrap_fn(ccx, llshimfn, llwrapfn, &tys)\n+fn foreign_types_for_id(ccx: &mut CrateContext,\n+                        id: ast::NodeId) -> ForeignTypes {\n+    foreign_types_for_fn_ty(ccx, ty::node_id_to_type(ccx.tcx, id))\n }\n \n-pub fn register_foreign_fn(ccx: @mut CrateContext,\n-                           sp: span,\n-                           sym: ~str,\n-                           node_id: ast::NodeId)\n-                           -> ValueRef {\n-    let _icx = push_ctxt(\"foreign::register_foreign_fn\");\n+fn foreign_types_for_fn_ty(ccx: &mut CrateContext,\n+                           ty: ty::t) -> ForeignTypes {\n+    let fn_sig = match ty::get(ty).sty {\n+        ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n+        _ => ccx.sess.bug(\"foreign_types_for_fn_ty called on non-function type\")\n+    };\n+    let llsig = foreign_signature(ccx, &fn_sig);\n+    let ret_def = !ty::type_is_voidish(fn_sig.output);\n+    let fn_ty = cabi::compute_abi_info(ccx,\n+                                       llsig.llarg_tys,\n+                                       llsig.llret_ty,\n+                                       ret_def);\n+    debug!(\"foreign_types_for_fn_ty(\\\n+           ty=%s, \\\n+           llsig=%s -> %s, \\\n+           fn_ty=%s -> %s, \\\n+           ret_def=%b\",\n+           ty.repr(ccx.tcx),\n+           ccx.tn.types_to_str(llsig.llarg_tys),\n+           ccx.tn.type_to_str(llsig.llret_ty),\n+           ccx.tn.types_to_str(fn_ty.arg_tys.map(|t| t.ty)),\n+           ccx.tn.type_to_str(fn_ty.ret_ty.ty),\n+           ret_def);\n+\n+    ForeignTypes {\n+        fn_sig: fn_sig,\n+        llsig: llsig,\n+        ret_def: ret_def,\n+        fn_ty: fn_ty\n+    }\n+}\n \n-    let sym = Cell::new(sym);\n+fn lltype_for_fn_from_foreign_types(tys: &ForeignTypes) -> Type {\n+    let llargument_tys: ~[Type] =\n+        tys.fn_ty.arg_tys.iter().map(|t| t.ty).collect();\n+    let llreturn_ty = tys.fn_ty.ret_ty.ty;\n+    Type::func(llargument_tys, &llreturn_ty)\n+}\n+\n+pub fn lltype_for_foreign_fn(ccx: &mut CrateContext, ty: ty::t) -> Type {\n+    let fn_types = foreign_types_for_fn_ty(ccx, ty);\n+    lltype_for_fn_from_foreign_types(&fn_types)\n+}\n \n-    let tys = shim_types(ccx, node_id);\n-    do tys.fn_ty.decl_fn |fnty| {\n-        register_fn_llvmty(ccx, sp, sym.take(), node_id, lib::llvm::CCallConv, fnty)\n+fn add_argument_attributes(tys: &ForeignTypes,\n+                           llfn: ValueRef) {\n+    for (i, a) in tys.fn_ty.attrs.iter().enumerate() {\n+        match *a {\n+            Some(attr) => {\n+                let llarg = get_param(llfn, i);\n+                unsafe {\n+                    llvm::LLVMAddAttribute(llarg, attr as c_uint);\n+                }\n+            }\n+            None => ()\n+        }\n     }\n }"}, {"sha": "2232b8966b8695bd938e5e19e24e46570eb2fbbb", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "added", "additions": 503, "deletions": 0, "changes": 503, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -0,0 +1,503 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use back::{abi};\n+use lib::llvm::{SequentiallyConsistent, Acquire, Release, Xchg};\n+use lib::llvm::{ValueRef, Pointer};\n+use lib;\n+use middle::trans::base::*;\n+use middle::trans::build::*;\n+use middle::trans::callee::*;\n+use middle::trans::common::*;\n+use middle::trans::datum::*;\n+use middle::trans::type_of::*;\n+use middle::trans::type_of;\n+use middle::trans::expr::Ignore;\n+use middle::trans::machine;\n+use middle::trans::glue;\n+use middle::ty::FnSig;\n+use middle::ty;\n+use syntax::ast;\n+use syntax::ast_map;\n+use syntax::attr;\n+use syntax::opt_vec;\n+use util::ppaux::{ty_to_str};\n+use middle::trans::machine::llsize_of;\n+use middle::trans::type_::Type;\n+\n+pub fn trans_intrinsic(ccx: @mut CrateContext,\n+                       decl: ValueRef,\n+                       item: &ast::foreign_item,\n+                       path: ast_map::path,\n+                       substs: @param_substs,\n+                       attributes: &[ast::Attribute],\n+                       ref_id: Option<ast::NodeId>) {\n+    debug!(\"trans_intrinsic(item.ident=%s)\", ccx.sess.str_of(item.ident));\n+\n+    fn simple_llvm_intrinsic(bcx: @mut Block, name: &'static str, num_args: uint) {\n+        assert!(num_args <= 4);\n+        let mut args = [0 as ValueRef, ..4];\n+        let first_real_arg = bcx.fcx.arg_pos(0u);\n+        for i in range(0u, num_args) {\n+            args[i] = get_param(bcx.fcx.llfn, first_real_arg + i);\n+        }\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        Ret(bcx, Call(bcx, llfn, args.slice(0, num_args)));\n+    }\n+\n+    fn with_overflow_instrinsic(bcx: @mut Block, name: &'static str) {\n+        let first_real_arg = bcx.fcx.arg_pos(0u);\n+        let a = get_param(bcx.fcx.llfn, first_real_arg);\n+        let b = get_param(bcx.fcx.llfn, first_real_arg + 1);\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+\n+        // convert `i1` to a `bool`, and write to the out parameter\n+        let val = Call(bcx, llfn, [a, b]);\n+        let result = ExtractValue(bcx, val, 0);\n+        let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool());\n+        let retptr = get_param(bcx.fcx.llfn, bcx.fcx.out_arg_pos());\n+        let ret = Load(bcx, retptr);\n+        let ret = InsertValue(bcx, ret, result, 0);\n+        let ret = InsertValue(bcx, ret, overflow, 1);\n+        Store(bcx, ret, retptr);\n+        RetVoid(bcx)\n+    }\n+\n+    fn memcpy_intrinsic(bcx: @mut Block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n+        let ccx = bcx.ccx();\n+        let lltp_ty = type_of::type_of(ccx, tp_ty);\n+        let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+        let size = match sizebits {\n+            32 => C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32),\n+            64 => C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64),\n+            _ => ccx.sess.fatal(\"Invalid value for sizebits\")\n+        };\n+\n+        let decl = bcx.fcx.llfn;\n+        let first_real_arg = bcx.fcx.arg_pos(0u);\n+        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n+        let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n+        let count = get_param(decl, first_real_arg + 2);\n+        let volatile = C_i1(false);\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n+        RetVoid(bcx);\n+    }\n+\n+    fn memset_intrinsic(bcx: @mut Block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n+        let ccx = bcx.ccx();\n+        let lltp_ty = type_of::type_of(ccx, tp_ty);\n+        let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+        let size = match sizebits {\n+            32 => C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32),\n+            64 => C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64),\n+            _ => ccx.sess.fatal(\"Invalid value for sizebits\")\n+        };\n+\n+        let decl = bcx.fcx.llfn;\n+        let first_real_arg = bcx.fcx.arg_pos(0u);\n+        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n+        let val = get_param(decl, first_real_arg + 1);\n+        let count = get_param(decl, first_real_arg + 2);\n+        let volatile = C_i1(false);\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile]);\n+        RetVoid(bcx);\n+    }\n+\n+    fn count_zeros_intrinsic(bcx: @mut Block, name: &'static str) {\n+        let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n+        let y = C_i1(false);\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        Ret(bcx, Call(bcx, llfn, [x, y]));\n+    }\n+\n+    let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n+\n+    let fcx = new_fn_ctxt_w_id(ccx,\n+                               path,\n+                               decl,\n+                               item.id,\n+                               output_type,\n+                               true,\n+                               Some(substs),\n+                               None,\n+                               Some(item.span));\n+\n+    set_always_inline(fcx.llfn);\n+\n+    // Set the fixed stack segment flag if necessary.\n+    if attr::contains_name(attributes, \"fixed_stack_segment\") {\n+        set_fixed_stack_segment(fcx.llfn);\n+    }\n+\n+    let mut bcx = fcx.entry_bcx.unwrap();\n+    let first_real_arg = fcx.arg_pos(0u);\n+\n+    let nm = ccx.sess.str_of(item.ident);\n+    let name = nm.as_slice();\n+\n+    // This requires that atomic intrinsics follow a specific naming pattern:\n+    // \"atomic_<operation>[_<ordering>], and no ordering means SeqCst\n+    if name.starts_with(\"atomic_\") {\n+        let split : ~[&str] = name.split_iter('_').collect();\n+        assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n+        let order = if split.len() == 2 {\n+            lib::llvm::SequentiallyConsistent\n+        } else {\n+            match split[2] {\n+                \"relaxed\" => lib::llvm::Monotonic,\n+                \"acq\"     => lib::llvm::Acquire,\n+                \"rel\"     => lib::llvm::Release,\n+                \"acqrel\"  => lib::llvm::AcquireRelease,\n+                _ => ccx.sess.fatal(\"Unknown ordering in atomic intrinsic\")\n+            }\n+        };\n+\n+        match split[1] {\n+            \"cxchg\" => {\n+                let old = AtomicCmpXchg(bcx, get_param(decl, first_real_arg),\n+                                        get_param(decl, first_real_arg + 1u),\n+                                        get_param(decl, first_real_arg + 2u),\n+                                        order);\n+                Ret(bcx, old);\n+            }\n+            \"load\" => {\n+                let old = AtomicLoad(bcx, get_param(decl, first_real_arg),\n+                                     order);\n+                Ret(bcx, old);\n+            }\n+            \"store\" => {\n+                AtomicStore(bcx, get_param(decl, first_real_arg + 1u),\n+                            get_param(decl, first_real_arg),\n+                            order);\n+                RetVoid(bcx);\n+            }\n+            \"fence\" => {\n+                AtomicFence(bcx, order);\n+                RetVoid(bcx);\n+            }\n+            op => {\n+                // These are all AtomicRMW ops\n+                let atom_op = match op {\n+                    \"xchg\"  => lib::llvm::Xchg,\n+                    \"xadd\"  => lib::llvm::Add,\n+                    \"xsub\"  => lib::llvm::Sub,\n+                    \"and\"   => lib::llvm::And,\n+                    \"nand\"  => lib::llvm::Nand,\n+                    \"or\"    => lib::llvm::Or,\n+                    \"xor\"   => lib::llvm::Xor,\n+                    \"max\"   => lib::llvm::Max,\n+                    \"min\"   => lib::llvm::Min,\n+                    \"umax\"  => lib::llvm::UMax,\n+                    \"umin\"  => lib::llvm::UMin,\n+                    _ => ccx.sess.fatal(\"Unknown atomic operation\")\n+                };\n+\n+                let old = AtomicRMW(bcx, atom_op, get_param(decl, first_real_arg),\n+                                    get_param(decl, first_real_arg + 1u),\n+                                    order);\n+                Ret(bcx, old);\n+            }\n+        }\n+\n+        fcx.cleanup();\n+        return;\n+    }\n+\n+    match name {\n+        \"size_of\" => {\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            Ret(bcx, C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty)));\n+        }\n+        \"move_val\" => {\n+            // Create a datum reflecting the value being moved.\n+            // Use `appropriate_mode` so that the datum is by ref\n+            // if the value is non-immediate. Note that, with\n+            // intrinsics, there are no argument cleanups to\n+            // concern ourselves with.\n+            let tp_ty = substs.tys[0];\n+            let mode = appropriate_mode(ccx.tcx, tp_ty);\n+            let src = Datum {val: get_param(decl, first_real_arg + 1u),\n+                             ty: tp_ty, mode: mode};\n+            bcx = src.move_to(bcx, DROP_EXISTING,\n+                              get_param(decl, first_real_arg));\n+            RetVoid(bcx);\n+        }\n+        \"move_val_init\" => {\n+            // See comments for `\"move_val\"`.\n+            let tp_ty = substs.tys[0];\n+            let mode = appropriate_mode(ccx.tcx, tp_ty);\n+            let src = Datum {val: get_param(decl, first_real_arg + 1u),\n+                             ty: tp_ty, mode: mode};\n+            bcx = src.move_to(bcx, INIT, get_param(decl, first_real_arg));\n+            RetVoid(bcx);\n+        }\n+        \"min_align_of\" => {\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            Ret(bcx, C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty)));\n+        }\n+        \"pref_align_of\"=> {\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            Ret(bcx, C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty)));\n+        }\n+        \"get_tydesc\" => {\n+            let tp_ty = substs.tys[0];\n+            let static_ti = get_tydesc(ccx, tp_ty);\n+            glue::lazily_emit_all_tydesc_glue(ccx, static_ti);\n+\n+            // FIXME (#3730): ideally this shouldn't need a cast,\n+            // but there's a circularity between translating rust types to llvm\n+            // types and having a tydesc type available. So I can't directly access\n+            // the llvm type of intrinsic::TyDesc struct.\n+            let userland_tydesc_ty = type_of::type_of(ccx, output_type);\n+            let td = PointerCast(bcx, static_ti.tydesc, userland_tydesc_ty);\n+            Ret(bcx, td);\n+        }\n+        \"init\" => {\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            match bcx.fcx.llretptr {\n+                Some(ptr) => { Store(bcx, C_null(lltp_ty), ptr); RetVoid(bcx); }\n+                None if ty::type_is_nil(tp_ty) => RetVoid(bcx),\n+                None => Ret(bcx, C_null(lltp_ty)),\n+            }\n+        }\n+        \"uninit\" => {\n+            // Do nothing, this is effectively a no-op\n+            let retty = substs.tys[0];\n+            if ty::type_is_immediate(ccx.tcx, retty) && !ty::type_is_nil(retty) {\n+                unsafe {\n+                    Ret(bcx, lib::llvm::llvm::LLVMGetUndef(type_of(ccx, retty).to_ref()));\n+                }\n+            } else {\n+                RetVoid(bcx)\n+            }\n+        }\n+        \"forget\" => {\n+            RetVoid(bcx);\n+        }\n+        \"transmute\" => {\n+            let (in_type, out_type) = (substs.tys[0], substs.tys[1]);\n+            let llintype = type_of::type_of(ccx, in_type);\n+            let llouttype = type_of::type_of(ccx, out_type);\n+\n+            let in_type_size = machine::llbitsize_of_real(ccx, llintype);\n+            let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n+            if in_type_size != out_type_size {\n+                let sp = match ccx.tcx.items.get_copy(&ref_id.unwrap()) {\n+                    ast_map::node_expr(e) => e.span,\n+                    _ => fail!(\"transmute has non-expr arg\"),\n+                };\n+                let pluralize = |n| if 1u == n { \"\" } else { \"s\" };\n+                ccx.sess.span_fatal(sp,\n+                                    fmt!(\"transmute called on types with \\\n+                                          different sizes: %s (%u bit%s) to \\\n+                                          %s (%u bit%s)\",\n+                                         ty_to_str(ccx.tcx, in_type),\n+                                         in_type_size,\n+                                         pluralize(in_type_size),\n+                                         ty_to_str(ccx.tcx, out_type),\n+                                         out_type_size,\n+                                         pluralize(out_type_size)));\n+            }\n+\n+            if !ty::type_is_voidish(out_type) {\n+                let llsrcval = get_param(decl, first_real_arg);\n+                if ty::type_is_immediate(ccx.tcx, in_type) {\n+                    match fcx.llretptr {\n+                        Some(llretptr) => {\n+                            Store(bcx, llsrcval, PointerCast(bcx, llretptr, llintype.ptr_to()));\n+                            RetVoid(bcx);\n+                        }\n+                        None => match (llintype.kind(), llouttype.kind()) {\n+                            (Pointer, other) | (other, Pointer) if other != Pointer => {\n+                                let tmp = Alloca(bcx, llouttype, \"\");\n+                                Store(bcx, llsrcval, PointerCast(bcx, tmp, llintype.ptr_to()));\n+                                Ret(bcx, Load(bcx, tmp));\n+                            }\n+                            _ => Ret(bcx, BitCast(bcx, llsrcval, llouttype))\n+                        }\n+                    }\n+                } else if ty::type_is_immediate(ccx.tcx, out_type) {\n+                    let llsrcptr = PointerCast(bcx, llsrcval, llouttype.ptr_to());\n+                    Ret(bcx, Load(bcx, llsrcptr));\n+                } else {\n+                    // NB: Do not use a Load and Store here. This causes massive\n+                    // code bloat when `transmute` is used on large structural\n+                    // types.\n+                    let lldestptr = fcx.llretptr.unwrap();\n+                    let lldestptr = PointerCast(bcx, lldestptr, Type::i8p());\n+                    let llsrcptr = PointerCast(bcx, llsrcval, Type::i8p());\n+\n+                    let llsize = llsize_of(ccx, llintype);\n+                    call_memcpy(bcx, lldestptr, llsrcptr, llsize, 1);\n+                    RetVoid(bcx);\n+                };\n+            } else {\n+                RetVoid(bcx);\n+            }\n+        }\n+        \"needs_drop\" => {\n+            let tp_ty = substs.tys[0];\n+            Ret(bcx, C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)));\n+        }\n+        \"contains_managed\" => {\n+            let tp_ty = substs.tys[0];\n+            Ret(bcx, C_bool(ty::type_contents(ccx.tcx, tp_ty).contains_managed()));\n+        }\n+        \"visit_tydesc\" => {\n+            let td = get_param(decl, first_real_arg);\n+            let visitor = get_param(decl, first_real_arg + 1u);\n+            let td = PointerCast(bcx, td, ccx.tydesc_type.ptr_to());\n+            glue::call_tydesc_glue_full(bcx, visitor, td,\n+                                        abi::tydesc_field_visit_glue, None);\n+            RetVoid(bcx);\n+        }\n+        \"frame_address\" => {\n+            let frameaddress = ccx.intrinsics.get_copy(& &\"llvm.frameaddress\");\n+            let frameaddress_val = Call(bcx, frameaddress, [C_i32(0i32)]);\n+            let star_u8 = ty::mk_imm_ptr(\n+                bcx.tcx(),\n+                ty::mk_mach_uint(ast::ty_u8));\n+            let fty = ty::mk_closure(bcx.tcx(), ty::ClosureTy {\n+                purity: ast::impure_fn,\n+                sigil: ast::BorrowedSigil,\n+                onceness: ast::Many,\n+                region: ty::re_bound(ty::br_anon(0)),\n+                bounds: ty::EmptyBuiltinBounds(),\n+                sig: FnSig {\n+                    bound_lifetime_names: opt_vec::Empty,\n+                    inputs: ~[ star_u8 ],\n+                    output: ty::mk_nil()\n+                }\n+            });\n+            let datum = Datum {val: get_param(decl, first_real_arg),\n+                               mode: ByRef(ZeroMem), ty: fty};\n+            let arg_vals = ~[frameaddress_val];\n+            bcx = trans_call_inner(\n+                bcx, None, fty, ty::mk_nil(),\n+                |bcx| Callee {bcx: bcx, data: Closure(datum)},\n+                ArgVals(arg_vals), Some(Ignore), DontAutorefArg).bcx;\n+            RetVoid(bcx);\n+        }\n+        \"morestack_addr\" => {\n+            // XXX This is a hack to grab the address of this particular\n+            // native function. There should be a general in-language\n+            // way to do this\n+            let llfty = type_of_rust_fn(bcx.ccx(), [], ty::mk_nil());\n+            let morestack_addr = decl_cdecl_fn(\n+                bcx.ccx().llmod, \"__morestack\", llfty);\n+            let morestack_addr = PointerCast(bcx, morestack_addr, Type::nil().ptr_to());\n+            Ret(bcx, morestack_addr);\n+        }\n+        \"offset\" => {\n+            let ptr = get_param(decl, first_real_arg);\n+            let offset = get_param(decl, first_real_arg + 1);\n+            Ret(bcx, GEP(bcx, ptr, [offset]));\n+        }\n+        \"offset_inbounds\" => {\n+            let ptr = get_param(decl, first_real_arg);\n+            let offset = get_param(decl, first_real_arg + 1);\n+            Ret(bcx, InBoundsGEP(bcx, ptr, [offset]));\n+        }\n+        \"memcpy32\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i32\", substs.tys[0], 32),\n+        \"memcpy64\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i64\", substs.tys[0], 64),\n+        \"memmove32\" => memcpy_intrinsic(bcx, \"llvm.memmove.p0i8.p0i8.i32\", substs.tys[0], 32),\n+        \"memmove64\" => memcpy_intrinsic(bcx, \"llvm.memmove.p0i8.p0i8.i64\", substs.tys[0], 64),\n+        \"memset32\" => memset_intrinsic(bcx, \"llvm.memset.p0i8.i32\", substs.tys[0], 32),\n+        \"memset64\" => memset_intrinsic(bcx, \"llvm.memset.p0i8.i64\", substs.tys[0], 64),\n+        \"sqrtf32\" => simple_llvm_intrinsic(bcx, \"llvm.sqrt.f32\", 1),\n+        \"sqrtf64\" => simple_llvm_intrinsic(bcx, \"llvm.sqrt.f64\", 1),\n+        \"powif32\" => simple_llvm_intrinsic(bcx, \"llvm.powi.f32\", 2),\n+        \"powif64\" => simple_llvm_intrinsic(bcx, \"llvm.powi.f64\", 2),\n+        \"sinf32\" => simple_llvm_intrinsic(bcx, \"llvm.sin.f32\", 1),\n+        \"sinf64\" => simple_llvm_intrinsic(bcx, \"llvm.sin.f64\", 1),\n+        \"cosf32\" => simple_llvm_intrinsic(bcx, \"llvm.cos.f32\", 1),\n+        \"cosf64\" => simple_llvm_intrinsic(bcx, \"llvm.cos.f64\", 1),\n+        \"powf32\" => simple_llvm_intrinsic(bcx, \"llvm.pow.f32\", 2),\n+        \"powf64\" => simple_llvm_intrinsic(bcx, \"llvm.pow.f64\", 2),\n+        \"expf32\" => simple_llvm_intrinsic(bcx, \"llvm.exp.f32\", 1),\n+        \"expf64\" => simple_llvm_intrinsic(bcx, \"llvm.exp.f64\", 1),\n+        \"exp2f32\" => simple_llvm_intrinsic(bcx, \"llvm.exp2.f32\", 1),\n+        \"exp2f64\" => simple_llvm_intrinsic(bcx, \"llvm.exp2.f64\", 1),\n+        \"logf32\" => simple_llvm_intrinsic(bcx, \"llvm.log.f32\", 1),\n+        \"logf64\" => simple_llvm_intrinsic(bcx, \"llvm.log.f64\", 1),\n+        \"log10f32\" => simple_llvm_intrinsic(bcx, \"llvm.log10.f32\", 1),\n+        \"log10f64\" => simple_llvm_intrinsic(bcx, \"llvm.log10.f64\", 1),\n+        \"log2f32\" => simple_llvm_intrinsic(bcx, \"llvm.log2.f32\", 1),\n+        \"log2f64\" => simple_llvm_intrinsic(bcx, \"llvm.log2.f64\", 1),\n+        \"fmaf32\" => simple_llvm_intrinsic(bcx, \"llvm.fma.f32\", 3),\n+        \"fmaf64\" => simple_llvm_intrinsic(bcx, \"llvm.fma.f64\", 3),\n+        \"fabsf32\" => simple_llvm_intrinsic(bcx, \"llvm.fabs.f32\", 1),\n+        \"fabsf64\" => simple_llvm_intrinsic(bcx, \"llvm.fabs.f64\", 1),\n+        \"floorf32\" => simple_llvm_intrinsic(bcx, \"llvm.floor.f32\", 1),\n+        \"floorf64\" => simple_llvm_intrinsic(bcx, \"llvm.floor.f64\", 1),\n+        \"ceilf32\" => simple_llvm_intrinsic(bcx, \"llvm.ceil.f32\", 1),\n+        \"ceilf64\" => simple_llvm_intrinsic(bcx, \"llvm.ceil.f64\", 1),\n+        \"truncf32\" => simple_llvm_intrinsic(bcx, \"llvm.trunc.f32\", 1),\n+        \"truncf64\" => simple_llvm_intrinsic(bcx, \"llvm.trunc.f64\", 1),\n+        \"ctpop8\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i8\", 1),\n+        \"ctpop16\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i16\", 1),\n+        \"ctpop32\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i32\", 1),\n+        \"ctpop64\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i64\", 1),\n+        \"ctlz8\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\"),\n+        \"ctlz16\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\"),\n+        \"ctlz32\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i32\"),\n+        \"ctlz64\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i64\"),\n+        \"cttz8\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i8\"),\n+        \"cttz16\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i16\"),\n+        \"cttz32\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i32\"),\n+        \"cttz64\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i64\"),\n+        \"bswap16\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i16\", 1),\n+        \"bswap32\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i32\", 1),\n+        \"bswap64\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i64\", 1),\n+\n+        \"i8_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i8\"),\n+        \"i16_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i16\"),\n+        \"i32_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i32\"),\n+        \"i64_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i64\"),\n+\n+        \"u8_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i8\"),\n+        \"u16_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i16\"),\n+        \"u32_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i32\"),\n+        \"u64_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i64\"),\n+\n+        \"i8_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i8\"),\n+        \"i16_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i16\"),\n+        \"i32_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i32\"),\n+        \"i64_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i64\"),\n+\n+        \"u8_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i8\"),\n+        \"u16_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i16\"),\n+        \"u32_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i32\"),\n+        \"u64_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i64\"),\n+\n+        \"i8_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i8\"),\n+        \"i16_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i16\"),\n+        \"i32_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i32\"),\n+        \"i64_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i64\"),\n+\n+        \"u8_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i8\"),\n+        \"u16_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i16\"),\n+        \"u32_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i32\"),\n+        \"u64_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i64\"),\n+\n+        _ => {\n+            // Could we make this an enum rather than a string? does it get\n+            // checked earlier?\n+            ccx.sess.span_bug(item.span, \"unknown intrinsic\");\n+        }\n+    }\n+    fcx.cleanup();\n+}"}, {"sha": "cf6d465cb820c50f230e222cac3b3f3d7f73091f", "filename": "src/librustc/middle/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -35,6 +35,7 @@ pub mod cabi_x86_64;\n pub mod cabi_arm;\n pub mod cabi_mips;\n pub mod foreign;\n+pub mod intrinsic;\n pub mod reflect;\n pub mod debuginfo;\n pub mod type_use;"}, {"sha": "5249a2b9b7bb642443ed9b7659d2c5afeb8ce967", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -19,12 +19,12 @@ use middle::trans::base::{get_item_val, no_self};\n use middle::trans::base;\n use middle::trans::common::*;\n use middle::trans::datum;\n-use middle::trans::foreign;\n use middle::trans::machine;\n use middle::trans::meth;\n use middle::trans::type_of::type_of_fn_from_ty;\n use middle::trans::type_of;\n use middle::trans::type_use;\n+use middle::trans::intrinsic;\n use middle::ty;\n use middle::ty::{FnSig};\n use middle::typeck;\n@@ -239,8 +239,8 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n       }\n       ast_map::node_foreign_item(i, _, _, _) => {\n           let d = mk_lldecl();\n-          foreign::trans_intrinsic(ccx, d, i, pt, psubsts, i.attrs,\n-                                ref_id);\n+          intrinsic::trans_intrinsic(ccx, d, i, pt, psubsts, i.attrs,\n+                                     ref_id);\n           d\n       }\n       ast_map::node_variant(ref v, enum_item, _) => {"}, {"sha": "dd1b041ef80f1aae3d49dd4012a6b087986b3464", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -284,7 +284,7 @@ impl Reflector {\n                                                                sub_path,\n                                                                \"get_disr\");\n \n-                let llfty = type_of_fn(ccx, [opaqueptrty], ty::mk_int());\n+                let llfty = type_of_rust_fn(ccx, [opaqueptrty], ty::mk_int());\n                 let llfdecl = decl_internal_cdecl_fn(ccx.llmod, sym, llfty);\n                 let fcx = new_fn_ctxt(ccx,\n                                       ~[],"}, {"sha": "6a57827e6d1c60ab3a6f2599a4c62d6ee1e17e55", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -11,6 +11,7 @@\n \n use middle::trans::adt;\n use middle::trans::common::*;\n+use middle::trans::foreign;\n use middle::ty;\n use util::ppaux;\n \n@@ -19,12 +20,16 @@ use middle::trans::type_::Type;\n use syntax::ast;\n use syntax::opt_vec;\n \n-pub fn arg_is_indirect(ccx: &CrateContext, arg_ty: &ty::t) -> bool {\n-    !ty::type_is_immediate(ccx.tcx, *arg_ty)\n+pub fn arg_is_indirect(ccx: &CrateContext, arg_ty: ty::t) -> bool {\n+    !ty::type_is_immediate(ccx.tcx, arg_ty)\n }\n \n-pub fn type_of_explicit_arg(ccx: &mut CrateContext, arg_ty: &ty::t) -> Type {\n-    let llty = type_of(ccx, *arg_ty);\n+pub fn return_uses_outptr(tcx: ty::ctxt, ty: ty::t) -> bool {\n+    !ty::type_is_immediate(tcx, ty)\n+}\n+\n+pub fn type_of_explicit_arg(ccx: &mut CrateContext, arg_ty: ty::t) -> Type {\n+    let llty = type_of(ccx, arg_ty);\n     if arg_is_indirect(ccx, arg_ty) {\n         llty.ptr_to()\n     } else {\n@@ -34,17 +39,19 @@ pub fn type_of_explicit_arg(ccx: &mut CrateContext, arg_ty: &ty::t) -> Type {\n \n pub fn type_of_explicit_args(ccx: &mut CrateContext,\n                              inputs: &[ty::t]) -> ~[Type] {\n-    inputs.map(|arg_ty| type_of_explicit_arg(ccx, arg_ty))\n+    inputs.map(|&arg_ty| type_of_explicit_arg(ccx, arg_ty))\n }\n \n-pub fn type_of_fn(cx: &mut CrateContext, inputs: &[ty::t], output: ty::t) -> Type {\n+pub fn type_of_rust_fn(cx: &mut CrateContext,\n+                       inputs: &[ty::t],\n+                       output: ty::t) -> Type {\n     let mut atys: ~[Type] = ~[];\n \n     // Arg 0: Output pointer.\n     // (if the output type is non-immediate)\n-    let output_is_immediate = ty::type_is_immediate(cx.tcx, output);\n+    let use_out_pointer = return_uses_outptr(cx.tcx, output);\n     let lloutputtype = type_of(cx, output);\n-    if !output_is_immediate {\n+    if use_out_pointer {\n         atys.push(lloutputtype.ptr_to());\n     }\n \n@@ -55,7 +62,7 @@ pub fn type_of_fn(cx: &mut CrateContext, inputs: &[ty::t], output: ty::t) -> Typ\n     atys.push_all(type_of_explicit_args(cx, inputs));\n \n     // Use the output as the actual return value if it's immediate.\n-    if output_is_immediate && !ty::type_is_nil(output) {\n+    if !use_out_pointer && !ty::type_is_voidish(output) {\n         Type::func(atys, &lloutputtype)\n     } else {\n         Type::func(atys, &Type::void())\n@@ -64,13 +71,21 @@ pub fn type_of_fn(cx: &mut CrateContext, inputs: &[ty::t], output: ty::t) -> Typ\n \n // Given a function type and a count of ty params, construct an llvm type\n pub fn type_of_fn_from_ty(cx: &mut CrateContext, fty: ty::t) -> Type {\n-    match ty::get(fty).sty {\n-        ty::ty_closure(ref f) => type_of_fn(cx, f.sig.inputs, f.sig.output),\n-        ty::ty_bare_fn(ref f) => type_of_fn(cx, f.sig.inputs, f.sig.output),\n+    return match ty::get(fty).sty {\n+        ty::ty_closure(ref f) => {\n+            type_of_rust_fn(cx, f.sig.inputs, f.sig.output)\n+        }\n+        ty::ty_bare_fn(ref f) => {\n+            if f.abis.is_rust() || f.abis.is_intrinsic() {\n+                type_of_rust_fn(cx, f.sig.inputs, f.sig.output)\n+            } else {\n+                foreign::lltype_for_foreign_fn(cx, fty)\n+            }\n+        }\n         _ => {\n             cx.sess.bug(\"type_of_fn_from_ty given non-closure, non-bare-fn\")\n         }\n-    }\n+    };\n }\n \n // A \"sizing type\" is an LLVM type, the size and alignment of which are\n@@ -250,7 +265,9 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n           Type::array(&type_of(cx, mt.ty), n as u64)\n       }\n \n-      ty::ty_bare_fn(_) => type_of_fn_from_ty(cx, t).ptr_to(),\n+      ty::ty_bare_fn(_) => {\n+          type_of_fn_from_ty(cx, t).ptr_to()\n+      }\n       ty::ty_closure(_) => {\n           let ty = type_of_fn_from_ty(cx, t);\n           Type::func_pair(cx, &ty)"}, {"sha": "685699f781900e741a98d3c44516ef5df2a8cc1e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -1545,6 +1545,11 @@ pub fn subst(cx: ctxt,\n \n // Type utilities\n \n+pub fn type_is_voidish(ty: t) -> bool {\n+    //! \"nil\" and \"bot\" are void types in that they represent 0 bits of information\n+    type_is_nil(ty) || type_is_bot(ty)\n+}\n+\n pub fn type_is_nil(ty: t) -> bool { get(ty).sty == ty_nil }\n \n pub fn type_is_bot(ty: t) -> bool {"}, {"sha": "f9cbab58211e6475296a4db16e6207c6fa6a49b6", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -17,6 +17,11 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n+// Rustc tasks always run on a fixed_stack_segment, so code in this\n+// module can call C functions (in particular, LLVM functions) with\n+// impunity.\n+#[allow(cstack)];\n+\n extern mod extra;\n extern mod syntax;\n \n@@ -68,6 +73,7 @@ pub mod middle {\n     pub mod reachable;\n     pub mod graph;\n     pub mod cfg;\n+    pub mod stack_check;\n }\n \n pub mod front {"}, {"sha": "5ba52326579e1b1d820218f1b83e0df5f663d3d1", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -862,3 +862,15 @@ impl UserString for ty::t {\n         ty_to_str(tcx, *self)\n     }\n }\n+\n+impl Repr for AbiSet {\n+    fn repr(&self, _tcx: ctxt) -> ~str {\n+        self.to_str()\n+    }\n+}\n+\n+impl UserString for AbiSet {\n+    fn user_string(&self, _tcx: ctxt) -> ~str {\n+        self.to_str()\n+    }\n+}"}, {"sha": "d4bee13aae7f97eb3a180a150eebfd59c5f52239", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -498,6 +498,8 @@ pub fn run_line(repl: &mut Repl, input: @io::Reader, out: @io::Writer, line: ~st\n }\n \n pub fn main() {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let args = os::args();\n     let input = io::stdin();\n     let out = io::stdout();"}, {"sha": "41c1c7e31aeff82eb7503c354e1ee3af0dc647c1", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -382,6 +382,8 @@ pub fn find_and_install_dependencies(ctxt: &Ctx,\n \n #[cfg(windows)]\n pub fn link_exe(_src: &Path, _dest: &Path) -> bool {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     /* FIXME (#1768): Investigate how to do this on win32\n        Node wraps symlinks by having a .bat,\n        but that won't work with minGW. */\n@@ -394,6 +396,8 @@ pub fn link_exe(_src: &Path, _dest: &Path) -> bool {\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"macos\")]\n pub fn link_exe(src: &Path, dest: &Path) -> bool {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     use std::c_str::ToCStr;\n     use std::libc;\n "}, {"sha": "98710c158e0d7f8d82e0719952ab13716a075e51", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -96,6 +96,7 @@ impl CString {\n     ///\n     /// Fails if the CString is null.\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n+        #[fixed_stack_segment]; #[inline(never)];\n         if self.buf.is_null() { fail!(\"CString is null!\"); }\n         unsafe {\n             let len = libc::strlen(self.buf) as uint;\n@@ -114,6 +115,7 @@ impl CString {\n \n impl Drop for CString {\n     fn drop(&self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n         if self.owns_buffer_ {\n             unsafe {\n                 libc::free(self.buf as *libc::c_void)\n@@ -172,6 +174,7 @@ impl<'self> ToCStr for &'self str {\n \n impl<'self> ToCStr for &'self [u8] {\n     fn to_c_str(&self) -> CString {\n+        #[fixed_stack_segment]; #[inline(never)];\n         let mut cs = unsafe { self.to_c_str_unchecked() };\n         do cs.with_mut_ref |buf| {\n             for i in range(0, self.len()) {\n@@ -190,6 +193,7 @@ impl<'self> ToCStr for &'self [u8] {\n     }\n \n     unsafe fn to_c_str_unchecked(&self) -> CString {\n+        #[fixed_stack_segment]; #[inline(never)];\n         do self.as_imm_buf |self_buf, self_len| {\n             let buf = libc::malloc(self_len as libc::size_t + 1) as *mut u8;\n             if buf.is_null() {\n@@ -260,12 +264,16 @@ mod tests {\n \n     #[test]\n     fn test_unwrap() {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         let c_str = \"hello\".to_c_str();\n         unsafe { libc::free(c_str.unwrap() as *libc::c_void) }\n     }\n \n     #[test]\n     fn test_with_ref() {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         let c_str = \"hello\".to_c_str();\n         let len = unsafe { c_str.with_ref(|buf| libc::strlen(buf)) };\n         assert!(!c_str.is_null());"}, {"sha": "8f5a3728e95b4845f2ce6de11e0fbf39ced394b8", "filename": "src/libstd/io.rs", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -928,6 +928,8 @@ fn convert_whence(whence: SeekStyle) -> i32 {\n \n impl Reader for *libc::FILE {\n     fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             do bytes.as_mut_buf |buf_p, buf_len| {\n                 assert!(buf_len >= len);\n@@ -950,23 +952,31 @@ impl Reader for *libc::FILE {\n         }\n     }\n     fn read_byte(&self) -> int {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             libc::fgetc(*self) as int\n         }\n     }\n     fn eof(&self) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             return libc::feof(*self) != 0 as c_int;\n         }\n     }\n     fn seek(&self, offset: int, whence: SeekStyle) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             assert!(libc::fseek(*self,\n                                      offset as c_long,\n                                      convert_whence(whence)) == 0 as c_int);\n         }\n     }\n     fn tell(&self) -> uint {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             return libc::ftell(*self) as uint;\n         }\n@@ -1005,6 +1015,8 @@ impl FILERes {\n \n impl Drop for FILERes {\n     fn drop(&self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             libc::fclose(self.f);\n         }\n@@ -1035,12 +1047,16 @@ pub fn FILE_reader(f: *libc::FILE, cleanup: bool) -> @Reader {\n * ~~~\n */\n pub fn stdin() -> @Reader {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         @rustrt::rust_get_stdin() as @Reader\n     }\n }\n \n pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let f = do path.with_c_str |pathbuf| {\n         do \"rb\".with_c_str |modebuf| {\n             unsafe { libc::fopen(pathbuf, modebuf as *libc::c_char) }\n@@ -1162,6 +1178,8 @@ impl<W:Writer,C> Writer for Wrapper<W, C> {\n \n impl Writer for *libc::FILE {\n     fn write(&self, v: &[u8]) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             do v.as_imm_buf |vbuf, len| {\n                 let nout = libc::fwrite(vbuf as *c_void,\n@@ -1177,23 +1195,31 @@ impl Writer for *libc::FILE {\n         }\n     }\n     fn seek(&self, offset: int, whence: SeekStyle) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             assert!(libc::fseek(*self,\n                                      offset as c_long,\n                                      convert_whence(whence)) == 0 as c_int);\n         }\n     }\n     fn tell(&self) -> uint {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             libc::ftell(*self) as uint\n         }\n     }\n     fn flush(&self) -> int {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             libc::fflush(*self) as int\n         }\n     }\n     fn get_type(&self) -> WriterType {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             let fd = libc::fileno(*self);\n             if libc::isatty(fd) == 0 { File   }\n@@ -1212,6 +1238,8 @@ pub fn FILE_writer(f: *libc::FILE, cleanup: bool) -> @Writer {\n \n impl Writer for fd_t {\n     fn write(&self, v: &[u8]) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             let mut count = 0u;\n             do v.as_imm_buf |vbuf, len| {\n@@ -1238,6 +1266,8 @@ impl Writer for fd_t {\n     }\n     fn flush(&self) -> int { 0 }\n     fn get_type(&self) -> WriterType {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             if libc::isatty(*self) == 0 { File } else { Screen }\n         }\n@@ -1256,6 +1286,8 @@ impl FdRes {\n \n impl Drop for FdRes {\n     fn drop(&self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             libc::close(self.fd);\n         }\n@@ -1273,6 +1305,8 @@ pub fn fd_writer(fd: fd_t, cleanup: bool) -> @Writer {\n \n pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n                    -> Result<@Writer, ~str> {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     #[cfg(windows)]\n     fn wb() -> c_int {\n       (O_WRONLY | libc::consts::os::extra::O_BINARY) as c_int\n@@ -1573,6 +1607,8 @@ pub fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<@Writer, ~str> {\n \n // FIXME: fileflags // #2004\n pub fn buffered_file_writer(path: &Path) -> Result<@Writer, ~str> {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         let f = do path.with_c_str |pathbuf| {\n             do \"w\".with_c_str |modebuf| {\n@@ -1803,23 +1839,30 @@ pub mod fsync {\n                          blk: &fn(v: Res<*libc::FILE>)) {\n         blk(Res::new(Arg {\n             val: file.f, opt_level: opt_level,\n-            fsync_fn: |file, l| {\n-                unsafe {\n-                    os::fsync_fd(libc::fileno(*file), l) as int\n-                }\n-            }\n+            fsync_fn: |file, l| fsync_fd(fileno(*file), l)\n         }));\n+\n+        fn fileno(stream: *libc::FILE) -> libc::c_int {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe { libc::fileno(stream) }\n+        }\n     }\n \n     // fsync fd after executing blk\n     pub fn fd_res_sync(fd: &FdRes, opt_level: Option<Level>,\n                        blk: &fn(v: Res<fd_t>)) {\n         blk(Res::new(Arg {\n             val: fd.fd, opt_level: opt_level,\n-            fsync_fn: |fd, l| os::fsync_fd(*fd, l) as int\n+            fsync_fn: |fd, l| fsync_fd(*fd, l)\n         }));\n     }\n \n+    fn fsync_fd(fd: libc::c_int, level: Level) -> int {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n+        os::fsync_fd(fd, level) as int\n+    }\n+\n     // Type of objects that may want to fsync\n     pub trait FSyncable { fn fsync(&self, l: Level) -> int; }\n "}, {"sha": "d3e0c88e5dff7e78bad2ed3543178ca89767ebd3", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -2762,9 +2762,11 @@ pub mod funcs {\n             // doesn't link it correctly on i686, so we're going\n             // through a C function that mysteriously does work.\n             pub unsafe fn opendir(dirname: *c_char) -> *DIR {\n+                #[fixed_stack_segment]; #[inline(never)];\n                 rust_opendir(dirname)\n             }\n             pub unsafe fn readdir(dirp: *DIR) -> *dirent_t {\n+                #[fixed_stack_segment]; #[inline(never)];\n                 rust_readdir(dirp)\n             }\n "}, {"sha": "17175de9b929dafd3025c0ca6b57102b5046f7fc", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -41,7 +41,7 @@ macro_rules! delegate(\n             use unstable::intrinsics;\n \n             $(\n-                #[inline]\n+                #[inline] #[fixed_stack_segment] #[inline(never)]\n                 pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n                     unsafe {\n                         $bound_name($( $arg ),*)"}, {"sha": "91361a61c215137042e4607715c08415094f96b8", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -43,7 +43,7 @@ macro_rules! delegate(\n             use unstable::intrinsics;\n \n             $(\n-                #[inline]\n+                #[inline] #[fixed_stack_segment] #[inline(never)]\n                 pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n                     unsafe {\n                         $bound_name($( $arg ),*)"}, {"sha": "4e5a0e9b9138a632beda8eeaa6e4689cd585cfe2", "filename": "src/libstd/os.rs", "status": "modified", "additions": 92, "deletions": 6, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -51,6 +51,7 @@ pub use os::consts::*;\n \n /// Delegates to the libc close() function, returning the same return value.\n pub fn close(fd: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         libc::close(fd)\n     }\n@@ -70,6 +71,7 @@ pub static TMPBUF_SZ : uint = 1000u;\n static BUF_BYTES : uint = 2048u;\n \n pub fn getcwd() -> Path {\n+    #[fixed_stack_segment]; #[inline(never)];\n     let mut buf = [0 as libc::c_char, ..BUF_BYTES];\n     do buf.as_mut_buf |buf, len| {\n         unsafe {\n@@ -109,6 +111,8 @@ pub mod win32 {\n \n     pub fn fill_utf16_buf_and_decode(f: &fn(*mut u16, DWORD) -> DWORD)\n         -> Option<~str> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             let mut n = TMPBUF_SZ as DWORD;\n             let mut res = None;\n@@ -145,6 +149,18 @@ pub mod win32 {\n     }\n }\n \n+#[cfg(stage0)]\n+mod macro_hack {\n+#[macro_escape];\n+macro_rules! externfn(\n+    (fn $name:ident ()) => (\n+        extern {\n+            fn $name();\n+        }\n+    )\n+)\n+}\n+\n /*\n Accessing environment variables is not generally threadsafe.\n Serialize access through a global lock.\n@@ -161,12 +177,8 @@ fn with_env_lock<T>(f: &fn() -> T) -> T {\n         };\n     }\n \n-    extern {\n-        #[fast_ffi]\n-        fn rust_take_env_lock();\n-        #[fast_ffi]\n-        fn rust_drop_env_lock();\n-    }\n+    externfn!(fn rust_take_env_lock());\n+    externfn!(fn rust_drop_env_lock());\n }\n \n /// Returns a vector of (variable, value) pairs for all the environment\n@@ -175,6 +187,8 @@ pub fn env() -> ~[(~str,~str)] {\n     unsafe {\n         #[cfg(windows)]\n         unsafe fn get_env_pairs() -> ~[~str] {\n+            #[fixed_stack_segment]; #[inline(never)];\n+\n             use libc::funcs::extra::kernel32::{\n                 GetEnvironmentStringsA,\n                 FreeEnvironmentStringsA\n@@ -198,6 +212,8 @@ pub fn env() -> ~[(~str,~str)] {\n         }\n         #[cfg(unix)]\n         unsafe fn get_env_pairs() -> ~[~str] {\n+            #[fixed_stack_segment]; #[inline(never)];\n+\n             extern {\n                 fn rust_env_pairs() -> **libc::c_char;\n             }\n@@ -237,6 +253,7 @@ pub fn env() -> ~[(~str,~str)] {\n /// Fetches the environment variable `n` from the current process, returning\n /// None if the variable isn't set.\n pub fn getenv(n: &str) -> Option<~str> {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         do with_env_lock {\n             let s = do n.with_c_str |buf| {\n@@ -255,6 +272,8 @@ pub fn getenv(n: &str) -> Option<~str> {\n /// Fetches the environment variable `n` from the current process, returning\n /// None if the variable isn't set.\n pub fn getenv(n: &str) -> Option<~str> {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         do with_env_lock {\n             use os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n@@ -272,6 +291,7 @@ pub fn getenv(n: &str) -> Option<~str> {\n /// Sets the environment variable `n` to the value `v` for the currently running\n /// process\n pub fn setenv(n: &str, v: &str) {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         do with_env_lock {\n             do n.with_c_str |nbuf| {\n@@ -288,6 +308,8 @@ pub fn setenv(n: &str, v: &str) {\n /// Sets the environment variable `n` to the value `v` for the currently running\n /// process\n pub fn setenv(n: &str, v: &str) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         do with_env_lock {\n             use os::win32::as_utf16_p;\n@@ -304,6 +326,7 @@ pub fn setenv(n: &str, v: &str) {\n pub fn unsetenv(n: &str) {\n     #[cfg(unix)]\n     fn _unsetenv(n: &str) {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             do with_env_lock {\n                 do n.with_c_str |nbuf| {\n@@ -314,6 +337,7 @@ pub fn unsetenv(n: &str) {\n     }\n     #[cfg(windows)]\n     fn _unsetenv(n: &str) {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             do with_env_lock {\n                 use os::win32::as_utf16_p;\n@@ -328,6 +352,7 @@ pub fn unsetenv(n: &str) {\n }\n \n pub fn fdopen(fd: c_int) -> *FILE {\n+    #[fixed_stack_segment]; #[inline(never)];\n     do \"r\".with_c_str |modebuf| {\n         unsafe {\n             libc::fdopen(fd, modebuf)\n@@ -340,6 +365,7 @@ pub fn fdopen(fd: c_int) -> *FILE {\n \n #[cfg(windows)]\n pub fn fsync_fd(fd: c_int, _level: io::fsync::Level) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         use libc::funcs::extra::msvcrt::*;\n         return commit(fd);\n@@ -349,6 +375,7 @@ pub fn fsync_fd(fd: c_int, _level: io::fsync::Level) -> c_int {\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"android\")]\n pub fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         use libc::funcs::posix01::unistd::*;\n         match level {\n@@ -361,6 +388,8 @@ pub fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n \n #[cfg(target_os = \"macos\")]\n pub fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         use libc::consts::os::extra::*;\n         use libc::funcs::posix88::fcntl::*;\n@@ -381,6 +410,8 @@ pub fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n \n #[cfg(target_os = \"freebsd\")]\n pub fn fsync_fd(fd: c_int, _l: io::fsync::Level) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         use libc::funcs::posix01::unistd::*;\n         return fsync(fd);\n@@ -394,6 +425,7 @@ pub struct Pipe {\n \n #[cfg(unix)]\n pub fn pipe() -> Pipe {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         let mut fds = Pipe {input: 0 as c_int,\n                             out: 0 as c_int };\n@@ -406,6 +438,7 @@ pub fn pipe() -> Pipe {\n \n #[cfg(windows)]\n pub fn pipe() -> Pipe {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         // Windows pipes work subtly differently than unix pipes, and their\n         // inheritance has to be handled in a different way that I do not\n@@ -424,6 +457,7 @@ pub fn pipe() -> Pipe {\n }\n \n fn dup2(src: c_int, dst: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         libc::dup2(src, dst)\n     }\n@@ -440,6 +474,7 @@ pub fn self_exe_path() -> Option<Path> {\n \n     #[cfg(target_os = \"freebsd\")]\n     fn load_self() -> Option<~str> {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use libc::funcs::bsd44::*;\n             use libc::consts::os::extra::*;\n@@ -458,6 +493,7 @@ pub fn self_exe_path() -> Option<Path> {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     fn load_self() -> Option<~str> {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use libc::funcs::posix01::unistd::readlink;\n \n@@ -479,6 +515,7 @@ pub fn self_exe_path() -> Option<Path> {\n \n     #[cfg(target_os = \"macos\")]\n     fn load_self() -> Option<~str> {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             do fill_charp_buf() |buf, sz| {\n                 let mut sz = sz as u32;\n@@ -490,6 +527,7 @@ pub fn self_exe_path() -> Option<Path> {\n \n     #[cfg(windows)]\n     fn load_self() -> Option<~str> {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::fill_utf16_buf_and_decode;\n             do fill_utf16_buf_and_decode() |buf, sz| {\n@@ -592,6 +630,7 @@ pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) -> bool {\n \n /// Indicates whether a path represents a directory\n pub fn path_is_dir(p: &Path) -> bool {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         do p.with_c_str |buf| {\n             rustrt::rust_path_is_dir(buf) != 0 as c_int\n@@ -601,6 +640,7 @@ pub fn path_is_dir(p: &Path) -> bool {\n \n /// Indicates whether a path exists\n pub fn path_exists(p: &Path) -> bool {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         do p.with_c_str |buf| {\n             rustrt::rust_path_exists(buf) != 0 as c_int\n@@ -633,6 +673,7 @@ pub fn make_dir(p: &Path, mode: c_int) -> bool {\n \n     #[cfg(windows)]\n     fn mkdir(p: &Path, _mode: c_int) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::as_utf16_p;\n             // FIXME: turn mode into something useful? #2623\n@@ -645,6 +686,7 @@ pub fn make_dir(p: &Path, mode: c_int) -> bool {\n \n     #[cfg(unix)]\n     fn mkdir(p: &Path, mode: c_int) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         do p.with_c_str |buf| {\n             unsafe {\n                 libc::mkdir(buf, mode as libc::mode_t) == (0 as c_int)\n@@ -689,6 +731,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n         #[cfg(target_os = \"freebsd\")]\n         #[cfg(target_os = \"macos\")]\n         unsafe fn get_list(p: &Path) -> ~[~str] {\n+            #[fixed_stack_segment]; #[inline(never)];\n             use libc::{dirent_t};\n             use libc::{opendir, readdir, closedir};\n             extern {\n@@ -721,6 +764,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n         }\n         #[cfg(windows)]\n         unsafe fn get_list(p: &Path) -> ~[~str] {\n+            #[fixed_stack_segment]; #[inline(never)];\n             use libc::consts::os::extra::INVALID_HANDLE_VALUE;\n             use libc::{wcslen, free};\n             use libc::funcs::extra::kernel32::{\n@@ -809,6 +853,7 @@ pub fn remove_dir(p: &Path) -> bool {\n \n     #[cfg(windows)]\n     fn rmdir(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::as_utf16_p;\n             return do as_utf16_p(p.to_str()) |buf| {\n@@ -819,6 +864,7 @@ pub fn remove_dir(p: &Path) -> bool {\n \n     #[cfg(unix)]\n     fn rmdir(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         do p.with_c_str |buf| {\n             unsafe {\n                 libc::rmdir(buf) == (0 as c_int)\n@@ -834,6 +880,7 @@ pub fn change_dir(p: &Path) -> bool {\n \n     #[cfg(windows)]\n     fn chdir(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::as_utf16_p;\n             return do as_utf16_p(p.to_str()) |buf| {\n@@ -844,6 +891,7 @@ pub fn change_dir(p: &Path) -> bool {\n \n     #[cfg(unix)]\n     fn chdir(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         do p.with_c_str |buf| {\n             unsafe {\n                 libc::chdir(buf) == (0 as c_int)\n@@ -858,6 +906,7 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n \n     #[cfg(windows)]\n     fn do_copy_file(from: &Path, to: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::as_utf16_p;\n             return do as_utf16_p(from.to_str()) |fromp| {\n@@ -871,6 +920,7 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n \n     #[cfg(unix)]\n     fn do_copy_file(from: &Path, to: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             let istream = do from.with_c_str |fromp| {\n                 do \"rb\".with_c_str |modebuf| {\n@@ -933,6 +983,7 @@ pub fn remove_file(p: &Path) -> bool {\n \n     #[cfg(windows)]\n     fn unlink(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::as_utf16_p;\n             return do as_utf16_p(p.to_str()) |buf| {\n@@ -943,6 +994,7 @@ pub fn remove_file(p: &Path) -> bool {\n \n     #[cfg(unix)]\n     fn unlink(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             do p.with_c_str |buf| {\n                 libc::unlink(buf) == (0 as c_int)\n@@ -957,6 +1009,7 @@ pub fn errno() -> int {\n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]\n     fn errno_location() -> *c_int {\n+        #[fixed_stack_segment]; #[inline(never)];\n         #[nolink]\n         extern {\n             fn __error() -> *c_int;\n@@ -969,6 +1022,7 @@ pub fn errno() -> int {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     fn errno_location() -> *c_int {\n+        #[fixed_stack_segment]; #[inline(never)];\n         #[nolink]\n         extern {\n             fn __errno_location() -> *c_int;\n@@ -986,6 +1040,7 @@ pub fn errno() -> int {\n #[cfg(windows)]\n /// Returns the platform-specific value of errno\n pub fn errno() -> uint {\n+    #[fixed_stack_segment]; #[inline(never)];\n     use libc::types::os::arch::extra::DWORD;\n \n     #[link_name = \"kernel32\"]\n@@ -1008,6 +1063,8 @@ pub fn last_os_error() -> ~str {\n         #[cfg(target_os = \"freebsd\")]\n         fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t)\n                       -> c_int {\n+            #[fixed_stack_segment]; #[inline(never)];\n+\n             #[nolink]\n             extern {\n                 fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t)\n@@ -1023,6 +1080,7 @@ pub fn last_os_error() -> ~str {\n         // So we just use __xpg_strerror_r which is always POSIX compliant\n         #[cfg(target_os = \"linux\")]\n         fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t) -> c_int {\n+            #[fixed_stack_segment]; #[inline(never)];\n             #[nolink]\n             extern {\n                 fn __xpg_strerror_r(errnum: c_int,\n@@ -1050,6 +1108,8 @@ pub fn last_os_error() -> ~str {\n \n     #[cfg(windows)]\n     fn strerror() -> ~str {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         use libc::types::os::arch::extra::DWORD;\n         use libc::types::os::arch::extra::LPSTR;\n         use libc::types::os::arch::extra::LPVOID;\n@@ -1129,6 +1189,8 @@ unsafe fn load_argc_and_argv(argc: c_int, argv: **c_char) -> ~[~str] {\n  */\n #[cfg(target_os = \"macos\")]\n pub fn real_args() -> ~[~str] {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         let (argc, argv) = (*_NSGetArgc() as c_int,\n                             *_NSGetArgv() as **c_char);\n@@ -1150,6 +1212,8 @@ pub fn real_args() -> ~[~str] {\n \n #[cfg(windows)]\n pub fn real_args() -> ~[~str] {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let mut nArgs: c_int = 0;\n     let lpArgCount: *mut c_int = &mut nArgs;\n     let lpCmdLine = unsafe { GetCommandLineW() };\n@@ -1232,6 +1296,8 @@ pub fn set_args(new_args: ~[~str]) {\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"macos\")]\n pub fn glob(pattern: &str) -> ~[Path] {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     fn default_glob_t () -> libc::glob_t {\n@@ -1326,13 +1392,17 @@ fn round_up(from: uint, to: uint) -> uint {\n \n #[cfg(unix)]\n pub fn page_size() -> uint {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         libc::sysconf(libc::_SC_PAGESIZE) as uint\n     }\n }\n \n #[cfg(windows)]\n pub fn page_size() -> uint {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n   unsafe {\n     let mut info = libc::SYSTEM_INFO::new();\n     libc::GetSystemInfo(&mut info);\n@@ -1404,6 +1474,8 @@ impl to_str::ToStr for MapError {\n #[cfg(unix)]\n impl MemoryMap {\n     pub fn new(min_len: uint, options: ~[MapOption]) -> Result<~MemoryMap, MapError> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         use libc::off_t;\n \n         let mut addr: *c_void = ptr::null();\n@@ -1460,6 +1532,8 @@ impl MemoryMap {\n #[cfg(unix)]\n impl Drop for MemoryMap {\n     fn drop(&self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             match libc::munmap(self.data as *c_void, self.len) {\n                 0 => (),\n@@ -1476,6 +1550,8 @@ impl Drop for MemoryMap {\n #[cfg(windows)]\n impl MemoryMap {\n     pub fn new(min_len: uint, options: ~[MapOption]) -> Result<~MemoryMap, MapError> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         use libc::types::os::arch::extra::{LPVOID, DWORD, SIZE_T, HANDLE};\n \n         let mut lpAddress: LPVOID = ptr::mut_null();\n@@ -1569,6 +1645,8 @@ impl MemoryMap {\n #[cfg(windows)]\n impl Drop for MemoryMap {\n     fn drop(&self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         use libc::types::os::arch::extra::{LPCVOID, HANDLE};\n \n         unsafe {\n@@ -1921,6 +1999,8 @@ mod tests {\n \n     #[test]\n     fn copy_file_ok() {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             let tempdir = getcwd(); // would like to use $TMPDIR,\n                                     // doesn't seem to work on Linux\n@@ -1991,17 +2071,23 @@ mod tests {\n \n     #[test]\n     fn memory_map_file() {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         use result::{Ok, Err};\n         use os::*;\n         use libc::*;\n \n         #[cfg(unix)]\n+        #[fixed_stack_segment]\n+        #[inline(never)]\n         fn lseek_(fd: c_int, size: uint) {\n             unsafe {\n                 assert!(lseek(fd, size as off_t, SEEK_SET) == size as off_t);\n             }\n         }\n         #[cfg(windows)]\n+        #[fixed_stack_segment]\n+        #[inline(never)]\n         fn lseek_(fd: c_int, size: uint) {\n            unsafe {\n                assert!(lseek(fd, size as c_long, SEEK_SET) == size as c_long);"}, {"sha": "858098409e90d7c8dd9f4ff76e185a38fb107f64", "filename": "src/libstd/path.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -381,6 +381,7 @@ mod stat {\n #[cfg(target_os = \"win32\")]\n impl WindowsPath {\n     pub fn stat(&self) -> Option<libc::stat> {\n+        #[fixed_stack_segment]; #[inline(never)];\n         do self.with_c_str |buf| {\n             let mut st = stat::arch::default_stat();\n             match unsafe { libc::stat(buf, &mut st) } {\n@@ -415,6 +416,7 @@ impl WindowsPath {\n #[cfg(not(target_os = \"win32\"))]\n impl PosixPath {\n     pub fn stat(&self) -> Option<libc::stat> {\n+        #[fixed_stack_segment]; #[inline(never)];\n         do self.with_c_str |buf| {\n             let mut st = stat::arch::default_stat();\n             match unsafe { libc::stat(buf as *libc::c_char, &mut st) } {\n@@ -493,6 +495,7 @@ impl PosixPath {\n #[cfg(unix)]\n impl PosixPath {\n     pub fn lstat(&self) -> Option<libc::stat> {\n+        #[fixed_stack_segment]; #[inline(never)];\n         do self.with_c_str |buf| {\n             let mut st = stat::arch::default_stat();\n             match unsafe { libc::lstat(buf, &mut st) } {\n@@ -1101,6 +1104,8 @@ pub mod windows {\n     }\n \n     pub fn extract_drive_prefix(s: &str) -> Option<(~str,~str)> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             if (s.len() > 1 &&\n                 libc::isalpha(s[0] as libc::c_int) != 0 &&"}, {"sha": "7b10866207a4222a6f6426b044384673fa09a940", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -877,6 +877,8 @@ impl Rng for XorShiftRng {\n impl XorShiftRng {\n     /// Create an xor shift random number generator with a random seed.\n     pub fn new() -> XorShiftRng {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         // generate seeds the same way as seed(), except we have a spceific size\n         let mut s = [0u8, ..16];\n         loop {\n@@ -910,6 +912,8 @@ impl XorShiftRng {\n \n /// Create a new random seed.\n pub fn seed() -> ~[u8] {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         let n = rustrt::rand_seed_size() as uint;\n         let mut s = vec::from_elem(n, 0_u8);\n@@ -1142,6 +1146,8 @@ mod test {\n \n     #[test]\n     fn compare_isaac_implementation() {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         // This is to verify that the implementation of the ISAAC rng is\n         // correct (i.e. matches the output of the upstream implementation,\n         // which is in the runtime)"}, {"sha": "71eae56c894b81842baf946b38ac56ad610c688c", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -118,12 +118,22 @@ mod imp {\n         args\n     }\n \n-    extern {\n-        fn rust_take_global_args_lock();\n-        fn rust_drop_global_args_lock();\n-        fn rust_get_global_args_ptr() -> *mut Option<~~[~str]>;\n+    #[cfg(stage0)]\n+    mod macro_hack {\n+    #[macro_escape];\n+    macro_rules! externfn(\n+        (fn $name:ident () $(-> $ret_ty:ty),*) => (\n+            extern {\n+                fn $name() $(-> $ret_ty),*;\n+            }\n+        )\n+    )\n     }\n \n+    externfn!(fn rust_take_global_args_lock())\n+    externfn!(fn rust_drop_global_args_lock())\n+    externfn!(fn rust_get_global_args_ptr() -> *mut Option<~~[~str]>)\n+\n     #[cfg(test)]\n     mod tests {\n         use option::{Some, None};"}, {"sha": "6400c1b660d17f7421bac367c7d5eac0e5d34584", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -136,6 +136,7 @@ impl DebugPrints for io::fd_t {\n     }\n \n     unsafe fn write_cstr(&self, p: *c_char) {\n+        #[fixed_stack_segment]; #[inline(never)];\n         use libc::strlen;\n         use vec;\n "}, {"sha": "7d3f5f917748732982753722828c78349eaee010", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -35,8 +35,9 @@ fn align_to(size: uint, align: uint) -> uint {\n }\n \n /// A wrapper around libc::malloc, aborting on out-of-memory\n-#[inline]\n pub unsafe fn malloc_raw(size: uint) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let p = malloc(size as size_t);\n     if p.is_null() {\n         // we need a non-allocating way to print an error here\n@@ -46,8 +47,9 @@ pub unsafe fn malloc_raw(size: uint) -> *c_void {\n }\n \n /// A wrapper around libc::realloc, aborting on out-of-memory\n-#[inline]\n pub unsafe fn realloc_raw(ptr: *mut c_void, size: uint) -> *mut c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let p = realloc(ptr, size as size_t);\n     if p.is_null() {\n         // we need a non-allocating way to print an error here\n@@ -97,8 +99,9 @@ pub unsafe fn exchange_free_(ptr: *c_char) {\n     exchange_free(ptr)\n }\n \n-#[inline]\n pub unsafe fn exchange_free(ptr: *c_char) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     free(ptr as *c_void);\n }\n "}, {"sha": "bca1b4a70f4c933ba604d15f117255bb593251e3", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -37,6 +37,7 @@ pub struct LocalHeap {\n }\n \n impl LocalHeap {\n+    #[fixed_stack_segment] #[inline(never)]\n     pub fn new() -> LocalHeap {\n         unsafe {\n             // Don't need synchronization for the single-threaded local heap\n@@ -55,18 +56,21 @@ impl LocalHeap {\n         }\n     }\n \n+    #[fixed_stack_segment] #[inline(never)]\n     pub fn alloc(&mut self, td: *TypeDesc, size: uint) -> *OpaqueBox {\n         unsafe {\n             return rust_boxed_region_malloc(self.boxed_region, td, size as size_t);\n         }\n     }\n \n+    #[fixed_stack_segment] #[inline(never)]\n     pub fn realloc(&mut self, ptr: *OpaqueBox, size: uint) -> *OpaqueBox {\n         unsafe {\n             return rust_boxed_region_realloc(self.boxed_region, ptr, size as size_t);\n         }\n     }\n \n+    #[fixed_stack_segment] #[inline(never)]\n     pub fn free(&mut self, box: *OpaqueBox) {\n         unsafe {\n             return rust_boxed_region_free(self.boxed_region, box);\n@@ -75,6 +79,7 @@ impl LocalHeap {\n }\n \n impl Drop for LocalHeap {\n+    #[fixed_stack_segment] #[inline(never)]\n     fn drop(&self) {\n         unsafe {\n             rust_delete_boxed_region(self.boxed_region);"}, {"sha": "77303cb8c06cf5b04759624bd6ffa03d1ee29f5a", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -24,6 +24,8 @@ use unstable::finally::Finally;\n use tls = rt::thread_local_storage;\n \n /// Initialize the TLS key. Other ops will fail if this isn't executed first.\n+#[fixed_stack_segment]\n+#[inline(never)]\n pub fn init_tls_key() {\n     unsafe {\n         rust_initialize_rt_tls_key();\n@@ -124,6 +126,8 @@ fn tls_key() -> tls::Key {\n     }\n }\n \n+#[fixed_stack_segment]\n+#[inline(never)]\n fn maybe_tls_key() -> Option<tls::Key> {\n     unsafe {\n         let key: *mut c_void = rust_get_rt_tls_key();\n@@ -149,8 +153,6 @@ fn maybe_tls_key() -> Option<tls::Key> {\n     }\n \n     extern {\n-        #[fast_ffi]\n         fn rust_get_rt_tls_key() -> *mut c_void;\n     }\n-\n }"}, {"sha": "f35304865bb3d7297442f78b899698f707d05122", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -57,6 +57,7 @@ impl Logger for StdErrLogger {\n \n /// Configure logging by traversing the crate map and setting the\n /// per-module global logging flags based on the logging spec\n+#[fixed_stack_segment] #[inline(never)]\n pub fn init(crate_map: *u8) {\n     use c_str::ToCStr;\n     use os;\n@@ -78,8 +79,13 @@ pub fn init(crate_map: *u8) {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn console_on() { unsafe { rust_log_console_on() } }\n+\n+#[fixed_stack_segment] #[inline(never)]\n pub fn console_off() { unsafe { rust_log_console_off() } }\n+\n+#[fixed_stack_segment] #[inline(never)]\n fn should_log_console() -> bool { unsafe { rust_should_log_console() != 0 } }\n \n extern {"}, {"sha": "db1bfdf1bf56cb0cba485736f00bd5f6d74d9f03", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -200,6 +200,18 @@ pub fn start_on_main_thread(argc: int, argv: **u8, crate_map: *u8, main: ~fn())\n     return exit_code;\n }\n \n+#[cfg(stage0)]\n+mod macro_hack {\n+#[macro_escape];\n+macro_rules! externfn(\n+    (fn $name:ident ($($arg_name:ident : $arg_ty:ty),*) $(-> $ret_ty:ty),*) => (\n+        extern {\n+            fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),*;\n+        }\n+    )\n+)\n+}\n+\n /// One-time runtime initialization.\n ///\n /// Initializes global state, including frobbing\n@@ -215,9 +227,7 @@ pub fn init(argc: int, argv: **u8, crate_map: *u8) {\n         rust_update_gc_metadata(crate_map);\n     }\n \n-    extern {\n-        fn rust_update_gc_metadata(crate_map: *u8);\n-    }\n+    externfn!(fn rust_update_gc_metadata(crate_map: *u8));\n }\n \n /// One-time runtime cleanup."}, {"sha": "4b2a9b7a6cce40b418df65d081be82ac787a5ab9", "filename": "src/libstd/rt/stack.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fstack.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -21,6 +21,8 @@ pub struct StackSegment {\n \n impl StackSegment {\n     pub fn new(size: uint) -> StackSegment {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             // Crate a block of uninitialized values\n             let mut stack = vec::with_capacity(size);\n@@ -50,6 +52,8 @@ impl StackSegment {\n \n impl Drop for StackSegment {\n     fn drop(&self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             // XXX: Using the FFI to call a C macro. Slow\n             rust_valgrind_stack_deregister(self.valgrind_id);"}, {"sha": "22d2600507836159db13e1d5d8f7a1d11cd4b954", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -441,6 +441,8 @@ impl Unwinder {\n     }\n \n     pub fn begin_unwind(&mut self) -> ! {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         self.unwinding = true;\n         unsafe {\n             rust_begin_unwind(UNWIND_TOKEN);"}, {"sha": "a9331157749338123d784b36e8673ed77a012e41", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -98,6 +98,8 @@ mod darwin_fd_limit {\n     static RLIMIT_NOFILE: libc::c_int = 8;\n \n     pub unsafe fn raise_fd_limit() {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         // The strategy here is to fetch the current resource limits, read the kern.maxfilesperproc\n         // sysctl value, and bump the soft resource limit for maxfiles up to the sysctl value.\n         use ptr::{to_unsafe_ptr, to_mut_unsafe_ptr, mut_null};\n@@ -305,6 +307,7 @@ pub fn cleanup_task(mut task: ~Task) {\n }\n \n /// Get a port number, starting at 9600, for use in tests\n+#[fixed_stack_segment] #[inline(never)]\n pub fn next_test_port() -> u16 {\n     unsafe {\n         return rust_dbg_next_port(base_port() as libc::uintptr_t) as u16;"}, {"sha": "61db08f4813ef5da516cd1d8ecc335cb43fc9a3d", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -23,6 +23,8 @@ pub struct Thread {\n impl Thread {\n     pub fn start(main: ~fn()) -> Thread {\n         fn substart(main: &~fn()) -> *raw_thread {\n+            #[fixed_stack_segment]; #[inline(never)];\n+\n             unsafe { rust_raw_thread_start(main) }\n         }\n         let raw = substart(&main);\n@@ -34,6 +36,8 @@ impl Thread {\n     }\n \n     pub fn join(self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         assert!(!self.joined);\n         let mut this = self;\n         unsafe { rust_raw_thread_join(this.raw_thread); }\n@@ -43,6 +47,8 @@ impl Thread {\n \n impl Drop for Thread {\n     fn drop(&self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         assert!(self.joined);\n         unsafe { rust_raw_thread_delete(self.raw_thread) }\n     }"}, {"sha": "a9cd29c18c9652d58a2fbe10704d236bf6650ccb", "filename": "src/libstd/rt/thread_local_storage.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread_local_storage.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -20,16 +20,22 @@ use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n pub type Key = pthread_key_t;\n \n #[cfg(unix)]\n+#[fixed_stack_segment]\n+#[inline(never)]\n pub unsafe fn create(key: &mut Key) {\n     assert_eq!(0, pthread_key_create(key, null()));\n }\n \n #[cfg(unix)]\n+#[fixed_stack_segment]\n+#[inline(never)]\n pub unsafe fn set(key: Key, value: *mut c_void) {\n     assert_eq!(0, pthread_setspecific(key, value));\n }\n \n #[cfg(unix)]\n+#[fixed_stack_segment]\n+#[inline(never)]\n pub unsafe fn get(key: Key) -> *mut c_void {\n     pthread_getspecific(key)\n }\n@@ -58,18 +64,24 @@ extern {\n pub type Key = DWORD;\n \n #[cfg(windows)]\n+#[fixed_stack_segment]\n+#[inline(never)]\n pub unsafe fn create(key: &mut Key) {\n     static TLS_OUT_OF_INDEXES: DWORD = 0xFFFFFFFF;\n     *key = TlsAlloc();\n     assert!(*key != TLS_OUT_OF_INDEXES);\n }\n \n #[cfg(windows)]\n+#[fixed_stack_segment]\n+#[inline(never)]\n pub unsafe fn set(key: Key, value: *mut c_void) {\n     assert!(0 != TlsSetValue(key, value))\n }\n \n #[cfg(windows)]\n+#[fixed_stack_segment]\n+#[inline(never)]\n pub unsafe fn get(key: Key) -> *mut c_void {\n     TlsGetValue(key)\n }"}, {"sha": "b8c7c8761e85d72cd2ffaae9a5320b5946e74fce", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -17,6 +17,8 @@ use str::StrSlice;\n \n /// Get the number of cores available\n pub fn num_cpus() -> uint {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         return rust_get_num_cpus();\n     }\n@@ -94,11 +96,16 @@ memory and partly incapable of presentation to others.\",\n     rterrln!(\"%s\", \"\");\n     rterrln!(\"fatal runtime error: %s\", msg);\n \n-    unsafe { libc::abort(); }\n+    abort();\n+\n+    fn abort() -> ! {\n+        #[fixed_stack_segment]; #[inline(never)];\n+        unsafe { libc::abort() }\n+    }\n }\n \n pub fn set_exit_status(code: int) {\n-\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         return rust_set_exit_status_newrt(code as libc::uintptr_t);\n     }\n@@ -109,7 +116,7 @@ pub fn set_exit_status(code: int) {\n }\n \n pub fn get_exit_status() -> int {\n-\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         return rust_get_exit_status_newrt() as int;\n     }"}, {"sha": "9312efbf03e9ac4f0d9e3e66e7fc07bea31eca8d", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -310,6 +310,8 @@ pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n \n /// Transmute an owned vector to a Buf\n pub fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         let data = malloc(v.len() as size_t) as *u8;\n         assert!(data.is_not_null());\n@@ -323,6 +325,8 @@ pub fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n \n /// Transmute a Buf that was once a ~[u8] back to ~[u8]\n pub fn vec_from_uv_buf(buf: Buf) -> Option<~[u8]> {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     if !(buf.len == 0 && buf.base.is_null()) {\n         let v = unsafe { vec::from_buf(buf.base, buf.len as uint) };\n         unsafe { free(buf.base as *c_void) };"}, {"sha": "d4794da9b0f2884f47d00a1a48f7c66826b66a71", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -45,6 +45,7 @@ enum SocketNameKind {\n \n fn socket_name<T, U: Watcher + NativeHandle<*T>>(sk: SocketNameKind,\n                                                  handle: U) -> Result<SocketAddr, IoError> {\n+    #[fixed_stack_segment]; #[inline(never)];\n \n     let getsockname = match sk {\n         TcpPeer => uvll::rust_uv_tcp_getpeername,\n@@ -406,6 +407,8 @@ impl RtioTcpListener for UvTcpListener {\n     }\n \n     fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         let r = unsafe {\n             uvll::rust_uv_tcp_simultaneous_accepts(self.watcher.native_handle(), 1 as c_int)\n         };\n@@ -417,6 +420,8 @@ impl RtioTcpListener for UvTcpListener {\n     }\n \n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         let r = unsafe {\n             uvll::rust_uv_tcp_simultaneous_accepts(self.watcher.native_handle(), 0 as c_int)\n         };\n@@ -524,6 +529,8 @@ impl RtioTcpStream for UvTcpStream {\n     }\n \n     fn control_congestion(&mut self) -> Result<(), IoError> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         let r = unsafe {\n             uvll::rust_uv_tcp_nodelay(self.native_handle(), 0 as c_int)\n         };\n@@ -535,6 +542,8 @@ impl RtioTcpStream for UvTcpStream {\n     }\n \n     fn nodelay(&mut self) -> Result<(), IoError> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         let r = unsafe {\n             uvll::rust_uv_tcp_nodelay(self.native_handle(), 1 as c_int)\n         };\n@@ -546,6 +555,8 @@ impl RtioTcpStream for UvTcpStream {\n     }\n \n     fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         let r = unsafe {\n             uvll::rust_uv_tcp_keepalive(self.native_handle(), 1 as c_int,\n                                         delay_in_seconds as c_uint)\n@@ -558,6 +569,8 @@ impl RtioTcpStream for UvTcpStream {\n     }\n \n     fn letdie(&mut self) -> Result<(), IoError> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         let r = unsafe {\n             uvll::rust_uv_tcp_keepalive(self.native_handle(), 0 as c_int, 0 as c_uint)\n         };"}, {"sha": "65c0cffe5a073a57d607f0a1d93791b4233c0dd6", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -124,6 +124,8 @@ pub enum uv_membership {\n }\n \n pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     assert!(handle != UV_UNKNOWN_HANDLE && handle != UV_HANDLE_TYPE_MAX);\n     let size = rust_uv_handle_size(handle as uint);\n     let p = malloc(size);\n@@ -132,10 +134,14 @@ pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n }\n \n pub unsafe fn free_handle(v: *c_void) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     free(v)\n }\n \n pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     assert!(req != UV_UNKNOWN_REQ && req != UV_REQ_TYPE_MAX);\n     let size = rust_uv_req_size(req as uint);\n     let p = malloc(size);\n@@ -144,309 +150,454 @@ pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n }\n \n pub unsafe fn free_req(v: *c_void) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     free(v)\n }\n \n #[test]\n fn handle_sanity_check() {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         assert_eq!(UV_HANDLE_TYPE_MAX as uint, rust_uv_handle_type_max());\n     }\n }\n \n #[test]\n+#[fixed_stack_segment]\n+#[inline(never)]\n fn request_sanity_check() {\n     unsafe {\n         assert_eq!(UV_REQ_TYPE_MAX as uint, rust_uv_req_type_max());\n     }\n }\n \n pub unsafe fn loop_new() -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_loop_new();\n }\n \n pub unsafe fn loop_delete(loop_handle: *c_void) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_loop_delete(loop_handle);\n }\n \n pub unsafe fn run(loop_handle: *c_void) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_run(loop_handle);\n }\n \n pub unsafe fn close<T>(handle: *T, cb: *u8) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_close(handle as *c_void, cb);\n }\n \n pub unsafe fn walk(loop_handle: *c_void, cb: *u8, arg: *c_void) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_walk(loop_handle, cb, arg);\n }\n \n pub unsafe fn idle_new() -> *uv_idle_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_idle_new()\n }\n \n pub unsafe fn idle_delete(handle: *uv_idle_t) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_idle_delete(handle)\n }\n \n pub unsafe fn idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_idle_init(loop_handle, handle)\n }\n \n pub unsafe fn idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_idle_start(handle, cb)\n }\n \n pub unsafe fn idle_stop(handle: *uv_idle_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_idle_stop(handle)\n }\n \n pub unsafe fn udp_init(loop_handle: *uv_loop_t, handle: *uv_udp_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_init(loop_handle, handle);\n }\n \n pub unsafe fn udp_bind(server: *uv_udp_t, addr: *sockaddr_in, flags: c_uint) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_bind(server, addr, flags);\n }\n \n pub unsafe fn udp_bind6(server: *uv_udp_t, addr: *sockaddr_in6, flags: c_uint) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_bind6(server, addr, flags);\n }\n \n pub unsafe fn udp_send<T>(req: *uv_udp_send_t, handle: *T, buf_in: &[uv_buf_t],\n                           addr: *sockaddr_in, cb: uv_udp_send_cb) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let buf_ptr = vec::raw::to_ptr(buf_in);\n     let buf_cnt = buf_in.len() as i32;\n     return rust_uv_udp_send(req, handle as *c_void, buf_ptr, buf_cnt, addr, cb);\n }\n \n pub unsafe fn udp_send6<T>(req: *uv_udp_send_t, handle: *T, buf_in: &[uv_buf_t],\n                           addr: *sockaddr_in6, cb: uv_udp_send_cb) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let buf_ptr = vec::raw::to_ptr(buf_in);\n     let buf_cnt = buf_in.len() as i32;\n     return rust_uv_udp_send6(req, handle as *c_void, buf_ptr, buf_cnt, addr, cb);\n }\n \n pub unsafe fn udp_recv_start(server: *uv_udp_t, on_alloc: uv_alloc_cb,\n                              on_recv: uv_udp_recv_cb) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_recv_start(server, on_alloc, on_recv);\n }\n \n pub unsafe fn udp_recv_stop(server: *uv_udp_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_recv_stop(server);\n }\n \n pub unsafe fn get_udp_handle_from_send_req(send_req: *uv_udp_send_t) -> *uv_udp_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_get_udp_handle_from_send_req(send_req);\n }\n \n pub unsafe fn udp_get_sockname(handle: *uv_udp_t, name: *sockaddr_storage) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_getsockname(handle, name);\n }\n \n pub unsafe fn udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n                                  interface_addr: *c_char, membership: uv_membership) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_set_membership(handle, multicast_addr, interface_addr, membership as c_int);\n }\n \n pub unsafe fn udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_set_multicast_loop(handle, on);\n }\n \n pub unsafe fn udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_set_multicast_ttl(handle, ttl);\n }\n \n pub unsafe fn udp_set_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_set_ttl(handle, ttl);\n }\n \n pub unsafe fn udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_set_broadcast(handle, on);\n }\n \n pub unsafe fn tcp_init(loop_handle: *c_void, handle: *uv_tcp_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_init(loop_handle, handle);\n }\n \n pub unsafe fn tcp_connect(connect_ptr: *uv_connect_t, tcp_handle_ptr: *uv_tcp_t,\n                           addr_ptr: *sockaddr_in, after_connect_cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr, after_connect_cb, addr_ptr);\n }\n \n pub unsafe fn tcp_connect6(connect_ptr: *uv_connect_t, tcp_handle_ptr: *uv_tcp_t,\n                            addr_ptr: *sockaddr_in6, after_connect_cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_connect6(connect_ptr, tcp_handle_ptr, after_connect_cb, addr_ptr);\n }\n \n pub unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_bind(tcp_server_ptr, addr_ptr);\n }\n \n pub unsafe fn tcp_bind6(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in6) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_bind6(tcp_server_ptr, addr_ptr);\n }\n \n pub unsafe fn tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_storage) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_getpeername(tcp_handle_ptr, name);\n }\n \n pub unsafe fn tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_storage) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_getsockname(handle, name);\n }\n \n pub unsafe fn tcp_nodelay(handle: *uv_tcp_t, enable: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_nodelay(handle, enable);\n }\n \n pub unsafe fn tcp_keepalive(handle: *uv_tcp_t, enable: c_int, delay: c_uint) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_keepalive(handle, enable, delay);\n }\n \n pub unsafe fn tcp_simultaneous_accepts(handle: *uv_tcp_t, enable: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_simultaneous_accepts(handle, enable);\n }\n \n pub unsafe fn listen<T>(stream: *T, backlog: c_int, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_listen(stream as *c_void, backlog, cb);\n }\n \n pub unsafe fn accept(server: *c_void, client: *c_void) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_accept(server as *c_void, client as *c_void);\n }\n \n pub unsafe fn write<T>(req: *uv_write_t, stream: *T, buf_in: &[uv_buf_t], cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let buf_ptr = vec::raw::to_ptr(buf_in);\n     let buf_cnt = buf_in.len() as i32;\n     return rust_uv_write(req as *c_void, stream as *c_void, buf_ptr, buf_cnt, cb);\n }\n pub unsafe fn read_start(stream: *uv_stream_t, on_alloc: uv_alloc_cb, on_read: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_read_start(stream as *c_void, on_alloc, on_read);\n }\n \n pub unsafe fn read_stop(stream: *uv_stream_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_read_stop(stream as *c_void);\n }\n \n pub unsafe fn last_error(loop_handle: *c_void) -> uv_err_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_last_error(loop_handle);\n }\n \n pub unsafe fn strerror(err: *uv_err_t) -> *c_char {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_strerror(err);\n }\n pub unsafe fn err_name(err: *uv_err_t) -> *c_char {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_err_name(err);\n }\n \n pub unsafe fn async_init(loop_handle: *c_void, async_handle: *uv_async_t, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_async_init(loop_handle, async_handle, cb);\n }\n \n pub unsafe fn async_send(async_handle: *uv_async_t) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_async_send(async_handle);\n }\n pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let out_buf = uv_buf_t { base: ptr::null(), len: 0 as size_t };\n     let out_buf_ptr = ptr::to_unsafe_ptr(&out_buf);\n     rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n     return out_buf;\n }\n \n pub unsafe fn timer_init(loop_ptr: *c_void, timer_ptr: *uv_timer_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_timer_init(loop_ptr, timer_ptr);\n }\n pub unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: u64,\n                           repeat: u64) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_timer_start(timer_ptr, cb, timeout, repeat);\n }\n pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_timer_stop(timer_ptr);\n }\n \n pub unsafe fn is_ip4_addr(addr: *sockaddr) -> bool {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     match rust_uv_is_ipv4_sockaddr(addr) { 0 => false, _ => true }\n }\n \n pub unsafe fn is_ip6_addr(addr: *sockaddr) -> bool {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     match rust_uv_is_ipv6_sockaddr(addr) { 0 => false, _ => true }\n }\n \n pub unsafe fn malloc_ip4_addr(ip: &str, port: int) -> *sockaddr_in {\n+    #[fixed_stack_segment]; #[inline(never)];\n     do ip.with_c_str |ip_buf| {\n         rust_uv_ip4_addrp(ip_buf as *u8, port as libc::c_int)\n     }\n }\n pub unsafe fn malloc_ip6_addr(ip: &str, port: int) -> *sockaddr_in6 {\n+    #[fixed_stack_segment]; #[inline(never)];\n     do ip.with_c_str |ip_buf| {\n         rust_uv_ip6_addrp(ip_buf as *u8, port as libc::c_int)\n     }\n }\n \n pub unsafe fn malloc_sockaddr_storage() -> *sockaddr_storage {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_malloc_sockaddr_storage()\n }\n \n pub unsafe fn free_sockaddr_storage(ss: *sockaddr_storage) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_free_sockaddr_storage(ss);\n }\n \n pub unsafe fn free_ip4_addr(addr: *sockaddr_in) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_free_ip4_addr(addr);\n }\n \n pub unsafe fn free_ip6_addr(addr: *sockaddr_in6) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_free_ip6_addr(addr);\n }\n \n pub unsafe fn ip4_name(addr: *sockaddr_in, dst: *u8, size: size_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_ip4_name(addr, dst, size);\n }\n \n pub unsafe fn ip6_name(addr: *sockaddr_in6, dst: *u8, size: size_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_ip6_name(addr, dst, size);\n }\n \n pub unsafe fn ip4_port(addr: *sockaddr_in) -> c_uint {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n    return rust_uv_ip4_port(addr);\n }\n \n pub unsafe fn ip6_port(addr: *sockaddr_in6) -> c_uint {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_ip6_port(addr);\n }\n \n // data access helpers\n pub unsafe fn get_loop_for_uv_handle<T>(handle: *T) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_get_loop_for_uv_handle(handle as *c_void);\n }\n pub unsafe fn get_stream_handle_from_connect_req(connect: *uv_connect_t) -> *uv_stream_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_get_stream_handle_from_connect_req(connect);\n }\n pub unsafe fn get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_get_stream_handle_from_write_req(write_req);\n }\n pub unsafe fn get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_get_data_for_uv_loop(loop_ptr)\n }\n pub unsafe fn set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_set_data_for_uv_loop(loop_ptr, data);\n }\n pub unsafe fn get_data_for_uv_handle<T>(handle: *T) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_get_data_for_uv_handle(handle as *c_void);\n }\n pub unsafe fn set_data_for_uv_handle<T, U>(handle: *T, data: *U) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_set_data_for_uv_handle(handle as *c_void, data as *c_void);\n }\n pub unsafe fn get_data_for_req<T>(req: *T) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_get_data_for_req(req as *c_void);\n }\n pub unsafe fn set_data_for_req<T, U>(req: *T, data: *U) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_set_data_for_req(req as *c_void, data as *c_void);\n }\n pub unsafe fn get_base_from_buf(buf: uv_buf_t) -> *u8 {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_get_base_from_buf(buf);\n }\n pub unsafe fn get_len_from_buf(buf: uv_buf_t) -> size_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_get_len_from_buf(buf);\n }\n pub unsafe fn get_last_err_info(uv_loop: *c_void) -> ~str {"}, {"sha": "a43d448dae51f30a0bda7b6c7312c4df4ddd8d9a", "filename": "src/libstd/run.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -147,8 +147,11 @@ impl Process {\n      * * options - Options to configure the environment of the process,\n      *             the working directory and the standard IO streams.\n      */\n-    pub fn new(prog: &str, args: &[~str], options: ProcessOptions)\n+    pub fn new(prog: &str, args: &[~str],\n+               options: ProcessOptions)\n                -> Process {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         let (in_pipe, in_fd) = match options.in_fd {\n             None => {\n                 let pipe = os::pipe();\n@@ -287,6 +290,7 @@ impl Process {\n      * method does nothing.\n      */\n     pub fn close_input(&mut self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n         match self.input {\n             Some(-1) | None => (),\n             Some(fd) => {\n@@ -299,10 +303,12 @@ impl Process {\n     }\n \n     fn close_outputs(&mut self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n         fclose_and_null(&mut self.output);\n         fclose_and_null(&mut self.error);\n \n         fn fclose_and_null(f_opt: &mut Option<*libc::FILE>) {\n+            #[allow(cstack)]; // fixed_stack_segment declared on enclosing fn\n             match *f_opt {\n                 Some(f) if !f.is_null() => {\n                     unsafe {\n@@ -387,6 +393,7 @@ impl Process {\n \n         #[cfg(windows)]\n         fn killpid(pid: pid_t, _force: bool) {\n+            #[fixed_stack_segment]; #[inline(never)];\n             unsafe {\n                 libc::funcs::extra::kernel32::TerminateProcess(\n                     cast::transmute(pid), 1);\n@@ -395,6 +402,8 @@ impl Process {\n \n         #[cfg(unix)]\n         fn killpid(pid: pid_t, force: bool) {\n+            #[fixed_stack_segment]; #[inline(never)];\n+\n             let signal = if force {\n                 libc::consts::os::posix88::SIGKILL\n             } else {\n@@ -447,6 +456,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n                     env: Option<~[(~str, ~str)]>,\n                     dir: Option<&Path>,\n                     in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n+    #[fixed_stack_segment]; #[inline(never)];\n \n     use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n     use libc::consts::os::extra::{\n@@ -630,6 +640,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n                     env: Option<~[(~str, ~str)]>,\n                     dir: Option<&Path>,\n                     in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n+    #[fixed_stack_segment]; #[inline(never)];\n \n     use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n     use libc::funcs::bsd44::getdtablesize;\n@@ -782,6 +793,7 @@ fn with_dirp<T>(d: Option<&Path>, cb: &fn(*libc::c_char) -> T) -> T {\n \n #[cfg(windows)]\n fn free_handle(handle: *()) {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         libc::funcs::extra::kernel32::CloseHandle(cast::transmute(handle));\n     }\n@@ -848,6 +860,7 @@ fn waitpid(pid: pid_t) -> int {\n \n     #[cfg(windows)]\n     fn waitpid_os(pid: pid_t) -> int {\n+        #[fixed_stack_segment]; #[inline(never)];\n \n         use libc::types::os::arch::extra::DWORD;\n         use libc::consts::os::extra::{\n@@ -892,6 +905,7 @@ fn waitpid(pid: pid_t) -> int {\n \n     #[cfg(unix)]\n     fn waitpid_os(pid: pid_t) -> int {\n+        #[fixed_stack_segment]; #[inline(never)];\n \n         use libc::funcs::posix01::wait::*;\n \n@@ -1069,6 +1083,8 @@ mod tests {\n     }\n \n     fn readclose(fd: c_int) -> ~str {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             let file = os::fdopen(fd);\n             let reader = io::FILE_reader(file, false);\n@@ -1351,6 +1367,7 @@ mod tests {\n     }\n \n     fn running_on_valgrind() -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe { rust_running_on_valgrind() != 0 }\n     }\n "}, {"sha": "7f22f44a6f87286ec101244bcf5953aff531cac2", "filename": "src/libstd/std.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -220,3 +220,4 @@ mod std {\n     pub use fmt;\n     pub use to_bytes;\n }\n+"}, {"sha": "2a8a79fcb32923f8e058ea8db25f2c43482da409", "filename": "src/libstd/str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -2908,6 +2908,7 @@ mod tests {\n \n     #[test]\n     fn test_map() {\n+        #[fixed_stack_segment]; #[inline(never)];\n         assert_eq!(~\"\", \"\".map_chars(|c| unsafe {libc::toupper(c as c_char)} as char));\n         assert_eq!(~\"YMCA\", \"ymca\".map_chars(|c| unsafe {libc::toupper(c as c_char)} as char));\n     }"}, {"sha": "8132bfe53778ba246c273019f2f674a94b6f51df", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -147,7 +147,7 @@ pub unsafe fn local_pop<T: 'static>(handle: Handle,\n                 // above.\n                 let data = match util::replace(entry, None) {\n                     Some((_, data, _)) => data,\n-                    None => libc::abort(),\n+                    None => abort(),\n                 };\n \n                 // Move `data` into transmute to get out the memory that it\n@@ -252,7 +252,7 @@ unsafe fn local_get_with<T: 'static, U>(handle: Handle,\n                         }\n                     }\n                 }\n-                _ => libc::abort()\n+                _ => abort()\n             }\n \n             // n.b. 'data' and 'loans' are both invalid pointers at the point\n@@ -262,14 +262,20 @@ unsafe fn local_get_with<T: 'static, U>(handle: Handle,\n             if return_loan {\n                 match map[i] {\n                     Some((_, _, ref mut loan)) => { *loan = NoLoan; }\n-                    None => { libc::abort(); }\n+                    None => { abort(); }\n                 }\n             }\n             return ret;\n         }\n     }\n }\n \n+fn abort() -> ! {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    unsafe { libc::abort() }\n+}\n+\n pub unsafe fn local_set<T: 'static>(handle: Handle,\n                                     key: local_data::Key<T>,\n                                     data: T) {"}, {"sha": "0d2e62a77003e003e016033b5cb4bd2bae37d33c", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -1045,15 +1045,12 @@ fn test_spawn_sched_childs_on_default_sched() {\n mod testrt {\n     use libc;\n \n-    #[nolink]\n-    extern {\n-        pub fn rust_dbg_lock_create() -> *libc::c_void;\n-        pub fn rust_dbg_lock_destroy(lock: *libc::c_void);\n-        pub fn rust_dbg_lock_lock(lock: *libc::c_void);\n-        pub fn rust_dbg_lock_unlock(lock: *libc::c_void);\n-        pub fn rust_dbg_lock_wait(lock: *libc::c_void);\n-        pub fn rust_dbg_lock_signal(lock: *libc::c_void);\n-    }\n+    externfn!(fn rust_dbg_lock_create() -> *libc::c_void)\n+    externfn!(fn rust_dbg_lock_destroy(lock: *libc::c_void))\n+    externfn!(fn rust_dbg_lock_lock(lock: *libc::c_void))\n+    externfn!(fn rust_dbg_lock_unlock(lock: *libc::c_void))\n+    externfn!(fn rust_dbg_lock_wait(lock: *libc::c_void))\n+    externfn!(fn rust_dbg_lock_signal(lock: *libc::c_void))\n }\n \n #[test]"}, {"sha": "6dbe68200b3b7fe23d28c62b72dc39083e7ec993", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -145,16 +145,21 @@ mod dl {\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n+        #[fixed_stack_segment]; #[inline(never)];\n         do filename.with_c_str |raw_name| {\n             dlopen(raw_name, Lazy as libc::c_int)\n         }\n     }\n \n     pub unsafe fn open_internal() -> *libc::c_void {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         dlopen(ptr::null(), Lazy as libc::c_int)\n     }\n \n     pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             do atomically {\n                 let _old_error = dlerror();\n@@ -172,9 +177,13 @@ mod dl {\n     }\n \n     pub unsafe fn symbol(handle: *libc::c_void, symbol: *libc::c_char) -> *libc::c_void {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         dlsym(handle, symbol)\n     }\n     pub unsafe fn close(handle: *libc::c_void) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         dlclose(handle); ()\n     }\n \n@@ -204,18 +213,21 @@ mod dl {\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n+        #[fixed_stack_segment]; #[inline(never)];\n         do os::win32::as_utf16_p(filename.to_str()) |raw_name| {\n             LoadLibraryW(raw_name)\n         }\n     }\n \n     pub unsafe fn open_internal() -> *libc::c_void {\n+        #[fixed_stack_segment]; #[inline(never)];\n         let handle = ptr::null();\n         GetModuleHandleExW(0 as libc::DWORD, ptr::null(), &handle as **libc::c_void);\n         handle\n     }\n \n     pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             do atomically {\n                 SetLastError(0);\n@@ -232,9 +244,11 @@ mod dl {\n         }\n     }\n     pub unsafe fn symbol(handle: *libc::c_void, symbol: *libc::c_char) -> *libc::c_void {\n+        #[fixed_stack_segment]; #[inline(never)];\n         GetProcAddress(handle, symbol)\n     }\n     pub unsafe fn close(handle: *libc::c_void) {\n+        #[fixed_stack_segment]; #[inline(never)];\n         FreeLibrary(handle); ()\n     }\n "}, {"sha": "6ad15bfc7c03939884be3590eaad06ffa789d946", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -83,6 +83,8 @@ fn test_run_in_bare_thread_exchange() {\n /// can lead to deadlock. Calling change_dir_locked recursively will\n /// also deadlock.\n pub fn change_dir_locked(p: &Path, action: &fn()) -> bool {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     use os;\n     use os::change_dir;\n     use unstable::sync::atomically;"}, {"sha": "29be094121c3b6350bc64c61e7b4e585747730f1", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -322,7 +322,6 @@ impl LittleLock {\n         }\n     }\n \n-    #[inline]\n     pub unsafe fn lock<T>(&self, f: &fn() -> T) -> T {\n         do atomically {\n             rust_lock_little_lock(self.l);\n@@ -410,13 +409,28 @@ impl<T:Send> Exclusive<T> {\n     }\n }\n \n-extern {\n-    fn rust_create_little_lock() -> rust_little_lock;\n-    fn rust_destroy_little_lock(lock: rust_little_lock);\n-    fn rust_lock_little_lock(lock: rust_little_lock);\n-    fn rust_unlock_little_lock(lock: rust_little_lock);\n+#[cfg(stage0)]\n+mod macro_hack {\n+#[macro_escape];\n+macro_rules! externfn(\n+    (fn $name:ident () $(-> $ret_ty:ty),*) => (\n+        extern {\n+            fn $name() $(-> $ret_ty),*;\n+        }\n+    );\n+    (fn $name:ident ($($arg_name:ident : $arg_ty:ty),*) $(-> $ret_ty:ty),*) => (\n+        extern {\n+            fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),*;\n+        }\n+    )\n+)\n }\n \n+externfn!(fn rust_create_little_lock() -> rust_little_lock)\n+externfn!(fn rust_destroy_little_lock(lock: rust_little_lock))\n+externfn!(fn rust_lock_little_lock(lock: rust_little_lock))\n+externfn!(fn rust_unlock_little_lock(lock: rust_little_lock))\n+\n #[cfg(test)]\n mod tests {\n     use cell::Cell;"}, {"sha": "4bea1dc23e737a0d4ae660130ec9358030ddcb9b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -968,6 +968,85 @@ pub fn std_macros() -> @str {\n             pub static $name: ::std::local_data::Key<$ty> = &::std::local_data::Key;\n         )\n     )\n+\n+    // externfn! declares a wrapper for an external function.\n+    // It is intended to be used like:\n+    //\n+    // externfn!(#[nolink]\n+    //           #[abi = \\\"cdecl\\\"]\n+    //           fn memcmp(cx: *u8, ct: *u8, n: u32) -> u32)\n+    //\n+    // Due to limitations in the macro parser, this pattern must be\n+    // implemented with 4 distinct patterns (with attrs / without\n+    // attrs CROSS with args / without ARGS).\n+    //\n+    // Also, this macro grammar allows for any number of return types\n+    // because I couldn't figure out the syntax to specify at most one.\n+    macro_rules! externfn(\n+        (fn $name:ident () $(-> $ret_ty:ty),*) => (\n+            pub unsafe fn $name() $(-> $ret_ty),* {\n+                // Note: to avoid obscure bug in macros, keep these\n+                // attributes *internal* to the fn\n+                #[fixed_stack_segment];\n+                #[inline(never)];\n+                #[allow(missing_doc)];\n+\n+                return $name();\n+\n+                extern {\n+                    fn $name() $(-> $ret_ty),*;\n+                }\n+            }\n+        );\n+        (fn $name:ident ($($arg_name:ident : $arg_ty:ty),*) $(-> $ret_ty:ty),*) => (\n+            pub unsafe fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),* {\n+                // Note: to avoid obscure bug in macros, keep these\n+                // attributes *internal* to the fn\n+                #[fixed_stack_segment];\n+                #[inline(never)];\n+                #[allow(missing_doc)];\n+\n+                return $name($($arg_name),*);\n+\n+                extern {\n+                    fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),*;\n+                }\n+            }\n+        );\n+        ($($attrs:attr)* fn $name:ident () $(-> $ret_ty:ty),*) => (\n+            pub unsafe fn $name() $(-> $ret_ty),* {\n+                // Note: to avoid obscure bug in macros, keep these\n+                // attributes *internal* to the fn\n+                #[fixed_stack_segment];\n+                #[inline(never)];\n+                #[allow(missing_doc)];\n+\n+                return $name();\n+\n+                $($attrs)*\n+                extern {\n+                    fn $name() $(-> $ret_ty),*;\n+                }\n+            }\n+        );\n+        ($($attrs:attr)* fn $name:ident ($($arg_name:ident : $arg_ty:ty),*) $(-> $ret_ty:ty),*) => (\n+            pub unsafe fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),* {\n+                // Note: to avoid obscure bug in macros, keep these\n+                // attributes *internal* to the fn\n+                #[fixed_stack_segment];\n+                #[inline(never)];\n+                #[allow(missing_doc)];\n+\n+                return $name($($arg_name),*);\n+\n+                $($attrs)*\n+                extern {\n+                    fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),*;\n+                }\n+            }\n+        )\n+    )\n+\n }\";\n }\n "}, {"sha": "03cb96a3729af21dc9295d761534fde3f81f583c", "filename": "src/test/auxiliary/extern-crosscrate-source.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -24,6 +24,7 @@ pub mod rustrt {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn fact(n: uint) -> uint {\n     unsafe {\n         info!(\"n = %?\", n);"}, {"sha": "6f0c2f1de1ab45b1bb7f4cf7992a2e1e329d2cb3", "filename": "src/test/compile-fail/lint-unused-unsafe.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -10,6 +10,7 @@\n \n // Exercise the unused_unsafe attribute in some positive and negative cases\n \n+#[allow(cstack)];\n #[deny(unused_unsafe)];\n \n mod foo {\n@@ -55,6 +56,7 @@ fn good2() {\n         }\n     }\n }\n+\n unsafe fn good3() { foo::bar() }\n fn good4() { unsafe { foo::bar() } }\n "}, {"sha": "be6871ae6ffa7657e2a96dd5d32d4302608b0480", "filename": "src/test/compile-fail/warn-foreign-int-types.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Fcompile-fail%2Fwarn-foreign-int-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Fcompile-fail%2Fwarn-foreign-int-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwarn-foreign-int-types.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//error-pattern:libc::c_int or libc::c_long should be used\n+#[forbid(ctypes)];\n+\n mod xx {\n     extern {\n-        pub fn strlen(str: *u8) -> uint;\n-        pub fn foo(x: int, y: uint);\n+        pub fn strlen(str: *u8) -> uint; //~ ERROR found rust type `uint`\n+        pub fn foo(x: int, y: uint); //~ ERROR found rust type `int`\n+        //~^ ERROR found rust type `uint`\n     }\n }\n \n fn main() {\n-  // let it fail to verify warning message\n-  fail!()\n }"}, {"sha": "1a2c22889fd82d680fc6a993f9077c7ee0f16f7c", "filename": "src/test/run-pass/anon-extern-mod-cross-crate-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -14,6 +14,7 @@ extern mod anonexternmod;\n \n use anonexternmod::*;\n \n+#[fixed_stack_segment]\n pub fn main() {\n     unsafe {\n         rust_get_test_int();"}, {"sha": "ed9caa1f65e2f52223ea868d95d5d7ac54a7ba3c", "filename": "src/test/run-pass/anon-extern-mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fanon-extern-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fanon-extern-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-extern-mod.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -16,6 +16,7 @@ extern {\n     fn rust_get_test_int() -> libc::intptr_t;\n }\n \n+#[fixed_stack_segment]\n pub fn main() {\n     unsafe {\n         let _ = rust_get_test_int();"}, {"sha": "f140c4621aa27319cec5be3f064514d951d4b2b1", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -19,10 +19,12 @@ mod libc {\n     }\n }\n \n+#[fixed_stack_segment]\n fn atol(s: ~str) -> int {\n     s.with_c_str(|x| unsafe { libc::atol(x) as int })\n }\n \n+#[fixed_stack_segment]\n fn atoll(s: ~str) -> i64 {\n     s.with_c_str(|x| unsafe { libc::atoll(x) as i64 })\n }"}, {"sha": "27ad2fc46e07dab407a2c9e2b3b055917b7f696b", "filename": "src/test/run-pass/extern-call-deep.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -27,6 +27,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     }\n }\n \n+#[fixed_stack_segment]\n fn count(n: uint) -> uint {\n     unsafe {\n         info!(\"n = %?\", n);"}, {"sha": "6c90443636d3913cabe7008e469bdbf99697426f", "filename": "src/test/run-pass/extern-call-deep2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -28,6 +28,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn count(n: uint) -> uint {\n     unsafe {\n         info!(\"n = %?\", n);"}, {"sha": "5abd3c7b9d918ce55865b555aaa1c6ebe4cfa5de", "filename": "src/test/run-pass/extern-call-scrub.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -32,6 +32,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn count(n: uint) -> uint {\n     unsafe {\n         info!(\"n = %?\", n);"}, {"sha": "939487df174db1f1cf9059b746ab13179994b4d2", "filename": "src/test/run-pass/extern-call.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -27,6 +27,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn fact(n: uint) -> uint {\n     unsafe {\n         info!(\"n = %?\", n);"}, {"sha": "7db7b898c0e6d7e29e1f059eeddc84c882e239c7", "filename": "src/test/run-pass/extern-crosscrate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -13,6 +13,7 @@\n \n extern mod externcallback(vers = \"0.1\");\n \n+#[fixed_stack_segment] #[inline(never)]\n fn fact(n: uint) -> uint {\n     unsafe {\n         info!(\"n = %?\", n);"}, {"sha": "147db0c0b2b0d9eb1c33ccf6b16b67c2ce3d6245", "filename": "src/test/run-pass/extern-pass-TwoU32s.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -20,6 +20,7 @@ extern {\n     pub fn rust_dbg_extern_identity_TwoU32s(v: TwoU32s) -> TwoU32s;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let x = TwoU32s {one: 22, two: 23};"}, {"sha": "1937c366831ffc795de87530dcb49eefd1790b34", "filename": "src/test/run-pass/extern-pass-TwoU64s-ref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s-ref.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -19,6 +19,7 @@ extern {\n     pub fn rust_dbg_extern_identity_TwoU64s(u: TwoU64s) -> TwoU64s;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let x = TwoU64s {one: 22, two: 23};"}, {"sha": "b543099b3b8f8f4990ecc508ef8d1ff20f9680d2", "filename": "src/test/run-pass/extern-pass-TwoU64s.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -24,6 +24,7 @@ extern {\n     pub fn rust_dbg_extern_identity_TwoU64s(v: TwoU64s) -> TwoU64s;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let x = TwoU64s {one: 22, two: 23};"}, {"sha": "f255746b75a8f683ca6ae60449866660904a0fcd", "filename": "src/test/run-pass/extern-pass-char.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-pass-char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-pass-char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-char.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -14,6 +14,7 @@ extern {\n     pub fn rust_dbg_extern_identity_u8(v: u8) -> u8;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         assert_eq!(22_u8, rust_dbg_extern_identity_u8(22_u8));"}, {"sha": "c80a0cd502fd351905a863140af3f5b765a2b702", "filename": "src/test/run-pass/extern-pass-double.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-pass-double.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-pass-double.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-double.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -12,6 +12,7 @@ extern {\n     pub fn rust_dbg_extern_identity_double(v: f64) -> f64;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         assert_eq!(22.0_f64, rust_dbg_extern_identity_double(22.0_f64));"}, {"sha": "c6fdabeab3dea0bbf4ee0f39903531bd6426966f", "filename": "src/test/run-pass/extern-pass-u32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-pass-u32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-pass-u32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-u32.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -14,6 +14,7 @@ extern {\n     pub fn rust_dbg_extern_identity_u32(v: u32) -> u32;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         assert_eq!(22_u32, rust_dbg_extern_identity_u32(22_u32));"}, {"sha": "09babc1109f8c3166bbd9058201c5b909fb8ec10", "filename": "src/test/run-pass/extern-pass-u64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-pass-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-pass-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-u64.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -14,6 +14,7 @@ extern {\n     pub fn rust_dbg_extern_identity_u64(v: u64) -> u64;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         assert_eq!(22_u64, rust_dbg_extern_identity_u64(22_u64));"}, {"sha": "2b9f99ca0105cb06a620c519252e4d0139275b33", "filename": "src/test/run-pass/extern-return-TwoU16s.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-return-TwoU16s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-return-TwoU16s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-return-TwoU16s.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-win32 #5745\n-// xfail-macos Broken on mac i686\n-\n struct TwoU16s {\n     one: u16, two: u16\n }\n@@ -19,6 +16,7 @@ extern {\n     pub fn rust_dbg_extern_return_TwoU16s() -> TwoU16s;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let y = rust_dbg_extern_return_TwoU16s();"}, {"sha": "f93a15bd80806c601aab3e1612346e939aff138c", "filename": "src/test/run-pass/extern-return-TwoU32s.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-return-TwoU32s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-return-TwoU32s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-return-TwoU32s.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -16,6 +16,7 @@ extern {\n     pub fn rust_dbg_extern_return_TwoU32s() -> TwoU32s;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let y = rust_dbg_extern_return_TwoU32s();"}, {"sha": "4dc31d715260b2707ffbd34521f941c198e31433", "filename": "src/test/run-pass/extern-return-TwoU64s.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-return-TwoU64s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-return-TwoU64s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-return-TwoU64s.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -16,6 +16,7 @@ extern {\n     pub fn rust_dbg_extern_return_TwoU64s() -> TwoU64s;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let y = rust_dbg_extern_return_TwoU64s();"}, {"sha": "aae8b8a8587d0d7d91addae7f5b4fd24135d47f1", "filename": "src/test/run-pass/extern-return-TwoU8s.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-return-TwoU8s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-return-TwoU8s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-return-TwoU8s.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-win32 #5745\n-// xfail-macos Broken on mac i686\n-\n struct TwoU8s {\n     one: u8, two: u8\n }\n@@ -19,6 +16,7 @@ extern {\n     pub fn rust_dbg_extern_return_TwoU8s() -> TwoU8s;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let y = rust_dbg_extern_return_TwoU8s();"}, {"sha": "4eda3f34b6c15198a9f78d15d7b7efc22542a9b7", "filename": "src/test/run-pass/extern-stress.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-stress.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -32,6 +32,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn count(n: uint) -> uint {\n     unsafe {\n         rustrt::rust_dbg_call(cb, n)"}, {"sha": "ce51aafa9d80960160f663f1544535643ca5cb7f", "filename": "src/test/run-pass/extern-yield.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-yield.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -28,6 +28,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn count(n: uint) -> uint {\n     unsafe {\n         task::deschedule();"}, {"sha": "c8acdbf44781c64bebe81228a742f753337d36ee", "filename": "src/test/run-pass/foreign-call-no-runtime.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -2,9 +2,7 @@ use std::cast;\n use std::libc;\n use std::unstable::run_in_bare_thread;\n \n-extern {\n-    pub fn rust_dbg_call(cb: *u8, data: libc::uintptr_t) -> libc::uintptr_t;\n-}\n+externfn!(fn rust_dbg_call(cb: *u8, data: libc::uintptr_t) -> libc::uintptr_t)\n \n pub fn main() {\n     unsafe {"}, {"sha": "3ff1ebb57322cfa10e67d32a56ce2cecbcda5e9a", "filename": "src/test/run-pass/foreign-dupe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -31,6 +31,7 @@ mod rustrt2 {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         rustrt1::rust_get_test_int();"}, {"sha": "57b59e4445e7718800ffe80de19a24fdda7b90a0", "filename": "src/test/run-pass/foreign-fn-linkname.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -21,6 +21,7 @@ mod libc {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn strlen(str: ~str) -> uint {\n     // C string is terminated with a zero\n     do str.with_c_str |buf| {"}, {"sha": "f9c2698eda499f882b5d6781718578db047c3f78", "filename": "src/test/run-pass/foreign-no-abi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fforeign-no-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fforeign-no-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-no-abi.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -18,6 +18,7 @@ mod rustrt {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         rustrt::rust_get_test_int();"}, {"sha": "1736428affb36cc0844152bba85fa5ff4d47b008", "filename": "src/test/run-pass/invoke-external-foreign.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -17,6 +17,7 @@\n \n extern mod foreign_lib;\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let _foo = foreign_lib::rustrt::rust_get_test_int();"}, {"sha": "1bb8a0008760b2ede0f90d6cdd9381ee03ce5259", "filename": "src/test/run-pass/issue-2214.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2214.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -19,6 +19,7 @@ fn to_c_int(v: &mut int) -> &mut c_int {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn lgamma(n: c_double, value: &mut int) -> c_double {\n     unsafe {\n         return m::lgamma(n, to_c_int(value));"}, {"sha": "b58c8738295da925923dba8c2c9c40ce5cacae97", "filename": "src/test/run-pass/newtype-struct-with-dtor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fnewtype-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fnewtype-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-struct-with-dtor.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -4,6 +4,7 @@ use std::libc;\n pub struct Fd(c_int);\n \n impl Drop for Fd {\n+    #[fixed_stack_segment] #[inline(never)]\n     fn drop(&self) {\n         unsafe {\n             libc::close(**self);"}, {"sha": "360ac75b3e75357381cc2aebc7fa15828f58b2af", "filename": "src/test/run-pass/pub-extern-privacy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -6,6 +6,7 @@ mod a {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn main() {\n     unsafe {\n         a::free(transmute(0));"}, {"sha": "201584d48a58571231daf8ee855752e2a033359e", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -27,6 +27,7 @@ struct Ccx {\n     x: int\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn alloc<'a>(_bcx : &'a arena) -> &'a Bcx<'a> {\n     unsafe {\n         cast::transmute(libc::malloc(sys::size_of::<Bcx<'blk>>()\n@@ -38,6 +39,7 @@ fn h<'a>(bcx : &'a Bcx<'a>) -> &'a Bcx<'a> {\n     return alloc(bcx.fcx.arena);\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn g(fcx : &Fcx) {\n     let bcx = Bcx { fcx: fcx };\n     let bcx2 = h(&bcx);"}, {"sha": "1e5ea7126e4403396c409eac4f34335c2457d53b", "filename": "src/test/run-pass/smallest-hello-world.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test - FIXME(#8538) some kind of problem linking induced by extern \"C\" fns that I do not understand\n // xfail-fast - windows doesn't like this\n \n // Smallest hello world with no runtime"}, {"sha": "429b49375e0daa0576e3f8c1405dff560eed200b", "filename": "src/test/run-pass/static-mut-foreign.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fstatic-mut-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fstatic-mut-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-mut-foreign.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -26,6 +26,7 @@ fn static_bound_set(a: &'static mut libc::c_int) {\n     *a = 3;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n unsafe fn run() {\n     assert!(debug_static_mut == 3);\n     debug_static_mut = 4;"}, {"sha": "1c39504ba717bc5cf5f7c9773983f049c753bcec", "filename": "src/test/run-pass/struct-return.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-return.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -21,6 +21,7 @@ mod rustrt {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn test1() {\n     unsafe {\n         let q = Quad { a: 0xaaaa_aaaa_aaaa_aaaa_u64,\n@@ -40,6 +41,8 @@ fn test1() {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n+#[fixed_stack_segment]\n+#[inline(never)]\n fn test2() {\n     unsafe {\n         let f = Floats { a: 1.234567890e-15_f64,"}, {"sha": "3722dccf94b94001c38914056d6220fe9f082c47", "filename": "src/test/run-pass/x86stdcall2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fx86stdcall2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a78161b5354c9cfecd8c659cc1dc3711d347d6/src%2Ftest%2Frun-pass%2Fx86stdcall2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fx86stdcall2.rs?ref=81a78161b5354c9cfecd8c659cc1dc3711d347d6", "patch": "@@ -29,6 +29,7 @@ mod kernel32 {\n \n \n #[cfg(target_os = \"win32\")]\n+#[fixed_stack_segment]\n pub fn main() {\n     let heap = unsafe { kernel32::GetProcessHeap() };\n     let mem = unsafe { kernel32::HeapAlloc(heap, 0u32, 100u32) };"}]}