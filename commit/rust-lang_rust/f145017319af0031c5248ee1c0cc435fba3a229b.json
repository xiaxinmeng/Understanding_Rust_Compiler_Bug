{"sha": "f145017319af0031c5248ee1c0cc435fba3a229b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNDUwMTczMTlhZjAwMzFjNTI0OGVlMWMwY2M0MzVmYmEzYTIyOWI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-13T20:36:25Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-13T20:36:25Z"}, "message": "Add support for pointers.", "tree": {"sha": "e9c6f933444de80d072074d1476f2db3451e4a7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9c6f933444de80d072074d1476f2db3451e4a7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f145017319af0031c5248ee1c0cc435fba3a229b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f145017319af0031c5248ee1c0cc435fba3a229b", "html_url": "https://github.com/rust-lang/rust/commit/f145017319af0031c5248ee1c0cc435fba3a229b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f145017319af0031c5248ee1c0cc435fba3a229b/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "039014fee262bd3e9587bce90a650d6b5990d349", "url": "https://api.github.com/repos/rust-lang/rust/commits/039014fee262bd3e9587bce90a650d6b5990d349", "html_url": "https://github.com/rust-lang/rust/commit/039014fee262bd3e9587bce90a650d6b5990d349"}], "stats": {"total": 193, "additions": 157, "deletions": 36}, "files": [{"sha": "b2031162a79f59d01cfa69ce94122505bbd848d6", "filename": "src/interpreter.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f145017319af0031c5248ee1c0cc435fba3a229b/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f145017319af0031c5248ee1c0cc435fba3a229b/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=f145017319af0031c5248ee1c0cc435fba3a229b", "patch": "@@ -16,6 +16,7 @@ pub enum EvalError {\n     DanglingPointerDeref,\n     InvalidBool,\n     PointerOutOfBounds,\n+    InvalidPointerAccess,\n }\n \n pub type EvalResult<T> = Result<T, EvalError>;\n@@ -26,6 +27,8 @@ impl Error for EvalError {\n             EvalError::DanglingPointerDeref => \"dangling pointer was dereferenced\",\n             EvalError::InvalidBool => \"invalid boolean value read\",\n             EvalError::PointerOutOfBounds => \"pointer offset outside bounds of allocation\",\n+            EvalError::InvalidPointerAccess =>\n+                \"a raw memory access tried to access part of a pointer value as bytes\",\n         }\n     }\n \n@@ -297,9 +300,10 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                 }\n             }\n \n-            // Ref(_region, _kind, ref lvalue) => {\n-            //     Value::Pointer(self.lvalue_to_ptr(lvalue))\n-            // }\n+            Ref(_, _, ref lvalue) => {\n+                let (ptr, _) = try!(self.eval_lvalue(lvalue));\n+                self.memory.write_ptr(dest, ptr)\n+            }\n \n             ref r => panic!(\"can't handle rvalue: {:?}\", r),\n         }\n@@ -349,6 +353,8 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                         _ => panic!(\"variant downcast on non-sum type\"),\n                     },\n \n+                    Deref => try!(self.memory.read_ptr(base_ptr)),\n+\n                     _ => unimplemented!(),\n                 }\n             }\n@@ -453,6 +459,10 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                 self.make_variant_repr(&adt_def.variants[0], substs)\n             }\n \n+            ty::TyRef(_, ty::TypeAndMut { ty, .. }) => {\n+                Repr::Pointer { target: Box::new(self.ty_to_repr(ty)) }\n+            }\n+\n             ref t => panic!(\"can't convert type to repr: {:?}\", t),\n         }\n     }"}, {"sha": "c7b5df9fa3d17767a0e2f683f4cb61712b53471c", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f145017319af0031c5248ee1c0cc435fba3a229b/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f145017319af0031c5248ee1c0cc435fba3a229b/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f145017319af0031c5248ee1c0cc435fba3a229b", "patch": "@@ -1,4 +1,4 @@\n-#![feature(rustc_private)]\n+#![feature(btree_range, collections_bound, rustc_private)]\n \n extern crate byteorder;\n extern crate rustc;"}, {"sha": "acc5597a4264c3387ffcf6338c0bc6ee5f7e84ce", "filename": "src/memory.rs", "status": "modified", "additions": 96, "deletions": 8, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f145017319af0031c5248ee1c0cc435fba3a229b/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f145017319af0031c5248ee1c0cc435fba3a229b/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=f145017319af0031c5248ee1c0cc435fba3a229b", "patch": "@@ -1,10 +1,13 @@\n use byteorder::{self, ByteOrder};\n-use std::collections::HashMap;\n+use std::collections::{BTreeMap, HashMap};\n+use std::collections::Bound::{Included, Excluded};\n use std::ptr;\n \n use interpreter::{EvalError, EvalResult};\n use primval::PrimVal;\n \n+const POINTER_SIZE: usize = 8;\n+\n pub struct Memory {\n     next_id: u64,\n     alloc_map: HashMap<u64, Allocation>,\n@@ -13,10 +16,20 @@ pub struct Memory {\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub struct AllocId(u64);\n \n+/// A relocation represents a part of an allocation which points into another allocation. This is\n+/// used to represent pointers existing in the virtual memory.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub struct Relocation {\n+    /// The offset in the allocation where the relocation starts.\n+    offset: usize,\n+    /// The allocation this relocation points into.\n+    target: AllocId,\n+}\n+\n #[derive(Debug)]\n pub struct Allocation {\n     pub bytes: Vec<u8>,\n-    // TODO(tsion): relocations\n+    pub relocations: BTreeMap<usize, AllocId>,\n     // TODO(tsion): undef mask\n }\n \n@@ -61,6 +74,10 @@ pub enum Repr {\n     //     length: usize,\n     //     elem: Repr,\n     // },\n+\n+    Pointer {\n+        target: Box<Repr>,\n+    }\n }\n \n impl Memory {\n@@ -70,7 +87,7 @@ impl Memory {\n \n     pub fn allocate(&mut self, size: usize) -> Pointer {\n         let id = AllocId(self.next_id);\n-        let alloc = Allocation { bytes: vec![0; size] };\n+        let alloc = Allocation { bytes: vec![0; size], relocations: BTreeMap::new() };\n         self.alloc_map.insert(self.next_id, alloc);\n         self.next_id += 1;\n         Pointer {\n@@ -89,20 +106,40 @@ impl Memory {\n \n     fn get_bytes(&self, ptr: Pointer, size: usize) -> EvalResult<&[u8]> {\n         let alloc = try!(self.get(ptr.alloc_id));\n-        try!(alloc.check_bytes(ptr.offset, ptr.offset + size));\n+        try!(alloc.check_no_relocations(ptr.offset, ptr.offset + size));\n         Ok(&alloc.bytes[ptr.offset..ptr.offset + size])\n     }\n \n     fn get_bytes_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<&mut [u8]> {\n         let alloc = try!(self.get_mut(ptr.alloc_id));\n-        try!(alloc.check_bytes(ptr.offset, ptr.offset + size));\n+        try!(alloc.check_no_relocations(ptr.offset, ptr.offset + size));\n         Ok(&mut alloc.bytes[ptr.offset..ptr.offset + size])\n     }\n \n     pub fn copy(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<()> {\n-        let src_bytes = try!(self.get_bytes_mut(src, size)).as_mut_ptr();\n+        let (src_bytes, relocations) = {\n+            let alloc = try!(self.get_mut(src.alloc_id));\n+            try!(alloc.check_relocation_edges(src.offset, src.offset + size));\n+            let bytes = alloc.bytes[src.offset..src.offset + size].as_mut_ptr();\n+\n+            let mut relocations: Vec<(usize, AllocId)> = alloc.relocations\n+                .range(Included(&src.offset), Excluded(&(src.offset + size)))\n+                .map(|(&k, &v)| (k, v))\n+                .collect();\n+\n+            for &mut (ref mut offset, _) in &mut relocations {\n+                alloc.relocations.remove(offset);\n+                *offset += dest.offset - src.offset;\n+            }\n+\n+            (bytes, relocations)\n+        };\n+\n         let dest_bytes = try!(self.get_bytes_mut(dest, size)).as_mut_ptr();\n \n+        // TODO(tsion): Clear the destination range's existing relocations.\n+        try!(self.get_mut(dest.alloc_id)).relocations.extend(relocations);\n+\n         // SAFE: The above indexing would have panicked if there weren't at least `size` bytes\n         // behind `src` and `dest`. Also, we use the overlapping-safe `ptr::copy` if `src` and\n         // `dest` could possibly overlap.\n@@ -117,6 +154,29 @@ impl Memory {\n         Ok(())\n     }\n \n+    pub fn read_ptr(&self, ptr: Pointer) -> EvalResult<Pointer> {\n+        let alloc = try!(self.get(ptr.alloc_id));\n+        try!(alloc.check_relocation_edges(ptr.offset, ptr.offset + POINTER_SIZE));\n+        let bytes = &alloc.bytes[ptr.offset..ptr.offset + POINTER_SIZE];\n+        let offset = byteorder::NativeEndian::read_u64(bytes) as usize;\n+\n+        // TODO(tsion): Return an EvalError here instead of panicking.\n+        let alloc_id = *alloc.relocations.get(&ptr.offset).unwrap();\n+\n+        Ok(Pointer { alloc_id: alloc_id, offset: offset })\n+    }\n+\n+    // TODO(tsion): Detect invalid writes here and elsewhere.\n+    pub fn write_ptr(&mut self, dest: Pointer, ptr_val: Pointer) -> EvalResult<()> {\n+        {\n+            let bytes = try!(self.get_bytes_mut(dest, POINTER_SIZE));\n+            byteorder::NativeEndian::write_u64(bytes, ptr_val.offset as u64);\n+        }\n+        let alloc = try!(self.get_mut(dest.alloc_id));\n+        alloc.relocations.insert(dest.offset, ptr_val.alloc_id);\n+        Ok(())\n+    }\n+\n     pub fn read_primval(&self, ptr: Pointer, repr: &Repr) -> EvalResult<PrimVal> {\n         match *repr {\n             Repr::Bool => self.read_bool(ptr).map(PrimVal::Bool),\n@@ -193,18 +253,45 @@ impl Memory {\n }\n \n impl Allocation {\n-    fn check_bytes(&self, start: usize, end: usize) -> EvalResult<()> {\n+    fn check_bounds(&self, start: usize, end: usize) -> EvalResult<()> {\n         if start <= self.bytes.len() && end <= self.bytes.len() {\n             Ok(())\n         } else {\n             Err(EvalError::PointerOutOfBounds)\n         }\n     }\n+\n+    fn count_overlapping_relocations(&self, start: usize, end: usize) -> usize {\n+        self.relocations.range(\n+            Included(&start.saturating_sub(POINTER_SIZE - 1)),\n+            Excluded(&end)\n+        ).count()\n+    }\n+\n+    fn check_relocation_edges(&self, start: usize, end: usize) -> EvalResult<()> {\n+        try!(self.check_bounds(start, end));\n+        let n =\n+            self.count_overlapping_relocations(start, start) +\n+            self.count_overlapping_relocations(end, end);\n+        if n == 0 {\n+            Ok(())\n+        } else {\n+            Err(EvalError::InvalidPointerAccess)\n+        }\n+    }\n+\n+    fn check_no_relocations(&self, start: usize, end: usize) -> EvalResult<()> {\n+        try!(self.check_bounds(start, end));\n+        if self.count_overlapping_relocations(start, end) == 0 {\n+            Ok(())\n+        } else {\n+            Err(EvalError::InvalidPointerAccess)\n+        }\n+    }\n }\n \n impl Pointer {\n     pub fn offset(self, i: usize) -> Self {\n-        // TODO(tsion): Check for offset out of bounds.\n         Pointer { offset: self.offset + i, ..self }\n     }\n }\n@@ -219,6 +306,7 @@ impl Repr {\n             Repr::I64 => 8,\n             Repr::Product { size, .. } => size,\n             Repr::Sum { ref discr, max_variant_size, .. } => discr.size() + max_variant_size,\n+            Repr::Pointer { .. } => POINTER_SIZE,\n         }\n     }\n }"}, {"sha": "494adf243acb10518d9d054c77751797fbc25635", "filename": "test/pointers.rs", "status": "modified", "additions": 47, "deletions": 24, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f145017319af0031c5248ee1c0cc435fba3a229b/test%2Fpointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f145017319af0031c5248ee1c0cc435fba3a229b/test%2Fpointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test%2Fpointers.rs?ref=f145017319af0031c5248ee1c0cc435fba3a229b", "patch": "@@ -1,30 +1,53 @@\n #![feature(custom_attribute)]\n #![allow(dead_code, unused_attributes)]\n \n-// #[miri_run(expected = \"Int(1)\")]\n-// fn one_line_ref() -> i64 {\n-//     *&1\n-// }\n+#[miri_run]\n+fn one_line_ref() -> i16 {\n+    *&1\n+}\n \n-// #[miri_run(expected = \"Int(1)\")]\n-// fn basic_ref() -> i64 {\n-//     let x = &1;\n-//     *x\n-// }\n+#[miri_run]\n+fn basic_ref() -> i16 {\n+    let x = &1;\n+    *x\n+}\n \n-// #[miri_run(expected = \"Int(3)\")]\n-// fn basic_ref_mut() -> i64 {\n-//     let x = &mut 1;\n-//     *x += 2;\n-//     *x\n-// }\n+#[miri_run]\n+fn basic_ref_mut() -> i16 {\n+    let x = &mut 1;\n+    *x += 2;\n+    *x\n+}\n \n-// #[miri_run(expected = \"Int(3)\")]\n-// fn basic_ref_mut_var() -> i64 {\n-//     let mut a = 1;\n-//     {\n-//         let x = &mut a;\n-//         *x += 2;\n-//     }\n-//     a\n-// }\n+#[miri_run]\n+fn basic_ref_mut_var() -> i16 {\n+    let mut a = 1;\n+    {\n+        let x = &mut a;\n+        *x += 2;\n+    }\n+    a\n+}\n+\n+#[miri_run]\n+fn tuple_ref_mut() -> (i8, i8) {\n+    let mut t = (10, 20);\n+    {\n+        let x = &mut t.1;\n+        *x += 2;\n+    }\n+    t\n+}\n+\n+#[miri_run]\n+fn match_ref_mut() -> i8 {\n+    let mut t = (20, 22);\n+    {\n+        let mut opt = Some(&mut t);\n+        match opt {\n+            Some(&mut (ref mut x, ref mut y)) => *x += *y,\n+            None => {},\n+        }\n+    }\n+    t.0\n+}"}]}