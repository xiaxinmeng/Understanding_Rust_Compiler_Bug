{"sha": "67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3YjA3NjA1OTJlMWNmOWFhZDJlODRmMTUzNGVmMDhjM2M1ZjFhMmI=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-30T01:15:28Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-06T17:42:39Z"}, "message": "Moved pipes runtime support to libcore, and add a test that will help verify that busy waiting is no longer happening.\n\nFixing the result of a bad merge.", "tree": {"sha": "302572d9e576d9aa0d3fc08f70e4ee3ce20d7c40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/302572d9e576d9aa0d3fc08f70e4ee3ce20d7c40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b", "html_url": "https://github.com/rust-lang/rust/commit/67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c3889a02f107a3c93e05e8834673f924113c161", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c3889a02f107a3c93e05e8834673f924113c161", "html_url": "https://github.com/rust-lang/rust/commit/5c3889a02f107a3c93e05e8834673f924113c161"}], "stats": {"total": 464, "additions": 270, "deletions": 194}, "files": [{"sha": "97eefd708f3286329550728e6b6477bc8825161e", "filename": "src/libcore/core.rc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b", "patch": "@@ -39,7 +39,7 @@ export float, f32, f64;\n export box, char, str, ptr, vec, bool;\n export either, option, result, iter;\n export libc, os, io, run, rand, sys, unsafe, logging;\n-export arc, newcomm, comm, task, future;\n+export arc, newcomm, comm, task, future, pipes;\n export extfmt;\n export tuple;\n export to_str, to_bytes;\n@@ -187,7 +187,9 @@ mod newcomm;\n mod comm;\n mod task;\n mod future;\n-\n+// TODO: remove the conditionals once a new snapshot happens\n+#[cfg(stage1)]\n+mod pipes;\n \n // Runtime and language-primitive support\n "}, {"sha": "75a4b90af067afb0daf1aa627ac7f123f45bf841", "filename": "src/libcore/pipes.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b", "patch": "@@ -0,0 +1,207 @@\n+// Runtime support for pipes.\n+\n+import unsafe::{forget, reinterpret_cast};\n+\n+enum state {\n+    empty,\n+    full,\n+    blocked,\n+    terminated\n+}\n+\n+type packet<T: send> = {\n+    mut state: state,\n+    mut blocked_task: option<task::task>,\n+    mut payload: option<T>\n+};\n+\n+fn packet<T: send>() -> *packet<T> unsafe {\n+    let p: *packet<T> = unsafe::transmute(~{\n+        mut state: empty,\n+        mut blocked_task: none::<task::task>,\n+        mut payload: none::<T>\n+    });\n+    p\n+}\n+\n+#[abi = \"rust-intrinsic\"]\n+native mod rusti {\n+    fn atomic_xchng(&dst: int, src: int) -> int;\n+    fn atomic_xchng_acq(&dst: int, src: int) -> int;\n+    fn atomic_xchng_rel(&dst: int, src: int) -> int;\n+}\n+\n+// We should consider moving this to core::unsafe, although I\n+// suspect graydon would want us to use void pointers instead.\n+unsafe fn uniquify<T>(x: *T) -> ~T {\n+    unsafe { unsafe::reinterpret_cast(x) }\n+}\n+\n+fn swap_state_acq(&dst: state, src: state) -> state {\n+    unsafe {\n+        reinterpret_cast(rusti::atomic_xchng_acq(\n+            *(ptr::mut_addr_of(dst) as *mut int),\n+            src as int))\n+    }\n+}\n+\n+fn swap_state_rel(&dst: state, src: state) -> state {\n+    unsafe {\n+        reinterpret_cast(rusti::atomic_xchng_rel(\n+            *(ptr::mut_addr_of(dst) as *mut int),\n+            src as int))\n+    }\n+}\n+\n+fn send<T: send>(-p: send_packet<T>, -payload: T) {\n+    let p = p.unwrap();\n+    let p = unsafe { uniquify(p) };\n+    assert (*p).payload == none;\n+    (*p).payload <- some(payload);\n+    let old_state = swap_state_rel((*p).state, full);\n+    alt old_state {\n+      empty {\n+        // Yay, fastpath.\n+\n+        // The receiver will eventually clean this up.\n+        unsafe { forget(p); }\n+      }\n+      full { fail \"duplicate send\" }\n+      blocked {\n+        // TODO: once the target will actually block, tell the\n+        // scheduler to wake it up.\n+\n+        // The receiver will eventually clean this up.\n+        unsafe { forget(p); }\n+      }\n+      terminated {\n+        // The receiver will never receive this. Rely on drop_glue\n+        // to clean everything up.\n+      }\n+    }\n+}\n+\n+fn recv<T: send>(-p: recv_packet<T>) -> option<T> {\n+    let p = p.unwrap();\n+    let p = unsafe { uniquify(p) };\n+    loop {\n+        let old_state = swap_state_acq((*p).state,\n+                                       blocked);\n+        alt old_state {\n+          empty | blocked { task::yield(); }\n+          full {\n+            let mut payload = none;\n+            payload <-> (*p).payload;\n+            ret some(option::unwrap(payload))\n+          }\n+          terminated {\n+            assert old_state == terminated;\n+            ret none;\n+          }\n+        }\n+    }\n+}\n+\n+fn sender_terminate<T: send>(p: *packet<T>) {\n+    let p = unsafe { uniquify(p) };\n+    alt swap_state_rel((*p).state, terminated) {\n+      empty | blocked {\n+        // The receiver will eventually clean up.\n+        unsafe { forget(p) }\n+      }\n+      full {\n+        // This is impossible\n+        fail \"you dun goofed\"\n+      }\n+      terminated {\n+        // I have to clean up, use drop_glue\n+      }\n+    }\n+}\n+\n+fn receiver_terminate<T: send>(p: *packet<T>) {\n+    let p = unsafe { uniquify(p) };\n+    alt swap_state_rel((*p).state, terminated) {\n+      empty {\n+        // the sender will clean up\n+        unsafe { forget(p) }\n+      }\n+      blocked {\n+        // this shouldn't happen.\n+        fail \"terminating a blocked packet\"\n+      }\n+      terminated | full {\n+        // I have to clean up, use drop_glue\n+      }\n+    }\n+}\n+\n+class send_packet<T: send> {\n+    let mut p: option<*packet<T>>;\n+    new(p: *packet<T>) {\n+        //#error(\"take send %?\", p);\n+        self.p = some(p);\n+    }\n+    drop {\n+        //if self.p != none {\n+        //    #error(\"drop send %?\", option::get(self.p));\n+        //}\n+        if self.p != none {\n+            let mut p = none;\n+            p <-> self.p;\n+            sender_terminate(option::unwrap(p))\n+        }\n+    }\n+    fn unwrap() -> *packet<T> {\n+        let mut p = none;\n+        p <-> self.p;\n+        option::unwrap(p)\n+    }\n+}\n+\n+class recv_packet<T: send> {\n+    let mut p: option<*packet<T>>;\n+    new(p: *packet<T>) {\n+        //#error(\"take recv %?\", p);\n+        self.p = some(p);\n+    }\n+    drop {\n+        //if self.p != none {\n+        //    #error(\"drop recv %?\", option::get(self.p));\n+        //}\n+        if self.p != none {\n+            let mut p = none;\n+            p <-> self.p;\n+            receiver_terminate(option::unwrap(p))\n+        }\n+    }\n+    fn unwrap() -> *packet<T> {\n+        let mut p = none;\n+        p <-> self.p;\n+        option::unwrap(p)\n+    }\n+}\n+\n+fn entangle<T: send>() -> (send_packet<T>, recv_packet<T>) {\n+    let p = packet();\n+    (send_packet(p), recv_packet(p))\n+}\n+\n+fn spawn_service<T: send>(\n+    init: native fn() -> (send_packet<T>, recv_packet<T>),\n+    +service: fn~(+recv_packet<T>))\n+    -> send_packet<T>\n+{\n+    let (client, server) = init();\n+\n+    // This is some nasty gymnastics required to safely move the pipe\n+    // into a new task.\n+    let server = ~mut some(server);\n+    task::spawn() {|move service|\n+        let mut server_ = none;\n+        server_ <-> *server;\n+        service(option::unwrap(server_))\n+    }\n+\n+    client\n+}"}, {"sha": "b3b9d089fea7a92ce185c433cb7117017a8ba30c", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b", "patch": "@@ -1163,7 +1163,6 @@ pure fn unpack_mut_slice<T,U>(s: &[mut T],\n impl extensions<T: copy> for ~[T] {\n     #[inline(always)]\n     pure fn +(rhs: &[const T]) -> ~[T] {\n-he pretty printer is unhappy.\n         append(self, rhs)\n     }\n }"}, {"sha": "b3e69e5699df4b99300fc750b4ff22da75f4b646", "filename": "src/test/bench/msgsend-ring-contracts.rs", "status": "modified", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b/src%2Ftest%2Fbench%2Fmsgsend-ring-contracts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b/src%2Ftest%2Fbench%2Fmsgsend-ring-contracts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-contracts.rs?ref=67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b", "patch": "@@ -15,197 +15,6 @@ import std::time;\n \n import ring::server::recv;\n \n-mod pipes {\n-    // Runtime support for pipes.\n-\n-    import unsafe::{forget, reinterpret_cast};\n-\n-    enum state {\n-        empty,\n-        full,\n-        blocked,\n-        terminated\n-    }\n-\n-    type packet<T: send> = {\n-        mut state: state,\n-        mut blocked_task: option<task::task>,\n-        mut payload: option<T>\n-    };\n-\n-    fn packet<T: send>() -> *packet<T> unsafe {\n-        let p: *packet<T> = unsafe::transmute(~{\n-            mut state: empty,\n-            mut blocked_task: none::<task::task>,\n-            mut payload: none::<T>\n-        });\n-        p\n-    }\n-\n-    #[abi = \"rust-intrinsic\"]\n-    native mod rusti {\n-        fn atomic_xchng(&dst: int, src: int) -> int;\n-        fn atomic_xchng_acq(&dst: int, src: int) -> int;\n-        fn atomic_xchng_rel(&dst: int, src: int) -> int;\n-    }\n-\n-    // We should consider moving this to core::unsafe, although I\n-    // suspect graydon would want us to use void pointers instead.\n-    unsafe fn uniquify<T>(x: *T) -> ~T {\n-        unsafe { unsafe::reinterpret_cast(x) }\n-    }\n-\n-    fn swap_state_acq(&dst: state, src: state) -> state {\n-        unsafe {\n-            reinterpret_cast(rusti::atomic_xchng_acq(\n-                *(ptr::mut_addr_of(dst) as *mut int),\n-                src as int))\n-        }\n-    }\n-\n-    fn swap_state_rel(&dst: state, src: state) -> state {\n-        unsafe {\n-            reinterpret_cast(rusti::atomic_xchng_rel(\n-                *(ptr::mut_addr_of(dst) as *mut int),\n-                src as int))\n-        }\n-    }\n-\n-    fn send<T: send>(-p: send_packet<T>, -payload: T) {\n-        let p = p.unwrap();\n-        let p = unsafe { uniquify(p) };\n-        assert (*p).payload == none;\n-        (*p).payload <- some(payload);\n-        let old_state = swap_state_rel((*p).state, full);\n-        alt old_state {\n-          empty {\n-            // Yay, fastpath.\n-\n-            // The receiver will eventually clean this up.\n-            unsafe { forget(p); }\n-          }\n-          full { fail \"duplicate send\" }\n-          blocked {\n-            // FIXME: once the target will actually block, tell the\n-            // scheduler to wake it up.\n-\n-            // The receiver will eventually clean this up.\n-            unsafe { forget(p); }\n-          }\n-          terminated {\n-            // The receiver will never receive this. Rely on drop_glue\n-            // to clean everything up.\n-          }\n-        }\n-    }\n-\n-    fn recv<T: send>(-p: recv_packet<T>) -> option<T> {\n-        let p = p.unwrap();\n-        let p = unsafe { uniquify(p) };\n-        loop {\n-            let old_state = swap_state_acq((*p).state,\n-                                           blocked);\n-            alt old_state {\n-              empty | blocked { task::yield(); }\n-              full {\n-                let mut payload = none;\n-                payload <-> (*p).payload;\n-                ret some(option::unwrap(payload))\n-              }\n-              terminated {\n-                assert old_state == terminated;\n-                ret none;\n-              }\n-            }\n-        }\n-    }\n-\n-    fn sender_terminate<T: send>(p: *packet<T>) {\n-        let p = unsafe { uniquify(p) };\n-        alt swap_state_rel((*p).state, terminated) {\n-          empty | blocked {\n-            // The receiver will eventually clean up.\n-            unsafe { forget(p) }\n-          }\n-          full {\n-            // This is impossible\n-            fail \"you dun goofed\"\n-          }\n-          terminated {\n-            // I have to clean up, use drop_glue\n-          }\n-        }\n-    }\n-\n-    fn receiver_terminate<T: send>(p: *packet<T>) {\n-        let p = unsafe { uniquify(p) };\n-        alt swap_state_rel((*p).state, terminated) {\n-          empty {\n-            // the sender will clean up\n-            unsafe { forget(p) }\n-          }\n-          blocked {\n-            // this shouldn't happen.\n-            fail \"terminating a blocked packet\"\n-          }\n-          terminated | full {\n-            // I have to clean up, use drop_glue\n-          }\n-        }\n-    }\n-\n-    class send_packet<T: send> {\n-        let mut p: option<*packet<T>>;\n-        new(p: *packet<T>) {\n-            //#error(\"take send %?\", p);\n-            self.p = some(p);\n-        }\n-        drop {\n-            //if self.p != none {\n-            //    #error(\"drop send %?\", option::get(self.p));\n-            //}\n-            if self.p != none {\n-                let mut p = none;\n-                p <-> self.p;\n-                sender_terminate(option::unwrap(p))\n-            }\n-        }\n-        fn unwrap() -> *packet<T> {\n-            let mut p = none;\n-            p <-> self.p;\n-            option::unwrap(p)\n-        }\n-    }\n-\n-    class recv_packet<T: send> {\n-        let mut p: option<*packet<T>>;\n-        new(p: *packet<T>) {\n-            //#error(\"take recv %?\", p);\n-            self.p = some(p);\n-        }\n-        drop {\n-            //if self.p != none {\n-            //    #error(\"drop recv %?\", option::get(self.p));\n-            //}\n-            if self.p != none {\n-                let mut p = none;\n-                p <-> self.p;\n-                receiver_terminate(option::unwrap(p))\n-            }\n-        }\n-        fn unwrap() -> *packet<T> {\n-            let mut p = none;\n-            p <-> self.p;\n-            option::unwrap(p)\n-        }\n-    }\n-\n-    fn entangle<T: send>() -> (send_packet<T>, recv_packet<T>) {\n-        let p = packet();\n-        (send_packet(p), recv_packet(p))\n-    }\n-}\n-\n // This module was generated by the pipe compiler.\n mod ring {\n     fn init() -> (client::num, server::num) { pipes::entangle() }"}, {"sha": "0855acef51dcb1c00d03a51348395315ec46903e", "filename": "src/test/run-pass/pipe-sleep.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs?ref=67b0760592e1cf9aad2e84f1534ef08c3c5f1a2b", "patch": "@@ -0,0 +1,59 @@\n+use std;\n+import std::timer::sleep;\n+import std::uv;\n+\n+// Compiled by pipec\n+mod oneshot {\n+    fn init() -> (client::waiting, server::waiting) { pipes::entangle() }\n+    enum waiting { signal(server::signaled), }\n+    enum signaled { }\n+    mod client {\n+        fn signal(-pipe: waiting) -> signaled {\n+            let (c, s) = pipes::entangle();\n+            let message = oneshot::signal(s);\n+            pipes::send(pipe, message);\n+            c\n+        }\n+        type waiting = pipes::send_packet<oneshot::waiting>;\n+        type signaled = pipes::send_packet<oneshot::signaled>;\n+    }\n+    mod server {\n+        impl recv for waiting {\n+            fn recv() -> extern fn(-waiting) -> oneshot::waiting {\n+                fn recv(-pipe: waiting) -> oneshot::waiting {\n+                    option::unwrap(pipes::recv(pipe))\n+                }\n+                recv\n+            }\n+        }\n+        type waiting = pipes::recv_packet<oneshot::waiting>;\n+        impl recv for signaled {\n+            fn recv() -> extern fn(-signaled) -> oneshot::signaled {\n+                fn recv(-pipe: signaled) -> oneshot::signaled {\n+                    option::unwrap(pipes::recv(pipe))\n+                }\n+                recv\n+            }\n+        }\n+        type signaled = pipes::recv_packet<oneshot::signaled>;\n+    }\n+}\n+\n+fn main() {\n+    import oneshot::client::*;\n+    import oneshot::server::recv;\n+\n+    #macro[\n+        [#recv[chan],\n+         chan.recv()(chan)]\n+    ];\n+\n+    let c = pipes::spawn_service(oneshot::init) {|p|\n+        #recv(p);\n+    };\n+\n+    let iotask = uv::global_loop::get();\n+    sleep(iotask, 5000);\n+    \n+    signal(c);\n+}\n\\ No newline at end of file"}]}