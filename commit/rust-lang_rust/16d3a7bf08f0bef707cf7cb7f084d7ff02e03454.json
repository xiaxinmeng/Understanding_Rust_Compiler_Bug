{"sha": "16d3a7bf08f0bef707cf7cb7f084d7ff02e03454", "node_id": "C_kwDOAAsO6NoAKDE2ZDNhN2JmMDhmMGJlZjcwN2NmN2NiN2YwODRkN2ZmMDJlMDM0NTQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-12T18:58:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-12T18:58:24Z"}, "message": "Merge #11266\n\n11266: internal: Mostly restore `hir` API boundary r=jonas-schievink a=jonas-schievink\n\nThe boundary was broken in https://github.com/rust-analyzer/rust-analyzer/pull/10872 by reexporting a bunch of `hir_def`-internal types.\r\n\r\nThis PR moves symbol collection to `hir` and removes those reexports again.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>", "tree": {"sha": "24dfce996c157c387af8155edce84693e84afabb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24dfce996c157c387af8155edce84693e84afabb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16d3a7bf08f0bef707cf7cb7f084d7ff02e03454", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh3yTQCRBK7hj4Ov3rIwAAFDMIAGdXyM/SHNidY/MSUDgykoRE\n1u8fKw47jTzr88KKKVJhKv1f2I+9tiY7CCZYpMFWc5AK3X8tGZtr+N6S0pBHxbkW\ncXGsyjztdnrFwMiblhyRMa13N87Pk2Fl2n4rbL0/NFPcvBzPpT7AJbcsaXtwO+Y5\ndIiV3C6phmxza6U6uffQlwmQ3MRFN+hZ+LVqXk+cIx38TR3qeXqjzPeVqtlDSWg7\n6mHO3rlFSlhC5Q+iRKtOeGliMVzaVtTOeCRWof2WEjmena55MmkNQk0oMocoyaKa\n9eFCBljfYQcF/7EWKXy/3lvJxY/0e3VAwQjPkNVAfCeOa3CtqpA6Bw6wNWuJ/gM=\n=jnFg\n-----END PGP SIGNATURE-----\n", "payload": "tree 24dfce996c157c387af8155edce84693e84afabb\nparent 4fe10b7bfe806174c1c92cc562d6ad0a92627e5c\nparent 09219e10f17e22b6560c5fc4da1d9ace53686345\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1642013904 +0000\ncommitter GitHub <noreply@github.com> 1642013904 +0000\n\nMerge #11266\n\n11266: internal: Mostly restore `hir` API boundary r=jonas-schievink a=jonas-schievink\n\nThe boundary was broken in https://github.com/rust-analyzer/rust-analyzer/pull/10872 by reexporting a bunch of `hir_def`-internal types.\r\n\r\nThis PR moves symbol collection to `hir` and removes those reexports again.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16d3a7bf08f0bef707cf7cb7f084d7ff02e03454", "html_url": "https://github.com/rust-lang/rust/commit/16d3a7bf08f0bef707cf7cb7f084d7ff02e03454", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16d3a7bf08f0bef707cf7cb7f084d7ff02e03454/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fe10b7bfe806174c1c92cc562d6ad0a92627e5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fe10b7bfe806174c1c92cc562d6ad0a92627e5c", "html_url": "https://github.com/rust-lang/rust/commit/4fe10b7bfe806174c1c92cc562d6ad0a92627e5c"}, {"sha": "09219e10f17e22b6560c5fc4da1d9ace53686345", "url": "https://api.github.com/repos/rust-lang/rust/commits/09219e10f17e22b6560c5fc4da1d9ace53686345", "html_url": "https://github.com/rust-lang/rust/commit/09219e10f17e22b6560c5fc4da1d9ace53686345"}], "stats": {"total": 801, "additions": 401, "deletions": 400}, "files": [{"sha": "22789e08971125665f384b6fb6a9dde283c94707", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/16d3a7bf08f0bef707cf7cb7f084d7ff02e03454/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d3a7bf08f0bef707cf7cb7f084d7ff02e03454/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=16d3a7bf08f0bef707cf7cb7f084d7ff02e03454", "patch": "@@ -28,6 +28,7 @@ mod has_source;\n \n pub mod diagnostics;\n pub mod db;\n+pub mod symbols;\n \n mod display;\n \n@@ -40,12 +41,16 @@ use hir_def::{\n     adt::{ReprKind, VariantData},\n     body::{BodyDiagnostic, SyntheticSyntax},\n     expr::{BindingAnnotation, LabelId, Pat, PatId},\n+    item_tree::ItemTreeNode,\n     lang_item::LangItemTarget,\n     nameres::{self, diagnostics::DefDiagnostic},\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n-    AttrDefId, ConstId, ConstParamId, EnumId, FunctionId, GenericDefId, HasModule, LifetimeParamId,\n-    LocalEnumVariantId, LocalFieldId, StaticId, StructId, TypeAliasId, TypeParamId, UnionId,\n+    src::HasSource as _,\n+    AdtId, AssocItemId, AssocItemLoc, AttrDefId, ConstId, ConstParamId, DefWithBodyId, EnumId,\n+    FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, LifetimeParamId,\n+    LocalEnumVariantId, LocalFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId,\n+    TypeParamId, UnionId,\n };\n use hir_expand::{name::name, MacroCallKind, MacroDefKind};\n use hir_ty::{\n@@ -106,24 +111,11 @@ pub use {\n         builtin_attr::AttributeTemplate,\n         find_path::PrefixKind,\n         import_map,\n-        item_scope::ItemScope,\n-        item_tree::ItemTreeNode,\n-        nameres::{DefMap, ModuleData, ModuleOrigin, ModuleSource},\n+        nameres::ModuleSource,\n         path::{ModPath, PathKind},\n-        src::HasSource as DefHasSource, // xx: I don't like this shadowing of HasSource... :(\n         type_ref::{Mutability, TypeRef},\n         visibility::Visibility,\n-        AdtId,\n-        AssocItemId,\n-        AssocItemLoc,\n-        DefWithBodyId,\n-        ImplId,\n-        ItemContainerId,\n-        ItemLoc,\n-        Lookup,\n-        ModuleDefId,\n         ModuleId,\n-        TraitId,\n     },\n     hir_expand::{\n         name::{known, Name},"}, {"sha": "b9d2f0cdca1ee3117a972be5ece396aec8855f72", "filename": "crates/hir/src/symbols.rs", "status": "added", "additions": 359, "deletions": 0, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/16d3a7bf08f0bef707cf7cb7f084d7ff02e03454/crates%2Fhir%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d3a7bf08f0bef707cf7cb7f084d7ff02e03454/crates%2Fhir%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsymbols.rs?ref=16d3a7bf08f0bef707cf7cb7f084d7ff02e03454", "patch": "@@ -0,0 +1,359 @@\n+//! File symbol extraction.\n+\n+use base_db::FileRange;\n+use either::Either;\n+use hir_def::{\n+    item_tree::ItemTreeNode, src::HasSource, AdtId, AssocItemId, AssocItemLoc, DefWithBodyId,\n+    ImplId, ItemContainerId, ItemLoc, Lookup, ModuleDefId, ModuleId, TraitId,\n+};\n+use hir_expand::{HirFileId, InFile};\n+use hir_ty::db::HirDatabase;\n+use syntax::{ast::HasName, AstNode, SmolStr, SyntaxNode, SyntaxNodePtr};\n+\n+use crate::{HasSource as _, MacroDef, Module, Semantics};\n+\n+/// The actual data that is stored in the index. It should be as compact as\n+/// possible.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct FileSymbol {\n+    pub name: SmolStr,\n+    pub loc: DeclarationLocation,\n+    pub kind: FileSymbolKind,\n+    pub container_name: Option<SmolStr>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DeclarationLocation {\n+    /// The file id for both the `ptr` and `name_ptr`.\n+    pub hir_file_id: HirFileId,\n+    /// This points to the whole syntax node of the declaration.\n+    pub ptr: SyntaxNodePtr,\n+    /// This points to the [`syntax::ast::Name`] identifier of the declaration.\n+    pub name_ptr: SyntaxNodePtr,\n+}\n+\n+impl DeclarationLocation {\n+    pub fn syntax<DB: HirDatabase>(&self, sema: &Semantics<DB>) -> Option<SyntaxNode> {\n+        let root = sema.parse_or_expand(self.hir_file_id)?;\n+        Some(self.ptr.to_node(&root))\n+    }\n+\n+    pub fn original_range(&self, db: &dyn HirDatabase) -> Option<FileRange> {\n+        find_original_file_range(db, self.hir_file_id, &self.ptr)\n+    }\n+\n+    pub fn original_name_range(&self, db: &dyn HirDatabase) -> Option<FileRange> {\n+        find_original_file_range(db, self.hir_file_id, &self.name_ptr)\n+    }\n+}\n+\n+fn find_original_file_range(\n+    db: &dyn HirDatabase,\n+    file_id: HirFileId,\n+    ptr: &SyntaxNodePtr,\n+) -> Option<FileRange> {\n+    let root = db.parse_or_expand(file_id)?;\n+    let node = ptr.to_node(&root);\n+    let node = InFile::new(file_id, &node);\n+\n+    Some(node.original_file_range(db.upcast()))\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n+pub enum FileSymbolKind {\n+    Const,\n+    Enum,\n+    Function,\n+    Macro,\n+    Module,\n+    Static,\n+    Struct,\n+    Trait,\n+    TypeAlias,\n+    Union,\n+}\n+\n+impl FileSymbolKind {\n+    pub fn is_type(self: FileSymbolKind) -> bool {\n+        matches!(\n+            self,\n+            FileSymbolKind::Struct\n+                | FileSymbolKind::Enum\n+                | FileSymbolKind::Trait\n+                | FileSymbolKind::TypeAlias\n+                | FileSymbolKind::Union\n+        )\n+    }\n+}\n+\n+/// Represents an outstanding module that the symbol collector must collect symbols from.\n+struct SymbolCollectorWork {\n+    module_id: ModuleId,\n+    parent: Option<DefWithBodyId>,\n+}\n+\n+pub struct SymbolCollector<'a> {\n+    db: &'a dyn HirDatabase,\n+    symbols: Vec<FileSymbol>,\n+    work: Vec<SymbolCollectorWork>,\n+    current_container_name: Option<SmolStr>,\n+}\n+\n+/// Given a [`ModuleId`] and a [`HirDatabase`], use the DefMap for the module's crate to collect\n+/// all symbols that should be indexed for the given module.\n+impl<'a> SymbolCollector<'a> {\n+    pub fn collect(db: &dyn HirDatabase, module_id: ModuleId) -> Vec<FileSymbol> {\n+        let mut symbol_collector = SymbolCollector {\n+            db,\n+            symbols: Default::default(),\n+            current_container_name: None,\n+            // The initial work is the root module we're collecting, additional work will\n+            // be populated as we traverse the module's definitions.\n+            work: vec![SymbolCollectorWork { module_id, parent: None }],\n+        };\n+\n+        while let Some(work) = symbol_collector.work.pop() {\n+            symbol_collector.do_work(work);\n+        }\n+\n+        symbol_collector.symbols\n+    }\n+\n+    fn do_work(&mut self, work: SymbolCollectorWork) {\n+        self.db.unwind_if_cancelled();\n+\n+        let parent_name = work.parent.and_then(|id| self.def_with_body_id_name(id));\n+        self.with_container_name(parent_name, |s| s.collect_from_module(work.module_id));\n+    }\n+\n+    fn collect_from_module(&mut self, module_id: ModuleId) {\n+        let def_map = module_id.def_map(self.db.upcast());\n+        let scope = &def_map[module_id.local_id].scope;\n+\n+        for module_def_id in scope.declarations() {\n+            match module_def_id {\n+                ModuleDefId::ModuleId(id) => self.push_module(id),\n+                ModuleDefId::FunctionId(id) => {\n+                    self.push_decl_assoc(id, FileSymbolKind::Function);\n+                    self.collect_from_body(id);\n+                }\n+                ModuleDefId::AdtId(AdtId::StructId(id)) => {\n+                    self.push_decl(id, FileSymbolKind::Struct)\n+                }\n+                ModuleDefId::AdtId(AdtId::EnumId(id)) => self.push_decl(id, FileSymbolKind::Enum),\n+                ModuleDefId::AdtId(AdtId::UnionId(id)) => self.push_decl(id, FileSymbolKind::Union),\n+                ModuleDefId::ConstId(id) => {\n+                    self.push_decl_assoc(id, FileSymbolKind::Const);\n+                    self.collect_from_body(id);\n+                }\n+                ModuleDefId::StaticId(id) => {\n+                    self.push_decl_assoc(id, FileSymbolKind::Static);\n+                    self.collect_from_body(id);\n+                }\n+                ModuleDefId::TraitId(id) => {\n+                    self.push_decl(id, FileSymbolKind::Trait);\n+                    self.collect_from_trait(id);\n+                }\n+                ModuleDefId::TypeAliasId(id) => {\n+                    self.push_decl_assoc(id, FileSymbolKind::TypeAlias);\n+                }\n+                // Don't index these.\n+                ModuleDefId::BuiltinType(_) => {}\n+                ModuleDefId::EnumVariantId(_) => {}\n+            }\n+        }\n+\n+        for impl_id in scope.impls() {\n+            self.collect_from_impl(impl_id);\n+        }\n+\n+        for const_id in scope.unnamed_consts() {\n+            self.collect_from_body(const_id);\n+        }\n+\n+        for macro_def_id in scope.macro_declarations() {\n+            self.push_decl_macro(macro_def_id.into());\n+        }\n+    }\n+\n+    fn collect_from_body(&mut self, body_id: impl Into<DefWithBodyId>) {\n+        let body_id = body_id.into();\n+        let body = self.db.body(body_id);\n+\n+        // Descend into the blocks and enqueue collection of all modules within.\n+        for (_, def_map) in body.blocks(self.db.upcast()) {\n+            for (id, _) in def_map.modules() {\n+                self.work.push(SymbolCollectorWork {\n+                    module_id: def_map.module_id(id),\n+                    parent: Some(body_id),\n+                });\n+            }\n+        }\n+    }\n+\n+    fn collect_from_impl(&mut self, impl_id: ImplId) {\n+        let impl_data = self.db.impl_data(impl_id);\n+        for &assoc_item_id in &impl_data.items {\n+            self.push_assoc_item(assoc_item_id)\n+        }\n+    }\n+\n+    fn collect_from_trait(&mut self, trait_id: TraitId) {\n+        let trait_data = self.db.trait_data(trait_id);\n+        self.with_container_name(trait_data.name.as_text(), |s| {\n+            for &(_, assoc_item_id) in &trait_data.items {\n+                s.push_assoc_item(assoc_item_id);\n+            }\n+        });\n+    }\n+\n+    fn with_container_name(&mut self, container_name: Option<SmolStr>, f: impl FnOnce(&mut Self)) {\n+        if let Some(container_name) = container_name {\n+            let prev = self.current_container_name.replace(container_name);\n+            f(self);\n+            self.current_container_name = prev;\n+        } else {\n+            f(self);\n+        }\n+    }\n+\n+    fn current_container_name(&self) -> Option<SmolStr> {\n+        self.current_container_name.clone()\n+    }\n+\n+    fn def_with_body_id_name(&self, body_id: DefWithBodyId) -> Option<SmolStr> {\n+        match body_id {\n+            DefWithBodyId::FunctionId(id) => Some(\n+                id.lookup(self.db.upcast()).source(self.db.upcast()).value.name()?.text().into(),\n+            ),\n+            DefWithBodyId::StaticId(id) => Some(\n+                id.lookup(self.db.upcast()).source(self.db.upcast()).value.name()?.text().into(),\n+            ),\n+            DefWithBodyId::ConstId(id) => Some(\n+                id.lookup(self.db.upcast()).source(self.db.upcast()).value.name()?.text().into(),\n+            ),\n+        }\n+    }\n+\n+    fn push_assoc_item(&mut self, assoc_item_id: AssocItemId) {\n+        match assoc_item_id {\n+            AssocItemId::FunctionId(id) => self.push_decl_assoc(id, FileSymbolKind::Function),\n+            AssocItemId::ConstId(id) => self.push_decl_assoc(id, FileSymbolKind::Const),\n+            AssocItemId::TypeAliasId(id) => self.push_decl_assoc(id, FileSymbolKind::TypeAlias),\n+        }\n+    }\n+\n+    fn push_decl_assoc<L, T>(&mut self, id: L, kind: FileSymbolKind)\n+    where\n+        L: Lookup<Data = AssocItemLoc<T>>,\n+        T: ItemTreeNode,\n+        <T as ItemTreeNode>::Source: HasName,\n+    {\n+        fn container_name(db: &dyn HirDatabase, container: ItemContainerId) -> Option<SmolStr> {\n+            match container {\n+                ItemContainerId::ModuleId(module_id) => {\n+                    let module = Module::from(module_id);\n+                    module.name(db).and_then(|name| name.as_text())\n+                }\n+                ItemContainerId::TraitId(trait_id) => {\n+                    let trait_data = db.trait_data(trait_id);\n+                    trait_data.name.as_text()\n+                }\n+                ItemContainerId::ImplId(_) | ItemContainerId::ExternBlockId(_) => None,\n+            }\n+        }\n+\n+        self.push_file_symbol(|s| {\n+            let loc = id.lookup(s.db.upcast());\n+            let source = loc.source(s.db.upcast());\n+            let name_node = source.value.name()?;\n+            let container_name =\n+                container_name(s.db, loc.container).or_else(|| s.current_container_name());\n+\n+            Some(FileSymbol {\n+                name: name_node.text().into(),\n+                kind,\n+                container_name,\n+                loc: DeclarationLocation {\n+                    hir_file_id: source.file_id,\n+                    ptr: SyntaxNodePtr::new(source.value.syntax()),\n+                    name_ptr: SyntaxNodePtr::new(name_node.syntax()),\n+                },\n+            })\n+        })\n+    }\n+\n+    fn push_decl<L, T>(&mut self, id: L, kind: FileSymbolKind)\n+    where\n+        L: Lookup<Data = ItemLoc<T>>,\n+        T: ItemTreeNode,\n+        <T as ItemTreeNode>::Source: HasName,\n+    {\n+        self.push_file_symbol(|s| {\n+            let loc = id.lookup(s.db.upcast());\n+            let source = loc.source(s.db.upcast());\n+            let name_node = source.value.name()?;\n+\n+            Some(FileSymbol {\n+                name: name_node.text().into(),\n+                kind,\n+                container_name: s.current_container_name(),\n+                loc: DeclarationLocation {\n+                    hir_file_id: source.file_id,\n+                    ptr: SyntaxNodePtr::new(source.value.syntax()),\n+                    name_ptr: SyntaxNodePtr::new(name_node.syntax()),\n+                },\n+            })\n+        })\n+    }\n+\n+    fn push_module(&mut self, module_id: ModuleId) {\n+        self.push_file_symbol(|s| {\n+            let def_map = module_id.def_map(s.db.upcast());\n+            let module_data = &def_map[module_id.local_id];\n+            let declaration = module_data.origin.declaration()?;\n+            let module = declaration.to_node(s.db.upcast());\n+            let name_node = module.name()?;\n+\n+            Some(FileSymbol {\n+                name: name_node.text().into(),\n+                kind: FileSymbolKind::Module,\n+                container_name: s.current_container_name(),\n+                loc: DeclarationLocation {\n+                    hir_file_id: declaration.file_id,\n+                    ptr: SyntaxNodePtr::new(module.syntax()),\n+                    name_ptr: SyntaxNodePtr::new(name_node.syntax()),\n+                },\n+            })\n+        })\n+    }\n+\n+    fn push_decl_macro(&mut self, macro_def: MacroDef) {\n+        self.push_file_symbol(|s| {\n+            let name = macro_def.name(s.db)?.as_text()?;\n+            let source = macro_def.source(s.db)?;\n+\n+            let (ptr, name_ptr) = match source.value {\n+                Either::Left(m) => {\n+                    (SyntaxNodePtr::new(m.syntax()), SyntaxNodePtr::new(m.name()?.syntax()))\n+                }\n+                Either::Right(f) => {\n+                    (SyntaxNodePtr::new(f.syntax()), SyntaxNodePtr::new(f.name()?.syntax()))\n+                }\n+            };\n+\n+            Some(FileSymbol {\n+                name,\n+                kind: FileSymbolKind::Macro,\n+                container_name: s.current_container_name(),\n+                loc: DeclarationLocation { hir_file_id: source.file_id, name_ptr, ptr },\n+            })\n+        })\n+    }\n+\n+    fn push_file_symbol(&mut self, f: impl FnOnce(&Self) -> Option<FileSymbol>) {\n+        if let Some(file_symbol) = f(self) {\n+            self.symbols.push(file_symbol);\n+        }\n+    }\n+}"}, {"sha": "db7b80f71bf1c376da5ba9d4b3c676853b0555e8", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16d3a7bf08f0bef707cf7cb7f084d7ff02e03454/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d3a7bf08f0bef707cf7cb7f084d7ff02e03454/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=16d3a7bf08f0bef707cf7cb7f084d7ff02e03454", "patch": "@@ -66,8 +66,7 @@ use ide_db::{\n         salsa::{self, ParallelDatabase},\n         Env, FileLoader, FileSet, SourceDatabase, VfsPath,\n     },\n-    symbol_index::{self, FileSymbol},\n-    LineIndexDatabase,\n+    symbol_index, LineIndexDatabase,\n };\n use syntax::SourceFile;\n "}, {"sha": "1c3ff0624717d6416e20834f77d6c7d648d176f5", "filename": "crates/ide/src/navigation_target.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16d3a7bf08f0bef707cf7cb7f084d7ff02e03454/crates%2Fide%2Fsrc%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d3a7bf08f0bef707cf7cb7f084d7ff02e03454/crates%2Fide%2Fsrc%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fnavigation_target.rs?ref=16d3a7bf08f0bef707cf7cb7f084d7ff02e03454", "patch": "@@ -4,8 +4,8 @@ use std::fmt;\n \n use either::Either;\n use hir::{\n-    AssocItem, Documentation, FieldSource, HasAttrs, HasSource, HirDisplay, InFile, ModuleSource,\n-    Semantics,\n+    symbols::FileSymbol, AssocItem, Documentation, FieldSource, HasAttrs, HasSource, HirDisplay,\n+    InFile, ModuleSource, Semantics,\n };\n use ide_db::{\n     base_db::{FileId, FileRange},\n@@ -17,8 +17,6 @@ use syntax::{\n     match_ast, AstNode, SmolStr, TextRange,\n };\n \n-use crate::FileSymbol;\n-\n /// `NavigationTarget` represents an element in the editor's UI which you can\n /// click on to navigate to a particular piece of code.\n ///"}, {"sha": "db38a487830e681dbe2c7a38735d8a204f5f065e", "filename": "crates/ide_db/src/items_locator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16d3a7bf08f0bef707cf7cb7f084d7ff02e03454/crates%2Fide_db%2Fsrc%2Fitems_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d3a7bf08f0bef707cf7cb7f084d7ff02e03454/crates%2Fide_db%2Fsrc%2Fitems_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fitems_locator.rs?ref=16d3a7bf08f0bef707cf7cb7f084d7ff02e03454", "patch": "@@ -5,6 +5,7 @@\n use either::Either;\n use hir::{\n     import_map::{self, ImportKind},\n+    symbols::FileSymbol,\n     AsAssocItem, Crate, ItemInNs, Semantics,\n };\n use limit::Limit;\n@@ -13,8 +14,7 @@ use syntax::{ast, AstNode, SyntaxKind::NAME};\n use crate::{\n     defs::{Definition, NameClass},\n     helpers::import_assets::NameToImport,\n-    symbol_index::{self, FileSymbol},\n-    RootDatabase,\n+    symbol_index, RootDatabase,\n };\n \n /// A value to use, when uncertain which limit to pick."}, {"sha": "602eaf0de5309392927842fa1c31ce3f42d8cb88", "filename": "crates/ide_db/src/lib.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/16d3a7bf08f0bef707cf7cb7f084d7ff02e03454/crates%2Fide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d3a7bf08f0bef707cf7cb7f084d7ff02e03454/crates%2Fide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Flib.rs?ref=16d3a7bf08f0bef707cf7cb7f084d7ff02e03454", "patch": "@@ -26,7 +26,10 @@ use base_db::{\n     salsa::{self, Durability},\n     AnchoredPath, CrateId, FileId, FileLoader, FileLoaderDelegate, SourceDatabase, Upcast,\n };\n-use hir::db::{AstDatabase, DefDatabase, HirDatabase};\n+use hir::{\n+    db::{AstDatabase, DefDatabase, HirDatabase},\n+    symbols::FileSymbolKind,\n+};\n use rustc_hash::FxHashSet;\n \n use crate::{line_index::LineIndex, symbol_index::SymbolsDatabase};\n@@ -183,6 +186,23 @@ impl From<hir::MacroKind> for SymbolKind {\n     }\n }\n \n+impl From<FileSymbolKind> for SymbolKind {\n+    fn from(it: FileSymbolKind) -> Self {\n+        match it {\n+            FileSymbolKind::Const => SymbolKind::Const,\n+            FileSymbolKind::Enum => SymbolKind::Enum,\n+            FileSymbolKind::Function => SymbolKind::Function,\n+            FileSymbolKind::Macro => SymbolKind::Macro,\n+            FileSymbolKind::Module => SymbolKind::Module,\n+            FileSymbolKind::Static => SymbolKind::Static,\n+            FileSymbolKind::Struct => SymbolKind::Struct,\n+            FileSymbolKind::Trait => SymbolKind::Trait,\n+            FileSymbolKind::TypeAlias => SymbolKind::TypeAlias,\n+            FileSymbolKind::Union => SymbolKind::Union,\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     mod sourcegen_lints;"}, {"sha": "e82230b2f37cea45681e64ea959fff4424550868", "filename": "crates/ide_db/src/symbol_index.rs", "status": "modified", "additions": 8, "deletions": 375, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/16d3a7bf08f0bef707cf7cb7f084d7ff02e03454/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d3a7bf08f0bef707cf7cb7f084d7ff02e03454/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs?ref=16d3a7bf08f0bef707cf7cb7f084d7ff02e03454", "patch": "@@ -30,21 +30,18 @@ use std::{\n \n use base_db::{\n     salsa::{self, ParallelDatabase},\n-    CrateId, FileRange, SourceDatabaseExt, SourceRootId, Upcast,\n+    CrateId, SourceDatabaseExt, SourceRootId, Upcast,\n };\n-use either::Either;\n use fst::{self, Streamer};\n use hir::{\n     db::{DefDatabase, HirDatabase},\n-    AdtId, AssocItemId, AssocItemLoc, DefHasSource, DefWithBodyId, HasSource, HirFileId, ImplId,\n-    InFile, ItemContainerId, ItemLoc, ItemTreeNode, Lookup, MacroDef, Module, ModuleDefId,\n-    ModuleId, Semantics, TraitId,\n+    symbols::{FileSymbol, SymbolCollector},\n+    ModuleId,\n };\n use rayon::prelude::*;\n use rustc_hash::FxHashSet;\n-use syntax::{ast::HasName, AstNode, SmolStr, SyntaxNode, SyntaxNodePtr};\n \n-use crate::{RootDatabase, SymbolKind};\n+use crate::RootDatabase;\n \n #[derive(Debug)]\n pub struct Query {\n@@ -123,7 +120,7 @@ fn library_symbols(db: &dyn SymbolsDatabase, source_root_id: SourceRootId) -> Ar\n         // we specifically avoid calling SymbolsDatabase::module_symbols here, even they do the same thing,\n         // as the index for a library is not going to really ever change, and we do not want to store each\n         // module's index in salsa.\n-        .map(|module_id| SymbolCollector::collect(db, module_id))\n+        .map(|module_id| SymbolCollector::collect(db.upcast(), module_id))\n         .flatten()\n         .collect();\n \n@@ -132,7 +129,7 @@ fn library_symbols(db: &dyn SymbolsDatabase, source_root_id: SourceRootId) -> Ar\n \n fn module_symbols(db: &dyn SymbolsDatabase, module_id: ModuleId) -> Arc<SymbolIndex> {\n     let _p = profile::span(\"module_symbols\");\n-    let symbols = SymbolCollector::collect(db, module_id);\n+    let symbols = SymbolCollector::collect(db.upcast(), module_id);\n     Arc::new(SymbolIndex::new(symbols))\n }\n \n@@ -356,374 +353,12 @@ impl Query {\n     }\n }\n \n-/// The actual data that is stored in the index. It should be as compact as\n-/// possible.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct FileSymbol {\n-    pub name: SmolStr,\n-    pub loc: DeclarationLocation,\n-    pub kind: FileSymbolKind,\n-    pub container_name: Option<SmolStr>,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct DeclarationLocation {\n-    /// The file id for both the `ptr` and `name_ptr`.\n-    pub hir_file_id: HirFileId,\n-    /// This points to the whole syntax node of the declaration.\n-    pub ptr: SyntaxNodePtr,\n-    /// This points to the [`syntax::ast::Name`] identifier of the declaration.\n-    pub name_ptr: SyntaxNodePtr,\n-}\n-\n-impl DeclarationLocation {\n-    pub fn syntax(&self, semantics: &Semantics<'_, RootDatabase>) -> Option<SyntaxNode> {\n-        let root = semantics.parse_or_expand(self.hir_file_id)?;\n-        Some(self.ptr.to_node(&root))\n-    }\n-\n-    pub fn original_range(&self, db: &dyn HirDatabase) -> Option<FileRange> {\n-        find_original_file_range(db, self.hir_file_id, &self.ptr)\n-    }\n-\n-    pub fn original_name_range(&self, db: &dyn HirDatabase) -> Option<FileRange> {\n-        find_original_file_range(db, self.hir_file_id, &self.name_ptr)\n-    }\n-}\n-\n-fn find_original_file_range(\n-    db: &dyn HirDatabase,\n-    file_id: HirFileId,\n-    ptr: &SyntaxNodePtr,\n-) -> Option<FileRange> {\n-    let root = db.parse_or_expand(file_id)?;\n-    let node = ptr.to_node(&root);\n-    let node = InFile::new(file_id, &node);\n-\n-    Some(node.original_file_range(db.upcast()))\n-}\n-\n-#[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n-pub enum FileSymbolKind {\n-    Const,\n-    Enum,\n-    Function,\n-    Macro,\n-    Module,\n-    Static,\n-    Struct,\n-    Trait,\n-    TypeAlias,\n-    Union,\n-}\n-\n-impl FileSymbolKind {\n-    fn is_type(self: FileSymbolKind) -> bool {\n-        matches!(\n-            self,\n-            FileSymbolKind::Struct\n-                | FileSymbolKind::Enum\n-                | FileSymbolKind::Trait\n-                | FileSymbolKind::TypeAlias\n-                | FileSymbolKind::Union\n-        )\n-    }\n-}\n-\n-impl From<FileSymbolKind> for SymbolKind {\n-    fn from(it: FileSymbolKind) -> Self {\n-        match it {\n-            FileSymbolKind::Const => SymbolKind::Const,\n-            FileSymbolKind::Enum => SymbolKind::Enum,\n-            FileSymbolKind::Function => SymbolKind::Function,\n-            FileSymbolKind::Macro => SymbolKind::Macro,\n-            FileSymbolKind::Module => SymbolKind::Module,\n-            FileSymbolKind::Static => SymbolKind::Static,\n-            FileSymbolKind::Struct => SymbolKind::Struct,\n-            FileSymbolKind::Trait => SymbolKind::Trait,\n-            FileSymbolKind::TypeAlias => SymbolKind::TypeAlias,\n-            FileSymbolKind::Union => SymbolKind::Union,\n-        }\n-    }\n-}\n-\n-/// Represents an outstanding module that the symbol collector must collect symbols from.\n-struct SymbolCollectorWork {\n-    module_id: ModuleId,\n-    parent: Option<DefWithBodyId>,\n-}\n-\n-struct SymbolCollector<'a> {\n-    db: &'a dyn SymbolsDatabase,\n-    symbols: Vec<FileSymbol>,\n-    work: Vec<SymbolCollectorWork>,\n-    current_container_name: Option<SmolStr>,\n-}\n-\n-/// Given a [`ModuleId`] and a [`SymbolsDatabase`], use the DefMap for the module's crate to collect all symbols that should be\n-/// indexed for the given module.\n-impl<'a> SymbolCollector<'a> {\n-    fn collect(db: &dyn SymbolsDatabase, module_id: ModuleId) -> Vec<FileSymbol> {\n-        let mut symbol_collector = SymbolCollector {\n-            db,\n-            symbols: Default::default(),\n-            current_container_name: None,\n-            // The initial work is the root module we're collecting, additional work will\n-            // be populated as we traverse the module's definitions.\n-            work: vec![SymbolCollectorWork { module_id, parent: None }],\n-        };\n-\n-        while let Some(work) = symbol_collector.work.pop() {\n-            symbol_collector.do_work(work);\n-        }\n-\n-        symbol_collector.symbols\n-    }\n-\n-    fn do_work(&mut self, work: SymbolCollectorWork) {\n-        self.db.unwind_if_cancelled();\n-\n-        let parent_name = work.parent.and_then(|id| self.def_with_body_id_name(id));\n-        self.with_container_name(parent_name, |s| s.collect_from_module(work.module_id));\n-    }\n-\n-    fn collect_from_module(&mut self, module_id: ModuleId) {\n-        let def_map = module_id.def_map(self.db.upcast());\n-        let scope = &def_map[module_id.local_id].scope;\n-\n-        for module_def_id in scope.declarations() {\n-            match module_def_id {\n-                ModuleDefId::ModuleId(id) => self.push_module(id),\n-                ModuleDefId::FunctionId(id) => {\n-                    self.push_decl_assoc(id, FileSymbolKind::Function);\n-                    self.collect_from_body(id);\n-                }\n-                ModuleDefId::AdtId(AdtId::StructId(id)) => {\n-                    self.push_decl(id, FileSymbolKind::Struct)\n-                }\n-                ModuleDefId::AdtId(AdtId::EnumId(id)) => self.push_decl(id, FileSymbolKind::Enum),\n-                ModuleDefId::AdtId(AdtId::UnionId(id)) => self.push_decl(id, FileSymbolKind::Union),\n-                ModuleDefId::ConstId(id) => {\n-                    self.push_decl_assoc(id, FileSymbolKind::Const);\n-                    self.collect_from_body(id);\n-                }\n-                ModuleDefId::StaticId(id) => {\n-                    self.push_decl_assoc(id, FileSymbolKind::Static);\n-                    self.collect_from_body(id);\n-                }\n-                ModuleDefId::TraitId(id) => {\n-                    self.push_decl(id, FileSymbolKind::Trait);\n-                    self.collect_from_trait(id);\n-                }\n-                ModuleDefId::TypeAliasId(id) => {\n-                    self.push_decl_assoc(id, FileSymbolKind::TypeAlias);\n-                }\n-                // Don't index these.\n-                ModuleDefId::BuiltinType(_) => {}\n-                ModuleDefId::EnumVariantId(_) => {}\n-            }\n-        }\n-\n-        for impl_id in scope.impls() {\n-            self.collect_from_impl(impl_id);\n-        }\n-\n-        for const_id in scope.unnamed_consts() {\n-            self.collect_from_body(const_id);\n-        }\n-\n-        for macro_def_id in scope.macro_declarations() {\n-            self.push_decl_macro(macro_def_id.into());\n-        }\n-    }\n-\n-    fn collect_from_body(&mut self, body_id: impl Into<DefWithBodyId>) {\n-        let body_id = body_id.into();\n-        let body = self.db.body(body_id);\n-\n-        // Descend into the blocks and enqueue collection of all modules within.\n-        for (_, def_map) in body.blocks(self.db.upcast()) {\n-            for (id, _) in def_map.modules() {\n-                self.work.push(SymbolCollectorWork {\n-                    module_id: def_map.module_id(id),\n-                    parent: Some(body_id),\n-                });\n-            }\n-        }\n-    }\n-\n-    fn collect_from_impl(&mut self, impl_id: ImplId) {\n-        let impl_data = self.db.impl_data(impl_id);\n-        for &assoc_item_id in &impl_data.items {\n-            self.push_assoc_item(assoc_item_id)\n-        }\n-    }\n-\n-    fn collect_from_trait(&mut self, trait_id: TraitId) {\n-        let trait_data = self.db.trait_data(trait_id);\n-        self.with_container_name(trait_data.name.as_text(), |s| {\n-            for &(_, assoc_item_id) in &trait_data.items {\n-                s.push_assoc_item(assoc_item_id);\n-            }\n-        });\n-    }\n-\n-    fn with_container_name(&mut self, container_name: Option<SmolStr>, f: impl FnOnce(&mut Self)) {\n-        if let Some(container_name) = container_name {\n-            let prev = self.current_container_name.replace(container_name);\n-            f(self);\n-            self.current_container_name = prev;\n-        } else {\n-            f(self);\n-        }\n-    }\n-\n-    fn current_container_name(&self) -> Option<SmolStr> {\n-        self.current_container_name.clone()\n-    }\n-\n-    fn def_with_body_id_name(&self, body_id: DefWithBodyId) -> Option<SmolStr> {\n-        match body_id {\n-            DefWithBodyId::FunctionId(id) => Some(\n-                id.lookup(self.db.upcast()).source(self.db.upcast()).value.name()?.text().into(),\n-            ),\n-            DefWithBodyId::StaticId(id) => Some(\n-                id.lookup(self.db.upcast()).source(self.db.upcast()).value.name()?.text().into(),\n-            ),\n-            DefWithBodyId::ConstId(id) => Some(\n-                id.lookup(self.db.upcast()).source(self.db.upcast()).value.name()?.text().into(),\n-            ),\n-        }\n-    }\n-\n-    fn push_assoc_item(&mut self, assoc_item_id: AssocItemId) {\n-        match assoc_item_id {\n-            AssocItemId::FunctionId(id) => self.push_decl_assoc(id, FileSymbolKind::Function),\n-            AssocItemId::ConstId(id) => self.push_decl_assoc(id, FileSymbolKind::Const),\n-            AssocItemId::TypeAliasId(id) => self.push_decl_assoc(id, FileSymbolKind::TypeAlias),\n-        }\n-    }\n-\n-    fn push_decl_assoc<L, T>(&mut self, id: L, kind: FileSymbolKind)\n-    where\n-        L: Lookup<Data = AssocItemLoc<T>>,\n-        T: ItemTreeNode,\n-        <T as ItemTreeNode>::Source: HasName,\n-    {\n-        fn container_name(db: &dyn HirDatabase, container: ItemContainerId) -> Option<SmolStr> {\n-            match container {\n-                ItemContainerId::ModuleId(module_id) => {\n-                    let module = Module::from(module_id);\n-                    module.name(db).and_then(|name| name.as_text())\n-                }\n-                ItemContainerId::TraitId(trait_id) => {\n-                    let trait_data = db.trait_data(trait_id);\n-                    trait_data.name.as_text()\n-                }\n-                ItemContainerId::ImplId(_) | ItemContainerId::ExternBlockId(_) => None,\n-            }\n-        }\n-\n-        self.push_file_symbol(|s| {\n-            let loc = id.lookup(s.db.upcast());\n-            let source = loc.source(s.db.upcast());\n-            let name_node = source.value.name()?;\n-            let container_name =\n-                container_name(s.db.upcast(), loc.container).or_else(|| s.current_container_name());\n-\n-            Some(FileSymbol {\n-                name: name_node.text().into(),\n-                kind,\n-                container_name,\n-                loc: DeclarationLocation {\n-                    hir_file_id: source.file_id,\n-                    ptr: SyntaxNodePtr::new(source.value.syntax()),\n-                    name_ptr: SyntaxNodePtr::new(name_node.syntax()),\n-                },\n-            })\n-        })\n-    }\n-\n-    fn push_decl<L, T>(&mut self, id: L, kind: FileSymbolKind)\n-    where\n-        L: Lookup<Data = ItemLoc<T>>,\n-        T: ItemTreeNode,\n-        <T as ItemTreeNode>::Source: HasName,\n-    {\n-        self.push_file_symbol(|s| {\n-            let loc = id.lookup(s.db.upcast());\n-            let source = loc.source(s.db.upcast());\n-            let name_node = source.value.name()?;\n-\n-            Some(FileSymbol {\n-                name: name_node.text().into(),\n-                kind,\n-                container_name: s.current_container_name(),\n-                loc: DeclarationLocation {\n-                    hir_file_id: source.file_id,\n-                    ptr: SyntaxNodePtr::new(source.value.syntax()),\n-                    name_ptr: SyntaxNodePtr::new(name_node.syntax()),\n-                },\n-            })\n-        })\n-    }\n-\n-    fn push_module(&mut self, module_id: ModuleId) {\n-        self.push_file_symbol(|s| {\n-            let def_map = module_id.def_map(s.db.upcast());\n-            let module_data = &def_map[module_id.local_id];\n-            let declaration = module_data.origin.declaration()?;\n-            let module = declaration.to_node(s.db.upcast());\n-            let name_node = module.name()?;\n-\n-            Some(FileSymbol {\n-                name: name_node.text().into(),\n-                kind: FileSymbolKind::Module,\n-                container_name: s.current_container_name(),\n-                loc: DeclarationLocation {\n-                    hir_file_id: declaration.file_id,\n-                    ptr: SyntaxNodePtr::new(module.syntax()),\n-                    name_ptr: SyntaxNodePtr::new(name_node.syntax()),\n-                },\n-            })\n-        })\n-    }\n-\n-    fn push_decl_macro(&mut self, macro_def: MacroDef) {\n-        self.push_file_symbol(|s| {\n-            let name = macro_def.name(s.db.upcast())?.as_text()?;\n-            let source = macro_def.source(s.db.upcast())?;\n-\n-            let (ptr, name_ptr) = match source.value {\n-                Either::Left(m) => {\n-                    (SyntaxNodePtr::new(m.syntax()), SyntaxNodePtr::new(m.name()?.syntax()))\n-                }\n-                Either::Right(f) => {\n-                    (SyntaxNodePtr::new(f.syntax()), SyntaxNodePtr::new(f.name()?.syntax()))\n-                }\n-            };\n-\n-            Some(FileSymbol {\n-                name,\n-                kind: FileSymbolKind::Macro,\n-                container_name: s.current_container_name(),\n-                loc: DeclarationLocation { hir_file_id: source.file_id, name_ptr, ptr },\n-            })\n-        })\n-    }\n-\n-    fn push_file_symbol(&mut self, f: impl FnOnce(&Self) -> Option<FileSymbol>) {\n-        if let Some(file_symbol) = f(self) {\n-            self.symbols.push(file_symbol);\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n \n     use base_db::fixture::WithFixture;\n     use expect_test::expect_file;\n+    use hir::symbols::SymbolCollector;\n \n     use super::*;\n \n@@ -794,9 +429,7 @@ struct StructInModB;\n \n         let symbols: Vec<_> = module_ids_for_crate(db.upcast(), db.test_crate())\n             .into_iter()\n-            .map(|module_id| {\n-                (module_id, SymbolCollector::collect(&db as &dyn SymbolsDatabase, module_id))\n-            })\n+            .map(|module_id| (module_id, SymbolCollector::collect(&db, module_id)))\n             .collect();\n \n         expect_file![\"./test_data/test_symbol_index_collection.txt\"].assert_debug_eq(&symbols);"}]}