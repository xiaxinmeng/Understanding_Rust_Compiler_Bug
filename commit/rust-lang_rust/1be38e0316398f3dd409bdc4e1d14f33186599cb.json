{"sha": "1be38e0316398f3dd409bdc4e1d14f33186599cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiZTM4ZTAzMTYzOThmM2RkNDA5YmRjNGUxZDE0ZjMzMTg2NTk5Y2I=", "commit": {"author": {"name": "Ritiek Malhotra", "email": "ritiekmalhotra123@gmail.com", "date": "2017-11-23T11:36:48Z"}, "committer": {"name": "ritiek", "email": "ritiekmalhotra123@gmail.com", "date": "2017-11-26T14:11:52Z"}, "message": "MIR: Fix value moved diagnose messages\n\nMIR: adopt borrowck test\n\nFix trailing whitespace\n\nspan_bug! on unexpected action\n\nMake RegionVid use newtype_index!\n\nCloses #45843\n\nCheck rvalue aggregates during check_stmt in tycheck, add initial, (not passing) test\n\nFix failing test\n\nRemove attributes and test comments accidentally left behind, add in span_mirbugs\n\nNormalize LvalueTy for ops and format code to satisfy tidy check\n\nonly normalize operand types when in an ADT constructor\n\navoid early return\n\nhandle the active field index in unions\n\nnormalize types in ADT constructor\n\nFixes #45940\n\nFix borrowck compiler errors for upvars contain \"spurious\" dereferences\n\nFixes #46003\n\nadded associated function Box::leak\n\nBox::leak - improve documentation\n\nBox::leak - fixed bug in documentation\n\nBox::leak - relaxed constraints wrt. lifetimes\n\nBox::leak - updated documentation\n\nBox::leak - made an oops, fixed now =)\n\nBox::leak: update unstable issue number (46179).\n\nAdd test for #44953\n\nAdd missing Debug impls to std_unicode\n\nAlso adds #![deny(missing_debug_implementations)] so they don't get\nmissed again.\n\nAmend RELEASES for 1.22.1\n\nand fix the date for 1.22.0\n\nRename param in `[T]::swap_with_slice` from `src` to `other`.\n\nThe idea of \u2018source\u2019 and \u2018destination\u2019 aren\u2019t very applicable for this\noperation since both slices can both be considered sources and\ndestinations.\n\nClarify stdin behavior of `Command::output`.\n\nFixes #44929.\n\nAdd hints for the case of confusing enum with its variants\n\nAdd failing testcases\n\nAdd module population and case of enum in place of expression\n\nUse for_each_child_stable in find_module\n\nUse multiline text for crate conflict diagnostics\n\nMake float::from_bits transmute (and update the documentation to reflect this).\n\nThe current implementation/documentation was made to avoid sNaN because of\npotential safety issues implied by old/bad LLVM documentation. These issues\naren't real, so we can just make the implementation transmute (as permitted\nby the existing documentation of this method).\n\nAlso the documentation didn't actually match the behaviour: it said we may\nchange sNaNs, but in fact we canonicalized *all* NaNs.\n\nAlso an example in the documentation was wrong: it said we *always* change\nsNaNs, when the documentation was explicitly written to indicate it was\nimplementation-defined.\n\nThis makes to_bits and from_bits perfectly roundtrip cross-platform, except\nfor one caveat: although the 2008 edition of IEEE-754 specifies how to\ninterpet the signaling bit, earlier editions didn't. This lead to some platforms\npicking the opposite interpretation, so all signaling NaNs on x86/ARM are quiet\non MIPS, and vice-versa.\n\nNaN-boxing is a fairly important optimization, while we don't even guarantee\nthat float operations properly preserve signalingness. As such, this seems like\nthe more natural strategy to take (as opposed to trying to mangle the signaling\nbit on a per-platform basis).\n\nThis implementation is also, of course, faster.\n\nSimplify an Iterator::fold to Iterator::any\n\nThis method of once-diagnostics doesn't allow nesting\n\nUI tests extract the regular output from the 'rendered' field in json\n\nMerge cfail and ui tests into ui tests\n\nAdd a MIR pass to lower 128-bit operators to lang item calls\n\nRuns only with `-Z lower_128bit_ops` since it's not hooked into targets yet.\n\nInclude tuple projections in MIR tests\n\nAdd type checking for the lang item\n\nAs part of doing so, add more lang items instead of passing u128 to the i128 ones where it doesn't matter in twos-complement.\n\nHandle shifts properly\n\n* The overflow-checking shift items need to take a full 128-bit type, since they need to be able to detect idiocy like `1i128 << (1u128 << 127)`\n* The unchecked ones just take u32, like the `*_sh?` methods in core\n* Because shift-by-anything is allowed, cast into a new local for every shift\n\nincr.comp.: Make sure we don't lose unused green results from the query cache.\n\nrustbuild: Update LLVM and enable ThinLTO\n\nThis commit updates LLVM to fix #45511 (https://reviews.llvm.org/D39981) and\nalso reenables ThinLTO for libtest now that we shouldn't hit #45768. This also\nopportunistically enables ThinLTO for libstd which was previously blocked\n(#45661) on test failures related to debuginfo with a presumed cause of #45511.\n\nCloses #45511\n\nstd: Flag Windows TLS dtor symbol as #[used]\n\nTurns out ThinLTO was internalizing this symbol and eliminating it. Worse yet if\nyou compiled with LTO turns out no TLS destructors would run on Windows! The\n`#[used]` annotation should be a more bulletproof implementation (in the face of\nLTO) of preserving this symbol all the way through in LLVM and ensuring it makes\nit all the way to the linker which will take care of it.\n\nAdd enum InitializationRequiringAction\n\nFix tidy tests", "tree": {"sha": "b9fc511467c6d2175f082f5873ff268ca0870f81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9fc511467c6d2175f082f5873ff268ca0870f81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1be38e0316398f3dd409bdc4e1d14f33186599cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1be38e0316398f3dd409bdc4e1d14f33186599cb", "html_url": "https://github.com/rust-lang/rust/commit/1be38e0316398f3dd409bdc4e1d14f33186599cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1be38e0316398f3dd409bdc4e1d14f33186599cb/comments", "author": {"login": "ritiek", "id": 20314742, "node_id": "MDQ6VXNlcjIwMzE0NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/20314742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ritiek", "html_url": "https://github.com/ritiek", "followers_url": "https://api.github.com/users/ritiek/followers", "following_url": "https://api.github.com/users/ritiek/following{/other_user}", "gists_url": "https://api.github.com/users/ritiek/gists{/gist_id}", "starred_url": "https://api.github.com/users/ritiek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ritiek/subscriptions", "organizations_url": "https://api.github.com/users/ritiek/orgs", "repos_url": "https://api.github.com/users/ritiek/repos", "events_url": "https://api.github.com/users/ritiek/events{/privacy}", "received_events_url": "https://api.github.com/users/ritiek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ritiek", "id": 20314742, "node_id": "MDQ6VXNlcjIwMzE0NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/20314742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ritiek", "html_url": "https://github.com/ritiek", "followers_url": "https://api.github.com/users/ritiek/followers", "following_url": "https://api.github.com/users/ritiek/following{/other_user}", "gists_url": "https://api.github.com/users/ritiek/gists{/gist_id}", "starred_url": "https://api.github.com/users/ritiek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ritiek/subscriptions", "organizations_url": "https://api.github.com/users/ritiek/orgs", "repos_url": "https://api.github.com/users/ritiek/repos", "events_url": "https://api.github.com/users/ritiek/events{/privacy}", "received_events_url": "https://api.github.com/users/ritiek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c115551c425c5180d89bfc4b7ca0405b1d00b25", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c115551c425c5180d89bfc4b7ca0405b1d00b25", "html_url": "https://github.com/rust-lang/rust/commit/2c115551c425c5180d89bfc4b7ca0405b1d00b25"}], "stats": {"total": 57, "additions": 46, "deletions": 11}, "files": [{"sha": "6ec665549f8eae033e5811df8c54fe6e153ac424", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 45, "deletions": 10, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1be38e0316398f3dd409bdc4e1d14f33186599cb/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be38e0316398f3dd409bdc4e1d14f33186599cb/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=1be38e0316398f3dd409bdc4e1d14f33186599cb", "patch": "@@ -444,6 +444,34 @@ enum WriteKind {\n     Move,\n }\n \n+#[derive(Copy, Clone)]\n+enum InitializationRequiringAction {\n+    Update,\n+    Borrow,\n+    Use,\n+    Assignment,\n+}\n+\n+impl InitializationRequiringAction {\n+    fn as_noun(self) -> &'static str {\n+        match self {\n+            InitializationRequiringAction::Update     => \"update\",\n+            InitializationRequiringAction::Borrow     => \"borrow\",\n+            InitializationRequiringAction::Use        => \"use\",\n+            InitializationRequiringAction::Assignment => \"assign\"\n+        }\n+    }\n+\n+    fn as_verb_in_past_tense(self) -> &'static str {\n+        match self {\n+            InitializationRequiringAction::Update     => \"updated\",\n+            InitializationRequiringAction::Borrow     => \"borrowed\",\n+            InitializationRequiringAction::Use        => \"used\",\n+            InitializationRequiringAction::Assignment => \"assigned\"\n+        }\n+    }\n+}\n+\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Checks an access to the given lvalue to see if it is allowed. Examines the set of borrows\n     /// that are in scope, as well as which paths have been initialized, to ensure that (a) the\n@@ -534,7 +562,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // Write of P[i] or *P, or WriteAndRead of any P, requires P init'd.\n         match mode {\n             MutateMode::WriteAndRead => {\n-                self.check_if_path_is_moved(context, \"update\", lvalue_span, flow_state);\n+                self.check_if_path_is_moved(context, InitializationRequiringAction::Update,\n+                                            lvalue_span, flow_state);\n             }\n             MutateMode::JustWrite => {\n                 self.check_if_assigned_path_is_moved(context, lvalue_span, flow_state);\n@@ -560,7 +589,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     BorrowKind::Mut => (Deep, Write(WriteKind::MutableBorrow(bk))),\n                 };\n                 self.access_lvalue(context, (lvalue, span), access_kind, flow_state);\n-                self.check_if_path_is_moved(context, \"borrow\", (lvalue, span), flow_state);\n+                self.check_if_path_is_moved(context, InitializationRequiringAction::Borrow,\n+                                            (lvalue, span), flow_state);\n             }\n \n             Rvalue::Use(ref operand) |\n@@ -579,7 +609,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 };\n                 self.access_lvalue(\n                     context, (lvalue, span), (Shallow(Some(af)), Read(ReadKind::Copy)), flow_state);\n-                self.check_if_path_is_moved(context, \"use\", (lvalue, span), flow_state);\n+                self.check_if_path_is_moved(context, InitializationRequiringAction::Use,\n+                                            (lvalue, span), flow_state);\n             }\n \n             Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2) |\n@@ -680,7 +711,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // skip this check in that case).\n             }\n             ConsumeKind::Consume => {\n-                self.check_if_path_is_moved(context, \"use\", lvalue_span, flow_state);\n+                self.check_if_path_is_moved(context, InitializationRequiringAction::Use,\n+                                            lvalue_span, flow_state);\n             }\n         }\n     }\n@@ -741,7 +773,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn check_if_path_is_moved(&mut self,\n                               context: Context,\n-                              desired_action: &str,\n+                              desired_action: InitializationRequiringAction,\n                               lvalue_span: (&Lvalue<'tcx>, Span),\n                               flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         // FIXME: analogous code in check_loans first maps `lvalue` to\n@@ -912,7 +944,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // `base` to its base_path.\n \n                                     self.check_if_path_is_moved(\n-                                        context, \"assignment\", (base, span), flow_state);\n+                                        context, InitializationRequiringAction::Assignment,\n+                                        (base, span), flow_state);\n \n                                     // (base initialized; no need to\n                                     // recur further)\n@@ -1316,7 +1349,7 @@ mod prefixes {\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn report_use_of_moved_or_uninitialized(&mut self,\n                            _context: Context,\n-                           desired_action: &str,\n+                           desired_action: InitializationRequiringAction,\n                            (lvalue, span): (&Lvalue<'tcx>, Span),\n                            mpi: MovePathIndex,\n                            curr_move_out: &IdxSetBuf<MoveOutIndex>) {\n@@ -1326,7 +1359,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         if mois.is_empty() {\n             self.tcx.cannot_act_on_uninitialized_variable(span,\n-                                                          desired_action,\n+                                                          desired_action.as_noun(),\n                                                           &self.describe_lvalue(lvalue),\n                                                           Origin::Mir)\n                     .span_label(span, format!(\"use of possibly uninitialized `{}`\",\n@@ -1336,11 +1369,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let msg = \"\"; //FIXME: add \"partially \" or \"collaterally \"\n \n             let mut err = self.tcx.cannot_act_on_moved_value(span,\n-                                                             desired_action,\n+                                                             desired_action.as_noun(),\n                                                              msg,\n                                                              &self.describe_lvalue(lvalue),\n                                                              Origin::Mir);\n-            err.span_label(span, format!(\"value {} here after move\", desired_action));\n+\n+            err.span_label(span, format!(\"value {} here after move\",\n+                                         desired_action.as_verb_in_past_tense()));\n             for moi in mois {\n                 let move_msg = \"\"; //FIXME: add \" (into closure)\"\n                 let move_span = self.mir.source_info(self.move_data.moves[*moi].source).span;"}, {"sha": "9f08bd198223e248d4364c3a74088e20312ade95", "filename": "src/test/ui/borrowck/borrowck-reinit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1be38e0316398f3dd409bdc4e1d14f33186599cb/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1be38e0316398f3dd409bdc4e1d14f33186599cb/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.stderr?ref=1be38e0316398f3dd409bdc4e1d14f33186599cb", "patch": "@@ -14,7 +14,7 @@ error[E0382]: use of moved value: `x` (Mir)\n 17 |     drop(x);\n    |          - value moved here\n 18 |     let _ = (1,x); //~ ERROR use of moved value: `x` (Ast)\n-   |                ^ value use here after move\n+   |                ^ value used here after move\n \n error: aborting due to 2 previous errors\n "}]}