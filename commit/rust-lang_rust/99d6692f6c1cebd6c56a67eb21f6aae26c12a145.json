{"sha": "99d6692f6c1cebd6c56a67eb21f6aae26c12a145", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZDY2OTJmNmMxY2ViZDZjNTZhNjdlYjIxZjZhYWUyNmMxMmExNDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-27T10:38:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-27T10:38:41Z"}, "message": "Auto merge of #87431 - the8472:array-iter-fold, r=kennytm\n\nimplement fold() on array::IntoIter to improve flatten().collect() perf\n\nWith #87168 flattening `array::IntoIter`s is now `TrustedLen`, the `FromIterator` implementation for `Vec` has a specialization for `TrustedLen` iterators which uses internal iteration. This implements one of the main internal iteration methods on `array::Into` to optimize the combination of those two features.\n\nThis should address the main issue in #87411\n\n```\n# old\ntest vec::bench_flat_map_collect                         ... bench:   2,244,024 ns/iter (+/- 18,903)\n\n# new\ntest vec::bench_flat_map_collect                         ... bench:     172,863 ns/iter (+/- 2,141)\n```", "tree": {"sha": "57e6df70c3e510b0d103d5d54429f99711333e44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57e6df70c3e510b0d103d5d54429f99711333e44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99d6692f6c1cebd6c56a67eb21f6aae26c12a145", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99d6692f6c1cebd6c56a67eb21f6aae26c12a145", "html_url": "https://github.com/rust-lang/rust/commit/99d6692f6c1cebd6c56a67eb21f6aae26c12a145", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99d6692f6c1cebd6c56a67eb21f6aae26c12a145/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "998cfe5aad7c21eb19a4bca50f05a13354706970", "url": "https://api.github.com/repos/rust-lang/rust/commits/998cfe5aad7c21eb19a4bca50f05a13354706970", "html_url": "https://github.com/rust-lang/rust/commit/998cfe5aad7c21eb19a4bca50f05a13354706970"}, {"sha": "2276c5e3d76591561e28fed760984e75c46bc407", "url": "https://api.github.com/repos/rust-lang/rust/commits/2276c5e3d76591561e28fed760984e75c46bc407", "html_url": "https://github.com/rust-lang/rust/commit/2276c5e3d76591561e28fed760984e75c46bc407"}], "stats": {"total": 27, "additions": 27, "deletions": 0}, "files": [{"sha": "c93a493cadb0db7e24744182793348c3b71a8e49", "filename": "library/alloc/benches/vec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99d6692f6c1cebd6c56a67eb21f6aae26c12a145/library%2Falloc%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d6692f6c1cebd6c56a67eb21f6aae26c12a145/library%2Falloc%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fvec.rs?ref=99d6692f6c1cebd6c56a67eb21f6aae26c12a145", "patch": "@@ -726,3 +726,9 @@ fn bench_dedup_old_100000(b: &mut Bencher) {\n fn bench_dedup_new_100000(b: &mut Bencher) {\n     bench_vec_dedup_new(b, 100000);\n }\n+\n+#[bench]\n+fn bench_flat_map_collect(b: &mut Bencher) {\n+    let v = vec![777u32; 500000];\n+    b.iter(|| v.iter().flat_map(|color| color.rotate_left(8).to_be_bytes()).collect::<Vec<_>>());\n+}"}, {"sha": "f6616399610a6a278ade82ae200044cb886ac4e1", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/99d6692f6c1cebd6c56a67eb21f6aae26c12a145/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d6692f6c1cebd6c56a67eb21f6aae26c12a145/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=99d6692f6c1cebd6c56a67eb21f6aae26c12a145", "patch": "@@ -123,6 +123,27 @@ impl<T, const N: usize> Iterator for IntoIter<T, N> {\n         (len, Some(len))\n     }\n \n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, mut fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let data = &mut self.data;\n+        // FIXME: This uses try_fold(&mut iter) instead of fold(iter) because the latter\n+        //  would go through the blanket `impl Iterator for &mut I` implementation\n+        //  which lacks inline annotations on its methods and adding those would be a larger\n+        //  perturbation than using try_fold here.\n+        //  Whether it would be beneficial to add those annotations should be investigated separately.\n+        (&mut self.alive)\n+            .try_fold::<_, _, Result<_, !>>(init, |acc, idx| {\n+                // SAFETY: idx is obtained by folding over the `alive` range, which implies the\n+                // value is currently considered alive but as the range is being consumed each value\n+                // we read here will only be read once and then considered dead.\n+                Ok(fold(acc, unsafe { data.get_unchecked(idx).assume_init_read() }))\n+            })\n+            .unwrap()\n+    }\n+\n     fn count(self) -> usize {\n         self.len()\n     }"}]}