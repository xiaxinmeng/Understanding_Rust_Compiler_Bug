{"sha": "3238e0d098cfd798a8828ec053cf37836c6c927d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMzhlMGQwOThjZmQ3OThhODgyOGVjMDUzY2YzNzgzNmM2YzkyN2Q=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-04-11T14:54:27Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-04-11T15:12:28Z"}, "message": "Optimise the last field operations in derive[PartialOrd]", "tree": {"sha": "4befff3f0cb827417f1d31a826d559fab6ef303d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4befff3f0cb827417f1d31a826d559fab6ef303d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3238e0d098cfd798a8828ec053cf37836c6c927d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3238e0d098cfd798a8828ec053cf37836c6c927d", "html_url": "https://github.com/rust-lang/rust/commit/3238e0d098cfd798a8828ec053cf37836c6c927d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3238e0d098cfd798a8828ec053cf37836c6c927d/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44efb05edfcba3baf7a3abcf10085c7647a909ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/44efb05edfcba3baf7a3abcf10085c7647a909ad", "html_url": "https://github.com/rust-lang/rust/commit/44efb05edfcba3baf7a3abcf10085c7647a909ad"}], "stats": {"total": 123, "additions": 72, "deletions": 51}, "files": [{"sha": "605e8a2e6cd18e1e30bd5dc8e73aa553b30e8773", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 72, "deletions": 51, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/3238e0d098cfd798a8828ec053cf37836c6c927d/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3238e0d098cfd798a8828ec053cf37836c6c927d/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=3238e0d098cfd798a8828ec053cf37836c6c927d", "patch": "@@ -190,58 +190,79 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<\n \n /// Strict inequality.\n fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-    let op = if less { BinOpKind::Lt } else { BinOpKind::Gt };\n-    cs_fold(false, // need foldr,\n-            |cx, span, subexpr, self_f, other_fs| {\n-        // build up a series of chain ||'s and &&'s from the inside\n-        // out (hence foldr) to get lexical ordering, i.e. for op ==\n-        // `ast::lt`\n-        //\n-        // ```\n-        // self.f1 < other.f1 || (!(other.f1 < self.f1) &&\n-        // (self.f2 < other.f2 || (!(other.f2 < self.f2) &&\n-        // (false)\n-        // ))\n-        // )\n-        // ```\n-        //\n-        // The optimiser should remove the redundancy. We explicitly\n-        // get use the binops to avoid auto-deref dereferencing too many\n-        // layers of pointers, if the type includes pointers.\n-        //\n-        let other_f = match (other_fs.len(), other_fs.get(0)) {\n-            (1, Some(o_f)) => o_f,\n-            _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n-        };\n-\n-        let strict_ineq = cx.expr_binary(span, op, self_f.clone(), other_f.clone());\n+    let strict_op = if less { BinOpKind::Lt } else { BinOpKind::Gt };\n+    cs_fold1(false, // need foldr,\n+        |cx, span, subexpr, self_f, other_fs| {\n+            // build up a series of chain ||'s and &&'s from the inside\n+            // out (hence foldr) to get lexical ordering, i.e. for op ==\n+            // `ast::lt`\n+            //\n+            // ```\n+            // self.f1 < other.f1 || (!(other.f1 < self.f1) &&\n+            // (self.f2 < other.f2 || (!(other.f2 < self.f2) &&\n+            // (false)\n+            // ))\n+            // )\n+            // ```\n+            //\n+            // The optimiser should remove the redundancy. We explicitly\n+            // get use the binops to avoid auto-deref dereferencing too many\n+            // layers of pointers, if the type includes pointers.\n+            //\n+            let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                (1, Some(o_f)) => o_f,\n+                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n+            };\n \n-        let deleg_cmp = if !equal {\n-            cx.expr_unary(span,\n-                          ast::UnOp::Not,\n-                          cx.expr_binary(span, op, other_f.clone(), self_f))\n-        } else {\n-            cx.expr_binary(span, BinOpKind::Eq, self_f, other_f.clone())\n-        };\n+            let strict_ineq = cx.expr_binary(span, strict_op, self_f.clone(), other_f.clone());\n \n-        let and = cx.expr_binary(span, BinOpKind::And, deleg_cmp, subexpr);\n-        cx.expr_binary(span, BinOpKind::Or, strict_ineq, and)\n-    },\n-            cx.expr_bool(span, equal),\n-            Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n-        if self_args.len() != 2 {\n-            cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n-        } else {\n-            let op = match (less, equal) {\n-                (true, true) => LeOp,\n-                (true, false) => LtOp,\n-                (false, true) => GeOp,\n-                (false, false) => GtOp,\n+            let deleg_cmp = if !equal {\n+                cx.expr_unary(span,\n+                            ast::UnOp::Not,\n+                            cx.expr_binary(span, strict_op, other_f.clone(), self_f))\n+            } else {\n+                cx.expr_binary(span, BinOpKind::Eq, self_f, other_f.clone())\n             };\n-            some_ordering_collapsed(cx, span, op, tag_tuple)\n-        }\n-    }),\n-            cx,\n-            span,\n-            substr)\n+\n+            let and = cx.expr_binary(span, BinOpKind::And, deleg_cmp, subexpr);\n+            cx.expr_binary(span, BinOpKind::Or, strict_ineq, and)\n+        },\n+        |cx, args| {\n+            match args {\n+                Some((span, self_f, other_fs)) => {\n+                    // Special-case the base case to generate cleaner code with\n+                    // fewer operations (e.g. `<=` instead of `<` and `==`).\n+                    let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                        (1, Some(o_f)) => o_f,\n+                        _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n+                    };\n+\n+                    let op = match (less, equal) {\n+                        (false, false) => BinOpKind::Gt,\n+                        (false, true) => BinOpKind::Ge,\n+                        (true, false) => BinOpKind::Lt,\n+                        (true, true) => BinOpKind::Le,\n+                    };\n+\n+                    cx.expr_binary(span, op, self_f, other_f.clone())\n+                }\n+                None => cx.expr_bool(span, equal)\n+            }\n+        },\n+        Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n+            if self_args.len() != 2 {\n+                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+            } else {\n+                let op = match (less, equal) {\n+                    (false, false) => GtOp,\n+                    (false, true) => GeOp,\n+                    (true, false) => LtOp,\n+                    (true, true) => LeOp,\n+                };\n+                some_ordering_collapsed(cx, span, op, tag_tuple)\n+            }\n+        }),\n+        cx,\n+        span,\n+        substr)\n }"}]}