{"sha": "86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2Nzg3ZjhiZWZlMGY4OTcxZjI3YmQxNWJlMWUxNmVjN2FhOTllN2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-12T02:11:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-12T02:11:17Z"}, "message": "auto merge of #10109 : pcmattman/rust/pass-nonzero-exit-status-on-termination-by-signal, r=alexcrichton\n\nThe UvProcess exit callback is called with a zero exit status and non-zero termination signal when a child is terminated by a signal.\r\n\r\nIf a parent checks only the exit status (for example, only checks the return value from `wait()`), it may believe the process completed successfully when it actually failed.\r\n\r\nHelpers for common use-cases are in `std::rt::io::process`.\r\n\r\nShould resolve https://github.com/mozilla/rust/issues/10062.", "tree": {"sha": "481ca094a98776594c0810dfc5b4767d8e9fae9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/481ca094a98776594c0810dfc5b4767d8e9fae9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "html_url": "https://github.com/rust-lang/rust/commit/86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0b7972f7d63e4b55098797cb48949b00d3ffee7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b7972f7d63e4b55098797cb48949b00d3ffee7", "html_url": "https://github.com/rust-lang/rust/commit/c0b7972f7d63e4b55098797cb48949b00d3ffee7"}, {"sha": "f698decf3701cc51a61bbc3e36971898339ba91e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f698decf3701cc51a61bbc3e36971898339ba91e", "html_url": "https://github.com/rust-lang/rust/commit/f698decf3701cc51a61bbc3e36971898339ba91e"}], "stats": {"total": 302, "additions": 202, "deletions": 100}, "files": [{"sha": "32ee19badd209c115e131e4744726d85f16a00d1", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "patch": "@@ -11,6 +11,7 @@\n use std::os;\n use std::run;\n use std::str;\n+use std::rt::io::process::ProcessExit;\n \n #[cfg(target_os = \"win32\")]\n fn target_env(lib_path: &str, prog: &str) -> ~[(~str,~str)] {\n@@ -39,7 +40,7 @@ fn target_env(_lib_path: &str, _prog: &str) -> ~[(~str,~str)] {\n     os::env()\n }\n \n-pub struct Result {status: int, out: ~str, err: ~str}\n+pub struct Result {status: ProcessExit, out: ~str, err: ~str}\n \n pub fn run(lib_path: &str,\n            prog: &str,"}, {"sha": "ffd5e721d67f41463fa18859f6ec500f73b567c9", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "patch": "@@ -23,6 +23,8 @@ use util::logv;\n use std::rt::io;\n use std::rt::io::fs;\n use std::rt::io::File;\n+use std::rt::io::process;\n+use std::rt::io::process::ProcessExit;\n use std::os;\n use std::str;\n use std::vec;\n@@ -60,7 +62,7 @@ pub fn run_metrics(config: config, testfile: ~str, mm: &mut MetricMap) {\n fn run_cfail_test(config: &config, props: &TestProps, testfile: &Path) {\n     let ProcRes = compile_test(config, props, testfile);\n \n-    if ProcRes.status == 0 {\n+    if ProcRes.status.success() {\n         fatal_ProcRes(~\"compile-fail test compiled successfully!\", &ProcRes);\n     }\n \n@@ -81,7 +83,7 @@ fn run_rfail_test(config: &config, props: &TestProps, testfile: &Path) {\n     let ProcRes = if !config.jit {\n         let ProcRes = compile_test(config, props, testfile);\n \n-        if ProcRes.status != 0 {\n+        if !ProcRes.status.success() {\n             fatal_ProcRes(~\"compilation failed!\", &ProcRes);\n         }\n \n@@ -92,7 +94,7 @@ fn run_rfail_test(config: &config, props: &TestProps, testfile: &Path) {\n \n     // The value our Makefile configures valgrind to return on failure\n     static VALGRIND_ERR: int = 100;\n-    if ProcRes.status == VALGRIND_ERR {\n+    if ProcRes.status.matches_exit_status(VALGRIND_ERR) {\n         fatal_ProcRes(~\"run-fail test isn't valgrind-clean!\", &ProcRes);\n     }\n \n@@ -115,10 +117,9 @@ fn run_rfail_test(config: &config, props: &TestProps, testfile: &Path) {\n fn check_correct_failure_status(ProcRes: &ProcRes) {\n     // The value the rust runtime returns on failure\n     static RUST_ERR: int = 101;\n-    if ProcRes.status != RUST_ERR {\n+    if !ProcRes.status.matches_exit_status(RUST_ERR) {\n         fatal_ProcRes(\n-            format!(\"failure produced the wrong error code: {}\",\n-                    ProcRes.status),\n+            format!(\"failure produced the wrong error: {}\", ProcRes.status),\n             ProcRes);\n     }\n }\n@@ -127,19 +128,19 @@ fn run_rpass_test(config: &config, props: &TestProps, testfile: &Path) {\n     if !config.jit {\n         let mut ProcRes = compile_test(config, props, testfile);\n \n-        if ProcRes.status != 0 {\n+        if !ProcRes.status.success() {\n             fatal_ProcRes(~\"compilation failed!\", &ProcRes);\n         }\n \n         ProcRes = exec_compiled_test(config, props, testfile);\n \n-        if ProcRes.status != 0 {\n+        if !ProcRes.status.success() {\n             fatal_ProcRes(~\"test run failed!\", &ProcRes);\n         }\n     } else {\n         let ProcRes = jit_test(config, props, testfile);\n \n-        if ProcRes.status != 0 { fatal_ProcRes(~\"jit failed!\", &ProcRes); }\n+        if !ProcRes.status.success() { fatal_ProcRes(~\"jit failed!\", &ProcRes); }\n     }\n }\n \n@@ -160,7 +161,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n         logv(config, format!(\"pretty-printing round {}\", round));\n         let ProcRes = print_source(config, testfile, srcs[round].clone());\n \n-        if ProcRes.status != 0 {\n+        if !ProcRes.status.success() {\n             fatal_ProcRes(format!(\"pretty-printing failed in round {}\", round),\n                           &ProcRes);\n         }\n@@ -192,7 +193,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     // Finally, let's make sure it actually appears to remain valid code\n     let ProcRes = typecheck_source(config, props, testfile, actual);\n \n-    if ProcRes.status != 0 {\n+    if !ProcRes.status.success() {\n         fatal_ProcRes(~\"pretty-printed source does not typecheck\", &ProcRes);\n     }\n \n@@ -264,7 +265,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n \n     // compile test file (it shoud have 'compile-flags:-g' in the header)\n     let mut ProcRes = compile_test(config, props, testfile);\n-    if ProcRes.status != 0 {\n+    if !ProcRes.status.success() {\n         fatal_ProcRes(~\"compilation failed!\", &ProcRes);\n     }\n \n@@ -375,7 +376,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n         }\n     }\n \n-    if ProcRes.status != 0 {\n+    if !ProcRes.status.success() {\n         fatal(~\"gdb failed to execute\");\n     }\n     let num_check_lines = check_lines.len();\n@@ -431,7 +432,7 @@ fn check_error_patterns(props: &TestProps,\n         }\n     }\n \n-    if ProcRes.status == 0 {\n+    if ProcRes.status.success() {\n         fatal(~\"process did not return an error status\");\n     }\n \n@@ -473,7 +474,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n     let mut found_flags = vec::from_elem(\n         expected_errors.len(), false);\n \n-    if ProcRes.status == 0 {\n+    if ProcRes.status.success() {\n         fatal(~\"process did not return an error status\");\n     }\n \n@@ -625,7 +626,7 @@ fn scan_string(haystack: &str, needle: &str, idx: &mut uint) -> bool {\n \n struct ProcArgs {prog: ~str, args: ~[~str]}\n \n-struct ProcRes {status: int, stdout: ~str, stderr: ~str, cmdline: ~str}\n+struct ProcRes {status: ProcessExit, stdout: ~str, stderr: ~str, cmdline: ~str}\n \n fn compile_test(config: &config, props: &TestProps,\n                 testfile: &Path) -> ProcRes {\n@@ -692,7 +693,7 @@ fn compose_and_run_compiler(\n                               |a,b| make_lib_name(a, b, testfile), &abs_ab);\n         let auxres = compose_and_run(config, &abs_ab, aux_args, ~[],\n                                      config.compile_lib_path, None);\n-        if auxres.status != 0 {\n+        if !auxres.status.success() {\n             fatal_ProcRes(\n                 format!(\"auxiliary build of {} failed to compile: \",\n                      abs_ab.display()),\n@@ -966,7 +967,12 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n \n     dump_output(config, testfile, stdout_out, stderr_out);\n \n-    ProcRes {status: exitcode, stdout: stdout_out, stderr: stderr_out, cmdline: cmdline }\n+    ProcRes {\n+        status: process::ExitStatus(exitcode),\n+        stdout: stdout_out,\n+        stderr: stderr_out,\n+        cmdline: cmdline\n+    }\n }\n \n fn _dummy_exec_compiled_test(config: &config, props: &TestProps,\n@@ -976,9 +982,9 @@ fn _dummy_exec_compiled_test(config: &config, props: &TestProps,\n     let cmdline = make_cmdline(\"\", args.prog, args.args);\n \n     match config.mode {\n-        mode_run_fail => ProcRes {status: 101, stdout: ~\"\",\n+        mode_run_fail => ProcRes {status: process::ExitStatus(101), stdout: ~\"\",\n                                  stderr: ~\"\", cmdline: cmdline},\n-        _             => ProcRes {status: 0, stdout: ~\"\",\n+        _             => ProcRes {status: process::ExitStatus(0), stdout: ~\"\",\n                                  stderr: ~\"\", cmdline: cmdline}\n     }\n }\n@@ -1099,33 +1105,33 @@ fn run_codegen_test(config: &config, props: &TestProps,\n     }\n \n     let mut ProcRes = compile_test_and_save_bitcode(config, props, testfile);\n-    if ProcRes.status != 0 {\n+    if !ProcRes.status.success() {\n         fatal_ProcRes(~\"compilation failed!\", &ProcRes);\n     }\n \n     ProcRes = extract_function_from_bitcode(config, props, \"test\", testfile, \"\");\n-    if ProcRes.status != 0 {\n+    if !ProcRes.status.success() {\n         fatal_ProcRes(~\"extracting 'test' function failed\", &ProcRes);\n     }\n \n     ProcRes = disassemble_extract(config, props, testfile, \"\");\n-    if ProcRes.status != 0 {\n+    if !ProcRes.status.success() {\n         fatal_ProcRes(~\"disassembling extract failed\", &ProcRes);\n     }\n \n \n     let mut ProcRes = compile_cc_with_clang_and_save_bitcode(config, props, testfile);\n-    if ProcRes.status != 0 {\n+    if !ProcRes.status.success() {\n         fatal_ProcRes(~\"compilation failed!\", &ProcRes);\n     }\n \n     ProcRes = extract_function_from_bitcode(config, props, \"test\", testfile, \"clang\");\n-    if ProcRes.status != 0 {\n+    if !ProcRes.status.success() {\n         fatal_ProcRes(~\"extracting 'test' function failed\", &ProcRes);\n     }\n \n     ProcRes = disassemble_extract(config, props, testfile, \"clang\");\n-    if ProcRes.status != 0 {\n+    if !ProcRes.status.success() {\n         fatal_ProcRes(~\"disassembling extract failed\", &ProcRes);\n     }\n "}, {"sha": "9b0a2c5fde8b0b0100437b1097dd8403dc15cdc8", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "patch": "@@ -378,9 +378,8 @@ pub mod write {\n \n         let prog = run::process_output(cc_prog, cc_args);\n \n-        if prog.status != 0 {\n-            sess.err(format!(\"building with `{}` failed with code {}\",\n-                        cc_prog, prog.status));\n+        if !prog.status.success() {\n+            sess.err(format!(\"linking with `{}` failed: {}\", cc_prog, prog.status));\n             sess.note(format!(\"{} arguments: {}\",\n                         cc_prog, cc_args.connect(\" \")));\n             sess.note(str::from_utf8(prog.error + prog.output));\n@@ -947,11 +946,11 @@ pub fn link_binary(sess: Session,\n \n     // We run 'cc' here\n     let prog = run::process_output(cc_prog, cc_args);\n-    if 0 != prog.status {\n-        sess.err(format!(\"linking with `{}` failed with code {}\",\n-                      cc_prog, prog.status));\n+\n+    if !prog.status.success() {\n+        sess.err(format!(\"linking with `{}` failed: {}\", cc_prog, prog.status));\n         sess.note(format!(\"{} arguments: {}\",\n-                       cc_prog, cc_args.connect(\" \")));\n+                    cc_prog, cc_args.connect(\" \")));\n         sess.note(str::from_utf8(prog.error + prog.output));\n         sess.abort_if_errors();\n     }"}, {"sha": "bb73882bde8e764b156af67deda74969b7d4601d", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "patch": "@@ -159,17 +159,16 @@ pub fn build_library_in_workspace(exec: &mut workcache::Exec,\n \n     let all_args = flags + absolute_paths + cc_args +\n          ~[~\"-o\", out_name.as_str().unwrap().to_owned()];\n-    let exit_code = run::process_status(tool, all_args);\n-    if exit_code != 0 {\n-        command_failed.raise((tool.to_owned(), all_args, exit_code))\n-    }\n-    else {\n+    let exit_process = run::process_status(tool, all_args);\n+    if exit_process.success() {\n         let out_name_str = out_name.as_str().unwrap().to_owned();\n         exec.discover_output(\"binary\",\n                              out_name_str,\n                              digest_only_date(&out_name));\n         context.add_library_path(out_name.dir_path());\n         out_name_str\n+    } else {\n+        command_failed.raise((tool.to_owned(), all_args, exit_process))\n     }\n }\n "}, {"sha": "6831b6ec31275bd7c613c80c0224b9373d449080", "filename": "src/librustpkg/conditions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "patch": "@@ -13,6 +13,7 @@\n pub use std::path::Path;\n pub use package_id::PkgId;\n pub use std::rt::io::FileStat;\n+pub use std::rt::io::process::ProcessExit;\n \n condition! {\n     pub bad_path: (Path, ~str) -> Path;\n@@ -57,5 +58,5 @@ condition! {\n condition! {\n     // str is output of applying the command (first component)\n     // to the args (second component)\n-    pub command_failed: (~str, ~[~str], int) -> ~str;\n+    pub command_failed: (~str, ~[~str], ProcessExit) -> ~str;\n }"}, {"sha": "94978b4a7e12fc82e0c6f179a7c9d8bd13736af3", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "patch": "@@ -26,6 +26,7 @@ extern mod rustc;\n extern mod syntax;\n \n use std::{os, result, run, str, task};\n+use std::rt::io::process;\n use std::hashmap::HashSet;\n use std::rt::io;\n use std::rt::io::fs;\n@@ -164,14 +165,14 @@ impl<'self> PkgScript<'self> {\n     /// is the command to pass to it (e.g., \"build\", \"clean\", \"install\")\n     /// Returns a pair of an exit code and list of configs (obtained by\n     /// calling the package script's configs() function if it exists\n-    fn run_custom(exe: &Path, sysroot: &Path) -> (~[~str], int) {\n+    fn run_custom(exe: &Path, sysroot: &Path) -> (~[~str], process::ProcessExit) {\n         debug!(\"Running program: {} {} {}\", exe.as_str().unwrap().to_owned(),\n                sysroot.display(), \"install\");\n         // FIXME #7401 should support commands besides `install`\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let status = run::process_status(exe.as_str().unwrap(),\n                                          [sysroot.as_str().unwrap().to_owned(), ~\"install\"]);\n-        if status != 0 {\n+        if !status.success() {\n             debug!(\"run_custom: first pkg command failed with {:?}\", status);\n             (~[], status)\n         }\n@@ -486,7 +487,7 @@ impl CtxMethods for BuildContext {\n                 // We always *run* the package script\n                 let (cfgs, hook_result) = PkgScript::run_custom(&Path::new(pkg_exe), &sysroot);\n                 debug!(\"Command return code = {:?}\", hook_result);\n-                if hook_result != 0 {\n+                if !hook_result.success() {\n                     fail!(\"Error running custom build command\")\n                 }\n                 custom = true;\n@@ -697,7 +698,7 @@ impl CtxMethods for BuildContext {\n                 debug!(\"test: test_exec = {}\", test_exec.display());\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 let status = run::process_status(test_exec.as_str().unwrap(), [~\"--test\"]);\n-                if status != 0 {\n+                if !status.success() {\n                     fail!(\"Some tests failed\");\n                 }\n             }"}, {"sha": "6f484a7be5da241f833a288557717305f16c76a0", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "patch": "@@ -36,7 +36,7 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n             let outp = run::process_output(\"git\", [~\"clone\",\n                                                    source.as_str().unwrap().to_owned(),\n                                                    target.as_str().unwrap().to_owned()]);\n-            if outp.status != 0 {\n+            if !outp.status.success() {\n                 println(str::from_utf8_owned(outp.output.clone()));\n                 println(str::from_utf8_owned(outp.error));\n                 return DirToUse(target.clone());\n@@ -52,7 +52,7 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n                             [format!(\"--work-tree={}\", target.as_str().unwrap().to_owned()),\n                              format!(\"--git-dir={}\", git_dir.as_str().unwrap().to_owned()),\n                              ~\"checkout\", format!(\"{}\", *s)]);\n-                        if outp.status != 0 {\n+                        if !outp.status.success() {\n                             println(str::from_utf8_owned(outp.output.clone()));\n                             println(str::from_utf8_owned(outp.error));\n                             return DirToUse(target.clone());\n@@ -73,7 +73,7 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n                         format!(\"--git-dir={}\", git_dir.as_str().unwrap().to_owned()),\n                         ~\"pull\", ~\"--no-edit\", source.as_str().unwrap().to_owned()];\n             let outp = run::process_output(\"git\", args);\n-            assert!(outp.status == 0);\n+            assert!(outp.status.success());\n         }\n         CheckedOutSources\n     } else {\n@@ -110,7 +110,7 @@ pub fn git_clone_url(source: &str, target: &Path, v: &Version) {\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let outp = run::process_output(\"git\", [~\"clone\", source.to_owned(),\n                                            target.as_str().unwrap().to_owned()]);\n-    if outp.status != 0 {\n+    if !outp.status.success() {\n          debug!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n          debug!(\"{}\", str::from_utf8_owned(outp.error));\n          cond.raise((source.to_owned(), target.clone()))\n@@ -120,7 +120,7 @@ pub fn git_clone_url(source: &str, target: &Path, v: &Version) {\n             &ExactRevision(ref s) | &Tagged(ref s) => {\n                     let outp = process_output_in_cwd(\"git\", [~\"checkout\", s.to_owned()],\n                                                          target);\n-                    if outp.status != 0 {\n+                    if !outp.status.success() {\n                         debug!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n                         debug!(\"{}\", str::from_utf8_owned(outp.error));\n                         cond.raise((source.to_owned(), target.clone()))"}, {"sha": "99910242582c7a9fffa6d60dfa9c9412029c9b5a", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "patch": "@@ -15,6 +15,8 @@ use std::{os, run, str, task};\n use std::rt::io;\n use std::rt::io::fs;\n use std::rt::io::File;\n+use std::rt::io::process;\n+use std::rt::io::process::ProcessExit;\n use extra::arc::Arc;\n use extra::arc::RWArc;\n use extra::tempfile::TempDir;\n@@ -149,7 +151,7 @@ fn run_git(args: &[~str], env: Option<~[(~str, ~str)]>, cwd: &Path, err_msg: &st\n         err_fd: None\n     });\n     let rslt = prog.finish_with_output();\n-    if rslt.status != 0 {\n+    if !rslt.status.success() {\n         fail!(\"{} [git returned {:?}, output = {}, error = {}]\", err_msg,\n            rslt.status, str::from_utf8(rslt.output), str::from_utf8(rslt.error));\n     }\n@@ -251,15 +253,15 @@ fn command_line_test_expect_fail(args: &[~str],\n                                  expected_exitcode: int) {\n     match command_line_test_with_env(args, cwd, env) {\n         Success(_) => fail!(\"Should have failed with {}, but it succeeded\", expected_exitcode),\n-        Fail(error) if error == expected_exitcode => (), // ok\n+        Fail(error) if error.matches_exit_status(expected_exitcode) => (), // ok\n         Fail(other) => fail!(\"Expected to fail with {}, but failed with {} instead\",\n                               expected_exitcode, other)\n     }\n }\n \n enum ProcessResult {\n     Success(ProcessOutput),\n-    Fail(int) // exit code\n+    Fail(ProcessExit)\n }\n \n /// Runs `rustpkg` (based on the directory that this executable was\n@@ -289,7 +291,7 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n                     cmd, args, str::from_utf8(output.output),\n                    str::from_utf8(output.error),\n                    output.status);\n-    if output.status != 0 {\n+    if !output.status.success() {\n         debug!(\"Command {} {:?} failed with exit code {:?}; its output was --- {} ---\",\n               cmd, args, output.status,\n               str::from_utf8(output.output) + str::from_utf8(output.error));\n@@ -501,9 +503,9 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n             // should be able to do this w/o a process\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             // n.b. Bumps time up by 2 seconds to get around granularity issues\n-            if run::process_output(\"touch\", [~\"--date\",\n+            if !run::process_output(\"touch\", [~\"--date\",\n                                              ~\"+2 seconds\",\n-                                             p.as_str().unwrap().to_owned()]).status != 0 {\n+                                             p.as_str().unwrap().to_owned()]).status.success() {\n                 let _ = cond.raise((pkg_src_dir.clone(), ~\"Bad path\"));\n             }\n         }\n@@ -520,8 +522,8 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n             // should be able to do this w/o a process\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             // n.b. Bumps time up by 2 seconds to get around granularity issues\n-            if run::process_output(\"touch\", [~\"-A02\",\n-                                             p.as_str().unwrap().to_owned()]).status != 0 {\n+            if !run::process_output(\"touch\", [~\"-A02\",\n+                                             p.as_str().unwrap().to_owned()]).status.success() {\n                 let _ = cond.raise((pkg_src_dir.clone(), ~\"Bad path\"));\n             }\n         }\n@@ -1091,7 +1093,8 @@ fn no_rebuilding() {\n \n     match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n         Success(*) => (), // ok\n-        Fail(status) if status == 65 => fail!(\"no_rebuilding failed: it tried to rebuild bar\"),\n+        Fail(status) if status.matches_exit_status(65) =>\n+            fail!(\"no_rebuilding failed: it tried to rebuild bar\"),\n         Fail(_) => fail!(\"no_rebuilding failed for some other reason\")\n     }\n }\n@@ -1109,7 +1112,7 @@ fn no_recopying() {\n \n     match command_line_test_partial([~\"install\", ~\"foo\"], workspace) {\n         Success(*) => (), // ok\n-        Fail(65) => fail!(\"no_recopying failed: it tried to re-copy foo\"),\n+        Fail(process::ExitStatus(65)) => fail!(\"no_recopying failed: it tried to re-copy foo\"),\n         Fail(_) => fail!(\"no_copying failed for some other reason\")\n     }\n }\n@@ -1127,7 +1130,8 @@ fn no_rebuilding_dep() {\n     assert!(chmod_read_only(&bar_lib));\n     match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n         Success(*) => (), // ok\n-        Fail(status) if status == 65 => fail!(\"no_rebuilding_dep failed: it tried to rebuild bar\"),\n+        Fail(status) if status.matches_exit_status(65) =>\n+            fail!(\"no_rebuilding_dep failed: it tried to rebuild bar\"),\n         Fail(_) => fail!(\"no_rebuilding_dep failed for some other reason\")\n     }\n }\n@@ -1147,7 +1151,7 @@ fn do_rebuild_dep_dates_change() {\n \n     match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n         Success(*) => fail!(\"do_rebuild_dep_dates_change failed: it didn't rebuild bar\"),\n-        Fail(status) if status == 65 => (), // ok\n+        Fail(status) if status.matches_exit_status(65) => (), // ok\n         Fail(_) => fail!(\"do_rebuild_dep_dates_change failed for some other reason\")\n     }\n }\n@@ -1168,7 +1172,7 @@ fn do_rebuild_dep_only_contents_change() {\n     // should adjust the datestamp\n     match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n         Success(*) => fail!(\"do_rebuild_dep_only_contents_change failed: it didn't rebuild bar\"),\n-        Fail(status) if status == 65 => (), // ok\n+        Fail(status) if status.matches_exit_status(65) => (), // ok\n         Fail(_) => fail!(\"do_rebuild_dep_only_contents_change failed for some other reason\")\n     }\n }\n@@ -1274,7 +1278,7 @@ fn test_extern_mod() {\n         err_fd: None\n     });\n     let outp = prog.finish_with_output();\n-    if outp.status != 0 {\n+    if !outp.status.success() {\n         fail!(\"output was {}, error was {}\",\n               str::from_utf8(outp.output),\n               str::from_utf8(outp.error));\n@@ -1329,7 +1333,7 @@ fn test_extern_mod_simpler() {\n         err_fd: None\n     });\n     let outp = prog.finish_with_output();\n-    if outp.status != 0 {\n+    if !outp.status.success() {\n         fail!(\"output was {}, error was {}\",\n               str::from_utf8(outp.output),\n               str::from_utf8(outp.error));\n@@ -2144,7 +2148,7 @@ fn test_rebuild_when_needed() {\n     chmod_read_only(&test_executable);\n     match command_line_test_partial([~\"test\", ~\"foo\"], foo_workspace) {\n         Success(*) => fail!(\"test_rebuild_when_needed didn't rebuild\"),\n-        Fail(status) if status == 65 => (), // ok\n+        Fail(status) if status.matches_exit_status(65) => (), // ok\n         Fail(_) => fail!(\"test_rebuild_when_needed failed for some other reason\")\n     }\n }\n@@ -2164,7 +2168,8 @@ fn test_no_rebuilding() {\n     chmod_read_only(&test_executable);\n     match command_line_test_partial([~\"test\", ~\"foo\"], foo_workspace) {\n         Success(*) => (), // ok\n-        Fail(status) if status == 65 => fail!(\"test_no_rebuilding failed: it rebuilt the tests\"),\n+        Fail(status) if status.matches_exit_status(65) =>\n+            fail!(\"test_no_rebuilding failed: it rebuilt the tests\"),\n         Fail(_) => fail!(\"test_no_rebuilding failed for some other reason\")\n     }\n }\n@@ -2359,9 +2364,11 @@ fn test_c_dependency_no_rebuilding() {\n \n     match command_line_test_partial([~\"build\", ~\"cdep\"], dir) {\n         Success(*) => (), // ok\n-        Fail(status) if status == 65 => fail!(\"test_c_dependency_no_rebuilding failed: \\\n-                                              it tried to rebuild foo.c\"),\n-        Fail(_) => fail!(\"test_c_dependency_no_rebuilding failed for some other reason\")\n+        Fail(status) if status.matches_exit_status(65) =>\n+            fail!(\"test_c_dependency_no_rebuilding failed: \\\n+                    it tried to rebuild foo.c\"),\n+        Fail(_) =>\n+            fail!(\"test_c_dependency_no_rebuilding failed for some other reason\")\n     }\n }\n \n@@ -2396,7 +2403,7 @@ fn test_c_dependency_yes_rebuilding() {\n     match command_line_test_partial([~\"build\", ~\"cdep\"], dir) {\n         Success(*) => fail!(\"test_c_dependency_yes_rebuilding failed: \\\n                             it didn't rebuild and should have\"),\n-        Fail(status) if status == 65 => (),\n+        Fail(status) if status.matches_exit_status(65) => (),\n         Fail(_) => fail!(\"test_c_dependency_yes_rebuilding failed for some other reason\")\n     }\n }"}, {"sha": "d40a104ccdad81c6f279036c7b8ebc3e264fbc81", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "patch": "@@ -109,7 +109,7 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n \n         debug!(\"git --git-dir={} tag -l ~~~> {:?}\", git_dir.display(), outp.status);\n \n-        if outp.status != 0 {\n+        if !outp.status.success() {\n             continue;\n         }\n \n@@ -143,7 +143,7 @@ pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n         let outp  = run::process_output(\"git\", [~\"clone\", format!(\"https://{}\",\n                                                                   remote_path.as_str().unwrap()),\n                                                 tmp_dir.as_str().unwrap().to_owned()]);\n-        if outp.status == 0 {\n+        if outp.status.success() {\n             debug!(\"Cloned it... ( {}, {} )\",\n                    str::from_utf8(outp.output),\n                    str::from_utf8(outp.error));"}, {"sha": "e49930c1fc93dbf3250f346545679d5d9e609781", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "patch": "@@ -33,8 +33,7 @@ pub struct Process {\n     to_wake: Option<BlockedTask>,\n \n     /// Collected from the exit_cb\n-    exit_status: Option<int>,\n-    term_signal: Option<int>,\n+    exit_status: Option<ProcessExit>,\n }\n \n impl Process {\n@@ -82,7 +81,6 @@ impl Process {\n                     home: get_handle_to_current_scheduler!(),\n                     to_wake: None,\n                     exit_status: None,\n-                    term_signal: None,\n                 };\n                 match unsafe {\n                     uvll::uv_spawn(loop_.handle, handle, &options)\n@@ -106,9 +104,10 @@ extern fn on_exit(handle: *uvll::uv_process_t,\n     let p: &mut Process = unsafe { UvHandle::from_uv_handle(&handle) };\n \n     assert!(p.exit_status.is_none());\n-    assert!(p.term_signal.is_none());\n-    p.exit_status = Some(exit_status as int);\n-    p.term_signal = Some(term_signal as int);\n+    p.exit_status = Some(match term_signal {\n+        0 => ExitStatus(exit_status as int),\n+        n => ExitSignal(n as int),\n+    });\n \n     match p.to_wake.take() {\n         Some(task) => {\n@@ -209,7 +208,7 @@ impl RtioProcess for Process {\n         }\n     }\n \n-    fn wait(&mut self) -> int {\n+    fn wait(&mut self) -> ProcessExit {\n         // Make sure (on the home scheduler) that we have an exit status listed\n         let _m = self.fire_homing_missile();\n         match self.exit_status {\n@@ -223,7 +222,6 @@ impl RtioProcess for Process {\n             }\n         }\n \n-        // FIXME(#10109): this is wrong\n         self.exit_status.unwrap()\n     }\n }"}, {"sha": "6b21cde2488c3c55987de1faddffa81350725ab2", "filename": "src/libstd/rt/io/process.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fprocess.rs?ref=86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "patch": "@@ -18,6 +18,8 @@ use rt::io;\n use rt::io::io_error;\n use rt::rtio::{RtioProcess, IoFactory, with_local_io};\n \n+use fmt;\n+\n // windows values don't matter as long as they're at least one of unix's\n // TERM/KILL/INT signals\n #[cfg(windows)] pub static PleaseExitSignal: int = 15;\n@@ -79,6 +81,40 @@ pub enum StdioContainer {\n     CreatePipe(bool /* readable */, bool /* writable */),\n }\n \n+/// Describes the result of a process after it has terminated.\n+#[deriving(Eq)]\n+pub enum ProcessExit {\n+    /// Normal termination with an exit status.\n+    ExitStatus(int),\n+\n+    /// Termination by signal, with the signal number.\n+    ExitSignal(int),\n+}\n+\n+impl fmt::Default for ProcessExit {\n+    /// Format a ProcessExit enum, to nicely present the information.\n+    fn fmt(obj: &ProcessExit, f: &mut fmt::Formatter) {\n+        match *obj {\n+            ExitStatus(code) =>  write!(f.buf, \"exit code: {}\", code),\n+            ExitSignal(code) =>  write!(f.buf, \"signal: {}\", code),\n+        }\n+    }\n+}\n+\n+impl ProcessExit {\n+    /// Was termination successful? Signal termination not considered a success,\n+    /// and success is defined as a zero exit status.\n+    pub fn success(&self) -> bool {\n+        return self.matches_exit_status(0);\n+    }\n+\n+    /// Checks whether this ProcessExit matches the given exit status.\n+    /// Termination by signal will never match an exit code.\n+    pub fn matches_exit_status(&self, wanted: int) -> bool {\n+        *self == ExitStatus(wanted)\n+    }\n+}\n+\n impl Process {\n     /// Creates a new pipe initialized, but not bound to any particular\n     /// source/destination\n@@ -122,7 +158,7 @@ impl Process {\n     /// Wait for the child to exit completely, returning the status that it\n     /// exited with. This function will continue to have the same return value\n     /// after it has been called at least once.\n-    pub fn wait(&mut self) -> int { self.handle.wait() }\n+    pub fn wait(&mut self) -> ProcessExit { self.handle.wait() }\n }\n \n impl Drop for Process {"}, {"sha": "9b1103b8a746bd7ec3810bc06f6a8295b63661d0", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "patch": "@@ -18,7 +18,7 @@ use c_str::CString;\n use ai = rt::io::net::addrinfo;\n use rt::io::IoError;\n use rt::io::signal::Signum;\n-use super::io::process::ProcessConfig;\n+use super::io::process::{ProcessConfig, ProcessExit};\n use super::io::net::ip::{IpAddr, SocketAddr};\n use path::Path;\n use super::io::{SeekStyle};\n@@ -201,7 +201,7 @@ pub trait RtioFileStream {\n pub trait RtioProcess {\n     fn id(&self) -> libc::pid_t;\n     fn kill(&mut self, signal: int) -> Result<(), IoError>;\n-    fn wait(&mut self) -> int;\n+    fn wait(&mut self) -> ProcessExit;\n }\n \n pub trait RtioPipe {"}, {"sha": "c9b33a14c527cbf0b454c7a53337b3f55722a773", "filename": "src/libstd/run.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "patch": "@@ -18,6 +18,7 @@ use libc::{pid_t, c_int};\n use libc;\n use prelude::*;\n use rt::io::process;\n+use rt::io::process::ProcessExit;\n use rt::io;\n use rt::io::Reader;\n use task;\n@@ -100,7 +101,7 @@ impl <'self> ProcessOptions<'self> {\n /// The output of a finished process.\n pub struct ProcessOutput {\n     /// The status (exit code) of the process.\n-    status: int,\n+    status: ProcessExit,\n \n     /// The data that the process wrote to stdout.\n     output: ~[u8],\n@@ -194,7 +195,7 @@ impl Process {\n      *\n      * If the child has already been finished then the exit code is returned.\n      */\n-    pub fn finish(&mut self) -> int { self.inner.wait() }\n+    pub fn finish(&mut self) -> ProcessExit { self.inner.wait() }\n \n     /**\n      * Closes the handle to stdin, waits for the child process to terminate, and\n@@ -296,7 +297,7 @@ impl Process {\n  *\n  * The process's exit code\n  */\n-pub fn process_status(prog: &str, args: &[~str]) -> int {\n+pub fn process_status(prog: &str, args: &[~str]) -> ProcessExit {\n     let mut prog = Process::new(prog, args, ProcessOptions {\n         env: None,\n         dir: None,\n@@ -340,8 +341,11 @@ mod tests {\n     #[test]\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n     fn test_process_status() {\n-        assert_eq!(run::process_status(\"false\", []), 1);\n-        assert_eq!(run::process_status(\"true\", []), 0);\n+        let mut status = run::process_status(\"false\", []);\n+        assert!(status.matches_exit_status(1));\n+\n+        status = run::process_status(\"true\", []);\n+        assert!(status.success());\n     }\n \n     #[test]\n@@ -352,7 +356,7 @@ mod tests {\n              = run::process_output(\"echo\", [~\"hello\"]);\n         let output_str = str::from_utf8(output);\n \n-        assert_eq!(status, 0);\n+        assert!(status.success());\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n         // FIXME #7224\n         if !running_on_valgrind() {\n@@ -367,7 +371,7 @@ mod tests {\n         let run::ProcessOutput {status, output, error}\n              = run::process_output(\"mkdir\", [~\".\"]);\n \n-        assert_eq!(status, 1);\n+        assert!(status.matches_exit_status(1));\n         assert_eq!(output, ~[]);\n         assert!(!error.is_empty());\n     }\n@@ -424,15 +428,15 @@ mod tests {\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n     fn test_finish_once() {\n         let mut prog = run::Process::new(\"false\", [], run::ProcessOptions::new());\n-        assert_eq!(prog.finish(), 1);\n+        assert!(prog.finish().matches_exit_status(1));\n     }\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n     fn test_finish_twice() {\n         let mut prog = run::Process::new(\"false\", [], run::ProcessOptions::new());\n-        assert_eq!(prog.finish(), 1);\n-        assert_eq!(prog.finish(), 1);\n+        assert!(prog.finish().matches_exit_status(1));\n+        assert!(prog.finish().matches_exit_status(1));\n     }\n \n     #[test]\n@@ -444,7 +448,7 @@ mod tests {\n             = prog.finish_with_output();\n         let output_str = str::from_utf8(output);\n \n-        assert_eq!(status, 0);\n+        assert!(status.success());\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n         // FIXME #7224\n         if !running_on_valgrind() {\n@@ -462,7 +466,7 @@ mod tests {\n \n         let output_str = str::from_utf8(output);\n \n-        assert_eq!(status, 0);\n+        assert!(status.success());\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n         // FIXME #7224\n         if !running_on_valgrind() {\n@@ -472,7 +476,7 @@ mod tests {\n         let run::ProcessOutput {status, output, error}\n             = prog.finish_with_output();\n \n-        assert_eq!(status, 0);\n+        assert!(status.success());\n         assert_eq!(output, ~[]);\n         // FIXME #7224\n         if !running_on_valgrind() {"}, {"sha": "2228f284fc31335df985c6676011d8e28658d01b", "filename": "src/test/run-pass/rtio-processes.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Ftest%2Frun-pass%2Frtio-processes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Ftest%2Frun-pass%2Frtio-processes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frtio-processes.rs?ref=86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "patch": "@@ -24,6 +24,7 @@\n // See #9341\n \n use std::rt::io;\n+use std::rt::io::process;\n use std::rt::io::process::{Process, ProcessConfig, CreatePipe, Ignored};\n use std::str;\n \n@@ -42,7 +43,7 @@ fn smoke() {\n     let p = Process::new(args);\n     assert!(p.is_some());\n     let mut p = p.unwrap();\n-    assert_eq!(p.wait(), 0);\n+    assert!(p.wait().success());\n }\n \n #[test]\n@@ -78,7 +79,27 @@ fn exit_reported_right() {\n     let p = Process::new(args);\n     assert!(p.is_some());\n     let mut p = p.unwrap();\n-    assert_eq!(p.wait(), 1);\n+    assert!(p.wait().matches_exit_status(1));\n+}\n+\n+#[test]\n+#[cfg(unix, not(target_os=\"android\"))]\n+fn signal_reported_right() {\n+    let io = ~[];\n+    let args = ProcessConfig {\n+        program: \"/bin/sh\",\n+        args: [~\"-c\", ~\"kill -1 $$\"],\n+        env: None,\n+        cwd: None,\n+        io: io,\n+    };\n+    let p = Process::new(args);\n+    assert!(p.is_some());\n+    let mut p = p.unwrap();\n+    match p.wait() {\n+        process::ExitSignal(1) => {},\n+        result => fail!(\"not terminated by signal 1 (instead, {})\", result),\n+    }\n }\n \n fn read_all(input: &mut Reader) -> ~str {\n@@ -100,7 +121,7 @@ fn run_output(args: ProcessConfig) -> ~str {\n     assert!(p.io[0].is_none());\n     assert!(p.io[1].is_some());\n     let ret = read_all(p.io[1].get_mut_ref() as &mut Reader);\n-    assert_eq!(p.wait(), 0);\n+    assert!(p.wait().success());\n     return ret;\n }\n \n@@ -152,6 +173,6 @@ fn stdin_works() {\n     p.io[0].get_mut_ref().write(\"foobar\".as_bytes());\n     p.io[0] = None; // close stdin;\n     let out = read_all(p.io[1].get_mut_ref() as &mut Reader);\n-    assert_eq!(p.wait(), 0);\n+    assert!(p.wait().success());\n     assert_eq!(out, ~\"foobar\\n\");\n }"}, {"sha": "e3dc4dcaadb411f553559216580e840114e1df88", "filename": "src/test/run-pass/signal-exit-status.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86787f8befe0f8971f27bd15be1e16ec7aa99e7e/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs?ref=86787f8befe0f8971f27bd15be1e16ec7aa99e7e", "patch": "@@ -0,0 +1,29 @@\n+// copyright 2013 the rust project developers. see the copyright\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/copyright.\n+//\n+// licensed under the apache license, version 2.0 <license-apache or\n+// http://www.apache.org/licenses/license-2.0> or the mit license\n+// <license-mit or http://opensource.org/licenses/mit>, at your\n+// option. this file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast\n+\n+use std::{os, run};\n+use std::rt::io::process;\n+\n+fn main() {\n+    let args = os::args();\n+    if args.len() >= 2 && args[1] == ~\"signal\" {\n+        // Raise a segfault.\n+        unsafe { *(0 as *mut int) = 0; }\n+    } else {\n+        let status = run::process_status(args[0], [~\"signal\"]);\n+        match status {\n+            process::ExitSignal(_) => {},\n+            _ => fail!(\"invalid termination (was not signalled): {:?}\", status)\n+        }\n+    }\n+}\n+"}]}