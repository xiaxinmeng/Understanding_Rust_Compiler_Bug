{"sha": "352577f4bb7c0214570db062d84dc69004348769", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1MjU3N2Y0YmI3YzAyMTQ1NzBkYjA2MmQ4NGRjNjkwMDQzNDg3Njk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-09T20:56:19Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-09T20:56:19Z"}, "message": "Initial pass review comments", "tree": {"sha": "7e4e0e77578865cf5b104161d25cc0a2e881d612", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e4e0e77578865cf5b104161d25cc0a2e881d612"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/352577f4bb7c0214570db062d84dc69004348769", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/352577f4bb7c0214570db062d84dc69004348769", "html_url": "https://github.com/rust-lang/rust/commit/352577f4bb7c0214570db062d84dc69004348769", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/352577f4bb7c0214570db062d84dc69004348769/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "html_url": "https://github.com/rust-lang/rust/commit/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5"}], "stats": {"total": 456, "additions": 251, "deletions": 205}, "files": [{"sha": "e316fd5f3e6db965bb1d29bb21733b97a867eb67", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -320,7 +320,7 @@ for ::middle::const_val::ConstVal<'tcx> {\n \n impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n \n-impl_stable_hash_for!(tuple_struct ty::GeneratorInterior<'tcx> { ty });\n+impl_stable_hash_for!(struct ty::GeneratorInterior<'tcx> { witness });\n \n impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n     parent,"}, {"sha": "e688af4316032eaf948e7fa83e72757457535450", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -411,8 +411,13 @@ pub struct LocalDecl<'tcx> {\n     /// True if this corresponds to a user-declared local variable.\n     pub is_user_variable: bool,\n \n-    /// True if this an internal local.\n+    /// True if this is an internal local.\n     /// Such locals are not checked against the legal types in a generator.\n+    ///\n+    /// Scalar state variables created by optimizations (e.g. nonzeroing drop\n+    /// flags) should not be included in generator OIBIT computations.\n+    /// Therefore, we mark them as `internal` so we can ignore them when\n+    /// sanity-checking the OIBIT list.\n     pub internal: bool,\n \n     /// Type of this local."}, {"sha": "52c8b67278e20d48f80a9fd3b085486b63745bf3", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -2126,7 +2126,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             ty::TyGenerator(def_id, ref substs, interior) => {\n-                let witness = iter::once(interior.witness());\n+                let witness = iter::once(interior.witness);\n                 substs.upvar_tys(def_id, self.tcx()).chain(witness).collect()\n             }\n "}, {"sha": "f40e1d370a99504ab0aec92780d284fd6d72d164", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -89,7 +89,7 @@ impl FlagComputation {\n                 self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n                 self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n                 self.add_substs(&substs.substs);\n-                self.add_ty(interior.witness());\n+                self.add_ty(interior.witness);\n             }\n \n             &ty::TyClosure(_, ref substs) => {"}, {"sha": "657ed4077911c8cd0dd1ea353cce5b366c230fe6", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -122,7 +122,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 // But generators can have additional interior types\n-                self.compute_components(interior.witness(), out);\n+                self.compute_components(interior.witness, out);\n             }\n \n             // OutlivesTypeParameterEnv -- the actual checking that `X:'a`"}, {"sha": "da94eddf295ea8c4b2eb2a9b75735e3339b1b879", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -531,7 +531,7 @@ impl<'tcx> Relate<'tcx> for ty::GeneratorInterior<'tcx> {\n                            -> RelateResult<'tcx, ty::GeneratorInterior<'tcx>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n-        let interior = relation.relate(&a.witness(), &b.witness())?;\n+        let interior = relation.relate(&a.witness, &b.witness)?;\n         Ok(ty::GeneratorInterior::new(interior))\n     }\n }"}, {"sha": "cbb0a45cf1e1478c7c8b99aae98adf49c8030867", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -232,8 +232,8 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n impl<'a, 'tcx> Lift<'tcx> for ty::GeneratorInterior<'a> {\n     type Lifted = ty::GeneratorInterior<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.witness()).map(|witness| {\n-            ty::GeneratorInterior(witness)\n+        tcx.lift(&self.witness).map(|witness| {\n+            ty::GeneratorInterior { witness }\n         })\n     }\n }\n@@ -737,11 +737,11 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for ty::GeneratorInterior<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::GeneratorInterior(self.0.fold_with(folder))\n+        ty::GeneratorInterior::new(self.witness.fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.0.visit_with(visitor)\n+        self.witness.visit_with(visitor)\n     }\n }\n "}, {"sha": "9898ce5d73daa79ffce9b1d6d8869284e1cc603c", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -295,19 +295,17 @@ impl<'a, 'gcx, 'tcx> ClosureSubsts<'tcx> {\n /// The state transformation MIR pass may only produce layouts which mention types in this tuple.\n /// Upvars are not counted here.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct GeneratorInterior<'tcx>(pub Ty<'tcx>);\n+pub struct GeneratorInterior<'tcx> {\n+    pub witness: Ty<'tcx>,\n+}\n \n impl<'tcx> GeneratorInterior<'tcx> {\n     pub fn new(witness: Ty<'tcx>) -> GeneratorInterior<'tcx> {\n-        GeneratorInterior(witness)\n-    }\n-\n-    pub fn witness(&self) -> Ty<'tcx> {\n-        self.0\n+        GeneratorInterior { witness }\n     }\n \n     pub fn as_slice(&self) -> &'tcx Slice<Ty<'tcx>> {\n-        match self.0.sty {\n+        match self.witness.sty {\n             ty::TyTuple(s, _) => s,\n             _ => bug!(),\n         }\n@@ -638,10 +636,8 @@ pub struct GenSig<'tcx> {\n     pub return_ty: Ty<'tcx>,\n }\n \n-#[allow(warnings)]\n pub type PolyGenSig<'tcx> = Binder<GenSig<'tcx>>;\n \n-#[allow(warnings)]\n impl<'tcx> PolyGenSig<'tcx> {\n     pub fn yield_ty(&self) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|sig| sig.yield_ty)"}, {"sha": "67ec8d2ae63adc4592156fdc1f89550f8f113180", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -570,7 +570,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             ty::TyGenerator(def_id, substs, interior) => {\n-                substs.upvar_tys(def_id, self).chain(iter::once(interior.witness())).map(|ty| {\n+                substs.upvar_tys(def_id, self).chain(iter::once(interior.witness)).map(|ty| {\n                     self.dtorck_constraint_for_ty(span, for_ty, depth+1, ty)\n                 }).collect()\n             }"}, {"sha": "bfabacdb1721496be8eb7bbcd18ff84b5312ac6d", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -114,7 +114,7 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         }\n         ty::TyGenerator(_, ref substs, ref interior) => {\n             stack.extend(substs.substs.types().rev());\n-            stack.push(interior.witness());\n+            stack.push(interior.witness);\n         }\n         ty::TyTuple(ts, _) => {\n             stack.extend(ts.iter().cloned().rev());"}, {"sha": "ed72f2429487f49a739342072b39dba970bf675b", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -717,7 +717,7 @@ impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n \n impl<'tcx> fmt::Display for ty::GeneratorInterior<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.0)\n+        self.witness.fmt(f)\n     }\n }\n "}, {"sha": "9fa47cee659583f091b0a0448d3dc690a9d547e9", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -9,9 +9,11 @@\n // except according to those terms.\n \n use std::fmt;\n+use std::iter;\n use std::marker::PhantomData;\n use std::mem;\n use std::ops::{Deref, DerefMut, Range};\n+use std::slice;\n use bitslice::{BitSlice, Word};\n use bitslice::{bitwise, Union, Subtract};\n use indexed_vec::Idx;\n@@ -161,4 +163,41 @@ impl<T: Idx> IdxSet<T> {\n     pub fn subtract(&mut self, other: &IdxSet<T>) -> bool {\n         bitwise(self.words_mut(), other.words(), &Subtract)\n     }\n+\n+    pub fn iter(&self) -> Iter<T> {\n+        Iter {\n+            cur: None,\n+            iter: self.words().iter().enumerate(),\n+            _pd: PhantomData,\n+        }\n+    }\n+}\n+\n+pub struct Iter<'a, T: Idx> {\n+    cur: Option<(Word, usize)>,\n+    iter: iter::Enumerate<slice::Iter<'a, Word>>,\n+    _pd: PhantomData<fn(&T)>,\n+}\n+\n+impl<'a, T: Idx> Iterator for Iter<'a, T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        let word_bits = mem::size_of::<Word>() * 8;\n+        loop {\n+            if let Some((ref mut word, offset)) = self.cur {\n+                let bit_pos = word.trailing_zeros();\n+                if bit_pos != word_bits as u32 {\n+                    let bit = 1 << bit_pos;\n+                    *word ^= bit;\n+                    return Some(T::new(bit + offset))\n+                }\n+            }\n+\n+            match self.iter.next() {\n+                Some((i, word)) => self.cur = Some((*word, word_bits * i)),\n+                None => return None,\n+            }\n+        }\n+    }\n }"}, {"sha": "a81103213b841f92d93c1da62d16d4bcd1a3f507", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -703,57 +703,57 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let region = cx.tcx.mk_region(region);\n \n             let self_expr = if let ty::TyClosure(..) = closure_ty.sty {\n-            match cx.tcx.closure_kind(closure_def_id) {\n-                ty::ClosureKind::Fn => {\n-                    let ref_closure_ty = cx.tcx.mk_ref(region,\n-                                                       ty::TypeAndMut {\n-                                                           ty: closure_ty,\n-                                                           mutbl: hir::MutImmutable,\n-                                                       });\n-                    Expr {\n-                        ty: closure_ty,\n-                        temp_lifetime: temp_lifetime,\n-                        span: expr.span,\n-                        kind: ExprKind::Deref {\n-                            arg: Expr {\n-                                ty: ref_closure_ty,\n-                                temp_lifetime: temp_lifetime,\n-                                span: expr.span,\n-                                kind: ExprKind::SelfRef,\n-                            }\n-                            .to_ref(),\n-                        },\n+                match cx.tcx.closure_kind(closure_def_id) {\n+                    ty::ClosureKind::Fn => {\n+                        let ref_closure_ty = cx.tcx.mk_ref(region,\n+                                                           ty::TypeAndMut {\n+                                                               ty: closure_ty,\n+                                                               mutbl: hir::MutImmutable,\n+                                                           });\n+                        Expr {\n+                            ty: closure_ty,\n+                            temp_lifetime: temp_lifetime,\n+                            span: expr.span,\n+                            kind: ExprKind::Deref {\n+                                arg: Expr {\n+                                    ty: ref_closure_ty,\n+                                    temp_lifetime: temp_lifetime,\n+                                    span: expr.span,\n+                                    kind: ExprKind::SelfRef,\n+                                }\n+                                .to_ref(),\n+                            },\n+                        }\n                     }\n-                }\n-                ty::ClosureKind::FnMut => {\n-                    let ref_closure_ty = cx.tcx.mk_ref(region,\n-                                                       ty::TypeAndMut {\n-                                                           ty: closure_ty,\n-                                                           mutbl: hir::MutMutable,\n-                                                       });\n-                    Expr {\n-                        ty: closure_ty,\n-                        temp_lifetime: temp_lifetime,\n-                        span: expr.span,\n-                        kind: ExprKind::Deref {\n-                            arg: Expr {\n-                                ty: ref_closure_ty,\n-                                temp_lifetime: temp_lifetime,\n-                                span: expr.span,\n-                                kind: ExprKind::SelfRef,\n-                            }.to_ref(),\n-                        },\n+                    ty::ClosureKind::FnMut => {\n+                        let ref_closure_ty = cx.tcx.mk_ref(region,\n+                                                           ty::TypeAndMut {\n+                                                               ty: closure_ty,\n+                                                               mutbl: hir::MutMutable,\n+                                                           });\n+                        Expr {\n+                            ty: closure_ty,\n+                            temp_lifetime: temp_lifetime,\n+                            span: expr.span,\n+                            kind: ExprKind::Deref {\n+                                arg: Expr {\n+                                    ty: ref_closure_ty,\n+                                    temp_lifetime: temp_lifetime,\n+                                    span: expr.span,\n+                                    kind: ExprKind::SelfRef,\n+                                }.to_ref(),\n+                            },\n+                        }\n                     }\n-                }\n-                ty::ClosureKind::FnOnce => {\n-                    Expr {\n-                        ty: closure_ty,\n-                        temp_lifetime: temp_lifetime,\n-                        span: expr.span,\n-                        kind: ExprKind::SelfRef,\n+                    ty::ClosureKind::FnOnce => {\n+                        Expr {\n+                            ty: closure_ty,\n+                            temp_lifetime: temp_lifetime,\n+                            span: expr.span,\n+                            kind: ExprKind::SelfRef,\n+                        }\n                     }\n                 }\n-            }\n             } else {\n                 Expr {\n                     ty: closure_ty,"}, {"sha": "f57ba0cf42a1223b6bacb211b10e13dfcfe93ffd", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 22, "deletions": 87, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -10,8 +10,6 @@\n \n //! Transforms generators into state machines\n \n-#![allow(warnings)]\n-\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::const_val::ConstVal;\n@@ -23,11 +21,11 @@ use rustc::ty::subst::{Kind, Substs};\n use util::dump_mir;\n use util::liveness;\n use rustc_const_math::ConstInt;\n-use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::Idx;\n use std::collections::HashMap;\n use std::borrow::Cow;\n use std::iter::once;\n+use std::mem;\n use syntax::ast::NodeId;\n use transform::simplify;\n \n@@ -150,7 +148,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n             }\n         });\n \n-        ret_val.map(|(state_idx, resume, v, drop)| {\n+        if let Some((state_idx, resume, v, drop)) = ret_val {\n             let bb_idx = {\n                 let bb_targets = &mut self.bb_targets;\n                 let bb_target = &mut self.bb_target_count;\n@@ -168,54 +166,12 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n                     self.make_state(state_idx, v)),\n             });\n             data.terminator.as_mut().unwrap().kind = TerminatorKind::Return;\n-        });\n+        }\n \n         self.super_basic_block_data(block, data);\n     }\n }\n \n-fn get_body_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: NodeId) -> (bool, hir::BodyId) {\n-    // Figure out what primary body this item has.\n-    match tcx.hir.get(node_id) {\n-        hir::map::NodeItem(item) => {\n-            match item.node {\n-                hir::ItemConst(_, body) |\n-                hir::ItemStatic(_, _, body) |\n-                hir::ItemFn(.., body) => (false, body),\n-                _ => bug!(),\n-            }\n-        }\n-        hir::map::NodeTraitItem(item) => {\n-            match item.node {\n-                hir::TraitItemKind::Const(_, Some(body)) |\n-                hir::TraitItemKind::Method(_,\n-                    hir::TraitMethod::Provided(body)) => (false, body),\n-                _ => bug!(),\n-            }\n-        }\n-        hir::map::NodeImplItem(item) => {\n-            match item.node {\n-                hir::ImplItemKind::Const(_, body) |\n-                hir::ImplItemKind::Method(_, body) => (false, body),\n-                _ => bug!(),\n-            }\n-        }\n-        hir::map::NodeExpr(expr) => {\n-            // FIXME(eddyb) Closures should have separate\n-            // function definition IDs and expression IDs.\n-            // Type-checking should not let closures get\n-            // this far in a constant position.\n-            // Assume that everything other than closures\n-            // is a constant \"initializer\" expression.\n-            match expr.node {\n-                hir::ExprClosure(_, _, body, _, _) => (true, body),\n-                _ => (false, hir::BodyId { node_id: expr.id })\n-            }\n-        }\n-        _ => bug!(),\n-    }\n-}\n-\n fn ensure_generator_state_argument<'a, 'tcx>(\n                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 node_id: NodeId,\n@@ -281,7 +237,6 @@ fn replace_result_variable<'tcx>(ret_ty: Ty<'tcx>,\n fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                mir: &Mir<'tcx>,\n                                                source: MirSource) -> liveness::LocalSet {\n-    use rustc_data_structures::indexed_set::IdxSetBuf;\n     let mut set = liveness::LocalSet::new_empty(mir.local_decls.len());\n     let result = liveness::liveness_of_locals(mir);\n     liveness::dump_mir(tcx, \"generator_liveness\", source, mir, &result);\n@@ -299,18 +254,12 @@ fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            def_id: DefId,\n                             source: MirSource,\n                             interior: GeneratorInterior<'tcx>,\n                             mir: &mut Mir<'tcx>)\n     -> (HashMap<Local, (Ty<'tcx>, usize)>, GeneratorLayout<'tcx>)\n {\n-    let source_info = SourceInfo {\n-        span: mir.span,\n-        scope: ARGUMENT_VISIBILITY_SCOPE,\n-    };\n-\n-    let mut live_locals = locals_live_across_suspend_points(tcx, mir, source);\n+    let live_locals = locals_live_across_suspend_points(tcx, mir, source);\n \n     let allowed = tcx.erase_regions(&interior.as_slice());\n \n@@ -319,34 +268,23 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             continue;\n         }\n         if !allowed.contains(&decl.ty) {\n-            tcx.sess.span_warn(mir.span,\n-                &format!(\"generator contains type {} in MIR, but typeck only knows about {}\",\n-                    decl.ty,\n-                    interior));\n+            span_bug!(mir.span,\n+                      \"Broken MIR: generator contains type {} in MIR, \\\n+                       but typeck only knows about {}\",\n+                      decl.ty,\n+                      interior);\n         }\n     }\n \n     let upvar_len = mir.upvar_decls.len();\n-    let live_decls : Vec<_> = mir.local_decls\n-        .iter_enumerated_mut()\n-        .filter(|&(local, _)| live_locals.contains(&local))\n-        .collect();\n-\n-    let mut remap = HashMap::new();\n-    let unit = tcx.mk_nil();\n-    let mut vars: Vec<_> = live_decls.into_iter().enumerate().map(|(idx, (local, decl))| {\n-        let var = decl.clone();\n-        *decl = LocalDecl {\n-            mutability: Mutability::Mut,\n-            ty: unit,\n-            name: None,\n-            source_info,\n-            internal: false,\n-            is_user_variable: false,\n-        };\n-        remap.insert(local, (var.ty, upvar_len + 1 + idx));\n-        var\n-    }).collect();\n+    let dummy_local = LocalDecl::new_internal(tcx.mk_nil(), mir.span);\n+    let live_decls = live_locals.iter().map(|local| {\n+        let var = mem::replace(&mut mir.local_decls[local], dummy_local.clone());\n+        (local, var)\n+    });\n+    let (remap, vars) = live_decls.enumerate().map(|(idx, (local, var))| {\n+        ((local, (var.ty, upvar_len + 1 + idx)), var)\n+    }).unzip();\n \n     let layout = GeneratorLayout {\n         fields: vars\n@@ -369,7 +307,7 @@ fn insert_entry_point<'tcx>(mir: &mut Mir<'tcx>,\n fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       def_id: DefId,\n                                       mir: &mut Mir<'tcx>) {\n-    use util::elaborate_drops::{elaborate_drop, Unwind, DropElaborator, DropStyle, DropFlagMode};\n+    use util::elaborate_drops::{elaborate_drop, Unwind};\n     use util::patch::MirPatch;\n     use shim::DropShimElaborator;\n \n@@ -418,7 +356,6 @@ fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn generate_drop<'a, 'tcx>(\n                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 transform: &TransformVisitor<'a, 'tcx>,\n-                node_id: NodeId,\n                 def_id: DefId,\n                 source: MirSource,\n                 gen_ty: Ty<'tcx>,\n@@ -439,7 +376,7 @@ fn generate_drop<'a, 'tcx>(\n         is_cleanup: false,\n     });\n \n-    let mut cases: Vec<_> = transform.bb_targets.iter().filter_map(|(&(r, u), &s)| {\n+    let mut cases: Vec<_> = transform.bb_targets.iter().filter_map(|(&(_, u), &s)| {\n         u.map(|d| (s, d))\n     }).collect();\n \n@@ -581,10 +518,9 @@ fn insert_resume_after_return<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cleanup\n }\n \n-fn generate_resume<'a, 'tcx>(\n+fn generate_entry_point<'a, 'tcx>(\n                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 mut transform: TransformVisitor<'a, 'tcx>,\n-                node_id: NodeId,\n                 def_id: DefId,\n                 source: MirSource,\n                 cleanup: Option<BasicBlock>,\n@@ -721,7 +657,7 @@ impl MirPass for StateTransform {\n \n         let new_ret_local = replace_result_variable(ret_ty, mir);\n \n-        let (remap, layout) = compute_layout(tcx, def_id, source, interior, mir);\n+        let (remap, layout) = compute_layout(tcx, source, interior, mir);\n \n         let tail_block = BasicBlock::new(mir.basic_blocks().len());\n \n@@ -763,7 +699,6 @@ impl MirPass for StateTransform {\n \n         generate_drop(tcx,\n                       &transform,\n-                      node_id,\n                       def_id,\n                       source,\n                       gen_ty,\n@@ -772,6 +707,6 @@ impl MirPass for StateTransform {\n \n         mir.generator_drop = Some(box drop_impl);\n \n-        generate_resume(tcx, transform, node_id, def_id, source, arg_cleanup, mir);\n+        generate_entry_point(tcx, transform, def_id, source, arg_cleanup, mir);\n     }\n }"}, {"sha": "fd15c90dc901360ab6c684f2770b014e08bd8062", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -9,6 +9,29 @@\n // except according to those terms.\n \n //! Liveness analysis which computes liveness of MIR local variables at the boundary of basic blocks\n+//!\n+//! This analysis considers references as being used only at the point of the\n+//! borrow. This means that this does not track uses because of references that\n+//! already exist:\n+//!\n+//! ```Rust\n+//!     fn foo() {\n+//!         x = 0;\n+//!         // `x` is live here\n+//!         GLOBAL = &x: *const u32;\n+//!         // but not here, even while it can be accessed through `GLOBAL`.\n+//!         foo();\n+//!         x = 1;\n+//!         // `x` is live again here, because it is assigned to `OTHER_GLOBAL`\n+//!         OTHER_GLOBAL = &x: *const u32;\n+//!         // ...\n+//!     }\n+//! ```\n+//!\n+//! This means that users of this analysis still have to check whether\n+//! pre-existing references can be used to access the value (e.g. at movable\n+//! generator yield points, all pre-existing references are invalidated, so this\n+//! doesn't matter).\n \n use rustc::mir::*;\n use rustc::mir::visit::{LvalueContext, Visitor};\n@@ -60,7 +83,7 @@ impl<'tcx> Visitor<'tcx> for BlockInfoVisitor {\n                 // Borrows only consider their local used at the point of the borrow.\n                 // This won't affect the results since we use this analysis for generators\n                 // and we only care about the result at suspension points. Borrows cannot\n-                // cross suspension points so this behavoir is unproblematic.\n+                // cross suspension points so this behavior is unproblematic.\n                 LvalueContext::Borrow { .. } |\n \n                 LvalueContext::Inspect |"}, {"sha": "0811783a9e57f7b75c211652c2398cc84b346c81", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -348,7 +348,9 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n \n             write!(w, \") -> {}\", mir.return_ty)\n         }\n-        _ => {\n+        MirSource::Const(..) |\n+        MirSource::Static(..) |\n+        MirSource::Promoted(..) => {\n             assert_eq!(mir.arg_count, 0);\n             write!(w, \": {} =\", mir.return_ty)\n         }"}, {"sha": "10b66fb1991087a351150bcc8ec921a8cd7ce349", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -287,9 +287,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n \n     let hash = get_symbol_hash(tcx, Some(def_id), instance_ty, Some(substs));\n \n-    let buffer = SymbolPathBuffer::from_interned(tcx.def_symbol_name(def_id));\n-\n-    buffer.finish(hash)\n+    SymbolPathBuffer::from_interned(tcx.def_symbol_name(def_id)).finish(hash)\n }\n \n // Follow C++ namespace-mangling style, see"}, {"sha": "6753d42b0c5499de7fdc44cd89c6ef71689e0d44", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -8,14 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use log;\n+use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, Body, Pat, PatKind, Expr};\n-use rustc::hir::def_id::DefId;\n-use rustc::ty::Ty;\n use rustc::middle::region::{RegionMaps, CodeExtent};\n-use util::nodemap::FxHashSet;\n+use rustc::ty::Ty;\n use std::rc::Rc;\n use super::FnCtxt;\n+use util::nodemap::FxHashSet;\n \n struct InteriorVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n@@ -28,36 +29,34 @@ impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n         use syntax_pos::DUMMY_SP;\n \n         if scope.map(|s| self.fcx.tcx.yield_in_extent(s).is_some()).unwrap_or(true) {\n-            if self.fcx.tcx.sess.verbose() {\n+            if log_enabled!(log::LogLevel::Debug) {\n                 if let Some(s) = scope {\n-                    self.fcx.tcx.sess.span_warn(s.span(&self.fcx.tcx.hir).unwrap_or(DUMMY_SP),\n-                        &format!(\"type in generator with scope = {:?}, type = {:?}\",\n-                                 scope,\n-                                 self.fcx.resolve_type_vars_if_possible(&ty)));\n+                    let span = s.span(&self.fcx.tcx.hir).unwrap_or(DUMMY_SP);\n+                    debug!(\"type in generator with scope = {:?}, type = {:?}, span = {:?}\",\n+                           scope,\n+                           self.fcx.resolve_type_vars_if_possible(&ty),\n+                           span);\n                 } else {\n-                    self.fcx.tcx.sess.span_warn(DUMMY_SP,\n-                        &format!(\"type in generator WITHOUT scope, type = {:?}\",\n-                                 self.fcx.resolve_type_vars_if_possible(&ty)));\n+                    debug!(\"type in generator WITHOUT scope, type = {:?}\",\n+                           self.fcx.resolve_type_vars_if_possible(&ty));\n                 }\n                 if let Some(e) = expr {\n-                    self.fcx.tcx.sess.span_warn(e.span,\n-                        &format!(\"type from expression: {:?}\", e));\n+                    debug!(\"type from expression: {:?}, span={:?}\", e, e.span);\n                 }\n             }\n             self.types.insert(ty);\n-        } else if self.fcx.tcx.sess.verbose() {\n+        } else {\n             if let Some(e) = expr {\n-                self.fcx.tcx.sess.span_warn(e.span,\n-                    &format!(\"NO type from expression: {:?}\", e));\n+                debug!(\"NO type from expression: {:?}, span = {:?}\", e, e.span);\n             }\n         }\n     }\n }\n \n-pub fn find_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-                                     def_id: DefId,\n-                                     body_id: hir::BodyId,\n-                                     witness: Ty<'tcx>) {\n+pub fn resolve_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n+                                        def_id: DefId,\n+                                        body_id: hir::BodyId,\n+                                        witness: Ty<'tcx>) {\n     let body = fcx.tcx.hir.body(body_id);\n     let mut visitor = InteriorVisitor {\n         fcx,\n@@ -74,10 +73,7 @@ pub fn find_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n \n     let tuple = fcx.tcx.intern_tup(&types, false);\n \n-    if fcx.tcx.sess.verbose() {\n-        fcx.tcx.sess.span_warn(body.value.span,\n-            &format!(\"Types in generator {:?}\", tuple));\n-    }\n+    debug!(\"Types in generator {:?}, span = {:?}\", tuple, body.value.span);\n \n     // Unify the tuple with the witness\n     match fcx.at(&fcx.misc(body.value.span), fcx.param_env).eq(witness, tuple) {"}, {"sha": "fee10f503780a643abf43a64b925d505cfa8267f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -892,7 +892,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         fcx.closure_analyze(body);\n         fcx.select_obligations_where_possible();\n         fcx.check_casts();\n-        fcx.find_generator_interiors(def_id);\n+        fcx.resolve_generator_interiors(def_id);\n         fcx.select_all_obligations_or_error();\n \n         if fn_decl.is_some() {\n@@ -2107,10 +2107,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn find_generator_interiors(&self, def_id: DefId) {\n+    fn resolve_generator_interiors(&self, def_id: DefId) {\n         let mut deferred_generator_interiors = self.deferred_generator_interiors.borrow_mut();\n         for (body_id, witness) in deferred_generator_interiors.drain(..) {\n-            generator_interior::find_interior(self, def_id, body_id, witness);\n+            generator_interior::resolve_interior(self, def_id, body_id, witness);\n         }\n     }\n \n@@ -2677,8 +2677,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_expr_has_type_or_error(&self,\n-                               expr: &'gcx hir::Expr,\n-                               expected: Ty<'tcx>) -> Ty<'tcx> {\n+                                        expr: &'gcx hir::Expr,\n+                                        expected: Ty<'tcx>) -> Ty<'tcx> {\n         self.check_expr_meets_expectation_or_error(expr, ExpectHasType(expected))\n     }\n \n@@ -3138,13 +3138,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return field_ty;\n         }\n \n-                if tuple_like {\n+        if tuple_like {\n             type_error_struct!(self.tcx().sess, expr.span, expr_t, E0612,\n-                               \"attempted out-of-bounds tuple index `{}` on type `{}`\",\n-                               idx.node, expr_t).emit();\n-                } else {\n+                \"attempted out-of-bounds tuple index `{}` on type `{}`\",\n+                idx.node, expr_t).emit();\n+        } else {\n             self.no_such_field_err(expr.span, idx.node, expr_t).emit();\n-                }\n+        }\n \n         self.tcx().types.err\n     }\n@@ -3733,14 +3733,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // Only check this if not in an `if` condition, as the\n                     // mistyped comparison help is more appropriate.\n                     if !self.tcx.expr_is_lval(&lhs) {\n-                struct_span_err!(\n-                            self.tcx.sess, expr.span, E0070,\n-                    \"invalid left-hand side expression\")\n-                .span_label(\n-                    expr.span,\n-                    \"left-hand of expression not valid\")\n-                .emit();\n-            }\n+                        struct_span_err!(self.tcx.sess, expr.span, E0070,\n+                                         \"invalid left-hand side expression\")\n+                            .span_label(expr.span, \"left-hand of expression not valid\")\n+                            .emit();\n+                    }\n                 }\n             }\n "}, {"sha": "519c34cd0edbf90a2cf8a5ad2d9d144863880ee0", "filename": "src/test/run-pass/generator/auxiliary/xcrate.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Ftest%2Frun-pass%2Fgenerator%2Fauxiliary%2Fxcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Ftest%2Frun-pass%2Fgenerator%2Fauxiliary%2Fxcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fauxiliary%2Fxcrate.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait, conservative_impl_trait)]\n+\n+use std::ops::Generator;\n+\n+fn bar() -> bool {\n+    false\n+}\n+\n+pub fn foo() -> impl Generator<Yield = (), Return = ()> {\n+    || {\n+        if bar() {\n+            yield;\n+        }\n+    }\n+}"}, {"sha": "53cd3235d9d0ceb51d8b4abaf27751a413364a2c", "filename": "src/test/run-pass/generator/panic-drops.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-drops.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -24,10 +24,14 @@ impl Drop for B {\n     }\n }\n \n+fn bool_true() -> bool {\n+    true\n+}\n+\n fn main() {\n     let b = B;\n     let mut foo = || {\n-        if true {\n+        if bool_true() {\n             panic!();\n         }\n         drop(b);\n@@ -42,7 +46,7 @@ fn main() {\n     assert_eq!(A.load(Ordering::SeqCst), 1);\n \n     let mut foo = || {\n-        if true {\n+        if bool_true() {\n             panic!();\n         }\n         drop(B);"}, {"sha": "5d6cdee1a242f1dbd15977d3501beb4c6f2a8e97", "filename": "src/test/run-pass/generator/xcrate.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Ftest%2Frun-pass%2Fgenerator%2Fxcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Ftest%2Frun-pass%2Fgenerator%2Fxcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fxcrate.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:xcrate.rs\n+\n+#![feature(generators, generator_trait)]\n+\n+extern crate xcrate;\n+\n+use std::ops::{GeneratorState, Generator};\n+\n+fn main() {\n+    let mut foo = xcrate::foo();\n+\n+    match foo.resume() {\n+        GeneratorState::Complete(()) => {}\n+        s => panic!(\"bad state: {:?}\", s),\n+    }\n+}"}, {"sha": "de10bdef4aee0585d496f20f497fd07c1b773638", "filename": "src/test/ui/generator/borrowing.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "previous_filename": "src/test/compile-fail/generator/borrowing.rs"}, {"sha": "a7e98fe4509278a699b3cff9e03dcd2832297fd1", "filename": "src/test/ui/generator/no-arguments-on-generators.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Ftest%2Fui%2Fgenerator%2Fno-arguments-on-generators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Ftest%2Fui%2Fgenerator%2Fno-arguments-on-generators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fno-arguments-on-generators.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "previous_filename": "src/test/compile-fail/generator/no-arguments-on-generators.rs"}, {"sha": "0419758d8ea17ac32e4befab15d0578efcee18f4", "filename": "src/test/ui/generator/not-send-sync.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "previous_filename": "src/test/compile-fail/generator/not-send-sync.rs"}, {"sha": "e166d2651597565eca1ae0d4917acee885905080", "filename": "src/test/ui/generator/yield-in-const.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-const.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "previous_filename": "src/test/compile-fail/generator/yield-in-const.rs"}, {"sha": "2f6c5a9ef754c317390f4356d8c7eed132828498", "filename": "src/test/ui/generator/yield-in-function.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-function.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "previous_filename": "src/test/compile-fail/generator/yield-in-function.rs"}, {"sha": "823a2aa425e2cfdfeff4db50ca127bd8e094e2f0", "filename": "src/test/ui/generator/yield-in-static.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/352577f4bb7c0214570db062d84dc69004348769/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352577f4bb7c0214570db062d84dc69004348769/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-static.rs?ref=352577f4bb7c0214570db062d84dc69004348769", "previous_filename": "src/test/compile-fail/generator/yield-in-static.rs"}]}