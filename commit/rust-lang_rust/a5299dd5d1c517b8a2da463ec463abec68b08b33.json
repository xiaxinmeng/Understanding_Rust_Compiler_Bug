{"sha": "a5299dd5d1c517b8a2da463ec463abec68b08b33", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1Mjk5ZGQ1ZDFjNTE3YjhhMmRhNDYzZWM0NjNhYmVjNjhiMDhiMzM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-20T14:26:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-20T14:26:34Z"}, "message": "Rollup merge of #63216 - oconnor663:take_read_to_end, r=sfackler\n\navoid unnecessary reservations in std::io::Take::read_to_end\n\nPrevously the `read_to_end` implementation for `std::io::Take` used its\nown `limit` as a cap on the `reservation_size`. However, that could\nstill result in an over-allocation like this:\n\n1. Call `reader.take(5).read_to_end(&mut vec)`.\n2. `read_to_end_with_reservation` reserves 5 bytes and calls `read`.\n3. `read` writes 5 bytes.\n4. `read_to_end_with_reservation` reserves 5 bytes and calls `read`.\n5. `read` writes 0 bytes.\n6. The read loop ends with `vec` having length 5 and capacity 10.\n\nThe reservation of 5 bytes was correct for the read at step 2 but\nunnecessary for the read at step 4. By that second read, `Take::limit`\nis 0, but the `read_to_end_with_reservation` loop is still using the\nsame `reservation_size` it started with.\n\nSolve this by having `read_to_end_with_reservation` take a closure,\nwhich lets it get a fresh `reservation_size` for each read. This is an\nimplementation detail which doesn't affect any public API.", "tree": {"sha": "05479e6089d60e97f2536b8571aca6db4ae1c0cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05479e6089d60e97f2536b8571aca6db4ae1c0cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5299dd5d1c517b8a2da463ec463abec68b08b33", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdXAMbCRBK7hj4Ov3rIwAAdHIIAABapXvSfNkQ2rf3vTncznPe\n4tn7me3L1Iq8Qu8Nn8uWD/eYyzMfD9su9WfRzp+Xhg9ESi+3Er1lLi8wDlcAOzNp\naogj479AS35lsSpmdCYXE/l7bxmKXwqAJIIKBEkX5GghkKMFd61EsyJVB+h/g++e\nxSOfGl2pPU8NFSx4l1/m7+MD7uz7DdLuhSqB+SELlFO72sprcsHzX7KbvAP3D8lU\nSavcDaxdY2cojA14Gm2jRtoyk0OazO0lC6F/Q/Z2Dtouu2zJo/3Fd5aj2L37oNSR\nCcx1ykg8ZUrHNLGTsiN0//IEJf+EnyZa0/O4pui1FfEpUjEzQfVMOXMG5skn6AY=\n=tbG0\n-----END PGP SIGNATURE-----\n", "payload": "tree 05479e6089d60e97f2536b8571aca6db4ae1c0cf\nparent 14890954ce17c44d944eda988c5a64bb4c5ec9eb\nparent edb5214b29cd7de06dd10f673986d38e568b077c\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1566311194 +0200\ncommitter GitHub <noreply@github.com> 1566311194 +0200\n\nRollup merge of #63216 - oconnor663:take_read_to_end, r=sfackler\n\navoid unnecessary reservations in std::io::Take::read_to_end\n\nPrevously the `read_to_end` implementation for `std::io::Take` used its\nown `limit` as a cap on the `reservation_size`. However, that could\nstill result in an over-allocation like this:\n\n1. Call `reader.take(5).read_to_end(&mut vec)`.\n2. `read_to_end_with_reservation` reserves 5 bytes and calls `read`.\n3. `read` writes 5 bytes.\n4. `read_to_end_with_reservation` reserves 5 bytes and calls `read`.\n5. `read` writes 0 bytes.\n6. The read loop ends with `vec` having length 5 and capacity 10.\n\nThe reservation of 5 bytes was correct for the read at step 2 but\nunnecessary for the read at step 4. By that second read, `Take::limit`\nis 0, but the `read_to_end_with_reservation` loop is still using the\nsame `reservation_size` it started with.\n\nSolve this by having `read_to_end_with_reservation` take a closure,\nwhich lets it get a fresh `reservation_size` for each read. This is an\nimplementation detail which doesn't affect any public API.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5299dd5d1c517b8a2da463ec463abec68b08b33", "html_url": "https://github.com/rust-lang/rust/commit/a5299dd5d1c517b8a2da463ec463abec68b08b33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5299dd5d1c517b8a2da463ec463abec68b08b33/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14890954ce17c44d944eda988c5a64bb4c5ec9eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/14890954ce17c44d944eda988c5a64bb4c5ec9eb", "html_url": "https://github.com/rust-lang/rust/commit/14890954ce17c44d944eda988c5a64bb4c5ec9eb"}, {"sha": "edb5214b29cd7de06dd10f673986d38e568b077c", "url": "https://api.github.com/repos/rust-lang/rust/commits/edb5214b29cd7de06dd10f673986d38e568b077c", "html_url": "https://github.com/rust-lang/rust/commit/edb5214b29cd7de06dd10f673986d38e568b077c"}], "stats": {"total": 66, "additions": 58, "deletions": 8}, "files": [{"sha": "5060f368229bb848821664e8fe48baadc9a227fe", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a5299dd5d1c517b8a2da463ec463abec68b08b33/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5299dd5d1c517b8a2da463ec463abec68b08b33/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=a5299dd5d1c517b8a2da463ec463abec68b08b33", "patch": "@@ -353,20 +353,25 @@ fn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\n // Because we're extending the buffer with uninitialized data for trusted\n // readers, we need to make sure to truncate that if any of this panics.\n fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n-    read_to_end_with_reservation(r, buf, 32)\n+    read_to_end_with_reservation(r, buf, |_| 32)\n }\n \n-fn read_to_end_with_reservation<R: Read + ?Sized>(r: &mut R,\n-                                                  buf: &mut Vec<u8>,\n-                                                  reservation_size: usize) -> Result<usize>\n+fn read_to_end_with_reservation<R, F>(\n+    r: &mut R,\n+    buf: &mut Vec<u8>,\n+    mut reservation_size: F,\n+) -> Result<usize>\n+where\n+    R: Read + ?Sized,\n+    F: FnMut(&R) -> usize,\n {\n     let start_len = buf.len();\n     let mut g = Guard { len: buf.len(), buf: buf };\n     let ret;\n     loop {\n         if g.len == g.buf.len() {\n             unsafe {\n-                g.buf.reserve(reservation_size);\n+                g.buf.reserve(reservation_size(r));\n                 let capacity = g.buf.capacity();\n                 g.buf.set_len(capacity);\n                 r.initializer().initialize(&mut g.buf[g.len..]);\n@@ -2253,9 +2258,10 @@ impl<T: Read> Read for Take<T> {\n     }\n \n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n-        let reservation_size = cmp::min(self.limit, 32) as usize;\n-\n-        read_to_end_with_reservation(self, buf, reservation_size)\n+        // Pass in a reservation_size closure that respects the current value\n+        // of limit for each read. If we hit the read limit, this prevents the\n+        // final zero-byte read from allocating again.\n+        read_to_end_with_reservation(self, buf, |self_| cmp::min(self_.limit, 32) as usize)\n     }\n }\n \n@@ -2378,6 +2384,7 @@ impl<B: BufRead> Iterator for Lines<B> {\n \n #[cfg(test)]\n mod tests {\n+    use crate::cmp;\n     use crate::io::prelude::*;\n     use super::{Cursor, SeekFrom, repeat};\n     use crate::io::{self, IoSlice, IoSliceMut};\n@@ -2651,6 +2658,49 @@ mod tests {\n         Ok(())\n     }\n \n+    // A simple example reader which uses the default implementation of\n+    // read_to_end.\n+    struct ExampleSliceReader<'a> {\n+        slice: &'a [u8],\n+    }\n+\n+    impl<'a> Read for ExampleSliceReader<'a> {\n+        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+            let len = cmp::min(self.slice.len(), buf.len());\n+            buf[..len].copy_from_slice(&self.slice[..len]);\n+            self.slice = &self.slice[len..];\n+            Ok(len)\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_to_end_capacity() -> io::Result<()> {\n+        let input = &b\"foo\"[..];\n+\n+        // read_to_end() generally needs to over-allocate, both for efficiency\n+        // and so that it can distinguish EOF. Assert that this is the case\n+        // with this simple ExampleSliceReader struct, which uses the default\n+        // implementation of read_to_end. Even though vec1 is allocated with\n+        // exactly enough capacity for the read, read_to_end will allocate more\n+        // space here.\n+        let mut vec1 = Vec::with_capacity(input.len());\n+        ExampleSliceReader { slice: input }.read_to_end(&mut vec1)?;\n+        assert_eq!(vec1.len(), input.len());\n+        assert!(vec1.capacity() > input.len(), \"allocated more\");\n+\n+        // However, std::io::Take includes an implementation of read_to_end\n+        // that will not allocate when the limit has already been reached. In\n+        // this case, vec2 never grows.\n+        let mut vec2 = Vec::with_capacity(input.len());\n+        ExampleSliceReader { slice: input }\n+            .take(input.len() as u64)\n+            .read_to_end(&mut vec2)?;\n+        assert_eq!(vec2.len(), input.len());\n+        assert_eq!(vec2.capacity(), input.len(), \"did not allocate more\");\n+\n+        Ok(())\n+    }\n+\n     #[test]\n     fn io_slice_mut_advance() {\n         let mut buf1 = [1; 8];"}]}