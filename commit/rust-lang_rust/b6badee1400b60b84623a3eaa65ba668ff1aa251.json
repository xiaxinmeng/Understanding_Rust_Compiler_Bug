{"sha": "b6badee1400b60b84623a3eaa65ba668ff1aa251", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2YmFkZWUxNDAwYjYwYjg0NjIzYTNlYWE2NWJhNjY4ZmYxYWEyNTE=", "commit": {"author": {"name": "Giacomo Stevanato", "email": "giaco.stevanato@gmail.com", "date": "2021-07-21T12:42:20Z"}, "committer": {"name": "Giacomo Stevanato", "email": "giaco.stevanato@gmail.com", "date": "2021-07-23T07:13:05Z"}, "message": "Fix span when suggesting to add an associated type bound", "tree": {"sha": "9170b7c84abe4c861ab85823a92b53cab472ab9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9170b7c84abe4c861ab85823a92b53cab472ab9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6badee1400b60b84623a3eaa65ba668ff1aa251", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6badee1400b60b84623a3eaa65ba668ff1aa251", "html_url": "https://github.com/rust-lang/rust/commit/b6badee1400b60b84623a3eaa65ba668ff1aa251", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6badee1400b60b84623a3eaa65ba668ff1aa251/comments", "author": {"login": "SkiFire13", "id": 9020423, "node_id": "MDQ6VXNlcjkwMjA0MjM=", "avatar_url": "https://avatars.githubusercontent.com/u/9020423?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SkiFire13", "html_url": "https://github.com/SkiFire13", "followers_url": "https://api.github.com/users/SkiFire13/followers", "following_url": "https://api.github.com/users/SkiFire13/following{/other_user}", "gists_url": "https://api.github.com/users/SkiFire13/gists{/gist_id}", "starred_url": "https://api.github.com/users/SkiFire13/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SkiFire13/subscriptions", "organizations_url": "https://api.github.com/users/SkiFire13/orgs", "repos_url": "https://api.github.com/users/SkiFire13/repos", "events_url": "https://api.github.com/users/SkiFire13/events{/privacy}", "received_events_url": "https://api.github.com/users/SkiFire13/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SkiFire13", "id": 9020423, "node_id": "MDQ6VXNlcjkwMjA0MjM=", "avatar_url": "https://avatars.githubusercontent.com/u/9020423?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SkiFire13", "html_url": "https://github.com/SkiFire13", "followers_url": "https://api.github.com/users/SkiFire13/followers", "following_url": "https://api.github.com/users/SkiFire13/following{/other_user}", "gists_url": "https://api.github.com/users/SkiFire13/gists{/gist_id}", "starred_url": "https://api.github.com/users/SkiFire13/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SkiFire13/subscriptions", "organizations_url": "https://api.github.com/users/SkiFire13/orgs", "repos_url": "https://api.github.com/users/SkiFire13/repos", "events_url": "https://api.github.com/users/SkiFire13/events{/privacy}", "received_events_url": "https://api.github.com/users/SkiFire13/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9197978a90be6f7570741eabe2da175fec75375", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9197978a90be6f7570741eabe2da175fec75375", "html_url": "https://github.com/rust-lang/rust/commit/b9197978a90be6f7570741eabe2da175fec75375"}], "stats": {"total": 65, "additions": 45, "deletions": 20}, "files": [{"sha": "f1c7c1ea852a285e08c3f12dbbf24aedcc47e0e9", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 45, "deletions": 20, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b6badee1400b60b84623a3eaa65ba668ff1aa251/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6badee1400b60b84623a3eaa65ba668ff1aa251/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=b6badee1400b60b84623a3eaa65ba668ff1aa251", "patch": "@@ -628,6 +628,7 @@ impl<T> Trait<T> for X {\n                             assoc_substs,\n                             ty,\n                             msg,\n+                            false,\n                         ) {\n                             return true;\n                         }\n@@ -646,6 +647,7 @@ impl<T> Trait<T> for X {\n                             assoc_substs,\n                             ty,\n                             msg,\n+                            false,\n                         );\n                     }\n                 }\n@@ -771,13 +773,24 @@ fn foo(&self) -> Self::T { String::new() }\n     ) -> bool {\n         let assoc = self.associated_item(proj_ty.item_def_id);\n         if let ty::Opaque(def_id, _) = *proj_ty.self_ty().kind() {\n-            self.constrain_associated_type_structured_suggestion(\n+            let opaque_local_def_id = def_id.expect_local();\n+            let opaque_hir_id = self.hir().local_def_id_to_hir_id(opaque_local_def_id);\n+            let opaque_hir_ty = match &self.hir().expect_item(opaque_hir_id).kind {\n+                hir::ItemKind::OpaqueTy(opaque_hir_ty) => opaque_hir_ty,\n+                _ => bug!(\"The HirId comes from a `ty::Opaque`\"),\n+            };\n+\n+            let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(self);\n+\n+            self.constrain_generic_bound_associated_type_structured_suggestion(\n                 db,\n-                self.def_span(def_id),\n-                &assoc,\n-                proj_ty.trait_ref_and_own_substs(self).1,\n+                &trait_ref,\n+                opaque_hir_ty.bounds,\n+                assoc,\n+                assoc_substs,\n                 ty,\n-                &msg,\n+                msg,\n+                true,\n             )\n         } else {\n             false\n@@ -899,6 +912,11 @@ fn foo(&self) -> Self::T { String::new() }\n \n     /// Given a slice of `hir::GenericBound`s, if any of them corresponds to the `trait_ref`\n     /// requirement, provide a structured suggestion to constrain it to a given type `ty`.\n+    ///\n+    /// `is_bound_surely_present` indicates whether we know the bound we're looking for is\n+    /// inside `bounds`. If that's the case then we can consider `bounds` containing only one\n+    /// trait bound as the one we're looking for. This can help in cases where the associated\n+    /// type is defined on a supertrait of the one present in the bounds.\n     fn constrain_generic_bound_associated_type_structured_suggestion(\n         self,\n         db: &mut DiagnosticBuilder<'_>,\n@@ -908,23 +926,30 @@ fn foo(&self) -> Self::T { String::new() }\n         assoc_substs: &[ty::GenericArg<'tcx>],\n         ty: Ty<'tcx>,\n         msg: &str,\n+        is_bound_surely_present: bool,\n     ) -> bool {\n         // FIXME: we would want to call `resolve_vars_if_possible` on `ty` before suggesting.\n-        bounds.iter().any(|bound| match bound {\n-            hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::None) => {\n-                // Relate the type param against `T` in `<A as T>::Foo`.\n-                ptr.trait_ref.trait_def_id() == Some(trait_ref.def_id)\n-                    && self.constrain_associated_type_structured_suggestion(\n-                        db,\n-                        ptr.span,\n-                        assoc,\n-                        assoc_substs,\n-                        ty,\n-                        msg,\n-                    )\n-            }\n-            _ => false,\n-        })\n+\n+        let trait_bounds = bounds.iter().filter_map(|bound| match bound {\n+            hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::None) => Some(ptr),\n+            _ => None,\n+        });\n+\n+        let matching_trait_bounds = trait_bounds\n+            .clone()\n+            .filter(|ptr| ptr.trait_ref.trait_def_id() == Some(trait_ref.def_id))\n+            .collect::<Vec<_>>();\n+\n+        let span = match &matching_trait_bounds[..] {\n+            &[ptr] => ptr.span,\n+            &[] if is_bound_surely_present => match &trait_bounds.collect::<Vec<_>>()[..] {\n+                &[ptr] => ptr.span,\n+                _ => return false,\n+            },\n+            _ => return false,\n+        };\n+\n+        self.constrain_associated_type_structured_suggestion(db, span, assoc, assoc_substs, ty, msg)\n     }\n \n     /// Given a span corresponding to a bound, provide a structured suggestion to set an"}]}