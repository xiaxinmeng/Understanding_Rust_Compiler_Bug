{"sha": "75f1db1102076e416e1154b241b4fc95c01c0d7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZjFkYjExMDIwNzZlNDE2ZTExNTRiMjQxYjRmYzk1YzAxYzBkN2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-04T14:26:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-04T14:26:03Z"}, "message": "Auto merge of #77227 - oli-obk:const_val_\ud83c\udf33_prelude, r=RalfJung\n\nRefactorings in preparation for const value trees\n\ncc #72396\n\nThis PR changes the `Scalar::Bits { data: u128, size: u8 }` variant to `Scalar::Bits(ScalarInt)` where `ScalarInt` contains the same information, but is `repr(packed)`. The reason for using a packed struct is to allow enum variant packing to keep the original size of `Scalar` instead of adding another word to its size due to padding.\nOther than that the PR just gets rid of all the inspection of the internal fields of `Scalar::Bits` which were frankly scary. These fields have invariants that we need to uphold and we can't do that without making the fields private.\n\nr? `@ghost`", "tree": {"sha": "da3aff37cbe521b14bfc86b1cdb3cab26ceb3b95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da3aff37cbe521b14bfc86b1cdb3cab26ceb3b95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75f1db1102076e416e1154b241b4fc95c01c0d7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75f1db1102076e416e1154b241b4fc95c01c0d7b", "html_url": "https://github.com/rust-lang/rust/commit/75f1db1102076e416e1154b241b4fc95c01c0d7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75f1db1102076e416e1154b241b4fc95c01c0d7b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "601c13c6fda6a7db423c974797e36c79a9a0c0ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/601c13c6fda6a7db423c974797e36c79a9a0c0ac", "html_url": "https://github.com/rust-lang/rust/commit/601c13c6fda6a7db423c974797e36c79a9a0c0ac"}, {"sha": "332750f9ebea6ff8a20b020772b60ccac637982e", "url": "https://api.github.com/repos/rust-lang/rust/commits/332750f9ebea6ff8a20b020772b60ccac637982e", "html_url": "https://github.com/rust-lang/rust/commit/332750f9ebea6ff8a20b020772b60ccac637982e"}], "stats": {"total": 764, "additions": 472, "deletions": 292}, "files": [{"sha": "bfe5514b6d3eab4a096f4007c00cbbc269c89166", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -499,7 +499,7 @@ fn codegen_stmt<'tcx>(\n                         UnOp::Neg => match layout.ty.kind() {\n                             ty::Int(IntTy::I128) => {\n                                 // FIXME remove this case once ineg.i128 works\n-                                let zero = CValue::const_val(fx, layout, 0);\n+                                let zero = CValue::const_val(fx, layout, ty::ScalarInt::null(layout.size));\n                                 crate::num::codegen_int_binop(fx, BinOp::Sub, zero, operand)\n                             }\n                             ty::Int(_) => CValue::by_val(fx.bcx.ins().ineg(val), layout),\n@@ -585,13 +585,11 @@ fn codegen_stmt<'tcx>(\n                                     .discriminant_for_variant(fx.tcx, *index)\n                                     .unwrap();\n                                 let discr = if discr.ty.is_signed() {\n-                                    rustc_middle::mir::interpret::sign_extend(\n-                                        discr.val,\n-                                        fx.layout_of(discr.ty).size,\n-                                    )\n+                                    fx.layout_of(discr.ty).size.sign_extend(discr.val)\n                                 } else {\n                                     discr.val\n                                 };\n+                                let discr = discr.into();\n \n                                 let discr = CValue::const_val(fx, fx.layout_of(to_ty), discr);\n                                 lval.write_cvalue(fx, discr);"}, {"sha": "41cfae4ca6e26e677319b6ee41d0af6893e91398", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -186,9 +186,8 @@ pub(crate) fn codegen_const_value<'tcx>(\n             }\n \n             match x {\n-                Scalar::Raw { data, size } => {\n-                    assert_eq!(u64::from(size), layout.size.bytes());\n-                    CValue::const_val(fx, layout, data)\n+                Scalar::Int(int) => {\n+                    CValue::const_val(fx, layout, int)\n                 }\n                 Scalar::Ptr(ptr) => {\n                     let alloc_kind = fx.tcx.get_global_alloc(ptr.alloc_id);"}, {"sha": "6c9fb8e051b3c23ab88a0c94ea6cdde402881499", "filename": "compiler/rustc_codegen_cranelift/src/discriminant.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -30,7 +30,8 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n                 .ty\n                 .discriminant_for_variant(fx.tcx, variant_index)\n                 .unwrap()\n-                .val;\n+                .val\n+                .into();\n             let discr = CValue::const_val(fx, ptr.layout(), to);\n             ptr.write_cvalue(fx, discr);\n         }\n@@ -49,7 +50,7 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n                 let niche = place.place_field(fx, mir::Field::new(tag_field));\n                 let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n                 let niche_value = u128::from(niche_value).wrapping_add(niche_start);\n-                let niche_llval = CValue::const_val(fx, niche.layout(), niche_value);\n+                let niche_llval = CValue::const_val(fx, niche.layout(), niche_value.into());\n                 niche.write_cvalue(fx, niche_llval);\n             }\n         }\n@@ -77,7 +78,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                 .ty\n                 .discriminant_for_variant(fx.tcx, *index)\n                 .map_or(u128::from(index.as_u32()), |discr| discr.val);\n-            return CValue::const_val(fx, dest_layout, discr_val);\n+            return CValue::const_val(fx, dest_layout, discr_val.into());\n         }\n         Variants::Multiple {\n             tag,"}, {"sha": "ab16fabd348a540d04a12b0f2bcdfb60dae441c0", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -1064,7 +1064,8 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n             fx.bcx.ins().call_indirect(f_sig, f, &[data]);\n \n-            let ret_val = CValue::const_val(fx, ret.layout(), 0);\n+            let layout = ret.layout();\n+            let ret_val = CValue::const_val(fx, layout, ty::ScalarInt::null(layout.size));\n             ret.write_cvalue(fx, ret_val);\n         };\n "}, {"sha": "0000866c4f6a95fd912424d5619cbf06b13680fc", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -231,22 +231,24 @@ impl<'tcx> CValue<'tcx> {\n     pub(crate) fn const_val(\n         fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n         layout: TyAndLayout<'tcx>,\n-        const_val: u128,\n+        const_val: ty::ScalarInt,\n     ) -> CValue<'tcx> {\n+        assert_eq!(const_val.size(), layout.size);\n         use cranelift_codegen::ir::immediates::{Ieee32, Ieee64};\n \n         let clif_ty = fx.clif_type(layout.ty).unwrap();\n \n         if let ty::Bool = layout.ty.kind() {\n             assert!(\n-                const_val == 0 || const_val == 1,\n+                const_val == ty::ScalarInt::FALSE || const_val == ty::ScalarInt::TRUE,\n                 \"Invalid bool 0x{:032X}\",\n                 const_val\n             );\n         }\n \n         let val = match layout.ty.kind() {\n             ty::Uint(UintTy::U128) | ty::Int(IntTy::I128) => {\n+                let const_val = const_val.to_bits(layout.size).unwrap();\n                 let lsb = fx.bcx.ins().iconst(types::I64, const_val as u64 as i64);\n                 let msb = fx\n                     .bcx\n@@ -259,7 +261,7 @@ impl<'tcx> CValue<'tcx> {\n                 fx\n                     .bcx\n                     .ins()\n-                    .iconst(clif_ty, u64::try_from(const_val).expect(\"uint\") as i64)\n+                    .iconst(clif_ty, const_val.to_bits(layout.size).unwrap() as i64)\n             }\n             ty::Float(FloatTy::F32) => {\n                 fx.bcx.ins().f32const(Ieee32::with_bits(u32::try_from(const_val).unwrap()))"}, {"sha": "34e1b7a60451eb225a0d9dae01408182a57c1e39", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -12,7 +12,7 @@ use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n use rustc_middle::bug;\n use rustc_middle::mir::interpret::{Allocation, GlobalAlloc, Scalar};\n-use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_middle::ty::{layout::TyAndLayout, ScalarInt};\n use rustc_span::symbol::Symbol;\n use rustc_target::abi::{self, AddressSpace, HasDataLayout, LayoutOf, Pointer, Size};\n \n@@ -230,12 +230,12 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn scalar_to_backend(&self, cv: Scalar, layout: &abi::Scalar, llty: &'ll Type) -> &'ll Value {\n         let bitsize = if layout.is_bool() { 1 } else { layout.value.size(self).bits() };\n         match cv {\n-            Scalar::Raw { size: 0, .. } => {\n+            Scalar::Int(ScalarInt::ZST) => {\n                 assert_eq!(0, layout.value.size(self).bytes());\n                 self.const_undef(self.type_ix(0))\n             }\n-            Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, layout.value.size(self).bytes());\n+            Scalar::Int(int) => {\n+                let data = int.assert_bits(layout.value.size(self));\n                 let llval = self.const_uint_big(self.type_ix(bitsize), data);\n                 if layout.value == Pointer {\n                     unsafe { llvm::LLVMConstIntToPtr(llval, llty) }"}, {"sha": "454d43fd4e7dcf22dffbe84bbc7358e9b0cd8cb2", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -29,7 +29,6 @@ use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::ich::NodeIdHashingMode;\n-use rustc_middle::mir::interpret::truncate;\n use rustc_middle::mir::{self, Field, GeneratorLayout};\n use rustc_middle::ty::layout::{self, IntegerExt, PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::subst::GenericArgKind;\n@@ -1693,7 +1692,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                 let value = (i.as_u32() as u128)\n                                     .wrapping_sub(niche_variants.start().as_u32() as u128)\n                                     .wrapping_add(niche_start);\n-                                let value = truncate(value, tag.value.size(cx));\n+                                let value = tag.value.size(cx).truncate(value);\n                                 // NOTE(eddyb) do *NOT* remove this assert, until\n                                 // we pass the full 128-bit value to LLVM, otherwise\n                                 // truncation will be silent and remain undetected."}, {"sha": "467a3a425906f96165c06199db241b955252f813", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -6,7 +6,6 @@ use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::{is_range_literal, ExprKind, Node};\n use rustc_index::vec::Idx;\n-use rustc_middle::mir::interpret::{sign_extend, truncate};\n use rustc_middle::ty::layout::{IntegerExt, SizeSkeleton};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n@@ -218,11 +217,11 @@ fn report_bin_hex_error(\n     cx.struct_span_lint(OVERFLOWING_LITERALS, expr.span, |lint| {\n         let (t, actually) = match ty {\n             attr::IntType::SignedInt(t) => {\n-                let actually = sign_extend(val, size) as i128;\n+                let actually = size.sign_extend(val) as i128;\n                 (t.name_str(), actually.to_string())\n             }\n             attr::IntType::UnsignedInt(t) => {\n-                let actually = truncate(val, size);\n+                let actually = size.truncate(val);\n                 (t.name_str(), actually.to_string())\n             }\n         };"}, {"sha": "4a1d5459d1eec0c6d0222a725440d940b9a92911", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -24,6 +24,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(array_windows)]\n+#![feature(assoc_char_funcs)]\n #![feature(backtrace)]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]"}, {"sha": "bcf85797313f265d7c0645487866e7c5ef936240", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -110,7 +110,7 @@ use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_serialize::{Decodable, Encodable};\n-use rustc_target::abi::{Endian, Size};\n+use rustc_target::abi::Endian;\n \n use crate::mir;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n@@ -590,39 +590,6 @@ pub fn read_target_uint(endianness: Endian, mut source: &[u8]) -> Result<u128, i\n     uint\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Methods to facilitate working with signed integers stored in a u128\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// Truncates `value` to `size` bits and then sign-extend it to 128 bits\n-/// (i.e., if it is negative, fill with 1's on the left).\n-#[inline]\n-pub fn sign_extend(value: u128, size: Size) -> u128 {\n-    let size = size.bits();\n-    if size == 0 {\n-        // Truncated until nothing is left.\n-        return 0;\n-    }\n-    // Sign-extend it.\n-    let shift = 128 - size;\n-    // Shift the unsigned value to the left, then shift back to the right as signed\n-    // (essentially fills with FF on the left).\n-    (((value << shift) as i128) >> shift) as u128\n-}\n-\n-/// Truncates `value` to `size` bits.\n-#[inline]\n-pub fn truncate(value: u128, size: Size) -> u128 {\n-    let size = size.bits();\n-    if size == 0 {\n-        // Truncated until nothing is left.\n-        return 0;\n-    }\n-    let shift = 128 - size;\n-    // Truncate (shift left to drop out leftover values, shift right to fill with zeroes).\n-    (value << shift) >> shift\n-}\n-\n /// Computes the unsigned absolute value without wrapping or panicking.\n #[inline]\n pub fn uabs(value: i64) -> u64 {"}, {"sha": "5e97862ecf2b6be734b8f49bdbdfaa11c3b8a212", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 41, "deletions": 95, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -8,9 +8,9 @@ use rustc_apfloat::{\n use rustc_macros::HashStable;\n use rustc_target::abi::{HasDataLayout, Size, TargetDataLayout};\n \n-use crate::ty::{ParamEnv, Ty, TyCtxt};\n+use crate::ty::{ParamEnv, ScalarInt, Ty, TyCtxt};\n \n-use super::{sign_extend, truncate, AllocId, Allocation, InterpResult, Pointer, PointerArithmetic};\n+use super::{AllocId, Allocation, InterpResult, Pointer, PointerArithmetic};\n \n /// Represents the result of const evaluation via the `eval_to_allocation` query.\n #[derive(Clone, HashStable, TyEncodable, TyDecodable)]\n@@ -103,12 +103,7 @@ impl<'tcx> ConstValue<'tcx> {\n #[derive(HashStable)]\n pub enum Scalar<Tag = ()> {\n     /// The raw bytes of a simple value.\n-    Raw {\n-        /// The first `size` bytes of `data` are the value.\n-        /// Do not try to read less or more bytes than that. The remaining bytes must be 0.\n-        data: u128,\n-        size: u8,\n-    },\n+    Int(ScalarInt),\n \n     /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n     /// relocations, but a `Scalar` is only large enough to contain one, so we just represent the\n@@ -125,16 +120,7 @@ impl<Tag: fmt::Debug> fmt::Debug for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Scalar::Ptr(ptr) => write!(f, \"{:?}\", ptr),\n-            &Scalar::Raw { data, size } => {\n-                Scalar::check_data(data, size);\n-                if size == 0 {\n-                    write!(f, \"<ZST>\")\n-                } else {\n-                    // Format as hex number wide enough to fit any value of the given `size`.\n-                    // So data=20, size=1 will be \"0x14\", but with size=4 it'll be \"0x00000014\".\n-                    write!(f, \"0x{:>0width$x}\", data, width = (size * 2) as usize)\n-                }\n-            }\n+            Scalar::Int(int) => write!(f, \"{:?}\", int),\n         }\n     }\n }\n@@ -143,7 +129,7 @@ impl<Tag: fmt::Debug> fmt::Display for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Scalar::Ptr(ptr) => write!(f, \"pointer to {}\", ptr),\n-            Scalar::Raw { .. } => fmt::Debug::fmt(self, f),\n+            Scalar::Int { .. } => fmt::Debug::fmt(self, f),\n         }\n     }\n }\n@@ -163,53 +149,35 @@ impl<Tag> From<Double> for Scalar<Tag> {\n }\n \n impl Scalar<()> {\n-    /// Make sure the `data` fits in `size`.\n-    /// This is guaranteed by all constructors here, but since the enum variants are public,\n-    /// it could still be violated (even though no code outside this file should\n-    /// construct `Scalar`s).\n-    #[inline(always)]\n-    fn check_data(data: u128, size: u8) {\n-        debug_assert_eq!(\n-            truncate(data, Size::from_bytes(u64::from(size))),\n-            data,\n-            \"Scalar value {:#x} exceeds size of {} bytes\",\n-            data,\n-            size\n-        );\n-    }\n-\n     /// Tag this scalar with `new_tag` if it is a pointer, leave it unchanged otherwise.\n     ///\n     /// Used by `MemPlace::replace_tag`.\n     #[inline]\n     pub fn with_tag<Tag>(self, new_tag: Tag) -> Scalar<Tag> {\n         match self {\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.with_tag(new_tag)),\n-            Scalar::Raw { data, size } => Scalar::Raw { data, size },\n+            Scalar::Int(int) => Scalar::Int(int),\n         }\n     }\n }\n \n impl<'tcx, Tag> Scalar<Tag> {\n+    pub const ZST: Self = Scalar::Int(ScalarInt::ZST);\n+\n     /// Erase the tag from the scalar, if any.\n     ///\n     /// Used by error reporting code to avoid having the error type depend on `Tag`.\n     #[inline]\n     pub fn erase_tag(self) -> Scalar {\n         match self {\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.erase_tag()),\n-            Scalar::Raw { data, size } => Scalar::Raw { data, size },\n+            Scalar::Int(int) => Scalar::Int(int),\n         }\n     }\n \n     #[inline]\n     pub fn null_ptr(cx: &impl HasDataLayout) -> Self {\n-        Scalar::Raw { data: 0, size: cx.data_layout().pointer_size.bytes() as u8 }\n-    }\n-\n-    #[inline]\n-    pub fn zst() -> Self {\n-        Scalar::Raw { data: 0, size: 0 }\n+        Scalar::Int(ScalarInt::null(cx.data_layout().pointer_size))\n     }\n \n     #[inline(always)]\n@@ -220,10 +188,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n         f_ptr: impl FnOnce(Pointer<Tag>) -> InterpResult<'tcx, Pointer<Tag>>,\n     ) -> InterpResult<'tcx, Self> {\n         match self {\n-            Scalar::Raw { data, size } => {\n-                assert_eq!(u64::from(size), dl.pointer_size.bytes());\n-                Ok(Scalar::Raw { data: u128::from(f_int(u64::try_from(data).unwrap())?), size })\n-            }\n+            Scalar::Int(int) => Ok(Scalar::Int(int.ptr_sized_op(dl, f_int)?)),\n             Scalar::Ptr(ptr) => Ok(Scalar::Ptr(f_ptr(ptr)?)),\n         }\n     }\n@@ -264,24 +229,17 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline]\n     pub fn from_bool(b: bool) -> Self {\n-        // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: b as u128, size: 1 }\n+        Scalar::Int(b.into())\n     }\n \n     #[inline]\n     pub fn from_char(c: char) -> Self {\n-        // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: c as u128, size: 4 }\n+        Scalar::Int(c.into())\n     }\n \n     #[inline]\n     pub fn try_from_uint(i: impl Into<u128>, size: Size) -> Option<Self> {\n-        let i = i.into();\n-        if truncate(i, size) == i {\n-            Some(Scalar::Raw { data: i, size: size.bytes() as u8 })\n-        } else {\n-            None\n-        }\n+        ScalarInt::try_from_uint(i, size).map(Scalar::Int)\n     }\n \n     #[inline]\n@@ -293,26 +251,22 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline]\n     pub fn from_u8(i: u8) -> Self {\n-        // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i.into(), size: 1 }\n+        Scalar::Int(i.into())\n     }\n \n     #[inline]\n     pub fn from_u16(i: u16) -> Self {\n-        // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i.into(), size: 2 }\n+        Scalar::Int(i.into())\n     }\n \n     #[inline]\n     pub fn from_u32(i: u32) -> Self {\n-        // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i.into(), size: 4 }\n+        Scalar::Int(i.into())\n     }\n \n     #[inline]\n     pub fn from_u64(i: u64) -> Self {\n-        // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i.into(), size: 8 }\n+        Scalar::Int(i.into())\n     }\n \n     #[inline]\n@@ -322,14 +276,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline]\n     pub fn try_from_int(i: impl Into<i128>, size: Size) -> Option<Self> {\n-        let i = i.into();\n-        // `into` performed sign extension, we have to truncate\n-        let truncated = truncate(i as u128, size);\n-        if sign_extend(truncated, size) as i128 == i {\n-            Some(Scalar::Raw { data: truncated, size: size.bytes() as u8 })\n-        } else {\n-            None\n-        }\n+        ScalarInt::try_from_int(i, size).map(Scalar::Int)\n     }\n \n     #[inline]\n@@ -366,14 +313,12 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline]\n     pub fn from_f32(f: Single) -> Self {\n-        // We trust apfloat to give us properly truncated data.\n-        Scalar::Raw { data: f.to_bits(), size: 4 }\n+        Scalar::Int(f.into())\n     }\n \n     #[inline]\n     pub fn from_f64(f: Double) -> Self {\n-        // We trust apfloat to give us properly truncated data.\n-        Scalar::Raw { data: f.to_bits(), size: 8 }\n+        Scalar::Int(f.into())\n     }\n \n     /// This is very rarely the method you want!  You should dispatch on the type\n@@ -388,11 +333,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n     ) -> Result<u128, Pointer<Tag>> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         match self {\n-            Scalar::Raw { data, size } => {\n-                assert_eq!(target_size.bytes(), u64::from(size));\n-                Scalar::check_data(data, size);\n-                Ok(data)\n-            }\n+            Scalar::Int(int) => Ok(int.assert_bits(target_size)),\n             Scalar::Ptr(ptr) => {\n                 assert_eq!(target_size, cx.data_layout().pointer_size);\n                 Err(ptr)\n@@ -406,16 +347,13 @@ impl<'tcx, Tag> Scalar<Tag> {\n     fn to_bits(self, target_size: Size) -> InterpResult<'tcx, u128> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         match self {\n-            Scalar::Raw { data, size } => {\n-                if target_size.bytes() != u64::from(size) {\n-                    throw_ub!(ScalarSizeMismatch {\n-                        target_size: target_size.bytes(),\n-                        data_size: u64::from(size),\n-                    });\n-                }\n-                Scalar::check_data(data, size);\n-                Ok(data)\n-            }\n+            Scalar::Int(int) => int.to_bits(target_size).map_err(|size| {\n+                err_ub!(ScalarSizeMismatch {\n+                    target_size: target_size.bytes(),\n+                    data_size: size.bytes(),\n+                })\n+                .into()\n+            }),\n             Scalar::Ptr(_) => throw_unsup!(ReadPointerAsBytes),\n         }\n     }\n@@ -425,18 +363,26 @@ impl<'tcx, Tag> Scalar<Tag> {\n         self.to_bits(target_size).expect(\"expected Raw bits but got a Pointer\")\n     }\n \n+    #[inline]\n+    pub fn assert_int(self) -> ScalarInt {\n+        match self {\n+            Scalar::Ptr(_) => bug!(\"expected an int but got an abstract pointer\"),\n+            Scalar::Int(int) => int,\n+        }\n+    }\n+\n     #[inline]\n     pub fn assert_ptr(self) -> Pointer<Tag> {\n         match self {\n             Scalar::Ptr(p) => p,\n-            Scalar::Raw { .. } => bug!(\"expected a Pointer but got Raw bits\"),\n+            Scalar::Int { .. } => bug!(\"expected a Pointer but got Raw bits\"),\n         }\n     }\n \n     /// Do not call this method!  Dispatch based on the type instead.\n     #[inline]\n     pub fn is_bits(self) -> bool {\n-        matches!(self, Scalar::Raw { .. })\n+        matches!(self, Scalar::Int { .. })\n     }\n \n     /// Do not call this method!  Dispatch based on the type instead.\n@@ -502,7 +448,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n     fn to_signed_with_bit_width(self, bits: u64) -> InterpResult<'static, i128> {\n         let sz = Size::from_bits(bits);\n         let b = self.to_bits(sz)?;\n-        Ok(sign_extend(b, sz) as i128)\n+        Ok(sz.sign_extend(b) as i128)\n     }\n \n     /// Converts the scalar to produce an `i8`. Fails if the scalar is a pointer.\n@@ -533,7 +479,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn to_machine_isize(self, cx: &impl HasDataLayout) -> InterpResult<'static, i64> {\n         let sz = cx.data_layout().pointer_size;\n         let b = self.to_bits(sz)?;\n-        let b = sign_extend(b, sz) as i128;\n+        let b = sz.sign_extend(b) as i128;\n         Ok(i64::try_from(b).unwrap())\n     }\n "}, {"sha": "bf091201e1004e3c41348eccccfee1196ae50ed0", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -28,7 +28,6 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_serialize::{Decodable, Encodable};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n-use rustc_target::abi;\n use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n@@ -1952,10 +1951,10 @@ impl<'tcx> Operand<'tcx> {\n                 .layout_of(param_env_and_ty)\n                 .unwrap_or_else(|e| panic!(\"could not compute layout for {:?}: {:?}\", ty, e))\n                 .size;\n-            let scalar_size = abi::Size::from_bytes(match val {\n-                Scalar::Raw { size, .. } => size,\n+            let scalar_size = match val {\n+                Scalar::Int(int) => int.size(),\n                 _ => panic!(\"Invalid scalar type {:?}\", val),\n-            });\n+            };\n             scalar_size == type_size\n         });\n         Operand::Constant(box Constant {"}, {"sha": "0af884a286d6ec15897ad5899e0cd6cd7cbf6059", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -132,7 +132,7 @@ impl<'tcx> Const<'tcx> {\n     #[inline]\n     /// Creates an interned zst constant.\n     pub fn zero_sized(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n-        Self::from_scalar(tcx, Scalar::zst(), ty)\n+        Self::from_scalar(tcx, Scalar::ZST, ty)\n     }\n \n     #[inline]"}, {"sha": "126257a5b49ee85b768170a08ad53fef35424ade", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 268, "deletions": 13, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -1,31 +1,32 @@\n-use crate::mir::interpret::truncate;\n-use rustc_target::abi::Size;\n+use rustc_apfloat::ieee::{Double, Single};\n+use rustc_apfloat::Float;\n+use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n+use rustc_target::abi::{Size, TargetDataLayout};\n+use std::convert::{TryFrom, TryInto};\n+use std::fmt;\n \n #[derive(Copy, Clone)]\n /// A type for representing any integer. Only used for printing.\n-// FIXME: Use this for the integer-tree representation needed for type level ints and\n-// const generics?\n pub struct ConstInt {\n-    /// Number of bytes of the integer. Only 1, 2, 4, 8, 16 are legal values.\n-    size: u8,\n+    /// The \"untyped\" variant of `ConstInt`.\n+    int: ScalarInt,\n     /// Whether the value is of a signed integer type.\n     signed: bool,\n     /// Whether the value is a `usize` or `isize` type.\n     is_ptr_sized_integral: bool,\n-    /// Raw memory of the integer. All bytes beyond the `size` are unused and must be zero.\n-    raw: u128,\n }\n \n impl ConstInt {\n-    pub fn new(raw: u128, size: Size, signed: bool, is_ptr_sized_integral: bool) -> Self {\n-        assert!(raw <= truncate(u128::MAX, size));\n-        Self { raw, size: size.bytes() as u8, signed, is_ptr_sized_integral }\n+    pub fn new(int: ScalarInt, signed: bool, is_ptr_sized_integral: bool) -> Self {\n+        Self { int, signed, is_ptr_sized_integral }\n     }\n }\n \n impl std::fmt::Debug for ConstInt {\n     fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        let Self { size, signed, raw, is_ptr_sized_integral } = *self;\n+        let Self { int, signed, is_ptr_sized_integral } = *self;\n+        let size = int.size().bytes();\n+        let raw = int.data;\n         if signed {\n             let bit_size = size * 8;\n             let min = 1u128 << (bit_size - 1);\n@@ -73,7 +74,7 @@ impl std::fmt::Debug for ConstInt {\n                 Ok(())\n             }\n         } else {\n-            let max = truncate(u128::MAX, Size::from_bytes(size));\n+            let max = Size::from_bytes(size).truncate(u128::MAX);\n             if raw == max {\n                 match (size, is_ptr_sized_integral) {\n                     (_, true) => write!(fmt, \"usize::MAX\"),\n@@ -109,3 +110,257 @@ impl std::fmt::Debug for ConstInt {\n         }\n     }\n }\n+\n+/// The raw bytes of a simple value.\n+///\n+/// This is a packed struct in order to allow this type to be optimally embedded in enums\n+/// (like Scalar).\n+#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+#[repr(packed)]\n+pub struct ScalarInt {\n+    /// The first `size` bytes of `data` are the value.\n+    /// Do not try to read less or more bytes than that. The remaining bytes must be 0.\n+    data: u128,\n+    size: u8,\n+}\n+\n+// Cannot derive these, as the derives take references to the fields, and we\n+// can't take references to fields of packed structs.\n+impl<CTX> crate::ty::HashStable<CTX> for ScalarInt {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut crate::ty::StableHasher) {\n+        // Using a block `{self.data}` here to force a copy instead of using `self.data`\n+        // directly, because `hash_stable` takes `&self` and would thus borrow `self.data`.\n+        // Since `Self` is a packed struct, that would create a possibly unaligned reference,\n+        // which is UB.\n+        { self.data }.hash_stable(hcx, hasher);\n+        self.size.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<S: Encoder> Encodable<S> for ScalarInt {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_u128(self.data)?;\n+        s.emit_u8(self.size)\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for ScalarInt {\n+    fn decode(d: &mut D) -> Result<ScalarInt, D::Error> {\n+        Ok(ScalarInt { data: d.read_u128()?, size: d.read_u8()? })\n+    }\n+}\n+\n+impl ScalarInt {\n+    pub const TRUE: ScalarInt = ScalarInt { data: 1_u128, size: 1 };\n+\n+    pub const FALSE: ScalarInt = ScalarInt { data: 0_u128, size: 1 };\n+\n+    pub const ZST: ScalarInt = ScalarInt { data: 0_u128, size: 0 };\n+\n+    #[inline]\n+    pub fn size(self) -> Size {\n+        Size::from_bytes(self.size)\n+    }\n+\n+    /// Make sure the `data` fits in `size`.\n+    /// This is guaranteed by all constructors here, but having had this check saved us from\n+    /// bugs many times in the past, so keeping it around is definitely worth it.\n+    #[inline(always)]\n+    fn check_data(self) {\n+        // Using a block `{self.data}` here to force a copy instead of using `self.data`\n+        // directly, because `assert_eq` takes references to its arguments and formatting\n+        // arguments and would thus borrow `self.data`. Since `Self`\n+        // is a packed struct, that would create a possibly unaligned reference, which\n+        // is UB.\n+        debug_assert_eq!(\n+            self.size().truncate(self.data),\n+            { self.data },\n+            \"Scalar value {:#x} exceeds size of {} bytes\",\n+            { self.data },\n+            self.size\n+        );\n+    }\n+\n+    #[inline]\n+    pub fn null(size: Size) -> Self {\n+        Self { data: 0, size: size.bytes() as u8 }\n+    }\n+\n+    #[inline]\n+    pub fn is_null(self) -> bool {\n+        self.data == 0\n+    }\n+\n+    pub(crate) fn ptr_sized_op<E>(\n+        self,\n+        dl: &TargetDataLayout,\n+        f_int: impl FnOnce(u64) -> Result<u64, E>,\n+    ) -> Result<Self, E> {\n+        assert_eq!(u64::from(self.size), dl.pointer_size.bytes());\n+        Ok(Self::try_from_uint(f_int(u64::try_from(self.data).unwrap())?, self.size()).unwrap())\n+    }\n+\n+    #[inline]\n+    pub fn try_from_uint(i: impl Into<u128>, size: Size) -> Option<Self> {\n+        let data = i.into();\n+        if size.truncate(data) == data {\n+            Some(Self { data, size: size.bytes() as u8 })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn try_from_int(i: impl Into<i128>, size: Size) -> Option<Self> {\n+        let i = i.into();\n+        // `into` performed sign extension, we have to truncate\n+        let truncated = size.truncate(i as u128);\n+        if size.sign_extend(truncated) as i128 == i {\n+            Some(Self { data: truncated, size: size.bytes() as u8 })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn assert_bits(self, target_size: Size) -> u128 {\n+        self.to_bits(target_size).unwrap_or_else(|size| {\n+            bug!(\"expected int of size {}, but got size {}\", target_size.bytes(), size.bytes())\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn to_bits(self, target_size: Size) -> Result<u128, Size> {\n+        assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n+        if target_size.bytes() == u64::from(self.size) {\n+            self.check_data();\n+            Ok(self.data)\n+        } else {\n+            Err(self.size())\n+        }\n+    }\n+}\n+\n+macro_rules! from {\n+    ($($ty:ty),*) => {\n+        $(\n+            impl From<$ty> for ScalarInt {\n+                #[inline]\n+                fn from(u: $ty) -> Self {\n+                    Self {\n+                        data: u128::from(u),\n+                        size: std::mem::size_of::<$ty>() as u8,\n+                    }\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+macro_rules! try_from {\n+    ($($ty:ty),*) => {\n+        $(\n+            impl TryFrom<ScalarInt> for $ty {\n+                type Error = Size;\n+                #[inline]\n+                fn try_from(int: ScalarInt) -> Result<Self, Size> {\n+                    // The `unwrap` cannot fail because to_bits (if it succeeds)\n+                    // is guaranteed to return a value that fits into the size.\n+                    int.to_bits(Size::from_bytes(std::mem::size_of::<$ty>()))\n+                       .map(|u| u.try_into().unwrap())\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+from!(u8, u16, u32, u64, u128, bool);\n+try_from!(u8, u16, u32, u64, u128);\n+\n+impl From<char> for ScalarInt {\n+    #[inline]\n+    fn from(c: char) -> Self {\n+        Self { data: c as u128, size: std::mem::size_of::<char>() as u8 }\n+    }\n+}\n+\n+impl TryFrom<ScalarInt> for char {\n+    type Error = Size;\n+    #[inline]\n+    fn try_from(int: ScalarInt) -> Result<Self, Size> {\n+        int.to_bits(Size::from_bytes(std::mem::size_of::<char>()))\n+            .map(|u| char::from_u32(u.try_into().unwrap()).unwrap())\n+    }\n+}\n+\n+impl From<Single> for ScalarInt {\n+    #[inline]\n+    fn from(f: Single) -> Self {\n+        // We trust apfloat to give us properly truncated data.\n+        Self { data: f.to_bits(), size: 4 }\n+    }\n+}\n+\n+impl TryFrom<ScalarInt> for Single {\n+    type Error = Size;\n+    #[inline]\n+    fn try_from(int: ScalarInt) -> Result<Self, Size> {\n+        int.to_bits(Size::from_bytes(4)).map(Self::from_bits)\n+    }\n+}\n+\n+impl From<Double> for ScalarInt {\n+    #[inline]\n+    fn from(f: Double) -> Self {\n+        // We trust apfloat to give us properly truncated data.\n+        Self { data: f.to_bits(), size: 8 }\n+    }\n+}\n+\n+impl TryFrom<ScalarInt> for Double {\n+    type Error = Size;\n+    #[inline]\n+    fn try_from(int: ScalarInt) -> Result<Self, Size> {\n+        int.to_bits(Size::from_bytes(8)).map(Self::from_bits)\n+    }\n+}\n+\n+impl fmt::Debug for ScalarInt {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.size == 0 {\n+            self.check_data();\n+            write!(f, \"<ZST>\")\n+        } else {\n+            // Dispatch to LowerHex below.\n+            write!(f, \"0x{:x}\", self)\n+        }\n+    }\n+}\n+\n+impl fmt::LowerHex for ScalarInt {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.check_data();\n+        // Format as hex number wide enough to fit any value of the given `size`.\n+        // So data=20, size=1 will be \"0x14\", but with size=4 it'll be \"0x00000014\".\n+        // Using a block `{self.data}` here to force a copy instead of using `self.data`\n+        // directly, because `write!` takes references to its formatting arguments and\n+        // would thus borrow `self.data`. Since `Self`\n+        // is a packed struct, that would create a possibly unaligned reference, which\n+        // is UB.\n+        write!(f, \"{:01$x}\", { self.data }, self.size as usize * 2)\n+    }\n+}\n+\n+impl fmt::UpperHex for ScalarInt {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.check_data();\n+        // Format as hex number wide enough to fit any value of the given `size`.\n+        // So data=20, size=1 will be \"0x14\", but with size=4 it'll be \"0x00000014\".\n+        // Using a block `{self.data}` here to force a copy instead of using `self.data`\n+        // directly, because `write!` takes references to its formatting arguments and\n+        // would thus borrow `self.data`. Since `Self`\n+        // is a packed struct, that would create a possibly unaligned reference, which\n+        // is UB.\n+        write!(f, \"{:01$X}\", { self.data }, self.size as usize * 2)\n+    }\n+}"}, {"sha": "216451f268f4e049399335642c1f7dfdd17e3318", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -844,7 +844,7 @@ impl<'tcx> CommonConsts<'tcx> {\n \n         CommonConsts {\n             unit: mk_const(ty::Const {\n-                val: ty::ConstKind::Value(ConstValue::Scalar(Scalar::zst())),\n+                val: ty::ConstKind::Value(ConstValue::Scalar(Scalar::ZST)),\n                 ty: types.unit,\n             }),\n         }"}, {"sha": "0a7bec1a342f3661f4b3e7da2cb0c981a326fca6", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -87,7 +87,7 @@ pub use self::trait_def::TraitDef;\n \n pub use self::query::queries;\n \n-pub use self::consts::{Const, ConstInt, ConstKind, InferConst};\n+pub use self::consts::{Const, ConstInt, ConstKind, InferConst, ScalarInt};\n \n pub mod _match;\n pub mod adjustment;"}, {"sha": "8ff4adda606e204b2e050827a933252a6242bd6e", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -1,12 +1,9 @@\n use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n use crate::mir::interpret::{AllocId, ConstValue, GlobalAlloc, Pointer, Scalar};\n-use crate::ty::layout::IntegerExt;\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n-use crate::ty::{self, ConstInt, DefIdTree, ParamConst, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, ConstInt, DefIdTree, ParamConst, ScalarInt, Ty, TyCtxt, TypeFoldable};\n use rustc_apfloat::ieee::{Double, Single};\n-use rustc_apfloat::Float;\n use rustc_ast as ast;\n-use rustc_attr::{SignedInt, UnsignedInt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{self, CtorKind, DefKind, Namespace};\n@@ -15,12 +12,13 @@ use rustc_hir::definitions::{DefPathData, DefPathDataName, DisambiguatedDefPathD\n use rustc_hir::ItemKind;\n use rustc_session::config::TrimmedDefPaths;\n use rustc_span::symbol::{kw, Ident, Symbol};\n-use rustc_target::abi::{Integer, Size};\n+use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n use std::cell::Cell;\n use std::char;\n use std::collections::BTreeMap;\n+use std::convert::TryFrom;\n use std::fmt::{self, Write as _};\n use std::ops::{ControlFlow, Deref, DerefMut};\n \n@@ -960,11 +958,7 @@ pub trait PrettyPrinter<'tcx>:\n                             ty::Array(\n                                 ty::TyS { kind: ty::Uint(ast::UintTy::U8), .. },\n                                 ty::Const {\n-                                    val:\n-                                        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw {\n-                                            data,\n-                                            ..\n-                                        })),\n+                                    val: ty::ConstKind::Value(ConstValue::Scalar(int)),\n                                     ..\n                                 },\n                             ),\n@@ -974,8 +968,9 @@ pub trait PrettyPrinter<'tcx>:\n                 ),\n             ) => match self.tcx().get_global_alloc(ptr.alloc_id) {\n                 Some(GlobalAlloc::Memory(alloc)) => {\n-                    if let Ok(byte_str) = alloc.get_bytes(&self.tcx(), ptr, Size::from_bytes(*data))\n-                    {\n+                    let bytes = int.assert_bits(self.tcx().data_layout.pointer_size);\n+                    let size = Size::from_bytes(bytes);\n+                    if let Ok(byte_str) = alloc.get_bytes(&self.tcx(), ptr, size) {\n                         p!(pretty_print_byte_str(byte_str))\n                     } else {\n                         p!(\"<too short allocation>\")\n@@ -987,32 +982,28 @@ pub trait PrettyPrinter<'tcx>:\n                 None => p!(\"<dangling pointer>\"),\n             },\n             // Bool\n-            (Scalar::Raw { data: 0, .. }, ty::Bool) => p!(\"false\"),\n-            (Scalar::Raw { data: 1, .. }, ty::Bool) => p!(\"true\"),\n+            (Scalar::Int(int), ty::Bool) if int == ScalarInt::FALSE => p!(\"false\"),\n+            (Scalar::Int(int), ty::Bool) if int == ScalarInt::TRUE => p!(\"true\"),\n             // Float\n-            (Scalar::Raw { data, .. }, ty::Float(ast::FloatTy::F32)) => {\n-                p!(write(\"{}f32\", Single::from_bits(data)))\n+            (Scalar::Int(int), ty::Float(ast::FloatTy::F32)) => {\n+                p!(write(\"{}f32\", Single::try_from(int).unwrap()))\n             }\n-            (Scalar::Raw { data, .. }, ty::Float(ast::FloatTy::F64)) => {\n-                p!(write(\"{}f64\", Double::from_bits(data)))\n+            (Scalar::Int(int), ty::Float(ast::FloatTy::F64)) => {\n+                p!(write(\"{}f64\", Double::try_from(int).unwrap()))\n             }\n             // Int\n-            (Scalar::Raw { data, .. }, ty::Uint(ui)) => {\n-                let size = Integer::from_attr(&self.tcx(), UnsignedInt(*ui)).size();\n-                let int = ConstInt::new(data, size, false, ty.is_ptr_sized_integral());\n-                if print_ty { p!(write(\"{:#?}\", int)) } else { p!(write(\"{:?}\", int)) }\n-            }\n-            (Scalar::Raw { data, .. }, ty::Int(i)) => {\n-                let size = Integer::from_attr(&self.tcx(), SignedInt(*i)).size();\n-                let int = ConstInt::new(data, size, true, ty.is_ptr_sized_integral());\n+            (Scalar::Int(int), ty::Uint(_) | ty::Int(_)) => {\n+                let int =\n+                    ConstInt::new(int, matches!(ty.kind(), ty::Int(_)), ty.is_ptr_sized_integral());\n                 if print_ty { p!(write(\"{:#?}\", int)) } else { p!(write(\"{:?}\", int)) }\n             }\n             // Char\n-            (Scalar::Raw { data, .. }, ty::Char) if char::from_u32(data as u32).is_some() => {\n-                p!(write(\"{:?}\", char::from_u32(data as u32).unwrap()))\n+            (Scalar::Int(int), ty::Char) if char::try_from(int).is_ok() => {\n+                p!(write(\"{:?}\", char::try_from(int).unwrap()))\n             }\n             // Raw pointers\n-            (Scalar::Raw { data, .. }, ty::RawPtr(_)) => {\n+            (Scalar::Int(int), ty::RawPtr(_)) => {\n+                let data = int.assert_bits(self.tcx().data_layout.pointer_size);\n                 self = self.typed_value(\n                     |mut this| {\n                         write!(this, \"0x{:x}\", data)?;\n@@ -1034,14 +1025,16 @@ pub trait PrettyPrinter<'tcx>:\n                 )?;\n             }\n             // For function type zsts just printing the path is enough\n-            (Scalar::Raw { size: 0, .. }, ty::FnDef(d, s)) => p!(print_value_path(*d, s)),\n+            (Scalar::Int(int), ty::FnDef(d, s)) if int == ScalarInt::ZST => {\n+                p!(print_value_path(*d, s))\n+            }\n             // Nontrivial types with scalar bit representation\n-            (Scalar::Raw { data, size }, _) => {\n+            (Scalar::Int(int), _) => {\n                 let print = |mut this: Self| {\n-                    if size == 0 {\n+                    if int.size() == Size::ZERO {\n                         write!(this, \"transmute(())\")?;\n                     } else {\n-                        write!(this, \"transmute(0x{:01$x})\", data, size as usize * 2)?;\n+                        write!(this, \"transmute(0x{:x})\", int)?;\n                     }\n                     Ok(this)\n                 };"}, {"sha": "5f117e19eca2788e43354e63311a439afefd875a", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -2,7 +2,6 @@\n \n use crate::ich::NodeIdHashingMode;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n-use crate::mir::interpret::{sign_extend, truncate};\n use crate::ty::fold::TypeFolder;\n use crate::ty::layout::IntegerExt;\n use crate::ty::query::TyCtxtAt;\n@@ -38,7 +37,7 @@ impl<'tcx> fmt::Display for Discr<'tcx> {\n                 let size = ty::tls::with(|tcx| Integer::from_attr(&tcx, SignedInt(ity)).size());\n                 let x = self.val;\n                 // sign extend the raw representation to be an i128\n-                let x = sign_extend(x, size) as i128;\n+                let x = size.sign_extend(x) as i128;\n                 write!(fmt, \"{}\", x)\n             }\n             _ => write!(fmt, \"{}\", self.val),\n@@ -47,7 +46,7 @@ impl<'tcx> fmt::Display for Discr<'tcx> {\n }\n \n fn signed_min(size: Size) -> i128 {\n-    sign_extend(1_u128 << (size.bits() - 1), size) as i128\n+    size.sign_extend(1_u128 << (size.bits() - 1)) as i128\n }\n \n fn signed_max(size: Size) -> i128 {\n@@ -77,14 +76,14 @@ impl<'tcx> Discr<'tcx> {\n         let (val, oflo) = if signed {\n             let min = signed_min(size);\n             let max = signed_max(size);\n-            let val = sign_extend(self.val, size) as i128;\n+            let val = size.sign_extend(self.val) as i128;\n             assert!(n < (i128::MAX as u128));\n             let n = n as i128;\n             let oflo = val > max - n;\n             let val = if oflo { min + (n - (max - val) - 1) } else { val + n };\n             // zero the upper bits\n             let val = val as u128;\n-            let val = truncate(val, size);\n+            let val = size.truncate(val);\n             (val, oflo)\n         } else {\n             let max = unsigned_max(size);\n@@ -650,7 +649,7 @@ impl<'tcx> ty::TyS<'tcx> {\n         let val = match self.kind() {\n             ty::Int(_) | ty::Uint(_) => {\n                 let (size, signed) = int_size_and_signed(tcx, self);\n-                let val = if signed { truncate(signed_min(size) as u128, size) } else { 0 };\n+                let val = if signed { size.truncate(signed_min(size) as u128) } else { 0 };\n                 Some(val)\n             }\n             ty::Char => Some(0),"}, {"sha": "f1631d1b4401f7253b4cc0865f7367154715eb62", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, subst::Subst, TyCtxt};\n use rustc_span::source_map::Span;\n use rustc_target::abi::{Abi, LayoutOf};\n-use std::convert::{TryFrom, TryInto};\n+use std::convert::TryInto;\n \n pub fn note_on_undefined_behavior_error() -> &'static str {\n     \"The rules on what exactly is undefined behavior aren't clear, \\\n@@ -137,15 +137,16 @@ pub(super) fn op_to_const<'tcx>(\n             let alloc = ecx.tcx.global_alloc(ptr.alloc_id).unwrap_memory();\n             ConstValue::ByRef { alloc, offset: ptr.offset }\n         }\n-        Scalar::Raw { data, .. } => {\n+        Scalar::Int(int) => {\n             assert!(mplace.layout.is_zst());\n             assert_eq!(\n-                u64::try_from(data).unwrap() % mplace.layout.align.abi.bytes(),\n+                int.assert_bits(ecx.tcx.data_layout.pointer_size)\n+                    % u128::from(mplace.layout.align.abi.bytes()),\n                 0,\n                 \"this MPlaceTy must come from a validated constant, thus we can assume the \\\n                 alignment is correct\",\n             );\n-            ConstValue::Scalar(Scalar::zst())\n+            ConstValue::Scalar(Scalar::ZST)\n         }\n     };\n     match immediate {\n@@ -161,7 +162,7 @@ pub(super) fn op_to_const<'tcx>(\n                     Scalar::Ptr(ptr) => {\n                         (ecx.tcx.global_alloc(ptr.alloc_id).unwrap_memory(), ptr.offset.bytes())\n                     }\n-                    Scalar::Raw { .. } => (\n+                    Scalar::Int { .. } => (\n                         ecx.tcx\n                             .intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\" as &[u8])),\n                         0,"}, {"sha": "c72089ec55a993da51f9e621c1ea5f83a2a9aca5", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -181,9 +181,9 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n     fn guaranteed_eq(&mut self, a: Scalar, b: Scalar) -> bool {\n         match (a, b) {\n             // Comparisons between integers are always known.\n-            (Scalar::Raw { .. }, Scalar::Raw { .. }) => a == b,\n+            (Scalar::Int { .. }, Scalar::Int { .. }) => a == b,\n             // Equality with integers can never be known for sure.\n-            (Scalar::Raw { .. }, Scalar::Ptr(_)) | (Scalar::Ptr(_), Scalar::Raw { .. }) => false,\n+            (Scalar::Int { .. }, Scalar::Ptr(_)) | (Scalar::Ptr(_), Scalar::Int { .. }) => false,\n             // FIXME: return `true` for when both sides are the same pointer, *except* that\n             // some things (like functions and vtables) do not have stable addresses\n             // so we need to be careful around them (see e.g. #73722).\n@@ -194,13 +194,13 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n     fn guaranteed_ne(&mut self, a: Scalar, b: Scalar) -> bool {\n         match (a, b) {\n             // Comparisons between integers are always known.\n-            (Scalar::Raw { .. }, Scalar::Raw { .. }) => a != b,\n+            (Scalar::Int(_), Scalar::Int(_)) => a != b,\n             // Comparisons of abstract pointers with null pointers are known if the pointer\n             // is in bounds, because if they are in bounds, the pointer can't be null.\n-            (Scalar::Raw { data: 0, .. }, Scalar::Ptr(ptr))\n-            | (Scalar::Ptr(ptr), Scalar::Raw { data: 0, .. }) => !self.memory.ptr_may_be_null(ptr),\n             // Inequality with integers other than null can never be known for sure.\n-            (Scalar::Raw { .. }, Scalar::Ptr(_)) | (Scalar::Ptr(_), Scalar::Raw { .. }) => false,\n+            (Scalar::Int(int), Scalar::Ptr(ptr)) | (Scalar::Ptr(ptr), Scalar::Int(int)) => {\n+                int.is_null() && !self.memory.ptr_may_be_null(ptr)\n+            }\n             // FIXME: return `true` for at least some comparisons where we can reliably\n             // determine the result of runtime inequality tests at compile-time.\n             // Examples include comparison of addresses in different static items."}, {"sha": "6d224bcc50b0ffaf223d77f28310bcc231e65c0a", "filename": "compiler/rustc_mir/src/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -13,8 +13,7 @@ use rustc_span::symbol::sym;\n use rustc_target::abi::{Integer, LayoutOf, Variants};\n \n use super::{\n-    truncate, util::ensure_monomorphic_enough, FnVal, ImmTy, Immediate, InterpCx, Machine, OpTy,\n-    PlaceTy,\n+    util::ensure_monomorphic_enough, FnVal, ImmTy, Immediate, InterpCx, Machine, OpTy, PlaceTy,\n };\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -209,7 +208,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     RawPtr(_) => self.pointer_size(),\n                     _ => bug!(),\n                 };\n-                let v = truncate(v, size);\n+                let v = size.truncate(v);\n                 Scalar::from_uint(v, size)\n             }\n "}, {"sha": "08d8904ae1a5af711b2c1072f8dd787e01b1f03c", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -9,9 +9,7 @@ use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_middle::ich::StableHashingContext;\n use rustc_middle::mir;\n-use rustc_middle::mir::interpret::{\n-    sign_extend, truncate, GlobalId, InterpResult, Pointer, Scalar,\n-};\n+use rustc_middle::mir::interpret::{GlobalId, InterpResult, Pointer, Scalar};\n use rustc_middle::ty::layout::{self, TyAndLayout};\n use rustc_middle::ty::{\n     self, query::TyCtxtAt, subst::SubstsRef, ParamEnv, Ty, TyCtxt, TypeFoldable,\n@@ -443,12 +441,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline(always)]\n     pub fn sign_extend(&self, value: u128, ty: TyAndLayout<'_>) -> u128 {\n         assert!(ty.abi.is_signed());\n-        sign_extend(value, ty.size)\n+        ty.size.sign_extend(value)\n     }\n \n     #[inline(always)]\n     pub fn truncate(&self, value: u128, ty: TyAndLayout<'_>) -> u128 {\n-        truncate(value, ty.size)\n+        ty.size.truncate(value)\n     }\n \n     #[inline]"}, {"sha": "8716d4d9ad7f0974eafc737c5bde626165db25c9", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -211,14 +211,8 @@ impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag> {\n     #[inline]\n     pub fn to_const_int(self) -> ConstInt {\n         assert!(self.layout.ty.is_integral());\n-        ConstInt::new(\n-            self.to_scalar()\n-                .expect(\"to_const_int doesn't work on scalar pairs\")\n-                .assert_bits(self.layout.size),\n-            self.layout.size,\n-            self.layout.ty.is_signed(),\n-            self.layout.ty.is_ptr_sized_integral(),\n-        )\n+        let int = self.to_scalar().expect(\"to_const_int doesn't work on scalar pairs\").assert_int();\n+        ConstInt::new(int, self.layout.ty.is_signed(), self.layout.ty.is_ptr_sized_integral())\n     }\n }\n \n@@ -262,7 +256,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n                 return Ok(Some(ImmTy {\n                     // zero-sized type\n-                    imm: Scalar::zst().into(),\n+                    imm: Scalar::ZST.into(),\n                     layout: mplace.layout,\n                 }));\n             }\n@@ -361,7 +355,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let field_layout = op.layout.field(self, field)?;\n         if field_layout.is_zst() {\n-            let immediate = Scalar::zst().into();\n+            let immediate = Scalar::ZST.into();\n             return Ok(OpTy { op: Operand::Immediate(immediate), layout: field_layout });\n         }\n         let offset = op.layout.fields.offset(field);\n@@ -446,7 +440,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let layout = self.layout_of_local(frame, local, layout)?;\n         let op = if layout.is_zst() {\n             // Do not read from ZST, they might not be initialized\n-            Operand::Immediate(Scalar::zst().into())\n+            Operand::Immediate(Scalar::ZST.into())\n         } else {\n             M::access_local(&self, frame, local)?\n         };\n@@ -544,7 +538,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let tag_scalar = |scalar| -> InterpResult<'tcx, _> {\n             Ok(match scalar {\n                 Scalar::Ptr(ptr) => Scalar::Ptr(self.global_base_pointer(ptr)?),\n-                Scalar::Raw { data, size } => Scalar::Raw { data, size },\n+                Scalar::Int(int) => Scalar::Int(int),\n             })\n         };\n         // Early-return cases."}, {"sha": "a003380dda7e8a3d4be9f36bbe883c2b326711dd", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -14,9 +14,9 @@ use rustc_target::abi::{Abi, Align, FieldsShape, TagEncoding};\n use rustc_target::abi::{HasDataLayout, LayoutOf, Size, VariantIdx, Variants};\n \n use super::{\n-    mir_assign_valid_types, truncate, AllocId, AllocMap, Allocation, AllocationExtra, ConstAlloc,\n-    ImmTy, Immediate, InterpCx, InterpResult, LocalValue, Machine, MemoryKind, OpTy, Operand,\n-    Pointer, PointerArithmetic, Scalar, ScalarMaybeUninit,\n+    mir_assign_valid_types, AllocId, AllocMap, Allocation, AllocationExtra, ConstAlloc, ImmTy,\n+    Immediate, InterpCx, InterpResult, LocalValue, Machine, MemoryKind, OpTy, Operand, Pointer,\n+    PointerArithmetic, Scalar, ScalarMaybeUninit,\n };\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n@@ -721,12 +721,8 @@ where\n                     dest.layout.size,\n                     \"Size mismatch when writing pointer\"\n                 ),\n-                Immediate::Scalar(ScalarMaybeUninit::Scalar(Scalar::Raw { size, .. })) => {\n-                    assert_eq!(\n-                        Size::from_bytes(size),\n-                        dest.layout.size,\n-                        \"Size mismatch when writing bits\"\n-                    )\n+                Immediate::Scalar(ScalarMaybeUninit::Scalar(Scalar::Int(int))) => {\n+                    assert_eq!(int.size(), dest.layout.size, \"Size mismatch when writing bits\")\n                 }\n                 Immediate::Scalar(ScalarMaybeUninit::Uninit) => {} // uninit can have any size\n                 Immediate::ScalarPair(_, _) => {\n@@ -1077,7 +1073,7 @@ where\n                 // their computation, but the in-memory tag is the smallest possible\n                 // representation\n                 let size = tag_layout.value.size(self);\n-                let tag_val = truncate(discr_val, size);\n+                let tag_val = size.truncate(discr_val);\n \n                 let tag_dest = self.place_field(dest, tag_field)?;\n                 self.write_scalar(Scalar::from_uint(tag_val, size), tag_dest)?;"}, {"sha": "aeb9920c0e321c36c8f804c32211c992f0b0203b", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -19,18 +19,19 @@ use rustc_middle::mir::{\n };\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutError, TyAndLayout};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n-use rustc_middle::ty::{self, ConstInt, ConstKind, Instance, ParamEnv, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{\n+    self, ConstInt, ConstKind, Instance, ParamEnv, ScalarInt, Ty, TyCtxt, TypeFoldable,\n+};\n use rustc_session::lint;\n use rustc_span::{def_id::DefId, Span};\n use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TargetDataLayout};\n use rustc_trait_selection::traits;\n \n use crate::const_eval::ConstEvalErr;\n use crate::interpret::{\n-    self, compile_time_machine, truncate, AllocId, Allocation, ConstValue, CtfeValidationMode,\n-    Frame, ImmTy, Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemPlace, Memory,\n-    MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer, Scalar, ScalarMaybeUninit,\n-    StackPopCleanup,\n+    self, compile_time_machine, AllocId, Allocation, ConstValue, CtfeValidationMode, Frame, ImmTy,\n+    Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemPlace, Memory, MemoryKind, OpTy,\n+    Operand as InterpOperand, PlaceTy, Pointer, Scalar, ScalarMaybeUninit, StackPopCleanup,\n };\n use crate::transform::MirPass;\n \n@@ -578,8 +579,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                             Some(l) => l.to_const_int(),\n                             // Invent a dummy value, the diagnostic ignores it anyway\n                             None => ConstInt::new(\n-                                1,\n-                                left_size,\n+                                ScalarInt::try_from_uint(1_u8, left_size).unwrap(),\n                                 left_ty.is_signed(),\n                                 left_ty.is_ptr_sized_integral(),\n                             ),\n@@ -745,7 +745,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                             }\n                         }\n                         BinOp::BitOr => {\n-                            if arg_value == truncate(u128::MAX, const_arg.layout.size)\n+                            if arg_value == const_arg.layout.size.truncate(u128::MAX)\n                                 || (const_arg.layout.ty.is_bool() && arg_value == 1)\n                             {\n                                 this.ecx.write_immediate(*const_arg, dest)?;"}, {"sha": "ea56080c75216c96971ff01385e26fa4285c89a4", "filename": "compiler/rustc_mir/src/transform/simplify_comparison_integral.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -26,22 +26,26 @@ use rustc_middle::{\n pub struct SimplifyComparisonIntegral;\n \n impl<'tcx> MirPass<'tcx> for SimplifyComparisonIntegral {\n-    fn run_pass(&self, _: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         trace!(\"Running SimplifyComparisonIntegral on {:?}\", body.source);\n \n         let helper = OptimizationFinder { body };\n         let opts = helper.find_optimizations();\n         let mut storage_deads_to_insert = vec![];\n         let mut storage_deads_to_remove: Vec<(usize, BasicBlock)> = vec![];\n+        let param_env = tcx.param_env(body.source.def_id());\n         for opt in opts {\n             trace!(\"SUCCESS: Applying {:?}\", opt);\n             // replace terminator with a switchInt that switches on the integer directly\n             let bbs = &mut body.basic_blocks_mut();\n             let bb = &mut bbs[opt.bb_idx];\n-            // We only use the bits for the untyped, not length checked `values` field. Thus we are\n-            // not using any of the convenience wrappers here and directly access the bits.\n             let new_value = match opt.branch_value_scalar {\n-                Scalar::Raw { data, .. } => data,\n+                Scalar::Int(int) => {\n+                    let layout = tcx\n+                        .layout_of(param_env.and(opt.branch_value_ty))\n+                        .expect(\"if we have an evaluated constant we must know the layout\");\n+                    int.assert_bits(layout.size)\n+                }\n                 Scalar::Ptr(_) => continue,\n             };\n             const FALSE: u128 = 0;"}, {"sha": "8bee8417c51fa6dddc0102cfa022beac01694226", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -630,7 +630,7 @@ pub fn write_allocations<'tcx>(\n             ConstValue::Scalar(interpret::Scalar::Ptr(ptr)) => {\n                 Either::Left(Either::Left(std::iter::once(ptr.alloc_id)))\n             }\n-            ConstValue::Scalar(interpret::Scalar::Raw { .. }) => {\n+            ConstValue::Scalar(interpret::Scalar::Int { .. }) => {\n                 Either::Left(Either::Right(std::iter::empty()))\n             }\n             ConstValue::ByRef { alloc, .. } | ConstValue::Slice { data: alloc, .. } => {"}, {"sha": "375f19f87559fe6f9cd3d267a9a338408f7160f9", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -17,7 +17,6 @@ use crate::build::Builder;\n use crate::thir::{self, *};\n use rustc_attr::{SignedInt, UnsignedInt};\n use rustc_hir::RangeEnd;\n-use rustc_middle::mir::interpret::truncate;\n use rustc_middle::mir::Place;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::IntegerExt;\n@@ -161,13 +160,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     }\n                     ty::Int(ity) => {\n                         let size = Integer::from_attr(&tcx, SignedInt(ity)).size();\n-                        let max = truncate(u128::MAX, size);\n+                        let max = size.truncate(u128::MAX);\n                         let bias = 1u128 << (size.bits() - 1);\n                         (Some((0, max, size)), bias)\n                     }\n                     ty::Uint(uty) => {\n                         let size = Integer::from_attr(&tcx, UnsignedInt(uty)).size();\n-                        let max = truncate(u128::MAX, size);\n+                        let max = size.truncate(u128::MAX);\n                         (Some((0, max, size)), 0)\n                     }\n                     _ => (None, 0),"}, {"sha": "dfe82317f48c6f81b9932dbcf4449b06128b4351", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -1,6 +1,6 @@\n use rustc_ast as ast;\n use rustc_middle::mir::interpret::{\n-    truncate, Allocation, ConstValue, LitToConstError, LitToConstInput, Scalar,\n+    Allocation, ConstValue, LitToConstError, LitToConstInput, Scalar,\n };\n use rustc_middle::ty::{self, ParamEnv, TyCtxt};\n use rustc_span::symbol::Symbol;\n@@ -16,7 +16,7 @@ crate fn lit_to_const<'tcx>(\n         let param_ty = ParamEnv::reveal_all().and(ty);\n         let width = tcx.layout_of(param_ty).map_err(|_| LitToConstError::Reported)?.size;\n         trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n-        let result = truncate(n, width);\n+        let result = width.truncate(n);\n         trace!(\"trunc result: {}\", result);\n         Ok(ConstValue::Scalar(Scalar::from_uint(result, width)))\n     };"}, {"sha": "9e096f9ad68475913a84f246c2a70fd406447b0c", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -304,7 +304,7 @@ use rustc_arena::TypedArena;\n use rustc_attr::{SignedInt, UnsignedInt};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{HirId, RangeEnd};\n-use rustc_middle::mir::interpret::{truncate, ConstValue};\n+use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::mir::Field;\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n@@ -1608,7 +1608,7 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n         }\n         &ty::Uint(uty) => {\n             let size = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size();\n-            let max = truncate(u128::MAX, size);\n+            let max = size.truncate(u128::MAX);\n             vec![make_range(0, max)]\n         }\n         _ if cx.is_uninhabited(pcx.ty) => vec![],"}, {"sha": "db0ecd701bca4d3846cd5dbbda6ff7369615d630", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -15,7 +15,7 @@ use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n use rustc_hir::RangeEnd;\n use rustc_index::vec::Idx;\n-use rustc_middle::mir::interpret::{get_slice_bytes, sign_extend, ConstValue};\n+use rustc_middle::mir::interpret::{get_slice_bytes, ConstValue};\n use rustc_middle::mir::interpret::{ErrorHandled, LitToConstError, LitToConstInput};\n use rustc_middle::mir::UserTypeProjection;\n use rustc_middle::mir::{BorrowKind, Field, Mutability};\n@@ -1082,8 +1082,8 @@ crate fn compare_const_vals<'tcx>(\n                 use rustc_attr::SignedInt;\n                 use rustc_middle::ty::layout::IntegerExt;\n                 let size = rustc_target::abi::Integer::from_attr(&tcx, SignedInt(ity)).size();\n-                let a = sign_extend(a, size);\n-                let b = sign_extend(b, size);\n+                let a = size.sign_extend(a);\n+                let b = size.sign_extend(b);\n                 Some((a as i128).cmp(&(b as i128)))\n             }\n             _ => Some(a.cmp(&b)),"}, {"sha": "ac91fcf62937a5306ea78f7290a43860eaa0f1f3", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -237,7 +237,7 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n \n     fn print_const(mut self, ct: &'tcx ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n         // only print integers\n-        if let ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { .. })) = ct.val {\n+        if let ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int { .. })) = ct.val {\n             if ct.ty.is_integral() {\n                 return self.pretty_print_const(ct, true);\n             }"}, {"sha": "c28c2fecfbb434c46862e7c005d6c6badd9583b0", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -4,7 +4,6 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n-use rustc_middle::mir::interpret::sign_extend;\n use rustc_middle::ty::print::{Print, Printer};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt, TypeFoldable};\n@@ -527,7 +526,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n                 let param_env = ty::ParamEnv::reveal_all();\n                 ct.try_eval_bits(self.tcx, param_env, ct.ty).and_then(|b| {\n                     let sz = self.tcx.layout_of(param_env.and(ct.ty)).ok()?.size;\n-                    let val = sign_extend(b, sz) as i128;\n+                    let val = sz.sign_extend(b) as i128;\n                     if val < 0 {\n                         neg = true;\n                     }"}, {"sha": "d3c31773c1ee7df9830fd478ad9129deeedbcb16", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -306,6 +306,35 @@ impl Size {\n         let bytes = self.bytes().checked_mul(count)?;\n         if bytes < dl.obj_size_bound() { Some(Size::from_bytes(bytes)) } else { None }\n     }\n+\n+    /// Truncates `value` to `self` bits and then sign-extends it to 128 bits\n+    /// (i.e., if it is negative, fill with 1's on the left).\n+    #[inline]\n+    pub fn sign_extend(self, value: u128) -> u128 {\n+        let size = self.bits();\n+        if size == 0 {\n+            // Truncated until nothing is left.\n+            return 0;\n+        }\n+        // Sign-extend it.\n+        let shift = 128 - size;\n+        // Shift the unsigned value to the left, then shift back to the right as signed\n+        // (essentially fills with sign bit on the left).\n+        (((value << shift) as i128) >> shift) as u128\n+    }\n+\n+    /// Truncates `value` to `self` bits.\n+    #[inline]\n+    pub fn truncate(self, value: u128) -> u128 {\n+        let size = self.bits();\n+        if size == 0 {\n+            // Truncated until nothing is left.\n+            return 0;\n+        }\n+        let shift = 128 - size;\n+        // Truncate (shift left to drop out leftover values, shift right to fill with zeroes).\n+        (value << shift) >> shift\n+    }\n }\n \n // Panicking addition, subtraction and multiplication for convenience."}, {"sha": "f6258221e322d578a4a419a2e64b97010481ba57", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -14,7 +14,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_middle::mir::interpret::{sign_extend, ConstValue, Scalar};\n+use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, DefIdTree, Ty};\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -499,13 +499,14 @@ fn print_const_with_custom_print_scalar(cx: &DocContext<'_>, ct: &'tcx ty::Const\n     // Use a slightly different format for integer types which always shows the actual value.\n     // For all other types, fallback to the original `pretty_print_const`.\n     match (ct.val, ct.ty.kind()) {\n-        (ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data, .. })), ty::Uint(ui)) => {\n-            format!(\"{}{}\", format_integer_with_underscore_sep(&data.to_string()), ui.name_str())\n+        (ty::ConstKind::Value(ConstValue::Scalar(int)), ty::Uint(ui)) => {\n+            format!(\"{}{}\", format_integer_with_underscore_sep(&int.to_string()), ui.name_str())\n         }\n-        (ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data, .. })), ty::Int(i)) => {\n+        (ty::ConstKind::Value(ConstValue::Scalar(int)), ty::Int(i)) => {\n             let ty = cx.tcx.lift(ct.ty).unwrap();\n             let size = cx.tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap().size;\n-            let sign_extended_data = sign_extend(data, size) as i128;\n+            let data = int.assert_bits(size);\n+            let sign_extended_data = size.sign_extend(data) as i128;\n \n             format!(\n                 \"{}{}\","}, {"sha": "c8bbc9ce2b0287e9355350d53c8eea42fbcfd8cc", "filename": "src/tools/clippy/clippy_lints/src/consts.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/75f1db1102076e416e1154b241b4fc95c01c0d7b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f1db1102076e416e1154b241b4fc95c01c0d7b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs?ref=75f1db1102076e416e1154b241b4fc95c01c0d7b", "patch": "@@ -8,8 +8,9 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, QPath, UnOp};\n use rustc_lint::LateContext;\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt, ScalarInt};\n use rustc_middle::{bug, span_bug};\n+use rustc_middle::mir::interpret::Scalar;\n use rustc_span::symbol::Symbol;\n use std::cmp::Ordering::{self, Equal};\n use std::convert::TryInto;\n@@ -500,21 +501,21 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n }\n \n pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n-    use rustc_middle::mir::interpret::{ConstValue, Scalar};\n+    use rustc_middle::mir::interpret::{ConstValue};\n     match result.val {\n-        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data: d, .. })) => {\n+        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int(int))) => {\n             match result.ty.kind() {\n-                ty::Bool => Some(Constant::Bool(d == 1)),\n-                ty::Uint(_) | ty::Int(_) => Some(Constant::Int(d)),\n+                ty::Bool => Some(Constant::Bool(int == ScalarInt::TRUE)),\n+                ty::Uint(_) | ty::Int(_) => Some(Constant::Int(int.assert_bits(int.size()))),\n                 ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n-                    d.try_into().expect(\"invalid f32 bit representation\"),\n+                    int.try_into().expect(\"invalid f32 bit representation\"),\n                 ))),\n                 ty::Float(FloatTy::F64) => Some(Constant::F64(f64::from_bits(\n-                    d.try_into().expect(\"invalid f64 bit representation\"),\n+                    int.try_into().expect(\"invalid f64 bit representation\"),\n                 ))),\n                 ty::RawPtr(type_and_mut) => {\n                     if let ty::Uint(_) = type_and_mut.ty.kind() {\n-                        return Some(Constant::RawPtr(d));\n+                        return Some(Constant::RawPtr(int.assert_bits(int.size())));\n                     }\n                     None\n                 },"}]}