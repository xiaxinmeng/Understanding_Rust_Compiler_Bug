{"sha": "a95604fcaacf9cbad5f57b8c08e1b3e871462e9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NTYwNGZjYWFjZjljYmFkNWY1N2I4YzA4ZTFiM2U4NzE0NjJlOWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-20T21:11:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-20T21:11:08Z"}, "message": "auto merge of #9276 : alexcrichton/rust/dox, r=brson\n\nHopefull this will make our libstd docs appear a little more \"full\".", "tree": {"sha": "281b60fb5da3c1ca1ebb77859793599f69753f7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/281b60fb5da3c1ca1ebb77859793599f69753f7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a95604fcaacf9cbad5f57b8c08e1b3e871462e9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a95604fcaacf9cbad5f57b8c08e1b3e871462e9c", "html_url": "https://github.com/rust-lang/rust/commit/a95604fcaacf9cbad5f57b8c08e1b3e871462e9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a95604fcaacf9cbad5f57b8c08e1b3e871462e9c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fd3c07242e92b5f43ce8e120d711cde33a7ed1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fd3c07242e92b5f43ce8e120d711cde33a7ed1b", "html_url": "https://github.com/rust-lang/rust/commit/2fd3c07242e92b5f43ce8e120d711cde33a7ed1b"}, {"sha": "88bc11e646c8d1db7ac7894f74e2f660d9a82c54", "url": "https://api.github.com/repos/rust-lang/rust/commits/88bc11e646c8d1db7ac7894f74e2f660d9a82c54", "html_url": "https://github.com/rust-lang/rust/commit/88bc11e646c8d1db7ac7894f74e2f660d9a82c54"}], "stats": {"total": 387, "additions": 336, "deletions": 51}, "files": [{"sha": "3c50ff35358e7ccf14238e93b1a376790e552fa8", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a95604fcaacf9cbad5f57b8c08e1b3e871462e9c/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a95604fcaacf9cbad5f57b8c08e1b3e871462e9c/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=a95604fcaacf9cbad5f57b8c08e1b3e871462e9c", "patch": "@@ -8,6 +8,58 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*!\n+\n+C-string manipulation and management\n+\n+This modules provides the basic methods for creating and manipulating\n+null-terminated strings for use with FFI calls (back to C). Most C APIs require\n+that the string being passed to them is null-terminated, and by default rust's\n+string types are *not* null terminated.\n+\n+The other problem with translating Rust strings to C strings is that Rust\n+strings can validly contain a null-byte in the middle of the string (0 is a\n+valid unicode codepoint). This means that not all Rust strings can actually be\n+translated to C strings.\n+\n+# Creation of a C string\n+\n+A C string is managed through the `CString` type defined in this module. It\n+\"owns\" the internal buffer of characters and will automatically deallocate the\n+buffer when the string is dropped. The `ToCStr` trait is implemented for `&str`\n+and `&[u8]`, but the conversions can fail due to some of the limitations\n+explained above.\n+\n+This also means that currently whenever a C string is created, an allocation\n+must be performed to place the data elsewhere (the lifetime of the C string is\n+not tied to the lifetime of the original string/data buffer). If C strings are\n+heavily used in applications, then caching may be advisable to prevent\n+unnecessary amounts of allocations.\n+\n+An example of creating and using a C string would be:\n+\n+~~~{.rust}\n+use std::libc;\n+externfn!(fn puts(s: *libc::c_char))\n+\n+let my_string = \"Hello, world!\";\n+\n+// Allocate the C string with an explicit local that owns the string. The\n+// `c_buffer` pointer will be deallocated when `my_c_string` goes out of scope.\n+let my_c_string = my_string.to_c_str();\n+do my_c_string.with_ref |c_buffer| {\n+    unsafe { puts(c_buffer); }\n+}\n+\n+// Don't save off the allocation of the C string, the `c_buffer` will be\n+// deallocated when this block returns!\n+do my_string.with_c_str |c_buffer| {\n+    unsafe { puts(c_buffer); }\n+}\n+~~~\n+\n+*/\n+\n use cast;\n use iter::{Iterator, range};\n use libc;"}, {"sha": "c47dcfe3de69a1ce2db0bf8372303a2becb5144d", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 142, "deletions": 33, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/a95604fcaacf9cbad5f57b8c08e1b3e871462e9c/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a95604fcaacf9cbad5f57b8c08e1b3e871462e9c/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=a95604fcaacf9cbad5f57b8c08e1b3e871462e9c", "patch": "@@ -8,71 +8,179 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*! Condition handling */\n+/*!\n \n-#[allow(missing_doc)];\n+Condition handling\n+\n+Conditions are a utility used to deal with handling error conditions. The syntax\n+of a condition handler strikes a resemblance to try/catch blocks in other\n+languages, but condition handlers are *not* a form of exception handling in the\n+same manner.\n+\n+A condition is declared through the `condition!` macro provided by the compiler:\n+\n+~~~{.rust}\n+condition! {\n+    pub my_error: int -> ~str;\n+}\n+~~~\n+\n+This macro declares an inner module called `my_error` with one static variable,\n+`cond` that is a static `Condition` instance. To help understand what the other\n+parameters are used for, an example usage of this condition would be:\n+\n+~~~{.rust}\n+do my_error::cond.trap(|raised_int| {\n+\n+    // the condition `my_error` was raised on, and the value it raised is stored\n+    // in `raised_int`. This closure must return a `~str` type (as specified in\n+    // the declaration of the condition\n+    if raised_int == 3 { ~\"three\" } else { ~\"oh well\" }\n+\n+}).inside {\n+\n+    // The condition handler above is installed for the duration of this block.\n+    // That handler will override any previous handler, but the previous handler\n+    // is restored when this block returns (handlers nest)\n+    //\n+    // If any code from this block (or code from another block) raises on the\n+    // condition, then the above handler will be invoked (so long as there's no\n+    // other nested handler).\n+\n+    println(my_error::cond.raise(3)); // prints \"three\"\n+    println(my_error::cond.raise(4)); // prints \"oh well\"\n+\n+}\n+~~~\n+\n+Condition handling is useful in cases where propagating errors is either to\n+cumbersome or just not necessary in the first place. It should also be noted,\n+though, that if there is not handler installed when a condition is raised, then\n+the task invokes `fail!()` and will terminate.\n+\n+## More Info\n+\n+Condition handlers as an error strategy is well explained in the [conditions\n+tutorial](http://static.rust-lang.org/doc/master/tutorial-conditions.html),\n+along with comparing and contrasting it with other error handling strategies.\n+\n+*/\n \n use local_data;\n use prelude::*;\n+use unstable::raw::Closure;\n \n-// helper for transmutation, shown below.\n-type RustClosure = (int, int);\n-\n+#[doc(hidden)]\n pub struct Handler<T, U> {\n-    handle: RustClosure,\n-    prev: Option<@Handler<T, U>>,\n+    priv handle: Closure,\n+    priv prev: Option<@Handler<T, U>>,\n }\n \n+/// This struct represents the state of a condition handler. It contains a key\n+/// into TLS which holds the currently install handler, along with the name of\n+/// the condition (useful for debugging).\n+///\n+/// This struct should never be created directly, but rather only through the\n+/// `condition!` macro provided to all libraries using libstd.\n pub struct Condition<T, U> {\n+    /// Name of the condition handler\n     name: &'static str,\n+    /// TLS key used to insert/remove values in TLS.\n     key: local_data::Key<@Handler<T, U>>\n }\n \n impl<T, U> Condition<T, U> {\n+    /// Creates an object which binds the specified handler. This will also save\n+    /// the current handler *on creation* such that when the `Trap` is consumed,\n+    /// it knows which handler to restore.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~{.rust}\n+    /// condition! { my_error: int -> int; }\n+    ///\n+    /// let trap = my_error::cond.trap(|error| error + 3);\n+    ///\n+    /// // use `trap`'s inside method to register the handler and then run a\n+    /// // block of code with the handler registered\n+    /// ~~~\n     pub fn trap<'a>(&'a self, h: &'a fn(T) -> U) -> Trap<'a, T, U> {\n-        unsafe {\n-            let p : *RustClosure = ::cast::transmute(&h);\n-            let prev = local_data::get(self.key, |k| k.map(|&x| *x));\n-            let h = @Handler { handle: *p, prev: prev };\n-            Trap { cond: self, handler: h }\n-        }\n+        let h: Closure = unsafe { ::cast::transmute(h) };\n+        let prev = local_data::get(self.key, |k| k.map(|&x| *x));\n+        let h = @Handler { handle: h, prev: prev };\n+        Trap { cond: self, handler: h }\n     }\n \n+    /// Raises on this condition, invoking any handler if one has been\n+    /// registered, or failing the current task otherwise.\n+    ///\n+    /// While a condition handler is being run, the condition will have no\n+    /// handler listed, so a task failure will occur if the condition is\n+    /// re-raised during the handler.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * t - The argument to pass along to the condition handler.\n+    ///\n+    /// # Return value\n+    ///\n+    /// If a handler is found, its return value is returned, otherwise this\n+    /// function will not return.\n     pub fn raise(&self, t: T) -> U {\n         let msg = fmt!(\"Unhandled condition: %s: %?\", self.name, t);\n         self.raise_default(t, || fail!(msg.clone()))\n     }\n \n+    /// Performs the same functionality as `raise`, except that when no handler\n+    /// is found the `default` argument is called instead of failing the task.\n     pub fn raise_default(&self, t: T, default: &fn() -> U) -> U {\n-        unsafe {\n-            match local_data::pop(self.key) {\n-                None => {\n-                    debug!(\"Condition.raise: found no handler\");\n-                    default()\n-                }\n-                Some(handler) => {\n-                    debug!(\"Condition.raise: found handler\");\n-                    match handler.prev {\n-                        None => {}\n-                        Some(hp) => local_data::set(self.key, hp)\n-                    }\n-                    let handle : &fn(T) -> U =\n-                        ::cast::transmute(handler.handle);\n-                    let u = handle(t);\n-                    local_data::set(self.key, handler);\n-                    u\n+        match local_data::pop(self.key) {\n+            None => {\n+                debug!(\"Condition.raise: found no handler\");\n+                default()\n+            }\n+            Some(handler) => {\n+                debug!(\"Condition.raise: found handler\");\n+                match handler.prev {\n+                    None => {}\n+                    Some(hp) => local_data::set(self.key, hp)\n                 }\n+                let handle : &fn(T) -> U = unsafe {\n+                    ::cast::transmute(handler.handle)\n+                };\n+                let u = handle(t);\n+                local_data::set(self.key, handler);\n+                u\n             }\n         }\n     }\n }\n \n+/// A `Trap` is created when the `trap` method is invoked on a `Condition`, and\n+/// it is used to actually bind a handler into the TLS slot reserved for this\n+/// condition.\n+///\n+/// Normally this object is not dealt with directly, but rather it's directly\n+/// used after being returned from `trap`\n struct Trap<'self, T, U> {\n-    cond: &'self Condition<T, U>,\n-    handler: @Handler<T, U>\n+    priv cond: &'self Condition<T, U>,\n+    priv handler: @Handler<T, U>\n }\n \n impl<'self, T, U> Trap<'self, T, U> {\n+    /// Execute a block of code with this trap handler's exception handler\n+    /// registered.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~{.rust}\n+    /// condition! { my_error: int -> int; }\n+    ///\n+    /// let result = do my_error::cond.trap(|error| error + 3).inside {\n+    ///     my_error::cond.raise(4)\n+    /// };\n+    /// assert_eq!(result, 7);\n+    /// ~~~\n     pub fn inside<V>(&self, inner: &'self fn() -> V) -> V {\n         let _g = Guard { cond: self.cond };\n         debug!(\"Trap: pushing handler to TLS\");\n@@ -81,8 +189,9 @@ impl<'self, T, U> Trap<'self, T, U> {\n     }\n }\n \n+#[doc(hidden)]\n struct Guard<'self, T, U> {\n-    cond: &'self Condition<T, U>\n+    priv cond: &'self Condition<T, U>\n }\n \n #[unsafe_destructor]"}, {"sha": "99a5ed4d69812c84dfb7bdb37ca436b9ceb4f058", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a95604fcaacf9cbad5f57b8c08e1b3e871462e9c/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a95604fcaacf9cbad5f57b8c08e1b3e871462e9c/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=a95604fcaacf9cbad5f57b8c08e1b3e871462e9c", "patch": "@@ -10,17 +10,18 @@\n \n /*!\n \n-# The Formatting Module\n+The Formatting Module\n \n-This module contains the runtime support for the `format!` syntax extension. This\n-macro is implemented in the compiler to emit calls to this module in order to\n-format arguments at runtime into strings and streams.\n+This module contains the runtime support for the `format!` syntax extension.\n+This macro is implemented in the compiler to emit calls to this module in order\n+to format arguments at runtime into strings and streams.\n \n The functions contained in this module should not normally be used in everyday\n-use cases of `format!`. The assumptions made by these functions are unsafe for all\n-inputs, and the compiler performs a large amount of validation on the arguments\n-to `format!` in order to ensure safety at runtime. While it is possible to call\n-these functions directly, it is not recommended to do so in the general case.\n+use cases of `format!`. The assumptions made by these functions are unsafe for\n+all inputs, and the compiler performs a large amount of validation on the\n+arguments to `format!` in order to ensure safety at runtime. While it is\n+possible to call these functions directly, it is not recommended to do so in the\n+general case.\n \n ## Usage\n "}, {"sha": "87fad9aae70a97de06f0452bb5fd97b53a82d7c5", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a95604fcaacf9cbad5f57b8c08e1b3e871462e9c/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a95604fcaacf9cbad5f57b8c08e1b3e871462e9c/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=a95604fcaacf9cbad5f57b8c08e1b3e871462e9c", "patch": "@@ -8,12 +8,59 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*! Composable external iterators\n+/*!\n \n-The `Iterator` trait defines an interface for objects which implement iteration as a state machine.\n+Composable external iterators\n \n-Algorithms like `zip` are provided as `Iterator` implementations which wrap other objects\n-implementing the `Iterator` trait.\n+# The `Iterator` trait\n+\n+This module defines Rust's core iteration trait. The `Iterator` trait has one\n+un-implemented method, `next`. All other methods are derived through default\n+methods to perform operations such as `zip`, `chain`, `enumerate`, and `fold`.\n+\n+The goal of this module is to unify iteration across all containers in Rust.\n+An iterator can be considered as a state machine which is used to track which\n+element will be yielded next.\n+\n+There are various extensions also defined in this module to assist with various\n+types of iteration, such as the `DoubleEndedIterator` for iterating in reverse,\n+the `FromIterator` trait for creating a container from an iterator, and much\n+more.\n+\n+## Rust's `for` loop\n+\n+The special syntax used by rust's `for` loop is based around the `Iterator`\n+trait defined in this module. For loops can be viewed as a syntactical expansion\n+into a `loop`, for example, the `for` loop in this example is essentially\n+translated to the `loop` below.\n+\n+~~~{.rust}\n+let values = ~[1, 2, 3];\n+\n+// \"Syntactical sugar\" taking advantage of an iterator\n+for &x in values.iter() {\n+    println!(\"{}\", x);\n+}\n+\n+// Rough translation of the iteration without a `for` iterator.\n+let mut it = values.iter();\n+loop {\n+    match it.next() {\n+        Some(&x) => {\n+            println!(\"{}\", x);\n+        }\n+        None => { break }\n+    }\n+}\n+~~~\n+\n+This `for` loop syntax can be applied to any iterator over any type.\n+\n+## Iteration protocol and more\n+\n+More detailed information about iterators can be found in the [container\n+tutorial](http://static.rust-lang.org/doc/master/tutorial-container.html) with\n+the rest of the rust manuals.\n \n */\n "}, {"sha": "db4fe5fc762bac43622d64174685f7b38de43a1b", "filename": "src/libstd/str.rs", "status": "modified", "additions": 80, "deletions": 6, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a95604fcaacf9cbad5f57b8c08e1b3e871462e9c/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a95604fcaacf9cbad5f57b8c08e1b3e871462e9c/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=a95604fcaacf9cbad5f57b8c08e1b3e871462e9c", "patch": "@@ -8,12 +8,86 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! String manipulation\n-//!\n-//! Strings are a packed UTF-8 representation of text, stored as\n-//! buffers of u8 bytes. The buffer is not null terminated.\n-//! Strings should be indexed in bytes, for efficiency, but UTF-8 unsafe\n-//! operations should be avoided.\n+/*!\n+\n+String manipulation\n+\n+# Basic Usage\n+\n+Rust's string type is one of the core primitive types of the language. While\n+represented by the name `str`, the name `str` is not actually a valid type in\n+Rust. Each string must also be decorated with how its ownership. This means that\n+there are three common kinds of strings in rust:\n+\n+* `~str` - This is an owned string. This type obeys all of the normal semantics\n+           of the `~T` types, meaning that it has one, and only one, owner. This\n+           type cannot be implicitly copied, and is moved out of when passed to\n+           other functions.\n+\n+* `@str` - This is a managed string. Similarly to `@T`, this type can be\n+           implicitly copied, and each implicit copy will increment the\n+           reference count to the string. This means that there is not \"true\n+           owner\" of the string, and the string will be deallocated when the\n+           reference count reaches 0.\n+\n+* `&str` - Finally, this is the borrowed string type. This type of string can\n+           only be created from one of the other two kinds of strings. As the\n+           name \"borrowed\" implies, this type of string is owned elsewhere, and\n+           this string cannot be moved out of.\n+\n+As an example, here's a few different kinds of strings.\n+\n+~~~{.rust}\n+let owned_string = ~\"I am an owned string\";\n+let managed_string = @\"This string is garbage-collected\";\n+let borrowed_string1 = \"This string is borrowed with the 'static lifetime\";\n+let borrowed_string2: &str = owned_string;   // owned strings can be borrowed\n+let borrowed_string3: &str = managed_string; // managed strings can also be borrowed\n+~~~\n+\n+From the example above, you can see that rust has 3 different kinds of string\n+literals. The owned/managed literals correspond to the owned/managed string\n+types, but the \"borrowed literal\" is actually more akin to C's concept of a\n+static string.\n+\n+When a string is declared without a `~` or `@` sigil, then the string is\n+allocated statically in the rodata of the executable/library. The string then\n+has the type `&'static str` meaning that the string is valid for the `'static`\n+lifetime, otherwise known as the lifetime of the entire program. As can be\n+inferred from the type, these static strings are not mutable.\n+\n+# Mutability\n+\n+Many languages have immutable strings by default, and rust has a particular\n+flavor on this idea. As with the rest of Rust types, strings are immutable by\n+default. If a string is declared as `mut`, however, it may be mutated. This\n+works the same way as the rest of Rust's type system in the sense that if\n+there's a mutable reference to a string, there may only be one mutable reference\n+to that string. With these guarantees, strings can easily transition between\n+being mutable/immutable with the same benefits of having mutable strings in\n+other languages.\n+\n+~~~{.rust}\n+let mut buf = ~\"testing\";\n+buf.push_char(' ');\n+buf.push_str(\"123\");\n+assert_eq!(buf, ~\"testing 123\");\n+~~~\n+\n+# Representation\n+\n+Rust's string type, `str`, is a sequence of unicode codepoints encoded as a\n+stream of UTF-8 bytes. All safely-created strings are guaranteed to be validly\n+encoded UTF-8 sequences. Additionally, strings are not guaranteed to be\n+null-terminated (the null byte is a valid unicode codepoint).\n+\n+The actual representation of strings have direct mappings to vectors:\n+\n+* `~str` is the same as `~[u8]`\n+* `&str` is the same as `&[u8]`\n+* `@str` is the same as `@[u8]`\n+\n+*/\n \n use at_vec;\n use cast;"}, {"sha": "3cdee0eb19ad946648b77fdf2b28d0a55058aca3", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a95604fcaacf9cbad5f57b8c08e1b3e871462e9c/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a95604fcaacf9cbad5f57b8c08e1b3e871462e9c/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=a95604fcaacf9cbad5f57b8c08e1b3e871462e9c", "patch": "@@ -10,6 +10,8 @@\n \n /*!\n \n+Vector manipulation\n+\n The `vec` module contains useful code to help work with vector values.\n Vectors are Rust's list type. Vectors contain zero or more values of\n homogeneous types:"}]}