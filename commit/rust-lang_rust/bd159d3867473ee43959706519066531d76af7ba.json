{"sha": "bd159d3867473ee43959706519066531d76af7ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkMTU5ZDM4Njc0NzNlZTQzOTU5NzA2NTE5MDY2NTMxZDc2YWY3YmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-29T19:21:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-29T19:21:12Z"}, "message": "auto merge of #15955 : nikomatsakis/rust/issue-5527-new-inference-scheme, r=pcwalton\n\nThe inference scheme proposed in <http://smallcultfollowing.com/babysteps/blog/2014/07/09/an-experimental-new-type-inference-scheme-for-rust/>.\r\n\r\nThis is theoretically a [breaking-change]. It is possible that you may encounter type checking errors, particularly related to closures or functions with higher-ranked lifetimes or object types. Adding more explicit type annotations should help the problem. However, I have not been able to make an example that *actually* successfully compiles with the older scheme and fails with the newer scheme.\r\n\r\nf? @pcwalton, @pnkfelix", "tree": {"sha": "bbd2ce8f651f6e4377aa835a006cf34770b5579f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbd2ce8f651f6e4377aa835a006cf34770b5579f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd159d3867473ee43959706519066531d76af7ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd159d3867473ee43959706519066531d76af7ba", "html_url": "https://github.com/rust-lang/rust/commit/bd159d3867473ee43959706519066531d76af7ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd159d3867473ee43959706519066531d76af7ba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51d0d0641000d642b257beb2fe53f5174a7879d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/51d0d0641000d642b257beb2fe53f5174a7879d5", "html_url": "https://github.com/rust-lang/rust/commit/51d0d0641000d642b257beb2fe53f5174a7879d5"}, {"sha": "6e27c2fd58e290a05653560199762268d50165ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e27c2fd58e290a05653560199762268d50165ff", "html_url": "https://github.com/rust-lang/rust/commit/6e27c2fd58e290a05653560199762268d50165ff"}], "stats": {"total": 2589, "additions": 1535, "deletions": 1054}, "files": [{"sha": "ebce1a2a69b1431a0daa75716273982ded478683", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -136,6 +136,7 @@ pub mod util {\n     pub mod common;\n     pub mod ppaux;\n     pub mod nodemap;\n+    pub mod snapshot_vec;\n }\n \n pub mod lib {"}, {"sha": "6f2dd6e099235ebe290814c5c8c9aabc737d4b19", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -30,7 +30,6 @@ use middle::subst::{Subst, Substs, VecPerParamSpace};\n use middle::subst;\n use middle::ty;\n use middle::typeck;\n-use middle::typeck::MethodCall;\n use middle::ty_fold;\n use middle::ty_fold::{TypeFoldable,TypeFolder};\n use middle;"}, {"sha": "f54e650a173441e42300601809b8b7c43df45051", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 190, "deletions": 84, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -1381,8 +1381,8 @@ fn link_by_ref(rcx: &Rcx,\n            expr.repr(tcx), callee_scope);\n     let mc = mc::MemCategorizationContext::new(rcx);\n     let expr_cmt = ignore_err!(mc.cat_expr(expr));\n-    let region_min = ty::ReScope(callee_scope);\n-    link_region(rcx, expr.span, region_min, ty::ImmBorrow, expr_cmt);\n+    let borrow_region = ty::ReScope(callee_scope);\n+    link_region(rcx, expr.span, borrow_region, ty::ImmBorrow, expr_cmt);\n }\n \n fn link_region_from_node_type(rcx: &Rcx,\n@@ -1408,102 +1408,54 @@ fn link_region_from_node_type(rcx: &Rcx,\n \n fn link_region(rcx: &Rcx,\n                span: Span,\n-               region_min: ty::Region,\n-               kind: ty::BorrowKind,\n-               cmt_borrowed: mc::cmt) {\n+               borrow_region: ty::Region,\n+               borrow_kind: ty::BorrowKind,\n+               borrow_cmt: mc::cmt) {\n     /*!\n-     * Informs the inference engine that a borrow of `cmt`\n-     * must have the borrow kind `kind` and lifetime `region_min`.\n-     * If `cmt` is a deref of a region pointer with\n-     * lifetime `r_borrowed`, this will add the constraint that\n-     * `region_min <= r_borrowed`.\n+     * Informs the inference engine that `borrow_cmt` is being\n+     * borrowed with kind `borrow_kind` and lifetime `borrow_region`.\n+     * In order to ensure borrowck is satisfied, this may create\n+     * constraints between regions, as explained in\n+     * `link_reborrowed_region()`.\n      */\n \n-    // Iterate through all the things that must be live at least\n-    // for the lifetime `region_min` for the borrow to be valid:\n-    let mut cmt_borrowed = cmt_borrowed;\n+    let mut borrow_cmt = borrow_cmt;\n+    let mut borrow_kind = borrow_kind;\n+\n     loop {\n-        debug!(\"link_region(region_min={}, kind={}, cmt_borrowed={})\",\n-               region_min.repr(rcx.tcx()),\n-               kind.repr(rcx.tcx()),\n-               cmt_borrowed.repr(rcx.tcx()));\n-        match cmt_borrowed.cat.clone() {\n-            mc::cat_deref(base, _, mc::BorrowedPtr(_, r_borrowed)) |\n-            mc::cat_deref(base, _, mc::Implicit(_, r_borrowed)) => {\n-                // References to an upvar `x` are translated to\n-                // `*x`, since that is what happens in the\n-                // underlying machine.  We detect such references\n-                // and treat them slightly differently, both to\n-                // offer better error messages and because we need\n-                // to infer the kind of borrow (mut, const, etc)\n-                // to use for each upvar.\n-                let cause = match base.cat {\n-                    mc::cat_upvar(ref upvar_id, _) => {\n-                        match rcx.fcx.inh.upvar_borrow_map.borrow_mut()\n-                                 .find_mut(upvar_id) {\n-                            Some(upvar_borrow) => {\n-                                debug!(\"link_region: {} <= {}\",\n-                                       region_min.repr(rcx.tcx()),\n-                                       upvar_borrow.region.repr(rcx.tcx()));\n-                                adjust_upvar_borrow_kind_for_loan(\n-                                    *upvar_id,\n-                                    upvar_borrow,\n-                                    kind);\n-                                infer::ReborrowUpvar(span, *upvar_id)\n-                            }\n-                            None => {\n-                                rcx.tcx().sess.span_bug(\n-                                    span,\n-                                    format!(\"Illegal upvar id: {}\",\n-                                            upvar_id.repr(\n-                                                rcx.tcx())).as_slice());\n-                            }\n-                        }\n+        debug!(\"link_region(borrow_region={}, borrow_kind={}, borrow_cmt={})\",\n+               borrow_region.repr(rcx.tcx()),\n+               borrow_kind.repr(rcx.tcx()),\n+               borrow_cmt.repr(rcx.tcx()));\n+        match borrow_cmt.cat.clone() {\n+            mc::cat_deref(ref_cmt, _,\n+                          mc::Implicit(ref_kind, ref_region)) |\n+            mc::cat_deref(ref_cmt, _,\n+                          mc::BorrowedPtr(ref_kind, ref_region)) => {\n+                match link_reborrowed_region(rcx, span,\n+                                             borrow_region, borrow_kind,\n+                                             ref_cmt, ref_region, ref_kind) {\n+                    Some((c, k)) => {\n+                        borrow_cmt = c;\n+                        borrow_kind = k;\n                     }\n-\n-                    _ => {\n-                        infer::Reborrow(span)\n+                    None => {\n+                        return;\n                     }\n-                };\n-\n-                debug!(\"link_region: {} <= {}\",\n-                       region_min.repr(rcx.tcx()),\n-                       r_borrowed.repr(rcx.tcx()));\n-                rcx.fcx.mk_subr(cause, region_min, r_borrowed);\n-\n-                if kind != ty::ImmBorrow {\n-                    // If this is a mutable borrow, then the thing\n-                    // being borrowed will have to be unique.\n-                    // In user code, this means it must be an `&mut`\n-                    // borrow, but for an upvar, we might opt\n-                    // for an immutable-unique borrow.\n-                    adjust_upvar_borrow_kind_for_unique(rcx, base);\n                 }\n-\n-                // Borrowing an `&mut` pointee for `region_min` is\n-                // only valid if the pointer resides in a unique\n-                // location which is itself valid for\n-                // `region_min`.  We don't care about the unique\n-                // part, but we may need to influence the\n-                // inference to ensure that the location remains\n-                // valid.\n-                //\n-                // FIXME(#8624) fixing borrowck will require this\n-                // if m == ast::m_mutbl {\n-                //    cmt_borrowed = cmt_base;\n-                // } else {\n-                //    return;\n-                // }\n-                return;\n             }\n+\n             mc::cat_discr(cmt_base, _) |\n             mc::cat_downcast(cmt_base) |\n             mc::cat_deref(cmt_base, _, mc::GcPtr(..)) |\n             mc::cat_deref(cmt_base, _, mc::OwnedPtr) |\n             mc::cat_interior(cmt_base, _) => {\n-                // Interior or owned data requires its base to be valid\n-                cmt_borrowed = cmt_base;\n+                // Borrowing interior or owned data requires the base\n+                // to be valid and borrowable in the same fashion.\n+                borrow_cmt = cmt_base;\n+                borrow_kind = borrow_kind;\n             }\n+\n             mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n             mc::cat_static_item |\n             mc::cat_copied_upvar(..) |\n@@ -1519,6 +1471,154 @@ fn link_region(rcx: &Rcx,\n     }\n }\n \n+fn link_reborrowed_region(rcx: &Rcx,\n+                          span: Span,\n+                          borrow_region: ty::Region,\n+                          borrow_kind: ty::BorrowKind,\n+                          ref_cmt: mc::cmt,\n+                          ref_region: ty::Region,\n+                          ref_kind: ty::BorrowKind)\n+                          -> Option<(mc::cmt, ty::BorrowKind)>\n+{\n+    /*!\n+     * This is the most complicated case: the path being borrowed is\n+     * itself the referent of a borrowed pointer. Let me give an\n+     * example fragment of code to make clear(er) the situation:\n+     *\n+     *    let r: &'a mut T = ...;  // the original reference \"r\" has lifetime 'a\n+     *    ...\n+     *    &'z *r                   // the reborrow has lifetime 'z\n+     *\n+     * Now, in this case, our primary job is to add the inference\n+     * constraint that `'z <= 'a`. Given this setup, let's clarify the\n+     * parameters in (roughly) terms of the example:\n+     *\n+     *     A borrow of: `& 'z bk * r` where `r` has type `& 'a bk T`\n+     *     borrow_region   ^~                 ref_region    ^~\n+     *     borrow_kind        ^~               ref_kind        ^~\n+     *     ref_cmt                 ^\n+     *\n+     * Here `bk` stands for some borrow-kind (e.g., `mut`, `uniq`, etc).\n+     *\n+     * Unfortunately, there are some complications beyond the simple\n+     * scenario I just painted:\n+     *\n+     * 1. The reference `r` might in fact be a \"by-ref\" upvar. In that\n+     *    case, we have two jobs. First, we are inferring whether this reference\n+     *    should be an `&T`, `&mut T`, or `&uniq T` reference, and we must\n+     *    adjust that based on this borrow (e.g., if this is an `&mut` borrow,\n+     *    then `r` must be an `&mut` reference). Second, whenever we link\n+     *    two regions (here, `'z <= 'a`), we supply a *cause*, and in this\n+     *    case we adjust the cause to indicate that the reference being\n+     *    \"reborrowed\" is itself an upvar. This provides a nicer error message\n+     *    should something go wrong.\n+     *\n+     * 2. There may in fact be more levels of reborrowing. In the\n+     *    example, I said the borrow was like `&'z *r`, but it might\n+     *    in fact be a borrow like `&'z **q` where `q` has type `&'a\n+     *    &'b mut T`. In that case, we want to ensure that `'z <= 'a`\n+     *    and `'z <= 'b`. This is explained more below.\n+     *\n+     * The return value of this function indicates whether we need to\n+     * recurse and process `ref_cmt` (see case 2 above).\n+     */\n+\n+    // Detect references to an upvar `x`:\n+    let cause = match ref_cmt.cat {\n+        mc::cat_upvar(ref upvar_id, _) => {\n+            let mut upvar_borrow_map =\n+                rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n+            match upvar_borrow_map.find_mut(upvar_id) {\n+                Some(upvar_borrow) => {\n+                    // Adjust mutability that we infer for the upvar\n+                    // so it can accommodate being borrowed with\n+                    // mutability `kind`:\n+                    adjust_upvar_borrow_kind_for_loan(*upvar_id,\n+                                                      upvar_borrow,\n+                                                      borrow_kind);\n+\n+                    infer::ReborrowUpvar(span, *upvar_id)\n+                }\n+                None => {\n+                    rcx.tcx().sess.span_bug(\n+                        span,\n+                        format!(\"Illegal upvar id: {}\",\n+                                upvar_id.repr(\n+                                    rcx.tcx())).as_slice());\n+                }\n+            }\n+        }\n+\n+        _ => {\n+            infer::Reborrow(span)\n+        }\n+    };\n+\n+    debug!(\"link_reborrowed_region: {} <= {}\",\n+           borrow_region.repr(rcx.tcx()),\n+           ref_region.repr(rcx.tcx()));\n+    rcx.fcx.mk_subr(cause, borrow_region, ref_region);\n+\n+    // Decide whether we need to recurse and link any regions within\n+    // the `ref_cmt`. This is concerned for the case where the value\n+    // being reborrowed is in fact a borrowed pointer found within\n+    // another borrowed pointer. For example:\n+    //\n+    //    let p: &'b &'a mut T = ...;\n+    //    ...\n+    //    &'z **p\n+    //\n+    // What makes this case particularly tricky is that, if the data\n+    // being borrowed is a `&mut` or `&uniq` borrow, borrowck requires\n+    // not only that `'z <= 'a`, (as before) but also `'z <= 'b`\n+    // (otherwise the user might mutate through the `&mut T` reference\n+    // after `'b` expires and invalidate the borrow we are looking at\n+    // now).\n+    //\n+    // So let's re-examine our parameters in light of this more\n+    // complicated (possible) scenario:\n+    //\n+    //     A borrow of: `& 'z bk * * p` where `p` has type `&'b bk & 'a bk T`\n+    //     borrow_region   ^~                 ref_region             ^~\n+    //     borrow_kind        ^~               ref_kind                 ^~\n+    //     ref_cmt                 ^~~\n+    //\n+    // (Note that since we have not examined `ref_cmt.cat`, we don't\n+    // know whether this scenario has occurred; but I wanted to show\n+    // how all the types get adjusted.)\n+    match ref_kind {\n+        ty::ImmBorrow => {\n+            // The reference being reborrowed is a sharable ref of\n+            // type `&'a T`. In this case, it doesn't matter where we\n+            // *found* the `&T` pointer, the memory it references will\n+            // be valid and immutable for `'a`. So we can stop here.\n+            //\n+            // (Note that the `borrow_kind` must also be ImmBorrow or\n+            // else the user is borrowed imm memory as mut memory,\n+            // which means they'll get an error downstream in borrowck\n+            // anyhow.)\n+            return None;\n+        }\n+\n+        ty::MutBorrow | ty::UniqueImmBorrow => {\n+            // The reference being reborrowed is either an `&mut T` or\n+            // `&uniq T`. This is the case where recursion is needed.\n+            //\n+            // One interesting twist is that we can weaken the borrow\n+            // kind when we recurse: to reborrow an `&mut` referent as\n+            // mutable, borrowck requires a unique path to the `&mut`\n+            // reference but not necessarily a *mutable* path.\n+            let new_borrow_kind = match borrow_kind {\n+                ty::ImmBorrow =>\n+                    ty::ImmBorrow,\n+                ty::MutBorrow | ty::UniqueImmBorrow =>\n+                    ty::UniqueImmBorrow\n+            };\n+            return Some((ref_cmt, new_borrow_kind));\n+        }\n+    }\n+}\n+\n fn adjust_borrow_kind_for_assignment_lhs(rcx: &Rcx,\n                                          lhs: &ast::Expr) {\n     /*!\n@@ -1534,6 +1634,12 @@ fn adjust_borrow_kind_for_assignment_lhs(rcx: &Rcx,\n \n fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,\n                                     cmt: mc::cmt) {\n+    /*!\n+     * Indicates that `cmt` is being directly mutated (e.g., assigned\n+     * to).  If cmt contains any by-ref upvars, this implies that\n+     * those upvars must be borrowed using an `&mut` borow.\n+     */\n+\n     let mut cmt = cmt;\n     loop {\n         debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={})\","}, {"sha": "9013b468d3f89742e8bc0485b151aad91ab0af01", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -247,7 +247,7 @@ impl<'f> Coerce<'f> {\n         let a_borrowed = ty::mk_rptr(self.get_ref().infcx.tcx,\n                                      r_borrow,\n                                      mt {ty: inner_ty, mutbl: mutbl_b});\n-        if_ok!(sub.tys(a_borrowed, b));\n+        try!(sub.tys(a_borrowed, b));\n \n         Ok(Some(AutoDerefRef(AutoDerefRef {\n             autoderefs: 1,\n@@ -273,7 +273,7 @@ impl<'f> Coerce<'f> {\n                 let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n                 let unsized_ty = ty::mk_slice(self.get_ref().infcx.tcx, r_borrow,\n                                               mt {ty: t_a, mutbl: mutbl_b});\n-                if_ok!(self.get_ref().infcx.try(|| sub.tys(unsized_ty, b)));\n+                try!(self.get_ref().infcx.try(|| sub.tys(unsized_ty, b)));\n                 Ok(Some(AutoDerefRef(AutoDerefRef {\n                     autoderefs: 0,\n                     autoref: Some(ty::AutoPtr(r_borrow,\n@@ -316,7 +316,7 @@ impl<'f> Coerce<'f> {\n                             let ty = ty::mk_rptr(self.get_ref().infcx.tcx,\n                                                  r_borrow,\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                            if_ok!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n+                            try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoPtr(AutoUnsize({:?})))\", kind);\n                             Ok(Some(AutoDerefRef(AutoDerefRef {\n@@ -334,7 +334,7 @@ impl<'f> Coerce<'f> {\n                     match self.unsize_ty(sty_a, t_b) {\n                         Some((ty, kind)) => {\n                             let ty = ty::mk_uniq(self.get_ref().infcx.tcx, ty);\n-                            if_ok!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n+                            try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoUnsizeUniq({:?}))\", kind);\n                             Ok(Some(AutoDerefRef(AutoDerefRef {\n@@ -458,7 +458,7 @@ impl<'f> Coerce<'f> {\n             }\n         };\n \n-        if_ok!(self.subtype(a_borrowed, b));\n+        try!(self.subtype(a_borrowed, b));\n         Ok(Some(AutoDerefRef(AutoDerefRef {\n             autoderefs: 1,\n             autoref: Some(AutoPtr(r_a, b_mutbl, None))\n@@ -512,7 +512,7 @@ impl<'f> Coerce<'f> {\n                                                 sig: fn_ty_a.sig.clone(),\n                                                 .. *fn_ty_b\n                                            });\n-            if_ok!(self.subtype(a_closure, b));\n+            try!(self.subtype(a_closure, b));\n             Ok(Some(adj))\n         })\n     }\n@@ -536,7 +536,7 @@ impl<'f> Coerce<'f> {\n \n         // check that the types which they point at are compatible\n         let a_unsafe = ty::mk_ptr(self.get_ref().infcx.tcx, mt_a);\n-        if_ok!(self.subtype(a_unsafe, b));\n+        try!(self.subtype(a_unsafe, b));\n \n         // although references and unsafe ptrs have the same\n         // representation, we still register an AutoDerefRef so that"}, {"sha": "2a44ef9de2b1b6cf98a6b66f467366349650f1b2", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 176, "deletions": 100, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -8,43 +8,29 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ______________________________________________________________________\n-// Type combining\n+///////////////////////////////////////////////////////////////////////////\n+// # Type combining\n //\n-// There are three type combiners: sub, lub, and glb.  Each implements\n-// the trait `Combine` and contains methods for combining two\n-// instances of various things and yielding a new instance.  These\n-// combiner methods always yield a `result<T>`---failure is propagated\n-// upward using `and_then()` methods.  There is a lot of common code for\n-// these operations, implemented as default methods on the `Combine`\n-// trait.\n+// There are four type combiners: equate, sub, lub, and glb.  Each\n+// implements the trait `Combine` and contains methods for combining\n+// two instances of various things and yielding a new instance.  These\n+// combiner methods always yield a `Result<T>`.  There is a lot of\n+// common code for these operations, implemented as default methods on\n+// the `Combine` trait.\n //\n-// In reality, the sub operation is rather different from lub/glb, but\n-// they are combined into one trait to avoid duplication (they used to\n-// be separate but there were many bugs because there were two copies\n-// of most routines).\n+// Each operation may have side-effects on the inference context,\n+// though these can be unrolled using snapshots. On success, the\n+// LUB/GLB operations return the appropriate bound. The Eq and Sub\n+// operations generally return the first operand.\n //\n-// The differences are:\n-//\n-// - when making two things have a sub relationship, the order of the\n-//   arguments is significant (a <: b) and the return value of the\n-//   combine functions is largely irrelevant.  The important thing is\n-//   whether the action succeeds or fails.  If it succeeds, then side\n-//   effects have been committed into the type variables.\n-//\n-// - for GLB/LUB, the order of arguments is not significant (GLB(a,b) ==\n-//   GLB(b,a)) and the return value is important (it is the GLB).  Of\n-//   course GLB/LUB may also have side effects.\n-//\n-// Contravariance\n+// ## Contravariance\n //\n // When you are relating two things which have a contravariant\n // relationship, you should use `contratys()` or `contraregions()`,\n // rather than inversing the order of arguments!  This is necessary\n // because the order of arguments is not relevant for LUB and GLB.  It\n // is also useful to track which value is the \"expected\" value in\n-// terms of error reporting, although we do not do that properly right\n-// now.\n+// terms of error reporting.\n \n \n use middle::subst;\n@@ -53,14 +39,16 @@ use middle::ty::{FloatVar, FnSig, IntVar, TyVar};\n use middle::ty::{IntType, UintType};\n use middle::ty::{BuiltinBounds};\n use middle::ty;\n-use middle::typeck::infer::{ToUres};\n+use middle::typeck::infer::equate::Equate;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n-use middle::typeck::infer::{InferCtxt, cres, ures};\n-use middle::typeck::infer::{TypeTrace};\n-use util::common::indent;\n+use middle::typeck::infer::{InferCtxt, cres};\n+use middle::typeck::infer::{MiscVariable, TypeTrace};\n+use middle::typeck::infer::type_variable::{RelationDir, EqTo,\n+                                           SubtypeOf, SupertypeOf};\n+use middle::ty_fold::{RegionFolder, TypeFoldable};\n use util::ppaux::Repr;\n \n use std::result;\n@@ -75,6 +63,7 @@ pub trait Combine {\n     fn a_is_expected(&self) -> bool;\n     fn trace(&self) -> TypeTrace;\n \n+    fn equate<'a>(&'a self) -> Equate<'a>;\n     fn sub<'a>(&'a self) -> Sub<'a>;\n     fn lub<'a>(&'a self) -> Lub<'a>;\n     fn glb<'a>(&'a self) -> Glb<'a>;\n@@ -101,7 +90,7 @@ pub trait Combine {\n         try!(result::fold_(as_\n                           .iter()\n                           .zip(bs.iter())\n-                          .map(|(a, b)| eq_tys(self, *a, *b))));\n+                          .map(|(a, b)| self.equate().tys(*a, *b))));\n         Ok(Vec::from_slice(as_))\n     }\n \n@@ -121,7 +110,7 @@ pub trait Combine {\n         for &space in subst::ParamSpace::all().iter() {\n             let a_tps = a_subst.types.get_slice(space);\n             let b_tps = b_subst.types.get_slice(space);\n-            let tps = if_ok!(self.tps(space, a_tps, b_tps));\n+            let tps = try!(self.tps(space, a_tps, b_tps));\n \n             let a_regions = a_subst.regions().get_slice(space);\n             let b_regions = b_subst.regions().get_slice(space);\n@@ -137,11 +126,11 @@ pub trait Combine {\n                 }\n             };\n \n-            let regions = if_ok!(relate_region_params(self,\n-                                                      item_def_id,\n-                                                      r_variances,\n-                                                      a_regions,\n-                                                      b_regions));\n+            let regions = try!(relate_region_params(self,\n+                                                    item_def_id,\n+                                                    r_variances,\n+                                                    a_regions,\n+                                                    b_regions));\n \n             substs.types.replace(space, tps);\n             substs.mut_regions().replace(space, regions);\n@@ -177,25 +166,22 @@ pub trait Combine {\n                 let b_r = b_rs[i];\n                 let variance = variances[i];\n                 let r = match variance {\n-                    ty::Invariant => {\n-                        eq_regions(this, a_r, b_r)\n-                            .and_then(|()| Ok(a_r))\n-                    }\n+                    ty::Invariant => this.equate().regions(a_r, b_r),\n                     ty::Covariant => this.regions(a_r, b_r),\n                     ty::Contravariant => this.contraregions(a_r, b_r),\n                     ty::Bivariant => Ok(a_r),\n                 };\n-                rs.push(if_ok!(r));\n+                rs.push(try!(r));\n             }\n             Ok(rs)\n         }\n     }\n \n     fn bare_fn_tys(&self, a: &ty::BareFnTy,\n                    b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n-        let fn_style = if_ok!(self.fn_styles(a.fn_style, b.fn_style));\n-        let abi = if_ok!(self.abi(a.abi, b.abi));\n-        let sig = if_ok!(self.fn_sigs(&a.sig, &b.sig));\n+        let fn_style = try!(self.fn_styles(a.fn_style, b.fn_style));\n+        let abi = try!(self.abi(a.abi, b.abi));\n+        let sig = try!(self.fn_sigs(&a.sig, &b.sig));\n         Ok(ty::BareFnTy {fn_style: fn_style,\n                 abi: abi,\n                 sig: sig})\n@@ -207,7 +193,7 @@ pub trait Combine {\n         let store = match (a.store, b.store) {\n             (ty::RegionTraitStore(a_r, a_m),\n              ty::RegionTraitStore(b_r, b_m)) if a_m == b_m => {\n-                let r = if_ok!(self.contraregions(a_r, b_r));\n+                let r = try!(self.contraregions(a_r, b_r));\n                 ty::RegionTraitStore(r, a_m)\n             }\n \n@@ -219,11 +205,11 @@ pub trait Combine {\n                 return Err(ty::terr_sigil_mismatch(expected_found(self, a.store, b.store)))\n             }\n         };\n-        let fn_style = if_ok!(self.fn_styles(a.fn_style, b.fn_style));\n-        let onceness = if_ok!(self.oncenesses(a.onceness, b.onceness));\n-        let bounds = if_ok!(self.existential_bounds(a.bounds, b.bounds));\n-        let sig = if_ok!(self.fn_sigs(&a.sig, &b.sig));\n-        let abi = if_ok!(self.abi(a.abi, b.abi));\n+        let fn_style = try!(self.fn_styles(a.fn_style, b.fn_style));\n+        let onceness = try!(self.oncenesses(a.onceness, b.onceness));\n+        let bounds = try!(self.existential_bounds(a.bounds, b.bounds));\n+        let sig = try!(self.fn_sigs(&a.sig, &b.sig));\n+        let abi = try!(self.abi(a.abi, b.abi));\n         Ok(ty::ClosureTy {\n             fn_style: fn_style,\n             onceness: onceness,\n@@ -311,7 +297,7 @@ pub trait Combine {\n             Err(ty::terr_traits(\n                                 expected_found(self, a.def_id, b.def_id)))\n         } else {\n-            let substs = if_ok!(self.substs(a.def_id, &a.substs, &b.substs));\n+            let substs = try!(self.substs(a.def_id, &a.substs, &b.substs));\n             Ok(ty::TraitRef { def_id: a.def_id,\n                               substs: substs })\n         }\n@@ -334,34 +320,6 @@ pub fn expected_found<C:Combine,T>(\n     }\n }\n \n-pub fn eq_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> ures {\n-    let suber = this.sub();\n-    this.infcx().try(|| {\n-        suber.tys(a, b).and_then(|_ok| suber.contratys(a, b)).to_ures()\n-    })\n-}\n-\n-pub fn eq_regions<C:Combine>(this: &C, a: ty::Region, b: ty::Region)\n-                          -> ures {\n-    debug!(\"eq_regions({}, {})\",\n-            a.repr(this.infcx().tcx),\n-            b.repr(this.infcx().tcx));\n-    let sub = this.sub();\n-    indent(|| {\n-        this.infcx().try(|| {\n-            sub.regions(a, b).and_then(|_r| sub.contraregions(a, b))\n-        }).or_else(|e| {\n-            // substitute a better error, but use the regions\n-            // found in the original error\n-            match e {\n-              ty::terr_regions_does_not_outlive(a1, b1) =>\n-                Err(ty::terr_regions_not_same(a1, b1)),\n-              _ => Err(e)\n-            }\n-        }).to_ures()\n-    })\n-}\n-\n pub fn super_fn_sigs<C:Combine>(this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n \n     fn argvecs<C:Combine>(this: &C, a_args: &[ty::t], b_args: &[ty::t]) -> cres<Vec<ty::t> > {\n@@ -377,10 +335,10 @@ pub fn super_fn_sigs<C:Combine>(this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<\n         return Err(ty::terr_variadic_mismatch(expected_found(this, a.variadic, b.variadic)));\n     }\n \n-    let inputs = if_ok!(argvecs(this,\n+    let inputs = try!(argvecs(this,\n                                 a.inputs.as_slice(),\n                                 b.inputs.as_slice()));\n-    let output = if_ok!(this.tys(a.output, b.output));\n+    let output = try!(this.tys(a.output, b.output));\n     Ok(FnSig {binder_id: a.binder_id,\n               inputs: inputs,\n               output: output,\n@@ -430,7 +388,7 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n         // Relate integral variables to other types\n         (&ty::ty_infer(IntVar(a_id)), &ty::ty_infer(IntVar(b_id))) => {\n-            if_ok!(this.infcx().simple_vars(this.a_is_expected(),\n+            try!(this.infcx().simple_vars(this.a_is_expected(),\n                                             a_id, b_id));\n             Ok(a)\n         }\n@@ -453,8 +411,7 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n         // Relate floating-point variables to other types\n         (&ty::ty_infer(FloatVar(a_id)), &ty::ty_infer(FloatVar(b_id))) => {\n-            if_ok!(this.infcx().simple_vars(this.a_is_expected(),\n-                                            a_id, b_id));\n+            try!(this.infcx().simple_vars(this.a_is_expected(), a_id, b_id));\n             Ok(a)\n         }\n         (&ty::ty_infer(FloatVar(v_id)), &ty::ty_float(v)) => {\n@@ -469,7 +426,8 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       (&ty::ty_bool, _) |\n       (&ty::ty_int(_), _) |\n       (&ty::ty_uint(_), _) |\n-      (&ty::ty_float(_), _) => {\n+      (&ty::ty_float(_), _) |\n+      (&ty::ty_err, _) => {\n         if ty::get(a).sty == ty::get(b).sty {\n             Ok(a)\n         } else {\n@@ -485,7 +443,7 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       (&ty::ty_enum(a_id, ref a_substs),\n        &ty::ty_enum(b_id, ref b_substs))\n       if a_id == b_id => {\n-          let substs = if_ok!(this.substs(a_id,\n+          let substs = try!(this.substs(a_id,\n                                           a_substs,\n                                           b_substs));\n           Ok(ty::mk_enum(tcx, a_id, substs))\n@@ -495,8 +453,8 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n        &ty::ty_trait(ref b_))\n       if a_.def_id == b_.def_id => {\n           debug!(\"Trying to match traits {:?} and {:?}\", a, b);\n-          let substs = if_ok!(this.substs(a_.def_id, &a_.substs, &b_.substs));\n-          let bounds = if_ok!(this.existential_bounds(a_.bounds, b_.bounds));\n+          let substs = try!(this.substs(a_.def_id, &a_.substs, &b_.substs));\n+          let bounds = try!(this.existential_bounds(a_.bounds, b_.bounds));\n           Ok(ty::mk_trait(tcx,\n                           a_.def_id,\n                           substs.clone(),\n@@ -505,14 +463,17 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n       (&ty::ty_struct(a_id, ref a_substs), &ty::ty_struct(b_id, ref b_substs))\n       if a_id == b_id => {\n-            let substs = if_ok!(this.substs(a_id, a_substs, b_substs));\n+            let substs = try!(this.substs(a_id, a_substs, b_substs));\n             Ok(ty::mk_struct(tcx, a_id, substs))\n       }\n \n       (&ty::ty_unboxed_closure(a_id, a_region),\n        &ty::ty_unboxed_closure(b_id, b_region))\n       if a_id == b_id => {\n-          let region = if_ok!(this.regions(a_region, b_region));\n+          // All ty_unboxed_closure types with the same id represent\n+          // the (anonymous) type of the same closure expression. So\n+          // all of their regions should be equated.\n+          let region = try!(this.equate().regions(a_region, b_region));\n           Ok(ty::mk_unboxed_closure(tcx, a_id, region))\n       }\n \n@@ -521,27 +482,27 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       }\n \n       (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {\n-            let typ = if_ok!(this.tys(a_inner, b_inner));\n+            let typ = try!(this.tys(a_inner, b_inner));\n             check_ptr_to_unsized(this, a, b, a_inner, b_inner, ty::mk_uniq(tcx, typ))\n       }\n \n       (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) => {\n-            let mt = if_ok!(this.mts(a_mt, b_mt));\n+            let mt = try!(this.mts(a_mt, b_mt));\n             check_ptr_to_unsized(this, a, b, a_mt.ty, b_mt.ty, ty::mk_ptr(tcx, mt))\n       }\n \n       (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n-            let r = if_ok!(this.contraregions(a_r, b_r));\n+            let r = try!(this.contraregions(a_r, b_r));\n             // FIXME(14985)  If we have mutable references to trait objects, we\n             // used to use covariant subtyping. I have preserved this behaviour,\n             // even though it is probably incorrect. So don't go down the usual\n             // path which would require invariance.\n             let mt = match (&ty::get(a_mt.ty).sty, &ty::get(b_mt.ty).sty) {\n                 (&ty::ty_trait(..), &ty::ty_trait(..)) if a_mt.mutbl == b_mt.mutbl => {\n-                    let ty = if_ok!(this.tys(a_mt.ty, b_mt.ty));\n+                    let ty = try!(this.tys(a_mt.ty, b_mt.ty));\n                     ty::mt { ty: ty, mutbl: a_mt.mutbl }\n                 }\n-                _ => if_ok!(this.mts(a_mt, b_mt))\n+                _ => try!(this.mts(a_mt, b_mt))\n             };\n             check_ptr_to_unsized(this, a, b, a_mt.ty, b_mt.ty, ty::mk_rptr(tcx, r, mt))\n       }\n@@ -592,7 +553,7 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n         vid: ty::IntVid,\n         val: ty::IntVarValue) -> cres<ty::t>\n     {\n-        if_ok!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n+        try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n         match val {\n             IntType(v) => Ok(ty::mk_mach_int(v)),\n             UintType(v) => Ok(ty::mk_mach_uint(v))\n@@ -605,7 +566,122 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n         vid: ty::FloatVid,\n         val: ast::FloatTy) -> cres<ty::t>\n     {\n-        if_ok!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n+        try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n         Ok(ty::mk_mach_float(val))\n     }\n }\n+\n+impl<'f> CombineFields<'f> {\n+    pub fn switch_expected(&self) -> CombineFields<'f> {\n+        CombineFields {\n+            a_is_expected: !self.a_is_expected,\n+            ..(*self).clone()\n+        }\n+    }\n+\n+    fn equate(&self) -> Equate<'f> {\n+        Equate((*self).clone())\n+    }\n+\n+    fn sub(&self) -> Sub<'f> {\n+        Sub((*self).clone())\n+    }\n+\n+    pub fn instantiate(&self,\n+                       a_ty: ty::t,\n+                       dir: RelationDir,\n+                       b_vid: ty::TyVid)\n+                       -> cres<()>\n+    {\n+        let tcx = self.infcx.tcx;\n+        let mut stack = Vec::new();\n+        stack.push((a_ty, dir, b_vid));\n+        loop {\n+            // For each turn of the loop, we extract a tuple\n+            //\n+            //     (a_ty, dir, b_vid)\n+            //\n+            // to relate. Here dir is either SubtypeOf or\n+            // SupertypeOf. The idea is that we should ensure that\n+            // the type `a_ty` is a subtype or supertype (respectively) of the\n+            // type to which `b_vid` is bound.\n+            //\n+            // If `b_vid` has not yet been instantiated with a type\n+            // (which is always true on the first iteration, but not\n+            // necessarily true on later iterations), we will first\n+            // instantiate `b_vid` with a *generalized* version of\n+            // `a_ty`. Generalization introduces other inference\n+            // variables wherever subtyping could occur (at time of\n+            // this writing, this means replacing free regions with\n+            // region variables).\n+            let (a_ty, dir, b_vid) = match stack.pop() {\n+                None => break,\n+                Some(e) => e,\n+            };\n+\n+            debug!(\"instantiate(a_ty={} dir={} b_vid={})\",\n+                   a_ty.repr(tcx),\n+                   dir,\n+                   b_vid.repr(tcx));\n+\n+            // Check whether `vid` has been instantiated yet.  If not,\n+            // make a generalized form of `ty` and instantiate with\n+            // that.\n+            let b_ty = self.infcx.type_variables.borrow().probe(b_vid);\n+            let b_ty = match b_ty {\n+                Some(t) => t, // ...already instantiated.\n+                None => {     // ...not yet instantiated:\n+                    // Generalize type if necessary.\n+                    let generalized_ty = match dir {\n+                        EqTo => a_ty,\n+                        SupertypeOf | SubtypeOf => self.generalize(a_ty)\n+                    };\n+                    debug!(\"instantiate(a_ty={}, dir={}, \\\n+                                        b_vid={}, generalized_ty={})\",\n+                           a_ty.repr(tcx), dir, b_vid.repr(tcx),\n+                           generalized_ty.repr(tcx));\n+                    self.infcx.type_variables\n+                        .borrow_mut()\n+                        .instantiate_and_push(\n+                            b_vid, generalized_ty, &mut stack);\n+                    generalized_ty\n+                }\n+            };\n+\n+            // The original triple was `(a_ty, dir, b_vid)` -- now we have\n+            // resolved `b_vid` to `b_ty`, so apply `(a_ty, dir, b_ty)`:\n+            //\n+            // FIXME(#16847): This code is non-ideal because all these subtype\n+            // relations wind up attributed to the same spans. We need\n+            // to associate causes/spans with each of the relations in\n+            // the stack to get this right.\n+            match dir {\n+                EqTo => {\n+                    try!(self.equate().tys(a_ty, b_ty));\n+                }\n+\n+                SubtypeOf => {\n+                    try!(self.sub().tys(a_ty, b_ty));\n+                }\n+\n+                SupertypeOf => {\n+                    try!(self.sub().contratys(a_ty, b_ty));\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn generalize(&self, t: ty::t) -> ty::t {\n+        // FIXME(#16847): This is non-ideal because we don't give a\n+        // very descriptive origin for this region variable.\n+\n+        let infcx = self.infcx;\n+        let span = self.trace.origin.span();\n+        t.fold_with(\n+            &mut RegionFolder::regions(\n+                self.infcx.tcx,\n+                |_| infcx.next_region_var(MiscVariable(span))))\n+    }\n+}"}, {"sha": "391027f9c4bf93bc24478247eb1f52dcce25f4c2", "filename": "src/librustc/middle/typeck/infer/equate.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -0,0 +1,149 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty::{BuiltinBounds};\n+use middle::ty;\n+use middle::ty::TyVar;\n+use middle::typeck::infer::combine::*;\n+use middle::typeck::infer::{cres};\n+use middle::typeck::infer::glb::Glb;\n+use middle::typeck::infer::InferCtxt;\n+use middle::typeck::infer::lub::Lub;\n+use middle::typeck::infer::sub::Sub;\n+use middle::typeck::infer::{TypeTrace, Subtype};\n+use middle::typeck::infer::type_variable::{EqTo};\n+use util::ppaux::{Repr};\n+\n+use syntax::ast::{Onceness, FnStyle};\n+\n+pub struct Equate<'f> {\n+    fields: CombineFields<'f>\n+}\n+\n+#[allow(non_snake_case_functions)]\n+pub fn Equate<'f>(cf: CombineFields<'f>) -> Equate<'f> {\n+    Equate { fields: cf }\n+}\n+\n+impl<'f> Combine for Equate<'f> {\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.fields.infcx }\n+    fn tag(&self) -> String { \"eq\".to_string() }\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n+    fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n+\n+    fn equate<'a>(&'a self) -> Equate<'a> { Equate(self.fields.clone()) }\n+    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n+\n+    fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+        self.tys(a, b)\n+    }\n+\n+    fn contraregions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n+        self.regions(a, b)\n+    }\n+\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n+        debug!(\"{}.regions({}, {})\",\n+               self.tag(),\n+               a.repr(self.fields.infcx.tcx),\n+               b.repr(self.fields.infcx.tcx));\n+        self.infcx().region_vars.make_eqregion(Subtype(self.trace()), a, b);\n+        Ok(a)\n+    }\n+\n+    fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n+        debug!(\"mts({} <: {})\",\n+               a.repr(self.fields.infcx.tcx),\n+               b.repr(self.fields.infcx.tcx));\n+\n+        if a.mutbl != b.mutbl { return Err(ty::terr_mutability); }\n+        let t = try!(self.tys(a.ty, b.ty));\n+        Ok(ty::mt { mutbl: a.mutbl, ty: t })\n+    }\n+\n+    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n+        if a != b {\n+            Err(ty::terr_fn_style_mismatch(expected_found(self, a, b)))\n+        } else {\n+            Ok(a)\n+        }\n+    }\n+\n+    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness> {\n+        if a != b {\n+            Err(ty::terr_onceness_mismatch(expected_found(self, a, b)))\n+        } else {\n+            Ok(a)\n+        }\n+    }\n+\n+    fn builtin_bounds(&self,\n+                      a: BuiltinBounds,\n+                      b: BuiltinBounds)\n+                      -> cres<BuiltinBounds>\n+    {\n+        // More bounds is a subtype of fewer bounds.\n+        //\n+        // e.g., fn:Copy() <: fn(), because the former is a function\n+        // that only closes over copyable things, but the latter is\n+        // any function at all.\n+        if a != b {\n+            Err(ty::terr_builtin_bounds(expected_found(self, a, b)))\n+        } else {\n+            Ok(a)\n+        }\n+    }\n+\n+    fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+        debug!(\"{}.tys({}, {})\", self.tag(),\n+               a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n+        if a == b { return Ok(a); }\n+\n+        let infcx = self.fields.infcx;\n+        let a = infcx.type_variables.borrow().replace_if_possible(a);\n+        let b = infcx.type_variables.borrow().replace_if_possible(b);\n+        match (&ty::get(a).sty, &ty::get(b).sty) {\n+            (&ty::ty_bot, &ty::ty_bot) => {\n+                Ok(a)\n+            }\n+\n+            (&ty::ty_bot, _) |\n+            (_, &ty::ty_bot) => {\n+                Err(ty::terr_sorts(expected_found(self, a, b)))\n+            }\n+\n+            (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n+                infcx.type_variables.borrow_mut().relate_vars(a_id, EqTo, b_id);\n+                Ok(a)\n+            }\n+\n+            (&ty::ty_infer(TyVar(a_id)), _) => {\n+                try!(self.fields.instantiate(b, EqTo, a_id));\n+                Ok(a)\n+            }\n+\n+            (_, &ty::ty_infer(TyVar(b_id))) => {\n+                try!(self.fields.instantiate(a, EqTo, b_id));\n+                Ok(a)\n+            }\n+\n+            _ => {\n+                super_tys(self, a, b)\n+            }\n+        }\n+    }\n+\n+    fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+        try!(self.sub().fn_sigs(a, b));\n+        self.sub().fn_sigs(b, a)\n+    }\n+}"}, {"sha": "bd355d2f580b9dbc79087742d2d764b9a299d52f", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -583,6 +583,19 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                     sub,\n                     \"\");\n             }\n+            infer::ProcCapture(span, id) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    format!(\"captured variable `{}` must be 'static \\\n+                             to be captured in a proc\",\n+                            ty::local_var_name_str(self.tcx, id).get())\n+                        .as_slice());\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"captured variable is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_err(span,\n                                        \"index of slice outside its lifetime\");\n@@ -1423,11 +1436,11 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n                         bound_region_to_string(self.tcx, \"lifetime parameter \", true, br))\n             }\n             infer::EarlyBoundRegion(_, name) => {\n-                format!(\" for lifetime parameter `{}\",\n+                format!(\" for lifetime parameter `{}`\",\n                         token::get_name(name).get())\n             }\n             infer::BoundRegionInCoherence(name) => {\n-                format!(\" for lifetime parameter `{} in coherence check\",\n+                format!(\" for lifetime parameter `{}` in coherence check\",\n                         token::get_name(name).get())\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n@@ -1528,6 +1541,15 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n                                 self.tcx,\n                                 id).get().to_string()).as_slice());\n             }\n+            infer::ProcCapture(span, id) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    format!(\"...so that captured variable `{}` \\\n+                            is 'static\",\n+                            ty::local_var_name_str(\n+                                self.tcx,\n+                                id).get()).as_slice());\n+            }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n@@ -1571,8 +1593,8 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n             infer::AutoBorrow(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    \"...so that reference is valid \\\n-                     at the time of implicit borrow\");\n+                    \"...so that auto-reference is valid \\\n+                     at the time of borrow\");\n             }\n             infer::ExprTypeIsNotInScope(t, span) => {\n                 self.tcx.sess.span_note("}, {"sha": "68b8031a04b68a730f389bbff5587673bf9c9c34", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -12,9 +12,9 @@\n use middle::ty::{BuiltinBounds};\n use middle::ty::RegionVid;\n use middle::ty;\n-use middle::typeck::infer::then;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::lattice::*;\n+use middle::typeck::infer::equate::Equate;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::{cres, InferCtxt};\n@@ -29,52 +29,55 @@ use util::common::{indenter};\n use util::ppaux::mt_to_string;\n use util::ppaux::Repr;\n \n-pub struct Glb<'f>(pub CombineFields<'f>);  // \"greatest lower bound\" (common subtype)\n+/// \"Greatest lower bound\" (common subtype)\n+pub struct Glb<'f> {\n+    fields: CombineFields<'f>\n+}\n \n-impl<'f> Glb<'f> {\n-    pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f> { let Glb(ref v) = *self; v }\n+#[allow(non_snake_case_functions)]\n+pub fn Glb<'f>(cf: CombineFields<'f>) -> Glb<'f> {\n+    Glb { fields: cf }\n }\n \n impl<'f> Combine for Glb<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.fields.infcx }\n     fn tag(&self) -> String { \"glb\".to_string() }\n-    fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n+    fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n \n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.get_ref().clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.get_ref().clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.get_ref().clone()) }\n+    fn equate<'a>(&'a self) -> Equate<'a> { Equate(self.fields.clone()) }\n+    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n-        let tcx = self.get_ref().infcx.tcx;\n+        let tcx = self.fields.infcx.tcx;\n \n         debug!(\"{}.mts({}, {})\",\n                self.tag(),\n                mt_to_string(tcx, a),\n                mt_to_string(tcx, b));\n \n         match (a.mutbl, b.mutbl) {\n-          // If one side or both is mut, then the GLB must use\n-          // the precise type from the mut side.\n-          (MutMutable, MutMutable) => {\n-            eq_tys(self, a.ty, b.ty).then(|| {\n-                Ok(ty::mt {ty: a.ty, mutbl: MutMutable})\n-            })\n-          }\n-\n-          // If one side or both is immutable, we can use the GLB of\n-          // both sides but mutbl must be `MutImmutable`.\n-          (MutImmutable, MutImmutable) => {\n-            self.tys(a.ty, b.ty).and_then(|t| {\n+            // If one side or both is mut, then the GLB must use\n+            // the precise type from the mut side.\n+            (MutMutable, MutMutable) => {\n+                let t = try!(self.equate().tys(a.ty, b.ty));\n+                Ok(ty::mt {ty: t, mutbl: MutMutable})\n+            }\n+\n+            // If one side or both is immutable, we can use the GLB of\n+            // both sides but mutbl must be `MutImmutable`.\n+            (MutImmutable, MutImmutable) => {\n+                let t = try!(self.tys(a.ty, b.ty));\n                 Ok(ty::mt {ty: t, mutbl: MutImmutable})\n-            })\n-          }\n-\n-          // There is no mutual subtype of these combinations.\n-          (MutMutable, MutImmutable) |\n-          (MutImmutable, MutMutable) => {\n-              Err(ty::terr_mutability)\n-          }\n+            }\n+\n+            // There is no mutual subtype of these combinations.\n+            (MutMutable, MutImmutable) |\n+            (MutImmutable, MutMutable) => {\n+                Err(ty::terr_mutability)\n+            }\n         }\n     }\n \n@@ -108,10 +111,10 @@ impl<'f> Combine for Glb<'f> {\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.fields.infcx.tcx),\n+               b.repr(self.fields.infcx.tcx));\n \n-        Ok(self.get_ref().infcx.region_vars.glb_regions(Subtype(self.trace()), a, b))\n+        Ok(self.fields.infcx.region_vars.glb_regions(Subtype(self.trace()), a, b))\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n@@ -128,33 +131,33 @@ impl<'f> Combine for Glb<'f> {\n         // please see the large comment in `region_inference.rs`.\n \n         debug!(\"{}.fn_sigs({:?}, {:?})\",\n-               self.tag(), a.repr(self.get_ref().infcx.tcx), b.repr(self.get_ref().infcx.tcx));\n+               self.tag(), a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n         let _indenter = indenter();\n \n         // Make a mark so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        let mark = self.get_ref().infcx.region_vars.mark();\n+        let mark = self.fields.infcx.region_vars.mark();\n \n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_map) =\n-            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n+            self.fields.infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.trace(), a);\n         let a_vars = var_ids(self, &a_map);\n         let (b_with_fresh, b_map) =\n-            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n+            self.fields.infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.trace(), b);\n         let b_vars = var_ids(self, &b_map);\n \n         // Collect constraints.\n-        let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"sig0 = {}\", sig0.repr(self.get_ref().infcx.tcx));\n+        let sig0 = try!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n+        debug!(\"sig0 = {}\", sig0.repr(self.fields.infcx.tcx));\n \n         // Generalize the regions appearing in fn_ty0 if possible\n         let new_vars =\n-            self.get_ref().infcx.region_vars.vars_created_since_mark(mark);\n+            self.fields.infcx.region_vars.vars_created_since_mark(mark);\n         let sig1 =\n             fold_regions_in_sig(\n-                self.get_ref().infcx.tcx,\n+                self.fields.infcx.tcx,\n                 &sig0,\n                 |r| {\n                 generalize_region(self,\n@@ -166,7 +169,7 @@ impl<'f> Combine for Glb<'f> {\n                                   b_vars.as_slice(),\n                                   r)\n             });\n-        debug!(\"sig1 = {}\", sig1.repr(self.get_ref().infcx.tcx));\n+        debug!(\"sig1 = {}\", sig1.repr(self.fields.infcx.tcx));\n         return Ok(sig1);\n \n         fn generalize_region(this: &Glb,\n@@ -182,7 +185,7 @@ impl<'f> Combine for Glb<'f> {\n                 return r0;\n             }\n \n-            let tainted = this.get_ref().infcx.region_vars.tainted(mark, r0);\n+            let tainted = this.fields.infcx.region_vars.tainted(mark, r0);\n \n             let mut a_r = None;\n             let mut b_r = None;\n@@ -249,14 +252,14 @@ impl<'f> Combine for Glb<'f> {\n                     return ty::ReLateBound(new_binder_id, *a_br);\n                 }\n             }\n-            this.get_ref().infcx.tcx.sess.span_bug(\n-                this.get_ref().trace.origin.span(),\n+            this.fields.infcx.tcx.sess.span_bug(\n+                this.fields.trace.origin.span(),\n                 format!(\"could not find original bound region for {:?}\",\n                         r).as_slice())\n         }\n \n         fn fresh_bound_variable(this: &Glb, binder_id: NodeId) -> ty::Region {\n-            this.get_ref().infcx.region_vars.new_bound(binder_id)\n+            this.fields.infcx.region_vars.new_bound(binder_id)\n         }\n     }\n }"}, {"sha": "f09773d30b5149feb7b91046f6ae46d0c4d0cd52", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 38, "deletions": 459, "changes": 497, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n /*!\n- *\n  * # Lattice Variables\n  *\n  * This file contains generic code for operating on inference variables\n@@ -34,346 +33,55 @@\n \n use middle::ty::{RegionVid, TyVar};\n use middle::ty;\n-use middle::typeck::infer::{ToUres};\n use middle::typeck::infer::*;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n-use middle::typeck::infer::unify::*;\n-use middle::typeck::infer::sub::Sub;\n use util::ppaux::Repr;\n \n use std::collections::HashMap;\n \n-trait LatticeValue : Clone + Repr + PartialEq {\n-    fn sub(cf: CombineFields, a: &Self, b: &Self) -> ures;\n-    fn lub(cf: CombineFields, a: &Self, b: &Self) -> cres<Self>;\n-    fn glb(cf: CombineFields, a: &Self, b: &Self) -> cres<Self>;\n-}\n-\n-pub type LatticeOp<'a, T> =\n-    |cf: CombineFields, a: &T, b: &T|: 'a -> cres<T>;\n-\n-impl LatticeValue for ty::t {\n-    fn sub(cf: CombineFields, a: &ty::t, b: &ty::t) -> ures {\n-        Sub(cf).tys(*a, *b).to_ures()\n-    }\n-\n-    fn lub(cf: CombineFields, a: &ty::t, b: &ty::t) -> cres<ty::t> {\n-        Lub(cf).tys(*a, *b)\n-    }\n-\n-    fn glb(cf: CombineFields, a: &ty::t, b: &ty::t) -> cres<ty::t> {\n-        Glb(cf).tys(*a, *b)\n-    }\n-}\n-\n-pub trait CombineFieldsLatticeMethods<T:LatticeValue, K:UnifyKey<Bounds<T>>> {\n-    /// make variable a subtype of variable\n-    fn var_sub_var(&self,\n-                   a_id: K,\n-                   b_id: K)\n-                   -> ures;\n-\n-    /// make variable a subtype of T\n-    fn var_sub_t(&self,\n-                 a_id: K,\n-                 b: T)\n-                 -> ures;\n-\n-    /// make T a subtype of variable\n-    fn t_sub_var(&self,\n-                 a: T,\n-                 b_id: K)\n-                 -> ures;\n-\n-    fn set_var_to_merged_bounds(&self,\n-                                v_id: K,\n-                                a: &Bounds<T>,\n-                                b: &Bounds<T>,\n-                                rank: uint)\n-                                -> ures;\n-}\n-\n-pub trait CombineFieldsLatticeMethods2<T:LatticeValue> {\n-    fn merge_bnd(&self,\n-                 a: &Bound<T>,\n-                 b: &Bound<T>,\n-                 lattice_op: LatticeOp<T>)\n-                 -> cres<Bound<T>>;\n-\n-    fn bnds(&self, a: &Bound<T>, b: &Bound<T>) -> ures;\n-}\n-\n-impl<'f,T:LatticeValue, K:UnifyKey<Bounds<T>>>\n-    CombineFieldsLatticeMethods<T,K> for CombineFields<'f>\n-{\n-    fn var_sub_var(&self,\n-                   a_id: K,\n-                   b_id: K)\n-                   -> ures\n-    {\n-        /*!\n-         * Make one variable a subtype of another variable.  This is a\n-         * subtle and tricky process, as described in detail at the\n-         * top of infer.rs.\n-         */\n-\n-        let tcx = self.infcx.tcx;\n-        let table = UnifyKey::unification_table(self.infcx);\n-\n-        // Need to make sub_id a subtype of sup_id.\n-        let node_a = table.borrow_mut().get(tcx, a_id);\n-        let node_b = table.borrow_mut().get(tcx, b_id);\n-        let a_id = node_a.key.clone();\n-        let b_id = node_b.key.clone();\n-        let a_bounds = node_a.value.clone();\n-        let b_bounds = node_b.value.clone();\n-\n-        debug!(\"vars({}={} <: {}={})\",\n-               a_id, a_bounds.repr(tcx),\n-               b_id, b_bounds.repr(tcx));\n-\n-        if a_id == b_id { return Ok(()); }\n-\n-        // If both A's UB and B's LB have already been bound to types,\n-        // see if we can make those types subtypes.\n-        match (&a_bounds.ub, &b_bounds.lb) {\n-            (&Some(ref a_ub), &Some(ref b_lb)) => {\n-                let r = self.infcx.try(\n-                    || LatticeValue::sub(self.clone(), a_ub, b_lb));\n-                match r {\n-                    Ok(()) => {\n-                        return Ok(());\n-                    }\n-                    Err(_) => { /*fallthrough */ }\n-                }\n-            }\n-            _ => { /*fallthrough*/ }\n-        }\n-\n-        // Otherwise, we need to merge A and B so as to guarantee that\n-        // A remains a subtype of B.  Actually, there are other options,\n-        // but that's the route we choose to take.\n-\n-        let (new_root, new_rank) =\n-            table.borrow_mut().unify(tcx, &node_a, &node_b);\n-        self.set_var_to_merged_bounds(new_root,\n-                                      &a_bounds, &b_bounds,\n-                                      new_rank)\n-    }\n-\n-    /// make variable a subtype of T\n-    fn var_sub_t(&self,\n-                 a_id: K,\n-                 b: T)\n-                 -> ures\n-    {\n-        /*!\n-         * Make a variable (`a_id`) a subtype of the concrete type `b`.\n-         */\n-\n-        let tcx = self.infcx.tcx;\n-        let table = UnifyKey::unification_table(self.infcx);\n-        let node_a = table.borrow_mut().get(tcx, a_id);\n-        let a_id = node_a.key.clone();\n-        let a_bounds = &node_a.value;\n-        let b_bounds = &Bounds { lb: None, ub: Some(b.clone()) };\n-\n-        debug!(\"var_sub_t({}={} <: {})\",\n-               a_id,\n-               a_bounds.repr(self.infcx.tcx),\n-               b.repr(self.infcx.tcx));\n-\n-        self.set_var_to_merged_bounds(\n-            a_id, a_bounds, b_bounds, node_a.rank)\n-    }\n-\n-    fn t_sub_var(&self,\n-                 a: T,\n-                 b_id: K)\n-                 -> ures\n-    {\n-        /*!\n-         * Make a concrete type (`a`) a subtype of the variable `b_id`\n-         */\n-\n-        let tcx = self.infcx.tcx;\n-        let table = UnifyKey::unification_table(self.infcx);\n-        let a_bounds = &Bounds { lb: Some(a.clone()), ub: None };\n-        let node_b = table.borrow_mut().get(tcx, b_id);\n-        let b_id = node_b.key.clone();\n-        let b_bounds = &node_b.value;\n-\n-        debug!(\"t_sub_var({} <: {}={})\",\n-               a.repr(self.infcx.tcx),\n-               b_id,\n-               b_bounds.repr(self.infcx.tcx));\n-\n-        self.set_var_to_merged_bounds(\n-            b_id, a_bounds, b_bounds, node_b.rank)\n-    }\n-\n-    fn set_var_to_merged_bounds(&self,\n-                                v_id: K,\n-                                a: &Bounds<T>,\n-                                b: &Bounds<T>,\n-                                rank: uint)\n-                                -> ures\n-    {\n-        /*!\n-         * Updates the bounds for the variable `v_id` to be the intersection\n-         * of `a` and `b`.  That is, the new bounds for `v_id` will be\n-         * a bounds c such that:\n-         *    c.ub <: a.ub\n-         *    c.ub <: b.ub\n-         *    a.lb <: c.lb\n-         *    b.lb <: c.lb\n-         * If this cannot be achieved, the result is failure.\n-         */\n-\n-        // Think of the two diamonds, we want to find the\n-        // intersection.  There are basically four possibilities (you\n-        // can swap A/B in these pictures):\n-        //\n-        //       A         A\n-        //      / \\       / \\\n-        //     / B \\     / B \\\n-        //    / / \\ \\   / / \\ \\\n-        //   * *   * * * /   * *\n-        //    \\ \\ / /   \\   / /\n-        //     \\ B /   / \\ / /\n-        //      \\ /   *   \\ /\n-        //       A     \\ / A\n-        //              B\n-\n-        let tcx = self.infcx.tcx;\n-        let table = UnifyKey::unification_table(self.infcx);\n-\n-        debug!(\"merge({},{},{})\",\n-               v_id,\n-               a.repr(self.infcx.tcx),\n-               b.repr(self.infcx.tcx));\n-\n-        // First, relate the lower/upper bounds of A and B.\n-        // Note that these relations *must* hold for us\n-        // to be able to merge A and B at all, and relating\n-        // them explicitly gives the type inferencer more\n-        // information and helps to produce tighter bounds\n-        // when necessary.\n-        let () = if_ok!(self.bnds(&a.lb, &b.ub));\n-        let () = if_ok!(self.bnds(&b.lb, &a.ub));\n-        let ub = if_ok!(self.merge_bnd(&a.ub, &b.ub, LatticeValue::glb));\n-        let lb = if_ok!(self.merge_bnd(&a.lb, &b.lb, LatticeValue::lub));\n-        let bounds = Bounds { lb: lb, ub: ub };\n-        debug!(\"merge({}): bounds={}\",\n-               v_id,\n-               bounds.repr(self.infcx.tcx));\n-\n-        // the new bounds must themselves\n-        // be relatable:\n-        let () = if_ok!(self.bnds(&bounds.lb, &bounds.ub));\n-        table.borrow_mut().set(tcx, v_id, Root(bounds, rank));\n-        Ok(())\n-    }\n-}\n-\n-impl<'f,T:LatticeValue>\n-    CombineFieldsLatticeMethods2<T> for CombineFields<'f>\n-{\n-    fn merge_bnd(&self,\n-                 a: &Bound<T>,\n-                 b: &Bound<T>,\n-                 lattice_op: LatticeOp<T>)\n-                 -> cres<Bound<T>>\n-    {\n-        /*!\n-         * Combines two bounds into a more general bound.\n-         */\n-\n-        debug!(\"merge_bnd({},{})\",\n-               a.repr(self.infcx.tcx),\n-               b.repr(self.infcx.tcx));\n-        match (a, b) {\n-            (&None,          &None) => Ok(None),\n-            (&Some(_),       &None) => Ok((*a).clone()),\n-            (&None,          &Some(_)) => Ok((*b).clone()),\n-            (&Some(ref v_a), &Some(ref v_b)) => {\n-                lattice_op(self.clone(), v_a, v_b).and_then(|v| Ok(Some(v)))\n-            }\n-        }\n-    }\n-\n-    fn bnds(&self,\n-            a: &Bound<T>,\n-            b: &Bound<T>)\n-            -> ures\n-    {\n-        debug!(\"bnds({} <: {})\",\n-               a.repr(self.infcx.tcx),\n-               b.repr(self.infcx.tcx));\n-\n-        match (a, b) {\n-            (&None, &None) |\n-            (&Some(_), &None) |\n-            (&None, &Some(_)) => {\n-                Ok(())\n-            }\n-            (&Some(ref t_a), &Some(ref t_b)) => {\n-                LatticeValue::sub(self.clone(), t_a, t_b)\n-            }\n-        }\n-    }\n-}\n-\n-// ______________________________________________________________________\n-// Lattice operations on variables\n-//\n-// This is common code used by both LUB and GLB to compute the LUB/GLB\n-// for pairs of variables or for variables and values.\n-\n pub trait LatticeDir {\n-    fn combine_fields<'a>(&'a self) -> CombineFields<'a>;\n-    fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T>;\n-    fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T>;\n-}\n-\n-pub trait TyLatticeDir {\n+    // Relates the bottom type to `t` and returns LUB(t, _|_) or\n+    // GLB(t, _|_) as appropriate.\n     fn ty_bot(&self, t: ty::t) -> cres<ty::t>;\n-}\n \n-impl<'f> LatticeDir for Lub<'f> {\n-    fn combine_fields<'a>(&'a self) -> CombineFields<'a> { self.get_ref().clone() }\n-    fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T> { b.ub.clone() }\n-    fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n-        Bounds { ub: Some(t), ..(*b).clone() }\n-    }\n+    // Relates the type `v` to `a` and `b` such that `v` represents\n+    // the LUB/GLB of `a` and `b` as appropriate.\n+    fn relate_bound<'a>(&'a self, v: ty::t, a: ty::t, b: ty::t) -> cres<()>;\n }\n \n-impl<'f> TyLatticeDir for Lub<'f> {\n+impl<'a> LatticeDir for Lub<'a> {\n     fn ty_bot(&self, t: ty::t) -> cres<ty::t> {\n         Ok(t)\n     }\n-}\n \n-impl<'f> LatticeDir for Glb<'f> {\n-    fn combine_fields<'a>(&'a self) -> CombineFields<'a> { self.get_ref().clone() }\n-    fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T> { b.lb.clone() }\n-    fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n-        Bounds { lb: Some(t), ..(*b).clone() }\n+    fn relate_bound<'a>(&'a self, v: ty::t, a: ty::t, b: ty::t) -> cres<()> {\n+        let sub = self.sub();\n+        try!(sub.tys(a, v));\n+        try!(sub.tys(b, v));\n+        Ok(())\n     }\n }\n \n-impl<'f> TyLatticeDir for Glb<'f> {\n-    fn ty_bot(&self, _t: ty::t) -> cres<ty::t> {\n+impl<'a> LatticeDir for Glb<'a> {\n+    fn ty_bot(&self, _: ty::t) -> cres<ty::t> {\n         Ok(ty::mk_bot())\n     }\n+\n+    fn relate_bound<'a>(&'a self, v: ty::t, a: ty::t, b: ty::t) -> cres<()> {\n+        let sub = self.sub();\n+        try!(sub.tys(v, a));\n+        try!(sub.tys(v, b));\n+        Ok(())\n+    }\n }\n \n-pub fn super_lattice_tys<L:LatticeDir+TyLatticeDir+Combine>(this: &L,\n-                                                            a: ty::t,\n-                                                            b: ty::t)\n-                                                            -> cres<ty::t> {\n+pub fn super_lattice_tys<L:LatticeDir+Combine>(this: &L,\n+                                               a: ty::t,\n+                                               b: ty::t)\n+                                               -> cres<ty::t>\n+{\n     debug!(\"{}.lattice_tys({}, {})\",\n            this.tag(),\n            a.repr(this.infcx().tcx),\n@@ -383,156 +91,27 @@ pub fn super_lattice_tys<L:LatticeDir+TyLatticeDir+Combine>(this: &L,\n         return Ok(a);\n     }\n \n-    let tcx = this.infcx().tcx;\n-\n+    let infcx = this.infcx();\n+    let a = infcx.type_variables.borrow().replace_if_possible(a);\n+    let b = infcx.type_variables.borrow().replace_if_possible(b);\n     match (&ty::get(a).sty, &ty::get(b).sty) {\n-        (&ty::ty_bot, _) => { return this.ty_bot(b); }\n-        (_, &ty::ty_bot) => { return this.ty_bot(a); }\n-\n-        (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n-            let r = if_ok!(lattice_vars(this, a_id, b_id,\n-                                        |x, y| this.tys(*x, *y)));\n-            return match r {\n-                VarResult(v) => Ok(ty::mk_var(tcx, v)),\n-                ValueResult(t) => Ok(t)\n-            };\n-        }\n-\n-        (&ty::ty_infer(TyVar(a_id)), _) => {\n-            return lattice_var_and_t(this, a_id, &b,\n-                                     |x, y| this.tys(*x, *y));\n-        }\n-\n-        (_, &ty::ty_infer(TyVar(b_id))) => {\n-            return lattice_var_and_t(this, b_id, &a,\n-                                     |x, y| this.tys(*x, *y));\n+        (&ty::ty_bot, _) => { this.ty_bot(b) }\n+        (_, &ty::ty_bot) => { this.ty_bot(a) }\n+\n+        (&ty::ty_infer(TyVar(..)), _) |\n+        (_, &ty::ty_infer(TyVar(..))) => {\n+            let v = infcx.next_ty_var();\n+            try!(this.relate_bound(v, a, b));\n+            Ok(v)\n         }\n \n         _ => {\n-            return super_tys(this, a, b);\n-        }\n-    }\n-}\n-\n-pub type LatticeDirOp<'a, T> = |a: &T, b: &T|: 'a -> cres<T>;\n-\n-#[deriving(Clone)]\n-pub enum LatticeVarResult<K,T> {\n-    VarResult(K),\n-    ValueResult(T)\n-}\n-\n-/**\n- * Computes the LUB or GLB of two bounded variables.  These could be any\n- * sort of variables, but in the comments on this function I'll assume\n- * we are doing an LUB on two type variables.\n- *\n- * This computation can be done in one of two ways:\n- *\n- * - If both variables have an upper bound, we may just compute the\n- *   LUB of those bounds and return that, in which case we are\n- *   returning a type.  This is indicated with a `ValueResult` return.\n- *\n- * - If the variables do not both have an upper bound, we will unify\n- *   the variables and return the unified variable, in which case the\n- *   result is a variable.  This is indicated with a `VarResult`\n- *   return. */\n-pub fn lattice_vars<L:LatticeDir+Combine,\n-                    T:LatticeValue,\n-                    K:UnifyKey<Bounds<T>>>(\n-    this: &L,                           // defines whether we want LUB or GLB\n-    a_vid: K,                           // first variable\n-    b_vid: K,                           // second variable\n-    lattice_dir_op: LatticeDirOp<T>)    // LUB or GLB operation on types\n-    -> cres<LatticeVarResult<K,T>>\n-{\n-    let tcx = this.infcx().tcx;\n-    let table = UnifyKey::unification_table(this.infcx());\n-\n-    let node_a = table.borrow_mut().get(tcx, a_vid);\n-    let node_b = table.borrow_mut().get(tcx, b_vid);\n-    let a_vid = node_a.key.clone();\n-    let b_vid = node_b.key.clone();\n-    let a_bounds = &node_a.value;\n-    let b_bounds = &node_b.value;\n-\n-    debug!(\"{}.lattice_vars({}={} <: {}={})\",\n-           this.tag(),\n-           a_vid, a_bounds.repr(tcx),\n-           b_vid, b_bounds.repr(tcx));\n-\n-    // Same variable: the easy case.\n-    if a_vid == b_vid {\n-        return Ok(VarResult(a_vid));\n-    }\n-\n-    // If both A and B have an UB type, then we can just compute the\n-    // LUB of those types:\n-    let (a_bnd, b_bnd) = (this.bnd(a_bounds), this.bnd(b_bounds));\n-    match (a_bnd, b_bnd) {\n-        (Some(ref a_ty), Some(ref b_ty)) => {\n-            match this.infcx().try(|| lattice_dir_op(a_ty, b_ty) ) {\n-                Ok(t) => return Ok(ValueResult(t)),\n-                Err(_) => { /*fallthrough */ }\n-            }\n-        }\n-        _ => {/*fallthrough*/}\n-    }\n-\n-    // Otherwise, we need to merge A and B into one variable.  We can\n-    // then use either variable as an upper bound:\n-    let cf = this.combine_fields();\n-    let () = try!(cf.var_sub_var(a_vid.clone(), b_vid.clone()));\n-    Ok(VarResult(a_vid.clone()))\n-}\n-\n-pub fn lattice_var_and_t<L:LatticeDir+Combine,\n-                         T:LatticeValue,\n-                         K:UnifyKey<Bounds<T>>>(\n-    this: &L,\n-    a_id: K,\n-    b: &T,\n-    lattice_dir_op: LatticeDirOp<T>)\n-    -> cres<T>\n-{\n-    let tcx = this.infcx().tcx;\n-    let table = UnifyKey::unification_table(this.infcx());\n-\n-    let node_a = table.borrow_mut().get(tcx, a_id);\n-    let a_id = node_a.key.clone();\n-    let a_bounds = &node_a.value;\n-\n-    // The comments in this function are written for LUB, but they\n-    // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n-\n-    debug!(\"{}.lattice_var_and_t({}={} <: {})\",\n-           this.tag(),\n-           a_id,\n-           a_bounds.repr(this.infcx().tcx),\n-           b.repr(this.infcx().tcx));\n-\n-    match this.bnd(a_bounds) {\n-        Some(ref a_bnd) => {\n-            // If a has an upper bound, return the LUB(a.ub, b)\n-            debug!(\"bnd=Some({})\", a_bnd.repr(this.infcx().tcx));\n-            lattice_dir_op(a_bnd, b)\n-        }\n-        None => {\n-            // If a does not have an upper bound, make b the upper bound of a\n-            // and then return b.\n-            debug!(\"bnd=None\");\n-            let a_bounds = this.with_bnd(a_bounds, (*b).clone());\n-            let () = try!(this.combine_fields().bnds(&a_bounds.lb,\n-                                                     &a_bounds.ub));\n-            table.borrow_mut().set(tcx,\n-                                   a_id.clone(),\n-                                   Root(a_bounds.clone(), node_a.rank));\n-            Ok((*b).clone())\n+            super_tys(this, a, b)\n         }\n     }\n }\n \n-// ___________________________________________________________________________\n+///////////////////////////////////////////////////////////////////////////\n // Random utility functions used by LUB/GLB when computing LUB/GLB of\n // fn types\n "}, {"sha": "9c6c0763ad45ec8a5389ead7800daa34f8edc306", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -11,8 +11,8 @@\n use middle::ty::{BuiltinBounds};\n use middle::ty::RegionVid;\n use middle::ty;\n-use middle::typeck::infer::then;\n use middle::typeck::infer::combine::*;\n+use middle::typeck::infer::equate::Equate;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lattice::*;\n use middle::typeck::infer::sub::Sub;\n@@ -28,24 +28,29 @@ use syntax::ast::{MutMutable, MutImmutable};\n use util::ppaux::mt_to_string;\n use util::ppaux::Repr;\n \n-pub struct Lub<'f>(pub CombineFields<'f>);  // least-upper-bound: common supertype\n+/// \"Least upper bound\" (common supertype)\n+pub struct Lub<'f> {\n+    fields: CombineFields<'f>\n+}\n \n-impl<'f> Lub<'f> {\n-    pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f> { let Lub(ref v) = *self; v }\n+#[allow(non_snake_case_functions)]\n+pub fn Lub<'f>(cf: CombineFields<'f>) -> Lub<'f> {\n+    Lub { fields: cf }\n }\n \n impl<'f> Combine for Lub<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.fields.infcx }\n     fn tag(&self) -> String { \"lub\".to_string() }\n-    fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n+    fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n \n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.get_ref().clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.get_ref().clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.get_ref().clone()) }\n+    fn equate<'a>(&'a self) -> Equate<'a> { Equate(self.fields.clone()) }\n+    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n-        let tcx = self.get_ref().infcx.tcx;\n+        let tcx = self.fields.infcx.tcx;\n \n         debug!(\"{}.mts({}, {})\",\n                self.tag(),\n@@ -58,17 +63,15 @@ impl<'f> Combine for Lub<'f> {\n \n         let m = a.mutbl;\n         match m {\n-          MutImmutable => {\n-            self.tys(a.ty, b.ty).and_then(|t| Ok(ty::mt {ty: t, mutbl: m}) )\n-          }\n-\n-          MutMutable => {\n-            self.get_ref().infcx.try(|| {\n-                eq_tys(self, a.ty, b.ty).then(|| {\n-                    Ok(ty::mt {ty: a.ty, mutbl: m})\n-                })\n-            }).or_else(|e| Err(e))\n-          }\n+            MutImmutable => {\n+                let t = try!(self.tys(a.ty, b.ty));\n+                Ok(ty::mt {ty: t, mutbl: m})\n+            }\n+\n+            MutMutable => {\n+                let t = try!(self.equate().tys(a.ty, b.ty));\n+                Ok(ty::mt {ty: t, mutbl: m})\n+            }\n         }\n     }\n \n@@ -107,10 +110,10 @@ impl<'f> Combine for Lub<'f> {\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.fields.infcx.tcx),\n+               b.repr(self.fields.infcx.tcx));\n \n-        Ok(self.get_ref().infcx.region_vars.lub_regions(Subtype(self.trace()), a, b))\n+        Ok(self.fields.infcx.region_vars.lub_regions(Subtype(self.trace()), a, b))\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n@@ -119,26 +122,26 @@ impl<'f> Combine for Lub<'f> {\n \n         // Make a mark so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        let mark = self.get_ref().infcx.region_vars.mark();\n+        let mark = self.fields.infcx.region_vars.mark();\n \n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_map) =\n-            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n+            self.fields.infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.trace(), a);\n         let (b_with_fresh, _) =\n-            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n+            self.fields.infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.trace(), b);\n \n         // Collect constraints.\n-        let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"sig0 = {}\", sig0.repr(self.get_ref().infcx.tcx));\n+        let sig0 = try!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n+        debug!(\"sig0 = {}\", sig0.repr(self.fields.infcx.tcx));\n \n         // Generalize the regions appearing in sig0 if possible\n         let new_vars =\n-            self.get_ref().infcx.region_vars.vars_created_since_mark(mark);\n+            self.fields.infcx.region_vars.vars_created_since_mark(mark);\n         let sig1 =\n             fold_regions_in_sig(\n-                self.get_ref().infcx.tcx,\n+                self.fields.infcx.tcx,\n                 &sig0,\n                 |r| generalize_region(self, mark, new_vars.as_slice(),\n                                       sig0.binder_id, &a_map, r));\n@@ -158,7 +161,7 @@ impl<'f> Combine for Lub<'f> {\n                 return r0;\n             }\n \n-            let tainted = this.get_ref().infcx.region_vars.tainted(mark, r0);\n+            let tainted = this.fields.infcx.region_vars.tainted(mark, r0);\n \n             // Variables created during LUB computation which are\n             // *related* to regions that pre-date the LUB computation\n@@ -185,8 +188,8 @@ impl<'f> Combine for Lub<'f> {\n                 }\n             }\n \n-            this.get_ref().infcx.tcx.sess.span_bug(\n-                this.get_ref().trace.origin.span(),\n+            this.fields.infcx.tcx.sess.span_bug(\n+                this.fields.trace.origin.span(),\n                 format!(\"region {:?} is not associated with \\\n                          any bound region from A!\",\n                         r0).as_slice())"}, {"sha": "f86857f97f6546db85cadd6156d8e9d3e930638a", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -29,13 +29,14 @@ use middle::ty_fold;\n use middle::ty_fold::TypeFolder;\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::infer::coercion::Coerce;\n-use middle::typeck::infer::combine::{Combine, CombineFields, eq_tys};\n-use middle::typeck::infer::region_inference::{RegionSnapshot};\n-use middle::typeck::infer::region_inference::{RegionVarBindings};\n+use middle::typeck::infer::combine::{Combine, CombineFields};\n+use middle::typeck::infer::region_inference::{RegionVarBindings,\n+                                              RegionSnapshot};\n use middle::typeck::infer::resolve::{resolver};\n+use middle::typeck::infer::equate::Equate;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::lub::Lub;\n-use middle::typeck::infer::unify::{UnificationTable, Snapshot};\n+use middle::typeck::infer::unify::{UnificationTable};\n use middle::typeck::infer::error_reporting::ErrorReporting;\n use std::cell::{RefCell};\n use std::collections::HashMap;\n@@ -46,19 +47,20 @@ use syntax::codemap::Span;\n use util::common::indent;\n use util::ppaux::{bound_region_to_string, ty_to_string, trait_ref_to_string, Repr};\n \n-pub mod doc;\n-pub mod macros;\n+pub mod coercion;\n pub mod combine;\n+pub mod doc;\n+pub mod equate;\n+pub mod error_reporting;\n pub mod glb;\n pub mod lattice;\n pub mod lub;\n pub mod region_inference;\n pub mod resolve;\n pub mod sub;\n-pub mod unify;\n-pub mod coercion;\n-pub mod error_reporting;\n pub mod test;\n+pub mod type_variable;\n+pub mod unify;\n \n pub type Bound<T> = Option<T>;\n \n@@ -79,8 +81,7 @@ pub struct InferCtxt<'a> {\n     // We instantiate UnificationTable with bounds<ty::t> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n-    type_unification_table:\n-        RefCell<UnificationTable<ty::TyVid, Bounds<ty::t>>>,\n+    type_variables: RefCell<type_variable::TypeVariableTable>,\n \n     // Map from integral variable to the kind of integer it represents\n     int_unification_table:\n@@ -161,6 +162,9 @@ pub enum SubregionOrigin {\n     // Closure bound must not outlive captured free variables\n     FreeVariable(Span, ast::NodeId),\n \n+    // Proc upvars must be 'static\n+    ProcCapture(Span, ast::NodeId),\n+\n     // Index into slice must be within its lifetime\n     IndexSlice(Span),\n \n@@ -290,7 +294,7 @@ pub fn fixup_err_to_string(f: fixup_err) -> String {\n pub fn new_infer_ctxt<'a>(tcx: &'a ty::ctxt) -> InferCtxt<'a> {\n     InferCtxt {\n         tcx: tcx,\n-        type_unification_table: RefCell::new(UnificationTable::new()),\n+        type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n         int_unification_table: RefCell::new(UnificationTable::new()),\n         float_unification_table: RefCell::new(UnificationTable::new()),\n         region_vars: RegionVarBindings::new(tcx),\n@@ -392,8 +396,8 @@ pub fn mk_eqty(cx: &InferCtxt,\n             origin: origin,\n             values: Types(expected_found(a_is_expected, a, b))\n         };\n-        let suber = cx.sub(a_is_expected, trace);\n-        eq_tys(&suber, a, b)\n+        try!(cx.equate(a_is_expected, trace).tys(a, b));\n+        Ok(())\n     })\n }\n \n@@ -508,9 +512,9 @@ pub fn uok() -> ures {\n }\n \n pub struct CombinedSnapshot {\n-    type_snapshot: Snapshot<ty::TyVid>,\n-    int_snapshot: Snapshot<ty::IntVid>,\n-    float_snapshot: Snapshot<ty::FloatVid>,\n+    type_snapshot: type_variable::Snapshot,\n+    int_snapshot: unify::Snapshot<ty::IntVid>,\n+    float_snapshot: unify::Snapshot<ty::FloatVid>,\n     region_vars_snapshot: RegionSnapshot,\n }\n \n@@ -522,6 +526,10 @@ impl<'a> InferCtxt<'a> {\n                        trace: trace}\n     }\n \n+    pub fn equate<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Equate<'a> {\n+        Equate(self.combine_fields(a_is_expected, trace))\n+    }\n+\n     pub fn sub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Sub<'a> {\n         Sub(self.combine_fields(a_is_expected, trace))\n     }\n@@ -530,13 +538,9 @@ impl<'a> InferCtxt<'a> {\n         Lub(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn in_snapshot(&self) -> bool {\n-        self.region_vars.in_snapshot()\n-    }\n-\n     fn start_snapshot(&self) -> CombinedSnapshot {\n         CombinedSnapshot {\n-            type_snapshot: self.type_unification_table.borrow_mut().snapshot(),\n+            type_snapshot: self.type_variables.borrow_mut().snapshot(),\n             int_snapshot: self.int_unification_table.borrow_mut().snapshot(),\n             float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n             region_vars_snapshot: self.region_vars.start_snapshot(),\n@@ -550,15 +554,15 @@ impl<'a> InferCtxt<'a> {\n                                float_snapshot,\n                                region_vars_snapshot } = snapshot;\n \n-        self.type_unification_table\n+        self.type_variables\n             .borrow_mut()\n-            .rollback_to(self.tcx, type_snapshot);\n+            .rollback_to(type_snapshot);\n         self.int_unification_table\n             .borrow_mut()\n-            .rollback_to(self.tcx, int_snapshot);\n+            .rollback_to(int_snapshot);\n         self.float_unification_table\n             .borrow_mut()\n-            .rollback_to(self.tcx, float_snapshot);\n+            .rollback_to(float_snapshot);\n         self.region_vars\n             .rollback_to(region_vars_snapshot);\n     }\n@@ -570,7 +574,7 @@ impl<'a> InferCtxt<'a> {\n                                float_snapshot,\n                                region_vars_snapshot } = snapshot;\n \n-        self.type_unification_table\n+        self.type_variables\n             .borrow_mut()\n             .commit(type_snapshot);\n         self.int_unification_table\n@@ -633,9 +637,9 @@ impl<'a> InferCtxt<'a> {\n \n impl<'a> InferCtxt<'a> {\n     pub fn next_ty_var_id(&self) -> TyVid {\n-        self.type_unification_table\n+        self.type_variables\n             .borrow_mut()\n-            .new_key(Bounds { lb: None, ub: None })\n+            .new_var()\n     }\n \n     pub fn next_ty_var(&self) -> ty::t {\n@@ -933,6 +937,7 @@ impl SubregionOrigin {\n             InvokeClosure(a) => a,\n             DerefPointer(a) => a,\n             FreeVariable(a, _) => a,\n+            ProcCapture(a, _) => a,\n             IndexSlice(a) => a,\n             RelateObjectBound(a) => a,\n             RelateProcBound(a, _, _) => a,\n@@ -972,6 +977,9 @@ impl Repr for SubregionOrigin {\n             FreeVariable(a, b) => {\n                 format!(\"FreeVariable({}, {})\", a.repr(tcx), b)\n             }\n+            ProcCapture(a, b) => {\n+                format!(\"ProcCapture({}, {})\", a.repr(tcx), b)\n+            }\n             IndexSlice(a) => {\n                 format!(\"IndexSlice({})\", a.repr(tcx))\n             }"}, {"sha": "f34894346f64afbc42e5d7a485267f2d5d65c902", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -234,7 +234,7 @@ impl<'a> RegionVarBindings<'a> {\n         }\n     }\n \n-    pub fn in_snapshot(&self) -> bool {\n+    fn in_snapshot(&self) -> bool {\n         self.undo_log.borrow().len() > 0\n     }\n \n@@ -253,7 +253,7 @@ impl<'a> RegionVarBindings<'a> {\n     }\n \n     pub fn commit(&self, snapshot: RegionSnapshot) {\n-        debug!(\"RegionVarBindings: commit()\");\n+        debug!(\"RegionVarBindings: commit({})\", snapshot.length);\n         assert!(self.undo_log.borrow().len() > snapshot.length);\n         assert!(*self.undo_log.borrow().get(snapshot.length) == OpenSnapshot);\n \n@@ -406,6 +406,18 @@ impl<'a> RegionVarBindings<'a> {\n         }\n     }\n \n+    pub fn make_eqregion(&self,\n+                         origin: SubregionOrigin,\n+                         sub: Region,\n+                         sup: Region) {\n+        if sub != sup {\n+            // Eventually, it would be nice to add direct support for\n+            // equating regions.\n+            self.make_subregion(origin.clone(), sub, sup);\n+            self.make_subregion(origin, sup, sub);\n+        }\n+    }\n+\n     pub fn make_subregion(&self,\n                           origin: SubregionOrigin,\n                           sub: Region,"}, {"sha": "f9742c522dac4a6d0d5ff753467e27f546a01b11", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -48,12 +48,11 @@\n \n \n use middle::ty::{FloatVar, FloatVid, IntVar, IntVid, RegionVid, TyVar, TyVid};\n-use middle::ty::{type_is_bot, IntType, UintType};\n+use middle::ty::{IntType, UintType};\n use middle::ty;\n use middle::ty_fold;\n-use middle::typeck::infer::{Bounds, cyclic_ty, fixup_err, fres, InferCtxt};\n-use middle::typeck::infer::{unresolved_float_ty, unresolved_int_ty};\n-use middle::typeck::infer::{unresolved_ty};\n+use middle::typeck::infer::{cyclic_ty, fixup_err, fres, InferCtxt};\n+use middle::typeck::infer::{unresolved_int_ty,unresolved_float_ty,unresolved_ty};\n use syntax::codemap::Span;\n use util::common::indent;\n use util::ppaux::{Repr, ty_to_string};\n@@ -132,8 +131,8 @@ impl<'a> ResolveState<'a> {\n         assert!(self.v_seen.is_empty());\n         match self.err {\n           None => {\n-            debug!(\"Resolved to {} + {} (modes={:x})\",\n-                   ty_to_string(self.infcx.tcx, rty),\n+            debug!(\"Resolved {} to {} (modes={:x})\",\n+                   ty_to_string(self.infcx.tcx, typ),\n                    ty_to_string(self.infcx.tcx, rty),\n                    self.modes);\n             return Ok(rty);\n@@ -219,21 +218,16 @@ impl<'a> ResolveState<'a> {\n             // tend to carry more restrictions or higher\n             // perf. penalties, so it pays to know more.\n \n-            let node =\n-                self.infcx.type_unification_table.borrow_mut().get(tcx, vid);\n-            let t1 = match node.value {\n-              Bounds { ub:_, lb:Some(t) } if !type_is_bot(t) => {\n-                  self.resolve_type(t)\n-              }\n-              Bounds { ub:Some(t), lb:_ } | Bounds { ub:_, lb:Some(t) } => {\n-                  self.resolve_type(t)\n-              }\n-              Bounds { ub:None, lb:None } => {\n-                if self.should(force_tvar) {\n-                    self.err = Some(unresolved_ty(vid));\n+            let t1 = match self.infcx.type_variables.borrow().probe(vid) {\n+                Some(t) => {\n+                    self.resolve_type(t)\n+                }\n+                None => {\n+                    if self.should(force_tvar) {\n+                        self.err = Some(unresolved_ty(vid));\n+                    }\n+                    ty::mk_var(tcx, vid)\n                 }\n-                ty::mk_var(tcx, vid)\n-              }\n             };\n             self.v_seen.pop().unwrap();\n             return t1;"}, {"sha": "cc3abc279bf34da83a4547fc193764a5d668d0f4", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 67, "deletions": 56, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -15,79 +15,83 @@ use middle::ty::TyVar;\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::{cres, CresCompare};\n+use middle::typeck::infer::equate::Equate;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::InferCtxt;\n-use middle::typeck::infer::lattice::CombineFieldsLatticeMethods;\n use middle::typeck::infer::lub::Lub;\n-use middle::typeck::infer::then;\n use middle::typeck::infer::{TypeTrace, Subtype};\n+use middle::typeck::infer::type_variable::{SubtypeOf, SupertypeOf};\n use util::common::{indenter};\n use util::ppaux::{bound_region_to_string, Repr};\n \n use syntax::ast::{Onceness, FnStyle, MutImmutable, MutMutable};\n \n-pub struct Sub<'f>(pub CombineFields<'f>);  // \"subtype\", \"subregion\" etc\n \n-impl<'f> Sub<'f> {\n-    pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f> { let Sub(ref v) = *self; v }\n+/// \"Greatest lower bound\" (common subtype)\n+pub struct Sub<'f> {\n+    fields: CombineFields<'f>\n+}\n+\n+#[allow(non_snake_case_functions)]\n+pub fn Sub<'f>(cf: CombineFields<'f>) -> Sub<'f> {\n+    Sub { fields: cf }\n }\n \n impl<'f> Combine for Sub<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.fields.infcx }\n     fn tag(&self) -> String { \"sub\".to_string() }\n-    fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n+    fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n \n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.get_ref().clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.get_ref().clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.get_ref().clone()) }\n+    fn equate<'a>(&'a self) -> Equate<'a> { Equate(self.fields.clone()) }\n+    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n \n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n-        let opp = CombineFields {\n-            a_is_expected: !self.get_ref().a_is_expected,\n-            ..self.get_ref().clone()\n-        };\n-        Sub(opp).tys(b, a)\n+        Sub(self.fields.switch_expected()).tys(b, a)\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                    -> cres<ty::Region> {\n-        let opp = CombineFields {\n-            a_is_expected: !self.get_ref().a_is_expected,\n-            ..self.get_ref().clone()\n-        };\n-        Sub(opp).regions(b, a)\n-    }\n+                     -> cres<ty::Region> {\n+                         let opp = CombineFields {\n+                             a_is_expected: !self.fields.a_is_expected,\n+                             ..self.fields.clone()\n+                         };\n+                         Sub(opp).regions(b, a)\n+                     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n-        self.get_ref().infcx.region_vars.make_subregion(Subtype(self.trace()), a, b);\n+               a.repr(self.fields.infcx.tcx),\n+               b.repr(self.fields.infcx.tcx));\n+        self.fields.infcx.region_vars.make_subregion(Subtype(self.trace()), a, b);\n         Ok(a)\n     }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         debug!(\"mts({} <: {})\",\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.fields.infcx.tcx),\n+               b.repr(self.fields.infcx.tcx));\n \n         if a.mutbl != b.mutbl {\n             return Err(ty::terr_mutability);\n         }\n \n         match b.mutbl {\n-          MutMutable => {\n-            // If supertype is mut, subtype must match exactly\n-            // (i.e., invariant if mut):\n-            eq_tys(self, a.ty, b.ty).then(|| Ok(*a))\n-          }\n-          MutImmutable => {\n-            // Otherwise we can be covariant:\n-            self.tys(a.ty, b.ty).and_then(|_t| Ok(*a) )\n-          }\n+            MutMutable => {\n+                // If supertype is mut, subtype must match exactly\n+                // (i.e., invariant if mut):\n+                try!(self.equate().tys(a.ty, b.ty));\n+            }\n+            MutImmutable => {\n+                // Otherwise we can be covariant:\n+                try!(self.tys(a.ty, b.ty));\n+            }\n         }\n+\n+        Ok(*a) // return is meaningless in sub, just return *a\n     }\n \n     fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n@@ -118,16 +122,21 @@ impl<'f> Combine for Sub<'f> {\n \n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n-               a.repr(self.get_ref().infcx.tcx), b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n         if a == b { return Ok(a); }\n-        let _indenter = indenter();\n+\n+        let infcx = self.fields.infcx;\n+        let a = infcx.type_variables.borrow().replace_if_possible(a);\n+        let b = infcx.type_variables.borrow().replace_if_possible(b);\n         match (&ty::get(a).sty, &ty::get(b).sty) {\n             (&ty::ty_bot, _) => {\n                 Ok(a)\n             }\n \n             (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n-                if_ok!(self.get_ref().var_sub_var(a_id, b_id));\n+                infcx.type_variables\n+                    .borrow_mut()\n+                    .relate_vars(a_id, SubtypeOf, b_id);\n                 Ok(a)\n             }\n             // The vec/str check here and below is so that we don't unify\n@@ -139,7 +148,9 @@ impl<'f> Combine for Sub<'f> {\n                 Err(ty::terr_sorts(expected_found(self, a, b)))\n             }\n             (&ty::ty_infer(TyVar(a_id)), _) => {\n-                if_ok!(self.get_ref().var_sub_t(a_id, b));\n+                try!(self.fields\n+                       .switch_expected()\n+                       .instantiate(b, SupertypeOf, a_id));\n                 Ok(a)\n             }\n \n@@ -148,7 +159,7 @@ impl<'f> Combine for Sub<'f> {\n                 Err(ty::terr_sorts(expected_found(self, a, b)))\n             }\n             (_, &ty::ty_infer(TyVar(b_id))) => {\n-                if_ok!(self.get_ref().t_sub_var(a, b_id));\n+                try!(self.fields.instantiate(a, SubtypeOf, b_id));\n                 Ok(a)\n             }\n \n@@ -164,7 +175,7 @@ impl<'f> Combine for Sub<'f> {\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n         debug!(\"fn_sigs(a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx), b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n         let _indenter = indenter();\n \n         // Rather than checking the subtype relationship between `a` and `b`\n@@ -176,38 +187,38 @@ impl<'f> Combine for Sub<'f> {\n \n         // Make a mark so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        let mark = self.get_ref().infcx.region_vars.mark();\n+        let mark = self.fields.infcx.region_vars.mark();\n \n         // First, we instantiate each bound region in the subtype with a fresh\n         // region variable.\n         let (a_sig, _) =\n-            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n+            self.fields.infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.trace(), a);\n \n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n         let (skol_map, b_sig) = {\n-            replace_late_bound_regions_in_fn_sig(self.get_ref().infcx.tcx, b, |br| {\n-                let skol = self.get_ref().infcx.region_vars.new_skolemized(br);\n+            replace_late_bound_regions_in_fn_sig(self.fields.infcx.tcx, b, |br| {\n+                let skol = self.fields.infcx.region_vars.new_skolemized(br);\n                 debug!(\"Bound region {} skolemized to {:?}\",\n-                       bound_region_to_string(self.get_ref().infcx.tcx, \"\", false, br),\n+                       bound_region_to_string(self.fields.infcx.tcx, \"\", false, br),\n                        skol);\n                 skol\n             })\n         };\n \n-        debug!(\"a_sig={}\", a_sig.repr(self.get_ref().infcx.tcx));\n-        debug!(\"b_sig={}\", b_sig.repr(self.get_ref().infcx.tcx));\n+        debug!(\"a_sig={}\", a_sig.repr(self.fields.infcx.tcx));\n+        debug!(\"b_sig={}\", b_sig.repr(self.fields.infcx.tcx));\n \n         // Compare types now that bound regions have been replaced.\n-        let sig = if_ok!(super_fn_sigs(self, &a_sig, &b_sig));\n+        let sig = try!(super_fn_sigs(self, &a_sig, &b_sig));\n \n         // Presuming type comparison succeeds, we need to check\n         // that the skolemized regions do not \"leak\".\n         let new_vars =\n-            self.get_ref().infcx.region_vars.vars_created_since_mark(mark);\n+            self.fields.infcx.region_vars.vars_created_since_mark(mark);\n         for (&skol_br, &skol) in skol_map.iter() {\n-            let tainted = self.get_ref().infcx.region_vars.tainted(mark, skol);\n+            let tainted = self.fields.infcx.region_vars.tainted(mark, skol);\n             for tainted_region in tainted.iter() {\n                 // Each skolemized should only be relatable to itself\n                 // or new variables:\n@@ -224,16 +235,16 @@ impl<'f> Combine for Sub<'f> {\n                 if self.a_is_expected() {\n                     debug!(\"Not as polymorphic!\");\n                     return Err(ty::terr_regions_insufficiently_polymorphic(\n-                            skol_br, *tainted_region));\n+                        skol_br, *tainted_region));\n                 } else {\n                     debug!(\"Overly polymorphic!\");\n                     return Err(ty::terr_regions_overly_polymorphic(\n-                            skol_br, *tainted_region));\n+                        skol_br, *tainted_region));\n                 }\n             }\n         }\n \n         return Ok(sig);\n     }\n-\n }\n+"}, {"sha": "5f67f8a048aa4e48148975db250b758319ab6304", "filename": "src/librustc/middle/typeck/infer/type_variable.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty;\n+use std::mem;\n+use util::snapshot_vec as sv;\n+\n+pub struct TypeVariableTable {\n+    values: sv::SnapshotVec<TypeVariableData,UndoEntry,Delegate>,\n+}\n+\n+struct TypeVariableData {\n+    value: TypeVariableValue\n+}\n+\n+enum TypeVariableValue {\n+    Known(ty::t),\n+    Bounded(Vec<Relation>),\n+}\n+\n+pub struct Snapshot {\n+    snapshot: sv::Snapshot\n+}\n+\n+enum UndoEntry {\n+    // The type of the var was specified.\n+    SpecifyVar(ty::TyVid, Vec<Relation>),\n+    Relate(ty::TyVid, ty::TyVid),\n+}\n+\n+struct Delegate;\n+\n+type Relation = (RelationDir, ty::TyVid);\n+\n+#[deriving(PartialEq,Show)]\n+pub enum RelationDir {\n+    SubtypeOf, SupertypeOf, EqTo\n+}\n+\n+impl RelationDir {\n+    fn opposite(self) -> RelationDir {\n+        match self {\n+            SubtypeOf => SupertypeOf,\n+            SupertypeOf => SubtypeOf,\n+            EqTo => EqTo\n+        }\n+    }\n+}\n+\n+impl TypeVariableTable {\n+    pub fn new() -> TypeVariableTable {\n+        TypeVariableTable { values: sv::SnapshotVec::new(Delegate) }\n+    }\n+\n+    fn relations<'a>(&'a mut self, a: ty::TyVid) -> &'a mut Vec<Relation> {\n+        relations(self.values.get_mut(a.index))\n+    }\n+\n+    pub fn relate_vars(&mut self, a: ty::TyVid, dir: RelationDir, b: ty::TyVid) {\n+        /*!\n+         * Records that `a <: b`, `a :> b`, or `a == b`, depending on `dir`.\n+         *\n+         * Precondition: neither `a` nor `b` are known.\n+         */\n+\n+        if a != b {\n+            self.relations(a).push((dir, b));\n+            self.relations(b).push((dir.opposite(), a));\n+            self.values.record(Relate(a, b));\n+        }\n+    }\n+\n+    pub fn instantiate_and_push(\n+        &mut self,\n+        vid: ty::TyVid,\n+        ty: ty::t,\n+        stack: &mut Vec<(ty::t, RelationDir, ty::TyVid)>)\n+    {\n+        /*!\n+         * Instantiates `vid` with the type `ty` and then pushes an\n+         * entry onto `stack` for each of the relations of `vid` to\n+         * other variables. The relations will have the form `(ty,\n+         * dir, vid1)` where `vid1` is some other variable id.\n+         */\n+\n+        let old_value = {\n+            let value_ptr = &mut self.values.get_mut(vid.index).value;\n+            mem::replace(value_ptr, Known(ty))\n+        };\n+\n+        let relations = match old_value {\n+            Bounded(b) => b,\n+            Known(_) => fail!(\"Asked to instantiate variable that is \\\n+                               already instantiated\")\n+        };\n+\n+        for &(dir, vid) in relations.iter() {\n+            stack.push((ty, dir, vid));\n+        }\n+\n+        self.values.record(SpecifyVar(vid, relations));\n+    }\n+\n+    pub fn new_var(&mut self) -> ty::TyVid {\n+        let index =\n+            self.values.push(\n+                TypeVariableData { value: Bounded(Vec::new()) });\n+        ty::TyVid { index: index }\n+    }\n+\n+    pub fn probe(&self, vid: ty::TyVid) -> Option<ty::t> {\n+        match self.values.get(vid.index).value {\n+            Bounded(..) => None,\n+            Known(t) => Some(t)\n+        }\n+    }\n+\n+    pub fn replace_if_possible(&self, t: ty::t) -> ty::t {\n+        match ty::get(t).sty {\n+            ty::ty_infer(ty::TyVar(v)) => {\n+                match self.probe(v) {\n+                    None => t,\n+                    Some(u) => u\n+                }\n+            }\n+            _ => t,\n+        }\n+    }\n+\n+    pub fn snapshot(&mut self) -> Snapshot {\n+        Snapshot { snapshot: self.values.start_snapshot() }\n+    }\n+\n+    pub fn rollback_to(&mut self, s: Snapshot) {\n+        self.values.rollback_to(s.snapshot);\n+    }\n+\n+    pub fn commit(&mut self, s: Snapshot) {\n+        self.values.commit(s.snapshot);\n+    }\n+}\n+\n+impl sv::SnapshotVecDelegate<TypeVariableData,UndoEntry> for Delegate {\n+    fn reverse(&mut self,\n+               values: &mut Vec<TypeVariableData>,\n+               action: UndoEntry) {\n+        match action {\n+            SpecifyVar(vid, relations) => {\n+                values.get_mut(vid.index).value = Bounded(relations);\n+            }\n+\n+            Relate(a, b) => {\n+                relations(values.get_mut(a.index)).pop();\n+                relations(values.get_mut(b.index)).pop();\n+            }\n+        }\n+    }\n+}\n+\n+fn relations<'a>(v: &'a mut TypeVariableData) -> &'a mut Vec<Relation> {\n+    match v.value {\n+        Known(_) => fail!(\"var_sub_var: variable is known\"),\n+        Bounded(ref mut relations) => relations\n+    }\n+}\n+"}, {"sha": "adf0a25ce4002e5f8069c59e27afe1a4b679abaa", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 38, "deletions": 167, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -12,23 +12,23 @@ use std::kinds::marker;\n \n use middle::ty::{expected_found, IntVarValue};\n use middle::ty;\n-use middle::typeck::infer::{Bounds, uok, ures};\n+use middle::typeck::infer::{uok, ures};\n use middle::typeck::infer::InferCtxt;\n use std::cell::RefCell;\n use std::fmt::Show;\n-use std::mem;\n use syntax::ast;\n use util::ppaux::Repr;\n+use util::snapshot_vec as sv;\n \n /**\n  * This trait is implemented by any type that can serve as a type\n  * variable. We call such variables *unification keys*. For example,\n- * this trait is implemented by `TyVid`, which represents normal\n- * type variables, and `IntVid`, which represents integral variables.\n+ * this trait is implemented by `IntVid`, which represents integral\n+ * variables.\n  *\n- * Each key type has an associated value type `V`. For example,\n- * for `TyVid`, this is `Bounds<ty::t>`, representing a pair of\n- * upper- and lower-bound types.\n+ * Each key type has an associated value type `V`. For example, for\n+ * `IntVid`, this is `Option<IntVarValue>`, representing some\n+ * (possibly not yet known) sort of integer.\n  *\n  * Implementations of this trait are at the end of this file.\n  */\n@@ -48,11 +48,10 @@ pub trait UnifyKey<V> : Clone + Show + PartialEq + Repr {\n }\n \n /**\n- * Trait for valid types that a type variable can be set to.  Note\n- * that this is typically not the end type that the value will\n- * take on, but rather some wrapper: for example, for normal type\n- * variables, the associated type is not `ty::t` but rather\n- * `Bounds<ty::t>`.\n+ * Trait for valid types that a type variable can be set to. Note that\n+ * this is typically not the end type that the value will take on, but\n+ * rather an `Option` wrapper (where `None` represents a variable\n+ * whose value is not yet set).\n  *\n  * Implementations of this trait are at the end of this file.\n  */\n@@ -82,43 +81,18 @@ pub struct UnificationTable<K,V> {\n     /**\n      * Indicates the current value of each key.\n      */\n-    values: Vec<VarValue<K,V>>,\n \n-    /**\n-     * When a snapshot is active, logs each change made to the table\n-     * so that they can be unrolled.\n-     */\n-    undo_log: Vec<UndoLog<K,V>>,\n+    values: sv::SnapshotVec<VarValue<K,V>,(),Delegate>,\n }\n \n /**\n  * At any time, users may snapshot a unification table.  The changes\n  * made during the snapshot may either be *committed* or *rolled back*.\n  */\n pub struct Snapshot<K> {\n-    // Ensure that this snapshot is keyed to the table type.\n-    marker1: marker::CovariantType<K>,\n-\n-    // Snapshots are tokens that should be created/consumed linearly.\n-    marker2: marker::NoCopy,\n-\n-    // Length of the undo log at the time the snapshot was taken.\n-    length: uint,\n-}\n-\n-#[deriving(PartialEq)]\n-enum UndoLog<K,V> {\n-    /// Indicates where a snapshot started.\n-    OpenSnapshot,\n-\n-    /// Indicates a snapshot that has been committed.\n-    CommittedSnapshot,\n-\n-    /// New variable with given index was created.\n-    NewVar(uint),\n-\n-    /// Variable with given index was changed *from* the given value.\n-    SetVar(uint, VarValue<K,V>),\n+    // Link snapshot to the key type `K` of the table.\n+    marker: marker::CovariantType<K>,\n+    snapshot: sv::Snapshot,\n }\n \n /**\n@@ -131,135 +105,56 @@ pub struct Node<K,V> {\n     pub rank: uint,\n }\n \n+pub struct Delegate;\n+\n // We can't use V:LatticeValue, much as I would like to,\n-// because frequently the pattern is that V=Bounds<U> for some\n+// because frequently the pattern is that V=Option<U> for some\n // other type parameter U, and we have no way to say\n-// Bounds<U>:\n+// Option<U>:LatticeValue.\n \n impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n     pub fn new() -> UnificationTable<K,V> {\n         UnificationTable {\n-            values: Vec::new(),\n-            undo_log: Vec::new()\n+            values: sv::SnapshotVec::new(Delegate),\n         }\n     }\n \n-    pub fn in_snapshot(&self) -> bool {\n-        /*! True if a snapshot has been started. */\n-\n-        self.undo_log.len() > 0\n-    }\n-\n     /**\n      * Starts a new snapshot. Each snapshot must be either\n      * rolled back or committed in a \"LIFO\" (stack) order.\n      */\n     pub fn snapshot(&mut self) -> Snapshot<K> {\n-        let length = self.undo_log.len();\n-        debug!(\"{}: snapshot at length {}\",\n-               UnifyKey::tag(None::<K>),\n-               length);\n-        self.undo_log.push(OpenSnapshot);\n-        Snapshot { length: length,\n-                   marker1: marker::CovariantType,\n-                   marker2: marker::NoCopy }\n-    }\n-\n-    fn assert_open_snapshot(&self, snapshot: &Snapshot<K>) {\n-        // Or else there was a failure to follow a stack discipline:\n-        assert!(self.undo_log.len() > snapshot.length);\n-\n-        // Invariant established by start_snapshot():\n-        assert!(*self.undo_log.get(snapshot.length) == OpenSnapshot);\n+        Snapshot { marker: marker::CovariantType::<K>,\n+                   snapshot: self.values.start_snapshot() }\n     }\n \n     /**\n      * Reverses all changes since the last snapshot. Also\n      * removes any keys that have been created since then.\n      */\n-    pub fn rollback_to(&mut self, tcx: &ty::ctxt, snapshot: Snapshot<K>) {\n-        debug!(\"{}: rollback_to({})\",\n-               UnifyKey::tag(None::<K>),\n-               snapshot.length);\n-\n-        self.assert_open_snapshot(&snapshot);\n-\n-        while self.undo_log.len() > snapshot.length + 1 {\n-            match self.undo_log.pop().unwrap() {\n-                OpenSnapshot => {\n-                    // This indicates a failure to obey the stack discipline.\n-                    tcx.sess.bug(\"Cannot rollback an uncommitted snapshot\");\n-                }\n-\n-                CommittedSnapshot => {\n-                    // This occurs when there are nested snapshots and\n-                    // the inner is committed but outer is rolled back.\n-                }\n-\n-                NewVar(i) => {\n-                    assert!(self.values.len() == i);\n-                    self.values.pop();\n-                }\n-\n-                SetVar(i, v) => {\n-                    *self.values.get_mut(i) = v;\n-                }\n-            }\n-        }\n-\n-        let v = self.undo_log.pop().unwrap();\n-        assert!(v == OpenSnapshot);\n-        assert!(self.undo_log.len() == snapshot.length);\n+    pub fn rollback_to(&mut self, snapshot: Snapshot<K>) {\n+        debug!(\"{}: rollback_to()\", UnifyKey::tag(None::<K>));\n+        self.values.rollback_to(snapshot.snapshot);\n     }\n \n     /**\n      * Commits all changes since the last snapshot. Of course, they\n      * can still be undone if there is a snapshot further out.\n      */\n     pub fn commit(&mut self, snapshot: Snapshot<K>) {\n-        debug!(\"{}: commit({})\",\n-               UnifyKey::tag(None::<K>),\n-               snapshot.length);\n-\n-        self.assert_open_snapshot(&snapshot);\n-\n-        if snapshot.length == 0 {\n-            // The root snapshot.\n-            self.undo_log.truncate(0);\n-        } else {\n-            *self.undo_log.get_mut(snapshot.length) = CommittedSnapshot;\n-        }\n+        debug!(\"{}: commit()\", UnifyKey::tag(None::<K>));\n+        self.values.commit(snapshot.snapshot);\n     }\n \n     pub fn new_key(&mut self, value: V) -> K {\n-        let index = self.values.len();\n-\n-        if self.in_snapshot() {\n-            self.undo_log.push(NewVar(index));\n-        }\n-\n-        self.values.push(Root(value, 0));\n+        let index = self.values.push(Root(value, 0));\n         let k = UnifyKey::from_index(index);\n         debug!(\"{}: created new key: {}\",\n                UnifyKey::tag(None::<K>),\n                k);\n         k\n     }\n \n-    fn swap_value(&mut self,\n-                  index: uint,\n-                  new_value: VarValue<K,V>)\n-                  -> VarValue<K,V>\n-    {\n-        /*!\n-         * Primitive operation to swap a value in the var array.\n-         * Caller should update the undo log if we are in a snapshot.\n-         */\n-\n-        let loc = self.values.get_mut(index);\n-        mem::replace(loc, new_value)\n-    }\n-\n     pub fn get(&mut self, tcx: &ty::ctxt, vid: K) -> Node<K,V> {\n         /*!\n          * Find the root node for `vid`. This uses the standard\n@@ -274,15 +169,7 @@ impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n                 let node: Node<K,V> = self.get(tcx, redirect.clone());\n                 if node.key != redirect {\n                     // Path compression\n-                    let old_value =\n-                        self.swap_value(index, Redirect(node.key.clone()));\n-\n-                    // If we are in a snapshot, record this compression,\n-                    // because it's possible that the unification which\n-                    // caused it will be rolled back later.\n-                    if self.in_snapshot() {\n-                        self.undo_log.push(SetVar(index, old_value));\n-                    }\n+                    self.values.set(index, Redirect(node.key.clone()));\n                 }\n                 node\n             }\n@@ -310,15 +197,12 @@ impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n          */\n \n         assert!(self.is_root(&key));\n-        assert!(self.in_snapshot());\n \n         debug!(\"Updating variable {} to {}\",\n                key.repr(tcx),\n                new_value.repr(tcx));\n \n-        let index = key.index();\n-        let old_value = self.swap_value(index, new_value);\n-        self.undo_log.push(SetVar(index, old_value));\n+        self.values.set(key.index(), new_value);\n     }\n \n     pub fn unify(&mut self,\n@@ -359,6 +243,12 @@ impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n     }\n }\n \n+impl<K,V> sv::SnapshotVecDelegate<VarValue<K,V>,()> for Delegate {\n+    fn reverse(&mut self, _: &mut Vec<VarValue<K,V>>, _: ()) {\n+        fail!(\"Nothing to reverse\");\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Code to handle simple keys like ints, floats---anything that\n // doesn't have a subtyping relationship we need to worry about.\n@@ -373,7 +263,8 @@ pub trait SimplyUnifiable : Clone + PartialEq + Repr {\n \n pub fn err<V:SimplyUnifiable>(a_is_expected: bool,\n                               a_t: V,\n-                              b_t: V) -> ures {\n+                              b_t: V)\n+                              -> ures {\n     if a_is_expected {\n         Err(SimplyUnifiable::to_type_err(\n             ty::expected_found {expected: a_t, found: b_t}))\n@@ -483,26 +374,6 @@ impl<'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n \n ///////////////////////////////////////////////////////////////////////////\n \n-// General type keys\n-\n-impl UnifyKey<Bounds<ty::t>> for ty::TyVid {\n-    fn index(&self) -> uint { self.index }\n-\n-    fn from_index(i: uint) -> ty::TyVid { ty::TyVid { index: i } }\n-\n-    fn unification_table<'v>(infcx: &'v InferCtxt)\n-        -> &'v RefCell<UnificationTable<ty::TyVid, Bounds<ty::t>>>\n-    {\n-        return &infcx.type_unification_table;\n-    }\n-\n-    fn tag(_: Option<ty::TyVid>) -> &'static str {\n-        \"TyVid\"\n-    }\n-}\n-\n-impl UnifyValue for Bounds<ty::t> { }\n-\n // Integral type keys\n \n impl UnifyKey<Option<IntVarValue>> for ty::IntVid {"}, {"sha": "60e50c84c61f50926826739b0d032f5d96243180", "filename": "src/librustc/util/snapshot_vec.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -0,0 +1,195 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * A utility class for implementing \"snapshottable\" things; a\n+ * snapshottable data structure permits you to take a snapshot (via\n+ * `start_snapshot`) and then, after making some changes, elect either\n+ * to rollback to the start of the snapshot or commit those changes.\n+ *\n+ * This vector is intended to be used as part of an abstraction, not\n+ * serve as a complete abstraction on its own. As such, while it will\n+ * roll back most changes on its own, it also supports a `get_mut`\n+ * operation that gives you an abitrary mutable pointer into the\n+ * vector. To ensure that any changes you make this with this pointer\n+ * are rolled back, you must invoke `record` to record any changes you\n+ * make and also supplying a delegate capable of reversing those\n+ * changes.\n+ */\n+\n+use std::kinds::marker;\n+use std::mem;\n+\n+#[deriving(PartialEq)]\n+enum UndoLog<T,U> {\n+    /// Indicates where a snapshot started.\n+    OpenSnapshot,\n+\n+    /// Indicates a snapshot that has been committed.\n+    CommittedSnapshot,\n+\n+    /// New variable with given index was created.\n+    NewElem(uint),\n+\n+    /// Variable with given index was changed *from* the given value.\n+    SetElem(uint, T),\n+\n+    /// Extensible set of actions\n+    Other(U)\n+}\n+\n+pub struct SnapshotVec<T,U,D> {\n+    values: Vec<T>,\n+    undo_log: Vec<UndoLog<T,U>>,\n+    delegate: D\n+}\n+\n+pub struct Snapshot {\n+    // Snapshots are tokens that should be created/consumed linearly.\n+    marker: marker::NoCopy,\n+\n+    // Length of the undo log at the time the snapshot was taken.\n+    length: uint,\n+}\n+\n+pub trait SnapshotVecDelegate<T,U> {\n+    fn reverse(&mut self, values: &mut Vec<T>, action: U);\n+}\n+\n+impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n+    pub fn new(delegate: D) -> SnapshotVec<T,U,D> {\n+        SnapshotVec {\n+            values: Vec::new(),\n+            undo_log: Vec::new(),\n+            delegate: delegate\n+        }\n+    }\n+\n+    fn in_snapshot(&self) -> bool {\n+        !self.undo_log.is_empty()\n+    }\n+\n+    pub fn record(&mut self, action: U) {\n+        if self.in_snapshot() {\n+            self.undo_log.push(Other(action));\n+        }\n+    }\n+\n+    pub fn push(&mut self, elem: T) -> uint {\n+        let len = self.values.len();\n+        self.values.push(elem);\n+\n+        if self.in_snapshot() {\n+            self.undo_log.push(NewElem(len));\n+        }\n+\n+        len\n+    }\n+\n+    pub fn get<'a>(&'a self, index: uint) -> &'a T {\n+        self.values.get(index)\n+    }\n+\n+    pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n+        /*!\n+         * Returns a mutable pointer into the vec; whatever changes\n+         * you make here cannot be undone automatically, so you should\n+         * be sure call `record()` with some sort of suitable undo\n+         * action.\n+         */\n+\n+        self.values.get_mut(index)\n+    }\n+\n+    pub fn set(&mut self, index: uint, new_elem: T) {\n+        /*!\n+         * Updates the element at the given index. The old value will\n+         * saved (and perhaps restored) if a snapshot is active.\n+         */\n+\n+        let old_elem = mem::replace(self.values.get_mut(index), new_elem);\n+        if self.in_snapshot() {\n+            self.undo_log.push(SetElem(index, old_elem));\n+        }\n+    }\n+\n+    pub fn start_snapshot(&mut self) -> Snapshot {\n+        let length = self.undo_log.len();\n+        self.undo_log.push(OpenSnapshot);\n+        Snapshot { length: length,\n+                   marker: marker::NoCopy }\n+    }\n+\n+    fn assert_open_snapshot(&self, snapshot: &Snapshot) {\n+        // Or else there was a failure to follow a stack discipline:\n+        assert!(self.undo_log.len() > snapshot.length);\n+\n+        // Invariant established by start_snapshot():\n+        assert!(\n+            match *self.undo_log.get(snapshot.length) {\n+                OpenSnapshot => true,\n+                _ => false\n+            });\n+    }\n+\n+    pub fn rollback_to(&mut self, snapshot: Snapshot) {\n+        debug!(\"rollback_to({})\", snapshot.length);\n+\n+        self.assert_open_snapshot(&snapshot);\n+\n+        while self.undo_log.len() > snapshot.length + 1 {\n+            match self.undo_log.pop().unwrap() {\n+                OpenSnapshot => {\n+                    // This indicates a failure to obey the stack discipline.\n+                    fail!(\"Cannot rollback an uncommited snapshot\");\n+                }\n+\n+                CommittedSnapshot => {\n+                    // This occurs when there are nested snapshots and\n+                    // the inner is commited but outer is rolled back.\n+                }\n+\n+                NewElem(i) => {\n+                    self.values.pop();\n+                    assert!(self.values.len() == i);\n+                }\n+\n+                SetElem(i, v) => {\n+                    *self.values.get_mut(i) = v;\n+                }\n+\n+                Other(u) => {\n+                    self.delegate.reverse(&mut self.values, u);\n+                }\n+            }\n+        }\n+\n+        let v = self.undo_log.pop().unwrap();\n+        assert!(match v { OpenSnapshot => true, _ => false });\n+        assert!(self.undo_log.len() == snapshot.length);\n+    }\n+\n+    /**\n+     * Commits all changes since the last snapshot. Of course, they\n+     * can still be undone if there is a snapshot further out.\n+     */\n+    pub fn commit(&mut self, snapshot: Snapshot) {\n+        debug!(\"commit({})\", snapshot.length);\n+\n+        self.assert_open_snapshot(&snapshot);\n+\n+        if snapshot.length == 0 {\n+            // The root snapshot.\n+            self.undo_log.truncate(0);\n+        } else {\n+            *self.undo_log.get_mut(snapshot.length) = CommittedSnapshot;\n+        }\n+    }\n+}"}, {"sha": "6360a9135005c3d465703f1045c5cb4c9c42140e", "filename": "src/test/compile-fail/borrowck-closures-mut-of-imm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-of-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-of-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-of-imm.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -23,8 +23,7 @@ fn a(x: &int) {\n     let c1 = || set(&mut *x);\n     //~^ ERROR cannot borrow\n     let c2 = || set(&mut *x);\n-    //~^ ERROR closure requires unique access to `x`\n-    //~^^ ERROR cannot borrow\n+    //~^ ERROR cannot borrow\n }\n \n fn main() {"}, {"sha": "05cadfd536567aeadfd4d7302958c20cb1a05b34", "filename": "src/test/compile-fail/borrowck-reborrow-from-shorter-lived-andmut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fborrowck-reborrow-from-shorter-lived-andmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fborrowck-reborrow-from-shorter-lived-andmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-reborrow-from-shorter-lived-andmut.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -17,7 +17,7 @@ struct S<'a> {\n \n fn copy_borrowed_ptr<'a,'b>(p: &'a mut S<'b>) -> S<'b> {\n     S { pointer: &mut *p.pointer }\n-    //~^ ERROR lifetime of `p` is too short to guarantee its contents can be safely reborrowed\n+    //~^ ERROR cannot infer\n }\n \n fn main() {"}, {"sha": "995ae7b3d44e70632669f9bc53a91942b38de75b", "filename": "src/test/compile-fail/issue-10291.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn test<'x>(x: &'x int) {\n-    drop::< <'z>|&'z int| -> &'z int>(|z| {\n+    drop::< <'z>|&'z int| -> &'z int >(|z| {\n         x\n         //~^ ERROR cannot infer an appropriate lifetime\n     });"}, {"sha": "2d7458944269cb24efe2ed5796c76b944e59fc0c", "filename": "src/test/compile-fail/issue-13482.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -12,7 +12,7 @@ fn main() {\n   let x = [1,2];\n   let y = match x {\n     [] => None,\n-//~^ ERROR expected `[<generic integer #1>, .. 2]`, found a fixed vector pattern of size 0\n+//~^ ERROR expected `[<generic integer #0>, .. 2]`, found a fixed vector pattern of size 0\n     [a,_] => Some(a)\n   };\n }"}, {"sha": "305b1fe2ad7ded015e6c6b79eba5fdf60ded30de", "filename": "src/test/compile-fail/issue-16338.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fissue-16338.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fissue-16338.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16338.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -12,6 +12,6 @@ use std::raw::Slice;\n \n fn main() {\n     let Slice { data: data, len: len } = \"foo\";\n-    //~^ ERROR mismatched types: expected `&'static str`, found a structure pattern\n+    //~^ ERROR mismatched types: expected `&str`, found a structure pattern\n }\n "}, {"sha": "5d07472afbb2572ea7b1f4b13ed9803304c5a086", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -22,5 +22,5 @@ impl<A> vec_monad<A> for Vec<A> {\n }\n fn main() {\n     [\"hi\"].bind(|x| [x] );\n-    //~^ ERROR type `[&'static str, .. 1]` does not implement any method in scope named `bind`\n+    //~^ ERROR type `[&str, .. 1]` does not implement any method in scope named `bind`\n }"}, {"sha": "2520ed215d55eb30d272f491cc991961af45119d", "filename": "src/test/compile-fail/kindck-inherited-copy-bound.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fkindck-inherited-copy-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fkindck-inherited-copy-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-inherited-copy-bound.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that Copy bounds inherited by trait are checked.\n+\n+use std::any::Any;\n+use std::any::AnyRefExt;\n+\n+trait Foo : Copy {\n+}\n+\n+impl<T:Copy> Foo for T {\n+}\n+\n+fn take_param<T:Foo>(foo: &T) { }\n+\n+fn main() {\n+    let x = box 3i;\n+    take_param(&x); //~ ERROR does not fulfill `Copy`\n+\n+    let y = &x;\n+    let z = &x as &Foo; //~ ERROR does not fulfill `Copy`\n+}"}, {"sha": "6a90fd553560470680b3d956086e15d18af75601", "filename": "src/test/compile-fail/kindck-send-object1.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test which object types are considered sendable. This test\n+// is broken into two parts because some errors occur in distinct\n+// phases in the compiler. See kindck-send-object2.rs as well!\n+\n+fn assert_send<T:Send>() { }\n+trait Dummy { }\n+\n+// careful with object types, who knows what they close over...\n+fn test51<'a>() {\n+    assert_send::<&'a Dummy>(); //~ ERROR does not fulfill the required lifetime\n+}\n+fn test52<'a>() {\n+    assert_send::<&'a Dummy+Send>(); //~ ERROR does not fulfill the required lifetime\n+}\n+\n+// ...unless they are properly bounded\n+fn test60() {\n+    assert_send::<&'static Dummy+Send>();\n+}\n+fn test61() {\n+    assert_send::<Box<Dummy+Send>>();\n+}\n+\n+// closure and object types can have lifetime bounds which make\n+// them not ok\n+fn test_70<'a>() {\n+    assert_send::<proc():'a>(); //~ ERROR does not fulfill the required lifetime\n+}\n+\n+fn test_71<'a>() {\n+    assert_send::<Box<Dummy+'a>>(); //~ ERROR does not fulfill the required lifetime\n+}\n+\n+fn main() { }"}, {"sha": "75006477837c2bd2323e119043b8c48f01a3b564", "filename": "src/test/compile-fail/kindck-send-object2.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Continue kindck-send-object1.rs.\n+\n+fn assert_send<T:Send>() { }\n+trait Dummy { }\n+\n+fn test50() {\n+    assert_send::<&'static Dummy>(); //~ ERROR does not fulfill `Send`\n+}\n+\n+fn test53() {\n+    assert_send::<Box<Dummy>>(); //~ ERROR does not fulfill `Send`\n+}\n+\n+// ...unless they are properly bounded\n+fn test60() {\n+    assert_send::<&'static Dummy+Send>();\n+}\n+fn test61() {\n+    assert_send::<Box<Dummy+Send>>();\n+}\n+\n+fn main() { }"}, {"sha": "0eed05692b9c5ddf505d96966ff68f812d15187a", "filename": "src/test/compile-fail/kindck-send-owned.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fkindck-send-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fkindck-send-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-owned.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test which of the builtin types are considered sendable.\n+\n+fn assert_send<T:Send>() { }\n+\n+// owned content are ok\n+fn test30() { assert_send::<Box<int>>(); }\n+fn test31() { assert_send::<String>(); }\n+fn test32() { assert_send::<Vec<int> >(); }\n+\n+// but not if they own a bad thing\n+fn test40<'a>(_: &'a int) {\n+    assert_send::<Box<&'a int>>(); //~ ERROR does not fulfill the required lifetime\n+}\n+\n+fn main() { }"}, {"sha": "cc46d7f4de9c0ef529ac0b8a9d70eb1edc3d86d7", "filename": "src/test/compile-fail/kindck-send-region-pointers.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fkindck-send-region-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fkindck-send-region-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-region-pointers.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that borrowed pointers are not sendable unless 'static.\n+\n+fn assert_send<T:Send>() { }\n+\n+// lifetime pointers with 'static lifetime are ok\n+fn test01() { assert_send::<&'static int>(); }\n+fn test02() { assert_send::<&'static str>(); }\n+fn test03() { assert_send::<&'static [int]>(); }\n+\n+// whether or not they are mutable\n+fn test10() { assert_send::<&'static mut int>(); }\n+\n+// otherwise lifetime pointers are not ok\n+fn test20<'a>(_: &'a int) {\n+    assert_send::<&'a int>(); //~ ERROR does not fulfill the required lifetime\n+}\n+fn test21<'a>(_: &'a int) {\n+    assert_send::<&'a str>(); //~ ERROR does not fulfill the required lifetime\n+}\n+fn test22<'a>(_: &'a int) {\n+    assert_send::<&'a [int]>(); //~ ERROR does not fulfill the required lifetime\n+}\n+\n+fn main() { }"}, {"sha": "a9bbfcfa26263c50fba60f3bcab62077bf7b5e0b", "filename": "src/test/compile-fail/kindck-send-unsafe.rs", "status": "renamed", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fkindck-send-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fkindck-send-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-unsafe.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,13 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n+fn assert_send<T:Send>() { }\n \n-macro_rules! if_ok(\n-    ($inp: expr) => (\n-        match $inp {\n-            Ok(v) => { v }\n-            Err(e) => { return Err(e); }\n-        }\n-    )\n-)\n+// unsafe ptrs are ok unless they point at unsendable things\n+fn test70() {\n+    assert_send::<*mut int>();\n+}\n+fn test71<'a>() {\n+    assert_send::<*mut &'a int>(); //~ ERROR does not fulfill the required lifetime\n+}\n+\n+fn main() {\n+}", "previous_filename": "src/librustc/middle/typeck/infer/macros.rs"}, {"sha": "e13a6b211a5038b7526b532bcb9adde394c2c02f", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -17,12 +17,10 @@ struct a_class<'a> { x:&'a int }\n \n fn a_fn1<'a,'b>(e: an_enum<'a>) -> an_enum<'b> {\n     return e; //~ ERROR mismatched types: expected `an_enum<'b>`, found `an_enum<'a>`\n-    //~^ ERROR cannot infer\n }\n \n fn a_fn3<'a,'b>(e: a_class<'a>) -> a_class<'b> {\n     return e; //~ ERROR mismatched types: expected `a_class<'b>`, found `a_class<'a>`\n-    //~^ ERROR cannot infer\n }\n \n fn main() { }"}, {"sha": "66103eb95888ac941e1cf123c8641d2b0978c584", "filename": "src/test/compile-fail/regions-escape-bound-fn-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -15,7 +15,6 @@ fn with_int(f: |x: &int|) {\n \n fn main() {\n     let mut x = None;\n-         //~^ ERROR lifetime of variable does not enclose its declaration\n-         //~^^ ERROR type of expression contains references that are not valid during the expression\n     with_int(|y| x = Some(y));\n+         //~^ ERROR cannot infer\n }"}, {"sha": "fee84cf9656d1ceaae73f4fb5d02a75c55a63579", "filename": "src/test/compile-fail/regions-escape-bound-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -14,6 +14,6 @@ fn with_int(f: |x: &int|) {\n }\n \n fn main() {\n-    let mut x: Option<&int> = None;   //~ ERROR cannot infer\n-    with_int(|y| x = Some(y));\n+    let mut x: Option<&int> = None;\n+    with_int(|y| x = Some(y));   //~ ERROR cannot infer\n }"}, {"sha": "b73b5e0649ff5a76a6a7afd612c613183786acbc", "filename": "src/test/compile-fail/regions-escape-via-trait-or-not.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -27,7 +27,7 @@ fn with<R:Deref>(f: |x: &int| -> R) -> int {\n }\n \n fn return_it() -> int {\n-    with(|o| o) //~ ERROR cannot infer an appropriate lifetime\n+    with(|o| o) //~ ERROR cannot infer\n }\n \n fn main() {"}, {"sha": "8af341e3ace42b9d949319d92199f98008180d8b", "filename": "src/test/compile-fail/regions-infer-at-fn-not-param.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -22,7 +22,6 @@ struct not_parameterized2 {\n \n fn take1<'a>(p: parameterized1) -> parameterized1<'a> { p }\n //~^ ERROR mismatched types\n-//~^^ ERROR cannot infer\n \n fn take3(p: not_parameterized1) -> not_parameterized1 { p }\n fn take4(p: not_parameterized2) -> not_parameterized2 { p }"}, {"sha": "4dd028b78845996e18acfdb6f65d1a0446260bac", "filename": "src/test/compile-fail/regions-infer-contravariance-due-to-decl.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-decl.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -33,7 +33,6 @@ fn use_<'short,'long>(c: Contravariant<'short>,\n     // covariant with respect to its parameter 'a.\n \n     let _: Contravariant<'long> = c; //~ ERROR mismatched types\n-    //~^ ERROR  cannot infer an appropriate lifetime\n }\n \n fn main() {}"}, {"sha": "93c06aecd30ecffdaf5ad5d732071fa44c06f59b", "filename": "src/test/compile-fail/regions-infer-covariance-due-to-decl.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-decl.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -30,7 +30,6 @@ fn use_<'short,'long>(c: Covariant<'long>,\n     // contravariant with respect to its parameter 'a.\n \n     let _: Covariant<'short> = c; //~ ERROR mismatched types\n-    //~^ ERROR  cannot infer an appropriate lifetime\n }\n \n fn main() {}"}, {"sha": "b84f13ec37feb44d16654af4e6bf795c965046f3", "filename": "src/test/compile-fail/regions-infer-not-param.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -23,11 +23,9 @@ struct indirect2<'a> {\n }\n \n fn take_direct<'a,'b>(p: direct<'a>) -> direct<'b> { p } //~ ERROR mismatched types\n-//~^ ERROR cannot infer\n \n fn take_indirect1(p: indirect1) -> indirect1 { p }\n \n fn take_indirect2<'a,'b>(p: indirect2<'a>) -> indirect2<'b> { p } //~ ERROR mismatched types\n-//~^ ERROR cannot infer\n \n fn main() {}"}, {"sha": "e862b36dcd1680a2ddd7d8408fd921c13676a125", "filename": "src/test/compile-fail/regions-infer-paramd-indirect.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -22,18 +22,17 @@ struct c<'a> {\n }\n \n trait set_f<'a> {\n-    fn set_f_ok(&self, b: Gc<b<'a>>);\n-    fn set_f_bad(&self, b: Gc<b>);\n+    fn set_f_ok(&mut self, b: Gc<b<'a>>);\n+    fn set_f_bad(&mut self, b: Gc<b>);\n }\n \n impl<'a> set_f<'a> for c<'a> {\n-    fn set_f_ok(&self, b: Gc<b<'a>>) {\n+    fn set_f_ok(&mut self, b: Gc<b<'a>>) {\n         self.f = b;\n     }\n \n-    fn set_f_bad(&self, b: Gc<b>) {\n+    fn set_f_bad(&mut self, b: Gc<b>) {\n         self.f = b; //~ ERROR mismatched types: expected `Gc<Gc<&'a int>>`, found `Gc<Gc<&int>>`\n-        //~^ ERROR cannot infer\n     }\n }\n "}, {"sha": "7fe85290da0ecf5355f3f2e866de52f07654fdc2", "filename": "src/test/compile-fail/regions-infer-proc-static-upvar.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-infer-proc-static-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-infer-proc-static-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-proc-static-upvar.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that, when a variable of type `&T` is captured inside a proc,\n+// we correctly infer/require that its lifetime is 'static.\n+\n+fn foo(_p: proc():'static) { }\n+\n+static i: int = 3;\n+\n+fn capture_local() {\n+    let x = 3i;\n+    let y = &x; //~ ERROR `x` does not live long enough\n+    foo(proc() {\n+        let _a = *y;\n+    });\n+}\n+\n+fn capture_static() {\n+    // Legal because &i can have static lifetime:\n+    let y = &i;\n+    foo(proc() {\n+        let _a = *y;\n+    });\n+}\n+\n+fn main() { }"}, {"sha": "783009f6dcbfca4ae240e83f81517911d598d353", "filename": "src/test/compile-fail/regions-reborrow-from-shorter-mut-ref-mut-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref-mut-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref-mut-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref-mut-ref.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -11,7 +11,7 @@\n // Issue #8624. Test for reborrowing with 3 levels, not just two.\n \n fn copy_borrowed_ptr<'a, 'b, 'c>(p: &'a mut &'b mut &'c mut int) -> &'b mut int {\n-    &mut ***p //~ ERROR lifetime of `p` is too short to guarantee its contents\n+    &mut ***p //~ ERROR cannot infer\n }\n \n fn main() {"}, {"sha": "4b1c7a2928b8ef1f67ba268a1b0afb120c3e4393", "filename": "src/test/compile-fail/regions-reborrow-from-shorter-mut-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -13,7 +13,7 @@\n // for `'a` (which must be a sublifetime of `'b`).\n \n fn copy_borrowed_ptr<'a, 'b>(p: &'a mut &'b mut int) -> &'b mut int {\n-    &mut **p //~ ERROR lifetime of `p` is too short\n+    &mut **p //~ ERROR cannot infer\n }\n \n fn main() {"}, {"sha": "6d9b2619171057fd632f836e258d478965f2c584", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -19,8 +19,6 @@ fn with<R>(f: <'a>|x: &'a int| -> R) -> R {\n fn return_it<'a>() -> &'a int {\n     with(|o| o)\n         //~^ ERROR cannot infer\n-        //~^^ ERROR not valid during the expression\n-        //~^^^ ERROR not valid at this point\n }\n \n fn main() {"}, {"sha": "465f4410fbbccb2d05451c0db6240e5433815a9f", "filename": "src/test/compile-fail/regions-ret-borrowed.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -22,8 +22,6 @@ fn with<R>(f: |x: &int| -> R) -> R {\n fn return_it<'a>() -> &'a int {\n     with(|o| o)\n         //~^ ERROR cannot infer\n-        //~^^ ERROR not valid during the expression\n-        //~^^^ ERROR not valid at this point\n }\n \n fn main() {"}, {"sha": "14ead8da1587b12189c23015e1f09414c5765de3", "filename": "src/test/compile-fail/regions-variance-contravariant-use-covariant-in-second-position.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant-in-second-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant-in-second-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant-in-second-position.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -33,7 +33,6 @@ fn use_<'short,'long>(c: S<'long, 'short>,\n     // covariant with respect to its parameter 'a.\n \n     let _: S<'long, 'long> = c; //~ ERROR mismatched types\n-    //~^ ERROR  cannot infer an appropriate lifetime\n }\n \n fn main() {}"}, {"sha": "3fc58071d2ce86c421b8e4cb09774224881ee8f4", "filename": "src/test/compile-fail/regions-variance-contravariant-use-covariant.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -31,7 +31,6 @@ fn use_<'short,'long>(c: Contravariant<'short>,\n     // covariant with respect to its parameter 'a.\n \n     let _: Contravariant<'long> = c; //~ ERROR mismatched types\n-    //~^ ERROR  cannot infer an appropriate lifetime\n }\n \n fn main() {}"}, {"sha": "844c8151a642ae31f59ba28ef922f524da989894", "filename": "src/test/compile-fail/regions-variance-covariant-use-contravariant.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -31,7 +31,6 @@ fn use_<'short,'long>(c: Covariant<'long>,\n     // contravariant with respect to its parameter 'a.\n \n     let _: Covariant<'short> = c; //~ ERROR mismatched types\n-    //~^ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {}"}, {"sha": "efe3994dbb7b98e928fb735fb4b635d014f7b81d", "filename": "src/test/run-pass/regions-infer-reborrow-ref-mut-recurse.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Frun-pass%2Fregions-infer-reborrow-ref-mut-recurse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Frun-pass%2Fregions-infer-reborrow-ref-mut-recurse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-reborrow-ref-mut-recurse.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test an edge case in region inference: the lifetime of the borrow\n+// of `*x` must be extended to at least 'a.\n+\n+fn foo<'a,'b>(x: &'a &'b mut int) -> &'a int {\n+    let y = &*x; // should be inferred to have type &'a &'b mut int...\n+\n+    // ...because if we inferred, say, &'x &'b mut int where 'x <= 'a,\n+    // this reborrow would be illegal:\n+    &**y\n+}\n+\n+pub fn main() {\n+    /* Just want to know that it compiles. */\n+}"}, {"sha": "823644ddfb51954bf79dab420014872869042e0c", "filename": "src/test/run-pass/regions-infer-static-from-proc.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Frun-pass%2Fregions-infer-static-from-proc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Frun-pass%2Fregions-infer-static-from-proc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-static-from-proc.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that the 'static bound on a proc influences lifetimes of\n+// region variables contained within (otherwise, region inference will\n+// give `x` a very short lifetime).\n+\n+static i: uint = 3;\n+fn foo(_: proc():'static) {}\n+fn read(_: uint) { }\n+pub fn main() {\n+    let x = &i;\n+    foo(proc() {\n+        read(*x);\n+    });\n+}"}, {"sha": "0eacb27a600bd849dc4624b3e3477be93b7d0c41", "filename": "src/test/run-pass/regions-scope-chain-example.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Frun-pass%2Fregions-scope-chain-example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd159d3867473ee43959706519066531d76af7ba/src%2Ftest%2Frun-pass%2Fregions-scope-chain-example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-scope-chain-example.rs?ref=bd159d3867473ee43959706519066531d76af7ba", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is an example where the older inference algorithm failed. The\n+// specifics of why it failed are somewhat, but not entirely, tailed\n+// to the algorithm. Ultimately the problem is that when computing the\n+// mutual supertype of both sides of the `if` it would be faced with a\n+// choice of tightening bounds or unifying variables and it took the\n+// wrong path. The new algorithm avoids this problem and hence this\n+// example typechecks correctly.\n+\n+enum ScopeChain<'a> {\n+    Link(Scope<'a>),\n+    End\n+}\n+\n+type Scope<'a> = &'a ScopeChain<'a>;\n+\n+struct OuterContext;\n+\n+struct Context<'a> {\n+    foo: &'a OuterContext\n+}\n+\n+impl<'a> Context<'a> {\n+    fn foo(&mut self, scope: Scope) {\n+        let link = if 1i < 2 {\n+            let l = Link(scope);\n+            self.take_scope(&l);\n+            l\n+        } else {\n+            Link(scope)\n+        };\n+        self.take_scope(&link);\n+    }\n+\n+    fn take_scope(&mut self, x: Scope) {\n+    }\n+}\n+\n+fn main() { }"}]}