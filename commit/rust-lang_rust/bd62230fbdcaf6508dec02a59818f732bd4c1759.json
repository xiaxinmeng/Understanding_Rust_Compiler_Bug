{"sha": "bd62230fbdcaf6508dec02a59818f732bd4c1759", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNjIyMzBmYmRjYWY2NTA4ZGVjMDJhNTk4MThmNzMyYmQ0YzE3NTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-22T21:46:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-22T21:46:08Z"}, "message": "Auto merge of #42614 - GuillaumeGomez:new-error-codes, r=pnkfelix\n\nNew error codes\n\nPart of #42229.\n\ncc @Susurrus @frewsxcv @QuietMisdreavus", "tree": {"sha": "0e546986ce54804d446f749f5800cbf3142d9b2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e546986ce54804d446f749f5800cbf3142d9b2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd62230fbdcaf6508dec02a59818f732bd4c1759", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd62230fbdcaf6508dec02a59818f732bd4c1759", "html_url": "https://github.com/rust-lang/rust/commit/bd62230fbdcaf6508dec02a59818f732bd4c1759", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd62230fbdcaf6508dec02a59818f732bd4c1759/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab5bec25530aac43dfd64384b405c909b6e405e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab5bec25530aac43dfd64384b405c909b6e405e3", "html_url": "https://github.com/rust-lang/rust/commit/ab5bec25530aac43dfd64384b405c909b6e405e3"}, {"sha": "ee600642db3034743d3f8ae19abd639139d743dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee600642db3034743d3f8ae19abd639139d743dd", "html_url": "https://github.com/rust-lang/rust/commit/ee600642db3034743d3f8ae19abd639139d743dd"}], "stats": {"total": 447, "additions": 401, "deletions": 46}, "files": [{"sha": "2bf24d5b3504c534942e943d13cb2352fefe02bb", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 35, "deletions": 41, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bd62230fbdcaf6508dec02a59818f732bd4c1759", "patch": "@@ -2950,8 +2950,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some((did, field_ty)) = private_candidate {\n             let struct_path = self.tcx().item_path_str(did);\n-            let msg = format!(\"field `{}` of struct `{}` is private\", field.node, struct_path);\n-            let mut err = self.tcx().sess.struct_span_err(expr.span, &msg);\n+            let mut err = struct_span_err!(self.tcx().sess, expr.span, E0616,\n+                                           \"field `{}` of struct `{}` is private\",\n+                                           field.node, struct_path);\n             // Also check if an accessible method exists, which is often what is meant.\n             if self.method_exists(field.span, field.node, expr_t, expr.id, false) {\n                 err.note(&format!(\"a method `{}` also exists, perhaps you wish to call it\",\n@@ -2962,10 +2963,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         } else if field.node == keywords::Invalid.name() {\n             self.tcx().types.err\n         } else if self.method_exists(field.span, field.node, expr_t, expr.id, true) {\n-            self.type_error_struct(field.span, |actual| {\n-                format!(\"attempted to take value of method `{}` on type \\\n-                         `{}`\", field.node, actual)\n-            }, expr_t)\n+            type_error_struct!(self.tcx().sess, field.span, expr_t, E0615,\n+                              \"attempted to take value of method `{}` on type `{}`\",\n+                              field.node, expr_t)\n                 .help(\"maybe a `()` to call it is missing? \\\n                        If not, try an anonymous function\")\n                 .emit();\n@@ -3080,27 +3080,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some((did, field_ty)) = private_candidate {\n             let struct_path = self.tcx().item_path_str(did);\n-            let msg = format!(\"field `{}` of struct `{}` is private\", idx.node, struct_path);\n-            self.tcx().sess.span_err(expr.span, &msg);\n+            struct_span_err!(self.tcx().sess, expr.span, E0611,\n+                             \"field `{}` of tuple-struct `{}` is private\",\n+                             idx.node, struct_path).emit();\n             return field_ty;\n         }\n \n-        self.type_error_message(\n-            expr.span,\n-            |actual| {\n-                if tuple_like {\n-                    format!(\"attempted out-of-bounds tuple index `{}` on \\\n-                                    type `{}`\",\n-                                   idx.node,\n-                                   actual)\n-                } else {\n-                    format!(\"attempted tuple index `{}` on type `{}`, but the \\\n-                                     type was not a tuple or tuple struct\",\n-                                    idx.node,\n-                                    actual)\n-                }\n-            },\n-            expr_t);\n+        if tuple_like {\n+            type_error_struct!(self.tcx().sess, expr.span, expr_t, E0612,\n+                               \"attempted out-of-bounds tuple index `{}` on type `{}`\",\n+                               idx.node, expr_t).emit();\n+        } else {\n+            type_error_struct!(self.tcx().sess, expr.span, expr_t, E0613,\n+                               \"attempted to access tuple index `{}` on type `{}`, but the type \\\n+                                was not a tuple or tuple struct\",\n+                               idx.node, expr_t).emit();\n+        }\n \n         self.tcx().types.err\n     }\n@@ -3201,10 +3196,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 field_type_hint = tcx.types.err;\n                 if let Some(_) = variant.find_field_named(field.name.node) {\n                     let mut err = struct_span_err!(self.tcx.sess,\n-                                                field.name.span,\n-                                                E0062,\n-                                                \"field `{}` specified more than once\",\n-                                                field.name.node);\n+                                                   field.name.span,\n+                                                   E0062,\n+                                                   \"field `{}` specified more than once\",\n+                                                   field.name.node);\n \n                     err.span_label(field.name.span, \"used more than once\");\n \n@@ -3251,15 +3246,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                         .join(\", \");\n \n             struct_span_err!(tcx.sess, span, E0063,\n-                        \"missing field{} {}{} in initializer of `{}`\",\n-                        if remaining_fields.len() == 1 {\"\"} else {\"s\"},\n-                        remaining_fields_names,\n-                        truncated_fields_error,\n-                        adt_ty)\n-                        .span_label(span, format!(\"missing {}{}\",\n-                            remaining_fields_names,\n-                            truncated_fields_error))\n-                        .emit();\n+                             \"missing field{} {}{} in initializer of `{}`\",\n+                             if remaining_fields.len() == 1 { \"\" } else { \"s\" },\n+                             remaining_fields_names,\n+                             truncated_fields_error,\n+                             adt_ty)\n+                            .span_label(span, format!(\"missing {}{}\",\n+                                        remaining_fields_names,\n+                                        truncated_fields_error))\n+                            .emit();\n         }\n     }\n \n@@ -3492,10 +3487,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             oprnd_t = self.make_overloaded_lvalue_return_type(method).ty;\n                             self.write_method_call(expr.id, method);\n                         } else {\n-                            self.type_error_message(expr.span, |actual| {\n-                                format!(\"type `{}` cannot be \\\n-                                        dereferenced\", actual)\n-                            }, oprnd_t);\n+                            type_error_struct!(tcx.sess, expr.span, oprnd_t, E0614,\n+                                               \"type `{}` cannot be dereferenced\",\n+                                               oprnd_t).emit();\n                             oprnd_t = tcx.types.err;\n                         }\n                     }"}, {"sha": "a898a75d0c976b8a4006fc7285f7fd85ae97712a", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=bd62230fbdcaf6508dec02a59818f732bd4c1759", "patch": "@@ -4174,6 +4174,253 @@ println!(\"x: {}, y: {}\", variable.x, variable.y);\n For more information see The Rust Book: https://doc.rust-lang.org/book/\n \"##,\n \n+E0611: r##\"\n+Attempted to access a private field on a tuple-struct.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0611\n+mod some_module {\n+    pub struct Foo(u32);\n+\n+    impl Foo {\n+        pub fn new() -> Foo { Foo(0) }\n+    }\n+}\n+\n+let y = some_module::Foo::new();\n+println!(\"{}\", y.0); // error: field `0` of tuple-struct `some_module::Foo`\n+                     //        is private\n+```\n+\n+Since the field is private, you have two solutions:\n+\n+1) Make the field public:\n+\n+```\n+mod some_module {\n+    pub struct Foo(pub u32); // The field is now public.\n+\n+    impl Foo {\n+        pub fn new() -> Foo { Foo(0) }\n+    }\n+}\n+\n+let y = some_module::Foo::new();\n+println!(\"{}\", y.0); // So we can access it directly.\n+```\n+\n+2) Add a getter function to keep the field private but allow for accessing its\n+value:\n+\n+```\n+mod some_module {\n+    pub struct Foo(u32);\n+\n+    impl Foo {\n+        pub fn new() -> Foo { Foo(0) }\n+\n+        // We add the getter function.\n+        pub fn get(&self) -> &u32 { &self.0 }\n+    }\n+}\n+\n+let y = some_module::Foo::new();\n+println!(\"{}\", y.get()); // So we can get the value through the function.\n+```\n+\"##,\n+\n+E0612: r##\"\n+Attempted out-of-bounds tuple index.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0612\n+struct Foo(u32);\n+\n+let y = Foo(0);\n+println!(\"{}\", y.1); // error: attempted out-of-bounds tuple index `1`\n+                     //        on type `Foo`\n+```\n+\n+If a tuple/tuple-struct type has n fields, you can only try to access these n\n+fields from 0 to (n - 1). So in this case, you can only index `0`. Example:\n+\n+```\n+struct Foo(u32);\n+\n+let y = Foo(0);\n+println!(\"{}\", y.0); // ok!\n+```\n+\"##,\n+\n+E0613: r##\"\n+Attempted tuple index on a type which isn't a tuple nor a tuple-struct.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0613\n+struct Foo;\n+\n+let y = Foo;\n+println!(\"{}\", y.1); // error: attempted to access tuple index `1` on type\n+                     //        `Foo`, but the type was not a tuple or tuple\n+                     //        struct\n+```\n+\n+Only tuple and tuple-struct types can be indexed this way. Example:\n+\n+```\n+// Let's create a tuple first:\n+let x: (u32, u32, u32, u32) = (0, 1, 1, 2);\n+// You can index its fields this way:\n+println!(\"({}, {}, {}, {})\", x.0, x.1, x.2, x.3);\n+\n+// Now let's declare a tuple-struct:\n+struct TupleStruct(u32, u32, u32, u32);\n+// Let's instantiate it:\n+let x = TupleStruct(0, 1, 1, 2);\n+// And just like the tuple:\n+println!(\"({}, {}, {}, {})\", x.0, x.1, x.2, x.3);\n+```\n+\n+If you want to index into an array, use `[]` instead:\n+\n+```\n+let x = &[0, 1, 1, 2];\n+println!(\"[{}, {}, {}, {}]\", x[0], x[1], x[2], x[3]);\n+```\n+\n+If you want to access a field of a struct, check the field's name wasn't\n+misspelled:\n+\n+```\n+struct SomeStruct {\n+    x: u32,\n+    y: i32,\n+}\n+\n+let s = SomeStruct {\n+    x: 0,\n+    y: -1,\n+};\n+println!(\"x: {} y: {}\", s.x, s.y);\n+```\n+\"##,\n+\n+E0614: r##\"\n+Attempted to dereference a variable which cannot be dereferenced.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0614\n+let y = 0u32;\n+*y; // error: type `u32` cannot be dereferenced\n+```\n+\n+Only types implementing `std::ops::Deref` can be dereferenced (such as `&T`).\n+Example:\n+\n+```\n+let y = 0u32;\n+let x = &y;\n+// So here, `x` is a `&u32`, so we can dereference it:\n+*x; // ok!\n+```\n+\"##,\n+\n+E0615: r##\"\n+Attempted to access a method like a field.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0615\n+struct Foo {\n+    x: u32,\n+}\n+\n+impl Foo {\n+    fn method(&self) {}\n+}\n+\n+let f = Foo { x: 0 };\n+f.method; // error: attempted to take value of method `method` on type `Foo`\n+```\n+\n+If you want to use a method, add `()` after it:\n+\n+```ignore\n+f.method();\n+```\n+\n+However, if you wanted to access a field of a struct check that the field name\n+is spelled correctly. Example:\n+\n+```ignore\n+println!(\"{}\", f.x);\n+```\n+\"##,\n+\n+E0616: r##\"\n+Attempted to access a private field on a struct.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0616\n+mod some_module {\n+    pub struct Foo {\n+        x: u32, // So `x` is private in here.\n+    }\n+\n+    impl Foo {\n+        pub fn new() -> Foo { Foo { x: 0 } }\n+    }\n+}\n+\n+let f = some_module::Foo::new();\n+println!(\"{}\", f.x); // error: field `x` of struct `some_module::Foo` is private\n+```\n+\n+If you want to access this field, you have two options:\n+\n+1) Set the field public:\n+\n+```\n+mod some_module {\n+    pub struct Foo {\n+        pub x: u32, // `x` is now public.\n+    }\n+\n+    impl Foo {\n+        pub fn new() -> Foo { Foo { x: 0 } }\n+    }\n+}\n+\n+let f = some_module::Foo::new();\n+println!(\"{}\", f.x); // ok!\n+```\n+\n+2) Add a getter function:\n+\n+```\n+mod some_module {\n+    pub struct Foo {\n+        x: u32, // So `x` is still private in here.\n+    }\n+\n+    impl Foo {\n+        pub fn new() -> Foo { Foo { x: 0 } }\n+\n+        // We create the getter function here:\n+        pub fn get_x(&self) -> &u32 { &self.x }\n+    }\n+}\n+\n+let f = some_module::Foo::new();\n+println!(\"{}\", f.get_x()); // ok!\n+```\n+\"##,\n+\n E0617: r##\"\n Attempted to pass an invalid type of variable into a variadic function.\n "}, {"sha": "1e392d194b1d83d85f1993c28c1cd4d83e190adc", "filename": "src/test/compile-fail/E0611.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Ftest%2Fcompile-fail%2FE0611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Ftest%2Fcompile-fail%2FE0611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0611.rs?ref=bd62230fbdcaf6508dec02a59818f732bd4c1759", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod a {\n+    pub struct Foo(u32);\n+\n+    impl Foo {\n+        pub fn new() -> Foo { Foo(0) }\n+    }\n+}\n+\n+fn main() {\n+   let y = a::Foo::new();\n+   y.0; //~ ERROR E0611\n+}"}, {"sha": "429a8bb7eb7b2119be64b58dda966c98fdce3b54", "filename": "src/test/compile-fail/E0612.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Ftest%2Fcompile-fail%2FE0612.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Ftest%2Fcompile-fail%2FE0612.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0612.rs?ref=bd62230fbdcaf6508dec02a59818f732bd4c1759", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo(u32);\n+\n+fn main() {\n+   let y = Foo(0);\n+   y.1; //~ ERROR E0612\n+}"}, {"sha": "189d1b1d3bad6108a3bead21591d573b93d03831", "filename": "src/test/compile-fail/E0613.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Ftest%2Fcompile-fail%2FE0613.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Ftest%2Fcompile-fail%2FE0613.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0613.rs?ref=bd62230fbdcaf6508dec02a59818f732bd4c1759", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo;\n+\n+fn main() {\n+   let y = Foo;\n+   y.1; //~ ERROR E0613\n+}"}, {"sha": "909f0eb828558446200599035842b198cf86ea3d", "filename": "src/test/compile-fail/E0614.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Ftest%2Fcompile-fail%2FE0614.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Ftest%2Fcompile-fail%2FE0614.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0614.rs?ref=bd62230fbdcaf6508dec02a59818f732bd4c1759", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let y = 0u32;\n+    *y; //~ ERROR E0614\n+}"}, {"sha": "abfa93d2fd0c151b98b6ec17b807e2783d7f0822", "filename": "src/test/compile-fail/E0615.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Ftest%2Fcompile-fail%2FE0615.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Ftest%2Fcompile-fail%2FE0615.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0615.rs?ref=bd62230fbdcaf6508dec02a59818f732bd4c1759", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+    x: u32,\n+}\n+\n+impl Foo {\n+    fn method(&self) {}\n+}\n+\n+fn main() {\n+    let f = Foo { x: 0 };\n+    f.method; //~ ERROR E0615\n+}"}, {"sha": "2fd9f94763d8d2d83e231d52787c65af98d4590b", "filename": "src/test/compile-fail/E0616.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Ftest%2Fcompile-fail%2FE0616.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Ftest%2Fcompile-fail%2FE0616.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0616.rs?ref=bd62230fbdcaf6508dec02a59818f732bd4c1759", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod a {\n+    pub struct Foo {\n+        x: u32,\n+    }\n+\n+    impl Foo {\n+        pub fn new() -> Foo { Foo { x: 0 } }\n+    }\n+}\n+\n+fn main() {\n+    let f = a::Foo::new();\n+    f.x; //~ ERROR E0616\n+}"}, {"sha": "5b2e04e25a93d6ab82b01023b9573ad37be488ab", "filename": "src/test/compile-fail/struct-field-privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs?ref=bd62230fbdcaf6508dec02a59818f732bd4c1759", "patch": "@@ -42,7 +42,7 @@ fn test(a: A, b: inner::A, c: inner::B, d: xc::A, e: xc::B, z: inner::Z) {\n     e.b; //~ ERROR: field `b` of struct `xc::B` is private\n \n     z.0;\n-    z.1; //~ ERROR: field `1` of struct `inner::Z` is private\n+    z.1; //~ ERROR: field `1` of tuple-struct `inner::Z` is private\n }\n \n fn main() {}"}, {"sha": "26decccdcd8af454e9ed7b82da851c75c8a44441", "filename": "src/test/compile-fail/tuple-index-not-tuple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Ftest%2Fcompile-fail%2Ftuple-index-not-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Ftest%2Fcompile-fail%2Ftuple-index-not-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftuple-index-not-tuple.rs?ref=bd62230fbdcaf6508dec02a59818f732bd4c1759", "patch": "@@ -14,7 +14,7 @@ struct Empty;\n fn main() {\n     let origin = Point { x: 0, y: 0 };\n     origin.0;\n-    //~^ ERROR attempted tuple index `0` on type `Point`, but the type was not\n+    //~^ ERROR attempted to access tuple index `0` on type `Point`, but the type was not\n     Empty.0;\n-    //~^ ERROR attempted tuple index `0` on type `Empty`, but the type was not\n+    //~^ ERROR attempted to access tuple index `0` on type `Empty`, but the type was not\n }"}, {"sha": "5ed4ab4552a66e010beee95eca3198a17721d6e3", "filename": "src/test/ui/macros/macro-backtrace-invalid-internals.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd62230fbdcaf6508dec02a59818f732bd4c1759/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr?ref=bd62230fbdcaf6508dec02a59818f732bd4c1759", "patch": "@@ -16,7 +16,7 @@ error[E0610]: `{integer}` is a primitive type and therefore doesn't have fields\n 51 |     fake_field_stmt!();\n    |     ------------------- in this macro invocation\n \n-error: attempted tuple index `0` on type `{integer}`, but the type was not a tuple or tuple struct\n+error[E0613]: attempted to access tuple index `0` on type `{integer}`, but the type was not a tuple or tuple struct\n   --> $DIR/macro-backtrace-invalid-internals.rs:27:11\n    |\n 27 |           (1).0\n@@ -43,7 +43,7 @@ error[E0610]: `{integer}` is a primitive type and therefore doesn't have fields\n 55 |     let _ = fake_field_expr!();\n    |             ------------------ in this macro invocation\n \n-error: attempted tuple index `0` on type `{integer}`, but the type was not a tuple or tuple struct\n+error[E0613]: attempted to access tuple index `0` on type `{integer}`, but the type was not a tuple or tuple struct\n   --> $DIR/macro-backtrace-invalid-internals.rs:45:11\n    |\n 45 |           (1).0"}]}