{"sha": "fc9f9882f351b0823b2e3f140cf28c76bc8787b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjOWY5ODgyZjM1MWIwODIzYjJlM2YxNDBjZjI4Yzc2YmM4Nzg3Yjc=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas@schievink.net", "date": "2015-11-25T19:58:57Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas@schievink.net", "date": "2015-11-25T19:58:57Z"}, "message": "Fix \"Cannot fill in a NT\" ICE", "tree": {"sha": "e5cc1d9145532debe19fc6b34bae1dc96529047e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5cc1d9145532debe19fc6b34bae1dc96529047e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc9f9882f351b0823b2e3f140cf28c76bc8787b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc9f9882f351b0823b2e3f140cf28c76bc8787b7", "html_url": "https://github.com/rust-lang/rust/commit/fc9f9882f351b0823b2e3f140cf28c76bc8787b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc9f9882f351b0823b2e3f140cf28c76bc8787b7/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b9a13e6ba83a5619b628c1534b1c6d566157f62", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b9a13e6ba83a5619b628c1534b1c6d566157f62", "html_url": "https://github.com/rust-lang/rust/commit/1b9a13e6ba83a5619b628c1534b1c6d566157f62"}], "stats": {"total": 35, "additions": 23, "deletions": 12}, "files": [{"sha": "5b8307eb6c6f2a1f4e4a93dbdea595b8971ec3c6", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fc9f9882f351b0823b2e3f140cf28c76bc8787b7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc9f9882f351b0823b2e3f140cf28c76bc8787b7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=fc9f9882f351b0823b2e3f140cf28c76bc8787b7", "patch": "@@ -200,18 +200,19 @@ pub enum NamedMatch {\n }\n \n pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n-            -> HashMap<Name, Rc<NamedMatch>> {\n+            -> ParseResult<HashMap<Name, Rc<NamedMatch>>> {\n     fn n_rec(p_s: &ParseSess, m: &TokenTree, res: &[Rc<NamedMatch>],\n-             ret_val: &mut HashMap<Name, Rc<NamedMatch>>, idx: &mut usize) {\n+             ret_val: &mut HashMap<Name, Rc<NamedMatch>>, idx: &mut usize)\n+             -> Result<(), (codemap::Span, String)> {\n         match *m {\n             TokenTree::Sequence(_, ref seq) => {\n                 for next_m in &seq.tts {\n-                    n_rec(p_s, next_m, res, ret_val, idx)\n+                    try!(n_rec(p_s, next_m, res, ret_val, idx))\n                 }\n             }\n             TokenTree::Delimited(_, ref delim) => {\n                 for next_m in &delim.tts {\n-                    n_rec(p_s, next_m, res, ret_val, idx)\n+                    try!(n_rec(p_s, next_m, res, ret_val, idx));\n                 }\n             }\n             TokenTree::Token(sp, MatchNt(bind_name, _, _, _)) => {\n@@ -221,26 +222,36 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n                         *idx += 1;\n                     }\n                     Occupied(..) => {\n-                        panic!(p_s.span_diagnostic\n-                           .span_fatal(sp,\n-                                       &format!(\"duplicated bind name: {}\",\n-                                               bind_name)))\n+                        return Err((sp, format!(\"duplicated bind name: {}\", bind_name)))\n                     }\n                 }\n             }\n-            TokenTree::Token(_, SubstNt(..)) => panic!(\"Cannot fill in a NT\"),\n+            TokenTree::Token(sp, SubstNt(..)) => {\n+                return Err((sp, \"missing fragment specifier\".to_string()))\n+            }\n             TokenTree::Token(_, _) => (),\n         }\n+\n+        Ok(())\n     }\n+\n     let mut ret_val = HashMap::new();\n     let mut idx = 0;\n-    for m in ms { n_rec(p_s, m, res, &mut ret_val, &mut idx) }\n-    ret_val\n+    for m in ms {\n+        match n_rec(p_s, m, res, &mut ret_val, &mut idx) {\n+            Ok(_) => {},\n+            Err((sp, msg)) => return Error(sp, msg),\n+        }\n+    }\n+\n+    Success(ret_val)\n }\n \n pub enum ParseResult<T> {\n     Success(T),\n+    /// Arm failed to match\n     Failure(codemap::Span, String),\n+    /// Fatal error (malformed macro?). Abort compilation.\n     Error(codemap::Span, String)\n }\n \n@@ -429,7 +440,7 @@ pub fn parse(sess: &ParseSess,\n                 for dv in &mut (&mut eof_eis[0]).matches {\n                     v.push(dv.pop().unwrap());\n                 }\n-                return Success(nameize(sess, ms, &v[..]));\n+                return nameize(sess, ms, &v[..]);\n             } else if eof_eis.len() > 1 {\n                 return Error(sp, \"ambiguity: multiple successful parses\".to_string());\n             } else {"}]}