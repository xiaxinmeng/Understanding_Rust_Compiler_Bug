{"sha": "35e160364df35104313ad0d6d884037e360bbd46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ZTE2MDM2NGRmMzUxMDQzMTNhZDBkNmQ4ODQwMzdlMzYwYmJkNDY=", "commit": {"author": {"name": "Benjamin Herr", "email": "ben@0x539.de", "date": "2016-03-28T22:06:35Z"}, "committer": {"name": "Benjamin Herr", "email": "ben@0x539.de", "date": "2016-03-31T20:06:52Z"}, "message": "librustc_typeck: use bug!(), span_bug!()", "tree": {"sha": "401e1f1cba8f321f020d441593296a9e4b5fb41f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/401e1f1cba8f321f020d441593296a9e4b5fb41f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35e160364df35104313ad0d6d884037e360bbd46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35e160364df35104313ad0d6d884037e360bbd46", "html_url": "https://github.com/rust-lang/rust/commit/35e160364df35104313ad0d6d884037e360bbd46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35e160364df35104313ad0d6d884037e360bbd46/comments", "author": {"login": "ben0x539", "id": 24142, "node_id": "MDQ6VXNlcjI0MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/24142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ben0x539", "html_url": "https://github.com/ben0x539", "followers_url": "https://api.github.com/users/ben0x539/followers", "following_url": "https://api.github.com/users/ben0x539/following{/other_user}", "gists_url": "https://api.github.com/users/ben0x539/gists{/gist_id}", "starred_url": "https://api.github.com/users/ben0x539/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ben0x539/subscriptions", "organizations_url": "https://api.github.com/users/ben0x539/orgs", "repos_url": "https://api.github.com/users/ben0x539/repos", "events_url": "https://api.github.com/users/ben0x539/events{/privacy}", "received_events_url": "https://api.github.com/users/ben0x539/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ben0x539", "id": 24142, "node_id": "MDQ6VXNlcjI0MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/24142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ben0x539", "html_url": "https://github.com/ben0x539", "followers_url": "https://api.github.com/users/ben0x539/followers", "following_url": "https://api.github.com/users/ben0x539/following{/other_user}", "gists_url": "https://api.github.com/users/ben0x539/gists{/gist_id}", "starred_url": "https://api.github.com/users/ben0x539/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ben0x539/subscriptions", "organizations_url": "https://api.github.com/users/ben0x539/orgs", "repos_url": "https://api.github.com/users/ben0x539/repos", "events_url": "https://api.github.com/users/ben0x539/events{/privacy}", "received_events_url": "https://api.github.com/users/ben0x539/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bb767965c2dc80e3af44b2dea0c959e84da6605", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bb767965c2dc80e3af44b2dea0c959e84da6605", "html_url": "https://github.com/rust-lang/rust/commit/4bb767965c2dc80e3af44b2dea0c959e84da6605"}], "stats": {"total": 280, "additions": 129, "deletions": 151}, "files": [{"sha": "d925ff9fa3cf60afe16e450bf6736f7a35b5dade", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=35e160364df35104313ad0d6d884037e360bbd46", "patch": "@@ -161,7 +161,7 @@ pub fn ast_region_to_region(tcx: &TyCtxt, lifetime: &hir::Lifetime)\n     let r = match tcx.named_region_map.get(&lifetime.id) {\n         None => {\n             // should have been recorded by the `resolve_lifetime` pass\n-            tcx.sess.span_bug(lifetime.span, \"unresolved lifetime\");\n+            span_bug!(lifetime.span, \"unresolved lifetime\");\n         }\n \n         Some(&rl::DefStaticRegion) => {\n@@ -485,7 +485,7 @@ fn create_substs_for_ast_path<'tcx>(\n                 substs.types.push(TypeSpace, default);\n             }\n         } else {\n-            tcx.sess.span_bug(span, \"extra parameter without default\");\n+            span_bug!(span, \"extra parameter without default\");\n         }\n     }\n \n@@ -839,7 +839,7 @@ fn create_substs_for_ast_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n         Err(ErrorReported) => {\n             // No convenient way to recover from a cycle here. Just bail. Sorry!\n             this.tcx().sess.abort_if_errors();\n-            this.tcx().sess.bug(\"ErrorReported returned, but no errors reports?\")\n+            bug!(\"ErrorReported returned, but no errors reports?\")\n         }\n     };\n \n@@ -1353,7 +1353,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                       .expect(\"missing associated type\");\n                 tcx.map.local_def_id(item.id)\n             }\n-            _ => unreachable!()\n+            _ => bug!()\n         }\n     } else {\n         let trait_items = tcx.trait_items(trait_did);\n@@ -1496,7 +1496,7 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                     ty\n                 }\n             } else {\n-                tcx.sess.span_bug(span, \"self type has not been fully resolved\")\n+                span_bug!(span, \"self type has not been fully resolved\")\n             }\n         }\n         Def::SelfTy(Some(_), None) => {\n@@ -1654,7 +1654,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                     depth: path.segments.len()\n                 }\n             } else {\n-                tcx.sess.span_bug(ast_ty.span, &format!(\"unbound path {:?}\", ast_ty))\n+                span_bug!(ast_ty.span, \"unbound path {:?}\", ast_ty)\n             };\n             let def = path_res.base_def;\n             let base_ty_end = path.segments.len() - path_res.depth;\n@@ -1961,7 +1961,7 @@ pub fn ty_of_closure<'tcx>(\n             ty::FnConverging(this.ty_infer(None, None, None, decl.output.span())),\n         hir::Return(ref output) =>\n             ty::FnConverging(ast_ty_to_ty(this, &rb, &output)),\n-        hir::DefaultReturn(..) => unreachable!(),\n+        hir::DefaultReturn(..) => bug!(),\n         hir::NoReturn(..) => ty::FnDiverging\n     };\n "}, {"sha": "6dad3ff850ba74409ad395958ae50570d4cc7ad2", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=35e160364df35104313ad0d6d884037e360bbd46", "patch": "@@ -413,8 +413,7 @@ fn check_assoc_item_is_const(pcx: &pat_ctxt, def: Def, span: Span) -> bool {\n             false\n         }\n         _ => {\n-            pcx.fcx.ccx.tcx.sess.span_bug(span, \"non-associated item in\n-                                                 check_assoc_item_is_const\");\n+            span_bug!(span, \"non-associated item in check_assoc_item_is_const\");\n         }\n     }\n }\n@@ -588,7 +587,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx hir::Pat,\n     let pat_ty = pcx.fcx.instantiate_type(def.def_id(), path);\n     let item_substs = match pat_ty.sty {\n         ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n-        _ => tcx.sess.span_bug(pat.span, \"struct variant is not an ADT\")\n+        _ => span_bug!(pat.span, \"struct variant is not an ADT\")\n     };\n     demand::eqtype(fcx, pat.span, expected, pat_ty);\n     check_struct_pat_fields(pcx, pat.span, fields, variant, &item_substs, etc);"}, {"sha": "bedf4753313fdf3504907e5de31674357037f90b", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=35e160364df35104313ad0d6d884037e360bbd46", "patch": "@@ -397,7 +397,7 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n                 write_overloaded_call_method_map(fcx, self.call_expr, method_callee);\n             }\n             None => {\n-                fcx.tcx().sess.span_bug(\n+                span_bug!(\n                     self.call_expr.span,\n                     \"failed to find an overloaded call trait for closure call\");\n             }"}, {"sha": "d743a036040d50568039561a2080111186dc2b46", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=35e160364df35104313ad0d6d884037e360bbd46", "patch": "@@ -139,7 +139,7 @@ impl<'tcx> CastCheck<'tcx> {\n                             CastError::NeedViaThinPtr => \"a thin pointer\",\n                             CastError::NeedViaInt => \"an integer\",\n                             CastError::NeedViaUsize => \"a usize\",\n-                            _ => unreachable!()\n+                            _ => bug!()\n                         }))\n                     .emit();\n             }"}, {"sha": "70467e2d2dd9f6e5f35ce676a94198c72314c03f", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=35e160364df35104313ad0d6d884037e360bbd46", "patch": "@@ -372,8 +372,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         }\n         let r_borrow = match ty.sty {\n             ty::TyRef(r_borrow, _) => r_borrow,\n-            _ => self.tcx().sess.span_bug(span,\n-                                          &format!(\"expected a ref type, got {:?}\", ty))\n+            _ => span_bug!(span, \"expected a ref type, got {:?}\", ty)\n         };\n         let autoref = Some(AutoPtr(r_borrow, mt_b.mutbl));\n         debug!(\"coerce_borrowed_pointer: succeeded ty={:?} autoderefs={:?} autoref={:?}\","}, {"sha": "1f1bba509e01ecdd4835736a91b248f1445b3f14", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=35e160364df35104313ad0d6d884037e360bbd46", "patch": "@@ -62,9 +62,9 @@ pub fn check_drop_impl(tcx: &TyCtxt, drop_impl_did: DefId) -> Result<(), ()> {\n             // Destructors only work on nominal types.  This was\n             // already checked by coherence, so we can panic here.\n             let span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n-            tcx.sess.span_bug(\n-                span, &format!(\"should have been rejected by coherence check: {}\",\n-                               dtor_self_type));\n+            span_bug!(span,\n+                      \"should have been rejected by coherence check: {}\",\n+                      dtor_self_type);\n         }\n     }\n }\n@@ -276,8 +276,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n            typ, scope);\n \n     let parent_scope = rcx.tcx().region_maps.opt_encl_scope(scope).unwrap_or_else(|| {\n-        rcx.tcx().sess.span_bug(\n-            span, &format!(\"no enclosing scope found for scope: {:?}\", scope))\n+        span_bug!(span, \"no enclosing scope found for scope: {:?}\", scope)\n     });\n \n     let result = iterate_over_potentially_unsafe_regions_in_type(\n@@ -493,7 +492,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n         }\n \n         // these are always dtorck\n-        ty::TyTrait(..) | ty::TyProjection(_) => unreachable!(),\n+        ty::TyTrait(..) | ty::TyProjection(_) => bug!(),\n     }\n }\n "}, {"sha": "f90a56965397218628cd1b5d87412f152fc73448", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=35e160364df35104313ad0d6d884037e360bbd46", "patch": "@@ -300,10 +300,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         match result {\n             Some(r) => r,\n             None => {\n-                self.tcx().sess.span_bug(\n+                span_bug!(\n                     self.span,\n-                    &format!(\"self-type `{}` for ObjectPick never dereferenced to an object\",\n-                            self_ty))\n+                    \"self-type `{}` for ObjectPick never dereferenced to an object\",\n+                    self_ty)\n             }\n         }\n     }\n@@ -372,10 +372,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         match self.fcx.mk_subty(false, TypeOrigin::Misc(self.span), self_ty, method_self_ty) {\n             Ok(_) => {}\n             Err(_) => {\n-                self.tcx().sess.span_bug(\n+                span_bug!(\n                     self.span,\n-                    &format!(\"{} was a subtype of {} but now is not?\",\n-                             self_ty, method_self_ty));\n+                    \"{} was a subtype of {} but now is not?\",\n+                    self_ty, method_self_ty);\n             }\n         }\n     }\n@@ -550,15 +550,15 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                 }))\n                             }\n                             Some(_) => {\n-                                self.tcx().sess.span_bug(\n+                                span_bug!(\n                                     base_expr.span,\n-                                    &format!(\"unexpected adjustment autoref {:?}\",\n-                                            adr));\n+                                    \"unexpected adjustment autoref {:?}\",\n+                                    adr);\n                             }\n                         },\n                         None => (0, None),\n                         Some(_) => {\n-                            self.tcx().sess.span_bug(\n+                            span_bug!(\n                                 base_expr.span,\n                                 \"unexpected adjustment type\");\n                         }\n@@ -646,12 +646,12 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         // must be exactly one trait ref or we'd get an ambig error etc\n         if upcast_trait_refs.len() != 1 {\n-            self.tcx().sess.span_bug(\n+            span_bug!(\n                 self.span,\n-                &format!(\"cannot uniquely upcast `{:?}` to `{:?}`: `{:?}`\",\n-                         source_trait_ref,\n-                         target_trait_def_id,\n-                         upcast_trait_refs));\n+                \"cannot uniquely upcast `{:?}` to `{:?}`: `{:?}`\",\n+                source_trait_ref,\n+                target_trait_def_id,\n+                upcast_trait_refs);\n         }\n \n         upcast_trait_refs.into_iter().next().unwrap()"}, {"sha": "43a18d2c1024f417657cde88ad7c4d312b777303", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=35e160364df35104313ad0d6d884037e360bbd46", "patch": "@@ -302,21 +302,19 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         }\n \n                         _ => {\n-                            fcx.tcx().sess.span_bug(\n+                            span_bug!(\n                                 span,\n-                                &format!(\n-                                    \"trait method is &self but first arg is: {}\",\n-                                    transformed_self_ty));\n+                                \"trait method is &self but first arg is: {}\",\n+                                transformed_self_ty);\n                         }\n                     }\n                 }\n \n                 _ => {\n-                    fcx.tcx().sess.span_bug(\n+                    span_bug!(\n                         span,\n-                        &format!(\n-                            \"unexpected explicit self type in operator method: {:?}\",\n-                            method_ty.explicit_self));\n+                        \"unexpected explicit self type in operator method: {:?}\",\n+                        method_ty.explicit_self);\n                 }\n             }\n         }"}, {"sha": "c4a8022071bf8877ecfdae715fe012795d14d81a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=35e160364df35104313ad0d6d884037e360bbd46", "patch": "@@ -877,8 +877,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                         match tcx.trait_id_of_impl(impl_id) {\n                             Some(id) => id,\n                             None =>\n-                                tcx.sess.span_bug(span,\n-                                                  \"found inherent method when looking at traits\")\n+                                span_bug!(span,\n+                                          \"found inherent method when looking at traits\")\n                         }\n                     }\n                 }\n@@ -889,7 +889,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             }\n             Some(Err(MethodError::ClosureAmbiguity(..))) => {\n                 // this error only occurs when assembling candidates\n-                tcx.sess.span_bug(span, \"encountered ClosureAmbiguity from pick_core\");\n+                span_bug!(span, \"encountered ClosureAmbiguity from pick_core\");\n             }\n             _ => vec![],\n         };"}, {"sha": "6c3469c9d7245edc46eadafc26662b234fc78453", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=35e160364df35104313ad0d6d884037e360bbd46", "patch": "@@ -463,8 +463,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             regionck::regionck_fn(&fcx, fn_id, fn_span, decl, body);\n             writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n         }\n-        _ => ccx.tcx.sess.impossible_case(body.span,\n-                                 \"check_bare_fn: function type expected\")\n+        _ => span_bug!(body.span, \"check_bare_fn: function type expected\")\n     }\n }\n \n@@ -946,7 +945,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 hir::ImplItemKind::Const(..) => {\n                     let impl_const = match ty_impl_item {\n                         ty::ConstTraitItem(ref cti) => cti,\n-                        _ => tcx.sess.span_bug(impl_item.span, \"non-const impl-item for const\")\n+                        _ => span_bug!(impl_item.span, \"non-const impl-item for const\")\n                     };\n \n                     // Find associated const definition.\n@@ -969,7 +968,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n                     let impl_method = match ty_impl_item {\n                         ty::MethodTraitItem(ref mti) => mti,\n-                        _ => tcx.sess.span_bug(impl_item.span, \"non-method impl-item for method\")\n+                        _ => span_bug!(impl_item.span, \"non-method impl-item for method\")\n                     };\n \n                     if let &ty::MethodTraitItem(ref trait_method) = ty_trait_item {\n@@ -990,7 +989,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 hir::ImplItemKind::Type(_) => {\n                     let impl_type = match ty_impl_item {\n                         ty::TypeTraitItem(ref tti) => tti,\n-                        _ => tcx.sess.span_bug(impl_item.span, \"non-type impl-item for type\")\n+                        _ => span_bug!(impl_item.span, \"non-type impl-item for type\")\n                     };\n \n                     if let &ty::TypeTraitItem(ref at) = ty_trait_item {\n@@ -1567,8 +1566,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match self.inh.tables.borrow().node_types.get(&ex.id) {\n             Some(&t) => t,\n             None => {\n-                self.tcx().sess.bug(&format!(\"no type for expr in fcx {}\",\n-                                            self.tag()));\n+                bug!(\"no type for expr in fcx {}\", self.tag());\n             }\n         }\n     }\n@@ -1593,10 +1591,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Some(&t) => t,\n             None if self.err_count_since_creation() != 0 => self.tcx().types.err,\n             None => {\n-                self.tcx().sess.bug(\n-                    &format!(\"no type for node {}: {} in fcx {}\",\n-                            id, self.tcx().map.node_to_string(id),\n-                            self.tag()));\n+                bug!(\"no type for node {}: {} in fcx {}\",\n+                     id, self.tcx().map.node_to_string(id),\n+                     self.tag());\n             }\n         }\n     }\n@@ -2386,8 +2383,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 fty.sig.0.output\n             }\n             _ => {\n-                fcx.tcx().sess.span_bug(callee_expr.span,\n-                                        \"method without bare fn type\");\n+                span_bug!(callee_expr.span, \"method without bare fn type\");\n             }\n         }\n     }\n@@ -3139,7 +3135,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         let tcx = fcx.ccx.tcx;\n         let substs = match adt_ty.sty {\n             ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n-            _ => tcx.sess.span_bug(span, \"non-ADT passed to check_expr_struct_fields\")\n+            _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n         };\n \n         let mut remaining_fields = FnvHashMap();\n@@ -3400,8 +3396,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     depth: path.segments.len()\n                 }\n             } else {\n-              tcx.sess.span_bug(expr.span,\n-                                &format!(\"unbound path {:?}\", expr))\n+              span_bug!(expr.span, \"unbound path {:?}\", expr)\n           };\n \n           if let Some((opt_ty, segments, def)) =\n@@ -4224,7 +4219,7 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Def::Label(..) |\n         Def::SelfTy(..) |\n         Def::Err => {\n-            fcx.ccx.tcx.sess.span_bug(sp, &format!(\"expected value, found {:?}\", defn));\n+            span_bug!(sp, \"expected value, found {:?}\", defn);\n         }\n     }\n }\n@@ -4485,11 +4480,10 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         let impl_ty = fcx.instantiate_type_scheme(span, &substs, &impl_scheme.ty);\n         if fcx.mk_subty(false, TypeOrigin::Misc(span), self_ty, impl_ty).is_err() {\n-            fcx.tcx().sess.span_bug(span,\n-            &format!(\n+            span_bug!(span,\n                 \"instantiate_path: (UFCS) {:?} was a subtype of {:?} but now is not?\",\n                 self_ty,\n-                impl_ty));\n+                impl_ty);\n         }\n     }\n "}, {"sha": "494135ee3ffb14e5d531b3a30aafd3bea9b1b2b6", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=35e160364df35104313ad0d6d884037e360bbd46", "patch": "@@ -270,8 +270,9 @@ fn name_and_trait_def_id(fcx: &FnCtxt,\n             hir::BiShr => (\"shr_assign\", lang.shr_assign_trait()),\n             hir::BiLt | hir::BiLe | hir::BiGe | hir::BiGt | hir::BiEq | hir::BiNe | hir::BiAnd |\n             hir::BiOr => {\n-                fcx.tcx().sess.span_bug(op.span, &format!(\"impossible assignment operation: {}=\",\n-                                        hir_util::binop_to_string(op.node)))\n+                span_bug!(op.span,\n+                          \"impossible assignment operation: {}=\",\n+                          hir_util::binop_to_string(op.node))\n             }\n         }\n     } else {\n@@ -293,7 +294,7 @@ fn name_and_trait_def_id(fcx: &FnCtxt,\n             hir::BiEq => (\"eq\", lang.eq_trait()),\n             hir::BiNe => (\"ne\", lang.eq_trait()),\n             hir::BiAnd | hir::BiOr => {\n-                fcx.tcx().sess.span_bug(op.span, \"&& and || are not overloadable\")\n+                span_bug!(op.span, \"&& and || are not overloadable\")\n             }\n         }\n     }"}, {"sha": "283245bd6f46a0b903d8702481ebdcbfcb9049e0", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=35e160364df35104313ad0d6d884037e360bbd46", "patch": "@@ -298,8 +298,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             match fn_sig_map.get(&id) {\n                 Some(f) => f.clone(),\n                 None => {\n-                    self.tcx().sess.bug(\n-                        &format!(\"No fn-sig entry for id={}\", id));\n+                    bug!(\"No fn-sig entry for id={}\", id);\n                 }\n             }\n         };\n@@ -446,8 +445,8 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         let subject_node_id = match self.subject {\n             Subject(s) => s,\n             SubjectNode::None => {\n-                self.tcx().sess.bug(\"cannot resolve_regions_and_report_errors \\\n-                                     without subject node\");\n+                bug!(\"cannot resolve_regions_and_report_errors \\\n+                      without subject node\");\n             }\n         };\n \n@@ -886,9 +885,10 @@ fn constrain_callee(rcx: &mut Rcx,\n             // this should not happen, but it does if the program is\n             // erroneous\n             //\n-            // tcx.sess.span_bug(\n+            // bug!(\n             //     callee_expr.span,\n-            //     format!(\"Calling non-function: {}\", callee_ty));\n+            //     \"Calling non-function: {}\",\n+            //     callee_ty);\n         }\n     }\n }\n@@ -986,10 +986,10 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 let (m, r) = match self_ty.sty {\n                     ty::TyRef(r, ref m) => (m.mutbl, r),\n                     _ => {\n-                        rcx.tcx().sess.span_bug(\n+                        span_bug!(\n                             deref_expr.span,\n-                            &format!(\"bad overloaded deref type {:?}\",\n-                                     method.ty))\n+                            \"bad overloaded deref type {:?}\",\n+                            method.ty)\n                     }\n                 };\n \n@@ -1014,7 +1014,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                           return_type, r_deref_expr);\n                         return_type\n                     }\n-                    ty::FnDiverging => unreachable!()\n+                    ty::FnDiverging => bug!()\n                 }\n             }\n             None => derefd_ty\n@@ -1057,12 +1057,10 @@ fn check_safety_of_rvalue_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 't\n                 }\n                 ty::ReStatic => {}\n                 region => {\n-                    rcx.tcx()\n-                       .sess\n-                       .span_bug(span,\n-                                 &format!(\"unexpected rvalue region in rvalue \\\n-                                           destructor safety checking: `{:?}`\",\n-                                          region));\n+                    span_bug!(span,\n+                              \"unexpected rvalue region in rvalue \\\n+                               destructor safety checking: `{:?}`\",\n+                              region);\n                 }\n             }\n         }\n@@ -1394,10 +1392,7 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                     infer::ReborrowUpvar(span, *upvar_id)\n                 }\n                 _ => {\n-                    rcx.tcx().sess.span_bug(\n-                        span,\n-                        &format!(\"Illegal upvar id: {:?}\",\n-                                upvar_id));\n+                    span_bug!( span, \"Illegal upvar id: {:?}\", upvar_id);\n                 }\n             }\n         }"}, {"sha": "7d51d5ec7f74470ded2e157a863b5e24adfc5d9d", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=35e160364df35104313ad0d6d884037e360bbd46", "patch": "@@ -209,10 +209,10 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         let closure_substs = match self.fcx.node_ty(id).sty {\n             ty::TyClosure(_, ref substs) => substs,\n             ref t => {\n-                self.fcx.tcx().sess.span_bug(\n+                span_bug!(\n                     span,\n-                    &format!(\"type of closure expr {:?} is not a closure {:?}\",\n-                             id, t));\n+                    \"type of closure expr {:?} is not a closure {:?}\",\n+                    id, t);\n             }\n         };\n "}, {"sha": "68c9816b48c3ea4032a0d692fa53bb8c3367effd", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=35e160364df35104313ad0d6d884037e360bbd46", "patch": "@@ -257,7 +257,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let bare_fn_ty = match item_ty.sty {\n                 ty::TyFnDef(_, _, ref bare_fn_ty) => bare_fn_ty,\n                 _ => {\n-                    this.tcx().sess.span_bug(item.span, \"Fn item without fn type\");\n+                    span_bug!(item.span, \"Fn item without fn type\");\n                 }\n             };\n \n@@ -473,7 +473,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let name = match space {\n             TypeSpace => ast_generics.ty_params[index].name,\n             SelfSpace => special_idents::type_self.name,\n-            FnSpace => self.tcx().sess.bug(\"Fn space occupied?\"),\n+            FnSpace => bug!(\"Fn space occupied?\"),\n         };\n \n         ty::ParamTy { space: space, idx: index as u32, name: name }\n@@ -489,7 +489,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         match space {\n             TypeSpace => ast_generics.ty_params[index].span,\n             SelfSpace => item.span,\n-            FnSpace => self.tcx().sess.span_bug(item.span, \"Fn space occupied?\"),\n+            FnSpace => span_bug!(item.span, \"Fn space occupied?\"),\n         }\n     }\n "}, {"sha": "f9a4cfadc0b11073f880ba70a43d56c0ffcd462d", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=35e160364df35104313ad0d6d884037e360bbd46", "patch": "@@ -77,10 +77,10 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n         TyInfer(..) | TyClosure(..) => {\n             // `ty` comes from a user declaration so we should only expect types\n             // that the user can type\n-            inference_context.tcx.sess.span_bug(\n+            span_bug!(\n                 span,\n-                &format!(\"coherence encountered unexpected type searching for base type: {}\",\n-                         ty));\n+                \"coherence encountered unexpected type searching for base type: {}\",\n+                ty);\n         }\n     }\n }\n@@ -219,9 +219,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 }).collect()\n             }\n             _ => {\n-                self.crate_context.tcx.sess.span_bug(item.span,\n-                                                     \"can't convert a non-impl \\\n-                                                      to an impl\");\n+                span_bug!(item.span, \"can't convert a non-impl to an impl\");\n             }\n         }\n     }\n@@ -263,13 +261,12 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                           \"the Drop trait may only be implemented on structures\");\n                             }\n                             _ => {\n-                                tcx.sess.bug(\"didn't find impl in ast \\\n-                                              map\");\n+                                bug!(\"didn't find impl in ast map\");\n                             }\n                         }\n                     } else {\n-                        tcx.sess.bug(\"found external impl of Drop trait on \\\n-                                      something other than a struct\");\n+                        bug!(\"found external impl of Drop trait on \\\n+                              :omething other than a struct\");\n                     }\n                 }\n             }"}, {"sha": "59546f619c0ac3b1738164d0ae1c42aac9080136", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=35e160364df35104313ad0d6d884037e360bbd46", "patch": "@@ -274,7 +274,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         if let Some(trait_id) = tcx.map.as_local_node_id(trait_id) {\n             let item = match tcx.map.get(trait_id) {\n                 hir_map::NodeItem(item) => item,\n-                _ => tcx.sess.bug(&format!(\"get_trait_def({:?}): not an item\", trait_id))\n+                _ => bug!(\"get_trait_def({:?}): not an item\", trait_id)\n             };\n \n             trait_def_of_item(self, &item)\n@@ -1165,13 +1165,13 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n     let superpredicates = superpredicates.unwrap_or_else(|| {\n         let item = match ccx.tcx.map.get(trait_node_id) {\n             hir_map::NodeItem(item) => item,\n-            _ => ccx.tcx.sess.bug(&format!(\"trait_node_id {} is not an item\", trait_node_id))\n+            _ => bug!(\"trait_node_id {} is not an item\", trait_node_id)\n         };\n \n         let (generics, bounds) = match item.node {\n             hir::ItemTrait(_, ref generics, ref supertraits, _) => (generics, supertraits),\n-            _ => tcx.sess.span_bug(item.span,\n-                                   \"ensure_super_predicates_step invoked on non-trait\"),\n+            _ => span_bug!(item.span,\n+                           \"ensure_super_predicates_step invoked on non-trait\"),\n         };\n \n         // In-scope when converting the superbounds for `Trait` are\n@@ -1237,7 +1237,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let (unsafety, generics, items) = match it.node {\n         hir::ItemTrait(unsafety, ref generics, _, ref items) => (unsafety, generics, items),\n-        _ => tcx.sess.span_bug(it.span, \"trait_def_of_item invoked on non-trait\"),\n+        _ => span_bug!(it.span, \"trait_def_of_item invoked on non-trait\"),\n     };\n \n     let paren_sugar = tcx.has_attr(def_id, \"rustc_paren_sugar\");\n@@ -1317,12 +1317,12 @@ fn trait_defines_associated_type_named(ccx: &CrateCtxt,\n {\n     let item = match ccx.tcx.map.get(trait_node_id) {\n         hir_map::NodeItem(item) => item,\n-        _ => ccx.tcx.sess.bug(&format!(\"trait_node_id {} is not an item\", trait_node_id))\n+        _ => bug!(\"trait_node_id {} is not an item\", trait_node_id)\n     };\n \n     let trait_items = match item.node {\n         hir::ItemTrait(_, _, _, ref trait_items) => trait_items,\n-        _ => ccx.tcx.sess.bug(&format!(\"trait_node_id {} is not a trait\", trait_node_id))\n+        _ => bug!(\"trait_node_id {} is not a trait\", trait_node_id)\n     };\n \n     trait_items.iter().any(|trait_item| {\n@@ -1342,9 +1342,10 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n     let (generics, items) = match it.node {\n         hir::ItemTrait(_, ref generics, _, ref items) => (generics, items),\n         ref s => {\n-            tcx.sess.span_bug(\n+            span_bug!(\n                 it.span,\n-                &format!(\"trait_def_of_item invoked on {:?}\", s));\n+                \"trait_def_of_item invoked on {:?}\",\n+                s);\n         }\n     };\n \n@@ -1421,9 +1422,8 @@ fn type_scheme_of_def_id<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 type_scheme_of_foreign_item(ccx, &foreign_item, abi)\n             }\n             x => {\n-                ccx.tcx.sess.bug(&format!(\"unexpected sort of node \\\n-                                           in get_item_type_scheme(): {:?}\",\n-                                          x));\n+                bug!(\"unexpected sort of node in get_item_type_scheme(): {:?}\",\n+                     x);\n             }\n         }\n     } else {\n@@ -1489,10 +1489,10 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         hir::ItemForeignMod(..) |\n         hir::ItemExternCrate(..) |\n         hir::ItemUse(..) => {\n-            tcx.sess.span_bug(\n+            span_bug!(\n                 it.span,\n-                &format!(\"compute_type_scheme_of_item: unexpected item type: {:?}\",\n-                         it.node));\n+                \"compute_type_scheme_of_item: unexpected item type: {:?}\",\n+                it.node);\n         }\n     }\n }\n@@ -1528,10 +1528,10 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         hir::ItemImpl(..) |\n         hir::ItemMod(..) |\n         hir::ItemForeignMod(..) => {\n-            tcx.sess.span_bug(\n+            span_bug!(\n                 it.span,\n-                &format!(\"compute_type_scheme_of_item: unexpected item type: {:?}\",\n-                         it.node));\n+                \"compute_type_scheme_of_item: unexpected item type: {:?}\",\n+                it.node);\n         }\n     };\n \n@@ -1836,9 +1836,9 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n \n             &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n                 // FIXME(#20041)\n-                tcx.sess.span_bug(eq_pred.span,\n-                                    \"Equality constraints are not yet \\\n-                                        implemented (#20041)\")\n+                span_bug!(eq_pred.span,\n+                         \"Equality constraints are not yet \\\n+                          implemented (#20041)\")\n             }\n         }\n     }"}, {"sha": "fa23445fe630d3824bd5a6839b9e37771e3b9126", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=35e160364df35104313ad0d6d884037e360bbd46", "patch": "@@ -88,7 +88,7 @@ This API is completely unstable and subject to change.\n \n extern crate arena;\n extern crate fmt_macros;\n-extern crate rustc;\n+#[macro_use] extern crate rustc;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_front;\n extern crate rustc_back;\n@@ -258,9 +258,9 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 });\n         }\n         _ => {\n-            tcx.sess.span_bug(main_span,\n-                              &format!(\"main has a non-function type: found `{}`\",\n-                                       main_t));\n+            span_bug!(main_span,\n+                      \"main has a non-function type: found `{}`\",\n+                      main_t);\n         }\n     }\n }\n@@ -310,9 +310,9 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n \n         }\n         _ => {\n-            tcx.sess.span_bug(start_span,\n-                              &format!(\"start has a non-function type: found `{}`\",\n-                                       start_t));\n+            span_bug!(start_span,\n+                      \"start has a non-function type: found `{}`\",\n+                      start_t);\n         }\n     }\n }\n@@ -325,7 +325,7 @@ fn check_for_entry_fn(ccx: &CrateCtxt) {\n             Some(config::EntryMain) => check_main_fn_ty(ccx, id, sp),\n             Some(config::EntryStart) => check_start_fn_ty(ccx, id, sp),\n             Some(config::EntryNone) => {}\n-            None => tcx.sess.bug(\"entry function without a type\")\n+            None => bug!(\"entry function without a type\")\n         },\n         None => {}\n     }"}, {"sha": "50c99e33b4455125db073d92129f5974045a333a", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e160364df35104313ad0d6d884037e360bbd46/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=35e160364df35104313ad0d6d884037e360bbd46", "patch": "@@ -135,9 +135,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         match self.terms_cx.inferred_map.get(&param_id) {\n             Some(&index) => index,\n             None => {\n-                self.tcx().sess.bug(&format!(\n-                        \"no inferred index entry for {}\",\n-                        self.tcx().map.node_to_string(param_id)));\n+                bug!(\"no inferred index entry for {}\",\n+                     self.tcx().map.node_to_string(param_id));\n             }\n         }\n     }\n@@ -148,7 +147,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         match tcx.named_region_map.get(&param_id) {\n             Some(&rl::DefEarlyBoundRegion(_, _, lifetime_decl_id))\n                 => lifetime_decl_id,\n-            Some(_) => panic!(\"should not encounter non early-bound cases\"),\n+            Some(_) => bug!(\"should not encounter non early-bound cases\"),\n \n             // The lookup should only fail when `param_id` is\n             // itself a lifetime binding: use it as the decl_id.\n@@ -173,13 +172,13 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             assert!(is_lifetime(&tcx.map, param_id));\n             let parent_id = tcx.map.get_parent(decl_id);\n             let parent = tcx.map.find(parent_id).unwrap_or_else(\n-                || panic!(\"tcx.map missing entry for id: {}\", parent_id));\n+                || bug!(\"tcx.map missing entry for id: {}\", parent_id));\n \n             let is_inferred;\n             macro_rules! cannot_happen { () => { {\n-                panic!(\"invalid parent: {} for {}\",\n-                      tcx.map.node_to_string(parent_id),\n-                      tcx.map.node_to_string(param_id));\n+                bug!(\"invalid parent: {} for {}\",\n+                     tcx.map.node_to_string(parent_id),\n+                     tcx.map.node_to_string(param_id));\n             } } }\n \n             match parent {\n@@ -328,7 +327,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyClosure(..) => {\n-                self.tcx().sess.bug(\"Unexpected closure type in variance computation\");\n+                bug!(\"Unexpected closure type in variance computation\");\n             }\n \n             ty::TyRef(region, ref mt) => {\n@@ -440,9 +439,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyInfer(..) => {\n-                self.tcx().sess.bug(\n-                    &format!(\"unexpected type encountered in \\\n-                              variance inference: {}\", ty));\n+                bug!(\"unexpected type encountered in \\\n+                      variance inference: {}\", ty);\n             }\n         }\n     }\n@@ -525,11 +523,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             ty::ReSkolemized(..) | ty::ReEmpty => {\n                 // We don't expect to see anything but 'static or bound\n                 // regions when visiting member types or method types.\n-                self.tcx()\n-                    .sess\n-                    .bug(&format!(\"unexpected region encountered in variance \\\n-                                  inference: {:?}\",\n-                                 region));\n+                bug!(\"unexpected region encountered in variance \\\n+                      inference: {:?}\",\n+                     region);\n             }\n         }\n     }"}]}