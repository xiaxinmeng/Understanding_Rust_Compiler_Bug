{"sha": "4a5341e0448d716e2ead16f89449543b63ee6f78", "node_id": "C_kwDOAAsO6NoAKDRhNTM0MWUwNDQ4ZDcxNmUyZWFkMTZmODk0NDk1NDNiNjNlZTZmNzg", "commit": {"author": {"name": "C\u00f4me ALLART", "email": "come.allart@etu.emse.fr", "date": "2022-01-04T23:23:36Z"}, "committer": {"name": "C\u00f4me ALLART", "email": "come.allart@etu.emse.fr", "date": "2022-01-04T23:23:36Z"}, "message": "fix(gen-doc-assist): remove lifetimes in description of `new`", "tree": {"sha": "8f900ebf0b81f181e73f89db94c3e77caf9dcc45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f900ebf0b81f181e73f89db94c3e77caf9dcc45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a5341e0448d716e2ead16f89449543b63ee6f78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a5341e0448d716e2ead16f89449543b63ee6f78", "html_url": "https://github.com/rust-lang/rust/commit/4a5341e0448d716e2ead16f89449543b63ee6f78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a5341e0448d716e2ead16f89449543b63ee6f78/comments", "author": null, "committer": null, "parents": [{"sha": "c5049bdcdaefd7650a58fa9f393ad7351e5c5462", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5049bdcdaefd7650a58fa9f393ad7351e5c5462", "html_url": "https://github.com/rust-lang/rust/commit/c5049bdcdaefd7650a58fa9f393ad7351e5c5462"}], "stats": {"total": 125, "additions": 124, "deletions": 1}, "files": [{"sha": "4558f06fb512ebbf7259dd385b3415f6d1956e90", "filename": "crates/ide_assists/src/handlers/generate_documentation_template.rs", "status": "modified", "additions": 124, "deletions": 1, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/4a5341e0448d716e2ead16f89449543b63ee6f78/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5341e0448d716e2ead16f89449543b63ee6f78/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs?ref=4a5341e0448d716e2ead16f89449543b63ee6f78", "patch": "@@ -88,7 +88,9 @@ fn introduction_builder(ast_func: &ast::Fn, ctx: &AssistContext) -> String {\n \n             let is_new = ast_func.name()?.to_string() == \"new\";\n             match is_new && ret_ty == self_ty {\n-                true => Some(format!(\"Creates a new [`{}`].\", self_type(ast_func)?)),\n+                true => {\n+                    Some(format!(\"Creates a new [`{}`].\", lifetimes_removed(&self_type(ast_func)?)))\n+                }\n                 false => None,\n             }\n         } else {\n@@ -230,6 +232,49 @@ fn self_type(ast_func: &ast::Fn) -> Option<String> {\n         .map(|t| (t.to_string()))\n }\n \n+/// Output the same string as the input, removing lifetimes.\n+///\n+/// Lifetimes are detected as starting with a `'` and ending with `,\\s*` or before a `>`.\n+fn lifetimes_removed(with_lifetimes: &str) -> String {\n+    #[derive(Debug)]\n+    enum State {\n+        OutOfLifetime,\n+        AfterLifetime,\n+        InLifetime,\n+    }\n+\n+    let mut state = State::OutOfLifetime;\n+    let mut without_lifetimes = String::new();\n+    for c in with_lifetimes.chars() {\n+        match state {\n+            State::OutOfLifetime => {\n+                if c == '\\'' {\n+                    state = State::InLifetime;\n+                } else {\n+                    without_lifetimes.push(c);\n+                }\n+            }\n+            State::InLifetime => {\n+                if c == ',' {\n+                    state = State::AfterLifetime;\n+                } else if c == '>' {\n+                    without_lifetimes.push(c);\n+                    state = State::OutOfLifetime;\n+                }\n+            }\n+            State::AfterLifetime => {\n+                if c == '\\'' {\n+                    state = State::InLifetime;\n+                } else if !c.is_whitespace() {\n+                    without_lifetimes.push(c);\n+                    state = State::OutOfLifetime;\n+                }\n+            }\n+        }\n+    }\n+    without_lifetimes\n+}\n+\n /// Heper function to get the name of the type of `self` without generic arguments\n fn self_partial_type(ast_func: &ast::Fn) -> Option<String> {\n     let mut self_type = self_type(ast_func)?;\n@@ -991,6 +1036,84 @@ impl<T> MyGenericStruct<T> {\n         );\n     }\n \n+    #[test]\n+    fn removes_one_lifetime_from_description() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+#[derive(Debug, PartialEq)]\n+pub struct MyGenericStruct<'a, T> {\n+    pub x: &'a T,\n+}\n+impl<'a, T> MyGenericStruct<'a, T> {\n+    pub fn new$0(x: &'a T) -> Self {\n+        MyGenericStruct { x }\n+    }\n+}\n+\"#,\n+            r#\"\n+#[derive(Debug, PartialEq)]\n+pub struct MyGenericStruct<'a, T> {\n+    pub x: &'a T,\n+}\n+impl<'a, T> MyGenericStruct<'a, T> {\n+    /// Creates a new [`MyGenericStruct<T>`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::MyGenericStruct;\n+    ///\n+    /// assert_eq!(MyGenericStruct::new(x), );\n+    /// ```\n+    pub fn new(x: &'a T) -> Self {\n+        MyGenericStruct { x }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn removes_all_lifetimes_from_description() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+#[derive(Debug, PartialEq)]\n+pub struct MyGenericStruct<'a, 'b, T> {\n+    pub x: &'a T,\n+    pub y: &'b T,\n+}\n+impl<'a, 'b, T> MyGenericStruct<'a, 'b, T> {\n+    pub fn new$0(x: &'a T, y: &'b T) -> Self {\n+        MyGenericStruct { x, y }\n+    }\n+}\n+\"#,\n+            r#\"\n+#[derive(Debug, PartialEq)]\n+pub struct MyGenericStruct<'a, 'b, T> {\n+    pub x: &'a T,\n+    pub y: &'b T,\n+}\n+impl<'a, 'b, T> MyGenericStruct<'a, 'b, T> {\n+    /// Creates a new [`MyGenericStruct<T>`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::MyGenericStruct;\n+    ///\n+    /// assert_eq!(MyGenericStruct::new(x, y), );\n+    /// ```\n+    pub fn new(x: &'a T, y: &'b T) -> Self {\n+        MyGenericStruct { x, y }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn detects_new_with_self() {\n         check_assist("}]}