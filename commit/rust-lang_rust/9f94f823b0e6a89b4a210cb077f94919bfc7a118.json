{"sha": "9f94f823b0e6a89b4a210cb077f94919bfc7a118", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmOTRmODIzYjBlNmE4OWI0YTIxMGNiMDc3Zjk0OTE5YmZjN2ExMTg=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-06T21:29:29Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-08T22:14:45Z"}, "message": "change if/else to match", "tree": {"sha": "20349b0513146e2145f2d523d62b1981335cff2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20349b0513146e2145f2d523d62b1981335cff2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f94f823b0e6a89b4a210cb077f94919bfc7a118", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f94f823b0e6a89b4a210cb077f94919bfc7a118", "html_url": "https://github.com/rust-lang/rust/commit/9f94f823b0e6a89b4a210cb077f94919bfc7a118", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f94f823b0e6a89b4a210cb077f94919bfc7a118/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3fa836939161f59224c30c96210df1eb01f002e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3fa836939161f59224c30c96210df1eb01f002e", "html_url": "https://github.com/rust-lang/rust/commit/f3fa836939161f59224c30c96210df1eb01f002e"}], "stats": {"total": 376, "additions": 197, "deletions": 179}, "files": [{"sha": "2f6555dcb69d51caa0474a26dea3ccbce83deca4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 197, "deletions": 179, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/9f94f823b0e6a89b4a210cb077f94919bfc7a118/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f94f823b0e6a89b4a210cb077f94919bfc7a118/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9f94f823b0e6a89b4a210cb077f94919bfc7a118", "patch": "@@ -1877,211 +1877,229 @@ impl<'a> Parser<'a> {\n \n         let ex: Expr_;\n \n-        if self.token == token::LPAREN {\n-            self.bump();\n-            // (e) is parenthesized e\n-            // (e,) is a tuple with only one field, e\n-            let mut trailing_comma = false;\n-            if self.token == token::RPAREN {\n-                hi = self.span.hi;\n-                self.bump();\n-                let lit = box(GC) spanned(lo, hi, LitNil);\n-                return self.mk_expr(lo, hi, ExprLit(lit));\n-            }\n-            let mut es = vec!(self.parse_expr());\n-            self.commit_expr(*es.last().unwrap(), &[], &[token::COMMA, token::RPAREN]);\n-            while self.token == token::COMMA {\n+        match self.token {\n+            token::LPAREN => {\n                 self.bump();\n-                if self.token != token::RPAREN {\n-                    es.push(self.parse_expr());\n-                    self.commit_expr(*es.last().unwrap(), &[], &[token::COMMA, token::RPAREN]);\n+                // (e) is parenthesized e\n+                // (e,) is a tuple with only one field, e\n+                let mut trailing_comma = false;\n+                if self.token == token::RPAREN {\n+                    hi = self.span.hi;\n+                    self.bump();\n+                    let lit = box(GC) spanned(lo, hi, LitNil);\n+                    return self.mk_expr(lo, hi, ExprLit(lit));\n                 }\n-                else {\n-                    trailing_comma = true;\n+                let mut es = vec!(self.parse_expr());\n+                self.commit_expr(*es.last().unwrap(), &[], &[token::COMMA, token::RPAREN]);\n+                while self.token == token::COMMA {\n+                    self.bump();\n+                    if self.token != token::RPAREN {\n+                        es.push(self.parse_expr());\n+                        self.commit_expr(*es.last().unwrap(), &[], &[token::COMMA, token::RPAREN]);\n+                    }\n+                        else {\n+                        trailing_comma = true;\n+                    }\n                 }\n-            }\n-            hi = self.span.hi;\n-            self.commit_expr_expecting(*es.last().unwrap(), token::RPAREN);\n-\n-            return if es.len() == 1 && !trailing_comma {\n-                self.mk_expr(lo, hi, ExprParen(*es.get(0)))\n-            }\n-            else {\n-                self.mk_expr(lo, hi, ExprTup(es))\n-            }\n-        } else if self.token == token::LBRACE {\n-            self.bump();\n-            let blk = self.parse_block_tail(lo, DefaultBlock);\n-            return self.mk_expr(blk.span.lo, blk.span.hi,\n-                                 ExprBlock(blk));\n-        } else if token::is_bar(&self.token) {\n-            return self.parse_lambda_expr();\n-        } else if self.eat_keyword(keywords::Proc) {\n-            let decl = self.parse_proc_decl();\n-            let body = self.parse_expr();\n-            let fakeblock = P(ast::Block {\n-                view_items: Vec::new(),\n-                stmts: Vec::new(),\n-                expr: Some(body),\n-                id: ast::DUMMY_NODE_ID,\n-                rules: DefaultBlock,\n-                span: body.span,\n-            });\n+                hi = self.span.hi;\n+                self.commit_expr_expecting(*es.last().unwrap(), token::RPAREN);\n \n-            return self.mk_expr(lo, body.span.hi, ExprProc(decl, fakeblock));\n-        } else if self.eat_keyword(keywords::Self) {\n-            let path = ast_util::ident_to_path(mk_sp(lo, hi), special_idents::self_);\n-            ex = ExprPath(path);\n-            hi = self.last_span.hi;\n-        } else if self.eat_keyword(keywords::If) {\n-            return self.parse_if_expr();\n-        } else if self.eat_keyword(keywords::For) {\n-            return self.parse_for_expr(None);\n-        } else if self.eat_keyword(keywords::While) {\n-            return self.parse_while_expr();\n-        } else if Parser::token_is_lifetime(&self.token) {\n-            let lifetime = self.get_lifetime();\n-            self.bump();\n-            self.expect(&token::COLON);\n-            if self.eat_keyword(keywords::For) {\n-                return self.parse_for_expr(Some(lifetime))\n-            } else if self.eat_keyword(keywords::Loop) {\n-                return self.parse_loop_expr(Some(lifetime))\n-            } else {\n-                self.fatal(\"expected `for` or `loop` after a label\")\n+                return if es.len() == 1 && !trailing_comma {\n+                    self.mk_expr(lo, hi, ExprParen(*es.get(0)))\n+                }\n+                    else {\n+                    self.mk_expr(lo, hi, ExprTup(es))\n+                }\n+            },\n+            token::LBRACE => {\n+                self.bump();\n+                let blk = self.parse_block_tail(lo, DefaultBlock);\n+                return self.mk_expr(blk.span.lo, blk.span.hi,\n+                                    ExprBlock(blk));\n+            },\n+            _ if token::is_bar(&self.token) => {\n+                return self.parse_lambda_expr();\n+            },\n+            _ if self.eat_keyword(keywords::Proc) => {\n+                let decl = self.parse_proc_decl();\n+                let body = self.parse_expr();\n+                let fakeblock = P(ast::Block {\n+                        view_items: Vec::new(),\n+                        stmts: Vec::new(),\n+                        expr: Some(body),\n+                        id: ast::DUMMY_NODE_ID,\n+                        rules: DefaultBlock,\n+                        span: body.span,\n+                    });\n+                return self.mk_expr(lo, body.span.hi, ExprProc(decl, fakeblock));\n+            },\n+            _ if self.eat_keyword(keywords::Self) => {\n+                let path = ast_util::ident_to_path(mk_sp(lo, hi), special_idents::self_);\n+                ex = ExprPath(path);\n+                hi = self.last_span.hi;\n             }\n-        } else if self.eat_keyword(keywords::Loop) {\n-            return self.parse_loop_expr(None);\n-        } else if self.eat_keyword(keywords::Continue) {\n-            let lo = self.span.lo;\n-            let ex = if Parser::token_is_lifetime(&self.token) {\n+            _ if self.eat_keyword(keywords::If) => {\n+                return self.parse_if_expr();\n+            },\n+            _ if self.eat_keyword(keywords::For) => {\n+                return self.parse_for_expr(None);\n+            },\n+            _ if self.eat_keyword(keywords::While) => {\n+                return self.parse_while_expr();\n+            },\n+            _ if Parser::token_is_lifetime(&self.token) => {\n                 let lifetime = self.get_lifetime();\n                 self.bump();\n-                ExprAgain(Some(lifetime))\n-            } else {\n-                ExprAgain(None)\n-            };\n-            let hi = self.span.hi;\n-            return self.mk_expr(lo, hi, ex);\n-        } else if self.eat_keyword(keywords::Match) {\n-            return self.parse_match_expr();\n-        } else if self.eat_keyword(keywords::Unsafe) {\n-            return self.parse_block_expr(lo, UnsafeBlock(ast::UserProvided));\n-        } else if self.token == token::LBRACKET {\n-            self.bump();\n-\n-            if self.token == token::RBRACKET {\n-                // Empty vector.\n-                self.bump();\n-                ex = ExprVec(Vec::new());\n-            } else {\n-                // Nonempty vector.\n-                let first_expr = self.parse_expr();\n-                if self.token == token::COMMA &&\n-                        self.look_ahead(1, |t| *t == token::DOTDOT) {\n-                    // Repeating vector syntax: [ 0, ..512 ]\n+                self.expect(&token::COLON);\n+                if self.eat_keyword(keywords::For) {\n+                    return self.parse_for_expr(Some(lifetime))\n+                } else if self.eat_keyword(keywords::Loop) {\n+                    return self.parse_loop_expr(Some(lifetime))\n+                } else {\n+                    self.fatal(\"expected `for` or `loop` after a label\")\n+                }\n+            },\n+            _ if self.eat_keyword(keywords::Loop) => {\n+                return self.parse_loop_expr(None);\n+            },\n+            _ if self.eat_keyword(keywords::Continue) => {\n+                let lo = self.span.lo;\n+                let ex = if Parser::token_is_lifetime(&self.token) {\n+                    let lifetime = self.get_lifetime();\n                     self.bump();\n+                    ExprAgain(Some(lifetime))\n+                } else {\n+                    ExprAgain(None)\n+                };\n+                let hi = self.span.hi;\n+                return self.mk_expr(lo, hi, ex);\n+            },\n+            _ if self.eat_keyword(keywords::Match) => {\n+                return self.parse_match_expr();\n+            },\n+            _ if self.eat_keyword(keywords::Unsafe) => {\n+                return self.parse_block_expr(lo, UnsafeBlock(ast::UserProvided));\n+            },\n+            token::LBRACKET => {\n+                self.bump();\n+                \n+                if self.token == token::RBRACKET {\n+                    // Empty vector.\n                     self.bump();\n-                    let count = self.parse_expr();\n-                    self.expect(&token::RBRACKET);\n-                    ex = ExprRepeat(first_expr, count);\n-                } else if self.token == token::COMMA {\n-                    // Vector with two or more elements.\n+                    ex = ExprVec(Vec::new());\n+                } else {\n+                    // Nonempty vector.\n+                    let first_expr = self.parse_expr();\n+                    if self.token == token::COMMA &&\n+                        self.look_ahead(1, |t| *t == token::DOTDOT) {\n+                        // Repeating vector syntax: [ 0, ..512 ]\n+                        self.bump();\n+                        self.bump();\n+                        let count = self.parse_expr();\n+                        self.expect(&token::RBRACKET);\n+                        ex = ExprRepeat(first_expr, count);\n+                    } else if self.token == token::COMMA {\n+                        // Vector with two or more elements.\n+                        self.bump();\n+                        let remaining_exprs = self.parse_seq_to_end(\n+                            &token::RBRACKET,\n+                            seq_sep_trailing_allowed(token::COMMA),\n+                            |p| p.parse_expr()\n+                                );\n+                        let mut exprs = vec!(first_expr);\n+                        exprs.push_all_move(remaining_exprs);\n+                        ex = ExprVec(exprs);\n+                    } else {\n+                        // Vector with one element.\n+                        self.expect(&token::RBRACKET);\n+                        ex = ExprVec(vec!(first_expr));\n+                    }\n+                }\n+                hi = self.last_span.hi;\n+            },\n+            _ if self.eat_keyword(keywords::Return) => {\n+                // RETURN expression\n+                if can_begin_expr(&self.token) {\n+                    let e = self.parse_expr();\n+                    hi = e.span.hi;\n+                    ex = ExprRet(Some(e));\n+                } else { ex = ExprRet(None); }\n+            },\n+            _ if self.eat_keyword(keywords::Break) => {\n+                // BREAK expression\n+                if Parser::token_is_lifetime(&self.token) {\n+                    let lifetime = self.get_lifetime();\n                     self.bump();\n-                    let remaining_exprs = self.parse_seq_to_end(\n-                        &token::RBRACKET,\n-                        seq_sep_trailing_allowed(token::COMMA),\n-                        |p| p.parse_expr()\n-                    );\n-                    let mut exprs = vec!(first_expr);\n-                    exprs.push_all_move(remaining_exprs);\n-                    ex = ExprVec(exprs);\n+                    ex = ExprBreak(Some(lifetime));\n                 } else {\n-                    // Vector with one element.\n-                    self.expect(&token::RBRACKET);\n-                    ex = ExprVec(vec!(first_expr));\n+                    ex = ExprBreak(None);\n                 }\n-            }\n-            hi = self.last_span.hi;\n-        } else if self.eat_keyword(keywords::Return) {\n-            // RETURN expression\n-            if can_begin_expr(&self.token) {\n-                let e = self.parse_expr();\n-                hi = e.span.hi;\n-                ex = ExprRet(Some(e));\n-            } else { ex = ExprRet(None); }\n-        } else if self.eat_keyword(keywords::Break) {\n-            // BREAK expression\n-            if Parser::token_is_lifetime(&self.token) {\n-                let lifetime = self.get_lifetime();\n-                self.bump();\n-                ex = ExprBreak(Some(lifetime));\n-            } else {\n-                ex = ExprBreak(None);\n-            }\n-            hi = self.span.hi;\n-        } else if self.token == token::MOD_SEP ||\n+                hi = self.span.hi;\n+            },\n+            _ if self.token == token::MOD_SEP ||\n                 is_ident(&self.token) && !self.is_keyword(keywords::True) &&\n-                !self.is_keyword(keywords::False) {\n-            let pth = self.parse_path(LifetimeAndTypesWithColons).path;\n+                !self.is_keyword(keywords::False) => {\n+                let pth = self.parse_path(LifetimeAndTypesWithColons).path;\n \n-            // `!`, as an operator, is prefix, so we know this isn't that\n-            if self.token == token::NOT {\n-                // MACRO INVOCATION expression\n-                self.bump();\n+                // `!`, as an operator, is prefix, so we know this isn't that\n+                if self.token == token::NOT {\n+                    // MACRO INVOCATION expression\n+                    self.bump();\n \n-                let ket = token::close_delimiter_for(&self.token)\n-                                .unwrap_or_else(|| self.fatal(\"expected open delimiter\"));\n-                self.bump();\n+                    let ket = token::close_delimiter_for(&self.token)\n+                        .unwrap_or_else(|| self.fatal(\"expected open delimiter\"));\n+                    self.bump();\n \n-                let tts = self.parse_seq_to_end(&ket,\n-                                                seq_sep_none(),\n-                                                |p| p.parse_token_tree());\n-                let hi = self.span.hi;\n+                    let tts = self.parse_seq_to_end(&ket,\n+                                                    seq_sep_none(),\n+                                                    |p| p.parse_token_tree());\n+                    let hi = self.span.hi;\n \n-                return self.mk_mac_expr(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT));\n-            } else if self.token == token::LBRACE {\n-                // This is a struct literal, unless we're prohibited from\n-                // parsing struct literals here.\n-                if self.restriction != RESTRICT_NO_STRUCT_LITERAL {\n-                    // It's a struct literal.\n-                    self.bump();\n-                    let mut fields = Vec::new();\n-                    let mut base = None;\n+                    return self.mk_mac_expr(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT));\n+                } else if self.token == token::LBRACE {\n+                    // This is a struct literal, unless we're prohibited from\n+                    // parsing struct literals here.\n+                    if self.restriction != RESTRICT_NO_STRUCT_LITERAL {\n+                        // It's a struct literal.\n+                        self.bump();\n+                        let mut fields = Vec::new();\n+                        let mut base = None;\n \n-                    while self.token != token::RBRACE {\n-                        if self.eat(&token::DOTDOT) {\n-                            base = Some(self.parse_expr());\n-                            break;\n+                        while self.token != token::RBRACE {\n+                            if self.eat(&token::DOTDOT) {\n+                                base = Some(self.parse_expr());\n+                                break;\n+                            }\n+\n+                            fields.push(self.parse_field());\n+                            self.commit_expr(fields.last().unwrap().expr,\n+                                             &[token::COMMA], &[token::RBRACE]);\n                         }\n \n-                        fields.push(self.parse_field());\n-                        self.commit_expr(fields.last().unwrap().expr,\n-                                         &[token::COMMA], &[token::RBRACE]);\n-                    }\n+                        if fields.len() == 0 && base.is_none() {\n+                            let last_span = self.last_span;\n+                            self.span_err(last_span,\n+                                          \"structure literal must either have at \\\n+                                          least one field or use functional \\\n+                                          structure update syntax\");\n+                        }\n \n-                    if fields.len() == 0 && base.is_none() {\n-                        let last_span = self.last_span;\n-                        self.span_err(last_span,\n-                                      \"structure literal must either have at \\\n-                                       least one field or use functional \\\n-                                       structure update syntax\");\n+                        hi = self.span.hi;\n+                        self.expect(&token::RBRACE);\n+                        ex = ExprStruct(pth, fields, base);\n+                        return self.mk_expr(lo, hi, ex);\n                     }\n-\n-                    hi = self.span.hi;\n-                    self.expect(&token::RBRACE);\n-                    ex = ExprStruct(pth, fields, base);\n-                    return self.mk_expr(lo, hi, ex);\n                 }\n-            }\n \n             hi = pth.span.hi;\n             ex = ExprPath(pth);\n-        } else {\n-            // other literal expression\n-            let lit = self.parse_lit();\n-            hi = lit.span.hi;\n-            ex = ExprLit(box(GC) lit);\n+            },\n+            _ => {\n+                // other literal expression\n+                let lit = self.parse_lit();\n+                hi = lit.span.hi;\n+                ex = ExprLit(box(GC) lit);\n+            }\n         }\n \n         return self.mk_expr(lo, hi, ex);"}]}