{"sha": "800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwMGYyYzEzYTNmNDIxMzY0OGYzMDFkY2Q0ZTEwZDgwYjFlNmVhMzg=", "commit": {"author": {"name": "Masaki Hara", "email": "ackie.h.gmai@gmail.com", "date": "2018-05-28T15:12:55Z"}, "committer": {"name": "Masaki Hara", "email": "ackie.h.gmai@gmail.com", "date": "2018-08-18T23:07:33Z"}, "message": "Implement simple codegen for unsized rvalues.", "tree": {"sha": "bb789909096a22e3d46f36033eda4d4edd897e2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb789909096a22e3d46f36033eda4d4edd897e2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "html_url": "https://github.com/rust-lang/rust/commit/800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/comments", "author": {"login": "qnighy", "id": 41755, "node_id": "MDQ6VXNlcjQxNzU1", "avatar_url": "https://avatars.githubusercontent.com/u/41755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qnighy", "html_url": "https://github.com/qnighy", "followers_url": "https://api.github.com/users/qnighy/followers", "following_url": "https://api.github.com/users/qnighy/following{/other_user}", "gists_url": "https://api.github.com/users/qnighy/gists{/gist_id}", "starred_url": "https://api.github.com/users/qnighy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qnighy/subscriptions", "organizations_url": "https://api.github.com/users/qnighy/orgs", "repos_url": "https://api.github.com/users/qnighy/repos", "events_url": "https://api.github.com/users/qnighy/events{/privacy}", "received_events_url": "https://api.github.com/users/qnighy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "qnighy", "id": 41755, "node_id": "MDQ6VXNlcjQxNzU1", "avatar_url": "https://avatars.githubusercontent.com/u/41755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qnighy", "html_url": "https://github.com/qnighy", "followers_url": "https://api.github.com/users/qnighy/followers", "following_url": "https://api.github.com/users/qnighy/following{/other_user}", "gists_url": "https://api.github.com/users/qnighy/gists{/gist_id}", "starred_url": "https://api.github.com/users/qnighy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qnighy/subscriptions", "organizations_url": "https://api.github.com/users/qnighy/orgs", "repos_url": "https://api.github.com/users/qnighy/repos", "events_url": "https://api.github.com/users/qnighy/events{/privacy}", "received_events_url": "https://api.github.com/users/qnighy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2b95cb70e2142aab82a40115d11ff54a975335e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2b95cb70e2142aab82a40115d11ff54a975335e", "html_url": "https://github.com/rust-lang/rust/commit/e2b95cb70e2142aab82a40115d11ff54a975335e"}], "stats": {"total": 408, "additions": 388, "deletions": 20}, "files": [{"sha": "b8a67a60e62cbb4161c25bc31a61ba042ae6dc96", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "patch": "@@ -189,6 +189,8 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n         let cx = bx.cx;\n         if self.is_indirect() {\n             OperandValue::Ref(val, self.layout.align).store(bx, dst)\n+        } else if self.is_unsized_indirect() {\n+            bug!(\"unsized ArgType must be handled through store_fn_arg\");\n         } else if let PassMode::Cast(cast) = self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n@@ -246,6 +248,9 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n             PassMode::Pair(..) => {\n                 OperandValue::Pair(next(), next()).store(bx, dst);\n             }\n+            PassMode::UnsizedIndirect(..) => {\n+                OperandValue::UnsizedRef(next(), next()).store(bx, dst);\n+            }\n             PassMode::Direct(_) | PassMode::Indirect(_) | PassMode::Cast(_) => {\n                 self.store(bx, next(), dst);\n             }\n@@ -302,6 +307,10 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             // Don't pass the vtable, it's not an argument of the virtual fn.\n             // Instead, pass just the (thin pointer) first field of `*dyn Trait`.\n             if arg_idx == Some(0) {\n+                if layout.is_unsized() {\n+                    unimplemented!(\"by-value trait object is not \\\n+                                    yet implemented in #![feature(unsized_locals)]\");\n+                }\n                 // FIXME(eddyb) `layout.field(cx, 0)` is not enough because e.g.\n                 // `Box<dyn Trait>` has a few newtype wrappers around the raw\n                 // pointer, so we'd have to \"dig down\" to find `*dyn Trait`.\n@@ -538,7 +547,9 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 }\n \n                 let size = arg.layout.size;\n-                if size > layout::Pointer.size(cx) {\n+                if arg.layout.is_unsized() {\n+                    arg.make_unsized_indirect(None);\n+                } else if size > layout::Pointer.size(cx) {\n                     arg.make_indirect();\n                 } else {\n                     // We want to pass small aggregates as immediates, but using\n@@ -584,6 +595,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 llargument_tys.push(self.ret.memory_ty(cx).ptr_to());\n                 Type::void(cx)\n             }\n+            PassMode::UnsizedIndirect(..) => bug!(\"return type must be sized\"),\n         };\n \n         for arg in &self.args {\n@@ -600,6 +612,13 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                     llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(cx, 1, true));\n                     continue;\n                 }\n+                PassMode::UnsizedIndirect(..) => {\n+                    let ptr_ty = cx.tcx.mk_mut_ptr(arg.layout.ty);\n+                    let ptr_layout = cx.layout_of(ptr_ty);\n+                    llargument_tys.push(ptr_layout.scalar_pair_element_llvm_type(cx, 0, true));\n+                    llargument_tys.push(ptr_layout.scalar_pair_element_llvm_type(cx, 1, true));\n+                    continue;\n+                }\n                 PassMode::Cast(cast) => cast.llvm_type(cx),\n                 PassMode::Indirect(_) => arg.memory_ty(cx).ptr_to(),\n             };\n@@ -651,6 +670,10 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 PassMode::Ignore => {}\n                 PassMode::Direct(ref attrs) |\n                 PassMode::Indirect(ref attrs) => apply(attrs),\n+                PassMode::UnsizedIndirect(ref attrs, ref extra_attrs) => {\n+                    apply(attrs);\n+                    apply(extra_attrs);\n+                }\n                 PassMode::Pair(ref a, ref b) => {\n                     apply(a);\n                     apply(b);\n@@ -695,6 +718,10 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 PassMode::Ignore => {}\n                 PassMode::Direct(ref attrs) |\n                 PassMode::Indirect(ref attrs) => apply(attrs),\n+                PassMode::UnsizedIndirect(ref attrs, ref extra_attrs) => {\n+                    apply(attrs);\n+                    apply(extra_attrs);\n+                }\n                 PassMode::Pair(ref a, ref b) => {\n                     apply(a);\n                     apply(b);"}, {"sha": "49db35f586524ac1fa59f0f4c908f25d0a308826", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "patch": "@@ -295,7 +295,7 @@ pub fn coerce_unsized_into(\n             OperandValue::Immediate(base) => {\n                 unsize_thin_ptr(bx, base, src_ty, dst_ty)\n             }\n-            OperandValue::Ref(..) => bug!()\n+            OperandValue::Ref(..) | OperandValue::UnsizedRef(..) => bug!()\n         };\n         OperandValue::Pair(base, info).store(bx, dst);\n     };"}, {"sha": "52f8576d0d12a92525de1ae16c895552dcc3057e", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "patch": "@@ -32,7 +32,7 @@ use syntax_pos::Pos;\n use super::{FunctionCx, LocalRef};\n use super::place::PlaceRef;\n use super::operand::OperandRef;\n-use super::operand::OperandValue::{Pair, Ref, Immediate};\n+use super::operand::OperandValue::{Pair, Ref, UnsizedRef, Immediate};\n \n impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_block(&mut self, bb: mir::BasicBlock) {\n@@ -234,6 +234,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         let op = self.codegen_consume(&bx, &mir::Place::Local(mir::RETURN_PLACE));\n                         if let Ref(llval, align) = op.val {\n                             bx.load(llval, align)\n+                        } else if let UnsizedRef(..) = op.val {\n+                            bug!(\"return type must be sized\");\n                         } else {\n                             op.immediate_or_packed_pair(&bx)\n                         }\n@@ -249,6 +251,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                                     layout: cg_place.layout\n                                 }\n                             }\n+                            LocalRef::UnsizedPlace(_) => bug!(\"return type must be sized\"),\n                         };\n                         let llslot = match op.val {\n                             Immediate(_) | Pair(..) => {\n@@ -261,11 +264,14 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                                            \"return place is unaligned!\");\n                                 llval\n                             }\n+                            UnsizedRef(..) => bug!(\"return type must be sized\"),\n                         };\n                         bx.load(\n                             bx.pointercast(llslot, cast_ty.llvm_type(bx.cx).ptr_to()),\n                             self.fn_ty.ret.layout.align)\n                     }\n+\n+                    PassMode::UnsizedIndirect(..) => bug!(\"return value must be sized\"),\n                 };\n                 bx.ret(llval);\n             }\n@@ -607,6 +613,10 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                             op.val.store(&bx, tmp);\n                             op.val = Ref(tmp.llval, tmp.align);\n                         }\n+                        (&mir::Operand::Copy(_), UnsizedRef(..)) |\n+                        (&mir::Operand::Constant(_), UnsizedRef(..)) => {\n+                            bug!(\"tried to pass an unsized argument by copy or constant\")\n+                        }\n                         _ => {}\n                     }\n \n@@ -657,6 +667,15 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 }\n                 _ => bug!(\"codegen_argument: {:?} invalid for pair arugment\", op)\n             }\n+        } else if let PassMode::UnsizedIndirect(..) = arg.mode {\n+            match op.val {\n+                UnsizedRef(a, b) => {\n+                    llargs.push(a);\n+                    llargs.push(b);\n+                    return;\n+                }\n+                _ => bug!(\"codegen_argument: {:?} invalid for unsized indirect argument\", op)\n+            }\n         }\n \n         // Force by-ref if we have to load through a cast pointer.\n@@ -686,6 +705,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     (llval, align, true)\n                 }\n             }\n+            UnsizedRef(..) =>\n+                bug!(\"codegen_argument: tried to pass unsized operand to sized argument\"),\n         };\n \n         if by_ref && !arg.is_indirect() {\n@@ -727,6 +748,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 let field_ptr = tuple_ptr.project_field(bx, i);\n                 self.codegen_argument(bx, field_ptr.load(bx), llargs, &args[i]);\n             }\n+        } else if let UnsizedRef(..) = tuple.val {\n+            bug!(\"closure arguments must be sized\")\n         } else {\n             // If the tuple is immediate, the elements are as well.\n             for i in 0..tuple.layout.fields.count() {\n@@ -820,6 +843,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         let dest = if let mir::Place::Local(index) = *dest {\n             match self.locals[index] {\n                 LocalRef::Place(dest) => dest,\n+                LocalRef::UnsizedPlace(_) => bug!(\"return type must be sized\"),\n                 LocalRef::Operand(None) => {\n                     // Handle temporary places, specifically Operand ones, as\n                     // they don't have allocas\n@@ -871,6 +895,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         if let mir::Place::Local(index) = *dst {\n             match self.locals[index] {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),\n+                LocalRef::UnsizedPlace(_) => bug!(\"transmute must not involve unsized locals\"),\n                 LocalRef::Operand(None) => {\n                     let dst_layout = bx.cx.layout_of(self.monomorphized_place_ty(dst));\n                     assert!(!dst_layout.ty.has_erasable_regions());"}, {"sha": "d7bad05a66cefa59007823cf242f0fbe619ff271", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "patch": "@@ -180,6 +180,11 @@ impl FunctionCx<'a, 'll, 'tcx> {\n \n enum LocalRef<'ll, 'tcx> {\n     Place(PlaceRef<'ll, 'tcx>),\n+    /// `UnsizedPlace(p)`: `p` itself is a thin pointer (indirect place).\n+    /// `*p` is the fat pointer that references the actual unsized place.\n+    /// Every time it is initialized, we have to reallocate the place\n+    /// and update the fat pointer. That's the reason why it is indirect.\n+    UnsizedPlace(PlaceRef<'ll, 'tcx>),\n     Operand(Option<OperandRef<'ll, 'tcx>>),\n }\n \n@@ -275,17 +280,24 @@ pub fn codegen_mir(\n                 }\n \n                 debug!(\"alloc: {:?} ({}) -> place\", local, name);\n-                let place = PlaceRef::alloca(&bx, layout, &name.as_str());\n-                if dbg {\n-                    let (scope, span) = fx.debug_loc(mir::SourceInfo {\n-                        span: decl.source_info.span,\n-                        scope: decl.visibility_scope,\n-                    });\n-                    declare_local(&bx, &fx.debug_context, name, layout.ty, scope.unwrap(),\n-                        VariableAccess::DirectVariable { alloca: place.llval },\n-                        VariableKind::LocalVariable, span);\n+                if layout.is_unsized() {\n+                    let indirect_place =\n+                        PlaceRef::alloca_unsized_indirect(&bx, layout, &name.as_str());\n+                    // FIXME: add an appropriate debuginfo\n+                    LocalRef::UnsizedPlace(indirect_place)\n+                } else {\n+                    let place = PlaceRef::alloca(&bx, layout, &name.as_str());\n+                    if dbg {\n+                        let (scope, span) = fx.debug_loc(mir::SourceInfo {\n+                            span: decl.source_info.span,\n+                            scope: decl.visibility_scope,\n+                        });\n+                        declare_local(&bx, &fx.debug_context, name, layout.ty, scope.unwrap(),\n+                            VariableAccess::DirectVariable { alloca: place.llval },\n+                            VariableKind::LocalVariable, span);\n+                    }\n+                    LocalRef::Place(place)\n                 }\n-                LocalRef::Place(place)\n             } else {\n                 // Temporary or return place\n                 if local == mir::RETURN_PLACE && fx.fn_ty.ret.is_indirect() {\n@@ -294,7 +306,13 @@ pub fn codegen_mir(\n                     LocalRef::Place(PlaceRef::new_sized(llretptr, layout, layout.align))\n                 } else if memory_locals.contains(local) {\n                     debug!(\"alloc: {:?} -> place\", local);\n-                    LocalRef::Place(PlaceRef::alloca(&bx, layout, &format!(\"{:?}\", local)))\n+                    if layout.is_unsized() {\n+                        let indirect_place =\n+                            PlaceRef::alloca_unsized_indirect(&bx, layout, &format!(\"{:?}\", local));\n+                        LocalRef::UnsizedPlace(indirect_place)\n+                    } else {\n+                        LocalRef::Place(PlaceRef::alloca(&bx, layout, &format!(\"{:?}\", local)))\n+                    }\n                 } else {\n                     // If this is an immediate local, we do not create an\n                     // alloca in advance. Instead we wait until we see the\n@@ -531,6 +549,18 @@ fn arg_local_refs(\n             bx.set_value_name(llarg, &name);\n             llarg_idx += 1;\n             PlaceRef::new_sized(llarg, arg.layout, arg.layout.align)\n+        } else if arg.is_unsized_indirect() {\n+            // As the storage for the indirect argument lives during\n+            // the whole function call, we just copy the fat pointer.\n+            let llarg = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+            llarg_idx += 1;\n+            let llextra = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+            llarg_idx += 1;\n+            let indirect_operand = OperandValue::Pair(llarg, llextra);\n+\n+            let tmp = PlaceRef::alloca_unsized_indirect(bx, arg.layout, &name);\n+            indirect_operand.store(&bx, tmp);\n+            tmp\n         } else {\n             let tmp = PlaceRef::alloca(bx, arg.layout, &name);\n             arg.store_fn_arg(bx, &mut llarg_idx, tmp);\n@@ -632,7 +662,11 @@ fn arg_local_refs(\n                 );\n             }\n         });\n-        LocalRef::Place(place)\n+        if arg.is_unsized_indirect() {\n+            LocalRef::UnsizedPlace(place)\n+        } else {\n+            LocalRef::Place(place)\n+        }\n     }).collect()\n }\n "}, {"sha": "ae929681b55eeb87bdad9560a79d7d88d6b8af36", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "patch": "@@ -21,6 +21,8 @@ use common::{CodegenCx, C_undef, C_usize};\n use builder::{Builder, MemFlags};\n use value::Value;\n use type_of::LayoutLlvmExt;\n+use type_::Type;\n+use glue;\n \n use std::fmt;\n \n@@ -36,6 +38,10 @@ pub enum OperandValue<'ll> {\n     /// A reference to the actual operand. The data is guaranteed\n     /// to be valid for the operand's lifetime.\n     Ref(&'ll Value, Align),\n+    /// A reference to the unsized operand. The data is guaranteed\n+    /// to be valid for the operand's lifetime.\n+    /// The second field is the extra.\n+    UnsizedRef(&'ll Value, &'ll Value),\n     /// A single LLVM value.\n     Immediate(&'ll Value),\n     /// A pair of immediate LLVM values. Used by fat pointers too.\n@@ -148,7 +154,8 @@ impl OperandRef<'ll, 'tcx> {\n         let (llptr, llextra) = match self.val {\n             OperandValue::Immediate(llptr) => (llptr, None),\n             OperandValue::Pair(llptr, llextra) => (llptr, Some(llextra)),\n-            OperandValue::Ref(..) => bug!(\"Deref of by-Ref operand {:?}\", self)\n+            OperandValue::Ref(..) |\n+            OperandValue::UnsizedRef(..) => bug!(\"Deref of by-Ref operand {:?}\", self)\n         };\n         let layout = cx.layout_of(projected_ty);\n         PlaceRef {\n@@ -243,7 +250,8 @@ impl OperandRef<'ll, 'tcx> {\n                 *a = bx.bitcast(*a, field.scalar_pair_element_llvm_type(bx.cx, 0, true));\n                 *b = bx.bitcast(*b, field.scalar_pair_element_llvm_type(bx.cx, 1, true));\n             }\n-            OperandValue::Ref(..) => bug!()\n+            OperandValue::Ref(..) |\n+            OperandValue::UnsizedRef(..) => bug!()\n         }\n \n         OperandRef {\n@@ -287,6 +295,9 @@ impl OperandValue<'ll> {\n                 base::memcpy_ty(bx, dest.llval, r, dest.layout,\n                                 source_align.min(dest.align), flags)\n             }\n+            OperandValue::UnsizedRef(..) => {\n+                bug!(\"cannot directly store unsized values\");\n+            }\n             OperandValue::Immediate(s) => {\n                 let val = base::from_immediate(bx, s);\n                 bx.store_with_flags(val, dest.llval, dest.align, flags);\n@@ -300,6 +311,35 @@ impl OperandValue<'ll> {\n             }\n         }\n     }\n+\n+    pub fn store_unsized(self, bx: &Builder<'a, 'll, 'tcx>, indirect_dest: PlaceRef<'ll, 'tcx>) {\n+        debug!(\"OperandRef::store_unsized: operand={:?}, indirect_dest={:?}\", self, indirect_dest);\n+        let flags = MemFlags::empty();\n+\n+        // `indirect_dest` must have `*mut T` type. We extract `T` out of it.\n+        let unsized_ty = indirect_dest.layout.ty.builtin_deref(true)\n+            .unwrap_or_else(|| bug!(\"indirect_dest has non-pointer type: {:?}\", indirect_dest)).ty;\n+\n+        let (llptr, llextra) =\n+            if let OperandValue::UnsizedRef(llptr, llextra) = self {\n+                (llptr, llextra)\n+            } else {\n+                bug!(\"store_unsized called with a sized value\")\n+            };\n+\n+        // FIXME: choose an appropriate alignment, or use dynamic align somehow\n+        let max_align = Align::from_bits(128, 128).unwrap();\n+        let min_align = Align::from_bits(8, 8).unwrap();\n+\n+        // Allocate an appropriate region on the stack, and copy the value into it\n+        let (llsize, _) = glue::size_and_align_of_dst(&bx, unsized_ty, Some(llextra));\n+        let lldst = bx.array_alloca(Type::i8(bx.cx), llsize, \"unsized_tmp\", max_align);\n+        base::call_memcpy(&bx, lldst, llptr, llsize, min_align, flags);\n+\n+        // Store the allocated region and the extra to the indirect place.\n+        let indirect_operand = OperandValue::Pair(lldst, llextra);\n+        indirect_operand.store(&bx, indirect_dest);\n+    }\n }\n \n impl FunctionCx<'a, 'll, 'tcx> {\n@@ -320,7 +360,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 LocalRef::Operand(None) => {\n                     bug!(\"use of {:?} before def\", place);\n                 }\n-                LocalRef::Place(..) => {\n+                LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n                     // use path below\n                 }\n             }"}, {"sha": "6e5d3dad252266e323ccaf288c970b9f9b8ee0d6", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "patch": "@@ -48,6 +48,7 @@ impl PlaceRef<'ll, 'tcx> {\n         layout: TyLayout<'tcx>,\n         align: Align,\n     ) -> PlaceRef<'ll, 'tcx> {\n+        assert!(!layout.is_unsized());\n         PlaceRef {\n             llval,\n             llextra: None,\n@@ -77,10 +78,21 @@ impl PlaceRef<'ll, 'tcx> {\n     pub fn alloca(bx: &Builder<'a, 'll, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n                   -> PlaceRef<'ll, 'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n+        assert!(!layout.is_unsized(), \"tried to statically allocate unsized place\");\n         let tmp = bx.alloca(layout.llvm_type(bx.cx), name, layout.align);\n         Self::new_sized(tmp, layout, layout.align)\n     }\n \n+    /// Returns a place for an indirect reference to an unsized place.\n+    pub fn alloca_unsized_indirect(bx: &Builder<'a, 'll, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n+                  -> PlaceRef<'ll, 'tcx> {\n+        debug!(\"alloca_unsized_indirect({:?}: {:?})\", name, layout);\n+        assert!(layout.is_unsized(), \"tried to allocate indirect place for sized values\");\n+        let ptr_ty = bx.cx.tcx.mk_mut_ptr(layout.ty);\n+        let ptr_layout = bx.cx.layout_of(ptr_ty);\n+        Self::alloca(bx, ptr_layout, name)\n+    }\n+\n     pub fn len(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Value {\n         if let layout::FieldPlacement::Array { count, .. } = self.layout.fields {\n             if self.layout.is_unsized() {\n@@ -97,7 +109,7 @@ impl PlaceRef<'ll, 'tcx> {\n     pub fn load(&self, bx: &Builder<'a, 'll, 'tcx>) -> OperandRef<'ll, 'tcx> {\n         debug!(\"PlaceRef::load: {:?}\", self);\n \n-        assert_eq!(self.llextra, None);\n+        assert_eq!(self.llextra.is_some(), self.layout.is_unsized());\n \n         if self.layout.is_zst() {\n             return OperandRef::new_zst(bx.cx, self.layout);\n@@ -119,7 +131,9 @@ impl PlaceRef<'ll, 'tcx> {\n             }\n         };\n \n-        let val = if self.layout.is_llvm_immediate() {\n+        let val = if let Some(llextra) = self.llextra {\n+            OperandValue::UnsizedRef(self.llval, llextra)\n+        } else if self.layout.is_llvm_immediate() {\n             let mut const_llval = None;\n             unsafe {\n                 if let Some(global) = llvm::LLVMIsAGlobalVariable(self.llval) {\n@@ -424,6 +438,9 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 LocalRef::Place(place) => {\n                     return place;\n                 }\n+                LocalRef::UnsizedPlace(place) => {\n+                    return place.load(bx).deref(&cx);\n+                }\n                 LocalRef::Operand(..) => {\n                     bug!(\"using operand local {:?} as place\", place);\n                 }"}, {"sha": "ae318cda2022b80076094f643cffcb212cd5eda4", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "patch": "@@ -87,6 +87,9 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         let source = PlaceRef::new_sized(llref, operand.layout, align);\n                         base::coerce_unsized_into(&bx, source, dest);\n                     }\n+                    OperandValue::UnsizedRef(..) => {\n+                        bug!(\"unsized coercion on an unsized rvalue\")\n+                    }\n                 }\n                 bx\n             }\n@@ -175,6 +178,26 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         }\n     }\n \n+    pub fn codegen_rvalue_unsized(&mut self,\n+                        bx: Builder<'a, 'll, 'tcx>,\n+                        indirect_dest: PlaceRef<'ll, 'tcx>,\n+                        rvalue: &mir::Rvalue<'tcx>)\n+                        -> Builder<'a, 'll, 'tcx>\n+    {\n+        debug!(\"codegen_rvalue_unsized(indirect_dest.llval={:?}, rvalue={:?})\",\n+               indirect_dest.llval, rvalue);\n+\n+        match *rvalue {\n+            mir::Rvalue::Use(ref operand) => {\n+                let cg_operand = self.codegen_operand(&bx, operand);\n+                cg_operand.val.store_unsized(&bx, indirect_dest);\n+                bx\n+            }\n+\n+            _ => bug!(\"unsized assignment other than Rvalue::Use\"),\n+        }\n+    }\n+\n     pub fn codegen_rvalue_operand(&mut self,\n                                 bx: Builder<'a, 'll, 'tcx>,\n                                 rvalue: &mir::Rvalue<'tcx>)\n@@ -245,6 +268,9 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                                 bug!(\"by-ref operand {:?} in codegen_rvalue_operand\",\n                                      operand);\n                             }\n+                            OperandValue::UnsizedRef(..) => {\n+                                bug!(\"unsized coercion on an unsized rvalue\")\n+                            }\n                         }\n                     }\n                     mir::CastKind::Misc if operand.layout.is_llvm_scalar_pair() => {"}, {"sha": "dd62a12553caa24f9009d305abc61364a1c6d641", "filename": "src/librustc_codegen_llvm/mir/statement.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs?ref=800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "patch": "@@ -31,6 +31,9 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         LocalRef::Place(cg_dest) => {\n                             self.codegen_rvalue(bx, cg_dest, rvalue)\n                         }\n+                        LocalRef::UnsizedPlace(cg_indirect_dest) => {\n+                            self.codegen_rvalue_unsized(bx, cg_indirect_dest, rvalue)\n+                        }\n                         LocalRef::Operand(None) => {\n                             let (bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n                             self.locals[index] = LocalRef::Operand(Some(operand));\n@@ -61,12 +64,16 @@ impl FunctionCx<'a, 'll, 'tcx> {\n             mir::StatementKind::StorageLive(local) => {\n                 if let LocalRef::Place(cg_place) = self.locals[local] {\n                     cg_place.storage_live(&bx);\n+                } else if let LocalRef::UnsizedPlace(cg_indirect_place) = self.locals[local] {\n+                    cg_indirect_place.storage_live(&bx);\n                 }\n                 bx\n             }\n             mir::StatementKind::StorageDead(local) => {\n                 if let LocalRef::Place(cg_place) = self.locals[local] {\n                     cg_place.storage_dead(&bx);\n+                } else if let LocalRef::UnsizedPlace(cg_indirect_place) = self.locals[local] {\n+                    cg_indirect_place.storage_dead(&bx);\n                 }\n                 bx\n             }"}, {"sha": "8647beef3d5c87b446721dcccddac81bfb4c084f", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "patch": "@@ -45,6 +45,8 @@ pub enum PassMode {\n     Cast(CastTarget),\n     /// Pass the argument indirectly via a hidden pointer.\n     Indirect(ArgAttributes),\n+    /// Pass the unsized argument indirectly via a hidden pointer.\n+    UnsizedIndirect(ArgAttributes, ArgAttributes),\n }\n \n // Hack to disable non_upper_case_globals only for the bitflags! and not for the rest\n@@ -381,6 +383,25 @@ impl<'a, Ty> ArgType<'a, Ty> {\n         }\n     }\n \n+    pub fn make_unsized_indirect(&mut self, vtable_size: Option<Size>) {\n+        self.make_indirect();\n+\n+        let attrs = if let PassMode::Indirect(attrs) = self.mode {\n+            attrs\n+        } else {\n+            unreachable!()\n+        };\n+\n+        let mut extra_attrs = ArgAttributes::new();\n+        if let Some(vtable_size) = vtable_size {\n+            extra_attrs.set(ArgAttribute::NoAlias)\n+                       .set(ArgAttribute::NonNull);\n+            extra_attrs.pointee_size = vtable_size;\n+        }\n+\n+        self.mode = PassMode::UnsizedIndirect(attrs, extra_attrs);\n+    }\n+\n     pub fn extend_integer_width_to(&mut self, bits: u64) {\n         // Only integers have signedness\n         if let Abi::Scalar(ref scalar) = self.layout.abi {\n@@ -414,6 +435,13 @@ impl<'a, Ty> ArgType<'a, Ty> {\n         }\n     }\n \n+    pub fn is_unsized_indirect(&self) -> bool {\n+        match self.mode {\n+            PassMode::UnsizedIndirect(..) => true,\n+            _ => false\n+        }\n+    }\n+\n     pub fn is_ignore(&self) -> bool {\n         self.mode == PassMode::Ignore\n     }"}, {"sha": "6e64210a890017f8288d37cdc62b4e27b7d584a6", "filename": "src/librustc_target/abi/call/x86.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs?ref=800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "patch": "@@ -102,6 +102,7 @@ pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>, flavor: Flav\n                 PassMode::Indirect(_) => continue,\n                 PassMode::Direct(ref mut attrs) => attrs,\n                 PassMode::Pair(..) |\n+                PassMode::UnsizedIndirect(..) |\n                 PassMode::Cast(_) => {\n                     unreachable!(\"x86 shouldn't be passing arguments by {:?}\", arg.mode)\n                 }"}, {"sha": "e1fda427b4e73e9c5a8756972eace8a4e306e469", "filename": "src/test/run-pass-valgrind/unsized-locals/long-live-the-unsized-temporary.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Ftest%2Frun-pass-valgrind%2Funsized-locals%2Flong-live-the-unsized-temporary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Ftest%2Frun-pass-valgrind%2Funsized-locals%2Flong-live-the-unsized-temporary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Funsized-locals%2Flong-live-the-unsized-temporary.rs?ref=800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unsized_locals)]\n+\n+use std::fmt;\n+\n+fn gen_foo() -> Box<fmt::Display> {\n+    Box::new(Box::new(\"foo\"))\n+}\n+\n+fn foo(x: fmt::Display) {\n+    assert_eq!(x.to_string(), \"foo\");\n+}\n+\n+fn foo_indirect(x: fmt::Display) {\n+    foo(x);\n+}\n+\n+fn main() {\n+    foo(*gen_foo());\n+    foo_indirect(*gen_foo());\n+\n+    {\n+        let x: fmt::Display = *gen_foo();\n+        foo(x);\n+    }\n+\n+    {\n+        let x: fmt::Display = *gen_foo();\n+        let y: fmt::Display = *gen_foo();\n+        foo(x);\n+        foo(y);\n+    }\n+\n+    {\n+        let mut cnt: usize = 3;\n+        let x = loop {\n+            let x: fmt::Display = *gen_foo();\n+            if cnt == 0 {\n+                break x;\n+            } else {\n+                cnt -= 1;\n+            }\n+        };\n+        foo(x);\n+    }\n+\n+    {\n+        let x: fmt::Display = *gen_foo();\n+        let x = if true {\n+            x\n+        } else {\n+            *gen_foo()\n+        };\n+        foo(x);\n+    }\n+}"}, {"sha": "6ed39a78648a26935fb52a91a4e4fdd09da31591", "filename": "src/test/run-pass/unsized-locals/reference-unsized-locals.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Ftest%2Frun-pass%2Funsized-locals%2Freference-unsized-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Ftest%2Frun-pass%2Funsized-locals%2Freference-unsized-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized-locals%2Freference-unsized-locals.rs?ref=800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unsized_locals)]\n+\n+fn main() {\n+    let foo: Box<[u8]> = Box::new(*b\"foo\");\n+    let foo: [u8] = *foo;\n+    assert_eq!(&foo, b\"foo\" as &[u8]);\n+}"}, {"sha": "0b1aa6225eb50ef1e520a23bce26cd0964fa657e", "filename": "src/test/run-pass/unsized-locals/simple-unsized-locals.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Ftest%2Frun-pass%2Funsized-locals%2Fsimple-unsized-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Ftest%2Frun-pass%2Funsized-locals%2Fsimple-unsized-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized-locals%2Fsimple-unsized-locals.rs?ref=800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unsized_locals)]\n+\n+fn main() {\n+    let foo: Box<[u8]> = Box::new(*b\"foo\");\n+    let _foo: [u8] = *foo;\n+}"}, {"sha": "9a5e534db25b33a1681d2b8c5e0e16cce6122877", "filename": "src/test/run-pass/unsized-locals/unsized-exprs.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Ftest%2Frun-pass%2Funsized-locals%2Funsized-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Ftest%2Frun-pass%2Funsized-locals%2Funsized-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized-locals%2Funsized-exprs.rs?ref=800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unsized_tuple_coercion, unsized_locals)]\n+\n+struct A<X: ?Sized>(X);\n+\n+fn udrop<T: ?Sized>(_x: T) {}\n+fn foo() -> Box<[u8]> {\n+    Box::new(*b\"foo\")\n+}\n+fn tfoo() -> Box<(i32, [u8])> {\n+    Box::new((42, *b\"foo\"))\n+}\n+fn afoo() -> Box<A<[u8]>> {\n+    Box::new(A(*b\"foo\"))\n+}\n+\n+impl std::ops::Add<i32> for A<[u8]> {\n+    type Output = ();\n+    fn add(self, _rhs: i32) -> Self::Output {}\n+}\n+\n+fn main() {\n+    udrop::<[u8]>(loop {\n+        break *foo();\n+    });\n+    udrop::<[u8]>(if true {\n+        *foo()\n+    } else {\n+        *foo()\n+    });\n+    udrop::<[u8]>({*foo()});\n+    #[allow(unused_parens)]\n+    udrop::<[u8]>((*foo()));\n+    udrop::<[u8]>((*tfoo()).1);\n+    *afoo() + 42;\n+}"}, {"sha": "0314fe1d686621bf483a64ae773ee0b5e40bac39", "filename": "src/test/run-pass/unsized-locals/unsized-parameters.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Ftest%2Frun-pass%2Funsized-locals%2Funsized-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800f2c13a3f4213648f301dcd4e10d80b1e6ea38/src%2Ftest%2Frun-pass%2Funsized-locals%2Funsized-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized-locals%2Funsized-parameters.rs?ref=800f2c13a3f4213648f301dcd4e10d80b1e6ea38", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unsized_locals)]\n+\n+pub fn f0(_f: dyn FnOnce()) {}\n+pub fn f1(_s: str) {}\n+pub fn f2((_x, _y): (i32, [i32])) {}\n+\n+fn main() {\n+    let foo = \"foo\".to_string().into_boxed_str();\n+    f1(*foo);\n+}"}]}