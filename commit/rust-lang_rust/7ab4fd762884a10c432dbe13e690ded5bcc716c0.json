{"sha": "7ab4fd762884a10c432dbe13e690ded5bcc716c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhYjRmZDc2Mjg4NGExMGM0MzJkYmUxM2U2OTBkZWQ1YmNjNzE2YzA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-08T12:42:17Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-08T12:45:17Z"}, "message": "internal: remove one more usage of SyntaxRewriter", "tree": {"sha": "f41918cdce6ac8c64225d0cf368328c92f3c647d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f41918cdce6ac8c64225d0cf368328c92f3c647d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ab4fd762884a10c432dbe13e690ded5bcc716c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ab4fd762884a10c432dbe13e690ded5bcc716c0", "html_url": "https://github.com/rust-lang/rust/commit/7ab4fd762884a10c432dbe13e690ded5bcc716c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ab4fd762884a10c432dbe13e690ded5bcc716c0/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "526040eea8886a748dfd0a5449526f37a8bcf6af", "url": "https://api.github.com/repos/rust-lang/rust/commits/526040eea8886a748dfd0a5449526f37a8bcf6af", "html_url": "https://github.com/rust-lang/rust/commit/526040eea8886a748dfd0a5449526f37a8bcf6af"}], "stats": {"total": 102, "additions": 46, "deletions": 56}, "files": [{"sha": "4116985ae144b4ff01d25c91fb19fd51650bf6af", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 46, "deletions": 56, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/7ab4fd762884a10c432dbe13e690ded5bcc716c0/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ab4fd762884a10c432dbe13e690ded5bcc716c0/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=7ab4fd762884a10c432dbe13e690ded5bcc716c0", "patch": "@@ -10,7 +10,6 @@ use ide_db::{\n use itertools::Itertools;\n use stdx::format_to;\n use syntax::{\n-    algo::SyntaxRewriter,\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n@@ -1362,7 +1361,8 @@ fn rewrite_body_segment(\n     syntax: &SyntaxNode,\n ) -> SyntaxNode {\n     let syntax = fix_param_usages(ctx, params, syntax);\n-    update_external_control_flow(handler, &syntax)\n+    update_external_control_flow(handler, &syntax);\n+    syntax\n }\n \n /// change all usages to account for added `&`/`&mut` for some params\n@@ -1415,75 +1415,65 @@ fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode)\n     res\n }\n \n-fn update_external_control_flow(handler: &FlowHandler, syntax: &SyntaxNode) -> SyntaxNode {\n-    let mut rewriter = SyntaxRewriter::default();\n-\n+fn update_external_control_flow(handler: &FlowHandler, syntax: &SyntaxNode) {\n     let mut nested_loop = None;\n     let mut nested_scope = None;\n     for event in syntax.preorder() {\n-        let node = match event {\n-            WalkEvent::Enter(e) => {\n-                match e.kind() {\n-                    SyntaxKind::LOOP_EXPR | SyntaxKind::WHILE_EXPR | SyntaxKind::FOR_EXPR => {\n-                        if nested_loop.is_none() {\n-                            nested_loop = Some(e.clone());\n-                        }\n+        match event {\n+            WalkEvent::Enter(e) => match e.kind() {\n+                SyntaxKind::LOOP_EXPR | SyntaxKind::WHILE_EXPR | SyntaxKind::FOR_EXPR => {\n+                    if nested_loop.is_none() {\n+                        nested_loop = Some(e.clone());\n                     }\n-                    SyntaxKind::FN\n-                    | SyntaxKind::CONST\n-                    | SyntaxKind::STATIC\n-                    | SyntaxKind::IMPL\n-                    | SyntaxKind::MODULE => {\n-                        if nested_scope.is_none() {\n-                            nested_scope = Some(e.clone());\n-                        }\n+                }\n+                SyntaxKind::FN\n+                | SyntaxKind::CONST\n+                | SyntaxKind::STATIC\n+                | SyntaxKind::IMPL\n+                | SyntaxKind::MODULE => {\n+                    if nested_scope.is_none() {\n+                        nested_scope = Some(e.clone());\n                     }\n-                    _ => {}\n                 }\n-                e\n-            }\n+                _ => {}\n+            },\n             WalkEvent::Leave(e) => {\n+                if nested_scope.is_none() {\n+                    if let Some(expr) = ast::Expr::cast(e.clone()) {\n+                        match expr {\n+                            ast::Expr::ReturnExpr(return_expr) if nested_scope.is_none() => {\n+                                let expr = return_expr.expr();\n+                                if let Some(replacement) = make_rewritten_flow(handler, expr) {\n+                                    ted::replace(return_expr.syntax(), replacement.syntax())\n+                                }\n+                            }\n+                            ast::Expr::BreakExpr(break_expr) if nested_loop.is_none() => {\n+                                let expr = break_expr.expr();\n+                                if let Some(replacement) = make_rewritten_flow(handler, expr) {\n+                                    ted::replace(break_expr.syntax(), replacement.syntax())\n+                                }\n+                            }\n+                            ast::Expr::ContinueExpr(continue_expr) if nested_loop.is_none() => {\n+                                if let Some(replacement) = make_rewritten_flow(handler, None) {\n+                                    ted::replace(continue_expr.syntax(), replacement.syntax())\n+                                }\n+                            }\n+                            _ => {\n+                                // do nothing\n+                            }\n+                        }\n+                    }\n+                }\n+\n                 if nested_loop.as_ref() == Some(&e) {\n                     nested_loop = None;\n                 }\n                 if nested_scope.as_ref() == Some(&e) {\n                     nested_scope = None;\n                 }\n-                continue;\n             }\n         };\n-        if nested_scope.is_some() {\n-            continue;\n-        }\n-        let expr = match ast::Expr::cast(node) {\n-            Some(e) => e,\n-            None => continue,\n-        };\n-        match expr {\n-            ast::Expr::ReturnExpr(return_expr) if nested_scope.is_none() => {\n-                let expr = return_expr.expr();\n-                if let Some(replacement) = make_rewritten_flow(handler, expr) {\n-                    rewriter.replace_ast(&return_expr.into(), &replacement);\n-                }\n-            }\n-            ast::Expr::BreakExpr(break_expr) if nested_loop.is_none() => {\n-                let expr = break_expr.expr();\n-                if let Some(replacement) = make_rewritten_flow(handler, expr) {\n-                    rewriter.replace_ast(&break_expr.into(), &replacement);\n-                }\n-            }\n-            ast::Expr::ContinueExpr(continue_expr) if nested_loop.is_none() => {\n-                if let Some(replacement) = make_rewritten_flow(handler, None) {\n-                    rewriter.replace_ast(&continue_expr.into(), &replacement);\n-                }\n-            }\n-            _ => {\n-                // do nothing\n-            }\n-        }\n     }\n-\n-    rewriter.rewrite(syntax)\n }\n \n fn make_rewritten_flow(handler: &FlowHandler, arg_expr: Option<ast::Expr>) -> Option<ast::Expr> {\n@@ -1502,7 +1492,7 @@ fn make_rewritten_flow(handler: &FlowHandler, arg_expr: Option<ast::Expr>) -> Op\n             make::expr_call(make::expr_path(make_path_from_text(\"Err\")), args)\n         }\n     };\n-    Some(make::expr_return(Some(value)))\n+    Some(make::expr_return(Some(value)).clone_for_update())\n }\n \n #[cfg(test)]"}]}