{"sha": "2a5a320babdf000bc9cf719ccd9d95d250f83a02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNWEzMjBiYWJkZjAwMGJjOWNmNzE5Y2NkOWQ5NWQyNTBmODNhMDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-12T14:39:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-12T14:39:31Z"}, "message": "Auto merge of #25300 - kballard:core-slice-overflow, r=Gankro\n\ncore::slice was originally written to tolerate overflow (notably, with\r\nslices of zero-sized elements), but it was never updated to use wrapping\r\narithmetic when overflow traps were added.\r\n\r\nAlso correctly handle the case of calling .nth() on an Iter with a\r\nzero-sized element type. The iterator was assuming that the pointer\r\nvalue of the returned reference was meaningful, but that's not true for\r\nzero-sized elements.\r\n\r\nFixes #25016.", "tree": {"sha": "c38b76ac8c49fef76d19e0f6027ac676054afa7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c38b76ac8c49fef76d19e0f6027ac676054afa7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a5a320babdf000bc9cf719ccd9d95d250f83a02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a5a320babdf000bc9cf719ccd9d95d250f83a02", "html_url": "https://github.com/rust-lang/rust/commit/2a5a320babdf000bc9cf719ccd9d95d250f83a02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a5a320babdf000bc9cf719ccd9d95d250f83a02/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ad202671fc031ee90133fa5849ef0ec31164e04", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ad202671fc031ee90133fa5849ef0ec31164e04", "html_url": "https://github.com/rust-lang/rust/commit/0ad202671fc031ee90133fa5849ef0ec31164e04"}, {"sha": "f2614f5858fed10e180102def32c60f180e46496", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2614f5858fed10e180102def32c60f180e46496", "html_url": "https://github.com/rust-lang/rust/commit/f2614f5858fed10e180102def32c60f180e46496"}], "stats": {"total": 169, "additions": 105, "deletions": 64}, "files": [{"sha": "9db1ceddf0d752ae20df6770281667b841a63668", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 45, "deletions": 64, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/2a5a320babdf000bc9cf719ccd9d95d250f83a02/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5a320babdf000bc9cf719ccd9d95d250f83a02/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=2a5a320babdf000bc9cf719ccd9d95d250f83a02", "patch": "@@ -140,7 +140,7 @@ impl<T> SliceExt for [T] {\n             assume(!p.is_null());\n             if mem::size_of::<T>() == 0 {\n                 Iter {ptr: p,\n-                      end: (p as usize + self.len()) as *const T,\n+                      end: ((p as usize).wrapping_add(self.len())) as *const T,\n                       _marker: marker::PhantomData}\n             } else {\n                 Iter {ptr: p,\n@@ -277,7 +277,7 @@ impl<T> SliceExt for [T] {\n             assume(!p.is_null());\n             if mem::size_of::<T>() == 0 {\n                 IterMut {ptr: p,\n-                         end: (p as usize + self.len()) as *mut T,\n+                         end: ((p as usize).wrapping_add(self.len())) as *mut T,\n                          _marker: marker::PhantomData}\n             } else {\n                 IterMut {ptr: p,\n@@ -632,35 +632,17 @@ fn size_from_ptr<T>(_: *const T) -> usize {\n \n \n // Use macros to be generic over const/mut\n-//\n-// They require non-negative `$by` because otherwise the expression\n-// `(ptr as usize + $by)` would interpret `-1` as `usize::MAX` (and\n-// thus trigger a panic when overflow checks are on).\n-\n-// Use this to do `$ptr + $by`, where `$by` is non-negative.\n-macro_rules! slice_add_offset {\n+macro_rules! slice_offset {\n     ($ptr:expr, $by:expr) => {{\n         let ptr = $ptr;\n         if size_from_ptr(ptr) == 0 {\n-            transmute(ptr as usize + $by)\n+            transmute((ptr as isize).wrapping_add($by))\n         } else {\n             ptr.offset($by)\n         }\n     }};\n }\n \n-// Use this to do `$ptr - $by`, where `$by` is non-negative.\n-macro_rules! slice_sub_offset {\n-    ($ptr:expr, $by:expr) => {{\n-        let ptr = $ptr;\n-        if size_from_ptr(ptr) == 0 {\n-            transmute(ptr as usize - $by)\n-        } else {\n-            ptr.offset(-$by)\n-        }\n-    }};\n-}\n-\n macro_rules! slice_ref {\n     ($ptr:expr) => {{\n         let ptr = $ptr;\n@@ -683,22 +665,24 @@ macro_rules! iterator {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n-                unsafe {\n-                    ::intrinsics::assume(!self.ptr.is_null());\n-                    ::intrinsics::assume(!self.end.is_null());\n-                    if self.ptr == self.end {\n-                        None\n-                    } else {\n+                if self.ptr == self.end {\n+                    None\n+                } else {\n+                    unsafe {\n+                        if mem::size_of::<T>() != 0 {\n+                            ::intrinsics::assume(!self.ptr.is_null());\n+                            ::intrinsics::assume(!self.end.is_null());\n+                        }\n                         let old = self.ptr;\n-                        self.ptr = slice_add_offset!(self.ptr, 1);\n+                        self.ptr = slice_offset!(self.ptr, 1);\n                         Some(slice_ref!(old))\n                     }\n                 }\n             }\n \n             #[inline]\n             fn size_hint(&self) -> (usize, Option<usize>) {\n-                let diff = (self.end as usize) - (self.ptr as usize);\n+                let diff = (self.end as usize).wrapping_sub(self.ptr as usize);\n                 let size = mem::size_of::<T>();\n                 let exact = diff / (if size == 0 {1} else {size});\n                 (exact, Some(exact))\n@@ -726,13 +710,15 @@ macro_rules! iterator {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n-                unsafe {\n-                    ::intrinsics::assume(!self.ptr.is_null());\n-                    ::intrinsics::assume(!self.end.is_null());\n-                    if self.end == self.ptr {\n-                        None\n-                    } else {\n-                        self.end = slice_sub_offset!(self.end, 1);\n+                if self.end == self.ptr {\n+                    None\n+                } else {\n+                    unsafe {\n+                        self.end = slice_offset!(self.end, -1);\n+                        if mem::size_of::<T>() != 0 {\n+                            ::intrinsics::assume(!self.ptr.is_null());\n+                            ::intrinsics::assume(!self.end.is_null());\n+                        }\n                         Some(slice_ref!(self.end))\n                     }\n                 }\n@@ -742,29 +728,29 @@ macro_rules! iterator {\n }\n \n macro_rules! make_slice {\n-    ($t: ty => $result: ty: $start: expr, $end: expr) => {{\n-        let diff = $end as usize - $start as usize;\n-        let len = if mem::size_of::<T>() == 0 {\n-            diff\n+    ($start: expr, $end: expr) => {{\n+        let start = $start;\n+        let diff = ($end as usize).wrapping_sub(start as usize);\n+        if size_from_ptr(start) == 0 {\n+            // use a non-null pointer value\n+            unsafe { from_raw_parts(1 as *const _, diff) }\n         } else {\n-            diff / mem::size_of::<$t>()\n-        };\n-        unsafe {\n-            from_raw_parts($start, len)\n+            let len = diff / size_from_ptr(start);\n+            unsafe { from_raw_parts(start, len) }\n         }\n     }}\n }\n \n macro_rules! make_mut_slice {\n-    ($t: ty => $result: ty: $start: expr, $end: expr) => {{\n-        let diff = $end as usize - $start as usize;\n-        let len = if mem::size_of::<T>() == 0 {\n-            diff\n+    ($start: expr, $end: expr) => {{\n+        let start = $start;\n+        let diff = ($end as usize).wrapping_sub(start as usize);\n+        if size_from_ptr(start) == 0 {\n+            // use a non-null pointer value\n+            unsafe { from_raw_parts_mut(1 as *mut _, diff) }\n         } else {\n-            diff / mem::size_of::<$t>()\n-        };\n-        unsafe {\n-            from_raw_parts_mut($start, len)\n+            let len = diff / size_from_ptr(start);\n+            unsafe { from_raw_parts_mut(start, len) }\n         }\n     }}\n }\n@@ -787,14 +773,14 @@ impl<'a, T> Iter<'a, T> {\n     /// iterator can continue to be used while this exists.\n     #[unstable(feature = \"core\")]\n     pub fn as_slice(&self) -> &'a [T] {\n-        make_slice!(T => &'a [T]: self.ptr, self.end)\n+        make_slice!(self.ptr, self.end)\n     }\n \n     // Helper function for Iter::nth\n     fn iter_nth(&mut self, n: usize) -> Option<&'a T> {\n         match self.as_slice().get(n) {\n             Some(elem_ref) => unsafe {\n-                self.ptr = slice_add_offset!(elem_ref as *const _, 1);\n+                self.ptr = slice_offset!(self.ptr, (n as isize).wrapping_add(1));\n                 Some(slice_ref!(elem_ref))\n             },\n             None => {\n@@ -827,12 +813,7 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     fn idx(&mut self, index: usize) -> Option<&'a T> {\n         unsafe {\n             if index < self.indexable() {\n-                if mem::size_of::<T>() == 0 {\n-                    // Use a non-null pointer value\n-                    Some(&mut *(1 as *mut _))\n-                } else {\n-                    Some(transmute(self.ptr.offset(index as isize)))\n-                }\n+                Some(slice_ref!(self.ptr.offset(index as isize)))\n             } else {\n                 None\n             }\n@@ -860,14 +841,14 @@ impl<'a, T> IterMut<'a, T> {\n     /// restricted lifetimes that do not consume the iterator.\n     #[unstable(feature = \"core\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n-        make_mut_slice!(T => &'a mut [T]: self.ptr, self.end)\n+        make_mut_slice!(self.ptr, self.end)\n     }\n \n     // Helper function for IterMut::nth\n     fn iter_nth(&mut self, n: usize) -> Option<&'a mut T> {\n-        match make_mut_slice!(T => &'a mut [T]: self.ptr, self.end).get_mut(n) {\n+        match make_mut_slice!(self.ptr, self.end).get_mut(n) {\n             Some(elem_ref) => unsafe {\n-                self.ptr = slice_add_offset!(elem_ref as *mut _, 1);\n+                self.ptr = slice_offset!(self.ptr, (n as isize).wrapping_add(1));\n                 Some(slice_ref!(elem_ref))\n             },\n             None => {"}, {"sha": "6fe510586c74822223e2da6790a2323b76a7ab60", "filename": "src/test/run-pass/slice-of-zero-size-elements.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2a5a320babdf000bc9cf719ccd9d95d250f83a02/src%2Ftest%2Frun-pass%2Fslice-of-zero-size-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5a320babdf000bc9cf719ccd9d95d250f83a02/src%2Ftest%2Frun-pass%2Fslice-of-zero-size-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-of-zero-size-elements.rs?ref=2a5a320babdf000bc9cf719ccd9d95d250f83a02", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C debug-assertions\n+\n+#![feature(core)]\n+\n+use std::slice;\n+\n+fn foo<T>(v: &[T]) -> Option<&[T]> {\n+    let mut it = v.iter();\n+    for _ in 0..5 {\n+        let _ = it.next();\n+    }\n+    Some(it.as_slice())\n+}\n+\n+fn foo_mut<T>(v: &mut [T]) -> Option<&mut [T]> {\n+    let mut it = v.iter_mut();\n+    for _ in 0..5 {\n+        let _ = it.next();\n+    }\n+    Some(it.into_slice())\n+}\n+\n+pub fn main() {\n+    // In a slice of zero-size elements the pointer is meaningless.\n+    // Ensure iteration still works even if the pointer is at the end of the address space.\n+    let slice: &[()] = unsafe { slice::from_raw_parts(-5isize as *const (), 10) };\n+    assert_eq!(slice.len(), 10);\n+    assert_eq!(slice.iter().count(), 10);\n+\n+    // .nth() on the iterator should also behave correctly\n+    let mut it = slice.iter();\n+    assert!(it.nth(5).is_some());\n+    assert_eq!(it.count(), 4);\n+\n+    // Converting Iter to a slice should never have a null pointer\n+    assert!(foo(slice).is_some());\n+\n+    // Test mutable iterators as well\n+    let slice: &mut [()] = unsafe { slice::from_raw_parts_mut(-5isize as *mut (), 10) };\n+    assert_eq!(slice.len(), 10);\n+    assert_eq!(slice.iter_mut().count(), 10);\n+\n+    {\n+        let mut it = slice.iter_mut();\n+        assert!(it.nth(5).is_some());\n+        assert_eq!(it.count(), 4);\n+    }\n+\n+    assert!(foo_mut(slice).is_some())\n+}"}]}