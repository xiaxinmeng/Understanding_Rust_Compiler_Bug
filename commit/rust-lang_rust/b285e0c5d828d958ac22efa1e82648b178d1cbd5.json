{"sha": "b285e0c5d828d958ac22efa1e82648b178d1cbd5", "node_id": "C_kwDOAAsO6NoAKGIyODVlMGM1ZDgyOGQ5NThhYzIyZWZhMWU4MjY0OGIxNzhkMWNiZDU", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-10-29T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-11-03T15:43:12Z"}, "message": "Remove `MaybeMutBorrowedLocals`", "tree": {"sha": "b559dee6f512df23a0c12e87fab8c54c507cc8ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b559dee6f512df23a0c12e87fab8c54c507cc8ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b285e0c5d828d958ac22efa1e82648b178d1cbd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b285e0c5d828d958ac22efa1e82648b178d1cbd5", "html_url": "https://github.com/rust-lang/rust/commit/b285e0c5d828d958ac22efa1e82648b178d1cbd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b285e0c5d828d958ac22efa1e82648b178d1cbd5/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "473eaa42e9365c47d129f72693b5d163a20cf369", "url": "https://api.github.com/repos/rust-lang/rust/commits/473eaa42e9365c47d129f72693b5d163a20cf369", "html_url": "https://github.com/rust-lang/rust/commit/473eaa42e9365c47d129f72693b5d163a20cf369"}], "stats": {"total": 233, "additions": 26, "deletions": 207}, "files": [{"sha": "2420f31ac0897d190115ba22f0d71cd10a227c9c", "filename": "compiler/rustc_const_eval/src/transform/check_consts/resolver.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b285e0c5d828d958ac22efa1e82648b178d1cbd5/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285e0c5d828d958ac22efa1e82648b178d1cbd5/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=b285e0c5d828d958ac22efa1e82648b178d1cbd5", "patch": "@@ -110,6 +110,15 @@ where\n         }\n     }\n \n+    /// `&` and `&raw` only allow mutation if the borrowed place is `!Freeze`.\n+    ///\n+    /// This assumes that it is UB to take the address of a struct field whose type is\n+    /// `Freeze`, then use pointer arithmetic to derive a pointer to a *different* field of\n+    /// that same struct whose type is `!Freeze`. If we decide that this is not UB, we will\n+    /// have to check the type of the borrowed **local** instead of the borrowed **place**\n+    /// below. See [rust-lang/unsafe-code-guidelines#134].\n+    ///\n+    /// [rust-lang/unsafe-code-guidelines#134]: https://github.com/rust-lang/unsafe-code-guidelines/issues/134\n     fn shared_borrow_allows_mutation(&self, place: mir::Place<'tcx>) -> bool {\n         !place\n             .ty(self.ccx.body, self.ccx.tcx)"}, {"sha": "d38b567a95849be35d1995a6e2e8c3707dd2e1e4", "filename": "compiler/rustc_mir_dataflow/src/impls/borrowed_locals.rs", "status": "modified", "additions": 15, "deletions": 117, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/b285e0c5d828d958ac22efa1e82648b178d1cbd5/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285e0c5d828d958ac22efa1e82648b178d1cbd5/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fborrowed_locals.rs?ref=b285e0c5d828d958ac22efa1e82648b178d1cbd5", "patch": "@@ -3,55 +3,26 @@ use super::*;\n use crate::{AnalysisDomain, GenKill, GenKillAnalysis};\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{ParamEnv, TyCtxt};\n-use rustc_span::DUMMY_SP;\n-\n-pub type MaybeMutBorrowedLocals<'mir, 'tcx> = MaybeBorrowedLocals<MutBorrow<'mir, 'tcx>>;\n \n /// A dataflow analysis that tracks whether a pointer or reference could possibly exist that points\n /// to a given local.\n ///\n-/// The `K` parameter determines what kind of borrows are tracked. By default,\n-/// `MaybeBorrowedLocals` looks for *any* borrow of a local. If you are only interested in borrows\n-/// that might allow mutation, use the `MaybeMutBorrowedLocals` type alias instead.\n-///\n /// At present, this is used as a very limited form of alias analysis. For example,\n /// `MaybeBorrowedLocals` is used to compute which locals are live during a yield expression for\n-/// immovable generators. `MaybeMutBorrowedLocals` is used during const checking to prove that a\n-/// local has not been mutated via indirect assignment (e.g., `*p = 42`), the side-effects of a\n-/// function call or inline assembly.\n-pub struct MaybeBorrowedLocals<K = AnyBorrow> {\n-    kind: K,\n+/// immovable generators.\n+pub struct MaybeBorrowedLocals {\n     ignore_borrow_on_drop: bool,\n }\n \n impl MaybeBorrowedLocals {\n     /// A dataflow analysis that records whether a pointer or reference exists that may alias the\n     /// given local.\n     pub fn all_borrows() -> Self {\n-        MaybeBorrowedLocals { kind: AnyBorrow, ignore_borrow_on_drop: false }\n-    }\n-}\n-\n-impl MaybeMutBorrowedLocals<'mir, 'tcx> {\n-    /// A dataflow analysis that records whether a pointer or reference exists that may *mutably*\n-    /// alias the given local.\n-    ///\n-    /// This includes `&mut` and pointers derived from an `&mut`, as well as shared borrows of\n-    /// types with interior mutability.\n-    pub fn mut_borrows_only(\n-        tcx: TyCtxt<'tcx>,\n-        body: &'mir mir::Body<'tcx>,\n-        param_env: ParamEnv<'tcx>,\n-    ) -> Self {\n-        MaybeBorrowedLocals {\n-            kind: MutBorrow { body, tcx, param_env },\n-            ignore_borrow_on_drop: false,\n-        }\n+        MaybeBorrowedLocals { ignore_borrow_on_drop: false }\n     }\n }\n \n-impl<K> MaybeBorrowedLocals<K> {\n+impl MaybeBorrowedLocals {\n     /// During dataflow analysis, ignore the borrow that may occur when a place is dropped.\n     ///\n     /// Drop terminators may call custom drop glue (`Drop::drop`), which takes `&mut self` as a\n@@ -69,21 +40,14 @@ impl<K> MaybeBorrowedLocals<K> {\n         MaybeBorrowedLocals { ignore_borrow_on_drop: true, ..self }\n     }\n \n-    fn transfer_function<'a, T>(&'a self, trans: &'a mut T) -> TransferFunction<'a, T, K> {\n-        TransferFunction {\n-            kind: &self.kind,\n-            trans,\n-            ignore_borrow_on_drop: self.ignore_borrow_on_drop,\n-        }\n+    fn transfer_function<'a, T>(&'a self, trans: &'a mut T) -> TransferFunction<'a, T> {\n+        TransferFunction { trans, ignore_borrow_on_drop: self.ignore_borrow_on_drop }\n     }\n }\n \n-impl<K> AnalysisDomain<'tcx> for MaybeBorrowedLocals<K>\n-where\n-    K: BorrowAnalysisKind<'tcx>,\n-{\n+impl AnalysisDomain<'tcx> for MaybeBorrowedLocals {\n     type Domain = BitSet<Local>;\n-    const NAME: &'static str = K::ANALYSIS_NAME;\n+    const NAME: &'static str = \"maybe_borrowed_locals\";\n \n     fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n         // bottom = unborrowed\n@@ -95,10 +59,7 @@ where\n     }\n }\n \n-impl<K> GenKillAnalysis<'tcx> for MaybeBorrowedLocals<K>\n-where\n-    K: BorrowAnalysisKind<'tcx>,\n-{\n+impl GenKillAnalysis<'tcx> for MaybeBorrowedLocals {\n     type Idx = Local;\n \n     fn statement_effect(\n@@ -131,16 +92,14 @@ where\n }\n \n /// A `Visitor` that defines the transfer function for `MaybeBorrowedLocals`.\n-struct TransferFunction<'a, T, K> {\n+struct TransferFunction<'a, T> {\n     trans: &'a mut T,\n-    kind: &'a K,\n     ignore_borrow_on_drop: bool,\n }\n \n-impl<T, K> Visitor<'tcx> for TransferFunction<'a, T, K>\n+impl<T> Visitor<'tcx> for TransferFunction<'a, T>\n where\n     T: GenKill<Local>,\n-    K: BorrowAnalysisKind<'tcx>,\n {\n     fn visit_statement(&mut self, stmt: &Statement<'tcx>, location: Location) {\n         self.super_statement(stmt, location);\n@@ -156,14 +115,14 @@ where\n         self.super_rvalue(rvalue, location);\n \n         match rvalue {\n-            mir::Rvalue::AddressOf(mt, borrowed_place) => {\n-                if !borrowed_place.is_indirect() && self.kind.in_address_of(*mt, *borrowed_place) {\n+            mir::Rvalue::AddressOf(_mt, borrowed_place) => {\n+                if !borrowed_place.is_indirect() {\n                     self.trans.gen(borrowed_place.local);\n                 }\n             }\n \n-            mir::Rvalue::Ref(_, kind, borrowed_place) => {\n-                if !borrowed_place.is_indirect() && self.kind.in_ref(*kind, *borrowed_place) {\n+            mir::Rvalue::Ref(_, _kind, borrowed_place) => {\n+                if !borrowed_place.is_indirect() {\n                     self.trans.gen(borrowed_place.local);\n                 }\n             }\n@@ -211,64 +170,3 @@ where\n         }\n     }\n }\n-\n-pub struct AnyBorrow;\n-\n-pub struct MutBorrow<'mir, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    body: &'mir Body<'tcx>,\n-    param_env: ParamEnv<'tcx>,\n-}\n-\n-impl MutBorrow<'mir, 'tcx> {\n-    /// `&` and `&raw` only allow mutation if the borrowed place is `!Freeze`.\n-    ///\n-    /// This assumes that it is UB to take the address of a struct field whose type is\n-    /// `Freeze`, then use pointer arithmetic to derive a pointer to a *different* field of\n-    /// that same struct whose type is `!Freeze`. If we decide that this is not UB, we will\n-    /// have to check the type of the borrowed **local** instead of the borrowed **place**\n-    /// below. See [rust-lang/unsafe-code-guidelines#134].\n-    ///\n-    /// [rust-lang/unsafe-code-guidelines#134]: https://github.com/rust-lang/unsafe-code-guidelines/issues/134\n-    fn shared_borrow_allows_mutation(&self, place: Place<'tcx>) -> bool {\n-        !place.ty(self.body, self.tcx).ty.is_freeze(self.tcx.at(DUMMY_SP), self.param_env)\n-    }\n-}\n-\n-pub trait BorrowAnalysisKind<'tcx> {\n-    const ANALYSIS_NAME: &'static str;\n-\n-    fn in_address_of(&self, mt: Mutability, place: Place<'tcx>) -> bool;\n-    fn in_ref(&self, kind: mir::BorrowKind, place: Place<'tcx>) -> bool;\n-}\n-\n-impl BorrowAnalysisKind<'tcx> for AnyBorrow {\n-    const ANALYSIS_NAME: &'static str = \"maybe_borrowed_locals\";\n-\n-    fn in_ref(&self, _: mir::BorrowKind, _: Place<'_>) -> bool {\n-        true\n-    }\n-    fn in_address_of(&self, _: Mutability, _: Place<'_>) -> bool {\n-        true\n-    }\n-}\n-\n-impl BorrowAnalysisKind<'tcx> for MutBorrow<'mir, 'tcx> {\n-    const ANALYSIS_NAME: &'static str = \"maybe_mut_borrowed_locals\";\n-\n-    fn in_ref(&self, kind: mir::BorrowKind, place: Place<'tcx>) -> bool {\n-        match kind {\n-            mir::BorrowKind::Mut { .. } => true,\n-            mir::BorrowKind::Shared | mir::BorrowKind::Shallow | mir::BorrowKind::Unique => {\n-                self.shared_borrow_allows_mutation(place)\n-            }\n-        }\n-    }\n-\n-    fn in_address_of(&self, mt: Mutability, place: Place<'tcx>) -> bool {\n-        match mt {\n-            Mutability::Mut => true,\n-            Mutability::Not => self.shared_borrow_allows_mutation(place),\n-        }\n-    }\n-}"}, {"sha": "91dddc6cd55c5d415b76548051dd488b0774bb4a", "filename": "compiler/rustc_mir_dataflow/src/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b285e0c5d828d958ac22efa1e82648b178d1cbd5/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285e0c5d828d958ac22efa1e82648b178d1cbd5/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs?ref=b285e0c5d828d958ac22efa1e82648b178d1cbd5", "patch": "@@ -22,7 +22,7 @@ mod init_locals;\n mod liveness;\n mod storage_liveness;\n \n-pub use self::borrowed_locals::{MaybeBorrowedLocals, MaybeMutBorrowedLocals};\n+pub use self::borrowed_locals::MaybeBorrowedLocals;\n pub use self::init_locals::MaybeInitializedLocals;\n pub use self::liveness::MaybeLiveLocals;\n pub use self::storage_liveness::{MaybeRequiresStorage, MaybeStorageLive};"}, {"sha": "28e5d76783aa4015cb8af5bc2cce5b2a618cf584", "filename": "compiler/rustc_mir_dataflow/src/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b285e0c5d828d958ac22efa1e82648b178d1cbd5/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285e0c5d828d958ac22efa1e82648b178d1cbd5/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs?ref=b285e0c5d828d958ac22efa1e82648b178d1cbd5", "patch": "@@ -11,8 +11,7 @@ use rustc_middle::mir::{self, Body, Local, Location};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n use crate::impls::{\n-    DefinitelyInitializedPlaces, MaybeInitializedPlaces, MaybeLiveLocals, MaybeMutBorrowedLocals,\n-    MaybeUninitializedPlaces,\n+    DefinitelyInitializedPlaces, MaybeInitializedPlaces, MaybeLiveLocals, MaybeUninitializedPlaces,\n };\n use crate::move_paths::{HasMoveData, MoveData};\n use crate::move_paths::{LookupResult, MovePathIndex};\n@@ -62,14 +61,6 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n             sanity_check_via_rustc_peek(tcx, body, &attributes, &flow_def_inits);\n         }\n \n-        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_indirectly_mutable).is_some() {\n-            let flow_mut_borrowed = MaybeMutBorrowedLocals::mut_borrows_only(tcx, body, param_env)\n-                .into_engine(tcx, body)\n-                .iterate_to_fixpoint();\n-\n-            sanity_check_via_rustc_peek(tcx, body, &attributes, &flow_mut_borrowed);\n-        }\n-\n         if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_liveness).is_some() {\n             let flow_liveness = MaybeLiveLocals.into_engine(tcx, body).iterate_to_fixpoint();\n \n@@ -281,26 +272,6 @@ where\n     }\n }\n \n-impl<'tcx> RustcPeekAt<'tcx> for MaybeMutBorrowedLocals<'_, 'tcx> {\n-    fn peek_at(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        place: mir::Place<'tcx>,\n-        flow_state: &BitSet<Local>,\n-        call: PeekCall,\n-    ) {\n-        info!(?place, \"peek_at\");\n-        let Some(local) = place.as_local() else {\n-            tcx.sess.span_err(call.span, \"rustc_peek: argument was not a local\");\n-            return;\n-        };\n-\n-        if !flow_state.contains(local) {\n-            tcx.sess.span_err(call.span, \"rustc_peek: bit not set\");\n-        }\n-    }\n-}\n-\n impl<'tcx> RustcPeekAt<'tcx> for MaybeLiveLocals {\n     fn peek_at(\n         &self,"}, {"sha": "52e2a8f48e23be3f62f4f419d1ba34e7359c5b82", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b285e0c5d828d958ac22efa1e82648b178d1cbd5/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285e0c5d828d958ac22efa1e82648b178d1cbd5/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=b285e0c5d828d958ac22efa1e82648b178d1cbd5", "patch": "@@ -1128,7 +1128,6 @@ symbols! {\n         rustc_partition_reused,\n         rustc_peek,\n         rustc_peek_definite_init,\n-        rustc_peek_indirectly_mutable,\n         rustc_peek_liveness,\n         rustc_peek_maybe_init,\n         rustc_peek_maybe_uninit,"}, {"sha": "374a9f75a134b68036aadf51d1d86d8beece9480", "filename": "src/test/ui/mir-dataflow/indirect-mutation-offset.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/473eaa42e9365c47d129f72693b5d163a20cf369/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473eaa42e9365c47d129f72693b5d163a20cf369/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs?ref=473eaa42e9365c47d129f72693b5d163a20cf369", "patch": "@@ -1,48 +0,0 @@\n-// compile-flags: -Zunleash-the-miri-inside-of-you\n-\n-// This test demonstrates a shortcoming of the `MaybeMutBorrowedLocals` analysis. It does not\n-// handle code that takes a reference to one field of a struct, then use pointer arithmetic to\n-// transform it to another field of that same struct that may have interior mutability. For now,\n-// this is UB, but this may change in the future. See [rust-lang/unsafe-code-guidelines#134].\n-//\n-// [rust-lang/unsafe-code-guidelines#134]: https://github.com/rust-lang/unsafe-code-guidelines/issues/134\n-\n-#![feature(core_intrinsics, rustc_attrs, const_raw_ptr_deref)]\n-\n-use std::cell::UnsafeCell;\n-use std::intrinsics::rustc_peek;\n-\n-#[repr(C)]\n-struct PartialInteriorMut {\n-    zst: [i32; 0],\n-    cell: UnsafeCell<i32>,\n-}\n-\n-#[rustc_mir(rustc_peek_indirectly_mutable,stop_after_dataflow)]\n-const BOO: i32 = {\n-    let x = PartialInteriorMut {\n-        zst: [],\n-        cell: UnsafeCell::new(0),\n-    };\n-\n-    let p_zst: *const _ = &x.zst ; // Doesn't cause `x` to get marked as indirectly mutable.\n-\n-    let rmut_cell = unsafe {\n-        // Take advantage of the fact that `zst` and `cell` are at the same location in memory.\n-        // This trick would work with any size type if miri implemented `ptr::offset`.\n-        let p_cell = p_zst as *const UnsafeCell<i32>;\n-\n-        let pmut_cell = (*p_cell).get();\n-        &mut *pmut_cell\n-    };\n-\n-    *rmut_cell = 42;  // Mutates `x` indirectly even though `x` is not marked indirectly mutable!!!\n-    let val = *rmut_cell;\n-    rustc_peek(x); //~ ERROR rustc_peek: bit not set\n-\n-    val\n-};\n-\n-fn main() {\n-    println!(\"{}\", BOO);\n-}"}, {"sha": "1d5287c15ab7994983d160f6764fa9b3872b5ab7", "filename": "src/test/ui/mir-dataflow/indirect-mutation-offset.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/473eaa42e9365c47d129f72693b5d163a20cf369/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/473eaa42e9365c47d129f72693b5d163a20cf369/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr?ref=473eaa42e9365c47d129f72693b5d163a20cf369", "patch": "@@ -1,10 +0,0 @@\n-error: rustc_peek: bit not set\n-  --> $DIR/indirect-mutation-offset.rs:41:5\n-   |\n-LL |     rustc_peek(x);\n-   |     ^^^^^^^^^^^^^\n-\n-error: stop_after_dataflow ended compilation\n-\n-error: aborting due to 2 previous errors\n-"}]}