{"sha": "ca54ff22f28db3ce2463fa13651624967c392cae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhNTRmZjIyZjI4ZGIzY2UyNDYzZmExMzY1MTYyNDk2N2MzOTJjYWU=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-22T09:51:20Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-22T14:43:31Z"}, "message": "Rollup merge of #49029 - GuillaumeGomez:atomic-docs, r=QuietMisdreavus\n\nMake Atomic doc examples specific to each type\n\nFixes #49018.\n\nr? @QuietMisdreavus", "tree": {"sha": "2d1598b74018a7c6c8cc3245670fd937df872b58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d1598b74018a7c6c8cc3245670fd937df872b58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca54ff22f28db3ce2463fa13651624967c392cae", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlqzwRQACgkQ/vbIBR0O\nATyyBw//cVChACnopZTn4A0pBtlpLUQvKPkK/oj3xKTHE5224FeQ6z2cYVR6o+eJ\njpgysQLRNvc/Z406eqOVDtjSEyKum7tjYqqFQhMeZhumQJLDr+G0cjy5chrJ7VMc\nn75FJmUdBaFJlpE6cjc4cIE098evvy4B37dvAlFHci6OMY7BGY9HuP/QRj+ogSbV\nnNJHylFmTM3GxXy++pVzzs81LQ0x+OFuO0EuyYZ8rOq9ba+f7RCyJcmZfZjwwkxK\nI7KrwNQ3sl1hUYxUIN3bIClBh40eAIKhkTjn6or+kM5FFBFH0/Nkc9Gob5YsakTg\n0aytByBuDKMLmLeDFwV6mrAR+Hg2TEiUYM5OW80n/vGHajR46dpeQsWsugSOdchW\ncAXmgSKMQSSGt9q+fBvFoZ56D3z4sDXBn02vo9naGKGo5HHRC1BTL7Xt9E6+VP0C\noBjyfoEHEU9+ZE97oxJtpDxyJEYQrhuzYUgg8hBHQgftG4VC3jZrzjfcVbzQaRu1\ntcThW5p+SLt0FihFwRKh2vfG0yRIrqpEUKNwlOQkw8jGcai715A0yymM9WGrvmxf\nWhj2tXTSo5Xiwa1QTwKqElVdgKMk2sB0oi/3HUHfEfgBje54RFSkOpwJGb6KuFqv\nzCfHSmI8gkSTtWYymCmF5EVl1BkKInhIDLdUB8q9k+RVocfIL14=\n=hZZm\n-----END PGP SIGNATURE-----", "payload": "tree 2d1598b74018a7c6c8cc3245670fd937df872b58\nparent b7ee149c474ee1a9c458a80f67dbb3d783b64265\nparent 2b64799365a43bf8685cb9750d9e887c006c1f22\nauthor kennytm <kennytm@gmail.com> 1521712280 +0800\ncommitter kennytm <kennytm@gmail.com> 1521729811 +0800\n\nRollup merge of #49029 - GuillaumeGomez:atomic-docs, r=QuietMisdreavus\n\nMake Atomic doc examples specific to each type\n\nFixes #49018.\n\nr? @QuietMisdreavus\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca54ff22f28db3ce2463fa13651624967c392cae", "html_url": "https://github.com/rust-lang/rust/commit/ca54ff22f28db3ce2463fa13651624967c392cae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca54ff22f28db3ce2463fa13651624967c392cae/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7ee149c474ee1a9c458a80f67dbb3d783b64265", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7ee149c474ee1a9c458a80f67dbb3d783b64265", "html_url": "https://github.com/rust-lang/rust/commit/b7ee149c474ee1a9c458a80f67dbb3d783b64265"}, {"sha": "2b64799365a43bf8685cb9750d9e887c006c1f22", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b64799365a43bf8685cb9750d9e887c006c1f22", "html_url": "https://github.com/rust-lang/rust/commit/2b64799365a43bf8685cb9750d9e887c006c1f22"}], "stats": {"total": 765, "additions": 401, "deletions": 364}, "files": [{"sha": "fe5ed5d49422439147d860657366c6d16b061cd8", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 401, "deletions": 364, "changes": 765, "blob_url": "https://github.com/rust-lang/rust/blob/ca54ff22f28db3ce2463fa13651624967c392cae/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca54ff22f28db3ce2463fa13651624967c392cae/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=ca54ff22f28db3ce2463fa13651624967c392cae", "patch": "@@ -948,6 +948,7 @@ macro_rules! atomic_int {\n      $stable_from:meta,\n      $stable_nand:meta,\n      $s_int_type:expr, $int_ref:expr,\n+     $extra_feature:expr,\n      $int_type:ident $atomic_type:ident $atomic_init:ident) => {\n         /// An integer type which can be safely shared between threads.\n         ///\n@@ -959,12 +960,7 @@ macro_rules! atomic_int {\n         /// ). For more about the differences between atomic types and\n         /// non-atomic types, please see the [module-level documentation].\n         ///\n-        /// Please note that examples are shared between atomic variants of\n-        /// primitive integer types, so it's normal that they are all\n-        /// demonstrating [`AtomicIsize`].\n-        ///\n         /// [module-level documentation]: index.html\n-        /// [`AtomicIsize`]: struct.AtomicIsize.html\n         #[$stable]\n         pub struct $atomic_type {\n             v: UnsafeCell<$int_type>,\n@@ -1001,395 +997,426 @@ macro_rules! atomic_int {\n         unsafe impl Sync for $atomic_type {}\n \n         impl $atomic_type {\n-            /// Creates a new atomic integer.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::AtomicIsize;\n-            ///\n-            /// let atomic_forty_two  = AtomicIsize::new(42);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub const fn new(v: $int_type) -> Self {\n-                $atomic_type {v: UnsafeCell::new(v)}\n+            doc_comment! {\n+                concat!(\"Creates a new atomic integer.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\n+\n+let atomic_forty_two = \", stringify!($atomic_type), \"::new(42);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub const fn new(v: $int_type) -> Self {\n+                    $atomic_type {v: UnsafeCell::new(v)}\n+                }\n             }\n \n-            /// Returns a mutable reference to the underlying integer.\n-            ///\n-            /// This is safe because the mutable reference guarantees that no other threads are\n-            /// concurrently accessing the atomic data.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let mut some_isize = AtomicIsize::new(10);\n-            /// assert_eq!(*some_isize.get_mut(), 10);\n-            /// *some_isize.get_mut() = 5;\n-            /// assert_eq!(some_isize.load(Ordering::SeqCst), 5);\n-            /// ```\n-            #[inline]\n-            #[$stable_access]\n-            pub fn get_mut(&mut self) -> &mut $int_type {\n-                unsafe { &mut *self.v.get() }\n+            doc_comment! {\n+                concat!(\"Returns a mutable reference to the underlying integer.\n+\n+This is safe because the mutable reference guarantees that no other threads are\n+concurrently accessing the atomic data.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let mut some_var = \", stringify!($atomic_type), \"::new(10);\n+assert_eq!(*some_var.get_mut(), 10);\n+*some_var.get_mut() = 5;\n+assert_eq!(some_var.load(Ordering::SeqCst), 5);\n+```\"),\n+                #[inline]\n+                #[$stable_access]\n+                pub fn get_mut(&mut self) -> &mut $int_type {\n+                    unsafe { &mut *self.v.get() }\n+                }\n             }\n \n-            /// Consumes the atomic and returns the contained value.\n-            ///\n-            /// This is safe because passing `self` by value guarantees that no other threads are\n-            /// concurrently accessing the atomic data.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::AtomicIsize;\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            /// assert_eq!(some_isize.into_inner(), 5);\n-            /// ```\n-            #[inline]\n-            #[$stable_access]\n-            pub fn into_inner(self) -> $int_type {\n-                self.v.into_inner()\n+            doc_comment! {\n+                concat!(\"Consumes the atomic and returns the contained value.\n+\n+This is safe because passing `self` by value guarantees that no other threads are\n+concurrently accessing the atomic data.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+assert_eq!(some_var.into_inner(), 5);\n+```\"),\n+                #[inline]\n+                #[$stable_access]\n+                pub fn into_inner(self) -> $int_type {\n+                    self.v.into_inner()\n+                }\n             }\n \n-            /// Loads a value from the atomic integer.\n-            ///\n-            /// `load` takes an [`Ordering`] argument which describes the memory ordering of this\n-            /// operation.\n-            ///\n-            /// # Panics\n-            ///\n-            /// Panics if `order` is [`Release`] or [`AcqRel`].\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            /// [`Release`]: enum.Ordering.html#variant.Release\n-            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 5);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn load(&self, order: Ordering) -> $int_type {\n-                unsafe { atomic_load(self.v.get(), order) }\n+            doc_comment! {\n+                concat!(\"Loads a value from the atomic integer.\n+\n+`load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+\n+# Panics\n+\n+Panics if `order` is [`Release`] or [`AcqRel`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+assert_eq!(some_var.load(Ordering::Relaxed), 5);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn load(&self, order: Ordering) -> $int_type {\n+                    unsafe { atomic_load(self.v.get(), order) }\n+                }\n             }\n \n-            /// Stores a value into the atomic integer.\n-            ///\n-            /// `store` takes an [`Ordering`] argument which describes the memory ordering of this\n-            /// operation.\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// some_isize.store(10, Ordering::Relaxed);\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            /// ```\n-            ///\n-            /// # Panics\n-            ///\n-            /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n-            ///\n-            /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-            #[inline]\n-            #[$stable]\n-            pub fn store(&self, val: $int_type, order: Ordering) {\n-                unsafe { atomic_store(self.v.get(), val, order); }\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer.\n+\n+`store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+\n+[`Ordering`]: enum.Ordering.html\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+some_var.store(10, Ordering::Relaxed);\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+```\n+\n+# Panics\n+\n+Panics if `order` is [`Acquire`] or [`AcqRel`].\n+\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn store(&self, val: $int_type, order: Ordering) {\n+                    unsafe { atomic_store(self.v.get(), val, order); }\n+                }\n             }\n \n-            /// Stores a value into the atomic integer, returning the previous value.\n-            ///\n-            /// `swap` takes an [`Ordering`] argument which describes the memory ordering of this\n-            /// operation.\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// assert_eq!(some_isize.swap(10, Ordering::Relaxed), 5);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_swap(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer, returning the previous value.\n+\n+`swap` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+\n+[`Ordering`]: enum.Ordering.html\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_swap(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Stores a value into the atomic integer if the current value is the same as the\n-            /// `current` value.\n-            ///\n-            /// The return value is always the previous value. If it is equal to `current`, then the\n-            /// value was updated.\n-            ///\n-            /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n-            /// ordering of this operation.\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// assert_eq!(some_isize.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            ///\n-            /// assert_eq!(some_isize.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn compare_and_swap(&self,\n-                                    current: $int_type,\n-                                    new: $int_type,\n-                                    order: Ordering) -> $int_type {\n-                match self.compare_exchange(current,\n-                                            new,\n-                                            order,\n-                                            strongest_failure_ordering(order)) {\n-                    Ok(x) => x,\n-                    Err(x) => x,\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer if the current value is the same as\n+the `current` value.\n+\n+The return value is always the previous value. If it is equal to `current`, then the\n+value was updated.\n+\n+`compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n+ordering of this operation.\n+\n+[`Ordering`]: enum.Ordering.html\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+assert_eq!(some_var.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+\n+assert_eq!(some_var.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn compare_and_swap(&self,\n+                                        current: $int_type,\n+                                        new: $int_type,\n+                                        order: Ordering) -> $int_type {\n+                    match self.compare_exchange(current,\n+                                                new,\n+                                                order,\n+                                                strongest_failure_ordering(order)) {\n+                        Ok(x) => x,\n+                        Err(x) => x,\n+                    }\n                 }\n             }\n \n-            /// Stores a value into the atomic integer if the current value is the same as the\n-            /// `current` value.\n-            ///\n-            /// The return value is a result indicating whether the new value was written and\n-            /// containing the previous value. On success this value is guaranteed to be equal to\n-            /// `current`.\n-            ///\n-            /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n-            /// ordering of this operation. The first describes the required ordering if\n-            /// the operation succeeds while the second describes the required ordering when\n-            /// the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n-            /// must be equivalent or weaker than the success ordering.\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            /// [`Release`]: enum.Ordering.html#variant.Release\n-            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// assert_eq!(some_isize.compare_exchange(5, 10,\n-            ///                                        Ordering::Acquire,\n-            ///                                        Ordering::Relaxed),\n-            ///            Ok(5));\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            ///\n-            /// assert_eq!(some_isize.compare_exchange(6, 12,\n-            ///                                        Ordering::SeqCst,\n-            ///                                        Ordering::Acquire),\n-            ///            Err(10));\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            /// ```\n-            #[inline]\n-            #[$stable_cxchg]\n-            pub fn compare_exchange(&self,\n-                                    current: $int_type,\n-                                    new: $int_type,\n-                                    success: Ordering,\n-                                    failure: Ordering) -> Result<$int_type, $int_type> {\n-                unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer if the current value is the same as\n+the `current` value.\n+\n+The return value is a result indicating whether the new value was written and\n+containing the previous value. On success this value is guaranteed to be equal to\n+`current`.\n+\n+`compare_exchange` takes two [`Ordering`] arguments to describe the memory\n+ordering of this operation. The first describes the required ordering if\n+the operation succeeds while the second describes the required ordering when\n+the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n+must be equivalent or weaker than the success ordering.\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+assert_eq!(some_var.compare_exchange(5, 10,\n+                                     Ordering::Acquire,\n+                                     Ordering::Relaxed),\n+           Ok(5));\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+\n+assert_eq!(some_var.compare_exchange(6, 12,\n+                                     Ordering::SeqCst,\n+                                     Ordering::Acquire),\n+           Err(10));\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+```\"),\n+                #[inline]\n+                #[$stable_cxchg]\n+                pub fn compare_exchange(&self,\n+                                        current: $int_type,\n+                                        new: $int_type,\n+                                        success: Ordering,\n+                                        failure: Ordering) -> Result<$int_type, $int_type> {\n+                    unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n+                }\n             }\n \n-            /// Stores a value into the atomic integer if the current value is the same as the\n-            /// `current` value.\n-            ///\n-            /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even\n-            /// when the comparison succeeds, which can result in more efficient code on some\n-            /// platforms. The return value is a result indicating whether the new value was\n-            /// written and containing the previous value.\n-            ///\n-            /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n-            /// ordering of this operation. The first describes the required ordering if the\n-            /// operation succeeds while the second describes the required ordering when the\n-            /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n-            /// must be equivalent or weaker than the success ordering.\n-            ///\n-            /// [`compare_exchange`]: #method.compare_exchange\n-            /// [`Ordering`]: enum.Ordering.html\n-            /// [`Release`]: enum.Ordering.html#variant.Release\n-            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let val = AtomicIsize::new(4);\n-            ///\n-            /// let mut old = val.load(Ordering::Relaxed);\n-            /// loop {\n-            ///     let new = old * 2;\n-            ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n-            ///         Ok(_) => break,\n-            ///         Err(x) => old = x,\n-            ///     }\n-            /// }\n-            /// ```\n-            #[inline]\n-            #[$stable_cxchg]\n-            pub fn compare_exchange_weak(&self,\n-                                         current: $int_type,\n-                                         new: $int_type,\n-                                         success: Ordering,\n-                                         failure: Ordering) -> Result<$int_type, $int_type> {\n-                unsafe {\n-                    atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer if the current value is the same as\n+the `current` value.\n+\n+Unlike [`compare_exchange`], this function is allowed to spuriously fail even\n+when the comparison succeeds, which can result in more efficient code on some\n+platforms. The return value is a result indicating whether the new value was\n+written and containing the previous value.\n+\n+`compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n+ordering of this operation. The first describes the required ordering if the\n+operation succeeds while the second describes the required ordering when the\n+operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n+must be equivalent or weaker than the success ordering.\n+\n+[`compare_exchange`]: #method.compare_exchange\n+[`Ordering`]: enum.Ordering.html\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let val = \", stringify!($atomic_type), \"::new(4);\n+\n+let mut old = val.load(Ordering::Relaxed);\n+loop {\n+    let new = old * 2;\n+    match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n+        Ok(_) => break,\n+        Err(x) => old = x,\n+    }\n+}\n+```\"),\n+                #[inline]\n+                #[$stable_cxchg]\n+                pub fn compare_exchange_weak(&self,\n+                                             current: $int_type,\n+                                             new: $int_type,\n+                                             success: Ordering,\n+                                             failure: Ordering) -> Result<$int_type, $int_type> {\n+                    unsafe {\n+                        atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n+                    }\n                 }\n             }\n \n-            /// Adds to the current value, returning the previous value.\n-            ///\n-            /// This operation wraps around on overflow.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0);\n-            /// assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), 10);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_add(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Adds to the current value, returning the previous value.\n+\n+This operation wraps around on overflow.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0);\n+assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n+assert_eq!(foo.load(Ordering::SeqCst), 10);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_add(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Subtracts from the current value, returning the previous value.\n-            ///\n-            /// This operation wraps around on overflow.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0);\n-            /// assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 0);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), -10);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_sub(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Subtracts from the current value, returning the previous value.\n+\n+This operation wraps around on overflow.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(20);\n+assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 20);\n+assert_eq!(foo.load(Ordering::SeqCst), 10);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_sub(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Bitwise \"and\" with the current value.\n-            ///\n-            /// Performs a bitwise \"and\" operation on the current value and the argument `val`, and\n-            /// sets the new value to the result.\n-            ///\n-            /// Returns the previous value.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0b101101);\n-            /// assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_and(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Bitwise \\\"and\\\" with the current value.\n+\n+Performs a bitwise \\\"and\\\" operation on the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0b101101);\n+assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n+assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_and(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Bitwise \"nand\" with the current value.\n-            ///\n-            /// Performs a bitwise \"nand\" operation on the current value and the argument `val`, and\n-            /// sets the new value to the result.\n-            ///\n-            /// Returns the previous value.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// #![feature(atomic_nand)]\n-            ///\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0xf731);\n-            /// assert_eq!(foo.fetch_nand(0x137f, Ordering::SeqCst), 0xf731);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), !(0xf731 & 0x137f));\n-            #[inline]\n-            #[$stable_nand]\n-            pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_nand(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Bitwise \\\"nand\\\" with the current value.\n+\n+Performs a bitwise \\\"nand\\\" operation on the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"#![feature(atomic_nand)]\n+\n+use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0x13);\n+assert_eq!(foo.fetch_nand(0x31, Ordering::SeqCst), 0x13);\n+assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n+```\"),\n+                #[inline]\n+                #[$stable_nand]\n+                pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_nand(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Bitwise \"or\" with the current value.\n-            ///\n-            /// Performs a bitwise \"or\" operation on the current value and the argument `val`, and\n-            /// sets the new value to the result.\n-            ///\n-            /// Returns the previous value.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0b101101);\n-            /// assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_or(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Bitwise \\\"or\\\" with the current value.\n+\n+Performs a bitwise \\\"or\\\" operation on the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0b101101);\n+assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n+assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_or(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Bitwise \"xor\" with the current value.\n-            ///\n-            /// Performs a bitwise \"xor\" operation on the current value and the argument `val`, and\n-            /// sets the new value to the result.\n-            ///\n-            /// Returns the previous value.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0b101101);\n-            /// assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_xor(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Bitwise \\\"xor\\\" with the current value.\n+\n+Performs a bitwise \\\"xor\\\" operation on the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0b101101);\n+assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n+assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_xor(self.v.get(), val, order) }\n+                }\n             }\n         }\n     }\n@@ -1404,6 +1431,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i8\", \"../../../std/primitive.i8.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n     i8 AtomicI8 ATOMIC_I8_INIT\n }\n #[cfg(target_has_atomic = \"8\")]\n@@ -1415,6 +1443,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u8\", \"../../../std/primitive.u8.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n     u8 AtomicU8 ATOMIC_U8_INIT\n }\n #[cfg(target_has_atomic = \"16\")]\n@@ -1426,6 +1455,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i16\", \"../../../std/primitive.i16.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n     i16 AtomicI16 ATOMIC_I16_INIT\n }\n #[cfg(target_has_atomic = \"16\")]\n@@ -1437,6 +1467,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u16\", \"../../../std/primitive.u16.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n     u16 AtomicU16 ATOMIC_U16_INIT\n }\n #[cfg(target_has_atomic = \"32\")]\n@@ -1448,6 +1479,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i32\", \"../../../std/primitive.i32.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n     i32 AtomicI32 ATOMIC_I32_INIT\n }\n #[cfg(target_has_atomic = \"32\")]\n@@ -1459,6 +1491,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u32\", \"../../../std/primitive.u32.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n     u32 AtomicU32 ATOMIC_U32_INIT\n }\n #[cfg(target_has_atomic = \"64\")]\n@@ -1470,6 +1503,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i64\", \"../../../std/primitive.i64.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n     i64 AtomicI64 ATOMIC_I64_INIT\n }\n #[cfg(target_has_atomic = \"64\")]\n@@ -1481,6 +1515,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u64\", \"../../../std/primitive.u64.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n     u64 AtomicU64 ATOMIC_U64_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n@@ -1492,6 +1527,7 @@ atomic_int!{\n     stable(feature = \"atomic_from\", since = \"1.23.0\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"isize\", \"../../../std/primitive.isize.html\",\n+    \"\",\n     isize AtomicIsize ATOMIC_ISIZE_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n@@ -1503,6 +1539,7 @@ atomic_int!{\n     stable(feature = \"atomic_from\", since = \"1.23.0\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"usize\", \"../../../std/primitive.usize.html\",\n+    \"\",\n     usize AtomicUsize ATOMIC_USIZE_INIT\n }\n "}]}