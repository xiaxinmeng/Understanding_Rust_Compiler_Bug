{"sha": "dd2df8f97db8319e0eea433bfbc68244150d7bea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkMmRmOGY5N2RiODMxOWUwZWVhNDMzYmZiYzY4MjQ0MTUwZDdiZWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-25T04:24:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-25T04:24:40Z"}, "message": "Auto merge of #65793 - Centril:rollup-v40xke9, r=Centril\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #62959 (Add by-value iterator for arrays )\n - #65390 (Add long error explanation for E0576)\n - #65408 (reorder config.toml.example options and add one missing option)\n - #65414 (ignore uninhabited non-exhaustive variant fields)\n - #65666 (Deprecated proc_macro doesn't trigger warning on build library)\n - #65742 (Pre-expansion gate most of the things)\n - #65747 (Adjust the tracking issue for `untagged_unions`.)\n - #65763 (Changed APIT with explicit generic args span to specific arg spans)\n - #65775 (Fix more `ReEmpty` ICEs)\n\nFailed merges:\n\n - #65519 (trait-based structural match implementation)\n\nr? @ghost", "tree": {"sha": "c67f37c945de42d499f93dc17cc8500557f77e81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c67f37c945de42d499f93dc17cc8500557f77e81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd2df8f97db8319e0eea433bfbc68244150d7bea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd2df8f97db8319e0eea433bfbc68244150d7bea", "html_url": "https://github.com/rust-lang/rust/commit/dd2df8f97db8319e0eea433bfbc68244150d7bea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd2df8f97db8319e0eea433bfbc68244150d7bea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d54111afc061ef398cd8ce28984f9e8d70001b24", "url": "https://api.github.com/repos/rust-lang/rust/commits/d54111afc061ef398cd8ce28984f9e8d70001b24", "html_url": "https://github.com/rust-lang/rust/commit/d54111afc061ef398cd8ce28984f9e8d70001b24"}, {"sha": "100c924527f461f1fe0d9365a476455ce544c3c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/100c924527f461f1fe0d9365a476455ce544c3c7", "html_url": "https://github.com/rust-lang/rust/commit/100c924527f461f1fe0d9365a476455ce544c3c7"}], "stats": {"total": 1493, "additions": 1215, "deletions": 278}, "files": [{"sha": "e832570ed982e5f858924128358dab9bcf08140c", "filename": "config.toml.example", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -258,10 +258,9 @@\n [rust]\n \n # Whether or not to optimize the compiler and standard library.\n-#\n-# Note: the slowness of the non optimized compiler compiling itself usually\n-#       outweighs the time gains in not doing optimizations, therefore a\n-#       full bootstrap takes much more time with `optimize` set to false.\n+# WARNING: Building with optimize = false is NOT SUPPORTED. Due to bootstrapping,\n+# building without optimizations takes much longer than optimizing. Further, some platforms\n+# fail to build without this optimization (c.f. #65352).\n #optimize = true\n \n # Indicates that the build should be configured for debugging Rust. A\n@@ -341,6 +340,9 @@\n # nightly features\n #channel = \"dev\"\n \n+# The root location of the MUSL installation directory.\n+#musl-root = \"...\"\n+\n # By default the `rustc` executable is built with `-Wl,-rpath` flags on Unix\n # platforms to ensure that the compiler is usable by default from the build\n # directory (as it links to a number of dynamic libraries). This may not be"}, {"sha": "d1bdfa0a7676309ccd0209ea4ac8bd8397f358de", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -200,23 +200,23 @@ struct Build {\n     target: Vec<String>,\n     cargo: Option<String>,\n     rustc: Option<String>,\n-    low_priority: Option<bool>,\n-    compiler_docs: Option<bool>,\n     docs: Option<bool>,\n+    compiler_docs: Option<bool>,\n     submodules: Option<bool>,\n     fast_submodules: Option<bool>,\n     gdb: Option<String>,\n-    locked_deps: Option<bool>,\n-    vendor: Option<bool>,\n     nodejs: Option<String>,\n     python: Option<String>,\n+    locked_deps: Option<bool>,\n+    vendor: Option<bool>,\n     full_bootstrap: Option<bool>,\n     extended: Option<bool>,\n     tools: Option<HashSet<String>>,\n     verbose: Option<usize>,\n     sanitizers: Option<bool>,\n     profiler: Option<bool>,\n     cargo_native_static: Option<bool>,\n+    low_priority: Option<bool>,\n     configure_args: Option<Vec<String>>,\n     local_rebuild: Option<bool>,\n     print_step_timings: Option<bool>,\n@@ -228,11 +228,11 @@ struct Build {\n struct Install {\n     prefix: Option<String>,\n     sysconfdir: Option<String>,\n-    datadir: Option<String>,\n     docdir: Option<String>,\n     bindir: Option<String>,\n     libdir: Option<String>,\n     mandir: Option<String>,\n+    datadir: Option<String>,\n \n     // standard paths, currently unused\n     infodir: Option<String>,\n@@ -243,14 +243,14 @@ struct Install {\n #[derive(Deserialize, Default)]\n #[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n struct Llvm {\n-    ccache: Option<StringOrBool>,\n-    ninja: Option<bool>,\n-    assertions: Option<bool>,\n     optimize: Option<bool>,\n     thin_lto: Option<bool>,\n     release_debuginfo: Option<bool>,\n+    assertions: Option<bool>,\n+    ccache: Option<StringOrBool>,\n     version_check: Option<bool>,\n     static_libstdcpp: Option<bool>,\n+    ninja: Option<bool>,\n     targets: Option<String>,\n     experimental_targets: Option<String>,\n     link_jobs: Option<u32>,\n@@ -293,6 +293,7 @@ impl Default for StringOrBool {\n #[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n struct Rust {\n     optimize: Option<bool>,\n+    debug: Option<bool>,\n     codegen_units: Option<u32>,\n     codegen_units_std: Option<u32>,\n     debug_assertions: Option<bool>,\n@@ -301,25 +302,24 @@ struct Rust {\n     debuginfo_level_std: Option<u32>,\n     debuginfo_level_tools: Option<u32>,\n     debuginfo_level_tests: Option<u32>,\n-    parallel_compiler: Option<bool>,\n     backtrace: Option<bool>,\n+    incremental: Option<bool>,\n+    parallel_compiler: Option<bool>,\n     default_linker: Option<String>,\n     channel: Option<String>,\n     musl_root: Option<String>,\n     rpath: Option<bool>,\n+    verbose_tests: Option<bool>,\n     optimize_tests: Option<bool>,\n     codegen_tests: Option<bool>,\n     ignore_git: Option<bool>,\n-    debug: Option<bool>,\n     dist_src: Option<bool>,\n-    verbose_tests: Option<bool>,\n-    incremental: Option<bool>,\n     save_toolstates: Option<String>,\n     codegen_backends: Option<Vec<String>>,\n     codegen_backends_dir: Option<String>,\n     lld: Option<bool>,\n-    lldb: Option<bool>,\n     llvm_tools: Option<bool>,\n+    lldb: Option<bool>,\n     deny_warnings: Option<bool>,\n     backtrace_on_ice: Option<bool>,\n     verify_llvm_ir: Option<bool>,\n@@ -333,13 +333,13 @@ struct Rust {\n #[derive(Deserialize, Default)]\n #[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n struct TomlTarget {\n-    llvm_config: Option<String>,\n-    llvm_filecheck: Option<String>,\n     cc: Option<String>,\n     cxx: Option<String>,\n     ar: Option<String>,\n     ranlib: Option<String>,\n     linker: Option<String>,\n+    llvm_config: Option<String>,\n+    llvm_filecheck: Option<String>,\n     android_ndk: Option<String>,\n     crt_static: Option<bool>,\n     musl_root: Option<String>,"}, {"sha": "850a599c6599f46de6858786e3335d87ce30f04e", "filename": "src/libcore/array/iter.rs", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibcore%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibcore%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fiter.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -0,0 +1,266 @@\n+//! Defines the `IntoIter` owned iterator for arrays.\n+\n+use crate::{\n+    fmt,\n+    iter::{ExactSizeIterator, FusedIterator, TrustedLen},\n+    mem::{self, MaybeUninit},\n+    ops::Range,\n+    ptr,\n+};\n+use super::LengthAtMost32;\n+\n+\n+/// A by-value [array] iterator.\n+///\n+/// [array]: ../../std/primitive.array.html\n+#[unstable(feature = \"array_value_iter\", issue = \"0\")]\n+pub struct IntoIter<T, const N: usize>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    /// This is the array we are iterating over.\n+    ///\n+    /// Elements with index `i` where `alive.start <= i < alive.end` have not\n+    /// been yielded yet and are valid array entries. Elements with indices `i\n+    /// < alive.start` or `i >= alive.end` have been yielded already and must\n+    /// not be accessed anymore! Those dead elements might even be in a\n+    /// completely uninitialized state!\n+    ///\n+    /// So the invariants are:\n+    /// - `data[alive]` is alive (i.e. contains valid elements)\n+    /// - `data[..alive.start]` and `data[alive.end..]` are dead (i.e. the\n+    ///   elements were already read and must not be touched anymore!)\n+    data: [MaybeUninit<T>; N],\n+\n+    /// The elements in `data` that have not been yielded yet.\n+    ///\n+    /// Invariants:\n+    /// - `alive.start <= alive.end`\n+    /// - `alive.end <= N`\n+    alive: Range<usize>,\n+}\n+\n+impl<T, const N: usize> IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    /// Creates a new iterator over the given `array`.\n+    ///\n+    /// *Note*: this method might never get stabilized and/or removed in the\n+    /// future as there will likely be another, preferred way of obtaining this\n+    /// iterator (either via `IntoIterator` for arrays or via another way).\n+    #[unstable(feature = \"array_value_iter\", issue = \"0\")]\n+    pub fn new(array: [T; N]) -> Self {\n+        // The transmute here is actually safe. The docs of `MaybeUninit`\n+        // promise:\n+        //\n+        // > `MaybeUninit<T>` is guaranteed to have the same size and alignment\n+        // > as `T`.\n+        //\n+        // The docs even show a transmute from an array of `MaybeUninit<T>` to\n+        // an array of `T`.\n+        //\n+        // With that, this initialization satisfies the invariants.\n+\n+        // FIXME(LukasKalbertodt): actually use `mem::transmute` here, once it\n+        // works with const generics:\n+        //     `mem::transmute::<[T; {N}], [MaybeUninit<T>; {N}]>(array)`\n+        //\n+        // Until then, we do it manually here. We first create a bitwise copy\n+        // but cast the pointer so that it is treated as a different type. Then\n+        // we forget `array` so that it is not dropped.\n+        let data = unsafe {\n+            let data = ptr::read(&array as *const [T; N] as *const [MaybeUninit<T>; N]);\n+            mem::forget(array);\n+            data\n+        };\n+\n+        Self {\n+            data,\n+            alive: 0..N,\n+        }\n+    }\n+\n+    /// Returns an immutable slice of all elements that have not been yielded\n+    /// yet.\n+    fn as_slice(&self) -> &[T] {\n+        // This transmute is safe. As mentioned in `new`, `MaybeUninit` retains\n+        // the size and alignment of `T`. Furthermore, we know that all\n+        // elements within `alive` are properly initialized.\n+        let slice = &self.data[self.alive.clone()];\n+        unsafe {\n+            mem::transmute::<&[MaybeUninit<T>], &[T]>(slice)\n+        }\n+    }\n+}\n+\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T, const N: usize> Iterator for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Item = T;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.alive.start == self.alive.end {\n+            return None;\n+        }\n+\n+        // Bump start index.\n+        //\n+        // From the check above we know that `alive.start != alive.end`.\n+        // Combine this with the invariant `alive.start <= alive.end`, we know\n+        // that `alive.start < alive.end`. Increasing `alive.start` by 1\n+        // maintains the invariant regarding `alive`. However, due to this\n+        // change, for a short time, the alive zone is not `data[alive]`\n+        // anymore, but `data[idx..alive.end]`.\n+        let idx = self.alive.start;\n+        self.alive.start += 1;\n+\n+        // Read the element from the array. This is safe: `idx` is an index\n+        // into the \"alive\" region of the array. Reading this element means\n+        // that `data[idx]` is regarded as dead now (i.e. do not touch). As\n+        // `idx` was the start of the alive-zone, the alive zone is now\n+        // `data[alive]` again, restoring all invariants.\n+        let out = unsafe { self.data.get_unchecked(idx).read() };\n+\n+        Some(out)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = self.len();\n+        (len, Some(len))\n+    }\n+\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.alive.start == self.alive.end {\n+            return None;\n+        }\n+\n+        // Decrease end index.\n+        //\n+        // From the check above we know that `alive.start != alive.end`.\n+        // Combine this with the invariant `alive.start <= alive.end`, we know\n+        // that `alive.start < alive.end`. As `alive.start` cannot be negative,\n+        // `alive.end` is at least 1, meaning that we can safely decrement it\n+        // by one. This also maintains the invariant `alive.start <=\n+        // alive.end`. However, due to this change, for a short time, the alive\n+        // zone is not `data[alive]` anymore, but `data[alive.start..alive.end\n+        // + 1]`.\n+        self.alive.end -= 1;\n+\n+        // Read the element from the array. This is safe: `alive.end` is an\n+        // index into the \"alive\" region of the array. Compare the previous\n+        // comment that states that the alive region is\n+        // `data[alive.start..alive.end + 1]`. Reading this element means that\n+        // `data[alive.end]` is regarded as dead now (i.e. do not touch). As\n+        // `alive.end` was the end of the alive-zone, the alive zone is now\n+        // `data[alive]` again, restoring all invariants.\n+        let out = unsafe { self.data.get_unchecked(self.alive.end).read() };\n+\n+        Some(out)\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T, const N: usize> Drop for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn drop(&mut self) {\n+        // We simply drop each element via `for_each`. This should not incur\n+        // any significant runtime overhead and avoids adding another `unsafe`\n+        // block.\n+        self.by_ref().for_each(drop);\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T, const N: usize> ExactSizeIterator for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn len(&self) -> usize {\n+        // Will never underflow due to the invariant `alive.start <=\n+        // alive.end`.\n+        self.alive.end - self.alive.start\n+    }\n+    fn is_empty(&self) -> bool {\n+        self.alive.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T, const N: usize> FusedIterator for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{}\n+\n+// The iterator indeed reports the correct length. The number of \"alive\"\n+// elements (that will still be yielded) is the length of the range `alive`.\n+// This range is decremented in length in either `next` or `next_back`. It is\n+// always decremented by 1 in those methods, but only if `Some(_)` is returned.\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+unsafe impl<T, const N: usize> TrustedLen for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T: Clone, const N: usize> Clone for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn clone(&self) -> Self {\n+        unsafe {\n+            // This creates a new uninitialized array. Note that the `assume_init`\n+            // refers to the array, not the individual elements. And it is Ok if\n+            // the array is in an uninitialized state as all elements may be\n+            // uninitialized (all bit patterns are valid). Compare the\n+            // `MaybeUninit` docs for more information.\n+            let mut new_data: [MaybeUninit<T>; N] = MaybeUninit::uninit().assume_init();\n+\n+            // Clone all alive elements.\n+            for idx in self.alive.clone() {\n+                // The element at `idx` in the old array is alive, so we can\n+                // safely call `get_ref()`. We then clone it, and write the\n+                // clone into the new array.\n+                let clone = self.data.get_unchecked(idx).get_ref().clone();\n+                new_data.get_unchecked_mut(idx).write(clone);\n+            }\n+\n+            Self {\n+                data: new_data,\n+                alive: self.alive.clone(),\n+            }\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T: fmt::Debug, const N: usize> fmt::Debug for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Only print the elements that were not yielded yet: we cannot\n+        // access the yielded elements anymore.\n+        f.debug_tuple(\"IntoIter\")\n+            .field(&self.as_slice())\n+            .finish()\n+    }\n+}"}, {"sha": "120658e9a4343caee366b45152b44c52c8663986", "filename": "src/libcore/array/mod.rs", "status": "renamed", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibcore%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibcore%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fmod.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -14,6 +14,13 @@ use crate::hash::{Hash, self};\n use crate::marker::Unsize;\n use crate::slice::{Iter, IterMut};\n \n+#[cfg(not(bootstrap))]\n+mod iter;\n+\n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"array_value_iter\", issue = \"0\")]\n+pub use iter::IntoIter;\n+\n /// Utility trait implemented only on arrays of fixed size\n ///\n /// This trait can be used to implement other traits on fixed-size arrays", "previous_filename": "src/libcore/array.rs"}, {"sha": "4f3b79c78b66c58d6d604800134a9173af9b1df5", "filename": "src/libcore/tests/array.rs", "status": "modified", "additions": 206, "deletions": 1, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Farray.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,4 +1,4 @@\n-use core::array::FixedSizeArray;\n+use core::array::{FixedSizeArray, IntoIter};\n use core::convert::TryFrom;\n \n #[test]\n@@ -40,3 +40,208 @@ fn array_try_from() {\n         30 31 32\n     }\n }\n+\n+\n+#[test]\n+fn iterator_collect() {\n+    let arr = [0, 1, 2, 5, 9];\n+    let v: Vec<_> = IntoIter::new(arr.clone()).collect();\n+    assert_eq!(&arr[..], &v[..]);\n+}\n+\n+#[test]\n+fn iterator_rev_collect() {\n+    let arr = [0, 1, 2, 5, 9];\n+    let v: Vec<_> = IntoIter::new(arr.clone()).rev().collect();\n+    assert_eq!(&v[..], &[9, 5, 2, 1, 0]);\n+}\n+\n+#[test]\n+fn iterator_nth() {\n+    let v = [0, 1, 2, 3, 4];\n+    for i in 0..v.len() {\n+        assert_eq!(IntoIter::new(v.clone()).nth(i).unwrap(), v[i]);\n+    }\n+    assert_eq!(IntoIter::new(v.clone()).nth(v.len()), None);\n+\n+    let mut iter = IntoIter::new(v);\n+    assert_eq!(iter.nth(2).unwrap(), v[2]);\n+    assert_eq!(iter.nth(1).unwrap(), v[4]);\n+}\n+\n+#[test]\n+fn iterator_last() {\n+    let v = [0, 1, 2, 3, 4];\n+    assert_eq!(IntoIter::new(v).last().unwrap(), 4);\n+    assert_eq!(IntoIter::new([0]).last().unwrap(), 0);\n+\n+    let mut it = IntoIter::new([0, 9, 2, 4]);\n+    assert_eq!(it.next_back(), Some(4));\n+    assert_eq!(it.last(), Some(2));\n+}\n+\n+#[test]\n+fn iterator_clone() {\n+    let mut it = IntoIter::new([0, 2, 4, 6, 8]);\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n+    let mut clone = it.clone();\n+    assert_eq!(it.next_back(), Some(6));\n+    assert_eq!(clone.next_back(), Some(6));\n+    assert_eq!(it.next_back(), Some(4));\n+    assert_eq!(clone.next_back(), Some(4));\n+    assert_eq!(it.next(), Some(2));\n+    assert_eq!(clone.next(), Some(2));\n+}\n+\n+#[test]\n+fn iterator_fused() {\n+    let mut it = IntoIter::new([0, 9, 2]);\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next(), Some(9));\n+    assert_eq!(it.next(), Some(2));\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn iterator_len() {\n+    let mut it = IntoIter::new([0, 1, 2, 5, 9]);\n+    assert_eq!(it.size_hint(), (5, Some(5)));\n+    assert_eq!(it.len(), 5);\n+    assert_eq!(it.is_empty(), false);\n+\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.size_hint(), (4, Some(4)));\n+    assert_eq!(it.len(), 4);\n+    assert_eq!(it.is_empty(), false);\n+\n+    assert_eq!(it.next_back(), Some(9));\n+    assert_eq!(it.size_hint(), (3, Some(3)));\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.is_empty(), false);\n+\n+    // Empty\n+    let it = IntoIter::new([] as [String; 0]);\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert_eq!(it.len(), 0);\n+    assert_eq!(it.is_empty(), true);\n+}\n+\n+#[test]\n+fn iterator_count() {\n+    let v = [0, 1, 2, 3, 4];\n+    assert_eq!(IntoIter::new(v.clone()).count(), 5);\n+\n+    let mut iter2 = IntoIter::new(v);\n+    iter2.next();\n+    iter2.next();\n+    assert_eq!(iter2.count(), 3);\n+}\n+\n+#[test]\n+fn iterator_flat_map() {\n+    assert!((0..5).flat_map(|i| IntoIter::new([2 * i, 2 * i + 1])).eq(0..10));\n+}\n+\n+#[test]\n+fn iterator_debug() {\n+    let arr = [0, 1, 2, 5, 9];\n+    assert_eq!(\n+        format!(\"{:?}\", IntoIter::new(arr)),\n+        \"IntoIter([0, 1, 2, 5, 9])\",\n+    );\n+}\n+\n+#[test]\n+fn iterator_drops() {\n+    use core::cell::Cell;\n+\n+    // This test makes sure the correct number of elements are dropped. The `R`\n+    // type is just a reference to a `Cell` that is incremented when an `R` is\n+    // dropped.\n+\n+    #[derive(Clone)]\n+    struct Foo<'a>(&'a Cell<usize>);\n+\n+    impl Drop for Foo<'_> {\n+       fn drop(&mut self) {\n+            self.0.set(self.0.get() + 1);\n+        }\n+    }\n+\n+    fn five(i: &Cell<usize>) -> [Foo<'_>; 5] {\n+        // This is somewhat verbose because `Foo` does not implement `Copy`\n+        // since it implements `Drop`. Consequently, we cannot write\n+        // `[Foo(i); 5]`.\n+        [Foo(i), Foo(i), Foo(i), Foo(i), Foo(i)]\n+    }\n+\n+    // Simple: drop new iterator.\n+    let i = Cell::new(0);\n+    {\n+        IntoIter::new(five(&i));\n+    }\n+    assert_eq!(i.get(), 5);\n+\n+    // Call `next()` once.\n+    let i = Cell::new(0);\n+    {\n+        let mut iter = IntoIter::new(five(&i));\n+        let _x = iter.next();\n+        assert_eq!(i.get(), 0);\n+        assert_eq!(iter.count(), 4);\n+        assert_eq!(i.get(), 4);\n+    }\n+    assert_eq!(i.get(), 5);\n+\n+    // Check `clone` and calling `next`/`next_back`.\n+    let i = Cell::new(0);\n+    {\n+        let mut iter = IntoIter::new(five(&i));\n+        iter.next();\n+        assert_eq!(i.get(), 1);\n+        iter.next_back();\n+        assert_eq!(i.get(), 2);\n+\n+        let mut clone = iter.clone();\n+        assert_eq!(i.get(), 2);\n+\n+        iter.next();\n+        assert_eq!(i.get(), 3);\n+\n+        clone.next();\n+        assert_eq!(i.get(), 4);\n+\n+        assert_eq!(clone.count(), 2);\n+        assert_eq!(i.get(), 6);\n+    }\n+    assert_eq!(i.get(), 8);\n+\n+    // Check via `nth`.\n+    let i = Cell::new(0);\n+    {\n+        let mut iter = IntoIter::new(five(&i));\n+        let _x = iter.nth(2);\n+        assert_eq!(i.get(), 2);\n+        let _y = iter.last();\n+        assert_eq!(i.get(), 3);\n+    }\n+    assert_eq!(i.get(), 5);\n+\n+    // Check every element.\n+    let i = Cell::new(0);\n+    for (index, _x) in IntoIter::new(five(&i)).enumerate() {\n+        assert_eq!(i.get(), index);\n+    }\n+    assert_eq!(i.get(), 5);\n+\n+    let i = Cell::new(0);\n+    for (index, _x) in IntoIter::new(five(&i)).rev().enumerate() {\n+        assert_eq!(i.get(), index);\n+    }\n+    assert_eq!(i.get(), 5);\n+}"}, {"sha": "b28ed2eaa0876ad6af9fb264eed6cc736b2cadb6", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -31,6 +31,7 @@\n #![feature(slice_partition_dedup)]\n #![feature(int_error_matching)]\n #![feature(const_fn)]\n+#![feature(array_value_iter)]\n #![feature(iter_partition_in_place)]\n #![feature(iter_is_partitioned)]\n #![feature(iter_order_by)]"}, {"sha": "34ac96beb5ca35531a1017b1b7fe7005f5578172", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -178,6 +178,9 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n     ) {\n+        if let ty::ReEmpty = a {\n+            return;\n+        }\n         let b = self.to_region_vid(b);\n         let a = self.to_region_vid(a);\n         self.add_outlives(b, a);\n@@ -190,6 +193,9 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         a: ty::Region<'tcx>,\n         bound: VerifyBound<'tcx>,\n     ) {\n+        if let ty::ReEmpty = a {\n+            return;\n+        }\n         let type_test = self.verify_to_type_test(kind, a, bound);\n         self.add_type_test(type_test);\n     }"}, {"sha": "907c84b6f8cf02ac23a4d4a33f1dade25a452a52", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 39, "deletions": 49, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -394,16 +394,6 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn is_non_exhaustive_variant<'p>(&self, pattern: &'p Pat<'tcx>) -> bool {\n-        match *pattern.kind {\n-            PatKind::Variant { adt_def, variant_index, .. } => {\n-                let ref variant = adt_def.variants[variant_index];\n-                variant.is_field_list_non_exhaustive()\n-            }\n-            _ => false,\n-        }\n-    }\n-\n     fn is_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n         match ty.kind {\n             ty::Adt(adt_def, ..) => adt_def.is_variant_list_non_exhaustive(),\n@@ -1252,19 +1242,12 @@ pub fn is_useful<'p, 'a, 'tcx>(\n     debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v[0]);\n \n     if let Some(constructors) = pat_constructors(cx, v[0], pcx) {\n-        let is_declared_nonexhaustive = cx.is_non_exhaustive_variant(v[0]) && !cx.is_local(pcx.ty);\n-        debug!(\"is_useful - expanding constructors: {:#?}, is_declared_nonexhaustive: {:?}\",\n-               constructors, is_declared_nonexhaustive);\n-\n-        if is_declared_nonexhaustive {\n-            Useful\n-        } else {\n-            split_grouped_constructors(\n-                cx.tcx, cx.param_env, constructors, matrix, pcx.ty, pcx.span, Some(hir_id),\n-            ).into_iter().map(|c|\n-                is_useful_specialized(cx, matrix, v, c, pcx.ty, witness, hir_id)\n-            ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n-        }\n+        debug!(\"is_useful - expanding constructors: {:#?}\", constructors);\n+        split_grouped_constructors(\n+            cx.tcx, cx.param_env, constructors, matrix, pcx.ty, pcx.span, Some(hir_id),\n+        ).into_iter().map(|c|\n+            is_useful_specialized(cx, matrix, v, c, pcx.ty, witness, hir_id)\n+        ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n     } else {\n         debug!(\"is_useful - expanding wildcard\");\n \n@@ -1548,27 +1531,30 @@ fn constructor_sub_pattern_tys<'a, 'tcx>(\n                 // Use T as the sub pattern type of Box<T>.\n                 vec![substs.type_at(0)]\n             } else {\n-                adt.variants[ctor.variant_index_for_adt(cx, adt)].fields.iter().map(|field| {\n+                let variant = &adt.variants[ctor.variant_index_for_adt(cx, adt)];\n+                let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !cx.is_local(ty);\n+                variant.fields.iter().map(|field| {\n                     let is_visible = adt.is_enum()\n                         || field.vis.is_accessible_from(cx.module, cx.tcx);\n-                    if is_visible {\n-                        let ty = field.ty(cx.tcx, substs);\n-                        match ty.kind {\n-                            // If the field type returned is an array of an unknown\n-                            // size return an TyErr.\n-                            ty::Array(_, len)\n-                                if len.try_eval_usize(cx.tcx, cx.param_env).is_none() =>\n-                                cx.tcx.types.err,\n-                            _ => ty,\n-                        }\n-                    } else {\n-                        // Treat all non-visible fields as TyErr. They\n-                        // can't appear in any other pattern from\n-                        // this match (because they are private),\n-                        // so their type does not matter - but\n-                        // we don't want to know they are\n-                        // uninhabited.\n-                        cx.tcx.types.err\n+                    let is_uninhabited = cx.is_uninhabited(field.ty(cx.tcx, substs));\n+                    match (is_visible, is_non_exhaustive, is_uninhabited) {\n+                        // Treat all uninhabited types in non-exhaustive variants as `TyErr`.\n+                        (_, true, true) => cx.tcx.types.err,\n+                        // Treat all non-visible fields as `TyErr`. They can't appear in any\n+                        // other pattern from this match (because they are private), so their\n+                        // type does not matter - but we don't want to know they are uninhabited.\n+                        (false, ..) => cx.tcx.types.err,\n+                        (true, ..) => {\n+                            let ty = field.ty(cx.tcx, substs);\n+                            match ty.kind {\n+                                // If the field type returned is an array of an unknown\n+                                // size return an TyErr.\n+                                ty::Array(_, len)\n+                                    if len.try_eval_usize(cx.tcx, cx.param_env).is_none() =>\n+                                    cx.tcx.types.err,\n+                                _ => ty,\n+                            }\n+                        },\n                     }\n                 }).collect()\n             }\n@@ -1874,15 +1860,18 @@ fn constructor_covered_by_range<'tcx>(\n     }\n }\n \n-fn patterns_for_variant<'p, 'tcx>(\n+fn patterns_for_variant<'p, 'a: 'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     subpatterns: &'p [FieldPat<'tcx>],\n-    wild_patterns: &[&'p Pat<'tcx>])\n-    -> SmallVec<[&'p Pat<'tcx>; 2]>\n-{\n+    wild_patterns: &[&'p Pat<'tcx>],\n+    is_non_exhaustive: bool,\n+) -> SmallVec<[&'p Pat<'tcx>; 2]> {\n     let mut result = SmallVec::from_slice(wild_patterns);\n \n     for subpat in subpatterns {\n-        result[subpat.field.index()] = &subpat.pattern;\n+        if !is_non_exhaustive || !cx.is_uninhabited(subpat.pattern.ty) {\n+            result[subpat.field.index()] = &subpat.pattern;\n+        }\n     }\n \n     debug!(\"patterns_for_variant({:#?}, {:#?}) = {:#?}\", subpatterns, wild_patterns, result);\n@@ -1916,13 +1905,14 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n \n         PatKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n+            let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !cx.is_local(pat.ty);\n             Some(Variant(variant.def_id))\n                 .filter(|variant_constructor| variant_constructor == constructor)\n-                .map(|_| patterns_for_variant(subpatterns, wild_patterns))\n+                .map(|_| patterns_for_variant(cx, subpatterns, wild_patterns, is_non_exhaustive))\n         }\n \n         PatKind::Leaf { ref subpatterns } => {\n-            Some(patterns_for_variant(subpatterns, wild_patterns))\n+            Some(patterns_for_variant(cx, subpatterns, wild_patterns, false))\n         }\n \n         PatKind::Deref { ref subpattern } => {"}, {"sha": "be2e9f505aa6f2d331452840ccba2e490ae5a942", "filename": "src/librustc_resolve/error_codes.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibrustc_resolve%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibrustc_resolve%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_codes.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1797,6 +1797,31 @@ let _: <u8 as Age>::Empire; // ok!\n ```\n \"##,\n \n+E0576: r##\"\n+An associated item wasn't found in the given type.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0576\n+trait Hello {\n+    type Who;\n+\n+    fn hello() -> <Self as Hello>::You; // error!\n+}\n+```\n+\n+In this example, we tried to use the non-existent associated type `You` of the\n+`Hello` trait. To fix this error, use an existing associated type:\n+\n+```\n+trait Hello {\n+    type Who;\n+\n+    fn hello() -> <Self as Hello>::Who; // ok!\n+}\n+```\n+\"##,\n+\n E0603: r##\"\n A private item was used outside its scope.\n \n@@ -1925,7 +1950,6 @@ struct Foo<X = Box<Self>> {\n //  E0427, merged into 530\n //  E0467, removed\n //  E0470, removed\n-    E0576,\n     E0577,\n     E0578,\n }"}, {"sha": "aa05a08686a995974bdac75589f57c09ead049a9", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -215,7 +215,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// Report error if there is an explicit type parameter when using `impl Trait`.\n     fn check_impl_trait(\n         tcx: TyCtxt<'_>,\n-        span: Span,\n         seg: &hir::PathSegment,\n         generics: &ty::Generics,\n     ) -> bool {\n@@ -228,14 +227,28 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         });\n \n         if explicit && impl_trait {\n+            let spans =\n+                seg.generic_args().args\n+                    .iter()\n+                    .filter_map(|arg|\n+                        match arg {\n+                            GenericArg::Type(_) => Some(arg.span()),\n+                            _ => None\n+                        })\n+                    .collect::<Vec<_>>();\n+\n             let mut err = struct_span_err! {\n                 tcx.sess,\n-                span,\n+                spans.clone(),\n                 E0632,\n                 \"cannot provide explicit generic arguments when `impl Trait` is \\\n-                 used in argument position\"\n+                used in argument position\"\n             };\n \n+            for span in spans {\n+                err.span_label(span, \"explicit generic argument not allowed\");\n+            }\n+\n             err.emit();\n         }\n \n@@ -254,7 +267,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let empty_args = P(hir::GenericArgs {\n             args: HirVec::new(), bindings: HirVec::new(), parenthesized: false,\n         });\n-        let suppress_mismatch = Self::check_impl_trait(tcx, span, seg, &def);\n+        let suppress_mismatch = Self::check_impl_trait(tcx, seg, &def);\n         Self::check_generic_arg_count(\n             tcx,\n             span,"}, {"sha": "2894cd1c1f685e7de1e34b7639fce595104c99e8", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -220,7 +220,7 @@\n \n #![cfg_attr(test, feature(print_internals, set_stdio, update_panic_count))]\n #![cfg_attr(all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n-            feature(slice_index_methods, decl_macro, coerce_unsized,\n+            feature(slice_index_methods, coerce_unsized,\n                     sgx_platform, ptr_wrapping_offset_from))]\n #![cfg_attr(all(test, target_vendor = \"fortanix\", target_env = \"sgx\"),\n             feature(fixed_size_array, maybe_uninit_extra))]\n@@ -251,6 +251,7 @@\n #![feature(container_error_extra)]\n #![feature(core_intrinsics)]\n #![feature(custom_test_frameworks)]\n+#![feature(decl_macro)]\n #![feature(doc_alias)]\n #![feature(doc_cfg)]\n #![feature(doc_keyword)]"}, {"sha": "4f92401d2bc57ed8d4d8903747345088881c3366", "filename": "src/libsyntax/feature_gate/active.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax%2Ffeature_gate%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax%2Ffeature_gate%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Factive.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -330,8 +330,13 @@ declare_features! (\n     /// Allows exhaustive pattern matching on types that contain uninhabited types.\n     (active, exhaustive_patterns, \"1.13.0\", Some(51085), None),\n \n-    /// Allows untagged unions `union U { ... }`.\n-    (active, untagged_unions, \"1.13.0\", Some(32836), None),\n+    /// Allows `union`s to implement `Drop`. Moreover, `union`s may now include fields\n+    /// that don't implement `Copy` as long as they don't have any drop glue.\n+    /// This is checked recursively. On encountering type variable where no progress can be made,\n+    /// `T: Copy` is used as a substitute for \"no drop glue\".\n+    ///\n+    /// NOTE: A limited form of `union U { ... }` was accepted in 1.19.0.\n+    (active, untagged_unions, \"1.13.0\", Some(55149), None),\n \n     /// Allows `#[link(..., cfg(..))]`.\n     (active, link_cfg, \"1.14.0\", Some(37406), None),\n@@ -522,13 +527,16 @@ declare_features! (\n     /// Allows the definition of `const extern fn` and `const unsafe extern fn`.\n     (active, const_extern_fn, \"1.40.0\", Some(64926), None),\n \n-    // Allows the use of raw-dylibs (RFC 2627).\n+    /// Allows the use of raw-dylibs (RFC 2627).\n     (active, raw_dylib, \"1.40.0\", Some(58713), None),\n \n-    /// Enable accurate caller location reporting during panic (RFC 2091).\n+    /// Allows `#[track_caller]` to be used which provides\n+    /// accurate caller location reporting during panic (RFC 2091).\n     (active, track_caller, \"1.40.0\", Some(47809), None),\n \n-    /// Non-object safe trait objects safe to use but cannot be created in safe rust\n+    /// Allows making `dyn Trait` well-formed even if `Trait` is not object safe.\n+    /// In that case, `dyn Trait: Trait` does not hold. Moreover, coercions and\n+    /// casts in safe Rust to `dyn Trait` for such a `Trait` is also forbidden.\n     (active, object_safe_for_dispatch, \"1.40.0\", Some(43561), None),\n \n     // -------------------------------------------------------------------------"}, {"sha": "502b1c0f7437157eb90be023383a9fd5b05e4ddb", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 39, "deletions": 111, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -3,12 +3,8 @@ use super::accepted::ACCEPTED_FEATURES;\n use super::removed::{REMOVED_FEATURES, STABLE_REMOVED_FEATURES};\n use super::builtin_attrs::{AttributeGate, BUILTIN_ATTRIBUTE_MAP};\n \n-use crate::ast::{\n-    self, AssocTyConstraint, AssocTyConstraintKind, NodeId, GenericParam, GenericParamKind,\n-    PatKind, RangeEnd, VariantData,\n-};\n+use crate::ast::{self, NodeId, PatKind, VariantData};\n use crate::attr::{self, check_builtin_attribute};\n-use crate::source_map::Spanned;\n use crate::edition::{ALL_EDITIONS, Edition};\n use crate::visit::{self, FnKind, Visitor};\n use crate::parse::token;\n@@ -157,9 +153,6 @@ fn leveled_feature_err<'a, S: Into<MultiSpan>>(\n \n }\n \n-const EXPLAIN_BOX_SYNTAX: &str =\n-    \"box expression syntax is experimental; you can call `Box::new` instead\";\n-\n pub const EXPLAIN_STMT_ATTR_SYNTAX: &str =\n     \"attributes on expressions are experimental\";\n \n@@ -291,6 +284,25 @@ impl<'a> PostExpansionVisitor<'a> {\n             err.emit();\n         }\n     }\n+\n+    fn check_gat(&self, generics: &ast::Generics, span: Span) {\n+        if !generics.params.is_empty() {\n+            gate_feature_post!(\n+                &self,\n+                generic_associated_types,\n+                span,\n+                \"generic associated types are unstable\"\n+            );\n+        }\n+        if !generics.where_clause.predicates.is_empty() {\n+            gate_feature_post!(\n+                &self,\n+                generic_associated_types,\n+                span,\n+                \"where clauses on associated types are unstable\"\n+            );\n+        }\n+    }\n }\n \n impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n@@ -423,20 +435,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                                    \"auto traits are experimental and possibly buggy\");\n             }\n \n-            ast::ItemKind::TraitAlias(..) => {\n-                gate_feature_post!(\n-                    &self,\n-                    trait_alias,\n-                    i.span,\n-                    \"trait aliases are experimental\"\n-                );\n-            }\n-\n-            ast::ItemKind::MacroDef(ast::MacroDef { legacy: false, .. }) => {\n-                let msg = \"`macro` is experimental\";\n-                gate_feature_post!(&self, decl_macro, i.span, msg);\n-            }\n-\n             ast::ItemKind::OpaqueTy(..) => {\n                 gate_feature_post!(\n                     &self,\n@@ -500,37 +498,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         }\n     }\n \n-    fn visit_expr(&mut self, e: &'a ast::Expr) {\n-        match e.kind {\n-            ast::ExprKind::Box(_) => {\n-                gate_feature_post!(&self, box_syntax, e.span, EXPLAIN_BOX_SYNTAX);\n-            }\n-            ast::ExprKind::Type(..) => {\n-                // To avoid noise about type ascription in common syntax errors, only emit if it\n-                // is the *only* error.\n-                if self.parse_sess.span_diagnostic.err_count() == 0 {\n-                    gate_feature_post!(&self, type_ascription, e.span,\n-                                       \"type ascription is experimental\");\n-                }\n-            }\n-            ast::ExprKind::TryBlock(_) => {\n-                gate_feature_post!(&self, try_blocks, e.span, \"`try` expression is experimental\");\n-            }\n-            ast::ExprKind::Block(_, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    gate_feature_post!(&self, label_break_value, label.ident.span,\n-                                    \"labels on blocks are unstable\");\n-                }\n-            }\n-            _ => {}\n-        }\n-        visit::walk_expr(self, e)\n-    }\n-\n-    fn visit_arm(&mut self, arm: &'a ast::Arm) {\n-        visit::walk_arm(self, arm)\n-    }\n-\n     fn visit_pat(&mut self, pattern: &'a ast::Pat) {\n         match &pattern.kind {\n             PatKind::Slice(pats) => {\n@@ -550,25 +517,12 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     }\n                 }\n             }\n-            PatKind::Box(..) => {\n-                gate_feature_post!(&self, box_patterns,\n-                                  pattern.span,\n-                                  \"box pattern syntax is experimental\");\n-            }\n-            PatKind::Range(_, _, Spanned { node: RangeEnd::Excluded, .. }) => {\n-                gate_feature_post!(&self, exclusive_range_pattern, pattern.span,\n-                                   \"exclusive range pattern syntax is experimental\");\n-            }\n             _ => {}\n         }\n         visit::walk_pat(self, pattern)\n     }\n \n-    fn visit_fn(&mut self,\n-                fn_kind: FnKind<'a>,\n-                fn_decl: &'a ast::FnDecl,\n-                span: Span,\n-                _node_id: NodeId) {\n+    fn visit_fn(&mut self, fn_kind: FnKind<'a>, fn_decl: &'a ast::FnDecl, span: Span, _: NodeId) {\n         if let Some(header) = fn_kind.header() {\n             // Stability of const fn methods are covered in\n             // `visit_trait_item` and `visit_impl_item` below; this is\n@@ -583,26 +537,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         visit::walk_fn(self, fn_kind, fn_decl, span)\n     }\n \n-    fn visit_generic_param(&mut self, param: &'a GenericParam) {\n-        match param.kind {\n-            GenericParamKind::Const { .. } =>\n-                gate_feature_post!(&self, const_generics, param.ident.span,\n-                    \"const generics are unstable\"),\n-            _ => {}\n-        }\n-        visit::walk_generic_param(self, param)\n-    }\n-\n-    fn visit_assoc_ty_constraint(&mut self, constraint: &'a AssocTyConstraint) {\n-        match constraint.kind {\n-            AssocTyConstraintKind::Bound { .. } =>\n-                gate_feature_post!(&self, associated_type_bounds, constraint.span,\n-                    \"associated type bounds are unstable\"),\n-            _ => {}\n-        }\n-        visit::walk_assoc_ty_constraint(self, constraint)\n-    }\n-\n     fn visit_trait_item(&mut self, ti: &'a ast::TraitItem) {\n         match ti.kind {\n             ast::TraitItemKind::Method(ref sig, ref block) => {\n@@ -624,14 +558,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     gate_feature_post!(&self, associated_type_defaults, ti.span,\n                                        \"associated type defaults are unstable\");\n                 }\n-                if !ti.generics.params.is_empty() {\n-                    gate_feature_post!(&self, generic_associated_types, ti.span,\n-                                       \"generic associated types are unstable\");\n-                }\n-                if !ti.generics.where_clause.predicates.is_empty() {\n-                    gate_feature_post!(&self, generic_associated_types, ti.span,\n-                                       \"where clauses on associated types are unstable\");\n-                }\n+                self.check_gat(&ti.generics, ti.span);\n             }\n             _ => {}\n         }\n@@ -661,27 +588,12 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 );\n             }\n             ast::ImplItemKind::TyAlias(_) => {\n-                if !ii.generics.params.is_empty() {\n-                    gate_feature_post!(&self, generic_associated_types, ii.span,\n-                                       \"generic associated types are unstable\");\n-                }\n-                if !ii.generics.where_clause.predicates.is_empty() {\n-                    gate_feature_post!(&self, generic_associated_types, ii.span,\n-                                       \"where clauses on associated types are unstable\");\n-                }\n+                self.check_gat(&ii.generics, ii.span);\n             }\n             _ => {}\n         }\n         visit::walk_impl_item(self, ii)\n     }\n-\n-    fn visit_vis(&mut self, vis: &'a ast::Visibility) {\n-        if let ast::VisibilityKind::Crate(ast::CrateSugar::JustCrate) = vis.node {\n-            gate_feature_post!(&self, crate_visibility_modifier, vis.span,\n-                               \"`crate` visibility modifier is experimental\");\n-        }\n-        visit::walk_vis(self, vis)\n-    }\n }\n \n pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n@@ -867,6 +779,22 @@ pub fn check_crate(krate: &ast::Crate,\n     gate_all!(yields, generators, \"yield syntax is experimental\");\n     gate_all!(or_patterns, \"or-patterns syntax is experimental\");\n     gate_all!(const_extern_fn, \"`const extern fn` definitions are unstable\");\n+    gate_all!(trait_alias, \"trait aliases are experimental\");\n+    gate_all!(associated_type_bounds, \"associated type bounds are unstable\");\n+    gate_all!(crate_visibility_modifier, \"`crate` visibility modifier is experimental\");\n+    gate_all!(const_generics, \"const generics are unstable\");\n+    gate_all!(decl_macro, \"`macro` is experimental\");\n+    gate_all!(box_patterns, \"box pattern syntax is experimental\");\n+    gate_all!(exclusive_range_pattern, \"exclusive range pattern syntax is experimental\");\n+    gate_all!(try_blocks, \"`try` blocks are unstable\");\n+    gate_all!(label_break_value, \"labels on blocks are unstable\");\n+    gate_all!(box_syntax, \"box expression syntax is experimental; you can call `Box::new` instead\");\n+\n+    // To avoid noise about type ascription in common syntax errors,\n+    // only emit if it is the *only* error. (Also check it last.)\n+    if parse_sess.span_diagnostic.err_count() == 0 {\n+        gate_all!(type_ascription, \"type ascription is experimental\");\n+    }\n \n     visit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "f25224d1e36f5d2ab0b949c9df840aee578ab14c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1122,6 +1122,7 @@ impl<'a> Parser<'a> {\n         self.expected_tokens.push(TokenType::Keyword(kw::Crate));\n         if self.is_crate_vis() {\n             self.bump(); // `crate`\n+            self.sess.gated_spans.crate_visibility_modifier.borrow_mut().push(self.prev_span);\n             return Ok(respan(self.prev_span, VisibilityKind::Crate(CrateSugar::JustCrate)));\n         }\n "}, {"sha": "97b1092452aafa22214905be4e5ec47852579274", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -252,6 +252,7 @@ impl<'a> Parser<'a> {\n                 self.last_type_ascription = Some((self.prev_span, maybe_path));\n \n                 lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type)?;\n+                self.sess.gated_spans.type_ascription.borrow_mut().push(lhs.span);\n                 continue\n             } else if op == AssocOp::DotDot || op == AssocOp::DotDotEq {\n                 // If we didn\u2019t have to handle `x..`/`x..=`, it would be pretty easy to\n@@ -453,7 +454,9 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (lo.to(span), ExprKind::Box(e))\n+                let span = lo.to(span);\n+                self.sess.gated_spans.box_syntax.borrow_mut().push(span);\n+                (span, ExprKind::Box(e))\n             }\n             token::Ident(..) if self.token.is_ident_named(sym::not) => {\n                 // `not` is just an ordinary identifier in Rust-the-language,\n@@ -1260,6 +1263,10 @@ impl<'a> Parser<'a> {\n         blk_mode: BlockCheckMode,\n         outer_attrs: ThinVec<Attribute>,\n     ) -> PResult<'a, P<Expr>> {\n+        if let Some(label) = opt_label {\n+            self.sess.gated_spans.label_break_value.borrow_mut().push(label.ident.span);\n+        }\n+\n         self.expect(&token::OpenDelim(token::Brace))?;\n \n         let mut attrs = outer_attrs;\n@@ -1646,7 +1653,9 @@ impl<'a> Parser<'a> {\n             error.emit();\n             Err(error)\n         } else {\n-            Ok(self.mk_expr(span_lo.to(body.span), ExprKind::TryBlock(body), attrs))\n+            let span = span_lo.to(body.span);\n+            self.sess.gated_spans.try_blocks.borrow_mut().push(span);\n+            Ok(self.mk_expr(span, ExprKind::TryBlock(body), attrs))\n         }\n     }\n "}, {"sha": "51caae69c86a4e4b60a7639f3ee9a9a466227742", "filename": "src/libsyntax/parse/parser/generics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -55,11 +55,15 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_const_param(&mut self, preceding_attrs: Vec<Attribute>) -> PResult<'a, GenericParam> {\n+        let lo = self.token.span;\n+\n         self.expect_keyword(kw::Const)?;\n         let ident = self.parse_ident()?;\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n \n+        self.sess.gated_spans.const_generics.borrow_mut().push(lo.to(self.prev_span));\n+\n         Ok(GenericParam {\n             ident,\n             id: ast::DUMMY_NODE_ID,"}, {"sha": "95bddb5afdd08dcd76ddbdf69b2dea16e17758cb", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -211,7 +211,7 @@ impl<'a> Parser<'a> {\n         {\n             // UNSAFE TRAIT ITEM\n             self.bump(); // `unsafe`\n-            let info = self.parse_item_trait(Unsafety::Unsafe)?;\n+            let info = self.parse_item_trait(lo, Unsafety::Unsafe)?;\n             return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n \n@@ -289,7 +289,7 @@ impl<'a> Parser<'a> {\n                 && self.is_keyword_ahead(1, &[kw::Trait]))\n         {\n             // TRAIT ITEM\n-            let info = self.parse_item_trait(Unsafety::Normal)?;\n+            let info = self.parse_item_trait(lo, Unsafety::Normal)?;\n             return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n \n@@ -780,7 +780,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `auto? trait Foo { ... }` or `trait Foo = Bar;`.\n-    fn parse_item_trait(&mut self, unsafety: Unsafety) -> PResult<'a, ItemInfo> {\n+    fn parse_item_trait(&mut self, lo: Span, unsafety: Unsafety) -> PResult<'a, ItemInfo> {\n         // Parse optional `auto` prefix.\n         let is_auto = if self.eat_keyword(kw::Auto) {\n             IsAuto::Yes\n@@ -793,29 +793,43 @@ impl<'a> Parser<'a> {\n         let mut tps = self.parse_generics()?;\n \n         // Parse optional colon and supertrait bounds.\n-        let bounds = if self.eat(&token::Colon) {\n+        let had_colon = self.eat(&token::Colon);\n+        let span_at_colon = self.prev_span;\n+        let bounds = if had_colon {\n             self.parse_generic_bounds(Some(self.prev_span))?\n         } else {\n             Vec::new()\n         };\n \n+        let span_before_eq = self.prev_span;\n         if self.eat(&token::Eq) {\n             // It's a trait alias.\n+            if had_colon {\n+                let span = span_at_colon.to(span_before_eq);\n+                self.struct_span_err(span, \"bounds are not allowed on trait aliases\")\n+                    .emit();\n+            }\n+\n             let bounds = self.parse_generic_bounds(None)?;\n             tps.where_clause = self.parse_where_clause()?;\n             self.expect(&token::Semi)?;\n+\n+            let whole_span = lo.to(self.prev_span);\n             if is_auto == IsAuto::Yes {\n                 let msg = \"trait aliases cannot be `auto`\";\n-                self.struct_span_err(self.prev_span, msg)\n-                    .span_label(self.prev_span, msg)\n+                self.struct_span_err(whole_span, msg)\n+                    .span_label(whole_span, msg)\n                     .emit();\n             }\n             if unsafety != Unsafety::Normal {\n                 let msg = \"trait aliases cannot be `unsafe`\";\n-                self.struct_span_err(self.prev_span, msg)\n-                    .span_label(self.prev_span, msg)\n+                self.struct_span_err(whole_span, msg)\n+                    .span_label(whole_span, msg)\n                     .emit();\n             }\n+\n+            self.sess.gated_spans.trait_alias.borrow_mut().push(whole_span);\n+\n             Ok((ident, ItemKind::TraitAlias(tps, bounds), None))\n         } else {\n             // It's a normal trait.\n@@ -1692,6 +1706,11 @@ impl<'a> Parser<'a> {\n         };\n \n         let span = lo.to(self.prev_span);\n+\n+        if !def.legacy {\n+            self.sess.gated_spans.decl_macro.borrow_mut().push(span);\n+        }\n+\n         Ok(Some(self.mk_item(span, ident, ItemKind::MacroDef(def), vis.clone(), attrs.to_vec())))\n     }\n "}, {"sha": "969d5dd8374805668d010553aa47cccd627101d7", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -324,7 +324,9 @@ impl<'a> Parser<'a> {\n                 self.parse_pat_ident(BindingMode::ByRef(mutbl))?\n             } else if self.eat_keyword(kw::Box) {\n                 // Parse `box pat`\n-                PatKind::Box(self.parse_pat_with_range_pat(false, None)?)\n+                let pat = self.parse_pat_with_range_pat(false, None)?;\n+                self.sess.gated_spans.box_patterns.borrow_mut().push(lo.to(self.prev_span));\n+                PatKind::Box(pat)\n             } else if self.can_be_ident_pat() {\n                 // Parse `ident @ pat`\n                 // This can give false positives and parse nullary enums,\n@@ -609,6 +611,11 @@ impl<'a> Parser<'a> {\n         Ok(PatKind::Mac(mac))\n     }\n \n+    fn excluded_range_end(&self, span: Span) -> RangeEnd {\n+        self.sess.gated_spans.exclusive_range_pattern.borrow_mut().push(span);\n+        RangeEnd::Excluded\n+    }\n+\n     /// Parse a range pattern `$path $form $end?` where `$form = \"..\" | \"...\" | \"..=\" ;`.\n     /// The `$path` has already been parsed and the next token is the `$form`.\n     fn parse_pat_range_starting_with_path(\n@@ -618,7 +625,7 @@ impl<'a> Parser<'a> {\n         path: Path\n     ) -> PResult<'a, PatKind> {\n         let (end_kind, form) = match self.token.kind {\n-            token::DotDot => (RangeEnd::Excluded, \"..\"),\n+            token::DotDot => (self.excluded_range_end(self.token.span), \"..\"),\n             token::DotDotDot => (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\"),\n             token::DotDotEq => (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\"),\n             _ => panic!(\"can only parse `..`/`...`/`..=` for ranges (checked above)\"),\n@@ -641,7 +648,7 @@ impl<'a> Parser<'a> {\n         } else if self.eat(&token::DotDotEq) {\n             (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")\n         } else if self.eat(&token::DotDot) {\n-            (RangeEnd::Excluded, \"..\")\n+            (self.excluded_range_end(op_span), \"..\")\n         } else {\n             panic!(\"impossible case: we already matched on a range-operator token\")\n         };"}, {"sha": "77709a2295339fb5ac5765852f451004090fac45", "filename": "src/libsyntax/parse/parser/path.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -404,8 +404,9 @@ impl<'a> Parser<'a> {\n                 // Parse lifetime argument.\n                 args.push(GenericArg::Lifetime(self.expect_lifetime()));\n                 misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n-            } else if self.check_ident() && self.look_ahead(1,\n-                    |t| t == &token::Eq || t == &token::Colon) {\n+            } else if self.check_ident()\n+                && self.look_ahead(1, |t| t == &token::Eq || t == &token::Colon)\n+            {\n                 // Parse associated type constraint.\n                 let lo = self.token.span;\n                 let ident = self.parse_ident()?;\n@@ -420,7 +421,14 @@ impl<'a> Parser<'a> {\n                 } else {\n                     unreachable!();\n                 };\n+\n                 let span = lo.to(self.prev_span);\n+\n+                // Gate associated type bounds, e.g., `Iterator<Item: Ord>`.\n+                if let AssocTyConstraintKind::Bound { .. } = kind {\n+                    self.sess.gated_spans.associated_type_bounds.borrow_mut().push(span);\n+                }\n+\n                 constraints.push(AssocTyConstraint {\n                     id: ast::DUMMY_NODE_ID,\n                     ident,"}, {"sha": "28a0868d5dd1ea055edb880b444e326de0019205", "filename": "src/libsyntax/sess.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax%2Fsess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax%2Fsess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsess.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -30,6 +30,28 @@ crate struct GatedSpans {\n     crate or_patterns: Lock<Vec<Span>>,\n     /// Spans collected for gating `const_extern_fn`, e.g. `const extern fn foo`.\n     crate const_extern_fn: Lock<Vec<Span>>,\n+    /// Spans collected for gating `trait_alias`, e.g. `trait Foo = Ord + Eq;`.\n+    pub trait_alias: Lock<Vec<Span>>,\n+    /// Spans collected for gating `associated_type_bounds`, e.g. `Iterator<Item: Ord>`.\n+    pub associated_type_bounds: Lock<Vec<Span>>,\n+    /// Spans collected for gating `crate_visibility_modifier`, e.g. `crate fn`.\n+    pub crate_visibility_modifier: Lock<Vec<Span>>,\n+    /// Spans collected for gating `const_generics`, e.g. `const N: usize`.\n+    pub const_generics: Lock<Vec<Span>>,\n+    /// Spans collected for gating `decl_macro`, e.g. `macro m() {}`.\n+    pub decl_macro: Lock<Vec<Span>>,\n+    /// Spans collected for gating `box_patterns`, e.g. `box 0`.\n+    pub box_patterns: Lock<Vec<Span>>,\n+    /// Spans collected for gating `exclusive_range_pattern`, e.g. `0..2`.\n+    pub exclusive_range_pattern: Lock<Vec<Span>>,\n+    /// Spans collected for gating `try_blocks`, e.g. `try { a? + b? }`.\n+    pub try_blocks: Lock<Vec<Span>>,\n+    /// Spans collected for gating `label_break_value`, e.g. `'label: { ... }`.\n+    pub label_break_value: Lock<Vec<Span>>,\n+    /// Spans collected for gating `box_syntax`, e.g. `box $expr`.\n+    pub box_syntax: Lock<Vec<Span>>,\n+    /// Spans collected for gating `type_ascription`, e.g. `42: usize`.\n+    pub type_ascription: Lock<Vec<Span>>,\n }\n \n /// Info about a parsing session."}, {"sha": "c874f1ffb1175d55d3d5824f777b7a357c8295d2", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -337,6 +337,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n //          use proc_macro::bridge::client::ProcMacro;\n //\n //          #[rustc_proc_macro_decls]\n+//          #[allow(deprecated)]\n //          static DECLS: &[ProcMacro] = &[\n //              ProcMacro::custom_derive($name_trait1, &[], ::$name1);\n //              ProcMacro::custom_derive($name_trait2, &[\"attribute_name\"], ::$name2);\n@@ -416,6 +417,16 @@ fn mk_decls(\n     ).map(|mut i| {\n         let attr = cx.meta_word(span, sym::rustc_proc_macro_decls);\n         i.attrs.push(cx.attribute(attr));\n+\n+        let deprecated_attr = attr::mk_nested_word_item(\n+            Ident::new(sym::deprecated, span)\n+        );\n+        let allow_deprecated_attr = attr::mk_list_item(\n+            Ident::new(sym::allow, span),\n+            vec![deprecated_attr]\n+        );\n+        i.attrs.push(cx.attribute(allow_deprecated_attr));\n+\n         i\n     });\n "}, {"sha": "0aeba8607e818b774b82c596ffbc57f084f1ac0f", "filename": "src/test/ui/const-generics/array-impls/into-iter-impls-length-32.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-impls-length-32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-impls-length-32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-impls-length-32.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -0,0 +1,41 @@\n+// check-pass\n+\n+#![feature(array_value_iter)]\n+#![feature(trusted_len)]\n+\n+use std::{\n+    array::IntoIter,\n+    fmt::Debug,\n+    iter::{ExactSizeIterator, FusedIterator, TrustedLen},\n+};\n+\n+pub fn yes_iterator() -> impl Iterator<Item = i32> {\n+    IntoIter::new([0i32; 32])\n+}\n+\n+pub fn yes_double_ended_iterator() -> impl DoubleEndedIterator {\n+    IntoIter::new([0i32; 32])\n+}\n+\n+pub fn yes_exact_size_iterator() -> impl ExactSizeIterator {\n+    IntoIter::new([0i32; 32])\n+}\n+\n+pub fn yes_fused_iterator() -> impl FusedIterator {\n+    IntoIter::new([0i32; 32])\n+}\n+\n+pub fn yes_trusted_len() -> impl TrustedLen {\n+    IntoIter::new([0i32; 32])\n+}\n+\n+pub fn yes_clone() -> impl Clone {\n+    IntoIter::new([0i32; 32])\n+}\n+\n+pub fn yes_debug() -> impl Debug {\n+    IntoIter::new([0i32; 32])\n+}\n+\n+\n+fn main() {}"}, {"sha": "a0bbd2ce64add0adfe8ba440d30b47fade1407c8", "filename": "src/test/ui/const-generics/array-impls/into-iter-no-impls-length-33.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -0,0 +1,53 @@\n+#![feature(array_value_iter)]\n+#![feature(trusted_len)]\n+\n+use std::{\n+    array::IntoIter,\n+    fmt::Debug,\n+    iter::{ExactSizeIterator, FusedIterator, TrustedLen},\n+};\n+\n+pub fn no_iterator() -> impl Iterator<Item = i32> {\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+    IntoIter::new([0i32; 33])\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+}\n+\n+pub fn no_double_ended_iterator() -> impl DoubleEndedIterator {\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+    IntoIter::new([0i32; 33])\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+}\n+\n+pub fn no_exact_size_iterator() -> impl ExactSizeIterator {\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+    IntoIter::new([0i32; 33])\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+}\n+\n+pub fn no_fused_iterator() -> impl FusedIterator {\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+    IntoIter::new([0i32; 33])\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+}\n+\n+pub fn no_trusted_len() -> impl TrustedLen {\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+    IntoIter::new([0i32; 33])\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+}\n+\n+pub fn no_clone() -> impl Clone {\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+    IntoIter::new([0i32; 33])\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+}\n+\n+pub fn no_debug() -> impl Debug {\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+    IntoIter::new([0i32; 33])\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+}\n+\n+\n+fn main() {}"}, {"sha": "bfdff8e3bbe61599026772b8321c1bff56deab25", "filename": "src/test/ui/const-generics/array-impls/into-iter-no-impls-length-33.stderr", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -0,0 +1,122 @@\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:12:5\n+   |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required by `std::array::IntoIter::<T, N>::new`\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:10:25\n+   |\n+LL | pub fn no_iterator() -> impl Iterator<Item = i32> {\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required because of the requirements on the impl of `std::iter::Iterator` for `std::array::IntoIter<i32, 33usize>`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:18:5\n+   |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required by `std::array::IntoIter::<T, N>::new`\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:16:38\n+   |\n+LL | pub fn no_double_ended_iterator() -> impl DoubleEndedIterator {\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required because of the requirements on the impl of `std::iter::DoubleEndedIterator` for `std::array::IntoIter<i32, 33usize>`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:24:5\n+   |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required by `std::array::IntoIter::<T, N>::new`\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:22:36\n+   |\n+LL | pub fn no_exact_size_iterator() -> impl ExactSizeIterator {\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required because of the requirements on the impl of `std::iter::ExactSizeIterator` for `std::array::IntoIter<i32, 33usize>`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:30:5\n+   |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required by `std::array::IntoIter::<T, N>::new`\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:28:31\n+   |\n+LL | pub fn no_fused_iterator() -> impl FusedIterator {\n+   |                               ^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required because of the requirements on the impl of `std::iter::FusedIterator` for `std::array::IntoIter<i32, 33usize>`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:36:5\n+   |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required by `std::array::IntoIter::<T, N>::new`\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:34:28\n+   |\n+LL | pub fn no_trusted_len() -> impl TrustedLen {\n+   |                            ^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required because of the requirements on the impl of `std::iter::TrustedLen` for `std::array::IntoIter<i32, 33usize>`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:42:5\n+   |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required by `std::array::IntoIter::<T, N>::new`\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:40:22\n+   |\n+LL | pub fn no_clone() -> impl Clone {\n+   |                      ^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required because of the requirements on the impl of `std::clone::Clone` for `std::array::IntoIter<i32, 33usize>`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:48:5\n+   |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required by `std::array::IntoIter::<T, N>::new`\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:46:22\n+   |\n+LL | pub fn no_debug() -> impl Debug {\n+   |                      ^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required because of the requirements on the impl of `std::fmt::Debug` for `std::array::IntoIter<i32, 33usize>`\n+   = note: the return type of a function must have a statically known size\n+\n+error: aborting due to 14 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "330c93e83b5e7d1f2230cbd27f001af1a15ff3b0", "filename": "src/test/ui/const-generics/const-param-in-trait-ungated.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-in-trait-ungated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-in-trait-ungated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-in-trait-ungated.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,8 +1,8 @@\n error[E0658]: const generics are unstable\n-  --> $DIR/const-param-in-trait-ungated.rs:1:19\n+  --> $DIR/const-param-in-trait-ungated.rs:1:13\n    |\n LL | trait Trait<const T: ()> {}\n-   |                   ^\n+   |             ^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/44580\n    = help: add `#![feature(const_generics)]` to the crate attributes to enable"}, {"sha": "e34a2da24cecc8d3daef20dc866d672ef398d5b0", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param-ungated.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,8 +1,8 @@\n error[E0658]: const generics are unstable\n-  --> $DIR/const-param-type-depends-on-type-param-ungated.rs:3:19\n+  --> $DIR/const-param-type-depends-on-type-param-ungated.rs:3:13\n    |\n LL | struct B<T, const N: T>(PhantomData<[T; N]>);\n-   |                   ^\n+   |             ^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/44580\n    = help: add `#![feature(const_generics)]` to the crate attributes to enable"}, {"sha": "5223c8c5137aeae97552db686946db730a7a0b71", "filename": "src/test/ui/const-generics/issues/issue-60263.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-60263.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-60263.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-60263.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,8 +1,8 @@\n error[E0658]: const generics are unstable\n-  --> $DIR/issue-60263.rs:1:16\n+  --> $DIR/issue-60263.rs:1:10\n    |\n LL | struct B<const I: u8>;\n-   |                ^\n+   |          ^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/44580\n    = help: add `#![feature(const_generics)]` to the crate attributes to enable"}, {"sha": "00737d8428b3da9c87be6e03aff4de9f15f6074b", "filename": "src/test/ui/feature-gates/feature-gate-associated_type_bounds.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -70,3 +70,7 @@ fn main() {\n     // FIXME: uncomment when `impl_trait_in_bindings` feature is fixed.\n     // let _: &dyn Tr1<As1: Copy> = &S1;\n }\n+\n+macro_rules! accept_path { ($p:path) => {} }\n+accept_path!(Iterator<Item: Ord>);\n+//~^ ERROR associated type bounds are unstable"}, {"sha": "a7ab7614d7b78c646dfc42c044f8e971baef3689", "filename": "src/test/ui/feature-gates/feature-gate-associated_type_bounds.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -115,6 +115,15 @@ LL |     let _: impl Tr1<As1: Copy> = S1;\n    = note: for more information, see https://github.com/rust-lang/rust/issues/52662\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n+error[E0658]: associated type bounds are unstable\n+  --> $DIR/feature-gate-associated_type_bounds.rs:75:23\n+   |\n+LL | accept_path!(Iterator<Item: Ord>);\n+   |                       ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/52662\n+   = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n+\n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n   --> $DIR/feature-gate-associated_type_bounds.rs:54:14\n    |\n@@ -139,7 +148,7 @@ LL |     let _: impl Tr1<As1: Copy> = S1;\n    |\n    = help: add `#![feature(impl_trait_in_bindings)]` to the crate attributes to enable\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 17 previous errors\n \n Some errors have detailed explanations: E0562, E0658.\n For more information about an error, try `rustc --explain E0562`."}, {"sha": "c5b926d5af28c86c1cc1ade736b83cb358034075", "filename": "src/test/ui/feature-gates/feature-gate-box_patterns.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-box_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-box_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-box_patterns.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -2,3 +2,6 @@ fn main() {\n     let box x = Box::new('c'); //~ ERROR box pattern syntax is experimental\n     println!(\"x: {}\", x);\n }\n+\n+macro_rules! accept_pat { ($p:pat) => {} }\n+accept_pat!(box 0); //~ ERROR box pattern syntax is experimental"}, {"sha": "1e47bd41e88705a7cc0f8330877fa5ddcc531cd5", "filename": "src/test/ui/feature-gates/feature-gate-box_patterns.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-box_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-box_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-box_patterns.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -7,6 +7,15 @@ LL |     let box x = Box::new('c');\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29641\n    = help: add `#![feature(box_patterns)]` to the crate attributes to enable\n \n-error: aborting due to previous error\n+error[E0658]: box pattern syntax is experimental\n+  --> $DIR/feature-gate-box_patterns.rs:7:13\n+   |\n+LL | accept_pat!(box 0);\n+   |             ^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/29641\n+   = help: add `#![feature(box_patterns)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "c23953a9e099e1dfa279390e63506790b6ea8aa9", "filename": "src/test/ui/feature-gates/feature-gate-box_syntax.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-box_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-box_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-box_syntax.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,6 +1,9 @@\n // Test that the use of the box syntax is gated by `box_syntax` feature gate.\n \n-fn main() {\n+#[cfg(FALSE)]\n+fn foo() {\n     let x = box 3;\n     //~^ ERROR box expression syntax is experimental; you can call `Box::new` instead\n }\n+\n+fn main() {}"}, {"sha": "cbafa50257706e53cb7efde0f8de5fd1360310ed", "filename": "src/test/ui/feature-gates/feature-gate-box_syntax.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-box_syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-box_syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-box_syntax.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: box expression syntax is experimental; you can call `Box::new` instead\n-  --> $DIR/feature-gate-box_syntax.rs:4:13\n+  --> $DIR/feature-gate-box_syntax.rs:5:13\n    |\n LL |     let x = box 3;\n    |             ^^^^^"}, {"sha": "790bc33e2683e717e7138ba287ea8f8c35f4af1d", "filename": "src/test/ui/feature-gates/feature-gate-const_generics-ptr.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics-ptr.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,17 +1,17 @@\n error[E0658]: const generics are unstable\n-  --> $DIR/feature-gate-const_generics-ptr.rs:1:22\n+  --> $DIR/feature-gate-const_generics-ptr.rs:1:16\n    |\n LL | struct ConstFn<const F: fn()>;\n-   |                      ^\n+   |                ^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/44580\n    = help: add `#![feature(const_generics)]` to the crate attributes to enable\n \n error[E0658]: const generics are unstable\n-  --> $DIR/feature-gate-const_generics-ptr.rs:5:23\n+  --> $DIR/feature-gate-const_generics-ptr.rs:5:17\n    |\n LL | struct ConstPtr<const P: *const u32>;\n-   |                       ^\n+   |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/44580\n    = help: add `#![feature(const_generics)]` to the crate attributes to enable"}, {"sha": "0adc9902a6937462f490e2899006484868f81f22", "filename": "src/test/ui/feature-gates/feature-gate-const_generics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -2,4 +2,9 @@ fn foo<const X: ()>() {} //~ ERROR const generics are unstable\n \n struct Foo<const X: usize>([(); X]); //~ ERROR const generics are unstable\n \n+macro_rules! accept_item { ($i:item) => {} }\n+accept_item! {\n+    impl<const X: ()> A {} //~ ERROR const generics are unstable\n+}\n+\n fn main() {}"}, {"sha": "f0154ed289f140c73d276444f301a4d5f681fabe", "filename": "src/test/ui/feature-gates/feature-gate-const_generics.stderr", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,21 +1,30 @@\n error[E0658]: const generics are unstable\n-  --> $DIR/feature-gate-const_generics.rs:1:14\n+  --> $DIR/feature-gate-const_generics.rs:1:8\n    |\n LL | fn foo<const X: ()>() {}\n-   |              ^\n+   |        ^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/44580\n    = help: add `#![feature(const_generics)]` to the crate attributes to enable\n \n error[E0658]: const generics are unstable\n-  --> $DIR/feature-gate-const_generics.rs:3:18\n+  --> $DIR/feature-gate-const_generics.rs:3:12\n    |\n LL | struct Foo<const X: usize>([(); X]);\n-   |                  ^\n+   |            ^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/44580\n    = help: add `#![feature(const_generics)]` to the crate attributes to enable\n \n-error: aborting due to 2 previous errors\n+error[E0658]: const generics are unstable\n+  --> $DIR/feature-gate-const_generics.rs:7:10\n+   |\n+LL |     impl<const X: ()> A {}\n+   |          ^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/44580\n+   = help: add `#![feature(const_generics)]` to the crate attributes to enable\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "7517fb280ea785487ba19b2ad2a3d67c40315848", "filename": "src/test/ui/feature-gates/feature-gate-crate_visibility_modifier.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-crate_visibility_modifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-crate_visibility_modifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-crate_visibility_modifier.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -5,4 +5,7 @@ crate struct Bender { //~ ERROR `crate` visibility modifier is experimental\n     water: bool,\n }\n \n+macro_rules! accept_vis { ($v:vis) => {} }\n+accept_vis!(crate);  //~ ERROR `crate` visibility modifier is experimental\n+\n fn main() {}"}, {"sha": "b317872cea81729bdb872e7ed4630355f4290aa2", "filename": "src/test/ui/feature-gates/feature-gate-crate_visibility_modifier.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-crate_visibility_modifier.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-crate_visibility_modifier.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-crate_visibility_modifier.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -7,6 +7,15 @@ LL | crate struct Bender {\n    = note: for more information, see https://github.com/rust-lang/rust/issues/53120\n    = help: add `#![feature(crate_visibility_modifier)]` to the crate attributes to enable\n \n-error: aborting due to previous error\n+error[E0658]: `crate` visibility modifier is experimental\n+  --> $DIR/feature-gate-crate_visibility_modifier.rs:9:13\n+   |\n+LL | accept_vis!(crate);\n+   |             ^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53120\n+   = help: add `#![feature(crate_visibility_modifier)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "b208a047481a4b35183ab4921e49712127f2bfcf", "filename": "src/test/ui/feature-gates/feature-gate-decl_macro.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-decl_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-decl_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-decl_macro.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -2,4 +2,8 @@\n \n macro m() {} //~ ERROR `macro` is experimental\n \n+macro_rules! accept_item { ($i:item) => {} }\n+accept_item! {\n+    macro m() {} //~ ERROR `macro` is experimental\n+}\n fn main() {}"}, {"sha": "c6690ebd4d91779186143f076e2bf106fe350905", "filename": "src/test/ui/feature-gates/feature-gate-decl_macro.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-decl_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-decl_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-decl_macro.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -7,6 +7,15 @@ LL | macro m() {}\n    = note: for more information, see https://github.com/rust-lang/rust/issues/39412\n    = help: add `#![feature(decl_macro)]` to the crate attributes to enable\n \n-error: aborting due to previous error\n+error[E0658]: `macro` is experimental\n+  --> $DIR/feature-gate-decl_macro.rs:7:5\n+   |\n+LL |     macro m() {}\n+   |     ^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/39412\n+   = help: add `#![feature(decl_macro)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "594ec73fe26f7954948392b138944aa7852e3133", "filename": "src/test/ui/feature-gates/feature-gate-exclusive-range-pattern.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exclusive-range-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exclusive-range-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exclusive-range-pattern.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,6 +1,10 @@\n-pub fn main() {\n+#[cfg(FALSE)]\n+fn foo() {\n     match 22 {\n         0 .. 3 => {} //~ ERROR exclusive range pattern syntax is experimental\n+        PATH .. 3 => {} //~ ERROR exclusive range pattern syntax is experimental\n         _ => {}\n     }\n }\n+\n+fn main() {}"}, {"sha": "075fdbed90d6c7b0c6ae58824c8591a5a28e47f6", "filename": "src/test/ui/feature-gates/feature-gate-exclusive-range-pattern.stderr", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exclusive-range-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exclusive-range-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exclusive-range-pattern.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,12 +1,21 @@\n error[E0658]: exclusive range pattern syntax is experimental\n-  --> $DIR/feature-gate-exclusive-range-pattern.rs:3:9\n+  --> $DIR/feature-gate-exclusive-range-pattern.rs:4:11\n    |\n LL |         0 .. 3 => {}\n-   |         ^^^^^^\n+   |           ^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/37854\n    = help: add `#![feature(exclusive_range_pattern)]` to the crate attributes to enable\n \n-error: aborting due to previous error\n+error[E0658]: exclusive range pattern syntax is experimental\n+  --> $DIR/feature-gate-exclusive-range-pattern.rs:5:14\n+   |\n+LL |         PATH .. 3 => {}\n+   |              ^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/37854\n+   = help: add `#![feature(exclusive_range_pattern)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "8d7ecd27b450fd0e035304515b54674ee8a683b5", "filename": "src/test/ui/feature-gates/feature-gate-label_break_value.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-label_break_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-label_break_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-label_break_value.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,5 +1,8 @@\n-pub fn main() {\n+#[cfg(FALSE)]\n+pub fn foo() {\n     'a: { //~ ERROR labels on blocks are unstable\n         break 'a;\n     }\n }\n+\n+fn main() {}"}, {"sha": "6a861d3e04f92be31a72b983ecdf1564e65dc1f9", "filename": "src/test/ui/feature-gates/feature-gate-label_break_value.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-label_break_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-label_break_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-label_break_value.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: labels on blocks are unstable\n-  --> $DIR/feature-gate-label_break_value.rs:2:5\n+  --> $DIR/feature-gate-label_break_value.rs:3:5\n    |\n LL |     'a: {\n    |     ^^"}, {"sha": "4b94d7d6d3bdad3f8e879c319b025cd198d42701", "filename": "src/test/ui/feature-gates/feature-gate-trait-alias.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait-alias.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,4 +1,13 @@\n trait Foo = Default;\n //~^ ERROR trait aliases are experimental\n \n+macro_rules! accept_item {\n+    ($i:item) => {}\n+}\n+\n+accept_item! {\n+    trait Foo = Ord + Eq;\n+    //~^ ERROR trait aliases are experimental\n+}\n+\n fn main() {}"}, {"sha": "b1bf6ad3491293ff9e809ddfbdb946f17e5dc05a", "filename": "src/test/ui/feature-gates/feature-gate-trait-alias.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait-alias.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -7,6 +7,15 @@ LL | trait Foo = Default;\n    = note: for more information, see https://github.com/rust-lang/rust/issues/41517\n    = help: add `#![feature(trait_alias)]` to the crate attributes to enable\n \n-error: aborting due to previous error\n+error[E0658]: trait aliases are experimental\n+  --> $DIR/feature-gate-trait-alias.rs:9:5\n+   |\n+LL |     trait Foo = Ord + Eq;\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/41517\n+   = help: add `#![feature(trait_alias)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "b451ba84a15654eec1efacbb552b8c614098cfc5", "filename": "src/test/ui/feature-gates/feature-gate-try_blocks.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-try_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-try_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-try_blocks.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,9 +1,12 @@\n // compile-flags: --edition 2018\n \n-pub fn main() {\n-    let try_result: Option<_> = try { //~ ERROR `try` expression is experimental\n+#[cfg(FALSE)]\n+fn foo() {\n+    let try_result: Option<_> = try { //~ ERROR `try` blocks are unstable\n         let x = 5;\n         x\n     };\n     assert_eq!(try_result, Some(5));\n }\n+\n+fn main() {}"}, {"sha": "44a7d9b9043fd352e058e359e2fef94b1f8c550a", "filename": "src/test/ui/feature-gates/feature-gate-try_blocks.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-try_blocks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-try_blocks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-try_blocks.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,5 +1,5 @@\n-error[E0658]: `try` expression is experimental\n-  --> $DIR/feature-gate-try_blocks.rs:4:33\n+error[E0658]: `try` blocks are unstable\n+  --> $DIR/feature-gate-try_blocks.rs:5:33\n    |\n LL |       let try_result: Option<_> = try {\n    |  _________________________________^"}, {"sha": "655891d802c1ceda3cc54331dedd4bd8106e8262", "filename": "src/test/ui/feature-gates/feature-gate-type_ascription.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_ascription.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_ascription.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_ascription.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,5 +1,8 @@\n // Type ascription is unstable\n \n-fn main() {\n+#[cfg(FALSE)]\n+fn foo() {\n     let a = 10: u8; //~ ERROR type ascription is experimental\n }\n+\n+fn main() {}"}, {"sha": "d63d624c6c112bfd74ac6602f6196778dc51ec72", "filename": "src/test/ui/feature-gates/feature-gate-type_ascription.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_ascription.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_ascription.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_ascription.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: type ascription is experimental\n-  --> $DIR/feature-gate-type_ascription.rs:4:13\n+  --> $DIR/feature-gate-type_ascription.rs:5:13\n    |\n LL |     let a = 10: u8;\n    |             ^^^^^^"}, {"sha": "2182b3a313efb86583cfe52135a3b414ecb17a0c", "filename": "src/test/ui/feature-gates/feature-gate-untagged_unions.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -6,7 +6,7 @@ LL | |     a: String,\n LL | | }\n    | |_^\n    |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/32836\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/55149\n    = help: add `#![feature(untagged_unions)]` to the crate attributes to enable\n \n error[E0658]: unions with non-`Copy` fields are unstable\n@@ -17,7 +17,7 @@ LL | |     a: T,\n LL | | }\n    | |_^\n    |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/32836\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/55149\n    = help: add `#![feature(untagged_unions)]` to the crate attributes to enable\n \n error[E0658]: unions with `Drop` implementations are unstable\n@@ -28,7 +28,7 @@ LL | |     a: u8,\n LL | | }\n    | |_^\n    |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/32836\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/55149\n    = help: add `#![feature(untagged_unions)]` to the crate attributes to enable\n \n error[E0740]: unions may not contain fields that need dropping"}, {"sha": "8f05ab3c4940c30e22f0f170108907dbeb31e65e", "filename": "src/test/ui/impl-trait/issues/universal-issue-48703.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-issue-48703.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-issue-48703.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-issue-48703.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,8 +1,8 @@\n error[E0632]: cannot provide explicit generic arguments when `impl Trait` is used in argument position\n-  --> $DIR/universal-issue-48703.rs:8:5\n+  --> $DIR/universal-issue-48703.rs:8:11\n    |\n LL |     foo::<String>('a');\n-   |     ^^^^^^^^^^^^^\n+   |           ^^^^^^ explicit generic argument not allowed\n \n error: aborting due to previous error\n "}, {"sha": "c980e9463e48ae383b377412b67cfaac37976414", "filename": "src/test/ui/impl-trait/issues/universal-turbofish-in-method-issue-50950.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-turbofish-in-method-issue-50950.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-turbofish-in-method-issue-50950.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Funiversal-turbofish-in-method-issue-50950.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,8 +1,10 @@\n error[E0632]: cannot provide explicit generic arguments when `impl Trait` is used in argument position\n-  --> $DIR/universal-turbofish-in-method-issue-50950.rs:14:9\n+  --> $DIR/universal-turbofish-in-method-issue-50950.rs:14:24\n    |\n LL |     evt.handle_event::<TestEvent, fn(TestEvent)>(|_evt| {\n-   |         ^^^^^^^^^^^^\n+   |                        ^^^^^^^^^  ^^^^^^^^^^^^^ explicit generic argument not allowed\n+   |                        |\n+   |                        explicit generic argument not allowed\n \n error: aborting due to previous error\n "}, {"sha": "e370b2ec1cb42c62884524ae00fb9f2c90802737", "filename": "src/test/ui/issues/issue-19883.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fissues%2Fissue-19883.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fissues%2Fissue-19883.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-19883.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -6,3 +6,4 @@ LL |         <Dst as From<Self>>::Dst\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0576`."}, {"sha": "615628558f08bce45cc63662a94b11c07afd96d2", "filename": "src/test/ui/issues/issue-22037.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fissues%2Fissue-22037.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fissues%2Fissue-22037.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22037.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -6,3 +6,4 @@ LL |     fn a(&self) -> <Self as A>::X;\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0576`."}, {"sha": "1f767a443d0f0bf12c06609055f683194970cdad", "filename": "src/test/ui/issues/issue-22384.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fissues%2Fissue-22384.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fissues%2Fissue-22384.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22384.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -6,3 +6,4 @@ LL |     <<i32 as Copy>::foobar as Trait>::foo();\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0576`."}, {"sha": "20d6e47f75300cab5fa2405fa1b7866982a116db", "filename": "src/test/ui/nll/empty-type-predicate-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fnll%2Fempty-type-predicate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fnll%2Fempty-type-predicate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fempty-type-predicate-2.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -0,0 +1,18 @@\n+// Regression test for #65553\n+//\n+// `D::Error:` is lowered to `D::Error: ReEmpty` - check that we don't ICE in\n+// NLL for the unexpected region.\n+\n+// check-pass\n+\n+trait Deserializer {\n+    type Error;\n+}\n+\n+fn d1<D: Deserializer>() where D::Error: {}\n+\n+fn d2<D: Deserializer>() {\n+    d1::<D>();\n+}\n+\n+fn main() {}"}, {"sha": "d126a455daeb204e77f11ff63139de60378bdd99", "filename": "src/test/ui/nll/empty-type-predicate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fnll%2Fempty-type-predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fnll%2Fempty-type-predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fempty-type-predicate.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -3,9 +3,9 @@\n // `dyn T:` is lowered to `dyn T: ReEmpty` - check that we don't ICE in NLL for\n // the unexpected region.\n \n-// build-pass (FIXME(62277): could be check-pass?)\n+// check-pass\n \n trait T {}\n fn f() where dyn T: {}\n \n-fn main() {}\n+fn main() { f(); }"}, {"sha": "9667711242ce61d57d9594051811c1bde10c98fd", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-pass.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -4,6 +4,7 @@\n // check-pass\n \n #![feature(or_patterns)]\n+#![feature(box_patterns)]\n \n fn main() {}\n "}, {"sha": "6b8c146949aecc5916581e1fe1760d4f55ca480a", "filename": "src/test/ui/parser/pat-tuple-4.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-4.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -4,7 +4,6 @@ fn main() {\n     match 0 {\n         (.. PAT) => {}\n         //~^ ERROR `..X` range patterns are not supported\n-        //~| ERROR exclusive range pattern syntax is experimental\n     }\n }\n "}, {"sha": "1962dc4ff20a87d29016b3894f14dc373e105c62", "filename": "src/test/ui/parser/pat-tuple-4.stderr", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-4.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -4,25 +4,15 @@ error: `..X` range patterns are not supported\n LL |         (.. PAT) => {}\n    |          ^^^^^^ help: try using the minimum value for the type: `MIN..PAT`\n \n-error[E0658]: exclusive range pattern syntax is experimental\n-  --> $DIR/pat-tuple-4.rs:5:10\n-   |\n-LL |         (.. PAT) => {}\n-   |          ^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/37854\n-   = help: add `#![feature(exclusive_range_pattern)]` to the crate attributes to enable\n-\n error[E0308]: mismatched types\n-  --> $DIR/pat-tuple-4.rs:11:30\n+  --> $DIR/pat-tuple-4.rs:10:30\n    |\n LL | const RECOVERY_WITNESS: () = 0;\n    |                              ^ expected (), found integer\n    |\n    = note: expected type `()`\n               found type `{integer}`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0308, E0658.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "17155b4dd49544050eb5772e3d2b4347bde3cc16", "filename": "src/test/ui/parser/pat-tuple-5.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -5,10 +5,10 @@ LL |         (PAT ..) => {}\n    |          ^^^^^^ help: try using the maximum value for the type: `PAT..MAX`\n \n error[E0658]: exclusive range pattern syntax is experimental\n-  --> $DIR/pat-tuple-5.rs:5:10\n+  --> $DIR/pat-tuple-5.rs:5:14\n    |\n LL |         (PAT ..) => {}\n-   |          ^^^^^^\n+   |              ^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/37854\n    = help: add `#![feature(exclusive_range_pattern)]` to the crate attributes to enable"}, {"sha": "45b31f6125374254c69dcecb8879fc1c4bebe8f5", "filename": "src/test/ui/pattern/rest-pat-syntactic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fpattern%2Frest-pat-syntactic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fpattern%2Frest-pat-syntactic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Frest-pat-syntactic.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -3,6 +3,8 @@\n \n // check-pass\n \n+#![feature(box_patterns)]\n+\n fn main() {}\n \n macro_rules! accept_pat {"}, {"sha": "f1144a4a55b16f65aec804d8c172b1f5901b5349", "filename": "src/test/ui/proc-macro/proc-macro-deprecated-attr.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-deprecated-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-deprecated-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-deprecated-attr.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+// force-host\n+// no-prefer-dynamic\n+\n+#![deny(deprecated)]\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro]\n+#[deprecated(since = \"1.0.0\", note = \"test\")]\n+pub fn test_compile_without_warning_with_deprecated(_: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}"}, {"sha": "0096e2963007a442f05c70aea27779619cccba9e", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/issue-65157-repeated-match-arm.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -0,0 +1,22 @@\n+// aux-build:uninhabited.rs\n+#![deny(unreachable_patterns)]\n+#![feature(never_type)]\n+#![feature(non_exhaustive)]\n+\n+extern crate uninhabited;\n+\n+use uninhabited::PartiallyInhabitedVariants;\n+\n+// This test checks a redundant/useless pattern of a non-exhaustive enum/variant is still\n+// warned against.\n+\n+pub fn foo(x: PartiallyInhabitedVariants) {\n+    match x {\n+        PartiallyInhabitedVariants::Struct { .. } => {},\n+        PartiallyInhabitedVariants::Struct { .. } => {},\n+        //~^ ERROR unreachable pattern\n+        _ => {},\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "d46b1fd4c420252f6d34b8f7bb2505889582833a", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/issue-65157-repeated-match-arm.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -0,0 +1,14 @@\n+error: unreachable pattern\n+  --> $DIR/issue-65157-repeated-match-arm.rs:16:9\n+   |\n+LL |         PartiallyInhabitedVariants::Struct { .. } => {},\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-65157-repeated-match-arm.rs:2:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "951d7edb7f523ec14cbd3ad24f921b9d963fe8a5", "filename": "src/test/ui/synthetic-param.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fsynthetic-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fsynthetic-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsynthetic-param.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,20 +1,20 @@\n error[E0632]: cannot provide explicit generic arguments when `impl Trait` is used in argument position\n-  --> $DIR/synthetic-param.rs:20:5\n+  --> $DIR/synthetic-param.rs:20:12\n    |\n LL |     func::<u8>(42);\n-   |     ^^^^^^^^^^\n+   |            ^^ explicit generic argument not allowed\n \n error[E0632]: cannot provide explicit generic arguments when `impl Trait` is used in argument position\n-  --> $DIR/synthetic-param.rs:23:5\n+  --> $DIR/synthetic-param.rs:23:17\n    |\n LL |     Foo::func::<u8>(42);\n-   |     ^^^^^^^^^^^^^^^\n+   |                 ^^ explicit generic argument not allowed\n \n error[E0632]: cannot provide explicit generic arguments when `impl Trait` is used in argument position\n-  --> $DIR/synthetic-param.rs:26:5\n+  --> $DIR/synthetic-param.rs:26:23\n    |\n LL |     Bar::<i8>::func::<u8>(42);\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |                       ^^ explicit generic argument not allowed\n \n error: aborting due to 3 previous errors\n "}, {"sha": "039bbce8c1ed0f279237e20da56fe8ea0b72cf91", "filename": "src/test/ui/traits/trait-alias/trait-alias-syntax-fail.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-syntax-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-syntax-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-syntax-fail.rs?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -4,4 +4,7 @@ trait Foo {}\n auto trait A = Foo; //~ ERROR trait aliases cannot be `auto`\n unsafe trait B = Foo; //~ ERROR trait aliases cannot be `unsafe`\n \n+trait C: Ord = Eq; //~ ERROR bounds are not allowed on trait aliases\n+trait D: = Eq; //~ ERROR bounds are not allowed on trait aliases\n+\n fn main() {}"}, {"sha": "18c22133bc780ca3f40d8fc412c2c106f11b519d", "filename": "src/test/ui/traits/trait-alias/trait-alias-syntax-fail.stderr", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-syntax-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-syntax-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-syntax-fail.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -1,14 +1,26 @@\n error: trait aliases cannot be `auto`\n-  --> $DIR/trait-alias-syntax-fail.rs:4:19\n+  --> $DIR/trait-alias-syntax-fail.rs:4:1\n    |\n LL | auto trait A = Foo;\n-   |                   ^ trait aliases cannot be `auto`\n+   | ^^^^^^^^^^^^^^^^^^^ trait aliases cannot be `auto`\n \n error: trait aliases cannot be `unsafe`\n-  --> $DIR/trait-alias-syntax-fail.rs:5:21\n+  --> $DIR/trait-alias-syntax-fail.rs:5:1\n    |\n LL | unsafe trait B = Foo;\n-   |                     ^ trait aliases cannot be `unsafe`\n+   | ^^^^^^^^^^^^^^^^^^^^^ trait aliases cannot be `unsafe`\n \n-error: aborting due to 2 previous errors\n+error: bounds are not allowed on trait aliases\n+  --> $DIR/trait-alias-syntax-fail.rs:7:8\n+   |\n+LL | trait C: Ord = Eq;\n+   |        ^^^^^\n+\n+error: bounds are not allowed on trait aliases\n+  --> $DIR/trait-alias-syntax-fail.rs:8:8\n+   |\n+LL | trait D: = Eq;\n+   |        ^\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "ea9cca2bfaab09f188a47b52704140ef308c39a9", "filename": "src/test/ui/type/type-path-err-node-types.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ftype%2Ftype-path-err-node-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Ftype%2Ftype-path-err-node-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-path-err-node-types.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -30,5 +30,5 @@ LL |     let _ = |a, b: _| -> _ { 0 };\n \n error: aborting due to 5 previous errors\n \n-Some errors have detailed explanations: E0282, E0412, E0425, E0433.\n+Some errors have detailed explanations: E0282, E0412, E0425, E0433, E0576.\n For more information about an error, try `rustc --explain E0282`."}, {"sha": "dee990ec3d1cb12487cdb0c5f9b45bd93cef36ad", "filename": "src/test/ui/ufcs/ufcs-partially-resolved.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd2df8f97db8319e0eea433bfbc68244150d7bea/src%2Ftest%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr?ref=dd2df8f97db8319e0eea433bfbc68244150d7bea", "patch": "@@ -200,5 +200,5 @@ LL |     <u8 as Dr>::X::N;\n \n error: aborting due to 32 previous errors\n \n-Some errors have detailed explanations: E0223, E0433, E0575, E0599.\n+Some errors have detailed explanations: E0223, E0433, E0575, E0576, E0599.\n For more information about an error, try `rustc --explain E0223`."}]}