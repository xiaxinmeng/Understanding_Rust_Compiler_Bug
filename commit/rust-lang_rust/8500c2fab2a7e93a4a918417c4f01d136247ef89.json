{"sha": "8500c2fab2a7e93a4a918417c4f01d136247ef89", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1MDBjMmZhYjJhN2U5M2E0YTkxODQxN2M0ZjAxZDEzNjI0N2VmODk=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-01-31T14:06:45Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-08T07:34:16Z"}, "message": "Const eval error refactoring", "tree": {"sha": "2d092b72bd2a799d21d0d6cf7d58f8902c1f9894", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d092b72bd2a799d21d0d6cf7d58f8902c1f9894"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8500c2fab2a7e93a4a918417c4f01d136247ef89", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlqg53gACgkQpp+NIls6\n19lL+g/5AeQhe61VgOKHm6fRdsA0IzOzw/yc6wm1R/mkho4GerOk2hssA7T2hGt2\nqFCD9/LC86ExaJDutmCjROT/o2h/WxhFpXSnipErtx6fILX2YsBu/k7ZsKMAWRJw\nOWwpxycqaOQm9ntiSRRs/HEF4i2Dc1JCKXvZqs2eJSeB/pPinwkuCvUYj63Fcgtx\nn8LqZODE1c80GBaSGu4q1YJGRXU1rORmY0IggBrg+N6L9CZG78Hg/D2mSfkB8Twy\neT/dVqkPnNZJTSS5+7/8FCmxOstwD0s9QVjz2ujLMmzJVfTiyPQEMGx6aXiFkzXN\nekMOso0//mN6O01IdWejZMFkyTQLJcPDSppdfzK1ewUGwB+I7oRYAzpq+41x12Yn\nHWaxh6pQ2yIuOiH64UJ1eAO/3ar/rBEK+9YxRbV2dH8vf9vJt0FkJpR+3+VPM8dZ\nfDVO+cU22RxURmuFRBmAKFnXhF6bpgg4lXSse/aaSh/ZavzzsGIJkIXBHmDaxHDk\nGHaWlGV6ntCfkM+5mQvbaN/GoMpUeQ/iIhYaBpJomn8tYoL0wKGnjNn38REr36df\npCMphjHTEYm4g7dumqp/mkvQhWozp1zalodq9S6mXtj4QZVMh6zFmu2BFRNmMpKb\nItRtXaOOJBZMo7ZrcTIg27KyjFm01Cjp7RwQce1xVeCaULSDV14=\n=gV17\n-----END PGP SIGNATURE-----", "payload": "tree 2d092b72bd2a799d21d0d6cf7d58f8902c1f9894\nparent bd03371f711adcb7724c939ea053f4090e87c16f\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1517407605 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1520494456 +0100\n\nConst eval error refactoring\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8500c2fab2a7e93a4a918417c4f01d136247ef89", "html_url": "https://github.com/rust-lang/rust/commit/8500c2fab2a7e93a4a918417c4f01d136247ef89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8500c2fab2a7e93a4a918417c4f01d136247ef89/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd03371f711adcb7724c939ea053f4090e87c16f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd03371f711adcb7724c939ea053f4090e87c16f", "html_url": "https://github.com/rust-lang/rust/commit/bd03371f711adcb7724c939ea053f4090e87c16f"}], "stats": {"total": 193, "additions": 109, "deletions": 84}, "files": [{"sha": "d5476f742c896f0b7b7ae5fca7488c19e301d94b", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8500c2fab2a7e93a4a918417c4f01d136247ef89/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8500c2fab2a7e93a4a918417c4f01d136247ef89/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=8500c2fab2a7e93a4a918417c4f01d136247ef89", "patch": "@@ -531,6 +531,7 @@ for ::mir::interpret::EvalError<'gcx> {\n             TypeckError |\n             DerefFunctionPointer |\n             ExecuteMemory |\n+            ReferencedConstant |\n             OverflowingMath => {}\n             MachineError(ref err) => err.hash_stable(hcx, hasher),\n             FunctionPointerTyMismatch(a, b) => {"}, {"sha": "151cc9b1ce2ab7999a3fb659bcb5637f6f3355ab", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8500c2fab2a7e93a4a918417c4f01d136247ef89/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8500c2fab2a7e93a4a918417c4f01d136247ef89/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=8500c2fab2a7e93a4a918417c4f01d136247ef89", "patch": "@@ -173,6 +173,13 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n     {\n         match *self.kind {\n             ErrKind::TypeckError | ErrKind::CheckMatchError => return,\n+            ErrKind::Miri(ref miri, _) => {\n+                match miri.kind {\n+                    ::mir::interpret::EvalErrorKind::TypeckError |\n+                    ::mir::interpret::EvalErrorKind::Layout(_) => return,\n+                    _ => {},\n+                }\n+            }\n             _ => {}\n         }\n         self.struct_error(tcx, primary_span, primary_kind).emit();"}, {"sha": "bb27628fa9c73f4dab295ecd80dc3e1d4ed16414", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8500c2fab2a7e93a4a918417c4f01d136247ef89/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8500c2fab2a7e93a4a918417c4f01d136247ef89/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=8500c2fab2a7e93a4a918417c4f01d136247ef89", "patch": "@@ -124,6 +124,9 @@ pub enum EvalErrorKind<'tcx> {\n     UnimplementedTraitSelection,\n     /// Abort in case type errors are reached\n     TypeckError,\n+    /// Cannot compute this constant because it depends on another one\n+    /// which already produced an error\n+    ReferencedConstant,\n }\n \n pub type EvalResult<'tcx, T = ()> = Result<T, EvalError<'tcx>>;\n@@ -245,6 +248,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"there were unresolved type arguments during trait selection\",\n             TypeckError =>\n                 \"encountered constants with type errors, stopping evaluation\",\n+            ReferencedConstant =>\n+                \"referenced constant has errors\",\n         }\n     }\n }"}, {"sha": "243e17ee5c7ecb4d96b37cda3065d62c9ac18d3a", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8500c2fab2a7e93a4a918417c4f01d136247ef89/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8500c2fab2a7e93a4a918417c4f01d136247ef89/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=8500c2fab2a7e93a4a918417c4f01d136247ef89", "patch": "@@ -689,6 +689,7 @@ impl<'a, 'tcx> Lift<'tcx> for interpret::EvalError<'a> {\n             PathNotFound(ref v) => PathNotFound(v.clone()),\n             UnimplementedTraitSelection => UnimplementedTraitSelection,\n             TypeckError => TypeckError,\n+            ReferencedConstant => ReferencedConstant,\n         };\n         Some(interpret::EvalError {\n             kind: kind,"}, {"sha": "a4100a9d28af6a5276b2ac33c4d6f5240c84ffb6", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 41, "deletions": 51, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/8500c2fab2a7e93a4a918417c4f01d136247ef89/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8500c2fab2a7e93a4a918417c4f01d136247ef89/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=8500c2fab2a7e93a4a918417c4f01d136247ef89", "patch": "@@ -1,7 +1,6 @@\n use rustc::hir;\n use rustc::middle::const_val::{ConstEvalErr, ConstVal, ErrKind};\n use rustc::middle::const_val::ErrKind::{TypeckError, CheckMatchError};\n-use rustc::traits;\n use rustc::mir;\n use rustc::ty::{self, TyCtxt, Ty, Instance};\n use rustc::ty::layout::{self, LayoutOf};\n@@ -15,6 +14,7 @@ use super::{Place, EvalContext, StackPopCleanup, ValTy, PlaceExtra, Memory};\n \n use std::fmt;\n use std::error::Error;\n+use std::rc::Rc;\n \n pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -236,7 +236,7 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         let mir = match ecx.load_mir(instance.def) {\n             Ok(mir) => mir,\n             Err(err) => {\n-                if let EvalErrorKind::NoMirFor(ref path) = *err.kind {\n+                if let EvalErrorKind::NoMirFor(ref path) = err.kind {\n                     return Err(\n                         ConstEvalError::NeedsRfc(format!(\"calling extern function `{}`\", path))\n                             .into(),\n@@ -333,15 +333,8 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         cid: GlobalId<'tcx>,\n     ) -> EvalResult<'tcx, AllocId> {\n-        let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n         // ensure the static is computed\n-        if let Err(err) = ecx.tcx.const_eval(param_env.and(cid)) {\n-            match err.kind {\n-                ErrKind::Miri(miri) => return Err(miri),\n-                ErrKind::TypeckError => return err!(TypeckError),\n-                other => bug!(\"const eval returned {:?}\", other),\n-            }\n-        };\n+        ecx.const_eval(cid)?;\n         Ok(ecx\n             .tcx\n             .interpret_interner\n@@ -377,52 +370,47 @@ pub fn const_val_field<'a, 'tcx>(\n     span: Span,\n     variant: Option<usize>,\n     field: mir::Field,\n-    val: Value,\n+    value: Value,\n     ty: Ty<'tcx>,\n ) -> ::rustc::middle::const_val::EvalResult<'tcx> {\n-    match const_val_field_inner(tcx, param_env, instance, variant, field, val, ty) {\n+    trace!(\"const_val_field: {:?}, {:?}, {:?}, {:?}\", instance, field, value, ty);\n+    let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n+    let result = (|| {\n+        let (mut field, ty) = match value {\n+            Value::ByValPair(..) | Value::ByVal(_) => ecx.read_field(value, variant, field, ty)?.expect(\"const_val_field on non-field\"),\n+            Value::ByRef(ptr, align) => {\n+                let place = Place::Ptr {\n+                    ptr,\n+                    align,\n+                    extra: variant.map_or(PlaceExtra::None, PlaceExtra::DowncastVariant),\n+                };\n+                let layout = ecx.layout_of(ty)?;\n+                let (place, layout) = ecx.place_field(place, field, layout)?;\n+                let (ptr, align) = place.to_ptr_align();\n+                (Value::ByRef(ptr, align), layout.ty)\n+            }\n+        };\n+        if let Value::ByRef(ptr, align) = field {\n+            if let Some(val) = ecx.try_read_value(ptr, align, ty)? {\n+                field = val;\n+            }\n+        }\n+        Ok((field, ty))\n+    })();\n+    match result {\n         Ok((field, ty)) => Ok(tcx.mk_const(ty::Const {\n             val: ConstVal::Value(field),\n             ty,\n         })),\n-        Err(err) => Err(ConstEvalErr {\n-            span,\n-            kind: err.into(),\n-        }),\n-    }\n-}\n-\n-fn const_val_field_inner<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    instance: ty::Instance<'tcx>,\n-    variant: Option<usize>,\n-    field: mir::Field,\n-    value: Value,\n-    ty: Ty<'tcx>,\n-) -> EvalResult<'tcx, (Value, Ty<'tcx>)> {\n-    trace!(\"const_val_field: {:?}, {:?}, {:?}, {:?}\", instance, field, value, ty);\n-    let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n-    let (mut field, ty) = match value {\n-        Value::ByValPair(..) | Value::ByVal(_) => ecx.read_field(value, variant, field, ty)?.expect(\"const_val_field on non-field\"),\n-        Value::ByRef(ptr, align) => {\n-            let place = Place::Ptr {\n-                ptr,\n-                align,\n-                extra: variant.map_or(PlaceExtra::None, PlaceExtra::DowncastVariant),\n-            };\n-            let layout = ecx.layout_of(ty)?;\n-            let (place, layout) = ecx.place_field(place, field, layout)?;\n-            let (ptr, align) = place.to_ptr_align();\n-            (Value::ByRef(ptr, align), layout.ty)\n-        }\n-    };\n-    if let Value::ByRef(ptr, align) = field {\n-        if let Some(val) = ecx.try_read_value(ptr, align, ty)? {\n-            field = val;\n-        }\n+        Err(err) => {\n+            let trace = ecx.generate_stacktrace(None);\n+            let err = ErrKind::Miri(err, trace);\n+            Err(ConstEvalErr {\n+                kind: err.into(),\n+                span,\n+            })\n+        },\n     }\n-    Ok((field, ty))\n }\n \n pub fn const_discr<'a, 'tcx>(\n@@ -484,7 +472,7 @@ pub fn const_eval_provider<'a, 'tcx>(\n         // Do match-check before building MIR\n         if tcx.check_match(def_id).is_err() {\n             return Err(ConstEvalErr {\n-                kind: CheckMatchError,\n+                kind: Rc::new(CheckMatchError),\n                 span,\n             });\n         }\n@@ -496,7 +484,7 @@ pub fn const_eval_provider<'a, 'tcx>(\n         // Do not continue into miri if typeck errors occurred; it will fail horribly\n         if tables.tainted_by_errors {\n             return Err(ConstEvalErr {\n-                kind: TypeckError,\n+                kind: Rc::new(TypeckError),\n                 span,\n             });\n         }\n@@ -512,6 +500,8 @@ pub fn const_eval_provider<'a, 'tcx>(\n         if tcx.is_static(def_id).is_some() {\n             ecx.report(&mut err, true, None);\n         }\n+        let trace = ecx.generate_stacktrace(None);\n+        let err = ErrKind::Miri(err, trace);\n         ConstEvalErr {\n             kind: err.into(),\n             span,"}, {"sha": "483649204fbecf7a1700929892731057f307d57b", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 54, "deletions": 33, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/8500c2fab2a7e93a4a918417c4f01d136247ef89/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8500c2fab2a7e93a4a918417c4f01d136247ef89/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=8500c2fab2a7e93a4a918417c4f01d136247ef89", "patch": "@@ -10,6 +10,7 @@ use rustc::ty::layout::{self, Size, Align, HasDataLayout, LayoutOf, TyLayout};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc::middle::const_val::FrameInfo;\n use syntax::codemap::{self, DUMMY_SP, Span};\n use syntax::ast::Mutability;\n use rustc::mir::interpret::{\n@@ -934,17 +935,28 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 return Ok(Value::ByRef(ptr.into(), layout.align))\n             }\n         }\n-        let cv = match self.tcx.const_eval(self.param_env.and(gid)) {\n-            Ok(val) => val,\n-            Err(err) => match err.kind {\n-                ErrKind::Miri(miri) => return Err(miri),\n-                ErrKind::TypeckError => return err!(TypeckError),\n-                other => bug!(\"const eval returned {:?}\", other),\n-            },\n-        };\n+        let cv = self.const_eval(gid)?;\n         self.const_to_value(&cv.val, ty)\n     }\n \n+    pub fn const_eval(&self, gid: GlobalId<'tcx>) -> EvalResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        let param_env = if self.tcx.is_static(gid.instance.def_id()).is_some() {\n+            use rustc::traits;\n+            ty::ParamEnv::empty(traits::Reveal::All)\n+        } else {\n+            self.param_env\n+        };\n+        self.tcx.const_eval(param_env.and(gid)).map_err(|err| match *err.kind {\n+            ErrKind::Miri(ref err, _) => match err.kind {\n+                EvalErrorKind::TypeckError |\n+                EvalErrorKind::Layout(_) => EvalErrorKind::TypeckError.into(),\n+                _ => EvalErrorKind::ReferencedConstant.into(),\n+            },\n+            ErrKind::TypeckError => EvalErrorKind::TypeckError.into(),\n+            ref other => bug!(\"const eval returned {:?}\", other),\n+        })\n+    }\n+\n     pub fn force_allocation(&mut self, place: Place) -> EvalResult<'tcx, Place> {\n         let new_place = match place {\n             Place::Local { frame, local } => {\n@@ -1496,7 +1508,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n                 match self.stack[frame].get_local(local) {\n                     Err(err) => {\n-                        if let EvalErrorKind::DeadLocal = *err.kind {\n+                        if let EvalErrorKind::DeadLocal = err.kind {\n                             write!(msg, \" is dead\").unwrap();\n                         } else {\n                             panic!(\"Failed to access local: {:?}\", err);\n@@ -1558,9 +1570,38 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         Ok(())\n     }\n \n+    pub fn generate_stacktrace(&self, explicit_span: Option<Span>) -> Vec<FrameInfo> {\n+        let mut last_span = None;\n+        let mut frames = Vec::new();\n+        // skip 1 because the last frame is just the environment of the constant\n+        for &Frame { instance, span, .. } in self.stack().iter().skip(1).rev() {\n+            // make sure we don't emit frames that are duplicates of the previous\n+            if explicit_span == Some(span) {\n+                last_span = Some(span);\n+                continue;\n+            }\n+            if let Some(last) = last_span {\n+                if last == span {\n+                    continue;\n+                }\n+            } else {\n+                last_span = Some(span);\n+            }\n+            let location = if self.tcx.def_key(instance.def_id()).disambiguated_data.data == DefPathData::ClosureExpr {\n+                \"closure\".to_owned()\n+            } else {\n+                instance.to_string()\n+            };\n+            frames.push(FrameInfo { span, location });\n+        }\n+        frames\n+    }\n+\n     pub fn report(&self, e: &mut EvalError, as_err: bool, explicit_span: Option<Span>) {\n-        if let EvalErrorKind::TypeckError = *e.kind {\n-            return;\n+        match e.kind {\n+            EvalErrorKind::Layout(_) |\n+            EvalErrorKind::TypeckError => return,\n+            _ => {},\n         }\n         if let Some(ref mut backtrace) = e.backtrace {\n             let mut trace_text = \"\\n\\nAn error occurred in miri:\\n\".to_string();\n@@ -1618,28 +1659,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 )\n             };\n             err.span_label(span, e.to_string());\n-            let mut last_span = None;\n-            // skip 1 because the last frame is just the environment of the constant\n-            for &Frame { instance, span, .. } in self.stack().iter().skip(1).rev() {\n-                // make sure we don't emit frames that are duplicates of the previous\n-                if explicit_span == Some(span) {\n-                    last_span = Some(span);\n-                    continue;\n-                }\n-                if let Some(last) = last_span {\n-                    if last == span {\n-                        continue;\n-                    }\n-                } else {\n-                    last_span = Some(span);\n-                }\n-                if self.tcx.def_key(instance.def_id()).disambiguated_data.data ==\n-                    DefPathData::ClosureExpr\n-                {\n-                    err.span_note(span, \"inside call to closure\");\n-                    continue;\n-                }\n-                err.span_note(span, &format!(\"inside call to {}\", instance));\n+            for FrameInfo { span, location } in self.generate_stacktrace(explicit_span) {\n+                err.span_note(span, &format!(\"inside call to {}\", location));\n             }\n             err.emit();\n         } else {"}]}