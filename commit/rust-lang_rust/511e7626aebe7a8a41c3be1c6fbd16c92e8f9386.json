{"sha": "511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxMWU3NjI2YWViZTdhOGE0MWMzYmUxYzZmYmQxNmM5MmU4ZjkzODY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-09T16:59:50Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-23T13:30:43Z"}, "message": "Infer variance of types with respect to the region parameter.\n\nA similar approach could be used for type parameters.\n\nFixes #2282.", "tree": {"sha": "aea0830fc0eb00431d95c5b41550ee1e99e99da2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aea0830fc0eb00431d95c5b41550ee1e99e99da2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "html_url": "https://github.com/rust-lang/rust/commit/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8185ede1fad8312244e418b3c082f87386c40145", "url": "https://api.github.com/repos/rust-lang/rust/commits/8185ede1fad8312244e418b3c082f87386c40145", "html_url": "https://github.com/rust-lang/rust/commit/8185ede1fad8312244e418b3c082f87386c40145"}], "stats": {"total": 958, "additions": 723, "deletions": 235}, "files": [{"sha": "8d6453f0059701804af93764edefd780d94ae56f", "filename": "src/libcore/task.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -770,6 +770,7 @@ enum AncestorList = option<unsafe::Exclusive<AncestorNode>>;\n fn access_group<U>(x: &TaskGroupArc, blk: fn(TaskGroupInner) -> U) -> U {\n     unsafe { x.with(blk) }\n }\n+\n #[inline(always)]\n fn access_ancestors<U>(x: &unsafe::Exclusive<AncestorNode>,\n                        blk: fn(x: &mut AncestorNode) -> U) -> U {"}, {"sha": "9c90a422c53a4cb3b4b71785fc26cb98312c947d", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -299,7 +299,20 @@ fn node_id_to_str(map: map, id: node_id, itr: ident_interner) -> ~str {\n         fmt!{\"unknown node (id=%d)\", id}\n       }\n       some(node_item(item, path)) => {\n-        fmt!{\"item %s (id=%?)\", path_ident_to_str(*path, item.ident, itr), id}\n+        let path_str = path_ident_to_str(*path, item.ident, itr);\n+        let item_str = match item.node {\n+          item_const(*) => ~\"const\",\n+          item_fn(*) => ~\"fn\",\n+          item_mod(*) => ~\"mod\",\n+          item_foreign_mod(*) => ~\"foreign mod\",\n+          item_ty(*) => ~\"ty\",\n+          item_enum(*) => ~\"enum\",\n+          item_class(*) => ~\"class\",\n+          item_trait(*) => ~\"trait\",\n+          item_impl(*) => ~\"impl\",\n+          item_mac(*) => ~\"macro\"\n+        };\n+        fmt!(\"%s %s (id=%?)\", item_str, path_str, id)\n       }\n       some(node_foreign_item(item, abi, path)) => {\n         fmt!{\"foreign item %s with abi %? (id=%?)\","}, {"sha": "09de007f0a56937faf4fac53eed67e2794376c02", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -127,7 +127,7 @@ fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n }\n \n fn get_region_param(cstore: metadata::cstore::cstore,\n-                    def: ast::def_id) -> bool {\n+                    def: ast::def_id) -> option<ty::region_variance> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     return decoder::get_region_param(cdata, def.node);\n }\n@@ -149,7 +149,9 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n                  class_id, def} );\n     debug!{\"got field data %?\", the_field};\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n-    return {bounds: @~[], rp: false, ty: ty};\n+    return {bounds: @~[],\n+            region_param: none,\n+            ty: ty};\n }\n \n // Given a def_id for an impl or class, return the traits it implements,"}, {"sha": "b78be76dc690aeb7390639bb39c364db3a80aa12", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -237,11 +237,11 @@ fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n     @bounds\n }\n \n-fn item_ty_region_param(item: ebml::doc) -> bool {\n-    match ebml::maybe_get_doc(item, tag_region_param) {\n-      some(_) => true,\n-      none => false\n-    }\n+fn item_ty_region_param(item: ebml::doc) -> option<ty::region_variance> {\n+    ebml::maybe_get_doc(item, tag_region_param).map(|doc| {\n+        let d = ebml::ebml_deserializer(doc);\n+        ty::deserialize_region_variance(d)\n+    })\n }\n \n fn item_ty_param_count(item: ebml::doc) -> uint {\n@@ -340,10 +340,14 @@ fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n         item_ty_param_bounds(item, tcx, cdata)\n     } else { @~[] };\n     let rp = item_ty_region_param(item);\n-    return {bounds: tp_bounds, rp: rp, ty: t};\n+    return {bounds: tp_bounds,\n+            region_param: rp,\n+            ty: t};\n }\n \n-fn get_region_param(cdata: cmd, id: ast::node_id) -> bool {\n+fn get_region_param(cdata: cmd, id: ast::node_id)\n+    -> option<ty::region_variance> {\n+\n     let item = lookup_item(id, cdata.data);\n     return item_ty_region_param(item);\n }"}, {"sha": "f37cdd331ccad38dd48cb36e9ccc056d4a6691f3", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -81,8 +81,12 @@ fn encode_def_id(ebml_w: ebml::writer, id: def_id) {\n \n fn encode_region_param(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                        it: @ast::item) {\n-    let rp = ecx.tcx.region_paramd_items.contains_key(it.id);\n-    if rp { do ebml_w.wr_tag(tag_region_param) { } }\n+    let opt_rp = ecx.tcx.region_paramd_items.find(it.id);\n+    for opt_rp.each |rp| {\n+        do ebml_w.wr_tag(tag_region_param) {\n+            ty::serialize_region_variance(ebml_w, rp);\n+        }\n+    }\n }\n \n fn encode_mutability(ebml_w: ebml::writer, mt: class_mutability) {"}, {"sha": "f6008ead9395cdc69c37ea28981338a9ded66ce6", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -601,8 +601,10 @@ impl ebml::writer: ebml_writer_helpers {\n                     self.emit_bounds(ecx, bs);\n                 }\n             }\n-            do self.emit_rec_field(~\"rp\", 1u) {\n-                self.emit_bool(tpbt.rp);\n+            do self.emit_rec_field(~\"region_param\", 1u) {\n+                ty::serialize_opt_region_variance(\n+                    self,\n+                    tpbt.region_param);\n             }\n             do self.emit_rec_field(~\"ty\", 2u) {\n                 self.emit_ty(ecx, tpbt.ty);\n@@ -817,8 +819,8 @@ impl ebml::ebml_deserializer: ebml_deserializer_decoder_helpers {\n                 bounds: self.read_rec_field(~\"bounds\", 0u, || {\n                     @self.read_to_vec(|| self.read_bounds(xcx) )\n                 }),\n-                rp: self.read_rec_field(~\"rp\", 1u, || {\n-                    self.read_bool()\n+                region_param: self.read_rec_field(~\"region_param\", 1u, || {\n+                    ty::deserialize_opt_region_variance(self)\n                 }),\n                 ty: self.read_rec_field(~\"ty\", 2u, || {\n                     self.read_ty(xcx)"}, {"sha": "aa2dc699940c0a52593712529109a2ac3b2677f5", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 205, "deletions": 46, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -16,6 +16,7 @@ import syntax::ast_util::new_def_hash;\n import syntax::ast_map;\n import dvec::{DVec, dvec};\n import metadata::csearch;\n+import ty::{region_variance, rv_covariant, rv_invariant, rv_contravariant};\n \n import std::list;\n import std::list::list;\n@@ -365,8 +366,9 @@ fn resolve_crate(sess: session, def_map: resolve3::DefMap,\n // a worklist.  We can then process the worklist, propagating indirect\n // dependencies until a fixed point is reached.\n \n-type region_paramd_items = hashmap<ast::node_id, ()>;\n-type dep_map = hashmap<ast::node_id, @DVec<ast::node_id>>;\n+type region_paramd_items = hashmap<ast::node_id, region_variance>;\n+type region_dep = {ambient_variance: region_variance, id: ast::node_id};\n+type dep_map = hashmap<ast::node_id, @DVec<region_dep>>;\n \n type determine_rp_ctxt_ = {\n     sess: session,\n@@ -381,42 +383,98 @@ type determine_rp_ctxt_ = {\n \n     // true when we are within an item but not within a method.\n     // see long discussion on region_is_relevant()\n-    mut anon_implies_rp: bool\n+    mut anon_implies_rp: bool,\n+\n+    // encodes the context of the current type; invariant if\n+    // mutable, covariant otherwise\n+    mut ambient_variance: region_variance,\n };\n \n enum determine_rp_ctxt {\n     determine_rp_ctxt_(@determine_rp_ctxt_)\n }\n \n+fn join_variance(++variance1: region_variance,\n+                 ++variance2: region_variance) -> region_variance{\n+    match (variance1, variance2) {\n+      (rv_invariant, _) => {rv_invariant}\n+      (_, rv_invariant) => {rv_invariant}\n+      (rv_covariant, rv_contravariant) => {rv_invariant}\n+      (rv_contravariant, rv_covariant) => {rv_invariant}\n+      (rv_covariant, rv_covariant) => {rv_covariant}\n+      (rv_contravariant, rv_contravariant) => {rv_contravariant}\n+    }\n+}\n+\n+/// Combines the ambient variance with the variance of a\n+/// particular site to yield the final variance of the reference.\n+///\n+/// Example: if we are checking function arguments then the ambient\n+/// variance is contravariant.  If we then find a `&r/T` pointer, `r`\n+/// appears in a co-variant position.  This implies that this\n+/// occurrence of `r` is contra-variant with respect to the current\n+/// item, and hence the function returns `rv_contravariant`.\n+fn add_variance(+ambient_variance: region_variance,\n+                +variance: region_variance) -> region_variance {\n+    match (ambient_variance, variance) {\n+      (rv_invariant, _) => rv_invariant,\n+      (_, rv_invariant) => rv_invariant,\n+      (rv_covariant, c) => c,\n+      (c, rv_covariant) => c,\n+      (rv_contravariant, rv_contravariant) => rv_covariant\n+    }\n+}\n+\n impl determine_rp_ctxt {\n-    fn add_rp(id: ast::node_id) {\n+    fn add_variance(variance: region_variance) -> region_variance {\n+        add_variance(self.ambient_variance, variance)\n+    }\n+\n+    /// Records that item `id` is region-parameterized with the\n+    /// variance `variance`.  If `id` was already parameterized, then\n+    /// the new variance is joined with the old variance.\n+    fn add_rp(id: ast::node_id, variance: region_variance) {\n         assert id != 0;\n-        if self.region_paramd_items.insert(id, ()) {\n-            debug!{\"add region-parameterized item: %d (%s)\", id,\n-                   ast_map::node_id_to_str(self.ast_map, id,\n-                                           self.sess.parse_sess.interner)};\n+        let old_variance = self.region_paramd_items.find(id);\n+        let joined_variance = match old_variance {\n+          none => variance,\n+          some(v) => join_variance(v, variance)\n+        };\n+\n+        debug![\"add_rp() variance for %s: %? == %? ^ %?\",\n+               ast_map::node_id_to_str(self.ast_map, id,\n+                                       self.sess.parse_sess.interner),\n+               joined_variance, old_variance, variance];\n+\n+        if some(joined_variance) != old_variance {\n+            self.region_paramd_items.insert(id, joined_variance);\n             self.worklist.push(id);\n-        } else {\n-            debug!{\"item %d already region-parameterized\", id};\n         }\n     }\n \n-    fn add_dep(from: ast::node_id, to: ast::node_id) {\n-        debug!{\"add dependency from %d -> %d (%s -> %s)\",\n-               from, to,\n+    /// Indicates that the region-parameterization of the current item\n+    /// is dependent on the region-parameterization of the item\n+    /// `from`.  Put another way, it indicates that the current item\n+    /// contains a value of type `from`, so if `from` is\n+    /// region-parameterized, so is the current item.\n+    fn add_dep(from: ast::node_id) {\n+        debug![\"add dependency from %d -> %d (%s -> %s) with variance %?\",\n+               from, self.item_id,\n                ast_map::node_id_to_str(self.ast_map, from,\n                                        self.sess.parse_sess.interner),\n-               ast_map::node_id_to_str(self.ast_map, to,\n-                                       self.sess.parse_sess.interner)};\n+               ast_map::node_id_to_str(self.ast_map, self.item_id,\n+                                       self.sess.parse_sess.interner),\n+               copy self.ambient_variance];\n         let vec = match self.dep_map.find(from) {\n-            some(vec) => {vec}\n+            some(vec) => vec,\n             none => {\n                 let vec = @dvec();\n                 self.dep_map.insert(from, vec);\n                 vec\n             }\n         };\n-        if !vec.contains(to) { vec.push(to); }\n+        let dep = {ambient_variance: self.ambient_variance, id: self.item_id};\n+        if !vec.contains(dep) { vec.push(dep); }\n     }\n \n     // Determines whether a reference to a region that appears in the\n@@ -460,7 +518,9 @@ impl determine_rp_ctxt {\n         }\n     }\n \n-    fn with(item_id: ast::node_id, anon_implies_rp: bool, f: fn()) {\n+    fn with(item_id: ast::node_id,\n+            anon_implies_rp: bool,\n+            f: fn()) {\n         let old_item_id = self.item_id;\n         let old_anon_implies_rp = self.anon_implies_rp;\n         self.item_id = item_id;\n@@ -471,6 +531,13 @@ impl determine_rp_ctxt {\n         self.item_id = old_item_id;\n         self.anon_implies_rp = old_anon_implies_rp;\n     }\n+\n+    fn with_ambient_variance(variance: region_variance, f: fn()) {\n+        let old_ambient_variance = self.ambient_variance;\n+        self.ambient_variance = self.add_variance(variance);\n+        f();\n+        self.ambient_variance = old_ambient_variance;\n+    }\n }\n \n fn determine_rp_in_item(item: @ast::item,\n@@ -484,12 +551,17 @@ fn determine_rp_in_item(item: @ast::item,\n fn determine_rp_in_fn(fk: visit::fn_kind,\n                       decl: ast::fn_decl,\n                       body: ast::blk,\n-                      sp: span,\n-                      id: ast::node_id,\n+                      _sp: span,\n+                      _id: ast::node_id,\n                       &&cx: determine_rp_ctxt,\n                       visitor: visit::vt<determine_rp_ctxt>) {\n     do cx.with(cx.item_id, false) {\n-        visit::visit_fn(fk, decl, body, sp, id, cx, visitor);\n+        do cx.with_ambient_variance(rv_contravariant) {\n+            for decl.inputs.each |a| { visitor.visit_ty(a.ty, cx, visitor); }\n+        }\n+        visitor.visit_ty(decl.output, cx, visitor);\n+        visitor.visit_ty_params(visit::tps_of_fn(fk), cx, visitor);\n+        visitor.visit_block(body, cx, visitor);\n     }\n }\n \n@@ -511,24 +583,26 @@ fn determine_rp_in_ty(ty: @ast::ty,\n     // impl etc.  So we can ignore it and its components.\n     if cx.item_id == 0 { return; }\n \n-    // if this type directly references a region, either via a\n-    // region pointer like &r.ty or a region-parameterized path\n-    // like path/r, add to the worklist/set\n+    // if this type directly references a region pointer like &r/ty,\n+    // add to the worklist/set.  Note that &r/ty is contravariant with\n+    // respect to &r, because &r/ty can be used whereever a *smaller*\n+    // region is expected (and hence is a supertype of those\n+    // locations)\n     match ty.node {\n-      ast::ty_rptr(r, _) |\n-      ast::ty_path(@{rp: some(r), _}, _) => {\n-        debug!{\"referenced type with regions %s\",\n-               pprust::ty_to_str(ty, cx.sess.intr())};\n+      ast::ty_rptr(r, _) => {\n+        debug![\"referenced rptr type %s\",\n+               pprust::ty_to_str(ty, cx.sess.intr())];\n+\n         if cx.region_is_relevant(r) {\n-            cx.add_rp(cx.item_id);\n+            cx.add_rp(cx.item_id, cx.add_variance(rv_contravariant))\n         }\n       }\n \n       ast::ty_fn(ast::proto_bare, _, _) |\n       ast::ty_fn(ast::proto_block, _, _) if cx.anon_implies_rp => {\n         debug!(\"referenced bare fn type with regions %s\",\n                pprust::ty_to_str(ty, cx.sess.intr()));\n-        cx.add_rp(cx.item_id);\n+        cx.add_rp(cx.item_id, cx.add_variance(rv_contravariant));\n       }\n \n       _ => {}\n@@ -543,13 +617,16 @@ fn determine_rp_in_ty(ty: @ast::ty,\n         match cx.def_map.get(id) {\n           ast::def_ty(did) | ast::def_class(did, _) => {\n             if did.crate == ast::local_crate {\n-                cx.add_dep(did.node, cx.item_id);\n+                cx.add_dep(did.node);\n             } else {\n                 let cstore = cx.sess.cstore;\n-                if csearch::get_region_param(cstore, did) {\n-                    debug!{\"reference to external, rp'd type %s\",\n-                           pprust::ty_to_str(ty, cx.sess.intr())};\n-                    cx.add_rp(cx.item_id);\n+                match csearch::get_region_param(cstore, did) {\n+                  none => {}\n+                  some(variance) => {\n+                    debug![\"reference to external, rp'd type %s\",\n+                           pprust::ty_to_str(ty, cx.sess.intr())];\n+                    cx.add_rp(cx.item_id, cx.add_variance(variance))\n+                  }\n                 }\n             }\n           }\n@@ -560,15 +637,73 @@ fn determine_rp_in_ty(ty: @ast::ty,\n     }\n \n     match ty.node {\n-      ast::ty_fn(*) => {\n+      ast::ty_box(mt) | ast::ty_uniq(mt) | ast::ty_vec(mt) |\n+      ast::ty_rptr(_, mt) | ast::ty_ptr(mt) => {\n+        visit_mt(mt, cx, visitor);\n+      }\n+\n+      ast::ty_rec(fields) => {\n+        for fields.each |field| {\n+            visit_mt(field.node.mt, cx, visitor);\n+        }\n+      }\n+\n+      ast::ty_path(path, _) => {\n+        // type parameters are---for now, anyway---always invariant\n+        do cx.with_ambient_variance(rv_invariant) {\n+            for path.types.each |tp| {\n+                visitor.visit_ty(tp, cx, visitor);\n+            }\n+        }\n+      }\n+\n+      ast::ty_fn(_, bounds, decl) => {\n+        // fn() binds the & region, so do not consider &T types that\n+        // appear *inside* a fn() type to affect the enclosing item:\n         do cx.with(cx.item_id, false) {\n-            visit::visit_ty(ty, cx, visitor);\n+            // parameters are contravariant\n+            do cx.with_ambient_variance(rv_contravariant) {\n+                for decl.inputs.each |a| {\n+                    visitor.visit_ty(a.ty, cx, visitor);\n+                }\n+            }\n+            visit::visit_ty_param_bounds(bounds, cx, visitor);\n+            visitor.visit_ty(decl.output, cx, visitor);\n         }\n       }\n+\n       _ => {\n         visit::visit_ty(ty, cx, visitor);\n       }\n     }\n+\n+    fn visit_mt(mt: ast::mt, &&cx: determine_rp_ctxt,\n+                visitor: visit::vt<determine_rp_ctxt>) {\n+        // mutability is invariant\n+        if mt.mutbl == ast::m_mutbl {\n+            do cx.with_ambient_variance(rv_invariant) {\n+                visitor.visit_ty(mt.ty, cx, visitor);\n+            }\n+        } else {\n+            visitor.visit_ty(mt.ty, cx, visitor);\n+        }\n+    }\n+}\n+\n+fn determine_rp_in_struct_field(cm: @ast::struct_field,\n+                                &&cx: determine_rp_ctxt,\n+                                visitor: visit::vt<determine_rp_ctxt>) {\n+    match cm.node.kind {\n+      ast::named_field(_, ast::class_mutable, _) => {\n+        do cx.with_ambient_variance(rv_invariant) {\n+            visit::visit_struct_field(cm, cx, visitor);\n+        }\n+      }\n+      ast::named_field(_, ast::class_immutable, _) |\n+      ast::unnamed_field => {\n+        visit::visit_struct_field(cm, cx, visitor);\n+      }\n+    }\n }\n \n fn determine_rp_in_crate(sess: session,\n@@ -582,32 +717,56 @@ fn determine_rp_in_crate(sess: session,\n                                   dep_map: int_hash(),\n                                   worklist: dvec(),\n                                   mut item_id: 0,\n-                                  mut anon_implies_rp: false});\n+                                  mut anon_implies_rp: false,\n+                                  mut ambient_variance: rv_covariant});\n \n-    // gather up the base set, worklist and dep_map:\n+    // Gather up the base set, worklist and dep_map\n     let visitor = visit::mk_vt(@{\n         visit_fn: determine_rp_in_fn,\n         visit_item: determine_rp_in_item,\n         visit_ty: determine_rp_in_ty,\n         visit_ty_method: determine_rp_in_ty_method,\n+        visit_struct_field: determine_rp_in_struct_field,\n         with *visit::default_visitor()\n     });\n     visit::visit_crate(*crate, cx, visitor);\n \n-    // propagate indirect dependencies\n+    // Propagate indirect dependencies\n+    //\n+    // Each entry in the worklist is the id of an item C whose region\n+    // parameterization has been updated.  So we pull ids off of the\n+    // worklist, find the current variance, and then iterate through\n+    // all of the dependent items (that is, those items that reference\n+    // C).  For each dependent item D, we combine the variance of C\n+    // with the ambient variance where the reference occurred and then\n+    // update the region-parameterization of D to reflect the result.\n     while cx.worklist.len() != 0 {\n-        let id = cx.worklist.pop();\n-        debug!{\"popped %d from worklist\", id};\n-        match cx.dep_map.find(id) {\n+        let c_id = cx.worklist.pop();\n+        let c_variance = cx.region_paramd_items.get(c_id);\n+        debug![\"popped %d from worklist\", c_id];\n+        match cx.dep_map.find(c_id) {\n           none => {}\n-          some(vec) => {\n-            for vec.each |to_id| {\n-                cx.add_rp(to_id);\n+          some(deps) => {\n+            for deps.each |dep| {\n+                let v = add_variance(dep.ambient_variance, c_variance);\n+                cx.add_rp(dep.id, v);\n             }\n           }\n         }\n     }\n \n+    debug!(\"%s\", {\n+        debug!(\"Region variance results:\");\n+        for cx.region_paramd_items.each |key, value| {\n+            debug!(\"item %? (%s) is parameterized with variance %?\",\n+                   key,\n+                   ast_map::node_id_to_str(ast_map, key,\n+                                           sess.parse_sess.interner),\n+                   value);\n+        }\n+        \"----\"\n+    });\n+\n     // return final set\n     return cx.region_paramd_items;\n }"}, {"sha": "7ef772a311215d8f442ea0250b5e4fb0bed02721", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -2348,7 +2348,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n           }\n           csearch::found(ast::ii_method(impl_did, mth)) => {\n             ccx.external.insert(fn_id, some(mth.id));\n-            let {bounds: impl_bnds, rp: _, ty: impl_ty} =\n+            let {bounds: impl_bnds, region_param: _, ty: impl_ty} =\n                 ty::lookup_item_type(ccx.tcx, impl_did);\n             if (*impl_bnds).len() + mth.tps.len() == 0u {\n                 let llfn = get_item_val(ccx, mth.id);"}, {"sha": "13bb97fcdbf9da0bf94518e0a109c0ec27b9d5a1", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -17,6 +17,8 @@ import middle::lint::{get_lint_level, allow};\n import syntax::ast::*;\n import syntax::print::pprust::*;\n import util::ppaux::{ty_to_str, proto_ty_to_str, tys_to_str};\n+import std::serialization::{serialize_option,\n+                            deserialize_option};\n \n export tv_vid, tvi_vid, region_vid, vid;\n export br_hashmap;\n@@ -181,6 +183,10 @@ export ast_proto_to_proto;\n export is_blockish;\n export method_call_bounds;\n export hash_region;\n+export region_variance, rv_covariant, rv_invariant, rv_contravariant;\n+export serialize_region_variance, deserialize_region_variance;\n+export opt_region_variance;\n+export serialize_opt_region_variance, deserialize_opt_region_variance;\n \n // Data types\n \n@@ -226,6 +232,12 @@ enum ast_ty_to_ty_cache_entry {\n     atttce_resolved(t)  /* resolved to a type, irrespective of region */\n }\n \n+#[auto_serialize]\n+type opt_region_variance = option<region_variance>;\n+\n+#[auto_serialize]\n+enum region_variance { rv_covariant, rv_invariant, rv_contravariant }\n+\n // N.B.: Borrows from inlined content are not accurately deserialized.  This\n // is because we don't need the details in trans, we only care if there is an\n // entry in the table or not.\n@@ -565,7 +577,7 @@ fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n /// - `ty`: the base type.  May have reference to the (unsubstituted) bound\n ///   region `&self` or to (unsubstituted) ty_param types\n type ty_param_bounds_and_ty = {bounds: @~[param_bounds],\n-                               rp: bool,\n+                               region_param: option<region_variance>,\n                                ty: t};\n \n type type_cache = hashmap<ast::def_id, ty_param_bounds_and_ty>;"}, {"sha": "641d2e89c6c077ee1e675081d25847b967537995", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -200,7 +200,7 @@ fn lookup_def_ccx(ccx: @crate_ctxt, sp: span, id: ast::node_id) -> ast::def {\n }\n \n fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n-    {bounds: @~[], rp: false, ty: t}\n+    {bounds: @~[], region_param: none, ty: t}\n }\n \n fn require_same_types("}, {"sha": "a636fbded1a2ee27bc5fecd7787b14eabfd0eff5", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -84,33 +84,33 @@ fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy owned>(\n     path: @ast::path) -> ty_param_substs_and_ty {\n \n     let tcx = self.tcx();\n-    let {bounds: decl_bounds, rp: decl_rp, ty: decl_ty} =\n+    let {bounds: decl_bounds, region_param: decl_rp, ty: decl_ty} =\n         self.get_item_ty(did);\n \n-    debug!{\"ast_path_to_substs_and_ty: did=%? decl_rp=%b\",\n-           did, decl_rp};\n+    debug![\"ast_path_to_substs_and_ty: did=%? decl_rp=%?\",\n+           did, decl_rp];\n \n     // If the type is parameterized by the self region, then replace self\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n     let self_r = match (decl_rp, path.rp) {\n-      (false, none) => {\n+      (none, none) => {\n         none\n       }\n-      (false, some(_)) => {\n+      (none, some(_)) => {\n         tcx.sess.span_err(\n             path.span,\n             fmt!{\"no region bound is allowed on `%s`, \\\n                   which is not declared as containing region pointers\",\n                  ty::item_path_str(tcx, did)});\n         none\n       }\n-      (true, none) => {\n+      (some(_), none) => {\n         let res = rscope.anon_region(path.span);\n         let r = get_region_reporting_err(self.tcx(), path.span, res);\n         some(r)\n       }\n-      (true, some(r)) => {\n+      (some(_), some(r)) => {\n         some(ast_region_to_region(self, rscope, path.span, r))\n       }\n     };"}, {"sha": "535ba01fb92644040d53ef47fdf550510d5db04e", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 104, "deletions": 98, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -71,7 +71,8 @@ import astconv::{ast_region_to_region};\n import middle::ty::{tv_vid, vid};\n import regionmanip::{replace_bound_regions_in_fn_ty};\n import rscope::{anon_rscope, binding_rscope, empty_rscope, in_anon_rscope};\n-import rscope::{in_binding_rscope, region_scope, type_rscope};\n+import rscope::{in_binding_rscope, region_scope, type_rscope,\n+                bound_self_region};\n import syntax::ast::ty_i;\n import typeck::infer::{resolve_type, force_tvar};\n \n@@ -84,60 +85,59 @@ type self_info = {\n     explicit_self: ast::self_ty\n };\n \n-type fn_ctxt_ =\n+struct fn_ctxt {\n     // var_bindings, locals and next_var_id are shared\n     // with any nested functions that capture the environment\n     // (and with any functions whose environment is being captured).\n-    {self_impl_def_id: option<ast::def_id>,\n-     ret_ty: ty::t,\n-     // Used by loop bodies that return from the outer function\n-     indirect_ret_ty: option<ty::t>,\n-     purity: ast::purity,\n-     infcx: infer::infer_ctxt,\n-     locals: hashmap<ast::node_id, tv_vid>,\n-\n-     // Sometimes we generate region pointers where the precise region\n-     // to use is not known. For example, an expression like `&x.f`\n-     // where `x` is of type `@T`: in this case, we will be rooting\n-     // `x` onto the stack frame, and we could choose to root it until\n-     // the end of (almost) any enclosing block or expression.  We\n-     // want to pick the narrowest block that encompasses all uses.\n-     //\n-     // What we do in such cases is to generate a region variable with\n-     // `region_lb` as a lower bound.  The regionck pass then adds\n-     // other constriants based on how the variable is used and region\n-     // inference selects the ultimate value.  Finally, borrowck is\n-     // charged with guaranteeing that the value whose address was taken\n-     // can actually be made to live as long as it needs to live.\n-     mut region_lb: ast::node_id,\n-\n-     in_scope_regions: isr_alist,\n-\n-     node_types: hashmap<ast::node_id, ty::t>,\n-     node_type_substs: hashmap<ast::node_id, ty::substs>,\n-\n-     ccx: @crate_ctxt};\n-\n-enum fn_ctxt {\n-    fn_ctxt_(fn_ctxt_)\n+    self_impl_def_id: option<ast::def_id>;\n+    ret_ty: ty::t;\n+    // Used by loop bodies that return from the outer function\n+    indirect_ret_ty: option<ty::t>;\n+    purity: ast::purity;\n+    infcx: infer::infer_ctxt;\n+    locals: hashmap<ast::node_id, tv_vid>;\n+\n+    // Sometimes we generate region pointers where the precise region\n+    // to use is not known. For example, an expression like `&x.f`\n+    // where `x` is of type `@T`: in this case, we will be rooting\n+    // `x` onto the stack frame, and we could choose to root it until\n+    // the end of (almost) any enclosing block or expression.  We\n+    // want to pick the narrowest block that encompasses all uses.\n+    //\n+    // What we do in such cases is to generate a region variable with\n+    // `region_lb` as a lower bound.  The regionck pass then adds\n+    // other constriants based on how the variable is used and region\n+    // inference selects the ultimate value.  Finally, borrowck is\n+    // charged with guaranteeing that the value whose address was taken\n+    // can actually be made to live as long as it needs to live.\n+    mut region_lb: ast::node_id;\n+\n+    in_scope_regions: isr_alist;\n+\n+    node_types: hashmap<ast::node_id, ty::t>;\n+    node_type_substs: hashmap<ast::node_id, ty::substs>;\n+\n+    ccx: @crate_ctxt;\n }\n \n // Used by check_const and check_enum_variants\n fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t,\n                  region_bnd: ast::node_id) -> @fn_ctxt {\n // It's kind of a kludge to manufacture a fake function context\n // and statement context, but we might as well do write the code only once\n-    @fn_ctxt_({self_impl_def_id: none,\n-               ret_ty: rty,\n-               indirect_ret_ty: none,\n-               purity: ast::pure_fn,\n-               infcx: infer::new_infer_ctxt(ccx.tcx),\n-               locals: int_hash(),\n-               mut region_lb: region_bnd,\n-               in_scope_regions: @nil,\n-               node_types: map::int_hash(),\n-               node_type_substs: map::int_hash(),\n-               ccx: ccx})\n+    @fn_ctxt {\n+        self_impl_def_id: none,\n+        ret_ty: rty,\n+        indirect_ret_ty: none,\n+        purity: ast::pure_fn,\n+        infcx: infer::new_infer_ctxt(ccx.tcx),\n+        locals: int_hash(),\n+        mut region_lb: region_bnd,\n+        in_scope_regions: @nil,\n+        node_types: map::int_hash(),\n+        node_type_substs: map::int_hash(),\n+        ccx: ccx\n+    }\n }\n \n // a list of mapping from in-scope-region-names (\"isr\") to the\n@@ -245,17 +245,19 @@ fn check_fn(ccx: @crate_ctxt,\n             }\n         } else { none };\n \n-        @fn_ctxt_({self_impl_def_id: self_info.map(|info| info.def_id),\n-                   ret_ty: ret_ty,\n-                   indirect_ret_ty: indirect_ret_ty,\n-                   purity: purity,\n-                   infcx: infcx,\n-                   locals: locals,\n-                   mut region_lb: body.node.id,\n-                   in_scope_regions: isr,\n-                   node_types: node_types,\n-                   node_type_substs: node_type_substs,\n-                   ccx: ccx})\n+        @fn_ctxt {\n+            self_impl_def_id: self_info.map(|info| info.def_id),\n+            ret_ty: ret_ty,\n+            indirect_ret_ty: indirect_ret_ty,\n+            purity: purity,\n+            infcx: infcx,\n+            locals: locals,\n+            mut region_lb: body.node.id,\n+            in_scope_regions: isr,\n+            node_types: node_types,\n+            node_type_substs: node_type_substs,\n+            ccx: ccx\n+        }\n     };\n \n     // Update the self_info to contain an accurate self type (taking\n@@ -478,9 +480,9 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         check_bare_fn(ccx, decl, body, it.id, none);\n       }\n       ast::item_impl(tps, _, ty, ms) => {\n-        let rp = ccx.tcx.region_paramd_items.contains_key(it.id);\n-        debug!{\"item_impl %s with id %d rp %b\",\n-               ccx.tcx.sess.str_of(it.ident), it.id, rp};\n+        let rp = ccx.tcx.region_paramd_items.find(it.id);\n+        debug!(\"item_impl %s with id %d rp %?\",\n+               ccx.tcx.sess.str_of(it.ident), it.id, rp);\n         let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n         for ms.each |m| {\n             check_method(ccx, m, self_ty, local_def(it.id));\n@@ -701,6 +703,15 @@ impl @fn_ctxt {\n         self.region_lb = old_region_lb;\n         return v;\n     }\n+\n+    fn region_var_if_parameterized(rp: option<ty::region_variance>,\n+                                   span: span)\n+        -> option<ty::region> {\n+        match rp {\n+          some(_) => some(self.infcx.next_region_var_nb(span)),\n+          none => none\n+        }\n+    }\n }\n \n fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n@@ -789,14 +800,14 @@ fn impl_self_ty(fcx: @fn_ctxt,\n                 require_rp: bool) -> ty_param_substs_and_ty {\n     let tcx = fcx.ccx.tcx;\n \n-    let {n_tps, rp, raw_ty} = if did.crate == ast::local_crate {\n-        let rp = fcx.tcx().region_paramd_items.contains_key(did.node);\n+    let {n_tps, region_param, raw_ty} = if did.crate == ast::local_crate {\n+        let region_param = fcx.tcx().region_paramd_items.find(did.node);\n         match check tcx.items.find(did.node) {\n           some(ast_map::node_item(@{node: ast::item_impl(ts, _, st, _),\n                                   _}, _)) => {\n             {n_tps: ts.len(),\n-             rp: rp,\n-             raw_ty: fcx.ccx.to_ty(rscope::type_rscope(rp), st)}\n+             region_param: region_param,\n+             raw_ty: fcx.ccx.to_ty(rscope::type_rscope(region_param), st)}\n           }\n           some(ast_map::node_item(@{node: ast::item_class(_, ts),\n                                     id: class_id, _},_)) => {\n@@ -805,10 +816,9 @@ fn impl_self_ty(fcx: @fn_ctxt,\n                  we substitute in fresh vars for them)\n                */\n               {n_tps: ts.len(),\n-               rp: rp,\n+               region_param: region_param,\n                raw_ty: ty::mk_class(tcx, local_def(class_id),\n-                      {self_r: if rp {some(ty::re_bound(ty::br_self))}\n-                               else {none},\n+                      {self_r: rscope::bound_self_region(region_param),\n                        self_ty: none,\n                        tps: ty::ty_params_to_tys(tcx, ts)})}\n           }\n@@ -818,13 +828,15 @@ fn impl_self_ty(fcx: @fn_ctxt,\n     } else {\n         let ity = ty::lookup_item_type(tcx, did);\n         {n_tps: vec::len(*ity.bounds),\n-         rp: ity.rp,\n+         region_param: ity.region_param,\n          raw_ty: ity.ty}\n     };\n \n-    let rp = rp || require_rp;\n-    let self_r = if rp {some(fcx.infcx.next_region_var(expr.span, expr.id))}\n-                 else {none};\n+    let self_r = if region_param.is_some() || require_rp {\n+        some(fcx.infcx.next_region_var(expr.span, expr.id))\n+    } else {\n+        none\n+    };\n     let tps = fcx.infcx.next_ty_vars(n_tps);\n \n     let substs = {self_r: self_r, self_ty: none, tps: tps};\n@@ -1832,7 +1844,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let type_parameter_count, region_parameterized, raw_type;\n         if class_id.crate == ast::local_crate {\n             region_parameterized =\n-                tcx.region_paramd_items.contains_key(class_id.node);\n+                tcx.region_paramd_items.find(class_id.node);\n             match tcx.items.find(class_id.node) {\n                 some(ast_map::node_item(@{\n                         node: ast::item_class(_, type_parameters),\n@@ -1841,12 +1853,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n                     type_parameter_count = type_parameters.len();\n \n-                    let self_region;\n-                    if region_parameterized {\n-                        self_region = some(ty::re_bound(ty::br_self));\n-                    } else {\n-                        self_region = none;\n-                    }\n+                    let self_region =\n+                        bound_self_region(region_parameterized);\n \n                     raw_type = ty::mk_class(tcx, class_id, {\n                         self_r: self_region,\n@@ -1862,18 +1870,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         } else {\n             let item_type = ty::lookup_item_type(tcx, class_id);\n             type_parameter_count = (*item_type.bounds).len();\n-            region_parameterized = item_type.rp;\n+            region_parameterized = item_type.region_param;\n             raw_type = item_type.ty;\n         }\n \n         // Generate the struct type.\n-        let self_region;\n-        if region_parameterized {\n-            self_region = some(fcx.infcx.next_region_var(expr.span, expr.id));\n-        } else {\n-            self_region = none;\n-        }\n-\n+        let self_region =\n+            fcx.region_var_if_parameterized(region_parameterized,\n+                                            expr.span);\n         let type_parameters = fcx.infcx.next_ty_vars(type_parameter_count);\n         let substitutions = {\n             self_r: self_region,\n@@ -2082,8 +2086,8 @@ fn check_block_no_value(fcx: @fn_ctxt, blk: ast::blk) -> bool {\n \n fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n     let fcx = match blk.node.rules {\n-      ast::unchecked_blk => @fn_ctxt_({purity: ast::impure_fn with **fcx0}),\n-      ast::unsafe_blk => @fn_ctxt_({purity: ast::unsafe_fn with **fcx0}),\n+      ast::unchecked_blk => @fn_ctxt {purity: ast::impure_fn with *fcx0},\n+      ast::unsafe_blk => @fn_ctxt {purity: ast::unsafe_fn with *fcx0},\n       ast::default_blk => fcx0\n     };\n     do fcx.with_region_lb(blk.node.id) {\n@@ -2294,7 +2298,7 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n         // extern functions are just u8 pointers\n         return {\n             bounds: @~[],\n-            rp: false,\n+            region_param: none,\n             ty: ty::mk_ptr(\n                 fcx.ccx.tcx,\n                 {\n@@ -2358,19 +2362,21 @@ fn instantiate_path(fcx: @fn_ctxt,\n     // determine the region bound, using the value given by the user\n     // (if any) and otherwise using a fresh region variable\n     let self_r = match pth.rp {\n-      some(r) if !tpt.rp => {\n-        fcx.ccx.tcx.sess.span_err\n-            (span, ~\"this item is not region-parameterized\");\n-        none\n-      }\n       some(r) => {\n-        some(ast_region_to_region(fcx, fcx, span, r))\n-      }\n-      none if tpt.rp => {\n-        some(fcx.infcx.next_region_var_with_lb(span, region_lb))\n+        match tpt.region_param {\n+          none => {\n+            fcx.ccx.tcx.sess.span_err\n+                (span, ~\"this item is not region-parameterized\");\n+            none\n+          }\n+          some(_) => {\n+            some(ast_region_to_region(fcx, fcx, span, r))\n+          }\n+        }\n       }\n       none => {\n-        none\n+        fcx.region_var_if_parameterized(\n+            tpt.region_param, span)\n       }\n     };\n "}, {"sha": "5691af2b91a94d0999e4c25d7ac55a7e96a8181c", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -402,11 +402,9 @@ struct CoherenceChecker {\n \n     fn universally_quantify_polytype(polytype: ty_param_bounds_and_ty) -> t {\n         // NDM--this span is bogus.\n-        let self_region = if !polytype.rp {\n-            none\n-        } else {\n-            some(self.inference_context.next_region_var_nb(dummy_sp()))\n-        };\n+        let self_region =\n+            polytype.region_param.map(\n+                |_r| self.inference_context.next_region_var_nb(dummy_sp()));\n \n         let bounds_count = polytype.bounds.len();\n         let type_parameters ="}, {"sha": "85b1ebc58de2371520f99c699e64794399c828f4", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 55, "deletions": 36, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -112,7 +112,7 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n                           enum_ty: ty::t,\n                           variants: ~[ast::variant],\n                           ty_params: ~[ast::ty_param],\n-                          rp: bool) {\n+                          rp: option<ty::region_variance>) {\n     let tcx = ccx.tcx;\n \n     // Create a set of parameter types shared among all the variants.\n@@ -150,7 +150,7 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n             none => {}\n             some(result_ty) => {\n                 let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n-                           rp: rp,\n+                           region_param: rp,\n                            ty: result_ty};\n                 tcx.tcache.insert(local_def(variant.node.id), tpt);\n                 write_ty_to_tcx(tcx, variant.node.id, result_ty);\n@@ -167,7 +167,8 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n \n     fn make_static_method_ty(ccx: @crate_ctxt,\n                              am: ast::ty_method,\n-                             rp: bool, m: ty::method,\n+                             rp: option<ty::region_variance>,\n+                             m: ty::method,\n                              // Take this as an argument b/c we may check\n                              // the impl before the trait.\n                              trait_ty: ty::t,\n@@ -197,20 +198,22 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n         let bounds = @(*trait_bounds + ~[@~[ty::bound_trait(trait_ty)]]\n                        + *m.tps);\n         ccx.tcx.tcache.insert(local_def(am.id),\n-                              {bounds: bounds, rp: rp, ty: ty});\n+                              {bounds: bounds,\n+                               region_param: rp,\n+                               ty: ty});\n     }\n \n \n     let tcx = ccx.tcx;\n-    let rp = tcx.region_paramd_items.contains_key(id);\n+    let region_paramd = tcx.region_paramd_items.find(id);\n     match tcx.items.get(id) {\n       ast_map::node_item(@{node: ast::item_trait(params, _, ms), _}, _) => {\n         store_methods::<ast::trait_method>(ccx, id, ms, |m| {\n             let trait_bounds = ty_param_bounds(ccx, params);\n             let ty_m = trait_method_to_ty_method(m);\n-            let method_ty = ty_of_ty_method(ccx, ty_m, rp);\n+            let method_ty = ty_of_ty_method(ccx, ty_m, region_paramd);\n             if ty_m.self_ty.node == ast::sty_static {\n-                make_static_method_ty(ccx, ty_m, rp,\n+                make_static_method_ty(ccx, ty_m, region_paramd,\n                                       method_ty, trait_ty, trait_bounds);\n             }\n             method_ty\n@@ -220,7 +223,7 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n         // All methods need to be stored, since lookup_method\n         // relies on the same method cache for self-calls\n         store_methods::<@ast::method>(ccx, id, struct_def.methods, |m| {\n-            ty_of_method(ccx, m, rp)\n+            ty_of_method(ccx, m, region_paramd)\n         });\n       }\n       _ => { /* Ignore things that aren't traits or classes */ }\n@@ -316,7 +319,7 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n \n fn check_methods_against_trait(ccx: @crate_ctxt,\n                                tps: ~[ast::ty_param],\n-                               rp: bool,\n+                               rp: option<ty::region_variance>,\n                                selfty: ty::t,\n                                a_trait_ty: @ast::trait_ref,\n                                impl_ms: ~[converted_method]) {\n@@ -370,21 +373,23 @@ fn check_methods_against_trait(ccx: @crate_ctxt,\n } // fn\n \n fn convert_field(ccx: @crate_ctxt,\n-                 rp: bool,\n+                 rp: option<ty::region_variance>,\n                  bounds: @~[ty::param_bounds],\n                  v: @ast::struct_field) {\n     let tt = ccx.to_ty(type_rscope(rp), v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n     ccx.tcx.tcache.insert(local_def(v.node.id),\n-                          {bounds: bounds, rp: rp, ty: tt});\n+                          {bounds: bounds,\n+                           region_param: rp,\n+                           ty: tt});\n }\n \n type converted_method = {mty: ty::method, id: ast::node_id, span: span};\n \n fn convert_methods(ccx: @crate_ctxt,\n                    ms: ~[@ast::method],\n-                   rp: bool,\n+                   rp: option<ty::region_variance>,\n                    rcvr_bounds: @~[ty::param_bounds]) -> ~[converted_method] {\n \n     let tcx = ccx.tcx;\n@@ -397,17 +402,19 @@ fn convert_methods(ccx: @crate_ctxt,\n \n             // n.b.: the type of a method is parameterized by both\n             // the tps on the receiver and those on the method itself\n-            {bounds: @(vec::append(*rcvr_bounds, *bounds)), rp: rp, ty: fty});\n+            {bounds: @(vec::append(*rcvr_bounds, *bounds)),\n+             region_param: rp,\n+             ty: fty});\n         write_ty_to_tcx(tcx, m.id, fty);\n         {mty: mty, id: m.id, span: m.span}\n     }\n }\n \n fn convert(ccx: @crate_ctxt, it: @ast::item) {\n     let tcx = ccx.tcx;\n-    let rp = tcx.region_paramd_items.contains_key(it.id);\n-    debug!{\"convert: item %s with id %d rp %b\", tcx.sess.str_of(it.ident),\n-           it.id, rp};\n+    let rp = tcx.region_paramd_items.find(it.id);\n+    #debug[\"convert: item %s with id %d rp %?\",\n+           tcx.sess.str_of(it.ident), it.id, rp];\n     match it.node {\n       // These don't define types.\n       ast::item_foreign_mod(_) | ast::item_mod(_) => {}\n@@ -423,7 +430,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         write_ty_to_tcx(tcx, it.id, selfty);\n         tcx.tcache.insert(local_def(it.id),\n                           {bounds: i_bounds,\n-                           rp: rp,\n+                           region_param: rp,\n                            ty: selfty});\n \n         let cms = convert_methods(ccx, ms, rp, i_bounds);\n@@ -465,8 +472,11 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n     }\n }\n \n-fn convert_struct(ccx: @crate_ctxt, rp: bool, struct_def: @ast::struct_def,\n-                  tps: ~[ast::ty_param], tpt: ty::ty_param_bounds_and_ty,\n+fn convert_struct(ccx: @crate_ctxt,\n+                  rp: option<ty::region_variance>,\n+                  struct_def: @ast::struct_def,\n+                  tps: ~[ast::ty_param],\n+                  tpt: ty::ty_param_bounds_and_ty,\n                   id: ast::node_id) {\n     let tcx = ccx.tcx;\n     do option::iter(struct_def.ctor) |ctor| {\n@@ -475,7 +485,7 @@ fn convert_struct(ccx: @crate_ctxt, rp: bool, struct_def: @ast::struct_def,\n             |a| ty_of_arg(ccx, type_rscope(rp), a, none) );\n         let t_res = ty::mk_class(\n             tcx, local_def(id),\n-            {self_r: if rp {some(ty::re_bound(ty::br_self))} else {none},\n+            {self_r: rscope::bound_self_region(rp),\n              self_ty: none,\n              tps: ty::ty_params_to_tys(tcx, tps)});\n         let t_ctor = ty::mk_fn(\n@@ -488,7 +498,7 @@ fn convert_struct(ccx: @crate_ctxt, rp: bool, struct_def: @ast::struct_def,\n         write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n         tcx.tcache.insert(local_def(ctor.node.id),\n                           {bounds: tpt.bounds,\n-                           rp: rp,\n+                           region_param: rp,\n                            ty: t_ctor});\n     }\n \n@@ -501,7 +511,7 @@ fn convert_struct(ccx: @crate_ctxt, rp: bool, struct_def: @ast::struct_def,\n         write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n         tcx.tcache.insert(local_def(dtor.node.id),\n                           {bounds: tpt.bounds,\n-                           rp: rp,\n+                           region_param: rp,\n                            ty: t_dtor});\n     };\n     ensure_trait_methods(ccx, id, tpt.ty);\n@@ -536,8 +546,7 @@ fn convert_foreign(ccx: @crate_ctxt, i: @ast::foreign_item) {\n \n fn ty_of_method(ccx: @crate_ctxt,\n                 m: @ast::method,\n-                rp: bool) -> ty::method {\n-    // XXX: Are the bounds correct here?\n+                rp: option<ty::region_variance>) -> ty::method {\n     {ident: m.ident,\n      tps: ty_param_bounds(ccx, m.tps),\n      fty: ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_bare, @~[],\n@@ -549,7 +558,7 @@ fn ty_of_method(ccx: @crate_ctxt,\n \n fn ty_of_ty_method(self: @crate_ctxt,\n                    m: ast::ty_method,\n-                   rp: bool) -> ty::method {\n+                   rp: option<ty::region_variance>) -> ty::method {\n     {ident: m.ident,\n      tps: ty_param_bounds(self, m.tps),\n      fty: ty_of_fn_decl(self, type_rscope(rp), ast::proto_bare, @~[], m.decl,\n@@ -564,7 +573,8 @@ fn ty_of_ty_method(self: @crate_ctxt,\n   it's bound to a valid trait type. Returns the def_id for the defining\n   trait. Fails if the type is a type other than an trait type.\n  */\n-fn instantiate_trait_ref(ccx: @crate_ctxt, t: @ast::trait_ref, rp: bool)\n+fn instantiate_trait_ref(ccx: @crate_ctxt, t: @ast::trait_ref,\n+                         rp: option<ty::region_variance>)\n     -> (ast::def_id, ty_param_substs_and_ty) {\n \n     let sp = t.path.span, err = ~\"can only implement trait types\",\n@@ -596,7 +606,7 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n       some(tpt) => return tpt,\n       _ => {}\n     }\n-    let rp = tcx.region_paramd_items.contains_key(it.id);\n+    let rp = tcx.region_paramd_items.find(it.id);\n     match it.node {\n       ast::item_const(t, _) => {\n         let typ = ccx.to_ty(empty_rscope, t);\n@@ -609,7 +619,7 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n         let tofd = ty_of_fn_decl(ccx, empty_rscope, ast::proto_bare, @~[],\n                                  decl, none, it.span);\n         let tpt = {bounds: bounds,\n-                   rp: false, // functions do not have a self\n+                   region_param: none,\n                    ty: ty::mk_fn(ccx.tcx, tofd)};\n         debug!{\"type of %s (id %d) is %s\",\n                tcx.sess.str_of(it.ident), it.id, ty_to_str(tcx, tpt.ty)};\n@@ -622,7 +632,7 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n           none => { }\n         }\n \n-        let rp = tcx.region_paramd_items.contains_key(it.id);\n+        let rp = tcx.region_paramd_items.find(it.id);\n         let tpt = {\n             let ty = {\n                 let t0 = ccx.to_ty(type_rscope(rp), t);\n@@ -634,7 +644,9 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n                     ty::mk_with_id(tcx, t0, def_id)\n                 }\n             };\n-            {bounds: ty_param_bounds(ccx, tps), rp: rp, ty: ty}\n+            {bounds: ty_param_bounds(ccx, tps),\n+             region_param: rp,\n+             ty: ty}\n         };\n \n         tcx.tcache.insert(local_def(it.id), tpt);\n@@ -644,21 +656,27 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n         // Create a new generic polytype.\n         let {bounds, substs} = mk_substs(ccx, tps, rp);\n         let t = ty::mk_enum(tcx, local_def(it.id), substs);\n-        let tpt = {bounds: bounds, rp: rp, ty: t};\n+        let tpt = {bounds: bounds,\n+                   region_param: rp,\n+                   ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n       ast::item_trait(tps, _, ms) => {\n         let {bounds, substs} = mk_substs(ccx, tps, rp);\n         let t = ty::mk_trait(tcx, local_def(it.id), substs, ty::vstore_box);\n-        let tpt = {bounds: bounds, rp: rp, ty: t};\n+        let tpt = {bounds: bounds,\n+                   region_param: rp,\n+                   ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n       ast::item_class(_, tps) => {\n           let {bounds,substs} = mk_substs(ccx, tps, rp);\n           let t = ty::mk_class(tcx, local_def(it.id), substs);\n-          let tpt = {bounds: bounds, rp: rp, ty: t};\n+          let tpt = {bounds: bounds,\n+                     region_param: rp,\n+                     ty: t};\n           tcx.tcache.insert(local_def(it.id), tpt);\n           return tpt;\n       }\n@@ -736,7 +754,7 @@ fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n                                    inputs: input_tys,\n                                    output: output_ty,\n                                    ret_style: ast::return_val});\n-    let tpt = {bounds: bounds, rp: false, ty: t_fn};\n+    let tpt = {bounds: bounds, region_param: none, ty: t_fn};\n     ccx.tcx.tcache.insert(def_id, tpt);\n     return tpt;\n }\n@@ -754,10 +772,11 @@ fn mk_ty_params(ccx: @crate_ctxt, atps: ~[ast::ty_param])\n      })}\n }\n \n-fn mk_substs(ccx: @crate_ctxt, atps: ~[ast::ty_param], rp: bool)\n+fn mk_substs(ccx: @crate_ctxt, atps: ~[ast::ty_param],\n+             rp: option<ty::region_variance>)\n     -> {bounds: @~[ty::param_bounds], substs: ty::substs} {\n \n     let {bounds, params} = mk_ty_params(ccx, atps);\n-    let self_r = if rp {some(ty::re_bound(ty::br_self))} else {none};\n+    let self_r = rscope::bound_self_region(rp);\n     {bounds: bounds, substs: {self_r: self_r, self_ty: none, tps: params}}\n }"}, {"sha": "308818d50f013b6e84a7f4db4f58efc107efc788", "filename": "src/rustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 53, "deletions": 7, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -58,7 +58,8 @@ trait combine {\n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t>;\n     fn tps(as: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]>;\n     fn self_tys(a: option<ty::t>, b: option<ty::t>) -> cres<option<ty::t>>;\n-    fn substs(as: &ty::substs, bs: &ty::substs) -> cres<ty::substs>;\n+    fn substs(did: ast::def_id, as: &ty::substs,\n+              bs: &ty::substs) -> cres<ty::substs>;\n     fn fns(a: &ty::fn_ty, b: &ty::fn_ty) -> cres<ty::fn_ty>;\n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field>;\n     fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode>;\n@@ -148,12 +149,57 @@ fn eq_opt_regions<C:combine>(\n }\n \n fn super_substs<C:combine>(\n-    self: &C, a: &ty::substs, b: &ty::substs) -> cres<ty::substs> {\n+    self: &C, did: ast::def_id,\n+    a: &ty::substs, b: &ty::substs) -> cres<ty::substs> {\n+\n+    fn relate_region_param<C:combine>(\n+        self: &C,\n+        did: ast::def_id,\n+        a: option<ty::region>,\n+        b: option<ty::region>)\n+        -> cres<option<ty::region>>\n+    {\n+        let polyty = ty::lookup_item_type(self.infcx().tcx, did);\n+        match (polyty.region_param, a, b) {\n+          (none, none, none) => {\n+            ok(none)\n+          }\n+          (some(ty::rv_invariant), some(a), some(b)) => {\n+            do eq_regions(self, a, b).then {\n+                ok(some(a))\n+            }\n+          }\n+          (some(ty::rv_covariant), some(a), some(b)) => {\n+            do self.regions(a, b).chain |r| {\n+                ok(some(r))\n+            }\n+          }\n+          (some(ty::rv_contravariant), some(a), some(b)) => {\n+            do self.contraregions(a, b).chain |r| {\n+                ok(some(r))\n+            }\n+          }\n+          (_, _, _) => {\n+            // If these two substitutions are for the same type (and\n+            // they should be), then the type should either\n+            // consistently have a region parameter or not have a\n+            // region parameter, and that should match with the\n+            // polytype.\n+            self.infcx().tcx.sess.bug(\n+                fmt!(\"substitution a had opt_region %s and \\\n+                      b had opt_region %s with variance %?\",\n+                      a.to_str(self.infcx()),\n+                      b.to_str(self.infcx()),\n+                      polyty.region_param));\n+          }\n+        }\n+    }\n \n     do self.tps(a.tps, b.tps).chain |tps| {\n         do self.self_tys(a.self_ty, b.self_ty).chain |self_ty| {\n-            do eq_opt_regions(self, a.self_r, b.self_r).chain\n-                |self_r| {\n+            do relate_region_param(self, did,\n+                                   a.self_r, b.self_r).chain |self_r|\n+            {\n                 ok({self_r: self_r, self_ty: self_ty, tps: tps})\n             }\n         }\n@@ -348,15 +394,15 @@ fn super_tys<C:combine>(\n       (ty::ty_enum(a_id, ref a_substs),\n        ty::ty_enum(b_id, ref b_substs))\n       if a_id == b_id => {\n-        do self.substs(a_substs, b_substs).chain |substs| {\n+        do self.substs(a_id, a_substs, b_substs).chain |substs| {\n             ok(ty::mk_enum(tcx, a_id, substs))\n         }\n       }\n \n       (ty::ty_trait(a_id, ref a_substs, a_vstore),\n        ty::ty_trait(b_id, ref b_substs, b_vstore))\n       if a_id == b_id => {\n-        do self.substs(a_substs, b_substs).chain |substs| {\n+        do self.substs(a_id, a_substs, b_substs).chain |substs| {\n             do self.vstores(ty::terr_trait, a_vstore, b_vstore).chain |vs| {\n                 ok(ty::mk_trait(tcx, a_id, substs, vs))\n             }\n@@ -365,7 +411,7 @@ fn super_tys<C:combine>(\n \n       (ty::ty_class(a_id, ref a_substs), ty::ty_class(b_id, ref b_substs))\n       if a_id == b_id => {\n-        do self.substs(a_substs, b_substs).chain |substs| {\n+        do self.substs(a_id, a_substs, b_substs).chain |substs| {\n             ok(ty::mk_class(tcx, a_id, substs))\n         }\n       }"}, {"sha": "966611ab0d9c727b9774ce66dd3f4e8ff94a96b1", "filename": "src/rustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -151,8 +151,10 @@ impl Glb: combine {\n         super_fns(&self, a, b)\n     }\n \n-    fn substs(as: &ty::substs, bs: &ty::substs) -> cres<ty::substs> {\n-        super_substs(&self, as, bs)\n+    fn substs(did: ast::def_id,\n+              as: &ty::substs,\n+              bs: &ty::substs) -> cres<ty::substs> {\n+        super_substs(&self, did, as, bs)\n     }\n \n     fn tps(as: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {"}, {"sha": "d5a6b44aa5c7df2a77aa0600aa26ba07b784f0e9", "filename": "src/rustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -130,8 +130,10 @@ impl Lub: combine {\n         super_fns(&self, a, b)\n     }\n \n-    fn substs(as: &ty::substs, bs: &ty::substs) -> cres<ty::substs> {\n-        super_substs(&self, as, bs)\n+    fn substs(did: ast::def_id,\n+              as: &ty::substs,\n+              bs: &ty::substs) -> cres<ty::substs> {\n+        super_substs(&self, did, as, bs)\n     }\n \n     fn tps(as: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {"}, {"sha": "d2bdc61724ccf64201f5068491b54396190ec584", "filename": "src/rustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -184,8 +184,10 @@ impl Sub: combine {\n         super_args(&self, a, b)\n     }\n \n-    fn substs(as: &ty::substs, bs: &ty::substs) -> cres<ty::substs> {\n-        super_substs(&self, as, bs)\n+    fn substs(did: ast::def_id,\n+              as: &ty::substs,\n+              bs: &ty::substs) -> cres<ty::substs> {\n+        super_substs(&self, did, as, bs)\n     }\n \n     fn tps(as: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {"}, {"sha": "340399427fc94f987ae4a4d9e9376b90bd5f1c74", "filename": "src/rustc/middle/typeck/rscope.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -17,14 +17,13 @@ impl empty_rscope: region_scope {\n     }\n }\n \n-enum type_rscope = bool;\n+enum type_rscope = option<ty::region_variance>;\n impl type_rscope: region_scope {\n     fn anon_region(_span: span) -> result<ty::region, ~str> {\n-        if *self {\n-            result::ok(ty::re_bound(ty::br_self))\n-        } else {\n-            result::err(~\"to use region types here, the containing type \\\n-                         must be declared with a region bound\")\n+        match *self {\n+          some(_) => result::ok(ty::re_bound(ty::br_self)),\n+          none => result::err(~\"to use region types here, the containing \\\n+                                type must be declared with a region bound\")\n         }\n     }\n     fn named_region(span: span, id: ast::ident) -> result<ty::region, ~str> {\n@@ -39,6 +38,13 @@ impl type_rscope: region_scope {\n     }\n }\n \n+fn bound_self_region(rp: option<ty::region_variance>) -> option<ty::region> {\n+    match rp {\n+      some(_) => some(ty::re_bound(ty::br_self)),\n+      none => none\n+    }\n+}\n+\n enum anon_rscope = {anon: ty::region, base: region_scope};\n fn in_anon_rscope<RS: region_scope copy owned>(self: RS, r: ty::region)\n     -> @anon_rscope {"}, {"sha": "434b360d18cf0d70bd0e29f1e40887616c2a84af", "filename": "src/test/compile-fail/regions-creating-enums3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums3.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -5,7 +5,6 @@ enum ast {\n \n fn mk_add_bad1(x: &a/ast, y: &b/ast) -> ast/&a {\n     add(x, y) //~ ERROR cannot infer an appropriate lifetime\n-        //~^ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {"}, {"sha": "e4c86c14b3e85a8128b6399563c619b840635212", "filename": "src/test/compile-fail/regions-creating-enums4.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -6,7 +6,6 @@ enum ast {\n fn mk_add_bad2(x: &a/ast, y: &a/ast, z: &ast) -> ast {\n     add(x, y)\n          //~^ ERROR cannot infer an appropriate lifetime\n-         //~^^ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {"}, {"sha": "07d456d31885c9ab638939fd409d39a724545457", "filename": "src/test/compile-fail/regions-infer-contravariance-due-to-immutability.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-immutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-immutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-immutability.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -0,0 +1,18 @@\n+struct contravariant {\n+    f: &int;\n+}\n+\n+fn to_same_lifetime(bi: contravariant/&r) {\n+    let bj: contravariant/&r = bi;\n+}\n+\n+fn to_shorter_lifetime(bi: contravariant/&r) {\n+    let bj: contravariant/&blk = bi;\n+}\n+\n+fn to_longer_lifetime(bi: contravariant/&r) -> contravariant/&static {\n+    bi //~ ERROR mismatched types\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "970350748d55a5a9decf42778bf160dbb6f12a0b", "filename": "src/test/compile-fail/regions-infer-contravariance-due-to-ret.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-ret.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -0,0 +1,23 @@\n+// Contravariant with respect to a region:\n+//\n+// You can upcast to a *smaller region* but not a larger one.  This is\n+// the normal case.\n+\n+struct contravariant {\n+    f: fn@() -> &self/int;\n+}\n+\n+fn to_same_lifetime(bi: contravariant/&r) {\n+    let bj: contravariant/&r = bi;\n+}\n+\n+fn to_shorter_lifetime(bi: contravariant/&r) {\n+    let bj: contravariant/&blk = bi;\n+}\n+\n+fn to_longer_lifetime(bi: contravariant/&r) -> contravariant/&static {\n+    bi //~ ERROR mismatched types\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "a2a0d131760686d24874f871d77d7a57560c1d18", "filename": "src/test/compile-fail/regions-infer-covariance-due-to-arg.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -0,0 +1,22 @@\n+// Covariant with respect to a region:\n+//\n+// You can upcast to a *larger region* but not a smaller one.\n+\n+struct covariant {\n+    f: fn@(x: &self/int) -> int;\n+}\n+\n+fn to_same_lifetime(bi: covariant/&r) {\n+    let bj: covariant/&r = bi;\n+}\n+\n+fn to_shorter_lifetime(bi: covariant/&r) {\n+    let bj: covariant/&blk = bi; //~ ERROR mismatched types\n+}\n+\n+fn to_longer_lifetime(bi: covariant/&r) -> covariant/&static {\n+    bi\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "d7ed0ed1d76d6705ed0d20caadc572d5b536c6c6", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-arg-and-ret.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-arg-and-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-arg-and-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-arg-and-ret.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -0,0 +1,22 @@\n+// Invariance with respect to a region:\n+//\n+// You cannot convert between regions.\n+\n+struct invariant {\n+    f: fn(x: &self/int) -> &self/int;\n+}\n+\n+fn to_same_lifetime(bi: invariant/&r) {\n+    let bj: invariant/&r = bi;\n+}\n+\n+fn to_shorter_lifetime(bi: invariant/&r) {\n+    let bj: invariant/&blk = bi; //~ ERROR mismatched types\n+}\n+\n+fn to_longer_lifetime(bi: invariant/&r) -> invariant/&static {\n+    bi //~ ERROR mismatched types\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "0b0a8bb74481bfacd62f55fc7dcaa1d0f4ab95e2", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-1.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -0,0 +1,18 @@\n+struct invariant {\n+    f: @mut &int;\n+}\n+\n+fn to_same_lifetime(bi: invariant/&r) {\n+    let bj: invariant/&r = bi;\n+}\n+\n+fn to_shorter_lifetime(bi: invariant/&r) {\n+    let bj: invariant/&blk = bi; //~ ERROR mismatched types\n+}\n+\n+fn to_longer_lifetime(bi: invariant/&r) -> invariant/&static {\n+    bi //~ ERROR mismatched types\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "cad76bb63806b0115f0906135d527bdf5e9ec813", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-2.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -0,0 +1,18 @@\n+struct invariant {\n+    f: @[mut &int];\n+}\n+\n+fn to_same_lifetime(bi: invariant/&r) {\n+    let bj: invariant/&r = bi;\n+}\n+\n+fn to_shorter_lifetime(bi: invariant/&r) {\n+    let bj: invariant/&blk = bi; //~ ERROR mismatched types\n+}\n+\n+fn to_longer_lifetime(bi: invariant/&r) -> invariant/&static {\n+    bi //~ ERROR mismatched types\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "0f8441110f13aaba79c2354a787f59fe81bdd2a4", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-3.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-3.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -0,0 +1,18 @@\n+struct invariant {\n+    f: fn@(x: @mut &self/int);\n+}\n+\n+fn to_same_lifetime(bi: invariant/&r) {\n+    let bj: invariant/&r = bi;\n+}\n+\n+fn to_shorter_lifetime(bi: invariant/&r) {\n+    let bj: invariant/&blk = bi; //~ ERROR mismatched types\n+}\n+\n+fn to_longer_lifetime(bi: invariant/&r) -> invariant/&static {\n+    bi //~ ERROR mismatched types\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "e39293ddcb132fd9a8aeae441c4f319ff73607ba", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-4.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -0,0 +1,18 @@\n+struct invariant {\n+    f: fn@() -> @mut &self/int;\n+}\n+\n+fn to_same_lifetime(bi: invariant/&r) {\n+    let bj: invariant/&r = bi;\n+}\n+\n+fn to_shorter_lifetime(bi: invariant/&r) {\n+    let bj: invariant/&blk = bi; //~ ERROR mismatched types\n+}\n+\n+fn to_longer_lifetime(bi: invariant/&r) -> invariant/&static {\n+    bi //~ ERROR mismatched types\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "f00888add68a060e9688447c0e581ac93337c394", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -0,0 +1,18 @@\n+struct invariant {\n+    mut f: &int;\n+}\n+\n+fn to_same_lifetime(bi: invariant/&r) {\n+    let bj: invariant/&r = bi;\n+}\n+\n+fn to_shorter_lifetime(bi: invariant/&r) {\n+    let bj: invariant/&blk = bi; //~ ERROR mismatched types\n+}\n+\n+fn to_longer_lifetime(bi: invariant/&r) -> invariant/&static {\n+    bi //~ ERROR mismatched types\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "e6b00890fabbb6072e28d54040d9ef35582f5620", "filename": "src/test/run-pass/regions-infer-contravariance-due-to-ret.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance-due-to-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance-due-to-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance-due-to-ret.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -0,0 +1,18 @@\n+struct boxed_int {\n+    f: &int;\n+}\n+\n+fn max(bi: &r/boxed_int, f: &r/int) -> int {\n+    if *bi.f > *f {*bi.f} else {*f}\n+}\n+\n+fn with(bi: &boxed_int) -> int {\n+    let i = 22;\n+    max(bi, &i)\n+}\n+\n+fn main() {\n+    let g = 21;\n+    let foo = boxed_int { f: &g };\n+    assert with(&foo) == 22;\n+}\n\\ No newline at end of file"}, {"sha": "0007556375030e9175297b0475110dca3a8683ef", "filename": "src/test/run-pass/regions-infer-contravariance.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -0,0 +1,21 @@\n+struct boxed_int {\n+    f: &int;\n+}\n+\n+fn get(bi: &r/boxed_int) -> &r/int {\n+    bi.f\n+}\n+\n+fn with(bi: &r/boxed_int) {\n+    // Here, the upcast is allowed because the `boxed_int` type is\n+    // contravariant with respect to `&r`.  See also\n+    // compile-fail/regions-infer-invariance-due-to-mutability.rs\n+    let bi: &blk/boxed_int/&blk = bi;\n+    assert *get(bi) == 22;\n+}\n+\n+fn main() {\n+    let g = 22;\n+    let foo = boxed_int { f: &g };\n+    with(&foo);\n+}\n\\ No newline at end of file"}, {"sha": "d5e009c5bb7afeab55e45bc26abd6f998dd1b351", "filename": "src/test/run-pass/regions-trait.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Frun-pass%2Fregions-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511e7626aebe7a8a41c3be1c6fbd16c92e8f9386/src%2Ftest%2Frun-pass%2Fregions-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-trait.rs?ref=511e7626aebe7a8a41c3be1c6fbd16c92e8f9386", "patch": "@@ -20,7 +20,5 @@ fn main() {\n     let ctxt = { v: 22u };\n     let hc = { c: &ctxt };\n \n-    // This no longer works, interestingly, due to the ownership\n-    // requirement.  Perhaps this ownership requirement is too strict.\n-    // assert get_v(hc as get_ctxt) == 22u;\n+    assert get_v(hc as get_ctxt) == 22u;\n }"}]}