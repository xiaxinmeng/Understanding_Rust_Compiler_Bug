{"sha": "2ccfb49baba6a9a0381e8a5be77df5a3c8f46205", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjY2ZiNDliYWJhNmE5YTAzODFlOGE1YmU3N2RmNWEzYzhmNDYyMDU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-25T12:53:15Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-25T12:53:15Z"}, "message": "Always expand macros during analysis", "tree": {"sha": "eedee71ea4d2535dddeb2aa56966140652d6d2c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eedee71ea4d2535dddeb2aa56966140652d6d2c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ccfb49baba6a9a0381e8a5be77df5a3c8f46205", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ccfb49baba6a9a0381e8a5be77df5a3c8f46205", "html_url": "https://github.com/rust-lang/rust/commit/2ccfb49baba6a9a0381e8a5be77df5a3c8f46205", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ccfb49baba6a9a0381e8a5be77df5a3c8f46205/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2dd17f75b1bb5e1185acff66211e74430177592", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2dd17f75b1bb5e1185acff66211e74430177592", "html_url": "https://github.com/rust-lang/rust/commit/e2dd17f75b1bb5e1185acff66211e74430177592"}], "stats": {"total": 74, "additions": 51, "deletions": 23}, "files": [{"sha": "16a5fe9680973f6ded918c65d148a081bd618a03", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ccfb49baba6a9a0381e8a5be77df5a3c8f46205/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccfb49baba6a9a0381e8a5be77df5a3c8f46205/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=2ccfb49baba6a9a0381e8a5be77df5a3c8f46205", "patch": "@@ -173,11 +173,11 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     }\n \n     pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n-        self.analyze(call.syntax()).resolve_method_call(call)\n+        self.analyze(call.syntax()).resolve_method_call(self.db, call)\n     }\n \n     pub fn resolve_field(&self, field: &ast::FieldExpr) -> Option<StructField> {\n-        self.analyze(field.syntax()).resolve_field(field)\n+        self.analyze(field.syntax()).resolve_field(self.db, field)\n     }\n \n     pub fn resolve_record_field(\n@@ -188,7 +188,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     }\n \n     pub fn resolve_record_literal(&self, record_lit: &ast::RecordLit) -> Option<VariantDef> {\n-        self.analyze(record_lit.syntax()).resolve_record_literal(record_lit)\n+        self.analyze(record_lit.syntax()).resolve_record_literal(self.db, record_lit)\n     }\n \n     pub fn resolve_record_pattern(&self, record_pat: &ast::RecordPat) -> Option<VariantDef> {"}, {"sha": "815ca158c140e4f4dc9ea13f5bc2d2c3b5031605", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2ccfb49baba6a9a0381e8a5be77df5a3c8f46205/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccfb49baba6a9a0381e8a5be77df5a3c8f46205/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=2ccfb49baba6a9a0381e8a5be77df5a3c8f46205", "patch": "@@ -78,9 +78,15 @@ impl SourceAnalyzer {\n         }\n     }\n \n-    fn expr_id(&self, expr: &ast::Expr) -> Option<ExprId> {\n-        let src = InFile { file_id: self.file_id, value: expr };\n-        self.body_source_map.as_ref()?.node_expr(src)\n+    fn expr_id(&self, db: &dyn HirDatabase, expr: &ast::Expr) -> Option<ExprId> {\n+        let src = match expr {\n+            ast::Expr::MacroCall(call) => {\n+                self.expand_expr(db, InFile::new(self.file_id, call.clone()))?\n+            }\n+            _ => InFile::new(self.file_id, expr.clone()),\n+        };\n+        let sm = self.body_source_map.as_ref()?;\n+        sm.node_expr(src.as_ref())\n     }\n \n     fn pat_id(&self, pat: &ast::Pat) -> Option<PatId> {\n@@ -104,14 +110,7 @@ impl SourceAnalyzer {\n     }\n \n     pub(crate) fn type_of(&self, db: &dyn HirDatabase, expr: &ast::Expr) -> Option<Type> {\n-        let expr_id = match expr {\n-            ast::Expr::MacroCall(call) => {\n-                let expr = self.expand_expr(db, InFile::new(self.file_id, call.clone()))?;\n-                self.body_source_map.as_ref()?.node_expr(expr.as_ref())\n-            }\n-            _ => self.expr_id(expr),\n-        }?;\n-\n+        let expr_id = self.expr_id(db, expr)?;\n         let ty = self.infer.as_ref()?[expr_id].clone();\n         Type::new_with_resolver(db, &self.resolver, ty)\n     }\n@@ -122,13 +121,21 @@ impl SourceAnalyzer {\n         Type::new_with_resolver(db, &self.resolver, ty)\n     }\n \n-    pub(crate) fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n-        let expr_id = self.expr_id(&call.clone().into())?;\n+    pub(crate) fn resolve_method_call(\n+        &self,\n+        db: &dyn HirDatabase,\n+        call: &ast::MethodCallExpr,\n+    ) -> Option<Function> {\n+        let expr_id = self.expr_id(db, &call.clone().into())?;\n         self.infer.as_ref()?.method_resolution(expr_id).map(Function::from)\n     }\n \n-    pub(crate) fn resolve_field(&self, field: &ast::FieldExpr) -> Option<crate::StructField> {\n-        let expr_id = self.expr_id(&field.clone().into())?;\n+    pub(crate) fn resolve_field(\n+        &self,\n+        db: &dyn HirDatabase,\n+        field: &ast::FieldExpr,\n+    ) -> Option<crate::StructField> {\n+        let expr_id = self.expr_id(db, &field.clone().into())?;\n         self.infer.as_ref()?.field_resolution(expr_id).map(|it| it.into())\n     }\n \n@@ -138,7 +145,7 @@ impl SourceAnalyzer {\n         field: &ast::RecordField,\n     ) -> Option<(crate::StructField, Option<Local>)> {\n         let (expr_id, local) = match field.expr() {\n-            Some(it) => (self.expr_id(&it)?, None),\n+            Some(it) => (self.expr_id(db, &it)?, None),\n             None => {\n                 let src = InFile { file_id: self.file_id, value: field };\n                 let expr_id = self.body_source_map.as_ref()?.field_init_shorthand_expr(src)?;\n@@ -159,9 +166,10 @@ impl SourceAnalyzer {\n \n     pub(crate) fn resolve_record_literal(\n         &self,\n+        db: &dyn HirDatabase,\n         record_lit: &ast::RecordLit,\n     ) -> Option<crate::VariantDef> {\n-        let expr_id = self.expr_id(&record_lit.clone().into())?;\n+        let expr_id = self.expr_id(db, &record_lit.clone().into())?;\n         self.infer.as_ref()?.variant_resolution_for_expr(expr_id).map(|it| it.into())\n     }\n \n@@ -207,7 +215,7 @@ impl SourceAnalyzer {\n         path: &ast::Path,\n     ) -> Option<PathResolution> {\n         if let Some(path_expr) = path.syntax().parent().and_then(ast::PathExpr::cast) {\n-            let expr_id = self.expr_id(&path_expr.into())?;\n+            let expr_id = self.expr_id(db, &path_expr.into())?;\n             if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_expr(expr_id) {\n                 return Some(PathResolution::AssocItem(assoc.into()));\n             }"}, {"sha": "8aed94d162aba166761d94dcf62c872674bd523d", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2ccfb49baba6a9a0381e8a5be77df5a3c8f46205/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccfb49baba6a9a0381e8a5be77df5a3c8f46205/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=2ccfb49baba6a9a0381e8a5be77df5a3c8f46205", "patch": "@@ -104,6 +104,9 @@ mod tests {\n         let (analysis, pos) = analysis_and_position(ra_fixture);\n \n         let mut navs = analysis.goto_definition(pos).unwrap().unwrap().info;\n+        if navs.len() == 0 {\n+            panic!(\"unresolved reference\")\n+        }\n         assert_eq!(navs.len(), 1);\n \n         let nav = navs.pop().unwrap();\n@@ -359,7 +362,7 @@ mod tests {\n     fn goto_def_for_fields() {\n         covers!(ra_ide_db::goto_def_for_fields);\n         check_goto(\n-            \"\n+            r\"\n             //- /lib.rs\n             struct Foo {\n                 spam: u32,\n@@ -378,7 +381,7 @@ mod tests {\n     fn goto_def_for_record_fields() {\n         covers!(ra_ide_db::goto_def_for_record_fields);\n         check_goto(\n-            \"\n+            r\"\n             //- /lib.rs\n             struct Foo {\n                 spam: u32,\n@@ -395,6 +398,23 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn goto_def_for_record_fields_macros() {\n+        check_goto(\n+            r\"\n+            //- /lib.rs\n+            macro_rules! m { () => { 92 };}\n+            struct Foo { spam: u32 }\n+\n+            fn bar() -> Foo {\n+                Foo { spam<|>: m!() }\n+            }\n+            \",\n+            \"spam RECORD_FIELD_DEF FileId(1) [45; 54) [45; 49)\",\n+            \"spam: u32|spam\",\n+        );\n+    }\n+\n     #[test]\n     fn goto_for_tuple_fields() {\n         check_goto("}]}