{"sha": "5182cc1ca65d05f16ee5e1529707ac6f63233ca9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxODJjYzFjYTY1ZDA1ZjE2ZWU1ZTE1Mjk3MDdhYzZmNjMyMzNjYTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-06T22:23:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-06T22:23:24Z"}, "message": "Auto merge of #55318 - Aaron1011:fix/final-auto-trait-resolve, r=nikomatsakis\n\nEnsure that Rustdoc discovers all necessary auto trait bounds\n\nFixes #50159\n\nThis commit makes several improvements to AutoTraitFinder:\n\n* Call infcx.resolve_type_vars_if_possible before processing new\npredicates. This ensures that we eliminate inference variables wherever\npossible.\n* Process all nested obligations we get from a vtable, not just ones\nwith depth=1.\n  * The 'depth=1' check was a hack to work around issues processing\ncertain predicates. The other changes in this commit allow us to\nproperly process all predicates that we encounter, so the check is no\nlonger necessary,\n* Ensure that we only display predicates *without* inference variables\nto the user, and only attempt to unify predicates that *have* an\ninference variable as their type.\n\nAdditionally, the internal helper method is_of_param now operates\ndirectly on a type, rather than taking a Substs. This allows us to use\nthe 'self_ty' method, rather than directly dealing with Substs.", "tree": {"sha": "eeb9461caef0f9ee5ddc6fc6a80ac89353c92593", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eeb9461caef0f9ee5ddc6fc6a80ac89353c92593"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5182cc1ca65d05f16ee5e1529707ac6f63233ca9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5182cc1ca65d05f16ee5e1529707ac6f63233ca9", "html_url": "https://github.com/rust-lang/rust/commit/5182cc1ca65d05f16ee5e1529707ac6f63233ca9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5182cc1ca65d05f16ee5e1529707ac6f63233ca9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "118e052d84157a675649fe640e3d56f264475a3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/118e052d84157a675649fe640e3d56f264475a3a", "html_url": "https://github.com/rust-lang/rust/commit/118e052d84157a675649fe640e3d56f264475a3a"}, {"sha": "913937418150f79d80c78f1c69846903f7aaeaeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/913937418150f79d80c78f1c69846903f7aaeaeb", "html_url": "https://github.com/rust-lang/rust/commit/913937418150f79d80c78f1c69846903f7aaeaeb"}], "stats": {"total": 169, "additions": 152, "deletions": 17}, "files": [{"sha": "a0237348ea6909b459a11829bf9cb45470897d46", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 81, "deletions": 17, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/5182cc1ca65d05f16ee5e1529707ac6f63233ca9/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5182cc1ca65d05f16ee5e1529707ac6f63233ca9/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=5182cc1ca65d05f16ee5e1529707ac6f63233ca9", "patch": "@@ -334,7 +334,12 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 continue;\n             }\n \n-            let result = select.select(&Obligation::new(dummy_cause.clone(), new_env, pred));\n+            // Call infcx.resolve_type_vars_if_possible to see if we can\n+            // get rid of any inference variables.\n+            let obligation = infcx.resolve_type_vars_if_possible(\n+                &Obligation::new(dummy_cause.clone(), new_env, pred)\n+            );\n+            let result = select.select(&obligation);\n \n             match &result {\n                 &Ok(Some(ref vtable)) => {\n@@ -369,7 +374,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 }\n                 &Ok(None) => {}\n                 &Err(SelectionError::Unimplemented) => {\n-                    if self.is_of_param(pred.skip_binder().trait_ref.substs) {\n+                    if self.is_param_no_infer(pred.skip_binder().trait_ref.substs) {\n                         already_visited.remove(&pred);\n                         self.add_user_pred(\n                             &mut user_computed_preds,\n@@ -631,18 +636,28 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         finished_map\n     }\n \n-    pub fn is_of_param(&self, substs: &Substs<'_>) -> bool {\n-        if substs.is_noop() {\n-            return false;\n-        }\n+    fn is_param_no_infer(&self, substs: &Substs<'_>) -> bool {\n+        return self.is_of_param(substs.type_at(0)) &&\n+            !substs.types().any(|t| t.has_infer_types());\n+    }\n \n-        return match substs.type_at(0).sty {\n+    pub fn is_of_param(&self, ty: Ty<'_>) -> bool {\n+        return match ty.sty {\n             ty::Param(_) => true,\n-            ty::Projection(p) => self.is_of_param(p.substs),\n+            ty::Projection(p) => self.is_of_param(p.self_ty()),\n             _ => false,\n         };\n     }\n \n+    fn is_self_referential_projection(&self, p: ty::PolyProjectionPredicate<'_>) -> bool {\n+        match p.ty().skip_binder().sty {\n+            ty::Projection(proj) if proj == p.skip_binder().projection_ty => {\n+                true\n+            },\n+            _ => false\n+        }\n+    }\n+\n     pub fn evaluate_nested_obligations<\n         'b,\n         'c,\n@@ -661,28 +676,77 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     ) -> bool {\n         let dummy_cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n \n-        for (obligation, predicate) in nested\n-            .filter(|o| o.recursion_depth == 1)\n+        for (obligation, mut predicate) in nested\n             .map(|o| (o.clone(), o.predicate.clone()))\n         {\n             let is_new_pred =\n                 fresh_preds.insert(self.clean_pred(select.infcx(), predicate.clone()));\n \n+            // Resolve any inference variables that we can, to help selection succeed\n+            predicate = select.infcx().resolve_type_vars_if_possible(&predicate);\n+\n+            // We only add a predicate as a user-displayable bound if\n+            // it involves a generic parameter, and doesn't contain\n+            // any inference variables.\n+            //\n+            // Displaying a bound involving a concrete type (instead of a generic\n+            // parameter) would be pointless, since it's always true\n+            // (e.g. u8: Copy)\n+            // Displaying an inference variable is impossible, since they're\n+            // an internal compiler detail without a defined visual representation\n+            //\n+            // We check this by calling is_of_param on the relevant types\n+            // from the various possible predicates\n             match &predicate {\n                 &ty::Predicate::Trait(ref p) => {\n-                    let substs = &p.skip_binder().trait_ref.substs;\n+                    if self.is_param_no_infer(p.skip_binder().trait_ref.substs)\n+                        && !only_projections\n+                        && is_new_pred {\n \n-                    if self.is_of_param(substs) && !only_projections && is_new_pred {\n                         self.add_user_pred(computed_preds, predicate);\n                     }\n                     predicates.push_back(p.clone());\n                 }\n                 &ty::Predicate::Projection(p) => {\n-                    // If the projection isn't all type vars, then\n-                    // we don't want to add it as a bound\n-                    if self.is_of_param(p.skip_binder().projection_ty.substs) && is_new_pred {\n-                        self.add_user_pred(computed_preds, predicate);\n-                    } else {\n+                    debug!(\"evaluate_nested_obligations: examining projection predicate {:?}\",\n+                           predicate);\n+\n+                    // As described above, we only want to display\n+                    // bounds which include a generic parameter but don't include\n+                    // an inference variable.\n+                    // Additionally, we check if we've seen this predicate before,\n+                    // to avoid rendering duplicate bounds to the user.\n+                    if self.is_param_no_infer(p.skip_binder().projection_ty.substs)\n+                        && !p.ty().skip_binder().is_ty_infer()\n+                        && is_new_pred {\n+                            debug!(\"evaluate_nested_obligations: adding projection predicate\\\n+                            to computed_preds: {:?}\", predicate);\n+\n+                            // Under unusual circumstances, we can end up with a self-refeential\n+                            // projection predicate. For example:\n+                            // <T as MyType>::Value == <T as MyType>::Value\n+                            // Not only is displaying this to the user pointless,\n+                            // having it in the ParamEnv will cause an issue if we try to call\n+                            // poly_project_and_unify_type on the predicate, since this kind of\n+                            // predicate will normally never end up in a ParamEnv.\n+                            //\n+                            // For these reasons, we ignore these weird predicates,\n+                            // ensuring that we're able to properly synthesize an auto trait impl\n+                            if self.is_self_referential_projection(p) {\n+                                debug!(\"evaluate_nested_obligations: encountered a projection\n+                                 predicate equating a type with itself! Skipping\");\n+\n+                            } else {\n+                                self.add_user_pred(computed_preds, predicate);\n+                            }\n+                    }\n+\n+                    // We can only call poly_project_and_unify_type when our predicate's\n+                    // Ty is an inference variable - otherwise, there won't be anything to\n+                    // unify\n+                    if p.ty().skip_binder().is_ty_infer() {\n+                        debug!(\"Projecting and unifying projection predicate {:?}\",\n+                               predicate);\n                         match poly_project_and_unify_type(select, &obligation.with(p.clone())) {\n                             Err(e) => {\n                                 debug!("}, {"sha": "3055c721624529d7397fc63636a9dede3489bcf3", "filename": "src/test/rustdoc/issue-50159.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5182cc1ca65d05f16ee5e1529707ac6f63233ca9/src%2Ftest%2Frustdoc%2Fissue-50159.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5182cc1ca65d05f16ee5e1529707ac6f63233ca9/src%2Ftest%2Frustdoc%2Fissue-50159.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-50159.rs?ref=5182cc1ca65d05f16ee5e1529707ac6f63233ca9", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+pub trait Signal {\n+    type Item;\n+}\n+\n+pub trait Signal2 {\n+    type Item2;\n+}\n+\n+impl<B, C> Signal2 for B where B: Signal<Item = C> {\n+    type Item2 = C;\n+}\n+\n+// @has issue_50159/struct.Switch.html\n+// @has - '//code' 'impl<B> Send for Switch<B> where <B as Signal>::Item: Send'\n+// @has - '//code' 'impl<B> Sync for Switch<B> where <B as Signal>::Item: Sync'\n+// @count - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]' 0\n+// @count - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]' 2\n+pub struct Switch<B: Signal> {\n+    pub inner: <B as Signal2>::Item2,\n+}"}, {"sha": "516a3c9a516ab335029f0212301cfe8a658eefc9", "filename": "src/test/rustdoc/synthetic_auto/self-referential.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5182cc1ca65d05f16ee5e1529707ac6f63233ca9/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fself-referential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5182cc1ca65d05f16ee5e1529707ac6f63233ca9/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fself-referential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fself-referential.rs?ref=5182cc1ca65d05f16ee5e1529707ac6f63233ca9", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Some unusual code minimized from\n+// https://github.com/sile/handy_async/tree/7b619b762c06544fc67792c8ff8ebc24a88fdb98\n+\n+pub trait Pattern {\n+    type Value;\n+}\n+\n+pub struct Constrain<A, B = A, C = A>(A, B, C);\n+\n+impl<A, B, C> Pattern for Constrain<A, B, C>\n+    where A: Pattern,\n+          B: Pattern<Value = A::Value>,\n+          C: Pattern<Value = A::Value>,\n+{\n+    type Value = A::Value;\n+}\n+\n+pub struct Wrapper<T>(T);\n+\n+impl<T> Pattern for Wrapper<T> {\n+    type Value = T;\n+}\n+\n+\n+// @has self_referential/struct.WriteAndThen.html\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<P1> Send for \\\n+// WriteAndThen<P1>  where  <P1 as Pattern>::Value: Send\"\n+pub struct WriteAndThen<P1>(pub P1::Value,pub <Constrain<P1, Wrapper<P1::Value>> as Pattern>::Value)\n+    where P1: Pattern;\n+"}]}