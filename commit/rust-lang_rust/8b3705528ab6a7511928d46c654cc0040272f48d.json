{"sha": "8b3705528ab6a7511928d46c654cc0040272f48d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMzcwNTUyOGFiNmE3NTExOTI4ZDQ2YzY1NGNjMDA0MDI3MmY0OGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-11T02:10:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-11T02:10:31Z"}, "message": "Auto merge of #27416 - alexcrichton:fix-dll-export, r=brson\n\nThese two commits are aimed at \"fixing\" our usage of `dllexport` in the compiler. Currently we blanket apply this attribute to *everything* public in a crate, but this ends up with a few downsides:\r\n\r\n* Executables are larger than the should be as a result of thinking they should export everything\r\n* Native libraries aren't handled correctly because technically a statically included native library should be exported from a DLL in some cases.\r\n* Symbols don't actually need to be exported if they never end up in a DLL.\r\n\r\nThe first commit adds a new unstable attribute, `#[linked_from]`, which is a way to tell the compiler what native library a block of symbols comes from. This is used to inform the compiler what set of native libraries are statically included in the rlib (or other output). This information is later used to export them from a DLL if necessary. Currently this is only used in a few places (such as the LLVM bindings) to get the compiler to link correctly.\r\n\r\nThe second commit stops adding `dllexport` to all items in LLVM and instead explicitly telling the linker what symbols should be exported. We only need to do this when building a dynamic library, and otherwise we can avoid adding `dllexport` or telling the linker about exported symbols.\r\n\r\nAs a testament to this change, the size of \"Hello World\" on MSVC drops from 1.2MB to 67KB as a result of this patch. This is because the linker can much more aggressively remove unused code.\r\n\r\nThese commits do not yet attempt to fix our story with `dllimport`, and I'll leave that to a future PR and issue, for now though I'm going to say that this\r\n\r\nCloses #7196", "tree": {"sha": "9a00b0e642a2dfe823f6ed89f4bd18027079d39c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a00b0e642a2dfe823f6ed89f4bd18027079d39c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b3705528ab6a7511928d46c654cc0040272f48d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b3705528ab6a7511928d46c654cc0040272f48d", "html_url": "https://github.com/rust-lang/rust/commit/8b3705528ab6a7511928d46c654cc0040272f48d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b3705528ab6a7511928d46c654cc0040272f48d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5aca49c693c9be3064d9e6db9473b1fa76834b79", "url": "https://api.github.com/repos/rust-lang/rust/commits/5aca49c693c9be3064d9e6db9473b1fa76834b79", "html_url": "https://github.com/rust-lang/rust/commit/5aca49c693c9be3064d9e6db9473b1fa76834b79"}, {"sha": "e648c96c5f9b69022ae416040cf0558221a11d77", "url": "https://api.github.com/repos/rust-lang/rust/commits/e648c96c5f9b69022ae416040cf0558221a11d77", "html_url": "https://github.com/rust-lang/rust/commit/e648c96c5f9b69022ae416040cf0558221a11d77"}], "stats": {"total": 498, "additions": 330, "deletions": 168}, "files": [{"sha": "082c0d526a0f0e7824720ff7c7215aa4c01c62a8", "filename": "mk/platform.mk", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8b3705528ab6a7511928d46c654cc0040272f48d/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/8b3705528ab6a7511928d46c654cc0040272f48d/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=8b3705528ab6a7511928d46c654cc0040272f48d", "patch": "@@ -277,10 +277,15 @@ $(foreach target,$(CFG_TARGET), \\\n # Fun times!\n #\n # [1]: https://msdn.microsoft.com/en-us/library/28d6s79h.aspx\n+#\n+# FIXME(stage0): remove this macro and the usage below (and the commments above)\n+# \t         when a new snapshot is available. Also remove the\n+# \t         RUSTFLAGS$(1)_.._T_ variable in mk/target.mk along with\n+# \t         CUSTOM_DEPS (as they were only added for this)\n define ADD_RUSTC_LLVM_DEF_TO_MSVC\n ifeq ($$(findstring msvc,$(1)),msvc)\n-RUSTFLAGS_rustc_llvm_T_$(1) += -C link-args=\"-DEF:$(1)/rt/rustc_llvm.def\"\n-CUSTOM_DEPS_rustc_llvm_T_$(1) += $(1)/rt/rustc_llvm.def\n+RUSTFLAGS0_rustc_llvm_T_$(1) += -C link-args=\"-DEF:$(1)/rt/rustc_llvm.def\"\n+CUSTOM_DEPS0_rustc_llvm_T_$(1) += $(1)/rt/rustc_llvm.def\n \n $(1)/rt/rustc_llvm.def: $$(S)src/etc/mklldef.py $$(S)src/librustc_llvm/lib.rs\n \t$$(CFG_PYTHON) $$^ $$@ rustc_llvm-$$(CFG_FILENAME_EXTRA)"}, {"sha": "cd22a77bd22e11cb1960ed232e0a55ea43f4c999", "filename": "mk/target.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b3705528ab6a7511928d46c654cc0040272f48d/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/8b3705528ab6a7511928d46c654cc0040272f48d/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=8b3705528ab6a7511928d46c654cc0040272f48d", "patch": "@@ -40,7 +40,7 @@ CRATE_FULLDEPS_$(1)_T_$(2)_H_$(3)_$(4) := \\\n \t\t  $$(RT_OUTPUT_DIR_$(2))/$$(dep)) \\\n \t\t$$(foreach dep,$$(NATIVE_TOOL_DEPS_$(4)_T_$(2)), \\\n \t\t  $$(TBIN$(1)_T_$(3)_H_$(3))/$$(dep)) \\\n-\t\t$$(CUSTOM_DEPS_$(4)_T_$(2))\n+\t\t$$(CUSTOM_DEPS$(1)_$(4)_T_$(2))\n endef\n \n $(foreach host,$(CFG_HOST), \\\n@@ -92,7 +92,7 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$(4): \\\n \t\t$$(LLVM_LIBDIR_RUSTFLAGS_$(2)) \\\n \t\t$$(LLVM_STDCPP_RUSTFLAGS_$(2)) \\\n \t\t$$(RUSTFLAGS_$(4)) \\\n-\t\t$$(RUSTFLAGS_$(4)_T_$(2)) \\\n+\t\t$$(RUSTFLAGS$(1)_$(4)_T_$(2)) \\\n \t\t--out-dir $$(@D) \\\n \t\t-C extra-filename=-$$(CFG_FILENAME_EXTRA) \\\n \t\t$$<"}, {"sha": "878dc00e7b462bc77da43e61e13ebc27e863d251", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=8b3705528ab6a7511928d46c654cc0040272f48d", "patch": "@@ -26,8 +26,7 @@ fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n     // Add the new dylib search path var\n     let var = DynamicLibrary::envvar();\n     let newpath = DynamicLibrary::create_path(&path);\n-    let newpath = newpath.to_str().unwrap().to_string();\n-    cmd.env(var, &newpath);\n+    cmd.env(var, newpath);\n }\n \n pub struct Result {pub status: ExitStatus, pub out: String, pub err: String}"}, {"sha": "4d5564d9fafb082b574e0eaf8f0480d234e50b29", "filename": "src/doc/reference.md", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=8b3705528ab6a7511928d46c654cc0040272f48d", "patch": "@@ -1924,10 +1924,16 @@ On an `extern` block, the following attributes are interpreted:\n   name and type. This is feature gated and the exact behavior is\n   implementation-defined (due to variety of linker invocation syntax).\n - `link` - indicate that a native library should be linked to for the\n-  declarations in this block to be linked correctly. `link` supports an optional `kind`\n-  key with three possible values: `dylib`, `static`, and `framework`. See [external blocks](#external-blocks) for more about external blocks. Two\n+  declarations in this block to be linked correctly. `link` supports an optional\n+  `kind` key with three possible values: `dylib`, `static`, and `framework`. See\n+  [external blocks](#external-blocks) for more about external blocks. Two\n   examples: `#[link(name = \"readline\")]` and\n   `#[link(name = \"CoreFoundation\", kind = \"framework\")]`.\n+- `linked_from` - indicates what native library this block of FFI items is\n+  coming from. This attribute is of the form `#[linked_from = \"foo\"]` where\n+  `foo` is the name of a library in either `#[link]` or a `-l` flag. This\n+  attribute is currently required to export symbols from a Rust dynamic library\n+  on Windows, and it is feature gated behind the `linked_from` feature.\n \n On declarations inside an `extern` block, the following attributes are\n interpreted:"}, {"sha": "abcff6e78e2c6fa0d60717210d19841039a32c82", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=8b3705528ab6a7511928d46c654cc0040272f48d", "patch": "@@ -205,8 +205,8 @@ pub const tag_plugin_registrar_fn: usize = 0x10b; // top-level only\n pub const tag_method_argument_names: usize = 0x85;\n pub const tag_method_argument_name: usize = 0x86;\n \n-pub const tag_reachable_extern_fns: usize = 0x10c; // top-level only\n-pub const tag_reachable_extern_fn_id: usize = 0x87;\n+pub const tag_reachable_ids: usize = 0x10c; // top-level only\n+pub const tag_reachable_id: usize = 0x87;\n \n pub const tag_items_data_item_stability: usize = 0x88;\n "}, {"sha": "3226a99c6b3ae285cf7885fa1d67eac578ff2c29", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 77, "deletions": 73, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=8b3705528ab6a7511928d46c654cc0040272f48d", "patch": "@@ -20,6 +20,7 @@ use metadata::cstore::{CStore, CrateSource, MetadataBlob};\n use metadata::decoder;\n use metadata::loader;\n use metadata::loader::CratePaths;\n+use util::nodemap::FnvHashMap;\n \n use std::cell::RefCell;\n use std::path::PathBuf;\n@@ -47,6 +48,7 @@ pub struct LocalCrateReader<'a, 'b:'a> {\n pub struct CrateReader<'a> {\n     sess: &'a Session,\n     next_crate_num: ast::CrateNum,\n+    foreign_item_map: FnvHashMap<String, Vec<ast::NodeId>>,\n }\n \n impl<'a, 'b, 'v> visit::Visitor<'v> for LocalCrateReader<'a, 'b> {\n@@ -157,6 +159,7 @@ impl<'a> CrateReader<'a> {\n         CrateReader {\n             sess: sess,\n             next_crate_num: sess.cstore.next_crate_num(),\n+            foreign_item_map: FnvHashMap(),\n         }\n     }\n \n@@ -490,6 +493,20 @@ impl<'a> CrateReader<'a> {\n             _ => None,\n         }\n     }\n+\n+    fn register_statically_included_foreign_items(&mut self) {\n+        let libs = self.sess.cstore.get_used_libraries();\n+        for (lib, list) in self.foreign_item_map.iter() {\n+            let is_static = libs.borrow().iter().any(|&(ref name, kind)| {\n+                lib == name && kind == cstore::NativeStatic\n+            });\n+            if is_static {\n+                for id in list {\n+                    self.sess.cstore.add_statically_included_foreign_item(*id);\n+                }\n+            }\n+        }\n+    }\n }\n \n impl<'a, 'b> LocalCrateReader<'a, 'b> {\n@@ -515,6 +532,7 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n         for &(ref name, kind) in &self.sess.opts.libs {\n             register_native_lib(self.sess, None, name.clone(), kind);\n         }\n+        self.creader.register_statically_included_foreign_items();\n     }\n \n     fn process_crate(&self, c: &ast::Crate) {\n@@ -541,87 +559,73 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n                                                               None,\n                                                               i.span,\n                                                               PathKind::Crate);\n-                        self.ast_map.with_path(i.id, |path|\n-                            cmeta.update_local_path(path));\n+                        self.ast_map.with_path(i.id, |path| {\n+                            cmeta.update_local_path(path)\n+                        });\n                         self.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n                     }\n                     None => ()\n                 }\n             }\n-            ast::ItemForeignMod(ref fm) => {\n-                if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n-                    return;\n-                }\n+            ast::ItemForeignMod(ref fm) => self.process_foreign_mod(i, fm),\n+            _ => { }\n+        }\n+    }\n \n-                // First, add all of the custom link_args attributes\n-                let link_args = i.attrs.iter()\n-                    .filter_map(|at| if at.name() == \"link_args\" {\n-                        Some(at)\n-                    } else {\n-                        None\n-                    })\n-                    .collect::<Vec<&ast::Attribute>>();\n-                for m in &link_args {\n-                    match m.value_str() {\n-                        Some(linkarg) => self.sess.cstore.add_used_link_args(&linkarg),\n-                        None => { /* fallthrough */ }\n-                    }\n-                }\n+    fn process_foreign_mod(&mut self, i: &ast::Item, fm: &ast::ForeignMod) {\n+        if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n+            return;\n+        }\n \n-                // Next, process all of the #[link(..)]-style arguments\n-                let link_args = i.attrs.iter()\n-                    .filter_map(|at| if at.name() == \"link\" {\n-                        Some(at)\n-                    } else {\n-                        None\n-                    })\n-                    .collect::<Vec<&ast::Attribute>>();\n-                for m in &link_args {\n-                    match m.meta_item_list() {\n-                        Some(items) => {\n-                            let kind = items.iter().find(|k| {\n-                                k.name() == \"kind\"\n-                            }).and_then(|a| a.value_str());\n-                            let kind = match kind {\n-                                Some(k) => {\n-                                    if k == \"static\" {\n-                                        cstore::NativeStatic\n-                                    } else if self.sess.target.target.options.is_like_osx\n-                                              && k == \"framework\" {\n-                                        cstore::NativeFramework\n-                                    } else if k == \"framework\" {\n-                                        cstore::NativeFramework\n-                                    } else if k == \"dylib\" {\n-                                        cstore::NativeUnknown\n-                                    } else {\n-                                        self.sess.span_err(m.span,\n-                                            &format!(\"unknown kind: `{}`\",\n-                                                    k));\n-                                        cstore::NativeUnknown\n-                                    }\n-                                }\n-                                None => cstore::NativeUnknown\n-                            };\n-                            let n = items.iter().find(|n| {\n-                                n.name() == \"name\"\n-                            }).and_then(|a| a.value_str());\n-                            let n = match n {\n-                                Some(n) => n,\n-                                None => {\n-                                    self.sess.span_err(m.span,\n-                                        \"#[link(...)] specified without \\\n-                                         `name = \\\"foo\\\"`\");\n-                                    InternedString::new(\"foo\")\n-                                }\n-                            };\n-                            register_native_lib(self.sess, Some(m.span),\n-                                                n.to_string(), kind);\n-                        }\n-                        None => {}\n-                    }\n-                }\n+        // First, add all of the custom #[link_args] attributes\n+        for m in i.attrs.iter().filter(|a| a.check_name(\"link_args\")) {\n+            if let Some(linkarg) = m.value_str() {\n+                self.sess.cstore.add_used_link_args(&linkarg);\n             }\n-            _ => { }\n+        }\n+\n+        // Next, process all of the #[link(..)]-style arguments\n+        for m in i.attrs.iter().filter(|a| a.check_name(\"link\")) {\n+            let items = match m.meta_item_list() {\n+                Some(item) => item,\n+                None => continue,\n+            };\n+            let kind = items.iter().find(|k| {\n+                k.check_name(\"kind\")\n+            }).and_then(|a| a.value_str());\n+            let kind = match kind.as_ref().map(|s| &s[..]) {\n+                Some(\"static\") => cstore::NativeStatic,\n+                Some(\"dylib\") => cstore::NativeUnknown,\n+                Some(\"framework\") => cstore::NativeFramework,\n+                Some(k) => {\n+                    self.sess.span_err(m.span, &format!(\"unknown kind: `{}`\", k));\n+                    cstore::NativeUnknown\n+                }\n+                None => cstore::NativeUnknown\n+            };\n+            let n = items.iter().find(|n| {\n+                n.check_name(\"name\")\n+            }).and_then(|a| a.value_str());\n+            let n = match n {\n+                Some(n) => n,\n+                None => {\n+                    self.sess.span_err(m.span, \"#[link(...)] specified without \\\n+                                                `name = \\\"foo\\\"`\");\n+                    InternedString::new(\"foo\")\n+                }\n+            };\n+            register_native_lib(self.sess, Some(m.span), n.to_string(), kind);\n+        }\n+\n+        // Finally, process the #[linked_from = \"...\"] attribute\n+        for m in i.attrs.iter().filter(|a| a.check_name(\"linked_from\")) {\n+            let lib_name = match m.value_str() {\n+                Some(name) => name,\n+                None => continue,\n+            };\n+            let list = self.creader.foreign_item_map.entry(lib_name.to_string())\n+                                                    .or_insert(Vec::new());\n+            list.extend(fm.items.iter().map(|it| it.id));\n         }\n     }\n }"}, {"sha": "2ade251018f2645f01eba362901fcc2973761d2f", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=8b3705528ab6a7511928d46c654cc0040272f48d", "patch": "@@ -352,11 +352,11 @@ pub fn get_method_arg_names(cstore: &cstore::CStore, did: ast::DefId)\n     decoder::get_method_arg_names(&*cdata, did.node)\n }\n \n-pub fn get_reachable_extern_fns(cstore: &cstore::CStore, cnum: ast::CrateNum)\n+pub fn get_reachable_ids(cstore: &cstore::CStore, cnum: ast::CrateNum)\n     -> Vec<ast::DefId>\n {\n     let cdata = cstore.get_crate_data(cnum);\n-    decoder::get_reachable_extern_fns(&*cdata)\n+    decoder::get_reachable_ids(&*cdata)\n }\n \n pub fn is_typedef(cstore: &cstore::CStore, did: ast::DefId) -> bool {\n@@ -400,3 +400,9 @@ pub fn is_default_impl(cstore: &cstore::CStore, impl_did: ast::DefId) -> bool {\n     let cdata = cstore.get_crate_data(impl_did.krate);\n     decoder::is_default_impl(&*cdata, impl_did.node)\n }\n+\n+pub fn is_extern_fn(cstore: &cstore::CStore, did: ast::DefId,\n+                    tcx: &ty::ctxt) -> bool {\n+    let cdata = cstore.get_crate_data(did.krate);\n+    decoder::is_extern_fn(&*cdata, did.node, tcx)\n+}"}, {"sha": "ae5e797a0299b591aa408c8fa29280c3da5842b8", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=8b3705528ab6a7511928d46c654cc0040272f48d", "patch": "@@ -20,7 +20,7 @@ pub use self::NativeLibraryKind::*;\n use back::svh::Svh;\n use metadata::{creader, decoder, loader};\n use session::search_paths::PathKind;\n-use util::nodemap::{FnvHashMap, NodeMap};\n+use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n use std::cell::{RefCell, Ref};\n use std::rc::Rc;\n@@ -97,6 +97,7 @@ pub struct CStore {\n     used_crate_sources: RefCell<Vec<CrateSource>>,\n     used_libraries: RefCell<Vec<(String, NativeLibraryKind)>>,\n     used_link_args: RefCell<Vec<String>>,\n+    statically_included_foreign_items: RefCell<NodeSet>,\n     pub intr: Rc<IdentInterner>,\n }\n \n@@ -108,7 +109,8 @@ impl CStore {\n             used_crate_sources: RefCell::new(Vec::new()),\n             used_libraries: RefCell::new(Vec::new()),\n             used_link_args: RefCell::new(Vec::new()),\n-            intr: intr\n+            intr: intr,\n+            statically_included_foreign_items: RefCell::new(NodeSet()),\n         }\n     }\n \n@@ -167,6 +169,7 @@ impl CStore {\n         self.used_crate_sources.borrow_mut().clear();\n         self.used_libraries.borrow_mut().clear();\n         self.used_link_args.borrow_mut().clear();\n+        self.statically_included_foreign_items.borrow_mut().clear();\n     }\n \n     // This method is used when generating the command line to pass through to\n@@ -240,6 +243,14 @@ impl CStore {\n                                      -> Option<ast::CrateNum> {\n         self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n     }\n+\n+    pub fn add_statically_included_foreign_item(&self, id: ast::NodeId) {\n+        self.statically_included_foreign_items.borrow_mut().insert(id);\n+    }\n+\n+    pub fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool {\n+        self.statically_included_foreign_items.borrow().contains(&id)\n+    }\n }\n \n impl crate_metadata {"}, {"sha": "c6c18fa14a3404d63ab2b327d885c3bd5d6e6b57", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8b3705528ab6a7511928d46c654cc0040272f48d", "patch": "@@ -45,6 +45,7 @@ use std::str;\n use rbml::reader;\n use rbml;\n use serialize::Decodable;\n+use syntax::abi;\n use syntax::attr;\n use syntax::parse::token::{IdentInterner, special_idents};\n use syntax::parse::token;\n@@ -1418,10 +1419,10 @@ pub fn get_method_arg_names(cdata: Cmd, id: ast::NodeId) -> Vec<String> {\n     }\n }\n \n-pub fn get_reachable_extern_fns(cdata: Cmd) -> Vec<ast::DefId> {\n+pub fn get_reachable_ids(cdata: Cmd) -> Vec<ast::DefId> {\n     let items = reader::get_doc(rbml::Doc::new(cdata.data()),\n-                                tag_reachable_extern_fns);\n-    reader::tagged_docs(items, tag_reachable_extern_fn_id).map(|doc| {\n+                                tag_reachable_ids);\n+    reader::tagged_docs(items, tag_reachable_id).map(|doc| {\n         ast::DefId {\n             krate: cdata.cnum,\n             node: reader::doc_as_u32(doc),\n@@ -1543,3 +1544,21 @@ pub fn get_imported_filemaps(metadata: &[u8]) -> Vec<codemap::FileMap> {\n         Decodable::decode(&mut decoder).unwrap()\n     }).collect()\n }\n+\n+pub fn is_extern_fn(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt) -> bool {\n+    let root_doc = rbml::Doc::new(cdata.data());\n+    let items = reader::get_doc(root_doc, tag_items);\n+    let item_doc = match maybe_find_item(id, items) {\n+        Some(doc) => doc,\n+        None => return false,\n+    };\n+    if let Fn = item_family(item_doc) {\n+        let ty::TypeScheme { generics, ty } = get_type(cdata, id, tcx);\n+        generics.types.is_empty() && match ty.sty {\n+            ty::TyBareFn(_, fn_ty) => fn_ty.abi != abi::Rust,\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "e0f35b6817b4f1f1429e88d53cc4ebbde4922069", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8b3705528ab6a7511928d46c654cc0040272f48d", "patch": "@@ -1781,9 +1781,8 @@ fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n     // FIXME (#2166): This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n     rbml_w.start_tag(tag_crate_deps);\n-    let r = get_ordered_deps(cstore);\n-    for dep in &r {\n-        encode_crate_dep(rbml_w, (*dep).clone());\n+    for dep in &get_ordered_deps(cstore) {\n+        encode_crate_dep(rbml_w, dep);\n     }\n     rbml_w.end_tag();\n }\n@@ -1971,24 +1970,22 @@ fn encode_misc_info(ecx: &EncodeContext,\n     rbml_w.end_tag();\n }\n \n-fn encode_reachable_extern_fns(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n-    rbml_w.start_tag(tag_reachable_extern_fns);\n-\n+// Encodes all reachable symbols in this crate into the metadata.\n+//\n+// This pass is seeded off the reachability list calculated in the\n+// middle::reachable module but filters out items that either don't have a\n+// symbol associated with them (they weren't translated) or if they're an FFI\n+// definition (as that's not defined in this crate).\n+fn encode_reachable(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n+    rbml_w.start_tag(tag_reachable_ids);\n     for id in ecx.reachable {\n-        if let Some(ast_map::NodeItem(i)) = ecx.tcx.map.find(*id) {\n-            if let ast::ItemFn(_, _, _, abi, ref generics, _) = i.node {\n-                if abi != abi::Rust && !generics.is_type_parameterized() {\n-                    rbml_w.wr_tagged_u32(tag_reachable_extern_fn_id, *id);\n-                }\n-            }\n-        }\n+        rbml_w.wr_tagged_u32(tag_reachable_id, *id);\n     }\n-\n     rbml_w.end_tag();\n }\n \n fn encode_crate_dep(rbml_w: &mut Encoder,\n-                    dep: decoder::CrateDep) {\n+                    dep: &decoder::CrateDep) {\n     rbml_w.start_tag(tag_crate_dep);\n     rbml_w.wr_tagged_str(tag_crate_dep_crate_name, &dep.name);\n     rbml_w.wr_tagged_str(tag_crate_dep_hash, dep.hash.as_str());\n@@ -2170,7 +2167,7 @@ fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n     // Encode miscellaneous info.\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n     encode_misc_info(&ecx, krate, &mut rbml_w);\n-    encode_reachable_extern_fns(&ecx, &mut rbml_w);\n+    encode_reachable(&ecx, &mut rbml_w);\n     stats.misc_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode and index the items."}, {"sha": "e0d585d6f5b52096378b7d9880f33d0426b2fd90", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=8b3705528ab6a7511928d46c654cc0040272f48d", "patch": "@@ -31,6 +31,7 @@\n #![feature(link_args)]\n #![feature(staged_api)]\n #![feature(vec_push_all)]\n+#![cfg_attr(not(stage0), feature(linked_from))]\n \n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n@@ -598,6 +599,7 @@ pub mod debuginfo {\n // automatically updated whenever LLVM is updated to include an up-to-date\n // set of the libraries we need to link to LLVM for.\n #[link(name = \"rustllvm\", kind = \"static\")]\n+#[cfg_attr(not(stage0), linked_from = \"rustllvm\")] // not quite true but good enough\n extern {\n     /* Create and destroy contexts. */\n     pub fn LLVMContextCreate() -> ContextRef;"}, {"sha": "46c7b80670f3c140a81d9fcc7449bf670a08ec4d", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=8b3705528ab6a7511928d46c654cc0040272f48d", "patch": "@@ -902,6 +902,12 @@ fn link_args(cmd: &mut Linker,\n     }\n     cmd.output_filename(out_filename);\n \n+    // If we're building a dynamic library then some platforms need to make sure\n+    // that all symbols are exported correctly from the dynamic library.\n+    if dylib {\n+        cmd.export_symbols(sess, trans, tmpdir);\n+    }\n+\n     // When linking a dynamic library, we put the metadata into a section of the\n     // executable. This metadata is in a separate object file from the main\n     // object file, so we link that in here."}, {"sha": "8bd86a3a34a1927fbb09e05421efe18574fe56b8", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 72, "deletions": 2, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=8b3705528ab6a7511928d46c654cc0040272f48d", "patch": "@@ -9,14 +9,21 @@\n // except according to those terms.\n \n use std::ffi::OsString;\n+use std::fs::{self, File};\n+use std::io::{self, BufWriter};\n+use std::io::prelude::*;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n-use std::fs;\n \n use back::archive;\n+use metadata::csearch;\n+use metadata::cstore;\n use session::Session;\n-use session::config;\n use session::config::DebugInfoLevel::{NoDebugInfo, LimitedDebugInfo, FullDebugInfo};\n+use session::config::CrateTypeDylib;\n+use session::config;\n+use syntax::ast;\n+use trans::CrateTranslation;\n \n /// Linker abstraction used by back::link to build up the command to invoke a\n /// linker.\n@@ -48,6 +55,8 @@ pub trait Linker {\n     fn hint_dynamic(&mut self);\n     fn whole_archives(&mut self);\n     fn no_whole_archives(&mut self);\n+    fn export_symbols(&mut self, sess: &Session, trans: &CrateTranslation,\n+                      tmpdir: &Path);\n }\n \n pub struct GnuLinker<'a> {\n@@ -192,6 +201,10 @@ impl<'a> Linker for GnuLinker<'a> {\n         if !self.takes_hints() { return }\n         self.cmd.arg(\"-Wl,-Bdynamic\");\n     }\n+\n+    fn export_symbols(&mut self, _: &Session, _: &CrateTranslation, _: &Path) {\n+        // noop, visibility in object files takes care of this\n+    }\n }\n \n pub struct MsvcLinker<'a> {\n@@ -301,4 +314,61 @@ impl<'a> Linker for MsvcLinker<'a> {\n     // we do on Unix platforms.\n     fn hint_static(&mut self) {}\n     fn hint_dynamic(&mut self) {}\n+\n+    // Currently the compiler doesn't use `dllexport` (an LLVM attribute) to\n+    // export symbols from a dynamic library. When building a dynamic library,\n+    // however, we're going to want some symbols exported, so this function\n+    // generates a DEF file which lists all the symbols.\n+    //\n+    // The linker will read this `*.def` file and export all the symbols from\n+    // the dynamic library. Note that this is not as simple as just exporting\n+    // all the symbols in the current crate (as specified by `trans.reachable`)\n+    // but rather we also need to possibly export the symbols of upstream\n+    // crates. Upstream rlibs may be linked statically to this dynamic library,\n+    // in which case they may continue to transitively be used and hence need\n+    // their symbols exported.\n+    fn export_symbols(&mut self, sess: &Session, trans: &CrateTranslation,\n+                      tmpdir: &Path) {\n+        let path = tmpdir.join(\"lib.def\");\n+        let res = (|| -> io::Result<()> {\n+            let mut f = BufWriter::new(try!(File::create(&path)));\n+\n+            // Start off with the standard module name header and then go\n+            // straight to exports.\n+            try!(writeln!(f, \"LIBRARY\"));\n+            try!(writeln!(f, \"EXPORTS\"));\n+\n+            // Write out all our local symbols\n+            for sym in trans.reachable.iter() {\n+                try!(writeln!(f, \"  {}\", sym));\n+            }\n+\n+            // Take a look at how all upstream crates are linked into this\n+            // dynamic library. For all statically linked libraries we take all\n+            // their reachable symbols and emit them as well.\n+            let cstore = &sess.cstore;\n+            let symbols = trans.crate_formats[&CrateTypeDylib].iter();\n+            let symbols = symbols.enumerate().filter_map(|(i, f)| {\n+                if let Some(cstore::RequireStatic) = *f {\n+                    Some((i + 1) as ast::CrateNum)\n+                } else {\n+                    None\n+                }\n+            }).flat_map(|cnum| {\n+                csearch::get_reachable_ids(cstore, cnum)\n+            }).map(|did| {\n+                csearch::get_symbol(cstore, did)\n+            });\n+            for symbol in symbols {\n+                try!(writeln!(f, \"  {}\", symbol));\n+            }\n+            Ok(())\n+        })();\n+        if let Err(e) = res {\n+            sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n+        }\n+        let mut arg = OsString::from(\"/DEF:\");\n+        arg.push(path);\n+        self.cmd.arg(&arg);\n+    }\n }"}, {"sha": "716b12908172413cc91793545a449b3281917703", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 72, "deletions": 60, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=8b3705528ab6a7511928d46c654cc0040272f48d", "patch": "@@ -81,7 +81,7 @@ use trans::type_of::*;\n use trans::value::Value;\n use util::common::indenter;\n use util::sha2::Sha256;\n-use util::nodemap::NodeMap;\n+use util::nodemap::{NodeMap, NodeSet};\n \n use arena::TypedArena;\n use libc::c_uint;\n@@ -2007,17 +2007,11 @@ pub fn update_linkage(ccx: &CrateContext,\n     match id {\n         Some(id) if ccx.reachable().contains(&id) => {\n             llvm::SetLinkage(llval, llvm::ExternalLinkage);\n-            if ccx.use_dll_storage_attrs() {\n-                llvm::SetDLLStorageClass(llval, llvm::DLLExportStorageClass);\n-            }\n         },\n         _ => {\n             // `id` does not refer to an item in `ccx.reachable`.\n             if ccx.sess().opts.cg.codegen_units > 1 {\n                 llvm::SetLinkage(llval, llvm::ExternalLinkage);\n-                if ccx.use_dll_storage_attrs() {\n-                    llvm::SetDLLStorageClass(llval, llvm::DLLExportStorageClass);\n-                }\n             } else {\n                 llvm::SetLinkage(llval, llvm::InternalLinkage);\n             }\n@@ -2158,28 +2152,12 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n                                    ty::FnConverging(ccx.tcx().mk_nil())).unwrap_or_else(||{\n         ccx.sess().span_fatal(sp, &format!(\"symbol `{}` is already defined\", sym));\n     });\n-    finish_register_fn(ccx, sym, node_id, llfn);\n+    finish_register_fn(ccx, sym, node_id);\n     llfn\n }\n \n-fn finish_register_fn(ccx: &CrateContext, sym: String, node_id: ast::NodeId,\n-                      llfn: ValueRef) {\n+fn finish_register_fn(ccx: &CrateContext, sym: String, node_id: ast::NodeId) {\n     ccx.item_symbols().borrow_mut().insert(node_id, sym);\n-\n-    // The eh_personality function need to be externally linkable.\n-    let def = ast_util::local_def(node_id);\n-    if ccx.tcx().lang_items.eh_personality() == Some(def) {\n-        llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n-        if ccx.use_dll_storage_attrs() {\n-            llvm::SetDLLStorageClass(llfn, llvm::DLLExportStorageClass);\n-        }\n-    }\n-    if ccx.tcx().lang_items.eh_unwind_resume() == Some(def) {\n-        llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n-        if ccx.use_dll_storage_attrs() {\n-            llvm::SetDLLStorageClass(llfn, llvm::DLLExportStorageClass);\n-        }\n-    }\n }\n \n fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -2201,7 +2179,7 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let llfn = declare::define_rust_fn(ccx, &sym[..], node_type).unwrap_or_else(||{\n         ccx.sess().span_fatal(sp, &format!(\"symbol `{}` is already defined\", sym));\n     });\n-    finish_register_fn(ccx, sym, node_id, llfn);\n+    finish_register_fn(ccx, sym, node_id);\n     llfn\n }\n \n@@ -2215,8 +2193,8 @@ pub fn is_entry_fn(sess: &Session, node_id: ast::NodeId) -> bool {\n /// Create the `main` function which will initialise the rust runtime and call users\u2019 main\n /// function.\n pub fn create_entry_wrapper(ccx: &CrateContext,\n-                           sp: Span,\n-                           main_llfn: ValueRef) {\n+                            sp: Span,\n+                            main_llfn: ValueRef) {\n     let et = ccx.sess().entry_type.get().unwrap();\n     match et {\n         config::EntryMain => {\n@@ -2242,12 +2220,6 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n             panic!();\n         });\n \n-        // FIXME: #16581: Marking a symbol in the executable with `dllexport`\n-        // linkage forces MinGW's linker to output a `.reloc` section for ASLR\n-        if ccx.sess().target.target.options.is_like_windows {\n-            llvm::SetDLLStorageClass(llfn, llvm::DLLExportStorageClass);\n-        }\n-\n         let llbb = unsafe {\n             llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llfn,\n                                                 \"top\\0\".as_ptr() as *const _)\n@@ -2524,7 +2496,8 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n }\n \n pub fn crate_ctxt_to_encode_parms<'a, 'tcx>(cx: &'a SharedCrateContext<'a, 'tcx>,\n-                                            ie: encoder::EncodeInlinedItem<'a>)\n+                                            ie: encoder::EncodeInlinedItem<'a>,\n+                                            reachable: &'a NodeSet)\n                                             -> encoder::EncodeParams<'a, 'tcx> {\n     encoder::EncodeParams {\n         diag: cx.sess().diagnostic(),\n@@ -2534,11 +2507,12 @@ pub fn crate_ctxt_to_encode_parms<'a, 'tcx>(cx: &'a SharedCrateContext<'a, 'tcx>\n         link_meta: cx.link_meta(),\n         cstore: &cx.sess().cstore,\n         encode_inlined_item: ie,\n-        reachable: cx.reachable(),\n+        reachable: reachable,\n     }\n }\n \n-pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n+pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate,\n+                      reachable: &NodeSet) -> Vec<u8> {\n     use flate;\n \n     let any_library = cx.sess().crate_types.borrow().iter().any(|ty| {\n@@ -2551,7 +2525,8 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n     let encode_inlined_item: encoder::EncodeInlinedItem =\n         Box::new(|ecx, rbml_w, ii| astencode::encode_inlined_item(ecx, rbml_w, ii));\n \n-    let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n+    let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item,\n+                                                  reachable);\n     let metadata = encoder::encode_metadata(encode_parms, krate);\n     let mut compressed = encoder::metadata_encoding_version.to_vec();\n     compressed.push_all(&flate::deflate_bytes(&metadata));\n@@ -2576,7 +2551,7 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n \n /// Find any symbols that are defined in one compilation unit, but not declared\n /// in any other compilation unit.  Give these symbols internal linkage.\n-fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n+fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<&str>) {\n     unsafe {\n         let mut declared = HashSet::new();\n \n@@ -2659,6 +2634,41 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n     }\n }\n \n+/// The context provided lists a set of reachable ids as calculated by\n+/// middle::reachable, but this contains far more ids and symbols than we're\n+/// actually exposing from the object file. This function will filter the set in\n+/// the context to the set of ids which correspond to symbols that are exposed\n+/// from the object file being generated.\n+///\n+/// This list is later used by linkers to determine the set of symbols needed to\n+/// be exposed from a dynamic library and it's also encoded into the metadata.\n+pub fn filter_reachable_ids(ccx: &SharedCrateContext) -> NodeSet {\n+    ccx.reachable().iter().map(|x| *x).filter(|id| {\n+        // First, only worry about nodes which have a symbol name\n+        ccx.item_symbols().borrow().contains_key(id)\n+    }).filter(|&id| {\n+        // Next, we want to ignore some FFI functions that are not exposed from\n+        // this crate. Reachable FFI functions can be lumped into two\n+        // categories:\n+        //\n+        // 1. Those that are included statically via a static library\n+        // 2. Those included otherwise (e.g. dynamically or via a framework)\n+        //\n+        // Although our LLVM module is not literally emitting code for the\n+        // statically included symbols, it's an export of our library which\n+        // needs to be passed on to the linker and encoded in the metadata.\n+        //\n+        // As a result, if this id is an FFI item (foreign item) then we only\n+        // let it through if it's included statically.\n+        match ccx.tcx().map.get(id) {\n+            ast_map::NodeForeignItem(..) => {\n+                ccx.sess().cstore.is_statically_included_foreign_item(id)\n+            }\n+            _ => true,\n+        }\n+    }).collect()\n+}\n+\n pub fn trans_crate(tcx: &ty::ctxt, analysis: ty::CrateAnalysis) -> CrateTranslation {\n     let ty::CrateAnalysis { export_map, reachable, name, .. } = analysis;\n     let krate = tcx.map.krate();\n@@ -2734,8 +2744,10 @@ pub fn trans_crate(tcx: &ty::ctxt, analysis: ty::CrateAnalysis) -> CrateTranslat\n         }\n     }\n \n+    let reachable_symbol_ids = filter_reachable_ids(&shared_ccx);\n+\n     // Translate the metadata.\n-    let metadata = write_metadata(&shared_ccx, krate);\n+    let metadata = write_metadata(&shared_ccx, krate, &reachable_symbol_ids);\n \n     if shared_ccx.sess().trans_stats() {\n         let stats = shared_ccx.stats();\n@@ -2770,31 +2782,31 @@ pub fn trans_crate(tcx: &ty::ctxt, analysis: ty::CrateAnalysis) -> CrateTranslat\n         .map(|ccx| ModuleTranslation { llcx: ccx.llcx(), llmod: ccx.llmod() })\n         .collect();\n \n-    let mut reachable: Vec<String> = shared_ccx.reachable().iter().filter_map(|id| {\n-        shared_ccx.item_symbols().borrow().get(id).map(|s| s.to_string())\n-    }).collect();\n+    let sess = shared_ccx.sess();\n+    let mut reachable_symbols = reachable_symbol_ids.iter().map(|id| {\n+        shared_ccx.item_symbols().borrow()[id].to_string()\n+    }).collect::<Vec<_>>();\n+    if sess.entry_fn.borrow().is_some() {\n+        reachable_symbols.push(\"main\".to_string());\n+    }\n \n     // For the purposes of LTO, we add to the reachable set all of the upstream\n     // reachable extern fns. These functions are all part of the public ABI of\n     // the final product, so LTO needs to preserve them.\n-    shared_ccx.sess().cstore.iter_crate_data(|cnum, _| {\n-        let syms = csearch::get_reachable_extern_fns(&shared_ccx.sess().cstore, cnum);\n-        reachable.extend(syms.into_iter().map(|did| {\n-            csearch::get_symbol(&shared_ccx.sess().cstore, did)\n-        }));\n-    });\n-\n-    // Make sure that some other crucial symbols are not eliminated from the\n-    // module, including the main function.\n-    reachable.push(\"main\".to_string());\n-\n-    // referenced from .eh_frame section on some platforms\n-    reachable.push(\"rust_eh_personality\".to_string());\n-    // referenced from rt/rust_try.ll\n-    reachable.push(\"rust_eh_personality_catch\".to_string());\n+    if sess.lto() {\n+        sess.cstore.iter_crate_data(|cnum, _| {\n+            let syms = csearch::get_reachable_ids(&sess.cstore, cnum);\n+            reachable_symbols.extend(syms.into_iter().filter(|did| {\n+                csearch::is_extern_fn(&sess.cstore, *did, shared_ccx.tcx())\n+            }).map(|did| {\n+                csearch::get_symbol(&sess.cstore, did)\n+            }));\n+        });\n+    }\n \n     if codegen_units > 1 {\n-        internalize_symbols(&shared_ccx, &reachable.iter().cloned().collect());\n+        internalize_symbols(&shared_ccx,\n+                            &reachable_symbols.iter().map(|x| &x[..]).collect());\n     }\n \n     let metadata_module = ModuleTranslation {\n@@ -2809,7 +2821,7 @@ pub fn trans_crate(tcx: &ty::ctxt, analysis: ty::CrateAnalysis) -> CrateTranslat\n         metadata_module: metadata_module,\n         link: link_meta,\n         metadata: metadata,\n-        reachable: reachable,\n+        reachable: reachable_symbols,\n         crate_formats: formats,\n         no_builtins: no_builtins,\n     }"}, {"sha": "87149ff81da78ef6a3db1836849e2a7bb681d83e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8b3705528ab6a7511928d46c654cc0040272f48d", "patch": "@@ -85,6 +85,7 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n     (\"on_unimplemented\", \"1.0.0\", Active),\n     (\"simd_ffi\", \"1.0.0\", Active),\n     (\"allocator\", \"1.0.0\", Active),\n+    (\"linked_from\", \"1.3.0\", Active),\n \n     (\"if_let\", \"1.0.0\", Accepted),\n     (\"while_let\", \"1.0.0\", Accepted),\n@@ -269,6 +270,10 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n                           \"the `#[fundamental]` attribute \\\n                            is an experimental feature\")),\n \n+    (\"linked_from\", Gated(\"linked_from\",\n+                          \"the `#[linked_from]` attribute \\\n+                           is an experimental feature\")),\n+\n     // FIXME: #14408 whitelist docs since rustdoc looks at them\n     (\"doc\", Whitelisted),\n "}, {"sha": "1ec29501b763cddd8a1c1e2b24bc22a5785b61cc", "filename": "src/test/auxiliary/issue-25185-1.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Ftest%2Fauxiliary%2Fissue-25185-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Ftest%2Fauxiliary%2Fissue-25185-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-25185-1.rs?ref=8b3705528ab6a7511928d46c654cc0040272f48d", "patch": "@@ -10,9 +10,12 @@\n \n // no-prefer-dynamic\n \n+#![feature(linked_from)]\n+\n #![crate_type = \"rlib\"]\n \n #[link(name = \"rust_test_helpers\", kind = \"static\")]\n+#[linked_from = \"rust_test_helpers\"]\n extern {\n     pub fn rust_dbg_extern_identity_u32(u: u32) -> u32;\n }"}, {"sha": "8705684111eb46eb276401b9a22170e4a3a9a67e", "filename": "src/test/compile-fail/feature-gate-linked-from.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Ftest%2Fcompile-fail%2Ffeature-gate-linked-from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Ftest%2Fcompile-fail%2Ffeature-gate-linked-from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-linked-from.rs?ref=8b3705528ab6a7511928d46c654cc0040272f48d", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[linked_from = \"foo\"] //~ ERROR experimental feature\n+extern {\n+    fn foo();\n+}\n+\n+fn main() {}"}, {"sha": "6351cc76a2e4c9f3e5cdc25f6d66705228cb15c1", "filename": "src/test/run-pass/variadic-ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3705528ab6a7511928d46c654cc0040272f48d/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs?ref=8b3705528ab6a7511928d46c654cc0040272f48d", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-msvc -- sprintf isn't a symbol in msvcrt? maybe a #define?\n \n #![feature(libc, std_misc)]\n "}]}