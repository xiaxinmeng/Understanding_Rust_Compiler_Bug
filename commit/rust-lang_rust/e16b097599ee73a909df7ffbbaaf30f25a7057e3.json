{"sha": "e16b097599ee73a909df7ffbbaaf30f25a7057e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNmIwOTc1OTllZTczYTkwOWRmN2ZmYmJhYWYzMGYyNWE3MDU3ZTM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-05-18T22:43:05Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-19T18:40:16Z"}, "message": "Rewrite tstate.annotate to use walk instead of fold\n\nand various other tidying in typestate", "tree": {"sha": "cd0dbe8f37a302a5f63be09ac62387807c0be12a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd0dbe8f37a302a5f63be09ac62387807c0be12a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e16b097599ee73a909df7ffbbaaf30f25a7057e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e16b097599ee73a909df7ffbbaaf30f25a7057e3", "html_url": "https://github.com/rust-lang/rust/commit/e16b097599ee73a909df7ffbbaaf30f25a7057e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e16b097599ee73a909df7ffbbaaf30f25a7057e3/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc83c846623c2d9c0ad31ebe769def34d8f1579f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc83c846623c2d9c0ad31ebe769def34d8f1579f", "html_url": "https://github.com/rust-lang/rust/commit/dc83c846623c2d9c0ad31ebe769def34d8f1579f"}], "stats": {"total": 1505, "additions": 621, "deletions": 884}, "files": [{"sha": "a62829f3a108215a3e363d39a2fb1dda4c0708de", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e16b097599ee73a909df7ffbbaaf30f25a7057e3/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16b097599ee73a909df7ffbbaaf30f25a7057e3/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=e16b097599ee73a909df7ffbbaaf30f25a7057e3", "patch": "@@ -20,13 +20,13 @@ type poststate = bitv::t; /* 1 means \"this variable is definitely initialized\"\n                             initialized\" */\n \n /* named thus so as not to confuse with prestate and poststate */\n-type pre_and_post = rec(precond precondition, postcond postcondition);\n+type pre_and_post = @rec(precond precondition, postcond postcondition);\n /* FIXME: once it's implemented: */\n //  : ((*.precondition).nbits == (*.postcondition).nbits);\n \n type pre_and_post_state = rec(prestate prestate, poststate poststate);\n \n-type ts_ann = rec(pre_and_post conditions, pre_and_post_state states);\n+type ts_ann = @rec(pre_and_post conditions, pre_and_post_state states);\n \n fn true_precond(uint num_vars) -> precond {\n   be bitv::create(num_vars, false);\n@@ -49,18 +49,18 @@ fn false_postcond(uint num_vars) -> postcond {\n }\n \n fn empty_pre_post(uint num_vars) -> pre_and_post {\n-  ret(rec(precondition=empty_prestate(num_vars),\n-          postcondition=empty_poststate(num_vars)));\n+  ret(@rec(precondition=empty_prestate(num_vars),\n+           postcondition=empty_poststate(num_vars)));\n }\n \n fn empty_states(uint num_vars) -> pre_and_post_state {\n   ret(rec(prestate=true_precond(num_vars),\n-           poststate=true_postcond(num_vars)));\n+          poststate=true_postcond(num_vars)));\n }\n \n fn empty_ann(uint num_vars) -> ts_ann {\n-  ret(rec(conditions=empty_pre_post(num_vars),\n-          states=empty_states(num_vars)));\n+  ret(@rec(conditions=empty_pre_post(num_vars),\n+           states=empty_states(num_vars)));\n }\n \n fn get_pre(&pre_and_post p) -> precond {\n@@ -111,25 +111,25 @@ fn set_in_poststate(uint i, &pre_and_post_state s) -> bool {\n \n // Sets all the bits in a's precondition to equal the\n // corresponding bit in p's precondition.\n-fn set_precondition(@ts_ann a, &precond p) -> () {\n+fn set_precondition(ts_ann a, &precond p) -> () {\n   bitv::copy(a.conditions.precondition, p);\n }\n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n-fn set_postcondition(@ts_ann a, &postcond p) -> () {\n+fn set_postcondition(ts_ann a, &postcond p) -> () {\n   bitv::copy(a.conditions.postcondition, p);\n }\n \n // Sets all the bits in a's prestate to equal the\n // corresponding bit in p's prestate.\n-fn set_prestate(@ts_ann a, &prestate p) -> bool {\n+fn set_prestate(ts_ann a, &prestate p) -> bool {\n   ret bitv::copy(a.states.prestate, p);\n }\n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n-fn set_poststate(@ts_ann a, &poststate p) -> bool {\n+fn set_poststate(ts_ann a, &poststate p) -> bool {\n   ret bitv::copy(a.states.poststate, p);\n }\n \n@@ -150,6 +150,16 @@ fn relax_prestate(uint i, &prestate p) -> bool {\n     ret was_set;\n }\n \n+// Clears all the bits in p\n+fn clear(&precond p) -> () {\n+    bitv::clear(p);\n+}\n+\n+// Sets all the bits in p\n+fn set(&precond p) -> () {\n+    bitv::set_all(p);\n+}\n+\n fn ann_precond(&ts_ann a) -> precond {\n   ret a.conditions.precondition;\n }\n@@ -163,8 +173,8 @@ fn ann_poststate(&ts_ann a) -> poststate {\n }\n \n fn pp_clone(&pre_and_post p) -> pre_and_post {\n-  ret rec(precondition=clone(p.precondition),\n-          postcondition=clone(p.postcondition));\n+  ret @rec(precondition=clone(p.precondition),\n+           postcondition=clone(p.postcondition));\n }\n \n fn clone(prestate p) -> prestate {"}, {"sha": "f126930386441d3080e1403ea7034f386cbe3632", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 69, "deletions": 383, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/e16b097599ee73a909df7ffbbaaf30f25a7057e3/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16b097599ee73a909df7ffbbaaf30f25a7057e3/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=e16b097599ee73a909df7ffbbaaf30f25a7057e3", "patch": "@@ -4,7 +4,6 @@ import std::option::some;\n import std::option::none;\n \n import front::ast;\n-\n import front::ast::ident;\n import front::ast::def_id;\n import front::ast::ann;\n@@ -76,417 +75,104 @@ import front::ast::method;\n \n import middle::fold;\n import middle::fold::respan;\n-import middle::fold::new_identity_fold;\n-import middle::fold::fold_crate;\n-import middle::fold::fold_item;\n-import middle::fold::fold_method;\n+import middle::ty::expr_ann;\n \n import util::common::uistr;\n import util::common::span;\n import util::common::new_str_hash;\n+import util::common::log_expr_err;\n+import util::common::log_block_err;\n+import util::common::log_item_err;\n+import util::common::log_stmt_err;\n+import util::common::log_expr;\n+import util::common::log_block;\n+import util::common::log_stmt;\n \n import middle::tstate::aux::fn_info;\n import middle::tstate::aux::fn_info_map;\n import middle::tstate::aux::num_locals;\n-import middle::tstate::aux::init_ann;\n-import middle::tstate::aux::init_blank_ann;\n import middle::tstate::aux::get_fn_info;\n+import middle::tstate::aux::crate_ctxt;\n+import middle::tstate::ann::empty_ann;\n \n-fn item_fn_anns(&fn_info_map fm, &span sp, ident i, &_fn f,\n-                vec[ty_param] ty_params, def_id id, ann a) -> @item {\n-\n-    assert (fm.contains_key(id));\n-    auto f_info = fm.get(id);\n-\n-    log(i + \" has \" + uistr(num_locals(f_info)) + \" local vars\");\n-\n-    auto fld0 = new_identity_fold[fn_info]();\n-\n-    fld0 = @rec(fold_ann = bind init_ann(_,_) \n-                    with *fld0);\n-\n-    ret fold_item[fn_info]\n-           (f_info, fld0, @respan(sp, item_fn(i, f, ty_params, id, a))); \n-}\n-\n-/* FIXME: rewrite this with walk instead of fold */\n-\n-/* This is painstakingly written as an explicit recursion b/c the\n-   standard ast.fold doesn't traverse in the correct order:\n-   consider\n-   fn foo() {\n-      fn bar() {\n-        auto x = 5;\n-        log(x);\n-      }\n-   }\n-   With fold, first bar() would be processed and its subexps would\n-   correctly be annotated with length-1 bit vectors.\n-   But then, the process would be repeated with (fn bar()...) as\n-   a subexp of foo, which has 0 local variables -- so then\n-   the body of bar() would be incorrectly annotated with length-0 bit\n-   vectors. */\n-fn annotate_exprs(&fn_info_map fm, &vec[@expr] es) -> vec[@expr] {\n-    fn one(fn_info_map fm, &@expr e) -> @expr {\n-        ret annotate_expr(fm, e);\n-    }\n-    auto f = bind one(fm,_);\n-    ret vec::map[@expr, @expr](f, es);\n-}\n-fn annotate_elts(&fn_info_map fm, &vec[elt] es) -> vec[elt] {\n-    fn one(fn_info_map fm, &elt e) -> elt {\n-        ret rec(mut=e.mut,\n-                expr=annotate_expr(fm, e.expr));\n-    }\n-    auto f = bind one(fm,_);\n-    ret vec::map[elt, elt](f, es);\n-}\n-fn annotate_fields(&fn_info_map fm, &vec[field] fs) -> vec[field] {\n-    fn one(fn_info_map fm, &field f) -> field {\n-        ret rec(mut=f.mut,\n-                 ident=f.ident,\n-                 expr=annotate_expr(fm, f.expr));\n-    }\n-    auto f = bind one(fm,_);\n-    ret vec::map[field, field](f, fs);\n+fn collect_ids_expr(&@expr e, @vec[uint] res) -> () {\n+    vec::push(*res, (expr_ann(e)).id);\n }\n-fn annotate_option_exp(&fn_info_map fm, &option::t[@expr] o)\n-  -> option::t[@expr] {\n-    fn one(fn_info_map fm, &@expr e) -> @expr {\n-        ret annotate_expr(fm, e);\n-    }\n-    auto f = bind one(fm,_);\n-    ret option::map[@expr, @expr](f, o);\n-}\n-fn annotate_option_exprs(&fn_info_map fm, &vec[option::t[@expr]] es)\n-  -> vec[option::t[@expr]] {\n-    fn one(fn_info_map fm, &option::t[@expr] o) -> option::t[@expr] {\n-        ret annotate_option_exp(fm, o);\n-    }\n-    auto f = bind one(fm,_);\n-    ret vec::map[option::t[@expr], option::t[@expr]](f, es);\n-}\n-fn annotate_decl(&fn_info_map fm, &@decl d) -> @decl {\n-    auto d1 = d.node;\n-    alt (d.node) {\n-        case (decl_local(?l)) {\n-            alt(l.init) {\n-                case (some[initializer](?init)) {\n-                    let option::t[initializer] an_i =\n-                        some[initializer]\n-                          (rec(expr=annotate_expr(fm, init.expr)\n-                                 with init));\n-                    let @local new_l = @rec(init=an_i with *l);\n-                    d1 = decl_local(new_l);\n-                }\n-                case (_) { /* do nothing */ }\n-            }\n-        }\n-        case (decl_item(?item)) {\n-            d1 = decl_item(annotate_item(fm, item));\n-        }\n-    }\n-    ret @respan(d.span, d1);\n+fn collect_ids_block(&block b, @vec[uint] res) -> () {\n+    vec::push(*res, b.node.a.id);\n }\n-fn annotate_alts(&fn_info_map fm, &vec[arm] alts) -> vec[arm] {\n-    fn one(fn_info_map fm, &arm a) -> arm {\n-        ret rec(pat=a.pat,\n-                 block=annotate_block(fm, a.block));\n-    }\n-    auto f = bind one(fm,_);\n-    ret vec::map[arm, arm](f, alts);\n \n-}\n-fn annotate_expr(&fn_info_map fm, &@expr e) -> @expr {\n-    auto e1 = e.node;\n-    alt (e.node) {\n-        case (expr_vec(?es, ?m, ?a)) {\n-            e1 = expr_vec(annotate_exprs(fm, es), m, a);\n-        }\n-        case (expr_tup(?es, ?a)) {\n-            e1 = expr_tup(annotate_elts(fm, es), a);\n-        }\n-        case (expr_rec(?fs, ?maybe_e, ?a)) {\n-            e1 = expr_rec(annotate_fields(fm, fs),\n-                          annotate_option_exp(fm, maybe_e), a);\n-        }\n-        case (expr_call(?e, ?es, ?a)) {\n-            e1 = expr_call(annotate_expr(fm, e),\n-                          annotate_exprs(fm, es), a);\n-        }\n-        case (expr_self_method(_,_)) {\n-            // no change\n-        }\n-        case (expr_bind(?e, ?maybe_es, ?a)) {\n-            e1 = expr_bind(annotate_expr(fm, e),\n-                           annotate_option_exprs(fm, maybe_es),\n-                           a);\n-        }\n-        case (expr_spawn(?s, ?maybe_s, ?e, ?es, ?a)) {\n-            e1 = expr_spawn(s, maybe_s, annotate_expr(fm, e),\n-                            annotate_exprs(fm, es), a);\n-        }\n-        case (expr_binary(?bop, ?w, ?x, ?a)) {\n-            e1 = expr_binary(bop, annotate_expr(fm, w),\n-                             annotate_expr(fm, x), a);\n-        }\n-        case (expr_unary(?uop, ?w, ?a)) {\n-            e1 = expr_unary(uop, annotate_expr(fm, w), a);\n-        }\n-        case (expr_lit(_,_)) {\n-            /* no change */\n-        }\n-        case (expr_cast(?e,?t,?a)) {\n-            e1 = expr_cast(annotate_expr(fm, e), t, a);\n-        }\n-        case (expr_if(?e, ?b, ?maybe_e, ?a)) {\n-            e1 = expr_if(annotate_expr(fm, e),\n-                         annotate_block(fm, b),\n-                         annotate_option_exp(fm, maybe_e), a);\n-        }\n-        case (expr_while(?e, ?b, ?a)) {\n-            e1 = expr_while(annotate_expr(fm, e),\n-                            annotate_block(fm, b), a);\n-        }\n-        case (expr_for(?d, ?e, ?b, ?a)) {\n-            e1 = expr_for(annotate_decl(fm, d),\n-                          annotate_expr(fm, e),\n-                          annotate_block(fm, b), a);\n-        }\n-        case (expr_for_each(?d, ?e, ?b, ?a)) {\n-            e1 = expr_for_each(annotate_decl(fm, d),\n-                          annotate_expr(fm, e),\n-                          annotate_block(fm, b), a);\n-        }\n-        case (expr_do_while(?b, ?e, ?a)) {\n-            e1 = expr_do_while(annotate_block(fm, b),\n-                               annotate_expr(fm, e), a);\n-        }\n-        case (expr_alt(?e, ?alts, ?a)) {\n-            e1 = expr_alt(annotate_expr(fm, e),\n-                          annotate_alts(fm, alts), a);\n-        }\n-        case (expr_block(?b, ?a)) {\n-            e1 = expr_block(annotate_block(fm, b), a);\n-        }\n-        case (expr_assign(?l, ?r, ?a)) {\n-            e1 = expr_assign(annotate_expr(fm, l), annotate_expr(fm, r), a);\n-        }\n-        case (expr_assign_op(?bop, ?l, ?r, ?a)) {\n-            e1 = expr_assign_op(bop,\n-               annotate_expr(fm, l), annotate_expr(fm, r), a);\n-        }\n-        case (expr_send(?l, ?r, ?a)) {\n-            e1 = expr_send(annotate_expr(fm, l),\n-                           annotate_expr(fm, r), a);\n-        }\n-        case (expr_recv(?l, ?r, ?a)) {\n-           e1 = expr_recv(annotate_expr(fm, l),\n-                           annotate_expr(fm, r), a);\n-        }\n-        case (expr_field(?e, ?i, ?a)) {\n-            e1 = expr_field(annotate_expr(fm, e),\n-                            i, a);\n-        }\n-        case (expr_index(?e, ?sub, ?a)) {\n-            e1 = expr_index(annotate_expr(fm, e),\n-                            annotate_expr(fm, sub), a);\n-        }\n-        case (expr_path(_,_)) {\n-            /* no change */\n-        }\n-        case (expr_ext(?p, ?es, ?s_opt, ?e, ?a)) {\n-            e1 = expr_ext(p, annotate_exprs(fm, es),\n-                          s_opt,\n-                          annotate_expr(fm, e), a);\n-        }\n-        /* no change, next 3 cases */\n-        case (expr_fail(_)) { }\n-        case (expr_break(_)) { }\n-        case (expr_cont(_)) { }\n-        case (expr_ret(?maybe_e, ?a)) {\n-            e1 = expr_ret(annotate_option_exp(fm, maybe_e), a);\n-        }\n-        case (expr_put(?maybe_e, ?a)) {\n-            e1 = expr_put(annotate_option_exp(fm, maybe_e), a);\n-        }\n-        case (expr_be(?e, ?a)) {\n-            e1 = expr_be(annotate_expr(fm, e), a);\n-        }\n-        case (expr_log(?n, ?e, ?a)) {\n-            e1 = expr_log(n, annotate_expr(fm, e), a);\n-        }\n-        case (expr_assert(?e, ?a)) {\n-            e1 = expr_assert(annotate_expr(fm, e), a);\n-        }\n-        case (expr_check(?e, ?a)) {\n-            e1 = expr_check(annotate_expr(fm, e), a);\n-        }\n-        case (expr_port(_)) { /* no change */ }\n-        case (expr_chan(?e, ?a)) {\n-            e1 = expr_chan(annotate_expr(fm, e), a);\n+fn collect_ids_stmt(&@stmt s, @vec[uint] res) -> () {\n+    alt (s.node) {\n+        case (stmt_decl(_,?a)) {\n+            log(\"node_id \" + uistr(a.id));\n+            log_stmt(*s);\n+  \n+            vec::push(*res, a.id);\n+        }\n+        case (stmt_expr(_,?a)) {\n+            log(\"node_id \" + uistr(a.id));\n+            log_stmt(*s);\n+    \n+            vec::push(*res, a.id);\n         }\n+        case (_) {}\n     }\n-    ret @respan(e.span, e1);\n }\n \n-fn annotate_stmt(&fn_info_map fm, &@stmt s) -> @stmt {\n-    alt (s.node) {\n-        case (stmt_decl(?d, ?a)) {\n-            ret @respan(s.span, stmt_decl(annotate_decl(fm, d), a));\n-        }\n-        case (stmt_expr(?e, ?a)) {\n-            ret @respan(s.span, stmt_expr(annotate_expr(fm, e), a));\n+fn collect_ids_decl(&@decl d, @vec[uint] res) -> () {\n+    alt (d.node) {\n+        case (decl_local(?l)) {\n+            vec::push(*res, l.ann.id);\n         }\n+        case (_) {}\n     }\n }\n-fn annotate_block(&fn_info_map fm, &block b) -> block {\n-    let vec[@stmt] new_stmts = [];\n-   \n-    for (@stmt s in b.node.stmts) {\n-        auto new_s = annotate_stmt(fm, s);\n-        vec::push[@stmt](new_stmts, new_s);\n-    }\n-    fn ann_e(fn_info_map fm, &@expr e) -> @expr {\n-        ret annotate_expr(fm, e);\n-    }\n-    auto f = bind ann_e(fm,_);\n-\n-    auto new_e = option::map[@expr, @expr](f, b.node.expr);\n \n-    ret respan(b.span,\n-          rec(stmts=new_stmts, expr=new_e with b.node));\n-}\n-fn annotate_fn(&fn_info_map fm, &_fn f) -> _fn {\n-    // subexps have *already* been annotated based on\n-    // f's number-of-locals\n-    ret rec(body=annotate_block(fm, f.body) with f);\n-}\n-fn annotate_mod(&fn_info_map fm, &_mod m) -> _mod {\n-    let vec[@item] new_items = [];\n-   \n-    for (@item i in m.items) {\n-        auto new_i = annotate_item(fm, i);\n-        vec::push[@item](new_items, new_i);\n-    }\n-    ret rec(items=new_items with m);\n-}\n-fn annotate_method(&fn_info_map fm, &@method m) -> @method {\n-    auto f_info = get_fn_info(fm, m.node.id);\n-    auto fld0 = new_identity_fold[fn_info]();\n-    fld0 = @rec(fold_ann = bind init_ann(_,_) \n-                with *fld0);\n-    auto outer = fold_method[fn_info](f_info, fld0, m);\n-    auto new_fn = annotate_fn(fm, outer.node.meth);\n-    ret @respan(m.span,\n-                rec(meth=new_fn with m.node));\n+fn node_ids_in_fn(&_fn f, &def_id d, @vec[uint] res) -> () {\n+    auto collect_ids = walk::default_visitor();\n+    collect_ids = rec(visit_expr_pre  = bind collect_ids_expr(_,res),\n+                      visit_block_pre = bind collect_ids_block(_,res),\n+                      visit_stmt_pre  = bind collect_ids_stmt(_,res),\n+                      visit_decl_pre  = bind collect_ids_decl(_,res)\n+                      with collect_ids);\n+    walk::walk_fn(collect_ids, f, d);\n }\n \n-fn annotate_obj(&fn_info_map fm, &_obj o) -> _obj {\n-    fn one(fn_info_map fm, &@method m) -> @method {\n-        ret annotate_method(fm, m);\n+fn init_vecs(&crate_ctxt ccx, @vec[uint] node_ids, uint len) -> () {\n+    for (uint i in *node_ids) {\n+        log(uistr(i) + \" |-> \" + uistr(len));\n+        ccx.node_anns.insert(i, empty_ann(len));\n     }\n-    auto f = bind one(fm,_);\n-    auto new_methods = vec::map[@method, @method](f, o.methods);\n-    auto new_dtor    = option::map[@method, @method](f, o.dtor);\n-    ret rec(methods=new_methods, dtor=new_dtor with o);\n }\n \n- \n-// Only annotates the components of the item recursively.\n-fn annotate_item_inner(&fn_info_map fm, &@item item) -> @item {\n-    alt (item.node) {\n-        /* FIXME can't skip this case -- exprs contain blocks contain stmts,\n-         which contain decls */\n-        case (item_const(_,_,_,_,_)) {\n-            // this has already been annotated by annotate_item\n-            ret item;\n-        }\n-        case (item_fn(?ident, ?ff, ?tps, ?id, ?ann)) {\n-            ret @respan(item.span,\n-                       item_fn(ident, annotate_fn(fm, ff), tps, id, ann));\n-        }\n-        case (item_mod(?ident, ?mm, ?id)) {\n-            ret @respan(item.span,\n-                       item_mod(ident, annotate_mod(fm, mm), id));\n-        }\n-        case (item_native_mod(?ident, ?mm, ?id)) {\n-            ret item;\n-        }\n-        case (item_ty(_,_,_,_,_)) {\n-            ret item;\n-        }\n-        case (item_tag(_,_,_,_,_)) {\n-            ret item;\n-        }\n-        case (item_obj(?ident, ?ob, ?tps, ?odid, ?ann)) {\n-            ret @respan(item.span,\n-              item_obj(ident, annotate_obj(fm, ob), tps, odid, ann));\n-        }\n-    } \n+fn visit_fn(&crate_ctxt ccx, uint num_locals, &_fn f, &def_id d) -> () {\n+     \n+    let vec[uint] node_ids_ = [];\n+    let @vec[uint] node_ids = @node_ids_;\n+    node_ids_in_fn(f, d, node_ids);\n+    init_vecs(ccx, node_ids, num_locals);\n }\n \n-fn annotate_item(&fn_info_map fm, &@item item) -> @item {\n-    // Using a fold, recursively set all anns in this item\n-    // to be blank.\n-    // *Then*, call annotate_item recursively to do the right\n-    // thing for any nested items inside this one.\n-    \n-    alt (item.node) {\n-        case (item_const(_,_,_,_,_)) {\n-            auto fld0 = new_identity_fold[()]();\n-            fld0 = @rec(fold_ann = bind init_blank_ann(_,_) \n-                        with *fld0);\n-            ret fold_item[()]((), fld0, item);\n-        }\n-        case (item_fn(?i,?ff,?tps,?id,?ann)) {\n-            auto f_info = get_fn_info(fm, id);\n-            auto fld0 = new_identity_fold[fn_info]();\n-            fld0 = @rec(fold_ann = bind init_ann(_,_) \n-                        with *fld0);\n-            auto outer = fold_item[fn_info](f_info, fld0, item);\n-            // now recurse into any nested items\n-            ret annotate_item_inner(fm, outer);\n-         }\n-        case (item_mod(?i, ?mm, ?id)) {\n-            auto fld0 = new_identity_fold[()]();\n-            fld0 = @rec(fold_ann = bind init_blank_ann(_,_) \n-                        with *fld0);\n-            auto outer = fold_item[()]((), fld0, item);\n-            ret annotate_item_inner(fm, outer);\n-        }\n-        case (item_native_mod(?i, ?nm, ?id)) {\n-            ret item;\n-        }\n-        case (item_ty(_,_,_,_,_)) {\n-            ret item;\n-        }\n-        case (item_tag(_,_,_,_,_)) {\n-            ret item;\n-        }\n-        case (item_obj(?i,?ob,?tps,?odid,?ann)) {\n-            auto fld0 = new_identity_fold[()]();\n-            fld0 = @rec(fold_ann = bind init_blank_ann(_,_) \n-                        with *fld0);\n-            auto outer = fold_item[()]((), fld0, item);\n-            ret annotate_item_inner(fm, outer);\n-        }\n-    }\n+fn annotate_in_fn(&crate_ctxt ccx, &_fn f, &def_id f_id) -> () {\n+    auto f_info = get_fn_info(ccx, f_id);\n+    visit_fn(ccx, num_locals(f_info), f, f_id);\n }\n \n-fn annotate_module(&fn_info_map fm, &_mod module) -> _mod {\n-    let vec[@item] new_items = [];\n-   \n-    for (@item i in module.items) {\n-        auto new_item = annotate_item(fm, i);\n-        vec::push[@item](new_items, new_item);\n-    }\n-\n-    ret rec(items = new_items with module);\n+fn annotate_crate(&crate_ctxt ccx, &crate crate) -> () {\n+    auto do_ann = walk::default_visitor();\n+    do_ann = rec(visit_fn_pre = bind annotate_in_fn(ccx, _, _)\n+                 with do_ann);\n+    walk::walk_crate(do_ann, crate);\n }\n \n-fn annotate_crate(&fn_info_map fm, &@crate crate) -> @crate {\n-    ret @respan(crate.span,\n-               rec(module = annotate_module(fm, crate.node.module)\n-                   with crate.node));\n-}\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "2e656e45ceb19e588b8e5f8e3888b0ed58a91a48", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 122, "deletions": 117, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/e16b097599ee73a909df7ffbbaaf30f25a7057e3/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16b097599ee73a909df7ffbbaaf30f25a7057e3/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=e16b097599ee73a909df7ffbbaaf30f25a7057e3", "patch": "@@ -37,6 +37,7 @@ import util::common;\n import util::common::span;\n import util::common::log_block;\n import util::common::new_def_hash;\n+import util::common::new_uint_hash;\n import util::common::log_expr_err;\n import util::common::uistr;\n \n@@ -157,6 +158,10 @@ fn print_idents(vec[ident] idents) -> () {\n type var_info     = tup(uint, ident);\n type fn_info      = rec(@std::map::hashmap[def_id, var_info] vars,\n                         controlflow cf);\n+\n+/* mapping from node ID to typestate annotation */\n+type node_ann_table = @std::map::hashmap[uint, ts_ann];\n+\n /* mapping from function name to fn_info map */\n type fn_info_map = @std::map::hashmap[def_id, fn_info];\n \n@@ -167,176 +172,187 @@ type fn_ctxt    = rec(fn_info enclosing,\n \n type crate_ctxt = rec(ty::ctxt tcx,\n                       ty::node_type_table node_types,\n+                      node_ann_table node_anns,\n                       fn_info_map fm);\n \n-fn get_fn_info(fn_info_map fm, def_id did) -> fn_info {\n-    assert (fm.contains_key(did));\n-    ret fm.get(did);\n+fn get_fn_info(&crate_ctxt ccx, def_id did) -> fn_info {\n+    assert (ccx.fm.contains_key(did));\n+    ret ccx.fm.get(did);\n }\n \n /********* utils ********/\n \n-\n-fn ann_to_ts_ann(ann a, uint nv) -> @ts_ann {\n-    alt (ann_to_ts_ann_fail(a)) {\n-        case (none[@ts_ann])         { ret @empty_ann(nv); }\n-        case (some[@ts_ann](?t))     { ret t; }\n-    }\n-}\n-\n-\n-fn ann_to_ts_ann_fail(ann a) -> option::t[@ts_ann] { ret a.ts; }\n-\n-fn ann_to_ts_ann_strict(ann a) -> @ts_ann {\n-    alt (ann_to_ts_ann_fail(a)) {\n-        case (none[@ts_ann]) {\n-            log(\"ann_to_ts_ann_strict: didn't expect none here\");\n+fn ann_to_ts_ann(&crate_ctxt ccx, &ann a) -> ts_ann {\n+    alt (ccx.node_anns.find(a.id)) {\n+        case (none[ts_ann])         { \n+            log_err (\"ann_to_ts_ann: no ts_ann for node_id \"\n+                     + uistr(a.id));\n             fail;\n         }\n-        case (some[@ts_ann](?t)) { ret t; }\n+        case (some[ts_ann](?t))     { ret t; }\n     }\n }\n \n-fn ann_to_poststate(ann a) -> poststate {\n-    ret (ann_to_ts_ann_strict(a)).states.poststate;\n+fn ann_to_poststate(&crate_ctxt ccx, ann a) -> poststate {\n+    log \"ann_to_poststate\";\n+    ret (ann_to_ts_ann(ccx, a)).states.poststate;\n }\n \n-fn stmt_to_ann(&stmt s) -> option::t[@ts_ann] {\n+fn stmt_to_ann(&crate_ctxt ccx, &stmt s) -> ts_ann {\n+    log \"stmt_to_ann\";\n   alt (s.node) {\n     case (stmt_decl(_,?a)) {\n-        ret ann_to_ts_ann_fail(a);\n+        ret ann_to_ts_ann(ccx, a);\n     }\n     case (stmt_expr(_,?a)) {\n-        ret ann_to_ts_ann_fail(a);\n+        ret ann_to_ts_ann(ccx, a);\n     }\n     case (stmt_crate_directive(_)) {\n-      ret none[@ts_ann];\n+        log_err \"expecting an annotated statement here\";\n+        fail;\n     }\n   }\n }\n \n-fn stmt_to_ann_strict(&stmt s) -> @ts_ann {\n-    alt (stmt_to_ann(s)) {\n-        case (none[@ts_ann]) {\n-            log_err(\"stmt_to_ann_strict: didn't expect none here\");\n-            fail;\n-        }\n-        case (some[@ts_ann](?a)) { ret a; }\n-    }\n-}\n-\n /* fails if e has no annotation */\n-fn expr_states(@expr e) -> pre_and_post_state {\n-    ret (ann_to_ts_ann_strict(expr_ann(e)).states);\n+fn expr_states(&crate_ctxt ccx, @expr e) -> pre_and_post_state {\n+    log \"expr_states\";\n+    ret (ann_to_ts_ann(ccx, expr_ann(e)).states);\n }\n \n /* fails if e has no annotation */\n-fn expr_pp(@expr e) -> pre_and_post {\n-    ret (ann_to_ts_ann_strict(expr_ann(e)).conditions);\n+fn expr_pp(&crate_ctxt ccx, @expr e) -> pre_and_post {\n+    log \"expr_pp\";\n+    ret (ann_to_ts_ann(ccx, expr_ann(e)).conditions);\n }\n \n-fn stmt_pp(&stmt s) -> pre_and_post {\n-    ret (stmt_to_ann_strict(s).conditions);\n+fn stmt_pp(&crate_ctxt ccx, &stmt s) -> pre_and_post {\n+    ret (stmt_to_ann(ccx, s).conditions);\n }\n \n /* fails if b has no annotation */\n-fn block_pp(&block b) -> pre_and_post {\n-    ret (ann_to_ts_ann_strict(b.node.a).conditions);\n+fn block_pp(&crate_ctxt ccx, &block b) -> pre_and_post {\n+    log \"block_pp\";\n+    ret (ann_to_ts_ann(ccx, b.node.a).conditions);\n }\n \n-fn block_states(&block b) -> pre_and_post_state {\n-    ret (ann_to_ts_ann_strict(b.node.a).states);\n+fn clear_pp(pre_and_post pp) {\n+    ann::clear(pp.precondition);\n+    ann::clear(pp.postcondition);\n }\n \n-fn stmt_states(&stmt s, uint nv) -> pre_and_post_state {\n-  alt (stmt_to_ann(s)) {\n-    case (none[@ts_ann]) {\n-      ret empty_states(nv);\n-    }\n-    case (some[@ts_ann](?a)) {\n-      ret a.states;\n-    }\n-  }\n+fn clear_precond(&crate_ctxt ccx, &ann a) {\n+    auto pp = ann_to_ts_ann(ccx, a);\n+    ann::clear(pp.conditions.precondition);\n+}\n+\n+fn block_states(&crate_ctxt ccx, &block b) -> pre_and_post_state {\n+    log \"block_states\";\n+    ret (ann_to_ts_ann(ccx, b.node.a).states);\n }\n \n-fn expr_precond(@expr e) -> precond {\n-  ret (expr_pp(e)).precondition;\n+fn stmt_states(&crate_ctxt ccx, &stmt s) -> pre_and_post_state {\n+    ret (stmt_to_ann(ccx, s)).states;\n }\n \n-fn expr_postcond(@expr e) -> postcond {\n-  ret (expr_pp(e)).postcondition;\n+fn expr_precond(&crate_ctxt ccx, @expr e) -> precond {\n+    ret (expr_pp(ccx, e)).precondition;\n }\n \n-fn expr_prestate(@expr e) -> prestate {\n-  ret (expr_states(e)).prestate;\n+fn expr_postcond(&crate_ctxt ccx, @expr e) -> postcond {\n+    ret (expr_pp(ccx, e)).postcondition;\n }\n \n-fn expr_poststate(@expr e) -> poststate {\n-  ret (expr_states(e)).poststate;\n+fn expr_prestate(&crate_ctxt ccx, @expr e) -> prestate {\n+    ret (expr_states(ccx, e)).prestate;\n }\n \n-fn stmt_precond(&stmt s) -> precond {\n-  ret (stmt_pp(s)).precondition;\n+fn expr_poststate(&crate_ctxt ccx, @expr e) -> poststate {\n+    ret (expr_states(ccx, e)).poststate;\n }\n \n-fn stmt_postcond(&stmt s) -> postcond {\n-  ret (stmt_pp(s)).postcondition;\n+fn stmt_precond(&crate_ctxt ccx, &stmt s) -> precond {\n+    ret (stmt_pp(ccx, s)).precondition;\n+}\n+\n+fn stmt_postcond(&crate_ctxt ccx, &stmt s) -> postcond {\n+    ret (stmt_pp(ccx, s)).postcondition;\n }\n \n fn states_to_poststate(&pre_and_post_state ss) -> poststate {\n   ret ss.poststate;\n }\n \n-fn stmt_prestate(&stmt s, uint nv) -> prestate {\n-  ret (stmt_states(s, nv)).prestate;\n+fn stmt_prestate(&crate_ctxt ccx, &stmt s) -> prestate {\n+    ret (stmt_states(ccx, s)).prestate;\n }\n \n-fn stmt_poststate(&stmt s, uint nv) -> poststate {\n-  ret (stmt_states(s, nv)).poststate;\n+fn stmt_poststate(&crate_ctxt ccx, &stmt s) -> poststate {\n+    ret (stmt_states(ccx, s)).poststate;\n }\n \n-fn block_postcond(&block b) -> postcond {\n-    ret (block_pp(b)).postcondition;\n+fn block_postcond(&crate_ctxt ccx, &block b) -> postcond {\n+    ret (block_pp(ccx, b)).postcondition;\n }\n \n-fn block_poststate(&block b) -> poststate {\n-    ret (block_states(b)).poststate;\n+fn block_poststate(&crate_ctxt ccx, &block b) -> poststate {\n+    ret (block_states(ccx, b)).poststate;\n }\n \n-/* returns a new annotation where the pre_and_post is p */\n-fn with_pp(ann a, pre_and_post p) -> ann {\n-    ret rec(id=a.id, ty=a.ty, tps=a.tps,\n-            ts=some[@ts_ann](@rec(conditions=p,\n-                                  states=empty_states(pps_len(p)))));\n+/* sets the pre_and_post for an ann */\n+fn with_pp(&crate_ctxt ccx, &ann a, pre_and_post p) {\n+    ccx.node_anns.insert(a.id, @rec(conditions=p,\n+                                    states=empty_states(pps_len(p))));\n }\n \n-fn set_prestate_ann(&ann a, &prestate pre) -> bool {\n-    ret set_prestate(ann_to_ts_ann_strict(a), pre);\n+fn set_prestate_ann(&crate_ctxt ccx, &ann a, &prestate pre) -> bool {\n+    log \"set_prestate_ann\";\n+    ret set_prestate(ann_to_ts_ann(ccx, a), pre);\n }\n \n \n-fn extend_prestate_ann(&ann a, &prestate pre) -> bool {\n-    ret extend_prestate(ann_to_ts_ann_strict(a).states.prestate, pre);\n+fn extend_prestate_ann(&crate_ctxt ccx, &ann a, &prestate pre) -> bool {\n+    log \"extend_prestate_ann\";\n+    ret extend_prestate(ann_to_ts_ann(ccx, a).states.prestate, pre);\n }\n \n-fn set_poststate_ann(&ann a, &poststate post) -> bool {\n-    ret set_poststate(ann_to_ts_ann_strict(a), post);\n+fn set_poststate_ann(&crate_ctxt ccx, &ann a, &poststate post) -> bool {\n+    log \"set_poststate_ann\";\n+    ret set_poststate(ann_to_ts_ann(ccx, a), post);\n }\n \n-fn extend_poststate_ann(&ann a, &poststate post) -> bool {\n-    ret extend_poststate(ann_to_ts_ann_strict(a).states.poststate, post);\n+fn extend_poststate_ann(&crate_ctxt ccx, &ann a, &poststate post) -> bool {\n+    log \"extend_poststate_ann\";\n+    ret extend_poststate(ann_to_ts_ann(ccx, a).states.poststate, post);\n }\n \n-fn set_pre_and_post(&ann a, &pre_and_post pp) -> () {\n-    auto t = ann_to_ts_ann_strict(a);\n-    set_precondition(t, pp.precondition);\n-    set_postcondition(t, pp.postcondition);\n+fn set_pre_and_post(&crate_ctxt ccx, &ann a,\n+                    &precond pre, &postcond post) -> () {\n+    log \"set_pre_and_post\";\n+    auto t = ann_to_ts_ann(ccx, a);\n+    set_precondition(t, pre);\n+    set_postcondition(t, post);\n }\n \n-fn pure_exp(&ann a, &prestate p) -> bool {\n+fn copy_pre_post(&crate_ctxt ccx, &ann a, &@expr sub) -> () {\n+    log \"set_pre_and_post\";\n+    auto p = expr_pp(ccx, sub);\n+    auto t = ann_to_ts_ann(ccx, a);\n+    set_precondition(t, p.precondition);\n+    set_postcondition(t, p.postcondition);\n+}\n+\n+\n+/* sets all bits to *1* */\n+fn set_postcond_false(&crate_ctxt ccx, &ann a) {\n+    auto p = ann_to_ts_ann(ccx, a);\n+    ann::set(p.conditions.postcondition);\n+}\n+\n+fn pure_exp(&crate_ctxt ccx, &ann a, &prestate p) -> bool {\n   auto changed = false;\n-  changed = extend_prestate_ann(a, p) || changed;\n-  changed = extend_poststate_ann(a, p) || changed;\n+  changed = extend_prestate_ann(ccx, a, p) || changed;\n+  changed = extend_poststate_ann(ccx, a, p) || changed;\n   ret changed;\n }\n \n@@ -354,31 +370,14 @@ fn fixed_point_states(&fn_ctxt fcx,\n   }\n }\n \n-fn init_ann(&fn_info fi, &ann a) -> ann {\n-    ret rec(id=a.id, ty=a.ty, tps=a.tps,\n-            ts=some[@ts_ann](@empty_ann(num_locals(fi))));\n-}\n-\n-fn init_blank_ann(&() ignore, &ann a) -> ann {\n-    ret rec(id=a.id, ty=a.ty, tps=a.tps, ts=some[@ts_ann](@empty_ann(0u)));\n-}\n-\n-fn init_block(&fn_info fi, &span sp, &block_ b) -> block {\n-    log(\"init_block:\");\n-    log_block(respan(sp, b));\n-\n-    auto fld0 = new_identity_fold[fn_info]();\n-\n-    fld0 = @rec(fold_ann = bind init_ann(_,_) with *fld0);\n-    ret fold_block[fn_info](fi, fld0, respan(sp, b)); \n-}\n-\n fn num_locals(fn_info m) -> uint {\n   ret m.vars.size();\n }\n \n fn new_crate_ctxt(ty::node_type_table nt, ty::ctxt cx) -> crate_ctxt {\n-    ret rec(tcx=cx, node_types=nt, fm=@new_def_hash[fn_info]());\n+    ret rec(tcx=cx, node_types=nt, \n+            node_anns=@new_uint_hash[ts_ann](),\n+            fm=@new_def_hash[fn_info]());\n }\n \n fn controlflow_def_id(&crate_ctxt ccx, &def_id d) -> controlflow {\n@@ -395,9 +394,15 @@ fn controlflow_def_id(&crate_ctxt ccx, &def_id d) -> controlflow {\n fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n     auto f = expr_ann(e).id;\n     alt (ccx.tcx.def_map.find(f)) {\n-        case (some[def](def_fn(?d)))        { ret controlflow_def_id(ccx, d); }\n-        case (some[def](def_obj_field(?d))) { ret controlflow_def_id(ccx, d); }\n-        case (_)                            { ret return; }\n+        case (some[def](def_fn(?d))) { \n+            ret controlflow_def_id(ccx, d); \n+        }\n+        case (some[def](def_obj_field(?d))) { \n+            ret controlflow_def_id(ccx, d);\n+        }\n+        case (_)                            {\n+            ret return;\n+        }\n     }\n }\n "}, {"sha": "aa379e072af7d85fccb54d2be45a61374977a8ec", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e16b097599ee73a909df7ffbbaaf30f25a7057e3/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16b097599ee73a909df7ffbbaaf30f25a7057e3/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=e16b097599ee73a909df7ffbbaaf30f25a7057e3", "patch": "@@ -12,8 +12,8 @@ import aux::fn_ctxt;\n import aux::fn_info;\n import aux::log_bitv;\n import aux::num_locals;\n-import aux::ann_to_ts_ann_strict;\n \n+import tstate::aux::ann_to_ts_ann;\n import tstate::ann::pre_and_post;\n import tstate::ann::precond;\n import tstate::ann::postcond;\n@@ -48,7 +48,7 @@ fn seq_preconds(fn_info enclosing, vec[pre_and_post] pps) -> precond {\n   let uint num_vars = num_locals(enclosing);\n \n   if (sz >= 1u) {\n-    auto first   = pps.(0);\n+    auto first = pps.(0);\n     assert (pps_len(first) == num_vars);\n     let precond rest = seq_preconds(enclosing,\n                          slice[pre_and_post](pps, 1u, sz));\n@@ -115,9 +115,10 @@ fn intersect_postconds(&vec[postcond] pcs) -> postcond {\n }\n \n fn gen(&fn_ctxt fcx, &ann a, def_id id) -> bool {\n+  log \"gen\";\n   assert (fcx.enclosing.vars.contains_key(id));\n   let uint i = (fcx.enclosing.vars.get(id))._0;\n-  ret set_in_postcond(i, (ann_to_ts_ann_strict(a)).conditions);\n+  ret set_in_postcond(i, (ann_to_ts_ann(fcx.ccx, a)).conditions);\n }\n \n fn declare_var(&fn_info enclosing, def_id id, prestate pre)\n@@ -130,8 +131,9 @@ fn declare_var(&fn_info enclosing, def_id id, prestate pre)\n }\n \n fn gen_poststate(&fn_ctxt fcx, &ann a, def_id id) -> bool {\n+  log \"gen_poststate\";\n   assert (fcx.enclosing.vars.contains_key(id));\n   let uint i = (fcx.enclosing.vars.get(id))._0;\n-  ret set_in_poststate(i, (ann_to_ts_ann_strict(a)).states);\n+  ret set_in_poststate(i, (ann_to_ts_ann(fcx.ccx, a)).states);\n }\n "}, {"sha": "5de793d64b04fa7cc037fe6af3f18ab2d2122667", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 59, "deletions": 66, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/e16b097599ee73a909df7ffbbaaf30f25a7057e3/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16b097599ee73a909df7ffbbaaf30f25a7057e3/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=e16b097599ee73a909df7ffbbaaf30f25a7057e3", "patch": "@@ -56,6 +56,8 @@ import aux::fixed_point_states;\n import aux::bitv_to_str;\n \n import util::common::ty_to_str;\n+import util::common::log_stmt_err;\n+import aux::log_bitv_err;\n import bitvectors::promises;\n \n import annotate::annotate_crate;\n@@ -64,85 +66,76 @@ import pre_post_conditions::check_item_fn;\n import states::find_pre_post_state_fn;\n \n fn check_states_expr(&fn_ctxt fcx, @expr e) -> () {\n-  let precond prec    = expr_precond(e);\n-  let prestate pres   = expr_prestate(e);\n-\n-  if (!implies(pres, prec)) {\n-      auto s = \"\";\n-      s += (\"Unsatisfied precondition constraint for expression:\\n\");\n-      s += util::common::expr_to_str(e);\n-      s += (\"Precondition: \");\n-      s += bitv_to_str(fcx.enclosing, prec);\n-      s += (\"Prestate: \");\n-      s += bitv_to_str(fcx.enclosing, pres);\n-      fcx.ccx.tcx.sess.span_err(e.span, s);\n-  }\n+    let precond prec  = expr_precond(fcx.ccx, e);\n+    let prestate pres = expr_prestate(fcx.ccx, e);\n+\n+    if (!implies(pres, prec)) {\n+        auto s = \"\";\n+        s += (\"Unsatisfied precondition constraint for expression:\\n\");\n+        s += util::common::expr_to_str(e);\n+        s += (\"Precondition: \");\n+        s += bitv_to_str(fcx.enclosing, prec);\n+        s += (\"Prestate: \");\n+        s += bitv_to_str(fcx.enclosing, pres);\n+        fcx.ccx.tcx.sess.span_err(e.span, s);\n+    }\n }\n \n fn check_states_stmt(&fn_ctxt fcx, &stmt s) -> () {\n-  alt (stmt_to_ann(s)) {\n-    case (none[@ts_ann]) {\n-      ret;\n-    }\n-    case (some[@ts_ann](?a)) {\n-      let precond prec    = ann_precond(*a);\n-      let prestate pres   = ann_prestate(*a);\n-\n-      /*\n-      log(\"check_states_stmt:\");\n-      log_stmt(s);\n-      log(\"prec = \");\n-      log_bitv(enclosing, prec);\n-      log(\"pres = \");\n-      log_bitv(enclosing, pres);\n-      */\n-\n-      if (!implies(pres, prec)) {\n-          auto ss = \"\";\n-          ss += (\"Unsatisfied precondition constraint for statement:\\n\");\n-          ss += util::common::stmt_to_str(s);\n-          ss += (\"Precondition: \");\n-          ss += bitv_to_str(fcx.enclosing, prec);\n-          ss += (\"Prestate: \");\n-          ss += bitv_to_str(fcx.enclosing, pres);\n-          fcx.ccx.tcx.sess.span_err(s.span, ss);\n-      }\n+    auto a = stmt_to_ann(fcx.ccx, s);\n+    let precond prec    = ann_precond(a);\n+    let prestate pres   = ann_prestate(a);\n+\n+    /*    \n+      log_err(\"check_states_stmt:\");\n+      log_stmt_err(s);\n+      log_err(\"prec = \");\n+      log_bitv_err(fcx.enclosing, prec);\n+      log_err(\"pres = \");\n+      log_bitv_err(fcx.enclosing, pres);\n+    */\n+\n+    if (!implies(pres, prec)) {\n+        auto ss = \"\";\n+        ss += (\"Unsatisfied precondition constraint for statement:\\n\");\n+        ss += util::common::stmt_to_str(s);\n+        ss += (\"Precondition: \");\n+        ss += bitv_to_str(fcx.enclosing, prec);\n+        ss += (\"Prestate: \");\n+        ss += bitv_to_str(fcx.enclosing, pres);\n+        fcx.ccx.tcx.sess.span_err(s.span, ss);\n     }\n-  }\n }\n \n fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a) -> () {\n     auto enclosing = fcx.enclosing;\n     auto nv   = num_locals(enclosing);\n     auto post = @empty_poststate(nv);\n \n-    fn do_one_(fn_ctxt fcx, &@stmt s, @poststate post, uint nv) -> () {\n+    fn do_one_(fn_ctxt fcx, &@stmt s, @poststate post) -> () {\n         check_states_stmt(fcx, *s);\n-        *post = stmt_poststate(*s, nv);\n+        *post = stmt_poststate(fcx.ccx, *s);\n     }\n \n-    auto do_one = bind do_one_(fcx, _, post, nv);\n+    auto do_one = bind do_one_(fcx, _, post);\n  \n-  vec::map[@stmt, ()](do_one, f.body.node.stmts);\n-  fn do_inner_(fn_ctxt fcx, &@expr e, @poststate post) -> () {\n-    check_states_expr(fcx, e);\n-    *post = expr_poststate(e);\n-  }\n-  auto do_inner = bind do_inner_(fcx, _, post);\n-  option::map[@expr, ()](do_inner, f.body.node.expr);\n+    vec::map[@stmt, ()](do_one, f.body.node.stmts);\n+    fn do_inner_(fn_ctxt fcx, &@expr e, @poststate post) -> () {\n+        check_states_expr(fcx, e);\n+        *post = expr_poststate(fcx.ccx, e);\n+    }\n+    auto do_inner = bind do_inner_(fcx, _, post);\n+    option::map[@expr, ()](do_inner, f.body.node.expr);\n   \n-  /* Finally, check that the return value is initialized */\n-  if (f.proto == ast::proto_fn\n-      && ! promises(*post, fcx.id, enclosing)\n-      && ! type_is_nil(fcx.ccx.tcx,\n-                       ret_ty_of_fn(fcx.ccx.node_types, fcx.ccx.tcx, a)) ) {\n-      /* FIXME: make this an error, not warning, once I finish implementing\n-         ! annotations */\n-        /* fcx.ccx.tcx.sess.span_err(f.body.span, \"Function \" +\n-           fcx.name + \" may not return. Its declared return type is \"\n-           + util.common.ty_to_str(*f.decl.output)); */\n-        fcx.ccx.tcx.sess.span_warn(f.body.span, \"not all control paths \" +\n-            \"return a value\");\n+    /* Finally, check that the return value is initialized */\n+    if (f.proto == ast::proto_fn\n+        && ! promises(*post, fcx.id, enclosing)\n+        && ! type_is_nil(fcx.ccx.tcx,\n+                         ret_ty_of_fn(fcx.ccx.node_types, fcx.ccx.tcx, a)) ) {\n+        /* FIXME: call span_err, not span_warn, once I finish implementing\n+           ! annotations */\n+        fcx.ccx.tcx.sess.span_warn(f.body.span, \"In function \" + fcx.name +\n+          \", not all control paths return a value\");\n         fcx.ccx.tcx.sess.span_note(f.decl.output.span,\n             \"see declared return type of '\" + ty_to_str(*f.decl.output) +\n             \"'\");\n@@ -202,15 +195,15 @@ fn check_crate(ty::node_type_table nt, ty::ctxt cx, @crate crate) -> @crate {\n     /* Build the global map from function id to var-to-bit-num-map */\n     mk_f_to_fn_info(ccx, crate);\n   \n-    /* Add a blank ts_ann to every statement (and expression) */\n-    auto with_anns = annotate_crate(ccx.fm, crate);\n+    /* Add a blank ts_ann for every statement (and expression) */\n+    annotate_crate(ccx, *crate);\n \n     /* Compute the pre and postcondition for every subexpression */\n     \n     auto fld = new_identity_fold[crate_ctxt]();\n     fld = @rec(fold_item_fn = bind check_item_fn(_,_,_,_,_,_,_) with *fld);\n     auto with_pre_postconditions =\n-           fold_crate[crate_ctxt](ccx, fld, with_anns);\n+           fold_crate[crate_ctxt](ccx, fld, crate);\n     \n     auto fld1 = new_identity_fold[crate_ctxt]();\n "}, {"sha": "9f99986009633a15f690e750e2f09cfb2e9a1583", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e16b097599ee73a909df7ffbbaaf30f25a7057e3/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16b097599ee73a909df7ffbbaaf30f25a7057e3/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=e16b097599ee73a909df7ffbbaaf30f25a7057e3", "patch": "@@ -31,22 +31,28 @@ import aux::var_info;\n import aux::crate_ctxt;\n \n import util::common::new_def_hash;\n+import util::common::uistr;\n \n fn var_is_local(def_id v, fn_info m) -> bool {\n   ret (m.vars.contains_key(v));\n }\n \n-fn collect_local(&@vec[tup(ident, def_id)] vars, &@local loc) -> () {\n-    log(\"collect_local: pushing \" + loc.ident);\n-    _vec::push[tup(ident, def_id)](*vars, tup(loc.ident, loc.id));\n+fn collect_local(&@vec[tup(ident, def_id)] vars, &@decl d) -> () {\n+    alt (d.node) {\n+      case (decl_local(?loc)) {\n+        log(\"collect_local: pushing \" + loc.ident);\n+        vec::push[tup(ident, def_id)](*vars, tup(loc.ident, loc.id));\n+      }\n+      case (_) { ret; }\n+    }\n }\n \n-fn find_locals(_fn f) -> @vec[tup(ident,def_id)] {\n+fn find_locals(_fn f, def_id d) -> @vec[tup(ident,def_id)] {\n   auto res = @vec::alloc[tup(ident,def_id)](0u);\n \n   auto visitor = walk::default_visitor();\n   visitor = rec(visit_decl_pre=bind collect_local(res,_) with visitor);\n-  walk_fn(visitor, f);\n+  walk_fn(visitor, f, d);\n \n   ret res;\n }\n@@ -69,7 +75,7 @@ fn mk_fn_info(_fn f, def_id f_id, ident f_name) -> fn_info {\n     /* ignore args, which we know are initialized;\n        just collect locally declared vars */\n \n-    let @vec[tup(ident,def_id)] locals = find_locals(f);\n+    let @vec[tup(ident,def_id)] locals = find_locals(f, f_id);\n     // log (uistr(vec::len[tup(ident, def_id)](locals)) + \" locals\");\n     for (tup(ident,def_id) p in *locals) {\n         next = add_var(p._1, p._0, next, res);\n@@ -78,6 +84,9 @@ fn mk_fn_info(_fn f, def_id f_id, ident f_name) -> fn_info {\n        we can safely use the function's name itself for this purpose */\n     add_var(f_id, f_name, next, res);\n \n+    log(f_name + \" has \" + uistr(vec::len[tup(ident, def_id)](*locals))\n+            + \" locals\");\n+   \n     ret res;\n }\n \n@@ -91,7 +100,7 @@ fn mk_fn_info_item (&crate_ctxt ccx, &@item i) -> () {\n       ccx.fm.insert(id, f_inf);\n     }\n     case (item_obj(?i,?o,?ty_params,?odid,?a)) {\n-      auto all_methods = _vec::clone[@method](o.methods);\n+      auto all_methods = vec::clone[@method](o.methods);\n       plus_option[@method](all_methods, o.dtor);\n       auto f_inf;\n       for (@method m in all_methods) {\n@@ -109,7 +118,7 @@ fn mk_fn_info_item (&crate_ctxt ccx, &@item i) -> () {\n fn mk_f_to_fn_info(&crate_ctxt ccx, @crate c) -> () {\n   let ast_visitor vars_visitor = walk::default_visitor();\n   vars_visitor = rec(visit_item_post=bind mk_fn_info_item(ccx,_)\n-\t\t     with vars_visitor);\n+                     with vars_visitor);\n \n   walk_crate(vars_visitor, *c);\n }"}, {"sha": "30437a4eeb5805655edae1241d8224dce916fcbd", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 117, "deletions": 107, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/e16b097599ee73a909df7ffbbaaf30f25a7057e3/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16b097599ee73a909df7ffbbaaf30f25a7057e3/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=e16b097599ee73a909df7ffbbaaf30f25a7057e3", "patch": "@@ -9,21 +9,25 @@ import tstate::ann::get_post;\n import tstate::ann::postcond;\n import tstate::ann::true_precond;\n import tstate::ann::false_postcond;\n-import tstate::ann::empty_pre_post;\n import tstate::ann::empty_poststate;\n import tstate::ann::require_and_preserve;\n import tstate::ann::union;\n import tstate::ann::intersect;\n import tstate::ann::pp_clone;\n import tstate::ann::empty_prestate;\n+import tstate::ann::set_precondition;\n+import tstate::ann::set_postcondition;\n import aux::var_info;\n import aux::crate_ctxt;\n import aux::fn_ctxt;\n import aux::num_locals;\n import aux::expr_pp;\n import aux::stmt_pp;\n import aux::block_pp;\n+import aux::clear_pp;\n+import aux::clear_precond;\n import aux::set_pre_and_post;\n+import aux::copy_pre_post;\n import aux::expr_precond;\n import aux::expr_postcond;\n import aux::expr_prestate;\n@@ -33,6 +37,8 @@ import aux::fn_info;\n import aux::log_pp;\n import aux::ann_to_def;\n import aux::ann_to_def_strict;\n+import aux::ann_to_ts_ann;\n+import aux::set_postcond_false;\n \n import bitvectors::seq_preconds;\n import bitvectors::union_postconds;\n@@ -145,6 +151,8 @@ import util::common::field_exprs;\n import util::common::has_nonlocal_exits;\n import util::common::log_stmt;\n import util::common::log_expr_err;\n+import util::common::log_block_err;\n+import util::common::log_block;\n \n fn find_pre_post_mod(&_mod m) -> _mod {\n     log(\"implement find_pre_post_mod!\");\n@@ -209,6 +217,11 @@ fn find_pre_post_item(&crate_ctxt ccx, &item i) -> () {\n    the preconditions for <args>, and the postcondition in a to \n    be the union of all postconditions for <args> */\n fn find_pre_post_exprs(&fn_ctxt fcx, &vec[@expr] args, ann a) {\n+    if (vec::len[@expr](args) > 0u) {\n+        log (\"find_pre_post_exprs: oper =\");\n+        log_expr(*(args.(0)));\n+    }\n+\n     auto enclosing = fcx.enclosing;\n     auto fm        = fcx.ccx.fm;\n     auto nv        = num_locals(enclosing);\n@@ -220,37 +233,40 @@ fn find_pre_post_exprs(&fn_ctxt fcx, &vec[@expr] args, ann a) {\n \n     vec::map[@expr, ()](f, args);\n \n-    fn get_pp(&@expr e) -> pre_and_post {\n-        ret expr_pp(e);\n+    fn get_pp(crate_ctxt ccx, &@expr e) -> pre_and_post {\n+        ret expr_pp(ccx, e);\n     }\n-    auto g = get_pp;\n+\n+    auto g = bind get_pp(fcx.ccx, _);\n     auto pps = vec::map[@expr, pre_and_post](g, args);\n     auto h = get_post;\n \n-    set_pre_and_post(a,\n-       rec(precondition=seq_preconds(enclosing, pps),\n-           postcondition=union_postconds\n-           (nv, (vec::map[pre_and_post, postcond](h, pps)))));\n+    set_pre_and_post(fcx.ccx, a, seq_preconds(enclosing, pps),\n+        union_postconds\n+          (nv, (vec::map[pre_and_post, postcond](h, pps))));\n }\n \n fn find_pre_post_loop(&fn_ctxt fcx, &@decl d, &@expr index,\n       &block body, &ann a) -> () {\n     find_pre_post_expr(fcx, index);\n     find_pre_post_block(fcx, body);\n+    log(\"222\");\n     auto loop_precond = declare_var(fcx.enclosing, decl_lhs(d),\n-           seq_preconds(fcx.enclosing, [expr_pp(index),\n-                                       block_pp(body)]));\n+      seq_preconds(fcx.enclosing, [expr_pp(fcx.ccx, index),\n+                                   block_pp(fcx.ccx, body)]));\n     auto loop_postcond = intersect_postconds\n-        ([expr_postcond(index), block_postcond(body)]);\n-    set_pre_and_post(a, rec(precondition=loop_precond,\n-                            postcondition=loop_postcond));\n+        ([expr_postcond(fcx.ccx, index), block_postcond(fcx.ccx, body)]);\n+    set_pre_and_post(fcx.ccx, a, loop_precond, loop_postcond);\n }\n \n-fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs, &ann larger_ann, &ann new_var) -> () {\n+fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs,\n+                &ann larger_ann, &ann new_var) -> () {\n   alt (ann_to_def(fcx.ccx, new_var)) {\n     case (some[def](def_local(?d_id))) {\n       find_pre_post_expr(fcx, rhs);\n-      set_pre_and_post(larger_ann, expr_pp(rhs));\n+      auto p = expr_pp(fcx.ccx, rhs);\n+      set_pre_and_post(fcx.ccx, larger_ann,\n+                       p.precondition, p.postcondition);\n       gen(fcx, larger_ann, d_id);\n     }\n     case (_) { find_pre_post_exprs(fcx, [lhs, rhs], larger_ann); }\n@@ -265,15 +281,10 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n     fn do_rand_(fn_ctxt fcx, &@expr e) -> () {\n         find_pre_post_expr(fcx, e);\n     }\n-    fn pp_one(&@expr e) -> pre_and_post {\n-        ret expr_pp(e);\n-    }\n     \n-    /*\n-    log_err(\"find_pre_post_expr (num_locals =\" +\n+    log(\"find_pre_post_expr (num_locals =\" +\n         uistr(num_local_vars) + \"):\");\n-    log_expr_err(*e);\n-    */\n+    log_expr(*e);\n \n     alt (e.node) {\n         case (expr_call(?operator, ?operands, ?a)) {\n@@ -293,47 +304,44 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             find_pre_post_exprs(fcx, elt_exprs(elts), a);\n         }\n         case (expr_path(?p, ?a)) {\n-            auto res = empty_pre_post(num_local_vars);\n-\t    \n-\t    auto df = ann_to_def_strict(fcx.ccx, a);\n+            auto res = expr_pp(fcx.ccx, e);\n+            clear_pp(res);\n+\n+            auto df = ann_to_def_strict(fcx.ccx, a);\n             alt (df) {\n                 case (def_local(?d_id)) {\n                     auto i = bit_num(d_id, enclosing);\n                     require_and_preserve(i, res);\n                 }\n                 case (_) { /* nothing to check */ }\n             }\n-\n-            // Otherwise, variable is global, so it must be initialized\n-            set_pre_and_post(a, res);\n         }\n         case (expr_self_method(?v, ?a)) {\n-            /* v is a method of the enclosing obj, so it must be\n-               initialized, right? */\n-            set_pre_and_post(a, empty_pre_post(num_local_vars));\n+            clear_pp(expr_pp(fcx.ccx, e));\n         }\n         case(expr_log(_, ?arg, ?a)) {\n             find_pre_post_expr(fcx, arg);\n-            set_pre_and_post(a, expr_pp(arg));\n+            copy_pre_post(fcx.ccx, a, arg);\n         }\n         case (expr_chan(?arg, ?a)) {\n             find_pre_post_expr(fcx, arg);\n-            set_pre_and_post(a, expr_pp(arg));\n+            copy_pre_post(fcx.ccx, a, arg);\n         }\n         case(expr_put(?opt, ?a)) {\n             alt (opt) {\n                 case (some[@expr](?arg)) {\n                     find_pre_post_expr(fcx, arg);\n-                    set_pre_and_post(a, expr_pp(arg));\n+                    copy_pre_post(fcx.ccx, a, arg);\n                 }\n                 case (none[@expr]) {\n-                    set_pre_and_post(a, empty_pre_post(num_local_vars));\n+                    clear_pp(expr_pp(fcx.ccx, e));\n                 }\n             }\n         }\n         case (expr_block(?b, ?a)) {\n             find_pre_post_block(fcx, b);\n-            set_pre_and_post(a, block_pp(b));\n+            auto p = block_pp(fcx.ccx, b);\n+            set_pre_and_post(fcx.ccx, a, p.precondition, p.postcondition);\n         }\n         case (expr_rec(?fields,?maybe_base,?a)) {\n             auto es = field_exprs(fields);\n@@ -343,7 +351,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n         case (expr_assign(?lhs, ?rhs, ?a)) {\n             alt (lhs.node) {\n                 case (expr_path(?p, ?a_lhs)) {\n-\t\t  gen_if_local(fcx, lhs, rhs, a, a_lhs);\n+                  gen_if_local(fcx, lhs, rhs, a, a_lhs);\n                 }\n                 case (_) {\n                     find_pre_post_exprs(fcx, [lhs, rhs], a);\n@@ -353,7 +361,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n         case (expr_recv(?lhs, ?rhs, ?a)) {\n             alt (lhs.node) {\n                 case (expr_path(?p, ?a_lhs)) {\n-\t\t  gen_if_local(fcx, lhs, rhs, a, a_lhs);\n+                  gen_if_local(fcx, lhs, rhs, a, a_lhs);\n                 }\n                 case (_) {\n                     // doesn't check that lhs is an lval, but\n@@ -368,63 +376,65 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             find_pre_post_exprs(fcx, [lhs, rhs], a);\n         }\n         case (expr_lit(_,?a)) {\n-            set_pre_and_post(a, empty_pre_post(num_local_vars));\n+            clear_pp(expr_pp(fcx.ccx, e));\n         }\n         case (expr_ret(?maybe_val, ?a)) {\n             alt (maybe_val) {\n                 case (none[@expr]) {\n-                    set_pre_and_post(a,\n-                      rec(precondition=true_precond(num_local_vars),\n-                          postcondition=false_postcond(num_local_vars)));\n+                    clear_precond(fcx.ccx, a);\n+                    set_postcond_false(fcx.ccx, a);\n                 }\n                 case (some[@expr](?ret_val)) {\n                     find_pre_post_expr(fcx, ret_val);\n-                    let pre_and_post pp =\n-                        rec(precondition=expr_precond(ret_val),\n-                            postcondition=false_postcond(num_local_vars));\n-                    set_pre_and_post(a, pp);\n+                    set_precondition(ann_to_ts_ann(fcx.ccx, a),\n+                                     expr_precond(fcx.ccx, ret_val));\n+                    set_postcond_false(fcx.ccx, a);\n                 }\n             }\n         }\n         case (expr_be(?e, ?a)) {\n             find_pre_post_expr(fcx, e);\n-            set_pre_and_post(a,\n-               rec(precondition=expr_prestate(e),\n-                   postcondition=false_postcond(num_local_vars)));\n+            set_pre_and_post(fcx.ccx, a,\n+               expr_prestate(fcx.ccx, e),\n+               false_postcond(num_local_vars));\n         }\n         case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n             find_pre_post_expr(fcx, antec);\n             find_pre_post_block(fcx, conseq);\n             alt (maybe_alt) {\n                 case (none[@expr]) {\n+                    log \"333\";\n                     auto precond_res = seq_preconds(enclosing,\n-                                                    [expr_pp(antec),\n-                                                        block_pp(conseq)]);\n-                    set_pre_and_post(a, rec(precondition=precond_res,\n-                                            postcondition=\n-                                            expr_poststate(antec)));\n+                                         [expr_pp(fcx.ccx, antec),\n+                                          block_pp(fcx.ccx, conseq)]);\n+                    set_pre_and_post(fcx.ccx, a, precond_res,\n+                                     expr_poststate(fcx.ccx, antec));\n                 }\n                 case (some[@expr](?altern)) {\n                     find_pre_post_expr(fcx, altern);\n+                    log \"444\";\n                     auto precond_true_case =\n                         seq_preconds(enclosing,\n-                                     [expr_pp(antec), block_pp(conseq)]);\n+                                     [expr_pp(fcx.ccx, antec),\n+                                      block_pp(fcx.ccx, conseq)]);\n                     auto postcond_true_case = union_postconds\n                         (num_local_vars,\n-                         [expr_postcond(antec), block_postcond(conseq)]);\n+                         [expr_postcond(fcx.ccx, antec),\n+                          block_postcond(fcx.ccx, conseq)]);\n+                    log \"555\";\n                     auto precond_false_case = seq_preconds\n                         (enclosing,\n-                         [expr_pp(antec), expr_pp(altern)]);\n+                         [expr_pp(fcx.ccx, antec), expr_pp(fcx.ccx, altern)]);\n                     auto postcond_false_case = union_postconds\n                         (num_local_vars,\n-                         [expr_postcond(antec), expr_postcond(altern)]);\n+                         [expr_postcond(fcx.ccx, antec),\n+                          expr_postcond(fcx.ccx, altern)]);\n                     auto precond_res = union_postconds\n                         (num_local_vars,\n                          [precond_true_case, precond_false_case]);\n                     auto postcond_res = intersect_postconds\n                         ([postcond_true_case, postcond_false_case]);\n-                    set_pre_and_post(a, rec(precondition=precond_res,\n-                                            postcondition=postcond_res));\n+                    set_pre_and_post(fcx.ccx, a, precond_res, postcond_res);\n                 }\n             }\n         }\n@@ -438,41 +448,42 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n         }\n         case (expr_unary(_,?operand,?a)) {\n             find_pre_post_expr(fcx, operand);\n-            set_pre_and_post(a, expr_pp(operand));\n+            copy_pre_post(fcx.ccx, a, operand);\n         }\n         case (expr_cast(?operand, _, ?a)) {\n             find_pre_post_expr(fcx, operand);\n-            set_pre_and_post(a, expr_pp(operand));\n+            copy_pre_post(fcx.ccx, a, operand);\n         }\n         case (expr_while(?test, ?body, ?a)) {\n             find_pre_post_expr(fcx, test);\n             find_pre_post_block(fcx, body);\n-            set_pre_and_post(a,\n-              rec(precondition=\n+            log \"666\";\n+            set_pre_and_post(fcx.ccx, a,\n                     seq_preconds(enclosing,\n-                               [expr_pp(test), \n-                                   block_pp(body)]),\n-                  postcondition=\n-                    intersect_postconds([expr_postcond(test),\n-                                            block_postcond(body)])));\n+                               [expr_pp(fcx.ccx, test), \n+                                   block_pp(fcx.ccx, body)]),\n+                    intersect_postconds([expr_postcond(fcx.ccx, test),\n+                                         block_postcond(fcx.ccx, body)]));\n         }\n         case (expr_do_while(?body, ?test, ?a)) {\n             find_pre_post_block(fcx, body);\n             find_pre_post_expr(fcx, test);\n    \n             auto loop_postcond = union_postconds(num_local_vars,\n-                   [block_postcond(body), expr_postcond(test)]);\n+                   [block_postcond(fcx.ccx, body),\n+                    expr_postcond(fcx.ccx, test)]);\n             /* conservative approximination: if the body\n                could break or cont, the test may never be executed */\n             if (has_nonlocal_exits(body)) {\n                 loop_postcond = empty_poststate(num_local_vars);\n             }\n \n-            set_pre_and_post(a, \n-              rec(precondition=seq_preconds(enclosing,\n-                                            [block_pp(body),\n-                                                expr_pp(test)]),\n-                  postcondition=loop_postcond));\n+            log \"777\";\n+            set_pre_and_post(fcx.ccx, a, \n+              seq_preconds(enclosing,\n+                           [block_pp(fcx.ccx, body),\n+                            expr_pp(fcx.ccx, test)]),\n+              loop_postcond);\n         }\n         case (expr_for(?d, ?index, ?body, ?a)) {\n             find_pre_post_loop(fcx, d, index, body, a);\n@@ -487,65 +498,67 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             find_pre_post_expr(fcx, e);\n             fn do_an_alt(&fn_ctxt fcx, &arm an_alt) -> pre_and_post {\n                 find_pre_post_block(fcx, an_alt.block);\n-                ret block_pp(an_alt.block);\n+                ret block_pp(fcx.ccx, an_alt.block);\n             }\n             auto f = bind do_an_alt(fcx, _);\n             auto alt_pps = vec::map[arm, pre_and_post](f, alts);\n             fn combine_pp(pre_and_post antec, \n                           fn_info enclosing, &pre_and_post pp,\n                           &pre_and_post next) -> pre_and_post {\n+                log \"777\";\n                 union(pp.precondition, seq_preconds(enclosing,\n                                                     [antec, next]));\n                 intersect(pp.postcondition, next.postcondition);\n                 ret pp;\n             }\n-            auto antec_pp = pp_clone(expr_pp(e)); \n-            auto e_pp  = rec(precondition=empty_prestate(num_local_vars),\n+            auto antec_pp = pp_clone(expr_pp(fcx.ccx, e)); \n+            auto e_pp  = @rec(precondition=empty_prestate(num_local_vars),\n                              postcondition=false_postcond(num_local_vars));\n             auto g = bind combine_pp(antec_pp, fcx.enclosing, _, _);\n \n             auto alts_overall_pp = vec::foldl[pre_and_post, pre_and_post]\n                                     (g, e_pp, alt_pps);\n \n-            set_pre_and_post(a, alts_overall_pp);\n+            set_pre_and_post(fcx.ccx, a, alts_overall_pp.precondition,\n+                             alts_overall_pp.postcondition);\n         }\n         case (expr_field(?operator, _, ?a)) {\n             find_pre_post_expr(fcx, operator);\n-            set_pre_and_post(a, expr_pp(operator));\n+            copy_pre_post(fcx.ccx, a, operator);\n         }\n         case (expr_fail(?a)) {\n-            set_pre_and_post(a,\n+            set_pre_and_post(fcx.ccx, a,\n                              /* if execution continues after fail,\n                                 then everything is true! */\n-               rec(precondition=empty_prestate(num_local_vars),\n-                   postcondition=false_postcond(num_local_vars)));\n+               empty_prestate(num_local_vars),\n+               false_postcond(num_local_vars));\n         }\n         case (expr_assert(?p, ?a)) {\n             find_pre_post_expr(fcx, p);\n-            set_pre_and_post(a, expr_pp(p));\n+            copy_pre_post(fcx.ccx, a, p);\n         }\n         case (expr_check(?p, ?a)) {\n             /* will need to change when we support arbitrary predicates... */\n             find_pre_post_expr(fcx, p);\n-            set_pre_and_post(a, expr_pp(p));\n+            copy_pre_post(fcx.ccx, a, p);\n         }\n         case(expr_bind(?operator, ?maybe_args, ?a)) {\n             auto args = vec::cat_options[@expr](maybe_args);\n             vec::push[@expr](args, operator); /* ??? order of eval? */\n             find_pre_post_exprs(fcx, args, a);\n         }\n         case (expr_break(?a)) {\n-            set_pre_and_post(a, empty_pre_post(num_local_vars));\n+            clear_pp(expr_pp(fcx.ccx, e));\n         }\n         case (expr_cont(?a)) {\n-            set_pre_and_post(a, empty_pre_post(num_local_vars));\n+            clear_pp(expr_pp(fcx.ccx, e));\n         }\n         case (expr_port(?a)) {\n-            set_pre_and_post(a, empty_pre_post(num_local_vars));\n+            clear_pp(expr_pp(fcx.ccx, e));\n         }\n         case (expr_ext(_, _, _, ?expanded, ?a)) {\n             find_pre_post_expr(fcx, expanded);\n-            set_pre_and_post(a, expr_pp(expanded));\n+            copy_pre_post(fcx.ccx, a, expanded);\n         }\n     }\n }\n@@ -565,12 +578,11 @@ fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s)\n                     alt(alocal.init) {\n                         case(some[initializer](?an_init)) {\n                             find_pre_post_expr(fcx, an_init.expr);\n-                            auto rhs_pp = expr_pp(an_init.expr);\n-                            set_pre_and_post(alocal.ann, rhs_pp);\n+                            copy_pre_post(fcx.ccx, alocal.ann, an_init.expr);\n \n                             /* Inherit ann from initializer, and add var being\n                                initialized to the postcondition */\n-                            set_pre_and_post(a, rhs_pp);\n+                            copy_pre_post(fcx.ccx, a, an_init.expr);\n                             /*  log(\"gen (decl):\");\n                                 log_stmt(s); */\n                             gen(fcx, a, alocal.id); \n@@ -580,22 +592,21 @@ fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s)\n                                                    log_pp(stmt_pp(s)); */\n                         }\n                         case(none[initializer]) {\n-                            auto pp = empty_pre_post(num_local_vars);\n-                            set_pre_and_post(alocal.ann, pp);\n-                            set_pre_and_post(a, pp);\n+                            clear_pp(ann_to_ts_ann(fcx.ccx,\n+                                                   alocal.ann).conditions);\n+                            clear_pp(ann_to_ts_ann(fcx.ccx, a).conditions);\n                         }\n                     }\n                 }\n                 case(decl_item(?anitem)) {\n-                    auto pp = empty_pre_post(num_local_vars);\n-                    set_pre_and_post(a, pp);\n+                    clear_pp(ann_to_ts_ann(fcx.ccx, a).conditions);\n                     find_pre_post_item(fcx.ccx, *anitem);\n                 }\n             }\n         }\n         case(stmt_expr(?e,?a)) {\n             find_pre_post_expr(fcx, e);\n-            set_pre_and_post(a, expr_pp(e));\n+            copy_pre_post(fcx.ccx, a, e);\n         }    \n     }\n }\n@@ -624,7 +635,7 @@ fn find_pre_post_block(&fn_ctxt fcx, block b) -> () {\n         log(\"pre_post for stmt:\");\n         log_stmt(*s);\n         log(\"is:\");\n-        log_pp(stmt_pp(*s));\n+        log_pp(stmt_pp(fcx.ccx, *s));\n     }\n     auto do_one = bind do_one_(fcx, _);\n     \n@@ -637,15 +648,15 @@ fn find_pre_post_block(&fn_ctxt fcx, block b) -> () {\n \n     let vec[pre_and_post] pps = [];\n \n-    fn get_pp_stmt(&@stmt s) -> pre_and_post {\n-        ret stmt_pp(*s);\n+    fn get_pp_stmt(crate_ctxt ccx, &@stmt s) -> pre_and_post {\n+        ret stmt_pp(ccx, *s);\n     }\n-    auto f = get_pp_stmt;\n+    auto f = bind get_pp_stmt(fcx.ccx,_);\n     pps += vec::map[@stmt, pre_and_post](f, b.node.stmts);\n-    fn get_pp_expr(&@expr e) -> pre_and_post {\n-        ret expr_pp(e);\n+    fn get_pp_expr(crate_ctxt ccx, &@expr e) -> pre_and_post {\n+        ret expr_pp(ccx, e);\n     }\n-    auto g = get_pp_expr;\n+    auto g = bind get_pp_expr(fcx.ccx, _);\n     plus_option[pre_and_post](pps,\n        option::map[@expr, pre_and_post](g, b.node.expr));\n \n@@ -661,8 +672,7 @@ fn find_pre_post_block(&fn_ctxt fcx, block b) -> () {\n         block_postcond = union_postconds(nv, postconds);\n     }\n \n-    set_pre_and_post(b.node.a, rec(precondition=block_precond,\n-                                   postcondition=block_postcond));\n+    set_pre_and_post(fcx.ccx, b.node.a, block_precond, block_postcond);\n }\n \n fn find_pre_post_fn(&fn_ctxt fcx, &_fn f) -> () {"}, {"sha": "9c0ca53410e994bf0ae7739262c51b32816cc832", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 207, "deletions": 185, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/e16b097599ee73a909df7ffbbaaf30f25a7057e3/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16b097599ee73a909df7ffbbaaf30f25a7057e3/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=e16b097599ee73a909df7ffbbaaf30f25a7057e3", "patch": "@@ -17,7 +17,6 @@ import tstate::ann::empty_poststate;\n import tstate::ann::require_and_preserve;\n import tstate::ann::union;\n import tstate::ann::intersect;\n-import tstate::ann::pp_clone;\n import tstate::ann::empty_prestate;\n import tstate::ann::prestate;\n import tstate::ann::poststate;\n@@ -181,7 +180,7 @@ fn seq_states(&fn_ctxt fcx, prestate pres, vec[@expr] exprs)\n \n   for (@expr e in exprs) {\n     changed = find_pre_post_state_expr(fcx, post, e) || changed;\n-    post = expr_poststate(e);\n+    post = expr_poststate(fcx.ccx, e);\n   }\n \n   ret tup(changed, post);\n@@ -191,8 +190,8 @@ fn find_pre_post_state_exprs(&fn_ctxt fcx, &prestate pres,\n                              &ann a, &vec[@expr] es) -> bool {\n     auto res = seq_states(fcx, pres, es);\n     auto changed = res._0;\n-    changed = extend_prestate_ann(a, pres) || changed;\n-    changed = extend_poststate_ann(a, res._1) || changed;\n+    changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+    changed = extend_poststate_ann(fcx.ccx, a, res._1) || changed;\n     ret changed;\n }\n \n@@ -201,16 +200,16 @@ fn find_pre_post_state_loop(&fn_ctxt fcx, prestate pres, &@decl d,\n     auto changed = false;\n \n     /* same issues as while */\n-    changed = extend_prestate_ann(a, pres) || changed;\n+    changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n     changed = find_pre_post_state_expr(fcx, pres, index) || changed;\n     /* in general, would need the intersection of\n        (poststate of index, poststate of body) */\n-    changed = find_pre_post_state_block(fcx, expr_poststate(index), body)\n-                || changed;\n-    auto res_p = intersect_postconds([expr_poststate(index),\n-                                         block_poststate(body)]);\n+    changed = find_pre_post_state_block(fcx,\n+                expr_poststate(fcx.ccx, index), body) || changed;\n+    auto res_p = intersect_postconds([expr_poststate(fcx.ccx, index),\n+                                         block_poststate(fcx.ccx, body)]);\n   \n-    changed = extend_poststate_ann(a, res_p) || changed;\n+    changed = extend_poststate_ann(fcx.ccx, a, res_p) || changed;\n     ret changed;\n }\n \n@@ -245,83 +244,85 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         || changed;\n       /* rands go left-to-right */\n       changed = find_pre_post_state_exprs(fcx,\n-                                    expr_poststate(operator), a, operands)\n-          || changed;\n+                  expr_poststate(fcx.ccx, operator), a, operands) || changed;\n       /* if this is a failing call, it sets the return value */\n        alt (controlflow_expr(fcx.ccx, operator)) {\n           case (noreturn) {\n-\t    /*\n-\t    log_err(\"Call that might fail! to\");\n-\t    log_expr_err(*operator);\n-\t    */\n-\t    changed = gen_poststate(fcx, a, fcx.id) || changed;\n+            /*\n+            log_err(\"Call that might fail! to\");\n+            log_expr_err(*operator);\n+            */\n+            changed = gen_poststate(fcx, a, fcx.id) || changed;\n           }\n           case (_) { \n-\t    /*\t    log_err(\"non-failing call, to:\");\n-\t    log_expr_err(*operator);\n-\t    */\n-\t  }\n+            /*      log_err(\"non-failing call, to:\");\n+            log_expr_err(*operator);\n+            */\n+          }\n       }\n       ret changed;\n     }\n     case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n         changed = find_pre_post_state_expr(fcx, pres, operator);\n         ret(find_pre_post_state_exprs(fcx,\n-                 expr_poststate(operator), a, operands)\n+                 expr_poststate(fcx.ccx, operator), a, operands)\n           || changed);\n     }\n     case (expr_bind(?operator, ?maybe_args, ?a)) {\n         changed = find_pre_post_state_expr(fcx, pres, operator)\n             || changed;\n         ret (find_pre_post_state_exprs(fcx,\n-          expr_poststate(operator), a, cat_options[@expr](maybe_args))\n-            || changed);\n+          expr_poststate(fcx.ccx, operator), a,\n+             cat_options[@expr](maybe_args)) || changed);\n     }\n     case (expr_path(_,?a)) {\n-      ret pure_exp(a, pres);\n+      ret pure_exp(fcx.ccx, a, pres);\n     }\n     case (expr_log(_,?e,?a)) {\n         /* factor out the \"one exp\" pattern */\n         changed = find_pre_post_state_expr(fcx, pres, e);\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(e)) || changed;\n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        changed = extend_poststate_ann(fcx.ccx, a,\n+                    expr_poststate(fcx.ccx, e)) || changed;\n         ret changed;\n     }\n     case (expr_chan(?e, ?a)) {\n         changed = find_pre_post_state_expr(fcx, pres, e);\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(e)) || changed;\n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        changed = extend_poststate_ann(fcx.ccx, a,\n+                    expr_poststate(fcx.ccx, e)) || changed;\n         ret changed;\n     }\n     case (expr_ext(_, _, _, ?expanded, ?a)) {\n         changed = find_pre_post_state_expr(fcx, pres, expanded);\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(expanded))\n-           || changed;\n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        changed = extend_poststate_ann(fcx.ccx, a,\n+                    expr_poststate(fcx.ccx, expanded)) || changed;\n         ret changed;\n     }\n     case (expr_put(?maybe_e, ?a)) {\n         alt (maybe_e) {\n             case (some[@expr](?arg)) {\n                 changed = find_pre_post_state_expr(fcx, pres, arg);\n-                changed = extend_prestate_ann(a, pres) || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(arg))\n-                    || changed;\n+                changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+                changed = extend_poststate_ann(fcx.ccx, a,\n+                            expr_poststate(fcx.ccx, arg)) || changed;\n                 ret changed;\n             }\n             case (none[@expr]) {\n-                ret pure_exp(a, pres);\n+                ret pure_exp(fcx.ccx, a, pres);\n             }\n         }\n     }\n     case (expr_lit(?l,?a)) {\n-        ret pure_exp(a, pres);\n+        ret pure_exp(fcx.ccx, a, pres);\n     }\n     case (expr_block(?b,?a)) {\n         changed = find_pre_post_state_block(fcx, pres, b)\n            || changed;\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, block_poststate(b)) || changed;\n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        changed = extend_poststate_ann(fcx.ccx, a,\n+                    block_poststate(fcx.ccx, b)) || changed;\n         ret changed;\n     }\n     case (expr_rec(?fields,?maybe_base,?a)) {\n@@ -332,66 +333,66 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             case (some[@expr](?base)) {\n                 changed = find_pre_post_state_expr(fcx, pres, base)\n                     || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(base))\n-                    || changed;\n+                changed = extend_poststate_ann(fcx.ccx, a,\n+                            expr_poststate(fcx.ccx, base)) || changed;\n             }\n         }\n         ret changed;\n     }\n     case (expr_assign(?lhs, ?rhs, ?a)) {\n-        extend_prestate_ann(a, pres);\n+        extend_prestate_ann(fcx.ccx, a, pres);\n \n         alt (lhs.node) {\n             case (expr_path(?p, ?a_lhs)) {\n                 // assignment to local var\n-                changed = pure_exp(a_lhs, pres) || changed;\n+                changed = pure_exp(fcx.ccx, a_lhs, pres) || changed;\n                 changed = find_pre_post_state_expr(fcx, pres, rhs)\n                     || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(rhs))\n-                    || changed;\n+                changed = extend_poststate_ann(fcx.ccx, a,\n+                            expr_poststate(fcx.ccx, rhs)) || changed;\n                 changed = gen_if_local(fcx, a_lhs, a)|| changed;\n             }\n             case (_) {\n                 // assignment to something that must already have been init'd\n                 changed = find_pre_post_state_expr(fcx, pres, lhs)\n                     || changed;\n                 changed = find_pre_post_state_expr(fcx,\n-                     expr_poststate(lhs), rhs) || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(rhs))\n-                    || changed;\n+                     expr_poststate(fcx.ccx, lhs), rhs) || changed;\n+                changed = extend_poststate_ann(fcx.ccx, a,\n+                            expr_poststate(fcx.ccx, rhs)) || changed;\n             }\n         }\n         ret changed;\n     }\n     case (expr_recv(?lhs, ?rhs, ?a)) {\n-        extend_prestate_ann(a, pres);\n+        extend_prestate_ann(fcx.ccx, a, pres);\n \n         alt (lhs.node) {\n             case (expr_path(?p, ?a_lhs)) {\n                 // receive to local var\n-                changed = pure_exp(a_lhs, pres) || changed;\n+                changed = pure_exp(fcx.ccx, a_lhs, pres) || changed;\n                 changed = find_pre_post_state_expr(fcx, pres, rhs)\n                     || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(rhs))\n-                    || changed;\n+                changed = extend_poststate_ann(fcx.ccx, a,\n+                            expr_poststate(fcx.ccx, rhs)) || changed;\n                 changed = gen_if_local(fcx, a_lhs, a) || changed;\n             }\n             case (_) {\n                 // receive to something that must already have been init'd\n                 changed = find_pre_post_state_expr(fcx, pres, lhs)\n                     || changed;\n                 changed = find_pre_post_state_expr(fcx,\n-                     expr_poststate(lhs), rhs) || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(rhs))\n-                    || changed;\n+                     expr_poststate(fcx.ccx, lhs), rhs) || changed;\n+                changed = extend_poststate_ann(fcx.ccx, a,\n+                            expr_poststate(fcx.ccx, rhs)) || changed;\n             }\n         }\n         ret changed;\n     }\n \n     case (expr_ret(?maybe_ret_val, ?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        set_poststate_ann(a, false_postcond(num_local_vars));\n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        set_poststate_ann(fcx.ccx, a, false_postcond(num_local_vars));\n         alt(maybe_ret_val) {\n             case (none[@expr]) { /* do nothing */ }\n             case (some[@expr](?ret_val)) {\n@@ -402,70 +403,75 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         ret changed;\n     }\n     case (expr_be(?e, ?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        set_poststate_ann(a, false_postcond(num_local_vars));\n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        set_poststate_ann(fcx.ccx, a, false_postcond(num_local_vars));\n         changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n         ret changed;\n     }\n     case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n         changed = find_pre_post_state_expr(fcx, pres, antec)\n             || changed;\n         changed = find_pre_post_state_block(fcx,\n-          expr_poststate(antec), conseq) || changed;\n+          expr_poststate(fcx.ccx, antec), conseq) || changed;\n         alt (maybe_alt) {\n             case (none[@expr]) {\n-                changed = extend_poststate_ann(a, expr_poststate(antec))\n-                    || changed;\n+                changed = extend_poststate_ann(fcx.ccx, a,\n+                            expr_poststate(fcx.ccx, antec)) || changed;\n             }\n             case (some[@expr](?altern)) {\n                 changed = find_pre_post_state_expr(fcx,\n-                   expr_poststate(antec), altern) || changed;\n+                   expr_poststate(fcx.ccx, antec), altern) || changed;\n                 auto poststate_res = intersect_postconds\n-                    ([block_poststate(conseq), expr_poststate(altern)]);\n-                changed = extend_poststate_ann(a, poststate_res) || changed;\n+                    ([block_poststate(fcx.ccx, conseq),\n+                      expr_poststate(fcx.ccx, altern)]);\n+                changed = extend_poststate_ann(fcx.ccx, a, poststate_res)\n+                            || changed;\n             }\n         }\n         log(\"if:\");\n         log_expr(*e);\n         log(\"new prestate:\");\n         log_bitv(fcx.enclosing, pres);\n         log(\"new poststate:\");\n-        log_bitv(fcx.enclosing, expr_poststate(e));\n+        log_bitv(fcx.enclosing, expr_poststate(fcx.ccx, e));\n \n         ret changed;\n     }\n     case (expr_binary(?bop, ?l, ?r, ?a)) {\n         /* FIXME: what if bop is lazy? */\n-        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n         changed = find_pre_post_state_expr(fcx, pres, l)\n                     || changed;\n-        changed = find_pre_post_state_expr(fcx, expr_poststate(l), r)\n+        changed = find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, l), r)\n                     || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(r)) || changed;\n+        changed = extend_poststate_ann(fcx.ccx, a,\n+                    expr_poststate(fcx.ccx, r)) || changed;\n         ret changed;\n     }\n     case (expr_send(?l, ?r, ?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n         changed = find_pre_post_state_expr(fcx, pres, l)\n                     || changed;\n-        changed = find_pre_post_state_expr(fcx, expr_poststate(l), r)\n+        changed = find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, l), r)\n                     || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(r)) || changed;\n+        changed = extend_poststate_ann(fcx.ccx, a,\n+                    expr_poststate(fcx.ccx, r)) || changed;\n         ret changed;\n     }\n     case (expr_assign_op(?op, ?lhs, ?rhs, ?a)) {\n         /* quite similar to binary -- should abstract this */\n-        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n         changed = find_pre_post_state_expr(fcx, pres, lhs)\n                     || changed;\n-        changed = find_pre_post_state_expr(fcx, expr_poststate(lhs), rhs)\n-                    || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(rhs)) || changed;\n+        changed = find_pre_post_state_expr(fcx,\n+                    expr_poststate(fcx.ccx, lhs), rhs) || changed;\n+        changed = extend_poststate_ann(fcx.ccx, a,\n+                    expr_poststate(fcx.ccx, rhs)) || changed;\n         ret changed;\n     }\n     case (expr_while(?test, ?body, ?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n         /* to handle general predicates, we need to pass in\n             pres `intersect` (poststate(a)) \n          like: auto test_pres = intersect_postconds(pres, expr_postcond(a));\n@@ -476,30 +482,30 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         */\n         changed = find_pre_post_state_expr(fcx, pres, test)\n             || changed;\n-        changed = find_pre_post_state_block(fcx, expr_poststate(test), body)\n-                    || changed; \n-        changed = extend_poststate_ann(a,\n-                    intersect_postconds([expr_poststate(test),\n-                                        block_poststate(body)])) || changed;\n+        changed = find_pre_post_state_block(fcx,\n+                    expr_poststate(fcx.ccx, test), body) || changed; \n+        changed = extend_poststate_ann(fcx.ccx, a,\n+                    intersect_postconds([expr_poststate(fcx.ccx, test),\n+                      block_poststate(fcx.ccx, body)])) || changed;\n         ret changed;\n     }\n     case (expr_do_while(?body, ?test, ?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n         changed = find_pre_post_state_block(fcx, pres, body)\n             || changed;\n         changed = find_pre_post_state_expr(fcx,\n-                     block_poststate(body), test) || changed;\n+                     block_poststate(fcx.ccx, body), test) || changed;\n \n         /* conservative approximination: if the body of the loop\n            could break or cont, we revert to the prestate\n            (TODO: could treat cont differently from break, since\n            if there's a cont, the test will execute) */\n         if (has_nonlocal_exits(body)) {\n-            changed = set_poststate_ann(a, pres) || changed;\n+            changed = set_poststate_ann(fcx.ccx, a, pres) || changed;\n         }\n         else {\n-            changed = extend_poststate_ann(a, expr_poststate(test))\n-              || changed;\n+            changed = extend_poststate_ann(fcx.ccx, a,\n+                        expr_poststate(fcx.ccx, test)) || changed;\n         }\n \n         ret changed;\n@@ -511,155 +517,160 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         ret find_pre_post_state_loop(fcx, pres, d, index, body, a);\n     }\n     case (expr_index(?e, ?sub, ?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed; \n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed; \n         changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n         changed = find_pre_post_state_expr(fcx,\n-                     expr_poststate(e), sub) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(sub));\n+                     expr_poststate(fcx.ccx, e), sub) || changed;\n+        changed = extend_poststate_ann(fcx.ccx, a,\n+                                       expr_poststate(fcx.ccx, sub));\n         ret changed;\n     }\n     case (expr_alt(?e, ?alts, ?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed; \n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed; \n         changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n-        auto e_post = expr_poststate(e);\n+        auto e_post = expr_poststate(fcx.ccx, e);\n         auto a_post;\n         if (vec::len[arm](alts) > 0u) {\n             a_post = false_postcond(num_local_vars);\n             for (arm an_alt in alts) {\n                 changed = find_pre_post_state_block(fcx, e_post,\n                                                     an_alt.block) || changed;\n-                changed = intersect(a_post, block_poststate(an_alt.block))\n-                    || changed; \n+                changed = intersect(a_post,\n+                            block_poststate(fcx.ccx,\n+                                            an_alt.block)) || changed; \n             }\n         }\n         else {\n             // No alts; poststate is the poststate of the test\n             a_post = e_post;\n         }\n-        changed = extend_poststate_ann(a, a_post);\n+        changed = extend_poststate_ann(fcx.ccx, a, a_post);\n         ret changed;\n     }\n     case (expr_field(?e, _, ?a)) {\n         changed = find_pre_post_state_expr(fcx, pres, e);\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(e)) || changed;\n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        changed = extend_poststate_ann(fcx.ccx, a,\n+                    expr_poststate(fcx.ccx, e)) || changed;\n         ret changed;\n     }\n     case (expr_unary(_,?operand,?a)) {\n         changed = find_pre_post_state_expr(fcx, pres, operand)\n           || changed;\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(operand))\n-          || changed;\n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        changed = extend_poststate_ann(fcx.ccx, a,\n+                    expr_poststate(fcx.ccx, operand)) || changed;\n         ret changed;\n     }\n     case (expr_cast(?operand, _, ?a)) {\n            changed = find_pre_post_state_expr(fcx, pres, operand)\n           || changed;\n-        changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(operand))\n-          || changed;\n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        changed = extend_poststate_ann(fcx.ccx, a,\n+                    expr_poststate(fcx.ccx, operand)) || changed;\n         ret changed;\n     }\n     case (expr_fail(?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n         /* if execution continues after fail, then everything is true! woo! */\n-        changed = set_poststate_ann(a, false_postcond(num_local_vars))\n-          || changed;\n+        changed = set_poststate_ann(fcx.ccx, a,\n+                    false_postcond(num_local_vars)) || changed;\n         ret changed;\n     }\n     case (expr_assert(?p, ?a)) {\n-        ret pure_exp(a, pres);\n+        ret pure_exp(fcx.ccx, a, pres);\n     }\n     case (expr_check(?p, ?a)) {\n-        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n         changed = find_pre_post_state_expr(fcx, pres, p) || changed;\n         /* FIXME: update the postcondition to reflect that p holds */\n-        changed = extend_poststate_ann(a, pres) || changed;\n+        changed = extend_poststate_ann(fcx.ccx, a, pres) || changed;\n         ret changed;\n     }\n     case (expr_break(?a)) {\n-        ret pure_exp(a, pres);\n+        ret pure_exp(fcx.ccx, a, pres);\n     }\n     case (expr_cont(?a)) {\n-        ret pure_exp(a, pres);\n+        ret pure_exp(fcx.ccx, a, pres);\n     }\n     case (expr_port(?a)) {\n-        ret pure_exp(a, pres);\n+        ret pure_exp(fcx.ccx, a, pres);\n     }\n     case (expr_self_method(_, ?a)) {\n-        ret pure_exp(a, pres);\n+        ret pure_exp(fcx.ccx, a, pres);\n     }\n   }\n }\n \n fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n-  auto changed = false;\n-  auto stmt_ann_ = stmt_to_ann(*s);\n-  assert (!is_none[@ts_ann](stmt_ann_));\n-  auto stmt_ann = *(get[@ts_ann](stmt_ann_));\n-              log(\"*At beginning: stmt = \");\n-              log_stmt(*s);\n-              log(\"*prestate = \");\n-              log(bitv::to_str(stmt_ann.states.prestate));\n-              log(\"*poststate =\");\n-              log(bitv::to_str(stmt_ann.states.poststate));\n-              log(\"*changed =\");\n-              log(changed);\n+    auto changed = false;\n+    auto stmt_ann = stmt_to_ann(fcx.ccx, *s);\n+ \n+    log(\"*At beginning: stmt = \");\n+    log_stmt(*s);\n+    log(\"*prestate = \");\n+    log(bitv::to_str(stmt_ann.states.prestate));\n+    log(\"*poststate =\");\n+    log(bitv::to_str(stmt_ann.states.poststate));\n+    log(\"*changed =\");\n+    log(changed);\n   \n-  alt (s.node) {\n-    case (stmt_decl(?adecl, ?a)) {\n-      alt (adecl.node) {\n-        case (decl_local(?alocal)) {\n-          alt (alocal.init) {\n-            case (some[initializer](?an_init)) {\n-                changed = extend_prestate(stmt_ann.states.prestate, pres)\n-                    || changed;\n-                changed = find_pre_post_state_expr\n-                    (fcx, pres, an_init.expr) || changed;\n-                changed = extend_poststate(stmt_ann.states.poststate,\n-                                           expr_poststate(an_init.expr))\n-                    || changed;\n-                changed = gen_poststate(fcx, a, alocal.id)\n-                            || changed;\n-              log(\"Summary: stmt = \");\n-              log_stmt(*s);\n-              log(\"prestate = \");\n-              log(bitv::to_str(stmt_ann.states.prestate));\n-              log_bitv(fcx.enclosing, stmt_ann.states.prestate);\n-              log(\"poststate =\");\n-              log_bitv(fcx.enclosing, stmt_ann.states.poststate);\n-              log(\"changed =\");\n-              log(changed);\n+    alt (s.node) {\n+        case (stmt_decl(?adecl, ?a)) {\n+            alt (adecl.node) {\n+                case (decl_local(?alocal)) {\n+                    alt (alocal.init) {\n+                        case (some[initializer](?an_init)) {\n+                            changed = extend_prestate\n+                                (stmt_ann.states.prestate, pres) || changed;\n+                            changed = find_pre_post_state_expr\n+                                (fcx, pres, an_init.expr) || changed;\n+                            changed = extend_poststate\n+                                (stmt_ann.states.poststate,\n+                                 expr_poststate(fcx.ccx, an_init.expr))\n+                                || changed;\n+                            changed = gen_poststate(fcx, a, alocal.id)\n+                                || changed;\n+                            log(\"Summary: stmt = \");\n+                            log_stmt(*s);\n+                            log(\"prestate = \");\n+                            log(bitv::to_str(stmt_ann.states.prestate));\n+                            log_bitv(fcx.enclosing, stmt_ann.states.prestate);\n+                            log(\"poststate =\");\n+                            log_bitv(fcx.enclosing,\n+                                     stmt_ann.states.poststate);\n+                            log(\"changed =\");\n+                            log(changed);\n   \n-              ret changed;\n-            }\n-            case (none[initializer]) {\n-              changed = extend_prestate(stmt_ann.states.prestate, pres)\n-                  || changed;\n-              changed = extend_poststate(stmt_ann.states.poststate, pres)\n-                  || changed;\n-              ret changed;\n+                            ret changed;\n+                        }\n+                        case (none[initializer]) {\n+                            changed = extend_prestate\n+                                (stmt_ann.states.prestate, pres) || changed;\n+                            changed = extend_poststate\n+                                (stmt_ann.states.poststate, pres) || changed;\n+                            ret changed;\n+                        }\n+                    }\n+                }\n+                case (decl_item(?an_item)) {\n+                    changed = extend_prestate(stmt_ann.states.prestate, pres)\n+                        || changed;\n+                    changed = extend_poststate(stmt_ann.states.poststate,\n+                                pres) || changed;\n+                    ret (find_pre_post_state_item(fcx, an_item) || changed);\n+                }\n             }\n-          }\n         }\n-        case (decl_item(?an_item)) {\n-            changed = extend_prestate(stmt_ann.states.prestate, pres)\n-               || changed;\n-            changed = extend_poststate(stmt_ann.states.poststate, pres)\n-               || changed;\n-            ret (find_pre_post_state_item(fcx, an_item) || changed);\n-        }\n-      }\n-    }\n-    case (stmt_expr(?e, _)) {\n-      changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n-      changed = extend_prestate(stmt_ann.states.prestate, expr_prestate(e))\n-          || changed;\n-      changed = extend_poststate(stmt_ann.states.poststate,\n-                                 expr_poststate(e)) || changed;\n-      /*\n-                    log(\"Summary: stmt = \");\n+        case (stmt_expr(?e, _)) {\n+            changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n+            changed = extend_prestate(stmt_ann.states.prestate,\n+                                      expr_prestate(fcx.ccx, e))\n+                || changed;\n+            changed = extend_poststate(stmt_ann.states.poststate,\n+                                       expr_poststate(fcx.ccx, e)) || changed;\n+            /*\n+              log(\"Summary: stmt = \");\n               log_stmt(*s);\n               log(\"prestate = \");\n               log(bitv::to_str(stmt_ann.states.prestate));\n@@ -669,11 +680,11 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n               log_bitv(enclosing, stmt_ann.states.poststate);\n               log(\"changed =\");\n               log(changed);\n-      */\n-      ret changed;\n+            */\n+            ret changed;\n+        }\n+        case (_) { ret false; }\n     }\n-    case (_) { ret false; }\n-  }\n }\n \n /* Updates the pre- and post-states of statements in the block,\n@@ -692,7 +703,7 @@ fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &block b)\n   Then <pres> becomes the new poststate. */ \n   for (@stmt s in b.node.stmts) {\n     changed = find_pre_post_state_stmt(fcx, pres, s) || changed;\n-    pres = stmt_poststate(*s, num_local_vars);\n+    pres = stmt_poststate(fcx.ccx, *s);\n   }\n \n   auto post = pres;\n@@ -701,7 +712,7 @@ fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &block b)\n     case (none[@expr]) {}\n     case (some[@expr](?e)) {\n       changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n-      post = expr_poststate(e);\n+      post = expr_poststate(fcx.ccx, e);\n     }\n   }\n \n@@ -718,13 +729,13 @@ fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &block b)\n       post = pres0;\n   }\n   \n-  set_prestate_ann(b.node.a, pres0);\n-  set_poststate_ann(b.node.a, post);\n+  set_prestate_ann(fcx.ccx, b.node.a, pres0);\n+  set_poststate_ann(fcx.ccx, b.node.a, post);\n \n   log(\"For block:\");\n   log_block(b);\n   log(\"poststate = \");\n-  log_states(block_states(b));\n+  log_states(block_states(fcx.ccx, b));\n   log(\"pres0:\");\n   log_bitv(fcx.enclosing, pres0);\n   log(\"post:\");\n@@ -785,3 +796,14 @@ fn find_pre_post_state_item(&fn_ctxt fcx, @item i) -> bool {\n         }\n     }\n }\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//\n+"}, {"sha": "b2f07fa2d38763c560e89915728cee05c833ce1a", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e16b097599ee73a909df7ffbbaaf30f25a7057e3/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16b097599ee73a909df7ffbbaaf30f25a7057e3/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=e16b097599ee73a909df7ffbbaaf30f25a7057e3", "patch": "@@ -114,7 +114,7 @@ fn clear(&t v) {\n }\n \n fn set_all(&t v) {\n-    for each (uint i in _uint::range(0u, v.nbits)) {\n+    for each (uint i in uint::range(0u, v.nbits)) {\n         set(v, i, true);\n     }\n }"}]}