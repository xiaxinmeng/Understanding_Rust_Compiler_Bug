{"sha": "e36b62873fb6787d521fbc4e0bd89915e28ed0f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNmI2Mjg3M2ZiNjc4N2Q1MjFmYmM0ZTBiZDg5OTE1ZTI4ZWQwZjE=", "commit": {"author": {"name": "Nicole Mazzuca", "email": "npmazzuca@gmail.com", "date": "2018-12-18T00:41:48Z"}, "committer": {"name": "Nicole Mazzuca", "email": "npmazzuca@gmail.com", "date": "2018-12-18T00:41:48Z"}, "message": "rename div_euc -> div_euclid, and mod_euc -> rem_euclid\n\nlogic is written up in https://github.com/rust-lang/rust/issues/49048\n\nAlso, update the documentation slightly", "tree": {"sha": "6c447787612b328385d1daf73977fae35c3052c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c447787612b328385d1daf73977fae35c3052c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e36b62873fb6787d521fbc4e0bd89915e28ed0f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e36b62873fb6787d521fbc4e0bd89915e28ed0f1", "html_url": "https://github.com/rust-lang/rust/commit/e36b62873fb6787d521fbc4e0bd89915e28ed0f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e36b62873fb6787d521fbc4e0bd89915e28ed0f1/comments", "author": {"login": "ubsan", "id": 60298436, "node_id": "MDQ6VXNlcjYwMjk4NDM2", "avatar_url": "https://avatars.githubusercontent.com/u/60298436?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubsan", "html_url": "https://github.com/ubsan", "followers_url": "https://api.github.com/users/ubsan/followers", "following_url": "https://api.github.com/users/ubsan/following{/other_user}", "gists_url": "https://api.github.com/users/ubsan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubsan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubsan/subscriptions", "organizations_url": "https://api.github.com/users/ubsan/orgs", "repos_url": "https://api.github.com/users/ubsan/repos", "events_url": "https://api.github.com/users/ubsan/events{/privacy}", "received_events_url": "https://api.github.com/users/ubsan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ubsan", "id": 60298436, "node_id": "MDQ6VXNlcjYwMjk4NDM2", "avatar_url": "https://avatars.githubusercontent.com/u/60298436?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubsan", "html_url": "https://github.com/ubsan", "followers_url": "https://api.github.com/users/ubsan/followers", "following_url": "https://api.github.com/users/ubsan/following{/other_user}", "gists_url": "https://api.github.com/users/ubsan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubsan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubsan/subscriptions", "organizations_url": "https://api.github.com/users/ubsan/orgs", "repos_url": "https://api.github.com/users/ubsan/repos", "events_url": "https://api.github.com/users/ubsan/events{/privacy}", "received_events_url": "https://api.github.com/users/ubsan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54f3cd6873149a00ae0fb7723f200dccbb4baaa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/54f3cd6873149a00ae0fb7723f200dccbb4baaa9", "html_url": "https://github.com/rust-lang/rust/commit/54f3cd6873149a00ae0fb7723f200dccbb4baaa9"}], "stats": {"total": 262, "additions": 141, "deletions": 121}, "files": [{"sha": "cedee1c8e5f99736110e2967aba24fb516d7a663", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 96, "deletions": 76, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/e36b62873fb6787d521fbc4e0bd89915e28ed0f1/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36b62873fb6787d521fbc4e0bd89915e28ed0f1/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=e36b62873fb6787d521fbc4e0bd89915e28ed0f1", "patch": "@@ -673,7 +673,7 @@ $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Checked Euclidean division. Computes `self.div_euc(rhs)`,\n+            concat!(\"Checked Euclidean division. Computes `self.div_euclid(rhs)`,\n returning `None` if `rhs == 0` or the division results in overflow.\n \n # Examples\n@@ -683,17 +683,17 @@ Basic usage:\n ```\n #![feature(euclidean_division)]\n assert_eq!((\", stringify!($SelfT),\n-\"::min_value() + 1).checked_div_euc(-1), Some(\", stringify!($Max), \"));\n-assert_eq!(\", stringify!($SelfT), \"::min_value().checked_div_euc(-1), None);\n-assert_eq!((1\", stringify!($SelfT), \").checked_div_euc(0), None);\n+\"::min_value() + 1).checked_div_euclid(-1), Some(\", stringify!($Max), \"));\n+assert_eq!(\", stringify!($SelfT), \"::min_value().checked_div_euclid(-1), None);\n+assert_eq!((1\", stringify!($SelfT), \").checked_div_euclid(0), None);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n-            pub fn checked_div_euc(self, rhs: Self) -> Option<Self> {\n+            pub fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                     None\n                 } else {\n-                    Some(self.div_euc(rhs))\n+                    Some(self.div_euclid(rhs))\n                 }\n             }\n         }\n@@ -726,8 +726,8 @@ $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Checked Euclidean modulo. Computes `self.mod_euc(rhs)`, returning `None` if\n-`rhs == 0` or the division results in overflow.\n+            concat!(\"Checked Euclidean remainder. Computes `self.rem_euclid(rhs)`, returning `None`\n+if `rhs == 0` or the division results in overflow.\n \n # Examples\n \n@@ -737,17 +737,17 @@ Basic usage:\n #![feature(euclidean_division)]\n use std::\", stringify!($SelfT), \";\n \n-assert_eq!(5\", stringify!($SelfT), \".checked_mod_euc(2), Some(1));\n-assert_eq!(5\", stringify!($SelfT), \".checked_mod_euc(0), None);\n-assert_eq!(\", stringify!($SelfT), \"::MIN.checked_mod_euc(-1), None);\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem_euclid(-1), None);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n-            pub fn checked_mod_euc(self, rhs: Self) -> Option<Self> {\n+            pub fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                     None\n                 } else {\n-                    Some(self.mod_euc(rhs))\n+                    Some(self.rem_euclid(rhs))\n                 }\n             }\n         }\n@@ -1089,7 +1089,7 @@ $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Wrapping Euclidean division. Computes `self.div_euc(rhs)`,\n+            concat!(\"Wrapping Euclidean division. Computes `self.div_euclid(rhs)`,\n wrapping around at the boundary of the type.\n \n Wrapping will only occur in `MIN / -1` on a signed type (where `MIN` is the negative minimal value\n@@ -1106,13 +1106,13 @@ Basic usage:\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euc(10), 10);\n-assert_eq!((-128i8).wrapping_div_euc(-1), -128);\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\n+assert_eq!((-128i8).wrapping_div_euclid(-1), -128);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n-            pub fn wrapping_div_euc(self, rhs: Self) -> Self {\n-                self.overflowing_div_euc(rhs).0\n+            pub fn wrapping_div_euclid(self, rhs: Self) -> Self {\n+                self.overflowing_div_euclid(rhs).0\n             }\n         }\n \n@@ -1145,8 +1145,8 @@ $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Wrapping Euclidean modulo. Computes `self.mod_euc(rhs)`, wrapping around at the\n-boundary of the type.\n+            concat!(\"Wrapping Euclidean remainder. Computes `self.rem_euclid(rhs)`, wrapping around\n+at the boundary of the type.\n \n Wrapping will only occur in `MIN % -1` on a signed type (where `MIN` is the negative minimal value\n for the type). In this case, this method returns 0.\n@@ -1161,13 +1161,13 @@ Basic usage:\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(100\", stringify!($SelfT), \".wrapping_mod_euc(10), 0);\n-assert_eq!((-128i8).wrapping_mod_euc(-1), 0);\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\n+assert_eq!((-128i8).wrapping_rem_euclid(-1), 0);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n-            pub fn wrapping_mod_euc(self, rhs: Self) -> Self {\n-                self.overflowing_mod_euc(rhs).0\n+            pub fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n+                self.overflowing_rem_euclid(rhs).0\n             }\n         }\n \n@@ -1442,7 +1442,7 @@ $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Calculates the quotient of Euclidean division `self.div_euc(rhs)`.\n+            concat!(\"Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n \n Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\n occur. If an overflow would occur then `self` is returned.\n@@ -1459,17 +1459,17 @@ Basic usage:\n #![feature(euclidean_division)]\n use std::\", stringify!($SelfT), \";\n \n-assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euc(2), (2, false));\n-assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euc(-1), (\", stringify!($SelfT),\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euclid(-1), (\", stringify!($SelfT),\n \"::MIN, true));\n ```\"),\n             #[inline]\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n-            pub fn overflowing_div_euc(self, rhs: Self) -> (Self, bool) {\n+            pub fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n                     (self, true)\n                 } else {\n-                    (self.div_euc(rhs), false)\n+                    (self.div_euclid(rhs), false)\n                 }\n             }\n         }\n@@ -1508,7 +1508,7 @@ $EndFeature, \"\n \n \n         doc_comment! {\n-            concat!(\"Calculates the remainder `self.mod_euc(rhs)` by Euclidean division.\n+            concat!(\"Overflowing Euclidean remainder. Calculates `self.rem_euclid(rhs)`.\n \n Returns a tuple of the remainder after dividing along with a boolean indicating whether an\n arithmetic overflow would occur. If an overflow would occur then 0 is returned.\n@@ -1525,16 +1525,16 @@ Basic usage:\n #![feature(euclidean_division)]\n use std::\", stringify!($SelfT), \";\n \n-assert_eq!(5\", stringify!($SelfT), \".overflowing_mod_euc(2), (1, false));\n-assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_mod_euc(-1), (0, true));\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem_euclid(-1), (0, true));\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n-            pub fn overflowing_mod_euc(self, rhs: Self) -> (Self, bool) {\n+            pub fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n                     (0, true)\n                 } else {\n-                    (self.mod_euc(rhs), false)\n+                    (self.rem_euclid(rhs), false)\n                 }\n             }\n         }\n@@ -1739,9 +1739,13 @@ $EndFeature, \"\n         doc_comment! {\n             concat!(\"Calculates the quotient of Euclidean division of `self` by `rhs`.\n \n-This computes the integer `n` such that `self = n * rhs + self.mod_euc(rhs)`.\n+This computes the integer `n` such that `self = n * rhs + self.rem_euclid(rhs)`,\n+with the `0 <= self.rem_euclid(rhs) < rhs`.\n+\n In other words, the result is `self / rhs` rounded to the integer `n`\n such that `self >= n * rhs`.\n+If `self > 0`, this is equal to round towards zero (the default in Rust);\n+if `self < 0`, this is equal to round towards +/- infinity.\n \n # Panics\n \n@@ -1756,15 +1760,15 @@ Basic usage:\n let a: \", stringify!($SelfT), \" = 7; // or any other integer type\n let b = 4;\n \n-assert_eq!(a.div_euc(b), 1); // 7 >= 4 * 1\n-assert_eq!(a.div_euc(-b), -1); // 7 >= -4 * -1\n-assert_eq!((-a).div_euc(b), -2); // -7 >= 4 * -2\n-assert_eq!((-a).div_euc(-b), 2); // -7 >= -4 * 2\n+assert_eq!(a.div_euclid(b), 1); // 7 >= 4 * 1\n+assert_eq!(a.div_euclid(-b), -1); // 7 >= -4 * -1\n+assert_eq!((-a).div_euclid(b), -2); // -7 >= 4 * -2\n+assert_eq!((-a).div_euclid(-b), 2); // -7 >= -4 * 2\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn div_euc(self, rhs: Self) -> Self {\n+            pub fn div_euclid(self, rhs: Self) -> Self {\n                 let q = self / rhs;\n                 if self % rhs < 0 {\n                     return if rhs > 0 { q - 1 } else { q + 1 }\n@@ -1775,9 +1779,9 @@ assert_eq!((-a).div_euc(-b), 2); // -7 >= -4 * 2\n \n \n         doc_comment! {\n-            concat!(\"Calculates the remainder `self mod rhs` by Euclidean division.\n+            concat!(\"Calculates the least nonnegative remainder of `self (mod rhs)`.\n \n-In particular, the result `n` satisfies `0 <= n < rhs.abs()`.\n+This is done as if by the euclidean division algorithm.\n \n # Panics\n \n@@ -1792,15 +1796,15 @@ Basic usage:\n let a: \", stringify!($SelfT), \" = 7; // or any other integer type\n let b = 4;\n \n-assert_eq!(a.mod_euc(b), 3);\n-assert_eq!((-a).mod_euc(b), 1);\n-assert_eq!(a.mod_euc(-b), 3);\n-assert_eq!((-a).mod_euc(-b), 1);\n+assert_eq!(a.rem_euclid(b), 3);\n+assert_eq!((-a).rem_euclid(b), 1);\n+assert_eq!(a.rem_euclid(-b), 3);\n+assert_eq!((-a).rem_euclid(-b), 1);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn mod_euc(self, rhs: Self) -> Self {\n+            pub fn rem_euclid(self, rhs: Self) -> Self {\n                 let r = self % rhs;\n                 if r < 0 {\n                     if rhs < 0 {\n@@ -2611,7 +2615,7 @@ assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\", $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Checked Euclidean division. Computes `self.div_euc(rhs)`, returning `None`\n+            concat!(\"Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n if `rhs == 0`.\n \n # Examples\n@@ -2620,16 +2624,16 @@ Basic usage:\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\n-assert_eq!(1\", stringify!($SelfT), \".checked_div_euc(0), None);\n+assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\n+assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n-            pub fn checked_div_euc(self, rhs: Self) -> Option<Self> {\n+            pub fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 {\n                     None\n                 } else {\n-                    Some(self.div_euc(rhs))\n+                    Some(self.div_euclid(rhs))\n                 }\n             }\n         }\n@@ -2659,7 +2663,7 @@ assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\", $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Checked Euclidean modulo. Computes `self.mod_euc(rhs)`, returning `None`\n+            concat!(\"Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n if `rhs == 0`.\n \n # Examples\n@@ -2668,16 +2672,16 @@ Basic usage:\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(5\", stringify!($SelfT), \".checked_mod_euc(2), Some(1));\n-assert_eq!(5\", stringify!($SelfT), \".checked_mod_euc(0), None);\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n-            pub fn checked_mod_euc(self, rhs: Self) -> Option<Self> {\n+            pub fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 {\n                     None\n                 } else {\n-                    Some(self.mod_euc(rhs))\n+                    Some(self.rem_euclid(rhs))\n                 }\n             }\n         }\n@@ -2965,23 +2969,26 @@ Basic usage:\n         }\n \n         doc_comment! {\n-            concat!(\"Wrapping Euclidean division. Computes `self.div_euc(rhs)`.\n+            concat!(\"Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n Wrapped division on unsigned types is just normal division.\n There's no way wrapping could ever happen.\n This function exists, so that all operations\n are accounted for in the wrapping operations.\n+Since, for the positive integers, all common\n+definitions of division are equal, this\n+is exactly equal to `self.wrapping_div(rhs)`.\n \n # Examples\n \n Basic usage:\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euc(10), 10);\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n-            pub fn wrapping_div_euc(self, rhs: Self) -> Self {\n+            pub fn wrapping_div_euclid(self, rhs: Self) -> Self {\n                 self / rhs\n             }\n         }\n@@ -3009,24 +3016,27 @@ Basic usage:\n         }\n \n         doc_comment! {\n-            concat!(\"Wrapping Euclidean modulo. Computes `self.mod_euc(rhs)`.\n+            concat!(\"Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n Wrapped modulo calculation on unsigned types is\n just the regular remainder calculation.\n There's no way wrapping could ever happen.\n This function exists, so that all operations\n are accounted for in the wrapping operations.\n+Since, for the positive integers, all common\n+definitions of division are equal, this\n+is exactly equal to `self.wrapping_rem(rhs)`.\n \n # Examples\n \n Basic usage:\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(100\", stringify!($SelfT), \".wrapping_mod_euc(10), 0);\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n-            pub fn wrapping_mod_euc(self, rhs: Self) -> Self {\n+            pub fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n                 self % rhs\n             }\n         }\n@@ -3270,12 +3280,15 @@ Basic usage\n         }\n \n         doc_comment! {\n-            concat!(\"Calculates the quotient of Euclidean division `self.div_euc(rhs)`.\n+            concat!(\"Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n \n Returns a tuple of the divisor along with a boolean indicating\n whether an arithmetic overflow would occur. Note that for unsigned\n integers overflow never occurs, so the second value is always\n `false`.\n+Since, for the positive integers, all common\n+definitions of division are equal, this\n+is exactly equal to `self.overflowing_div(rhs)`.\n \n # Panics\n \n@@ -3287,11 +3300,11 @@ Basic usage\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euc(2), (2, false));\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\n ```\"),\n             #[inline]\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n-            pub fn overflowing_div_euc(self, rhs: Self) -> (Self, bool) {\n+            pub fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n                 (self / rhs, false)\n             }\n         }\n@@ -3323,12 +3336,15 @@ Basic usage\n         }\n \n         doc_comment! {\n-            concat!(\"Calculates the remainder `self.mod_euc(rhs)` by Euclidean division.\n+            concat!(\"Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n \n Returns a tuple of the modulo after dividing along with a boolean\n indicating whether an arithmetic overflow would occur. Note that for\n unsigned integers overflow never occurs, so the second value is\n always `false`.\n+Since, for the positive integers, all common\n+definitions of division are equal, this operation\n+is exactly equal to `self.overflowing_rem(rhs)`.\n \n # Panics\n \n@@ -3340,11 +3356,11 @@ Basic usage\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(5\", stringify!($SelfT), \".overflowing_mod_euc(2), (1, false));\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\n ```\"),\n             #[inline]\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n-            pub fn overflowing_mod_euc(self, rhs: Self) -> (Self, bool) {\n+            pub fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n                 (self % rhs, false)\n             }\n         }\n@@ -3511,42 +3527,46 @@ Basic usage:\n             doc_comment! {\n             concat!(\"Performs Euclidean division.\n \n-For unsigned types, this is just the same as `self / rhs`.\n+Since, for the positive integers, all common\n+definitions of division are equal, this\n+is exactly equal to `self / rhs`.\n \n # Examples\n \n Basic usage:\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(7\", stringify!($SelfT), \".div_euc(4), 1); // or any other integer type\n+assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn div_euc(self, rhs: Self) -> Self {\n+            pub fn div_euclid(self, rhs: Self) -> Self {\n                 self / rhs\n             }\n         }\n \n \n         doc_comment! {\n-            concat!(\"Calculates the remainder `self mod rhs` by Euclidean division.\n+            concat!(\"Calculates the least remainder of `self (mod rhs)`.\n \n-For unsigned types, this is just the same as `self % rhs`.\n+Since, for the positive integers, all common\n+definitions of division are equal, this\n+is exactly equal to `self % rhs`.\n \n # Examples\n \n Basic usage:\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(7\", stringify!($SelfT), \".mod_euc(4), 3); // or any other integer type\n+assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn mod_euc(self, rhs: Self) -> Self {\n+            pub fn rem_euclid(self, rhs: Self) -> Self {\n                 self % rhs\n             }\n         }"}, {"sha": "577847b3c8282c8f6473bf2824cb619584592d1f", "filename": "src/libcore/tests/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e36b62873fb6787d521fbc4e0bd89915e28ed0f1/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36b62873fb6787d521fbc4e0bd89915e28ed0f1/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs?ref=e36b62873fb6787d521fbc4e0bd89915e28ed0f1", "patch": "@@ -31,8 +31,8 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_mod_euc() {\n-        assert!((-1 as $T).mod_euc(MIN) == MAX);\n+    fn test_mod_euclid() {\n+        assert!((-1 as $T).mod_euclid(MIN) == MAX);\n     }\n \n     #[test]"}, {"sha": "e1648db5e8ed2db699d4864a1ac793a7ece300fd", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e36b62873fb6787d521fbc4e0bd89915e28ed0f1/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36b62873fb6787d521fbc4e0bd89915e28ed0f1/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=e36b62873fb6787d521fbc4e0bd89915e28ed0f1", "patch": "@@ -694,23 +694,23 @@ macro_rules! test_float {\n             assert!(($nan as $fty).max($nan).is_nan());\n         }\n         #[test]\n-        fn mod_euc() {\n+        fn rem_euclid() {\n             let a: $fty = 42.0;\n-            assert!($inf.mod_euc(a).is_nan());\n-            assert_eq!(a.mod_euc($inf), a);\n-            assert!(a.mod_euc($nan).is_nan());\n-            assert!($inf.mod_euc($inf).is_nan());\n-            assert!($inf.mod_euc($nan).is_nan());\n-            assert!($nan.mod_euc($inf).is_nan());\n+            assert!($inf.rem_euclid(a).is_nan());\n+            assert_eq!(a.rem_euclid($inf), a);\n+            assert!(a.rem_euclid($nan).is_nan());\n+            assert!($inf.rem_euclid($inf).is_nan());\n+            assert!($inf.rem_euclid($nan).is_nan());\n+            assert!($nan.rem_euclid($inf).is_nan());\n         }\n         #[test]\n-        fn div_euc() {\n+        fn div_euclid() {\n             let a: $fty = 42.0;\n-            assert_eq!(a.div_euc($inf), 0.0);\n-            assert!(a.div_euc($nan).is_nan());\n-            assert!($inf.div_euc($inf).is_nan());\n-            assert!($inf.div_euc($nan).is_nan());\n-            assert!($nan.div_euc($inf).is_nan());\n+            assert_eq!(a.div_euclid($inf), 0.0);\n+            assert!(a.div_euclid($nan).is_nan());\n+            assert!($inf.div_euclid($inf).is_nan());\n+            assert!($inf.div_euclid($nan).is_nan());\n+            assert!($nan.div_euclid($inf).is_nan());\n         }\n     } }\n }"}, {"sha": "209343444a0b5f13d0a4e532cabd4c375fddcbb7", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e36b62873fb6787d521fbc4e0bd89915e28ed0f1/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36b62873fb6787d521fbc4e0bd89915e28ed0f1/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=e36b62873fb6787d521fbc4e0bd89915e28ed0f1", "patch": "@@ -253,10 +253,10 @@ impl f32 {\n         unsafe { intrinsics::fmaf32(self, a, b) }\n     }\n \n-    /// Calculates Euclidean division, the matching method for `mod_euc`.\n+    /// Calculates Euclidean division, the matching method for `rem_euclid`.\n     ///\n     /// This computes the integer `n` such that\n-    /// `self = n * rhs + self.mod_euc(rhs)`.\n+    /// `self = n * rhs + self.rem_euclid(rhs)`.\n     /// In other words, the result is `self / rhs` rounded to the integer `n`\n     /// such that `self >= n * rhs`.\n     ///\n@@ -266,30 +266,30 @@ impl f32 {\n     /// #![feature(euclidean_division)]\n     /// let a: f32 = 7.0;\n     /// let b = 4.0;\n-    /// assert_eq!(a.div_euc(b), 1.0); // 7.0 > 4.0 * 1.0\n-    /// assert_eq!((-a).div_euc(b), -2.0); // -7.0 >= 4.0 * -2.0\n-    /// assert_eq!(a.div_euc(-b), -1.0); // 7.0 >= -4.0 * -1.0\n-    /// assert_eq!((-a).div_euc(-b), 2.0); // -7.0 >= -4.0 * 2.0\n+    /// assert_eq!(a.div_euclid(b), 1.0); // 7.0 > 4.0 * 1.0\n+    /// assert_eq!((-a).div_euclid(b), -2.0); // -7.0 >= 4.0 * -2.0\n+    /// assert_eq!(a.div_euclid(-b), -1.0); // 7.0 >= -4.0 * -1.0\n+    /// assert_eq!((-a).div_euclid(-b), 2.0); // -7.0 >= -4.0 * 2.0\n     /// ```\n     #[inline]\n     #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n-    pub fn div_euc(self, rhs: f32) -> f32 {\n+    pub fn div_euclid(self, rhs: f32) -> f32 {\n         let q = (self / rhs).trunc();\n         if self % rhs < 0.0 {\n             return if rhs > 0.0 { q - 1.0 } else { q + 1.0 }\n         }\n         q\n     }\n \n-    /// Calculates the Euclidean modulo (self mod rhs), which is never negative.\n+    /// Calculates the least nonnegative remainder of `self (mod rhs)`.\n     ///\n     /// In particular, the return value `r` satisfies `0.0 <= r < rhs.abs()` in\n     /// most cases. However, due to a floating point round-off error it can\n     /// result in `r == rhs.abs()`, violating the mathematical definition, if\n     /// `self` is much smaller than `rhs.abs()` in magnitude and `self < 0.0`.\n     /// This result is not an element of the function's codomain, but it is the\n     /// closest floating point number in the real numbers and thus fulfills the\n-    /// property `self == self.div_euc(rhs) * rhs + self.mod_euc(rhs)`\n+    /// property `self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)`\n     /// approximatively.\n     ///\n     /// # Examples\n@@ -298,16 +298,16 @@ impl f32 {\n     /// #![feature(euclidean_division)]\n     /// let a: f32 = 7.0;\n     /// let b = 4.0;\n-    /// assert_eq!(a.mod_euc(b), 3.0);\n-    /// assert_eq!((-a).mod_euc(b), 1.0);\n-    /// assert_eq!(a.mod_euc(-b), 3.0);\n-    /// assert_eq!((-a).mod_euc(-b), 1.0);\n+    /// assert_eq!(a.rem_euclid(b), 3.0);\n+    /// assert_eq!((-a).rem_euclid(b), 1.0);\n+    /// assert_eq!(a.rem_euclid(-b), 3.0);\n+    /// assert_eq!((-a).rem_euclid(-b), 1.0);\n     /// // limitation due to round-off error\n-    /// assert!((-std::f32::EPSILON).mod_euc(3.0) != 0.0);\n+    /// assert!((-std::f32::EPSILON).rem_euclid(3.0) != 0.0);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n-    pub fn mod_euc(self, rhs: f32) -> f32 {\n+    pub fn rem_euclid(self, rhs: f32) -> f32 {\n         let r = self % rhs;\n         if r < 0.0 {\n             r + rhs.abs()"}, {"sha": "b73a67ed9d8a017c63da870f99963fd1e9a7e0d4", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e36b62873fb6787d521fbc4e0bd89915e28ed0f1/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36b62873fb6787d521fbc4e0bd89915e28ed0f1/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=e36b62873fb6787d521fbc4e0bd89915e28ed0f1", "patch": "@@ -229,10 +229,10 @@ impl f64 {\n         unsafe { intrinsics::fmaf64(self, a, b) }\n     }\n \n-    /// Calculates Euclidean division, the matching method for `mod_euc`.\n+    /// Calculates Euclidean division, the matching method for `rem_euclid`.\n     ///\n     /// This computes the integer `n` such that\n-    /// `self = n * rhs + self.mod_euc(rhs)`.\n+    /// `self = n * rhs + self.rem_euclid(rhs)`.\n     /// In other words, the result is `self / rhs` rounded to the integer `n`\n     /// such that `self >= n * rhs`.\n     ///\n@@ -242,30 +242,30 @@ impl f64 {\n     /// #![feature(euclidean_division)]\n     /// let a: f64 = 7.0;\n     /// let b = 4.0;\n-    /// assert_eq!(a.div_euc(b), 1.0); // 7.0 > 4.0 * 1.0\n-    /// assert_eq!((-a).div_euc(b), -2.0); // -7.0 >= 4.0 * -2.0\n-    /// assert_eq!(a.div_euc(-b), -1.0); // 7.0 >= -4.0 * -1.0\n-    /// assert_eq!((-a).div_euc(-b), 2.0); // -7.0 >= -4.0 * 2.0\n+    /// assert_eq!(a.div_euclid(b), 1.0); // 7.0 > 4.0 * 1.0\n+    /// assert_eq!((-a).div_euclid(b), -2.0); // -7.0 >= 4.0 * -2.0\n+    /// assert_eq!(a.div_euclid(-b), -1.0); // 7.0 >= -4.0 * -1.0\n+    /// assert_eq!((-a).div_euclid(-b), 2.0); // -7.0 >= -4.0 * 2.0\n     /// ```\n     #[inline]\n     #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n-    pub fn div_euc(self, rhs: f64) -> f64 {\n+    pub fn div_euclid(self, rhs: f64) -> f64 {\n         let q = (self / rhs).trunc();\n         if self % rhs < 0.0 {\n             return if rhs > 0.0 { q - 1.0 } else { q + 1.0 }\n         }\n         q\n     }\n \n-    /// Calculates the Euclidean modulo (self mod rhs), which is never negative.\n+    /// Calculates the least nonnegative remainder of `self (mod rhs)`.\n     ///\n     /// In particular, the return value `r` satisfies `0.0 <= r < rhs.abs()` in\n     /// most cases.  However, due to a floating point round-off error it can\n     /// result in `r == rhs.abs()`, violating the mathematical definition, if\n     /// `self` is much smaller than `rhs.abs()` in magnitude and `self < 0.0`.\n     /// This result is not an element of the function's codomain, but it is the\n     /// closest floating point number in the real numbers and thus fulfills the\n-    /// property `self == self.div_euc(rhs) * rhs + self.mod_euc(rhs)`\n+    /// property `self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)`\n     /// approximatively.\n     ///\n     /// # Examples\n@@ -274,16 +274,16 @@ impl f64 {\n     /// #![feature(euclidean_division)]\n     /// let a: f64 = 7.0;\n     /// let b = 4.0;\n-    /// assert_eq!(a.mod_euc(b), 3.0);\n-    /// assert_eq!((-a).mod_euc(b), 1.0);\n-    /// assert_eq!(a.mod_euc(-b), 3.0);\n-    /// assert_eq!((-a).mod_euc(-b), 1.0);\n+    /// assert_eq!(a.rem_euclid(b), 3.0);\n+    /// assert_eq!((-a).rem_euclid(b), 1.0);\n+    /// assert_eq!(a.rem_euclid(-b), 3.0);\n+    /// assert_eq!((-a).rem_euclid(-b), 1.0);\n     /// // limitation due to round-off error\n-    /// assert!((-std::f64::EPSILON).mod_euc(3.0) != 0.0);\n+    /// assert!((-std::f64::EPSILON).rem_euclid(3.0) != 0.0);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n-    pub fn mod_euc(self, rhs: f64) -> f64 {\n+    pub fn rem_euclid(self, rhs: f64) -> f64 {\n         let r = self % rhs;\n         if r < 0.0 {\n             r + rhs.abs()"}]}