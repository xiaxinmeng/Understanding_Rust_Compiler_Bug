{"sha": "a47881182237201f207a4b89166a6be6903a8228", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0Nzg4MTE4MjIzNzIwMWYyMDdhNGI4OTE2NmE2YmU2OTAzYTgyMjg=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-12-14T05:15:39Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-12-16T20:35:51Z"}, "message": "Move a bunch of stuff from Session to syntax::errors\n\nThe intention here is that Session is a very thin wrapper over the error handling infra.", "tree": {"sha": "f003790d230523966d4ca2f7361ee9936f1c64a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f003790d230523966d4ca2f7361ee9936f1c64a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a47881182237201f207a4b89166a6be6903a8228", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a47881182237201f207a4b89166a6be6903a8228", "html_url": "https://github.com/rust-lang/rust/commit/a47881182237201f207a4b89166a6be6903a8228", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a47881182237201f207a4b89166a6be6903a8228/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6309b0f5bb558b844f45b2d313d2078fd7b7614c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6309b0f5bb558b844f45b2d313d2078fd7b7614c", "html_url": "https://github.com/rust-lang/rust/commit/6309b0f5bb558b844f45b2d313d2078fd7b7614c"}], "stats": {"total": 87, "additions": 19, "deletions": 68}, "files": [{"sha": "7b96db4bf0a3af87e3283dc5cd672b30c5303865", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 11, "deletions": 60, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a47881182237201f207a4b89166a6be6903a8228/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47881182237201f207a4b89166a6be6903a8228/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=a47881182237201f207a4b89166a6be6903a8228", "patch": "@@ -64,14 +64,10 @@ pub struct Session {\n     pub crate_metadata: RefCell<Vec<String>>,\n     pub features: RefCell<feature_gate::Features>,\n \n-    pub delayed_span_bug: RefCell<Option<(codemap::Span, String)>>,\n-\n     /// The maximum recursion limit for potentially infinitely recursive\n     /// operations such as auto-dereference and monomorphization.\n     pub recursion_limit: Cell<usize>,\n \n-    pub can_print_warnings: bool,\n-\n     /// The metadata::creader module may inject an allocator dependency if it\n     /// didn't already find one, and this tracks what was injected.\n     pub injected_allocator: Cell<Option<ast::CrateNum>>,\n@@ -85,21 +81,12 @@ pub struct Session {\n \n impl Session {\n     pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n-        if self.opts.treat_err_as_bug {\n-            self.span_bug(sp, msg);\n-        }\n         panic!(self.diagnostic().span_fatal(sp, msg))\n     }\n     pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> ! {\n-        if self.opts.treat_err_as_bug {\n-            self.span_bug(sp, msg);\n-        }\n         panic!(self.diagnostic().span_fatal_with_code(sp, msg, code))\n     }\n     pub fn fatal(&self, msg: &str) -> ! {\n-        if self.opts.treat_err_as_bug {\n-            self.bug(msg);\n-        }\n         panic!(self.diagnostic().fatal(msg))\n     }\n     pub fn span_err_or_warn(&self, is_warning: bool, sp: Span, msg: &str) {\n@@ -110,9 +97,6 @@ impl Session {\n         }\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n-        if self.opts.treat_err_as_bug {\n-            self.span_bug(sp, msg);\n-        }\n         match split_msg_into_multilines(msg) {\n             Some(msg) => self.diagnostic().span_err(sp, &msg[..]),\n             None => self.diagnostic().span_err(sp, msg)\n@@ -126,18 +110,12 @@ impl Session {\n                       See RFC 1214 for details.\"));\n     }\n     pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n-        if self.opts.treat_err_as_bug {\n-            self.span_bug(sp, msg);\n-        }\n         match split_msg_into_multilines(msg) {\n             Some(msg) => self.diagnostic().span_err_with_code(sp, &msg[..], code),\n             None => self.diagnostic().span_err_with_code(sp, msg, code)\n         }\n     }\n     pub fn err(&self, msg: &str) {\n-        if self.opts.treat_err_as_bug {\n-            self.bug(msg);\n-        }\n         self.diagnostic().err(msg)\n     }\n     pub fn err_count(&self) -> usize {\n@@ -148,14 +126,6 @@ impl Session {\n     }\n     pub fn abort_if_errors(&self) {\n         self.diagnostic().abort_if_errors();\n-\n-        let delayed_bug = self.delayed_span_bug.borrow();\n-        match *delayed_bug {\n-            Some((span, ref errmsg)) => {\n-                self.diagnostic().span_bug(span, errmsg);\n-            },\n-            _ => {}\n-        }\n     }\n     pub fn abort_if_new_errors<F>(&self, mut f: F)\n         where F: FnMut()\n@@ -167,19 +137,13 @@ impl Session {\n         }\n     }\n     pub fn span_warn(&self, sp: Span, msg: &str) {\n-        if self.can_print_warnings {\n-            self.diagnostic().span_warn(sp, msg)\n-        }\n+        self.diagnostic().span_warn(sp, msg)\n     }\n     pub fn span_warn_with_code(&self, sp: Span, msg: &str, code: &str) {\n-        if self.can_print_warnings {\n-            self.diagnostic().span_warn_with_code(sp, msg, code)\n-        }\n+        self.diagnostic().span_warn_with_code(sp, msg, code)\n     }\n     pub fn warn(&self, msg: &str) {\n-        if self.can_print_warnings {\n-            self.diagnostic().warn(msg)\n-        }\n+        self.diagnostic().warn(msg)\n     }\n     pub fn opt_span_warn(&self, opt_sp: Option<Span>, msg: &str) {\n         match opt_sp {\n@@ -223,8 +187,7 @@ impl Session {\n     }\n     /// Delay a span_bug() call until abort_if_errors()\n     pub fn delay_span_bug(&self, sp: Span, msg: &str) {\n-        let mut delayed = self.delayed_span_bug.borrow_mut();\n-        *delayed = Some((sp, msg.to_string()));\n+        self.diagnostic().delay_span_bug(sp, msg)\n     }\n     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n         self.diagnostic().span_bug(sp, msg)\n@@ -270,8 +233,7 @@ impl Session {\n     // This exists to help with refactoring to eliminate impossible\n     // cases later on\n     pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n-        self.span_bug(sp,\n-                      &format!(\"impossible case reached: {}\", msg));\n+        self.span_bug(sp, &format!(\"impossible case reached: {}\", msg));\n     }\n     pub fn verbose(&self) -> bool { self.opts.debugging_opts.verbose }\n     pub fn time_passes(&self) -> bool { self.opts.debugging_opts.time_passes }\n@@ -414,10 +376,15 @@ pub fn build_session(sopts: config::Options,\n         .map(|&(_, ref level)| *level != lint::Allow)\n         .last()\n         .unwrap_or(true);\n+    let treat_err_as_bug = sopts.treat_err_as_bug;\n \n     let codemap = Rc::new(codemap::CodeMap::new());\n     let diagnostic_handler =\n-        errors::Handler::new(sopts.color, Some(registry), can_print_warnings, codemap.clone());\n+        errors::Handler::new(sopts.color,\n+                             Some(registry),\n+                             can_print_warnings,\n+                             treat_err_as_bug,\n+                             codemap.clone());\n \n     build_session_(sopts, local_crate_source_file, diagnostic_handler, codemap, cstore)\n }\n@@ -450,13 +417,6 @@ pub fn build_session_(sopts: config::Options,\n         }\n     );\n \n-    let can_print_warnings = sopts.lint_opts\n-        .iter()\n-        .filter(|&&(ref key, _)| *key == \"warnings\")\n-        .map(|&(_, ref level)| *level != lint::Allow)\n-        .last()\n-        .unwrap_or(true);\n-\n     let sess = Session {\n         target: target_cfg,\n         host: host,\n@@ -477,10 +437,8 @@ pub fn build_session_(sopts: config::Options,\n         crate_types: RefCell::new(Vec::new()),\n         dependency_formats: RefCell::new(FnvHashMap()),\n         crate_metadata: RefCell::new(Vec::new()),\n-        delayed_span_bug: RefCell::new(None),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),\n-        can_print_warnings: can_print_warnings,\n         next_node_id: Cell::new(1),\n         injected_allocator: Cell::new(None),\n         available_macros: RefCell::new(HashSet::new()),\n@@ -489,13 +447,6 @@ pub fn build_session_(sopts: config::Options,\n     sess\n }\n \n-// Seems out of place, but it uses session, so I'm putting it here\n-pub fn expect<T, M>(sess: &Session, opt: Option<T>, msg: M) -> T where\n-    M: FnOnce() -> String,\n-{\n-    errors::expect(sess.diagnostic(), opt, msg)\n-}\n-\n pub fn early_error(color: errors::ColorConfig, msg: &str) -> ! {\n     let mut emitter = BasicEmitter::stderr(color);\n     emitter.emit(None, msg, None, errors::Level::Fatal);"}, {"sha": "dc20b99f9a6bb1159ed1c710926503f34bf60fcd", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a47881182237201f207a4b89166a6be6903a8228/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47881182237201f207a4b89166a6be6903a8228/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=a47881182237201f207a4b89166a6be6903a8228", "patch": "@@ -862,7 +862,7 @@ fn run_work_multithreaded(sess: &Session,\n         futures.push(rx);\n \n         thread::Builder::new().name(format!(\"codegen-{}\", i)).spawn(move || {\n-            let diag_handler = Handler::with_emitter(true, box diag_emitter);\n+            let diag_handler = Handler::with_emitter(true, false, box diag_emitter);\n \n             // Must construct cgcx inside the proc because it has non-Send\n             // fields."}, {"sha": "cf82a3b72d578b6e7aa4985c752906c442a9b88e", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a47881182237201f207a4b89166a6be6903a8228/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47881182237201f207a4b89166a6be6903a8228/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=a47881182237201f207a4b89166a6be6903a8228", "patch": "@@ -20,7 +20,6 @@ pub use self::CallArgs::*;\n \n use arena::TypedArena;\n use back::link;\n-use session;\n use llvm::{self, ValueRef, get_params};\n use middle::cstore::LOCAL_CRATE;\n use middle::def;\n@@ -57,6 +56,7 @@ use rustc_front::hir;\n \n use syntax::abi as synabi;\n use syntax::ast;\n+use syntax::errors;\n use syntax::ptr::P;\n \n #[derive(Copy, Clone)]\n@@ -412,8 +412,8 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n             Some(n) => n,\n             None => { return false; }\n         };\n-        let map_node = session::expect(\n-            &tcx.sess,\n+        let map_node = errors::expect(\n+            &tcx.sess.diagnostic(),\n             tcx.map.find(node_id),\n             || \"local item should be in ast map\".to_string());\n "}, {"sha": "4b6a0d1a5096541cd77ba4349c0db612c417bc91", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a47881182237201f207a4b89166a6be6903a8228/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47881182237201f207a4b89166a6be6903a8228/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=a47881182237201f207a4b89166a6be6903a8228", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use back::link::exported_name;\n-use session;\n use llvm::ValueRef;\n use llvm;\n use middle::def_id::DefId;\n@@ -32,6 +31,7 @@ use rustc_front::hir;\n use syntax::abi;\n use syntax::ast;\n use syntax::attr;\n+use syntax::errors;\n use std::hash::{Hasher, Hash, SipHasher};\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -83,8 +83,8 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            hash_id);\n \n \n-    let map_node = session::expect(\n-        ccx.sess(),\n+    let map_node = errors::expect(\n+        ccx.sess().diagnostic(),\n         ccx.tcx().map.find(fn_node_id),\n         || {\n             format!(\"while monomorphizing {:?}, couldn't find it in \\"}, {"sha": "ed87961e7f3d7f2b686a0ab85c1f6db9ba3cd815", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a47881182237201f207a4b89166a6be6903a8228/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47881182237201f207a4b89166a6be6903a8228/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=a47881182237201f207a4b89166a6be6903a8228", "patch": "@@ -49,7 +49,7 @@ pub struct ParseSess {\n impl ParseSess {\n     pub fn new() -> ParseSess {\n         let cm = Rc::new(CodeMap::new());\n-        let handler = Handler::new(ColorConfig::Auto, None, true, cm.clone());\n+        let handler = Handler::new(ColorConfig::Auto, None, true, false, cm.clone());\n         ParseSess::with_span_handler(handler, cm)\n     }\n "}]}