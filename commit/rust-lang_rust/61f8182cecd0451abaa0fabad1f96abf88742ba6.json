{"sha": "61f8182cecd0451abaa0fabad1f96abf88742ba6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxZjgxODJjZWNkMDQ1MWFiYWEwZmFiYWQxZjk2YWJmODg3NDJiYTY=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-10-21T12:26:34Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-10-30T11:27:44Z"}, "message": "TypeVisitor: use `ControlFlow` in rustc_{mir,privacy,traits,typeck}", "tree": {"sha": "c722e135b8cd573c5c1fc8fcb0bd1fbf025ffd61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c722e135b8cd573c5c1fc8fcb0bd1fbf025ffd61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61f8182cecd0451abaa0fabad1f96abf88742ba6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61f8182cecd0451abaa0fabad1f96abf88742ba6", "html_url": "https://github.com/rust-lang/rust/commit/61f8182cecd0451abaa0fabad1f96abf88742ba6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61f8182cecd0451abaa0fabad1f96abf88742ba6/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fe735b3209388788176606e10b0bfe953008862", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fe735b3209388788176606e10b0bfe953008862", "html_url": "https://github.com/rust-lang/rust/commit/4fe735b3209388788176606e10b0bfe953008862"}], "stats": {"total": 293, "additions": 171, "deletions": 122}, "files": [{"sha": "4c52f8eeaffa1ddd3ad94fcd8f158293fe2f5183", "filename": "compiler/rustc_mir/src/interpret/util.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Futil.rs?ref=61f8182cecd0451abaa0fabad1f96abf88742ba6", "patch": "@@ -1,6 +1,7 @@\n use rustc_middle::mir::interpret::InterpResult;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use std::convert::TryInto;\n+use std::ops::ControlFlow;\n \n /// Returns `true` if a used generic parameter requires substitution.\n crate fn ensure_monomorphic_enough<'tcx, T>(tcx: TyCtxt<'tcx>, ty: T) -> InterpResult<'tcx>\n@@ -17,24 +18,24 @@ where\n     };\n \n     impl<'tcx> TypeVisitor<'tcx> for UsedParamsNeedSubstVisitor<'tcx> {\n-        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<(), ()> {\n             if !c.needs_subst() {\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n \n             match c.val {\n-                ty::ConstKind::Param(..) => true,\n+                ty::ConstKind::Param(..) => ControlFlow::BREAK,\n                 _ => c.super_visit_with(self),\n             }\n         }\n \n-        fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<(), ()> {\n             if !ty.needs_subst() {\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n \n             match *ty.kind() {\n-                ty::Param(_) => true,\n+                ty::Param(_) => ControlFlow::BREAK,\n                 ty::Closure(def_id, substs)\n                 | ty::Generator(def_id, substs, ..)\n                 | ty::FnDef(def_id, substs) => {\n@@ -50,11 +51,7 @@ where\n                         match (is_used, subst.needs_subst()) {\n                             // Just in case there are closures or generators within this subst,\n                             // recurse.\n-                            (true, true) if subst.super_visit_with(self) => {\n-                                // Only return when we find a parameter so the remaining substs\n-                                // are not skipped.\n-                                return true;\n-                            }\n+                            (true, true) => return subst.super_visit_with(self),\n                             // Confirm that polymorphization replaced the parameter with\n                             // `ty::Param`/`ty::ConstKind::Param`.\n                             (false, true) if cfg!(debug_assertions) => match subst.unpack() {\n@@ -69,15 +66,15 @@ where\n                             _ => {}\n                         }\n                     }\n-                    false\n+                    ControlFlow::CONTINUE\n                 }\n                 _ => ty.super_visit_with(self),\n             }\n         }\n     }\n \n     let mut vis = UsedParamsNeedSubstVisitor { tcx };\n-    if ty.visit_with(&mut vis) {\n+    if ty.visit_with(&mut vis) == ControlFlow::BREAK {\n         throw_inval!(TooGeneric);\n     } else {\n         Ok(())"}, {"sha": "2ed115b12971c38b998665b027aaa54977f24022", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=61f8182cecd0451abaa0fabad1f96abf88742ba6", "patch": "@@ -27,6 +27,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(option_expect_none)]\n #![feature(or_patterns)]\n #![feature(once_cell)]\n+#![feature(control_flow_enum)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "5eb60a550de961e5a75cf12efa12860040d12dd3", "filename": "compiler/rustc_mir/src/monomorphize/polymorphize.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs?ref=61f8182cecd0451abaa0fabad1f96abf88742ba6", "patch": "@@ -20,6 +20,7 @@ use rustc_middle::ty::{\n };\n use rustc_span::symbol::sym;\n use std::convert::TryInto;\n+use std::ops::ControlFlow;\n \n /// Provide implementations of queries relating to polymorphization analysis.\n pub fn provide(providers: &mut Providers) {\n@@ -138,7 +139,7 @@ fn mark_used_by_predicates<'tcx>(\n             // predicate is used.\n             let any_param_used = {\n                 let mut vis = HasUsedGenericParams { unused_parameters };\n-                predicate.visit_with(&mut vis)\n+                predicate.visit_with(&mut vis) == ControlFlow::BREAK\n             };\n \n             if any_param_used {\n@@ -249,17 +250,17 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n-    fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> bool {\n+    fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> ControlFlow<(), ()> {\n         debug!(\"visit_const: c={:?}\", c);\n         if !c.has_param_types_or_consts() {\n-            return false;\n+            return ControlFlow::CONTINUE;\n         }\n \n         match c.val {\n             ty::ConstKind::Param(param) => {\n                 debug!(\"visit_const: param={:?}\", param);\n                 self.unused_parameters.clear(param.index);\n-                false\n+                ControlFlow::CONTINUE\n             }\n             ty::ConstKind::Unevaluated(def, _, Some(p))\n                 // Avoid considering `T` unused when constants are of the form:\n@@ -270,41 +271,41 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n                 // the generic parameters, instead, traverse the promoted MIR.\n                 let promoted = self.tcx.promoted_mir(def.did);\n                 self.visit_body(&promoted[p]);\n-                false\n+                ControlFlow::CONTINUE\n             }\n             ty::ConstKind::Unevaluated(def, unevaluated_substs, None)\n                 if self.tcx.def_kind(def.did) == DefKind::AnonConst =>\n             {\n                 self.visit_child_body(def.did, unevaluated_substs);\n-                false\n+                ControlFlow::CONTINUE\n             }\n             _ => c.super_visit_with(self),\n         }\n     }\n \n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<(), ()> {\n         debug!(\"visit_ty: ty={:?}\", ty);\n         if !ty.has_param_types_or_consts() {\n-            return false;\n+            return ControlFlow::CONTINUE;\n         }\n \n         match *ty.kind() {\n             ty::Closure(def_id, substs) | ty::Generator(def_id, substs, ..) => {\n                 debug!(\"visit_ty: def_id={:?}\", def_id);\n                 // Avoid cycle errors with generators.\n                 if def_id == self.def_id {\n-                    return false;\n+                    return ControlFlow::CONTINUE;\n                 }\n \n                 // Consider any generic parameters used by any closures/generators as used in the\n                 // parent.\n                 self.visit_child_body(def_id, substs);\n-                false\n+                ControlFlow::CONTINUE\n             }\n             ty::Param(param) => {\n                 debug!(\"visit_ty: param={:?}\", param);\n                 self.unused_parameters.clear(param.index);\n-                false\n+                ControlFlow::CONTINUE\n             }\n             _ => ty.super_visit_with(self),\n         }\n@@ -317,28 +318,38 @@ struct HasUsedGenericParams<'a> {\n }\n \n impl<'a, 'tcx> TypeVisitor<'tcx> for HasUsedGenericParams<'a> {\n-    fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> bool {\n+    fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> ControlFlow<(), ()> {\n         debug!(\"visit_const: c={:?}\", c);\n         if !c.has_param_types_or_consts() {\n-            return false;\n+            return ControlFlow::CONTINUE;\n         }\n \n         match c.val {\n             ty::ConstKind::Param(param) => {\n-                !self.unused_parameters.contains(param.index).unwrap_or(false)\n+                if self.unused_parameters.contains(param.index).unwrap_or(false) {\n+                    ControlFlow::CONTINUE\n+                } else {\n+                    ControlFlow::BREAK\n+                }\n             }\n             _ => c.super_visit_with(self),\n         }\n     }\n \n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<(), ()> {\n         debug!(\"visit_ty: ty={:?}\", ty);\n         if !ty.has_param_types_or_consts() {\n-            return false;\n+            return ControlFlow::CONTINUE;\n         }\n \n         match ty.kind() {\n-            ty::Param(param) => !self.unused_parameters.contains(param.index).unwrap_or(false),\n+            ty::Param(param) => {\n+                if self.unused_parameters.contains(param.index).unwrap_or(false) {\n+                    ControlFlow::CONTINUE\n+                } else {\n+                    ControlFlow::BREAK\n+                }\n+            }\n             _ => ty.super_visit_with(self),\n         }\n     }"}, {"sha": "4065401731a22b4ac3482e11cf9ff069b7b28225", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=61f8182cecd0451abaa0fabad1f96abf88742ba6", "patch": "@@ -19,6 +19,7 @@ use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_target::abi::Size;\n+use std::ops::ControlFlow;\n \n const INDENT: &str = \"    \";\n /// Alignment for lining up comments following MIR statements\n@@ -639,7 +640,7 @@ pub fn write_allocations<'tcx>(\n     }\n     struct CollectAllocIds(BTreeSet<AllocId>);\n     impl<'tcx> TypeVisitor<'tcx> for CollectAllocIds {\n-        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<(), ()> {\n             if let ty::ConstKind::Value(val) = c.val {\n                 self.0.extend(alloc_ids_from_const(val));\n             }"}, {"sha": "a05da06bed78520ea801efaa7d99f725fba04b95", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 85, "deletions": 62, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=61f8182cecd0451abaa0fabad1f96abf88742ba6", "patch": "@@ -2,6 +2,8 @@\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(or_patterns)]\n+#![feature(control_flow_enum)]\n+#![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n \n use rustc_attr as attr;\n@@ -26,6 +28,7 @@ use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n \n use std::marker::PhantomData;\n+use std::ops::ControlFlow;\n use std::{cmp, fmt, mem};\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -48,7 +51,12 @@ trait DefIdVisitor<'tcx> {\n     fn skip_assoc_tys(&self) -> bool {\n         false\n     }\n-    fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool;\n+    fn visit_def_id(\n+        &mut self,\n+        def_id: DefId,\n+        kind: &str,\n+        descr: &dyn fmt::Display,\n+    ) -> ControlFlow<(), ()>;\n \n     /// Not overridden, but used to actually visit types and traits.\n     fn skeleton(&mut self) -> DefIdVisitorSkeleton<'_, 'tcx, Self> {\n@@ -58,13 +66,13 @@ trait DefIdVisitor<'tcx> {\n             dummy: Default::default(),\n         }\n     }\n-    fn visit(&mut self, ty_fragment: impl TypeFoldable<'tcx>) -> bool {\n+    fn visit(&mut self, ty_fragment: impl TypeFoldable<'tcx>) -> ControlFlow<(), ()> {\n         ty_fragment.visit_with(&mut self.skeleton())\n     }\n-    fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> bool {\n+    fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> ControlFlow<(), ()> {\n         self.skeleton().visit_trait(trait_ref)\n     }\n-    fn visit_predicates(&mut self, predicates: ty::GenericPredicates<'tcx>) -> bool {\n+    fn visit_predicates(&mut self, predicates: ty::GenericPredicates<'tcx>) -> ControlFlow<(), ()> {\n         self.skeleton().visit_predicates(predicates)\n     }\n }\n@@ -79,54 +87,49 @@ impl<'tcx, V> DefIdVisitorSkeleton<'_, 'tcx, V>\n where\n     V: DefIdVisitor<'tcx> + ?Sized,\n {\n-    fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> bool {\n+    fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> ControlFlow<(), ()> {\n         let TraitRef { def_id, substs } = trait_ref;\n-        self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref.print_only_trait_path())\n-            || (!self.def_id_visitor.shallow() && substs.visit_with(self))\n+        self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref.print_only_trait_path())?;\n+        if self.def_id_visitor.shallow() { ControlFlow::CONTINUE } else { substs.visit_with(self) }\n     }\n \n-    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n+    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<(), ()> {\n         match predicate.skip_binders() {\n             ty::PredicateAtom::Trait(ty::TraitPredicate { trait_ref }, _) => {\n                 self.visit_trait(trait_ref)\n             }\n             ty::PredicateAtom::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n-                ty.visit_with(self)\n-                    || self.visit_trait(projection_ty.trait_ref(self.def_id_visitor.tcx()))\n+                ty.visit_with(self)?;\n+                self.visit_trait(projection_ty.trait_ref(self.def_id_visitor.tcx()))\n             }\n             ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, _region)) => {\n                 ty.visit_with(self)\n             }\n-            ty::PredicateAtom::RegionOutlives(..) => false,\n+            ty::PredicateAtom::RegionOutlives(..) => ControlFlow::CONTINUE,\n             ty::PredicateAtom::ConstEvaluatable(..)\n                 if self.def_id_visitor.tcx().features().const_evaluatable_checked =>\n             {\n                 // FIXME(const_evaluatable_checked): If the constant used here depends on a\n                 // private function we may have to do something here...\n                 //\n                 // For now, let's just pretend that everything is fine.\n-                false\n+                ControlFlow::CONTINUE\n             }\n             _ => bug!(\"unexpected predicate: {:?}\", predicate),\n         }\n     }\n \n-    fn visit_predicates(&mut self, predicates: ty::GenericPredicates<'tcx>) -> bool {\n+    fn visit_predicates(&mut self, predicates: ty::GenericPredicates<'tcx>) -> ControlFlow<(), ()> {\n         let ty::GenericPredicates { parent: _, predicates } = predicates;\n-        for &(predicate, _span) in predicates {\n-            if self.visit_predicate(predicate) {\n-                return true;\n-            }\n-        }\n-        false\n+        predicates.iter().try_for_each(|&(predicate, _span)| self.visit_predicate(predicate))\n     }\n }\n \n impl<'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'tcx, V>\n where\n     V: DefIdVisitor<'tcx> + ?Sized,\n {\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<(), ()> {\n         let tcx = self.def_id_visitor.tcx();\n         // InternalSubsts are not visited here because they are visited below in `super_visit_with`.\n         match *ty.kind() {\n@@ -135,29 +138,23 @@ where\n             | ty::FnDef(def_id, ..)\n             | ty::Closure(def_id, ..)\n             | ty::Generator(def_id, ..) => {\n-                if self.def_id_visitor.visit_def_id(def_id, \"type\", &ty) {\n-                    return true;\n-                }\n+                self.def_id_visitor.visit_def_id(def_id, \"type\", &ty)?;\n                 if self.def_id_visitor.shallow() {\n-                    return false;\n+                    return ControlFlow::CONTINUE;\n                 }\n                 // Default type visitor doesn't visit signatures of fn types.\n                 // Something like `fn() -> Priv {my_func}` is considered a private type even if\n                 // `my_func` is public, so we need to visit signatures.\n                 if let ty::FnDef(..) = ty.kind() {\n-                    if tcx.fn_sig(def_id).visit_with(self) {\n-                        return true;\n-                    }\n+                    tcx.fn_sig(def_id).visit_with(self)?;\n                 }\n                 // Inherent static methods don't have self type in substs.\n                 // Something like `fn() {my_method}` type of the method\n                 // `impl Pub<Priv> { pub fn my_method() {} }` is considered a private type,\n                 // so we need to visit the self type additionally.\n                 if let Some(assoc_item) = tcx.opt_associated_item(def_id) {\n                     if let ty::ImplContainer(impl_def_id) = assoc_item.container {\n-                        if tcx.type_of(impl_def_id).visit_with(self) {\n-                            return true;\n-                        }\n+                        tcx.type_of(impl_def_id).visit_with(self)?;\n                     }\n                 }\n             }\n@@ -168,7 +165,7 @@ where\n                     // as visible/reachable even if both `Type` and `Trait` are private.\n                     // Ideally, associated types should be substituted in the same way as\n                     // free type aliases, but this isn't done yet.\n-                    return false;\n+                    return ControlFlow::CONTINUE;\n                 }\n                 // This will also visit substs if necessary, so we don't need to recurse.\n                 return self.visit_trait(proj.trait_ref(tcx));\n@@ -185,9 +182,7 @@ where\n                         }\n                     };\n                     let ty::ExistentialTraitRef { def_id, substs: _ } = trait_ref;\n-                    if self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref) {\n-                        return true;\n-                    }\n+                    self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref)?;\n                 }\n             }\n             ty::Opaque(def_id, ..) => {\n@@ -200,12 +195,10 @@ where\n                     // through the trait list (default type visitor doesn't visit those traits).\n                     // All traits in the list are considered the \"primary\" part of the type\n                     // and are visited by shallow visitors.\n-                    if self.visit_predicates(ty::GenericPredicates {\n+                    self.visit_predicates(ty::GenericPredicates {\n                         parent: None,\n                         predicates: tcx.explicit_item_bounds(def_id),\n-                    }) {\n-                        return true;\n-                    }\n+                    })?;\n                 }\n             }\n             // These types don't have their own def-ids (but may have subcomponents\n@@ -231,7 +224,11 @@ where\n             }\n         }\n \n-        !self.def_id_visitor.shallow() && ty.super_visit_with(self)\n+        if self.def_id_visitor.shallow() {\n+            ControlFlow::CONTINUE\n+        } else {\n+            ty.super_visit_with(self)\n+        }\n     }\n }\n \n@@ -281,9 +278,14 @@ impl<'a, 'tcx, VL: VisibilityLike> DefIdVisitor<'tcx> for FindMin<'a, 'tcx, VL>\n     fn skip_assoc_tys(&self) -> bool {\n         true\n     }\n-    fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n+    fn visit_def_id(\n+        &mut self,\n+        def_id: DefId,\n+        _kind: &str,\n+        _descr: &dyn fmt::Display,\n+    ) -> ControlFlow<(), ()> {\n         self.min = VL::new_min(self, def_id);\n-        false\n+        ControlFlow::CONTINUE\n     }\n }\n \n@@ -895,7 +897,12 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.ev.tcx\n     }\n-    fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n+    fn visit_def_id(\n+        &mut self,\n+        def_id: DefId,\n+        _kind: &str,\n+        _descr: &dyn fmt::Display,\n+    ) -> ControlFlow<(), ()> {\n         if let Some(def_id) = def_id.as_local() {\n             if let (ty::Visibility::Public, _) | (_, Some(AccessLevel::ReachableFromImplTrait)) =\n                 (self.tcx().visibility(def_id.to_def_id()), self.access_level)\n@@ -904,7 +911,7 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n                 self.ev.update(hir_id, self.access_level);\n             }\n         }\n-        false\n+        ControlFlow::CONTINUE\n     }\n }\n \n@@ -1072,17 +1079,14 @@ impl<'tcx> TypePrivacyVisitor<'tcx> {\n     fn check_expr_pat_type(&mut self, id: hir::HirId, span: Span) -> bool {\n         self.span = span;\n         let typeck_results = self.typeck_results();\n-        if self.visit(typeck_results.node_type(id)) || self.visit(typeck_results.node_substs(id)) {\n-            return true;\n-        }\n-        if let Some(adjustments) = typeck_results.adjustments().get(id) {\n-            for adjustment in adjustments {\n-                if self.visit(adjustment.target) {\n-                    return true;\n-                }\n+        let result: ControlFlow<(), ()> = try {\n+            self.visit(typeck_results.node_type(id))?;\n+            self.visit(typeck_results.node_substs(id))?;\n+            if let Some(adjustments) = typeck_results.adjustments().get(id) {\n+                adjustments.iter().try_for_each(|adjustment| self.visit(adjustment.target))?;\n             }\n-        }\n-        false\n+        };\n+        result == ControlFlow::BREAK\n     }\n \n     fn check_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n@@ -1124,14 +1128,14 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n         self.span = hir_ty.span;\n         if let Some(typeck_results) = self.maybe_typeck_results {\n             // Types in bodies.\n-            if self.visit(typeck_results.node_type(hir_ty.hir_id)) {\n+            if self.visit(typeck_results.node_type(hir_ty.hir_id)) == ControlFlow::BREAK {\n                 return;\n             }\n         } else {\n             // Types in signatures.\n             // FIXME: This is very ineffective. Ideally each HIR type should be converted\n             // into a semantic type only once and the result should be cached somehow.\n-            if self.visit(rustc_typeck::hir_ty_to_ty(self.tcx, hir_ty)) {\n+            if self.visit(rustc_typeck::hir_ty_to_ty(self.tcx, hir_ty)) == ControlFlow::BREAK {\n                 return;\n             }\n         }\n@@ -1153,15 +1157,16 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n             );\n \n             for (trait_predicate, _, _) in bounds.trait_bounds {\n-                if self.visit_trait(trait_predicate.skip_binder()) {\n+                if self.visit_trait(trait_predicate.skip_binder()) == ControlFlow::BREAK {\n                     return;\n                 }\n             }\n \n             for (poly_predicate, _) in bounds.projection_bounds {\n                 let tcx = self.tcx;\n-                if self.visit(poly_predicate.skip_binder().ty)\n+                if self.visit(poly_predicate.skip_binder().ty) == ControlFlow::BREAK\n                     || self.visit_trait(poly_predicate.skip_binder().projection_ty.trait_ref(tcx))\n+                        == ControlFlow::BREAK\n                 {\n                     return;\n                 }\n@@ -1188,7 +1193,7 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n                 // Method calls have to be checked specially.\n                 self.span = span;\n                 if let Some(def_id) = self.typeck_results().type_dependent_def_id(expr.hir_id) {\n-                    if self.visit(self.tcx.type_of(def_id)) {\n+                    if self.visit(self.tcx.type_of(def_id)) == ControlFlow::BREAK {\n                         return;\n                     }\n                 } else {\n@@ -1286,8 +1291,17 @@ impl DefIdVisitor<'tcx> for TypePrivacyVisitor<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n-    fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n-        self.check_def_id(def_id, kind, descr)\n+    fn visit_def_id(\n+        &mut self,\n+        def_id: DefId,\n+        kind: &str,\n+        descr: &dyn fmt::Display,\n+    ) -> ControlFlow<(), ()> {\n+        if self.check_def_id(def_id, kind, descr) {\n+            ControlFlow::BREAK\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n     }\n }\n \n@@ -1777,8 +1791,17 @@ impl DefIdVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n-    fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n-        self.check_def_id(def_id, kind, descr)\n+    fn visit_def_id(\n+        &mut self,\n+        def_id: DefId,\n+        kind: &str,\n+        descr: &dyn fmt::Display,\n+    ) -> ControlFlow<(), ()> {\n+        if self.check_def_id(def_id, kind, descr) {\n+            ControlFlow::BREAK\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n     }\n }\n "}, {"sha": "9862bc297befa768063abeeed60c08fc592b3006", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=61f8182cecd0451abaa0fabad1f96abf88742ba6", "patch": "@@ -42,6 +42,7 @@ use rustc_span::def_id::DefId;\n use chalk_ir::{FnSig, ForeignDefId};\n use rustc_hir::Unsafety;\n use std::collections::btree_map::{BTreeMap, Entry};\n+use std::ops::ControlFlow;\n \n /// Essentially an `Into` with a `&RustInterner` parameter\n crate trait LowerInto<'tcx, T> {\n@@ -897,14 +898,14 @@ impl<'tcx> BoundVarsCollector<'tcx> {\n }\n \n impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> ControlFlow<(), ()> {\n         self.binder_index.shift_in(1);\n         let result = t.super_visit_with(self);\n         self.binder_index.shift_out(1);\n         result\n     }\n \n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<(), ()> {\n         match *t.kind() {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n                 match self.parameters.entry(bound_ty.var.as_u32()) {\n@@ -924,7 +925,7 @@ impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: Region<'tcx>) -> bool {\n+    fn visit_region(&mut self, r: Region<'tcx>) -> ControlFlow<(), ()> {\n         match r {\n             ty::ReLateBound(index, br) if *index == self.binder_index => match br {\n                 ty::BoundRegion::BrNamed(def_id, _name) => {\n@@ -1114,7 +1115,7 @@ impl PlaceholdersCollector {\n }\n \n impl<'tcx> TypeVisitor<'tcx> for PlaceholdersCollector {\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<(), ()> {\n         match t.kind() {\n             ty::Placeholder(p) if p.universe == self.universe_index => {\n                 self.next_ty_placeholder = self.next_ty_placeholder.max(p.name.as_usize() + 1);\n@@ -1126,7 +1127,7 @@ impl<'tcx> TypeVisitor<'tcx> for PlaceholdersCollector {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: Region<'tcx>) -> bool {\n+    fn visit_region(&mut self, r: Region<'tcx>) -> ControlFlow<(), ()> {\n         match r {\n             ty::RePlaceholder(p) if p.universe == self.universe_index => {\n                 if let ty::BoundRegion::BrAnon(anon) = p.name {"}, {"sha": "7b688cd3e2199375d8e71309c0e282b08713597e", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=61f8182cecd0451abaa0fabad1f96abf88742ba6", "patch": "@@ -4,6 +4,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n+#![feature(control_flow_enum)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "4d3c899e58d3444d23daaa30ad031b4ed2f26e55", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=61f8182cecd0451abaa0fabad1f96abf88742ba6", "patch": "@@ -24,6 +24,8 @@ use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n+use std::ops::ControlFlow;\n+\n pub fn check_wf_new(tcx: TyCtxt<'_>) {\n     let visit = wfcheck::CheckTypeWellFormedVisitor::new(tcx);\n     tcx.hir().krate().par_visit_all_item_likes(&visit);\n@@ -448,30 +450,34 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n     };\n \n     impl<'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueVisitor<'tcx> {\n-        fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<(), ()> {\n             debug!(\"check_opaque_for_inheriting_lifetimes: (visit_ty) t={:?}\", t);\n-            if t != self.opaque_identity_ty && t.super_visit_with(self) {\n+            if t != self.opaque_identity_ty && t.super_visit_with(self) == ControlFlow::BREAK {\n                 self.ty = Some(t);\n-                return true;\n+                return ControlFlow::BREAK;\n             }\n-            false\n+            ControlFlow::CONTINUE\n         }\n \n-        fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+        fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<(), ()> {\n             debug!(\"check_opaque_for_inheriting_lifetimes: (visit_region) r={:?}\", r);\n             if let RegionKind::ReEarlyBound(ty::EarlyBoundRegion { index, .. }) = r {\n-                return *index < self.generics.parent_count as u32;\n+                if *index < self.generics.parent_count as u32 {\n+                    return ControlFlow::BREAK;\n+                } else {\n+                    return ControlFlow::CONTINUE;\n+                }\n             }\n \n             r.super_visit_with(self)\n         }\n \n-        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<(), ()> {\n             if let ty::ConstKind::Unevaluated(..) = c.val {\n                 // FIXME(#72219) We currenctly don't detect lifetimes within substs\n                 // which would violate this check. Even though the particular substitution is not used\n                 // within the const, this should still be fixed.\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n             c.super_visit_with(self)\n         }\n@@ -493,7 +499,7 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n         let prohibit_opaque = tcx\n             .explicit_item_bounds(def_id)\n             .iter()\n-            .any(|(predicate, _)| predicate.visit_with(&mut visitor));\n+            .any(|(predicate, _)| predicate.visit_with(&mut visitor) == ControlFlow::BREAK);\n         debug!(\n             \"check_opaque_for_inheriting_lifetimes: prohibit_opaque={:?}, visitor={:?}\",\n             prohibit_opaque, visitor\n@@ -1449,11 +1455,11 @@ fn opaque_type_cycle_error(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n             {\n                 struct VisitTypes(Vec<DefId>);\n                 impl<'tcx> ty::fold::TypeVisitor<'tcx> for VisitTypes {\n-                    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+                    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<(), ()> {\n                         match *t.kind() {\n                             ty::Opaque(def, _) => {\n                                 self.0.push(def);\n-                                false\n+                                ControlFlow::CONTINUE\n                             }\n                             _ => t.super_visit_with(self),\n                         }"}, {"sha": "2344c956182e799cb04384f203eb6d38463d4d6b", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=61f8182cecd0451abaa0fabad1f96abf88742ba6", "patch": "@@ -19,6 +19,8 @@ use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n \n+use std::ops::ControlFlow;\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Checks a `a <op>= b`\n     pub fn check_binop_assign(\n@@ -981,7 +983,7 @@ fn suggest_constraining_param(\n struct TypeParamVisitor<'tcx>(Vec<Ty<'tcx>>);\n \n impl<'tcx> TypeVisitor<'tcx> for TypeParamVisitor<'tcx> {\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<(), ()> {\n         if let ty::Param(_) = ty.kind() {\n             self.0.push(ty);\n         }"}, {"sha": "c41e5f83e7b9a84b05884535b17fb77f1fe36f02", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=61f8182cecd0451abaa0fabad1f96abf88742ba6", "patch": "@@ -24,6 +24,8 @@ use rustc_trait_selection::opaque_types::may_define_opaque_type;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n+use std::ops::ControlFlow;\n+\n /// Helper type of a temporary returned by `.for_item(...)`.\n /// This is necessary because we can't write the following bound:\n ///\n@@ -798,26 +800,26 @@ fn check_where_clauses<'tcx, 'fcx>(\n                 params: FxHashSet<u32>,\n             }\n             impl<'tcx> ty::fold::TypeVisitor<'tcx> for CountParams {\n-                fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+                fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<(), ()> {\n                     if let ty::Param(param) = t.kind() {\n                         self.params.insert(param.index);\n                     }\n                     t.super_visit_with(self)\n                 }\n \n-                fn visit_region(&mut self, _: ty::Region<'tcx>) -> bool {\n-                    true\n+                fn visit_region(&mut self, _: ty::Region<'tcx>) -> ControlFlow<(), ()> {\n+                    ControlFlow::BREAK\n                 }\n \n-                fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+                fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<(), ()> {\n                     if let ty::ConstKind::Param(param) = c.val {\n                         self.params.insert(param.index);\n                     }\n                     c.super_visit_with(self)\n                 }\n             }\n             let mut param_count = CountParams::default();\n-            let has_region = pred.visit_with(&mut param_count);\n+            let has_region = pred.visit_with(&mut param_count) == ControlFlow::BREAK;\n             let substituted_pred = pred.subst(fcx.tcx, substs);\n             // Don't check non-defaulted params, dependent defaults (including lifetimes)\n             // or preds with multiple params."}, {"sha": "b32fcad636dcfb5a7349b2117f51f7f13611a73a", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=61f8182cecd0451abaa0fabad1f96abf88742ba6", "patch": "@@ -50,6 +50,8 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits::error_reporting::suggestions::NextTypeParamName;\n \n+use std::ops::ControlFlow;\n+\n mod item_bounds;\n mod type_of;\n \n@@ -2060,14 +2062,14 @@ fn const_evaluatable_predicates_of<'tcx>(\n             }\n \n             impl<'a, 'tcx> TypeVisitor<'tcx> for TyAliasVisitor<'a, 'tcx> {\n-                fn visit_const(&mut self, ct: &'tcx Const<'tcx>) -> bool {\n+                fn visit_const(&mut self, ct: &'tcx Const<'tcx>) -> ControlFlow<(), ()> {\n                     if let ty::ConstKind::Unevaluated(def, substs, None) = ct.val {\n                         self.preds.insert((\n                             ty::PredicateAtom::ConstEvaluatable(def, substs).to_predicate(self.tcx),\n                             self.span,\n                         ));\n                     }\n-                    false\n+                    ControlFlow::CONTINUE\n                 }\n             }\n "}, {"sha": "0cd3718ca7bd2ca9c0bf532a40fe9e0be2d53207", "filename": "compiler/rustc_typeck/src/constrained_generic_params.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs?ref=61f8182cecd0451abaa0fabad1f96abf88742ba6", "patch": "@@ -2,6 +2,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_middle::ty::fold::{TypeFoldable, TypeVisitor};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::source_map::Span;\n+use std::ops::ControlFlow;\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Parameter(pub u32);\n@@ -56,11 +57,11 @@ struct ParameterCollector {\n }\n \n impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<(), ()> {\n         match *t.kind() {\n             ty::Projection(..) | ty::Opaque(..) if !self.include_nonconstraining => {\n                 // projections are not injective\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n             ty::Param(data) => {\n                 self.parameters.push(Parameter::from(data));\n@@ -71,14 +72,14 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<(), ()> {\n         if let ty::ReEarlyBound(data) = *r {\n             self.parameters.push(Parameter::from(data));\n         }\n-        false\n+        ControlFlow::CONTINUE\n     }\n \n-    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<(), ()> {\n         match c.val {\n             ty::ConstKind::Unevaluated(..) if !self.include_nonconstraining => {\n                 // Constant expressions are not injective"}, {"sha": "30904091c1b3fd2f3d1f929901231bcb67b47ea4", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f8182cecd0451abaa0fabad1f96abf88742ba6/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=61f8182cecd0451abaa0fabad1f96abf88742ba6", "patch": "@@ -66,6 +66,7 @@ This API is completely unstable and subject to change.\n #![feature(try_blocks)]\n #![feature(never_type)]\n #![feature(slice_partition_dedup)]\n+#![feature(control_flow_enum)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}]}