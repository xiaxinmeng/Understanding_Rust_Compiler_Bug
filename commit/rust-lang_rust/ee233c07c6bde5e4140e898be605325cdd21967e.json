{"sha": "ee233c07c6bde5e4140e898be605325cdd21967e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMjMzYzA3YzZiZGU1ZTQxNDBlODk4YmU2MDUzMjVjZGQyMTk2N2U=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-12-10T20:43:15Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-12-13T18:38:29Z"}, "message": "Restructue HIR const-checker to handle features with multiple gates", "tree": {"sha": "d9ead9deb402a16575b1e7d725917a119847616f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9ead9deb402a16575b1e7d725917a119847616f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee233c07c6bde5e4140e898be605325cdd21967e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee233c07c6bde5e4140e898be605325cdd21967e", "html_url": "https://github.com/rust-lang/rust/commit/ee233c07c6bde5e4140e898be605325cdd21967e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee233c07c6bde5e4140e898be605325cdd21967e/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f59902aad038fe32571740356844592b42a4376", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f59902aad038fe32571740356844592b42a4376", "html_url": "https://github.com/rust-lang/rust/commit/8f59902aad038fe32571740356844592b42a4376"}], "stats": {"total": 88, "additions": 69, "deletions": 19}, "files": [{"sha": "e108dfb81734e0ac7107299920b53753d68be71d", "filename": "src/librustc_passes/check_const.rs", "status": "modified", "additions": 68, "deletions": 19, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/ee233c07c6bde5e4140e898be605325cdd21967e/src%2Flibrustc_passes%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee233c07c6bde5e4140e898be605325cdd21967e/src%2Flibrustc_passes%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_const.rs?ref=ee233c07c6bde5e4140e898be605325cdd21967e", "patch": "@@ -13,11 +13,11 @@ use rustc::hir::map::Map;\n use rustc::hir;\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n-use rustc_feature::Features;\n+use rustc::session::config::nightly_options;\n use syntax::ast::Mutability;\n use syntax::feature_gate::feature_err;\n use syntax::span_err;\n-use syntax_pos::{sym, Span};\n+use syntax_pos::{sym, Span, Symbol};\n use rustc_error_codes::*;\n \n use std::fmt;\n@@ -37,18 +37,31 @@ impl NonConstExpr {\n         }\n     }\n \n-    /// Returns `true` if all feature gates required to enable this expression are turned on, or\n-    /// `None` if there is no feature gate corresponding to this expression.\n-    fn is_feature_gate_enabled(self, features: &Features) -> Option<bool> {\n+    fn required_feature_gates(self) -> Option<&'static [Symbol]> {\n         use hir::MatchSource::*;\n-        match self {\n+        use hir::LoopSource::*;\n+\n+        let gates: &[_] = match self {\n             | Self::Match(Normal)\n             | Self::Match(IfDesugar { .. })\n             | Self::Match(IfLetDesugar { .. })\n-            => Some(features.const_if_match),\n+            => &[sym::const_if_match],\n \n-            _ => None,\n-        }\n+            | Self::Loop(Loop)\n+            => &[sym::const_loop],\n+\n+            | Self::Loop(While)\n+            | Self::Loop(WhileLet)\n+            | Self::Match(WhileDesugar)\n+            | Self::Match(WhileLetDesugar)\n+            => &[sym::const_loop, sym::const_if_match],\n+\n+            // `for` loops desugar to a call to `FromIterator::from_iterator`,\n+            // so they are not yet supported behind a feature flag.\n+            _ => return None,\n+        };\n+\n+        Some(gates)\n     }\n }\n \n@@ -120,11 +133,15 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n \n     /// Emits an error when an unsupported expression is found in a const context.\n     fn const_check_violated(&self, expr: NonConstExpr, span: Span) {\n-        match expr.is_feature_gate_enabled(self.tcx.features()) {\n+        let features = self.tcx.features();\n+        let gates = expr.required_feature_gates();\n+        match gates {\n             // Don't emit an error if the user has enabled the requisite feature gates.\n-            Some(true) => return,\n+            Some(gates) if gates.iter().all(|&g| features[g]) => return,\n \n-            // Users of `-Zunleash-the-miri-inside-of-you` must use feature gates when possible.\n+            // `-Zunleash-the-miri-inside-of-you` only works for expressions that don't have a\n+            // corresponding feature gate. This encourages nightly users to use feature gates when\n+            // possible.\n             None if self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you => {\n                 self.tcx.sess.span_warn(span, \"skipping const checks\");\n                 return;\n@@ -135,15 +152,47 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n \n         let const_kind = self.const_kind\n             .expect(\"`const_check_violated` may only be called inside a const context\");\n-\n         let msg = format!(\"`{}` is not allowed in a `{}`\", expr.name(), const_kind);\n-        match expr {\n-            | NonConstExpr::Match(hir::MatchSource::Normal)\n-            | NonConstExpr::Match(hir::MatchSource::IfDesugar { .. })\n-            | NonConstExpr::Match(hir::MatchSource::IfLetDesugar { .. })\n-            => feature_err(&self.tcx.sess.parse_sess, sym::const_if_match, span, &msg).emit(),\n \n-            _ => span_err!(self.tcx.sess, span, E0744, \"{}\", msg),\n+        let gates = gates.unwrap_or(&[]);\n+        let missing_gates: Vec<_> = gates\n+            .iter()\n+            .copied()\n+            .filter(|&g| !features[g])\n+            .collect();\n+\n+        match missing_gates.as_slice() {\n+            &[] => span_err!(self.tcx.sess, span, E0744, \"{}\", msg),\n+\n+            // If the user enabled `#![feature(const_loop)]` but not `#![feature(const_if_match)]`,\n+            // explain why their `while` loop is being rejected.\n+            &[gate @ sym::const_if_match] if gates.contains(&sym::const_loop) => {\n+                let mut err = feature_err(&self.tcx.sess.parse_sess, gate, span, &msg);\n+                err.note(\"`#![feature(const_loop)]` alone is not sufficient, \\\n+                          since this loop expression contains an implicit conditional\");\n+                err.emit();\n+            }\n+\n+            &[missing_primary, ref missing_secondary @ ..] => {\n+                let mut err = feature_err(&self.tcx.sess.parse_sess, missing_primary, span, &msg);\n+\n+                // If multiple feature gates would be required to enable this expression, include\n+                // them as help messages. Don't emit a separate error for each missing feature gate.\n+                //\n+                // FIXME(ecstaticmorse): Maybe this could be incorporated into `feature_err`? This\n+                // is a pretty narrow case, however.\n+                if nightly_options::is_nightly_build() {\n+                    for gate in missing_secondary {\n+                        let note = format!(\n+                            \"add `#![feature({})]` to the crate attributes to enable\",\n+                            gate,\n+                        );\n+                        err.help(&note);\n+                    }\n+                }\n+\n+                err.emit();\n+            }\n         }\n     }\n "}, {"sha": "f01867f32c67b67d3a7b5ca53714f8aa13711e94", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee233c07c6bde5e4140e898be605325cdd21967e/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee233c07c6bde5e4140e898be605325cdd21967e/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=ee233c07c6bde5e4140e898be605325cdd21967e", "patch": "@@ -8,6 +8,7 @@\n \n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n+#![feature(slice_patterns)]\n \n #![recursion_limit=\"256\"]\n "}]}