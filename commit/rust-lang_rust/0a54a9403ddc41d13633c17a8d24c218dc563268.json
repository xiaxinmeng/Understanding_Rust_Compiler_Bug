{"sha": "0a54a9403ddc41d13633c17a8d24c218dc563268", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhNTRhOTQwM2RkYzQxZDEzNjMzYzE3YThkMjRjMjE4ZGM1NjMyNjg=", "commit": {"author": {"name": "Rakshith Ravi", "email": "rakshith.ravi@gmx.com", "date": "2020-04-08T00:09:00Z"}, "committer": {"name": "Rakshith Ravi", "email": "rakshith.ravi@gmx.com", "date": "2020-04-08T00:09:00Z"}, "message": "Added FuseIteratorImpl, FustDoubleEndedIteratorImpl and FuseExactSizeIteratorImpl to avoid exposing default functions outside of the current crate.", "tree": {"sha": "6b3183f71004fddfc6fa3e817371f218cb861f96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b3183f71004fddfc6fa3e817371f218cb861f96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a54a9403ddc41d13633c17a8d24c218dc563268", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a54a9403ddc41d13633c17a8d24c218dc563268", "html_url": "https://github.com/rust-lang/rust/commit/0a54a9403ddc41d13633c17a8d24c218dc563268", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a54a9403ddc41d13633c17a8d24c218dc563268/comments", "author": {"login": "rakshith-ravi", "id": 12864597, "node_id": "MDQ6VXNlcjEyODY0NTk3", "avatar_url": "https://avatars.githubusercontent.com/u/12864597?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rakshith-ravi", "html_url": "https://github.com/rakshith-ravi", "followers_url": "https://api.github.com/users/rakshith-ravi/followers", "following_url": "https://api.github.com/users/rakshith-ravi/following{/other_user}", "gists_url": "https://api.github.com/users/rakshith-ravi/gists{/gist_id}", "starred_url": "https://api.github.com/users/rakshith-ravi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rakshith-ravi/subscriptions", "organizations_url": "https://api.github.com/users/rakshith-ravi/orgs", "repos_url": "https://api.github.com/users/rakshith-ravi/repos", "events_url": "https://api.github.com/users/rakshith-ravi/events{/privacy}", "received_events_url": "https://api.github.com/users/rakshith-ravi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rakshith-ravi", "id": 12864597, "node_id": "MDQ6VXNlcjEyODY0NTk3", "avatar_url": "https://avatars.githubusercontent.com/u/12864597?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rakshith-ravi", "html_url": "https://github.com/rakshith-ravi", "followers_url": "https://api.github.com/users/rakshith-ravi/followers", "following_url": "https://api.github.com/users/rakshith-ravi/following{/other_user}", "gists_url": "https://api.github.com/users/rakshith-ravi/gists{/gist_id}", "starred_url": "https://api.github.com/users/rakshith-ravi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rakshith-ravi/subscriptions", "organizations_url": "https://api.github.com/users/rakshith-ravi/orgs", "repos_url": "https://api.github.com/users/rakshith-ravi/repos", "events_url": "https://api.github.com/users/rakshith-ravi/events{/privacy}", "received_events_url": "https://api.github.com/users/rakshith-ravi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af89eb5e5beda2c1de0c0c031694892a51e8db07", "url": "https://api.github.com/repos/rust-lang/rust/commits/af89eb5e5beda2c1de0c0c031694892a51e8db07", "html_url": "https://github.com/rust-lang/rust/commit/af89eb5e5beda2c1de0c0c031694892a51e8db07"}], "stats": {"total": 329, "additions": 250, "deletions": 79}, "files": [{"sha": "946cd47536307777ff4d943d7cf0e38b7d6a0b3a", "filename": "src/libcore/iter/adapters/fuse.rs", "status": "modified", "additions": 250, "deletions": 79, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/0a54a9403ddc41d13633c17a8d24c218dc563268/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a54a9403ddc41d13633c17a8d24c218dc563268/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs?ref=0a54a9403ddc41d13633c17a8d24c218dc563268", "patch": "@@ -52,70 +52,54 @@ where\n     type Item = <I as Iterator>::Item;\n \n     #[inline]\n-    default fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        fuse!(self.iter.next())\n+    fn next(&mut self) -> Option<Self::Item> {\n+        FuseIteratorImpl::next(self)\n     }\n \n     #[inline]\n-    default fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        fuse!(self.iter.nth(n))\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        FuseIteratorImpl::nth(self, n)\n     }\n \n     #[inline]\n-    default fn last(self) -> Option<I::Item> {\n-        match self.iter {\n-            Some(iter) => iter.last(),\n-            None => None,\n-        }\n+    fn last(self) -> Option<Self::Item> {\n+        FuseIteratorImpl::last(self)\n     }\n \n     #[inline]\n-    default fn count(self) -> usize {\n-        match self.iter {\n-            Some(iter) => iter.count(),\n-            None => 0,\n-        }\n+    fn count(self) -> usize {\n+        FuseIteratorImpl::count(self)\n     }\n \n     #[inline]\n-    default fn size_hint(&self) -> (usize, Option<usize>) {\n-        match self.iter {\n-            Some(ref iter) => iter.size_hint(),\n-            None => (0, Some(0)),\n-        }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        FuseIteratorImpl::size_hint(self)\n     }\n \n     #[inline]\n-    default fn try_fold<Acc, Fold, R>(&mut self, mut acc: Acc, fold: Fold) -> R\n+    fn try_fold<Acc, Fold, R>(&mut self, acc: Acc, fold: Fold) -> R\n     where\n         Self: Sized,\n         Fold: FnMut(Acc, Self::Item) -> R,\n         R: Try<Ok = Acc>,\n     {\n-        if let Some(ref mut iter) = self.iter {\n-            acc = iter.try_fold(acc, fold)?;\n-            self.iter = None;\n-        }\n-        Try::from_ok(acc)\n+        FuseIteratorImpl::try_fold(self, acc, fold)\n     }\n \n     #[inline]\n-    default fn fold<Acc, Fold>(self, mut acc: Acc, fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, acc: Acc, fold: Fold) -> Acc\n     where\n         Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        if let Some(iter) = self.iter {\n-            acc = iter.fold(acc, fold);\n-        }\n-        acc\n+        FuseIteratorImpl::fold(self, acc, fold)\n     }\n \n     #[inline]\n-    default fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        fuse!(self.iter.find(predicate))\n+        FuseIteratorImpl::find(self, predicate)\n     }\n }\n \n@@ -125,46 +109,39 @@ where\n     I: DoubleEndedIterator,\n {\n     #[inline]\n-    default fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n-        fuse!(self.iter.next_back())\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n+        FuseDoubleEndedIteratorImpl::next_back(self)\n     }\n \n     #[inline]\n-    default fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n-        fuse!(self.iter.nth_back(n))\n+    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n+        FuseDoubleEndedIteratorImpl::nth_back(self, n)\n     }\n \n     #[inline]\n-    default fn try_rfold<Acc, Fold, R>(&mut self, mut acc: Acc, fold: Fold) -> R\n+    fn try_rfold<Acc, Fold, R>(&mut self, acc: Acc, fold: Fold) -> R\n     where\n         Self: Sized,\n         Fold: FnMut(Acc, Self::Item) -> R,\n         R: Try<Ok = Acc>,\n     {\n-        if let Some(ref mut iter) = self.iter {\n-            acc = iter.try_rfold(acc, fold)?;\n-            self.iter = None;\n-        }\n-        Try::from_ok(acc)\n+        FuseDoubleEndedIteratorImpl::try_rfold(self, acc, fold)\n     }\n \n     #[inline]\n-    default fn rfold<Acc, Fold>(self, mut acc: Acc, fold: Fold) -> Acc\n+    fn rfold<Acc, Fold>(self, acc: Acc, fold: Fold) -> Acc\n     where\n         Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        if let Some(iter) = self.iter {\n-            acc = iter.rfold(acc, fold);\n-        }\n-        acc\n+        FuseDoubleEndedIteratorImpl::rfold(self, acc, fold)\n     }\n \n     #[inline]\n-    default fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        fuse!(self.iter.rfind(predicate))\n+        FuseDoubleEndedIteratorImpl::rfind(self, predicate)\n     }\n }\n \n@@ -173,18 +150,12 @@ impl<I> ExactSizeIterator for Fuse<I>\n where\n     I: ExactSizeIterator,\n {\n-    default fn len(&self) -> usize {\n-        match self.iter {\n-            Some(ref iter) => iter.len(),\n-            None => 0,\n-        }\n+    fn len(&self) -> usize {\n+        FuseExactSizeIteratorImpl::len(self)\n     }\n \n-    default fn is_empty(&self) -> bool {\n-        match self.iter {\n-            Some(ref iter) => iter.is_empty(),\n-            None => true,\n-        }\n+    fn is_empty(&self) -> bool {\n+        FuseExactSizeIteratorImpl::is_empty(self)\n     }\n }\n \n@@ -201,7 +172,131 @@ macro_rules! unchecked {\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> Iterator for Fuse<I>\n+impl<I> Iterator for Fuse<I> where I: FusedIterator {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator + FusedIterator {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Fuse<I> where I: ExactSizeIterator + FusedIterator {}\n+\n+unsafe impl<I> TrustedRandomAccess for Fuse<I>\n+where\n+    I: TrustedRandomAccess,\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n+        match self.iter {\n+            Some(ref mut iter) => iter.get_unchecked(i),\n+            // SAFETY: the caller asserts there is an item at `i`, so we're not exhausted.\n+            None => intrinsics::unreachable(),\n+        }\n+    }\n+\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n+}\n+\n+// Fuse specialization trait\n+#[doc(hidden)]\n+trait FuseIteratorImpl<I> {\n+    type Item;\n+    fn next(&mut self) -> Option<Self::Item>;\n+    fn nth(&mut self, n: usize) -> Option<Self::Item>;\n+    fn last(self) -> Option<Self::Item>;\n+    fn count(self) -> usize;\n+    fn size_hint(&self) -> (usize, Option<usize>);\n+    fn try_fold<Acc, Fold, R>(&mut self, acc: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>;\n+    fn fold<Acc, Fold>(self, acc: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc;\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool;\n+}\n+\n+// General Fuse impl\n+#[doc(hidden)]\n+impl<I> FuseIteratorImpl<I> for Fuse<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    default fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        fuse!(self.iter.next())\n+    }\n+\n+    #[inline]\n+    default fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        fuse!(self.iter.nth(n))\n+    }\n+\n+    #[inline]\n+    default fn last(self) -> Option<I::Item> {\n+        match self.iter {\n+            Some(iter) => iter.last(),\n+            None => None,\n+        }\n+    }\n+\n+    #[inline]\n+    default fn count(self) -> usize {\n+        match self.iter {\n+            Some(iter) => iter.count(),\n+            None => 0,\n+        }\n+    }\n+\n+    #[inline]\n+    default fn size_hint(&self) -> (usize, Option<usize>) {\n+        match self.iter {\n+            Some(ref iter) => iter.size_hint(),\n+            None => (0, Some(0)),\n+        }\n+    }\n+\n+    #[inline]\n+    default fn try_fold<Acc, Fold, R>(&mut self, mut acc: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        if let Some(ref mut iter) = self.iter {\n+            acc = iter.try_fold(acc, fold)?;\n+            self.iter = None;\n+        }\n+        Try::from_ok(acc)\n+    }\n+\n+    #[inline]\n+    default fn fold<Acc, Fold>(self, mut acc: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if let Some(iter) = self.iter {\n+            acc = iter.fold(acc, fold);\n+        }\n+        acc\n+    }\n+\n+    #[inline]\n+    default fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        fuse!(self.iter.find(predicate))\n+    }\n+}\n+\n+#[doc(hidden)]\n+impl<I> FuseIteratorImpl<I> for Fuse<I>\n where\n     I: FusedIterator,\n {\n@@ -257,8 +352,77 @@ where\n     }\n }\n \n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> DoubleEndedIterator for Fuse<I>\n+#[doc(hidden)]\n+trait FuseDoubleEndedIteratorImpl<I> {\n+    type Item;\n+    fn next_back(&mut self) -> Option<Self::Item>;\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item>;\n+    fn try_rfold<Acc, Fold, R>(&mut self, acc: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>;\n+    fn rfold<Acc, Fold>(self, acc: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc;\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool;\n+}\n+\n+#[doc(hidden)]\n+impl<I> FuseDoubleEndedIteratorImpl<I> for Fuse<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    default fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n+        fuse!(self.iter.next_back())\n+    }\n+\n+    #[inline]\n+    default fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n+        fuse!(self.iter.nth_back(n))\n+    }\n+\n+    #[inline]\n+    default fn try_rfold<Acc, Fold, R>(&mut self, mut acc: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        if let Some(ref mut iter) = self.iter {\n+            acc = iter.try_rfold(acc, fold)?;\n+            self.iter = None;\n+        }\n+        Try::from_ok(acc)\n+    }\n+\n+    #[inline]\n+    default fn rfold<Acc, Fold>(self, mut acc: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if let Some(iter) = self.iter {\n+            acc = iter.rfold(acc, fold);\n+        }\n+        acc\n+    }\n+\n+    #[inline]\n+    default fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        fuse!(self.iter.rfind(predicate))\n+    }\n+}\n+\n+#[doc(hidden)]\n+impl<I> FuseDoubleEndedIteratorImpl<I> for Fuse<I>\n where\n     I: DoubleEndedIterator + FusedIterator,\n {\n@@ -299,33 +463,40 @@ where\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Fuse<I>\n+#[doc(hidden)]\n+trait FuseExactSizeIteratorImpl<I> {\n+    fn len(&self) -> usize;\n+    fn is_empty(&self) -> bool;\n+}\n+\n+impl<I> FuseExactSizeIteratorImpl<I> for Fuse<I>\n where\n-    I: ExactSizeIterator + FusedIterator,\n+    I: ExactSizeIterator,\n {\n-    fn len(&self) -> usize {\n-        unchecked!(self).len()\n+    default fn len(&self) -> usize {\n+        match self.iter {\n+            Some(ref iter) => iter.len(),\n+            None => 0,\n+        }\n     }\n \n-    fn is_empty(&self) -> bool {\n-        unchecked!(self).is_empty()\n+    default fn is_empty(&self) -> bool {\n+        match self.iter {\n+            Some(ref iter) => iter.is_empty(),\n+            None => true,\n+        }\n     }\n }\n \n-unsafe impl<I> TrustedRandomAccess for Fuse<I>\n+impl<I> FuseExactSizeIteratorImpl<I> for Fuse<I>\n where\n-    I: TrustedRandomAccess,\n+    I: ExactSizeIterator + FusedIterator,\n {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n-        match self.iter {\n-            Some(ref mut iter) => iter.get_unchecked(i),\n-            // SAFETY: the caller asserts there is an item at `i`, so we're not exhausted.\n-            None => intrinsics::unreachable(),\n-        }\n+    fn len(&self) -> usize {\n+        unchecked!(self).len()\n     }\n \n-    fn may_have_side_effect() -> bool {\n-        I::may_have_side_effect()\n+    fn is_empty(&self) -> bool {\n+        unchecked!(self).is_empty()\n     }\n }"}]}