{"sha": "684e2aace5670efd1df8c578baeefa7739cd2be1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NGUyYWFjZTU2NzBlZmQxZGY4YzU3OGJhZWVmYTc3MzljZDJiZTE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-07T11:47:09Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-07T14:52:41Z"}, "message": "Rollup merge of #32699 - bluss:slice-memcmp, r=alexcrichton\n\nSpecialize equality for [T] and comparison for [u8] to use memcmp when possible\n\nSpecialize equality for [T] and comparison for [u8] to use memcmp when possible\n\nWhere T is a type that can be compared for equality bytewise, we can use\nmemcmp. We can also use memcmp for PartialOrd, Ord for [u8].\n\nUse specialization to call memcmp in PartialEq for slices for certain element types. This PR does not change the user visible API since the implementation uses an intermediate trait. See commit messages for more information.\n\nThe memcmp signature was changed from `*const i8` to `*const u8` which is in line with how the memcmp function is defined in C (taking const void * arguments, interpreting the values as unsigned bytes for purposes of the comparison).", "tree": {"sha": "6a3517045daa12be986e4bba1d0a8eade4e44d1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a3517045daa12be986e4bba1d0a8eade4e44d1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/684e2aace5670efd1df8c578baeefa7739cd2be1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/684e2aace5670efd1df8c578baeefa7739cd2be1", "html_url": "https://github.com/rust-lang/rust/commit/684e2aace5670efd1df8c578baeefa7739cd2be1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/684e2aace5670efd1df8c578baeefa7739cd2be1/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76e2349c4417788e03f877fe18d13b521b455a4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/76e2349c4417788e03f877fe18d13b521b455a4b", "html_url": "https://github.com/rust-lang/rust/commit/76e2349c4417788e03f877fe18d13b521b455a4b"}, {"sha": "a6c27be0b1074684ae918ab7132bbeb8f75d4f2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6c27be0b1074684ae918ab7132bbeb8f75d4f2a", "html_url": "https://github.com/rust-lang/rust/commit/a6c27be0b1074684ae918ab7132bbeb8f75d4f2a"}], "stats": {"total": 223, "additions": 179, "deletions": 44}, "files": [{"sha": "236c151891d11880d0d2da424ac29bc8247c7531", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/684e2aace5670efd1df8c578baeefa7739cd2be1/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/684e2aace5670efd1df8c578baeefa7739cd2be1/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=684e2aace5670efd1df8c578baeefa7739cd2be1", "patch": "@@ -574,18 +574,48 @@ fn test_slice_2() {\n     assert_eq!(v[1], 3);\n }\n \n+macro_rules! assert_order {\n+    (Greater, $a:expr, $b:expr) => {\n+        assert_eq!($a.cmp($b), Greater);\n+        assert!($a > $b);\n+    };\n+    (Less, $a:expr, $b:expr) => {\n+        assert_eq!($a.cmp($b), Less);\n+        assert!($a < $b);\n+    };\n+    (Equal, $a:expr, $b:expr) => {\n+        assert_eq!($a.cmp($b), Equal);\n+        assert_eq!($a, $b);\n+    }\n+}\n+\n+#[test]\n+fn test_total_ord_u8() {\n+    let c = &[1u8, 2, 3];\n+    assert_order!(Greater, &[1u8, 2, 3, 4][..], &c[..]);\n+    let c = &[1u8, 2, 3, 4];\n+    assert_order!(Less, &[1u8, 2, 3][..], &c[..]);\n+    let c = &[1u8, 2, 3, 6];\n+    assert_order!(Equal, &[1u8, 2, 3, 6][..], &c[..]);\n+    let c = &[1u8, 2, 3, 4, 5, 6];\n+    assert_order!(Less, &[1u8, 2, 3, 4, 5, 5, 5, 5][..], &c[..]);\n+    let c = &[1u8, 2, 3, 4];\n+    assert_order!(Greater, &[2u8, 2][..], &c[..]);\n+}\n+\n+\n #[test]\n-fn test_total_ord() {\n+fn test_total_ord_i32() {\n     let c = &[1, 2, 3];\n-    [1, 2, 3, 4][..].cmp(c) == Greater;\n+    assert_order!(Greater, &[1, 2, 3, 4][..], &c[..]);\n     let c = &[1, 2, 3, 4];\n-    [1, 2, 3][..].cmp(c) == Less;\n+    assert_order!(Less, &[1, 2, 3][..], &c[..]);\n     let c = &[1, 2, 3, 6];\n-    [1, 2, 3, 4][..].cmp(c) == Equal;\n+    assert_order!(Equal, &[1, 2, 3, 6][..], &c[..]);\n     let c = &[1, 2, 3, 4, 5, 6];\n-    [1, 2, 3, 4, 5, 5, 5, 5][..].cmp(c) == Less;\n+    assert_order!(Less, &[1, 2, 3, 4, 5, 5, 5, 5][..], &c[..]);\n     let c = &[1, 2, 3, 4];\n-    [2, 2][..].cmp(c) == Greater;\n+    assert_order!(Greater, &[2, 2][..], &c[..]);\n }\n \n #[test]"}, {"sha": "fa5e90562d80e1b28721b0b3baea998f569262ca", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/684e2aace5670efd1df8c578baeefa7739cd2be1/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/684e2aace5670efd1df8c578baeefa7739cd2be1/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=684e2aace5670efd1df8c578baeefa7739cd2be1", "patch": "@@ -75,6 +75,7 @@\n #![feature(unwind_attributes)]\n #![feature(repr_simd, platform_intrinsics)]\n #![feature(rustc_attrs)]\n+#![feature(specialization)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(question_mark)]"}, {"sha": "25082eed2fe6f4b7843eb06064110157f8366f00", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 139, "deletions": 16, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/684e2aace5670efd1df8c578baeefa7739cd2be1/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/684e2aace5670efd1df8c578baeefa7739cd2be1/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=684e2aace5670efd1df8c578baeefa7739cd2be1", "patch": "@@ -1630,12 +1630,60 @@ pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {\n }\n \n //\n-// Boilerplate traits\n+// Comparison traits\n //\n \n+extern {\n+    /// Call implementation provided memcmp\n+    ///\n+    /// Interprets the data as u8.\n+    ///\n+    /// Return 0 for equal, < 0 for less than and > 0 for greater\n+    /// than.\n+    // FIXME(#32610): Return type should be c_int\n+    fn memcmp(s1: *const u8, s2: *const u8, n: usize) -> i32;\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     fn eq(&self, other: &[B]) -> bool {\n+        SlicePartialEq::equal(self, other)\n+    }\n+\n+    fn ne(&self, other: &[B]) -> bool {\n+        SlicePartialEq::not_equal(self, other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Eq> Eq for [T] {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Ord> Ord for [T] {\n+    fn cmp(&self, other: &[T]) -> Ordering {\n+        SliceOrd::compare(self, other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: PartialOrd> PartialOrd for [T] {\n+    fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n+        SlicePartialOrd::partial_compare(self, other)\n+    }\n+}\n+\n+#[doc(hidden)]\n+// intermediate trait for specialization of slice's PartialEq\n+trait SlicePartialEq<B> {\n+    fn equal(&self, other: &[B]) -> bool;\n+    fn not_equal(&self, other: &[B]) -> bool;\n+}\n+\n+// Generic slice equality\n+impl<A, B> SlicePartialEq<B> for [A]\n+    where A: PartialEq<B>\n+{\n+    default fn equal(&self, other: &[B]) -> bool {\n         if self.len() != other.len() {\n             return false;\n         }\n@@ -1648,7 +1696,8 @@ impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n \n         true\n     }\n-    fn ne(&self, other: &[B]) -> bool {\n+\n+    default fn not_equal(&self, other: &[B]) -> bool {\n         if self.len() != other.len() {\n             return true;\n         }\n@@ -1663,12 +1712,36 @@ impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Eq> Eq for [T] {}\n+// Use memcmp for bytewise equality when the types allow\n+impl<A> SlicePartialEq<A> for [A]\n+    where A: PartialEq<A> + BytewiseEquality\n+{\n+    fn equal(&self, other: &[A]) -> bool {\n+        if self.len() != other.len() {\n+            return false;\n+        }\n+        unsafe {\n+            let size = mem::size_of_val(self);\n+            memcmp(self.as_ptr() as *const u8,\n+                   other.as_ptr() as *const u8, size) == 0\n+        }\n+    }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord> Ord for [T] {\n-    fn cmp(&self, other: &[T]) -> Ordering {\n+    fn not_equal(&self, other: &[A]) -> bool {\n+        !self.equal(other)\n+    }\n+}\n+\n+#[doc(hidden)]\n+// intermediate trait for specialization of slice's PartialOrd\n+trait SlicePartialOrd<B> {\n+    fn partial_compare(&self, other: &[B]) -> Option<Ordering>;\n+}\n+\n+impl<A> SlicePartialOrd<A> for [A]\n+    where A: PartialOrd\n+{\n+    default fn partial_compare(&self, other: &[A]) -> Option<Ordering> {\n         let l = cmp::min(self.len(), other.len());\n \n         // Slice to the loop iteration range to enable bound check\n@@ -1677,19 +1750,33 @@ impl<T: Ord> Ord for [T] {\n         let rhs = &other[..l];\n \n         for i in 0..l {\n-            match lhs[i].cmp(&rhs[i]) {\n-                Ordering::Equal => (),\n+            match lhs[i].partial_cmp(&rhs[i]) {\n+                Some(Ordering::Equal) => (),\n                 non_eq => return non_eq,\n             }\n         }\n \n-        self.len().cmp(&other.len())\n+        self.len().partial_cmp(&other.len())\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: PartialOrd> PartialOrd for [T] {\n-    fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n+impl SlicePartialOrd<u8> for [u8] {\n+    #[inline]\n+    fn partial_compare(&self, other: &[u8]) -> Option<Ordering> {\n+        Some(SliceOrd::compare(self, other))\n+    }\n+}\n+\n+#[doc(hidden)]\n+// intermediate trait for specialization of slice's Ord\n+trait SliceOrd<B> {\n+    fn compare(&self, other: &[B]) -> Ordering;\n+}\n+\n+impl<A> SliceOrd<A> for [A]\n+    where A: Ord\n+{\n+    default fn compare(&self, other: &[A]) -> Ordering {\n         let l = cmp::min(self.len(), other.len());\n \n         // Slice to the loop iteration range to enable bound check\n@@ -1698,12 +1785,48 @@ impl<T: PartialOrd> PartialOrd for [T] {\n         let rhs = &other[..l];\n \n         for i in 0..l {\n-            match lhs[i].partial_cmp(&rhs[i]) {\n-                Some(Ordering::Equal) => (),\n+            match lhs[i].cmp(&rhs[i]) {\n+                Ordering::Equal => (),\n                 non_eq => return non_eq,\n             }\n         }\n \n-        self.len().partial_cmp(&other.len())\n+        self.len().cmp(&other.len())\n     }\n }\n+\n+// memcmp compares a sequence of unsigned bytes lexicographically.\n+// this matches the order we want for [u8], but no others (not even [i8]).\n+impl SliceOrd<u8> for [u8] {\n+    #[inline]\n+    fn compare(&self, other: &[u8]) -> Ordering {\n+        let order = unsafe {\n+            memcmp(self.as_ptr(), other.as_ptr(),\n+                   cmp::min(self.len(), other.len()))\n+        };\n+        if order == 0 {\n+            self.len().cmp(&other.len())\n+        } else if order < 0 {\n+            Less\n+        } else {\n+            Greater\n+        }\n+    }\n+}\n+\n+#[doc(hidden)]\n+/// Trait implemented for types that can be compared for equality using\n+/// their bytewise representation\n+trait BytewiseEquality { }\n+\n+macro_rules! impl_marker_for {\n+    ($traitname:ident, $($ty:ty)*) => {\n+        $(\n+            impl $traitname for $ty { }\n+        )*\n+    }\n+}\n+\n+impl_marker_for!(BytewiseEquality,\n+                 u8 i8 u16 i16 u32 i32 u64 i64 usize isize char bool);\n+"}, {"sha": "305546df5be2da171140dd5aaad372dae1ea6ba2", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/684e2aace5670efd1df8c578baeefa7739cd2be1/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/684e2aace5670efd1df8c578baeefa7739cd2be1/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=684e2aace5670efd1df8c578baeefa7739cd2be1", "patch": "@@ -1150,16 +1150,7 @@ Section: Comparing strings\n #[lang = \"str_eq\"]\n #[inline]\n fn eq_slice(a: &str, b: &str) -> bool {\n-    a.len() == b.len() && unsafe { cmp_slice(a, b, a.len()) == 0 }\n-}\n-\n-/// Bytewise slice comparison.\n-/// NOTE: This uses the system's memcmp, which is currently dramatically\n-/// faster than comparing each byte in a loop.\n-#[inline]\n-unsafe fn cmp_slice(a: &str, b: &str, len: usize) -> i32 {\n-    extern { fn memcmp(s1: *const i8, s2: *const i8, n: usize) -> i32; }\n-    memcmp(a.as_ptr() as *const i8, b.as_ptr() as *const i8, len)\n+    a.as_bytes() == b.as_bytes()\n }\n \n /*\n@@ -1328,8 +1319,7 @@ Section: Trait implementations\n */\n \n mod traits {\n-    use cmp::{self, Ordering, Ord, PartialEq, PartialOrd, Eq};\n-    use cmp::Ordering::{Less, Greater};\n+    use cmp::{Ord, Ordering, PartialEq, PartialOrd, Eq};\n     use iter::Iterator;\n     use option::Option;\n     use option::Option::Some;\n@@ -1340,16 +1330,7 @@ mod traits {\n     impl Ord for str {\n         #[inline]\n         fn cmp(&self, other: &str) -> Ordering {\n-            let cmp = unsafe {\n-                super::cmp_slice(self, other, cmp::min(self.len(), other.len()))\n-            };\n-            if cmp == 0 {\n-                self.len().cmp(&other.len())\n-            } else if cmp < 0 {\n-                Less\n-            } else {\n-                Greater\n-            }\n+            self.as_bytes().cmp(other.as_bytes())\n         }\n     }\n "}]}