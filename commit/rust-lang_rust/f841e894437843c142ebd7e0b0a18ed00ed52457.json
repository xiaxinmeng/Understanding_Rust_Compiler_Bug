{"sha": "f841e894437843c142ebd7e0b0a18ed00ed52457", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4NDFlODk0NDM3ODQzYzE0MmViZDdlMGIwYTE4ZWQwMGVkNTI0NTc=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-08-26T00:42:38Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-08-26T01:28:23Z"}, "message": "Support unchecked blocks\n\nThis patch supports the syntax\n\n    unchecked {\n      ...\n    }\n\n    to disable purity checking within a block. Presumably it will only be\n    used within a declared \"pure fn\". However, there is no checking that it\n    doesn't occur elsewhere, and it would be harmless for it to do so.\n\n    I went with Lindsey's suggestion for the syntax, but it's subject to\n    change.\n\n    This allows you to write code that uses predicates that call arbitrary\n    Rust functions, but you must declare your intentions by wrapping it in\n    an unchecked { ... } block. The test case run-pass/unchecked-predicates.rs\n    demonstrates how to do that.", "tree": {"sha": "fac7eed5de504e4246754bd7eea9a2e25c055090", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fac7eed5de504e4246754bd7eea9a2e25c055090"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f841e894437843c142ebd7e0b0a18ed00ed52457", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f841e894437843c142ebd7e0b0a18ed00ed52457", "html_url": "https://github.com/rust-lang/rust/commit/f841e894437843c142ebd7e0b0a18ed00ed52457", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f841e894437843c142ebd7e0b0a18ed00ed52457/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9bc3cb10c4d1e856998c8e35ce7d89e0d74f4d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9bc3cb10c4d1e856998c8e35ce7d89e0d74f4d6", "html_url": "https://github.com/rust-lang/rust/commit/d9bc3cb10c4d1e856998c8e35ce7d89e0d74f4d6"}], "stats": {"total": 74, "additions": 55, "deletions": 19}, "files": [{"sha": "526bf20ebb76c2b57d2279d7ca3220418e4c20cc", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f841e894437843c142ebd7e0b0a18ed00ed52457/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f841e894437843c142ebd7e0b0a18ed00ed52457/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=f841e894437843c142ebd7e0b0a18ed00ed52457", "patch": "@@ -77,7 +77,7 @@ fn fold_block(cfg: &ast::crate_cfg, b: &ast::blk_, fld: fold::ast_fold) ->\n     let filtered_stmts = vec::filter_map(filter, b.stmts);\n     ret {stmts: vec::map(fld.fold_stmt, filtered_stmts),\n          expr: option::map(fld.fold_expr, b.expr),\n-         id: b.id};\n+         id: b.id, rules: b.rules};\n }\n \n fn item_in_cfg(cfg: &ast::crate_cfg, item: &@ast::item) -> bool {"}, {"sha": "d76e26064a7fad3aff5935b6ae694f3ca17a3245", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f841e894437843c142ebd7e0b0a18ed00ed52457/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f841e894437843c142ebd7e0b0a18ed00ed52457/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=f841e894437843c142ebd7e0b0a18ed00ed52457", "patch": "@@ -4,7 +4,8 @@ import std::option;\n import std::vec;\n import syntax::ast;\n import syntax::ast_util;\n-import syntax::ast_util::dummy_sp;\n+import syntax::ast_util::*;\n+//import syntax::ast_util::dummy_sp;\n import syntax::fold;\n import syntax::print::pprust;\n import front::attr;\n@@ -189,8 +190,8 @@ fn mk_tests(cx: &test_ctxt) -> @ast::item {\n     // The vector of test_descs for this crate\n     let test_descs = mk_test_desc_vec(cx);\n \n-    let body_: ast::blk_ =\n-        {stmts: [], expr: option::some(test_descs), id: cx.next_node_id()};\n+    let body_: ast::blk_ = checked_blk([], option::some(test_descs),\n+                                       cx.next_node_id());\n     let body = nospan(body_);\n \n     let fn_ = {decl: decl, proto: proto, body: body};\n@@ -305,10 +306,8 @@ fn mk_main(cx: &test_ctxt) -> @ast::item {\n \n     let test_main_call_expr = mk_test_main_call(cx);\n \n-    let body_: ast::blk_ =\n-        {stmts: [],\n-         expr: option::some(test_main_call_expr),\n-         id: cx.next_node_id()};\n+    let body_: ast::blk_ = checked_blk([], option::some(test_main_call_expr),\n+                                       cx.next_node_id());\n     let body = {node: body_, span: dummy_sp()};\n \n     let fn_ = {decl: decl, proto: proto, body: body};"}, {"sha": "7519e2541f584011fc3002773b0c8237f46840d5", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f841e894437843c142ebd7e0b0a18ed00ed52457/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f841e894437843c142ebd7e0b0a18ed00ed52457/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=f841e894437843c142ebd7e0b0a18ed00ed52457", "patch": "@@ -2081,7 +2081,12 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         check_fn(fcx.ccx, f, id, some(fcx));\n       }\n       ast::expr_block(b) {\n-        bot = check_block(fcx, b);\n+        // If this is an unchecked block, turn off purity-checking\n+        let fcx_for_block = alt b.node.rules {\n+          ast::unchecked. { @{ purity: ast::impure_fn with *fcx } }\n+          _               { fcx }\n+        };\n+        bot = check_block(fcx_for_block, b);\n         let typ =\n             alt b.node.expr {\n               some(expr) { expr_ty(tcx, expr) }"}, {"sha": "d44baebb6f3d3e95f038a4e60ca6ab2888a845aa", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f841e894437843c142ebd7e0b0a18ed00ed52457/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f841e894437843c142ebd7e0b0a18ed00ed52457/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=f841e894437843c142ebd7e0b0a18ed00ed52457", "patch": "@@ -82,7 +82,8 @@ tag meta_item_ {\n \n type blk = spanned<blk_>;\n \n-type blk_ = {stmts: [@stmt], expr: option::t<@expr>, id: node_id};\n+type blk_ = {stmts: [@stmt], expr: option::t<@expr>,\n+    id: node_id, rules: check_mode};\n \n type pat = {id: node_id, node: pat_, span: span};\n \n@@ -223,6 +224,15 @@ tag expr_ {\n     expr_uniq(@expr);\n }\n \n+/*\n+// Says whether this is a block the user marked as\n+// \"unchecked\"\n+tag blk_sort {\n+    blk_unchecked; // declared as \"exception to effect-checking rules\"\n+    blk_checked; // all typing rules apply\n+}\n+*/\n+\n type mac = spanned<mac_>;\n \n tag mac_ {"}, {"sha": "517e252dd9cca460753552baaf66ba3fa8be6522", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f841e894437843c142ebd7e0b0a18ed00ed52457/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f841e894437843c142ebd7e0b0a18ed00ed52457/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=f841e894437843c142ebd7e0b0a18ed00ed52457", "patch": "@@ -184,10 +184,14 @@ fn eq_ty(a: &@ty, b: &@ty) -> bool { ret std::box::ptr_eq(a, b); }\n fn hash_ty(t: &@ty) -> uint { ret t.span.lo << 16u + t.span.hi; }\n \n fn block_from_expr(e: @expr) -> blk {\n-    let blk_ = {stmts: [], expr: option::some::<@expr>(e), id: e.id};\n+    let blk_ = checked_blk([], option::some::<@expr>(e), e.id);\n     ret {node: blk_, span: e.span};\n }\n \n+fn checked_blk(stmts1: [@stmt], expr1: option::t<@expr>, id1: node_id)\n+    -> blk_ {\n+    ret {stmts: stmts1, expr: expr1, id: id1, rules: checked};\n+}\n \n fn obj_field_from_anon_obj_field(f: &anon_obj_field) -> obj_field {\n     ret {mut: f.mut, ty: f.ty, ident: f.ident, id: f.id};"}, {"sha": "770ed307e1418ef51e60b4ca4577671adf7f75f8", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f841e894437843c142ebd7e0b0a18ed00ed52457/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f841e894437843c142ebd7e0b0a18ed00ed52457/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=f841e894437843c142ebd7e0b0a18ed00ed52457", "patch": "@@ -255,7 +255,8 @@ fn noop_fold_method(m: &method_, fld: ast_fold) -> method_ {\n fn noop_fold_block(b: &blk_, fld: ast_fold) -> blk_ {\n     ret {stmts: vec::map(fld.fold_stmt, b.stmts),\n          expr: option::map(fld.fold_expr, b.expr),\n-         id: b.id};\n+         id: b.id,\n+         rules: b.rules};\n }\n \n fn noop_fold_stmt(s: &stmt_, fld: ast_fold) -> stmt_ {"}, {"sha": "729338b4b3022ad119944943c9878762235fda73", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f841e894437843c142ebd7e0b0a18ed00ed52457/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f841e894437843c142ebd7e0b0a18ed00ed52457/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=f841e894437843c142ebd7e0b0a18ed00ed52457", "patch": "@@ -837,7 +837,7 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         } else if p.peek() == token::BINOP(token::OR) {\n             ret parse_fn_block_expr(p);\n         } else {\n-            let blk = parse_block_tail(p, lo);\n+            let blk = parse_block_tail(p, lo, ast::checked);\n             ret mk_expr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n         }\n     } else if eat_word(p, \"if\") {\n@@ -860,6 +860,10 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         ret parse_fn_expr(p, ast::proto_block);\n     } else if eat_word(p, \"lambda\") {\n         ret parse_fn_expr(p, ast::proto_closure);\n+    } else if eat_word(p, \"unchecked\") {\n+        expect(p, token::LBRACE);\n+        let blk = parse_block_tail(p, lo, ast::unchecked);\n+        ret mk_expr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n     } else if p.peek() == token::LBRACKET {\n         p.bump();\n         let mut = parse_mutability(p);\n@@ -876,7 +880,7 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         ret mk_mac_expr(p, lo, p.get_hi_pos(), ast::mac_embed_type(ty))\n     } else if p.peek() == token::POUND_LBRACE {\n         p.bump();\n-        let blk = ast::mac_embed_block(parse_block_tail(p, lo));\n+        let blk = ast::mac_embed_block(parse_block_tail(p, lo, ast::checked));\n         ret mk_mac_expr(p, lo, p.get_hi_pos(), blk);\n     } else if p.peek() == token::ELLIPSIS {\n         p.bump();\n@@ -1309,7 +1313,7 @@ fn parse_fn_expr(p: &parser, proto: ast::proto) -> @ast::expr {\n fn parse_fn_block_expr(p: &parser) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n     let decl = parse_fn_block_decl(p);\n-    let body = parse_block_tail(p, lo);\n+    let body = parse_block_tail(p, lo, ast::checked);\n     let _fn = {decl: decl, proto: ast::proto_block, body: body};\n     ret mk_expr(p, lo, body.span.hi, ast::expr_fn(_fn));\n }\n@@ -1664,12 +1668,20 @@ fn stmt_ends_with_semi(stmt: &ast::stmt) -> bool {\n \n fn parse_block(p: &parser) -> ast::blk {\n     let lo = p.get_lo_pos();\n-    expect(p, token::LBRACE);\n-    be parse_block_tail(p, lo);\n+    if eat_word(p, \"unchecked\") {\n+        be parse_block_tail(p, lo, ast::unchecked);\n+    }\n+    else {\n+        expect(p, token::LBRACE);\n+        be parse_block_tail(p, lo, ast::checked);\n+    }\n }\n \n+// Precondition: already parsed the '{' or '#{'\n+// I guess that also means \"already parsed the 'impure'\" if\n+// necessary, and this should take a qualifier.\n // some blocks start with \"#{\"...\n-fn parse_block_tail(p: &parser, lo: uint) -> ast::blk {\n+fn parse_block_tail(p: &parser, lo: uint, s: ast::check_mode) -> ast::blk {\n     let stmts: [@ast::stmt] = [];\n     let expr: option::t<@ast::expr> = none;\n     while p.peek() != token::RBRACE {\n@@ -1710,7 +1722,7 @@ fn parse_block_tail(p: &parser, lo: uint) -> ast::blk {\n     }\n     let hi = p.get_hi_pos();\n     p.bump();\n-    let bloc = {stmts: stmts, expr: expr, id: p.get_id()};\n+    let bloc = {stmts: stmts, expr: expr, id: p.get_id(), rules: s};\n     ret spanned(lo, hi, bloc);\n }\n "}, {"sha": "52ee1eaeacc14bc42fda7355244240e896472367", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f841e894437843c142ebd7e0b0a18ed00ed52457/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f841e894437843c142ebd7e0b0a18ed00ed52457/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=f841e894437843c142ebd7e0b0a18ed00ed52457", "patch": "@@ -579,6 +579,11 @@ tag embed_type { block_macro; block_block_fn; block_normal; }\n \n fn print_possibly_embedded_block(s: &ps, blk: &ast::blk, embedded: embed_type,\n                                  indented: uint) {\n+    alt blk.node.rules {\n+      ast::unchecked. { word(s.s, \"unchecked\"); }\n+      _ {}\n+    }\n+\n     maybe_print_comment(s, blk.span.lo);\n     let ann_node = node_block(s, blk);\n     s.ann.pre(ann_node);"}]}