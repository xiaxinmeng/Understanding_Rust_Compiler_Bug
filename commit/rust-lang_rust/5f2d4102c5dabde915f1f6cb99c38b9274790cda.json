{"sha": "5f2d4102c5dabde915f1f6cb99c38b9274790cda", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMmQ0MTAyYzVkYWJkZTkxNWYxZjZjYjk5YzM4YjkyNzQ3OTBjZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-22T02:39:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-22T02:39:53Z"}, "message": "auto merge of #5479 : Kimundi/rust/str-dealloc, r=z0w0\n\nThis makes the `trim` and `substr` functions return a slice instead of an `~str`, and removes the unnecessary `Trimmable` trait (`StrSlice` already contains the same functionality).\r\n\r\nAlso moves the `ToStr` implementations for the three str types into the str module in anticipation of further untangling.", "tree": {"sha": "ef06cf4055b220ccc73f5dcd6c3c62faf53da292", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef06cf4055b220ccc73f5dcd6c3c62faf53da292"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f2d4102c5dabde915f1f6cb99c38b9274790cda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f2d4102c5dabde915f1f6cb99c38b9274790cda", "html_url": "https://github.com/rust-lang/rust/commit/5f2d4102c5dabde915f1f6cb99c38b9274790cda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f2d4102c5dabde915f1f6cb99c38b9274790cda/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8c0da39402818db2d41369826956538ba9672e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8c0da39402818db2d41369826956538ba9672e1", "html_url": "https://github.com/rust-lang/rust/commit/d8c0da39402818db2d41369826956538ba9672e1"}, {"sha": "0a47cd5ef183d5a7e763484e211f4b3aed6d72de", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a47cd5ef183d5a7e763484e211f4b3aed6d72de", "html_url": "https://github.com/rust-lang/rust/commit/0a47cd5ef183d5a7e763484e211f4b3aed6d72de"}], "stats": {"total": 226, "additions": 116, "deletions": 110}, "files": [{"sha": "1f7d05060c4201668971e2377b934d75902d105d", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=5f2d4102c5dabde915f1f6cb99c38b9274790cda", "patch": "@@ -198,7 +198,7 @@ pub use path::WindowsPath;\n pub use path::PosixPath;\n \n pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};\n-pub use str::{StrSlice, Trimmable};\n+pub use str::{StrSlice};\n pub use container::{Container, Mutable};\n pub use vec::{CopyableVector, ImmutableVector};\n pub use vec::{ImmutableEqVector, ImmutableCopyableVector};"}, {"sha": "d0307c8bf70de8479a45595010ded2576a4e9b79", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=5f2d4102c5dabde915f1f6cb99c38b9274790cda", "patch": "@@ -36,7 +36,7 @@ pub use path::Path;\n pub use path::PosixPath;\n pub use path::WindowsPath;\n pub use ptr::Ptr;\n-pub use str::{StrSlice, Trimmable, OwnedStr};\n+pub use str::{StrSlice, OwnedStr};\n pub use to_bytes::IterBytes;\n pub use to_str::ToStr;\n pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};"}, {"sha": "980e984f75b3b030f0fb521bfe50516e8da0af62", "filename": "src/libcore/str.rs", "status": "modified", "additions": 97, "deletions": 85, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=5f2d4102c5dabde915f1f6cb99c38b9274790cda", "patch": "@@ -29,6 +29,7 @@ use str;\n use u8;\n use uint;\n use vec;\n+use to_str::ToStr;\n \n #[cfg(notest)] use cmp::{Eq, Ord};\n \n@@ -53,6 +54,19 @@ pub pure fn from_slice(s: &str) -> ~str {\n     unsafe { raw::slice_bytes_unique(s, 0, len(s)) }\n }\n \n+impl ToStr for ~str {\n+    #[inline(always)]\n+    pure fn to_str(&self) -> ~str { copy *self }\n+}\n+impl ToStr for &'self str {\n+    #[inline(always)]\n+    pure fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n+}\n+impl ToStr for @str {\n+    #[inline(always)]\n+    pure fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n+}\n+\n /**\n  * Convert a byte to a UTF-8 string\n  *\n@@ -299,12 +313,12 @@ pub fn unshift_char(s: &mut ~str, ch: char) {\n  * * chars_to_trim - A vector of chars\n  *\n  */\n-pub pure fn trim_left_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n-    if chars_to_trim.is_empty() { return from_slice(s); }\n+pub pure fn trim_left_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n+    if chars_to_trim.is_empty() { return s; }\n \n     match find(s, |c| !chars_to_trim.contains(&c)) {\n-      None => ~\"\",\n-      Some(first) => unsafe { raw::slice_bytes_unique(s, first, s.len()) }\n+      None => \"\",\n+      Some(first) => unsafe { raw::slice_bytes(s, first, s.len()) }\n     }\n }\n \n@@ -317,14 +331,14 @@ pub pure fn trim_left_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n  * * chars_to_trim - A vector of chars\n  *\n  */\n-pub pure fn trim_right_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n-    if chars_to_trim.is_empty() { return str::from_slice(s); }\n+pub pure fn trim_right_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n+    if chars_to_trim.is_empty() { return s; }\n \n     match rfind(s, |c| !chars_to_trim.contains(&c)) {\n-      None => ~\"\",\n+      None => \"\",\n       Some(last) => {\n         let next = char_range_at(s, last).next;\n-        unsafe { raw::slice_bytes_unique(s, 0u, next) }\n+        unsafe { raw::slice_bytes(s, 0u, next) }\n       }\n     }\n }\n@@ -338,31 +352,31 @@ pub pure fn trim_right_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n  * * chars_to_trim - A vector of chars\n  *\n  */\n-pub pure fn trim_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n+pub pure fn trim_chars(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n     trim_left_chars(trim_right_chars(s, chars_to_trim), chars_to_trim)\n }\n \n /// Returns a string with leading whitespace removed\n-pub pure fn trim_left(s: &str) -> ~str {\n+pub pure fn trim_left(s: &'a str) -> &'a str {\n     match find(s, |c| !char::is_whitespace(c)) {\n-      None => ~\"\",\n-      Some(first) => unsafe { raw::slice_bytes_unique(s, first, len(s)) }\n+      None => \"\",\n+      Some(first) => unsafe { raw::slice_bytes(s, first, len(s)) }\n     }\n }\n \n /// Returns a string with trailing whitespace removed\n-pub pure fn trim_right(s: &str) -> ~str {\n+pub pure fn trim_right(s: &'a str) -> &'a str {\n     match rfind(s, |c| !char::is_whitespace(c)) {\n-      None => ~\"\",\n+      None => \"\",\n       Some(last) => {\n         let next = char_range_at(s, last).next;\n-        unsafe { raw::slice_bytes_unique(s, 0u, next) }\n+        unsafe { raw::slice_bytes(s, 0u, next) }\n       }\n     }\n }\n \n /// Returns a string with leading and trailing whitespace removed\n-pub pure fn trim(s: &str) -> ~str { trim_left(trim_right(s)) }\n+pub pure fn trim(s: &'a str) -> &'a str { trim_left(trim_right(s)) }\n \n /*\n Section: Transforming strings\n@@ -407,8 +421,8 @@ pub pure fn chars(s: &str) -> ~[char] {\n  * Returns a string containing `n` characters starting at byte offset\n  * `begin`.\n  */\n-pub pure fn substr(s: &str, begin: uint, n: uint) -> ~str {\n-    slice(s, begin, begin + count_bytes(s, begin, n)).to_owned()\n+pub pure fn substr(s: &'a str, begin: uint, n: uint) -> &'a str {\n+    slice(s, begin, begin + count_bytes(s, begin, n))\n }\n \n /**\n@@ -2221,25 +2235,6 @@ pub mod raw {\n \n }\n \n-pub trait Trimmable {\n-    pure fn trim(&self) -> Self;\n-    pure fn trim_left(&self) -> Self;\n-    pure fn trim_right(&self) -> Self;\n-}\n-\n-/// Extension methods for strings\n-impl Trimmable for ~str {\n-    /// Returns a string with leading and trailing whitespace removed\n-    #[inline]\n-    pure fn trim(&self) -> ~str { trim(*self) }\n-    /// Returns a string with leading whitespace removed\n-    #[inline]\n-    pure fn trim_left(&self) -> ~str { trim_left(*self) }\n-    /// Returns a string with trailing whitespace removed\n-    #[inline]\n-    pure fn trim_right(&self) -> ~str { trim_right(*self) }\n-}\n-\n #[cfg(notest)]\n pub mod traits {\n     use ops::Add;\n@@ -2280,14 +2275,17 @@ pub trait StrSlice {\n     pure fn split_char(&self, sep: char) -> ~[~str];\n     pure fn split_str(&self, sep: &'a str) -> ~[~str];\n     pure fn starts_with(&self, needle: &'a str) -> bool;\n-    pure fn substr(&self, begin: uint, n: uint) -> ~str;\n+    pure fn substr(&self, begin: uint, n: uint) -> &'self str;\n     pure fn to_lower(&self) -> ~str;\n     pure fn to_upper(&self) -> ~str;\n     pure fn escape_default(&self) -> ~str;\n     pure fn escape_unicode(&self) -> ~str;\n-    pure fn trim(&self) -> ~str;\n-    pure fn trim_left(&self) -> ~str;\n-    pure fn trim_right(&self) -> ~str;\n+    pure fn trim(&self) -> &'self str;\n+    pure fn trim_left(&self) -> &'self str;\n+    pure fn trim_right(&self) -> &'self str;\n+    pure fn trim_chars(&self, chars_to_trim: &[char]) -> &'self str;\n+    pure fn trim_left_chars(&self, chars_to_trim: &[char]) -> &'self str;\n+    pure fn trim_right_chars(&self, chars_to_trim: &[char]) -> &'self str;\n     pure fn to_owned(&self) -> ~str;\n     pure fn to_managed(&self) -> @str;\n     pure fn char_at(&self, i: uint) -> char;\n@@ -2421,7 +2419,7 @@ impl StrSlice for &'self str {\n      * `begin`.\n      */\n     #[inline]\n-    pure fn substr(&self, begin: uint, n: uint) -> ~str {\n+    pure fn substr(&self, begin: uint, n: uint) -> &'self str {\n         substr(*self, begin, n)\n     }\n     /// Convert a string to lowercase\n@@ -2439,13 +2437,27 @@ impl StrSlice for &'self str {\n \n     /// Returns a string with leading and trailing whitespace removed\n     #[inline]\n-    pure fn trim(&self) -> ~str { trim(*self) }\n+    pure fn trim(&self) -> &'self str { trim(*self) }\n     /// Returns a string with leading whitespace removed\n     #[inline]\n-    pure fn trim_left(&self) -> ~str { trim_left(*self) }\n+    pure fn trim_left(&self) -> &'self str { trim_left(*self) }\n     /// Returns a string with trailing whitespace removed\n     #[inline]\n-    pure fn trim_right(&self) -> ~str { trim_right(*self) }\n+    pure fn trim_right(&self) -> &'self str { trim_right(*self) }\n+\n+    #[inline]\n+    pure fn trim_chars(&self, chars_to_trim: &[char]) -> &'self str {\n+        trim_chars(*self, chars_to_trim)\n+    }\n+    #[inline]\n+    pure fn trim_left_chars(&self, chars_to_trim: &[char]) -> &'self str {\n+        trim_left_chars(*self, chars_to_trim)\n+    }\n+    #[inline]\n+    pure fn trim_right_chars(&self, chars_to_trim: &[char]) -> &'self str {\n+        trim_right_chars(*self, chars_to_trim)\n+    }\n+\n \n     #[inline]\n     pure fn to_owned(&self) -> ~str { from_slice(*self) }\n@@ -2805,11 +2817,11 @@ mod tests {\n     #[test]\n     fn test_substr() {\n         fn t(a: &str, b: &str, start: int) {\n-            fail_unless!(substr(a, start as uint, len(b)) == b.to_str());\n+            fail_unless!(substr(a, start as uint, len(b)) == b);\n         }\n-        t(~\"hello\", ~\"llo\", 2);\n-        t(~\"hello\", ~\"el\", 1);\n-        fail_unless!(~\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\" == substr(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", 6u, 6u));\n+        t(\"hello\", \"llo\", 2);\n+        t(\"hello\", \"el\", 1);\n+        fail_unless!(\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\" == substr(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", 6u, 6u));\n     }\n \n     #[test]\n@@ -3042,62 +3054,62 @@ mod tests {\n \n     #[test]\n     fn test_trim_left_chars() {\n-        fail_unless!(trim_left_chars(~\" *** foo *** \", ~[]) ==\n-                     ~\" *** foo *** \");\n-        fail_unless!(trim_left_chars(~\" *** foo *** \", ~['*', ' ']) ==\n-                     ~\"foo *** \");\n-        fail_unless!(trim_left_chars(~\" ***  *** \", ~['*', ' ']) == ~\"\");\n-        fail_unless!(trim_left_chars(~\"foo *** \", ~['*', ' ']) ==\n-                     ~\"foo *** \");\n+        fail_unless!(trim_left_chars(\" *** foo *** \", ~[]) ==\n+                     \" *** foo *** \");\n+        fail_unless!(trim_left_chars(\" *** foo *** \", ~['*', ' ']) ==\n+                     \"foo *** \");\n+        fail_unless!(trim_left_chars(\" ***  *** \", ~['*', ' ']) == \"\");\n+        fail_unless!(trim_left_chars(\"foo *** \", ~['*', ' ']) ==\n+                     \"foo *** \");\n     }\n \n     #[test]\n     fn test_trim_right_chars() {\n-        fail_unless!(trim_right_chars(~\" *** foo *** \", ~[]) ==\n-                     ~\" *** foo *** \");\n-        fail_unless!(trim_right_chars(~\" *** foo *** \", ~['*', ' ']) ==\n-                     ~\" *** foo\");\n-        fail_unless!(trim_right_chars(~\" ***  *** \", ~['*', ' ']) == ~\"\");\n-        fail_unless!(trim_right_chars(~\" *** foo\", ~['*', ' ']) ==\n-                     ~\" *** foo\");\n+        fail_unless!(trim_right_chars(\" *** foo *** \", ~[]) ==\n+                     \" *** foo *** \");\n+        fail_unless!(trim_right_chars(\" *** foo *** \", ~['*', ' ']) ==\n+                     \" *** foo\");\n+        fail_unless!(trim_right_chars(\" ***  *** \", ~['*', ' ']) == \"\");\n+        fail_unless!(trim_right_chars(\" *** foo\", ~['*', ' ']) ==\n+                     \" *** foo\");\n     }\n \n     #[test]\n     fn test_trim_chars() {\n-        fail_unless!(trim_chars(~\" *** foo *** \", ~[]) == ~\" *** foo *** \");\n-        fail_unless!(trim_chars(~\" *** foo *** \", ~['*', ' ']) == ~\"foo\");\n-        fail_unless!(trim_chars(~\" ***  *** \", ~['*', ' ']) == ~\"\");\n-        fail_unless!(trim_chars(~\"foo\", ~['*', ' ']) == ~\"foo\");\n+        fail_unless!(trim_chars(\" *** foo *** \", ~[]) == \" *** foo *** \");\n+        fail_unless!(trim_chars(\" *** foo *** \", ~['*', ' ']) == \"foo\");\n+        fail_unless!(trim_chars(\" ***  *** \", ~['*', ' ']) == \"\");\n+        fail_unless!(trim_chars(\"foo\", ~['*', ' ']) == \"foo\");\n     }\n \n     #[test]\n     fn test_trim_left() {\n-        fail_unless!((trim_left(~\"\") == ~\"\"));\n-        fail_unless!((trim_left(~\"a\") == ~\"a\"));\n-        fail_unless!((trim_left(~\"    \") == ~\"\"));\n-        fail_unless!((trim_left(~\"     blah\") == ~\"blah\"));\n-        fail_unless!((trim_left(~\"   \\u3000  wut\") == ~\"wut\"));\n-        fail_unless!((trim_left(~\"hey \") == ~\"hey \"));\n+        fail_unless!((trim_left(\"\") == \"\"));\n+        fail_unless!((trim_left(\"a\") == \"a\"));\n+        fail_unless!((trim_left(\"    \") == \"\"));\n+        fail_unless!((trim_left(\"     blah\") == \"blah\"));\n+        fail_unless!((trim_left(\"   \\u3000  wut\") == \"wut\"));\n+        fail_unless!((trim_left(\"hey \") == \"hey \"));\n     }\n \n     #[test]\n     fn test_trim_right() {\n-        fail_unless!((trim_right(~\"\") == ~\"\"));\n-        fail_unless!((trim_right(~\"a\") == ~\"a\"));\n-        fail_unless!((trim_right(~\"    \") == ~\"\"));\n-        fail_unless!((trim_right(~\"blah     \") == ~\"blah\"));\n-        fail_unless!((trim_right(~\"wut   \\u3000  \") == ~\"wut\"));\n-        fail_unless!((trim_right(~\" hey\") == ~\" hey\"));\n+        fail_unless!((trim_right(\"\") == \"\"));\n+        fail_unless!((trim_right(\"a\") == \"a\"));\n+        fail_unless!((trim_right(\"    \") == \"\"));\n+        fail_unless!((trim_right(\"blah     \") == \"blah\"));\n+        fail_unless!((trim_right(\"wut   \\u3000  \") == \"wut\"));\n+        fail_unless!((trim_right(\" hey\") == \" hey\"));\n     }\n \n     #[test]\n     fn test_trim() {\n-        fail_unless!((trim(~\"\") == ~\"\"));\n-        fail_unless!((trim(~\"a\") == ~\"a\"));\n-        fail_unless!((trim(~\"    \") == ~\"\"));\n-        fail_unless!((trim(~\"    blah     \") == ~\"blah\"));\n-        fail_unless!((trim(~\"\\nwut   \\u3000  \") == ~\"wut\"));\n-        fail_unless!((trim(~\" hey dude \") == ~\"hey dude\"));\n+        fail_unless!((trim(\"\") == \"\"));\n+        fail_unless!((trim(\"a\") == \"a\"));\n+        fail_unless!((trim(\"    \") == \"\"));\n+        fail_unless!((trim(\"    blah     \") == \"blah\"));\n+        fail_unless!((trim(\"\\nwut   \\u3000  \") == \"wut\"));\n+        fail_unless!((trim(\" hey dude \") == \"hey dude\"));\n     }\n \n     #[test]"}, {"sha": "b687fde0c37911ec39c28082d2cad7a48c8e97d6", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=5f2d4102c5dabde915f1f6cb99c38b9274790cda", "patch": "@@ -28,18 +28,6 @@ impl ToStr for () {\n     #[inline(always)]\n     pure fn to_str(&self) -> ~str { ~\"()\" }\n }\n-impl ToStr for ~str {\n-    #[inline(always)]\n-    pure fn to_str(&self) -> ~str { copy *self }\n-}\n-impl ToStr for &'self str {\n-    #[inline(always)]\n-    pure fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n-}\n-impl ToStr for @str {\n-    #[inline(always)]\n-    pure fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n-}\n \n // FIXME #4898: impl for one-tuples\n "}, {"sha": "a5c22fe0ad30359196c4d18d1d070f8295a28127", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=5f2d4102c5dabde915f1f6cb99c38b9274790cda", "patch": "@@ -537,7 +537,7 @@ pub mod rt {\n         let mut unpadded = match cv.precision {\n           CountImplied => s.to_owned(),\n           CountIs(max) => if (max as uint) < str::char_len(s) {\n-            str::substr(s, 0, max as uint)\n+            str::substr(s, 0, max as uint).to_owned()\n           } else {\n             s.to_owned()\n           }"}, {"sha": "c9ca2cbc1d58b345fc64fdb5b88fd9231841a589", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=5f2d4102c5dabde915f1f6cb99c38b9274790cda", "patch": "@@ -1849,6 +1849,7 @@ fn trans_assign_op(bcx: block,\n     return result_datum.copy_to_datum(bcx, DROP_EXISTING, dst_datum);\n }\n \n+// NOTE: Mode neccessary here?\n fn shorten(+x: ~str) -> ~str {\n-    if x.len() > 60 { x.substr(0, 60) } else { x }\n+    if x.len() > 60 { x.substr(0, 60).to_owned() } else { x }\n }"}, {"sha": "65e7228eeaea27292c3eae72959036f18a64779b", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=5f2d4102c5dabde915f1f6cb99c38b9274790cda", "patch": "@@ -311,7 +311,7 @@ mod test {\n             let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n             let doc = (desc_to_brief_pass::mk_pass().f)(srv.clone(), doc);\n             let doc = (sectionalize_pass::mk_pass().f)(srv.clone(), doc);\n-            (mk_pass(~\"\", |s| str::trim(s) ).f)(srv.clone(), doc)\n+            (mk_pass(~\"\", |s| str::trim(s).to_owned() ).f)(srv.clone(), doc)\n         }\n     }\n }"}, {"sha": "0adaed35d08f5b878db5d6d1f425d6f9f47e31e5", "filename": "src/librustdoc/trim_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibrustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibrustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftrim_pass.rs?ref=5f2d4102c5dabde915f1f6cb99c38b9274790cda", "patch": "@@ -21,7 +21,7 @@ use text_pass;\n use core::str;\n \n pub fn mk_pass() -> Pass {\n-    text_pass::mk_pass(~\"trim\", |s| str::trim(s) )\n+    text_pass::mk_pass(~\"trim\", |s| s.trim().to_owned() )\n }\n \n #[test]"}, {"sha": "ecd72950468e1b28afec1f795e38613669eca2ee", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=5f2d4102c5dabde915f1f6cb99c38b9274790cda", "patch": "@@ -78,7 +78,7 @@ fn unindent(s: &str) -> ~str {\n     };\n \n     if !lines.is_empty() {\n-        let unindented = ~[lines.head().trim()]\n+        let unindented = ~[lines.head().trim().to_owned()]\n             + do lines.tail().map |line| {\n             if str::is_whitespace(*line) {\n                 copy *line"}, {"sha": "6a54dc7de10208db3b825fb4e11ee635b5be144d", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=5f2d4102c5dabde915f1f6cb99c38b9274790cda", "patch": "@@ -283,7 +283,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n             for args.each |arg| {\n                 let (crate, filename) =\n                     if arg.ends_with(\".rs\") || arg.ends_with(\".rc\") {\n-                    (arg.substr(0, arg.len() - 3), *arg)\n+                    (arg.substr(0, arg.len() - 3).to_owned(), *arg)\n                 } else {\n                     (*arg, arg + ~\".rs\")\n                 };"}, {"sha": "01153a4b78e90d88487969d271af964e63e83b25", "filename": "src/libstd/bigint.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=5f2d4102c5dabde915f1f6cb99c38b9274790cda", "patch": "@@ -458,10 +458,11 @@ pub impl BigUint {\n \n         pure fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return ~\"0\" }\n-            str::trim_left_chars(str::concat(vec::reversed(v).map(|n| {\n+            let s = str::concat(vec::reversed(v).map(|n| {\n                 let s = uint::to_str_radix(*n as uint, radix);\n                 str::from_chars(vec::from_elem(l - s.len(), '0')) + s\n-            })), ['0'])\n+            }));\n+            str::trim_left_chars(s, ['0']).to_owned()\n         }\n     }\n "}, {"sha": "e1e7f8ca92423817431a9300e2d7c116b918a466", "filename": "src/libstd/semver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibstd%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibstd%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsemver.rs?ref=5f2d4102c5dabde915f1f6cb99c38b9274790cda", "patch": "@@ -228,7 +228,7 @@ pub fn parse(s: &str) -> Option<Version> {\n     do bad_parse::cond.trap(|_| { debug!(\"bad\"); bad = true }).in {\n         do io::with_str_reader(s) |rdr| {\n             let v = parse_reader(rdr);\n-            if bad || v.to_str() != s {\n+            if bad || v.to_str() != s.to_owned() {\n                 None\n             } else {\n                 Some(v)"}, {"sha": "6ebaa42357ef97ccaa4da7b562dc60911b47a504", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=5f2d4102c5dabde915f1f6cb99c38b9274790cda", "patch": "@@ -109,7 +109,10 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n     }\n \n     if comment.starts_with(~\"//\") {\n-        return comment.slice(3u, comment.len()).trim();\n+        // FIXME #5475:\n+        // return comment.slice(3u, comment.len()).trim().to_owned();\n+        let r = comment.slice(3u, comment.len()); return r.trim().to_owned();\n+\n     }\n \n     if comment.starts_with(~\"/*\") {"}, {"sha": "ae92be6a4dec7d3f095a8eda5b8f01c2722f7caf", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2d4102c5dabde915f1f6cb99c38b9274790cda/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=5f2d4102c5dabde915f1f6cb99c38b9274790cda", "patch": "@@ -67,7 +67,8 @@ pub impl Sudoku {\n \n         let mut g = vec::from_fn(10u, { |_i| ~[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8] });\n         while !reader.eof() {\n-            let comps = str::split_char(str::trim(reader.read_line()), ',');\n+            let line = reader.read_line();\n+            let comps = str::split_char(line.trim(), ',');\n             if vec::len(comps) == 3u {\n                 let row     = uint::from_str(comps[0]).get() as u8;\n                 let col     = uint::from_str(comps[1]).get() as u8;"}]}