{"sha": "1591955adfb54354bcdb04712e561951d371002a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1OTE5NTVhZGZiNTQzNTRiY2RiMDQ3MTJlNTYxOTUxZDM3MTAwMmE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-05T23:23:07Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-06T18:09:08Z"}, "message": "rustc: Make AST paths use interior vectors", "tree": {"sha": "57c62aee342bb2e0e6758351c63a2b1b8104b1da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57c62aee342bb2e0e6758351c63a2b1b8104b1da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1591955adfb54354bcdb04712e561951d371002a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1591955adfb54354bcdb04712e561951d371002a", "html_url": "https://github.com/rust-lang/rust/commit/1591955adfb54354bcdb04712e561951d371002a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1591955adfb54354bcdb04712e561951d371002a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b108280db10b0017f57003d959db8d18a6d36c84", "url": "https://api.github.com/repos/rust-lang/rust/commits/b108280db10b0017f57003d959db8d18a6d36c84", "html_url": "https://github.com/rust-lang/rust/commit/b108280db10b0017f57003d959db8d18a6d36c84"}], "stats": {"total": 114, "additions": 71, "deletions": 43}, "files": [{"sha": "3d4c727c9c02fc0274ae31ef782667f7db9f71b2", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=1591955adfb54354bcdb04712e561951d371002a", "patch": "@@ -80,21 +80,21 @@ fn parse_constrs(@pstate st, str_def sd) -> (@ty::constr_def)[] {\n }\n \n fn parse_path(@pstate st, str_def sd) -> ast::path {\n-    let vec[ast::ident] idents = [];\n+    let ast::ident[] idents = ~[];\n     fn is_last(char c) -> bool {\n         ret (c == '(' || c == ':');\n     }\n-    idents += [parse_ident_(st, sd, is_last)];\n+    idents += ~[parse_ident_(st, sd, is_last)];\n     while (true) {\n         alt (peek(st) as char) {\n             case (':') { next(st); next(st); }\n             case (?c) {\n                 if (c == '(') {\n                     ret respan(rec(lo=0u, hi=0u),\n-                               rec(idents=idents, types=[]));\n+                               rec(idents=idents, types=~[]));\n                 }\n                 else {\n-                    idents += [parse_ident_(st, sd, is_last)];\n+                    idents += ~[parse_ident_(st, sd, is_last)];\n                 }\n             }\n         }"}, {"sha": "2bd533dd163489728c23ab4f40e3d1b53677735d", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=1591955adfb54354bcdb04712e561951d371002a", "patch": "@@ -18,6 +18,7 @@ import syntax::ast::respan;\n import middle::ty::constr_table;\n import syntax::visit;\n import visit::vt;\n+import std::ivec;\n import std::map::hashmap;\n import std::list;\n import std::list::list;\n@@ -554,9 +555,9 @@ fn mk_unresolved_msg(&ident id, &str kind) -> str {\n }\n \n // Lookup helpers\n-fn lookup_path_strict(&env e, &scopes sc, &span sp, vec[ident] idents,\n+fn lookup_path_strict(&env e, &scopes sc, &span sp, &ident[] idents,\n                       namespace ns) -> option::t[def] {\n-    auto n_idents = vec::len(idents);\n+    auto n_idents = ivec::len(idents);\n     auto headns = if (n_idents == 1u) { ns } else { ns_module };\n     auto dcur = lookup_in_scope_strict(e, sc, sp, idents.(0), headns);\n     auto i = 1u;"}, {"sha": "85157850c5fc3ea4a95efaceda414476e74c21ea", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=1591955adfb54354bcdb04712e561951d371002a", "patch": "@@ -641,7 +641,7 @@ fn substitute_arg(&ty::ctxt cx, &(@expr)[] actuals, @constr_arg a) ->\n }\n \n fn path_to_ident(&ty::ctxt cx, &path p) -> ident {\n-    alt (std::vec::last(p.node.idents)) {\n+    alt (ivec::last(p.node.idents)) {\n         case (none) { cx.sess.span_fatal(p.span, \"Malformed path\"); }\n         case (some(?i)) { ret i; }\n     }"}, {"sha": "b48489a2d40fc8c817b27c054c91be1300cac8fc", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=1591955adfb54354bcdb04712e561951d371002a", "patch": "@@ -230,7 +230,7 @@ fn kill_poststate(&fn_ctxt fcx, node_id id, &constr_ c) -> bool {\n fn clear_in_poststate_expr(&fn_ctxt fcx, &@expr e, &poststate t) {\n     alt (e.node) {\n         case (expr_path(?p)) {\n-            alt (std::vec::last(p.node.idents)) {\n+            alt (ivec::last(p.node.idents)) {\n                 case (some(?i)) {\n                     alt (local_node_id_to_def(fcx, e.id)) {\n                         case (some(def_local(?d_id))) {"}, {"sha": "abf474d7cb7405af13aaf6ed3f2c83f0041a58ff", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=1591955adfb54354bcdb04712e561951d371002a", "patch": "@@ -155,7 +155,7 @@ fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n                             ty_param_count);\n     auto ty_param_vars = bind_result._0;\n     auto ty_substs_opt;\n-    auto ty_substs_len = vec::len[@ast::ty](pth.node.types);\n+    auto ty_substs_len = ivec::len[@ast::ty](pth.node.types);\n     if (ty_substs_len > 0u) {\n         let ty::t[] ty_substs = ~[];\n         auto i = 0u;\n@@ -256,7 +256,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n         ret rec(ty=ast_ty_to_ty(tcx, getter, mt.ty), mut=mt.mut);\n     }\n     fn instantiate(&ty::ctxt tcx, &span sp, &ty_getter getter,\n-                   &ast::def_id id, &vec[@ast::ty] args) -> ty::t {\n+                   &ast::def_id id, &(@ast::ty)[] args) -> ty::t {\n         // TODO: maybe record cname chains so we can do\n         // \"foo = int\" like OCaml?\n \n@@ -344,9 +344,8 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n         case (ast::ty_path(?path, ?id)) {\n             alt (tcx.def_map.find(id)) {\n                 case (some(ast::def_ty(?id))) {\n-                    typ =\n-                        instantiate(tcx, ast_ty.span, getter, id,\n-                                    path.node.types);\n+                    typ = instantiate(tcx, ast_ty.span, getter, id,\n+                                      path.node.types);\n                 }\n                 case (some(ast::def_native_ty(?id))) { typ = getter(id)._1; }\n                 case (some(ast::def_ty_arg(?id))) {\n@@ -1665,7 +1664,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             // The definition doesn't take type parameters. If the programmer\n             // supplied some, that's an error.\n \n-            if (vec::len[@ast::ty](pth.node.types) > 0u) {\n+            if (ivec::len[@ast::ty](pth.node.types) > 0u) {\n                 fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                           \"this kind of value does not \\\n                                            take type parameters\");"}, {"sha": "80ecf919559acc77e31bacf175df3238ba0c3e44", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=1591955adfb54354bcdb04712e561951d371002a", "patch": "@@ -1,4 +1,6 @@\n+// The Rust abstract syntax tree.\n \n+import std::ivec;\n import std::option;\n import std::str;\n import std::vec;\n@@ -15,11 +17,11 @@ type fn_ident = option::t[ident];\n // FIXME: with typestate constraint, could say\n // idents and types are the same length, and are\n // non-empty\n-type path_ = rec(vec[ident] idents, vec[@ty] types);\n+type path_ = rec(ident[] idents, (@ty)[] types);\n \n type path = spanned[path_];\n \n-fn path_name(&path p) -> str { ret str::connect(p.node.idents, \"::\"); }\n+fn path_name(&path p) -> str { ret str::connect_ivec(p.node.idents, \"::\"); }\n \n type crate_num = int;\n type node_id = int;\n@@ -632,11 +634,11 @@ fn ternary_to_if(&@expr e) -> @ast::expr {\n \n // Path stringification\n fn path_to_str(&ast::path pth) -> str {\n-    auto result = str::connect(pth.node.idents, \"::\");\n-    if (vec::len[@ast::ty](pth.node.types) > 0u) {\n+    auto result = str::connect_ivec(pth.node.idents, \"::\");\n+    if (ivec::len[@ast::ty](pth.node.types) > 0u) {\n         fn f(&@ast::ty t) -> str { ret print::pprust::ty_to_str(*t); }\n         result += \"[\";\n-        result += str::connect(vec::map(f, pth.node.types), \",\");\n+        result += str::connect_ivec(ivec::map(f, pth.node.types), \",\");\n         result += \"]\";\n     }\n     ret result;"}, {"sha": "766dd9f3f288a01470dbee05984011a4b9ebff36", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=1591955adfb54354bcdb04712e561951d371002a", "patch": "@@ -1,3 +1,4 @@\n+import std::ivec;\n import std::vec;\n import std::option;\n import std::map::hashmap;\n@@ -71,8 +72,8 @@ fn expr_to_str(&ext_ctxt cx, @ast::expr expr, str error) -> str {\n fn expr_to_ident(&ext_ctxt cx, @ast::expr expr, str error) -> ast::ident {\n     alt(expr.node) {\n         case (ast::expr_path(?p)) {\n-            if (vec::len(p.node.types) > 0u \n-                || vec::len(p.node.idents) != 1u) {\n+            if (ivec::len(p.node.types) > 0u \n+                    || ivec::len(p.node.idents) != 1u) {\n                 cx.span_fatal(expr.span, error);\n             } else {\n                 ret p.node.idents.(0);"}, {"sha": "c7e2787d502e4abefb981bf658fd7580bba14ae9", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=1591955adfb54354bcdb04712e561951d371002a", "patch": "@@ -60,10 +60,9 @@ fn pieces_to_expr(&ext_ctxt cx, span sp, vec[piece] pieces,\n         auto binexpr = ast::expr_binary(ast::add, lhs, rhs);\n         ret @rec(id=cx.next_id(), node=binexpr, span=sp);\n     }\n-    fn make_path_expr(&ext_ctxt cx, span sp, vec[ast::ident] idents)\n+    fn make_path_expr(&ext_ctxt cx, span sp, &ast::ident[] idents)\n        -> @ast::expr {\n-        let vec[@ast::ty] types = [];\n-        auto path = rec(idents=idents, types=types);\n+        auto path = rec(idents=idents, types=~[]);\n         auto sp_path = rec(node=path, span=sp);\n         auto pathexpr = ast::expr_path(sp_path);\n         ret @rec(id=cx.next_id(), node=pathexpr, span=sp);\n@@ -73,7 +72,7 @@ fn pieces_to_expr(&ext_ctxt cx, span sp, vec[piece] pieces,\n         auto vecexpr = ast::expr_vec(exprs, ast::imm, ast::sk_rc);\n         ret @rec(id=cx.next_id(), node=vecexpr, span=sp);\n     }\n-    fn make_call(&ext_ctxt cx, span sp, vec[ast::ident] fn_path,\n+    fn make_call(&ext_ctxt cx, span sp, &ast::ident[] fn_path,\n                  vec[@ast::expr] args) -> @ast::expr {\n         auto pathexpr = make_path_expr(cx, sp, fn_path);\n         auto callexpr = ast::expr_call(pathexpr, args);\n@@ -92,11 +91,11 @@ fn pieces_to_expr(&ext_ctxt cx, span sp, vec[piece] pieces,\n         auto recexpr = ast::expr_rec(astfields, option::none[@ast::expr]);\n         ret @rec(id=cx.next_id(), node=recexpr, span=sp);\n     }\n-    fn make_path_vec(str ident) -> vec[str] {\n+    fn make_path_vec(str ident) -> str[] {\n         // FIXME: #fmt can't currently be used from within std\n         // because we're explicitly referencing the 'std' crate here\n \n-        ret [\"std\", \"extfmt\", \"rt\", ident];\n+        ret ~[\"std\", \"extfmt\", \"rt\", ident];\n     }\n     fn make_rt_path_expr(&ext_ctxt cx, span sp, str ident) ->\n        @ast::expr {"}, {"sha": "53b37da6c277cc7ea3a9d705d2b3deafc5bca382", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=1591955adfb54354bcdb04712e561951d371002a", "patch": "@@ -1,6 +1,7 @@\n use std;\n \n import codemap::span;\n+import std::ivec;\n import std::vec;\n import std::option;\n import vec::map;\n@@ -50,7 +51,7 @@ fn subst_ident(&ext_ctxt cx, &vec[@ast::expr] args,\n fn subst_path(&ext_ctxt cx, &vec[@ast::expr] args, \n               @vec[ident] param_names, &path_ p, ast_fold fld) -> path_ {\n     // Don't substitute into qualified names.\n-    if (len(p.types) > 0u || len(p.idents) != 1u) { ret p; }\n+    if (ivec::len(p.types) > 0u || ivec::len(p.idents) != 1u) { ret p; }\n     alt (position(p.idents.(0), *param_names)) {\n         case (some[uint](?idx)) {\n             alt (args.(idx).node) {\n@@ -75,7 +76,8 @@ fn subst_expr(&ext_ctxt cx, &vec[@ast::expr] args, @vec[ident] param_names,\n     ret alt(e) {\n         case (expr_path(?p)){\n             // Don't substitute into qualified names.\n-            if (len(p.node.types) > 0u || len(p.node.idents) != 1u) { e }\n+            if (ivec::len(p.node.types) > 0u ||\n+                    ivec::len(p.node.idents) != 1u) { e }\n             alt (position(p.node.idents.(0), *param_names)) {\n                 case (some[uint](?idx)) {\n                     args.(idx).node"}, {"sha": "9134c03d670a382eb5da98fd58d85c1fee4108bf", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=1591955adfb54354bcdb04712e561951d371002a", "patch": "@@ -1,6 +1,7 @@\n import syntax::codemap::span;\n import ast::*;\n \n+import std::ivec;\n import std::vec;\n import std::option;\n import vec::map;\n@@ -485,8 +486,8 @@ fn noop_fold_ident(&ident i, ast_fold fld) -> ident {\n }\n \n fn noop_fold_path(&path_ p, ast_fold fld) -> path_ {\n-    ret rec(idents=map(fld.fold_ident, p.idents),\n-            types=map(fld.fold_ty, p.types));\n+    ret rec(idents=ivec::map(fld.fold_ident, p.idents),\n+            types=ivec::map(fld.fold_ty, p.types));\n }\n \n fn noop_fold_local(&local_ l, ast_fold fld) -> local_ {"}, {"sha": "f418a7e535e3077e554965e053b4dda686d04afc", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=1591955adfb54354bcdb04712e561951d371002a", "patch": "@@ -1,5 +1,6 @@\n \n import std::io;\n+import std::ivec;\n import std::vec;\n import std::str;\n import std::option;\n@@ -409,13 +410,18 @@ fn parse_ty_postfix(@ast::ty orig_t, &parser p) -> @ast::ty {\n             // This is explicit type parameter instantiation.\n             auto seq = parse_seq_to_end(token::RBRACKET, some(token::COMMA),\n                                         parse_ty, p);\n+\n+            // FIXME: Remove this vec->ivec conversion.\n+            auto seq_ivec = ~[];\n+            for (@ast::ty typ in seq) { seq_ivec += ~[typ]; }\n+\n             alt (orig_t.node) {\n                 case (ast::ty_path(?pth, ?ann)) {\n                     auto hi = p.get_hi_pos();\n                     ret @spanned(lo, hi,\n                                  ast::ty_path(spanned(lo, hi,\n                                               rec(idents=pth.node.idents,\n-                                                  types=seq)),\n+                                                  types=seq_ivec)),\n                                               ann));\n                 }\n                 case (_) {\n@@ -637,20 +643,20 @@ fn is_ident(token::token t) -> bool {\n fn parse_path(&parser p) -> ast::path {\n     auto lo = p.get_lo_pos();\n     auto hi = lo;\n-    let vec[ast::ident] ids = [];\n+    let ast::ident[] ids = ~[];\n     while (true) {\n         alt (p.peek()) {\n             case (token::IDENT(?i, _)) {\n                 hi = p.get_hi_pos();\n-                ids += [p.get_str(i)];\n+                ids += ~[p.get_str(i)];\n                 p.bump();\n                 if (p.peek() == token::MOD_SEP) { p.bump(); } else { break; }\n             }\n             case (_) { break; }\n         }\n     }\n     hi = p.get_hi_pos();\n-    ret spanned(lo, hi, rec(idents=ids, types=[]));\n+    ret spanned(lo, hi, rec(idents=ids, types=~[]));\n }\n \n fn parse_path_and_ty_param_substs(&parser p) -> ast::path {\n@@ -659,8 +665,13 @@ fn parse_path_and_ty_param_substs(&parser p) -> ast::path {\n     if (p.peek() == token::LBRACKET) {\n         auto seq = parse_seq(token::LBRACKET, token::RBRACKET,\n                              some(token::COMMA), parse_ty, p);\n+\n+        // FIXME: Remove this vec->ivec conversion.\n+        auto seq_ivec = ~[];\n+        for (@ast::ty typ in seq.node) { seq_ivec += ~[typ]; }\n+\n         auto hi = p.get_hi_pos();\n-        path = spanned(lo, hi, rec(idents=path.node.idents, types=seq.node));\n+        path = spanned(lo, hi, rec(idents=path.node.idents, types=seq_ivec));\n     }\n     ret path;\n }\n@@ -955,7 +966,7 @@ fn parse_syntax_ext(&parser p) -> @ast::expr {\n \n fn parse_syntax_ext_naked(&parser p, uint lo) -> @ast::expr {\n     auto pth = parse_path(p);\n-    if (vec::len(pth.node.idents) == 0u) {\n+    if (ivec::len(pth.node.idents) == 0u) {\n         p.fatal(\"expected a syntax expander name\");\n     }\n     auto es = parse_seq(token::LPAREN, token::RPAREN,\n@@ -975,7 +986,7 @@ fn parse_syntax_ext_naked(&parser p, uint lo) -> @ast::expr {\n fn expand_syntax_ext(&parser p, span sp, &ast::path path,\n                      vec[@ast::expr] args, option::t[str] body) ->\n    ast::expr_ {\n-    assert (vec::len(path.node.idents) > 0u);\n+    assert (ivec::len(path.node.idents) > 0u);\n     auto extname = path.node.idents.(0);\n     alt (p.get_syntax_expanders().find(extname)) {\n         case (none) { p.fatal(\"unknown syntax expander: '\" + extname + \"'\"); }"}, {"sha": "25f962a945d93c9a8166ce351beae0714386be13", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1591955adfb54354bcdb04712e561951d371002a/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=1591955adfb54354bcdb04712e561951d371002a", "patch": "@@ -1,9 +1,10 @@\n \n-import std::uint;\n+import std::ivec;\n import std::int;\n-import std::vec;\n-import std::str;\n import std::io;\n+import std::str;\n+import std::uint;\n+import std::vec;\n import std::option;\n import parse::lexer;\n import syntax::codemap::codemap;\n@@ -206,6 +207,17 @@ fn commasep[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN)  op) {\n     end(s);\n }\n \n+fn commasep_ivec[IN](&ps s, breaks b, &IN[] elts, fn(&ps, &IN)  op) {\n+    box(s, 0u, b);\n+    auto first = true;\n+    for (IN elt in elts) {\n+        if (first) { first = false; } else { word_space(s, \",\"); }\n+        op(s, elt);\n+    }\n+    end(s);\n+}\n+\n+\n fn commasep_cmnt[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN)  op,\n                      fn(&IN) -> codemap::span  get_span) {\n     box(s, 0u, b);\n@@ -1013,9 +1025,9 @@ fn print_path(&ps s, &ast::path path) {\n         if (first) { first = false; } else { word(s.s, \"::\"); }\n         word(s.s, id);\n     }\n-    if (vec::len(path.node.types) > 0u) {\n+    if (ivec::len(path.node.types) > 0u) {\n         word(s.s, \"[\");\n-        commasep(s, inconsistent, path.node.types, print_boxed_type);\n+        commasep_ivec(s, inconsistent, path.node.types, print_boxed_type);\n         word(s.s, \"]\");\n     }\n }"}]}