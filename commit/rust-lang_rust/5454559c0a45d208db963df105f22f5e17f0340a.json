{"sha": "5454559c0a45d208db963df105f22f5e17f0340a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0NTQ1NTljMGE0NWQyMDhkYjk2M2RmMTA1ZjIyZjVlMTdmMDM0MGE=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-02-09T20:32:05Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-02-09T20:35:02Z"}, "message": "Show qualified variant pattern completions", "tree": {"sha": "6038de6fd6a16ad6edef22a4bef9bd323071dc99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6038de6fd6a16ad6edef22a4bef9bd323071dc99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5454559c0a45d208db963df105f22f5e17f0340a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5454559c0a45d208db963df105f22f5e17f0340a", "html_url": "https://github.com/rust-lang/rust/commit/5454559c0a45d208db963df105f22f5e17f0340a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5454559c0a45d208db963df105f22f5e17f0340a/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d4ae1c8e3b76798fcb5eb656d886fe65a2c7277", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d4ae1c8e3b76798fcb5eb656d886fe65a2c7277", "html_url": "https://github.com/rust-lang/rust/commit/5d4ae1c8e3b76798fcb5eb656d886fe65a2c7277"}], "stats": {"total": 140, "additions": 95, "deletions": 45}, "files": [{"sha": "3b582ed07a331fdad3b41b613d8e8c72d53636c3", "filename": "crates/completion/src/completions.rs", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5454559c0a45d208db963df105f22f5e17f0340a/crates%2Fcompletion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5454559c0a45d208db963df105f22f5e17f0340a/crates%2Fcompletion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions.rs?ref=5454559c0a45d208db963df105f22f5e17f0340a", "patch": "@@ -15,7 +15,9 @@ pub(crate) mod trait_impl;\n pub(crate) mod mod_;\n pub(crate) mod flyimport;\n \n-use hir::{ModPath, ScopeDef, Type};\n+use std::iter;\n+\n+use hir::{known, ModPath, ScopeDef, Type};\n \n use crate::{\n     item::Builder,\n@@ -118,7 +120,18 @@ impl Completions {\n         variant: hir::Variant,\n         local_name: Option<hir::Name>,\n     ) {\n-        if let Some(item) = render_variant_pat(RenderContext::new(ctx), variant, local_name) {\n+        if let Some(item) = render_variant_pat(RenderContext::new(ctx), variant, local_name, None) {\n+            self.add(item);\n+        }\n+    }\n+\n+    pub(crate) fn add_qualified_variant_pat(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        variant: hir::Variant,\n+        path: ModPath,\n+    ) {\n+        if let Some(item) = render_variant_pat(RenderContext::new(ctx), variant, None, Some(path)) {\n             self.add(item);\n         }\n     }\n@@ -166,3 +179,46 @@ impl Completions {\n         self.add(item);\n     }\n }\n+\n+fn complete_enum_variants(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    ty: &hir::Type,\n+    cb: impl Fn(&mut Completions, &CompletionContext, hir::Variant, hir::ModPath),\n+) {\n+    if let Some(hir::Adt::Enum(enum_data)) =\n+        iter::successors(Some(ty.clone()), |ty| ty.remove_ref()).last().and_then(|ty| ty.as_adt())\n+    {\n+        let variants = enum_data.variants(ctx.db);\n+\n+        let module = if let Some(module) = ctx.scope.module() {\n+            // Compute path from the completion site if available.\n+            module\n+        } else {\n+            // Otherwise fall back to the enum's definition site.\n+            enum_data.module(ctx.db)\n+        };\n+\n+        if let Some(impl_) = ctx.impl_def.as_ref().and_then(|impl_| ctx.sema.to_def(impl_)) {\n+            if impl_.target_ty(ctx.db) == *ty {\n+                for &variant in &variants {\n+                    let self_path = hir::ModPath::from_segments(\n+                        hir::PathKind::Plain,\n+                        iter::once(known::SELF_TYPE).chain(iter::once(variant.name(ctx.db))),\n+                    );\n+                    cb(acc, ctx, variant, self_path);\n+                }\n+            }\n+        }\n+\n+        for variant in variants {\n+            if let Some(path) = module.find_use_path(ctx.db, hir::ModuleDef::from(variant)) {\n+                // Variants with trivial paths are already added by the existing completion logic,\n+                // so we should avoid adding these twice\n+                if path.segments().len() > 1 {\n+                    cb(acc, ctx, variant, path);\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "9282c38279323c1394caf9eef3649cbfe3103d8e", "filename": "crates/completion/src/completions/pattern.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5454559c0a45d208db963df105f22f5e17f0340a/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5454559c0a45d208db963df105f22f5e17f0340a/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=5454559c0a45d208db963df105f22f5e17f0340a", "patch": "@@ -11,6 +11,12 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n         return;\n     }\n \n+    if let Some(ty) = &ctx.expected_type {\n+        super::complete_enum_variants(acc, ctx, ty, |acc, ctx, variant, path| {\n+            acc.add_qualified_variant_pat(ctx, variant, path)\n+        });\n+    }\n+\n     // FIXME: ideally, we should look at the type we are matching against and\n     // suggest variants + auto-imports\n     ctx.scope.process_all_names(&mut |name, res| {\n@@ -286,4 +292,26 @@ impl Foo {\n             \"#]],\n         )\n     }\n+\n+    #[test]\n+    fn completes_qualified_variant() {\n+        check_snippet(\n+            r#\"\n+enum Foo {\n+    Bar { baz: i32 }\n+}\n+impl Foo {\n+    fn foo() {\n+        match {Foo::Bar { baz: 0 }} {\n+            B$0\n+        }\n+    }\n+}\n+    \"#,\n+            expect![[r#\"\n+                bn Self::Bar Self::Bar { baz$1 }$0\n+                bn Foo::Bar  Foo::Bar { baz$1 }$0\n+            \"#]],\n+        )\n+    }\n }"}, {"sha": "e9d0ff66589abe49f44acea8ab1eadf361aa9306", "filename": "crates/completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 4, "deletions": 42, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5454559c0a45d208db963df105f22f5e17f0340a/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5454559c0a45d208db963df105f22f5e17f0340a/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=5454559c0a45d208db963df105f22f5e17f0340a", "patch": "@@ -1,8 +1,6 @@\n //! Completion of names from the current scope, e.g. locals and imported items.\n \n-use std::iter;\n-\n-use hir::{known, Adt, ModuleDef, ScopeDef, Type};\n+use hir::ScopeDef;\n use syntax::AstNode;\n use test_utils::mark;\n \n@@ -21,7 +19,9 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n     }\n \n     if let Some(ty) = &ctx.expected_type {\n-        complete_enum_variants(acc, ctx, ty);\n+        super::complete_enum_variants(acc, ctx, ty, |acc, ctx, variant, path| {\n+            acc.add_qualified_enum_variant(ctx, variant, path)\n+        });\n     }\n \n     if ctx.is_pat_binding_or_const {\n@@ -45,44 +45,6 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n     });\n }\n \n-fn complete_enum_variants(acc: &mut Completions, ctx: &CompletionContext, ty: &Type) {\n-    if let Some(Adt::Enum(enum_data)) =\n-        iter::successors(Some(ty.clone()), |ty| ty.remove_ref()).last().and_then(|ty| ty.as_adt())\n-    {\n-        let variants = enum_data.variants(ctx.db);\n-\n-        let module = if let Some(module) = ctx.scope.module() {\n-            // Compute path from the completion site if available.\n-            module\n-        } else {\n-            // Otherwise fall back to the enum's definition site.\n-            enum_data.module(ctx.db)\n-        };\n-\n-        if let Some(impl_) = ctx.impl_def.as_ref().and_then(|impl_| ctx.sema.to_def(impl_)) {\n-            if impl_.target_ty(ctx.db) == *ty {\n-                for &variant in &variants {\n-                    let self_path = hir::ModPath::from_segments(\n-                        hir::PathKind::Plain,\n-                        iter::once(known::SELF_TYPE).chain(iter::once(variant.name(ctx.db))),\n-                    );\n-                    acc.add_qualified_enum_variant(ctx, variant, self_path.clone());\n-                }\n-            }\n-        }\n-\n-        for variant in variants {\n-            if let Some(path) = module.find_use_path(ctx.db, ModuleDef::from(variant)) {\n-                // Variants with trivial paths are already added by the existing completion logic,\n-                // so we should avoid adding these twice\n-                if path.segments().len() > 1 {\n-                    acc.add_qualified_enum_variant(ctx, variant, path);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};"}, {"sha": "465dfe00c5257d886897f7ed885e98bec969ef4d", "filename": "crates/completion/src/render/pattern.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5454559c0a45d208db963df105f22f5e17f0340a/crates%2Fcompletion%2Fsrc%2Frender%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5454559c0a45d208db963df105f22f5e17f0340a/crates%2Fcompletion%2Fsrc%2Frender%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Fpattern.rs?ref=5454559c0a45d208db963df105f22f5e17f0340a", "patch": "@@ -49,13 +49,17 @@ pub(crate) fn render_variant_pat(\n     ctx: RenderContext<'_>,\n     variant: hir::Variant,\n     local_name: Option<Name>,\n+    path: Option<hir::ModPath>,\n ) -> Option<CompletionItem> {\n     let _p = profile::span(\"render_variant_pat\");\n \n     let fields = variant.fields(ctx.db());\n     let (visible_fields, fields_omitted) = visible_fields(&ctx, &fields, variant)?;\n \n-    let name = local_name.unwrap_or_else(|| variant.name(ctx.db())).to_string();\n+    let name = match &path {\n+        Some(path) => path.to_string(),\n+        None => local_name.unwrap_or_else(|| variant.name(ctx.db())).to_string(),\n+    };\n     let pat = render_pat(&ctx, &name, variant.kind(ctx.db()), &visible_fields, fields_omitted)?;\n \n     Some(build_completion(ctx, name, pat, variant))"}]}