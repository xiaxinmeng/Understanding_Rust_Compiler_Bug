{"sha": "d017d59ed013a4bc2431d023077eb7209fe9c60d", "node_id": "C_kwDOAAsO6NoAKGQwMTdkNTllZDAxM2E0YmMyNDMxZDAyMzA3N2ViNzIwOWZlOWM2MGQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-24T07:39:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-24T07:39:28Z"}, "message": "Auto merge of #98109 - nikomatsakis:issue-98095, r=jackh726\n\nfix universes in the NLL type tests\n\nIn the NLL code, we were not accommodating universes in the\n`type_test` logic.\n\nFixes #98095.\n\nr? `@compiler-errors`\n\nThis breaks some tests, however, so the purpose of this branch is more explanatory and perhaps to do a crater run.", "tree": {"sha": "f9cc2f1615a02166ffec7da6ae4016b1789c8d84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9cc2f1615a02166ffec7da6ae4016b1789c8d84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d017d59ed013a4bc2431d023077eb7209fe9c60d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d017d59ed013a4bc2431d023077eb7209fe9c60d", "html_url": "https://github.com/rust-lang/rust/commit/d017d59ed013a4bc2431d023077eb7209fe9c60d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d017d59ed013a4bc2431d023077eb7209fe9c60d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc96600bf6a52f92aeeee60a92a161a82b61c0ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc96600bf6a52f92aeeee60a92a161a82b61c0ef", "html_url": "https://github.com/rust-lang/rust/commit/fc96600bf6a52f92aeeee60a92a161a82b61c0ef"}, {"sha": "e7ed8fe481fe103383f55a015a19f641450b76a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7ed8fe481fe103383f55a015a19f641450b76a3", "html_url": "https://github.com/rust-lang/rust/commit/e7ed8fe481fe103383f55a015a19f641450b76a3"}], "stats": {"total": 1002, "additions": 735, "deletions": 267}, "files": [{"sha": "3a919e954a424d350e4ef59cbea47cb34ba61177", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -299,7 +299,7 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n \n     // Solve the region constraints.\n     let (closure_region_requirements, nll_errors) =\n-        regioncx.solve(infcx, &body, polonius_output.clone());\n+        regioncx.solve(infcx, param_env, &body, polonius_output.clone());\n \n     if !nll_errors.is_empty() {\n         // Suppress unhelpful extra errors in `infer_opaque_types`."}, {"sha": "0fe3b45bc7c4c30343070bc620408b060651f6c9", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 81, "deletions": 20, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -10,7 +10,8 @@ use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n use rustc_hir::CRATE_HIR_ID;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::canonical::QueryOutlivesConstraint;\n-use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound};\n+use rustc_infer::infer::outlives::test_type_match;\n+use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound, VerifyIfEq};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin};\n use rustc_middle::mir::{\n     Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n@@ -46,6 +47,7 @@ pub mod values;\n \n pub struct RegionInferenceContext<'tcx> {\n     pub var_infos: VarInfos,\n+\n     /// Contains the definition for every region variable. Region\n     /// variables are identified by their index (`RegionVid`). The\n     /// definition contains information about where the region came\n@@ -559,6 +561,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(super) fn solve(\n         &mut self,\n         infcx: &InferCtxt<'_, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         body: &Body<'tcx>,\n         polonius_output: Option<Rc<PoloniusOutput>>,\n     ) -> (Option<ClosureRegionRequirements<'tcx>>, RegionErrors<'tcx>) {\n@@ -574,7 +577,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // eagerly.\n         let mut outlives_requirements = infcx.tcx.is_typeck_child(mir_def_id).then(Vec::new);\n \n-        self.check_type_tests(infcx, body, outlives_requirements.as_mut(), &mut errors_buffer);\n+        self.check_type_tests(\n+            infcx,\n+            param_env,\n+            body,\n+            outlives_requirements.as_mut(),\n+            &mut errors_buffer,\n+        );\n \n         // In Polonius mode, the errors about missing universal region relations are in the output\n         // and need to be emitted or propagated. Otherwise, we need to check whether the\n@@ -823,6 +832,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_type_tests(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         body: &Body<'tcx>,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut RegionErrors<'tcx>,\n@@ -839,7 +849,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             let generic_ty = type_test.generic_kind.to_ty(tcx);\n             if self.eval_verify_bound(\n-                tcx,\n+                infcx,\n+                param_env,\n                 body,\n                 generic_ty,\n                 type_test.lower_bound,\n@@ -851,6 +862,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if let Some(propagated_outlives_requirements) = &mut propagated_outlives_requirements {\n                 if self.try_promote_type_test(\n                     infcx,\n+                    param_env,\n                     body,\n                     type_test,\n                     propagated_outlives_requirements,\n@@ -907,6 +919,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn try_promote_type_test(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         body: &Body<'tcx>,\n         type_test: &TypeTest<'tcx>,\n         propagated_outlives_requirements: &mut Vec<ClosureOutlivesRequirement<'tcx>>,\n@@ -938,7 +951,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // where `ur` is a local bound -- we are sometimes in a\n             // position to prove things that our caller cannot.  See\n             // #53570 for an example.\n-            if self.eval_verify_bound(tcx, body, generic_ty, ur, &type_test.verify_bound) {\n+            if self.eval_verify_bound(\n+                infcx,\n+                param_env,\n+                body,\n+                generic_ty,\n+                ur,\n+                &type_test.verify_bound,\n+            ) {\n                 continue;\n             }\n \n@@ -1161,7 +1181,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// `point`.\n     fn eval_verify_bound(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         body: &Body<'tcx>,\n         generic_ty: Ty<'tcx>,\n         lower_bound: RegionVid,\n@@ -1170,8 +1191,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"eval_verify_bound(lower_bound={:?}, verify_bound={:?})\", lower_bound, verify_bound);\n \n         match verify_bound {\n-            VerifyBound::IfEq(test_ty, verify_bound1) => {\n-                self.eval_if_eq(tcx, body, generic_ty, lower_bound, *test_ty, verify_bound1)\n+            VerifyBound::IfEq(verify_if_eq_b) => {\n+                self.eval_if_eq(infcx, param_env, generic_ty, lower_bound, *verify_if_eq_b)\n             }\n \n             VerifyBound::IsEmpty => {\n@@ -1185,30 +1206,50 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             VerifyBound::AnyBound(verify_bounds) => verify_bounds.iter().any(|verify_bound| {\n-                self.eval_verify_bound(tcx, body, generic_ty, lower_bound, verify_bound)\n+                self.eval_verify_bound(\n+                    infcx,\n+                    param_env,\n+                    body,\n+                    generic_ty,\n+                    lower_bound,\n+                    verify_bound,\n+                )\n             }),\n \n             VerifyBound::AllBounds(verify_bounds) => verify_bounds.iter().all(|verify_bound| {\n-                self.eval_verify_bound(tcx, body, generic_ty, lower_bound, verify_bound)\n+                self.eval_verify_bound(\n+                    infcx,\n+                    param_env,\n+                    body,\n+                    generic_ty,\n+                    lower_bound,\n+                    verify_bound,\n+                )\n             }),\n         }\n     }\n \n     fn eval_if_eq(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n-        body: &Body<'tcx>,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         generic_ty: Ty<'tcx>,\n         lower_bound: RegionVid,\n-        test_ty: Ty<'tcx>,\n-        verify_bound: &VerifyBound<'tcx>,\n+        verify_if_eq_b: ty::Binder<'tcx, VerifyIfEq<'tcx>>,\n     ) -> bool {\n-        let generic_ty_normalized = self.normalize_to_scc_representatives(tcx, generic_ty);\n-        let test_ty_normalized = self.normalize_to_scc_representatives(tcx, test_ty);\n-        if generic_ty_normalized == test_ty_normalized {\n-            self.eval_verify_bound(tcx, body, generic_ty, lower_bound, verify_bound)\n-        } else {\n-            false\n+        let generic_ty = self.normalize_to_scc_representatives(infcx.tcx, generic_ty);\n+        let verify_if_eq_b = self.normalize_to_scc_representatives(infcx.tcx, verify_if_eq_b);\n+        match test_type_match::extract_verify_if_eq(\n+            infcx.tcx,\n+            param_env,\n+            &verify_if_eq_b,\n+            generic_ty,\n+        ) {\n+            Some(r) => {\n+                let r_vid = self.to_region_vid(r);\n+                self.eval_outlives(r_vid, lower_bound)\n+            }\n+            None => false,\n         }\n     }\n \n@@ -1278,6 +1319,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let sub_region_scc = self.constraint_sccs.scc(sub_region);\n         let sup_region_scc = self.constraint_sccs.scc(sup_region);\n \n+        // If we are checking that `'sup: 'sub`, and `'sub` contains\n+        // some placeholder that `'sup` cannot name, then this is only\n+        // true if `'sup` outlives static.\n+        if !self.universe_compatible(sub_region_scc, sup_region_scc) {\n+            debug!(\n+                \"eval_outlives: sub universe `{sub_region_scc:?}` is not nameable \\\n+                by super `{sup_region_scc:?}`, promoting to static\",\n+            );\n+\n+            return self.eval_outlives(sup_region, self.universal_regions.fr_static);\n+        }\n+\n         // Both the `sub_region` and `sup_region` consist of the union\n         // of some number of universal regions (along with the union\n         // of various points in the CFG; ignore those points for\n@@ -1292,6 +1345,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             });\n \n         if !universal_outlives {\n+            debug!(\n+                \"eval_outlives: returning false because sub region contains a universal region not present in super\"\n+            );\n             return false;\n         }\n \n@@ -1300,10 +1356,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         if self.universal_regions.is_universal_region(sup_region) {\n             // Micro-opt: universal regions contain all points.\n+            debug!(\n+                \"eval_outlives: returning true because super is universal and hence contains all points\"\n+            );\n             return true;\n         }\n \n-        self.scc_values.contains_points(sup_region_scc, sub_region_scc)\n+        let result = self.scc_values.contains_points(sup_region_scc, sub_region_scc);\n+        debug!(\"returning {} because of comparison between points in sup/sub\", result);\n+        result\n     }\n \n     /// Once regions have been propagated, this method is used to see"}, {"sha": "455de47acef1b97e681f3dfdadcb203cf6f137ac", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -22,19 +22,22 @@ use rustc_middle::ty::{Region, RegionVid};\n use rustc_span::Span;\n use std::fmt;\n \n+use super::outlives::test_type_match;\n+\n /// This function performs lexical region resolution given a complete\n /// set of constraints and variable origins. It performs a fixed-point\n /// iteration to find region values which satisfy all constraints,\n /// assuming such values can be found. It returns the final values of\n /// all the variables as well as a set of errors that must be reported.\n #[instrument(level = \"debug\", skip(region_rels, var_infos, data))]\n pub(crate) fn resolve<'tcx>(\n+    param_env: ty::ParamEnv<'tcx>,\n     region_rels: &RegionRelations<'_, 'tcx>,\n     var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,\n ) -> (LexicalRegionResolutions<'tcx>, Vec<RegionResolutionError<'tcx>>) {\n     let mut errors = vec![];\n-    let mut resolver = LexicalResolver { region_rels, var_infos, data };\n+    let mut resolver = LexicalResolver { param_env, region_rels, var_infos, data };\n     let values = resolver.infer_variable_values(&mut errors);\n     (values, errors)\n }\n@@ -100,6 +103,7 @@ struct RegionAndOrigin<'tcx> {\n type RegionGraph<'tcx> = Graph<(), Constraint<'tcx>>;\n \n struct LexicalResolver<'cx, 'tcx> {\n+    param_env: ty::ParamEnv<'tcx>,\n     region_rels: &'cx RegionRelations<'cx, 'tcx>,\n     var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,\n@@ -818,9 +822,20 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         min: ty::Region<'tcx>,\n     ) -> bool {\n         match bound {\n-            VerifyBound::IfEq(k, b) => {\n-                (var_values.normalize(self.region_rels.tcx, *k) == generic_ty)\n-                    && self.bound_is_met(b, var_values, generic_ty, min)\n+            VerifyBound::IfEq(verify_if_eq_b) => {\n+                let verify_if_eq_b = var_values.normalize(self.region_rels.tcx, *verify_if_eq_b);\n+                match test_type_match::extract_verify_if_eq(\n+                    self.tcx(),\n+                    self.param_env,\n+                    &verify_if_eq_b,\n+                    generic_ty,\n+                ) {\n+                    Some(r) => {\n+                        self.bound_is_met(&VerifyBound::OutlivedBy(r), var_values, generic_ty, min)\n+                    }\n+\n+                    None => false,\n+                }\n             }\n \n             VerifyBound::OutlivedBy(r) => {"}, {"sha": "6f88b83a473213d86857bcb6dac01c57653a88e3", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -1290,7 +1290,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             &RegionRelations::new(self.tcx, region_context, outlives_env.free_region_map());\n \n         let (lexical_region_resolutions, errors) =\n-            lexical_region_resolve::resolve(region_rels, var_infos, data);\n+            lexical_region_resolve::resolve(outlives_env.param_env, region_rels, var_infos, data);\n \n         let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n         assert!(old_value.is_none());"}, {"sha": "2a085288fb7c069c8d58d8a776b9e758d0b4078c", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -3,6 +3,7 @@\n pub mod components;\n pub mod env;\n pub mod obligations;\n+pub mod test_type_match;\n pub mod verify;\n \n use rustc_middle::traits::query::OutlivesBound;"}, {"sha": "a268493b28f631954047613056ee7bf26ec51ad6", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -318,17 +318,13 @@ where\n         self.delegate.push_verify(origin, generic, region, verify_bound);\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn projection_must_outlive(\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         region: ty::Region<'tcx>,\n         projection_ty: ty::ProjectionTy<'tcx>,\n     ) {\n-        debug!(\n-            \"projection_must_outlive(region={:?}, projection_ty={:?}, origin={:?})\",\n-            region, projection_ty, origin\n-        );\n-\n         // This case is thorny for inference. The fundamental problem is\n         // that there are many cases where we have choice, and inference\n         // doesn't like choice (the current region inference in\n@@ -363,13 +359,21 @@ where\n         // #55756) in cases where you have e.g., `<T as Foo<'a>>::Item:\n         // 'a` in the environment but `trait Foo<'b> { type Item: 'b\n         // }` in the trait definition.\n-        approx_env_bounds.retain(|bound| match *bound.0.kind() {\n-            ty::Projection(projection_ty) => self\n-                .verify_bound\n-                .projection_declared_bounds_from_trait(projection_ty)\n-                .all(|r| r != bound.1),\n-\n-            _ => panic!(\"expected only projection types from env, not {:?}\", bound.0),\n+        approx_env_bounds.retain(|bound_outlives| {\n+            // OK to skip binder because we only manipulate and compare against other\n+            // values from the same binder. e.g. if we have (e.g.) `for<'a> <T as Trait<'a>>::Item: 'a`\n+            // in `bound`, the `'a` will be a `^1` (bound, debruijn index == innermost) region.\n+            // If the declaration is `trait Trait<'b> { type Item: 'b; }`, then `projection_declared_bounds_from_trait`\n+            // will be invoked with `['b => ^1]` and so we will get `^1` returned.\n+            let bound = bound_outlives.skip_binder();\n+            match *bound.0.kind() {\n+                ty::Projection(projection_ty) => self\n+                    .verify_bound\n+                    .projection_declared_bounds_from_trait(projection_ty)\n+                    .all(|r| r != bound.1),\n+\n+                _ => panic!(\"expected only projection types from env, not {:?}\", bound.0),\n+            }\n         });\n \n         // If declared bounds list is empty, the only applicable rule is\n@@ -420,8 +424,16 @@ where\n         if !trait_bounds.is_empty()\n             && trait_bounds[1..]\n                 .iter()\n-                .chain(approx_env_bounds.iter().map(|b| &b.1))\n-                .all(|b| *b == trait_bounds[0])\n+                .map(|r| Some(*r))\n+                .chain(\n+                    // NB: The environment may contain `for<'a> T: 'a` style bounds.\n+                    // In that case, we don't know if they are equal to the trait bound\n+                    // or not (since we don't *know* whether the environment bound even applies),\n+                    // so just map to `None` here if there are bound vars, ensuring that\n+                    // the call to `all` will fail below.\n+                    approx_env_bounds.iter().map(|b| b.map_bound(|b| b.1).no_bound_vars()),\n+                )\n+                .all(|b| b == Some(trait_bounds[0]))\n         {\n             let unique_bound = trait_bounds[0];\n             debug!(\"projection_must_outlive: unique trait bound = {:?}\", unique_bound);\n@@ -437,6 +449,7 @@ where\n         // even though a satisfactory solution exists.\n         let generic = GenericKind::Projection(projection_ty);\n         let verify_bound = self.verify_bound.generic_bound(generic);\n+        debug!(\"projection_must_outlive: pushing {:?}\", verify_bound);\n         self.delegate.push_verify(origin, generic, region, verify_bound);\n     }\n }"}, {"sha": "9f71ebae99e5b4506d30a1135c825099144282cf", "filename": "compiler/rustc_infer/src/infer/outlives/test_type_match.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -0,0 +1,207 @@\n+use std::collections::hash_map::Entry;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty::TypeFoldable;\n+use rustc_middle::ty::{\n+    self,\n+    error::TypeError,\n+    relate::{self, Relate, RelateResult, TypeRelation},\n+    Ty, TyCtxt,\n+};\n+\n+use crate::infer::region_constraints::VerifyIfEq;\n+\n+/// Given a \"verify-if-eq\" type test like:\n+///\n+///     exists<'a...> {\n+///         verify_if_eq(some_type, bound_region)\n+///     }\n+///\n+/// and the type `test_ty` that the type test is being tested against,\n+/// returns:\n+///\n+/// * `None` if `some_type` cannot be made equal to `test_ty`,\n+///   no matter the values of the variables in `exists`.\n+/// * `Some(r)` with a suitable bound (typically the value of `bound_region`, modulo\n+///   any bound existential variables, which will be substituted) for the\n+///   type under test.\n+///\n+/// NB: This function uses a simplistic, syntactic version of type equality.\n+/// In other words, it may spuriously return `None` even if the type-under-test\n+/// is in fact equal to `some_type`. In practice, though, this is used on types\n+/// that are either projections like `T::Item` or `T` and it works fine, but it\n+/// could have trouble when complex types with higher-ranked binders and the\n+/// like are used. This is a particular challenge since this function is invoked\n+/// very late in inference and hence cannot make use of the normal inference\n+/// machinery.\n+#[tracing::instrument(level = \"debug\", skip(tcx, param_env))]\n+pub fn extract_verify_if_eq<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    verify_if_eq_b: &ty::Binder<'tcx, VerifyIfEq<'tcx>>,\n+    test_ty: Ty<'tcx>,\n+) -> Option<ty::Region<'tcx>> {\n+    assert!(!verify_if_eq_b.has_escaping_bound_vars());\n+    let mut m = Match::new(tcx, param_env);\n+    let verify_if_eq = verify_if_eq_b.skip_binder();\n+    m.relate(verify_if_eq.ty, test_ty).ok()?;\n+\n+    if let ty::RegionKind::ReLateBound(depth, br) = verify_if_eq.bound.kind() {\n+        assert!(depth == ty::INNERMOST);\n+        match m.map.get(&br) {\n+            Some(&r) => Some(r),\n+            None => {\n+                // If there is no mapping, then this region is unconstrained.\n+                // In that case, we escalate to `'static`.\n+                Some(tcx.lifetimes.re_static)\n+            }\n+        }\n+    } else {\n+        // The region does not contain any bound variables, so we don't need\n+        // to do any substitution.\n+        //\n+        // Example:\n+        //\n+        // for<'a> <T as Foo<'a>>::Item: 'b\n+        //\n+        // In this case, we've now matched and found a value for\n+        // `'a`, but it doesn't affect the bound `'b`.\n+        Some(verify_if_eq.bound)\n+    }\n+}\n+\n+/// True if a (potentially higher-ranked) outlives\n+#[tracing::instrument(level = \"debug\", skip(tcx, param_env))]\n+pub(super) fn can_match_erased_ty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    outlives_predicate: ty::Binder<'tcx, ty::TypeOutlivesPredicate<'tcx>>,\n+    erased_ty: Ty<'tcx>,\n+) -> bool {\n+    assert!(!outlives_predicate.has_escaping_bound_vars());\n+    let erased_outlives_predicate = tcx.erase_regions(outlives_predicate);\n+    let outlives_ty = erased_outlives_predicate.skip_binder().0;\n+    if outlives_ty == erased_ty {\n+        // pointless micro-optimization\n+        true\n+    } else {\n+        Match::new(tcx, param_env).relate(outlives_ty, erased_ty).is_ok()\n+    }\n+}\n+\n+struct Match<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    pattern_depth: ty::DebruijnIndex,\n+    map: FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n+}\n+\n+impl<'tcx> Match<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Match<'tcx> {\n+        Match { tcx, param_env, pattern_depth: ty::INNERMOST, map: FxHashMap::default() }\n+    }\n+}\n+\n+impl<'tcx> Match<'tcx> {\n+    /// Creates the \"Error\" variant that signals \"no match\".\n+    fn no_match<T>(&self) -> RelateResult<'tcx, T> {\n+        Err(TypeError::Mismatch)\n+    }\n+\n+    /// Binds the pattern variable `br` to `value`; returns an `Err` if the pattern\n+    /// is already bound to a different value.\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn bind(\n+        &mut self,\n+        br: ty::BoundRegion,\n+        value: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        match self.map.entry(br) {\n+            Entry::Occupied(entry) => {\n+                if *entry.get() == value {\n+                    Ok(value)\n+                } else {\n+                    self.no_match()\n+                }\n+            }\n+            Entry::Vacant(entry) => {\n+                entry.insert(value);\n+                Ok(value)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n+    fn tag(&self) -> &'static str {\n+        \"Match\"\n+    }\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    } // irrelevant\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        _: ty::Variance,\n+        _: ty::VarianceDiagInfo<'tcx>,\n+        a: T,\n+        b: T,\n+    ) -> RelateResult<'tcx, T> {\n+        self.relate(a, b)\n+    }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn regions(\n+        &mut self,\n+        pattern: ty::Region<'tcx>,\n+        value: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        debug!(\"self.pattern_depth = {:?}\", self.pattern_depth);\n+        if let ty::RegionKind::ReLateBound(depth, br) = pattern.kind() && depth == self.pattern_depth {\n+            self.bind(br, value)\n+        } else if pattern == value {\n+            Ok(pattern)\n+        } else {\n+            self.no_match()\n+        }\n+    }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn tys(&mut self, pattern: Ty<'tcx>, value: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        if pattern == value { Ok(pattern) } else { relate::super_relate_tys(self, pattern, value) }\n+    }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn consts(\n+        &mut self,\n+        pattern: ty::Const<'tcx>,\n+        value: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n+        debug!(\"{}.consts({:?}, {:?})\", self.tag(), pattern, value);\n+        if pattern == value {\n+            Ok(pattern)\n+        } else {\n+            relate::super_relate_consts(self, pattern, value)\n+        }\n+    }\n+\n+    fn binders<T>(\n+        &mut self,\n+        pattern: ty::Binder<'tcx, T>,\n+        value: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n+    where\n+        T: Relate<'tcx>,\n+    {\n+        self.pattern_depth.shift_in(1);\n+        let result = Ok(pattern.rebind(self.relate(pattern.skip_binder(), value.skip_binder())?));\n+        self.pattern_depth.shift_out(1);\n+        result\n+    }\n+}"}, {"sha": "191f5f18ec2a6e818bbc6e941f4b7f2324b306ac", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 68, "deletions": 45, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -1,4 +1,5 @@\n use crate::infer::outlives::env::RegionBoundPairs;\n+use crate::infer::region_constraints::VerifyIfEq;\n use crate::infer::{GenericKind, VerifyBound};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::sso::SsoHashSet;\n@@ -82,27 +83,39 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         debug!(\"param_bound(param_ty={:?})\", param_ty);\n \n         // Start with anything like `T: 'a` we can scrape from the\n-        // environment\n-        let param_bounds = self\n-            .declared_generic_bounds_from_env(GenericKind::Param(param_ty))\n-            .into_iter()\n-            .map(|outlives| outlives.1);\n+        // environment. If the environment contains something like\n+        // `for<'a> T: 'a`, then we know that `T` outlives everything.\n+        let declared_bounds_from_env = self.declared_generic_bounds_from_env(param_ty);\n+        let mut param_bounds = vec![];\n+        for declared_bound in declared_bounds_from_env {\n+            let bound_region = declared_bound.map_bound(|outlives| outlives.1);\n+            if let Some(region) = bound_region.no_bound_vars() {\n+                // This is `T: 'a` for some free region `'a`.\n+                param_bounds.push(VerifyBound::OutlivedBy(region));\n+            } else {\n+                // This is `for<'a> T: 'a`. This means that `T` outlives everything! All done here.\n+                return VerifyBound::AllBounds(vec![]);\n+            }\n+        }\n \n         // Add in the default bound of fn body that applies to all in\n         // scope type parameters:\n-        let param_bounds = param_bounds.chain(self.implicit_region_bound);\n-\n-        let any_bounds: Vec<_> = param_bounds.map(|r| VerifyBound::OutlivedBy(r)).collect();\n+        if let Some(r) = self.implicit_region_bound {\n+            param_bounds.push(VerifyBound::OutlivedBy(r));\n+        }\n \n-        if any_bounds.is_empty() {\n+        if param_bounds.is_empty() {\n             // We know that all types `T` outlive `'empty`, so if we\n             // can find no other bound, then check that the region\n             // being tested is `'empty`.\n             VerifyBound::IsEmpty\n+        } else if param_bounds.len() == 1 {\n+            // Micro-opt: no need to store the vector if it's just len 1\n+            param_bounds.pop().unwrap()\n         } else {\n             // If we can find any other bound `R` such that `T: R`, then\n             // we don't need to check for `'empty`, because `R: 'empty`.\n-            VerifyBound::AnyBound(any_bounds)\n+            VerifyBound::AnyBound(param_bounds)\n         }\n     }\n \n@@ -122,17 +135,10 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     pub fn projection_approx_declared_bounds_from_env(\n         &self,\n         projection_ty: ty::ProjectionTy<'tcx>,\n-    ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n+    ) -> Vec<ty::Binder<'tcx, ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>> {\n         let projection_ty = GenericKind::Projection(projection_ty).to_ty(self.tcx);\n         let erased_projection_ty = self.tcx.erase_regions(projection_ty);\n-        self.declared_generic_bounds_from_env_with_compare_fn(|ty| {\n-            if let ty::Projection(..) = ty.kind() {\n-                let erased_ty = self.tcx.erase_regions(ty);\n-                erased_ty == erased_projection_ty\n-            } else {\n-                false\n-            }\n-        })\n+        self.declared_generic_bounds_from_env_for_erased_ty(erased_projection_ty)\n     }\n \n     /// Searches the where-clauses in scope for regions that\n@@ -159,15 +165,15 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         let env_bounds = self\n             .projection_approx_declared_bounds_from_env(projection_ty)\n             .into_iter()\n-            .map(|ty::OutlivesPredicate(ty, r)| {\n-                let vb = VerifyBound::OutlivedBy(r);\n-                if ty == projection_ty_as_ty {\n+            .map(|binder| {\n+                if let Some(ty::OutlivesPredicate(ty, r)) = binder.no_bound_vars() && ty == projection_ty_as_ty {\n                     // Micro-optimize if this is an exact match (this\n                     // occurs often when there are no region variables\n                     // involved).\n-                    vb\n+                    VerifyBound::OutlivedBy(r)\n                 } else {\n-                    VerifyBound::IfEq(ty, Box::new(vb))\n+                    let verify_if_eq_b = binder.map_bound(|ty::OutlivesPredicate(ty, bound)| VerifyIfEq { ty, bound });\n+                    VerifyBound::IfEq(verify_if_eq_b)\n                 }\n             });\n \n@@ -219,26 +225,34 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     /// bounds, but all the bounds it returns can be relied upon.\n     fn declared_generic_bounds_from_env(\n         &self,\n-        generic: GenericKind<'tcx>,\n-    ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n-        let generic_ty = generic.to_ty(self.tcx);\n-        self.declared_generic_bounds_from_env_with_compare_fn(|ty| ty == generic_ty)\n+        param_ty: ty::ParamTy,\n+    ) -> Vec<ty::Binder<'tcx, ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>> {\n+        let generic_ty = param_ty.to_ty(self.tcx);\n+        self.declared_generic_bounds_from_env_for_erased_ty(generic_ty)\n     }\n \n-    fn declared_generic_bounds_from_env_with_compare_fn(\n+    /// Searches the environment to find all bounds that apply to `erased_ty`.\n+    /// Obviously these must be approximate -- they are in fact both *over* and\n+    /// and *under* approximated:\n+    ///\n+    /// * Over-approximated because we erase regions, so\n+    /// * Under-approximated because we look for syntactic equality and so for complex types\n+    ///   like `<T as Foo<fn(&u32, &u32)>>::Item` or whatever we may fail to figure out\n+    ///   all the subtleties.\n+    ///\n+    /// In some cases, such as when `erased_ty` represents a `ty::Param`, however,\n+    /// the result is precise.\n+    fn declared_generic_bounds_from_env_for_erased_ty(\n         &self,\n-        compare_ty: impl Fn(Ty<'tcx>) -> bool,\n-    ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n+        erased_ty: Ty<'tcx>,\n+    ) -> Vec<ty::Binder<'tcx, ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>> {\n         let tcx = self.tcx;\n \n         // To start, collect bounds from user environment. Note that\n         // parameter environments are already elaborated, so we don't\n-        // have to worry about that. Comparing using `==` is a bit\n-        // dubious for projections, but it will work for simple cases\n-        // like `T` and `T::Item`. It may not work as well for things\n-        // like `<T as Foo<'a>>::Item`.\n+        // have to worry about that.\n         let c_b = self.param_env.caller_bounds();\n-        let param_bounds = self.collect_outlives_from_predicate_list(&compare_ty, c_b.into_iter());\n+        let param_bounds = self.collect_outlives_from_predicate_list(erased_ty, c_b.into_iter());\n \n         // Next, collect regions we scraped from the well-formedness\n         // constraints in the fn signature. To do that, we walk the list\n@@ -253,18 +267,20 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         // don't know that this holds from first principles.\n         let from_region_bound_pairs = self.region_bound_pairs.iter().filter_map(|&(r, p)| {\n             debug!(\n-                \"declared_generic_bounds_from_env_with_compare_fn: region_bound_pair = {:?}\",\n+                \"declared_generic_bounds_from_env_for_erased_ty: region_bound_pair = {:?}\",\n                 (r, p)\n             );\n             let p_ty = p.to_ty(tcx);\n-            compare_ty(p_ty).then_some(ty::OutlivesPredicate(p_ty, r))\n+            let erased_p_ty = self.tcx.erase_regions(p_ty);\n+            (erased_p_ty == erased_ty)\n+                .then_some(ty::Binder::dummy(ty::OutlivesPredicate(p.to_ty(tcx), r)))\n         });\n \n         param_bounds\n             .chain(from_region_bound_pairs)\n             .inspect(|bound| {\n                 debug!(\n-                    \"declared_generic_bounds_from_env_with_compare_fn: result predicate = {:?}\",\n+                    \"declared_generic_bounds_from_env_for_erased_ty: result predicate = {:?}\",\n                     bound\n                 )\n             })\n@@ -344,12 +360,19 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     /// otherwise want a precise match.\n     fn collect_outlives_from_predicate_list(\n         &self,\n-        compare_ty: impl Fn(Ty<'tcx>) -> bool,\n+        erased_ty: Ty<'tcx>,\n         predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n-    ) -> impl Iterator<Item = ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n-        predicates\n-            .filter_map(|p| p.to_opt_type_outlives())\n-            .filter_map(|p| p.no_bound_vars())\n-            .filter(move |p| compare_ty(p.0))\n+    ) -> impl Iterator<Item = ty::Binder<'tcx, ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>>\n+    {\n+        let tcx = self.tcx;\n+        let param_env = self.param_env;\n+        predicates.filter_map(|p| p.to_opt_type_outlives()).filter(move |outlives_predicate| {\n+            super::test_type_match::can_match_erased_ty(\n+                tcx,\n+                param_env,\n+                *outlives_predicate,\n+                erased_ty,\n+            )\n+        })\n     }\n }"}, {"sha": "19f83e3377a675248103a238a6b0f9f6d0e90e40", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 50, "deletions": 36, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -190,41 +190,8 @@ pub enum GenericKind<'tcx> {\n /// This is described with an `AnyRegion('a, 'b)` node.\n #[derive(Debug, Clone)]\n pub enum VerifyBound<'tcx> {\n-    /// Given a kind K and a bound B, expands to a function like the\n-    /// following, where `G` is the generic for which this verify\n-    /// bound was created:\n-    ///\n-    /// ```ignore (pseudo-rust)\n-    /// fn(min) -> bool {\n-    ///     if G == K {\n-    ///         B(min)\n-    ///     } else {\n-    ///         false\n-    ///     }\n-    /// }\n-    /// ```\n-    ///\n-    /// In other words, if the generic `G` that we are checking is\n-    /// equal to `K`, then check the associated verify bound\n-    /// (otherwise, false).\n-    ///\n-    /// This is used when we have something in the environment that\n-    /// may or may not be relevant, depending on the region inference\n-    /// results. For example, we may have `where <T as\n-    /// Trait<'a>>::Item: 'b` in our where-clauses. If we are\n-    /// generating the verify-bound for `<T as Trait<'0>>::Item`, then\n-    /// this where-clause is only relevant if `'0` winds up inferred\n-    /// to `'a`.\n-    ///\n-    /// So we would compile to a verify-bound like\n-    ///\n-    /// ```ignore (illustrative)\n-    /// IfEq(<T as Trait<'a>>::Item, AnyRegion('a))\n-    /// ```\n-    ///\n-    /// meaning, if the subject G is equal to `<T as Trait<'a>>::Item`\n-    /// (after inference), and `'a: min`, then `G: min`.\n-    IfEq(Ty<'tcx>, Box<VerifyBound<'tcx>>),\n+    /// See [`VerifyIfEq`] docs\n+    IfEq(ty::Binder<'tcx, VerifyIfEq<'tcx>>),\n \n     /// Given a region `R`, expands to the function:\n     ///\n@@ -267,6 +234,53 @@ pub enum VerifyBound<'tcx> {\n     AllBounds(Vec<VerifyBound<'tcx>>),\n }\n \n+/// This is a \"conditional bound\" that checks the result of inference\n+/// and supplies a bound if it ended up being relevant. It's used in situations\n+/// like this:\n+///\n+/// ```rust\n+/// fn foo<'a, 'b, T: SomeTrait<'a>>\n+/// where\n+///    <T as SomeTrait<'a>>::Item: 'b\n+/// ```\n+///\n+/// If we have an obligation like `<T as SomeTrait<'?x>>::Item: 'c`, then\n+/// we don't know yet whether it suffices to show that `'b: 'c`. If `'?x` winds\n+/// up being equal to `'a`, then the where-clauses on function applies, and\n+/// in that case we can show `'b: 'c`. But if `'?x` winds up being something\n+/// else, the bound isn't relevant.\n+///\n+/// In the [`VerifyBound`], this struct is enclosed in `Binder to account\n+/// for cases like\n+///\n+/// ```rust\n+/// where for<'a> <T as SomeTrait<'a>::Item: 'a\n+/// ```\n+///\n+/// The idea is that we have to find some instantiation of `'a` that can\n+/// make `<T as SomeTrait<'a>>::Item` equal to the final value of `G`,\n+/// the generic we are checking.\n+///\n+/// ```ignore (pseudo-rust)\n+/// fn(min) -> bool {\n+///     exists<'a> {\n+///         if G == K {\n+///             B(min)\n+///         } else {\n+///             false\n+///         }\n+///     }\n+/// }\n+/// ```\n+#[derive(Debug, Copy, Clone, TypeFoldable)]\n+pub struct VerifyIfEq<'tcx> {\n+    /// Type which must match the generic `G`\n+    pub ty: Ty<'tcx>,\n+\n+    /// Bound that applies if `ty` is equal.\n+    pub bound: Region<'tcx>,\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub(crate) struct TwoRegions<'tcx> {\n     a: Region<'tcx>,\n@@ -770,7 +784,7 @@ impl<'tcx> VerifyBound<'tcx> {\n \n     pub fn cannot_hold(&self) -> bool {\n         match self {\n-            VerifyBound::IfEq(_, b) => b.cannot_hold(),\n+            VerifyBound::IfEq(..) => false,\n             VerifyBound::IsEmpty => false,\n             VerifyBound::OutlivedBy(_) => false,\n             VerifyBound::AnyBound(bs) => bs.iter().all(|b| b.cannot_hold()),"}, {"sha": "42100edeaa7125d40dfda579781f6b960d5a593e", "filename": "src/test/ui/borrowck/issue-71546.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fborrowck%2Fissue-71546.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fborrowck%2Fissue-71546.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-71546.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -1,20 +1,16 @@\n // Regression test for #71546.\n+//\n+// Made to pass as part of fixing #98095.\n+//\n+// check-pass\n \n pub fn serialize_as_csv<V>(value: &V) -> Result<String, &str>\n where\n     V: 'static,\n     for<'a> &'a V: IntoIterator,\n     for<'a> <&'a V as IntoIterator>::Item: ToString + 'static,\n {\n-    let csv_str: String = value\n-        //~^ ERROR higher-ranked lifetime error\n-        //~| ERROR higher-ranked lifetime error\n-        //~| ERROR higher-ranked lifetime error\n-        .into_iter()\n-        .map(|elem| elem.to_string())\n-        //~^ ERROR higher-ranked lifetime error\n-        .collect::<String>();\n-        //~^ ERROR higher-ranked lifetime error\n+    let csv_str: String = value.into_iter().map(|elem| elem.to_string()).collect::<String>();\n     Ok(csv_str)\n }\n "}, {"sha": "b8d79f0939b41c43c711ac09fb3cef89aa4c0521", "filename": "src/test/ui/borrowck/issue-71546.stderr", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fc96600bf6a52f92aeeee60a92a161a82b61c0ef/src%2Ftest%2Fui%2Fborrowck%2Fissue-71546.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc96600bf6a52f92aeeee60a92a161a82b61c0ef/src%2Ftest%2Fui%2Fborrowck%2Fissue-71546.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-71546.stderr?ref=fc96600bf6a52f92aeeee60a92a161a82b61c0ef", "patch": "@@ -1,59 +0,0 @@\n-error: higher-ranked lifetime error\n-  --> $DIR/issue-71546.rs:9:27\n-   |\n-LL |       let csv_str: String = value\n-   |  ___________________________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |         .into_iter()\n-LL | |         .map(|elem| elem.to_string())\n-   | |_____________________________________^\n-   |\n-   = note: could not prove for<'r> [closure@$DIR/issue-71546.rs:14:14: 14:37] well-formed\n-\n-error: higher-ranked lifetime error\n-  --> $DIR/issue-71546.rs:9:27\n-   |\n-LL |       let csv_str: String = value\n-   |  ___________________________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |         .into_iter()\n-LL | |         .map(|elem| elem.to_string())\n-   | |_____________________________________^\n-   |\n-   = note: could not prove for<'r, 's> Map<<&'r V as IntoIterator>::IntoIter, [closure@$DIR/issue-71546.rs:14:14: 14:37]> well-formed\n-\n-error: higher-ranked lifetime error\n-  --> $DIR/issue-71546.rs:9:27\n-   |\n-LL |       let csv_str: String = value\n-   |  ___________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |\n-LL | |         .collect::<String>();\n-   | |____________________________^\n-   |\n-   = note: could not prove for<'r, 's> Map<<&'r V as IntoIterator>::IntoIter, [closure@$DIR/issue-71546.rs:14:14: 14:37]> well-formed\n-\n-error: higher-ranked lifetime error\n-  --> $DIR/issue-71546.rs:14:14\n-   |\n-LL |         .map(|elem| elem.to_string())\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: could not prove for<'a> <&'a V as IntoIterator>::Item: 'static\n-\n-error: higher-ranked lifetime error\n-  --> $DIR/issue-71546.rs:16:10\n-   |\n-LL |         .collect::<String>();\n-   |          ^^^^^^^\n-\n-error: aborting due to 5 previous errors\n-"}, {"sha": "fb73684390737c09e6747e4fd2ba6384faa0a811", "filename": "src/test/ui/generic-associated-types/collectivity-regression.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollectivity-regression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollectivity-regression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollectivity-regression.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -0,0 +1,24 @@\n+// Regression test from https://github.com/rust-lang/rust/pull/98109\n+\n+#![feature(generic_associated_types)]\n+\n+pub trait Get {\n+    type Value<'a>\n+    where\n+        Self: 'a;\n+}\n+\n+fn multiply_at<T>(x: T)\n+where\n+    for<'a> T: Get<Value<'a> = ()>,\n+{\n+    || {\n+        //~^ `T` does not live long enough\n+        //\n+        // FIXME(#98437). This regressed at some point and\n+        // probably should work.\n+        let _x = x;\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "a858dd7fddcd28233506d5b7dc3f9c5c9c290e10", "filename": "src/test/ui/generic-associated-types/collectivity-regression.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollectivity-regression.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollectivity-regression.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollectivity-regression.stderr?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -0,0 +1,14 @@\n+error: `T` does not live long enough\n+  --> $DIR/collectivity-regression.rs:15:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |         //\n+LL | |         // FIXME(#98437). This regressed at some point and\n+LL | |         // probably should work.\n+LL | |         let _x = x;\n+LL | |     };\n+   | |_____^\n+\n+error: aborting due to previous error\n+"}, {"sha": "07dd0bffd4685900d5db37878e472cc05fea3fb7", "filename": "src/test/ui/generic-associated-types/issue-86483.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86483.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86483.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86483.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -1,14 +1,16 @@\n // Regression test of #86483.\n+//\n+// Made to pass as part of fixing #98095.\n+//\n+// check-pass\n \n #![feature(generic_associated_types)]\n \n-pub trait IceIce<T> //~ ERROR: the parameter type `T` may not live long enough\n+pub trait IceIce<T>\n where\n     for<'a> T: 'a,\n {\n     type Ice<'v>: IntoIterator<Item = &'v T>;\n-    //~^ ERROR: the parameter type `T` may not live long enough\n-    //~| ERROR: the parameter type `T` may not live long enough\n }\n \n fn main() {}"}, {"sha": "a13dc043dc52bc57163e45ce321e5fd9d8663cf9", "filename": "src/test/ui/generic-associated-types/issue-86483.stderr", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fc96600bf6a52f92aeeee60a92a161a82b61c0ef/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86483.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc96600bf6a52f92aeeee60a92a161a82b61c0ef/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86483.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86483.stderr?ref=fc96600bf6a52f92aeeee60a92a161a82b61c0ef", "patch": "@@ -1,50 +0,0 @@\n-error[E0311]: the parameter type `T` may not live long enough\n-  --> $DIR/issue-86483.rs:5:1\n-   |\n-LL | / pub trait IceIce<T>\n-LL | | where\n-LL | |     for<'a> T: 'a,\n-LL | | {\n-...  |\n-LL | |\n-LL | | }\n-   | |_^\n-   |\n-   = note: ...so that the type `T` will meet its required lifetime bounds...\n-note: ...that is required by this bound\n-  --> $DIR/issue-86483.rs:7:16\n-   |\n-LL |     for<'a> T: 'a,\n-   |                ^^\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL |     for<'a> T: 'a + 'a,\n-   |                   ++++\n-\n-error[E0311]: the parameter type `T` may not live long enough\n-  --> $DIR/issue-86483.rs:9:5\n-   |\n-LL |     type Ice<'v>: IntoIterator<Item = &'v T>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds...\n-   |\n-note: ...that is required by this bound\n-  --> $DIR/issue-86483.rs:7:16\n-   |\n-LL |     for<'a> T: 'a,\n-   |                ^^\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL |     for<'a> T: 'a + 'a,\n-   |                   ++++\n-\n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/issue-86483.rs:9:32\n-   |\n-LL |     type Ice<'v>: IntoIterator<Item = &'v T>;\n-   |                                ^^^^^^^^^^^^ - help: consider adding a where clause: `where T: 'v`\n-   |                                |\n-   |                                ...so that the reference type `&'v T` does not outlive the data it points at\n-\n-error: aborting due to 3 previous errors\n-\n-For more information about this error, try `rustc --explain E0309`."}, {"sha": "092fa939c308d5d9a3899d99c667c1d6562c46a5", "filename": "src/test/ui/generic-associated-types/issue-91139.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -1,5 +1,3 @@\n-//check-pass\n-\n #![feature(generic_associated_types)]\n \n trait Foo<T> {\n@@ -16,6 +14,22 @@ impl<T> Foo<T> for () {\n \n fn foo<T>() {\n     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n+    //~^ ERROR `T` does not live long enough\n+    //~| ERROR `T` does not live long enough\n+    //~| ERROR `T` does not live long enough\n+    //~| ERROR `T` does not live long enough\n+    //~| ERROR `T` does not live long enough\n+    //~| ERROR `T` does not live long enough\n+    //~| ERROR `T` does not live long enough\n+    //~| ERROR `T` does not live long enough\n+    //\n+    // FIXME: This error is bogus, but it arises because we try to validate\n+    // that `<() as Foo<T>>::Type<'a>` is valid, which requires proving\n+    // that `T: 'a`. Since `'a` is higher-ranked, this becomes\n+    // `for<'a> T: 'a`, which is not true. Of course, the error is bogus\n+    // because there *ought* to be an implied bound stating that `'a` is\n+    // not any lifetime but specifically\n+    // \"some `'a` such that `<() as Foo<T>>::Type<'a>\" is valid\".\n }\n \n pub fn main() {}"}, {"sha": "6c5092978c84b40084ee52c0eea7936c30de3fcb", "filename": "src/test/ui/generic-associated-types/issue-91139.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.stderr?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -0,0 +1,50 @@\n+error: `T` does not live long enough\n+  --> $DIR/issue-91139.rs:16:12\n+   |\n+LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `T` does not live long enough\n+  --> $DIR/issue-91139.rs:16:12\n+   |\n+LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `T` does not live long enough\n+  --> $DIR/issue-91139.rs:16:12\n+   |\n+LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `T` does not live long enough\n+  --> $DIR/issue-91139.rs:16:12\n+   |\n+LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `T` does not live long enough\n+  --> $DIR/issue-91139.rs:16:58\n+   |\n+LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n+   |                                                          ^^^^^^^^^\n+\n+error: `T` does not live long enough\n+  --> $DIR/issue-91139.rs:16:58\n+   |\n+LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n+   |                                                          ^^^^^^^^^\n+\n+error: `T` does not live long enough\n+  --> $DIR/issue-91139.rs:16:58\n+   |\n+LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n+   |                                                          ^^^^^^^^^\n+\n+error: `T` does not live long enough\n+  --> $DIR/issue-91139.rs:16:58\n+   |\n+LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n+   |                                                          ^^^^^^^^^\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "377b8164ad506745b26b62cb75d7a72493020614", "filename": "src/test/ui/generic-associated-types/issue-92096.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -1,5 +1,4 @@\n // edition:2018\n-// check-pass\n \n #![feature(generic_associated_types)]\n \n@@ -18,6 +17,14 @@ where\n     C: Client + Send + Sync,\n {\n     async move { c.connect().await }\n+    //~^ ERROR `C` does not live long enough\n+    //\n+    // FIXME(#71723). This is because we infer at some point a value of\n+    //\n+    // impl Future<Output = <C as Client>::Connection<'_>>\n+    //\n+    // and then we somehow fail the WF check because `where C: 'a` is not known,\n+    // but I'm not entirely sure how that comes about.\n }\n \n fn main() {}"}, {"sha": "ca61a0f435e93123b27523c4c37571e2495e08c2", "filename": "src/test/ui/generic-associated-types/issue-92096.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.stderr?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -0,0 +1,8 @@\n+error: `C` does not live long enough\n+  --> $DIR/issue-92096.rs:19:5\n+   |\n+LL |     async move { c.connect().await }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "92b7c5deb812e2946573db4516e454d06b5f8e5d", "filename": "src/test/ui/higher-rank-trait-bounds/issue-88586-hr-self-outlives-in-trait-def.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-88586-hr-self-outlives-in-trait-def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-88586-hr-self-outlives-in-trait-def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-88586-hr-self-outlives-in-trait-def.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -1,10 +1,12 @@\n // Regression test for #88586: a higher-ranked outlives bound on Self in a trait\n // definition caused an ICE when debug_assertions were enabled.\n //\n-// FIXME: The error output in the absence of the ICE is unhelpful; this should be improved.\n+// Made to pass as part of fixing #98095.\n+//\n+// check-pass\n \n-trait A where for<'a> Self: 'a\n-//~^ ERROR the parameter type `Self` may not live long enough\n+trait A where\n+    for<'a> Self: 'a,\n {\n }\n "}, {"sha": "18618ffcc86dc84098cab2debd2ad05d604dc2ce", "filename": "src/test/ui/higher-rank-trait-bounds/issue-88586-hr-self-outlives-in-trait-def.stderr", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fc96600bf6a52f92aeeee60a92a161a82b61c0ef/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-88586-hr-self-outlives-in-trait-def.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc96600bf6a52f92aeeee60a92a161a82b61c0ef/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-88586-hr-self-outlives-in-trait-def.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-88586-hr-self-outlives-in-trait-def.stderr?ref=fc96600bf6a52f92aeeee60a92a161a82b61c0ef", "patch": "@@ -1,19 +0,0 @@\n-error[E0311]: the parameter type `Self` may not live long enough\n-  --> $DIR/issue-88586-hr-self-outlives-in-trait-def.rs:6:1\n-   |\n-LL | / trait A where for<'a> Self: 'a\n-LL | |\n-LL | | {\n-LL | | }\n-   | |_^\n-   |\n-   = help: consider adding an explicit lifetime bound `Self: 'a`...\n-   = note: ...so that the type `Self` will meet its required lifetime bounds...\n-note: ...that is required by this bound\n-  --> $DIR/issue-88586-hr-self-outlives-in-trait-def.rs:6:29\n-   |\n-LL | trait A where for<'a> Self: 'a\n-   |                             ^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "b2e5995aa5bc23a3d235605a070189ce78f3175d", "filename": "src/test/ui/nll/snocat-regression.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fnll%2Fsnocat-regression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fnll%2Fsnocat-regression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fsnocat-regression.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -0,0 +1,16 @@\n+// Regression test from https://github.com/rust-lang/rust/pull/98109\n+\n+pub fn negotiate<S>(link: S)\n+where\n+    for<'a> &'a S: 'a,\n+{\n+    || {\n+        //~^ ERROR `S` does not live long enough\n+        //\n+        // FIXME(#98437). This regressed at some point and\n+        // probably should work.\n+        let _x = link;\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "0868984734d7bf9676035fe0c9c33b000e5256d3", "filename": "src/test/ui/nll/snocat-regression.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fnll%2Fsnocat-regression.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fnll%2Fsnocat-regression.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fsnocat-regression.stderr?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -0,0 +1,14 @@\n+error: `S` does not live long enough\n+  --> $DIR/snocat-regression.rs:7:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |         //\n+LL | |         // FIXME(#98437). This regressed at some point and\n+LL | |         // probably should work.\n+LL | |         let _x = link;\n+LL | |     };\n+   | |_____^\n+\n+error: aborting due to previous error\n+"}, {"sha": "f9801c07d7bcbafdde84785914c20734ad8e0683", "filename": "src/test/ui/nll/type-test-universe.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fnll%2Ftype-test-universe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fnll%2Ftype-test-universe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-test-universe.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -0,0 +1,21 @@\n+// Regression test for #98095: make sure that\n+// we detect that S needs to outlive 'static.\n+\n+fn outlives_forall<T>()\n+where\n+    for<'u> T: 'u,\n+{\n+}\n+\n+fn test1<S>() {\n+    outlives_forall::<S>();\n+    //~^ ERROR `S` does not live long enough\n+}\n+\n+struct Value<'a>(&'a ());\n+fn test2<'a>() {\n+    outlives_forall::<Value<'a>>();\n+    //~^ ERROR lifetime may not live long enough\n+}\n+\n+fn main() {}"}, {"sha": "242486c360a8090ea7f215d4448e6039250c8136", "filename": "src/test/ui/nll/type-test-universe.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fnll%2Ftype-test-universe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fnll%2Ftype-test-universe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-test-universe.stderr?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -0,0 +1,16 @@\n+error: `S` does not live long enough\n+  --> $DIR/type-test-universe.rs:11:5\n+   |\n+LL |     outlives_forall::<S>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: lifetime may not live long enough\n+  --> $DIR/type-test-universe.rs:17:5\n+   |\n+LL | fn test2<'a>() {\n+   |          -- lifetime `'a` defined here\n+LL |     outlives_forall::<Value<'a>>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "0a4ed7e0a4021167e4c5e4c71941311b91f43349", "filename": "src/test/ui/nll/vimwiki-core-regression.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fnll%2Fvimwiki-core-regression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fnll%2Fvimwiki-core-regression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fvimwiki-core-regression.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -0,0 +1,37 @@\n+// check-pass\n+//\n+// Regression test from crater run for\n+// <https://github.com/rust-lang/rust/pull/98109>.\n+\n+\n+pub trait ElementLike {}\n+\n+pub struct Located<T> where T: ElementLike {\n+    inner: T,\n+}\n+\n+pub struct BlockElement<'a>(&'a str);\n+\n+impl ElementLike for BlockElement<'_> {}\n+\n+\n+pub struct Page<'a> {\n+    /// Comprised of the elements within a page\n+    pub elements: Vec<Located<BlockElement<'a>>>,\n+}\n+\n+impl<'a, __IdxT> std::ops::Index<__IdxT> for Page<'a> where\n+    Vec<Located<BlockElement<'a>>>: std::ops::Index<__IdxT>\n+{\n+    type Output =\n+        <Vec<Located<BlockElement<'a>>> as\n+        std::ops::Index<__IdxT>>::Output;\n+\n+    #[inline]\n+    fn index(&self, idx: __IdxT) -> &Self::Output {\n+        <Vec<Located<BlockElement<'a>>> as\n+                std::ops::Index<__IdxT>>::index(&self.elements, idx)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "9c37d72d56b64e277fafe456ce51a52b44c03ebd", "filename": "src/test/ui/regions/forall-wf-ref-reflexive.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fregions%2Fforall-wf-ref-reflexive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fregions%2Fforall-wf-ref-reflexive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fforall-wf-ref-reflexive.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -0,0 +1,18 @@\n+// Test that we consider `for<'a> &'a T: 'a` to be sufficient to prove\n+// that `for<'a> &'a T: 'a`.\n+//\n+// FIXME. Except we don't!\n+\n+#![allow(warnings)]\n+\n+fn self_wf2<T>()\n+where\n+    for<'a> &'a T: 'a,\n+{\n+    self_wf2::<T>();\n+    //~^ ERROR `T` does not live long enough\n+    //\n+    // FIXME. This ought to be accepted, presumably.\n+}\n+\n+fn main() {}"}, {"sha": "3d059ccec7296da516f8542a796a2f14a23eb088", "filename": "src/test/ui/regions/forall-wf-ref-reflexive.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fregions%2Fforall-wf-ref-reflexive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fregions%2Fforall-wf-ref-reflexive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fforall-wf-ref-reflexive.stderr?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -0,0 +1,8 @@\n+error: `T` does not live long enough\n+  --> $DIR/forall-wf-ref-reflexive.rs:12:5\n+   |\n+LL |     self_wf2::<T>();\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "8e6b8224b318696965637bc0033dd2df44ef35de", "filename": "src/test/ui/regions/forall-wf-reflexive.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fregions%2Fforall-wf-reflexive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d017d59ed013a4bc2431d023077eb7209fe9c60d/src%2Ftest%2Fui%2Fregions%2Fforall-wf-reflexive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fforall-wf-reflexive.rs?ref=d017d59ed013a4bc2431d023077eb7209fe9c60d", "patch": "@@ -0,0 +1,15 @@\n+// Test that we consider `for<'a> T: 'a` to be sufficient to prove\n+// that `for<'a> T: 'a`.\n+//\n+// check-pass\n+\n+#![allow(warnings)]\n+\n+fn self_wf1<T>()\n+where\n+    for<'a> T: 'a,\n+{\n+    self_wf1::<T>();\n+}\n+\n+fn main() {}"}]}