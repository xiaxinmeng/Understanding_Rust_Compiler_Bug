{"sha": "22ec5f4af7b5a85ad375d672ed727571b49f3cad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZWM1ZjRhZjdiNWE4NWFkMzc1ZDY3MmVkNzI3NTcxYjQ5ZjNjYWQ=", "commit": {"author": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2015-07-24T01:04:55Z"}, "committer": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2015-08-09T20:05:22Z"}, "message": "Replace many uses of `mem::transmute` with more specific functions\n\nThe replacements are functions that usually use a single `mem::transmute` in\ntheir body and restrict input and output via more concrete types than `T` and\n`U`. Worth noting are the `transmute` functions for slices and the `from_utf8*`\nfamily for mutable slices. Additionally, `mem::transmute` was often used for\ncasting raw pointers, when you can already cast raw pointers just fine with\n`as`.", "tree": {"sha": "eea29f1286398aaaa9d55f23163ddcc49b033eeb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eea29f1286398aaaa9d55f23163ddcc49b033eeb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22ec5f4af7b5a85ad375d672ed727571b49f3cad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22ec5f4af7b5a85ad375d672ed727571b49f3cad", "html_url": "https://github.com/rust-lang/rust/commit/22ec5f4af7b5a85ad375d672ed727571b49f3cad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22ec5f4af7b5a85ad375d672ed727571b49f3cad/comments", "author": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "febdc3b201bcce1546c88e3be1b956d3f90d3059", "url": "https://api.github.com/repos/rust-lang/rust/commits/febdc3b201bcce1546c88e3be1b956d3f90d3059", "html_url": "https://github.com/rust-lang/rust/commit/febdc3b201bcce1546c88e3be1b956d3f90d3059"}], "stats": {"total": 290, "additions": 187, "deletions": 103}, "files": [{"sha": "56c7324090e4c41c82ecd4246e11d408c02a575a", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -193,7 +193,7 @@ impl<T> Arc<T> {\n             weak: atomic::AtomicUsize::new(1),\n             data: data,\n         };\n-        Arc { _ptr: unsafe { NonZero::new(mem::transmute(x)) } }\n+        Arc { _ptr: unsafe { NonZero::new(Box::into_raw(x)) } }\n     }\n }\n "}, {"sha": "54df3b35bdb8f373b5fd680d862c838cba0b3d7b", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -152,7 +152,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n     let fill = chunk.fill.get();\n \n     while idx < fill {\n-        let tydesc_data: *const usize = mem::transmute(buf.offset(idx as isize));\n+        let tydesc_data = buf.offset(idx as isize) as *const usize;\n         let (tydesc, is_done) = un_bitpack_tydesc_ptr(*tydesc_data);\n         let (size, align) = ((*tydesc).size, (*tydesc).align);\n \n@@ -305,7 +305,7 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n             let ptr = ptr as *mut T;\n             // Write in our tydesc along with a bit indicating that it\n             // has *not* been initialized yet.\n-            *ty_ptr = mem::transmute(tydesc);\n+            *ty_ptr = bitpack_tydesc_ptr(tydesc, false);\n             // Actually initialize it\n             ptr::write(&mut(*ptr), op());\n             // Now that we are done, update the tydesc to indicate that\n@@ -443,8 +443,7 @@ impl<T> TypedArenaChunk<T> {\n     fn start(&self) -> *const u8 {\n         let this: *const TypedArenaChunk<T> = self;\n         unsafe {\n-            mem::transmute(round_up(this.offset(1) as usize,\n-                                    mem::align_of::<T>()))\n+            round_up(this.offset(1) as usize, mem::align_of::<T>()) as *const u8\n         }\n     }\n \n@@ -488,7 +487,7 @@ impl<T> TypedArena<T> {\n         }\n \n         let ptr: &mut T = unsafe {\n-            let ptr: &mut T = mem::transmute(self.ptr.clone());\n+            let ptr: &mut T = &mut *(self.ptr.get() as *mut T);\n             ptr::write(ptr, object);\n             self.ptr.set(self.ptr.get().offset(1));\n             ptr"}, {"sha": "d36fe669fa374b798d9c6d918dd779cdf1e6ed81", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -25,7 +25,7 @@ use core::iter::Zip;\n use core::marker::PhantomData;\n use core::ops::{Deref, DerefMut, Index, IndexMut};\n use core::ptr::Unique;\n-use core::{slice, mem, ptr, cmp, raw};\n+use core::{slice, mem, ptr, cmp};\n use alloc::heap::{self, EMPTY};\n \n use borrow::Borrow;\n@@ -357,7 +357,10 @@ impl<K, V> Node<K, V> {\n \n     #[inline]\n     pub fn as_slices_mut<'a>(&'a mut self) -> (&'a mut [K], &'a mut [V]) {\n-        unsafe { mem::transmute(self.as_slices()) }\n+        unsafe {(\n+            slice::from_raw_parts_mut(*self.keys, self.len()),\n+            slice::from_raw_parts_mut(*self.vals, self.len()),\n+        )}\n     }\n \n     #[inline]\n@@ -372,10 +375,7 @@ impl<K, V> Node<K, V> {\n                     None => heap::EMPTY as *const Node<K,V>,\n                     Some(ref p) => **p as *const Node<K,V>,\n                 };\n-                mem::transmute(raw::Slice {\n-                    data: data,\n-                    len: self.len() + 1\n-                })\n+                slice::from_raw_parts(data, self.len() + 1)\n             }\n         };\n         NodeSlice {\n@@ -390,6 +390,7 @@ impl<K, V> Node<K, V> {\n \n     #[inline]\n     pub fn as_slices_internal_mut<'b>(&'b mut self) -> MutNodeSlice<'b, K, V> {\n+        // TODO: Bad: This relies on structure layout!\n         unsafe { mem::transmute(self.as_slices_internal()) }\n     }\n "}, {"sha": "3be5f32d6c2d58295f4e1eb433660c7a3db4924d", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -47,7 +47,6 @@\n #![feature(oom)]\n #![feature(pattern)]\n #![feature(ptr_as_ref)]\n-#![feature(raw)]\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n #![feature(step_by)]"}, {"sha": "b681f7a63413ed7d777ef0b7bc47cc510c6bb7b1", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -109,6 +109,7 @@ pub use core::slice::{IntSliceExt, SplitMut, ChunksMut, Split};\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n+pub use core::slice::{transmute, transmute_mut};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Basic slice extension methods"}, {"sha": "d359d7548f3f129a21f3852bee5f5368d06fd4d1", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -479,6 +479,19 @@ impl str {\n         core_str::StrExt::as_bytes(self)\n     }\n \n+    /// Converts `self` to a mutable byte slice.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// The `str` type guarantees that its contents are UTF-8 bytes, which can\n+    /// be violated using this function, leading to memory-unsafeties in other\n+    /// string functions.\n+    #[unstable(feature = \"str_as_bytes_mut\")]\n+    #[inline(always)]\n+    pub unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n+        core_str::StrExt::as_bytes_mut(self)\n+    }\n+\n     /// Returns a raw pointer to the `&str`'s buffer.\n     ///\n     /// The caller must ensure that the string outlives this pointer, and\n@@ -504,8 +517,7 @@ impl str {\n     /// # Unsafety\n     ///\n     /// Caller must check both UTF-8 sequence boundaries and the boundaries\n-    /// of the entire slice as\n-    /// well.\n+    /// of the entire slice as well.\n     ///\n     /// # Examples\n     ///"}, {"sha": "2bd5b315c4c0dbff81ad806c01584352e37126be", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -977,7 +977,7 @@ impl ops::Index<ops::RangeFull> for String {\n \n     #[inline]\n     fn index(&self, _index: ops::RangeFull) -> &str {\n-        unsafe { mem::transmute(&*self.vec) }\n+        unsafe { str::from_utf8_unchecked(&self.vec) }\n     }\n }\n \n@@ -1016,15 +1016,15 @@ impl ops::Deref for String {\n \n     #[inline]\n     fn deref(&self) -> &str {\n-        unsafe { mem::transmute(&self.vec[..]) }\n+        unsafe { str::from_utf8_unchecked(&self.vec) }\n     }\n }\n \n #[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n impl ops::DerefMut for String {\n     #[inline]\n     fn deref_mut(&mut self) -> &mut str {\n-        unsafe { mem::transmute(&mut self.vec[..]) }\n+        unsafe { mem::transmute(&mut *self.vec) }\n     }\n }\n "}, {"sha": "83786648ea04955565c82877d5b5137b3b34598a", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -1714,7 +1714,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n                 } else {\n                     self.end = self.end.offset(-1);\n \n-                    Some(ptr::read(mem::transmute(self.end)))\n+                    Some(ptr::read(self.end))\n                 }\n             }\n         }"}, {"sha": "ed912d59ce68733b52d2bdf0d672925c6236bf4c", "filename": "src/libcore/any.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -146,7 +146,7 @@ impl Any {\n                 let to: TraitObject = transmute(self);\n \n                 // Extract the data pointer\n-                Some(transmute(to.data))\n+                Some(&*(to.data as *const T))\n             }\n         } else {\n             None\n@@ -164,7 +164,7 @@ impl Any {\n                 let to: TraitObject = transmute(self);\n \n                 // Extract the data pointer\n-                Some(transmute(to.data))\n+                Some(&mut *(to.data as *const T as *mut T))\n             }\n         } else {\n             None"}, {"sha": "da4bb41fd9c3dedc0c16d29358aeaffec4ea1d25", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -19,6 +19,7 @@\n \n use self::Ordering::*;\n \n+use mem;\n use marker::Sized;\n use option::Option::{self, Some, None};\n \n@@ -114,6 +115,10 @@ pub enum Ordering {\n }\n \n impl Ordering {\n+    unsafe fn from_i8_unchecked(v: i8) -> Ordering {\n+        mem::transmute(v)\n+    }\n+\n     /// Reverse the `Ordering`.\n     ///\n     /// * `Less` becomes `Greater`.\n@@ -155,7 +160,7 @@ impl Ordering {\n             //\n             // NB. it is safe because of the explicit discriminants\n             // given above.\n-            ::mem::transmute::<_, Ordering>(-(self as i8))\n+            Ordering::from_i8_unchecked(-(self as i8))\n         }\n     }\n }"}, {"sha": "ea2a9d1cfaf60fed1e55433d42b755441a1c327b", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -90,7 +90,7 @@ pub trait Write {\n     fn write_char(&mut self, c: char) -> Result {\n         let mut utf_8 = [0u8; 4];\n         let bytes_written = c.encode_utf8(&mut utf_8).unwrap_or(0);\n-        self.write_str(unsafe { mem::transmute(&utf_8[..bytes_written]) })\n+        self.write_str(unsafe { str::from_utf8_unchecked(&utf_8[..bytes_written]) })\n     }\n \n     /// Glue for usage of the `write!` macro with implementers of this trait.\n@@ -1320,7 +1320,7 @@ impl Display for char {\n         } else {\n             let mut utf8 = [0; 4];\n             let amt = self.encode_utf8(&mut utf8).unwrap_or(0);\n-            let s: &str = unsafe { mem::transmute(&utf8[..amt]) };\n+            let s: &str = unsafe { str::from_utf8_unchecked(&utf8[..amt]) };\n             f.pad(s)\n         }\n     }"}, {"sha": "64727242b9c96ecb2a88b1f450b475f8eed56963", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -16,13 +16,13 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use mem;\n use clone::Clone;\n use intrinsics;\n use ops::Deref;\n use fmt;\n use option::Option::{self, Some, None};\n use marker::{PhantomData, Send, Sized, Sync};\n+use mem;\n use nonzero::NonZero;\n \n use cmp::{PartialEq, Eq, Ord, PartialOrd};\n@@ -100,7 +100,7 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n-    mem::swap(mem::transmute(dest), &mut src); // cannot overlap\n+    mem::swap(&mut *dest, &mut src); // cannot overlap\n     src\n }\n \n@@ -327,15 +327,14 @@ impl<T: ?Sized> Clone for *mut T {\n \n // Equality for extern \"C\" fn pointers\n mod externfnpointers {\n-    use mem;\n     use cmp::PartialEq;\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<_R> PartialEq for extern \"C\" fn() -> _R {\n         #[inline]\n         fn eq(&self, other: &extern \"C\" fn() -> _R) -> bool {\n-            let self_: *const () = unsafe { mem::transmute(*self) };\n-            let other_: *const () = unsafe { mem::transmute(*other) };\n+            let self_ = *self as usize;\n+            let other_ = *other as usize;\n             self_ == other_\n         }\n     }\n@@ -345,9 +344,9 @@ mod externfnpointers {\n             impl<_R,$($p),*> PartialEq for extern \"C\" fn($($p),*) -> _R {\n                 #[inline]\n                 fn eq(&self, other: &extern \"C\" fn($($p),*) -> _R) -> bool {\n-                    let self_: *const () = unsafe { mem::transmute(*self) };\n+                    let self_ = *self as usize;\n \n-                    let other_: *const () = unsafe { mem::transmute(*other) };\n+                    let other_ = *other as usize;\n                     self_ == other_\n                 }\n             }"}, {"sha": "9120da78d25172045bec96972f9ef7b303a76a4b", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -33,7 +33,6 @@\n // * The `raw` and `bytes` submodules.\n // * Boilerplate trait implementations.\n \n-use mem::transmute;\n use clone::Clone;\n use cmp::{Ordering, PartialEq, PartialOrd, Eq, Ord};\n use cmp::Ordering::{Less, Equal, Greater};\n@@ -148,7 +147,7 @@ macro_rules! slice_ref {\n             // Use a non-null pointer value\n             &mut *(1 as *mut _)\n         } else {\n-            transmute(ptr)\n+            mem::transmute(ptr)\n         }\n     }};\n }\n@@ -261,7 +260,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     unsafe fn get_unchecked(&self, index: usize) -> &T {\n-        transmute(self.repr().data.offset(index as isize))\n+        &*(self.repr().data.offset(index as isize))\n     }\n \n     #[inline]\n@@ -430,7 +429,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut T {\n-        transmute((self.repr().data as *mut T).offset(index as isize))\n+        &mut *(self.repr().data as *mut T).offset(index as isize)\n     }\n \n     #[inline]\n@@ -547,8 +546,7 @@ impl<T> ops::Index<usize> for [T] {\n \n     fn index(&self, index: usize) -> &T {\n         assert!(index < self.len());\n-\n-        unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n+        unsafe { self.get_unchecked(index) }\n     }\n }\n \n@@ -557,8 +555,7 @@ impl<T> ops::IndexMut<usize> for [T] {\n     #[inline]\n     fn index_mut(&mut self, index: usize) -> &mut T {\n         assert!(index < self.len());\n-\n-        unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n+        unsafe { self.get_unchecked_mut(index) }\n     }\n }\n \n@@ -1427,7 +1424,7 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_raw_parts<'a, T>(p: *const T, len: usize) -> &'a [T] {\n-    transmute(RawSlice { data: p, len: len })\n+    mem::transmute(RawSlice { data: p, len: len })\n }\n \n /// Performs the same functionality as `from_raw_parts`, except that a mutable\n@@ -1439,7 +1436,40 @@ pub unsafe fn from_raw_parts<'a, T>(p: *const T, len: usize) -> &'a [T] {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {\n-    transmute(RawSlice { data: p, len: len })\n+    mem::transmute(RawSlice { data: p, len: len })\n+}\n+\n+#[inline]\n+fn check_types<T,U>() {\n+    assert!(mem::size_of::<T>() == mem::size_of::<U>());\n+    assert!(mem::align_of::<T>() % mem::align_of::<U>() == 0)\n+}\n+\n+/// Reinterprets a slice of one type as a slice of another type.\n+///\n+/// Both types have to have the same size and the type that is converted to\n+/// must have equal or less restrictive alignment.\n+///\n+/// # Panics\n+///\n+/// This functions panics if the above preconditions about the types are not\n+/// met.\n+#[inline]\n+#[unstable(feature = \"slice_transmute\", reason = \"recent API addition\")]\n+pub unsafe fn transmute<T,U>(slice: &[T]) -> &[U] {\n+    check_types::<T,U>();\n+    from_raw_parts(slice.as_ptr() as *const U, slice.len())\n+}\n+\n+/// Reinterprets a mutable slice of one type as a mutable slice of another\n+/// type.\n+///\n+/// Equivalent of `slice::transmute` for mutable slices.\n+#[inline]\n+#[unstable(feature = \"slice_transmute\", reason = \"recent API addition\")]\n+pub unsafe fn transmute_mut<T,U>(slice: &mut [T]) -> &mut [U] {\n+    check_types::<T,U>();\n+    from_raw_parts_mut(slice.as_mut_ptr() as *mut U, slice.len())\n }\n \n //\n@@ -1580,9 +1610,9 @@ macro_rules! impl_int_slice {\n             #[inline]\n             fn as_signed(&self) -> &[$s] { unsafe { transmute(self) } }\n             #[inline]\n-            fn as_unsigned_mut(&mut self) -> &mut [$u] { unsafe { transmute(self) } }\n+            fn as_unsigned_mut(&mut self) -> &mut [$u] { unsafe { transmute_mut(self) } }\n             #[inline]\n-            fn as_signed_mut(&mut self) -> &mut [$s] { unsafe { transmute(self) } }\n+            fn as_signed_mut(&mut self) -> &mut [$s] { unsafe { transmute_mut(self) } }\n         }\n     }\n }"}, {"sha": "202fc90b40d22d90a35ce08a31650a9eca072814", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -17,7 +17,7 @@\n use self::pattern::Pattern;\n use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n \n-use char::CharExt;\n+use char::{self, CharExt};\n use clone::Clone;\n use cmp::Eq;\n use convert::AsRef;\n@@ -123,13 +123,13 @@ impl Utf8Error {\n /// Converts a slice of bytes to a string slice without performing any\n /// allocations.\n ///\n-/// Once the slice has been validated as utf-8, it is transmuted in-place and\n+/// Once the slice has been validated as UTF-8, it is transmuted in-place and\n /// returned as a '&str' instead of a '&[u8]'\n ///\n /// # Failure\n ///\n-/// Returns `Err` if the slice is not utf-8 with a description as to why the\n-/// provided slice is not utf-8.\n+/// Returns `Err` if the slice is not UTF-8 with a description as to why the\n+/// provided slice is not UTF-8.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n     try!(run_utf8_validation_iterator(&mut v.iter()));\n@@ -262,7 +262,7 @@ impl<'a> Iterator for Chars<'a> {\n         next_code_point(&mut self.iter).map(|ch| {\n             // str invariant says `ch` is a valid Unicode Scalar Value\n             unsafe {\n-                mem::transmute(ch)\n+                char::from_u32_unchecked(ch)\n             }\n         })\n     }\n@@ -284,7 +284,7 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n         next_code_point_reverse(&mut self.iter).map(|ch| {\n             // str invariant says `ch` is a valid Unicode Scalar Value\n             unsafe {\n-                mem::transmute(ch)\n+                char::from_u32_unchecked(ch)\n             }\n         })\n     }\n@@ -1264,6 +1264,7 @@ pub trait StrExt {\n     fn char_at(&self, i: usize) -> char;\n     fn char_at_reverse(&self, i: usize) -> char;\n     fn as_bytes<'a>(&'a self) -> &'a [u8];\n+    unsafe fn as_bytes_mut<'a>(&'a mut self) -> &'a mut [u8];\n     fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;\n     fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n         where P::Searcher: ReverseSearcher<'a>;\n@@ -1507,7 +1508,7 @@ impl StrExt for str {\n     #[inline]\n     fn char_range_at(&self, i: usize) -> CharRange {\n         let (c, n) = char_range_at_raw(self.as_bytes(), i);\n-        CharRange { ch: unsafe { mem::transmute(c) }, next: n }\n+        CharRange { ch: unsafe { char::from_u32_unchecked(c) }, next: n }\n     }\n \n     #[inline]\n@@ -1535,7 +1536,7 @@ impl StrExt for str {\n             if w > 2 { val = utf8_acc_cont_byte(val, s.as_bytes()[i + 2]); }\n             if w > 3 { val = utf8_acc_cont_byte(val, s.as_bytes()[i + 3]); }\n \n-            return CharRange {ch: unsafe { mem::transmute(val) }, next: i};\n+            return CharRange {ch: unsafe { char::from_u32_unchecked(val) }, next: i};\n         }\n \n         return multibyte_char_range_at_reverse(self, prev);\n@@ -1556,6 +1557,11 @@ impl StrExt for str {\n         unsafe { mem::transmute(self) }\n     }\n \n+    #[inline]\n+    unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n+        mem::transmute(self)\n+    }\n+\n     fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n         pat.into_searcher(self).next_match().map(|(i, _)| i)\n     }"}, {"sha": "595bce682010bc9282ea7b33dd262e8a754933d2", "filename": "src/libcoretest/hash/mod.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -10,7 +10,6 @@\n \n mod sip;\n \n-use std::mem;\n use std::hash::{Hash, Hasher};\n use std::default::Default;\n \n@@ -72,15 +71,11 @@ fn test_writer_hasher() {\n \n     // FIXME (#18248) Add tests for hashing Rc<str> and Rc<[T]>\n \n-    unsafe {\n-        let ptr: *const i32 = mem::transmute(5_usize);\n-        assert_eq!(hash(&ptr), 5);\n-    }\n+    let ptr = 5_usize as *const i32;\n+    assert_eq!(hash(&ptr), 5);\n \n-    unsafe {\n-        let ptr: *mut i32 = mem::transmute(5_usize);\n-        assert_eq!(hash(&ptr), 5);\n-    }\n+    let ptr = 5_usize as *mut i32;\n+    assert_eq!(hash(&ptr), 5);\n }\n \n struct Custom { hash: u64 }"}, {"sha": "343db93d4a970f2f05b28579ae413904b8187221", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use core::ptr::*;\n-use core::mem;\n \n #[test]\n fn test() {\n@@ -20,7 +19,7 @@ fn test() {\n         };\n         let mut p = Pair {fst: 10, snd: 20};\n         let pptr: *mut Pair = &mut p;\n-        let iptr: *mut isize = mem::transmute(pptr);\n+        let iptr: *mut isize = pptr as *mut isize;\n         assert_eq!(*iptr, 10);\n         *iptr = 30;\n         assert_eq!(*iptr, 30);"}, {"sha": "bec4f24a565b46b27e96ea023ee0a60753a4c1de", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -294,7 +294,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n             1 => panic!(\"cannot log after main thread has exited\"),\n             n => {\n                 let filter = mem::transmute::<_, &String>(n);\n-                if !args.to_string().contains(&filter[..]) {\n+                if !args.to_string().contains(filter) {\n                     return\n                 }\n             }"}, {"sha": "c3a02ec5aabdbbd8b9c9db1f3a0cdb467b46f100", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -17,9 +17,9 @@ use distributions::{ziggurat, ziggurat_tables, Sample, IndependentSample};\n \n /// A wrapper around an `f64` to generate Exp(1) random numbers.\n ///\n-/// See `Exp` for the general exponential distribution.Note that this\n- // has to be unwrapped before use as an `f64` (using either\n-/// `*` or `mem::transmute` is safe).\n+/// See `Exp` for the general exponential distribution. Note that this has to\n+/// be unwrapped before use as an `f64` (using either `*` or `mem::transmute`\n+/// is safe).\n ///\n /// Implemented via the ZIGNOR variant[1] of the Ziggurat method. The\n /// exact description in the paper was adjusted to use tables for the"}, {"sha": "d1fb0c2e8d79ee8dfa15937f4f96d7a635228293", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -25,7 +25,6 @@ use syntax::diagnostic::{Emitter, Handler, Level};\n \n use std::ffi::{CStr, CString};\n use std::fs;\n-use std::mem;\n use std::path::Path;\n use std::ptr;\n use std::str;\n@@ -375,8 +374,7 @@ unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext<'a>,\n unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n                                         user: *const c_void,\n                                         cookie: c_uint) {\n-    let HandlerFreeVars { cgcx, .. }\n-        = *mem::transmute::<_, *const HandlerFreeVars>(user);\n+    let HandlerFreeVars { cgcx, .. } = *(user as *const HandlerFreeVars);\n \n     let msg = llvm::build_string(|s| llvm::LLVMWriteSMDiagnosticToString(diag, s))\n         .expect(\"non-UTF8 SMDiagnostic\");\n@@ -385,8 +383,7 @@ unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n }\n \n unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_void) {\n-    let HandlerFreeVars { llcx, cgcx }\n-        = *mem::transmute::<_, *const HandlerFreeVars>(user);\n+    let HandlerFreeVars { llcx, cgcx } = *(user as *const HandlerFreeVars);\n \n     match llvm::diagnostic::Diagnostic::unpack(info) {\n         llvm::diagnostic::InlineAsm(inline) => {"}, {"sha": "24f4713cad29c9612592cd2a4930ea9be1783e9c", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -25,6 +25,7 @@\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![cfg_attr(not(stage0), feature(slice_transmute))]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(const_fn)]"}, {"sha": "530b1a8ebc054b747157ab0e534adc29f2dd291f", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -20,8 +20,11 @@ use util::nodemap::FnvHashMap;\n use syntax::ast;\n \n use std::ffi::CString;\n+#[cfg(stage0)]\n use std::mem;\n use std::ptr;\n+#[cfg(not(stage0))]\n+use std::slice;\n use std::cell::RefCell;\n \n use libc::c_uint;\n@@ -148,25 +151,50 @@ impl Type {\n         }\n     }\n \n+    #[cfg(stage0)]\n     pub fn func(args: &[Type], ret: &Type) -> Type {\n         let vec : &[TypeRef] = unsafe { mem::transmute(args) };\n         ty!(llvm::LLVMFunctionType(ret.to_ref(), vec.as_ptr(),\n                                    args.len() as c_uint, False))\n     }\n \n+    #[cfg(not(stage0))]\n+    pub fn func(args: &[Type], ret: &Type) -> Type {\n+        let vec: &[TypeRef] = unsafe { slice::transmute(args) };\n+        ty!(llvm::LLVMFunctionType(ret.to_ref(), vec.as_ptr(),\n+                                   args.len() as c_uint, False))\n+    }\n+\n+    #[cfg(stage0)]\n     pub fn variadic_func(args: &[Type], ret: &Type) -> Type {\n         let vec : &[TypeRef] = unsafe { mem::transmute(args) };\n         ty!(llvm::LLVMFunctionType(ret.to_ref(), vec.as_ptr(),\n                                    args.len() as c_uint, True))\n     }\n \n+    #[cfg(not(stage0))]\n+    pub fn variadic_func(args: &[Type], ret: &Type) -> Type {\n+        let vec: &[TypeRef] = unsafe { slice::transmute(args) };\n+        ty!(llvm::LLVMFunctionType(ret.to_ref(), vec.as_ptr(),\n+                                   args.len() as c_uint, True))\n+    }\n+\n+    #[cfg(stage0)]\n     pub fn struct_(ccx: &CrateContext, els: &[Type], packed: bool) -> Type {\n         let els : &[TypeRef] = unsafe { mem::transmute(els) };\n         ty!(llvm::LLVMStructTypeInContext(ccx.llcx(), els.as_ptr(),\n                                           els.len() as c_uint,\n                                           packed as Bool))\n     }\n \n+    #[cfg(not(stage0))]\n+    pub fn struct_(ccx: &CrateContext, els: &[Type], packed: bool) -> Type {\n+        let els : &[TypeRef] = unsafe { slice::transmute(els) };\n+        ty!(llvm::LLVMStructTypeInContext(ccx.llcx(), els.as_ptr(),\n+                                          els.len() as c_uint,\n+                                          packed as Bool))\n+    }\n+\n     pub fn named_struct(ccx: &CrateContext, name: &str) -> Type {\n         let name = CString::new(name).unwrap();\n         ty!(llvm::LLVMStructCreateNamed(ccx.llcx(), name.as_ptr()))\n@@ -208,6 +236,7 @@ impl Type {\n         }\n     }\n \n+    #[cfg(stage0)]\n     pub fn set_struct_body(&mut self, els: &[Type], packed: bool) {\n         unsafe {\n             let vec : &[TypeRef] = mem::transmute(els);\n@@ -216,6 +245,15 @@ impl Type {\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    pub fn set_struct_body(&mut self, els: &[Type], packed: bool) {\n+        unsafe {\n+            let vec: &[TypeRef] = slice::transmute(els);\n+            llvm::LLVMStructSetBody(self.to_ref(), vec.as_ptr(),\n+                                    els.len() as c_uint, packed as Bool)\n+        }\n+    }\n+\n     pub fn ptr_to(&self) -> Type {\n         ty!(llvm::LLVMPointerType(self.to_ref(), 0))\n     }"}, {"sha": "6cd8b72cb5ce1e80b9a2ff55a483af9aa13f5384", "filename": "src/librustc_unicode/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibrustc_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibrustc_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Flib.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -33,6 +33,7 @@\n        test(no_crate_inject))]\n #![no_std]\n \n+#![feature(char_from_unchecked)]\n #![feature(core_char_ext)]\n #![feature(core_slice_ext)]\n #![feature(core_str_ext)]"}, {"sha": "d5219ab28fed61ee6bf7e396af914db63b43bf3c", "filename": "src/librustc_unicode/normalize.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibrustc_unicode%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibrustc_unicode%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fnormalize.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -126,39 +126,37 @@ const S_COUNT: u32 = (L_COUNT * N_COUNT);\n // Decompose a precomposed Hangul syllable\n #[inline(always)]\n fn decompose_hangul<F>(s: char, f: &mut F) where F: FnMut(char) {\n-    use core::mem::transmute;\n-\n+    use core::char::from_u32_unchecked;\n     let si = s as u32 - S_BASE;\n-\n     let li = si / N_COUNT;\n     unsafe {\n-        (*f)(transmute(L_BASE + li));\n+        (*f)(from_u32_unchecked(L_BASE + li));\n \n         let vi = (si % N_COUNT) / T_COUNT;\n-        (*f)(transmute(V_BASE + vi));\n+        (*f)(from_u32_unchecked(V_BASE + vi));\n \n         let ti = si % T_COUNT;\n         if ti > 0 {\n-            (*f)(transmute(T_BASE + ti));\n+            (*f)(from_u32_unchecked(T_BASE + ti));\n         }\n     }\n }\n \n // Compose a pair of Hangul Jamo\n #[inline(always)]\n fn compose_hangul(a: char, b: char) -> Option<char> {\n-    use core::mem::transmute;\n+    use core::char::from_u32_unchecked;\n     let l = a as u32;\n     let v = b as u32;\n     // Compose an LPart and a VPart\n     if L_BASE <= l && l < (L_BASE + L_COUNT) && V_BASE <= v && v < (V_BASE + V_COUNT) {\n         let r = S_BASE + (l - L_BASE) * N_COUNT + (v - V_BASE) * T_COUNT;\n-        return unsafe { Some(transmute(r)) };\n+        return unsafe { Some(from_u32_unchecked(r)) };\n     }\n     // Compose an LVPart and a TPart\n     if S_BASE <= l && l <= (S_BASE+S_COUNT-T_COUNT) && T_BASE <= v && v < (T_BASE+T_COUNT) {\n         let r = l + (v - T_BASE);\n-        return unsafe { Some(transmute(r)) };\n+        return unsafe { Some(from_u32_unchecked(r)) };\n     }\n     None\n }"}, {"sha": "37443cfa70ce1fd6ece7cf83492d422c0657c3c1", "filename": "src/librustc_unicode/u_str.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibrustc_unicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibrustc_unicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fu_str.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -20,7 +20,6 @@ use core::prelude::v1::*;\n use core::char;\n use core::cmp;\n use core::iter::Filter;\n-use core::mem;\n use core::slice;\n use core::str::Split;\n \n@@ -454,7 +453,7 @@ impl<'a> Iterator for Utf16Items<'a> {\n \n         if u < 0xD800 || 0xDFFF < u {\n             // not a surrogate\n-            Some(Utf16Item::ScalarValue(unsafe {mem::transmute(u as u32)}))\n+            Some(Utf16Item::ScalarValue(unsafe { char::from_u32_unchecked(u as u32) }))\n         } else if u >= 0xDC00 {\n             // a trailing surrogate\n             Some(Utf16Item::LoneSurrogate(u))\n@@ -476,7 +475,7 @@ impl<'a> Iterator for Utf16Items<'a> {\n \n             // all ok, so lets decode it.\n             let c = (((u - 0xD800) as u32) << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n-            Some(Utf16Item::ScalarValue(unsafe {mem::transmute(c)}))\n+            Some(Utf16Item::ScalarValue(unsafe { char::from_u32_unchecked(c) }))\n         }\n     }\n "}, {"sha": "f003948be7bfe335035d151c51b2958b3271dabd", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -15,7 +15,6 @@\n use prelude::v1::*;\n \n use ops::Range;\n-use mem;\n \n /// Extension methods for ASCII-subset only operations on owned strings\n #[unstable(feature = \"owned_ascii_ext\",\n@@ -186,12 +185,12 @@ impl AsciiExt for str {\n     }\n \n     fn make_ascii_uppercase(&mut self) {\n-        let me: &mut [u8] = unsafe { mem::transmute(self) };\n+        let me: &mut [u8] = unsafe { self.as_bytes_mut() };\n         me.make_ascii_uppercase()\n     }\n \n     fn make_ascii_lowercase(&mut self) {\n-        let me: &mut [u8] = unsafe { mem::transmute(self) };\n+        let me: &mut [u8] = unsafe { self.as_bytes_mut() };\n         me.make_ascii_lowercase()\n     }\n }"}, {"sha": "f0f481d3721aec6d3ccfa8d04c82cc3cb5448e91", "filename": "src/libstd/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -192,7 +192,7 @@ impl Error + 'static {\n                 let to: TraitObject = transmute(self);\n \n                 // Extract the data pointer\n-                Some(transmute(to.data))\n+                Some(&*(to.data as *const T))\n             }\n         } else {\n             None\n@@ -210,7 +210,7 @@ impl Error + 'static {\n                 let to: TraitObject = transmute(self);\n \n                 // Extract the data pointer\n-                Some(transmute(to.data))\n+                Some(&mut *(to.data as *const T as *mut T))\n             }\n         } else {\n             None"}, {"sha": "adbda6ae242e45757197922e175082b9f4d81175", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -395,7 +395,7 @@ impl CStr {\n     /// > length calculation whenever this method is called.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_bytes_with_nul(&self) -> &[u8] {\n-        unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.inner) }\n+        unsafe { slice::transmute(&self.inner) }\n     }\n \n     /// Yields a `&str` slice if the `CStr` contains valid UTF-8."}, {"sha": "83d76481d49561b496dd01c83053ec8ae93ab6ec", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -134,7 +134,7 @@ impl ops::Index<ops::RangeFull> for OsString {\n \n     #[inline]\n     fn index(&self, _index: ops::RangeFull) -> &OsStr {\n-        unsafe { mem::transmute(self.inner.as_slice()) }\n+        OsStr::from_inner(self.inner.as_slice())\n     }\n }\n \n@@ -226,6 +226,10 @@ impl OsStr {\n         s.as_ref()\n     }\n \n+    fn from_inner(inner: &Slice) -> &OsStr {\n+        unsafe { mem::transmute(inner) }\n+    }\n+\n     /// Yields a `&str` slice if the `OsStr` is valid unicode.\n     ///\n     /// This conversion may entail doing a check for UTF-8 validity.\n@@ -387,14 +391,14 @@ impl AsRef<OsStr> for OsString {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for str {\n     fn as_ref(&self) -> &OsStr {\n-        unsafe { mem::transmute(Slice::from_str(self)) }\n+        OsStr::from_inner(Slice::from_str(self))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for String {\n     fn as_ref(&self) -> &OsStr {\n-        unsafe { mem::transmute(Slice::from_str(self)) }\n+        (&**self).as_ref()\n     }\n }\n "}, {"sha": "65f195be4e8e7700996ce47680d357406649d717", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -234,7 +234,9 @@\n #![feature(reflect_marker)]\n #![feature(slice_bytes)]\n #![feature(slice_patterns)]\n+#![feature(slice_transmute)]\n #![feature(staged_api)]\n+#![feature(str_as_bytes_mut)]\n #![feature(str_char)]\n #![feature(str_internals)]\n #![feature(unboxed_closures)]"}, {"sha": "c3a887cbcb8618e7d23cc107abd746ad3dbfff8b", "filename": "src/libstd/path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -942,7 +942,7 @@ pub struct PathBuf {\n \n impl PathBuf {\n     fn as_mut_vec(&mut self) -> &mut Vec<u8> {\n-        unsafe { mem::transmute(self) }\n+        unsafe { &mut *(self as *mut PathBuf as *mut Vec<u8>) }\n     }\n \n     /// Allocates an empty `PathBuf`.\n@@ -1126,7 +1126,7 @@ impl ops::Deref for PathBuf {\n     type Target = Path;\n \n     fn deref(&self) -> &Path {\n-        unsafe { mem::transmute(&self.inner[..]) }\n+        Path::new(&self.inner)\n     }\n }\n \n@@ -1227,11 +1227,11 @@ impl Path {\n     // The following (private!) function allows construction of a path from a u8\n     // slice, which is only safe when it is known to follow the OsStr encoding.\n     unsafe fn from_u8_slice(s: &[u8]) -> &Path {\n-        mem::transmute(s)\n+        Path::new(u8_slice_as_os_str(s))\n     }\n     // The following (private!) function reveals the byte encoding used for OsStr.\n     fn as_u8_slice(&self) -> &[u8] {\n-        unsafe { mem::transmute(self) }\n+        os_str_as_u8_slice(&self.inner)\n     }\n \n     /// Directly wrap a string slice as a `Path` slice."}, {"sha": "8ac2722f65a23670c41ed467fa820d1b3b973398", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -73,8 +73,8 @@ mod tests {\n     fn test_reader_rng_u64() {\n         // transmute from the target to avoid endianness concerns.\n         let v = &[0, 0, 0, 0, 0, 0, 0, 1,\n-                  0  , 0, 0, 0, 0, 0, 0, 2,\n-                  0,   0, 0, 0, 0, 0, 0, 3][..];\n+                  0, 0, 0, 0, 0, 0, 0, 2,\n+                  0, 0, 0, 0, 0, 0, 0, 3][..];\n         let mut rng = ReaderRng::new(v);\n \n         assert_eq!(rng.next_u64(), 1u64.to_be());"}, {"sha": "c46e61cf414400acf9aa25780e7ae4cece03dadc", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -62,7 +62,6 @@ use core::prelude::v1::*;\n \n use core::cell::{Cell, UnsafeCell};\n use core::marker;\n-use core::mem;\n use core::ptr;\n use core::usize;\n \n@@ -281,7 +280,7 @@ impl<'rx, T: Send> Handle<'rx, T> {\n     pub unsafe fn add(&mut self) {\n         if self.added { return }\n         let selector = &mut *self.selector;\n-        let me: *mut Handle<'static, ()> = mem::transmute(&*self);\n+        let me = self as *mut Handle<'rx, T> as *mut Handle<'static, ()>;\n \n         if selector.head.is_null() {\n             selector.head = me;\n@@ -302,7 +301,7 @@ impl<'rx, T: Send> Handle<'rx, T> {\n         if !self.added { return }\n \n         let selector = &mut *self.selector;\n-        let me: *mut Handle<'static, ()> = mem::transmute(&*self);\n+        let me = self as *mut Handle<'rx, T> as *mut Handle<'static, ()>;\n \n         if self.prev.is_null() {\n             assert_eq!(selector.head, me);"}, {"sha": "4128431ee64c089201a3abd8be66ae09937f2178", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -90,7 +90,6 @@ use io::prelude::*;\n use ffi::CStr;\n use io;\n use libc;\n-use mem;\n use str;\n use sync::StaticMutex;\n \n@@ -168,7 +167,7 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n \n     extern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n                        arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {\n-        let cx: &mut Context = unsafe { mem::transmute(arg) };\n+        let cx: &mut Context = unsafe { &mut *(arg as *mut Context) };\n         let mut ip_before_insn = 0;\n         let mut ip = unsafe {\n             uw::_Unwind_GetIPInfo(ctx, &mut ip_before_insn) as *mut libc::c_void"}, {"sha": "bce8adaf70fc7a25b9d457a4a01cd579df59a48a", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ec5f4af7b5a85ad375d672ed727571b49f3cad/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=22ec5f4af7b5a85ad375d672ed727571b49f3cad", "patch": "@@ -27,6 +27,7 @@\n \n #![feature(associated_consts)]\n #![feature(bitset)]\n+#![feature(copy_lifetime)]\n #![feature(drain)]\n #![feature(filling_drop)]\n #![feature(libc)]"}]}