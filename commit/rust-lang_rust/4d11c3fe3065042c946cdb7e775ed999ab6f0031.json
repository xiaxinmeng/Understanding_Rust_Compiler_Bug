{"sha": "4d11c3fe3065042c946cdb7e775ed999ab6f0031", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkMTFjM2ZlMzA2NTA0MmM5NDZjZGI3ZTc3NWVkOTk5YWI2ZjAwMzE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-19T13:12:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-19T13:12:36Z"}, "message": "Rollup merge of #71107 - vorner:weak-into-raw-dangling, r=Amanieu\n\nAddress concerns of weak-into-raw\n\nThis should address the standing concerns in https://github.com/rust-lang/rust/issues/60728#issuecomment-612525616.\n\nI've still left the ability to create a new dangling pointer from `null`, as I feel like this is the natural behaviour to expect, but I'm fine removing that too. I've modified the documentation to allow the `as_ptr` or `into_ptr` to return whatever garbage in case of a dangling pointer. I've also removed the guarantee to be able to do `from_raw(as_ptr)` from the documentation (but it would still work right now).\n\nI've renamed the method and added implementations for `Rc`/`Arc`.\n\nI've also tried if I can just \u201eenable\u201c unsized types. I believe the current interface is compatible with them. But the inner implementation will be a bit challenging \u2012 I can't use the `data_offset` as is used by `Rc` or `Arc` because it AFAIK \u201etouches\u201c (creates a reference to) the live value of `T` \u2012 and in case of `Weak`, it might be completely bogus or already dead \u2012 so that would be UB.\n\n`./x.py test tidy` is completely mad on my own system all over the code base :-(. I'll just hope it goes through CI, or will fix as necessary.\n\nIs it OK if I ask @Amanieu for review, as the concerns are from you?\n\n~r @Amanieu", "tree": {"sha": "d7d184d531cdb0635a320a6e547893d7860fd588", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7d184d531cdb0635a320a6e547893d7860fd588"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d11c3fe3065042c946cdb7e775ed999ab6f0031", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJenE5ECRBK7hj4Ov3rIwAAdHIIABifAbMZy6xzOWoOYeeG90Gr\nNKlpRJPUfsOmMqEefT9re4b5+P3U1rMTOl0mGki0wD09B8gewT03INfjSw7Z5HRH\ncmICrEntgQ2XoMWzihLuSkOa9TkqncTi5xGh+hl/pIcAt56tkU4pTDzWZe3IT8DS\n27QIN1UnXkR2QFZ9ri9zkVrSTijhudxbOQ/pw3ndUXDJfKFS84N3aJhG5KJob5sO\nnRhtP6QKAALtAVjkZ6R3ZroxYQZm4bOADiQFsJrDddWQ/p65imi/yuOr5+ezOO3/\nic4oDwRUvlPUC2QPwfghxb5Wx1JGHCeAHZ7cl7RRT2mY8BxTc699RvvfxDefUGQ=\n=GO/q\n-----END PGP SIGNATURE-----\n", "payload": "tree d7d184d531cdb0635a320a6e547893d7860fd588\nparent 36b1a9296cde2b773771710e9bbd608fd2eca35f\nparent f4ded11b49aa24dcd8c0e114b427757b5d08dbe7\nauthor Dylan DPC <dylan.dpc@gmail.com> 1587301956 +0200\ncommitter GitHub <noreply@github.com> 1587301956 +0200\n\nRollup merge of #71107 - vorner:weak-into-raw-dangling, r=Amanieu\n\nAddress concerns of weak-into-raw\n\nThis should address the standing concerns in https://github.com/rust-lang/rust/issues/60728#issuecomment-612525616.\n\nI've still left the ability to create a new dangling pointer from `null`, as I feel like this is the natural behaviour to expect, but I'm fine removing that too. I've modified the documentation to allow the `as_ptr` or `into_ptr` to return whatever garbage in case of a dangling pointer. I've also removed the guarantee to be able to do `from_raw(as_ptr)` from the documentation (but it would still work right now).\n\nI've renamed the method and added implementations for `Rc`/`Arc`.\n\nI've also tried if I can just \u201eenable\u201c unsized types. I believe the current interface is compatible with them. But the inner implementation will be a bit challenging \u2012 I can't use the `data_offset` as is used by `Rc` or `Arc` because it AFAIK \u201etouches\u201c (creates a reference to) the live value of `T` \u2012 and in case of `Weak`, it might be completely bogus or already dead \u2012 so that would be UB.\n\n`./x.py test tidy` is completely mad on my own system all over the code base :-(. I'll just hope it goes through CI, or will fix as necessary.\n\nIs it OK if I ask @Amanieu for review, as the concerns are from you?\n\n~r @Amanieu\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d11c3fe3065042c946cdb7e775ed999ab6f0031", "html_url": "https://github.com/rust-lang/rust/commit/4d11c3fe3065042c946cdb7e775ed999ab6f0031", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d11c3fe3065042c946cdb7e775ed999ab6f0031/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36b1a9296cde2b773771710e9bbd608fd2eca35f", "url": "https://api.github.com/repos/rust-lang/rust/commits/36b1a9296cde2b773771710e9bbd608fd2eca35f", "html_url": "https://github.com/rust-lang/rust/commit/36b1a9296cde2b773771710e9bbd608fd2eca35f"}, {"sha": "f4ded11b49aa24dcd8c0e114b427757b5d08dbe7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4ded11b49aa24dcd8c0e114b427757b5d08dbe7", "html_url": "https://github.com/rust-lang/rust/commit/f4ded11b49aa24dcd8c0e114b427757b5d08dbe7"}], "stats": {"total": 134, "additions": 80, "deletions": 54}, "files": [{"sha": "e106b4354e4e942e731192ec822834a12bb299f7", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4d11c3fe3065042c946cdb7e775ed999ab6f0031/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d11c3fe3065042c946cdb7e775ed999ab6f0031/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=4d11c3fe3065042c946cdb7e775ed999ab6f0031", "patch": "@@ -569,9 +569,33 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n+        let ptr = Self::as_ptr(&this);\n+        mem::forget(this);\n+        ptr\n+    }\n+\n+    /// Provides a raw pointer to the data.\n+    ///\n+    /// The counts are not affected in any way and the `Rc` is not consumed. The pointer is valid\n+    /// for as long there are strong counts in the `Rc`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let x = Rc::new(\"hello\".to_owned());\n+    /// let y = Rc::clone(&x);\n+    /// let x_ptr = Rc::as_ptr(&x);\n+    /// assert_eq!(x_ptr, Rc::as_ptr(&y));\n+    /// assert_eq!(unsafe { &*x_ptr }, \"hello\");\n+    /// ```\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn as_ptr(this: &Self) -> *const T {\n         let ptr: *mut RcBox<T> = NonNull::as_ptr(this.ptr);\n         let fake_ptr = ptr as *mut T;\n-        mem::forget(this);\n \n         // SAFETY: This cannot go through Deref::deref.\n         // Instead, we manually offset the pointer rather than manifesting a reference.\n@@ -1644,8 +1668,8 @@ impl<T> Weak<T> {\n \n     /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n     ///\n-    /// The pointer is valid only if there are some strong references. The pointer may be dangling\n-    /// or even [`null`] otherwise.\n+    /// The pointer is valid only if there are some strong references. The pointer may be dangling,\n+    /// unaligned or even [`null`] otherwise.\n     ///\n     /// # Examples\n     ///\n@@ -1658,31 +1682,22 @@ impl<T> Weak<T> {\n     /// let strong = Rc::new(\"hello\".to_owned());\n     /// let weak = Rc::downgrade(&strong);\n     /// // Both point to the same object\n-    /// assert!(ptr::eq(&*strong, weak.as_raw()));\n+    /// assert!(ptr::eq(&*strong, weak.as_ptr()));\n     /// // The strong here keeps it alive, so we can still access the object.\n-    /// assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     ///\n     /// drop(strong);\n-    /// // But not any more. We can do weak.as_raw(), but accessing the pointer would lead to\n+    /// // But not any more. We can do weak.as_ptr(), but accessing the pointer would lead to\n     /// // undefined behaviour.\n-    /// // assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// // assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n-    pub fn as_raw(&self) -> *const T {\n-        match self.inner() {\n-            None => ptr::null(),\n-            Some(inner) => {\n-                let offset = data_offset_sized::<T>();\n-                let ptr = inner as *const RcBox<T>;\n-                // Note: while the pointer we create may already point to dropped value, the\n-                // allocation still lives (it must hold the weak point as long as we are alive).\n-                // Therefore, the offset is OK to do, it won't get out of the allocation.\n-                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n-                ptr as *const T\n-            }\n-        }\n+    pub fn as_ptr(&self) -> *const T {\n+        let offset = data_offset_sized::<T>();\n+        let ptr = self.ptr.cast::<u8>().as_ptr().wrapping_offset(offset);\n+        ptr as *const T\n     }\n \n     /// Consumes the `Weak<T>` and turns it into a raw pointer.\n@@ -1691,7 +1706,7 @@ impl<T> Weak<T> {\n     /// can be turned back into the `Weak<T>` with [`from_raw`].\n     ///\n     /// The same restrictions of accessing the target of the pointer as with\n-    /// [`as_raw`] apply.\n+    /// [`as_ptr`] apply.\n     ///\n     /// # Examples\n     ///\n@@ -1712,10 +1727,10 @@ impl<T> Weak<T> {\n     /// ```\n     ///\n     /// [`from_raw`]: struct.Weak.html#method.from_raw\n-    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    /// [`as_ptr`]: struct.Weak.html#method.as_ptr\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n     pub fn into_raw(self) -> *const T {\n-        let result = self.as_raw();\n+        let result = self.as_ptr();\n         mem::forget(self);\n         result\n     }\n@@ -1730,9 +1745,8 @@ impl<T> Weak<T> {\n     ///\n     /// # Safety\n     ///\n-    /// The pointer must have originated from the [`into_raw`] (or [`as_raw`], provided there was\n-    /// a corresponding [`forget`] on the `Weak<T>`) and must still own its potential weak reference\n-    /// count.\n+    /// The pointer must have originated from the [`into_raw`]  and must still own its potential\n+    /// weak reference count.\n     ///\n     /// It is allowed for the strong count to be 0 at the time of calling this, but the weak count\n     /// must be non-zero or the pointer must have originated from a dangling `Weak<T>` (one created\n@@ -1765,7 +1779,6 @@ impl<T> Weak<T> {\n     /// [`upgrade`]: struct.Weak.html#method.upgrade\n     /// [`Rc`]: struct.Rc.html\n     /// [`Weak`]: struct.Weak.html\n-    /// [`as_raw`]: struct.Weak.html#method.as_raw\n     /// [`new`]: struct.Weak.html#method.new\n     /// [`forget`]: ../../std/mem/fn.forget.html\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]"}, {"sha": "54df2b60857803541ab7dbb15e13904bcf1a1b76", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4d11c3fe3065042c946cdb7e775ed999ab6f0031/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d11c3fe3065042c946cdb7e775ed999ab6f0031/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=4d11c3fe3065042c946cdb7e775ed999ab6f0031", "patch": "@@ -566,9 +566,33 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n+        let ptr = Self::as_ptr(&this);\n+        mem::forget(this);\n+        ptr\n+    }\n+\n+    /// Provides a raw pointer to the data.\n+    ///\n+    /// The counts are not affected in way and the `Arc` is not consumed. The pointer is valid for\n+    /// as long as there are strong counts in the `Arc`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(\"hello\".to_owned());\n+    /// let y = Arc::clone(&x);\n+    /// let x_ptr = Arc::as_ptr(&x);\n+    /// assert_eq!(x_ptr, Arc::as_ptr(&y));\n+    /// assert_eq!(unsafe { &*x_ptr }, \"hello\");\n+    /// ```\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn as_ptr(this: &Self) -> *const T {\n         let ptr: *mut ArcInner<T> = NonNull::as_ptr(this.ptr);\n         let fake_ptr = ptr as *mut T;\n-        mem::forget(this);\n \n         // SAFETY: This cannot go through Deref::deref.\n         // Instead, we manually offset the pointer rather than manifesting a reference.\n@@ -1340,8 +1364,8 @@ impl<T> Weak<T> {\n \n     /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n     ///\n-    /// The pointer is valid only if there are some strong references. The pointer may be dangling\n-    /// or even [`null`] otherwise.\n+    /// The pointer is valid only if there are some strong references. The pointer may be dangling,\n+    /// unaligned or even [`null`] otherwise.\n     ///\n     /// # Examples\n     ///\n@@ -1354,31 +1378,22 @@ impl<T> Weak<T> {\n     /// let strong = Arc::new(\"hello\".to_owned());\n     /// let weak = Arc::downgrade(&strong);\n     /// // Both point to the same object\n-    /// assert!(ptr::eq(&*strong, weak.as_raw()));\n+    /// assert!(ptr::eq(&*strong, weak.as_ptr()));\n     /// // The strong here keeps it alive, so we can still access the object.\n-    /// assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     ///\n     /// drop(strong);\n-    /// // But not any more. We can do weak.as_raw(), but accessing the pointer would lead to\n+    /// // But not any more. We can do weak.as_ptr(), but accessing the pointer would lead to\n     /// // undefined behaviour.\n-    /// // assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// // assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n-    pub fn as_raw(&self) -> *const T {\n-        match self.inner() {\n-            None => ptr::null(),\n-            Some(inner) => {\n-                let offset = data_offset_sized::<T>();\n-                let ptr = inner as *const ArcInner<T>;\n-                // Note: while the pointer we create may already point to dropped value, the\n-                // allocation still lives (it must hold the weak point as long as we are alive).\n-                // Therefore, the offset is OK to do, it won't get out of the allocation.\n-                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n-                ptr as *const T\n-            }\n-        }\n+    pub fn as_ptr(&self) -> *const T {\n+        let offset = data_offset_sized::<T>();\n+        let ptr = self.ptr.cast::<u8>().as_ptr().wrapping_offset(offset);\n+        ptr as *const T\n     }\n \n     /// Consumes the `Weak<T>` and turns it into a raw pointer.\n@@ -1387,7 +1402,7 @@ impl<T> Weak<T> {\n     /// can be turned back into the `Weak<T>` with [`from_raw`].\n     ///\n     /// The same restrictions of accessing the target of the pointer as with\n-    /// [`as_raw`] apply.\n+    /// [`as_ptr`] apply.\n     ///\n     /// # Examples\n     ///\n@@ -1408,10 +1423,10 @@ impl<T> Weak<T> {\n     /// ```\n     ///\n     /// [`from_raw`]: struct.Weak.html#method.from_raw\n-    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    /// [`as_ptr`]: struct.Weak.html#method.as_ptr\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n     pub fn into_raw(self) -> *const T {\n-        let result = self.as_raw();\n+        let result = self.as_ptr();\n         mem::forget(self);\n         result\n     }\n@@ -1427,9 +1442,8 @@ impl<T> Weak<T> {\n     ///\n     /// # Safety\n     ///\n-    /// The pointer must have originated from the [`into_raw`] (or [`as_raw'], provided there was\n-    /// a corresponding [`forget`] on the `Weak<T>`) and must still own its potential weak reference\n-    /// count.\n+    /// The pointer must have originated from the [`into_raw`] and must still own its potential\n+    /// weak reference count.\n     ///\n     /// It is allowed for the strong count to be 0 at the time of calling this, but the weak count\n     /// must be non-zero or the pointer must have originated from a dangling `Weak<T>` (one created\n@@ -1458,7 +1472,6 @@ impl<T> Weak<T> {\n     /// assert!(unsafe { Weak::from_raw(raw_2) }.upgrade().is_none());\n     /// ```\n     ///\n-    /// [`as_raw`]: struct.Weak.html#method.as_raw\n     /// [`new`]: struct.Weak.html#method.new\n     /// [`into_raw`]: struct.Weak.html#method.into_raw\n     /// [`upgrade`]: struct.Weak.html#method.upgrade"}]}