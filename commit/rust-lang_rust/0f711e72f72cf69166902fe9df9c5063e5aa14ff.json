{"sha": "0f711e72f72cf69166902fe9df9c5063e5aa14ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNzExZTcyZjcyY2Y2OTE2NjkwMmZlOWRmOWM1MDYzZTVhYTE0ZmY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-07T23:08:09Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-07T23:09:08Z"}, "message": "libsyntax: Break struct definitions out of classes internally in a few more places", "tree": {"sha": "6025c53bc18b4c615caf042dbc2d9fe68b7f1c03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6025c53bc18b4c615caf042dbc2d9fe68b7f1c03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f711e72f72cf69166902fe9df9c5063e5aa14ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f711e72f72cf69166902fe9df9c5063e5aa14ff", "html_url": "https://github.com/rust-lang/rust/commit/0f711e72f72cf69166902fe9df9c5063e5aa14ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f711e72f72cf69166902fe9df9c5063e5aa14ff/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f0574e8f0d304afa6931f4fa1019c80a708b94d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f0574e8f0d304afa6931f4fa1019c80a708b94d", "html_url": "https://github.com/rust-lang/rust/commit/1f0574e8f0d304afa6931f4fa1019c80a708b94d"}], "stats": {"total": 177, "additions": 94, "deletions": 83}, "files": [{"sha": "5c270c968f34a38a097bcb6f00781c4a5d0d3697", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0f711e72f72cf69166902fe9df9c5063e5aa14ff/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f711e72f72cf69166902fe9df9c5063e5aa14ff/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=0f711e72f72cf69166902fe9df9c5063e5aa14ff", "patch": "@@ -217,19 +217,8 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n         }\n       }\n       item_class(struct_def, _) => {\n-          let (_, ms) = ast_util::split_class_items(struct_def.members);\n-          // Map trait refs to their parent classes. This is\n-          // so we can find the self_ty\n-          for struct_def.traits.each |p| {\n-              cx.map.insert(p.ref_id, node_item(i, item_path));\n-              // This is so we can look up the right things when\n-              // encoding/decoding\n-              cx.map.insert(p.impl_id, node_item(i, item_path));\n-          }\n-          let d_id = ast_util::local_def(i.id);\n-          let p = extend(cx, i.ident);\n-           // only need to handle methods\n-          do vec::iter(ms) |m| { map_method(d_id, p, m, cx); }\n+        map_struct_def(struct_def, node_item(i, item_path), i.ident, i.id, cx,\n+                       v);\n       }\n       item_trait(tps, traits, methods) => {\n         // Map trait refs to their parent classes. This is\n@@ -258,6 +247,23 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n     vec::pop(cx.path);\n }\n \n+fn map_struct_def(struct_def: ast::struct_def, parent_node: ast_node,\n+                  ident: ast::ident, id: ast::node_id, cx: ctx, _v: vt) {\n+    let (_, ms) = ast_util::split_class_items(struct_def.members);\n+    // Map trait refs to their parent classes. This is\n+    // so we can find the self_ty\n+    for struct_def.traits.each |p| {\n+        cx.map.insert(p.ref_id, parent_node);\n+        // This is so we can look up the right things when\n+        // encoding/decoding\n+        cx.map.insert(p.impl_id, parent_node);\n+    }\n+    let d_id = ast_util::local_def(id);\n+    let p = extend(cx, ident);\n+     // only need to handle methods\n+    do vec::iter(ms) |m| { map_method(d_id, p, m, cx); }\n+}\n+\n fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {\n     match vi.node {\n       view_item_export(vps) => for vps.each |vp| {"}, {"sha": "db62637a67370bf56c545487c5f158a567bc2057", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 75, "deletions": 70, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/0f711e72f72cf69166902fe9df9c5063e5aa14ff/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f711e72f72cf69166902fe9df9c5063e5aa14ff/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0f711e72f72cf69166902fe9df9c5063e5aa14ff", "patch": "@@ -532,76 +532,8 @@ fn print_item(s: ps, &&item: @ast::item) {\n       }\n       ast::item_class(struct_def, tps) => {\n           head(s, ~\"class\");\n-          word_nbsp(s, *item.ident);\n-          print_type_params(s, tps);\n-          if vec::len(struct_def.traits) != 0u {\n-              word_space(s, ~\":\");\n-              commasep(s, inconsistent, struct_def.traits, |s, p|\n-                  print_path(s, p.path, false));\n-          }\n-          bopen(s);\n-          hardbreak_if_not_bol(s);\n-          do option::iter(struct_def.ctor) |ctor| {\n-            maybe_print_comment(s, ctor.span.lo);\n-            print_outer_attributes(s, ctor.node.attrs);\n-            // Doesn't call head because there shouldn't be a space after new.\n-            cbox(s, indent_unit);\n-            ibox(s, 4);\n-            word(s.s, ~\"new(\");\n-            print_fn_args(s, ctor.node.dec, ~[]);\n-            word(s.s, ~\")\");\n-            space(s.s);\n-            print_block(s, ctor.node.body);\n-          }\n-          do option::iter(struct_def.dtor) |dtor| {\n-            hardbreak_if_not_bol(s);\n-            maybe_print_comment(s, dtor.span.lo);\n-            print_outer_attributes(s, dtor.node.attrs);\n-            head(s, ~\"drop\");\n-            print_block(s, dtor.node.body);\n-          }\n-          for struct_def.members.each |ci| {\n-                  /*\n-                     FIXME (#1893): collect all private items and print\n-                     them in a single \"priv\" section\n-\n-                     tjc: I'm not going to fix this yet b/c we might\n-                     change how exports work, including for class items\n-                   */\n-             hardbreak_if_not_bol(s);\n-             maybe_print_comment(s, ci.span.lo);\n-             let pr = ast_util::class_member_visibility(ci);\n-             match pr {\n-                ast::private => {\n-                    head(s, ~\"priv\");\n-                    bopen(s);\n-                    hardbreak_if_not_bol(s);\n-                }\n-                _ => ()\n-             }\n-             match ci.node {\n-                ast::instance_var(nm, t, mt, _,_) => {\n-                    word_nbsp(s, ~\"let\");\n-                    match mt {\n-                      ast::class_mutable => word_nbsp(s, ~\"mut\"),\n-                      _ => ()\n-                    }\n-                    word(s.s, *nm);\n-                    word_nbsp(s, ~\":\");\n-                    print_type(s, t);\n-                    word(s.s, ~\";\");\n-                }\n-                ast::class_method(m) => {\n-                    print_method(s, m);\n-                }\n-             }\n-             match pr {\n-                 ast::private => bclose(s, ci.span),\n-                 _ => ()\n-             }\n-          }\n-          bclose(s, item.span);\n-       }\n+          print_struct(s, struct_def, tps, item.ident, item.span);\n+      }\n       ast::item_impl(tps, traits, ty, methods) => {\n         head(s, ~\"impl\");\n         word(s.s, *item.ident);\n@@ -650,6 +582,79 @@ fn print_item(s: ps, &&item: @ast::item) {\n     s.ann.post(ann_node);\n }\n \n+fn print_struct(s: ps, struct_def: ast::struct_def, tps: ~[ast::ty_param],\n+                ident: ast::ident, span: ast::span) {\n+    word_nbsp(s, *ident);\n+    print_type_params(s, tps);\n+    if vec::len(struct_def.traits) != 0u {\n+        word_space(s, ~\":\");\n+        commasep(s, inconsistent, struct_def.traits, |s, p|\n+            print_path(s, p.path, false));\n+    }\n+    bopen(s);\n+    hardbreak_if_not_bol(s);\n+    do option::iter(struct_def.ctor) |ctor| {\n+      maybe_print_comment(s, ctor.span.lo);\n+      print_outer_attributes(s, ctor.node.attrs);\n+      // Doesn't call head because there shouldn't be a space after new.\n+      cbox(s, indent_unit);\n+      ibox(s, 4);\n+      word(s.s, ~\"new(\");\n+      print_fn_args(s, ctor.node.dec, ~[]);\n+      word(s.s, ~\")\");\n+      space(s.s);\n+      print_block(s, ctor.node.body);\n+    }\n+    do option::iter(struct_def.dtor) |dtor| {\n+      hardbreak_if_not_bol(s);\n+      maybe_print_comment(s, dtor.span.lo);\n+      print_outer_attributes(s, dtor.node.attrs);\n+      head(s, ~\"drop\");\n+      print_block(s, dtor.node.body);\n+    }\n+    for struct_def.members.each |ci| {\n+            /*\n+               FIXME (#1893): collect all private items and print\n+               them in a single \"priv\" section\n+\n+               tjc: I'm not going to fix this yet b/c we might\n+               change how exports work, including for class items\n+             */\n+       hardbreak_if_not_bol(s);\n+       maybe_print_comment(s, ci.span.lo);\n+       let pr = ast_util::class_member_visibility(ci);\n+       match pr {\n+          ast::private => {\n+              head(s, ~\"priv\");\n+              bopen(s);\n+              hardbreak_if_not_bol(s);\n+          }\n+          _ => ()\n+       }\n+       match ci.node {\n+          ast::instance_var(nm, t, mt, _,_) => {\n+              word_nbsp(s, ~\"let\");\n+              match mt {\n+                ast::class_mutable => word_nbsp(s, ~\"mut\"),\n+                _ => ()\n+              }\n+              word(s.s, *nm);\n+              word_nbsp(s, ~\":\");\n+              print_type(s, t);\n+              word(s.s, ~\";\");\n+          }\n+          ast::class_method(m) => {\n+              print_method(s, m);\n+          }\n+       }\n+       match pr {\n+           ast::private => bclose(s, ci.span),\n+           _ => ()\n+       }\n+    }\n+    bclose(s, span);\n+}\n+\n /// This doesn't deserve to be called \"pretty\" printing, but it should be\n /// meaning-preserving. A quick hack that might help would be to look at the\n /// spans embedded in the TTs to decide where to put spaces and newlines."}]}