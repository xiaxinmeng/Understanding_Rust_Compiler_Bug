{"sha": "8f2a2e2dd8320215f834376c9a8a237e285df64e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMmEyZTJkZDgzMjAyMTVmODM0Mzc2YzlhOGEyMzdlMjg1ZGY2NGU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-05-19T04:47:51Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-05-20T17:38:21Z"}, "message": "core: Improve docs for cell", "tree": {"sha": "b57516975f4df3d225a3f5fbb602f4ce448b4fbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b57516975f4df3d225a3f5fbb602f4ce448b4fbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f2a2e2dd8320215f834376c9a8a237e285df64e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f2a2e2dd8320215f834376c9a8a237e285df64e", "html_url": "https://github.com/rust-lang/rust/commit/8f2a2e2dd8320215f834376c9a8a237e285df64e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f2a2e2dd8320215f834376c9a8a237e285df64e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "629195582b39a4956cd62439911f0094cf3878c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/629195582b39a4956cd62439911f0094cf3878c6", "html_url": "https://github.com/rust-lang/rust/commit/629195582b39a4956cd62439911f0094cf3878c6"}], "stats": {"total": 152, "additions": 151, "deletions": 1}, "files": [{"sha": "c5af72f9ccf6bb71c98a86273078960b96a2d173", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 151, "deletions": 1, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/8f2a2e2dd8320215f834376c9a8a237e285df64e/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f2a2e2dd8320215f834376c9a8a237e285df64e/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=8f2a2e2dd8320215f834376c9a8a237e285df64e", "patch": "@@ -8,7 +8,157 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Types that provide interior mutability.\n+//! Sharable mutable containers.\n+//!\n+//! Values of the `Cell` and `RefCell` types may be mutated through\n+//! shared references (i.e. the common `&T` type), whereas most Rust\n+//! types can only be mutated through unique (`&mut T`) references. We\n+//! say that `Cell` and `RefCell` provide *interior mutability*, in\n+//! contrast with typical Rust types that exhibit *inherited\n+//! mutability*.\n+//!\n+//! Cell types come in two flavors: `Cell` and `RefCell`. `Cell`\n+//! provides `get` and `set` methods that change the\n+//! interior value with a single method call. `Cell` though is only\n+//! compatible with types that implement `Copy`. For other types,\n+//! one must use the `RefCell` type, acquiring a write lock before\n+//! mutating.\n+//!\n+//! `RefCell` uses Rust's lifetimes to implement *dynamic borrowing*,\n+//! a process whereby one can claim temporary, exclusive, mutable\n+//! access to the inner value. Borrows for `RefCell`s are tracked *at\n+//! runtime*, unlike Rust's native reference types which are entirely\n+//! tracked statically, at compile time. Because `RefCell` borrows are\n+//! dynamic it is possible to attempt to borrow a value that is\n+//! already mutably borrowed; when this happens it results in task\n+//! failure.\n+//!\n+//! # When to choose interior mutability\n+//!\n+//! The more common inherited mutability, where one must have unique\n+//! access to mutate a value, is one of the key language elements that\n+//! enables Rust to reason strongly about pointer aliasing, statically\n+//! preventing crash bugs. Because of that, inherited mutability is\n+//! preferred, and interior mutability is something of a last\n+//! resort. Since cell types enable mutation where it would otherwise\n+//! be disallowed though, there are occassions when interior\n+//! mutability might be appropriate, or even *must* be used, e.g.\n+//!\n+//! * Introducing inherited mutability roots to shared types.\n+//! * Implementation details of logically-immutable methods.\n+//! * Mutating implementations of `clone`.\n+//!\n+//! ## Introducing inherited mutability roots to shared types\n+//!\n+//! Shared smart pointer types, including `Rc` and `Arc`, provide\n+//! containers that can be cloned and shared between multiple parties.\n+//! Because the contained values may be multiply-aliased, they can\n+//! only be borrowed as shared references, not mutable references.\n+//! Without cells then it would be impossible to mutate data inside of\n+//! shared boxes at all!\n+//!\n+//! It's very common then to put a `RefCell` inside shared pointer\n+//! types to reintroduce mutability:\n+//!\n+//! ```\n+//! extern crate collections;\n+//!\n+//! use collections::HashMap;\n+//! use std::cell::RefCell;\n+//! use std::rc::Rc;\n+//!\n+//! fn main() {\n+//!     let shared_map: Rc<RefCell<_>> = Rc::new(RefCell::new(HashMap::new()));\n+//!     shared_map.borrow_mut().insert(\"africa\", 92388);\n+//!     shared_map.borrow_mut().insert(\"kyoto\", 11837);\n+//!     shared_map.borrow_mut().insert(\"piccadilly\", 11826);\n+//!     shared_map.borrow_mut().insert(\"marbles\", 38);\n+//! }\n+//! ```\n+//!\n+//! ## Implementation details of logically-immutable methods\n+//!\n+//! Occasionally it may be desirable not to expose in an API that\n+//! there is mutation happening \"under the hood\". This may be because\n+//! logically the operation is immutable, but e.g. caching forces the\n+//! implementation to perform mutation; or because you must employ\n+//! mutation to implement a trait method that was originally defined\n+//! to take `&self`.\n+//!\n+//! ```\n+//! extern crate collections;\n+//!\n+//! use collections::HashMap;\n+//! use std::cell::RefCell;\n+//!\n+//! struct Graph {\n+//!     edges: HashMap<uint, uint>,\n+//!     span_tree_cache: RefCell<Option<Vec<(uint, uint)>>>\n+//! }\n+//!\n+//! impl Graph {\n+//!     fn minimum_spanning_tree(&self) -> Vec<(uint, uint)> {\n+//!         // Create a new scope to contain the lifetime of the\n+//!         // dynamic borrow\n+//!         {\n+//!             // Take a reference to the inside of cache cell\n+//!             let mut cache = self.span_tree_cache.borrow_mut();\n+//!             if cache.is_some() {\n+//!                 return cache.take_unwrap().clone();\n+//!             }\n+//!\n+//!             let span_tree = self.calc_span_tree();\n+//!             *cache = Some(span_tree);\n+//!         }\n+//!\n+//!         // Recursive call to return the just-cached value.\n+//!         // Note that if we had not let the previous borrow\n+//!         // of the cache fall out of scope then the subsequent\n+//!         // recursive borrow would cause a dynamic task failure.\n+//!         // This is the major hazard of using `RefCell`.\n+//!         self.minimum_spanning_tree()\n+//!     }\n+//! #   fn calc_span_tree(&self) -> Vec<(uint, uint)> { vec!() }\n+//! }\n+//! # fn main() { }\n+//! ```\n+//!\n+//! ## Mutating implementations of `clone`\n+//!\n+//! This is simply a special - bot common - case of the previous:\n+//! hiding mutability for operations that appear to be immutable.\n+//! The `clone` method is expected to not change the source value, and\n+//! is declared to take `&self`, not `&mut self`. Therefore any\n+//! mutation that happens in the `clone` method must use cell\n+//! types. For example, `Rc` maintains its reference counts within a\n+//! `Cell`.\n+//!\n+//! ```\n+//! use std::cell::Cell;\n+//!\n+//! struct Rc<T> {\n+//!     ptr: *mut RcBox<T>\n+//! }\n+//!\n+//! struct RcBox<T> {\n+//!     value: T,\n+//!     refcount: Cell<uint>\n+//! }\n+//!\n+//! impl<T> Clone for Rc<T> {\n+//!     fn clone(&self) -> Rc<T> {\n+//!         unsafe {\n+//!             (*self.ptr).refcount.set((*self.ptr).refcount.get() + 1);\n+//!             Rc { ptr: self.ptr }\n+//!         }\n+//!     }\n+//! }\n+//! ```\n+//!\n+// TODO: Explain difference between Cell and RefCell\n+// TODO: Downsides to interior mutability\n+// TODO: Can't be shared between threads. Dynamic borrows\n+// TODO: Relationship to Atomic types and RWLock\n \n use clone::Clone;\n use cmp::Eq;"}]}