{"sha": "0127704c984ad99f113e7f8b1adeb47994acac6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMjc3MDRjOTg0YWQ5OWYxMTNlN2Y4YjFhZGViNDc5OTRhY2FjNmQ=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2018-07-26T15:18:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-07-26T15:18:25Z"}, "message": "Rollup merge of #52610 - MajorBreakfast:task-terminology, r=cramertj\n\nClarify what a task is\n\nCurrently we call two distinct concepts \"task\":\n1. The top-level future that is polled until completion\n2. The lightweight \"thread\" that is responsible for polling the top-level future. What additional data beside the future is stored in this type varies between different `Executor` implementations.\n\nI'd prefer to return to the old formulation by @alexcrichton:\n```rust\n/// A handle to a \"task\", which represents a single lightweight \"thread\" of\n/// execution driving a future to completion.\npub struct Task {\n```\nSource: [`task_impl/mod.rs` in futures-rs 0.1](https://github.com/rust-lang-nursery/futures-rs/blob/1328fc9e8af5737183df477c7501e6ea24ff2053/src/task_impl/mod.rs#L49-L50)\n\nI think that this change will make it much easier to explain everything.\n\nr? @aturon\n@cramertj", "tree": {"sha": "2d7d3fa00decaa8db36d093f8b34f528a0a17a89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d7d3fa00decaa8db36d093f8b34f528a0a17a89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0127704c984ad99f113e7f8b1adeb47994acac6d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbWeZBCRBK7hj4Ov3rIwAAdHIIADpAvO0tTf8faBe4wkjMoMi2\na+Xyo4aSKtvCkaxk2ttnoF26No8K/nQ7a/yHcOXVbOftB9R0yJinqs4Blx3oy1Ib\nDNR8aBdgiPeyrzmEF/+xojGv3FzzqeaQxIey8yHN7OTsDPSO3MxYAB89lQPSCW6V\nwH+482VSoMVkzAyPnFOmPhuk7LUuBCuAEXTmleDc4SP7cnf1JtzGztAb8QMV3HYR\nLFBM6uQ2BIOWBdg5norc5dmSIACFL0ckNdDi1hxhb7PXdzx1ShuYPPOf6LdwvYsD\nEViONOPjlFR4YaLfDa/DZpfJk48+HFdgb6IoXCSN3UKvqTVMlYwyTJiKZAlMGsQ=\n=8Nun\n-----END PGP SIGNATURE-----\n", "payload": "tree 2d7d3fa00decaa8db36d093f8b34f528a0a17a89\nparent e29f15bafd08f306fd1255131003468f4ace71e9\nparent eacfd7252252fac66b9354cdd861f054cc678373\nauthor Mark Rousskov <mark.simulacrum@gmail.com> 1532618305 -0600\ncommitter GitHub <noreply@github.com> 1532618305 -0600\n\nRollup merge of #52610 - MajorBreakfast:task-terminology, r=cramertj\n\nClarify what a task is\n\nCurrently we call two distinct concepts \"task\":\n1. The top-level future that is polled until completion\n2. The lightweight \"thread\" that is responsible for polling the top-level future. What additional data beside the future is stored in this type varies between different `Executor` implementations.\n\nI'd prefer to return to the old formulation by @alexcrichton:\n```rust\n/// A handle to a \"task\", which represents a single lightweight \"thread\" of\n/// execution driving a future to completion.\npub struct Task {\n```\nSource: [`task_impl/mod.rs` in futures-rs 0.1](https://github.com/rust-lang-nursery/futures-rs/blob/1328fc9e8af5737183df477c7501e6ea24ff2053/src/task_impl/mod.rs#L49-L50)\n\nI think that this change will make it much easier to explain everything.\n\nr? @aturon\n@cramertj\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0127704c984ad99f113e7f8b1adeb47994acac6d", "html_url": "https://github.com/rust-lang/rust/commit/0127704c984ad99f113e7f8b1adeb47994acac6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0127704c984ad99f113e7f8b1adeb47994acac6d/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e29f15bafd08f306fd1255131003468f4ace71e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e29f15bafd08f306fd1255131003468f4ace71e9", "html_url": "https://github.com/rust-lang/rust/commit/e29f15bafd08f306fd1255131003468f4ace71e9"}, {"sha": "eacfd7252252fac66b9354cdd861f054cc678373", "url": "https://api.github.com/repos/rust-lang/rust/commits/eacfd7252252fac66b9354cdd861f054cc678373", "html_url": "https://github.com/rust-lang/rust/commit/eacfd7252252fac66b9354cdd861f054cc678373"}], "stats": {"total": 30, "additions": 18, "deletions": 12}, "files": [{"sha": "affcbf464da221214da7c8712e5c7972bde24d23", "filename": "src/libcore/task/executor.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0127704c984ad99f113e7f8b1adeb47994acac6d/src%2Flibcore%2Ftask%2Fexecutor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0127704c984ad99f113e7f8b1adeb47994acac6d/src%2Flibcore%2Ftask%2Fexecutor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fexecutor.rs?ref=0127704c984ad99f113e7f8b1adeb47994acac6d", "patch": "@@ -17,21 +17,27 @@ use future::{FutureObj, LocalFutureObj};\n \n /// A task executor.\n ///\n-/// A *task* is a `()`-producing async value that runs at the top level, and will\n-/// be `poll`ed until completion. It's also the unit at which wake-up\n-/// notifications occur. Executors, such as thread pools, allow tasks to be\n-/// spawned and are responsible for putting tasks onto ready queues when\n-/// they are woken up, and polling them when they are ready.\n+/// Futures are polled until completion by tasks, a kind of lightweight\n+/// \"thread\". A *task executor* is responsible for the creation of these tasks\n+/// and the coordination of their execution on real operating system threads. In\n+/// particular, whenever a task signals that it can make further progress via a\n+/// wake-up notification, it is the responsibility of the task executor to put\n+/// the task into a queue to continue executing it, i.e. polling the future in\n+/// it, later.\n pub trait Executor {\n-    /// Spawn the given task, polling it until completion.\n+    /// Spawns a new task with the given future. The future will be polled until\n+    /// completion.\n     ///\n     /// # Errors\n     ///\n     /// The executor may be unable to spawn tasks, either because it has\n     /// been shut down or is resource-constrained.\n-    fn spawn_obj(&mut self, task: FutureObj<'static, ()>) -> Result<(), SpawnObjError>;\n+    fn spawn_obj(\n+        &mut self,\n+        future: FutureObj<'static, ()>,\n+    ) -> Result<(), SpawnObjError>;\n \n-    /// Determine whether the executor is able to spawn new tasks.\n+    /// Determines whether the executor is able to spawn new tasks.\n     ///\n     /// # Returns\n     ///\n@@ -75,8 +81,8 @@ pub struct SpawnObjError {\n     /// The kind of error\n     pub kind: SpawnErrorKind,\n \n-    /// The task for which spawning was attempted\n-    pub task: FutureObj<'static, ()>,\n+    /// The future for which spawning inside a task was attempted\n+    pub future: FutureObj<'static, ()>,\n }\n \n /// The result of a failed spawn\n@@ -85,6 +91,6 @@ pub struct SpawnLocalObjError {\n     /// The kind of error\n     pub kind: SpawnErrorKind,\n \n-    /// The task for which spawning was attempted\n-    pub task: LocalFutureObj<'static, ()>,\n+    /// The future for which spawning inside a task was attempted\n+    pub future: LocalFutureObj<'static, ()>,\n }"}]}