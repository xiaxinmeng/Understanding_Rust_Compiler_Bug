{"sha": "a2fb4b95ddda1c2d622c809e63aa5e158cfb9976", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyZmI0Yjk1ZGRkYTFjMmQ2MjJjODA5ZTYzYWE1ZTE1OGNmYjk5NzY=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-12-16T23:10:04Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-12-18T17:29:55Z"}, "message": "Remove `DefPath` from `Visibility` and calculate it on demand", "tree": {"sha": "a07d5aade54d321b0f4b3a1d5fe52a3f9cc2f04c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a07d5aade54d321b0f4b3a1d5fe52a3f9cc2f04c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2fb4b95ddda1c2d622c809e63aa5e158cfb9976", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2fb4b95ddda1c2d622c809e63aa5e158cfb9976", "html_url": "https://github.com/rust-lang/rust/commit/a2fb4b95ddda1c2d622c809e63aa5e158cfb9976", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2fb4b95ddda1c2d622c809e63aa5e158cfb9976/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8d3ab96aa94423f1bdfbb605098a506ab5edc7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e", "html_url": "https://github.com/rust-lang/rust/commit/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e"}], "stats": {"total": 136, "additions": 75, "deletions": 61}, "files": [{"sha": "0ce689957ca5fab2a1f414cab9b8acb0127a858d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a2fb4b95ddda1c2d622c809e63aa5e158cfb9976/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2fb4b95ddda1c2d622c809e63aa5e158cfb9976/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a2fb4b95ddda1c2d622c809e63aa5e158cfb9976", "patch": "@@ -1775,25 +1775,28 @@ impl Clean<Visibility> for hir::Visibility<'_> {\n             hir::VisibilityKind::Inherited => Visibility::Inherited,\n             hir::VisibilityKind::Crate(_) => {\n                 let krate = DefId::local(CRATE_DEF_INDEX);\n-                Visibility::Restricted(krate, cx.tcx.def_path(krate))\n+                Visibility::Restricted(krate)\n             }\n             hir::VisibilityKind::Restricted { ref path, .. } => {\n                 let path = path.clean(cx);\n                 let did = register_res(cx, path.res);\n-                Visibility::Restricted(did, cx.tcx.def_path(did))\n+                Visibility::Restricted(did)\n             }\n         }\n     }\n }\n \n impl Clean<Visibility> for ty::Visibility {\n-    fn clean(&self, cx: &DocContext<'_>) -> Visibility {\n+    fn clean(&self, _cx: &DocContext<'_>) -> Visibility {\n         match *self {\n             ty::Visibility::Public => Visibility::Public,\n+            // NOTE: this is not quite right: `ty` uses `Invisible` to mean 'private',\n+            // while rustdoc really does mean inherited. That means that for enum variants, such as\n+            // `pub enum E { V }`, `V` will be marked as `Public` by `ty`, but as `Inherited` by rustdoc.\n+            // This is the main reason `impl Clean for hir::Visibility` still exists; various parts of clean\n+            // override `tcx.visibility` explicitly to make sure this distinction is captured.\n             ty::Visibility::Invisible => Visibility::Inherited,\n-            ty::Visibility::Restricted(module) => {\n-                Visibility::Restricted(module, cx.tcx.def_path(module))\n-            }\n+            ty::Visibility::Restricted(module) => Visibility::Restricted(module),\n         }\n     }\n }\n@@ -2303,14 +2306,14 @@ impl Clean<Item> for (&hir::MacroDef<'_>, Option<Symbol>) {\n             if matchers.len() <= 1 {\n                 format!(\n                     \"{}macro {}{} {{\\n    ...\\n}}\",\n-                    vis.print_with_space(),\n+                    vis.print_with_space(cx.tcx),\n                     name,\n                     matchers.iter().map(|span| span.to_src(cx)).collect::<String>(),\n                 )\n             } else {\n                 format!(\n                     \"{}macro {} {{\\n{}}}\",\n-                    vis.print_with_space(),\n+                    vis.print_with_space(cx.tcx),\n                     name,\n                     matchers\n                         .iter()"}, {"sha": "35917924fa68862507e19ced75402a8cec251367", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2fb4b95ddda1c2d622c809e63aa5e158cfb9976/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2fb4b95ddda1c2d622c809e63aa5e158cfb9976/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=a2fb4b95ddda1c2d622c809e63aa5e158cfb9976", "patch": "@@ -1569,11 +1569,11 @@ impl From<hir::PrimTy> for PrimitiveType {\n     }\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Copy, Clone, Debug)]\n crate enum Visibility {\n     Public,\n     Inherited,\n-    Restricted(DefId, rustc_hir::definitions::DefPath),\n+    Restricted(DefId),\n }\n \n impl Visibility {"}, {"sha": "7b0b219570b983586b9ae4b58108c310a14ab15b", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a2fb4b95ddda1c2d622c809e63aa5e158cfb9976/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2fb4b95ddda1c2d622c809e63aa5e158cfb9976/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=a2fb4b95ddda1c2d622c809e63aa5e158cfb9976", "patch": "@@ -11,6 +11,7 @@ use std::fmt;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_target::spec::abi::Abi;\n \n@@ -1084,18 +1085,18 @@ impl Function<'_> {\n }\n \n impl clean::Visibility {\n-    crate fn print_with_space(&self) -> impl fmt::Display + '_ {\n+    crate fn print_with_space<'tcx>(self, tcx: TyCtxt<'tcx>) -> impl fmt::Display + 'tcx {\n         use rustc_span::symbol::kw;\n \n-        display_fn(move |f| match *self {\n+        display_fn(move |f| match self {\n             clean::Public => f.write_str(\"pub \"),\n             clean::Inherited => Ok(()),\n-            // If this is `pub(crate)`, `path` will be empty.\n-            clean::Visibility::Restricted(did, _) if did.index == CRATE_DEF_INDEX => {\n+            clean::Visibility::Restricted(did) if did.index == CRATE_DEF_INDEX => {\n                 write!(f, \"pub(crate) \")\n             }\n-            clean::Visibility::Restricted(did, ref path) => {\n+            clean::Visibility::Restricted(did) => {\n                 f.write_str(\"pub(\")?;\n+                let path = tcx.def_path(did);\n                 debug!(\"path={:?}\", path);\n                 let first_name =\n                     path.data[0].data.get_opt_name().expect(\"modules are always named\");"}, {"sha": "76db0205695eff11f23446ea74d781c1b925db57", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 43, "deletions": 31, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a2fb4b95ddda1c2d622c809e63aa5e158cfb9976/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2fb4b95ddda1c2d622c809e63aa5e158cfb9976/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=a2fb4b95ddda1c2d622c809e63aa5e158cfb9976", "patch": "@@ -164,7 +164,7 @@ crate struct SharedContext<'tcx> {\n     playground: Option<markdown::Playground>,\n }\n \n-impl Context<'_> {\n+impl<'tcx> Context<'tcx> {\n     fn path(&self, filename: &str) -> PathBuf {\n         // We use splitn vs Path::extension here because we might get a filename\n         // like `style.min.css` and we want to process that into\n@@ -176,6 +176,10 @@ impl Context<'_> {\n         self.dst.join(&filename)\n     }\n \n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.shared.tcx\n+    }\n+\n     fn sess(&self) -> &Session {\n         &self.shared.tcx.sess\n     }\n@@ -2147,14 +2151,14 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                     Some(ref src) => write!(\n                         w,\n                         \"<tr><td><code>{}extern crate {} as {};\",\n-                        myitem.visibility.print_with_space(),\n+                        myitem.visibility.print_with_space(cx.tcx()),\n                         anchor(myitem.def_id, &*src.as_str()),\n                         name\n                     ),\n                     None => write!(\n                         w,\n                         \"<tr><td><code>{}extern crate {};\",\n-                        myitem.visibility.print_with_space(),\n+                        myitem.visibility.print_with_space(cx.tcx()),\n                         anchor(myitem.def_id, &*name.as_str())\n                     ),\n                 }\n@@ -2165,7 +2169,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                 write!(\n                     w,\n                     \"<tr><td><code>{}{}</code></td></tr>\",\n-                    myitem.visibility.print_with_space(),\n+                    myitem.visibility.print_with_space(cx.tcx()),\n                     import.print()\n                 );\n             }\n@@ -2379,7 +2383,7 @@ fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::\n     write!(\n         w,\n         \"{vis}const {name}: {typ}\",\n-        vis = it.visibility.print_with_space(),\n+        vis = it.visibility.print_with_space(cx.tcx()),\n         name = it.name.as_ref().unwrap(),\n         typ = c.type_.print(),\n     );\n@@ -2413,7 +2417,7 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n     write!(\n         w,\n         \"{vis}static {mutability}{name}: {typ}</pre>\",\n-        vis = it.visibility.print_with_space(),\n+        vis = it.visibility.print_with_space(cx.tcx()),\n         mutability = s.mutability.print_with_space(),\n         name = it.name.as_ref().unwrap(),\n         typ = s.type_.print()\n@@ -2424,7 +2428,7 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::Function) {\n     let header_len = format!(\n         \"{}{}{}{}{:#}fn {}{:#}\",\n-        it.visibility.print_with_space(),\n+        it.visibility.print_with_space(cx.tcx()),\n         f.header.constness.print_with_space(),\n         f.header.asyncness.print_with_space(),\n         f.header.unsafety.print_with_space(),\n@@ -2439,7 +2443,7 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n         w,\n         \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n          {name}{generics}{decl}{spotlight}{where_clause}</pre>\",\n-        vis = it.visibility.print_with_space(),\n+        vis = it.visibility.print_with_space(cx.tcx()),\n         constness = f.header.constness.print_with_space(),\n         asyncness = f.header.asyncness.print_with_space(),\n         unsafety = f.header.unsafety.print_with_space(),\n@@ -2565,7 +2569,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         write!(\n             w,\n             \"{}{}{}trait {}{}{}\",\n-            it.visibility.print_with_space(),\n+            it.visibility.print_with_space(cx.tcx()),\n             t.unsafety.print_with_space(),\n             if t.is_auto { \"auto \" } else { \"\" },\n             it.name.as_ref().unwrap(),\n@@ -2585,21 +2589,21 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n             // FIXME: we should be using a derived_id for the Anchors here\n             write!(w, \"{{\\n\");\n             for t in &types {\n-                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait);\n+                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n                 write!(w, \";\\n\");\n             }\n             if !types.is_empty() && !consts.is_empty() {\n                 w.write_str(\"\\n\");\n             }\n             for t in &consts {\n-                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait);\n+                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n                 write!(w, \";\\n\");\n             }\n             if !consts.is_empty() && !required.is_empty() {\n                 w.write_str(\"\\n\");\n             }\n             for (pos, m) in required.iter().enumerate() {\n-                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait);\n+                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n                 write!(w, \";\\n\");\n \n                 if pos < required.len() - 1 {\n@@ -2610,7 +2614,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n                 w.write_str(\"\\n\");\n             }\n             for (pos, m) in provided.iter().enumerate() {\n-                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait);\n+                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n                 match m.kind {\n                     clean::MethodItem(ref inner, _)\n                         if !inner.generics.where_predicates.is_empty() =>\n@@ -2659,7 +2663,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         let item_type = m.type_();\n         let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n         write!(w, \"<h3 id=\\\"{id}\\\" class=\\\"method\\\"><code>\", id = id,);\n-        render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl);\n+        render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl, cx);\n         write!(w, \"</code>\");\n         render_stability_since(w, m, t);\n         write_srclink(cx, m, w, cache);\n@@ -2877,12 +2881,13 @@ fn assoc_const(\n     _default: Option<&String>,\n     link: AssocItemLink<'_>,\n     extra: &str,\n+    cx: &Context<'_>,\n ) {\n     write!(\n         w,\n         \"{}{}const <a href=\\\"{}\\\" class=\\\"constant\\\"><b>{}</b></a>: {}\",\n         extra,\n-        it.visibility.print_with_space(),\n+        it.visibility.print_with_space(cx.tcx()),\n         naive_assoc_href(it, link),\n         it.name.as_ref().unwrap(),\n         ty.print()\n@@ -2965,6 +2970,7 @@ fn render_assoc_item(\n     item: &clean::Item,\n     link: AssocItemLink<'_>,\n     parent: ItemType,\n+    cx: &Context<'_>,\n ) {\n     fn method(\n         w: &mut Buffer,\n@@ -2974,6 +2980,7 @@ fn render_assoc_item(\n         d: &clean::FnDecl,\n         link: AssocItemLink<'_>,\n         parent: ItemType,\n+        cx: &Context<'_>,\n     ) {\n         let name = meth.name.as_ref().unwrap();\n         let anchor = format!(\"#{}.{}\", meth.type_(), name);\n@@ -2994,7 +3001,7 @@ fn render_assoc_item(\n         };\n         let mut header_len = format!(\n             \"{}{}{}{}{}{:#}fn {}{:#}\",\n-            meth.visibility.print_with_space(),\n+            meth.visibility.print_with_space(cx.tcx()),\n             header.constness.print_with_space(),\n             header.asyncness.print_with_space(),\n             header.unsafety.print_with_space(),\n@@ -3016,7 +3023,7 @@ fn render_assoc_item(\n             \"{}{}{}{}{}{}{}fn <a href=\\\"{href}\\\" class=\\\"fnname\\\">{name}</a>\\\n              {generics}{decl}{spotlight}{where_clause}\",\n             if parent == ItemType::Trait { \"    \" } else { \"\" },\n-            meth.visibility.print_with_space(),\n+            meth.visibility.print_with_space(cx.tcx()),\n             header.constness.print_with_space(),\n             header.asyncness.print_with_space(),\n             header.unsafety.print_with_space(),\n@@ -3032,9 +3039,11 @@ fn render_assoc_item(\n     }\n     match item.kind {\n         clean::StrippedItem(..) => {}\n-        clean::TyMethodItem(ref m) => method(w, item, m.header, &m.generics, &m.decl, link, parent),\n+        clean::TyMethodItem(ref m) => {\n+            method(w, item, m.header, &m.generics, &m.decl, link, parent, cx)\n+        }\n         clean::MethodItem(ref m, _) => {\n-            method(w, item, m.header, &m.generics, &m.decl, link, parent)\n+            method(w, item, m.header, &m.generics, &m.decl, link, parent, cx)\n         }\n         clean::AssocConstItem(ref ty, ref default) => assoc_const(\n             w,\n@@ -3043,6 +3052,7 @@ fn render_assoc_item(\n             default.as_ref(),\n             link,\n             if parent == ItemType::Trait { \"    \" } else { \"\" },\n+            cx,\n         ),\n         clean::AssocTypeItem(ref bounds, ref default) => assoc_type(\n             w,\n@@ -3066,7 +3076,7 @@ fn item_struct(\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class=\\\"rust struct\\\">\");\n         render_attributes(w, it, true);\n-        render_struct(w, it, Some(&s.generics), s.struct_type, &s.fields, \"\", true);\n+        render_struct(w, it, Some(&s.generics), s.struct_type, &s.fields, \"\", true, cx);\n         write!(w, \"</pre>\")\n     });\n \n@@ -3116,7 +3126,7 @@ fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Uni\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class=\\\"rust union\\\">\");\n         render_attributes(w, it, true);\n-        render_union(w, it, Some(&s.generics), &s.fields, \"\", true);\n+        render_union(w, it, Some(&s.generics), &s.fields, \"\", true, cx);\n         write!(w, \"</pre>\")\n     });\n \n@@ -3165,7 +3175,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n         write!(\n             w,\n             \"{}enum {}{}{}\",\n-            it.visibility.print_with_space(),\n+            it.visibility.print_with_space(cx.tcx()),\n             it.name.as_ref().unwrap(),\n             e.generics.print(),\n             WhereClause { gens: &e.generics, indent: 0, end_newline: true }\n@@ -3191,7 +3201,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                             write!(w, \")\");\n                         }\n                         clean::VariantKind::Struct(ref s) => {\n-                            render_struct(w, v, None, s.struct_type, &s.fields, \"    \", false);\n+                            render_struct(w, v, None, s.struct_type, &s.fields, \"    \", false, cx);\n                         }\n                     },\n                     _ => unreachable!(),\n@@ -3335,11 +3345,12 @@ fn render_struct(\n     fields: &[clean::Item],\n     tab: &str,\n     structhead: bool,\n+    cx: &Context<'_>,\n ) {\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(),\n+        it.visibility.print_with_space(cx.tcx()),\n         if structhead { \"struct \" } else { \"\" },\n         it.name.as_ref().unwrap()\n     );\n@@ -3359,7 +3370,7 @@ fn render_struct(\n                         w,\n                         \"\\n{}    {}{}: {},\",\n                         tab,\n-                        field.visibility.print_with_space(),\n+                        field.visibility.print_with_space(cx.tcx()),\n                         field.name.as_ref().unwrap(),\n                         ty.print()\n                     );\n@@ -3388,7 +3399,7 @@ fn render_struct(\n                 match field.kind {\n                     clean::StrippedItem(box clean::StructFieldItem(..)) => write!(w, \"_\"),\n                     clean::StructFieldItem(ref ty) => {\n-                        write!(w, \"{}{}\", field.visibility.print_with_space(), ty.print())\n+                        write!(w, \"{}{}\", field.visibility.print_with_space(cx.tcx()), ty.print())\n                     }\n                     _ => unreachable!(),\n                 }\n@@ -3416,11 +3427,12 @@ fn render_union(\n     fields: &[clean::Item],\n     tab: &str,\n     structhead: bool,\n+    cx: &Context<'_>,\n ) {\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(),\n+        it.visibility.print_with_space(cx.tcx()),\n         if structhead { \"union \" } else { \"\" },\n         it.name.as_ref().unwrap()\n     );\n@@ -3435,7 +3447,7 @@ fn render_union(\n             write!(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n-                field.visibility.print_with_space(),\n+                field.visibility.print_with_space(cx.tcx()),\n                 field.name.as_ref().unwrap(),\n                 ty.print(),\n                 tab\n@@ -3827,7 +3839,7 @@ fn render_impl(\n                     let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n                     write!(w, \"<h4 id=\\\"{}\\\" class=\\\"{}{}\\\">\", id, item_type, extra_class);\n                     write!(w, \"<code>\");\n-                    render_assoc_item(w, item, link.anchor(&id), ItemType::Impl);\n+                    render_assoc_item(w, item, link.anchor(&id), ItemType::Impl, cx);\n                     write!(w, \"</code>\");\n                     render_stability_since_raw(\n                         w,\n@@ -3849,7 +3861,7 @@ fn render_impl(\n             clean::AssocConstItem(ref ty, ref default) => {\n                 let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n                 write!(w, \"<h4 id=\\\"{}\\\" class=\\\"{}{}\\\"><code>\", id, item_type, extra_class);\n-                assoc_const(w, item, ty, default.as_ref(), link.anchor(&id), \"\");\n+                assoc_const(w, item, ty, default.as_ref(), link.anchor(&id), \"\", cx);\n                 write!(w, \"</code>\");\n                 render_stability_since_raw(\n                     w,\n@@ -4074,7 +4086,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, cache:\n     write!(\n         w,\n         \"    {}type {};\\n}}</pre>\",\n-        it.visibility.print_with_space(),\n+        it.visibility.print_with_space(cx.tcx()),\n         it.name.as_ref().unwrap(),\n     );\n "}, {"sha": "5a8b2cb5da1fb295f1837168887bd9f134421975", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a2fb4b95ddda1c2d622c809e63aa5e158cfb9976/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2fb4b95ddda1c2d622c809e63aa5e158cfb9976/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=a2fb4b95ddda1c2d622c809e63aa5e158cfb9976", "patch": "@@ -35,7 +35,7 @@ impl JsonRenderer<'_> {\n                 crate_id: def_id.krate.as_u32(),\n                 name: name.map(|sym| sym.to_string()),\n                 source: self.convert_span(source),\n-                visibility: visibility.into(),\n+                visibility: self.convert_visibility(visibility),\n                 docs: attrs.collapsed_doc_value().unwrap_or_default(),\n                 links: attrs\n                     .links\n@@ -75,31 +75,29 @@ impl JsonRenderer<'_> {\n             _ => None,\n         }\n     }\n-}\n-\n-impl From<rustc_attr::Deprecation> for Deprecation {\n-    fn from(deprecation: rustc_attr::Deprecation) -> Self {\n-        #[rustfmt::skip]\n-        let rustc_attr::Deprecation { since, note, is_since_rustc_version: _, suggestion: _ } = deprecation;\n-        Deprecation { since: since.map(|s| s.to_string()), note: note.map(|s| s.to_string()) }\n-    }\n-}\n \n-impl From<clean::Visibility> for Visibility {\n-    fn from(v: clean::Visibility) -> Self {\n+    fn convert_visibility(&self, v: clean::Visibility) -> Visibility {\n         use clean::Visibility::*;\n         match v {\n             Public => Visibility::Public,\n             Inherited => Visibility::Default,\n-            Restricted(did, _) if did.index == CRATE_DEF_INDEX => Visibility::Crate,\n-            Restricted(did, path) => Visibility::Restricted {\n+            Restricted(did) if did.index == CRATE_DEF_INDEX => Visibility::Crate,\n+            Restricted(did) => Visibility::Restricted {\n                 parent: did.into(),\n-                path: path.to_string_no_crate_verbose(),\n+                path: self.tcx.def_path(did).to_string_no_crate_verbose(),\n             },\n         }\n     }\n }\n \n+impl From<rustc_attr::Deprecation> for Deprecation {\n+    fn from(deprecation: rustc_attr::Deprecation) -> Self {\n+        #[rustfmt::skip]\n+        let rustc_attr::Deprecation { since, note, is_since_rustc_version: _, suggestion: _ } = deprecation;\n+        Deprecation { since: since.map(|s| s.to_string()), note: note.map(|s| s.to_string()) }\n+    }\n+}\n+\n impl From<clean::GenericArgs> for GenericArgs {\n     fn from(args: clean::GenericArgs) -> Self {\n         use clean::GenericArgs::*;"}]}