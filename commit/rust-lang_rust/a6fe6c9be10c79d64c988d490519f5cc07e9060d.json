{"sha": "a6fe6c9be10c79d64c988d490519f5cc07e9060d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2ZmU2YzliZTEwYzc5ZDY0Yzk4OGQ0OTA1MTlmNWNjMDdlOTA2MGQ=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-12-26T14:40:15Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-12-26T14:45:42Z"}, "message": "Refactor mir::dataflow: remove Ctxt associated type from BitDenotation trait.\n\nI no longer remember why I needed this (or thought I did). The way\nthat the `BitDenotation` is passed around in all existing use cases\n(and planned future ones), the thing that were in the `Ctxt` can just\nbe part of `Self` instead.\n\n(I think ariel had been pushing me to do this back when I first put in\nthis infrastructure; it took me a while to see how much of pain the\n`Ctxt` was causing.)", "tree": {"sha": "4a2251e58371b6a9474451f6cb679d700b1a8bf2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a2251e58371b6a9474451f6cb679d700b1a8bf2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6fe6c9be10c79d64c988d490519f5cc07e9060d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6fe6c9be10c79d64c988d490519f5cc07e9060d", "html_url": "https://github.com/rust-lang/rust/commit/a6fe6c9be10c79d64c988d490519f5cc07e9060d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6fe6c9be10c79d64c988d490519f5cc07e9060d/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8493dbed6c29b30844830d6e50a33493c6ea70af", "url": "https://api.github.com/repos/rust-lang/rust/commits/8493dbed6c29b30844830d6e50a33493c6ea70af", "html_url": "https://github.com/rust-lang/rust/commit/8493dbed6c29b30844830d6e50a33493c6ea70af"}], "stats": {"total": 279, "additions": 144, "deletions": 135}, "files": [{"sha": "b15c1873f9bd84506dbe3cd7b3f5946bf83dad59", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/graphviz.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a6fe6c9be10c79d64c988d490519f5cc07e9060d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6fe6c9be10c79d64c988d490519f5cc07e9060d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs?ref=a6fe6c9be10c79d64c988d490519f5cc07e9060d", "patch": "@@ -27,16 +27,15 @@ use std::marker::PhantomData;\n use std::mem;\n use std::path::Path;\n \n-use super::super::MoveDataParamEnv;\n use super::super::MirBorrowckCtxtPreDataflow;\n use super::{BitDenotation, DataflowState};\n \n impl<O: BitDenotation> DataflowState<O> {\n-    fn each_bit<F>(&self, ctxt: &O::Ctxt, words: &IdxSet<O::Idx>, mut f: F)\n+    fn each_bit<F>(&self, words: &IdxSet<O::Idx>, mut f: F)\n         where F: FnMut(O::Idx) {\n         //! Helper for iterating over the bits in a bitvector.\n \n-        let bits_per_block = self.operator.bits_per_block(ctxt);\n+        let bits_per_block = self.operator.bits_per_block();\n         let usize_bits: usize = mem::size_of::<usize>() * 8;\n \n         for (word_index, &word) in words.words().iter().enumerate() {\n@@ -65,35 +64,33 @@ impl<O: BitDenotation> DataflowState<O> {\n     }\n \n     pub fn interpret_set<'c, P>(&self,\n-                                ctxt: &'c O::Ctxt,\n+                                o: &'c O,\n                                 words: &IdxSet<O::Idx>,\n                                 render_idx: &P)\n                                 -> Vec<&'c Debug>\n-        where P: for <'b> Fn(&'b O::Ctxt, O::Idx) -> &'b Debug\n+        where P: Fn(&O, O::Idx) -> &Debug\n     {\n         let mut v = Vec::new();\n-        self.each_bit(ctxt, words, |i| {\n-            v.push(render_idx(ctxt, i));\n+        self.each_bit(words, |i| {\n+            v.push(render_idx(o, i));\n         });\n         v\n     }\n }\n \n pub trait MirWithFlowState<'tcx> {\n-    type BD: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>>;\n+    type BD: BitDenotation;\n     fn node_id(&self) -> NodeId;\n     fn mir(&self) -> &Mir<'tcx>;\n-    fn analysis_ctxt(&self) -> &<Self::BD as BitDenotation>::Ctxt;\n     fn flow_state(&self) -> &DataflowState<Self::BD>;\n }\n \n impl<'a, 'tcx: 'a, BD> MirWithFlowState<'tcx> for MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n-    where 'tcx: 'a, BD: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>>\n+    where 'tcx: 'a, BD: BitDenotation\n {\n     type BD = BD;\n     fn node_id(&self) -> NodeId { self.node_id }\n     fn mir(&self) -> &Mir<'tcx> { self.flow_state.mir() }\n-    fn analysis_ctxt(&self) -> &BD::Ctxt { &self.flow_state.ctxt }\n     fn flow_state(&self) -> &DataflowState<Self::BD> { &self.flow_state.flow_state }\n }\n \n@@ -110,8 +107,8 @@ pub fn print_borrowck_graph_to<'a, 'tcx, BD, P>(\n     path: &Path,\n     render_idx: P)\n     -> io::Result<()>\n-    where BD: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>>,\n-          P: for <'b> Fn(&'b BD::Ctxt, BD::Idx) -> &'b Debug\n+    where BD: BitDenotation,\n+          P: Fn(&BD, BD::Idx) -> &Debug\n {\n     let g = Graph { mbcx: mbcx, phantom: PhantomData, render_idx: render_idx };\n     let mut v = Vec::new();\n@@ -133,9 +130,7 @@ fn outgoing(mir: &Mir, bb: BasicBlock) -> Vec<Edge> {\n \n impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n     where MWF: MirWithFlowState<'tcx>,\n-          P: for <'b> Fn(&'b <MWF::BD as BitDenotation>::Ctxt,\n-                         <MWF::BD as BitDenotation>::Idx)\n-                         -> &'b Debug,\n+          P: for <'b> Fn(&'b MWF::BD, <MWF::BD as BitDenotation>::Idx) -> &'b Debug,\n {\n     type Node = Node;\n     type Edge = Edge;\n@@ -227,9 +222,8 @@ impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n         ::rustc_mir::graphviz::write_node_label(\n             *n, self.mbcx.mir(), &mut v, 4,\n             |w| {\n-                let ctxt = self.mbcx.analysis_ctxt();\n                 let flow = self.mbcx.flow_state();\n-                let entry_interp = flow.interpret_set(ctxt,\n+                let entry_interp = flow.interpret_set(&flow.operator,\n                                                       flow.sets.on_entry_set_for(i),\n                                                       &self.render_idx);\n                 chunked_present_left(w, &entry_interp[..], chunk_size)?;\n@@ -244,12 +238,11 @@ impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n                        entrybits=bits_to_string(entry.words(), bits_per_block))\n             },\n             |w| {\n-                let ctxt = self.mbcx.analysis_ctxt();\n                 let flow = self.mbcx.flow_state();\n                 let gen_interp =\n-                    flow.interpret_set(ctxt, flow.sets.gen_set_for(i), &self.render_idx);\n+                    flow.interpret_set(&flow.operator, flow.sets.gen_set_for(i), &self.render_idx);\n                 let kill_interp =\n-                    flow.interpret_set(ctxt, flow.sets.kill_set_for(i), &self.render_idx);\n+                    flow.interpret_set(&flow.operator, flow.sets.kill_set_for(i), &self.render_idx);\n                 chunked_present_left(w, &gen_interp[..], chunk_size)?;\n                 let bits_per_block = flow.sets.bits_per_block();\n                 {"}, {"sha": "1fa4da94dd6bfae51f1052e820e0945ac66cdcf1", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs", "status": "modified", "additions": 72, "deletions": 56, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/a6fe6c9be10c79d64c988d490519f5cc07e9060d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6fe6c9be10c79d64c988d490519f5cc07e9060d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs?ref=a6fe6c9be10c79d64c988d490519f5cc07e9060d", "patch": "@@ -15,7 +15,7 @@ use rustc_data_structures::bitslice::{BitwiseOperator};\n use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n \n-use super::super::gather_moves::{MoveOutIndex, MovePathIndex};\n+use super::super::gather_moves::{HasMoveData, MoveData, MoveOutIndex, MovePathIndex};\n use super::super::MoveDataParamEnv;\n use super::super::DropFlagState;\n use super::super::drop_flag_effects_for_function_entry;\n@@ -66,14 +66,23 @@ use super::{BitDenotation, BlockSets, DataflowOperator};\n pub struct MaybeInitializedLvals<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n+    mdpe: &'a MoveDataParamEnv<'tcx>,\n }\n \n impl<'a, 'tcx: 'a> MaybeInitializedLvals<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n-        MaybeInitializedLvals { tcx: tcx, mir: mir }\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               mir: &'a Mir<'tcx>,\n+               mdpe: &'a MoveDataParamEnv<'tcx>)\n+               -> Self\n+    {\n+        MaybeInitializedLvals { tcx: tcx, mir: mir, mdpe: mdpe }\n     }\n }\n \n+impl<'a, 'tcx: 'a> HasMoveData<'tcx> for MaybeInitializedLvals<'a, 'tcx> {\n+    fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n+}\n+\n /// `MaybeUninitializedLvals` tracks all l-values that might be\n /// uninitialized upon reaching a particular point in the control flow\n /// for a function.\n@@ -112,14 +121,23 @@ impl<'a, 'tcx: 'a> MaybeInitializedLvals<'a, 'tcx> {\n pub struct MaybeUninitializedLvals<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n+    mdpe: &'a MoveDataParamEnv<'tcx>,\n }\n \n impl<'a, 'tcx: 'a> MaybeUninitializedLvals<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n-        MaybeUninitializedLvals { tcx: tcx, mir: mir }\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               mir: &'a Mir<'tcx>,\n+               mdpe: &'a MoveDataParamEnv<'tcx>)\n+               -> Self\n+    {\n+        MaybeUninitializedLvals { tcx: tcx, mir: mir, mdpe: mdpe }\n     }\n }\n \n+impl<'a, 'tcx: 'a> HasMoveData<'tcx> for MaybeUninitializedLvals<'a, 'tcx> {\n+    fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n+}\n+\n /// `DefinitelyInitializedLvals` tracks all l-values that are definitely\n /// initialized upon reaching a particular point in the control flow\n /// for a function.\n@@ -164,14 +182,23 @@ impl<'a, 'tcx: 'a> MaybeUninitializedLvals<'a, 'tcx> {\n pub struct DefinitelyInitializedLvals<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n+    mdpe: &'a MoveDataParamEnv<'tcx>,\n }\n \n impl<'a, 'tcx: 'a> DefinitelyInitializedLvals<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n-        DefinitelyInitializedLvals { tcx: tcx, mir: mir }\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               mir: &'a Mir<'tcx>,\n+               mdpe: &'a MoveDataParamEnv<'tcx>)\n+               -> Self\n+    {\n+        DefinitelyInitializedLvals { tcx: tcx, mir: mir, mdpe: mdpe }\n     }\n }\n \n+impl<'a, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedLvals<'a, 'tcx> {\n+    fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n+}\n+\n /// `MovingOutStatements` tracks the statements that perform moves out\n /// of particular l-values. More precisely, it tracks whether the\n /// *effect* of such moves (namely, the uninitialization of the\n@@ -189,6 +216,11 @@ impl<'a, 'tcx: 'a> DefinitelyInitializedLvals<'a, 'tcx> {\n pub struct MovingOutStatements<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n+    mdpe: &'a MoveDataParamEnv<'tcx>,\n+}\n+\n+impl<'a, 'tcx> HasMoveData<'tcx> for MovingOutStatements<'a, 'tcx> {\n+    fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n impl<'a, 'tcx> MaybeInitializedLvals<'a, 'tcx> {\n@@ -226,201 +258,187 @@ impl<'a, 'tcx> DefinitelyInitializedLvals<'a, 'tcx> {\n \n impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n     type Idx = MovePathIndex;\n-    type Ctxt = MoveDataParamEnv<'tcx>;\n     fn name() -> &'static str { \"maybe_init\" }\n-    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n-        ctxt.move_data.move_paths.len()\n+    fn bits_per_block(&self) -> usize {\n+        self.move_data().move_paths.len()\n     }\n \n-    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<MovePathIndex>)\n+    fn start_block_effect(&self, sets: &mut BlockSets<MovePathIndex>)\n     {\n         drop_flag_effects_for_function_entry(\n-            self.tcx, self.mir, ctxt,\n+            self.tcx, self.mir, self.mdpe,\n             |path, s| {\n                 assert!(s == DropFlagState::Present);\n                 sets.on_entry.add(&path);\n             });\n     }\n \n     fn statement_effect(&self,\n-                        ctxt: &Self::Ctxt,\n                         sets: &mut BlockSets<MovePathIndex>,\n                         bb: mir::BasicBlock,\n                         idx: usize)\n     {\n         drop_flag_effects_for_location(\n-            self.tcx, self.mir, ctxt,\n+            self.tcx, self.mir, self.mdpe,\n             Location { block: bb, statement_index: idx },\n             |path, s| Self::update_bits(sets, path, s)\n         )\n     }\n \n     fn terminator_effect(&self,\n-                         ctxt: &Self::Ctxt,\n                          sets: &mut BlockSets<MovePathIndex>,\n                          bb: mir::BasicBlock,\n                          statements_len: usize)\n     {\n         drop_flag_effects_for_location(\n-            self.tcx, self.mir, ctxt,\n+            self.tcx, self.mir, self.mdpe,\n             Location { block: bb, statement_index: statements_len },\n             |path, s| Self::update_bits(sets, path, s)\n         )\n     }\n \n     fn propagate_call_return(&self,\n-                             ctxt: &Self::Ctxt,\n                              in_out: &mut IdxSet<MovePathIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n                              dest_lval: &mir::Lvalue) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_lval to 1 (initialized).\n-        on_lookup_result_bits(self.tcx, self.mir, &ctxt.move_data,\n-                              ctxt.move_data.rev_lookup.find(dest_lval),\n+        on_lookup_result_bits(self.tcx, self.mir, self.move_data(),\n+                              self.move_data().rev_lookup.find(dest_lval),\n                               |mpi| { in_out.add(&mpi); });\n     }\n }\n \n impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n     type Idx = MovePathIndex;\n-    type Ctxt = MoveDataParamEnv<'tcx>;\n     fn name() -> &'static str { \"maybe_uninit\" }\n-    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n-        ctxt.move_data.move_paths.len()\n+    fn bits_per_block(&self) -> usize {\n+        self.move_data().move_paths.len()\n     }\n \n     // sets on_entry bits for Arg lvalues\n-    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<MovePathIndex>) {\n+    fn start_block_effect(&self, sets: &mut BlockSets<MovePathIndex>) {\n         // set all bits to 1 (uninit) before gathering counterevidence\n         for e in sets.on_entry.words_mut() { *e = !0; }\n \n         drop_flag_effects_for_function_entry(\n-            self.tcx, self.mir, ctxt,\n+            self.tcx, self.mir, self.mdpe,\n             |path, s| {\n                 assert!(s == DropFlagState::Present);\n                 sets.on_entry.remove(&path);\n             });\n     }\n \n     fn statement_effect(&self,\n-                        ctxt: &Self::Ctxt,\n                         sets: &mut BlockSets<MovePathIndex>,\n                         bb: mir::BasicBlock,\n                         idx: usize)\n     {\n         drop_flag_effects_for_location(\n-            self.tcx, self.mir, ctxt,\n+            self.tcx, self.mir, self.mdpe,\n             Location { block: bb, statement_index: idx },\n             |path, s| Self::update_bits(sets, path, s)\n         )\n     }\n \n     fn terminator_effect(&self,\n-                         ctxt: &Self::Ctxt,\n                          sets: &mut BlockSets<MovePathIndex>,\n                          bb: mir::BasicBlock,\n                          statements_len: usize)\n     {\n         drop_flag_effects_for_location(\n-            self.tcx, self.mir, ctxt,\n+            self.tcx, self.mir, self.mdpe,\n             Location { block: bb, statement_index: statements_len },\n             |path, s| Self::update_bits(sets, path, s)\n         )\n     }\n \n     fn propagate_call_return(&self,\n-                             ctxt: &Self::Ctxt,\n                              in_out: &mut IdxSet<MovePathIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n                              dest_lval: &mir::Lvalue) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_lval to 0 (initialized).\n-        on_lookup_result_bits(self.tcx, self.mir, &ctxt.move_data,\n-                              ctxt.move_data.rev_lookup.find(dest_lval),\n+        on_lookup_result_bits(self.tcx, self.mir, self.move_data(),\n+                              self.move_data().rev_lookup.find(dest_lval),\n                               |mpi| { in_out.remove(&mpi); });\n     }\n }\n \n impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n     type Idx = MovePathIndex;\n-    type Ctxt = MoveDataParamEnv<'tcx>;\n     fn name() -> &'static str { \"definite_init\" }\n-    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n-        ctxt.move_data.move_paths.len()\n+    fn bits_per_block(&self) -> usize {\n+        self.move_data().move_paths.len()\n     }\n \n     // sets on_entry bits for Arg lvalues\n-    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<MovePathIndex>) {\n+    fn start_block_effect(&self, sets: &mut BlockSets<MovePathIndex>) {\n         for e in sets.on_entry.words_mut() { *e = 0; }\n \n         drop_flag_effects_for_function_entry(\n-            self.tcx, self.mir, ctxt,\n+            self.tcx, self.mir, self.mdpe,\n             |path, s| {\n                 assert!(s == DropFlagState::Present);\n                 sets.on_entry.add(&path);\n             });\n     }\n \n     fn statement_effect(&self,\n-                        ctxt: &Self::Ctxt,\n                         sets: &mut BlockSets<MovePathIndex>,\n                         bb: mir::BasicBlock,\n                         idx: usize)\n     {\n         drop_flag_effects_for_location(\n-            self.tcx, self.mir, ctxt,\n+            self.tcx, self.mir, self.mdpe,\n             Location { block: bb, statement_index: idx },\n             |path, s| Self::update_bits(sets, path, s)\n         )\n     }\n \n     fn terminator_effect(&self,\n-                         ctxt: &Self::Ctxt,\n                          sets: &mut BlockSets<MovePathIndex>,\n                          bb: mir::BasicBlock,\n                          statements_len: usize)\n     {\n         drop_flag_effects_for_location(\n-            self.tcx, self.mir, ctxt,\n+            self.tcx, self.mir, self.mdpe,\n             Location { block: bb, statement_index: statements_len },\n             |path, s| Self::update_bits(sets, path, s)\n         )\n     }\n \n     fn propagate_call_return(&self,\n-                             ctxt: &Self::Ctxt,\n                              in_out: &mut IdxSet<MovePathIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n                              dest_lval: &mir::Lvalue) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_lval to 1 (initialized).\n-        on_lookup_result_bits(self.tcx, self.mir, &ctxt.move_data,\n-                              ctxt.move_data.rev_lookup.find(dest_lval),\n+        on_lookup_result_bits(self.tcx, self.mir, self.move_data(),\n+                              self.move_data().rev_lookup.find(dest_lval),\n                               |mpi| { in_out.add(&mpi); });\n     }\n }\n \n impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n     type Idx = MoveOutIndex;\n-    type Ctxt = MoveDataParamEnv<'tcx>;\n     fn name() -> &'static str { \"moving_out\" }\n-    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n-        ctxt.move_data.moves.len()\n+    fn bits_per_block(&self) -> usize {\n+        self.move_data().moves.len()\n     }\n \n-    fn start_block_effect(&self,_move_data: &Self::Ctxt, _sets: &mut BlockSets<MoveOutIndex>) {\n+    fn start_block_effect(&self, _sets: &mut BlockSets<MoveOutIndex>) {\n         // no move-statements have been executed prior to function\n         // execution, so this method has no effect on `_sets`.\n     }\n     fn statement_effect(&self,\n-                        ctxt: &Self::Ctxt,\n                         sets: &mut BlockSets<MoveOutIndex>,\n                         bb: mir::BasicBlock,\n                         idx: usize) {\n-        let (tcx, mir, move_data) = (self.tcx, self.mir, &ctxt.move_data);\n+        let (tcx, mir, move_data) = (self.tcx, self.mir, self.move_data());\n         let stmt = &mir[bb].statements[idx];\n         let loc_map = &move_data.loc_map;\n         let path_map = &move_data.path_map;\n@@ -435,7 +453,7 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n             // here, in dataflow vector\n             zero_to_one(sets.gen_set.words_mut(), *move_index);\n         }\n-        let bits_per_block = self.bits_per_block(ctxt);\n+        let bits_per_block = self.bits_per_block();\n         match stmt.kind {\n             mir::StatementKind::SetDiscriminant { .. } => {\n                 span_bug!(stmt.source_info.span, \"SetDiscriminant should not exist in borrowck\");\n@@ -460,32 +478,30 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n     }\n \n     fn terminator_effect(&self,\n-                         ctxt: &Self::Ctxt,\n                          sets: &mut BlockSets<MoveOutIndex>,\n                          bb: mir::BasicBlock,\n                          statements_len: usize)\n     {\n-        let (mir, move_data) = (self.mir, &ctxt.move_data);\n+        let (mir, move_data) = (self.mir, self.move_data());\n         let term = mir[bb].terminator();\n         let loc_map = &move_data.loc_map;\n         let loc = Location { block: bb, statement_index: statements_len };\n         debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n                term, loc, &loc_map[loc]);\n-        let bits_per_block = self.bits_per_block(ctxt);\n+        let bits_per_block = self.bits_per_block();\n         for move_index in &loc_map[loc] {\n             assert!(move_index.index() < bits_per_block);\n             zero_to_one(sets.gen_set.words_mut(), *move_index);\n         }\n     }\n \n     fn propagate_call_return(&self,\n-                             ctxt: &Self::Ctxt,\n                              in_out: &mut IdxSet<MoveOutIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n                              dest_lval: &mir::Lvalue) {\n-        let move_data = &ctxt.move_data;\n-        let bits_per_block = self.bits_per_block(ctxt);\n+        let move_data = self.move_data();\n+        let bits_per_block = self.bits_per_block();\n \n         let path_map = &move_data.path_map;\n         on_lookup_result_bits(self.tcx,"}, {"sha": "f11cf90834dd900f565c5f420f371b1fe34f6fee", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "modified", "additions": 15, "deletions": 25, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a6fe6c9be10c79d64c988d490519f5cc07e9060d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6fe6c9be10c79d64c988d490519f5cc07e9060d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=a6fe6c9be10c79d64c988d490519f5cc07e9060d", "patch": "@@ -22,7 +22,6 @@ use std::path::PathBuf;\n use std::usize;\n \n use super::MirBorrowckCtxtPreDataflow;\n-use super::MoveDataParamEnv;\n \n pub use self::sanity_check::sanity_check_via_rustc_peek;\n pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n@@ -33,13 +32,13 @@ mod sanity_check;\n mod impls;\n \n pub trait Dataflow<BD: BitDenotation> {\n-    fn dataflow<P>(&mut self, p: P) where P: Fn(&BD::Ctxt, BD::Idx) -> &Debug;\n+    fn dataflow<P>(&mut self, p: P) where P: Fn(&BD, BD::Idx) -> &Debug;\n }\n \n impl<'a, 'tcx: 'a, BD> Dataflow<BD> for MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n-    where BD: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>> + DataflowOperator\n+    where BD: BitDenotation + DataflowOperator\n {\n-    fn dataflow<P>(&mut self, p: P) where P: Fn(&BD::Ctxt, BD::Idx) -> &Debug {\n+    fn dataflow<P>(&mut self, p: P) where P: Fn(&BD, BD::Idx) -> &Debug {\n         self.flow_state.build_sets();\n         self.pre_dataflow_instrumentation(|c,i| p(c,i)).unwrap();\n         self.flow_state.propagate();\n@@ -48,7 +47,7 @@ impl<'a, 'tcx: 'a, BD> Dataflow<BD> for MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n }\n \n struct PropagationContext<'b, 'a: 'b, 'tcx: 'a, O>\n-    where O: 'b + BitDenotation, O::Ctxt: 'a\n+    where O: 'b + BitDenotation\n {\n     builder: &'b mut DataflowAnalysis<'a, 'tcx, O>,\n     changed: bool,\n@@ -79,20 +78,20 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD>\n \n         {\n             let sets = &mut self.flow_state.sets.for_block(mir::START_BLOCK.index());\n-            self.flow_state.operator.start_block_effect(&self.ctxt, sets);\n+            self.flow_state.operator.start_block_effect(sets);\n         }\n \n         for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n             let &mir::BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = data;\n \n             let sets = &mut self.flow_state.sets.for_block(bb.index());\n             for j_stmt in 0..statements.len() {\n-                self.flow_state.operator.statement_effect(&self.ctxt, sets, bb, j_stmt);\n+                self.flow_state.operator.statement_effect(sets, bb, j_stmt);\n             }\n \n             if terminator.is_some() {\n                 let stmts_len = statements.len();\n-                self.flow_state.operator.terminator_effect(&self.ctxt, sets, bb, stmts_len);\n+                self.flow_state.operator.terminator_effect(sets, bb, stmts_len);\n             }\n         }\n     }\n@@ -137,10 +136,10 @@ fn dataflow_path(context: &str, prepost: &str, path: &str) -> PathBuf {\n }\n \n impl<'a, 'tcx: 'a, BD> MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n-    where BD: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>>\n+    where BD: BitDenotation\n {\n     fn pre_dataflow_instrumentation<P>(&self, p: P) -> io::Result<()>\n-        where P: Fn(&BD::Ctxt, BD::Idx) -> &Debug\n+        where P: Fn(&BD, BD::Idx) -> &Debug\n     {\n         if let Some(ref path_str) = self.print_preflow_to {\n             let path = dataflow_path(BD::name(), \"preflow\", path_str);\n@@ -151,7 +150,7 @@ impl<'a, 'tcx: 'a, BD> MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n     }\n \n     fn post_dataflow_instrumentation<P>(&self, p: P) -> io::Result<()>\n-        where P: Fn(&BD::Ctxt, BD::Idx) -> &Debug\n+        where P: Fn(&BD, BD::Idx) -> &Debug\n     {\n         if let Some(ref path_str) = self.print_postflow_to {\n             let path = dataflow_path(BD::name(), \"postflow\", path_str);\n@@ -179,11 +178,10 @@ impl<E:Idx> Bits<E> {\n }\n \n pub struct DataflowAnalysis<'a, 'tcx: 'a, O>\n-    where O: BitDenotation, O::Ctxt: 'a\n+    where O: BitDenotation\n {\n     flow_state: DataflowState<O>,\n     mir: &'a Mir<'tcx>,\n-    ctxt: &'a O::Ctxt,\n }\n \n impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O>\n@@ -295,9 +293,6 @@ pub trait BitDenotation {\n     /// Specifies what index type is used to access the bitvector.\n     type Idx: Idx;\n \n-    /// Specifies what, if any, separate context needs to be supplied for methods below.\n-    type Ctxt;\n-\n     /// A name describing the dataflow analysis that this\n     /// BitDenotation is supporting.  The name should be something\n     /// suitable for plugging in as part of a filename e.g. avoid\n@@ -308,7 +303,7 @@ pub trait BitDenotation {\n     fn name() -> &'static str;\n \n     /// Size of each bitvector allocated for each block in the analysis.\n-    fn bits_per_block(&self, &Self::Ctxt) -> usize;\n+    fn bits_per_block(&self) -> usize;\n \n     /// Mutates the block-sets (the flow sets for the given\n     /// basic block) according to the effects that have been\n@@ -319,7 +314,7 @@ pub trait BitDenotation {\n     /// (Typically this should only modify `sets.on_entry`, since the\n     /// gen and kill sets should reflect the effects of *executing*\n     /// the start block itself.)\n-    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<Self::Idx>);\n+    fn start_block_effect(&self, sets: &mut BlockSets<Self::Idx>);\n \n     /// Mutates the block-sets (the flow sets for the given\n     /// basic block) according to the effects of evaluating statement.\n@@ -332,7 +327,6 @@ pub trait BitDenotation {\n     /// `bb_data` is the sequence of statements identifed by `bb` in\n     /// the MIR.\n     fn statement_effect(&self,\n-                        ctxt: &Self::Ctxt,\n                         sets: &mut BlockSets<Self::Idx>,\n                         bb: mir::BasicBlock,\n                         idx_stmt: usize);\n@@ -348,7 +342,6 @@ pub trait BitDenotation {\n     /// The effects applied here cannot depend on which branch the\n     /// terminator took.\n     fn terminator_effect(&self,\n-                         ctxt: &Self::Ctxt,\n                          sets: &mut BlockSets<Self::Idx>,\n                          bb: mir::BasicBlock,\n                          idx_term: usize);\n@@ -373,7 +366,6 @@ pub trait BitDenotation {\n     /// kill-sets associated with each edge coming out of the basic\n     /// block.\n     fn propagate_call_return(&self,\n-                             ctxt: &Self::Ctxt,\n                              in_out: &mut IdxSet<Self::Idx>,\n                              call_bb: mir::BasicBlock,\n                              dest_bb: mir::BasicBlock,\n@@ -385,9 +377,8 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n {\n     pub fn new(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n-               ctxt: &'a D::Ctxt,\n                denotation: D) -> Self {\n-        let bits_per_block = denotation.bits_per_block(&ctxt);\n+        let bits_per_block = denotation.bits_per_block();\n         let usize_bits = mem::size_of::<usize>() * 8;\n         let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;\n \n@@ -405,7 +396,6 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n         });\n \n         DataflowAnalysis {\n-            ctxt: ctxt,\n             mir: mir,\n             flow_state: DataflowState {\n                 sets: AllSets {\n@@ -482,7 +472,7 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n                     // N.B.: This must be done *last*, after all other\n                     // propagation, as documented in comment above.\n                     self.flow_state.operator.propagate_call_return(\n-                        &self.ctxt, in_out, bb, *dest_bb, dest_lval);\n+                        in_out, bb, *dest_bb, dest_lval);\n                     self.propagate_bits_into_entry_set_for(in_out, changed, dest_bb);\n                 }\n             }"}, {"sha": "ea6ef423c92cebb89f577a6d8055111bc5d83f20", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a6fe6c9be10c79d64c988d490519f5cc07e9060d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6fe6c9be10c79d64c988d490519f5cc07e9060d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=a6fe6c9be10c79d64c988d490519f5cc07e9060d", "patch": "@@ -17,9 +17,9 @@ use rustc::mir::{self, Mir};\n use rustc_data_structures::indexed_vec::Idx;\n \n use super::super::gather_moves::{MovePathIndex, LookupResult};\n-use super::super::MoveDataParamEnv;\n use super::BitDenotation;\n use super::DataflowResults;\n+use super::super::gather_moves::HasMoveData;\n \n /// This function scans `mir` for all calls to the intrinsic\n /// `rustc_peek` that have the expression form `rustc_peek(&expr)`.\n@@ -41,28 +41,26 @@ pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 mir: &Mir<'tcx>,\n                                                 id: ast::NodeId,\n                                                 _attributes: &[ast::Attribute],\n-                                                flow_ctxt: &O::Ctxt,\n                                                 results: &DataflowResults<O>)\n-    where O: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>, Idx=MovePathIndex>\n+    where O: BitDenotation<Idx=MovePathIndex> + HasMoveData<'tcx>\n {\n     debug!(\"sanity_check_via_rustc_peek id: {:?}\", id);\n     // FIXME: this is not DRY. Figure out way to abstract this and\n     // `dataflow::build_sets`. (But note it is doing non-standard\n     // stuff, so such generalization may not be realistic.)\n \n     for bb in mir.basic_blocks().indices() {\n-        each_block(tcx, mir, flow_ctxt, results, bb);\n+        each_block(tcx, mir, results, bb);\n     }\n }\n \n fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            mir: &Mir<'tcx>,\n-                           ctxt: &O::Ctxt,\n                            results: &DataflowResults<O>,\n                            bb: mir::BasicBlock) where\n-    O: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>, Idx=MovePathIndex>\n+    O: BitDenotation<Idx=MovePathIndex> + HasMoveData<'tcx>\n {\n-    let move_data = &ctxt.move_data;\n+    let move_data = results.0.operator.move_data();\n     let mir::BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = mir[bb];\n \n     let (args, span) = match is_rustc_peek(tcx, terminator) {\n@@ -146,7 +144,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // reset GEN and KILL sets before emulating their effect.\n         for e in sets.gen_set.words_mut() { *e = 0; }\n         for e in sets.kill_set.words_mut() { *e = 0; }\n-        results.0.operator.statement_effect(ctxt, &mut sets, bb, j);\n+        results.0.operator.statement_effect(&mut sets, bb, j);\n         sets.on_entry.union(sets.gen_set);\n         sets.on_entry.subtract(sets.kill_set);\n     }"}, {"sha": "c9ce6eca865170cf4907ae798c2d1115baf8d6be", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a6fe6c9be10c79d64c988d490519f5cc07e9060d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6fe6c9be10c79d64c988d490519f5cc07e9060d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=a6fe6c9be10c79d64c988d490519f5cc07e9060d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::gather_moves::{MoveData, MovePathIndex, LookupResult};\n+use super::gather_moves::{HasMoveData, MoveData, MovePathIndex, LookupResult};\n use super::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use super::dataflow::{DataflowResults};\n use super::{drop_flag_effects_for_location, on_all_children_bits};\n@@ -51,11 +51,13 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n                 param_env: param_env\n             };\n             let flow_inits =\n-                super::do_dataflow(tcx, mir, id, &[], &env,\n-                                   MaybeInitializedLvals::new(tcx, mir));\n+                super::do_dataflow(tcx, mir, id, &[],\n+                                   MaybeInitializedLvals::new(tcx, mir, &env),\n+                                   |bd, p| &bd.move_data().move_paths[p]);\n             let flow_uninits =\n-                super::do_dataflow(tcx, mir, id, &[], &env,\n-                                   MaybeUninitializedLvals::new(tcx, mir));\n+                super::do_dataflow(tcx, mir, id, &[],\n+                                   MaybeUninitializedLvals::new(tcx, mir, &env),\n+                                   |bd, p| &bd.move_data().move_paths[p]);\n \n             ElaborateDropsCtxt {\n                 tcx: tcx,"}, {"sha": "2a9acaf58b8f2bf091ccce29eb8aede48a6abb88", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6fe6c9be10c79d64c988d490519f5cc07e9060d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6fe6c9be10c79d64c988d490519f5cc07e9060d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=a6fe6c9be10c79d64c988d490519f5cc07e9060d", "patch": "@@ -120,6 +120,10 @@ pub struct MoveData<'tcx> {\n     pub rev_lookup: MovePathLookup<'tcx>,\n }\n \n+pub trait HasMoveData<'tcx> {\n+    fn move_data(&self) -> &MoveData<'tcx>;\n+}\n+\n #[derive(Debug)]\n pub struct LocationMap<T> {\n     /// Location-indexed (BasicBlock for outer index, index within BB"}, {"sha": "68929cd4e85269c9d22dbd5cbf86db686836219d", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a6fe6c9be10c79d64c988d490519f5cc07e9060d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6fe6c9be10c79d64c988d490519f5cc07e9060d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=a6fe6c9be10c79d64c988d490519f5cc07e9060d", "patch": "@@ -32,7 +32,9 @@ use self::dataflow::{DataflowOperator};\n use self::dataflow::{Dataflow, DataflowAnalysis, DataflowResults};\n use self::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use self::dataflow::{DefinitelyInitializedLvals};\n-use self::gather_moves::{MoveData, MovePathIndex, LookupResult};\n+use self::gather_moves::{HasMoveData, MoveData, MovePathIndex, LookupResult};\n+\n+use std::fmt;\n \n fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<MetaItem> {\n     for attr in attrs {\n@@ -79,20 +81,23 @@ pub fn borrowck_mir(bcx: &mut BorrowckCtxt,\n     let move_data = MoveData::gather_moves(mir, tcx, &param_env);\n     let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n     let flow_inits =\n-        do_dataflow(tcx, mir, id, attributes, &mdpe, MaybeInitializedLvals::new(tcx, mir));\n+        do_dataflow(tcx, mir, id, attributes, MaybeInitializedLvals::new(tcx, mir, &mdpe),\n+                    |bd, i| &bd.move_data().move_paths[i]);\n     let flow_uninits =\n-        do_dataflow(tcx, mir, id, attributes, &mdpe, MaybeUninitializedLvals::new(tcx, mir));\n+        do_dataflow(tcx, mir, id, attributes, MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n+                    |bd, i| &bd.move_data().move_paths[i]);\n     let flow_def_inits =\n-        do_dataflow(tcx, mir, id, attributes, &mdpe, DefinitelyInitializedLvals::new(tcx, mir));\n+        do_dataflow(tcx, mir, id, attributes, DefinitelyInitializedLvals::new(tcx, mir, &mdpe),\n+                    |bd, i| &bd.move_data().move_paths[i]);\n \n     if has_rustc_mir_with(attributes, \"rustc_peek_maybe_init\").is_some() {\n-        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &mdpe, &flow_inits);\n+        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &flow_inits);\n     }\n     if has_rustc_mir_with(attributes, \"rustc_peek_maybe_uninit\").is_some() {\n-        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &mdpe, &flow_uninits);\n+        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &flow_uninits);\n     }\n     if has_rustc_mir_with(attributes, \"rustc_peek_definite_init\").is_some() {\n-        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &mdpe, &flow_def_inits);\n+        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &flow_def_inits);\n     }\n \n     if has_rustc_mir_with(attributes, \"stop_after_dataflow\").is_some() {\n@@ -103,7 +108,7 @@ pub fn borrowck_mir(bcx: &mut BorrowckCtxt,\n         bcx: bcx,\n         mir: mir,\n         node_id: id,\n-        move_data: mdpe.move_data,\n+        move_data: &mdpe.move_data,\n         flow_inits: flow_inits,\n         flow_uninits: flow_uninits,\n     };\n@@ -115,13 +120,15 @@ pub fn borrowck_mir(bcx: &mut BorrowckCtxt,\n     debug!(\"borrowck_mir done\");\n }\n \n-fn do_dataflow<'a, 'tcx, BD>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             mir: &Mir<'tcx>,\n-                             node_id: ast::NodeId,\n-                             attributes: &[ast::Attribute],\n-                             ctxt: &BD::Ctxt,\n-                             bd: BD) -> DataflowResults<BD>\n-    where BD: BitDenotation<Idx=MovePathIndex, Ctxt=MoveDataParamEnv<'tcx>> + DataflowOperator\n+fn do_dataflow<'a, 'tcx, BD, P>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                mir: &Mir<'tcx>,\n+                                node_id: ast::NodeId,\n+                                attributes: &[ast::Attribute],\n+                                bd: BD,\n+                                p: P)\n+                                -> DataflowResults<BD>\n+    where BD: BitDenotation<Idx=MovePathIndex> + DataflowOperator,\n+          P: Fn(&BD, BD::Idx) -> &fmt::Debug\n {\n     let name_found = |sess: &Session, attrs: &[ast::Attribute], name| -> Option<String> {\n         if let Some(item) = has_rustc_mir_with(attrs, name) {\n@@ -146,16 +153,15 @@ fn do_dataflow<'a, 'tcx, BD>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         node_id: node_id,\n         print_preflow_to: print_preflow_to,\n         print_postflow_to: print_postflow_to,\n-        flow_state: DataflowAnalysis::new(tcx, mir, ctxt, bd),\n+        flow_state: DataflowAnalysis::new(tcx, mir, bd),\n     };\n \n-    mbcx.dataflow(|ctxt, i| &ctxt.move_data.move_paths[i]);\n+    mbcx.dataflow(p);\n     mbcx.flow_state.results()\n }\n \n \n-pub struct MirBorrowckCtxtPreDataflow<'a, 'tcx: 'a, BD>\n-    where BD: BitDenotation, BD::Ctxt: 'a\n+pub struct MirBorrowckCtxtPreDataflow<'a, 'tcx: 'a, BD> where BD: BitDenotation\n {\n     node_id: ast::NodeId,\n     flow_state: DataflowAnalysis<'a, 'tcx, BD>,\n@@ -168,7 +174,7 @@ pub struct MirBorrowckCtxt<'b, 'a: 'b, 'tcx: 'a> {\n     bcx: &'b mut BorrowckCtxt<'a, 'tcx>,\n     mir: &'b Mir<'tcx>,\n     node_id: ast::NodeId,\n-    move_data: MoveData<'tcx>,\n+    move_data: &'b MoveData<'tcx>,\n     flow_inits: DataflowResults<MaybeInitializedLvals<'b, 'tcx>>,\n     flow_uninits: DataflowResults<MaybeUninitializedLvals<'b, 'tcx>>\n }"}]}