{"sha": "9e67bc37ff0854fbd2b27d3e5ae73639b490cbad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllNjdiYzM3ZmYwODU0ZmJkMmIyN2QzZTVhZTczNjM5YjQ5MGNiYWQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-07-07T22:43:31Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-07-11T20:15:52Z"}, "message": "extra: simplify the bench stat loop, improve stability somewhat (?)", "tree": {"sha": "dce8d04b86d7086b54b2e0cad7dd56fa4bcd40e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dce8d04b86d7086b54b2e0cad7dd56fa4bcd40e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e67bc37ff0854fbd2b27d3e5ae73639b490cbad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e67bc37ff0854fbd2b27d3e5ae73639b490cbad", "html_url": "https://github.com/rust-lang/rust/commit/9e67bc37ff0854fbd2b27d3e5ae73639b490cbad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e67bc37ff0854fbd2b27d3e5ae73639b490cbad/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbc5bb4c0ae10ef159d1c06a40fdf2b7883083d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc5bb4c0ae10ef159d1c06a40fdf2b7883083d3", "html_url": "https://github.com/rust-lang/rust/commit/fbc5bb4c0ae10ef159d1c06a40fdf2b7883083d3"}], "stats": {"total": 99, "additions": 46, "deletions": 53}, "files": [{"sha": "b6a2deb1663310e31056061a962def35d6f52531", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e67bc37ff0854fbd2b27d3e5ae73639b490cbad/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e67bc37ff0854fbd2b27d3e5ae73639b490cbad/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=9e67bc37ff0854fbd2b27d3e5ae73639b490cbad", "patch": "@@ -100,6 +100,7 @@ pub trait Stats {\n }\n \n /// Extracted collection of all the summary statistics of a sample set.\n+#[deriving(Eq)]\n struct Summary {\n     sum: f64,\n     min: f64,\n@@ -116,7 +117,9 @@ struct Summary {\n }\n \n impl Summary {\n-    fn new(samples: &[f64]) -> Summary {\n+\n+    /// Construct a new summary of a sample set.\n+    pub fn new(samples: &[f64]) -> Summary {\n         Summary {\n             sum: samples.sum(),\n             min: samples.min(),"}, {"sha": "14de7d0c21d0ca8c57f69c5928efe5ac2942328d", "filename": "src/libextra/test.rs", "status": "modified", "additions": 42, "deletions": 52, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9e67bc37ff0854fbd2b27d3e5ae73639b490cbad/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e67bc37ff0854fbd2b27d3e5ae73639b490cbad/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=9e67bc37ff0854fbd2b27d3e5ae73639b490cbad", "patch": "@@ -18,23 +18,20 @@\n \n use getopts;\n use sort;\n+use stats;\n use stats::Stats;\n use term;\n use time::precise_time_ns;\n \n use std::comm::{stream, SharedChan};\n use std::either;\n use std::io;\n-use std::num;\n use std::option;\n-use std::rand::RngUtil;\n-use std::rand;\n use std::result;\n use std::task;\n use std::to_str::ToStr;\n use std::u64;\n use std::uint;\n-use std::vec;\n \n \n // The name of a test. By convention this follows the rules for rust\n@@ -184,7 +181,7 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n \n #[deriving(Eq)]\n pub struct BenchSamples {\n-    ns_iter_samples: ~[f64],\n+    ns_iter_summ: stats::Summary,\n     mb_s: uint\n }\n \n@@ -299,16 +296,15 @@ pub fn run_tests_console(opts: &TestOpts,\n     return success;\n \n     fn fmt_bench_samples(bs: &BenchSamples) -> ~str {\n-        use stats::Stats;\n         if bs.mb_s != 0 {\n             fmt!(\"%u ns/iter (+/- %u) = %u MB/s\",\n-                 bs.ns_iter_samples.median() as uint,\n-                 3 * (bs.ns_iter_samples.median_abs_dev() as uint),\n+                 bs.ns_iter_summ.median as uint,\n+                 (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint,\n                  bs.mb_s)\n         } else {\n             fmt!(\"%u ns/iter (+/- %u)\",\n-                 bs.ns_iter_samples.median() as uint,\n-                 3 * (bs.ns_iter_samples.median_abs_dev() as uint))\n+                 bs.ns_iter_summ.median as uint,\n+                 (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint)\n         }\n     }\n \n@@ -688,54 +684,48 @@ impl BenchHarness {\n         }\n     }\n \n-    // This is a more statistics-driven benchmark algorithm.\n-    // It stops as quickly as 50ms, so long as the statistical\n-    // properties are satisfactory. If those properties are\n-    // not met, it may run as long as the Go algorithm.\n-    pub fn auto_bench(&mut self, f: &fn(&mut BenchHarness)) -> ~[f64] {\n+    // This is a more statistics-driven benchmark algorithm.  It stops as\n+    // quickly as 100ms, so long as the statistical properties are\n+    // satisfactory. If those properties are not met, it may run as long as\n+    // the Go algorithm.\n+    pub fn auto_bench(&mut self, f: &fn(&mut BenchHarness)) -> stats::Summary {\n \n-        let mut rng = rand::rng();\n-        let mut magnitude = 10;\n-        let mut prev_madp = 0.0;\n+        let mut magnitude = 1000;\n \n+        let samples : &mut [f64] = [0.0_f64, ..100];\n         loop {\n-            let n_samples = rng.gen_uint_range(50, 60);\n-            let n_iter = rng.gen_uint_range(magnitude,\n-                                            magnitude * 2);\n+            let loop_start = precise_time_ns();\n \n-            let samples = do vec::from_fn(n_samples) |_| {\n-                self.bench_n(n_iter as u64, |x| f(x));\n-                self.ns_per_iter() as f64\n+            for samples.mut_iter().advance() |p| {\n+                self.bench_n(magnitude as u64, |x| f(x));\n+                *p = self.ns_per_iter() as f64;\n             };\n \n-            // Eliminate outliers\n-            let med = samples.median();\n-            let mad = samples.median_abs_dev();\n-            let samples = do samples.consume_iter().filter |f| {\n-                num::abs(*f - med) <= 3.0 * mad\n-            }.collect::<~[f64]>();\n-\n-            debug!(\"%u samples, median %f, MAD=%f, %u survived filter\",\n-                   n_samples, med as float, mad as float,\n-                   samples.len());\n-\n-            if samples.len() != 0 {\n-                // If we have _any_ cluster of signal...\n-                let curr_madp = samples.median_abs_dev_pct();\n-                if self.ns_elapsed() > 1_000_000 &&\n-                    (curr_madp < 1.0 ||\n-                     num::abs(curr_madp - prev_madp) < 0.1) {\n-                    return samples;\n-                }\n-                prev_madp = curr_madp;\n+            // Clip top 10% and bottom 10% of outliers\n+            stats::winsorize(samples, 10.0);\n+            let summ = stats::Summary::new(samples);\n \n-                if n_iter > 20_000_000 ||\n-                    self.ns_elapsed() > 20_000_000 {\n-                    return samples;\n-                }\n+            debug!(\"%u samples, median %f, MAD=%f, MADP=%f\",\n+                   samples.len(),\n+                   summ.median as float,\n+                   summ.median_abs_dev as float,\n+                   summ.median_abs_dev_pct as float);\n+\n+            let now = precise_time_ns();\n+            let loop_run = now - loop_start;\n+\n+            // Stop early if we have a good signal after a 100ms loop.\n+            if loop_run > 100_000_000 && summ.median_abs_dev_pct < 5.0 {\n+                return summ;\n+            }\n+\n+            // Longest we ever run for is 1s.\n+            if loop_run > 1_000_000_000 {\n+                return summ;\n             }\n \n-            magnitude *= 2;\n+            magnitude *= 3;\n+            magnitude /= 2;\n         }\n     }\n }\n@@ -752,13 +742,13 @@ pub mod bench {\n             bytes: 0\n         };\n \n-        let ns_iter_samples = bs.auto_bench(f);\n+        let ns_iter_summ = bs.auto_bench(f);\n \n-        let iter_s = 1_000_000_000 / (ns_iter_samples.median() as u64);\n+        let iter_s = 1_000_000_000 / (ns_iter_summ.median as u64);\n         let mb_s = (bs.bytes * iter_s) / 1_000_000;\n \n         BenchSamples {\n-            ns_iter_samples: ns_iter_samples,\n+            ns_iter_summ: ns_iter_summ,\n             mb_s: mb_s as uint\n         }\n     }"}]}