{"sha": "4a90e36c85336d1d4b209556c1a9733210bbff19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhOTBlMzZjODUzMzZkMWQ0YjIwOTU1NmMxYTk3MzMyMTBiYmZmMTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-27T13:07:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-27T13:07:46Z"}, "message": "Auto merge of #74775 - RalfJung:miri-alloc-ids, r=oli-obk\n\n Miri: replace canonical_alloc_id mechanism by extern_static_alloc_id\n\nWe only have to call `extern_static_alloc_id` when a `Pointer` is \"imported\" from the `tcx` to the machine, not on each access. Also drop the old hook for TLS handling, it is not needed any more.\n\nThe Miri side of this is at https://github.com/rust-lang/miri/pull/1489.\n\nFixes https://github.com/rust-lang/rust/issues/71194\nr? @oli-obk", "tree": {"sha": "947e4bd945f2cf38eb824417a2b9b574b4bc563c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/947e4bd945f2cf38eb824417a2b9b574b4bc563c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a90e36c85336d1d4b209556c1a9733210bbff19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a90e36c85336d1d4b209556c1a9733210bbff19", "html_url": "https://github.com/rust-lang/rust/commit/4a90e36c85336d1d4b209556c1a9733210bbff19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a90e36c85336d1d4b209556c1a9733210bbff19/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52d2c7ac948d6abdc18eb9e05a53d03ddcaffd98", "url": "https://api.github.com/repos/rust-lang/rust/commits/52d2c7ac948d6abdc18eb9e05a53d03ddcaffd98", "html_url": "https://github.com/rust-lang/rust/commit/52d2c7ac948d6abdc18eb9e05a53d03ddcaffd98"}, {"sha": "b8fd0f6a13e4b898a12f09b3d2d483c5f8e25cff", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8fd0f6a13e4b898a12f09b3d2d483c5f8e25cff", "html_url": "https://github.com/rust-lang/rust/commit/b8fd0f6a13e4b898a12f09b3d2d483c5f8e25cff"}], "stats": {"total": 244, "additions": 122, "deletions": 122}, "files": [{"sha": "1d76bb525ebf4f3a453362f493f5fbaa17032f76", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=4a90e36c85336d1d4b209556c1a9733210bbff19", "patch": "@@ -502,8 +502,6 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n pub enum UnsupportedOpInfo {\n     /// Free-form case. Only for errors that are never caught!\n     Unsupported(String),\n-    /// Accessing an unsupported foreign static.\n-    ReadForeignStatic(DefId),\n     /// Could not find MIR for a function.\n     NoMirFor(DefId),\n     /// Encountered a pointer where we needed raw bytes.\n@@ -515,16 +513,16 @@ pub enum UnsupportedOpInfo {\n     ReadBytesAsPointer,\n     /// Accessing thread local statics\n     ThreadLocalStatic(DefId),\n+    /// Accessing an unsupported extern static.\n+    ReadExternStatic(DefId),\n }\n \n impl fmt::Display for UnsupportedOpInfo {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use UnsupportedOpInfo::*;\n         match self {\n             Unsupported(ref msg) => write!(f, \"{}\", msg),\n-            ReadForeignStatic(did) => {\n-                write!(f, \"cannot read from foreign (extern) static ({:?})\", did)\n-            }\n+            ReadExternStatic(did) => write!(f, \"cannot read from extern static ({:?})\", did),\n             NoMirFor(did) => write!(f, \"no MIR body is available for {:?}\", did),\n             ReadPointerAsBytes => write!(f, \"unable to turn pointer into raw bytes\",),\n             ReadBytesAsPointer => write!(f, \"unable to turn bytes into a pointer\"),"}, {"sha": "e7eeb4b4de4965d266d7babbeb9bcb51d1b1630d", "filename": "src/librustc_mir/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs?ref=4a90e36c85336d1d4b209556c1a9733210bbff19", "patch": "@@ -41,7 +41,7 @@ pub(crate) fn destructure_const<'tcx>(\n ) -> mir::DestructuredConst<'tcx> {\n     trace!(\"destructure_const: {:?}\", val);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n-    let op = ecx.eval_const_to_op(val, None).unwrap();\n+    let op = ecx.const_to_op(val, None).unwrap();\n \n     // We go to `usize` as we cannot allocate anything bigger anyway.\n     let (field_count, variant, down) = match val.ty.kind {"}, {"sha": "3d3d756cffe5a8bcead03508b9a1d1059c48f2b5", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=4a90e36c85336d1d4b209556c1a9733210bbff19", "patch": "@@ -323,14 +323,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     /// Call this to turn untagged \"global\" pointers (obtained via `tcx`) into\n-    /// the *canonical* machine pointer to the allocation.  Must never be used\n-    /// for any other pointers!\n+    /// the machine pointer to the allocation.  Must never be used\n+    /// for any other pointers, nor for TLS statics.\n     ///\n-    /// This represents a *direct* access to that memory, as opposed to access\n-    /// through a pointer that was created by the program.\n+    /// Using the resulting pointer represents a *direct* access to that memory\n+    /// (e.g. by directly using a `static`),\n+    /// as opposed to access through a pointer that was created by the program.\n+    ///\n+    /// This function can fail only if `ptr` points to an `extern static`.\n     #[inline(always)]\n-    pub fn tag_global_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n-        self.memory.tag_global_base_pointer(ptr)\n+    pub fn global_base_pointer(&self, ptr: Pointer) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n+        self.memory.global_base_pointer(ptr)\n     }\n \n     #[inline(always)]\n@@ -845,12 +848,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n         let val = self.tcx.const_eval_global_id(param_env, gid, Some(self.tcx.span))?;\n \n-        // Even though `ecx.const_eval` is called from `eval_const_to_op` we can never have a\n+        // Even though `ecx.const_eval` is called from `const_to_op` we can never have a\n         // recursion deeper than one level, because the `tcx.const_eval` above is guaranteed to not\n-        // return `ConstValue::Unevaluated`, which is the only way that `eval_const_to_op` will call\n+        // return `ConstValue::Unevaluated`, which is the only way that `const_to_op` will call\n         // `ecx.const_eval`.\n         let const_ = ty::Const { val: ty::ConstKind::Value(val), ty };\n-        self.eval_const_to_op(&const_, None)\n+        self.const_to_op(&const_, None)\n     }\n \n     pub fn const_eval_raw("}, {"sha": "634f3c96e6c9f77b4c39afe1f123a1c5e90505e5", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 20, "deletions": 49, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=4a90e36c85336d1d4b209556c1a9733210bbff19", "patch": "@@ -238,45 +238,30 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         Ok(())\n     }\n \n-    /// Called for *every* memory access to determine the real ID of the given allocation.\n-    /// This provides a way for the machine to \"redirect\" certain allocations as it sees fit.\n-    ///\n-    /// This is used by Miri to redirect extern statics to real allocations.\n-    ///\n-    /// This function must be idempotent.\n-    #[inline]\n-    fn canonical_alloc_id(_mem: &Memory<'mir, 'tcx, Self>, id: AllocId) -> AllocId {\n-        id\n+    /// Return the `AllocId` for the given thread-local static in the current thread.\n+    fn thread_local_static_alloc_id(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        def_id: DefId,\n+    ) -> InterpResult<'tcx, AllocId> {\n+        throw_unsup!(ThreadLocalStatic(def_id))\n     }\n \n-    /// Called when converting a `ty::Const` to an operand (in\n-    /// `eval_const_to_op`).\n-    ///\n-    /// Miri uses this callback for creating per thread allocations for thread\n-    /// locals. In Rust, one way of creating a thread local is by marking a\n-    /// static with `#[thread_local]`. On supported platforms this gets\n-    /// translated to a LLVM thread local for which LLVM automatically ensures\n-    /// that each thread gets its own copy. Since LLVM automatically handles\n-    /// thread locals, the Rust compiler just treats thread local statics as\n-    /// regular statics even though accessing a thread local static should be an\n-    /// effectful computation that depends on the current thread. The long term\n-    /// plan is to change MIR to make accesses to thread locals explicit\n-    /// (https://github.com/rust-lang/rust/issues/70685). While the issue 70685\n-    /// is not fixed, our current workaround in Miri is to use this function to\n-    /// make per-thread copies of thread locals. Please note that we cannot make\n-    /// these copies in `canonical_alloc_id` because that is too late: for\n-    /// example, if one created a pointer in thread `t1` to a thread local and\n-    /// sent it to another thread `t2`, resolving the access in\n-    /// `canonical_alloc_id` would result in pointer pointing to `t2`'s thread\n-    /// local and not `t1` as it should.\n-    #[inline]\n-    fn adjust_global_const(\n-        _ecx: &InterpCx<'mir, 'tcx, Self>,\n-        val: mir::interpret::ConstValue<'tcx>,\n-    ) -> InterpResult<'tcx, mir::interpret::ConstValue<'tcx>> {\n-        Ok(val)\n+    /// Return the `AllocId` backing the given `extern static`.\n+    fn extern_static_alloc_id(\n+        mem: &Memory<'mir, 'tcx, Self>,\n+        def_id: DefId,\n+    ) -> InterpResult<'tcx, AllocId> {\n+        // Use the `AllocId` associated with the `DefId`. Any actual *access* will fail.\n+        Ok(mem.tcx.create_static_alloc(def_id))\n     }\n \n+    /// Return the \"base\" tag for the given *global* allocation: the one that is used for direct\n+    /// accesses to this static/const/fn allocation. If `id` is not a global allocation,\n+    /// this will return an unusable tag (i.e., accesses will be UB)!\n+    ///\n+    /// Called on the id returned by `thread_local_static_alloc_id` and `extern_static_alloc_id`, if needed.\n+    fn tag_global_base_pointer(memory_extra: &Self::MemoryExtra, id: AllocId) -> Self::PointerTag;\n+\n     /// Called to initialize the \"extra\" state of an allocation and make the pointers\n     /// it contains (in relocations) tagged.  The way we construct allocations is\n     /// to always first construct it without extra and then add the extra.\n@@ -309,13 +294,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         Ok(())\n     }\n \n-    /// Return the \"base\" tag for the given *global* allocation: the one that is used for direct\n-    /// accesses to this static/const/fn allocation. If `id` is not a global allocation,\n-    /// this will return an unusable tag (i.e., accesses will be UB)!\n-    ///\n-    /// Expects `id` to be already canonical, if needed.\n-    fn tag_global_base_pointer(memory_extra: &Self::MemoryExtra, id: AllocId) -> Self::PointerTag;\n-\n     /// Executes a retagging operation\n     #[inline]\n     fn retag(\n@@ -375,13 +353,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _mem: &Memory<'mir, 'tcx, Self>,\n         _ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx, u64>;\n-\n-    fn thread_local_alloc_id(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        did: DefId,\n-    ) -> InterpResult<'tcx, AllocId> {\n-        throw_unsup!(ThreadLocalStatic(did))\n-    }\n }\n \n // A lot of the flexibility above is just needed for `Miri`, but all \"compile-time\" machines"}, {"sha": "ea7a1c6cffa4067afb044d7ece58ce0620705822", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 51, "deletions": 35, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=4a90e36c85336d1d4b209556c1a9733210bbff19", "patch": "@@ -14,6 +14,7 @@ use std::ptr;\n \n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, Instance, ParamEnv, TyCtxt};\n use rustc_target::abi::{Align, HasDataLayout, Size, TargetDataLayout};\n \n@@ -118,6 +119,17 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     pub tcx: TyCtxt<'tcx>,\n }\n \n+/// Return the `tcx` allocation containing the initial value of the given static\n+pub fn get_static(tcx: TyCtxt<'tcx>, def_id: DefId) -> InterpResult<'tcx, &'tcx Allocation> {\n+    trace!(\"get_static: Need to compute {:?}\", def_id);\n+    let instance = Instance::mono(tcx, def_id);\n+    let gid = GlobalId { instance, promoted: None };\n+    // Use the raw query here to break validation cycles. Later uses of the static\n+    // will call the full query anyway.\n+    let raw_const = tcx.const_eval_raw(ty::ParamEnv::reveal_all().and(gid))?;\n+    Ok(tcx.global_alloc(raw_const.alloc_id).unwrap_memory())\n+}\n+\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n@@ -137,15 +149,36 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n \n     /// Call this to turn untagged \"global\" pointers (obtained via `tcx`) into\n-    /// the *canonical* machine pointer to the allocation.  Must never be used\n-    /// for any other pointers!\n+    /// the machine pointer to the allocation.  Must never be used\n+    /// for any other pointers, nor for TLS statics.\n+    ///\n+    /// Using the resulting pointer represents a *direct* access to that memory\n+    /// (e.g. by directly using a `static`),\n+    /// as opposed to access through a pointer that was created by the program.\n     ///\n-    /// This represents a *direct* access to that memory, as opposed to access\n-    /// through a pointer that was created by the program.\n+    /// This function can fail only if `ptr` points to an `extern static`.\n     #[inline]\n-    pub fn tag_global_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n-        let id = M::canonical_alloc_id(self, ptr.alloc_id);\n-        ptr.with_tag(M::tag_global_base_pointer(&self.extra, id))\n+    pub fn global_base_pointer(\n+        &self,\n+        mut ptr: Pointer,\n+    ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n+        // We need to handle `extern static`.\n+        let ptr = match self.tcx.get_global_alloc(ptr.alloc_id) {\n+            Some(GlobalAlloc::Static(def_id)) if self.tcx.is_thread_local_static(def_id) => {\n+                bug!(\"global memory cannot point to thread-local static\")\n+            }\n+            Some(GlobalAlloc::Static(def_id)) if self.tcx.is_foreign_item(def_id) => {\n+                ptr.alloc_id = M::extern_static_alloc_id(self, def_id)?;\n+                ptr\n+            }\n+            _ => {\n+                // No need to change the `AllocId`.\n+                ptr\n+            }\n+        };\n+        // And we need to get the tag.\n+        let tag = M::tag_global_base_pointer(&self.extra, ptr.alloc_id);\n+        Ok(ptr.with_tag(tag))\n     }\n \n     pub fn create_fn_alloc(\n@@ -162,7 +195,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 id\n             }\n         };\n-        self.tag_global_base_pointer(Pointer::from(id))\n+        // Functions are global allocations, so make sure we get the right base pointer.\n+        // We know this is not an `extern static` so this cannot fail.\n+        self.global_base_pointer(Pointer::from(id)).unwrap()\n     }\n \n     pub fn allocate(\n@@ -195,6 +230,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             M::GLOBAL_KIND.map(MemoryKind::Machine),\n             \"dynamically allocating global memory\"\n         );\n+        // This is a new allocation, not a new global one, so no `global_base_ptr`.\n         let (alloc, tag) = M::init_allocation_extra(&self.extra, id, Cow::Owned(alloc), Some(kind));\n         self.alloc_map.insert(id, (kind, alloc.into_owned()));\n         Pointer::from(id).with_tag(tag)\n@@ -437,6 +473,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(GlobalAlloc::Function(..)) => throw_ub!(DerefFunctionPointer(id)),\n             None => throw_ub!(PointerUseAfterFree(id)),\n             Some(GlobalAlloc::Static(def_id)) => {\n+                assert!(tcx.is_static(def_id));\n                 assert!(!tcx.is_thread_local_static(def_id));\n                 // Notice that every static has two `AllocId` that will resolve to the same\n                 // thing here: one maps to `GlobalAlloc::Static`, this is the \"lazy\" ID,\n@@ -448,29 +485,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // The `GlobalAlloc::Memory` branch here is still reachable though; when a static\n                 // contains a reference to memory that was created during its evaluation (i.e., not\n                 // to another static), those inner references only exist in \"resolved\" form.\n-                //\n-                // Assumes `id` is already canonical.\n                 if tcx.is_foreign_item(def_id) {\n-                    trace!(\"get_global_alloc: foreign item {:?}\", def_id);\n-                    throw_unsup!(ReadForeignStatic(def_id))\n+                    throw_unsup!(ReadExternStatic(def_id));\n                 }\n-                trace!(\"get_global_alloc: Need to compute {:?}\", def_id);\n-                let instance = Instance::mono(tcx, def_id);\n-                let gid = GlobalId { instance, promoted: None };\n-                // Use the raw query here to break validation cycles. Later uses of the static\n-                // will call the full query anyway.\n-                let raw_const =\n-                    tcx.const_eval_raw(ty::ParamEnv::reveal_all().and(gid)).map_err(|err| {\n-                        // no need to report anything, the const_eval call takes care of that\n-                        // for statics\n-                        assert!(tcx.is_static(def_id));\n-                        err\n-                    })?;\n-                // Make sure we use the ID of the resolved memory, not the lazy one!\n-                let id = raw_const.alloc_id;\n-                let allocation = tcx.global_alloc(id).unwrap_memory();\n-\n-                (allocation, Some(def_id))\n+\n+                (get_static(tcx, def_id)?, Some(def_id))\n             }\n         };\n         M::before_access_global(memory_extra, id, alloc, def_id, is_write)?;\n@@ -482,6 +501,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             alloc,\n             M::GLOBAL_KIND.map(MemoryKind::Machine),\n         );\n+        // Sanity check that this is the same pointer we would have gotten via `global_base_pointer`.\n         debug_assert_eq!(tag, M::tag_global_base_pointer(memory_extra, id));\n         Ok(alloc)\n     }\n@@ -492,7 +512,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         &self,\n         id: AllocId,\n     ) -> InterpResult<'tcx, &Allocation<M::PointerTag, M::AllocExtra>> {\n-        let id = M::canonical_alloc_id(self, id);\n         // The error type of the inner closure here is somewhat funny.  We have two\n         // ways of \"erroring\": An actual error, or because we got a reference from\n         // `get_global_alloc` that we can actually use directly without inserting anything anywhere.\n@@ -529,7 +548,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         &mut self,\n         id: AllocId,\n     ) -> InterpResult<'tcx, &mut Allocation<M::PointerTag, M::AllocExtra>> {\n-        let id = M::canonical_alloc_id(self, id);\n         let tcx = self.tcx;\n         let memory_extra = &self.extra;\n         let a = self.alloc_map.get_mut_or(id, || {\n@@ -568,7 +586,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n         liveness: AllocCheck,\n     ) -> InterpResult<'static, (Size, Align)> {\n-        let id = M::canonical_alloc_id(self, id);\n         // # Regular allocations\n         // Don't use `self.get_raw` here as that will\n         // a) cause cycles in case `id` refers to a static\n@@ -621,7 +638,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n     }\n \n-    /// Assumes `id` is already canonical.\n     fn get_fn_alloc(&self, id: AllocId) -> Option<FnVal<'tcx, M::ExtraFnVal>> {\n         trace!(\"reading fn ptr: {}\", id);\n         if let Some(extra) = self.extra_fn_ptr_map.get(&id) {\n@@ -642,8 +658,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         if ptr.offset.bytes() != 0 {\n             throw_ub!(InvalidFunctionPointer(ptr.erase_tag()))\n         }\n-        let id = M::canonical_alloc_id(self, ptr.alloc_id);\n-        self.get_fn_alloc(id).ok_or_else(|| err_ub!(InvalidFunctionPointer(ptr.erase_tag())).into())\n+        self.get_fn_alloc(ptr.alloc_id)\n+            .ok_or_else(|| err_ub!(InvalidFunctionPointer(ptr.erase_tag())).into())\n     }\n \n     pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {"}, {"sha": "5de9b502a37c4b6568bbd3e0df5e486090b29163", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=4a90e36c85336d1d4b209556c1a9733210bbff19", "patch": "@@ -20,7 +20,7 @@ pub use rustc_middle::mir::interpret::*; // have all the `interpret` symbols in\n pub use self::eval_context::{Frame, InterpCx, LocalState, LocalValue, StackPopCleanup};\n pub use self::intern::{intern_const_alloc_recursive, InternKind};\n pub use self::machine::{compile_time_machine, AllocMap, Machine, MayLeak, StackPopJump};\n-pub use self::memory::{AllocCheck, FnVal, Memory, MemoryKind};\n+pub use self::memory::{get_static, AllocCheck, FnVal, Memory, MemoryKind};\n pub use self::operand::{ImmTy, Immediate, OpTy, Operand};\n pub use self::place::{MPlaceTy, MemPlace, MemPlaceMeta, Place, PlaceTy};\n pub use self::validity::RefTracking;"}, {"sha": "49fde4009132dd8a90668718c38548c995d787f4", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=4a90e36c85336d1d4b209556c1a9733210bbff19", "patch": "@@ -517,7 +517,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Constant(ref constant) => {\n                 let val =\n                     self.subst_from_current_frame_and_normalize_erasing_regions(constant.literal);\n-                self.eval_const_to_op(val, layout)?\n+                self.const_to_op(val, layout)?\n             }\n         };\n         trace!(\"{:?}: {:?}\", mir_op, *op);\n@@ -536,14 +536,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     // in patterns via the `const_eval` module\n     /// The `val` and `layout` are assumed to already be in our interpreter\n     /// \"universe\" (param_env).\n-    crate fn eval_const_to_op(\n+    crate fn const_to_op(\n         &self,\n         val: &ty::Const<'tcx>,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let tag_scalar = |scalar| match scalar {\n-            Scalar::Ptr(ptr) => Scalar::Ptr(self.tag_global_base_pointer(ptr)),\n-            Scalar::Raw { data, size } => Scalar::Raw { data, size },\n+        let tag_scalar = |scalar| -> InterpResult<'tcx, _> {\n+            Ok(match scalar {\n+                Scalar::Ptr(ptr) => Scalar::Ptr(self.global_base_pointer(ptr)?),\n+                Scalar::Raw { data, size } => Scalar::Raw { data, size },\n+            })\n         };\n         // Early-return cases.\n         let val_val = match val.val {\n@@ -557,23 +559,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // potentially requiring the current static to be evaluated again. This is not a\n                 // problem here, because we are building an operand which means an actual read is\n                 // happening.\n-                //\n-                // The machine callback `adjust_global_const` below is guaranteed to\n-                // be called for all constants because `const_eval` calls\n-                // `eval_const_to_op` recursively.\n                 return Ok(self.const_eval(GlobalId { instance, promoted }, val.ty)?);\n             }\n             ty::ConstKind::Infer(..)\n             | ty::ConstKind::Bound(..)\n             | ty::ConstKind::Placeholder(..) => {\n-                span_bug!(self.cur_span(), \"eval_const_to_op: Unexpected ConstKind {:?}\", val)\n+                span_bug!(self.cur_span(), \"const_to_op: Unexpected ConstKind {:?}\", val)\n             }\n             ty::ConstKind::Value(val_val) => val_val,\n         };\n-        // This call allows the machine to create fresh allocation ids for\n-        // thread-local statics (see the `adjust_global_const` function\n-        // documentation).\n-        let val_val = M::adjust_global_const(self, val_val)?;\n         // Other cases need layout.\n         let layout =\n             from_known_layout(self.tcx, self.param_env, layout, || self.layout_of(val.ty))?;\n@@ -582,10 +576,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let id = self.tcx.create_memory_alloc(alloc);\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen.\n-                let ptr = self.tag_global_base_pointer(Pointer::new(id, offset));\n+                let ptr = self.global_base_pointer(Pointer::new(id, offset))?;\n                 Operand::Indirect(MemPlace::from_ptr(ptr, layout.align.abi))\n             }\n-            ConstValue::Scalar(x) => Operand::Immediate(tag_scalar(x).into()),\n+            ConstValue::Scalar(x) => Operand::Immediate(tag_scalar(x)?.into()),\n             ConstValue::Slice { data, start, end } => {\n                 // We rely on mutability being set correctly in `data` to prevent writes\n                 // where none should happen.\n@@ -594,7 +588,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Size::from_bytes(start), // offset: `start`\n                 );\n                 Operand::Immediate(Immediate::new_slice(\n-                    self.tag_global_base_pointer(ptr).into(),\n+                    self.global_base_pointer(ptr)?.into(),\n                     u64::try_from(end.checked_sub(start).unwrap()).unwrap(), // len: `end - start`\n                     self,\n                 ))"}, {"sha": "c5d17273225e019f58694f7a5dad63f5d9b02553", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=4a90e36c85336d1d4b209556c1a9733210bbff19", "patch": "@@ -1126,7 +1126,7 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // This must be an allocation in `tcx`\n         let _ = self.tcx.global_alloc(raw.alloc_id);\n-        let ptr = self.tag_global_base_pointer(Pointer::from(raw.alloc_id));\n+        let ptr = self.global_base_pointer(Pointer::from(raw.alloc_id))?;\n         let layout = self.layout_of(raw.ty)?;\n         Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n     }"}, {"sha": "3d1e3eccc6147a8f1b2d5367058b55c8c88a1f44", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=4a90e36c85336d1d4b209556c1a9733210bbff19", "patch": "@@ -141,8 +141,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         use rustc_middle::mir::Rvalue::*;\n         match *rvalue {\n             ThreadLocalRef(did) => {\n-                let id = M::thread_local_alloc_id(self, did)?;\n-                let val = Scalar::Ptr(self.tag_global_base_pointer(id.into()));\n+                let id = M::thread_local_static_alloc_id(self, did)?;\n+                let val = self.global_base_pointer(id.into())?;\n                 self.write_scalar(val, dest)?;\n             }\n "}, {"sha": "a1db06e6aa3defdb9407ae64eab6f0069c7085af", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=4a90e36c85336d1d4b209556c1a9733210bbff19", "patch": "@@ -436,7 +436,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return None;\n         }\n \n-        match self.ecx.eval_const_to_op(c.literal, None) {\n+        match self.ecx.const_to_op(c.literal, None) {\n             Ok(op) => Some(op),\n             Err(error) => {\n                 let tcx = self.ecx.tcx.at(c.span);"}, {"sha": "7d4f8962a192c3da552b31d97d5e375539050094", "filename": "src/test/ui/consts/miri_unleashed/tls.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ftls.rs?ref=4a90e36c85336d1d4b209556c1a9733210bbff19", "patch": "@@ -14,4 +14,11 @@ static TEST_BAD: () = {\n     //~| NOTE cannot access thread local static\n };\n \n+// Make sure we catch taking a reference to thread-local storage.\n+static TEST_BAD_REF: () = {\n+    unsafe { let _val = &A; }\n+    //~^ ERROR could not evaluate static initializer\n+    //~| NOTE cannot access thread local static\n+};\n+\n fn main() {}"}, {"sha": "27d2b2df4d8ae9964e813a55f2058afb6ac1a1df", "filename": "src/test/ui/consts/miri_unleashed/tls.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ftls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4a90e36c85336d1d4b209556c1a9733210bbff19/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ftls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ftls.stderr?ref=4a90e36c85336d1d4b209556c1a9733210bbff19", "patch": "@@ -4,14 +4,25 @@ error[E0080]: could not evaluate static initializer\n LL |     unsafe { let _val = A; }\n    |                         ^ cannot access thread local static (DefId(0:4 ~ tls[317d]::A[0]))\n \n+error[E0080]: could not evaluate static initializer\n+  --> $DIR/tls.rs:19:26\n+   |\n+LL |     unsafe { let _val = &A; }\n+   |                          ^ cannot access thread local static (DefId(0:4 ~ tls[317d]::A[0]))\n+\n warning: skipping const checks\n    |\n help: skipping check that does not even have a feature gate\n   --> $DIR/tls.rs:12:25\n    |\n LL |     unsafe { let _val = A; }\n    |                         ^\n+help: skipping check that does not even have a feature gate\n+  --> $DIR/tls.rs:19:26\n+   |\n+LL |     unsafe { let _val = &A; }\n+   |                          ^\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to 2 previous errors; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0080`."}]}