{"sha": "6621895365ea70bcfaf09bb05e35d64c2f52e4c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MjE4OTUzNjVlYTcwYmNmYWYwOWJiMDVlMzVkNjRjMmY1MmU0YzY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-29T09:38:15Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-29T10:29:06Z"}, "message": "Move retokenize hack to save_analysis", "tree": {"sha": "fc5b322a8efbc56c7049debf4117f7f1b7721bd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc5b322a8efbc56c7049debf4117f7f1b7721bd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6621895365ea70bcfaf09bb05e35d64c2f52e4c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6621895365ea70bcfaf09bb05e35d64c2f52e4c6", "html_url": "https://github.com/rust-lang/rust/commit/6621895365ea70bcfaf09bb05e35d64c2f52e4c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6621895365ea70bcfaf09bb05e35d64c2f52e4c6/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c03c213daf5fe3b52c768b4f145e45d8994d87ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/c03c213daf5fe3b52c768b4f145e45d8994d87ea", "html_url": "https://github.com/rust-lang/rust/commit/c03c213daf5fe3b52c768b4f145e45d8994d87ea"}], "stats": {"total": 124, "additions": 36, "deletions": 88}, "files": [{"sha": "b86caf8b6477cceb072def7c52caafb26ee07680", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6621895365ea70bcfaf09bb05e35d64c2f52e4c6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6621895365ea70bcfaf09bb05e35d64c2f52e4c6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6621895365ea70bcfaf09bb05e35d64c2f52e4c6", "patch": "@@ -3918,8 +3918,8 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n  \"rustc_hir_pretty\",\n+ \"rustc_lexer\",\n  \"rustc_middle\",\n- \"rustc_parse\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"serde_json\","}, {"sha": "fdcabe416731fc22bf851a7aeb9b5d8e20a451a4", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6621895365ea70bcfaf09bb05e35d64c2f52e4c6/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6621895365ea70bcfaf09bb05e35d64c2f52e4c6/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=6621895365ea70bcfaf09bb05e35d64c2f52e4c6", "patch": "@@ -46,19 +46,10 @@ impl<'a> StringReader<'a> {\n         source_file: Lrc<rustc_span::SourceFile>,\n         override_span: Option<Span>,\n     ) -> Self {\n-        // Make sure external source is loaded first, before accessing it.\n-        // While this can't show up during normal parsing, `retokenize` may\n-        // be called with a source file from an external crate.\n-        sess.source_map().ensure_source_file_source_present(Lrc::clone(&source_file));\n-\n-        let src = if let Some(src) = &source_file.src {\n-            Lrc::clone(&src)\n-        } else if let Some(src) = source_file.external_src.borrow().get_source() {\n-            Lrc::clone(&src)\n-        } else {\n+        let src = source_file.src.clone().unwrap_or_else(|| {\n             sess.span_diagnostic\n                 .bug(&format!(\"cannot lex `source_file` without source: {}\", source_file.name));\n-        };\n+        });\n \n         StringReader {\n             sess,\n@@ -70,23 +61,6 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n-    pub fn retokenize(sess: &'a ParseSess, mut span: Span) -> Self {\n-        let begin = sess.source_map().lookup_byte_offset(span.lo());\n-        let end = sess.source_map().lookup_byte_offset(span.hi());\n-\n-        // Make the range zero-length if the span is invalid.\n-        if begin.sf.start_pos != end.sf.start_pos {\n-            span = span.shrink_to_lo();\n-        }\n-\n-        let mut sr = StringReader::new(sess, begin.sf, None);\n-\n-        // Seek the lexer to the right byte range.\n-        sr.end_src_index = sr.src_index(span.hi());\n-\n-        sr\n-    }\n-\n     fn mk_sp(&self, lo: BytePos, hi: BytePos) -> Span {\n         self.override_span.unwrap_or_else(|| Span::with_root_ctxt(lo, hi))\n     }"}, {"sha": "979a8da2a9f682740c96ea0579bd180a0372a2f2", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6621895365ea70bcfaf09bb05e35d64c2f52e4c6/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6621895365ea70bcfaf09bb05e35d64c2f52e4c6/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=6621895365ea70bcfaf09bb05e35d64c2f52e4c6", "patch": "@@ -16,7 +16,7 @@ rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_hir_pretty = { path = \"../librustc_hir_pretty\" }\n-rustc_parse = { path = \"../librustc_parse\" }\n+rustc_lexer = { path = \"../librustc_lexer\" }\n serde_json = \"1\"\n rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }"}, {"sha": "ce484858cbb66e1b74a73a0c3f91d62e34391161", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6621895365ea70bcfaf09bb05e35d64c2f52e4c6/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6621895365ea70bcfaf09bb05e35d64c2f52e4c6/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=6621895365ea70bcfaf09bb05e35d64c2f52e4c6", "patch": "@@ -14,7 +14,7 @@\n //! recording the output.\n \n use rustc_ast as ast;\n-use rustc_ast::{token, walk_list};\n+use rustc_ast::walk_list;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind as HirDefKind, Res};\n@@ -1207,9 +1207,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n \n                 // Otherwise it's a span with wrong macro expansion info, which\n                 // we don't want to track anyway, since it's probably macro-internal `use`\n-                if let Some(sub_span) =\n-                    self.span.sub_span_of_token(item.span, token::BinOp(token::Star))\n-                {\n+                if let Some(sub_span) = self.span.sub_span_of_star(item.span) {\n                     if !self.span.filter_generated(item.span) {\n                         let access = access_from!(self.save_ctxt, item, item.hir_id);\n                         let span = self.span_from_span(sub_span);"}, {"sha": "edcd4925773743270fc2b97e280b6a3e1599e6d4", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 30, "deletions": 54, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6621895365ea70bcfaf09bb05e35d64c2f52e4c6/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6621895365ea70bcfaf09bb05e35d64c2f52e4c6/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=6621895365ea70bcfaf09bb05e35d64c2f52e4c6", "patch": "@@ -1,6 +1,6 @@\n use crate::generated_code;\n-use rustc_ast::token::{self, TokenKind};\n-use rustc_parse::lexer::{self, StringReader};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_lexer::{tokenize, TokenKind};\n use rustc_session::Session;\n use rustc_span::*;\n \n@@ -43,61 +43,37 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n-    pub fn retokenise_span(&self, span: Span) -> StringReader<'a> {\n-        lexer::StringReader::retokenize(&self.sess.parse_sess, span)\n-    }\n-\n-    pub fn sub_span_of_token(&self, span: Span, tok: TokenKind) -> Option<Span> {\n-        let mut toks = self.retokenise_span(span);\n-        loop {\n-            let next = toks.next_token();\n-            if next == token::Eof {\n-                return None;\n-            }\n-            if next == tok {\n-                return Some(next.span);\n-            }\n+    /// Finds the span of `*` token withing the larger `span`.\n+    pub fn sub_span_of_star(&self, mut span: Span) -> Option<Span> {\n+        let begin = self.sess.source_map().lookup_byte_offset(span.lo());\n+        let end = self.sess.source_map().lookup_byte_offset(span.hi());\n+        // Make the range zero-length if the span is invalid.\n+        if begin.sf.start_pos != end.sf.start_pos {\n+            span = span.shrink_to_lo();\n         }\n-    }\n \n-    // // Return the name for a macro definition (identifier after first `!`)\n-    // pub fn span_for_macro_def_name(&self, span: Span) -> Option<Span> {\n-    //     let mut toks = self.retokenise_span(span);\n-    //     loop {\n-    //         let ts = toks.real_token();\n-    //         if ts == token::Eof {\n-    //             return None;\n-    //         }\n-    //         if ts == token::Not {\n-    //             let ts = toks.real_token();\n-    //             if ts.kind.is_ident() {\n-    //                 return Some(ts.sp);\n-    //             } else {\n-    //                 return None;\n-    //             }\n-    //         }\n-    //     }\n-    // }\n+        let sf = Lrc::clone(&begin.sf);\n \n-    // // Return the name for a macro use (identifier before first `!`).\n-    // pub fn span_for_macro_use_name(&self, span:Span) -> Option<Span> {\n-    //     let mut toks = self.retokenise_span(span);\n-    //     let mut prev = toks.real_token();\n-    //     loop {\n-    //         if prev == token::Eof {\n-    //             return None;\n-    //         }\n-    //         let ts = toks.real_token();\n-    //         if ts == token::Not {\n-    //             if prev.kind.is_ident() {\n-    //                 return Some(prev.sp);\n-    //             } else {\n-    //                 return None;\n-    //             }\n-    //         }\n-    //         prev = ts;\n-    //     }\n-    // }\n+        self.sess.source_map().ensure_source_file_source_present(Lrc::clone(&sf));\n+        let src =\n+            sf.src.clone().or_else(|| sf.external_src.borrow().get_source().map(Lrc::clone))?;\n+        let to_index = |pos: BytePos| -> usize { (pos - sf.start_pos).0 as usize };\n+        let text = &src[to_index(span.lo())..to_index(span.hi())];\n+        let start_pos = {\n+            let mut pos = 0;\n+            tokenize(text)\n+                .map(|token| {\n+                    let start = pos;\n+                    pos += token.len;\n+                    (start, token)\n+                })\n+                .find(|(_pos, token)| token.kind == TokenKind::Star)?\n+                .0\n+        };\n+        let lo = span.lo() + BytePos(start_pos as u32);\n+        let hi = lo + BytePos(1);\n+        Some(span.with_lo(lo).with_hi(hi))\n+    }\n \n     /// Return true if the span is generated code, and\n     /// it is not a subspan of the root callsite."}]}