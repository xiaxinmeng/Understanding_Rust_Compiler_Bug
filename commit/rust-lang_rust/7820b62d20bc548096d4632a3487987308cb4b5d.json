{"sha": "7820b62d20bc548096d4632a3487987308cb4b5d", "node_id": "C_kwDOAAsO6NoAKDc4MjBiNjJkMjBiYzU0ODA5NmQ0NjMyYTM0ODc5ODczMDhjYjRiNWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-05T19:35:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-05T19:35:44Z"}, "message": "Auto merge of #105117 - pitaj:debug_asserts, r=the8472\n\nAdd more debug assertions to unsafe functions\n\nrelated to #51713", "tree": {"sha": "13f7ce63409db60a48470368b7f442311adb9e9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13f7ce63409db60a48470368b7f442311adb9e9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7820b62d20bc548096d4632a3487987308cb4b5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7820b62d20bc548096d4632a3487987308cb4b5d", "html_url": "https://github.com/rust-lang/rust/commit/7820b62d20bc548096d4632a3487987308cb4b5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7820b62d20bc548096d4632a3487987308cb4b5d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73c8d2df7b36387553442a815d2b72f7ea5878aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/73c8d2df7b36387553442a815d2b72f7ea5878aa", "html_url": "https://github.com/rust-lang/rust/commit/73c8d2df7b36387553442a815d2b72f7ea5878aa"}, {"sha": "cd35794d5ea6688e77dd17e96556f5de0b410e8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd35794d5ea6688e77dd17e96556f5de0b410e8a", "html_url": "https://github.com/rust-lang/rust/commit/cd35794d5ea6688e77dd17e96556f5de0b410e8a"}], "stats": {"total": 85, "additions": 50, "deletions": 35}, "files": [{"sha": "f0e5ea53d7d7002a1a5e8c5480cefd8aac2702dc", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7820b62d20bc548096d4632a3487987308cb4b5d/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7820b62d20bc548096d4632a3487987308cb4b5d/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=7820b62d20bc548096d4632a3487987308cb4b5d", "patch": "@@ -371,12 +371,11 @@ unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n-        let this = ops::Range { start: self.start, end: self.end };\n+        let this = ops::Range { ..self };\n         // SAFETY: the caller guarantees that `slice` is not dangling, so it\n         // cannot be longer than `isize::MAX`. They also guarantee that\n         // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n         // so the call to `add` is safe.\n-\n         unsafe {\n             assert_unsafe_precondition!(\n                 \"slice::get_unchecked requires that the range is within the slice\",\n@@ -389,7 +388,7 @@ unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n-        let this = ops::Range { start: self.start, end: self.end };\n+        let this = ops::Range { ..self };\n         // SAFETY: see comments for `get_unchecked` above.\n         unsafe {\n             assert_unsafe_precondition!("}, {"sha": "d319b2bc37fddfd6ee2c78fb900e5dc3c07206c3", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7820b62d20bc548096d4632a3487987308cb4b5d/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7820b62d20bc548096d4632a3487987308cb4b5d/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=7820b62d20bc548096d4632a3487987308cb4b5d", "patch": "@@ -1695,7 +1695,13 @@ impl<T> [T] {\n         let ptr = self.as_ptr();\n \n         // SAFETY: Caller has to check that `0 <= mid <= self.len()`\n-        unsafe { (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), len - mid)) }\n+        unsafe {\n+            assert_unsafe_precondition!(\n+                \"slice::split_at_unchecked requires the index to be within the slice\",\n+                (mid: usize, len: usize) => mid <= len\n+            );\n+            (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), len - mid))\n+        }\n     }\n \n     /// Divides one mutable slice into two at an index, without doing bounds checking."}, {"sha": "41c097b55eefb343c8fdea99264972b57af5af9e", "filename": "library/core/src/str/traits.rs", "status": "modified", "additions": 41, "deletions": 31, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7820b62d20bc548096d4632a3487987308cb4b5d/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7820b62d20bc548096d4632a3487987308cb4b5d/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs?ref=7820b62d20bc548096d4632a3487987308cb4b5d", "patch": "@@ -1,6 +1,7 @@\n //! Trait implementations for `str`.\n \n use crate::cmp::Ordering;\n+use crate::intrinsics::assert_unsafe_precondition;\n use crate::ops;\n use crate::ptr;\n use crate::slice::SliceIndex;\n@@ -194,15 +195,37 @@ unsafe impl const SliceIndex<str> for ops::Range<usize> {\n         let slice = slice as *const [u8];\n         // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n         // which satisfies all the conditions for `add`.\n-        let ptr = unsafe { slice.as_ptr().add(self.start) };\n+        let ptr = unsafe {\n+            let this = ops::Range { ..self };\n+            assert_unsafe_precondition!(\n+                \"str::get_unchecked requires that the range is within the string slice\",\n+                (this: ops::Range<usize>, slice: *const [u8]) =>\n+                // We'd like to check that the bounds are on char boundaries,\n+                // but there's not really a way to do so without reading\n+                // behind the pointer, which has aliasing implications.\n+                // It's also not possible to move this check up to\n+                // `str::get_unchecked` without adding a special function\n+                // to `SliceIndex` just for this.\n+                this.end >= this.start && this.end <= slice.len()\n+            );\n+            slice.as_ptr().add(self.start)\n+        };\n         let len = self.end - self.start;\n         ptr::slice_from_raw_parts(ptr, len) as *const str\n     }\n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n         let slice = slice as *mut [u8];\n         // SAFETY: see comments for `get_unchecked`.\n-        let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n+        let ptr = unsafe {\n+            let this = ops::Range { ..self };\n+            assert_unsafe_precondition!(\n+                \"str::get_unchecked_mut requires that the range is within the string slice\",\n+                (this: ops::Range<usize>, slice: *mut [u8]) =>\n+                this.end >= this.start && this.end <= slice.len()\n+            );\n+            slice.as_mut_ptr().add(self.start)\n+        };\n         let len = self.end - self.start;\n         ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n     }\n@@ -272,15 +295,13 @@ unsafe impl const SliceIndex<str> for ops::RangeTo<usize> {\n     }\n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n-        let slice = slice as *const [u8];\n-        let ptr = slice.as_ptr();\n-        ptr::slice_from_raw_parts(ptr, self.end) as *const str\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (0..self.end).get_unchecked(slice) }\n     }\n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n-        let slice = slice as *mut [u8];\n-        let ptr = slice.as_mut_ptr();\n-        ptr::slice_from_raw_parts_mut(ptr, self.end) as *mut str\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (0..self.end).get_unchecked_mut(slice) }\n     }\n     #[inline]\n     fn index(self, slice: &str) -> &Self::Output {\n@@ -343,20 +364,15 @@ unsafe impl const SliceIndex<str> for ops::RangeFrom<usize> {\n     }\n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n-        let slice = slice as *const [u8];\n-        // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n-        // which satisfies all the conditions for `add`.\n-        let ptr = unsafe { slice.as_ptr().add(self.start) };\n-        let len = slice.len() - self.start;\n-        ptr::slice_from_raw_parts(ptr, len) as *const str\n+        let len = (slice as *const [u8]).len();\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (self.start..len).get_unchecked(slice) }\n     }\n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n-        let slice = slice as *mut [u8];\n-        // SAFETY: identical to `get_unchecked`.\n-        let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n-        let len = slice.len() - self.start;\n-        ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n+        let len = (slice as *mut [u8]).len();\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (self.start..len).get_unchecked_mut(slice) }\n     }\n     #[inline]\n     fn index(self, slice: &str) -> &Self::Output {\n@@ -452,35 +468,29 @@ unsafe impl const SliceIndex<str> for ops::RangeToInclusive<usize> {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {\n-        if self.end == usize::MAX { None } else { (..self.end + 1).get(slice) }\n+        (0..=self.end).get(slice)\n     }\n     #[inline]\n     fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-        if self.end == usize::MAX { None } else { (..self.end + 1).get_mut(slice) }\n+        (0..=self.end).get_mut(slice)\n     }\n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n         // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n-        unsafe { (..self.end + 1).get_unchecked(slice) }\n+        unsafe { (0..=self.end).get_unchecked(slice) }\n     }\n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n         // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { (..self.end + 1).get_unchecked_mut(slice) }\n+        unsafe { (0..=self.end).get_unchecked_mut(slice) }\n     }\n     #[inline]\n     fn index(self, slice: &str) -> &Self::Output {\n-        if self.end == usize::MAX {\n-            str_index_overflow_fail();\n-        }\n-        (..self.end + 1).index(slice)\n+        (0..=self.end).index(slice)\n     }\n     #[inline]\n     fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-        if self.end == usize::MAX {\n-            str_index_overflow_fail();\n-        }\n-        (..self.end + 1).index_mut(slice)\n+        (0..=self.end).index_mut(slice)\n     }\n }\n "}]}